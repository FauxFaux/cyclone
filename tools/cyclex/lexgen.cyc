
#include "core.h"
#include "list.h"
#include "dict.h"
#include "set.h"

#include "syntax.h"

#define LEXGEN_CYC
#include "lexgen.h"

using Core;
using List;
using Dict;
using Set;
using Syntax;

namespace Lexgen;

// Deep abstract for regular expressions
static tunion Regexp {
  Empty;
  Chars(int);
  Action(int);
  Seq(tunion Regexp, tunion Regexp);
  Alt(tunion Regexp, tunion Regexp);
  Star(tunion Regexp);
};
typedef tunion Regexp regexp_t;

static struct Lexer_entry {
  string_t                   name;
  regexp_t                   regexp;
  list_t<$(int,location_t)@> actions;
};
typedef struct Lexer_entry @ lexer_entry_t;

// From shallow to deep syntax
static list_t<list_t<int>>          chars         = null;
static int                      chars_count   = 0;
static list_t<$(int,location_t)@> actions       = null;
static int                      actions_count = 0;

static regexp_t encode_regexp(regular_expression_t r) {
  switch (r) {
  case Epsilon:            return Empty;
  case &Characters(cl): 
    chars = new List(cl,chars); return new Chars(chars_count++);
  case &Sequence(r1,r2):    
    return new Seq(encode_regexp(r1), encode_regexp(r2));
  case &Alternative(r1,r2): 
    return new Alt(encode_regexp(r1), encode_regexp(r2));
  case &Repetition(r1):     
    return new Star(encode_regexp(r1));
  }
}

static regexp_t encode_casedef(list_t<acase_t> casedef) {
  regexp_t ans = Empty;
  for(; casedef != null; casedef = casedef->tl) {
    let &$(expr,act) = casedef->hd;
    actions = new List(new $(actions_count, act), actions);
    ans = new Alt(ans, new Seq(encode_regexp(expr), 
                               new Action(actions_count)));
    ++actions_count;
  }
  return ans;
}

static 
$(list_t<int>?, list_t<lexer_entry_t>)@ encode_lexdef(lexer_definition_t def) {
  chars       = null;
  chars_count = 0;
  list_t<lexer_entry_t> entry_list_rev = null;
  for(let entries = def->entrypoints; entries!=null; entries=entries->tl) {
    let &$(entry_name, casedef) = entries->hd;
    actions       = null;
    actions_count = 0;
    let re = encode_casedef(casedef); // mutates actions
    entry_list_rev = new List(new Lexer_entry(entry_name, re, rev(actions)),
                              entry_list_rev);
  }
  list_t<int> ?chr = to_array(rev(chars));
  chars   = null;
  actions = null;
  return new $(chr, imp_rev(entry_list_rev));
}

// generate an NFA from a regular expression (dragon book, chapter 3)

static tunion transition { OnChars(int); ToAction(int); };
typedef tunion transition transition_t;

static int transition_cmp(transition_t t1, transition_t t2) {
  switch ($(t1,t2)) {
  case $(&OnChars(_),   &ToAction(_)):  return 1;
  case $(&ToAction(_),  &OnChars(_)):   return -1;
  case $(&OnChars(i1),  &OnChars(i2)):  return i1-i2;
  case $(&ToAction(i1), &ToAction(i2)): return i1-i2;  
  }
}

static bool nullable(regexp_t r) {
  switch (r) {
  case Empty:      return true;
  case &Chars(_):   return false;
  case &Action(_):  return false;
  case &Seq(r1,r2): return nullable(r1) && nullable(r2);
  case &Alt(r1,r2): return nullable(r1) || nullable(r2);
  case &Star(_):    return true;
  }
}

static set_t<transition_t> firstpos(regexp_t r) {
  switch (r) {
  case Empty:       return Set::empty(transition_cmp);
  case &Chars(pos):  return Set::insert(Set::empty(transition_cmp),new OnChars(pos));
  case &Action(act): return Set::insert(Set::empty(transition_cmp),new ToAction(act));
  case &Seq(r1,r2):  if(nullable(r1)) 
                      return Set::union_two(firstpos(r1),firstpos(r2));
                    else
		      return firstpos(r1);
  case &Alt(r1,r2):  return Set::union_two(firstpos(r1),firstpos(r2));
  case &Star(r1):    return firstpos(r1);
  }
}

static set_t<transition_t> lastpos(regexp_t r) {
  switch (r) {
  case Empty:       return Set::empty(transition_cmp);
  case &Chars(pos):  return Set::insert(Set::empty(transition_cmp),new OnChars(pos));
  case &Action(act): return Set::insert(Set::empty(transition_cmp),new ToAction(act));
  case &Seq(r1,r2):  if(nullable(r2)) 
                      return Set::union_two(lastpos(r1),lastpos(r2));
                    else
		      return lastpos(r2);
  case &Alt(r1,r2):  return Set::union_two(lastpos(r1),lastpos(r2));
  case &Star(r1):    return lastpos(r1);
  }
}

static 
void fill_pos($(set_t<transition_t> ?, set_t<transition_t>)@env, transition_t t) {
  let &$(v, first) = env;
  switch (t) {
  case &OnChars(pos): v[pos] = Set::union_two(v[pos], first); break;
  case &ToAction(_):  break;
  }
}

static void fill_it(regexp_t r, set_t<transition_t> ?v) {
  switch (r) {
  case &Seq(r1,r2): 
    fill_it(r1,v);
    fill_it(r2,v);
    Set::iter_c(fill_pos, new $(v,firstpos(r2)), lastpos(r1));
    break;
  case &Alt(r1,r2):
    fill_it(r1,v);
    fill_it(r2,v);
    break;
  case &Star(r1):
    fill_it(r1,v);
    Set::iter_c(fill_pos, new $(v,firstpos(r1)), lastpos(r1));
    break;
  default:
    break;
  }
}

static set_t<transition_t> ?followpos(int sz, list_t<lexer_entry_t> entry_list) {
  set_t<transition_t> ?v = new {for i < sz : Set::empty(transition_cmp)};
  for(; entry_list != null; entry_list = entry_list->tl) 
    fill_it(entry_list->hd->regexp, v);
  return v;
}

// Ocaml uses MAX_INT, but this should be large enough
#define NO_ACTION (1 << 29)

static $(int,list_t<int>)@ split_trans(transition_t      trans, 
				     $(int,list_t<int>)@ act_pos_set) {
  let &$(act, pos_set) = act_pos_set;
  switch (trans) {
  case &OnChars(pos):   
    list_t<int> l = new List(pos,pos_set); return new $(act, l);
  case &ToAction(act1): 
    return (act1 < act) ? (new $(act1,pos_set)) : act_pos_set;
  }
}

static $(int, list_t<int>)@ split_trans_set(set_t<transition_t> trans_set) {
  return Set::fold(split_trans, trans_set, new $(NO_ACTION,null));
}

// The Ocaml I'm porting from isn't functional (re-entrant) here either:
// (It doesn't look too hard to pass the state around functionally.)
static opt_t<dict_t<set_t<transition_t>, int>> state_map      = null;
static list_t<$(set_t<transition_t>,int)@>     todo           = null;
static int                                 next_state_num = 0;

static void reset_state_mem() {
  state_map      = new Opt(Dict::empty(Set::compare));
  todo           = null;
  next_state_num = 0;
}

static int get_state(set_t<transition_t> st) {
  try return Dict::lookup(state_map->v, st);
  catch {
  case Dict::Absent:
    state_map->v = Dict::insert(state_map->v, st, next_state_num);
    todo         = new List(new $(st, next_state_num), todo);
    return next_state_num++; // post-increment!
  }
}

static automata_move_t goto_state(set_t<transition_t> st) {
  if(Set::is_empty(st))
    return Backtrack;
  else
    return new Goto(get_state(st));
}

static automata_move_t ?transition_from(list_t<int>         ?chars,
					set_t<transition_t> ?follow,
					list_t<int>         pos_set) {
  set_t<transition_t> ?tr    = new {for i < 257 : Set::empty(transition_cmp)};
  automata_move_t   ?shift = new {for i < 257 : (automata_move_t)Backtrack};
  for(; pos_set != null; pos_set = pos_set->tl) {
    int pos = pos_set->hd;
    for(list_t<int> cs_pos = chars[pos]; cs_pos != null; cs_pos = cs_pos->tl) {
      int c = cs_pos->hd;
      tr[c] = Set::union_two(tr[c], follow[pos]);
    }
  }
  for(int i=0; i <= 256; ++i)
    shift[i] = goto_state(tr[i]);
  return shift;
}

static automata_t translate_state(list_t<int>         ?chars, 
				  set_t<transition_t> ?follow, 
				  set_t<transition_t> state) {
  switch (split_trans_set(state)) {
  case &$(n,null): return new Perform(n);
  case &$(n,ps):   return new Shift((n == NO_ACTION ? 
                                     ((automata_trans_t)No_remember) : 
                                     (new Remember(n))),
                                    transition_from(chars, follow, ps));
  }
}

$(list_t<automata_entry_t>,automata_t?)@ 
make_dfa(Syntax::lexer_definition_t lexdef) {
  let &$(chars, entry_list) = encode_lexdef(lexdef);
  set_t<transition_t> ?follow = followpos(chars.size, entry_list);
  reset_state_mem();
  list_t<automata_entry_t> initial_states = null;
  for(; entry_list != null; entry_list = entry_list->tl) {
    let le = entry_list->hd;
    initial_states = new List(new Automata_entry{le->name,
			 		   get_state(firstpos(le->regexp)),
				 	   le->actions
                                          },
			   initial_states);
  }
  initial_states = List::imp_rev(initial_states);
  list_t<$(automata_t,int)@> states = null;
  while(todo != null) {
    let &$(st,i) = todo->hd;
    todo = todo->tl;
    states = new List(new $(translate_state(chars, follow, st), i), states);
  }
  states = List::imp_rev(states);
  let actions = new {for i < next_state_num : (automata_t)(new Perform(0))};
  for(; states != null; states = states->tl) {
    let &$(act,i) = states->hd;
    actions[i] = act;
  }
  reset_state_mem();
  return new $(initial_states, actions);
}
