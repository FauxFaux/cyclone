#line 1 "lexer.cyl"
 

// Port of ocamllex to Cyclone, with enormous debt to INRIA:
/* 
(***********************************************************************)
(*                                                                     *)
(*                           Objective Caml                            *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *) 
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)
*/

  // FIX: We do not have the luxury of tail-call optimization but we act
  // as though we do! 

#include "core.h"
#include "string.h"
#include "lexing.h"

#include "syntax.h"
#include "parser.h"

using Core;
using Lexing;
using Parser;

int line_num       = 1;
int line_start_pos = 0;

void yyerror(string s) {
  fprintf(cyc_stderr, "%s, line:%d", s, line_num);
  throw Parser_error(s);
}

namespace Lexer {

xenum exn { Lexical_error(string,int,int); };

static string                  token_string = (string)"";
static Char                    token_char   = (Char)'D';
static struct Syntax::Location dummy_loc    = {0,0,0,0};
static Syntax::location_t      token_action = &dummy_loc;

static int brace_depth   = 0;
static int comment_depth = 0;

static string string_buff  = (string)"01234567012345670123456701234567";
static int    string_index = 0;

typedef int lexfun_t <`a>(Lexing::Lexbuf<`a>);

#define SHRINK_THRESHOLD 16384
void reset_string_buffer() {
  if(string_buff.size > SHRINK_THRESHOLD)
    string_buff = (string)"01234567012345670123456701234567";
  string_index = 0;
}

void store_string_char(char c) {
  if(string_index >= string_buff.size) {
    string new_buff = new_string(string_buff.size*2);
    String::strncpy(string_buff, 0, new_buff, 0, string_buff.size);
    string_buff = new_buff;
  }
  string_buff[string_index++] = c;
}

string get_stored_string() {
  return String::substring(string_buff,0,string_index);
}

char char_for_backslash(char c) {
  switch (c) {
  case 'n': return '\n';
  case 't': return '\t';
  case 'b': return '\b';
  case 'r': return '\r';
  default:  return c;
  }
}

// FIX: Maybe the Cyclone version should interpret things in octal instead
//      of decimal.  If so, change this code and all existing lexers.
char char_for_decimal_code<`a>(Lexbuf<`a> lbuf, int i) {
  return (char)(100 * (((int) lexeme_char(lbuf,i))   - 48) +
		10  * (((int) lexeme_char(lbuf,i+1)) - 48) +
		      (((int) lexeme_char(lbuf,i+2)) - 48));
}

static int handle_lexical_error<`a>(lexfun_t fn, Lexbuf<`a>lbuf) {
  int line = line_num;
  int column = lexeme_start(lbuf) - line_start_pos;
  try return fn(lbuf);
  catch { case Lexical_error(msg,_,_): throw Lexical_error(msg,line,column); }
}

// Forward declarations of lexing functions
extern lexfun_t lexmain, action, strng, comment;

} // namespace Lexer

// for parser -- must not be prefixed 
int yylex() {
  int ans = Lexer::lexmain(lbuf->v);
  switch (ans) {
  case TIDENT:  yylval = String_tok(Lexer::token_string);   break;
  case TSTRING: yylval = String_tok(Lexer::token_string);   break;
  case TCHAR:   yylval = Char_tok(Lexer::token_char);       break;
  case TACTION: yylval = Location_tok(Lexer::token_action); break;
  default: break;
  }
  return ans;
}

namespace Lexer;

using Lexing {

struct lex_tables *lt = null;
int lbase[?] = {0,10,4,12,-10,-9,-3,53,1,8,-8,-1,-2,13,-4,98,14,108,118,16,-7,-6,-5,-6,-1,167,172,24,-3,177,187,235,-9,-3,33,16,-1,-2,21,245,23,198,262,25,293,-23,174,-2,-5,34,-18,-19,-15,-17,-21,85,-10,-16,324,-13,-14,-20,-12,-9,-11,-22,453,89,537,90,296,399,91,179};
int lbacktrk[?] = {-1,-1,-1,-1,-1,-1,-1,9,9,9,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,1,-1,-1,-1,9,-1,-1,10,10,-1,-1,-1,-1,-1,-1,-1,-1,9,-1,0,-1,-1,22,-1,-1,-1,-1,-1,22,-1,-1,3,-1,-1,-1,-1,-1,-1,-1,3,-1,-1,-1,-1,-1,-1,0};
int ldefault[?] = {45,31,20,4,0,0,0,13,-1,-1,0,0,0,-1,0,-1,-1,-1,-1,-1,0,0,0,0,0,-1,-1,-1,0,-1,-1,44,0,0,38,-1,0,0,-1,-1,-1,-1,-1,-1,44,0,-1,0,0,67,0,0,0,0,0,-1,0,0,-1,0,0,0,0,0,0,0,-1,-1,-1,-1,-1,-1,-1,-1};
int ltrans[?] = {0,0,0,0,0,0,0,0,0,46,47,0,46,46,23,0,0,0,0,0,32,0,5,0,0,0,0,0,0,0,0,0,46,27,48,0,27,27,24,49,50,51,52,53,33,54,6,55,12,34,11,7,22,21,8,20,27,35,20,9,14,56,22,57,21,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,59,14,60,61,62,25,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,63,64,39,68,28,21,20,10,0,0,36,0,37,0,16,0,0,0,0,0,0,0,15,17,17,17,17,17,17,17,17,17,17,18,18,18,18,18,18,18,18,18,18,19,19,19,19,19,19,19,19,19,19,26,27,0,26,26,26,27,73,26,26,73,73,73,0,16,73,73,0,0,0,16,0,0,26,0,28,0,0,26,0,73,0,16,0,0,73,16,0,16,29,29,29,29,29,29,29,29,29,29,30,30,30,30,30,30,30,30,30,30,14,14,14,14,14,14,14,14,14,14,-1,42,42,42,42,42,42,42,42,42,42,65,0,0,28,22,0,0,0,0,28,10,0,10,-1,0,0,0,0,-1,0,0,28,0,0,0,28,-1,28,40,0,0,0,0,-1,-1,0,0,41,41,41,41,41,41,41,41,41,41,-1,0,0,0,0,0,-1,43,43,43,43,43,43,43,43,43,43,0,0,0,0,0,0,0,-1,0,0,0,0,-1,0,0,0,0,40,0,0,-1,0,0,40,71,71,71,71,71,71,71,71,71,71,0,40,0,0,-1,40,-1,40,0,66,0,0,0,0,0,0,0,0,66,66,66,66,66,66,66,66,66,66,0,0,0,0,0,0,0,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,0,-1,0,-1,66,0,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,72,72,72,72,72,72,72,72,72,72,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,66,0,0,0,0,0,0,0,0,66,66,66,66,66,66,66,66,66,66,0,0,0,0,0,0,0,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,0,0,0,0,66,-1,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,69,0,0,0,0,0,0,0,0,70,70,70,70,70,70,70,70,70,70,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,69,0,0,0,0,0,69,0,0,0,0,0,0,0,0,0,0,0,69,0,0,0,69,0,69,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
int lcheck[?] = {-1,-1,-1,-1,-1,-1,-1,-1,-1,0,0,-1,0,0,2,-1,-1,-1,-1,-1,1,-1,3,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,27,0,-1,27,27,2,0,0,0,0,0,1,0,3,0,8,1,9,3,13,16,3,19,27,1,35,3,38,0,40,0,43,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,34,49,55,67,69,72,-1,-1,1,-1,1,-1,15,-1,-1,-1,-1,-1,-1,-1,7,15,15,15,15,15,15,15,15,15,15,17,17,17,17,17,17,17,17,17,17,18,18,18,18,18,18,18,18,18,18,25,25,-1,25,25,26,26,46,26,26,46,46,73,-1,15,73,73,-1,-1,-1,15,-1,-1,25,-1,25,-1,-1,26,-1,46,-1,15,-1,-1,73,15,-1,15,25,25,25,25,25,25,25,25,25,25,29,29,29,29,29,29,29,29,29,29,30,30,30,30,30,30,30,30,30,30,31,41,41,41,41,41,41,41,41,41,41,0,-1,-1,25,2,-1,-1,-1,-1,25,1,-1,3,31,-1,-1,-1,-1,31,-1,-1,25,-1,-1,-1,25,31,25,39,-1,-1,-1,-1,34,49,-1,-1,39,39,39,39,39,39,39,39,39,39,44,-1,-1,-1,-1,-1,7,42,42,42,42,42,42,42,42,42,42,-1,-1,-1,-1,-1,-1,-1,44,-1,-1,-1,-1,44,-1,-1,-1,-1,39,-1,-1,44,-1,-1,39,70,70,70,70,70,70,70,70,70,70,-1,39,-1,-1,31,39,31,39,-1,58,-1,-1,-1,-1,-1,-1,-1,-1,58,58,58,58,58,58,58,58,58,58,-1,-1,-1,-1,-1,-1,-1,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,-1,44,-1,44,58,-1,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,71,71,71,71,71,71,71,71,71,71,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,31,66,-1,-1,-1,-1,-1,-1,-1,-1,66,66,66,66,66,66,66,66,66,66,-1,-1,-1,-1,-1,-1,-1,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,-1,-1,-1,-1,66,44,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,68,-1,-1,-1,-1,-1,-1,-1,-1,68,68,68,68,68,68,68,68,68,68,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,68,-1,-1,-1,-1,-1,68,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,68,-1,-1,-1,68,-1,68,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1};
int lexmain_rec<`a>(Lexbuf<`a> lexbuf, int lexstate) {
  if (lt == null) lt = &lex_tables(lbase, lbacktrk, ldefault, ltrans, lcheck);
  lexstate = lex_engine((LexTables)lt,lexstate,lexbuf);
  switch (lexstate) {

case 0: 
#line 125 "lexer.cyl"
                                return lexmain(lexbuf); 
case 1: 
#line 126 "lexer.cyl"
           line_start_pos = lexeme_end(lexbuf);
           ++line_num;
           return lexmain(lexbuf); 
case 2: 
#line 129 "lexer.cyl"
         comment_depth = 1;
         handle_lexical_error(comment<>,lexbuf); 
         return lexmain(lexbuf); 
case 3: 
#line 133 "lexer.cyl"
    string s = lexeme(lexbuf);
    if     (String::strcmp(s,"rule")  == 0) return TRULE;
    else if(String::strcmp(s,"parse") == 0) return TPARSE;
    else if(String::strcmp(s,"and")   == 0) return TAND;
    else if(String::strcmp(s,"eof")   == 0) return TEOF;
    else if(String::strcmp(s,"let")   == 0) return TLET;
    else { token_string = s; return TIDENT; }
  
case 4: 
#line 141 "lexer.cyl"
        reset_string_buffer();
        handle_lexical_error(strng<>, lexbuf);
	token_string = get_stored_string();
	return TSTRING;
      
case 5: 
#line 147 "lexer.cyl"
      token_char = (Char)lexeme_char(lexbuf,1); 
      return TCHAR; 
case 6: 
#line 150 "lexer.cyl"
      token_char = (Char)char_for_backslash(lexeme_char(lexbuf,2)); 
      return TCHAR; 
case 7: 
#line 153 "lexer.cyl"
    /* FIX: change to octal */
      token_char = (Char)char_for_decimal_code(lexbuf,2);
      return TCHAR; 
case 8: 
#line 157 "lexer.cyl"
      
     int n1 = lexeme_end(lexbuf);
     int l1 = line_num;
     int s1 = line_start_pos;
     brace_depth = 1;
     int n2 = handle_lexical_error(action<>,lexbuf);
     token_action = &Syntax::Location(n1,n2,l1,n1-s1);
     return TACTION;
   
case 9: 
#line 166 "lexer.cyl"
        return TEQUAL; 
case 10: 
#line 167 "lexer.cyl"
        return TOR; 
case 11: 
#line 168 "lexer.cyl"
        return TUNDERSCORE; 
case 12: 
#line 169 "lexer.cyl"
        return TLBRACKET; 
case 13: 
#line 170 "lexer.cyl"
        return TRBRACKET; 
case 14: 
#line 171 "lexer.cyl"
        return TSTAR; 
case 15: 
#line 172 "lexer.cyl"
        return TMAYBE; 
case 16: 
#line 173 "lexer.cyl"
        return TPLUS; 
case 17: 
#line 174 "lexer.cyl"
        return TLPAREN; 
case 18: 
#line 175 "lexer.cyl"
        return TRPAREN; 
case 19: 
#line 176 "lexer.cyl"
        return TCARET; 
case 20: 
#line 177 "lexer.cyl"
        return TDASH; 
case 21: 
#line 178 "lexer.cyl"
        return -1; 
case 22: 
#line 179 "lexer.cyl"
      throw Lexical_error(xprintf("illegal character %s", lexeme(lexbuf)),
			  line_num, 
			  lexeme_start(lexbuf) - line_start_pos);  default: lexbuf->refill_buff(lexbuf); return lexmain_rec(lexbuf,lexstate);
  }
 throw Error("some action didn't return!");
}
int lexmain<`a>(Lexbuf<`a> lexbuf) { return lexmain_rec(lexbuf,0); }
int action_rec<`a>(Lexbuf<`a> lexbuf, int lexstate) {
  if (lt == null) lt = &lex_tables(lbase, lbacktrk, ldefault, ltrans, lcheck);
  lexstate = lex_engine((LexTables)lt,lexstate,lexbuf);
  switch (lexstate) {

case 0: 
#line 184 "lexer.cyl"
        ++brace_depth; return action(lexbuf); 
case 1: 
#line 185 "lexer.cyl"
        --brace_depth; 
        if(brace_depth == 0) return lexeme_start(lexbuf);
	else return action(lexbuf); 
case 2: 
#line 188 "lexer.cyl"
        reset_string_buffer();
        strng(lexbuf);
        reset_string_buffer();
        return action(lexbuf);
      
case 3: 
#line 194 "lexer.cyl"
      return action(lexbuf); 
case 4: 
#line 196 "lexer.cyl"
      return action(lexbuf); 
case 5: 
#line 198 "lexer.cyl"
      return action(lexbuf); 
case 6: 
#line 199 "lexer.cyl"
         comment_depth = 1; /* FIX: Add // style too! */
         comment(lexbuf); 
         return action(lexbuf);
       
case 7: 
#line 203 "lexer.cyl"
        throw Lexical_error("unterminated action", 0, 0); 
case 8: 
#line 204 "lexer.cyl"
           line_start_pos = lexeme_end(lexbuf);
           ++line_num;
           return action(lexbuf);
         
case 9: 
#line 208 "lexer.cyl"
                                      return action(lexbuf); 
case 10: 
#line 209 "lexer.cyl"
      return action(lexbuf);  default: lexbuf->refill_buff(lexbuf); return action_rec(lexbuf,lexstate);
  }
 throw Error("some action didn't return!");
}
int action<`a>(Lexbuf<`a> lexbuf) { return action_rec(lexbuf,1); }
int strng_rec<`a>(Lexbuf<`a> lexbuf, int lexstate) {
  if (lt == null) lt = &lex_tables(lbase, lbacktrk, ldefault, ltrans, lcheck);
  lexstate = lex_engine((LexTables)lt,lexstate,lexbuf);
  switch (lexstate) {

case 0: 
#line 212 "lexer.cyl"
        return 0; /* ignored */ 
case 1: 
#line 214 "lexer.cyl"
    line_start_pos = lexeme_end(lexbuf);
    ++line_num;
    return strng(lexbuf);
  
case 2: 
#line 219 "lexer.cyl"
    store_string_char(char_for_backslash(lexeme_char(lexbuf,1)));
    return strng(lexbuf); 
case 3: 
#line 222 "lexer.cyl"
    store_string_char(char_for_decimal_code(lexbuf,1)); 
    return strng(lexbuf); 
case 4: 
#line 225 "lexer.cyl"
    throw Lexical_error("unterminated string", 0, 0); 
case 5: 
#line 227 "lexer.cyl"
    store_string_char('\012'); 
    line_start_pos = lexeme_end(lexbuf);
    ++line_num;
    return strng(lexbuf);
  
case 6: 
#line 232 "lexer.cyl"
      store_string_char(lexeme_char(lexbuf,0)); return strng(lexbuf);  default: lexbuf->refill_buff(lexbuf); return strng_rec(lexbuf,lexstate);
  }
 throw Error("some action didn't return!");
}
int strng<`a>(Lexbuf<`a> lexbuf) { return strng_rec(lexbuf,2); }
int comment_rec<`a>(Lexbuf<`a> lexbuf, int lexstate) {
  if (lt == null) lt = &lex_tables(lbase, lbacktrk, ldefault, ltrans, lcheck);
  lexstate = lex_engine((LexTables)lt,lexstate,lexbuf);
  switch (lexstate) {

case 0: 
#line 235 "lexer.cyl"
         ++comment_depth; return comment(lexbuf); /* should we nest? */ 
case 1: 
#line 236 "lexer.cyl"
         --comment_depth; return ((comment_depth == 0) ? 0 : comment(lexbuf)); 
case 2: 
#line 237 "lexer.cyl"
         reset_string_buffer();
         strng(lexbuf);
         reset_string_buffer();
         return comment(lexbuf);
       
case 3: 
#line 242 "lexer.cyl"
                                            return comment(lexbuf); 
case 4: 
#line 243 "lexer.cyl"
                                            return comment(lexbuf); 
case 5: 
#line 244 "lexer.cyl"
                                            return comment(lexbuf); 
case 6: 
#line 245 "lexer.cyl"
                                            return comment(lexbuf); 
case 7: 
#line 246 "lexer.cyl"
        throw Lexical_error("unterminated comment", 0, 0); 
case 8: 
#line 247 "lexer.cyl"
           line_start_pos = lexeme_end(lexbuf);
           ++line_num;
           return comment(lexbuf);
         
case 9: 
#line 251 "lexer.cyl"
      return comment(lexbuf);  default: lexbuf->refill_buff(lexbuf); return comment_rec(lexbuf,lexstate);
  }
 throw Error("some action didn't return!");
}
int comment<`a>(Lexbuf<`a> lexbuf) { return comment_rec(lexbuf,3); }

}
#line 253 "lexer.cyl"
 
