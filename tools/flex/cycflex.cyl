{
#include <stdio.h>
#include <lexing.h>
#include <filename.h>
#include <list.h>
#include <arg.h>
#include <core.h>
#include <string.h>
#include <stdlib.h>
using Lexing;
FILE *mangle_out = NULL;
extern int mangle(Lexbuf<`a>);
}

/* Rules to convert "char *" to "char ?" */
rule mangle = parse
  "char" [' ''\t''\n''\r']+ "*" {
    fprintf((FILE @)mangle_out,"char ?");
    return 1;
  }
| eof {
  return 0;
}
| [^'c']+ {
  fputs((const char @)(lexeme(lexbuf)),(FILE @)mangle_out);
  return 1;
}
| 'c' {
  /* The first rule will take precedence over this one */
  fputc('c',(FILE @)mangle_out);
  return 1;
}

{

  /* This is the file flexcyc.skl imported as a string.  */
  const char skeleton[]ZEROTERM =
    "/* A lexical scanner generated by flex */\n"
    "\n"
    "/* Scanner skeleton version:\n"
    " * /cvsroot/cyclone/tools/flex/cycflex.cyl,v 1.1 2001/11/12 21:10:30\n"
    " */\n"
    "\n"
    "#define FLEX_SCANNER\n"
    "#define YY_FLEX_MAJOR_VERSION 2\n"
    "#define YY_FLEX_MINOR_VERSION 5\n"
    "\n"
    "%+\n"
    "#error C++ mode unsupported\n"
    "%*\n"
    "\n"
    "#include <stdio.h>\n"
    "#include <string.h>\n"
    "#define register\n"
    "struct yy_buffer_state;\n"
    "\n"
    "#define YY_USE_PROTOS\n"
    "#define YY_USE_CONST\n"
    "\n"
    "#define yyconst const\n"
    "#define YY_PROTO(proto) proto\n"
    "\n"
    "/* Returned upon end-of-file. */\n"
    "#define YY_NULL 0\n"
    "\n"
    "/* Promotes a possibly negative, possibly signed char to an unsigned\n"
    " * integer for use as an array index.  If the signed char is negative,\n"
    " * we want to instead treat it as an 8-bit unsigned char, hence the\n"
    " * double cast.\n"
    " */\n"
    "#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)\n"
    "\n"
    "/* Enter a start condition.  This macro really ought to take a parameter,\n"
    " * but we do it the disgusting crufty way forced on us by the ()-less\n"
    " * definition of BEGIN.\n"
    " */\n"
    "#define BEGIN yy_start = 1 + 2 *\n"
    "\n"
    "/* Translate the current start state into a value that can be later handed\n"
    " * to BEGIN to return to the state.  The YYSTATE alias is for lex\n"
    " * compatibility.\n"
    " */\n"
    "#define YY_START ((yy_start - 1) / 2)\n"
    "#define YYSTATE YY_START\n"
    "\n"
    "/* Action number for EOF rule of a given start state. */\n"
    "#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)\n"
    "\n"
    "/* Special action meaning \"start processing a new file\". */\n"
    "#define YY_NEW_FILE yyrestart( yyin )\n"
    "\n"
    "#define YY_END_OF_BUFFER_CHAR 0\n"
    "\n"
    "/* Size of default input buffer. */\n"
    "#define YY_BUF_SIZE 16384\n"
    "\n"
    "typedef struct yy_buffer_state *YY_BUFFER_STATE;\n"
    "\n"
    "extern int yyleng;\n"
    "extern FILE *`H yyin, *`H yyout;\n"
    "\n"
    "#define EOB_ACT_CONTINUE_SCAN 0\n"
    "#define EOB_ACT_END_OF_FILE 1\n"
    "#define EOB_ACT_LAST_MATCH 2\n"
    "\n"
    "/* The funky do-while in the following #define is used to turn the definition\n"
    " * int a single C statement (which needs a semi-colon terminator).  This\n"
    " * avoids problems with code like:\n"
    " *\n"
    " * 	if ( condition_holds )\n"
    " *		yyless( 5 );\n"
    " *	else\n"
    " *		do_something_else();\n"
    " *\n"
    " * Prior to using the do-while the compiler would get upset at the\n"
    " * \"else\" because it interpreted the \"if\" statement as being all\n"
    " * done when it reached the ';' after the yyless() call.\n"
    " */\n"
    "\n"
    "/* Return all but the first 'n' matched characters back to the input stream. */\n"
    "\n"
    "#define yyless(n) \\\n"
    "	do \\\n"
    "		{ \\\n"
    "		/* Undo effects of setting up yytext. */ \\\n"
    "		*yy_cp = yy_hold_char; \\\n"
    "		YY_RESTORE_YY_MORE_OFFSET \\\n"
    "		yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \\\n"
    "		YY_DO_BEFORE_ACTION; /* set up yytext again */ \\\n"
    "		} \\\n"
    "	while ( 0 )\n"
    "\n"
    "#define unput(c) yyunput( c, yytext_ptr )\n"
    "\n"
    "/* The following is because we cannot portably get our hands on size_t\n"
    " * (without autoconf's help, which isn't available because we want\n"
    " * flex-generated scanners to compile on their own).\n"
    " */\n"
    "typedef unsigned int yy_size_t;\n"
    "\n"
    "\n"
    "struct yy_buffer_state\n"
    "	{\n"
    "	FILE *yy_input_file;\n"
    "\n"
    "	char ?yy_ch_buf;		/* input buffer */\n"
    "	char ?yy_buf_pos;		/* current position in input buffer */\n"
    "\n"
    "	/* Size of input buffer in bytes, not including room for EOB\n"
    "	 * characters.\n"
    "	 */\n"
    "	yy_size_t yy_buf_size;\n"
    "\n"
    "	/* Number of characters read into yy_ch_buf, not including EOB\n"
    "	 * characters.\n"
    "	 */\n"
    "	int yy_n_chars;\n"
    "\n"
    "	/* Whether we \"own\" the buffer - i.e., we know we created it,\n"
    "	 * and can realloc() it to grow it, and should free() it to\n"
    "	 * delete it.\n"
    "	 */\n"
    "	int yy_is_our_buffer;\n"
    "\n"
    "	/* Whether this is an \"interactive\" input source; if so, and\n"
    "	 * if we're using stdio for input, then we want to use getc()\n"
    "	 * instead of fread(), to make sure we stop fetching input after\n"
    "	 * each newline.\n"
    "	 */\n"
    "	int yy_is_interactive;\n"
    "\n"
    "	/* Whether we're considered to be at the beginning of a line.\n"
    "	 * If so, '^' rules will be active on the next match, otherwise\n"
    "	 * not.\n"
    "	 */\n"
    "	int yy_at_bol;\n"
    "\n"
    "	/* Whether to try to fill the input buffer when we reach the\n"
    "	 * end of it.\n"
    "	 */\n"
    "	int yy_fill_buffer;\n"
    "\n"
    "	int yy_buffer_status;\n"
    "#define YY_BUFFER_NEW 0\n"
    "#define YY_BUFFER_NORMAL 1\n"
    "	/* When an EOF's been seen but there's still some text to process\n"
    "	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we\n"
    "	 * shouldn't try reading from the input source any more.  We might\n"
    "	 * still have a bunch of tokens to match, though, because of\n"
    "	 * possible backing-up.\n"
    "	 *\n"
    "	 * When we actually see the EOF, we change the status to \"new\"\n"
    "	 * (via yyrestart()), so that the user can continue scanning by\n"
    "	 * just pointing yyin at a new input file.\n"
    "	 */\n"
    "#define YY_BUFFER_EOF_PENDING 2\n"
    "	};\n"
    "\n"
    "static YY_BUFFER_STATE yy_current_buffer = NULL;\n"
    "\n"
    "/* We provide macros for accessing buffer states in case in the\n"
    " * future we want to put the buffer states in a more general\n"
    " * \"scanner state\".\n"
    " */\n"
    "#define YY_CURRENT_BUFFER yy_current_buffer\n"
    "\n"
    "\n"
    "/* yy_hold_char holds the character lost when yytext is formed. */\n"
    "static char yy_hold_char;\n"
    "\n"
    "static int yy_n_chars;		/* number of characters read into yy_ch_buf */\n"
    "\n"
    "\n"
    "int yyleng;\n"
    "\n"
    "/* Points to current character in buffer. */\n"
    "static char ?yy_c_buf_p = NULL;\n"
    "static int yy_init = 1;		/* whether we need to initialize */\n"
    "static int yy_start = 0;	/* start state number */\n"
    "\n"
    "/* Flag which is used to allow yywrap()'s to do buffer switches\n"
    " * instead of setting up a fresh yyin.  A bit of a hack ...\n"
    " */\n"
    "static int yy_did_buffer_switch_on_eof;\n"
    "\n"
    "void yyrestart YY_PROTO(( FILE *`H input_file ));\n"
    "\n"
    "void yy_switch_to_buffer YY_PROTO(( YY_BUFFER_STATE new_buffer ));\n"
    "void yy_load_buffer_state YY_PROTO(( void ));\n"
    "YY_BUFFER_STATE yy_create_buffer YY_PROTO(( FILE *`H file, int size ));\n"
    "void yy_delete_buffer YY_PROTO(( YY_BUFFER_STATE b ));\n"
    "void yy_init_buffer YY_PROTO(( YY_BUFFER_STATE b, FILE *`H file ));\n"
    "void yy_flush_buffer YY_PROTO(( YY_BUFFER_STATE b ));\n"
    "#define YY_FLUSH_BUFFER yy_flush_buffer( yy_current_buffer )\n"
    "\n"
    "YY_BUFFER_STATE yy_scan_buffer YY_PROTO(( char ?`H base, yy_size_t size ));\n"
    "YY_BUFFER_STATE yy_scan_string YY_PROTO(( yyconst char ?yy_str ));\n"
    "YY_BUFFER_STATE yy_scan_bytes YY_PROTO(( yyconst char ?bytes, int len ));\n"
    "\n"
    "#define yy_new_buffer yy_create_buffer\n"
    "\n"
    "#define yy_set_interactive(is_interactive) \\\n"
    "	{ \\\n"
    "	if ( ! yy_current_buffer ) \\\n"
    "		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \\\n"
    "	yy_current_buffer->yy_is_interactive = is_interactive; \\\n"
    "	}\n"
    "\n"
    "#define yy_set_bol(at_bol) \\\n"
    "	{ \\\n"
    "	if ( ! yy_current_buffer ) \\\n"
    "		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \\\n"
    "	yy_current_buffer->yy_at_bol = at_bol; \\\n"
    "	}\n"
    "\n"
    "#define YY_AT_BOL() (yy_current_buffer->yy_at_bol)\n"
    "\n"
    "%% yytext/yyin/yyout/yy_state_type/yylineno etc. def's & init go here\n"
    "\n"
    "static yy_state_type yy_get_previous_state YY_PROTO(( void ));\n"
    "static yy_state_type yy_try_NUL_trans YY_PROTO(( yy_state_type current_state ));\n"
    "static int yy_get_next_buffer YY_PROTO(( void ));\n"
    "static void yy_fatal_error YY_PROTO(( yyconst char msg[] ));\n"
    "\n"
    "/* Done after the current pattern has been matched and before the\n"
    " * corresponding action - sets up yytext.\n"
    " */\n"
    "#define YY_DO_BEFORE_ACTION \\\n"
    "	yytext_ptr = yy_bp; \\\n"
    "%% code to fiddle yytext and yyleng for yymore() goes here\n"
    "	yy_hold_char = *yy_cp; \\\n"
    "	*yy_cp = '\\0'; \\\n"
    "%% code to copy yytext_ptr to yytext[] goes here, if %array\n"
    "	yy_c_buf_p = yy_cp;\n"
    "\n"
    "%% data tables for the DFA and the user's section 1 definitions go here\n"
    "\n"
    "/* Macros after this point can all be overridden by user definitions in\n"
    " * section 1.\n"
    " */\n"
    "\n"
    "#ifndef YY_SKIP_YYWRAP\n"
    "extern \"C\" int yywrap YY_PROTO(( void ));\n"
    "#endif\n"
    "\n"
    "#ifndef YY_NO_UNPUT\n"
    "static void yyunput YY_PROTO(( int c, char ?`H buf_ptr ));\n"
    "#endif\n"
    "\n"
    "#ifndef yytext_ptr\n"
    "static void yy_flex_strncpy YY_PROTO(( char ?, yyconst char ?, int ));\n"
    "#endif\n"
    "\n"
    "#ifdef YY_NEED_STRLEN\n"
    "static int yy_flex_strlen YY_PROTO(( yyconst char ? ));\n"
    "#endif\n"
    "\n"
    "#ifndef YY_NO_INPUT\n"
    "%- Standard (non-C++) definition\n"
    "#ifdef __cplusplus\n"
    "static int yyinput YY_PROTO(( void ));\n"
    "#else\n"
    "static int input YY_PROTO(( void ));\n"
    "#endif\n"
    "%*\n"
    "#endif\n"
    "\n"
    "#if YY_STACK_USED\n"
    "static int yy_start_stack_ptr = 0;\n"
    "static int yy_start_stack_depth = 0;\n"
    "static int *yy_start_stack = 0;\n"
    "#ifndef YY_NO_PUSH_STATE\n"
    "static void yy_push_state YY_PROTO(( int new_state ));\n"
    "#endif\n"
    "#ifndef YY_NO_POP_STATE\n"
    "static void yy_pop_state YY_PROTO(( void ));\n"
    "#endif\n"
    "#ifndef YY_NO_TOP_STATE\n"
    "static int yy_top_state YY_PROTO(( void ));\n"
    "#endif\n"
    "\n"
    "#else\n"
    "#define YY_NO_PUSH_STATE 1\n"
    "#define YY_NO_POP_STATE 1\n"
    "#define YY_NO_TOP_STATE 1\n"
    "#endif\n"
    "\n"
    "#ifdef YY_MALLOC_DECL\n"
    "YY_MALLOC_DECL\n"
    "#else\n"
    "#include <stdlib.h>\n"
    "#endif\n"
    "\n"
    "/* Amount of stuff to slurp up with each read. */\n"
    "#ifndef YY_READ_BUF_SIZE\n"
    "#define YY_READ_BUF_SIZE 8192\n"
    "#endif\n"
    "\n"
    "/* Copy whatever the last rule matched to the standard output. */\n"
    "\n"
    "#ifndef ECHO\n"
    "/* This used to be an fputs(), but since the string might contain NUL's,\n"
    " * we now use fwrite().\n"
    " */\n"
    "#define ECHO fwrite( yytext, yyleng, 1, (FILE @) yyout )\n"
    "#endif\n"
    "\n"
    "/* Gets input and stuffs it into \"buf\".  number of characters read, or YY_NULL,\n"
    " * is returned in \"result\".\n"
    " */\n"
    "#ifndef YY_INPUT\n"
    "#define YY_INPUT(buf,result,max_size) \\\n"
    "%% fread()/read() definition of YY_INPUT goes here unless we're doing C++\n"
    "#endif\n"
    "\n"
    "/* No semi-colon after return; correct usage is to write \"yyterminate();\" -\n"
    " * we don't want an extra ';' after the \"return\" because that will cause\n"
    " * some compilers to complain about unreachable statements.\n"
    " */\n"
    "#ifndef yyterminate\n"
    "#define yyterminate() return YY_NULL\n"
    "#endif\n"
    "\n"
    "/* Number of entries by which start-condition stack grows. */\n"
    "#ifndef YY_START_STACK_INCR\n"
    "#define YY_START_STACK_INCR 25\n"
    "#endif\n"
    "\n"
    "/* Report a fatal error. */\n"
    "#ifndef YY_FATAL_ERROR\n"
    "#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )\n"
    "#endif\n"
    "\n"
    "/* Default declaration of generated scanner - a define so the user can\n"
    " * easily add parameters.\n"
    " */\n"
    "#ifndef YY_DECL\n"
    "#define YY_DECL int yylex YY_PROTO(( void ))\n"
    "#endif\n"
    "\n"
    "/* Code executed at the beginning of each rule, after yytext and yyleng\n"
    " * have been set up.\n"
    " */\n"
    "#ifndef YY_USER_ACTION\n"
    "#define YY_USER_ACTION\n"
    "#endif\n"
    "\n"
    "/* Code executed at the end of each rule. */\n"
    "#ifndef YY_BREAK\n"
    "#define YY_BREAK break;\n"
    "#endif\n"
    "\n"
    "%% YY_RULE_SETUP definition goes here\n"
    "\n"
    "YY_DECL\n"
    "	{\n"
    "	register yy_state_type yy_current_state;\n"
    "	register char ?yy_cp, ?yy_bp;\n"
    "	register int yy_act;\n"
    "\n"
    "%% user's declarations go here\n"
    "\n"
    "	if ( yy_init )\n"
    "		{\n"
    "		yy_init = 0;\n"
    "\n"
    "#ifdef YY_USER_INIT\n"
    "		YY_USER_INIT;\n"
    "#endif\n"
    "\n"
    "		if ( ! yy_start )\n"
    "			yy_start = 1;	/* first start state */\n"
    "\n"
    "		if ( ! yyin )\n"
    "			yyin = stdin;\n"
    "\n"
    "		if ( ! yyout )\n"
    "			yyout = stdout;\n"
    "\n"
    "		if ( ! yy_current_buffer )\n"
    "			yy_current_buffer =\n"
    "				yy_create_buffer( yyin, YY_BUF_SIZE );\n"
    "\n"
    "		yy_load_buffer_state();\n"
    "		}\n"
    "\n"
    "	while ( 1 )		/* loops until end-of-file is reached */\n"
    "		{\n"
    "%% yymore()-related code goes here\n"
    "		yy_cp = yy_c_buf_p;\n"
    "\n"
    "		/* Support of yytext. */\n"
    "		*yy_cp = yy_hold_char;\n"
    "\n"
    "		/* yy_bp points to the position in yy_ch_buf of the start of\n"
    "		 * the current run.\n"
    "		 */\n"
    "		yy_bp = yy_cp;\n"
    "\n"
    "%% code to set up and find next match goes here\n"
    "\n"
    "yy_find_action:\n"
    "%% code to find the action number goes here\n"
    "\n"
    "		YY_DO_BEFORE_ACTION;\n"
    "\n"
    "%% code for yylineno update goes here\n"
    "\n"
    "do_action:	/* This label is used only to access EOF actions. */\n"
    "\n"
    "%% debug code goes here\n"
    "\n"
    "		switch \"C\" ( yy_act )\n"
    "	{ /* beginning of action switch */\n"
    "%% actions go here\n"
    "\n"
    "	case YY_END_OF_BUFFER:\n"
    "		{\n"
    "		/* Amount of text matched not including the EOB char. */\n"
    "		int yy_amount_of_matched_text = (int) (yy_cp - yytext_ptr) - 1;\n"
    "\n"
    "		/* Undo the effects of YY_DO_BEFORE_ACTION. */\n"
    "		*yy_cp = yy_hold_char;\n"
    "		YY_RESTORE_YY_MORE_OFFSET\n"
    "\n"
    "		if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW )\n"
    "			{\n"
    "			/* We're scanning a new file or input source.  It's\n"
    "			 * possible that this happened because the user\n"
    "			 * just pointed yyin at a new source and called\n"
    "			 * yylex().  If so, then we have to assure\n"
    "			 * consistency between yy_current_buffer and our\n"
    "			 * globals.  Here is the right place to do so, because\n"
    "			 * this is the first action (other than possibly a\n"
    "			 * back-up) that will match for the new input source.\n"
    "			 */\n"
    "			yy_n_chars = yy_current_buffer->yy_n_chars;\n"
    "			yy_current_buffer->yy_input_file = yyin;\n"
    "			yy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;\n"
    "			}\n"
    "\n"
    "		/* Note that here we test for yy_c_buf_p \"<=\" to the position\n"
    "		 * of the first EOB in the buffer, since yy_c_buf_p will\n"
    "		 * already have been incremented past the NUL character\n"
    "		 * (since all states make transitions on EOB to the\n"
    "		 * end-of-buffer state).  Contrast this with the test\n"
    "		 * in input().\n"
    "		 */\n"
    "		if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )\n"
    "			{ /* This was really a NUL. */\n"
    "			yy_state_type yy_next_state;\n"
    "\n"
    "			yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;\n"
    "\n"
    "			yy_current_state = yy_get_previous_state();\n"
    "\n"
    "			/* Okay, we're now positioned to make the NUL\n"
    "			 * transition.  We couldn't have\n"
    "			 * yy_get_previous_state() go ahead and do it\n"
    "			 * for us because it doesn't know how to deal\n"
    "			 * with the possibility of jamming (and we don't\n"
    "			 * want to build jamming into it because then it\n"
    "			 * will run more slowly).\n"
    "			 */\n"
    "\n"
    "			yy_next_state = yy_try_NUL_trans( yy_current_state );\n"
    "\n"
    "			yy_bp = yytext_ptr + YY_MORE_ADJ;\n"
    "\n"
    "			if ( yy_next_state )\n"
    "				{\n"
    "				/* Consume the NUL. */\n"
    "				yy_cp = ++yy_c_buf_p;\n"
    "				yy_current_state = yy_next_state;\n"
    "				goto yy_match;\n"
    "				}\n"
    "\n"
    "			else\n"
    "				{\n"
    "%% code to do back-up for compressed tables and set up yy_cp goes here\n"
    "				goto yy_find_action;\n"
    "				}\n"
    "			}\n"
    "\n"
    "		else switch \"C\" ( yy_get_next_buffer() )\n"
    "			{\n"
    "			case EOB_ACT_END_OF_FILE:\n"
    "				{\n"
    "				yy_did_buffer_switch_on_eof = 0;\n"
    "\n"
    "				if ( yywrap() )\n"
    "					{\n"
    "					/* Note: because we've taken care in\n"
    "					 * yy_get_next_buffer() to have set up\n"
    "					 * yytext, we can now set up\n"
    "					 * yy_c_buf_p so that if some total\n"
    "					 * hoser (like flex itself) wants to\n"
    "					 * call the scanner after we return the\n"
    "					 * YY_NULL, it'll still work - another\n"
    "					 * YY_NULL will get returned.\n"
    "					 */\n"
    "					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;\n"
    "\n"
    "					yy_act = YY_STATE_EOF(YY_START);\n"
    "					goto do_action;\n"
    "					}\n"
    "\n"
    "				else\n"
    "					{\n"
    "					if ( ! yy_did_buffer_switch_on_eof )\n"
    "						YY_NEW_FILE;\n"
    "					}\n"
    "				break;\n"
    "				}\n"
    "\n"
    "			case EOB_ACT_CONTINUE_SCAN:\n"
    "				yy_c_buf_p =\n"
    "					yytext_ptr + yy_amount_of_matched_text;\n"
    "\n"
    "				yy_current_state = yy_get_previous_state();\n"
    "\n"
    "				yy_cp = yy_c_buf_p;\n"
    "				yy_bp = yytext_ptr + YY_MORE_ADJ;\n"
    "				goto yy_match;\n"
    "\n"
    "			case EOB_ACT_LAST_MATCH:\n"
    "				yy_c_buf_p =\n"
    "				&yy_current_buffer->yy_ch_buf[yy_n_chars];\n"
    "\n"
    "				yy_current_state = yy_get_previous_state();\n"
    "\n"
    "				yy_cp = yy_c_buf_p;\n"
    "				yy_bp = yytext_ptr + YY_MORE_ADJ;\n"
    "				goto yy_find_action;\n"
    "                        default: break; // added by MSH\n"
    "			}\n"
    "		break;\n"
    "		}\n"
    "\n"
    "	default:\n"
    "		YY_FATAL_ERROR(\n"
    "			\"fatal flex scanner internal error--no action found\" );\n"
    "	} /* end of action switch */\n"
    "		} /* end of scanning one token */\n"
    "	} /* end of yylex */\n"
    "\n"
    "\n"
    "/* yy_get_next_buffer - try to read in a new buffer\n"
    " *\n"
    " * Returns a code representing an action:\n"
    " *	EOB_ACT_LAST_MATCH -\n"
    " *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position\n"
    " *	EOB_ACT_END_OF_FILE - end of file\n"
    " */\n"
    "\n"
    "static int yy_get_next_buffer()\n"
    "	{\n"
    "	register char ?dest = yy_current_buffer->yy_ch_buf;\n"
    "	register char ?source = yytext_ptr;\n"
    "	register int number_to_move, i;\n"
    "	int ret_val;\n"
    "\n"
    "	if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )\n"
    "		YY_FATAL_ERROR(\n"
    "		\"fatal flex scanner internal error--end of buffer missed\" );\n"
    "\n"
    "	if ( yy_current_buffer->yy_fill_buffer == 0 )\n"
    "		{ /* Don't try to fill the buffer, so this is an EOF. */\n"
    "		if ( yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1 )\n"
    "			{\n"
    "			/* We matched a single character, the EOB, so\n"
    "			 * treat this as a final EOF.\n"
    "			 */\n"
    "			return EOB_ACT_END_OF_FILE;\n"
    "			}\n"
    "\n"
    "		else\n"
    "			{\n"
    "			/* We matched some text prior to the EOB, first\n"
    "			 * process it.\n"
    "			 */\n"
    "			return EOB_ACT_LAST_MATCH;\n"
    "			}\n"
    "		}\n"
    "\n"
    "	/* Try to read more data. */\n"
    "\n"
    "	/* First move last chars to start of buffer. */\n"
    "	number_to_move = (int) (yy_c_buf_p - yytext_ptr) - 1;\n"
    "\n"
    "	for ( i = 0; i < number_to_move; ++i )\n"
    "		*(dest++) = *(source++);\n"
    "\n"
    "	if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING )\n"
    "		/* don't do the read, it's not guaranteed to return an EOF,\n"
    "		 * just force an EOF\n"
    "		 */\n"
    "		yy_current_buffer->yy_n_chars = yy_n_chars = 0;\n"
    "\n"
    "	else\n"
    "		{\n"
    "		int num_to_read =\n"
    "			yy_current_buffer->yy_buf_size - number_to_move - 1;\n"
    "\n"
    "		while ( num_to_read <= 0 )\n"
    "			{ /* Not enough room in the buffer - grow it. */\n"
    "#ifdef YY_USES_REJECT\n"
    "			YY_FATAL_ERROR(\n"
    "\"input buffer overflow, can't enlarge buffer because scanner uses REJECT\" );\n"
    "#else\n"
    "\n"
    "			/* just a shorter name for the current buffer */\n"
    "			YY_BUFFER_STATE b = yy_current_buffer;\n"
    "\n"
    "			int yy_c_buf_p_offset =\n"
    "				(int) (yy_c_buf_p - b->yy_ch_buf);\n"
    "\n"
    "			if ( b->yy_is_our_buffer )\n"
    "				{\n"
    "				int new_size = b->yy_buf_size * 2;\n"
    "\n"
    "				if ( new_size <= 0 )\n"
    "					b->yy_buf_size += b->yy_buf_size / 8;\n"
    "				else\n"
    "					b->yy_buf_size *= 2;\n"
    "\n"
    "				b->yy_ch_buf =\n"
    "					/* Include room in for 2 EOB chars. */\n"
    "                                  realloc_str(b->yy_ch_buf, b->yy_buf_size+2);\n"
    "				}\n"
    "			else\n"
    "				/* Can't grow it, we don't own it. */\n"
    "				b->yy_ch_buf = NULL;\n"
    "\n"
    "			if ( ! b->yy_ch_buf )\n"
    "				YY_FATAL_ERROR(\n"
    "				\"fatal error - scanner input buffer overflow\" );\n"
    "\n"
    "			yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];\n"
    "\n"
    "			num_to_read = yy_current_buffer->yy_buf_size -\n"
    "						number_to_move - 1;\n"
    "#endif\n"
    "			}\n"
    "\n"
    "		if ( num_to_read > YY_READ_BUF_SIZE )\n"
    "			num_to_read = YY_READ_BUF_SIZE;\n"
    "\n"
    "		/* Read in more data. */\n"
    "		YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),\n"
    "			yy_n_chars, num_to_read );\n"
    "\n"
    "		yy_current_buffer->yy_n_chars = yy_n_chars;\n"
    "		}\n"
    "\n"
    "	if ( yy_n_chars == 0 )\n"
    "		{\n"
    "		if ( number_to_move == YY_MORE_ADJ )\n"
    "			{\n"
    "			ret_val = EOB_ACT_END_OF_FILE;\n"
    "			yyrestart( yyin );\n"
    "			}\n"
    "\n"
    "		else\n"
    "			{\n"
    "			ret_val = EOB_ACT_LAST_MATCH;\n"
    "			yy_current_buffer->yy_buffer_status =\n"
    "				YY_BUFFER_EOF_PENDING;\n"
    "			}\n"
    "		}\n"
    "\n"
    "	else\n"
    "		ret_val = EOB_ACT_CONTINUE_SCAN;\n"
    "\n"
    "	yy_n_chars += number_to_move;\n"
    "	yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;\n"
    "	yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;\n"
    "\n"
    "	yytext_ptr = &yy_current_buffer->yy_ch_buf[0];\n"
    "\n"
    "	return ret_val;\n"
    "	}\n"
    "\n"
    "\n"
    "/* yy_get_previous_state - get the state just before the EOB char was reached */\n"
    "\n"
    "static yy_state_type yy_get_previous_state()\n"
    "	{\n"
    "	register yy_state_type yy_current_state;\n"
    "	register char ?yy_cp;\n"
    "\n"
    "%% code to get the start state into yy_current_state goes here\n"
    "\n"
    "	for ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )\n"
    "		{\n"
    "%% code to find the next state goes here\n"
    "		}\n"
    "\n"
    "	return yy_current_state;\n"
    "	}\n"
    "\n"
    "\n"
    "/* yy_try_NUL_trans - try to make a transition on the NUL character\n"
    " *\n"
    " * synopsis\n"
    " *	next_state = yy_try_NUL_trans( current_state );\n"
    " */\n"
    "\n"
    "static yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )\n"
    "	{\n"
    "	register int yy_is_jam;\n"
    "%% code to find the next state, and perhaps do backing up, goes here\n"
    "\n"
    "	return yy_is_jam ? 0 : yy_current_state;\n"
    "	}\n"
    "\n"
    "\n"
    "#ifndef YY_NO_UNPUT\n"
    "static void yyunput( int c, register char ?`H yy_bp )\n"
    "	{\n"
    "	register char ?yy_cp = yy_c_buf_p;\n"
    "\n"
    "	/* undo effects of setting up yytext */\n"
    "	*yy_cp = yy_hold_char;\n"
    "\n"
    "	if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )\n"
    "		{ /* need to shift things up to make room */\n"
    "		/* +2 for EOB chars. */\n"
    "		register int number_to_move = yy_n_chars + 2;\n"
    "		register char ?dest = &yy_current_buffer->yy_ch_buf[\n"
    "					yy_current_buffer->yy_buf_size + 2];\n"
    "		register char ?source =\n"
    "				&yy_current_buffer->yy_ch_buf[number_to_move];\n"
    "\n"
    "		while ( source > yy_current_buffer->yy_ch_buf )\n"
    "			*--dest = *--source;\n"
    "\n"
    "		yy_cp += (int) (dest - source);\n"
    "		yy_bp += (int) (dest - source);\n"
    "		yy_current_buffer->yy_n_chars =\n"
    "			yy_n_chars = yy_current_buffer->yy_buf_size;\n"
    "\n"
    "		if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )\n"
    "			YY_FATAL_ERROR( \"flex scanner push-back overflow\" );\n"
    "		}\n"
    "\n"
    "	*--yy_cp = (char) c;\n"
    "\n"
    "%% update yylineno here\n"
    "\n"
    "	yytext_ptr = yy_bp;\n"
    "	yy_hold_char = *yy_cp;\n"
    "	yy_c_buf_p = yy_cp;\n"
    "	}\n"
    "#endif	/* ifndef YY_NO_UNPUT */\n"
    "\n"
    "\n"
    "static int input()\n"
    "	{\n"
    "	int c;\n"
    "\n"
    "	*yy_c_buf_p = yy_hold_char;\n"
    "\n"
    "	if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )\n"
    "		{\n"
    "		/* yy_c_buf_p now points to the character we want to return.\n"
    "		 * If this occurs *before* the EOB characters, then it's a\n"
    "		 * valid NUL; if not, then we've hit the end of the buffer.\n"
    "		 */\n"
    "		if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )\n"
    "			/* This was really a NUL. */\n"
    "			*yy_c_buf_p = '\\0';\n"
    "\n"
    "		else\n"
    "			{ /* need more input */\n"
    "			int offset = yy_c_buf_p - yytext_ptr;\n"
    "			++yy_c_buf_p;\n"
    "\n"
    "			switch \"C\" ( yy_get_next_buffer() )\n"
    "				{\n"
    "				case EOB_ACT_LAST_MATCH:\n"
    "					/* This happens because yy_g_n_b()\n"
    "					 * sees that we've accumulated a\n"
    "					 * token and flags that we need to\n"
    "					 * try matching the token before\n"
    "					 * proceeding.  But for input(),\n"
    "					 * there's no matching to consider.\n"
    "					 * So convert the EOB_ACT_LAST_MATCH\n"
    "					 * to EOB_ACT_END_OF_FILE.\n"
    "					 */\n"
    "\n"
    "					/* Reset buffer status. */\n"
    "					yyrestart( yyin );\n"
    "\n"
    "					/* fall through */\n"
    "\n"
    "				case EOB_ACT_END_OF_FILE:\n"
    "					{\n"
    "					if ( yywrap() )\n"
    "						return EOF;\n"
    "\n"
    "					if ( ! yy_did_buffer_switch_on_eof )\n"
    "						YY_NEW_FILE;\n"
    "					return input();\n"
    "					}\n"
    "\n"
    "				case EOB_ACT_CONTINUE_SCAN:\n"
    "					yy_c_buf_p = yytext_ptr + offset;\n"
    "					break;\n"
    "                                default: break; // added by MSH\n"
    "				}\n"
    "			}\n"
    "		}\n"
    "\n"
    "	c = *(unsigned char ?) yy_c_buf_p;	/* cast for 8-bit char's */\n"
    "	*yy_c_buf_p = '\\0';	/* preserve yytext */\n"
    "	yy_hold_char = *++yy_c_buf_p;\n"
    "\n"
    "%% update BOL and yylineno\n"
    "\n"
    "	return c;\n"
    "	}\n"
    "\n"
    "\n"
    "void yyrestart( FILE *`H input_file )\n"
    "	{\n"
    "	if ( ! yy_current_buffer )\n"
    "		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );\n"
    "\n"
    "	yy_init_buffer( yy_current_buffer, input_file );\n"
    "	yy_load_buffer_state();\n"
    "	}\n"
    "\n"
    "\n"
    "void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )\n"
    "	{\n"
    "	if ( yy_current_buffer == new_buffer )\n"
    "		return;\n"
    "\n"
    "	if ( yy_current_buffer )\n"
    "		{\n"
    "		/* Flush out information for old buffer. */\n"
    "		*yy_c_buf_p = yy_hold_char;\n"
    "		yy_current_buffer->yy_buf_pos = yy_c_buf_p;\n"
    "		yy_current_buffer->yy_n_chars = yy_n_chars;\n"
    "		}\n"
    "\n"
    "	yy_current_buffer = new_buffer;\n"
    "	yy_load_buffer_state();\n"
    "\n"
    "	/* We don't actually know whether we did this switch during\n"
    "	 * EOF (yywrap()) processing, but the only time this flag\n"
    "	 * is looked at is after yywrap() is called, so it's safe\n"
    "	 * to go ahead and always set it.\n"
    "	 */\n"
    "	yy_did_buffer_switch_on_eof = 1;\n"
    "	}\n"
    "\n"
    "\n"
    "void yy_load_buffer_state( void )\n"
    "	{\n"
    "	yy_n_chars = yy_current_buffer->yy_n_chars;\n"
    "	yytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;\n"
    "	yyin = yy_current_buffer->yy_input_file;\n"
    "	yy_hold_char = *yy_c_buf_p;\n"
    "	}\n"
    "\n"
    "\n"
    "YY_BUFFER_STATE yy_create_buffer( FILE *`H file, int size )\n"
    "	{\n"
    "	YY_BUFFER_STATE b;\n"
    "\n"
    "	b = new yy_buffer_state {\n"
    "          .yy_input_file = NULL,\n"
    "	/* yy_ch_buf has to be 2 characters longer than the size given because\n"
    "	 * we need to put in 2 end-of-buffer characters.\n"
    "	 */\n"
    "          .yy_ch_buf = Core::new_string( size + 2 ),\n"
    "          .yy_buf_pos = NULL,\n"
    "          .yy_buf_size = size,\n"
    "          .yy_n_chars = 0,\n"
    "          .yy_is_our_buffer = 1,\n"
    "          .yy_is_interactive = 0,\n"
    "          .yy_at_bol = 0,\n"
    "          .yy_fill_buffer = 0,\n"
    "          .yy_buffer_status = 0\n"
    "        };\n"
    "\n"
    "	yy_init_buffer( b, file );\n"
    "\n"
    "	return b;\n"
    "	}\n"
    "\n"
    "\n"
    "void yy_delete_buffer( YY_BUFFER_STATE b )\n"
    "	{\n"
    "	if ( ! b )\n"
    "		return;\n"
    "\n"
    "	if ( b == yy_current_buffer )\n"
    "		yy_current_buffer = NULL;\n"
    "\n"
    "	}\n"
    "\n"
    "\n"
    "#ifndef YY_ALWAYS_INTERACTIVE\n"
    "#ifndef YY_NEVER_INTERACTIVE\n"
    "extern \"C\" int isatty YY_PROTO(( int ));\n"
    "#endif\n"
    "#endif\n"
    "\n"
    "void yy_init_buffer( YY_BUFFER_STATE b, FILE *`H file )\n"
    "	{\n"
    "	yy_flush_buffer( b );\n"
    "\n"
    "	b->yy_input_file = file;\n"
    "	b->yy_fill_buffer = 1;\n"
    "\n"
    "#if YY_ALWAYS_INTERACTIVE\n"
    "	b->yy_is_interactive = 1;\n"
    "#else\n"
    "#if YY_NEVER_INTERACTIVE\n"
    "	b->yy_is_interactive = 0;\n"
    "#else\n"
    "	b->yy_is_interactive = file ? (isatty( fileno((FILE @)file) ) > 0) : 0;\n"
    "#endif\n"
    "#endif\n"
    "	}\n"
    "\n"
    "\n"
    "void yy_flush_buffer( YY_BUFFER_STATE b )\n"
    "	{\n"
    "	if ( ! b )\n"
    "		return;\n"
    "\n"
    "	b->yy_n_chars = 0;\n"
    "\n"
    "	/* We always need two end-of-buffer characters.  The first causes\n"
    "	 * a transition to the end-of-buffer state.  The second causes\n"
    "	 * a jam in that state.\n"
    "	 */\n"
    "	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;\n"
    "	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;\n"
    "\n"
    "	b->yy_buf_pos = &b->yy_ch_buf[0];\n"
    "\n"
    "	b->yy_at_bol = 1;\n"
    "	b->yy_buffer_status = YY_BUFFER_NEW;\n"
    "\n"
    "	if ( b == yy_current_buffer )\n"
    "		yy_load_buffer_state();\n"
    "	}\n"
    "\n"
    "\n"
    "#ifndef YY_NO_SCAN_BUFFER\n"
    "YY_BUFFER_STATE yy_scan_buffer( char ?`H base, yy_size_t size )\n"
    "	{\n"
    "	YY_BUFFER_STATE b;\n"
    "\n"
    "	if ( size < 2 ||\n"
    "	     base[size-2] != YY_END_OF_BUFFER_CHAR ||\n"
    "	     base[size-1] != YY_END_OF_BUFFER_CHAR )\n"
    "		/* They forgot to leave room for the EOB's. */\n"
    "		return NULL;\n"
    "\n"
    "	b = new yy_buffer_state {\n"
    "          .yy_input_file = NULL,\n"
    "          .yy_ch_buf = base,\n"
    "          .yy_buf_pos = base,\n"
    "          .yy_buf_size = size - 2,	/* \"- 2\" to take care of EOB's */\n"
    "          .yy_n_chars = size - 2,\n"
    "          .yy_is_our_buffer = 0,\n"
    "          .yy_is_interactive = 0,\n"
    "          .yy_at_bol = 1,\n"
    "          .yy_fill_buffer = 0,\n"
    "          .yy_buffer_status = YY_BUFFER_NEW\n"
    "        };\n"
    "\n"
    "	yy_switch_to_buffer( b );\n"
    "\n"
    "	return b;\n"
    "	}\n"
    "#endif\n"
    "\n"
    "\n"
    "#ifndef YY_NO_SCAN_STRING\n"
    "YY_BUFFER_STATE yy_scan_string( yyconst char ?yy_str )\n"
    "	{\n"
    "	int len;\n"
    "	for ( len = 0; yy_str[len]; ++len )\n"
    "		;\n"
    "\n"
    "	return yy_scan_bytes( yy_str, len );\n"
    "	}\n"
    "#endif\n"
    "\n"
    "\n"
    "#ifndef YY_NO_SCAN_BYTES\n"
    "YY_BUFFER_STATE yy_scan_bytes( yyconst char ?bytes, int len )\n"
    "	{\n"
    "	YY_BUFFER_STATE b;\n"
    "	char ?buf;\n"
    "	yy_size_t n;\n"
    "	int i;\n"
    "\n"
    "	/* Get memory for full buffer, including space for trailing EOB's. */\n"
    "	n = len + 2;\n"
    "	buf = Core::new_string( n );\n"
    "\n"
    "	for ( i = 0; i < len; ++i )\n"
    "		buf[i] = bytes[i];\n"
    "\n"
    "	buf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;\n"
    "\n"
    "	b = yy_scan_buffer( buf, n );\n"
    "	if ( ! b )\n"
    "		YY_FATAL_ERROR( \"bad buffer in yy_scan_bytes()\" );\n"
    "\n"
    "	/* It's okay to grow etc. this buffer, and we should throw it\n"
    "	 * away when we're done.\n"
    "	 */\n"
    "	b->yy_is_our_buffer = 1;\n"
    "\n"
    "	return b;\n"
    "	}\n"
    "#endif\n"
    "\n"
    "\n"
    "#ifndef YY_NO_PUSH_STATE\n"
    "static void yy_push_state( int new_state ) {\n"
    "  if ( yy_start_stack_ptr >= yy_start_stack_depth ) {\n"
    "    yy_start_stack_depth += YY_START_STACK_INCR;\n"
    "\n"
    "    if ( ! yy_start_stack )\n"
    "      yy_start_stack = new {for i < yy_start_stack_depth : 0};\n"
    "    else\n"
    "      yy_start_stack = new {for i < yy_start_stack_depth :\n"
    "                            (i < yy_start_stack.size) ? yy_start_stack[i] : 0};\n"
    "  }\n"
    "\n"
    "  yy_start_stack[yy_start_stack_ptr++] = YY_START;\n"
    "\n"
    "  BEGIN(new_state);\n"
    "}\n"
    "#endif\n"
    "\n"
    "\n"
    "#ifndef YY_NO_POP_STATE\n"
    "static void yy_pop_state()\n"
    "	{\n"
    "	if ( --yy_start_stack_ptr < 0 )\n"
    "		YY_FATAL_ERROR( \"start-condition stack underflow\" );\n"
    "\n"
    "	BEGIN(yy_start_stack[yy_start_stack_ptr]);\n"
    "	}\n"
    "#endif\n"
    "\n"
    "\n"
    "#ifndef YY_NO_TOP_STATE\n"
    "static int yy_top_state()\n"
    "	{\n"
    "	return yy_start_stack[yy_start_stack_ptr - 1];\n"
    "	}\n"
    "#endif\n"
    "\n"
    "#ifndef YY_EXIT_FAILURE\n"
    "#define YY_EXIT_FAILURE 2\n"
    "#endif\n"
    "\n"
    "static void yy_fatal_error( yyconst char msg[] )\n"
    "	{\n"
    "	fprintf( stderr, \"%s\\n\", msg );\n"
    "	exit( YY_EXIT_FAILURE );\n"
    "	}\n"
    "\n"
    "\n"
    "/* Redefine yyless() so it works in section 3 code. */\n"
    "\n"
    "#undef yyless\n"
    "#define yyless(n) \\\n"
    "	do \\\n"
    "		{ \\\n"
    "		/* Undo effects of setting up yytext. */ \\\n"
    "		yytext[yyleng] = yy_hold_char; \\\n"
    "		yy_c_buf_p = yytext + n; \\\n"
    "		yy_hold_char = *yy_c_buf_p; \\\n"
    "		*yy_c_buf_p = '\\0'; \\\n"
    "		yyleng = n; \\\n"
    "		} \\\n"
    "	while ( 0 )\n"
    "\n"
    "\n"
    "/* Internal utility routines. */\n"
    "\n"
    "#ifndef yytext_ptr\n"
    "static void yy_flex_strncpy( char ?s1, yyconst char ?s2, int n )\n"
    "	{\n"
    "	register int i;\n"
    "	for ( i = 0; i < n; ++i )\n"
    "		s1[i] = s2[i];\n"
    "	}\n"
    "#endif\n"
    "\n"
    "#ifdef YY_NEED_STRLEN\n"
    "static int yy_flex_strlen( yyconst char ?s )\n"
    "	{\n"
    "	register int n;\n"
    "	for ( n = 0; s[n]; ++n )\n"
    "		;\n"
    "\n"
    "	return n;\n"
    "	}\n"
    "#endif\n"
    "\n"
    "\n"
    "#if YY_MAIN\n"
    "int main(int argc, char ??argv)\n"
    "	{\n"
    "	yylex();\n"
    "	return 0;\n"
    "	}\n"
    "#endif\n"
    ;

  using Core;
  using List;
  using Arg;
  static list_t<stringptr_t> flexargs = NULL;
  static void add_flexarg(string_t<`H> s) {
    flexargs = new List(new s,flexargs);
  }
  static const char ?other = NULL;
  static void add_other(string_t<`H> s) {
    other = s; // remember in case we need to make up an output file name
    add_flexarg(s);
  }
  static const char ?skeletonfile = NULL;
  static void add_skeleton(const char ?s) {
    let len = strlen(s);
    if (len <= 2) return;
    skeletonfile = (string_t)substring(s,2,len-2);
  }
  static const char ?finaloutfile = NULL;
  static void add_finaloutfile(const char ?s) {
    let len = strlen(s);
    if (len <= 2) return;
    finaloutfile = (string_t)substring(s,2,len-2);
  }

  int main(int argc, string_t<`H> ?`H argv) {

    Arg::speclist_t<`H,`H> options =
      list(new $("-S",true,"<file>",
                 new Flag_spec(add_skeleton),
                 "Use skeleton <file> instead of the default skeleton"),
           new $("-o",true,"<file>",
                 new Flag_spec(add_finaloutfile),
                 "Put the output in <file>"),
           /* The remaining options are just added to flexargs */
           new $("-",true,"",
                 new Flag_spec(add_flexarg),
                 "")
           );

    Arg::parse(options, add_other, "Options:", argv);

    let flexargstring = str_sepstr(rev(flexargs), " ");

    if (!other) {
      fprintf(stderr,"cycflex: no input file specified\n");
    }
    if (!finaloutfile)
      finaloutfile = strconcat(Filename::chop_extension(other), ".cyc");

    FILE *maybe;
    FILE @in_file;
    FILE @out_file;

    const char *tmpskeletonfile = NULL;
    const char ?theskeletonfile = NULL;
    if (skeletonfile) {
      theskeletonfile = skeletonfile;
    }
    else {
      /* Put the skeleton in a temp file */
      tmpskeletonfile = strdup((const char *)tmpnam(NULL));
      if (tmpskeletonfile) {
	maybe = fopen(tmpskeletonfile,"w");
	if (!maybe) {
	  fprintf(stderr,"cycflex: could not open temp file for skeleton\n");
	  exit(1);
	}
      }
      else {
	fprintf(stderr,"cycflex: tmpnam failed\n");
	exit(1);
      }
      out_file = (FILE@)maybe;
      fputs(skeleton,out_file);
      fclose(out_file);
      theskeletonfile = tmpskeletonfile;
    }
    
    /* Run flex */
    let flexoutfile = strdup((const char @)tmpnam(NULL));
    let cmd = (const char @)aprintf("flex -S%s -o%s %s",
                      theskeletonfile,
                      flexoutfile,
                      flexargstring);
    if (system(cmd) != 0) {
      fprintf(stderr,"cycflex: error running flex\n");
      if (tmpskeletonfile) remove(tmpskeletonfile);
      exit(1);
    }
    /* Mangle the output of flex */
    maybe = fopen(flexoutfile,"r");
    if (!maybe) {
      fprintf(stderr,"cycflex: can't read flex output\n");
      if (tmpskeletonfile) remove(tmpskeletonfile);
      exit(1);
    }
    in_file = (FILE@)maybe;
    let l = Lexing::from_file(in_file);
    mangle_out = fopen((const char @)finaloutfile,"w");
    if (!mangle_out) {
      fprintf(stderr,"cycflex: can't open %s\n",finaloutfile);
      if (tmpskeletonfile) remove(tmpskeletonfile);
      remove(flexoutfile);
      exit(1);
    }
    while (mangle(l))
      /* skip */;
    fclose(in_file);
    fclose((FILE @)mangle_out);

    if (tmpskeletonfile) remove(tmpskeletonfile);
    remove(flexoutfile);

    return 0;
  }
}



