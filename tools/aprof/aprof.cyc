/* Allocation profiler
   Copyright (C) 2001 Greg Morrisett, AT&T
   This file is part of the Cyclone compiler.

   The Cyclone compiler is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   The Cyclone compiler is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with the Cyclone compiler; see the file COPYING. If not,
   write to the Free Software Foundation, Inc., 59 Temple Place -
   Suite 330, Boston, MA 02111-1307, USA. */

#include <core.h>
#include <string.h>
#include <stdlib.h>
#include "aprof_event.h"

namespace Aprof {
  bool verbose = true;
  bool use_events = false;
}

using Aprof;

static void usage(string_t<`H> argv0) __attribute__((noreturn)) {
  fprintf(stderr,
          "usage: %s [options] [profile]\n"
          "  by default, generates an allocation summary for file amon.out\n"
          "  Options:\n"
          "  -g     generate a jgraph graph of cumulative memory usage over time\n"
          "  -gp    generate a gnuplot graph of cumulative memory usage over time\n"
          "  -svg   generate an svg graph of cumulative memory usage over time\n"
          "  -svg2  generate an svg graph of exact memory usage over time\n"
          "  -svg3  generate an svg graph of object lifetimes\n"
          "  -sizes generate a report on object sizes\n"
          "  -q     quiet output\n"
          "  -cd X  use X as a clock divisor\n"
          "  -ev    use allocation events instead of clocks\n"
          "  -d X   show dynamic regions that are >= X (a fraction) of the total heap (def=%g)\n",
          argv0,
          dyn_threshhold);
  exit(1);
}

int do_gnuplot = 0;

int main(int argc, string_t<`H> ?`H argv) {
  bool do_graph = false;
  bool do_newgraph = false;
  bool do_svg = false;
  bool do_svg2 = false;
  bool do_svg3 = false;
  bool do_sizes = false;
  unsigned int clockdivisor_override = 0;
  string_t<`H> file;

  int argn = 1;
  while ( argn < argc && argv[argn][0] == '-' )  {
    if ( strcmp( argv[argn], "-?" ) == 0 )
      usage(argv[0]);
    else if ( strcmp( argv[argn], "-g" ) == 0 ) {
      do_graph = true;
    }
    else if ( strcmp( argv[argn], "-gp" ) == 0 ) {
      do_graph = true;
      do_gnuplot = true;
    }
    else if ( strcmp( argv[argn], "-ngp" ) == 0 ) {
      do_newgraph = true;
      do_gnuplot = true;
    }
    else if ( strcmp( argv[argn], "-svg" ) == 0 ) {
      do_svg = true;
    }
    else if ( strcmp( argv[argn], "-svg2" ) == 0 ) {
      do_svg2 = true;
    }
    else if ( strcmp( argv[argn], "-svg3" ) == 0 ) {
      do_svg3 = true;
    }
    else if ( strcmp( argv[argn], "-sizes" ) == 0 ) {
      do_sizes = true;
    }
    else if ( strcmp( argv[argn], "-q" ) == 0 ) {
      verbose = false;
    }
    else if ( strcmp( argv[argn], "-d" ) == 0 && argn+1 < argc ) {
      dyn_threshhold = strtod(strdup(argv[++argn]),NULL);
    }
    else if ( strcmp( argv[argn], "-a" ) == 0 ) {
      all_dynregions = true;
    }
    else if ( strcmp( argv[argn], "-cd" ) == 0 && argn+1 < argc ) {
      clockdivisor_override = atoi(argv[++argn]);
    }
    else if ( strcmp( argv[argn], "-ev" ) == 0 ) {
      use_events = true;
    }
    else
      usage(argv[0]);
    ++argn;
  }
  if ( argn != argc )
    if ( argn == (argc-1) )
      file = argv[argn];
    else
      usage(argv[0]);
  else
    file = "amon.out";

#ifdef __linux__
  clockdivisor = 10000;
#endif
#ifdef __APPLE__
  clockdivisor = 1;
#endif
  if (clockdivisor_override)
    // since != 0 we won't divide by 0 later
    clockdivisor = clockdivisor_override;

  int ret;
  if (do_graph)
    ret = generate_graph(file);
  else if (do_newgraph)
    ret = generate_newgraph(file);
  else if (do_svg)
    ret = generate_svg(file);
  else if (do_svg2)
    ret = generate_svg2(file);
  else if (do_svg3)
    ret = generate_svg3(file);
  else if (do_sizes)
    ret = generate_sizes(file);
  else
    ret = generate_summary(file);
  return ret;
}
