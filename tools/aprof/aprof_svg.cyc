/* SVG output for allocation profiler
   Copyright (C) 2001 Greg Morrisett, AT&T
   This file is part of the Cyclone compiler.

   The Cyclone compiler is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   The Cyclone compiler is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with the Cyclone compiler; see the file COPYING. If not,
   write to the Free Software Foundation, Inc., 59 Temple Place -
   Suite 330, Boston, MA 02111-1307, USA. */

#include <stdio.h>
#include <core.h>
#include <string.h>
#include <list.h>
#include <stdlib.h>
#include <array.h>
#include <fn.h>
#include <assert.h>
#include <hashtable.h>
#include <set.h>
#include <xarray.h>
#include "aprof_event.h"

using Core;
using List;
using Aprof;
using Fn;

//#define DEBUG_ME

/* Dimensions of the graph on the printed page, in points (pt).
   The title, legend, etc., appear outside these dimensions. */
#define WIDTH 300.0
#define HEIGHT 300.0

/* Resolution of the graph: number of divisions in the x dimension.
   Increasing resolution will result in a more accurate graph.
   We limit resolution because SVG viewers in practice cannot
   handle objects with too many points.  "Too many" is
   about 40,000 for Adobe Illustrator, for example.  Also,
   limiting the resolution controls the size of the SVG
   output and the internal data structures of aprof. */
#define XMAXRES 1000
static unsigned int xres = XMAXRES;
double scale = 1.0;
static void compute_resolution() {
  if (max_time<XMAXRES) xres = max_time+1; else xres = XMAXRES;
  scale = ((double)xres)/((double)max_time+1);
}

typedef unsigned int coord_t;

struct Curve {
  const char ?name;
  /* updated in phase 1 */
  double area;  // would like to use long long, but can't printf
  unsigned int max_y;
  unsigned int num_points;
  /* updated in phase 2 */
  coord_t ?points;
  /* auxilliary data for both phases */
  unsigned int last_x;
  unsigned int last_y;
};
typedef struct Curve @curve_t;
static curve_t
curve_init(const char ?`H name) {
  return new Curve(name,0,0,0,NULL,0,0);
}

// Data that is maintained/updated at each profiled event
struct ProcEnv {
  curve_t mem_total;
  curve_t heap_live;
  curve_t unique_live;
  curve_t refcnt_live;
  curve_t other_live;
};

/* Nicely format f as a number of bytes */
static char ?print_bytes(double f) {
  $(double,const char ?) powers[] =
    { $(1099511627776.0,"TB"),
      $(1073741824.0,"GB"),
      $(1048576.0,"MB"),
      $(1024.0,"KB") };
  const char ?units = "B";

  for (let i = 0; i < numelts(powers); i++) {
    if (f > powers[i][0]) {
      units = powers[i][1];
      f = f/powers[i][0];
      break;
    }
  }
  /* Print >= 3 digits of precision */
  if (f < 10.0)
    return aprintf("%.2f %s",f,units);
  else if (f < 100.0)
    return aprintf("%.1f %s",f,units);
  else
    return aprintf("%.0f %s",f,units);
}

/////////////////////////////// EVENT PROCESSING

/* Table for remembering how much was allocated at an address */
static struct Hashtable::Table<unsigned int,$(const char ?,unsigned int)@> *
  allocation_at_address_table = NULL;
/* Table for remembering how much was allocated into a region */
static struct Hashtable::Table<const char ?@,unsigned int> *
  allocation_in_region_table = NULL;
/* Array of events -- (region name, x, delta_y) pairs */
static struct Xarray::Xarray<$(const char ?,clock_t,int)@> *events = NULL;

static int uint_cmp(unsigned int i, unsigned int j) {
  return (i<j)?(-1):((i>j)?1:0);
}
static int uint_hash(unsigned int i) {
  return (int)i;
}
static void
init_globals() {
  allocation_at_address_table =
    Hashtable::create(101,uint_cmp,uint_hash);
  allocation_in_region_table =
    Hashtable::create(101,strptrcmp,Hashtable::hash_stringptr);
  events = Xarray::create_empty();
}

static list_t<$(clock_t,const char ?)@> mark_list = NULL;

static bool inside_gc = false;
static clock_t gc_start_time = 0;
static clock_t gc_latest_time = 0;
static list_t<$(clock_t,clock_t)@> gc_list = NULL;

/* phase 1 */
static void mark_gc(clock_t x) {
  if (!inside_gc) {
    gc_start_time = gc_latest_time = x;
    inside_gc = true;
  }
  else
    gc_latest_time = x;
}
static void mark_gc_over() {
  if (inside_gc) {
    gc_list = new List(new $(gc_start_time,gc_latest_time),gc_list);
    inside_gc = false;
  }
}
static void mark_delta(curve_t b, clock_t x, int delta_y) {
  if (delta_y == 0) return;
  unsigned int y = b->last_y + delta_y;
  b->num_points++;
  Xarray::add((_@)events,new $(b->name,x,delta_y));
  //  unsigned int x = Xarray::length((_@)events);
  b->area += ((double)(x - b->last_x)) * b->last_y;
  if (b->max_y < y) b->max_y = y;
#ifdef DEBUG_ME
  fprintf(stderr,"%s = %d @ %d\n",b->name,y,x);
  fprintf(stderr,"%s->area += %s*events\n",
          b->name,
          print_bytes(((double)(x - b->last_x)) * b->last_y));
#endif
  b->last_x = x;
  b->last_y = y;
}
static void mark_point(curve_t b, clock_t x, unsigned int y) {
  mark_delta(b, x, (int)(y - b->last_y));
}
static void mark_finish(curve_t b, clock_t x) {
  b->area += ((double)(x - b->last_x)) * b->last_y;
#ifdef DEBUG_ME
  const char ?CE = "clocks";
  if (use_events) CE = "events";
  fprintf(stderr,"%s->area += %s*%s\n",
          b->name,
          print_bytes(((double)(x - b->last_x)) * b->last_y),
          CE);
#endif
  b->last_x = 0;
  b->last_y = 0;
  b->points = new {for i < xres: 0}; // xres must be set up before calling
}
static bool omitted(const char ?x) {
  bool result = false;
  for (let l = omits; l != NULL; l = l->tl)
    if (strcmp(x,*(l->hd)) == 0) {
      result = true;
      break;
    }
  return result;
}
static void update_heap_stats(struct ProcEnv @env,
                              clock_t x,
			      struct RegionStats @s) {
  if (!omitted("reserved"))
    mark_point(env->mem_total,x,s->region_size_bytes);
}

/* phase 2 */
static void add_delta(curve_t b, unsigned int unscaled_x, int delta_y) {
  clock_t x = (clock_t)(unscaled_x * scale);
  unsigned int y = b->last_y + delta_y;
  for (int i = b->last_x + 1; i <= x; i++) {
    b->points[i] = b->last_y;
  }
  b->points[x] = y;
  b->last_x = x;
  b->last_y = y;
}
static void add_finish(curve_t b, unsigned int unscaled_x) {
  clock_t x = (clock_t)(unscaled_x * scale);
  //  fprintf(stderr,"Finishing %u at scale %f giving %u\n",
  //          unscaled_x,scale,x);
  if (b->last_x < x)
    for (int i = b->last_x+1; i<=x; i++)
      b->points[i] = b->last_y;
}
static void gc_scale() {
  for (let l = gc_list; l != NULL; l = l->tl) {
    let &$(*x1,*x2) = l->hd;
    *x1 = (clock_t)(*x1 * scale);
    *x2 = (clock_t)(*x2 * scale);
  }
}



static int percent(unsigned int numerator, unsigned int denominator) {
  return (int)((numerator * 100.0)/denominator);
}

static void output_comment(const char ?s) {
  printf("<!-- %s -->\n",s);
  if (verbose)
    fprintf(stderr,"%s\n",s);
}

static void comment_curve_stats(curve_t b) { // for debugging
  const char ?CE = "clocks";
  if (use_events) CE = "events";
  output_comment(aprintf("%s area: %s*%s\tmax_y: %u",b->name,
                         print_bytes(b->area),CE,b->max_y));
}

static unsigned int bytes_reclaim_heap = 0;
static unsigned int num_reclaim_heap = 0;
static unsigned int bytes_reclaim_unique = 0;
static unsigned int num_reclaim_unique = 0;
static unsigned int bytes_reclaim_refcnt = 0;
static unsigned int num_reclaim_refcnt = 0;
static unsigned int bytes_freed_other = 0;

static bool proc_event(struct ProcEnv @env, aprof_event_t event) {
  switch (event) {
  case &CreateE(CreateEvent(time,_,rname,*rstats)):
    mark_gc_over();
    let rnameptr = new rname;

    assert(strcmp("unique",rname));
    assert(strcmp("heap",rname));
    assert(strcmp("refcnt",rname));

    update_heap_stats(env,time,rstats); // these rstats are for GC
    break;

  case &AllocE(AllocEvent(time,_,rname,count,*rstats,addr)):
    mark_gc_over();
    num_alloc_events++;
    if (!strcmp(rname,"unique")) {
      if (!omitted("unique"))
        mark_delta(env->unique_live,time,count);
      update_heap_stats(env,time,rstats);
      if (count>0) {
        // remember count for addr in case gc reclaims addr
        Hashtable::insert((_@)allocation_at_address_table,
                          addr,new $("unique",(unsigned int)count));
      }
      else {
        // gc did not reclaim, this is ufree, forget addr/count
        Hashtable::remove((_@)allocation_at_address_table, addr);
      }
    }
    else if (!strcmp(rname,"refcnt")) {
      if (!omitted("refcnt"))
        mark_delta(env->refcnt_live,time,count);
      update_heap_stats(env,time,rstats);
      if (count>0) {
        // remember count for addr in case gc reclaims addr
        Hashtable::insert((_@)allocation_at_address_table,
                          addr,new $("refcnt",(unsigned int)count));
      }
      else {
        // gc did not reclaim, this is free, forget addr/count
        Hashtable::remove((_@)allocation_at_address_table, addr);
      }
    }
    else if (!strcmp(rname,"heap")) {
      if (!omitted("heap"))
        mark_delta(env->heap_live,time,count);
      update_heap_stats(env,time,rstats);
      Hashtable::insert((_@)allocation_at_address_table,
                        addr,new $("heap",(unsigned int)count));
    }
    else {
      if (!omitted("other"))
        mark_delta(env->other_live,time,count);
      let rname_p = new rname;
      unsigned int x = 0;
      try {
        x = Hashtable::lookup((_@)allocation_in_region_table, rname_p);
        Hashtable::remove((_@)allocation_in_region_table, rname_p);
      }
      catch {
      case &Not_found: break;
      }
      Hashtable::insert((_@)allocation_in_region_table,rname_p,x+count);
      // The rstats give info about the "other" region, not the
      // memory managed by the GC -- so don't update that.
      // update_heap_stats(env,time,rstats);
    }
    break;

  case &ReclaimE(ReclaimEvent(time,addr)):
    mark_gc(time);
    try {
      let &$(rname,count) =
        Hashtable::lookup((_@)allocation_at_address_table,addr);
      Hashtable::remove((_@)allocation_at_address_table,addr);
      int delta_y = -1*((int)count);
      if (!omitted("unique") && strcmp("unique",rname) == 0) {
        // this is a unique pointer object that got garbage collected
        mark_delta(env->unique_live,time,delta_y);
        bytes_reclaim_unique += count;
      }
      if (!omitted("refcnt") && strcmp("refcnt",rname) == 0) {
        // this is a refcounted pointer object that got garbage collected
        mark_delta(env->refcnt_live,time,delta_y);
        bytes_reclaim_refcnt += count;
      }
      else if (!omitted("heap") && strcmp("heap",rname) == 0) {
        mark_delta(env->heap_live,time,delta_y);
        bytes_reclaim_heap += count;
      }
    }
    catch {
    case &Not_found:
      fprintf(stderr,
	      "error: reclaim event %x without (remembered) allocation\n",
              addr);
      break;
    }
    break;

  case &FreeE(FreeEvent(time,rname,*rstats)):
    assert(strcmp("unique",rname));
    assert(strcmp("heap",rname));
    assert(strcmp("refcnt",rname));

    mark_gc_over();
    let rname_p = new rname;
    unsigned int x = 0;
    try {
      x = Hashtable::lookup((_@)allocation_in_region_table,rname_p);
      Hashtable::remove((_@)allocation_in_region_table,rname_p);
    }
    catch {
    case &Not_found: break; // region created but not allocated into
    }
    if (!omitted("other"))
      mark_delta(env->other_live,time,-x);
    update_heap_stats(env,time,rstats);
    break;

  case &ResizeE(ResizeEvent(time,rname,count,*rstats)):
    assert(strcmp("unique",rname));
    assert(strcmp("heap",rname));
    assert(strcmp("refcnt",rname));

    mark_gc_over();
    // The count is the new size of the region -- ignore
    // mark_delta(env->other_live,time,count);

    // rstats measures GC
    update_heap_stats(env,time,rstats);
    break;

  case &GcE(GcEvent(time,n,*rstats)):
    mark_gc_over();
    update_heap_stats(env,time,rstats);
    break;

  case &GcAddToHeapE(GcAddToHeapEvent(time,addr,amt,*rstats)):
    mark_gc_over();
    update_heap_stats(env,time,rstats);
    break;

  case &MarkE(MarkEvent(time,m)):
    mark_list = new List(new $(time,m), mark_list);
    break;

  }

  return true;
}

//////////////////////////////////////////////////////////////////////
static list_t<curve_t> all_curves;
static void phase2($(const char ?,clock_t,int) @z) {
  let &$(name,x,delta_y) = z;
  if (strcmp(name,"reserved") == 0) {
    for (let l = all_curves; l != NULL; l = l->tl) {
      let b = l->hd;
      if (strcmp("reserved",b->name) == 0) {
        add_delta(b,x,delta_y);
        return;
      }
    }
  }
  else {
    /* increment the curve identified by name, as well as
       all subsequent curves in the list all_curves,
       except for the reserved curve */
    let saw_name = 0;
    for (let l = all_curves; l != NULL; l = l->tl) {
      let b = l->hd;
      if (!saw_name && strcmp(b->name,name) == 0)
        saw_name = 1;
      if (saw_name && strcmp(b->name,"reserved") != 0)
        add_delta(b,x,delta_y);
    }
  }
}
//////////////////////////////////////////////////////////////////////

static int curve_cmp(curve_t x, curve_t y) {
  if (x->area < y->area) return -1;
  else if (x->area == y->area) return 0;
  else return 1;
}

static const char ?colors[] =
//  {"red", "orange", "yellow", "green", "blue", "indigo", "violet" };
  {
    "rgb(148,208,84)",
    "rgb(0,104,96)",
    "rgb(0,101,0)",
    "rgb(88,80,0)",
    "rgb(0,67,58)",
    "rgb(0,56,0)",
    "rgb(0,0,208)"
  };

static const char ?color(unsigned int i) {
  if (i < numelts(colors)) return colors[i];
  fprintf(stderr,"aprof: ran out of colors (<%u)\n",i);
  exit(1);
}

#define SEPARATION 15
static void output_legend(list_t<$(const char ?,const char ?)@> items) {
  // items is a list of (name,color) pairs
  int i = 0;
  for (let l = items; l != NULL; i++, l = l->tl) {
    printf("<rect x='0' y='%f' width='%f' height='%f'"
           " fill='%s' stroke='none' opacity='0.7'/>\n",
           i*SEPARATION-(0.125*SEPARATION),
           (0.75*SEPARATION),
           (0.75*SEPARATION),
           (*l->hd)[1]);
    printf("<text x='%f' y='%f' fill='black' text-anchor='start'>%s</text>\n",
           SEPARATION+5,
           i*SEPARATION+(0.5*SEPARATION),
           (*l->hd)[0]);
  }
}

static void output_curves(int xres, int num_curves, unsigned int max_y, coord_t ?? yv) {

  printf("<g transform='translate(0,%f) scale(%.12f,%.12f)'>\n",
         HEIGHT,
         WIDTH / xres,
         -HEIGHT / max_y);  // negative y scale so coords are flipped

  /* the fills */
  // bottom curve first...
  printf("<path d='M");
  for (int x=0; x < xres; x++) {
    printf("%d,%d ",x,yv[0][x]);
  }
  printf("%d,0 0,0 ",xres-1); // bottom border is x axis
  printf("' stroke='none' fill='%s' opacity='0.7'/>\n",color(0));

  // ... then the other curves, going up
  for (int i=1; i < num_curves; i++) {
    printf("<path d='M");
    // top border is the curve
    for (int x=0; x < xres; x++) {
      printf("%d,%d ",x,yv[i][x]);
    }
    // bottom border is the previous curve
    for (int x=(xres-1); x >= 0; x--) {
      printf("%d,%d ",x,yv[i-1][x]);
    }
    printf("0,%d ",yv[i][0]);
    printf("' stroke='none' fill='%s' opacity='0.7'/>\n",color(i));
  }

  /* the garbage collections */
  gc_scale();
  for (let l = gc_list; l != NULL; l = l->tl) {
    let &$(x1,x2) = l->hd;
    printf("<rect x='%d' y='0' width='%d' height='%d'"
           " fill='black' stroke='none' opacity='0.3'/>\n",
           x1,x2-x1,max_y);
  }

  printf("<!-- marks -->\n");
  for (let l = mark_list; l != NULL; l = l->tl) {
    let &$(time,m) = l->hd;
    printf("<path d='M%u,0 v%u' stroke='red' fill='none' opacity='.7'/>\n",
           time,max_y);
  }

  printf("</g>\n");

  /* the lines */
  /*
  for (int i=0; i < num_curves; i++) {
    printf("<path d='M");
    for (int x=0; x < xres; x++) {
     printf("%d,%d ",x*10,100-yv[i][x]);
    }
    printf("' stroke='black' stroke-linecap='round' stroke-linejoin='round' fill='none'/>\n");
  }
  */

  /* x and y axes */
  /*
  printf("<path d='M0,0 0,100 100,100' fill='none'"
         " stroke='black' stroke-linecap='round'/>\n");
  // y axis tick marks
  for (int y=0; y <= 100; y += 10) {
    printf("<line x1='-3' y1='%d' x2='0' y2='%d'"
           " stroke='black' stroke-linecap='round'/>\n",
           100-y,100-y);
    printf("<text x='-8' y='%d' fill='black' text-anchor='end'>%d</text>\n",
           100-y,
           y);
  }
  // x axis tick marks
  for (int x=0; x <= 100; x += 10)
    printf("<line x1='%d' y1='100' x2='%d' y2='103'"
           " stroke='black' stroke-linecap='round'/>\n",x,x);
  */
}

static void comment_stats() {
  output_comment(aprintf("Total events:\t%u",
                         (num_create_events+num_alloc_events
                          +num_free_events+num_reclaim_events
                          +num_resize_events+num_gc_events)));
  output_comment(aprintf("\tCreate:\t%u",num_create_events));
  output_comment(aprintf("\tAlloc:\t%u",num_alloc_events));
  output_comment(aprintf("\tFree:\t%u",num_free_events));
  output_comment(aprintf("\tReclaim:\t%u",num_reclaim_events));
  output_comment(aprintf("\tResize:\t%u",num_resize_events));
  output_comment(aprintf("\tGc:\t%u",num_gc_events));
  if (num_alloc_heap) {
    output_comment(aprintf("%u objects (%u bytes) allocated in `H",
                           num_alloc_heap, bytes_alloc_heap));
    output_comment(aprintf("%u objects [%d%%] (%u bytes [%d%%]) collected from `H",
                           num_reclaim_heap,
                           percent(num_reclaim_heap,num_alloc_heap),
                           bytes_reclaim_heap,
                           percent(bytes_reclaim_heap,bytes_alloc_heap)));
  }
  if (num_alloc_unique) {
    output_comment(aprintf("%u objects (%u bytes) allocated in `U",
                           num_alloc_unique, bytes_alloc_unique));
    output_comment(aprintf("%u objects [%d%%] (%u bytes [%d%%]) freed from `U",
                           num_freed_unique,
                           percent(num_freed_unique,num_alloc_unique),
                           bytes_freed_unique,
                           percent(bytes_freed_unique,bytes_alloc_unique)));
    output_comment(aprintf("%u objects [%d%%] (%u bytes [%d%%]) collected from `U",
                           num_reclaim_unique,
                           percent(num_reclaim_unique,num_alloc_unique),
                           bytes_reclaim_unique,
                           percent(bytes_reclaim_unique,bytes_alloc_unique)));
  }
  if (num_alloc_refcnt) {
    output_comment(aprintf("%u objects (%u bytes) allocated in `RC",
                           num_alloc_refcnt, bytes_alloc_refcnt));
    output_comment(aprintf("%u objects [%d%%] (%u bytes [%d%%]) freed from `RC",
                           num_freed_refcnt,
                           percent(num_freed_refcnt,num_alloc_refcnt),
                           bytes_freed_refcnt,
                           percent(bytes_freed_refcnt,bytes_alloc_refcnt)));
    output_comment(aprintf("%u objects [%d%%] (%u bytes [%d%%]) collected from `RC",
                           num_reclaim_refcnt,
                           percent(num_reclaim_refcnt,num_alloc_refcnt),
                           bytes_reclaim_refcnt,
                           percent(bytes_reclaim_refcnt,bytes_alloc_refcnt)));
  }
  if (num_alloc_other) {
    output_comment(aprintf("%u objects (%u bytes) allocated in other regions",
                           num_alloc_other, bytes_alloc_other));
    output_comment(aprintf("%u bytes [%d%%] freed from other regions",
                           bytes_freed_other,
                           percent(bytes_freed_other,bytes_alloc_other)));
  }
}

namespace Aprof;

int generate_svg(string_t<`H> file) {
  struct ProcEnv @`H env =
    new ProcEnv{.mem_total = curve_init("reserved"),
		.heap_live = curve_init("heap"),
		.unique_live = curve_init("unique"),
		.refcnt_live = curve_init("refcnt"),
		.other_live = curve_init("other")};

  init_globals();

  /* Phase 1: process the allocation log file (amon.out) */
  fn_t clos = make_fn(proc_event,env);
  int ret = proc_file(file,clos);
  if (ret != 0) return ret;
  
  compute_resolution();

  if (!omitted("reserved"))
    mark_finish(env->mem_total,max_time);
  if (!omitted("heap"))
    mark_finish(env->heap_live,max_time);
  if (!omitted("unique"))
    mark_finish(env->unique_live,max_time);
  if (!omitted("refcnt"))
    mark_finish(env->refcnt_live,max_time);
  if (!omitted("other"))
    mark_finish(env->other_live,max_time);

  /* sort the curves by area, with bigger curves to be printed
     above smaller curves */
  if (!omitted("reserved") && env->mem_total->area > 0.0)
    all_curves = new List(env->mem_total,all_curves);
  if (!omitted("heap") && env->heap_live->area > 0.0)
    all_curves = new List(env->heap_live,all_curves);
  if (!omitted("unique") && env->unique_live->area > 0.0)
    all_curves = new List(env->unique_live,all_curves);
  if (!omitted("refcnt") && env->refcnt_live->area > 0.0)
    all_curves = new List(env->refcnt_live,all_curves);
  if (!omitted("other") && env->other_live->area > 0.0)
    all_curves = new List(env->other_live,all_curves);
  all_curves = merge_sort(curve_cmp,all_curves);

  /* Phase 2: compute the curves */
  Xarray::iter(phase2,(_@)events);
  for (let l = all_curves; l != NULL; l = l->tl) {
    add_finish(l->hd,max_time);
  }
  unsigned int max_y = 0;
  for (let l = all_curves; l != NULL; l = l->tl) {
    if (strcmp(l->hd->name,"reserved") == 0) {
      max_y = l->hd->max_y; break;
    }
    max_y += l->hd->max_y;
  }

  double memory_footprint = env->mem_total->area;
  double data_footprint =
    env->heap_live->area + env->unique_live->area
    + env->refcnt_live->area + env->other_live->area;
  let title = "";
  const char ?CE = "clocks";
  if (use_events) CE = "events";
  if (memory_footprint > 0.0)
    title =
      aprintf("Memory footprint %s*%s, data footprint %s*%s (%d%%)",
              print_bytes(memory_footprint),CE,
              print_bytes(data_footprint),CE,
              (int)((data_footprint * 100.0)/memory_footprint));
  else
    /* With -nogc we don't get measurement of memory footprint */
    title = aprintf("Data footprint %s*%s", print_bytes(data_footprint),CE);

  /* print the XML header */
  printf("<?xml version='1.0' encoding='ISO-8859-1'?>\n"
         "<!DOCTYPE svg PUBLIC '-//W3C//DTD SVG 1.0//EN'\n"
         " 'http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd'>\n");

  output_comment("Allocation profile produced by aprof");
  comment_stats();
  if (!omitted("reserved")) comment_curve_stats(env->mem_total);
  if (!omitted("heap")) comment_curve_stats(env->heap_live);
  if (!omitted("unique")) comment_curve_stats(env->unique_live);
  if (!omitted("refcnt")) comment_curve_stats(env->refcnt_live);
  if (!omitted("other")) comment_curve_stats(env->other_live);

  int num_curves = length(all_curves);
  coord_t ??zz = new {for i < num_curves: nth(all_curves,i)->points };
  output_comment(aprintf("max_time = %u, max_y = %u",max_time,max_y));

  /* start of svg stuff */
  printf("<svg xmlns='http://www.w3.org/2000/svg'\n"
         "     xmlns:xlink='http://www.w3.org/1999/xlink'>\n");

  /* print the curves and garbage collections */
  output_curves(xres,num_curves,max_y,zz);

  /* set up and print the legend */
  let namecolors = NULL;
  int i = 0;
  for (let l = all_curves; l != NULL; l = l->tl) {
    curve_t b = l->hd;
    if (strcmp("reserved",b->name) != 0) {
      let name = aprintf("%s %s*%s (%d%%)",b->name,
                         print_bytes(b->area),CE,
                         (int)((b->area * 100.0)/data_footprint));
      namecolors = new List(new $((const char ?)name,color(i++)),namecolors);
    }
    else
      namecolors = new List(new $("reserved",color(i++)),namecolors);
  }
  printf("<g transform='translate(%f,0)'>\n",WIDTH+20);
  output_legend(namecolors);
  printf("</g>\n");

  /* print the title of the graph */
  printf("<text x='%f' y='%f' text-anchor='middle'>%s</text>\n",
         WIDTH/2,HEIGHT+20,title);
  printf("</svg>\n");

  return 0;
}

/**********************************************************************/
/* Code to see how many points on a path can be handled by
   an SVG viewer.  For Adobe Illustrator it seems to be about
   30,000.
*/
/*
void try2() {
  printf("<?xml version='1.0' encoding='ISO-8859-1'?>\n"
         "<!DOCTYPE svg PUBLIC '-//W3C//DTD SVG 1.0//EN'\n"
         " 'http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd'>\n"
         "<svg xmlns='http://www.w3.org/2000/svg'\n"
         "     xmlns:xlink='http://www.w3.org/1999/xlink'>\n");

  printf("<g transform='scale(0.005)'>\n");
  printf("<path d='M");
  for (int x=0; x <= 40000; x++) {
    printf("%d,%d ",x,f(x));
  }
  printf("20000,0 0,0 ");
  printf("' stroke='none' fill='blue' opacity='0.7'/>\n");

  printf("</g>\n");
  printf("</svg>\n");
}

int main() {
  try2();
  return 0;
}
*/

/* Map address to time and amount of allocation */
static struct Hashtable::Table<unsigned int,$(const char ?,clock_t,unsigned int)@> *
  allocations_table = NULL;

/* Map region to addresses allocated in that region */
static struct Hashtable::Table<const char ?@,Set::set_t<unsigned int>> *
  regionaddresses_table = NULL;

/* Array of rects for later printing */
struct Rect {
  const char ?name;
  unsigned int gc_num;
  unsigned int x;
  unsigned int y;
  unsigned int width;
  unsigned int height;
};
typedef struct Rect @rect_t;
static struct Xarray::Xarray<rect_t> *rects = NULL;

static void
init_globals2() {
  allocations_table =
    Hashtable::create(101,uint_cmp,uint_hash);
  regionaddresses_table =
    Hashtable::create(101,strptrcmp,Hashtable::hash_stringptr);
  rects = Xarray::create_empty();
}
static unsigned int min_x;
static unsigned int max_x;
static unsigned int min_y;
static unsigned int max_y;
static bool first_rect = true;
static void add_rect(const char ?`H rname,
                     clock_t start_time,
                     unsigned int addr,
                     clock_t end_time,
                     unsigned int amount) {
  unsigned int x = (unsigned int)start_time;
  unsigned int y = addr;
  if (first_rect) {
    first_rect = false;
    min_x = x; // max_x computed by proc_file
    min_y = y;
    max_y = y+amount;
  }
  else {
    if (min_x > x) min_x = x; // max_x computed by proc_file
    if (min_y > y) min_y = y;
    if (max_y < y+amount) max_y = y+amount;
  }
  Xarray::add((_@)rects,
              new Rect{.name=rname,
                       .gc_num=num_gc_events,
                       .x=x,
                       .y=y,
                       .width=(unsigned int)(end_time - start_time),
                       .height=amount});
}
static void finish_rect(unsigned int addr,
                        $(const char ?,clock_t,unsigned int) @v) {
  clock_t end_time = max_x;
  let &$(rname,start_time,count) = v;
  if (strcmp(rname,"unique") == 0) {
    add_rect("unique",start_time,addr,end_time,count);
  }
  else if (strcmp(rname,"heap") == 0) {
    add_rect("heap",start_time,addr,end_time,count);
  }
}
static list_t<$(clock_t,unsigned int,unsigned int)@> gc_blocks = NULL;
static bool proc_event2(aprof_event_t event) {
  switch (event) {
  case &AllocE(AllocEvent(time,_,rname,count,*rstats,addr)):
    mark_gc_over();
    if (!strcmp(rname,"unique")) {
      if (count>0) {
        // remember count for addr in case gc reclaims addr
        Hashtable::insert((_@)allocations_table,
                          addr,new $("unique",time,
                                     (unsigned int)count));
      }
      else {
        // gc did not reclaim, this is ufree, forget addr/count

        try {
          let &$(_,start_time,_) =
            Hashtable::lookup((_@)allocations_table, addr);
          Hashtable::remove((_@)allocations_table, addr);
          add_rect("unique",start_time,addr,time,-count); // count<0
        }
        catch {
        case &Not_found: break;
        }
      }
    }
    else if (!strcmp(rname,"refcnt")) {
      // TODO
    }
    else if (!strcmp(rname,"heap")) {
      Hashtable::insert((_@)allocations_table, addr,
                        new $("heap",time,(unsigned int)count));
    }
    else {
      let rname_p = new rname;
      try {
        let aset = Hashtable::lookup((_@)regionaddresses_table, rname_p);
        Hashtable::remove((_@)regionaddresses_table, rname_p);
        Hashtable::insert((_@)regionaddresses_table, rname_p,
                          Set::insert(aset,addr));
        Hashtable::insert((_@)allocations_table, addr,
                          new $(rname,time,(unsigned int)count));
      }
      catch {
      case &Not_found:
        fprintf(stderr,
                "error: allocation into an unknown region %s\n",
                rname);
        break;
      }
    }
    break;

  case &ReclaimE(ReclaimEvent(time,addr)):
    mark_gc(time);
    try {
      let &$(rname,start_time,count) =
        Hashtable::lookup((_@)allocations_table, addr);
      Hashtable::remove((_@)allocations_table, addr);
      if (strcmp(rname,"unique") == 0) {
        // this is a unique pointer object that got garbage collected
        num_reclaim_unique++;
        bytes_reclaim_unique += count;
        add_rect("unique",start_time,addr,time,count);
      }
      else if (strcmp(rname,"heap") == 0) {
        num_reclaim_heap++;
        bytes_reclaim_heap += count;
        add_rect("heap",start_time,addr,time,count);
      }
    }
    catch {
    case &Not_found:
      fprintf(stderr,
	      "error: reclaim event %x without (remembered) allocation\n",
              addr);
      break;
    }
    break;

  case &CreateE(CreateEvent(time,_,rname,*rstats)):
    assert(strcmp("unique",rname));
    assert(strcmp("heap",rname));
    assert(strcmp("refcnt",rname));

    mark_gc_over();
    Hashtable::insert((_@)regionaddresses_table, new rname,
                      Set::empty(uint_cmp));
    break;

  case &FreeE(FreeEvent(time,rname,*rstats)):
    assert(strcmp("unique",rname));
    assert(strcmp("heap",rname));
    assert(strcmp("refcnt",rname));

    mark_gc_over();
    let rname_p = new rname;
    try {
      let aset = Hashtable::lookup((_@)regionaddresses_table, rname_p);
      Hashtable::remove((_@)regionaddresses_table, rname_p);
      let i = Set::make_iter(Core::heap_region,aset);
      unsigned int addr = 0;
      while (Iter::next(i,&addr)) {
        try {
          let &$(rname2,start_time,count) =
            Hashtable::lookup((_@)allocations_table, addr);
          Hashtable::remove((_@)allocations_table, addr);
          if (strcmp(rname,rname2) != 0) {
            fprintf(stderr,
                    "error: freed region %s seems to contain an allocation "
                    "from another region %s\n",
                    rname,rname2);
          }
          else {
            bytes_freed_other += count;
            add_rect("other",start_time,addr,time,count);
          }
        }
        catch {
        case &Not_found:
          fprintf(stderr,
                  "error: reclaim event %x without (remembered) allocation\n",
                  addr);
          break;
        }
      }
    }
    catch {
    case &Not_found:
      fprintf(stderr,
              "error: free of an unknown region %s\n",
              rname);
      break;
    }
    break;

  case &ResizeE(ResizeEvent(time,rname,count,*rstats)):
    assert(strcmp("unique",rname));
    assert(strcmp("heap",rname));
    assert(strcmp("refcnt",rname));

    mark_gc_over();
    break;

  case &GcE(GcEvent(time,n,*rstats)):
    mark_gc_over();
    break;

  case &GcAddToHeapE(GcAddToHeapEvent(time,addr,amt,*rstats)):
    gc_blocks = new List(new $(time,addr,amt), gc_blocks);
    if (first_rect) {
      first_rect = false;
      min_x = time; // max_x computed by proc_file
      min_y = addr;
      max_y = addr+amt;
    }
    else {
      if (min_x > time) min_x = time; // max_x computed by proc_file
      if (min_y > addr) min_y = addr;
      if (max_y < addr+amt) max_y = addr+amt;
    }
    break;

  case &MarkE(MarkEvent(time,m)):
    mark_list = new List(new $(time,m), mark_list);
    break;

  }

  return true;
}

static int num_colors = 0;
static list_t<$(const char ?,const char ?)@> color_map = NULL;
static const char ?color_of_region(const char ?`H rname) {
  const char ?c = NULL;
  if (color_map == NULL) {
    c = color(num_colors++);
    color_map = new List(new $(rname,c),NULL);
  }
  else for (let l = color_map; l != NULL; l = l-> tl) {
    if (strcmp((*l->hd)[0],rname) == 0)
      return ((*l->hd)[1]);
    if (l->tl == NULL) {
      c = color(num_colors++);
      l->tl = new List(new $(rname,c),NULL);
      break;
    }
  }
  return c;
}
static int rect_cmp(rect_t @a, rect_t @b) {
  return strcmp(a[0]->name,b[0]->name);
}
int generate_svg2(string_t<`H> file) {
  init_globals2();

  fn_t clos = fp2fn(proc_event2);
  int ret = proc_file(file,clos);
  if (ret != 0) return ret;
  max_x = (unsigned int)max_time;

  Hashtable::iter(finish_rect,(_@)allocations_table);

  /* print the XML header */
  printf("<?xml version='1.0' encoding='ISO-8859-1'?>\n"
         "<!DOCTYPE svg PUBLIC '-//W3C//DTD SVG 1.0//EN'\n"
         " 'http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd'>\n");

  output_comment("Allocation distribution profile produced by aprof");

  output_comment(aprintf("min_x = %u, max_x = %u",min_x,max_x));
  output_comment(aprintf("min_y = %u, max_y = %u",min_y,max_y));

  comment_stats();

  /* start of svg stuff */
  printf("<svg xmlns='http://www.w3.org/2000/svg'\n"
         "     xmlns:xlink='http://www.w3.org/1999/xlink'>\n");

  unsigned int visible_height = max_y - min_y;
  unsigned int visible_width = max_x - min_x;
  double xscale = 1.0;
  double yscale = 1.0;
  if (visible_width != 0)
    xscale = (double)WIDTH/(double)visible_width;
  if (visible_height != 0)
    yscale = (double)HEIGHT/(double)visible_height;
  printf("<g transform='translate(0,%d) scale(%.12f,-%.12f) translate(%d,%d)'>\n",
         (int)HEIGHT,
         xscale, yscale, -((int)min_x), -((int)min_y));

  printf("<!-- gc blocks -->\n");
  printf("<g fill='%s'>\n", color_of_region("available"));
  for (let l = gc_blocks; l != NULL; l = l->tl) {
    let &$(time,addr,amt) = l->hd;
    printf("<rect x='%u' y='%u' width='%u' height='%u'/>\n",
           time,
           addr,
           max_x-time,
           amt);
  }
  printf("</g>\n");

  printf("<!-- allocations -->\n");
  //  printf("<g opacity='%f'>\n", (double)gc_num/num_gc_events);
  let a = Xarray::to_array((_@)rects);
  let len = numelts(a);
  if (len > 0) {
    Array::msort(rect_cmp,a,len);
    printf("<g opacity='0.8'>\n");
    const char ?rname = a[0]->name;
    printf("<g fill='%s'>\n",color_of_region(rname));
    for (int i = 0; i < len; i++) {
      let &Rect(rname2,gc_num,x,y,width,height) = a[i];
      if (strcmp(rname,rname2) != 0) {
        rname = rname2;
        printf("</g>\n");
        printf("<g fill='%s'>\n",color_of_region(rname));
      }
      printf("<rect x='%u' y='%u' width='%u' height='%u'/>\n",
             x,y,width,height);
    }
    printf("</g>\n");
    printf("</g>\n");
  }

  printf("<!-- garbage collections -->\n");
  printf("<g opacity='0.3'>\n");
  for (let l = gc_list; l != NULL; l = l->tl) {
    let &$(x1,x2) = l->hd;
    printf("<rect x='%u' y='%u' width='%u' height='%u'/>\n",
           x1,min_y,x2-x1,max_y-min_y);
  }
  printf("</g>\n");

  printf("<!-- marks -->\n");
  for (let l = mark_list; l != NULL; l = l->tl) {
    let &$(time,m) = l->hd;
    printf("<path d='M%u,%u v%u' stroke='red' fill='none' opacity='.7'/>\n",
           time,min_y,max_y-min_y);
  }

  printf("</g>\n");

  /* print the legend of the graph */
  printf("<g transform='translate(%f,0)'>\n",WIDTH+20);
  output_legend(color_map);
  printf("</g>\n");

  /* print the title of the graph */
  let title = "Memory usage, lifetime x amount allocated";
  printf("<text x='%f' y='%f' text-anchor='middle'>%s</text>\n",
         WIDTH/2,HEIGHT+20,title);
  printf("</svg>\n");

  return 0;
}


/* Distribution of lifetimes */

/* Map address to time that address was allocated */
static struct Hashtable::Table<unsigned int,clock_t> *
  starttimes_table = NULL;

/* Map lifetime to number of objects with that lifetime */
static struct Hashtable::Table<unsigned int,unsigned int> *
  lifetimes_table = NULL;

static void
init_globals3() {
  starttimes_table =
    Hashtable::create(101,uint_cmp,uint_hash);
  lifetimes_table =
    Hashtable::create(101,uint_cmp,uint_hash);
  regionaddresses_table =
    Hashtable::create(101,strptrcmp,Hashtable::hash_stringptr);
}

static void increment_lifetime(unsigned int lifetime) {
  unsigned int lcount = 0;
  if (Hashtable::try_lookup((_@)lifetimes_table, lifetime, &lcount))
    Hashtable::remove((_@)lifetimes_table, lifetime);
  Hashtable::insert((_@)lifetimes_table, lifetime, lcount+1);
}

static void finish_lifetimes(unsigned int addr, clock_t start_time) {
  unsigned int lifetime = (unsigned int)(max_time - start_time);
  increment_lifetime(lifetime);
}

static bool proc_event3(aprof_event_t event) {
  switch (event) {
  case &AllocE(AllocEvent(time,_,rname,count,*rstats,addr)):
    if (!strcmp(rname,"unique")) {
      if (count>0) {
        // remember time for addr in case gc reclaims addr
        Hashtable::insert((_@)starttimes_table,addr,time);
      }
      else {
        // gc did not reclaim, this is ufree
        try {
          let start_time = Hashtable::lookup((_@)starttimes_table, addr);
          Hashtable::remove((_@)starttimes_table, addr);
          unsigned int lifetime = (unsigned int)(time - start_time);
          increment_lifetime(lifetime);
        }
        catch {
        case &Not_found:
          fprintf(stderr,
                  "error: reclaim event %x without (remembered) allocation\n",
                  addr);
          break;
        }
      }
    }
    else if (!strcmp(rname,"refcnt")) {
      // TODO
    }
    else if (!strcmp(rname,"heap")) {
      Hashtable::insert((_@)starttimes_table, addr, time);
    }
    else {
      let rname_p = new rname;
      try {
        let aset = Hashtable::lookup((_@)regionaddresses_table, rname_p);
        Hashtable::remove((_@)regionaddresses_table, rname_p);
        Hashtable::insert((_@)regionaddresses_table, rname_p,
                          Set::insert(aset,addr));
        Hashtable::insert((_@)starttimes_table,addr,time);
      }
      catch {
      case &Not_found:
        fprintf(stderr,
                "error: allocation into an unknown region %s\n",
                rname);
        break;
      }
    }
    break;

  case &ReclaimE(ReclaimEvent(time,addr)):
    try {
      let start_time = Hashtable::lookup((_@)starttimes_table, addr);
      Hashtable::remove((_@)starttimes_table, addr);
      unsigned int lifetime = (unsigned int)(time - start_time);
      increment_lifetime(lifetime);
    }
    catch {
    case &Not_found:
      fprintf(stderr,
	      "error: reclaim event %x without (remembered) allocation\n",
              addr);
      break;
    }
    break;

  case &CreateE(CreateEvent(_,_,rname,_)):
    Hashtable::insert((_@)regionaddresses_table, new rname,
                      Set::empty(uint_cmp));
    break;

  case &FreeE(FreeEvent(time,rname,_)):
    assert(strcmp("unique",rname));
    assert(strcmp("heap",rname));
    assert(strcmp("refcnt",rname));

    let rname_p = new rname;
    try {
      let aset = Hashtable::lookup((_@)regionaddresses_table, rname_p);
      Hashtable::remove((_@)regionaddresses_table, rname_p);
      let i = Set::make_iter(Core::heap_region,aset);
      unsigned int addr = 0;
      while (Iter::next(i,&addr)) {
        let start_time = Hashtable::lookup((_@)starttimes_table, addr);
        Hashtable::remove((_@)starttimes_table, addr);
        unsigned int lifetime = (unsigned int)(time - start_time);
        increment_lifetime(lifetime);
      }
    }
    catch {
    case &Not_found:
      fprintf(stderr,
              "error: free of an unknown region %s\n",
              rname);
      break;
    }
    break;

  case &MarkE(_):
  case &ResizeE(_):
  case &GcE(_):
  case &GcAddToHeapE(_):
    break;
  }

  return true;
}
static unsigned int max_lifetime = 0;
static unsigned int max_lcount = 0;
static unsigned int cumulative_lcount = 0;
static list_t<$(unsigned int,unsigned int)@> lifetimes = NULL;
static void record_lifetime(unsigned int lifetime,unsigned int lcount) {
  if (max_lifetime < lifetime) max_lifetime = lifetime;
  if (max_lcount < lcount) max_lcount = lcount;
  cumulative_lcount += lcount;
  lifetimes = new List(new $(lifetime,lcount),lifetimes);
}
int generate_svg3(string_t<`H> file) {

  init_globals3();

  fn_t clos = fp2fn(proc_event3);
  int ret = proc_file(file,clos);
  if (ret != 0) return ret;

  Hashtable::iter(finish_lifetimes,(_@)starttimes_table);
  Hashtable::iter(record_lifetime,(_@)lifetimes_table);

  unsigned int ?cumulative_arr = calloc(max_lifetime+1,sizeof(unsigned int));
  unsigned int ?lifetimes_arr = calloc(max_lifetime+1,sizeof(unsigned int));
  for (let l = lifetimes; l != NULL; l = l->tl) {
    let &$(lifetime,lcount) = l->hd;
    lifetimes_arr[lifetime] = lcount;
  }
  unsigned int cumulative_lifetime = 0;
  for (let i = 0; i < max_lifetime+1; i++) {
    cumulative_lifetime += lifetimes_arr[i];
    cumulative_arr[i] = cumulative_lifetime;
  }

  /* print the XML header */
  printf("<?xml version='1.0' encoding='ISO-8859-1'?>\n"
         "<!DOCTYPE svg PUBLIC '-//W3C//DTD SVG 1.0//EN'\n"
         " 'http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd'>\n");

  let title = "Number of objects with a given lifetime";
  output_comment("Allocation lifetime profile produced by aprof");
  output_comment(title);
  output_comment(aprintf("cumulative_lcount = %u",cumulative_lcount));
  output_comment(aprintf("cumulative_lifetime = %u",cumulative_lifetime));
  output_comment(aprintf("max_lifetime = %u",max_lifetime));
  comment_stats();

  /* start of svg stuff */
  printf("<svg xmlns='http://www.w3.org/2000/svg'\n"
         "     xmlns:xlink='http://www.w3.org/1999/xlink'>\n");

  double xscale = (double)WIDTH/(double)(max_lifetime+1);
  double yscale = 1.0;
  // TJIM: don't print cumulative graph for now
  //  if (cumulative_lcount != 0)
  //    yscale = (double)HEIGHT/(double)cumulative_lcount;
  if (max_lcount != 0)
    yscale = (double)HEIGHT/(double)max_lcount;

  printf("<!-- graph -->\n");
  printf("<g transform='translate(0,%d) scale(%.12f,-%.12f)'>\n",
         (int)HEIGHT,
         xscale, yscale);
  printf("<g opacity='0.4'>\n"); // svg says can't move y and width here :-(
  for (let i = 0; i<max_lifetime+1; i++) {
    // TJIM: don't print cumulative graph for now, swamps the other histo
    // TJIM: actually should print it as a percentage curve
    //    printf("<rect fill='green' x='%d' y='0' width='1' height='%d' />\n",
    //           i,cumulative_arr[i]);
    printf("<rect x='%d' y='0' width='1' height='%d'/>\n",
           i,lifetimes_arr[i]);
  }
  printf("</g>\n");
  printf("</g>\n");

  printf("<!-- x and y axes -->\n");
  printf("<path d='M-5,0 0,0 0,%f %f,%f %f,%f' fill='none'"
         " stroke='black'/>\n",
         HEIGHT, WIDTH, HEIGHT, WIDTH, HEIGHT+5);
  printf("<text x='-10' y='3' text-anchor='end'>%d objects</text>\n",
         max_lcount);
  const char ?CE = "clocks";
  if (use_events) CE = "events";
  printf("<text x='%f' y='%f' text-anchor='middle'>%d %s</text>\n",
         WIDTH, HEIGHT+18, max_lifetime, CE);

  printf("<!-- title -->\n");
  printf("<text x='%f' y='%f' text-anchor='middle'>%s</text>\n",
         WIDTH/2, HEIGHT+30, title);
  printf("</svg>\n");

  return 0;
}
