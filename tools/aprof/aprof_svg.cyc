/* SVG output for allocation profiler
   Copyright (C) 2001 Greg Morrisett, AT&T
   This file is part of the Cyclone compiler.

   The Cyclone compiler is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   The Cyclone compiler is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with the Cyclone compiler; see the file COPYING. If not,
   write to the Free Software Foundation, Inc., 59 Temple Place -
   Suite 330, Boston, MA 02111-1307, USA. */

#include <stdio.h>
#include <core.h>
#include <string.h>
#include <list.h>
#include <stdlib.h>
#include <array.h>
#include <fn.h>
#include <assert.h>
#include <hashtable.h>
#include <set.h>
#include <xarray.h>
#include "aprof_event.h"

using Core;
using List;
using Aprof;
using Fn;

// #define DEBUG_ME

const char ?graph_translate = NULL;
double x_caption_gap = 50.0;
double y_caption_gap = 50.0;
const char ?x_caption;
const char ?y_caption;
const char ?font_family = NULL;
const char ?font_size = NULL;
bool black_and_white = false;
bool gc_caps = false;
bool sort_changes = false;

char ?text_properties() {
  static int first_time = 1;
  static char ?ans = NULL;
  if (first_time) {
    first_time = 0;
    ans = aprintf("%s%s%s%s%s%s",
                  font_family?" font-family='":"",
                  font_family,
                  font_family?"'":"",
                  font_size?" font-size='":"",
                  font_size,
                  font_size?"'":"");
  }
  return ans;
}

/****************************** COLORS ******************************/
static const char ?default_colors[] =
//  {"red", "orange", "yellow", "green", "blue", "indigo", "violet" };
  {
    "rgb(148,208,84)",
    "rgb(0,104,96)",
    "rgb(0,101,0)",
    "rgb(88,80,0)",
    "rgb(0,67,58)",
    "rgb(0,56,0)",
    "rgb(0,0,208)"
  };

static const char ?bw_colors[] =
  {
    "rgb(50,50,50)",
    "rgb(110,110,110)",
    "rgb(170,170,170)",
    "rgb(80,80,80)",
    "rgb(140,140,140)",
    "rgb(200,200,200)",
    "rgb(20,20,20)"
  };

const char ??colors = default_colors;

static const char ?color(unsigned int i) {
  if (i < numelts(colors)) return colors[i];
  fprintf(stderr,"aprof: ran out of colors (<%u)\n",i);
  exit(1);
}

static int num_colors = 0;
static list_t<$(const char ?,const char ?)@> color_map = NULL;
static const char ?color_of_region(const char ?`H rname) {
  const char ?c = NULL;
  if (color_map == NULL) {
    c = color(num_colors++);
    color_map = new List(new $(rname,c),NULL);
  }
  else for (let l = color_map; l != NULL; l = l-> tl) {
    if (strcmp((*l->hd)[0],rname) == 0)
      return ((*l->hd)[1]);
    if (l->tl == NULL) {
      c = color(num_colors++);
      l->tl = new List(new $(rname,c),NULL);
      break;
    }
  }
  return c;
}
bool fixed_colors = false;
static void init_fixed_colors() {
  if (!fixed_colors) return;
  /* Should be called in initialization.  Forces default colors for regions. */
  color_of_region("unique");
  color_of_region("refcnt");
  color_of_region("heap");
  color_of_region("other");
  color_of_region("available");
  color_of_region("reserved");
}

/* Dimensions of the graph on the printed page, in points (pt).
   The title, legend, etc., appear outside these dimensions. */
double WIDTH = 300.0;
double HEIGHT = 300.0;

/* Resolution of the graph: number of divisions in the x dimension.
   Increasing resolution will result in a more accurate graph.
   We limit resolution because SVG viewers in practice cannot
   handle objects with too many points.  "Too many" is
   about 40,000 for Adobe Illustrator, for example.  Also,
   limiting the resolution controls the size of the SVG
   output and the internal data structures of aprof. */
unsigned int XMAXRES = 1000;
static unsigned int xres = 0;
double scale = 1.0;
static void compute_resolution() {
  if (max_time<XMAXRES) xres = max_time+1; else xres = XMAXRES;
  scale = ((double)xres)/((double)max_time+1);
}

typedef unsigned int coord_t;

struct Curve {
  const char ?name;
  /* updated in phase 1 */
  double area;  // would like to use long long, but can't printf
  unsigned int max_y;
  unsigned int changes_y;
  unsigned int num_points;
  /* updated in phase 2 */
  coord_t ?points;
  /* auxilliary data for both phases */
  unsigned int last_x;
  unsigned int last_y;
};
typedef struct Curve @curve_t;
static curve_t
curve_init(const char ?`H name) {
  return new Curve(name,0,0,0,0,NULL,0,0);
}

// Data that is maintained/updated at each profiled event
struct ProcEnv {
  curve_t mem_total;
  curve_t heap_live;
  curve_t unique_live;
  curve_t refcnt_live;
  curve_t other_live;
};

/* Nicely format f as a number of bytes */
static char ?print_units(double f,const char ?suffix) {
  $(double,const char ?) powers[] =
    { $(1099511627776.0,"T"),
      $(1073741824.0,"G"),
      $(1048576.0,"M"),
      $(1024.0,"K") };
  const char ?units = "";

  for (let i = 0; i < numelts(powers); i++) {
    if (f > powers[i][0]) {
      units = powers[i][1];
      f = f/powers[i][0];
      break;
    }
  }
  /* Print >= 3 digits of precision */
  if (f < 10.0)
    return aprintf("%.2f %s%s",f,units,suffix);
  else if (f < 100.0)
    return aprintf("%.1f %s%s",f,units,suffix);
  else
    return aprintf("%.0f %s%s",f,units,suffix);
}
static char ?print_bytes(double f) {
  return print_units(f,"B");
}

/////////////////////////////// EVENT PROCESSING

/* Table for remembering how much was allocated at an address */
static struct Hashtable::Table<unsigned int,$(const char ?,unsigned int)@> *
  allocation_at_address_table = NULL;
/* Table for remembering how much was allocated into a region */
static struct Hashtable::Table<const char ?@,unsigned int> *
  allocation_in_region_table = NULL;
/* Array of events -- (region name, x, delta_y) pairs */
static struct Xarray::Xarray<$(const char ?,clock_t,int)@> *events = NULL;

static int uint_cmp(unsigned int i, unsigned int j) {
  return (i<j)?(-1):((i>j)?1:0);
}
static int uint_hash(unsigned int i) {
  return (int)i;
}
static void
init_globals() {
  if (black_and_white) colors = bw_colors;
  init_fixed_colors();
  allocation_at_address_table =
    Hashtable::create(101,uint_cmp,uint_hash);
  allocation_in_region_table =
    Hashtable::create(101,strptrcmp,Hashtable::hash_stringptr);
  events = Xarray::create_empty();
}

static list_t<$(clock_t,const char ?)@> mark_list = NULL;

static bool inside_gc = false;
static clock_t gc_start_time = 0;
static clock_t gc_latest_time = 0;
static list_t<$(clock_t,clock_t)@> gc_list = NULL;

/* phase 1 */
static void mark_gc(clock_t x) {
  if (!inside_gc) {
    gc_start_time = gc_latest_time = x;
    inside_gc = true;
  }
  else
    gc_latest_time = x;
}
static void mark_gc_over() {
  if (inside_gc) {
    gc_list = new List(new $(gc_start_time,gc_latest_time),gc_list);
    inside_gc = false;
  }
}
static void mark_delta(curve_t b, clock_t x, int delta_y) {
  if (delta_y == 0) return;
  unsigned int y = b->last_y + delta_y;
  b->num_points++;
  Xarray::add((_@)events,new $(b->name,x,delta_y));
  //  unsigned int x = Xarray::length((_@)events);
  b->area += ((double)(x - b->last_x)) * b->last_y;
  if (b->max_y < y) b->max_y = y;
  b->changes_y++;
#ifdef DEBUG_ME
  fprintf(stderr,"%s = %d @ %d\n",b->name,y,x);
  //  fprintf(stderr,"%s->area += %s*events\n",
  //          b->name,
  //          print_bytes(((double)(x - b->last_x)) * b->last_y));
#endif
  b->last_x = x;
  b->last_y = y;
}
static void mark_point(curve_t b, clock_t x, unsigned int y) {
  mark_delta(b, x, (int)(y - b->last_y));
}
static void mark_finish(curve_t b, clock_t x) {
  b->area += ((double)(x - b->last_x)) * b->last_y;
#ifdef DEBUG_ME
  const char ?CE = "clocks";
  if (use_events) CE = "events";
  fprintf(stderr,"%s->area += %s*%s\n",
          b->name,
          print_bytes(((double)(x - b->last_x)) * b->last_y),
          CE);
#endif
  b->last_x = 0;
  b->last_y = 0;
  b->points = new {for i < xres: 0}; // xres must be set up before calling
}
static bool omitted(const char ?x) {
  bool result = false;
  for (let l = omits; l != NULL; l = l->tl)
    if (strcmp(x,*(l->hd)) == 0) {
      result = true;
      break;
    }
  return result;
}
static void update_heap_stats(struct ProcEnv @env,
                              clock_t x,
			      struct RegionStats @s) {
  if (!omitted("reserved"))
    mark_point(env->mem_total,x,s->region_size_bytes);
}

/* phase 2 */
static void add_delta(curve_t b, unsigned int unscaled_x, int delta_y) {
  clock_t x = (clock_t)(unscaled_x * scale);
  unsigned int y = b->last_y + delta_y;
  for (int i = b->last_x + 1; i <= x; i++) {
    b->points[i] = b->last_y;
  }
  b->points[x] = y;
  b->last_x = x;
  b->last_y = y;
}
static void add_finish(curve_t b, unsigned int unscaled_x) {
  clock_t x = (clock_t)(unscaled_x * scale);
  //  fprintf(stderr,"Finishing %u at scale %f giving %u\n",
  //          unscaled_x,scale,x);
  if (b->last_x < x)
    for (int i = b->last_x+1; i<=x; i++)
      b->points[i] = b->last_y;
}
static void gc_scale() {
  for (let l = gc_list; l != NULL; l = l->tl) {
    let &$(*x1,*x2) = l->hd;
    *x1 = (clock_t)(*x1 * scale);
    *x2 = (clock_t)(*x2 * scale);
  }
}



static int percent(unsigned int numerator, unsigned int denominator) {
  return (int)((numerator * 100.0)/denominator);
}

static void output_comment(const char ?s) {
  printf("<!-- %s -->\n",s);
  if (verbose)
    fprintf(stderr,"%s\n",s);
}

static void comment_curve_stats(curve_t b) { // for debugging
  const char ?CE = "clocks";
  if (use_events) CE = "events";
  output_comment(aprintf("%s area: %s*%s\tmax_y: %u\tchanges_y: %u",b->name,
			 print_bytes(b->area),CE,b->max_y,b->changes_y));
}

static unsigned int bytes_reclaim_heap = 0;
static unsigned int num_reclaim_heap = 0;
static unsigned int bytes_reclaim_unique = 0;
static unsigned int num_reclaim_unique = 0;
static unsigned int bytes_reclaim_refcnt = 0;
static unsigned int num_reclaim_refcnt = 0;
static unsigned int bytes_freed_other = 0;

static bool proc_event(struct ProcEnv @env, aprof_event_t event) {
  switch (event) {
  case &CreateE(CreateEvent(time,_,rname,*rstats)):
    mark_gc_over();
    let rnameptr = new rname;

    assert(strcmp("unique",rname));
    assert(strcmp("heap",rname));
    assert(strcmp("refcnt",rname));

    update_heap_stats(env,time,rstats); // these rstats are for GC
    break;

  case &AllocE(AllocEvent(time,_,rname,count,*rstats,addr)):
    mark_gc_over();
    if (!strcmp(rname,"unique")) {
      update_heap_stats(env,time,rstats);
      if (count>0) {
        if (!omitted("unique")) mark_delta(env->unique_live,time,count);
        // remember count for addr in case gc reclaims addr
        Hashtable::insert((_@)allocation_at_address_table,
                          addr,new $("unique",(unsigned int)count));
      }
      else {
        // gc did not reclaim, this is ufree, forget addr/count
        try {
          let &$(rname2,count2) =
            Hashtable::lookup((_@)allocation_at_address_table,addr);
          Hashtable::remove((_@)allocation_at_address_table,addr);
          int delta_y = -1*((int)count2);
          /* NB: if the program was compiled with -nogc, then count will not be
             valid (because GC_size can't be implemented correctly in -nogc).
             However, the original count2 should be correct. */
          count = delta_y; /* assume the second count is wrong */
        }
        catch {
        case &Not_found: break;
        }
        if (!omitted("unique")) mark_delta(env->unique_live,time,count);
      }
    }
    else if (!strcmp(rname,"refcnt")) {
      update_heap_stats(env,time,rstats);
      if (count>0) {
        if (!omitted("refcnt")) mark_delta(env->refcnt_live,time,count);
        // remember count for addr in case gc reclaims addr
        Hashtable::insert((_@)allocation_at_address_table,
                          addr,new $("refcnt",(unsigned int)count));
      }
      else {
        // gc did not reclaim, this is free, forget addr/count
        try {
          let &$(rname2,count2) =
            Hashtable::lookup((_@)allocation_at_address_table,addr);
          Hashtable::remove((_@)allocation_at_address_table,addr);
          int delta_y = -1*((int)count2);
          /* NB: if the program was compiled with -nogc, then count will not be
             valid (because GC_size can't be implemented correctly in -nogc).
             However, the original count2 should be correct. */
          count = delta_y; /* assume the second count is wrong */
        }
        catch {
        case &Not_found: break;
        }
        if (!omitted("refcnt")) mark_delta(env->refcnt_live,time,count);
      }
    }
    else if (!strcmp(rname,"heap")) {
      if (!omitted("heap"))
        mark_delta(env->heap_live,time,count);
      update_heap_stats(env,time,rstats);
      Hashtable::insert((_@)allocation_at_address_table,
                        addr,new $("heap",(unsigned int)count));
    }
    else {
      if (!omitted("other"))
        mark_delta(env->other_live,time,count);
      let rname_p = new rname;
      unsigned int x = 0;
      try {
        x = Hashtable::lookup((_@)allocation_in_region_table, rname_p);
        Hashtable::remove((_@)allocation_in_region_table, rname_p);
      }
      catch {
      case &Not_found: break;
      }
      Hashtable::insert((_@)allocation_in_region_table,rname_p,x+count);
      // The rstats give info about the "other" region, not the
      // memory managed by the GC -- so don't update that.
      // update_heap_stats(env,time,rstats);
    }
    break;

  case &ReclaimE(ReclaimEvent(time,addr)):
    mark_gc(time);
    try {
      let &$(rname,count) =
        Hashtable::lookup((_@)allocation_at_address_table,addr);
      Hashtable::remove((_@)allocation_at_address_table,addr);
      int delta_y = -1*((int)count);
      if (!omitted("unique") && strcmp("unique",rname) == 0) {
        // this is a unique pointer object that got garbage collected
        mark_delta(env->unique_live,time,delta_y);
        bytes_reclaim_unique += count;
      }
      if (!omitted("refcnt") && strcmp("refcnt",rname) == 0) {
        // this is a refcounted pointer object that got garbage collected
        mark_delta(env->refcnt_live,time,delta_y);
        bytes_reclaim_refcnt += count;
      }
      else if (!omitted("heap") && strcmp("heap",rname) == 0) {
        mark_delta(env->heap_live,time,delta_y);
        bytes_reclaim_heap += count;
      }
    }
    catch {
    case &Not_found:
      fprintf(stderr,
	      "error: reclaim event %x without (remembered) allocation\n",
              addr);
      break;
    }
    break;

  case &FreeE(FreeEvent(time,rname,*rstats)):
    assert(strcmp("unique",rname));
    assert(strcmp("heap",rname));
    assert(strcmp("refcnt",rname));

    mark_gc_over();
    let rname_p = new rname;
    unsigned int x = 0;
    try {
      x = Hashtable::lookup((_@)allocation_in_region_table,rname_p);
      Hashtable::remove((_@)allocation_in_region_table,rname_p);
    }
    catch {
    case &Not_found: break; // region created but not allocated into
    }
    if (!omitted("other"))
      mark_delta(env->other_live,time,-x);
    update_heap_stats(env,time,rstats);
    break;

  case &ResizeE(ResizeEvent(time,rname,count,*rstats)):
    /* NB: count size (but not sign) will be invalid if -nogc is used */
    assert(strcmp("unique",rname));
    assert(strcmp("heap",rname));
    assert(strcmp("refcnt",rname));

    mark_gc_over();
    // The count is the new size of the region -- ignore
    // mark_delta(env->other_live,time,count);

    // rstats measures GC
    update_heap_stats(env,time,rstats);
    break;

  case &GcE(GcEvent(time,n,*rstats)):
    mark_gc_over();
    update_heap_stats(env,time,rstats);
    break;

  case &GcAddToHeapE(GcAddToHeapEvent(time,addr,amt,*rstats)):
    mark_gc_over();
    update_heap_stats(env,time,rstats);
    break;

  case &MarkE(MarkEvent(time,m)):
    mark_list = new List(new $(time,m), mark_list);
    break;

  }

  return true;
}

//////////////////////////////////////////////////////////////////////
static list_t<curve_t> all_curves;
static void phase2($(const char ?,clock_t,int) @z) {
  let &$(name,x,delta_y) = z;
  if (strcmp(name,"reserved") == 0) {
    for (let l = all_curves; l != NULL; l = l->tl) {
      let b = l->hd;
      if (strcmp("reserved",b->name) == 0) {
        add_delta(b,x,delta_y);
        return;
      }
    }
  }
  else {
    /* increment the curve identified by name, as well as
       all subsequent curves in the list all_curves,
       except for the reserved curve */
    let saw_name = 0;
    for (let l = all_curves; l != NULL; l = l->tl) {
      let b = l->hd;
      if (!saw_name && strcmp(b->name,name) == 0)
        saw_name = 1;
      if (saw_name && strcmp(b->name,"reserved") != 0)
        add_delta(b,x,delta_y);
    }
  }
}
//////////////////////////////////////////////////////////////////////

static int curve_area_cmp(curve_t x, curve_t y) {
  if (x->area < y->area) return -1;
  else if (x->area > y->area) return 1;
  /* equal areas, secondary compare by changes in y */
  else if (x->changes_y < y->changes_y) return -1;
  else if (x->changes_y > y->changes_y) return 1;
  else return 0;
}

static int curve_changes_cmp(curve_t x, curve_t y) {
#define AREA_THRESH 5.0
  // only go by changes when the areas are within a certain threshhold
  if (x->area * AREA_THRESH < y->area) return -1;
  else if (x->area > y->area * AREA_THRESH) return 1;
  // now check by number of changes
  if (x->changes_y < y->changes_y) return -1;
  else if (x->changes_y > y->changes_y) return 1;
  /* equal changes in y, secondary compare by area */
  else if (x->area < y->area) return -1;
  else if (x->area > y->area) return 1;
  else return 0;
}

#define SEPARATION 15
static void output_legend(list_t<$(const char ?,const char ?)@> items) {
  // items is a list of (name,color) pairs
  int i = 0;
  for (let l = items; l != NULL; i++, l = l->tl) {
    printf("<rect x='0' y='%f' width='%f' height='%f'"
           " fill='%s' stroke='none' opacity='0.7'/>\n",
           i*SEPARATION-(0.125*SEPARATION),
           (0.75*SEPARATION),
           (0.75*SEPARATION),
           (*l->hd)[1]);
    printf("<text x='%f' y='%f' fill='black' text-anchor='start'%s>%s</text>\n",
           SEPARATION+5,
           i*SEPARATION+(0.5*SEPARATION),
           text_properties(),
           (*l->hd)[0]);
  }
}

bool landscape = false;
const char ?curve_stroke = "black";
const char ?gc_fill = "black";
const char ?gc_opacity = "0.5";

static void output_curves(int xres, int num_curves, unsigned int max_y, coord_t ?? yv) {

  printf("<g transform='translate(0,%f) scale(%.12f,%.12f)'>\n",
         HEIGHT,
         WIDTH / xres,
         -HEIGHT / max_y);  // negative y scale so coords are flipped

  /* the fills */
  printf("<!-- curves -->\n");
  // bottom curve first...
  printf("<path id='%s' d='M",nth(all_curves,0)->name);
  for (int x=0; x < xres; x++) {
    printf("%d,%d ",x,yv[0][x]);
  }
  printf("%d,0 0,0 ",xres-1); // bottom border is x axis
  printf("' stroke='%s' stroke-width='0.1' fill='%s' opacity='0.7'/>\n",
         curve_stroke,
	 color_of_region(nth(all_curves,0)->name));

  // ... then the other curves, going up
  for (int i=1; i < num_curves; i++) {
    let nm = nth(all_curves,i)->name;
    printf("<path id='%s' d='M",nm);
    // top border is the curve
    for (int x=0; x < xres; x++) {
      printf("%d,%d ",x,yv[i][x]);
    }
    // bottom border is the previous curve
    for (int x=(xres-1); x >= 0; x--) {
      printf("%d,%d ",x,yv[i-1][x]);
    }
    printf("0,%d ",yv[i][0]);
    printf("' stroke='%s' stroke-width='0.1' fill='%s' opacity='0.7'/>\n",curve_stroke,color_of_region(nm));
  }

  /* the garbage collections */
  printf("<!-- garbage collections -->\n");
  gc_scale();
  for (let l = gc_list; l != NULL; l = l->tl) {
    let &$(x1,x2) = l->hd;
    printf("<rect x='%d' y='0' width='%d' height='%d'"
           " fill='%s' stroke='none' opacity='%s'/>\n",
           x1,x2-x1,max_y,gc_fill,gc_opacity);
    if (gc_caps)
      printf("<polygon points='%f,%f %f,%f %f,%f'"
             " fill='black' stroke='none'/>\n",
             ((x2-x1)/2.0)+x1-(xres*0.01), 1.01*max_y,
             ((x2-x1)/2.0)+x1+(xres*0.01), 1.01*max_y,
             ((x2-x1)/2.0)+x1, max_y);
    //             x1,max_y,x2,max_y,((x2-x1)/2.0+x1),1.01*max_y);
//      printf("<polygon points='%d,%d %d,%d %f,%f'"
//             " fill='black' stroke='none'/>\n",
//             x1,max_y,x2,max_y,((x2-x1)/2.0+x1),1.01*max_y);
  }

  printf("<!-- marks -->\n");
  for (let l = mark_list; l != NULL; l = l->tl) {
    let &$(time,m) = l->hd;
    printf("<path d='M%u,0 v%u' stroke='red' fill='none' opacity='.7'/>\n",
           time,max_y);
  }

  printf("</g>\n");

  /* the lines */
  /*
  for (int i=0; i < num_curves; i++) {
    printf("<path d='M");
    for (int x=0; x < xres; x++) {
     printf("%d,%d ",x*10,100-yv[i][x]);
    }
    printf("' stroke='black' stroke-linecap='round' stroke-linejoin='round' fill='none'/>\n");
  }
  */

  /* x and y axes */
  /*
  printf("<path d='M0,0 0,100 100,100' fill='none'"
         " stroke='black' stroke-linecap='round'/>\n");
  // y axis tick marks
  for (int y=0; y <= 100; y += 10) {
    printf("<line x1='-3' y1='%d' x2='0' y2='%d'"
           " stroke='black' stroke-linecap='round'/>\n",
           100-y,100-y);
    printf("<text x='-8' y='%d' fill='black' text-anchor='end'%s>%d</text>\n",
           100-y,
           text_properties(),
           y);
  }
  // x axis tick marks
  for (int x=0; x <= 100; x += 10)
    printf("<line x1='%d' y1='100' x2='%d' y2='103'"
           " stroke='black' stroke-linecap='round'/>\n",x,x);
  */
}

#define PLURAL(x) x,(((x)!=1)?"s":"")
static void comment_stats() {
  output_comment(aprintf("Total events: %6u",
                         (num_create_events+num_alloc_events
                          +num_free_events+num_reclaim_events
                          +num_resize_events+num_gc_events)));
  output_comment(aprintf("* Create:     %6u",num_create_events));
  output_comment(aprintf("* Alloc:      %6u",num_alloc_events));
  output_comment(aprintf("* Free:       %6u",num_free_events));
  output_comment(aprintf("* Reclaim:    %6u",num_reclaim_events));
  output_comment(aprintf("* Resize:     %6u",num_resize_events));
  output_comment(aprintf("* Gc:         %6u",num_gc_events));

  output_comment("         _____ALLOCATED_____       ___________COLLECTED___________       _____________FREED_____________");
  output_comment("Region   Objects       Bytes       Objects     %       Bytes     %       Objects     %       Bytes     %");
  output_comment("========================================================================================================");

  if (num_alloc_heap)
    output_comment(aprintf("%6s%10u%12u%14u%5d%%%12u%5d%%",
                           "`H",num_alloc_heap,bytes_alloc_heap,
                           num_reclaim_heap,percent(num_reclaim_heap,num_alloc_heap),
                           bytes_reclaim_heap,
                           percent(bytes_reclaim_heap,bytes_alloc_heap)));
  if (num_alloc_unique)
    output_comment(aprintf("%6s%10u%12u%14u%5d%%%12u%5d%%%14u%5d%%%12u%5d%%",
                           "`U",num_alloc_unique,bytes_alloc_unique,
                           num_reclaim_unique,
                           percent(num_reclaim_unique,num_alloc_unique),
                           bytes_reclaim_unique,
                           percent(bytes_reclaim_unique,bytes_alloc_unique),
                           num_freed_unique,
                           percent(num_freed_unique,num_alloc_unique),
                           bytes_freed_unique,
                           percent(bytes_freed_unique,bytes_alloc_unique)));
  if (num_alloc_refcnt)
    output_comment(aprintf("%6s%10u%12u%14u%5d%%%12u%5d%%%14u%5d%%%12u%5d%%",
                           "`RC",num_alloc_refcnt,bytes_alloc_refcnt,
                           num_reclaim_refcnt,
                           percent(num_reclaim_refcnt,num_alloc_refcnt),
                           bytes_reclaim_refcnt,
                           percent(bytes_reclaim_refcnt,bytes_alloc_refcnt),
                           num_freed_refcnt,
                           percent(num_freed_refcnt,num_alloc_refcnt),
                           bytes_freed_refcnt,
                           percent(bytes_freed_refcnt,bytes_alloc_refcnt)));
  if (num_alloc_other)
    output_comment(aprintf("%6s%10u%12u                                                          %12u%5d%%",
                           "other",num_alloc_other,bytes_alloc_other,
                           bytes_freed_other,
                           percent(bytes_freed_other,bytes_alloc_other)));
}

namespace Aprof;

int generate_svg(string_t<`H> file) {
  struct ProcEnv @`H env =
    new ProcEnv{.mem_total = curve_init("reserved"),
		.heap_live = curve_init("heap"),
		.unique_live = curve_init("unique"),
		.refcnt_live = curve_init("refcnt"),
		.other_live = curve_init("other")};

  init_globals();

  /* Phase 1: process the allocation log file (amon.out) */
  fn_t clos = make_fn(proc_event,env);
  int ret = proc_file(file,clos);
  if (ret != 0) return ret;
  
  compute_resolution();

  if (!omitted("reserved"))
    mark_finish(env->mem_total,max_time);
  if (!omitted("heap"))
    mark_finish(env->heap_live,max_time);
  if (!omitted("unique"))
    mark_finish(env->unique_live,max_time);
  if (!omitted("refcnt"))
    mark_finish(env->refcnt_live,max_time);
  if (!omitted("other"))
    mark_finish(env->other_live,max_time);

  /* sort the curves by area, with bigger curves to be printed
     above smaller curves */
  if (!omitted("heap") && env->heap_live->area > 0.0)
    all_curves = new List(env->heap_live,all_curves);
  if (!omitted("unique") && env->unique_live->area > 0.0)
    all_curves = new List(env->unique_live,all_curves);
  if (!omitted("refcnt") && env->refcnt_live->area > 0.0)
    all_curves = new List(env->refcnt_live,all_curves);
  if (!omitted("other") && env->other_live->area > 0.0)
    all_curves = new List(env->other_live,all_curves);
  if (sort_changes)
    all_curves = merge_sort(curve_changes_cmp,all_curves);
  else all_curves = merge_sort(curve_area_cmp,all_curves);
  if (!omitted("reserved") && env->mem_total->area > 0.0)
    all_curves = imp_append(all_curves,new List(env->mem_total,NULL));

  /* Phase 2: compute the curves */
  Xarray::iter(phase2,(_@)events);
  for (let l = all_curves; l != NULL; l = l->tl) {
    add_finish(l->hd,max_time);
  }
  unsigned int max_y = 0;
  for (let l = all_curves; l != NULL; l = l->tl) {
    if (strcmp(l->hd->name,"reserved") == 0) {
      max_y = l->hd->max_y; break;
    }
    max_y += l->hd->max_y;
  }

  double memory_footprint = env->mem_total->area;
  double data_footprint =
    env->heap_live->area + env->unique_live->area
    + env->refcnt_live->area + env->other_live->area;
  const char ?CE = "clocks";
  if (use_events) CE = "events";

  /* print the XML header */
  printf("<?xml version='1.0' encoding='ISO-8859-1'?>\n"
         "<!DOCTYPE svg PUBLIC '-//W3C//DTD SVG 1.0//EN'\n"
         " 'http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd'>\n");

  output_comment("Allocation profile produced by aprof");
  comment_stats();
  if (!omitted("reserved")) comment_curve_stats(env->mem_total);
  if (!omitted("heap")) comment_curve_stats(env->heap_live);
  if (!omitted("unique")) comment_curve_stats(env->unique_live);
  if (!omitted("refcnt")) comment_curve_stats(env->refcnt_live);
  if (!omitted("other")) comment_curve_stats(env->other_live);

  int num_curves = length(all_curves);
  coord_t ??zz = new {for i < num_curves: nth(all_curves,i)->points };
  output_comment(aprintf("max_time = %u, max_y = %u",max_time,max_y));

  /* start of svg stuff */
  printf("<svg xmlns='http://www.w3.org/2000/svg'\n"
         "     xmlns:xlink='http://www.w3.org/1999/xlink'>\n");

  if (landscape)
    printf("<g transform='rotate(-90)'>\n");
  if (graph_translate)
    printf("<g transform='translate(%s)'>\n",graph_translate);

  /* print the curves and garbage collections */
  output_curves(xres,num_curves,max_y,zz);

  /* set up and print the legend */
  let namecolors = NULL;
  int i = 0;
  for (let l = all_curves; l != NULL; l = l->tl) {
    curve_t b = l->hd;
    if (strcmp("reserved",b->name) != 0) {
      let name = aprintf("%s %s*%s (%d%%)",b->name,
                         print_bytes(b->area),CE,
                         (int)((b->area * 100.0)/data_footprint));
      namecolors = new List(new $((const char ?)name,color_of_region(b->name)),namecolors);
    }
    else
      namecolors = new List(new $("reserved",color_of_region("reserved")),namecolors);
  }
  printf("<g transform='translate(%f,0)'>\n",WIDTH+20);
  output_legend(namecolors);
  printf("</g>\n");

  printf("<!-- x and y axes -->\n");
  printf("<path d='M-5,0 0,0 0,%f %f,%f %f,%f' fill='none'"
         " stroke='black' stroke-width='0.2'/>\n",
         HEIGHT, WIDTH, HEIGHT, WIDTH, HEIGHT+5);
  printf("<text x='-10' y='3' text-anchor='end'%s>%s</text>\n",
         text_properties(),
         print_bytes(max_y));
  const char ?CE = " clocks";
  if (use_events) CE = " events";
  printf("<text x='%f' y='%f' text-anchor='middle'%s>%s</text>\n",
         WIDTH, HEIGHT+18, text_properties(), print_units(max_time,CE));

  printf("<!-- x axis caption -->\n");
  if (!x_caption)
    if (memory_footprint > 0.0)
      x_caption =
        aprintf("Memory footprint %s*%s, data footprint %s*%s (%d%%)",
                print_bytes(memory_footprint),CE,
                print_bytes(data_footprint),CE,
                (int)((data_footprint * 100.0)/memory_footprint));
    else
      x_caption =
        aprintf("Data footprint %s*%s", print_bytes(data_footprint),CE);
  printf("<text x='%f' y='%f' text-anchor='middle'%s>%s</text>\n",
         WIDTH/2,HEIGHT+x_caption_gap, text_properties(), x_caption);

  printf("<!-- y axis caption -->\n");
  if (y_caption) {
    printf("<g transform='translate(%f,%f) rotate(-90)'>\n",
           -y_caption_gap,HEIGHT/2);
    printf("<text x='0' y='0' text-anchor='middle'%s>%s</text>\n", text_properties(), y_caption);
    printf("</g>\n");
  }

  if (graph_translate) printf("</g>\n");
  if (landscape) printf("</g>\n");
  printf("</svg>\n");

  return 0;
}

/**********************************************************************/
/* Code to see how many points on a path can be handled by
   an SVG viewer.  For Adobe Illustrator it seems to be about
   30,000.
*/
/*
void try2() {
  printf("<?xml version='1.0' encoding='ISO-8859-1'?>\n"
         "<!DOCTYPE svg PUBLIC '-//W3C//DTD SVG 1.0//EN'\n"
         " 'http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd'>\n"
         "<svg xmlns='http://www.w3.org/2000/svg'\n"
         "     xmlns:xlink='http://www.w3.org/1999/xlink'>\n");

  if (landscape)
    printf("<g transform='rotate(-90)'>\n");
  if (graph_translate)
    printf("<g transform='translate(%s)'>\n",graph_translate);

  printf("<g transform='scale(0.005)'>\n");
  printf("<path d='M");
  for (int x=0; x <= 40000; x++) {
    printf("%d,%d ",x,f(x));
  }
  printf("20000,0 0,0 ");
  printf("' stroke='none' fill='blue' opacity='0.7'/>\n");

  printf("</g>\n");
  if (graph_translate) printf("</g>\n");
  if (landscape) printf("</g>\n");
  printf("</svg>\n");
}

int main() {
  try2();
  return 0;
}
*/

/**********************************************************************/
/*                                                                    */
/*                PLOT OBJECT ADDRESS RANGE BY TIME                   */
/*                                                                    */
/**********************************************************************/

/* Map address to time and amount of allocation */
static struct Hashtable::Table<unsigned int,$(const char ?,clock_t,unsigned int)@> *
  allocations_table = NULL;

/* Map region to addresses allocated in that region */
static struct Hashtable::Table<const char ?@,Set::set_t<unsigned int>> *
  regionaddresses_table = NULL;

/* Array of rects for later printing */
struct Rect {
  const char ?name;
  unsigned int gc_num;
  unsigned int x;
  unsigned int y;
  unsigned int width;
  unsigned int height;
};
typedef struct Rect @rect_t;
static struct Xarray::Xarray<rect_t> *rects = NULL;

static void
init_globals2() {
  if (black_and_white) colors = bw_colors;
  init_fixed_colors();
  allocations_table =
    Hashtable::create(101,uint_cmp,uint_hash);
  regionaddresses_table =
    Hashtable::create(101,strptrcmp,Hashtable::hash_stringptr);
  rects = Xarray::create_empty();
}
static unsigned int min_x;
static unsigned int max_x;
static unsigned int min_y;
static unsigned int max_y;
static bool first_rect = true;
static void add_rect(const char ?`H rname,
                     clock_t start_time,
                     unsigned int addr,
                     clock_t end_time,
                     unsigned int amount) {
  unsigned int x = (unsigned int)start_time;
  unsigned int y = addr;
  if (first_rect) {
    first_rect = false;
    min_x = x; // max_x computed by proc_file
    min_y = y;
    max_y = y+amount;
  }
  else {
    if (min_x > x) min_x = x; // max_x computed by proc_file
    if (min_y > y) min_y = y;
    if (max_y < y+amount) max_y = y+amount;
  }
  Xarray::add((_@)rects,
              new Rect{.name=rname,
                       .gc_num=num_gc_events,
                       .x=x,
                       .y=y,
                       .width=(unsigned int)(end_time - start_time),
                       .height=amount});
}
static void finish_rect(unsigned int addr,
                        $(const char ?,clock_t,unsigned int) @v) {
  clock_t end_time = max_x;
  let &$(rname,start_time,count) = v;
  if (strcmp(rname,"unique") == 0) {
    add_rect("unique",start_time,addr,end_time,count);
  }
  else if (strcmp(rname,"heap") == 0) {
    add_rect("heap",start_time,addr,end_time,count);
  }
}
static list_t<$(clock_t,unsigned int,unsigned int)@> gc_blocks = NULL;
static bool proc_event2(aprof_event_t event) {
  switch (event) {
  case &AllocE(AllocEvent(time,_,rname,count,*rstats,addr)):
    mark_gc_over();
    if (!strcmp(rname,"unique") || !strcmp(rname,"refcnt")) {
      /* NB: count size (but not sign) will be invalid if -nogc is used */
      if (count>0) {
        // remember count for addr in case gc reclaims addr
        Hashtable::insert((_@)allocations_table,
                          addr,new $(rname,time,
                                     (unsigned int)count));
      }
      else {
        // gc did not reclaim, this is (u)free, forget addr/count
        try {
          let &$(_,start_time,count2) =
            Hashtable::lookup((_@)allocations_table, addr);
          Hashtable::remove((_@)allocations_table, addr);
          add_rect(rname,start_time,addr,time,count2); // count2 because count might not be accurate
        }
        catch {
        case &Not_found: break;
        }
      }
    }
    else if (!strcmp(rname,"heap")) {
      Hashtable::insert((_@)allocations_table, addr,
                        new $("heap",time,(unsigned int)count));
    }
    else {
      let rname_p = new rname;
      try {
        let aset = Hashtable::lookup((_@)regionaddresses_table, rname_p);
        Hashtable::remove((_@)regionaddresses_table, rname_p);
        Hashtable::insert((_@)regionaddresses_table, rname_p,
                          Set::insert(aset,addr));
        Hashtable::insert((_@)allocations_table, addr,
                          new $(rname,time,(unsigned int)count));
      }
      catch {
      case &Not_found:
        fprintf(stderr,
                "error: allocation into an unknown region %s\n",
                rname);
        break;
      }
    }
    break;

  case &ReclaimE(ReclaimEvent(time,addr)):
    mark_gc(time);
    try {
      let &$(rname,start_time,count) =
        Hashtable::lookup((_@)allocations_table, addr);
      Hashtable::remove((_@)allocations_table, addr);
      if (strcmp(rname,"unique") == 0) {
        // this is a unique pointer object that got garbage collected
        num_reclaim_unique++;
        bytes_reclaim_unique += count;
        add_rect("unique",start_time,addr,time,count);
      }
      else if (strcmp(rname,"heap") == 0) {
        num_reclaim_heap++;
        bytes_reclaim_heap += count;
        add_rect("heap",start_time,addr,time,count);
      }
    }
    catch {
    case &Not_found:
      fprintf(stderr,
	      "error: reclaim event %x without (remembered) allocation\n",
              addr);
      break;
    }
    break;

  case &CreateE(CreateEvent(time,_,rname,*rstats)):
    assert(strcmp("unique",rname));
    assert(strcmp("heap",rname));
    assert(strcmp("refcnt",rname));

    mark_gc_over();
    Hashtable::insert((_@)regionaddresses_table, new rname,
                      Set::empty(uint_cmp));
    break;

  case &FreeE(FreeEvent(time,rname,*rstats)):
    assert(strcmp("unique",rname));
    assert(strcmp("heap",rname));
    assert(strcmp("refcnt",rname));

    mark_gc_over();
    let rname_p = new rname;
    try {
      let aset = Hashtable::lookup((_@)regionaddresses_table, rname_p);
      Hashtable::remove((_@)regionaddresses_table, rname_p);
      let i = Set::make_iter(Core::heap_region,aset);
      unsigned int addr = 0;
      while (Iter::next(i,&addr)) {
        try {
          let &$(rname2,start_time,count) =
            Hashtable::lookup((_@)allocations_table, addr);
          Hashtable::remove((_@)allocations_table, addr);
          if (strcmp(rname,rname2) != 0) {
            fprintf(stderr,
                    "error: freed region %s seems to contain an allocation "
                    "from another region %s\n",
                    rname,rname2);
          }
          else {
            bytes_freed_other += count;
            add_rect("other",start_time,addr,time,count);
          }
        }
        catch {
        case &Not_found:
          fprintf(stderr,
                  "error: reclaim event %x without (remembered) allocation\n",
                  addr);
          break;
        }
      }
    }
    catch {
    case &Not_found:
      fprintf(stderr,
              "error: free of an unknown region %s\n",
              rname);
      break;
    }
    break;

  case &ResizeE(ResizeEvent(time,rname,count,*rstats)):
    /* NB: count size (but not sign) will be invalid if -nogc is used */
    assert(strcmp("unique",rname));
    assert(strcmp("heap",rname));
    assert(strcmp("refcnt",rname));

    mark_gc_over();
    break;

  case &GcE(GcEvent(time,n,*rstats)):
    mark_gc_over();
    break;

  case &GcAddToHeapE(GcAddToHeapEvent(time,addr,amt,*rstats)):
    gc_blocks = new List(new $(time,addr,amt), gc_blocks);
    if (first_rect) {
      first_rect = false;
      min_x = time; // max_x computed by proc_file
      min_y = addr;
      max_y = addr+amt;
    }
    else {
      if (min_x > time) min_x = time; // max_x computed by proc_file
      if (min_y > addr) min_y = addr;
      if (max_y < addr+amt) max_y = addr+amt;
    }
    break;

  case &MarkE(MarkEvent(time,m)):
    mark_list = new List(new $(time,m), mark_list);
    break;

  }

  return true;
}

static int rect_cmp(rect_t @a, rect_t @b) {
  return strcmp(a[0]->name,b[0]->name);
}
int generate_svg2(string_t<`H> file) {
  init_globals2();

  fn_t clos = fp2fn(proc_event2);
  int ret = proc_file(file,clos);
  if (ret != 0) return ret;
  max_x = (unsigned int)max_time;

  Hashtable::iter(finish_rect,(_@)allocations_table);

  /* print the XML header */
  printf("<?xml version='1.0' encoding='ISO-8859-1'?>\n"
         "<!DOCTYPE svg PUBLIC '-//W3C//DTD SVG 1.0//EN'\n"
         " 'http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd'>\n");

  output_comment("Allocation distribution profile produced by aprof");

  output_comment(aprintf("min_x = %u, max_x = %u, range = %u",
                         min_x, max_x, max_x-min_x));
  output_comment(aprintf("min_y = %u, max_y = %u, range = %u",
                         min_y, max_y, max_y-min_y));

  comment_stats();

  /* start of svg stuff */
  printf("<svg xmlns='http://www.w3.org/2000/svg'\n"
         "     xmlns:xlink='http://www.w3.org/1999/xlink'>\n");

  if (landscape)
    printf("<g transform='rotate(-90)'>\n");
  if (graph_translate)
    printf("<g transform='translate(%s)'>\n",graph_translate);

  unsigned int visible_height = max_y - min_y;
  unsigned int visible_width = max_x - min_x;
  double xscale = 1.0;
  double yscale = 1.0;
  if (visible_width != 0)
    xscale = (double)WIDTH/(double)visible_width;
  if (visible_height != 0)
    yscale = (double)HEIGHT/(double)visible_height;
  printf("<g transform='translate(0,%d) scale(%.12f,-%.12f) translate(%d,%d)'>\n",
         (int)HEIGHT,
         xscale, yscale, -((int)min_x), -((int)min_y));

  printf("<!-- gc blocks -->\n");
  printf("<g fill='%s'>\n", color_of_region("available"));
  for (let l = gc_blocks; l != NULL; l = l->tl) {
    let &$(time,addr,amt) = l->hd;
    printf("<rect x='%u' y='%u' width='%u' height='%u'/>\n",
           time,
           addr,
           max_x-time,
           amt);
  }
  printf("</g>\n");

  printf("<!-- allocations -->\n");
  //  printf("<g opacity='%f'>\n", (double)gc_num/num_gc_events);
  let a = Xarray::to_array((_@)rects);
  let len = numelts(a);
  if (len > 0) {
    Array::msort(rect_cmp,a,len);
    printf("<g opacity='0.8'>\n");
    const char ?rname = a[0]->name;
    printf("<g fill='%s'>\n",color_of_region(rname));
    for (int i = 0; i < len; i++) {
      let &Rect(rname2,gc_num,x,y,width,height) = a[i];
      if (strcmp(rname,rname2) != 0) {
        rname = rname2;
        printf("</g>\n");
        printf("<g fill='%s'>\n",color_of_region(rname));
      }
      printf("<rect x='%u' y='%u' width='%u' height='%u'/>\n",
             x,y,width,height);
    }
    printf("</g>\n");
    printf("</g>\n");
  }

  printf("<!-- garbage collections -->\n");
  printf("<g opacity='%s'>\n",gc_opacity);
  for (let l = gc_list; l != NULL; l = l->tl) {
    let &$(x1,x2) = l->hd;
    printf("<rect x='%u' y='%u' width='%u' height='%u'/>\n",
           x1,min_y,x2-x1,max_y-min_y);
  }
  printf("</g>\n");

  printf("<!-- marks -->\n");
  for (let l = mark_list; l != NULL; l = l->tl) {
    let &$(time,m) = l->hd;
    printf("<path d='M%u,%u v%u' stroke='red' fill='none' opacity='.7'/>\n",
           time,min_y,max_y-min_y);
  }

  printf("</g>\n");

  /* print the legend of the graph */
  printf("<g transform='translate(%f,0)'>\n",WIDTH+20);
  output_legend(color_map);
  printf("</g>\n");

  printf("<!-- x axis caption -->\n");
  if (!x_caption)
    x_caption = "Memory usage, time x address";
  printf("<text x='%f' y='%f' text-anchor='middle'%s>%s</text>\n",
         WIDTH/2,HEIGHT+x_caption_gap,text_properties(),x_caption);

  printf("<!-- y axis caption -->\n");
  if (y_caption) {
    printf("<g transform='translate(%f,%f) rotate(-90)'>\n",
           -y_caption_gap,HEIGHT/2);
    printf("<text x='0' y='0' text-anchor='middle'%s>%s</text>\n",text_properties(),y_caption);
    printf("</g>\n");
  }


  if (graph_translate) printf("</g>\n");
  if (landscape) printf("</g>\n");
  printf("</svg>\n");

  return 0;
}


/**********************************************************************/
/*                                                                    */
/*                    DISTRIBUTION OF LIFETIMES                       */
/*                                                                    */
/**********************************************************************/

/* Map address to time that address was allocated */
static struct Hashtable::Table<unsigned int,clock_t> *
  starttimes_table = NULL;

/* Map lifetime to number of objects with that lifetime */
static struct Hashtable::Table<unsigned int,unsigned int> *
  lifetimes_table = NULL;

static void
init_globals3() {
  if (black_and_white) colors = bw_colors;
  init_fixed_colors();
  starttimes_table =
    Hashtable::create(101,uint_cmp,uint_hash);
  lifetimes_table =
    Hashtable::create(101,uint_cmp,uint_hash);
  regionaddresses_table =
    Hashtable::create(101,strptrcmp,Hashtable::hash_stringptr);
}

static void increment_lifetime(unsigned int lifetime) {
  unsigned int lcount = 0;
  if (Hashtable::try_lookup((_@)lifetimes_table, lifetime, &lcount))
    Hashtable::remove((_@)lifetimes_table, lifetime);
  Hashtable::insert((_@)lifetimes_table, lifetime, lcount+1);
}

static void finish_lifetimes(unsigned int addr, clock_t start_time) {
  unsigned int lifetime = (unsigned int)(max_time - start_time);
  increment_lifetime(lifetime);
}

static bool proc_event3(aprof_event_t event) {
  switch (event) {
  case &AllocE(AllocEvent(time,_,rname,count,*rstats,addr)):
    if (!strcmp(rname,"unique") || !strcmp(rname,"refcnt")) {
      /* NB: count size (but not sign) will be invalid if -nogc is used */
      if (count>0) {
        // remember time for addr in case gc reclaims addr
        Hashtable::insert((_@)starttimes_table,addr,time);
      }
      else {
        // gc did not reclaim, this is (u)free
        try {
          let start_time = Hashtable::lookup((_@)starttimes_table, addr);
          Hashtable::remove((_@)starttimes_table, addr);
          unsigned int lifetime = (unsigned int)(time - start_time);
          increment_lifetime(lifetime);
        }
        catch {
        case &Not_found:
          fprintf(stderr,
                  "error: reclaim event %x without (remembered) allocation\n",
                  addr);
          break;
        }
      }
    }
    else if (!strcmp(rname,"heap")) {
      Hashtable::insert((_@)starttimes_table, addr, time);
    }
    else {
      let rname_p = new rname;
      try {
        let aset = Hashtable::lookup((_@)regionaddresses_table, rname_p);
        Hashtable::remove((_@)regionaddresses_table, rname_p);
        Hashtable::insert((_@)regionaddresses_table, rname_p,
                          Set::insert(aset,addr));
        Hashtable::insert((_@)starttimes_table,addr,time);
      }
      catch {
      case &Not_found:
        fprintf(stderr,
                "error: allocation into an unknown region %s\n",
                rname);
        break;
      }
    }
    break;

  case &ReclaimE(ReclaimEvent(time,addr)):
    try {
      let start_time = Hashtable::lookup((_@)starttimes_table, addr);
      Hashtable::remove((_@)starttimes_table, addr);
      unsigned int lifetime = (unsigned int)(time - start_time);
      increment_lifetime(lifetime);
    }
    catch {
    case &Not_found:
      fprintf(stderr,
	      "error: reclaim event %x without (remembered) allocation\n",
              addr);
      break;
    }
    break;

  case &CreateE(CreateEvent(_,_,rname,_)):
    Hashtable::insert((_@)regionaddresses_table, new rname,
                      Set::empty(uint_cmp));
    break;

  case &FreeE(FreeEvent(time,rname,_)):
    assert(strcmp("unique",rname));
    assert(strcmp("heap",rname));
    assert(strcmp("refcnt",rname));

    let rname_p = new rname;
    try {
      let aset = Hashtable::lookup((_@)regionaddresses_table, rname_p);
      Hashtable::remove((_@)regionaddresses_table, rname_p);
      let i = Set::make_iter(Core::heap_region,aset);
      unsigned int addr = 0;
      while (Iter::next(i,&addr)) {
        let start_time = Hashtable::lookup((_@)starttimes_table, addr);
        Hashtable::remove((_@)starttimes_table, addr);
        unsigned int lifetime = (unsigned int)(time - start_time);
        increment_lifetime(lifetime);
      }
    }
    catch {
    case &Not_found:
      fprintf(stderr,
              "error: free of an unknown region %s\n",
              rname);
      break;
    }
    break;

  case &MarkE(_):
  case &ResizeE(_):
  case &GcE(_):
  case &GcAddToHeapE(_):
    break;
  }

  return true;
}
static unsigned int max_lifetime = 0;
static unsigned int max_lcount = 0;
static unsigned int cumulative_lcount = 0;
static list_t<$(unsigned int,unsigned int)@> lifetimes = NULL;
static void record_lifetime(unsigned int lifetime,unsigned int lcount) {
  if (max_lifetime < lifetime) max_lifetime = lifetime;
  if (max_lcount < lcount) max_lcount = lcount;
  cumulative_lcount += lcount;
  lifetimes = new List(new $(lifetime,lcount),lifetimes);
}

int generate_svg3(string_t<`H> file) {

  init_globals3();

  fn_t clos = fp2fn(proc_event3);
  int ret = proc_file(file,clos);
  if (ret != 0) return ret;

  Hashtable::iter(finish_lifetimes,(_@)starttimes_table);
  Hashtable::iter(record_lifetime,(_@)lifetimes_table);

  unsigned int ?cumulative_arr = calloc(max_lifetime+1,sizeof(unsigned int));
  unsigned int ?lifetimes_arr = calloc(max_lifetime+1,sizeof(unsigned int));
  for (let l = lifetimes; l != NULL; l = l->tl) {
    let &$(lifetime,lcount) = l->hd;
    lifetimes_arr[lifetime] = lcount;
  }
  unsigned int cumulative_lifetime = 0;
  for (let i = 0; i < max_lifetime+1; i++) {
    cumulative_lifetime += lifetimes_arr[i];
    cumulative_arr[i] = cumulative_lifetime;
  }

  /* print the XML header */
  printf("<?xml version='1.0' encoding='ISO-8859-1'?>\n"
         "<!DOCTYPE svg PUBLIC '-//W3C//DTD SVG 1.0//EN'\n"
         " 'http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd'>\n");

  output_comment("Allocation lifetime profile produced by aprof");
  output_comment("Number of objects with a given lifetime");
  output_comment(aprintf("cumulative_lcount = %u",cumulative_lcount));
  output_comment(aprintf("cumulative_lifetime = %u",cumulative_lifetime));
  output_comment(aprintf("max_lifetime = %u",max_lifetime));
  comment_stats();

  /* start of svg stuff */
  printf("<svg xmlns='http://www.w3.org/2000/svg'\n"
         "     xmlns:xlink='http://www.w3.org/1999/xlink'>\n");

  if (landscape)
    printf("<g transform='rotate(-90)'>\n");
  if (graph_translate)
    printf("<g transform='translate(%s)'>\n",graph_translate);

  double xscale = (double)WIDTH/(double)(max_lifetime+1);
  double yscale = 1.0;
  // TJIM: don't print cumulative graph for now
  //  if (cumulative_lcount != 0)
  //    yscale = (double)HEIGHT/(double)cumulative_lcount;
  if (max_lcount != 0)
    yscale = (double)HEIGHT/(double)max_lcount;

  printf("<!-- graph -->\n");
  printf("<g transform='translate(0,%d) scale(%.12f,-%.12f)'>\n",
         (int)HEIGHT,
         xscale, yscale);
  for (let i = 0; i<max_lifetime+1; i++) {
    // TJIM: don't print cumulative graph for now, swamps the other histo
    // TJIM: actually should print it as a percentage curve
    //    printf("<rect fill='green' x='%d' y='0' width='1' height='%d' />\n",
    //           i,cumulative_arr[i]);
    if (lifetimes_arr[i]) // to prevent lots of zero-height bars
      printf("<rect fill='red' x='%d' y='0' width='1' height='%d'/>\n",
             i,lifetimes_arr[i]);
  }
  printf("</g>\n");

  printf("<!-- x and y axes -->\n");
  printf("<path d='M-5,0 0,0' fill='none'"
         " stroke='black' stroke-width='0.1'/>\n"
         "<path d='M 0,%f %f,%f %f,%f' fill='none'"
         " stroke='black' stroke-width='0.1'/>\n",
         HEIGHT, WIDTH, HEIGHT, WIDTH, HEIGHT+5);
  printf("<text x='-10' y='3' text-anchor='end'%s>%d objects</text>\n",
         text_properties(),max_lcount);
  const char ?CE = "clocks";
  if (use_events) CE = "events";
  printf("<text x='%f' y='%f' text-anchor='middle'%s>%d %s</text>\n",
         WIDTH, HEIGHT+18, text_properties(), max_lifetime, CE);

  printf("<!-- x axis caption -->\n");
  if (!x_caption)
    x_caption = "Number of objects with a given lifetime";
  printf("<text x='%f' y='%f' text-anchor='middle'%s>%s</text>\n",
         WIDTH/2,HEIGHT+x_caption_gap,text_properties(),x_caption);

  printf("<!-- y axis caption -->\n");
  if (y_caption) {
    printf("<g transform='translate(%f,%f) rotate(-90)'>\n",
           -y_caption_gap,HEIGHT/2);
    printf("<text x='0' y='0' text-anchor='middle'%s>%s</text>\n",text_properties(),y_caption);
    printf("</g>\n");
  }

  if (graph_translate) printf("</g>\n");
  if (landscape) printf("</g>\n");
  printf("</svg>\n");

  return 0;
}
