/* Copyright (C) 2005 Greg Morrisett, AT&T.
   This file is part of the Cyclone project.

   Cyclone is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   Cyclone is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with Cyclone; see the file COPYING. If not,
   write to the Free Software Foundation, Inc., 59 Temple Place -
   Suite 330, Boston, MA 02111-1307, USA. */

#include <stdio.h>
#include <string.h>
#include <buffer.h>
#include <list.h>
#include <stdlib.h>

#include "bnf.h"
#include "fa.h"
#include "parsergen.h"
#include "earley.h"
#include "earley-dispatch.h"

using List;

static 
void mkTemp(char @pattern) {
  int fd = mkstemp(pattern);
  if (fd < 0 || close(fd) < 0) {
    fprintf(stderr,"Error: problem creating temp file %s\n",pattern);
    exit(1);
  }
}

static
void earley_gen_fsm(string_t<`H> earley_regexp, grammar_t ds){
  /* Convert grammar to weighted NFA */
  char f1[]@zeroterm = "f1-XXXXXX";
  char f2[]@zeroterm = "f2-XXXXXX";
  mkTemp(f1);
  mkTemp(f2);

  // TODO: assume regexp is a symbol for now
  Earley::rule_fsm(f1,f2,ds,SYMB(earley_regexp));

  /* Run FSM */
  let cmd = aprintf("fsmcompile -i %s %s | "
                    "fsmrmepsilon | "
                    "fsmdeterminize | "
                    "fsmprint -i %s",
                    f2,f1,f2);
  if (system(cmd) != 0) {
    fprintf(stderr,"Error: fsm failed\n");
    remove(f1); remove(f2);
    exit(1);
  }
}

static int
earley_mk_dfa(string_t<`H> earley_regexp, grammar_t ds, 
    dfa_t *`H ? pp_dfa, Earley::symb_info_t *`H ? pp_si){
  /* Convert grammar to weighted NFA */
  char f1[]@zeroterm = "f1-XXXXXX";
  char f2[]@zeroterm = "f2-XXXXXX";
  char f3[]@zeroterm = "f3-XXXXXX";
  mkTemp(f1);
  mkTemp(f2);
  mkTemp(f3);

  debugprint(1,"starting rule_fsm(%s,%s)...",f1,f2);
  // TODO: assume regexp is a symbol for now
  Earley::rule_fsm(f1,f2,ds,SYMB(earley_regexp));
  debugprint(1,"done\n");

  /* Run FSM */
  debugprint(1,"starting fsm > %s ...",f3);
  let cmd = aprintf("fsmcompile -i %s %s | "
                    "fsmrmepsilon | "
                    "fsmdeterminize | "
                    "fsmprint -i %s > %s",
                    f2,f1,f2,f3);
  if (system(cmd) != 0) {
    fprintf(stderr,"Error: fsm failed\n");
    remove(f1); remove(f2); remove(f3);
    exit(1);
  }
  debugprint(1,"done\n");

  let r = Earley::fsm2dfa(f3);
  if (!r){
    fprintf(stderr,"Failed to reconstruct DFA.\n");
    remove(f1); remove(f2); remove(f3);
    return -1;
  }

  let $(dfa,_,symb_info) = *r;
  *pp_dfa = new dfa;
  *pp_si = new symb_info;          
  remove(f1); remove(f2); remove(f3);
  return 0;  
}

//////////////////////// Deprecated Earley ////////////////////////////

/***************
 * The following functions were commented out on 2/14/2008. If not used 
 * within three months, they should be deleted.
 ***************/

//// Run earley using our built in earley compiler.
//static
//void earley(string_t<`H> earley_regexp, grammar_t ds){
//  // TODO: assume regexp is a symbol for now
//  let $(dfa,dfa_final,symb_info) = Earley::compile(ds,SYMB(earley_regexp));
//
//  printf("Earley parsing stdin... "); fflush(stdout);
//  int c;
//  let b = Buffer::create(101);
//  while ( (c = fgetc(stdin)) != EOF)
//    Buffer::add_char(b,c);
//  let $(valid,valid_prefix) = Earley::recognize(dfa,symb_info,dfa_final,Buffer::contents(b), 1);
//  printf("done -- is valid string :%d. is valid prefix: %d\n",valid, valid_prefix);
//  fflush(stdout);
//}
//
//// Run earley using fsm.
//static
//void earley_fsm(string_t<`H> earley_regexp, grammar_t ds){
//  dfa_t *p_dfa = NULL;
//  Earley::symb_info_t *p_symb_info = NULL;
//  Set::set_t<st_t> *p_dfa_final = NULL;
//
//  /* Convert grammar to weighted NFA */
//  char f1[]@zeroterm = "f1-XXXXXX";
//  char f2[]@zeroterm = "f2-XXXXXX";
//  char f3[]@zeroterm = "f3-XXXXXX";
//  mkTemp(f1);
//  mkTemp(f2);
//  mkTemp(f3);
//
//  // TODO: assume regexp is a symbol for now
//  Earley::rule_fsm(f1,f2,ds,SYMB(earley_regexp));
//
//  /* Run FSM */
//  let cmd = aprintf("fsmcompile -i %s %s | "
//                    "fsmrmepsilon | "
//                    "fsmdeterminize | "
//                    "fsmprint -i %s > %s",
//                    f2,f1,f2,f3);
//  if (system(cmd) != 0) {
//    fprintf(stderr,"Error: fsm failed\n");
//    remove(f1); remove(f2); remove(f3);
//    exit(1);
//  }
//
//  let r = Earley::fsm2dfa(f3);
//  if (r){
//    let $(dfa,dfa_final,symb_info) = *r;
//    p_dfa = new dfa;
//    p_dfa_final = new dfa_final;
//    p_symb_info = new symb_info;          
//  } else {
//    fprintf(stderr,"Failed to reconstruct DFA.\n");
//    remove(f1); remove(f2); remove(f3);
//    exit(1);
//  }
//
//  remove(f1); remove(f2); remove(f3);
//  printf("Earley parsing stdin... "); fflush(stdout);
//  int c;
//  let b = Buffer::create(101);
//  while ( (c = fgetc(stdin)) != EOF )
//    Buffer::add_char(b,c);
//
//  let $(valid,valid_prefix) = 
//    Earley::recognize(*p_dfa,*p_symb_info, *p_dfa_final,Buffer::contents(b), 0);
//  printf("done -- is valid string :%d. is valid prefix: %d\n",valid, valid_prefix);
//  if (valid) printf("Parse tree saved.\n");
//  fflush(stdout);
//}
//
//static
//void earley_shell(string_t<`H> earley_regexp, grammar_t ds){
//  
//  char cmd[200]@zeroterm={for i<199:0};
//   char arg[200]@zeroterm={for i<199:0};
//   int done = 0;
//   dfa_t *p_dfa = NULL;
//   Earley::symb_info_t *p_symb_info = NULL;
//   Set::set_t<st_t> *p_dfa_final = NULL;
//   while(!done) {
//     int c;
//     
//     // Print prompt.
//     printf("earley:> "); fflush(stdout);
//     
//     // Get the command followed by arbitrary whitespace.
//     scanf("%s",cmd);
//     
//     // Parse command line
//     if (!strcmp(cmd, "compile")) {
//
//       // TODO: assume regexp is a symbol for now
//       let $(dfa,dfa_final,symb_info) = Earley::compile(ds,SYMB(earley_regexp));
//       p_dfa = new dfa;
//       p_dfa_final = new dfa_final;
//       p_symb_info = new symb_info;
//
//     } else if (!strcmp(cmd, "print-nfa")) {
//
//       char filename[200]@zeroterm={for i<199:0};
//       scanf("%s %s",arg,filename);
//
//       if (!strcmp(arg,"fsm")){
//         // TODO: assume regexp is a symbol for now
//         let fsm_file = aprintf("%s.fsm",filename);
//         let sym_file = aprintf("%s.sym",filename);
//         Earley::rule_fsm(fsm_file,sym_file,ds,SYMB(earley_regexp));
//       } else {
//         fprintf(stderr,"Invalid NFA format: %s.\n",arg);
//       }
//       
//     } else if (!strcmp(cmd, "load-dfa")){
//
//       char filename[200]@zeroterm={for i<199:0};
//       scanf("%s %s",arg,filename);
//
//       if (!strcmp(arg,"fsm")){
//         let r = Earley::fsm2dfa(filename);
//         if (r){
//           let $(dfa,dfa_final,symb_info) = *r;
//           p_dfa = new dfa;
//           p_dfa_final = new dfa_final;
//           p_symb_info = new symb_info;            
//         } else {
//           fprintf(stderr,"Failed to reconstruct DFA.\n");
//         }
//       } else {
//         fprintf(stderr,"Invalid DFA format: %s.\n",arg);
//       }
//       
//     } else if (!strcmp(cmd, "print-dfa")){
//
//       char filename[200]@zeroterm={for i<199:0};
//       scanf("%s %s",arg,filename);
//
//       if (!p_dfa || !p_symb_info) {
//         fprintf(stderr, "Need to compile or load DFA first.\n");
//         continue;
//       }
//
//       if (!strcmp(arg,"dot")){
//         // TODO: assume regexp is a symbol for now
//         Earley::dfa2dot(*p_dfa,*p_symb_info,filename);
//       }
//       else if (!strcmp(arg,"cyclone")) {
//         FILE *f = fopen(filename,"w");
//         if (f) { 
//           Earley::dfa2cyclone(f,*p_dfa,*p_symb_info,cyc_namespace,0);
//           fclose(f); 
//         }
//         else fprintf(stderr, "Failed to open file %s.\n",filename);
//       } else if (!strcmp(arg,"haxe")) {
//         FILE *f = fopen(filename,"w");
//         if (f) { 
//           Earley::act2symb_haxe(f,*p_symb_info);
//           dfa_haxe(f,*p_dfa);
//           fclose(f); 
//         }
//         else fprintf(stderr, "Failed to open file %s.\n",filename);
//       } else {
//         fprintf(stderr,"Invalid DFA format: %s.\n",arg);
//       }
//
//     } else if (!strcmp(cmd, "parse")){
//
//       if (!p_dfa || !p_dfa_final){
//         fprintf(stderr, "Need to compile DFA first.\n");
//         continue;
//       }
//
//       // Read file name
//       scanf("%s",arg);
//
//       // Check for options
//       let show_progress = 0;
//       if (!strcmp(arg,"--show-prog")){
//         show_progress = 1;
//         scanf("%s",arg);
//       }
//
//       // Read the file
//       printf("Earley parsing %s ... \n",arg); 
//       FILE *fp = fopen(arg,"r");
//       if (!fp){
//         fprintf(stderr,"Bad file name.\n");
//         continue;
//       }
//       let b = Buffer::create(101);
//       while ( (c = fgetc(fp)) != EOF)
//         Buffer::add_char(b,c);
//       fclose(fp);
//       printf("File read complete.\n"); 
//
//       // Parse the file
//       let $(valid,valid_prefix) = 
//         Earley::recognize(*p_dfa,*p_symb_info, *p_dfa_final,Buffer::contents(b), show_progress);
//       printf("done -- is valid string :%d. is valid prefix: %d\n",valid, valid_prefix);
//       if (valid) printf("Parse tree saved.\n");
//       fflush(stdout);
//
//     } else if (!strcmp(cmd,"amb?")){
//
//       let is_amb = Earley::isAmb_parse_tree(Earley::last_derivation_tree);
//       if (is_amb)
//         printf("Parse tree is ambiguous.\n");
//       else
//         printf("Parse tree is not ambiguous.\n");
//
//     } else if (!strcmp(cmd,"print")){
//
//       scanf("%s",arg);
//       let arg_end = (char @@zeroterm)arg;
//       let depth = strtod(arg,&arg_end);
//       if (arg_end == arg){
//         fprintf(stderr,"Bad depth.\n");
//         continue;
//       }
//       Earley::print_LT(Earley::last_derivation_tree,depth);
//       printf("\n");
//       Earley::print_RT(Earley::last_derivation_tree,depth);
//       printf("\n");
//     } else if (!strcmp(cmd,"exit")){
//       done = 1; // shell is done; exit loop.
//     } else {
//       fprintf(stderr,"Undefined command.\n");
//       continue;
//     }
//   }
//}

////////////////////////////////////////////////////////////
//////////////////// Dispatch //////////////////////////////
////////////////////////////////////////////////////////////

void dispatch_earley(int earley_mode, string_t<`H> earley_regexp, grammar_t ds){
  switch (earley_mode){
    case 0:
      printf("This flag is no longer supported.\n");
      //earley(earley_regexp,ds);
      break;
    case 1:
    case 4:
      printf("This flag is no longer supported.\n");
      break;
    case 2:
      printf("This flag is no longer supported.\n");
      //earley_shell(earley_regexp,ds);
      break;
    case 3: // Use FSM
      printf("This flag is no longer supported.\n");
      //earley_fsm(earley_regexp,ds);
      break;
    // Use FSM to generate dfa  
    case 5: // in dot 
      dfa_t *p_dfa = NULL;
      Earley::symb_info_t *p_symb_info = NULL;
      let err = earley_mk_dfa(earley_regexp, ds, &p_dfa, &p_symb_info);
      if (err) exit(1);
      Earley::dfa2dot(*p_dfa,*p_symb_info,aprintf("/dev/stdout"));
      break;
    case 6: // in cyclone
      dfa_t *p_dfa = NULL;
      Earley::symb_info_t *p_symb_info = NULL;
      let err = earley_mk_dfa(earley_regexp, ds, &p_dfa, &p_symb_info);
      if (err) exit(1);
      Earley::dfa2cyclone(stdout,*p_dfa,*p_symb_info,cyc_namespace,0);
      break;
    case 7: // in haxe
      dfa_t *p_dfa = NULL;
      Earley::symb_info_t *p_symb_info = NULL;
      let err = earley_mk_dfa(earley_regexp, ds, &p_dfa, &p_symb_info);
      if (err) exit(1);
      Earley::act2symb_haxe(stdout,*p_symb_info);
      dfa_haxe(stdout,*p_dfa);
      break;
    case 8:
      earley_gen_fsm(earley_regexp, ds);
      break;
    default:
      fprintf(stderr,"Internal error: invalid value for variable earley_mode.\n");
      break;
  }
}


