/* fa.cyc
 * Finite automata library
 */

/* Copyright (C) 2005 Greg Morrisett, AT&T.
   This file is part of the Cyclone project.

   Cyclone is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   Cyclone is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with Cyclone; see the file COPYING. If not,
   write to the Free Software Foundation, Inc., 59 Temple Place -
   Suite 330, Boston, MA 02111-1307, USA. */

#include <core.h>
#include <stdio.h>
#include <string.h>
#include <hashtable.h>
#include <list.h>
#include <iter.h>
#include <math.h>
#include "bnf.h"
#include "cs.h"
#include "axarray.h"
#include "analyze.h"
#include "fa.h"
#include "nfa_lazy.h"
#include "nfa_eager.h"
#include "pr.h"
#include "util.h"

#include <time.h>

int st_hash(st_t a) { return (int)a; }
int st_cmp(st_t a,st_t b) {
  if (a == b) return 0; else if (a<b) return -1; else return 1;
}
st_t nfa_number_of_states = 1;

int use_lazy_nfa = 1;

void nfa_init(grammar_t grm) {
  if (use_lazy_nfa)
    Nfa_lazy::nfa_init(grm);
  else
    Nfa_eager::nfa_init(grm);
}
st_t nfa_fresh_state() {
  if (use_lazy_nfa)
    return Nfa_lazy::nfa_fresh_state();
  else
    return Nfa_eager::nfa_fresh_state();
}
st_t get_final(st_t a) {
  if (use_lazy_nfa)
    return Nfa_lazy::get_final(a);
  else
    return Nfa_eager::get_final(a);
}
st_t get_etrans(st_t a) {
  if (use_lazy_nfa)
    return Nfa_lazy::get_etrans(a);
  else
    return Nfa_eager::get_etrans(a);
}
cs_opt_t get_action(st_t a) {
  if (use_lazy_nfa)
    return Nfa_lazy::get_action(a);
  else
    return Nfa_eager::get_action(a);
}
st_t get_atrans(st_t a) {
  if (use_lazy_nfa)
    return Nfa_lazy::get_atrans(a);
  else
    return Nfa_eager::get_atrans(a);
}
st_t rule2nfa(grammar_t grm, rule_t r) {
  if (use_lazy_nfa)
    return Nfa_lazy::rule2nfa(grm,r);
  else
    return Nfa_eager::rule2nfa(grm,r);
}
unsigned int what_interval(unsigned int ?intervals, unsigned int key) {
  if (use_lazy_nfa)
    return Nfa_lazy::what_interval(intervals,key);
  else
    return Nfa_eager::what_interval(intervals,key);
}
/* Print out an NFA in DOT format, for display by Graphviz */
void nfa_dot(FILE @f,Set::set_t<st_t> final_states,cs_pred_t special) {
  fprintf(f,"digraph g {\n");
  fprintf(f,"rankdir=LR;\n");
  for (let i = 1; i < nfa_number_of_states; i++) {
    fprintf(f,"%u [ shape = \"%s\"];\n",
	    i,
	    Set::member(final_states,i)?"doublecircle":"circle");
  }
  for (let i = 1; i < nfa_number_of_states; i++) {
    let to = get_atrans(i);
    if (to != NOTRANSITION) {
      let a = get_action(i);
      if (a == EPSILON) {
        // Don't know a good way to print an epsilon on the arrow;
        // UTF-8 for epsilon is 0xCE 0xB5, but it doesn't work so just leave empty
        fprintf(f,"%u -> %u;\n",i,to);
      }
      else {
        fprintf(f,"%u -> %u [ label = \"",i,to);
        cs_dot_print(f,a,special);
        fprintf(f,"\"];\n");
      }
    }
    to = get_etrans(i);
    if (to != NOTRANSITION) {
      fprintf(f,"%u -> %u;\n",i,to);
    }
  }
  fprintf(f,"}\n");
}




unsigned int num_conflicts_ll = 0;
unsigned int num_conflicts_dfa = 0;
unsigned int num_conflicts_change_order = 0;
unsigned int num_conflicts_resolved = 0;
unsigned int num_conflicts_unresolved = 0;
unsigned int num_conflicts_unbounded = 0;

int uint_cmp(unsigned int a, unsigned int b) {
  if (a == b) return 0; else if (a<b) return -1; else return 1;
}

#define iterator(x) (Set::make_iter(Core::heap_region,x))
//static Iter::iter_t<`a> iterator(Set::set_t<`a,`H> x : regions(`a) > `H) {
//  return Set::make_iter(Core::heap_region,x);
//}
#define dict_iter(x) (Dict::make_iter(Core::heap_region,x))
//static Iter::iter_t<$(`a,`b)> dict_iter(Dict::dict_t<`a,`b,`H> x : regions($(`a,`b)) > `H) {
//  return Dict::make_iter(Core::heap_region,x);
//}

const char ?txtfile(const char ?x);

/****************** NFA AND DFA COMMON DEFINITIONS ******************/
// List of glushkov transitions.
typedef List::list_t<$(Set::set_t<st_t>,cs_opt_t,Set::set_t<st_t>) @> glush_trans_t;

void nfa_print(FILE @f) {
  for (let i = 0; i < nfa_number_of_states; i++) {
    fprintf(f,"%d:",i);
    let to = get_atrans(i);
    if (to != NOTRANSITION) {
      let a = get_action(i);
      if (a == EPSILON) fprintf(f," EPSILON->%d",to);
      else { fprintf(f," "); cs_print(f,a); fprintf(f,"->%d",to); }
    }
    to = get_etrans(i);
    if (to != NOTRANSITION) fprintf(f," EPSILON->%d",to);
    fprintf(f,"\n");
  }
}

/************ Code for printing NFA's in FSM format *************/
void 
fsm_glush_print(FILE *`H f_fsm, Set::set_t<st_t> start_states, 
		List::list_t<glush_trans_t> T_list, Set::set_t<st_t> final_states)
{
  // Create a "super" start state and add transitions to all rule start states.
  let super_start = nfa_fresh_state();
  st_t s = 0;
  let out_sym = 1;
  let starts_iter = Set::make_iter(Core::heap_region, start_states);
  while (Iter::next(starts_iter,&s)){
    // Omit weight -- defaults to "one".
    fprintf(f_fsm,"%d %d %s %d\n",super_start,s,"EPSILON",out_sym);
    out_sym++;
  }
    
  for (; T_list != NULL; T_list = List::tl(T_list)) { 
    // Print all transitions in T.
    for (let T = List::hd(T_list); T != NULL; T = List::tl(T)) {
      switch ( List::hd(T) ) {
      case &$(A,EPSILON,B):
	printf("ERROR: EPSILON encountered in Glushkov automata.\n");
        exit(1);
        break;
      case &$(A,cs,B):
	// default output is EPSILON, which is encoded as 0.
	let out = 0;
	st_t source = 0;
	let A_iter = Set::make_iter(Core::heap_region,A);
	while (Iter::next(A_iter,&source)){	  
	  st_t target = 0;
	  let B_iter = Set::make_iter(Core::heap_region,B);
	  while (Iter::next(B_iter,&target)){
	    let chars = cs2list(cs);
	    let num_chars = List::length(chars);
	    let branch_val = log(num_chars);
	    while (chars != NULL){
	      let branch_name = fsm_char_escape(List::hd(chars));
	      fprintf(f_fsm,"%d %d %s %d %lf\n",source,target,branch_name,out,branch_val);
	      chars = List::tl(chars);
	    }
	  }	  
	}
      }
    }
  }

  // Print final states. Default to weight of "one".
  st_t f = 0;
  let F_iter = Set::make_iter(Core::heap_region,final_states);
  while (Iter::next(F_iter,&f)){
    fprintf(f_fsm,"%d\n",f);
  }
}

static void print_act_symb(act_t a, str_t s, FILE @f){
  fprintf(f,"%s %d\n",*s,a);
}

void symbols_fsm(FILE @f, Hashtable::table_t<act_t,str_t> action_symb_table){
  Hashtable::iter_c(print_act_symb, action_symb_table, f); 
}

void nfa_fsm(FILE @f,Set::set_t<st_t> final_states, 
	     Hashtable::table_t<act_t,str_t> action_symb_table,
	     Hashtable::table_t<st_t,act_t> act_table) {
  unsigned int output_symbol = 1;
  for (let i = 0; i < nfa_number_of_states; i++) {
    // Print final state. Default to weight of "one".
    if (Set::member(final_states,i)){
      fprintf(f,"%d\n",i);
      // associate it in the NFA w/ its symbol.
      let s = nfa_fresh_state();
      fprintf(f,"%d %d FINAL-STATE\n",i,s);
      let act = Hashtable::lookup(act_table,i);      
      let symb = Hashtable::lookup(action_symb_table,act);
      fprintf(f,"%d %d %s\n",s,s,*symb);
    }
    int num_branches = 0;
    double branch_val = 1.0;
//     int branch_val = 0;

    let e_to = get_etrans(i);
    if (e_to != NOTRANSITION) num_branches++;

    let a_to = get_atrans(i);
    if (a_to != NOTRANSITION) {
      let a = get_action(i);
      if (a == EPSILON) {
	num_branches++;
 	branch_val = 1.0/(double)num_branches;
// 	branch_val = num_branches;
	fprintf(f,"%d %d EPSILON %lf\n",i,a_to,branch_val);
      }
      else { 
	let acts = cs2list(a);
	num_branches += List::length(acts);
 	branch_val = 1.0/(double)num_branches;
// 	branch_val = num_branches;
	for (; acts; acts = acts->tl){
	  let sopt = Hashtable::lookup_opt(action_symb_table,acts->hd);
	  const char ? branch_name;
	  if (sopt == NULL || *sopt == NULL) 
	    branch_name = fsm_char_escape(acts->hd);
	  else 
	    branch_name = **sopt;
	  fprintf(f,"%d %d %s %lf\n",i,a_to,branch_name, branch_val);
	}
      }
    }
    if (e_to != NOTRANSITION) {      
      fprintf(f,"%d %d EPSILON %lf\n",i,e_to,branch_val);
    }
  }
}

/********* Experimental code for building Glushkov automata **********/
#include <array.h>
#include <sys/stat.h>
#include <errno.h>

const char ?txtfile(const char ?x) {
  return aprintf("ykdebug/%u-%s.txt",num_conflicts_ll,x);

}
const char ?dotfile(const char ?x) {
  return aprintf("ykdebug/%u-%s.dot",num_conflicts_ll,x);
}
void glush_dot(FILE @f, Set::set_t<st_t,`H> S, st_t s, Set::set_t<st_t> F,
	       List::list_t<$(Set::set_t<st_t,`H>,cs_opt_t,Set::set_t<st_t,`H>)@> T) {
  fprintf(f,"digraph {\n");
  let len = Set::cardinality(S);
  /* print nodes */
  for (let x = S; !Set::is_empty(x); 0) {
    let y = Set::choose(x);
    x = Set::delete(x,y);
    if (Set::member(F,y)) 
      fprintf(f,"%u [ label = \"%u\" shape = \"doublecircle\"];\n",
	      y,y);
    else
      fprintf(f,"%u [ label = \"%u\" shape = \"circle\"];\n",
	      y,y);
  }
  /* print transitions */
  while (T) {
    let &$(A,cs,B) = T->hd;
    T = T->tl;
    let AA = NULL;
    while (!Set::is_empty(A)) {
      let a = Set::choose(A);
      A = Set::delete(A,a);
      AA = new List::List(a,AA);
    }
    while (!Set::is_empty(B)) {
      let b = Set::choose(B);
      B = Set::delete(B,b);
      for (let AAA = AA; AAA; AAA = AAA->tl) {
	let a = AAA->hd;
	fprintf(f,"%u -> %u [ label = \"",a,b);
	cs_dot_print(f,cs,NULL);
	fprintf(f,"\"];\n");
      }
    }
  }
  fprintf(f,"}\n");
}

 /* what to return? */
// return start states, transitions, and set of final states of automaton.
$(Set::set_t<st_t>, st_t s, Set::set_t<st_t>,
	       List::list_t<$(Set::set_t<st_t>,cs_opt_t,Set::set_t<st_t>)@>)
rule2glush(grammar_t grm, rule_t r) {
  let st_before = nfa_number_of_states;
  let s = rule2nfa(grm,r);

  debugprint(1,"Created NFA, beginning Glushkov construction.\n");

  let st_after = nfa_number_of_states;
  Set::set_t<st_t> S = Set::singleton(st_cmp,s);
//   let EPS = Graph::empty(st_cmp);
  let REVEPS = Graph::empty(st_cmp);
  for (let i = st_before; i < st_after; i++) {
    // EPS = Graph::add_edge(EPS,i,i);
    REVEPS = Graph::add_edge(REVEPS,i,i);
    let j = get_atrans(i);
    if (j != NOTRANSITION) {
      if (get_action(i) == EPSILON) { // i -> j by EPSILON
	//	EPS = Graph::add_edge(EPS,i,j);
	REVEPS = Graph::add_edge(REVEPS,j,i);
      }
      else {                          // i -> j by non-EPSILON
	S = Set::insert(S,j);
      }
    }
    j = get_etrans(i);
    if (j != NOTRANSITION) {
      //      EPS = Graph::add_edge(EPS,i,j);
      REVEPS = Graph::add_edge(REVEPS,j,i);
    }
  }
//   let TCEPS = Graph::tc(EPS);
  let TCREVEPS = Graph::tc(REVEPS);
  /* TODO: maybe it makes sense to precompute intersection of S with all targets */
  Set::set_t<st_t> F = Set::intersect(S,Graph::get_targets(TCREVEPS,get_final(s)));
  let T = NULL;
  for (let i = st_before; i < st_after; i++) {
    let j = get_atrans(i);
    let cs = get_action(i);
    if (j != NOTRANSITION && cs != EPSILON) {
      let A = Set::intersect(S,Graph::get_targets(TCREVEPS,i));
      let B = Set::singleton(st_cmp,j);
//       let B = Set::intersect(S,Graph::get_targets(TCEPS,j));
      T = new List::List(new $(A,cs,B),T);
    }
  }

  /* At this point the Glushkov automaton is encoded as follows:
     States S
     Start state s
     Final states F
     Transitions encoded as a set T of tuples (A,cs,B) where
       (a -cs-> b) for all states a in A, b in B
  */
  return $(S,s,F,T);
}
void
lookahead_glush(grammar_t grm,List::list_t<rule_t> rules, rule_t right_ctxt) {
  //  if (!rules) return;


//  if (debug) {
    /* Make sure the ykdebug directory exists */
    struct stat sb;
    int err = stat("ykdebug",&sb);
    if (err && errno == ENOENT) {
      if (mkdir("ykdebug",S_IRWXU)) {
	eprintf("ERROR: could not create directory ykdebug\n");
	exit(1);
      }
    }
    else if (err) {
      perror("Error on stat(ykdebug)");
      exit(1);
    }
    else if (!(sb.st_mode & S_IFDIR)) {
      eprintf("ERROR: ykdebug is not a directory\n");
      exit(1);
    }
//  }

  nfa_init(grm);
  let nfa_final_states = Set::empty(st_cmp);
  let T_list = NULL;
  let F_all = Set::empty(st_cmp);
  let s_all = Set::empty(st_cmp);
  for (let rl = rules; rl; rl = rl->tl) {
    let $(S,s,F,T) = rule2glush(grm,SEQ(rl->hd,right_ctxt));
    T_list = new List::List(T,T_list);
    F_all = Set::union_two(F_all,F);
    s_all = Set::insert(s_all,s);
    nfa_final_states = Set::insert(nfa_final_states,get_final(s));
    let ga = aprintf("ga-%d",Set::cardinality(nfa_final_states));
    FILE *f = fopen(dotfile(ga),"w");
    if (f) { glush_dot(f,S,s,F,T); fclose(f); }
  }

//  if (debug) {
    FILE *f = fopen(dotfile("nfa"),"w");
    if (f) { nfa_dot(f,nfa_final_states,NULL); fclose(f); }

    f = fopen(txtfile("fsm"),"w");
    if (f) { fsm_glush_print(f,s_all, T_list, F_all); fclose(f); }

//  }
}


/******************************* DFAS *******************************/
/*
  Each state of a DFA is identified by a number.

  State 0 is a dead state: all transitions out of state 0 lead to
  state 0, and state 0 is not a final state.

  State 1 is the (unique) initial state.

  Each state has a list of transitions out of the state.

  The default transition out of a state is the dead state 0.

  A DFA has a set of final states (unlike the NFAs above which only
  needed a single final state).

  Each final state has some number of "attributes".  Essentially
  the attributes are used to say which of a number of alternatives
  were reached, e.g., in a dfa for a regular expression
  (r1 | r2 | r3) a final state might correspond to final states
  for r1, r2, or r3; we might want to know whether a final state
  of the dfa corresponds to more than one of r1, r2, r3, that tells
  us about ambiguities.
*/

static void att_print(FILE @f, att_t a) {
  fprintf(f,"%u",a);
}
static int att_hash(att_t a) { return (int)a; }
static int att_cmp(att_t a,att_t b) { return Core::intcmp((int)a,(int)b); }
aset_t aset_empty() {
  return Set::empty(att_cmp);
}
aset_t aset_insert(aset_t attrs,att_t x) {
  return Set::insert(attrs,x);
}
aset_t aset_union(aset_t attrs1,aset_t attrs2) {
  return Set::union_two(attrs1,attrs2);
}
aset_t aset_diff(aset_t attrs1,aset_t attrs2) {
  return Set::diff(attrs1,attrs2);
}
aset_t aset_singleton(att_t x) {
  return Set::insert(aset_empty(),x);
}

/* A span indicates that every action in the range [lb,ub), where
   lb is implicit, should cause a transition to target */
struct span {
  st_t  target;
  act_t ub;
};
typedef struct span @span_t;
/* Transitions.  lb is the implicit lower bound for the first span,
   the implicit lb for subsequent spans is given by the ub of the
   previous span. */
struct trans {
  act_t                lb;
  List::list_t<span_t> spans;
};
typedef struct trans @trans_t;
typedef struct trans *trans_opt_t;

struct DFA {
  unsigned int number_of_states;
  Hashtable::table_t<st_t,aset_t> final_attrs; // for final states only
  Axarray::xarray_t<trans_opt_t> states;

  Set::set_t<st_t> final_states; // this could be calculated from final_attrs

  //  Hashtable::table_t<act_t,str_t> act_map;

  // For compression
  // if (ranges) then actions in the transitions are translated
  // as follows:
  // suppose there are n actions numbered 0 to n-1.
  // then ranges has n+1 elements and
  // action 0 is translated to [ range[0],range[1] )
  // ...
  // action n-1 is translated to [ range[n-1],range[n] )
  unsigned int ?ranges;
  unsigned int number_of_actions; // numelts(ranges)-1
};
int dfa_is_final(dfa_t dfa,st_t s) {
  return Set::member(dfa->final_states,s);
}
Set::set_t<st_t> dfa_final_states(dfa_t dfa) {
  return dfa->final_states;
}
aset_t dfa_final_attrs(dfa_t dfa,st_t s) {
  return Hashtable::lookup(dfa->final_attrs,s);
}
st_t target(dfa_t dfa,st_t s,act_t a) {
  let t = Axarray::get(dfa->states,s);
  if (!t) return 0; /* target is the dead state */
  if (a < t->lb) return 0;
  for (let sp = t->spans; sp; sp = sp->tl)
    if (a < sp->hd->ub) return sp->hd->target;
  /* Should never get here */
  // We now use target() sometimes when we do not expect a target
  // internal_err("no target for action %u in state %u\n",a,s);
  return 0;
}

void dfa_add_trans(dfa_t dfa,st_t s, st_t dst, act_t act) {
  let t = Axarray::get(dfa->states,s);
  if (!t) {
    eprintf("Warning: attempt to add transition to dead state.\n");
    return; /* target is the dead state */
  }
  if (act < t->lb) {
    let old_lb = t->lb;
    let sp1 = new span(dst,act+1);
    let sp2 = new span(0,old_lb);
    t->lb = act;
    t->spans = new List::List(sp1,new List::List(sp2, t->spans));
    return;
  }
  let lb = t->lb;
  for (let ss = t->spans; ss; ss = ss->tl){
    if (act < ss->hd->ub){ 
      if (ss->hd->target == dst)
	return; // nothing to change
      let old_span = ss->hd;
      if (act > lb) {
	ss->hd = new span(old_span->target,act);
	ss->tl = new List::List(old_span /* filler, about to be changed */, 
				ss->tl);
	ss = ss->tl;
      }

      ss->hd = new span(dst,act+1);

      if (act+1 < old_span->ub){
	ss->tl = new List::List(new span(old_span->target,old_span->ub),
				ss->tl);
	ss = ss->tl;
      }

      return;
    }
    lb = ss->hd->ub;
  }

  let new_ss = List::list(new span(dst,act+1));
  if (act > lb) {
    new_ss = new List::List(new span(0,act), new_ss);
  } 
  t->spans = List::imp_append(t->spans, new_ss);
}

aset_t dfa_get_transitions(dfa_t dfa,st_t s) {
  let t = Axarray::get(dfa->states,s);
  let txs = Set::empty(st_cmp); // FIX: should be act_cmp
  if (!t) return txs; /* target is the dead state */

  let lb = t->lb;
  for (let sp = t->spans; sp; sp = sp->tl){
    if (sp->hd->target){ // add every element of this span to txs.
      for (int ub = sp->hd->ub; lb < ub; lb++)
	txs = Set::insert(txs,lb);
    } else // skips this span
      lb = sp->hd->ub;
  }

  return txs;
}

// Return pointer to first action not equal to a, for which there's a transition to a non-empty state.
// Return NULL if there is none.
act_t* first_action_but(dfa_t dfa,st_t s,act_t a) {
  let t = Axarray::get(dfa->states,s);
  if (!t) return NULL; /* target is the dead state */

  let lb = t->lb;
  for (let sp = t->spans; sp; sp = sp->tl){
    if (sp->hd->target != 0){
      if (lb != a)
	return new lb;      
      else if (lb+1 < sp->hd->ub)
	// if the next one is still within range, return it.
	// otherwise, move on to next range
	return new (lb+1);
    } 
    lb = sp->hd->ub;
  }
  
  return NULL;
}

dfa_t dfa_create() {
  return new DFA {
    .number_of_states = 1, // there's always a "dead" state 0
      .final_attrs = Hashtable::create(11,att_cmp,att_hash),
      .states = Axarray::create(11,NULL),
      .final_states = Set::empty(st_cmp),
       //      .act_map = Hashtable::create(11,st_cmp,st_hash),
      .ranges = NULL,
      .number_of_actions = MAXACTION+1
      };
}
void dfa_expand(dfa_t dfa) {
  debugprint(1,"Expanding dfa... ");
  if (dfa->ranges) {
    for (let i = 0; i < dfa->number_of_states; i++) {
      let t = Axarray::get(dfa->states,i);
      if (!t) continue;
      t->lb = dfa->ranges[t->lb];
      for (let sp = t->spans; sp; sp = sp->tl) {
	sp->hd->ub = dfa->ranges[sp->hd->ub];
      }
    }
    dfa->ranges = NULL;
    dfa->number_of_actions = MAXACTION+1;
  }
  debugprint(1,"done\n");
}
void dfa_compress(dfa_t dfa) {
  debugprint(1,"Compressing dfa... ");
  Set::set_t<unsigned int> edge_actions = Set::empty(uint_cmp);
  for (let i = 0; i < dfa->number_of_states; i++) {
    let t = Axarray::get(dfa->states,i);
    if (!t) continue;
    let lb = t->lb;
    edge_actions = Set::insert(edge_actions,lb);
    for (let sp = t->spans; sp; sp = sp->tl) {
      edge_actions = Set::insert(edge_actions,sp->hd->ub);
    }
  }
  let num_edge_actions = Set::cardinality(edge_actions);
  debugprint(1,"%d ranges... ",num_edge_actions);
  unsigned int ?ranges = new {for j < num_edge_actions : 0 };

  Dict::dict_t<unsigned int,unsigned int> action_map = Dict::empty(uint_cmp);
  for (let i = 0; !Set::is_empty(edge_actions); i++) {
    let a = Set::choose(edge_actions); // NB: we assume this is sorted
    edge_actions = Set::delete(edge_actions,a);
    ranges[i] = a;
    action_map = Dict::insert(action_map,a,i);
  }
  for (let i = 0; i < dfa->number_of_states; i++) {
    let t = Axarray::get(dfa->states,i);
    if (!t) continue;
    t->lb = Dict::lookup(action_map,t->lb);
    for (let sp = t->spans; sp; sp = sp->tl) {
      sp->hd->ub = Dict::lookup(action_map,sp->hd->ub);
    }
  }
  dfa->ranges = ranges;
  dfa->number_of_actions = numelts(ranges)-1;
  debugprint(1,"done\n");
}
st_t dfa_fresh_state(dfa_t dfa) {
  return dfa->number_of_states++;
}
void dfa_register_state(dfa_t dfa,st_t s) {
  if (dfa->number_of_states <= s)
    dfa->number_of_states = s + 1;
}
void dfa_add_final(dfa_t dfa, st_t final, aset_t attrs) {
  // NB: we allow marking a state final with empty attrs
  aset_t *att_opt = Hashtable::lookup_opt(dfa->final_attrs,final);
  if (att_opt) {
    Hashtable::remove(dfa->final_attrs,final);
    Hashtable::insert(dfa->final_attrs,final,aset_union(*att_opt,attrs));
  }
  else
    Hashtable::insert(dfa->final_attrs,final,attrs);
  dfa->final_states = Set::insert(dfa->final_states,final);
}
void dfa_set_final(dfa_t dfa, st_t final, aset_t attrs) {
  // NB: we allow marking a state final with empty attrs
  aset_t *att_opt = Hashtable::lookup_opt(dfa->final_attrs,final);
  if (att_opt) {
    Hashtable::remove(dfa->final_attrs,final);
  }
  Hashtable::insert(dfa->final_attrs,final,attrs);
  dfa->final_states = Set::insert(dfa->final_states,final);
}

void dfa_print(dfa_t dfa) {
  let len = dfa->number_of_states;
  if (len == 1) eprintf("There is 1 state\n");
  else eprintf("There are %d states\n",len);
  for (let i = 0; i < len; i++) {
    let transitions = Axarray::get(dfa->states,i);
    eprintf("%d",i);
    if (Set::member(dfa->final_states,i)) {
      eprintf("::");
      if (!transitions) {
        eprintf(" -- final attributes");
        fprint_uintset(stderr,Hashtable::lookup(dfa->final_attrs,i));
        continue;
      }
    }
    else {
      eprintf(": ");
      if (!transitions) {
        eprintf("\n");
        continue;
      }
    }
    let lb = transitions->lb;
    for (let spans = transitions->spans; spans; spans = spans->tl) {
      let ub = spans->hd->ub;
      let target = spans->hd->target;
      if (target) {
        if (lb + 1 == ub)
          eprintf(" %s->%d",
                  char_escape(lb),target);
        else
          eprintf(" [%s-%s]->%d",
                  char_escape(lb),char_escape(ub-1),target);
      }
      lb = ub;
    }
    if (Set::member(dfa->final_states,i)) {
      eprintf(" -- final attributes");
      fprint_uintset(stderr,Hashtable::lookup(dfa->final_attrs,i));
    }
    else
      eprintf("\n");
  }
}
/* Print the graph in dot format, for display by GraphViz */
/* Hint: to get the graph to print on one page try
     dot -Tps -Gsize=7,9 | lpr
*/
void dfa_dot(FILE @f, dfa_t dfa, cs_pred_t special) {
  fprintf(f,"digraph g {\n");
  let len = dfa->number_of_states;
  /* print nodes */
  for (let i = 1; i < len; i++) { /* Don't bother printing dead state 0 */
    if (Set::member(dfa->final_states,i)) {
      fprintf(f,"%u [ label = \"%u (",i,i);
      try {
        let x = Hashtable::lookup(dfa->final_attrs,i);
        let y = Set::choose(x);
        x = Set::delete(x,y);
        if (special && special(y))
          fprintf(f,"%s",special(y));
        else
          fprintf(f,"%u",y);
        while (!Set::is_empty(x)) {
          y = Set::choose(x);
          x = Set::delete(x,y);
          if (special && special(y))
            fprintf(f,",%s",special(y));
          else
            fprintf(f,",%u",y);
        }
      } catch {
      default: break; // Set::choose() fails for final state w/o attributes
      }
      fprintf(f,")\" shape = \"doublecircle\"];\n");
    }
    else
      fprintf(f,"%u [ label = \"%u\" shape = \"circle\"];\n",
	      i,i);
  }
  /* print transitions */
  for (let i = 1; i < len; i++) {
    let transitions = Axarray::get(dfa->states,i);
    if (!transitions) continue;
    let target_spans = Hashtable::create(17,st_cmp,st_hash); // map st_t to cs_opt_t
    let targets = Set::empty(st_cmp);
    let lb = transitions->lb;
    cs_opt_t cs = NULL;
    for (let spans = transitions->spans; spans; spans = spans->tl) {
      /* Figure out, for each target, what spans go there
	 (so there is only one arrow from i to each target) */
      let ub = spans->hd->ub;
      let target = spans->hd->target;
      if (target) { /* Don't print transitions to dead state 0 */
	if (!Hashtable::try_lookup(target_spans,target,&cs)) {
          cs = cs_empty();
          Hashtable::insert(target_spans,target,cs);
        }
        cs_union(cs,cs_range(lb,ub));
	targets = Set::insert(targets,target);
      }
      lb = ub;
    }
    while (!Set::is_empty(targets)) {
      /* Now for each target print the spans */
      let target = Set::choose(targets);
      targets = Set::delete(targets,target);
      let x = Hashtable::lookup(target_spans,target);
      //      x = List::imp_rev(x);
      fprintf(f,"%u -> %u [ label = \"",i,target);
      cs_dot_print(f,x,special);
//      for (; x; x = x->tl) {
//	let &$(lb,ub) = x->hd;
//	while (x->tl) { /* Merge adjacent spans */
//	  let &$(lb2,ub2) = x->tl->hd;
//	  if (lb2 != ub) break;
//	  ub = ub2;
//	  x = x->tl;
//	}
//        if (lb + 1 == ub)
//	  fprintf(f,"%s",char_escape(lb));
//        else if (lb + 2 == ub)
//	  fprintf(f,"%s,%s",char_escape(lb),char_escape(ub-1));
//        else
//	  fprintf(f,"%s-%s",char_escape(lb),char_escape(ub-1));
//	if (x->tl) fprintf(f,",");
//      }
      fprintf(f,"\"];\n");
    }
  }
  fprintf(f,"}\n");
}

/* Print the dfa as a haxe datastructure. */
void dfa_haxe(FILE @f, dfa_t dfa) {
  let len = dfa->number_of_states;
  /* print final attributes */
  let first = 1;
  fprintf(f,"var attributes = function (state:Int) {\nswitch (state) {\n");
  for (let i = 1; i < len; i++) {
    if (!Set::member(dfa->final_states,i)) continue;
    fprintf(f,"case %d: return [",i);
    let firstattr = 1;
    let x = Hashtable::lookup(dfa->final_attrs,i);
    while (!Set::is_empty(x)) {
      if (firstattr) firstattr = 0;
      else fprintf(f,",");
      let y = Set::choose(x);
      x = Set::delete(x,y);
      fprintf(f,"%u",y);
    }
    fprintf(f,"];\n");
  }
  fprintf(f,"default: return null;\n}\n};\n");
  
  /* print transitions */
  first = 1;
  fprintf(f,"var transitions = function (state:Int) {\nswitch (state) {\n");
  for (let i = 1; i < len; i++) {
    let transitions = Axarray::get(dfa->states,i);
    if (!transitions) continue;
    let allzeros = 1;
    for (let spans = transitions->spans; spans; spans = spans->tl) {
      if (spans->hd->target == 0) continue;
      allzeros = 0;
      break;
    }
    if (allzeros) continue;
    fprintf(f,"case %d: return function (act:Int):Int {",i);
    fprintf(f,"switch (act) {");
    let lb = transitions->lb;
    for (let spans = transitions->spans; spans; spans = spans->tl) {
      let ub = spans->hd->ub;
      let target = spans->hd->target;
      if (target) { /* Don't print transitions to dead state 0 */
        for (let j = lb; j < ub; j++) {
          fprintf(f," case %d: return %d;",j,target);
        }
      }
      lb = ub;
    }
    fprintf(f,"default: return 0;}};\n");
  }
  fprintf(f,"default: return null;\n}\n};\n");
}

// Create a DFA from an FSM file.
$(dfa_t,Set::set_t<st_t>) *fsm_dfa(const char ?filename, const char ?`H start_symb,
				   act_t (@symb2act)(const char ?`H)) {

  FILE *f = fopen(filename,"w");
  if (!f) {
    fprintf(stderr, "Failed to open file %s.\n",filename);
    return NULL;
  }
  
  dfa_t dfa = dfa_create();

  int src,dst;
  char ?dst_or_val = calloc(100,sizeof(char));
  char ?symb = calloc(100,sizeof(char));
  double val;

  let num_conv = fscanf(f,"%d %s %s %lf\n",&src,dst_or_val,symb,&val);
  for (let lineno = 1; num_conv != EOF; lineno++){
    switch (num_conv) {
    case 0:
      fprintf(stderr, "Parse error: scanf unable to perform any conversions on line: %d.\n", lineno);
      return NULL;
    case 1: // Final state, cost 1
      dfa_register_state(dfa,src);

      dfa->final_states = Set::insert(dfa->final_states,src);
      break;
    case 2: // Final state, given cost
      dfa_register_state(dfa,src);

//       sscanf(dst_or_val,"%lf",&val);
      fprintf(stderr, "Warning (line: %d): cost assigned to final state.\n", lineno);
      dfa->final_states = Set::insert(dfa->final_states,src);
      break;
    case 3: // Arc, cost 1
      dfa_register_state(dfa,src);

      sscanf(dst_or_val,"%d",&dst);
      dfa_add_trans(dfa,src,dst,symb2act(symb));
      break;
    case 4: // Arc, given cost
      dfa_register_state(dfa,src);

      sscanf(dst_or_val,"%d",&dst);
      dfa_add_trans(dfa,src,dst,symb2act(symb));
      break;
    default:
      fprintf(stderr, "Internal error: too many conversions in scanf.\n");
      return NULL;
    }
  } // end while(num_conv != EOF)

  // FIX: should coalesce spans of each state (for efficiency).

  // Build mapping of DFA final states to completed symbols.

  let dfa_final = Set::empty(st_cmp);
  let start_act = symb2act(start_symb);
  let final_st_action = symb2act("FINAL-STATE");

  for (let states = Set::to_list(dfa_final_states(dfa));
       states != NULL; states = states->tl) {
    let s = states->hd;
    let t = target(dfa,s,final_st_action);
    let action_attrs = Set::empty(st_cmp); // should be attr_cmp
    for (let s_txs = Set::to_list(dfa_get_transitions(dfa,t));
         s_txs != NULL; s_txs = s_txs->tl) {
      let act = s_txs->hd;
      if (act == start_act) {
        dfa_final = Set::insert(dfa_final,s);
        // action of the start symbol does not correspond to
        // the parsing of a symbol hence does not return.  So we do not
        // want it in the attributes which indicate what symbols are
        // returning.
        continue;
      }
      action_attrs = Set::insert(action_attrs,act);
    }
    dfa_set_final(dfa,s,action_attrs);
  }

  return new $(dfa,dfa_final);
}


/* Return the graph with an edge between state s and t iff
   s moves to t in a single step, and neither s nor t is
   the dead state */
#define IGNOREDEAD 1
stgraph_t dfa_onestep(dfa_t dfa) {
  let g = Graph::empty(st_cmp);
  for (let i = (IGNOREDEAD?1:0); i < dfa->number_of_states; i++) {
    g = Graph::add_node(g,i);
    let t = Axarray::get(dfa->states,i);
    if (!t) continue;
    if (!IGNOREDEAD && t->lb > 0) {
      g = Graph::add_node(g,0);
      g = Graph::add_edge(g,i,0);
    }
    for (let x = t->spans; x; x = x->tl) {
      let target = x->hd->target;
      if (IGNOREDEAD && !target) continue; /* ignore the dead state */
      g = Graph::add_node(g,target);
      g = Graph::add_edge(g,i,target);
      if (!IGNOREDEAD && x->tl == NULL) {
        if (x->hd->ub < MAXACTION+1) {
          g = Graph::add_node(g,0);
          g = Graph::add_edge(g,i,0);
        }
      }
    }
  }
  return g;
}

/* Return the reachability graph of the states of a dfa,
   ignoring the dead state */
stgraph_t dfa_reachable(dfa_t dfa) {
  return Graph::tc(dfa_onestep(dfa));
}

/* Build a spanning tree with state 1 as the root using a dumb BFS.
   Return the tree as a predecessor array: pred[s] is the parent of s
   in the tree.  pred[s] == 0 iff s is 0, 1, or not reachable from 1. */
static st_t ?dfa_spantree(dfa_t dfa) {
  let onestep = dfa_onestep(dfa);
  let pred = new { for i < dfa->number_of_states : (st_t)0 };
  let working = Set::singleton(st_cmp,1);
  let marked = working;
  while (!Set::is_empty(working)) {
    let next = Set::empty(st_cmp);
    while (!Set::is_empty(working)) {
      let x = Set::choose(working);
      working = Set::delete(working,x);
      let x_targets = Set::diff(Graph::get_targets(onestep,x),marked);
      marked = Set::union_two(marked,x_targets);
      next = Set::union_two(next,x_targets);
      while (!Set::is_empty(x_targets)) {
        let x_target = Set::choose(x_targets);
        x_targets = Set::delete(x_targets,x_target);
        pred[x_target] = x;
      }
    }
    working = next;
  }
  return pred;
}
/* Print an input that reaches state s */
void dfa_example(FILE @f,dfa_t dfa, st_t ?spantree, st_t s) {
  if (s == 1) {
    fprintf(f,"<the empty string>\n");
    return;
  }
  if (spantree[s] == 0) {
    fprintf(f,"<no input reaches state %u>\n",s);
    return;
  }
  let result = NULL;
  let current = s; /* Work backwards from s to the initial state 1  */
  while (current != 1) {
    /* pred is one state closer to the initial state */
    let pred = spantree[current];
    if (pred == 0) goto DFA_EXAMPLE_BAD;
    let t = Axarray::get(dfa->states,pred);
    if (!t) goto DFA_EXAMPLE_BAD;

    /* Find the transition from pred to the current state */
    let lb = t->lb;
    for (let sp = t->spans; sp; sp = sp->tl) {
      let target = sp->hd->target;
      let ub = sp->hd->ub;
      if (target != current) { lb = ub; continue; }
      /* Characters in [lb,ub) go from pred to current; find
         one to use in our example, preferring printable chars */
      int c = lb;
      for (let i = lb; i < ub; i++) {
        if (isprint(i)) { c = i; break; }
      }
      result = new List::List(c,result);
      break;
    }
    current = pred;
  }
  /* Print the example using C string escapes, except that DQUOTE is not escaped */
  for (; result; result = result->tl) {
    switch (result->hd) {
    case '\a': fprintf(f,"\\a"); break;
    case '\b': fprintf(f,"\\b"); break;
    case '\f': fprintf(f,"\\f"); break;
    case '\n': fprintf(f,"\\n"); break;
    case '\r': fprintf(f,"\\r"); break;
    case '\t': fprintf(f,"\\t"); break;
    case '\v': fprintf(f,"\\v"); break;
    case '\\': fprintf(f,"\\\\"); break;
    case c:
      if (c>=' ' && c<='~') fprintf(f,"%c",c);
      else fprintf(f,"\\%d%d%d",((c>>6)&7),((c>>3)&7),(c&7));
      break;
    }
  }
  fprintf(f,"\n");
  return;
 DFA_EXAMPLE_BAD:
  fprintf(f,"Internal error: dfa_example\n");
  return;
}

/* Warn if a final state for alternative A can reach a final state
   for a different alternative B.  This would mean that a string
   matching one alternative used to build the dfa is a prefix of
   a string used to match another alternative.
 */
typedef Set::set_t<Set::set_t<st_t>> stsetset_t;

/* Modify a DFA (if necessary) so that each final state has only one
   attribute.  Ties are broken as follows: when an attribute is also
   the attribute of a previous final state (matching a prefix), we
   drop it.  Otherwise we use the lowest numbered attribute.
   Return true iff a tie had to be broken.
*/
static int leq_all(att_t a,aset_t x) {
  att_t b;
  for (let i = iterator(x); Iter::next(i,&b); ) {
    if (b < a) return 0;
  }
  return 1;
}
int dfa_tiebreak(dfa_t dfa) {
  /* What final states can a given final state reach? */
  let final_reachable = node_intersect(dfa_reachable(dfa),dfa->final_states);

  /* { s | s is a final state with only one attribute } */
  let unique = Set::empty(st_cmp);

  /* { a | there is a final state with attribute a and no other attribute } */
  let unique_attrs = Set::empty(att_cmp);

  /* { s | s is a final state with more than one attribute } */
  let shared = Set::empty(st_cmp);

  st_t f;
  for (let i = iterator(dfa->final_states); Iter::next(i,&f); ) {
    let f_attrs = Hashtable::lookup(dfa->final_attrs,f);
    let num_f_attrs = Set::cardinality(f_attrs);
    switch (num_f_attrs) {
    case 0:
      internal_err("final state %u has no attributes\n",f);
      break;
    case 1:
      unique = Set::insert(unique,f);
      unique_attrs = Set::insert(unique_attrs,Set::choose(f_attrs));
      break;
    default:
      shared = Set::insert(shared,f);
      break;
    }
  }

  if (Set::cardinality(shared) == 0){
    eprintf("All LL(1) conflicts were resolved in the lookahead dfa\n");
    return 0;
  }

  let spantree = dfa_spantree(dfa);
  for (let i = iterator(shared); Iter::next(i,&f); ) {
    num_conflicts_dfa++;
    let f_attrs = Hashtable::lookup(dfa->final_attrs,f);

    eprintf("Some input matches these alternatives simultaneously:");
    fprint_uintset(stderr,f_attrs);
    eprintf("Example: ");
    dfa_example(stderr,dfa,spantree,f);

    let attrs = f_attrs;
    st_t g;
    for (let j = iterator(unique); Iter::next(j,&g); ) {
      if (Graph::is_edge(final_reachable,g,f)) {
        let g_attrs = Hashtable::lookup(dfa->final_attrs,g);
        attrs = Set::diff(attrs,g_attrs);
      }
    }
    if (Set::cardinality(attrs) == 1) {
      num_conflicts_resolved++;
      let chosen = Set::choose(attrs);
      eprintf("Choose %u to win by prefix test\n",chosen);
      Hashtable::insert(dfa->final_attrs,f,attrs);
      if (!leq_all(chosen,f_attrs)) {
	num_conflicts_change_order++;
	eprintf("*** THIS IS A CHANGE IN ORDER\n");
      }
      continue;
    }
    attrs = Set::diff(attrs,unique_attrs);
    if (Set::cardinality(attrs) == 1) {
      num_conflicts_resolved++;
      let chosen = Set::choose(attrs);
      eprintf("Choose %u to win by exclusive test\n",chosen);
      Hashtable::insert(dfa->final_attrs,f,attrs);
      if (!leq_all(chosen,f_attrs)) {
	num_conflicts_change_order++;
	eprintf("*** THIS IS A CHANGE IN ORDER\n");
      }
      continue;
    }
    num_conflicts_unresolved++;
    let chosen = Set::choose(f_attrs); // NB: WE ASSUME THIS IS THE SMALLEST
    eprintf("Unable to resolve by prefix test or exclusive test (so %u wins)\n",chosen);
    Hashtable::insert(dfa->final_attrs,f,Set::singleton(att_cmp,chosen));
  }
  return Set::cardinality(shared);
}

/********************** NFA TO DFA CONVERSION **********************/
/* The subset construction.
   There are the usual exponential blowup issues. */

/* An nstate is a set of nfa states plus a hash value, used
   for making maps from nstates.  We ensure that the dead
   nfa state 0 never appears in the set; this makes sense
   because there is a default transition to 0. */
typedef $(int,Set::set_t<st_t>) @nstate_t; // int is hash value = sum of elements
static int
nstate_hash(nstate_t n) {
  return (*n)[0];
}
static int
nstate_cmp(nstate_t n1, nstate_t n2) {
  return Set::setcmp((*n1)[1],(*n2)[1]);
}
static nstate_t
nstate_empty() {
  return new $(0,Set::empty(st_cmp));
}
static nstate_t
nstate_insert(nstate_t n,st_t a) {
  let &$(h,s) = n;
  if (a == 0 || Set::member(s,a)) return n;
  return new $(h+a,Set::insert(s,a));
}

// Convert a set of states to an nstate.
static nstate_t
stset2nstate(Set::set_t<st_t,`H> X) {
  let result = nstate_empty();
  while (!Set::is_empty(X)) {
    let x = Set::choose(X);
    X = Set::delete(X,x);
    result = nstate_insert(result,x);
  }
  return result;
}

static nstate_t
nstate_singleton(st_t a) {
  return nstate_insert(nstate_empty(),a);
}
static nstate_t
nstate_union(nstate_t n1,nstate_t n2) {
  let &$(h1,s1) = n1;
  let &$(h2,s2) = n2;
  return new $(h1+h2,Set::union_two(s1,s2));
}
/* NB: notice that if a==0 then because we keep 0
   out of the set, the membership test will return false.
   This is fine because nstate_member is only used in
   epsilon_close, where this is fine. */
static int
nstate_member(nstate_t n,st_t a) {
  let &$(h,s) = n;
  return Set::member(s,a);
}
static nstate_t
epsilon_close(nstate_t n) {
  let &$(h,s) = n;
  let result = nstate_empty();
  /* Invariant: s and result are disjoint */
  while (!Set::is_empty(s)) {
    let a = Set::choose(s);
    s = Set::delete(s,a);
    result = nstate_insert(result,a);
    let b = get_etrans(a);
    if (!(b == NOTRANSITION || nstate_member(result,b)))
      s = Set::insert(s,b);
    if (get_action(a) == EPSILON) {
      b = get_atrans(a);
      if (!(b == NOTRANSITION || nstate_member(result,b)))
	s = Set::insert(s,b);
    }
  }
  return result;
}

// return mapping from actions to state sets. Mapping from a to S
// indicates that on input a, all states in S are reachable.
// First value of tuple is minimum action. 
static $(act_t,nstate_t ?) transitions(nstate_t n) {
  let &$(h,s) = n; // NB: Assume n is epsilon closed
  List::list_t<$(cs_t,st_t)@> ts = NULL;

  // Collect action,target pairs.
  while (!Set::is_empty(s)) {
    let a = Set::choose(s);
    s = Set::delete(s,a);
    let b = get_atrans(a);
    if (b == NOTRANSITION) continue;
    let act = get_action(a);
    if (act == EPSILON) continue;
    ts = new List::List(new $(act,b),ts);
  }

  // Determine minimum and maximum "actionable" chars.
  let lb = MAXACTION;
  let ub = 0;
  for (let t = ts; t; t = t->tl) {
    let &$(act,target) = t->hd;
    if (is_cs_empty(act)) continue;
    let $(min,max) = cs_bounds(act);
    if (min < lb) lb = min;
    if (max > ub) ub = max;
  }

  // Construct mapping from "actionable" chars to state-sets.
  let num_actions = (ub>=lb)?(ub-lb+1):(0);
  let default_nstate = nstate_empty();
  let targets = new {for i < num_actions : default_nstate};
  for (let i = lb; i <= ub; i++) {
    for (let t = ts; t; t = t->tl) {
      let &$(act,target) = t->hd;
      if (!cs_member(act,i)) continue;
      targets[i-lb] = nstate_insert(targets[i-lb],target);
    }
  }
  return $(lb,targets);
}

/* The Thompson construction */
dfa_t nfa2dfa(st_t start_state, Set::set_t<st_t,`H> final_states) {
  // nstate = set of nfa states
  // dstate = a dfa state = an int
  //  eprintf("NFA start state is %d\n",start_state); fflush(stderr);
  dfa_t dfa = dfa_create();
  let n_curr_unclosed = stset2nstate(Set::singleton(st_cmp,start_state));
  let n_curr = epsilon_close(n_curr_unclosed);
  let d_curr = dfa_fresh_state(dfa);
  let n2d = Hashtable::create(101,nstate_cmp,nstate_hash);
  let d2n = Hashtable::create(101,st_cmp,st_hash);
  let d_todo = Set::empty(st_cmp);
  let d_done = Set::empty(st_cmp);

  Hashtable::insert(n2d,n_curr,d_curr);
  Hashtable::insert(d2n,d_curr,n_curr);
  /* It's a big win to add un-epsilon-closed states to the mapping,
     because epsilon-closure is expensive. */
  Hashtable::insert(n2d,n_curr_unclosed,d_curr);
  { /* add the dead state */
    let empty = nstate_empty();
    Hashtable::insert(n2d,empty,0);
    Hashtable::insert(d2n,0,empty);
    d_done = Set::insert(d_done,0);
  }
  {
    let &$(_,nfa_states) = n_curr;
    let nfa_final = Set::intersect(nfa_states,final_states);
    if (!Set::is_empty(nfa_final))
      dfa_add_final(dfa,d_curr,nfa_final);
  }
  d_todo = Set::insert(d_todo,d_curr);

  // Invariant: d_done and d_todo are disjoint
  while (!Set::is_empty(d_todo)) {
    d_curr = Set::choose(d_todo);
    d_todo = Set::delete(d_todo,d_curr);
    d_done = Set::insert(d_done,d_curr);
    n_curr = Hashtable::lookup(d2n,d_curr);
    let $(lb,ts) = transitions(n_curr);
    let last_d = 0;
    let last_ub = lb;
    let first_time = 1;
    let spans = NULL;
    for (let i = 0; i < numelts(ts); i++) {
      let a = i + lb;
      let n_unclosed = ts[i];
      let d;
      if (!Hashtable::try_lookup(n2d,n_unclosed,&d)) {
        let n = epsilon_close(n_unclosed);
        if (!Hashtable::try_lookup(n2d,n,&d)) {
          d = dfa_fresh_state(dfa);
          Hashtable::insert(n2d,n,d);
          Hashtable::insert(d2n,d,n);
          let &$(_,nfa_states) = n;
          let nfa_final = Set::intersect(nfa_states,final_states);
          if (!Set::is_empty(nfa_final))
            dfa_add_final(dfa,d,nfa_final);
        }
        Hashtable::insert(n2d,n_unclosed,d);
      }
      if (!Set::member(d_done,d)) d_todo = Set::insert(d_todo,d);
      if (first_time) { last_d = d; first_time = 0; }
      else if (d != last_d) {
        spans = new List::List(new span(last_d,i+lb),spans);
        last_ub = i + lb;
        last_d = d;
      }
    }
    if (numelts(ts)) {
      spans = new List::List(new span(last_d,lb+numelts(ts)),spans);
    }
    spans = List::imp_rev(spans);
    Axarray::set(dfa->states,d_curr,new trans(lb,spans));
  }
  //  eprintf("The dfa has %u states\n",dfa->number_of_states);
  return dfa;
}

/* Try to build a minimal dfa that will distinguish the final states.
   About the same as the nfa2dfa algorithm but stop sooner if possible. */
/* This construction does not build as small as dfa as we want.

   Consider
      foo = 1*("A"|"B").
      bar = "A" 1*("A"|"B").
   If we use foo and bar as the choices and minimize the result we get

       [1] ---A--> [[2]] --A,B--> [[4]]<-+
        |                           |    |A,B
        B                           \____/
        |
        v
      [[3]]

   where [[2]] and [[3]] indicate foo, and [[4]] indicates both foo
   and bar.  The idea is that the longest match indicates the
   alternative to choose.  The problem here is the self-loop for state
   [[4]].  In fact we could just eliminate this self loop, since all
   non-dead states reachable from [[4]] indicate the same
   alternatives, foo and bar.  The problem is, our algorithm is
   building things up incrementally and does not know that paths out
   of [[4]] can never distinguish foo and bar; that's only evident
   after the dfa is built.

   Also, having seen the result of this algorithm, we may choose to
   give some alternatives precedence over others; for example, we
   could give bar precedence over foo, since otherwise it is not going
   to be accepted at all.  This corresponds to changing the final
   attributes of the dfa, and then we might be able to do even more
   minization.

   So, this algorithm should have a second pass that eliminates
   cases like this.
*/
static Set::set_t<unsigned int>
st2ivals(unsigned int ?intervals,Set::set_t<st_t,`H> s) {
  let result = Set::empty(uint_cmp);
  while (!Set::is_empty(s)) {
    let x = Set::choose(s);
    s = Set::delete(s,x);
    result = Set::insert(result,what_interval(intervals,x));
  }
  return result;
}
#define DFASTATELIMIT 600 /* We give up after generating this many states */
#define CUTOFF 1 /* TEMPORARY */
dfa_t nfa_distinguish(Set::set_t<st_t,`H> start_states,
                      Set::set_t<st_t,`H> final_states,
                      unsigned int ?intervals) {
  time_t start_time = time(NULL);
  debugprint(1,"NFA has %u states\n",nfa_number_of_states);
  debugprint(1,"Building distinguishing dfa... ");
  // nstate = set of nfa states
  // dstate = a dfa state = an int
  dfa_t dfa = dfa_create();
  let n_curr_unclosed = stset2nstate(start_states);
  let n_curr = epsilon_close(n_curr_unclosed);
  let d_curr = dfa_fresh_state(dfa);
  let n2d = Hashtable::create(101,nstate_cmp,nstate_hash);
  let d2n = Hashtable::create(101,st_cmp,st_hash);
  let d_todo = Set::empty(st_cmp);
  let d_done = Set::empty(st_cmp);

  Hashtable::insert(d2n,d_curr,n_curr);
  Hashtable::insert(n2d,n_curr,d_curr);
  /* It's a big win to add un-epsilon-closed states to the mapping,
     because epsilon closure is expensive. */
  Hashtable::insert(n2d,n_curr_unclosed,d_curr);
  { /* Add the dead state */
    let empty = nstate_empty();
    Hashtable::insert(n2d,empty,0);
    Hashtable::insert(d2n,0,empty);
    d_done = Set::insert(d_done,0);
  }
  { /* See if the initial dfa state is a final state */
    let &$(_,nfa_states) = n_curr;
    let fs = Set::intersect(nfa_states,final_states);
    if (!Set::is_empty(fs)) {
      let ivals = st2ivals(intervals,fs);
      dfa_add_final(dfa,d_curr,ivals);
    }
  }
  d_todo = Set::insert(d_todo,d_curr);

  let gaveup = NULL;
  let no_state_limit_warned = 1; // flag indicating whether the user
				 // has been warned that the state
				 // limit has been exceeded.
  /* Invariant: d_done and d_todo are disjoint */
  while (!Set::is_empty(d_todo)) {
    d_curr = Set::choose(d_todo);
    d_todo = Set::delete(d_todo,d_curr);
    d_done = Set::insert(d_done,d_curr);
    n_curr = Hashtable::lookup(d2n,d_curr);

    if (dfa->number_of_states > DFASTATELIMIT) {
      /* We decided to give up, mark this state as final for all reachable alternatives */
      let &$(_,nfa_states) = n_curr;
      let ivals = st2ivals(intervals,nfa_states);
      dfa_add_final(dfa,d_curr,ivals);
      gaveup = new List::List(new $(d_curr,ivals),gaveup);
      continue;
    }

    let $(lb,ts) = transitions(n_curr);
    let last_d = 0;
    let last_ub = lb;
    let first_time = 1;
    let spans = NULL;
    for (let i = 0; i < numelts(ts); i++) {
      let a = i + lb;
      let n_unclosed = ts[i];
      let d;
      if (!Hashtable::try_lookup(n2d,n_unclosed,&d)) {
        let n = epsilon_close(n_unclosed);
        if (!Hashtable::try_lookup(n2d,n,&d)) {
          if ((dfa->number_of_states % 100) == 0) {
            debugprint(1,"+"); fflush(stderr);
          }
          d = dfa_fresh_state(dfa);
          Hashtable::insert(n2d,n,d);
          Hashtable::insert(d2n,d,n);
          let &$(_,nfa_states) = n;
          let nfa_final_states = Set::intersect(nfa_states,final_states);
          let ivals = st2ivals(intervals,nfa_states);
          if (CUTOFF && Set::cardinality(ivals) == 1) {
	    debugprint(1,"Cutting off. Number of DFA states = %d.\n", dfa->number_of_states);
            d_done = Set::insert(d_done,d);
            dfa_add_final(dfa,d,ivals);
          }
          else if (dfa->number_of_states >= DFASTATELIMIT) {
            d_done = Set::insert(d_done,d);
            dfa_add_final(dfa,d,ivals); /* Note, we simply don't know whether the ivals are separable */
            gaveup = new List::List(new $(d,ivals),gaveup);
          }
          else if (!Set::is_empty(nfa_final_states))
            dfa_add_final(dfa,d,st2ivals(intervals,nfa_final_states));
        }
	// invariant: d is the dfa state corresponding to the epsilon-closure of n_unclosed.
        Hashtable::insert(n2d,n_unclosed,d);
      }
      if (!Set::member(d_done,d)) d_todo = Set::insert(d_todo,d);
      if (first_time) { last_d = d; first_time = 0; }
      else if (d != last_d) {
        spans = new List::List(new span(last_d,i+lb),spans);
        last_ub = i + lb;
        last_d = d;
      }
    }
    if (numelts(ts)) {
      spans = new List::List(new span(last_d,lb+numelts(ts)),spans);
    }
    spans = List::imp_rev(spans);
    Axarray::set(dfa->states,d_curr,new trans(lb,spans));
    if (dfa->number_of_states >= DFASTATELIMIT && no_state_limit_warned){
      no_state_limit_warned = false;
      warn("dfa state limit exceeded\n");
    }
  }
  if (gaveup && debug) {
    let spantree = dfa_spantree(dfa);
    for (; gaveup; gaveup = gaveup->tl) {
      let &$(d,ivals) = gaveup->hd;
      eprintf("Gave up trying to distinguish alternatives");
      fprint_uintset(stderr,ivals);
      eprintf(" on the following input: ");
      dfa_example(stderr,dfa,spantree,d);
    }
  }
  let delta = time(NULL) - start_time;
  debugprint(1,"elapsed time %d\n",delta);
  debugprint(1,"The dfa has %u states\n",dfa->number_of_states);
  return dfa;
}

/* What nfa final states are reachable from a set of nfa states? */
static Set::set_t<st_t>
final_reachable(stgraph_t reachable,Set::set_t<st_t,`H> final_states,nstate_t ns) {
  let &$(_,s) = ns;
  let result = Set::empty(st_cmp);
  while (!Set::is_empty(s)) {
    let x = Set::choose(s);
    s = Set::delete(s,x);
    result = Set::union_two(result,Set::intersect(final_states,Graph::get_targets(reachable,x)));
  }
  return result;
}

/* Does the dfa accept strings of unbounded length? */
int dfa_unbounded(dfa_t dfa) {
  let reachable = dfa_reachable(dfa);
  let cyclic_states = Set::empty(st_cmp);
  for (let i = 1; i < dfa->number_of_states; i++) {
    if (Graph::is_edge(reachable,i,i)) {
      cyclic_states = Set::insert(cyclic_states,i);
    }
  }

  let unbounded_attrs = Set::empty(att_cmp);
  st_t f;
  for (let i = iterator(dfa->final_states); Iter::next(i,&f); ) {
    st_t g;
    for (let j = iterator(cyclic_states); Iter::next(j,&g); ) {
      if (Graph::is_edge(reachable,g,f)) {
	let f_attrs = Hashtable::lookup(dfa->final_attrs,f);
	unbounded_attrs = Set::union_two(unbounded_attrs,f_attrs);
	break;
      }
    }
  }
  if (Set::cardinality(unbounded_attrs)) {
    eprintf("The following attributes may require unbounded lookahead:");
    fprint_uintset(stderr,unbounded_attrs);
    return 1;
  }
  return 0;
}

/************************* DFA MINIMIZATION *************************/
/* Hopcroft's algorithm as explained by Gries */

/* Currently we have a time/space dependence on the number of possible
   actions, which will be a problem if we want to support Unicode.
   However, it is sufficient for minimization to consider only those
   actions which start a new range out of a state in the dfa.  Proof:

   If (Bj,a) splits Bi, then there are states s,t in Bi such that
   delta(s,a) in Bj and delta(t,a) not in Bj.  Now suppose a is not
   the start of a range out of s and t.  Then
     delta(s,a) == delta(s,a-1)
     delta(t,a) == delta(t,a-1)
   hence it would be sufficient to consider (Bj,a-1) instead of (Bj,a).
   Repeat until you reach an a that is the start of a range.

   Therefore, instead of looping over all actions, we can loop over
   all actions that start ranges.
*/

/* Return an array delta_inv such that delta_inv[s][a] is the set of states that
   transition to state s on action a */
/* Note the space dependence on MAXACTION */
typedef Set::set_t<st_t> @{MAXACTION+1} ?delta_inv_t;
static delta_inv_t make_delta_inv(dfa_t dfa) {
  /* For each state a mapping from actions to state sets */
  let emptyset = Set::empty(st_cmp);
  let result = new {for i < dfa->number_of_states : new {for j < MAXACTION+1 : emptyset }};
  for (let i = 0; i < dfa->number_of_states; i++) {
    let smap = result[i];
    switch (Axarray::get(dfa->states,i)) {
    case NULL: break;
    case t:
      let lb = t->lb;
      {
        let zmap = result[0];
        for (let a = 0; a < lb; a++)
          zmap[a] = Set::insert(zmap[a],i);
      }
      for (let x = t->spans; x; x = x->tl) {
        let ub = x->hd->ub;
        let target = x->hd->target;
        let tmap = result[target];
        for (let a = lb; a < ub; a++)
          tmap[a] = Set::insert(tmap[a],i);
        lb = ub;
      }
    }
  }
  return result;
}
/* Calculate the set of states that transition to a state B on action a; */
/* the union of the sets delta_inv[s][a] for all s in B */
static Set::set_t<st_t>
B_delta_inv(delta_inv_t delta_inv, Set::set_t<st_t,`H> B, act_t a) {
  let result = Set::empty(st_cmp);
  let B_iter = iterator(B);
  st_t s;
  while (Iter::next(B_iter,&s))
    result = Set::union_two(result,delta_inv[s][a]);
  return result;
}
static inline void L_insert_f(int ?L,unsigned int i) {
  if (L[i] >= 0) return;
  let last = numelts(L)-1;
  let next = L[last];
  L[last] = i;
  L[i] = next;
  return;
}
static inline int L_member_f(int ?L,unsigned int i) {
  return L[i] >= 0;
}
static inline int L_next_f(int ?L) {
  let last = numelts(L)-1;
  if (L[last] == last) return -1;
  let result = L[last];
  L[last] = L[result];
  return result;
}
/* We do not eliminate unreachable states. */
dfa_t dfa_minimize0(dfa_t dfa);
dfa_t dfa_minimize(dfa_t dfa) {
  if (1) {
    dfa_compress(dfa);
    dfa = dfa_minimize0(dfa);
    dfa_expand(dfa);
    return dfa;
  }
  else return dfa_minimize0(dfa);
}
dfa_t dfa_minimize0(dfa_t dfa) {
  time_t start_time = time(NULL);
  debugprint(1,"Minimizing... ");
  unsigned int number_of_blocks = 1; // Block 0 is for non-final states (state 0 is always non-final)
  unsigned int ?state2block = new {for i < dfa->number_of_states : 0};
  let block2states = Axarray::create(101,Set::empty(st_cmp));

  /* A straightforward representation of L as
       Set::set_t<$(unsigned int,unsigned int)@>
     turns out to be a bottleneck.  This one trades off space for speed.
     It is the same as the one in Gries' paper, but is singly-linked
     instead of doubly-linked.
     Not suitable for unicode because space is proportional to MAXACTION. */
  unsigned int last = dfa->number_of_states * (dfa->number_of_actions + 1);
  int ?L = new { for i < last+1 : -1 };
  L[last] = last;
#define L_insert(i) L_insert_f(L,i)
#define L_member(i) (L[i]>=0)
#define L_next L_next_f(L)

  /* Determine the initial partition of the states into blocks.
     A state s is in the same block as state t if
         (s is final iff t is final) and
         (the final attributes of s equal the final attributes of t)
     In the case where all final states have the same attributes, this
     is the same as Hopcroft's algorithm.
     The work list L is set up to contain the splits for all final blocks
     (we don't bother to see if the non-final block is smaller than some
     final block).
  */
  {
    let attrs2block = Hashtable::create(101,nstate_cmp,nstate_hash);
    for (let i = 0; i < dfa->number_of_states; i++) {
      unsigned int b = 0;
      if (Set::member(dfa->final_states,i)) {
        let attrs = stset2nstate(Hashtable::lookup(dfa->final_attrs,i));
        if (!Hashtable::try_lookup(attrs2block,attrs,&b)) {
          b = number_of_blocks++;
          Hashtable::insert(attrs2block,attrs,b);
        }
      }
      state2block[i] = b;
      Axarray::set(block2states,b,Set::insert(Axarray::get(block2states,b),i));
    }
    for (let block = 0; block < number_of_blocks; block++) {
      // TODO: Not sure why we have to insert all blocks here.  It should
      // be sufficient to insert all but block 0.  However, this demonstrably
      // fails for conflict 19 of imap.bnf.
      let b = block * (dfa->number_of_actions);
      for (let i = 0; i < dfa->number_of_actions; i++)
	L_insert(b+i);
    }
  }

  if (number_of_blocks < 2) {
    /* No final states.  So return the minimal non-accepting DFA: two
       states, one dead, and an initial state that is not a final
       state and that transitions to the dead state on every action */
  DEAD:
    let result = dfa_create();
    result->ranges = dfa->ranges;
    result->number_of_actions = dfa->number_of_actions;
    dfa_fresh_state(result);
    let delta = time(NULL) - start_time;
    debugprint(1,"+elapsed time %d\n",delta);
    return result;
  }

  let delta_inv = make_delta_inv(dfa);

  /* The main loop of Hopcroft's algorithm. */
  int Lidx;
  while ( (Lidx = L_next) >= 0) {
    let a = Lidx % (dfa->number_of_actions);
    let Bj_num = Lidx / (dfa->number_of_actions);
    let Bj = Axarray::get(block2states,Bj_num);
    let Bj_inv = B_delta_inv(delta_inv,Bj,a);
    st_t s_in_Bj_inv;
    let D = Set::empty(uint_cmp);
    for (let x = iterator(Bj_inv); Iter::next(x,&s_in_Bj_inv); ) {
      D = Set::insert(D,state2block[s_in_Bj_inv]);
    }
    unsigned int i;
    for (let x = iterator(D); Iter::next(x,&i); ) {
      let Bi = Axarray::get(block2states,i);
      let B1 = Set::intersect(Bi,Bj_inv);
      if (Set::cardinality(B1) == Set::cardinality(Bi))
	// all in, so no split here
	continue;
      let B2 = Set::diff(Bi,B1);

      /* After this, B1 will replace Bi as block number i,
	 and B2 will be a new block number number_of_blocks. */
      let Bi_num = i;
      let B1_num = i;
      let B2_num = number_of_blocks++;
      for (let c = 0; c < dfa->number_of_actions; c++) {
        if (L_member(Bi_num*(dfa->number_of_actions)+c)) // (Bi,c) in L
          // L = L - (Bi,c) + (B1,c) + (B2,c), noting Bi and B1 have same index
	  L_insert(B2_num*(dfa->number_of_actions)+c);
        else if (Set::cardinality(B1) < Set::cardinality(B2))
	  L_insert(B1_num*(dfa->number_of_actions)+c);
        else
	  L_insert(B2_num*(dfa->number_of_actions)+c);
      }
      Axarray::set(block2states,B1_num,B1); // overwriting Bi
      Axarray::set(block2states,B2_num,B2);
      while (!Set::is_empty(B2)) {
        let s = Set::choose(B2);
        B2 = Set::delete(B2,s);
        state2block[s] = B2_num;
      }
    }
  }

  /* The analysis is done.  Now we construct the minimal dfa,
     with one state for each block */

  /* Make sure the original dead state 0 maps to the new dead state 0. */
  if (state2block[0] != 0) {
    let s = state2block[0];
    for (let i = 0; i < dfa->number_of_states; i++)
      if (state2block[i] == s) state2block[i] = 0;
      else if (state2block[i] == 0) state2block[i] = s;
  }
  /* If the initial state 1 is in the same block as the dead state 0,
     return the minimal non-accepting dfa */
  if (state2block[1] == 0) goto DEAD;
  /* Make sure the original initial state 1 maps to the new initial state 1 */
  if (state2block[1] > 1) {
    let s = state2block[1];
    for (let i = 0; i < dfa->number_of_states; i++)
      if (state2block[i] == s) state2block[i] = 1;
      else if (state2block[i] == 1) state2block[i] = s;
  }

  /* Now build the dfa */
  let result = dfa_create();
  result->number_of_states = number_of_blocks;
  result->ranges = dfa->ranges;
  result->number_of_actions = dfa->number_of_actions;
  Set::set_t<st_t> completed_blocks =
    /* A block is completed if we have added all its transitions and final
       attributes.  The dead state starts out as completed. */
    Set::singleton(st_cmp,0);
  for (let i = 0; i < dfa->number_of_states; i++) {
    let b = state2block[i];
    if (Set::member(completed_blocks,b)) continue;
    completed_blocks = Set::insert(completed_blocks,b);
    if (Set::member(dfa->final_states,i))
      dfa_add_final(result,b,Hashtable::lookup(dfa->final_attrs,i));
    let t = Axarray::get(dfa->states,i);
    if (!t) continue; // All transitions are to dead state, nothing to do
    let new_t = new trans(t->lb,NULL);
    let new_spans = NULL;
    for (let x = t->spans; x; x = x->tl) {
      let target = state2block[x->hd->target];
      new_spans = new List::List(new span(target,x->hd->ub),new_spans);
    }
    new_spans = List::imp_rev(new_spans);
    new_t->spans = new_spans;
    // FIX: this might not be the minimal representation of the transitions,
    // since multiple targets in the original might be combined in the new.
    Axarray::set(result->states,b,new_t);
  }
  debugprint(1,"Minimization from %u states to %u states\n",dfa->number_of_states,
             result->number_of_states);
  let delta = time(NULL) - start_time;
  debugprint(1,"elapsed time %d\n",delta);
  return result;
}

/*********************** ANALYZER GENERATION ***********************/
/* Stupid table version */
/* Assumes transitions are sorted */
/* No table compression whatsoever */
extern const char ?dfa_engine1;
void dfa_generate1(dfa_t dfa) {
  printf("unsigned int final[%d] = {",dfa->number_of_states);
  printf("0");
  for (let i = 1; i < dfa->number_of_states; i++)
    if (Set::member(dfa->final_states,i))
      printf(",1");
    else printf(",0");
  printf("};\n");

  printf("unsigned int next[%d][%d] = {\n",dfa->number_of_states,MAXACTION+1);
  for (let i = 0; i < dfa->number_of_states; i++) {
    printf("{");
    let ts = Axarray::get(dfa->states,i);
    let lb = ts->lb;
    let sp = ts->spans;
    if (sp) {
      for (let j = 0; j < lb; j++) printf("0,");
      for (; sp; sp = sp->tl) {
        let target = sp->hd->target;
        let ub = sp->hd->ub;
        for (let j = lb; j < ub; j++) {
          printf("%u",target);
          if (j != MAXACTION) printf(",");
        }
      }
    }
    else
      for (let j = 0; j < MAXACTION + 1; j++) {
        printf("0");
        if (j != MAXACTION) printf(",");
      }
    printf("}");
    if (i+1 < dfa->number_of_states) printf(",\n"); else printf("\n");
  }
  printf("};\n");
  printf("%s",dfa_engine1);
}

/* re2c switch statement version */
/* Does not do filling.  Does not check limits.  Assumes input is in a string. */
/* Does not generate unique labels.  Uses variables ykaccept. */

/* A key state is one that has to fill the buffer */
static int key_state(stgraph_t reachable, stgraph_t scc, st_t s) {
  if (s == 1) return 1; /* the initial state is a key state */
  /* otherwise a state is a key state if it is part of a non-trivial
     strongly connected component.  This is an SCC that includes
     other states, or, the singleton SCC consisting of the state
     itself where the state has a self-loop. */
  let component = Graph::get_targets(scc,s);
  if (Set::cardinality(component) > 1) {
    debugprint(1,"%u is key bc 1\n",s);
    return 1;
  }
  if (Graph::is_edge(reachable,s,s)) {
    debugprint(1,"%u is key bc 2\n",s);
    return 1;
  }
  debugprint(1,"%u is not key\n",s);
  return 0;
}
/* For every reachable state of the dfa, calculate the max distance to a key state. */
#define INFINITY ((unsigned int)-1)
static void fill_table0(dfa_t dfa, stgraph_t reachable, stgraph_t scc, unsigned int ?result, st_t s) {
  let t = Axarray::get(dfa->states,s);
  if (!t) {
    // All transitions are to state 0.
    result[s] = 0;
    return;
  }
  result[s] = 1;
  for (let spans = t->spans; spans; spans = spans->tl) {
    let target = spans->hd->target;
    if (!target) continue; /* Target is the dead state */
    if (!result[target])
      fill_table0(dfa,reachable,scc,result,target);
    unsigned int distance;
    if (key_state(reachable,scc,target)) distance = 1;
    else {
      distance = result[target];
      if (distance != INFINITY) distance++;
    }
    if (result[s] < distance) result[s] = distance;
  }
}
extern int lazyfill; // in parsergen.cyc
static unsigned int ?fill_table(dfa_t dfa) {
  if (lazyfill) return new {for i < dfa->number_of_states : 1 };
  unsigned int ?result = new {for i < dfa->number_of_states : 0 };
  let g = dfa_onestep(dfa);
  let g_reachable = Graph::tc(g);
  let g_scc = Graph::scc(g);
  fill_table0(dfa,g_reachable,g_scc,result,1);
  for (let i = 1; i < dfa->number_of_states; i++)
    if (!key_state(g_reachable,g_scc,i)) result[i] = 0;
  return result;
}
extern const char ?dfa_engine2_1;
static unsigned int dfa_num = 1;
void dfa_generate2(dfa_t dfa) {
  let my_fill_table = fill_table(dfa);
  let base = dfa_num++;
  // TEMP comment out header
  // printf("%s",dfa_engine2_1);
  printf("{\n"
         "goto M%u_1;\n"
         "fin%u: YKCURSOR = YKMARKER;\n",base,base);
  //  printf("printf(\"The result was %%u\\n\",ykaccept);\n"); // FIX: do something
  printf("goto theend%u;\n",base);
  for (let i = 1; i < dfa->number_of_states; i++) { // NB, no code for dead state 0
    let t = Axarray::get(dfa->states,i);
    printf("L%u_%u:\n  ++YKCURSOR;\n",base,i);
    if (Set::member(dfa->final_states,i)) {
      let a = Set::choose(Hashtable::lookup(dfa->final_attrs,i));
      printf("  ykaccept = %u;\n",a);
      printf("  YKMARKER = YKCURSOR;\n");
    }
    if (!t) {
      printf("  goto fin%u;\n",base);
      continue;
    }
    let lb = t->lb;
    printf("M%u_%u:\n",base,i);
    if (my_fill_table[i])
      printf("  if ((YKLIMIT - YKCURSOR) < %u) YKFILL(%u);\n",my_fill_table[i],my_fill_table[i]);
    if (0) {
      // A big switch statement.  Usually the code is too big so disabled for now
      printf("  switch (*YKCURSOR) {\n");
      for (let spans = t->spans; spans; spans = spans->tl) {
	let ub = spans->hd->ub;
	let target = spans->hd->target;
	if (!target) { lb = ub; continue; }// The dead state; fall thru to default
	for (; lb < ub; lb++) {
	  printf("  case %u: goto L%u_%u;\n",lb,base,target);
	}
      }
      printf("  default: goto fin%u;\n",base);
      printf("  }\n");
    }
    else {
      // A simple chain of if-statements.
      // TODO: binary search.
      printf("{ int c = *YKCURSOR;\n");
      for (let spans = t->spans; spans; spans = spans->tl) {
	let ub = spans->hd->ub;
	let target = spans->hd->target;
	if (target) {
	  if (lb==ub-1) {
	    printf("  if (");
            gen_uint(lb);
	    printf("==c) ");
          }
	  else {
	    printf("  if (");
            gen_uint(lb);
	    printf("<=c&&c<");
            gen_uint(ub);
	    printf(") ");
          }
	  printf("goto L%u_%u;\n",base,target);
	}
	lb = ub;
      }
      printf("  goto fin%u;\n",base);
      printf("}\n");
    }
  }
  printf("}\ntheend%u: 0;\n",base);
  // TEMP: don't print footer
  //  printf("}\n");
}

/* Return a new dfa that accepts the shortest prefix such that
   only one final attribute is possible. */
static aset_t
reachable_attributes(dfa_t dfa, stgraph_t reachable, st_t s) {
  let final_reachable =
    Set::intersect(dfa->final_states,Graph::get_targets(reachable,s));
  if (Set::member(dfa->final_states,s)) final_reachable = Set::insert(final_reachable,s);
  let result = aset_empty();
  while (!Set::is_empty(final_reachable)) {
    let x = Set::choose(final_reachable);
    final_reachable = Set::delete(final_reachable,x);
    result = aset_union(result,Hashtable::lookup(dfa->final_attrs,x));
  }
  return result;
}

// YHM: what does this function do?
static dfa_t short_circuit(dfa_t dfa) {
  let reachable = dfa_reachable(dfa);
  let done = Set::empty(st_cmp);
  done = Set::insert(done,0);
  let todo = Set::empty(st_cmp);
  todo = Set::insert(todo,1);
  Dict::dict_t<st_t,st_t> stmap = Dict::empty(st_cmp);
  stmap = Dict::insert(stmap,0,0);
  let result = dfa_create();
  stmap = Dict::insert(stmap,1,dfa_fresh_state(result));
  while (!Set::is_empty(todo)) {
    /* Invariants: done and todo are disjoint sets of old states.
       (x in done) iff (x in stmap). */
    let old_st = Set::choose(todo);
    todo = Set::delete(todo,old_st);
    done = Set::insert(done,old_st);
    let new_st = Dict::lookup(stmap,old_st);
    let a = reachable_attributes(dfa,reachable,old_st);
    if (Set::cardinality(a) == 0) continue;
    if (Set::cardinality(a) == 1) { /* This is where short-circuits take place */
      dfa_add_final(result,new_st,a);
      continue;
    }
    if (Set::member(dfa->final_states,old_st))
      dfa_add_final(result,new_st,Hashtable::lookup(dfa->final_attrs,old_st));
    let old_trans = Axarray::get(dfa->states,old_st);
    if (!old_trans) continue;
    let lb = old_trans->lb;
    let new_spans = NULL;
    for (let old_spans = old_trans->spans; old_spans; old_spans = old_spans->tl) {
      let ub = old_spans->hd->ub;
      let old_target = old_spans->hd->target;
      st_t new_target;
      if (!Dict::lookup_bool(stmap,old_target,&new_target)) {
        /* old_target is neither in done nor todo */
        new_target = dfa_fresh_state(result);
        stmap = Dict::insert(stmap,old_target,new_target);
        todo = Set::insert(todo,old_target);
      }
      new_spans = new List::List(new span(new_target,ub),new_spans);
      lb = ub;
    }
    new_spans = List::imp_rev(new_spans);
    let new_trans = new trans(old_trans->lb,new_spans);
    Axarray::set(result->states,new_st,new_trans);
  }
  return result;
}

/************************* PACKAGING IT UP *************************/
/* NB: first_right is modified */
#include <array.h>
#include <sys/stat.h>
#include <errno.h>

/* Construct the lookahead dfa */
dfa_t lookahead_dfa(grammar_t grm,List::list_t<rule_t> rules, rule_t right_ctxt) {
  //  if (!rules) return;

  let try_local = 0; 
  if (try_local){
    nfa_init(grm);
    let start_states = Set::empty(st_cmp);
    let final_states = Set::empty(st_cmp);
    List::list_t<unsigned int> interval_list = NULL;
    for (let rl = rules; rl; rl = rl->tl) {
      unsigned int Z = nfa_number_of_states; // First state of this nfa
      interval_list = new List::List(Z,interval_list);
      let s = rule2nfa(grm,rl->hd); // TRY WITHOUT RIGHT CONTEXT
      start_states = Set::insert(start_states,s);
      final_states = Set::insert(final_states,get_final(s));
    }
    interval_list = List::imp_rev(interval_list);
    let intervals = Array::from_list(interval_list);

    let dfa = nfa_distinguish(start_states,final_states,intervals);

    dfa = dfa_minimize(dfa);

    // If all conflicts were resolved without using the right context...
    if (!dfa_tiebreak(dfa)) {
      eprintf("The final dfa has %u states\n",dfa->number_of_states);      
      if (dfa_unbounded(dfa)) {
	num_conflicts_unbounded++;
	FILE *f = fopen(dotfile("unbounded"),"w");
	if (f) { dfa_dot(f,dfa,NULL); fclose(f); }
      }
      return dfa;
    }
  }

  nfa_init(grm);
  let start_states = Set::empty(st_cmp);
  let final_states = Set::empty(st_cmp);
  List::list_t<unsigned int> interval_list = NULL;
  for (let rl = rules; rl; rl = rl->tl) {
    unsigned int Z = nfa_number_of_states; // First state of this nfa
    interval_list = new List::List(Z,interval_list);
    let s = rule2nfa(grm,SEQ(rl->hd,right_ctxt));
//     let s = rule2nfa(grm,rl->hd); // TEMPORARY: TRY WITHOUT RIGHT CONTEXT
    start_states = Set::insert(start_states,s);
    final_states = Set::insert(final_states,get_final(s));
  }

  if (debug) {
    /* Make sure the ykdebug directory exists */
    struct stat sb;
    int err = stat("ykdebug",&sb);
    if (err && errno == ENOENT) {
      if (mkdir("ykdebug",S_IRWXU)) {
	eprintf("ERROR: could not create directory ykdebug\n");
	exit(1);
      }
    }
    else if (err) {
      perror("Error on stat(ykdebug)");
      exit(1);
    }
    else if (!(sb.st_mode & S_IFDIR)) {
      eprintf("ERROR: ykdebug is not a directory\n");
      exit(1);
    }
    if (debug > 1) {
      FILE *f = fopen(dotfile("nfa"),"w");
      if (f) { nfa_dot(f,final_states,NULL); fclose(f); }
    }
  }

  interval_list = List::imp_rev(interval_list);
  let intervals = Array::from_list(interval_list);

  if (debug) {
    eprintf("Intervals: ");
    for (let i = 0; i < numelts(intervals); i++) {
      eprintf("%u.",intervals[i]);
    }
    eprintf("\n");
  }

  let dfa = nfa_distinguish(start_states,final_states,intervals);

  if (debug) {
    FILE *f = fopen(dotfile("nfa_after"),"w");
    if (f) { nfa_dot(f,final_states,NULL); fclose(f); }

    FILE *f = fopen(dotfile("dfa0"),"w");
    if (f) { dfa_dot(f,dfa,NULL); fclose(f); }
  }

  dfa = dfa_minimize(dfa);

  if (debug) {
    FILE *f = fopen(dotfile("dfa1"),"w");
    if (f) { dfa_dot(f,dfa,NULL); fclose(f); }
  }

  if (dfa_tiebreak(dfa)) {
    dfa = short_circuit(dfa);
    dfa = dfa_minimize(dfa);
  }
  eprintf("The final dfa has %u states\n",dfa->number_of_states);

  if (debug) {
    FILE *f = fopen(dotfile("dfa2"),"w");
    if (f) { dfa_dot(f,dfa,NULL); fclose(f); }
  }
  if (dfa_unbounded(dfa)) {
    num_conflicts_unbounded++;
    FILE *f = fopen(dotfile("unbounded"),"w");
    if (f) { dfa_dot(f,dfa,NULL); fclose(f); }
  }
  //  if (debug>=2) dfa_generate2(dfa);
  //  dfa_generate(dfa);
  return dfa;
}


// Construct a repeat dfa: a series of n states each transitioning to
// the given target state "target_s" on the "target" action. Each
// state transitions to the next on action "next".
// The last state is connected to the specified final state "f".
st_t construct_repeat_dfa(dfa_t dfa, unsigned int n, 
			  act_t next, 
			  st_t target_s, act_t target, st_t f){
  let lb = target;
  let target_span = new span(target_s,lb+1);
  // everything b/w CALL and nt.
  let pre_next_span = new span(NOTRANSITION,next);
  let last_d = f;
  for (int i = 0; i < n; i++){
    let d = dfa_fresh_state(dfa);
    let next_span = new span(last_d,next+1);
    let spans = next > lb+1 ?
      List::list(target_span, pre_next_span, next_span) : 
      List::list(target_span, next_span);
    Axarray::set(dfa->states,d,new trans(lb,spans));
    last_d = d;
  }
  return last_d;
}
