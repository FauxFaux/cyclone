/* This file is part of the Cyclone Library.
   Copyright (C) 2005 Greg Morrisett, AT&T

   This library is free software; you can redistribute it and/or it
   under the terms of the GNU Lesser General Public License as
   published by the Free Software Foundation; either version 2.1 of
   the License, or (at your option) any later version.

   This library is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with this library; see the file COPYING.LIB.  If not,
   write to the Free Software Foundation, Inc., 59 Temple Place, Suite
   330, Boston, MA 02111-1307 USA. */

#include <unistd.h>
#include <stdio.h>
#include <errno.h>
#include <string.h>

#define BSIZE 8192
//#define UINTCAST (unsigned int)(unsigned char *{0}@nozeroterm)

#include "ykbuf.h"

ykbuf_t @fd2ykbuf(int fd) {
  let buf = malloc(BSIZE*sizeof(unsigned char));
  let result = new ykbuf{
    .prod=new ykp_fd(fd),
    .bot=buf,
    .save=NULL,
    .mark=NULL,
    .cur=buf,
    .lim=buf,
    .top=buf+BSIZE,
    .eof=0,
    .save_count=0,
    .discarded=0};
  return result;
}
ykbuf_t @ssl2ykbuf(SSL @`H ssl) {
  let buf = malloc(BSIZE*sizeof(unsigned char));
  let result = new ykbuf{
    .prod=new ykp_ssl(ssl),
    .bot=buf,
    .save=NULL,
    .mark=NULL,
    .cur=buf,
    .lim=buf,
    .top=buf+BSIZE,
    .eof=0,
    .save_count=0,
    .discarded=0};
  return result;
}
ykbuf_t @p2ykbuf(int (@`H p)(ykbuf_t @`H),ykbuf_t @`H ykb) {
  let buf = malloc(BSIZE*sizeof(unsigned char));
  let result = new ykbuf{
    .prod=new ykp_p(p,ykb),
    .bot=buf,
    .save=NULL,
    .mark=NULL,
    .cur=buf,
    .lim=buf,
    .top=buf+BSIZE,
    .eof=0,
    .save_count=0,
    .discarded=0};
  return result;
}

// TODO: this is annoying, we have to copy the string.
// Actually it should not be necessary because we never
// modify the string, unlike when we need to fill a buffer.
ykbuf_t @string2ykbuf(const char ?s) {
  let len = strlen(s);
  let buf = malloc((len+1)*sizeof(char));
  memcpy(buf,s,len);
  buf[len] = '\0';
  let result = new ykbuf{
    .prod=NULL,
    .bot=buf,
    .save=NULL,
    .mark=NULL,
    .cur=buf,
    .lim=buf,
    .top=buf+BSIZE,
    .eof=1,
    .save_count=0,
    .discarded=0};
  return result;
}

/*
  bot points to the memory object obtained from malloc.
  top points one past the end of the memory object obtained from malloc.
  lim points one past the end of the input currently in memory.
  save is NULL if no input needs to be saved on a fill,
    else save points at the first character of the input to save.
  save_count is used to handle nested saves.  When it goes to zero, save should be NULL'd.
  eof records whether end-of-file has been reached.  Note, re2c does it
    a bit differently, eof is a pointer, allows the sentinel to be a legal input character,
    at the cost of a comparison when a (possible) sentinel is under YKCURSOR.

  mark is set by scanners, it points one past the last input which reached a final state.
    It is kept as part of the ykbuf_t because it has to be adjusted on fill.

  discarded records the number of characters discarded by ykfill.  It is
  useful to find the position of the current character with respect to
  the complete input.

  Scanners should call YKSAVE on entry and YKRESTORE on exit, because they may have to
    back up to the longest match.

  These invariants are maintained by ykfill:
  If save == NULL bot < lim <= top
  If save != NULL bot <= save < lim <= top

  These invariants should be maintained by users of the library:
  save == NULL iff save_count == 0

  Here are the definitions for using ykbuf_t in a scanner or parser.
  They assume two variables, ykb of type ykbuf_t, and ykcursor of type
  unsigned char ?@nozeroterm.

#define YKLIMIT ykb->lim
#define YKCURSOR ykcursor
#define YKFILL(n) (ykcursor = ykfill(ykb,ykcursor))
#define YKMARKER ykb->mark
//#define YKSAVE ((ykb->save)?(ykb->save_count++):((ykb->save=ykcursor),ykb->save_count++))
//#define YKDISCARD ((--ykb->save_count)?0:(ykb->save==NULL))
#define YKSAVE ({ let x = 0; ykb->save_count++; if (ykb->save) x = ykcursor-ykb->save; else ykb->save = ykcursor; x; })
#define YKRESTORE(x) ({ let p = ykb->save+x; if (--ykb->save_count == 0) ykb->save=NULL; p; })
*/

void ykdumpbuf(ykbuf_t @y) {
  let right = y->lim - y->cur;
  let left = y->cur - y->bot;
  let leftp;
  if (left+right < 80) leftp = y->bot;
  else if (left < 80) leftp = y->bot;
  else if (right < 80) leftp = y->lim - 80;
  else leftp = y->cur - 40;

  fprintf(stderr,"cur = bot + %d\n",left);
  fprintf(stderr,"lim = bot + %d = cur + %d\n",left+right,right);
  fprintf(stderr,"Window:\n");

  for (let x = leftp; x < y->lim && x < leftp + 80; x++)
    if (isprint(*x)) fprintf(stderr," ");
    else fprintf(stderr,"%x",*x/16);
  fprintf(stderr,"\n");
  for (let x = leftp; x < y->lim && x < leftp + 80; x++)
    if (isprint(*x)) fprintf(stderr,"%c",*x);
    else fprintf(stderr,"%x",*x%16);
  fprintf(stderr,"\n");
  for (let x = leftp; x < y->lim && x < leftp + 80; x++)
    if (x != y->cur) fprintf(stderr," ");
    else fprintf(stderr,"*");
  fprintf(stderr,"\n");
}

// Note: SSL uses int instead of size_t
extern int SSL_read(SSL @ssl, char ? @nozeroterm buf, int count);

// FIX: make p first-class polymorphic on `r?
int ykreadp(int (@p)(ykbuf_t @`r), ykbuf_t @`r ykb,
            unsigned char? @nozeroterm b, int n) {
  for (int i = 0; i < n; i++) {
    int r = p(ykb);
    if (r < 0 || r > 255) return i;
    *b = (unsigned char)r;
  }
  return n;
}

int ykread(datatype ykproducer *p, unsigned char? @nozeroterm b, int n) {
  switch (p) {
  case NULL:          return 0;
  case &ykp_fd(fd):   return read(fd,b,n);
  case &ykp_ssl(ssl): return SSL_read(ssl,b,n);
  case &ykp_p(p,ykb): return ykreadp(p,ykb,b,n);
 }
}

void ykfill(ykbuf_t @s,unsigned int n) {
  //  fprintf(stderr,"ykfill(%d)\n",n); fflush(stderr);
  if (n < (s->lim - s->cur)) return;
  if (!s->eof) {
    int TO_READ = BSIZE;
    int cnt;
    if (s->save) {
      // discard chars from bot to save, keep chars from save to lim
      cnt = s->save - s->bot;
      if (cnt) {
        memcpy(s->bot, s->save, s->lim - s->save);
        s->save = s->bot;
        s->mark -= cnt;
        s->cur -= cnt;
        s->lim -= cnt;
        s->discarded += cnt;
      }
    }
    // Invariant: (s->save == NULL || s->save == s->bot)
    // We want to read in TO_READ chars.  Resize the buffer if not enough space.
    if ((s->top - s->lim) < TO_READ) {
      unsigned char ?@nozeroterm buf = malloc(((s->lim - s->bot) + TO_READ)*sizeof(unsigned char));
      memcpy(buf, s->bot, s->lim - s->bot);
      if (s->save) s->save = buf;
      s->mark = &buf[s->mark - s->bot];
      // s->mark = buf + (s->mark - s->bot);
      s->cur = &buf[s->cur - s->bot];
      //      cursor = buf + (cursor - s->bot);
      s->lim = &buf[s->lim - s->bot];
      s->top = &s->lim[TO_READ];
      // TODO: free(s->bot);
      s->bot = buf;
    }
    // Read in TO_READ characters
  YKREADLOOP:
    if ((cnt = ykread(s->prod, s->lim, TO_READ)) != TO_READ) {
      if (!cnt) {                   // end-of-file
        s->eof = 1;
        s->lim[cnt++] = '\0'; // Invariant: cnt < TO_READ
      }
      else if (cnt < 0) {
        if (errno == EINTR) {       // interrupt occurred during a slow read
          goto YKREADLOOP;
        }
        else if (errno == EAGAIN) { // read from non-blocking fd, no data available
          // TODO: maybe we should change the fill API to allow a return here?
          goto YKREADLOOP;
        }
        else {                      // some other error
          perror("Read error on fill");
          // Act as if eof was encountered
          s->eof = cnt = 1;
          s->lim = '\0';
        }
      }
      else {                        // read fewer than TO_READ characters for some other reason
        s->lim += cnt;
        if (n < (s->lim - s->cur)) return; // TO_READ was larger than n
        //        fprintf(stderr,">> %s",substring(s->cur,0,s->lim - s->cur));
        TO_READ -= cnt;
        goto YKREADLOOP;
      }
    }
    s->lim += cnt;
  }
}

/* This has nothing to do with buffers but it's convenient to stick it here. */
void compress_whitespace(char ?x) {
  if (!x) return;
  if (!x[0]) return;
  const int COPYING_MODE = 0;
  const int COMPRESSING_MODE = 1;
  int mode = (isspace(x[0])) ? COMPRESSING_MODE : COPYING_MODE;
  int i = 0;
  int j = 0;
  while (x[j]) {
    let c = x[j++];
    let sp = isspace(c);
    if (!sp) { mode = COPYING_MODE; x[i++] = c; }
    else if (mode == COPYING_MODE) { x[i++] = ' '; mode = COMPRESSING_MODE; }
  }
  x[i--] = 0;
  if (i > 0 && isspace(x[i])) x[i] = 0; // possible trailing whitespace
}
