/* termgrammar.cyc
 * Library for specifying and printing parse trees for an ABNF grammar.
 */

/* Copyright (C) 2005 Greg Morrisett, AT&T.
   This file is part of the Cyclone project.

   Cyclone is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   Cyclone is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with Cyclone; see the file COPYING. If not,
   write to the Free Software Foundation, Inc., 59 Temple Place -
   Suite 330, Boston, MA 02111-1307, USA. */

/*
 Sometimes want to format a rule so that it has a tag
   f(...)
 Call this a *term*.
 Sometimes, with commas only, as in the ... above.
 Sometimes we format a rule, sometimes a list of rules.

     +-------------+-----------------------------------+
     |             |             OUTPUT                |
     |  INPUT      |  tagged         sequence of args  |
     |-------------+-----------------------------------+
     |  rule       |  rule2term      rule2terms        |
     |  rule list  |  rules2term     rules2terms       |
     +-------------+-----------------------------------+
 */


/*
Unique-tags:

Overall approach: 
New grammar obeys meta-grammar (with implicit whitespace):

tag  ::=  ... // valid identifier
escaped-data ::= ... // data with whitespace, (, and \ escaped. All escaped with \.
term ::= "(" tag *term ")"
       | escaped-data

 */

#include <core.h>
#include "bnf.h"
#include "pr.h"
#include "analyze.h"
#include "termgrammar.h"
#include <list.h>
#include <buffer.h>
#include <string.h>
#include <stdio.h>

using List;

static
cs_t termchars() {
  return string2cs("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789.-_=~&@");
}

/* Separate a rule list with a given separator */
static
rule_t with_sep(list_t<rule_t> rs, const char ?`H c) {
  if (rs == NULL) return LIT("");
  let res = rs->hd;
  rs = rs->tl;
  for (; rs; rs = rs->tl)
    res = SEQ(res,LIT(c),rs->hd);
  return res;
}

/* Separate a rule list with commas */
static
rule_t with_commas(list_t<rule_t> rs) {
  return with_sep(rs,",");
}

/* Separate a rule list with spaces */
static
rule_t with_spaces(list_t<rule_t> rs) {
  return with_sep(rs," ");
}


// We use a dummy rule to mark terms so that they can be recognized by later 
// optimization phases.
static datatype Rule.Symb term_symb = Symb("TERM_DUMMY",NULL);
struct arule term_rule = arule(NULL,NULL,NULL,NULL,&term_symb);

// Make a new term.
rule_t mkterm_UT(rule_t tag, rule_t args){
  return SEQ(LIT("("), tag, args, LIT(")"), &term_rule);
}

// Make a new term without the dummy term marker.
rule_t mkterm_UT_nodummy(rule_t tag, rule_t args){
  return SEQ(LIT("("), tag, args, LIT(")"));
}

// Checks whether rule r defines a term.
bool is_term_UT(rule_t r){
  switch (r->r){
  case &Seq(_,last):
    return last == &term_rule;
  default:
    return false;
  }
}

// Checks whether rule r directly contains a term. 
bool contains_term_UT(rule_t r){
  switch (r->r){
  case &Seq(_,last):
    // r itself might be a term
    return last == &term_rule;
  case &Symb(_,_):
    // r is a symbol, so its a definition is term.
    return true;
  default:
    return false;
  }
}

// Extract the tag from term. 
// N.B. "term" must really be a term, or an Invalid argument exception will be raised.
rule_t term_UT_get_tag(rule_t term){
  switch (term->r){
  case &Seq(&arule{.r= 
	  &Seq(&arule{.r= 
	     &Seq(&arule{.r= 
		&Seq(&arule{.r=
		   &Lit(lp),...},		     
		   t as &arule{.r=&Lit(s),...}), ...}, 
		r1),...},
		  &arule{.r=
		      &Lit(rp),...}),...},
          dummy_rule) :
      return t;
  default:
    throw new Core::Invalid_argument("Expecting term rule, received something else.");
  }
}

// Extract the rule from term.
// N.B. "term" must really be a term, or an Invalid argument exception will be raised.
rule_t term_UT_get_rule(rule_t term){
  switch (term->r){
  case &Seq(&arule{.r= 
	  &Seq(&arule{.r= 
	     &Seq(&arule{.r= 
		&Seq(&arule{.r=
		   &Lit(lp),...},
		     &arule{.r=
		   &Lit(s),...}), ...}, 
		r1),...},
		  &arule{.r=
		      &Lit(rp),...}),...},
          dummy_rule) :
      return r1;
  default:
    throw new Core::Invalid_argument("Expecting term rule, received something else.");
  }
}

// "Eliminate" (extract the contents of) the term.
// N.B. "term" must really be a term, or an Invalid argument exception will be raised.
$(rule_t,rule_t) term_UT_elim(rule_t term){
  switch (term->r){
  case &Seq(&arule{.r= 
	  &Seq(&arule{.r= 
	     &Seq(&arule{.r= 
		&Seq(&arule{.r=
		   &Lit(lp),...},		     
		   t as &arule{.r=&Lit(s),...}), ...}, 
		r1),...},
		  &arule{.r=
		      &Lit(rp),...}),...},
          dummy_rule) :
    return $(t,r1);
  default:
    throw new Core::Invalid_argument("Expecting term rule, received something else.");
  }
}

static int fresh_num=0;
static int get_fresh_num() { return fresh_num++; }

/* Create a fresh tag. */
static
rule_t fresh_tag(const char ?`H name){
  char num_string[30];
  sprintf(num_string, "__%d", get_fresh_num());
  return LIT(strconcat(name,num_string));
}

/* Return a possible tag from a sequence, if any */
static
Rule_t seqtag(rule_t r) {
  static cs_opt_t tc = NULL;
  if (!tc) tc = termchars();
  switch (r->r) {
  case &Lit(x):
    let cs = string2cs(x);
    cs_difference(cs,tc);
    if (is_cs_empty(cs))
      // x includes no character outside the legal term characters
      return r;
    else return NULL;
  case &Seq(r1,r2):
    let tag_opt = seqtag(r1);
    return (tag_opt)?tag_opt:seqtag(r2);
  default:
    return NULL;
  }
}

/* If a rule expands to a unique string (the rule has arity 0),
   return that string, else return NULL. */
static
const char ?rule2string(rule_t r0) {
  let b = Buffer::create(23);
  let rs = list(r0);
  while (rs) {
    let r = rs->hd;
    switch (r->r) {
    case &Symb(n,_):
      if (arity_rule(r) != 0) return NULL;
      /* FIX: need to look up rule! */
      internal_err("rule2string needs to look up rule for symbol %s\n",n);
      Buffer::add_string(b,n);
      rs = rs->tl;
      break;
    case &Lit(x):
      Buffer::add_string(b,x);
      rs = rs->tl;
      break;
    case &Seq(r2,r3): /* Flatten r2 and r3 into the rule list */
      rs = new List(r2,new List(r3,rs->tl));
      break;

    case &Star(m,&Num(n),r2):
      if (m==n) {
        let s = rule2string(r2);
        for (let i = 0; i < m; i++) Buffer::add_string(b,s); 
        break;
      }
      else return NULL;
    case &Rcount(_,_):
    case &Star(_,_,_):
    case &Hash(_,_,_):
    case &Opt(_):
    case &Alt(_,_):
    case &CharRange(_,_):
      return NULL;
    case &Prose(x): /* Should have been handled elsewhere */
      internal_err("Unexpected Prose(%s) in rule2string\n",x);
      return "<error>";
    case &Minus(_,_): /* Should have been handled elsewhere */
      internal_err("Unexpected Minus in rule2string\n");
      return "<error>";
    }
  }
  return Buffer::contents(b);
}

static rule_t alt2term(rule_t r);
static Rule_t seq2term(rule_t r0);

static rule_t alt2term_UT(rule_t r);
static Rule_t seq2term_UT(rule_t r0);

static cs_opt_t avoid_cs;
static int avoid(cs_t cs) {
  let x = string2cs("()[], \t\n\r");
  cs_intersect(x,cs);
  return !is_cs_empty(x);
}

static
rule_t rule2term(rule_t r) {
  let res = NULL;
  switch (r->r) {
  case &Rcount(n,r2):
    // FIX: what to do about n???
    return SEQ(LIT("["),
               STAR(0,new Infinity,rule2term(r2)),
               LIT("]"));
  case &Star(m,N,r2):
    if (is_cs(r2)) {
      let cs = rule2cs(r2);
      if (!avoid(cs))
        return STAR(m,N,cs2rule(cs));
    }
    fallthru(m,N,r2);
  case &Hash(m,N,r2):
    return SEQ(LIT("["),
               HASH(m,N,rule2term(r2)),
               LIT("]"));
  case &Opt(r2):
    return SEQ(LIT("["),
               OPT(rule2term(r2)),
               LIT("]"));
  case &Alt(_,_):
    return alt2term(r);
  case &Symb(_,_):
    return r;
  case &CharRange(_,_):
    return r;
  case &Lit(_):
    return r;

  case &Seq(_,_):
    let r2 = seq2term(r);
    if (r2) return r2;
    else {
      internal_err("rule2term: could not convert rule:\n");
      pr_rule(stderr,r);
      eprintf("\n");
      return LIT("[]");
    }

    /* Error cases */
  case &Prose(x):
    internal_err("Unexpected Prose(%s) in rule2term\n",x);
    exit(1);
  case &Minus(_,_):
    internal_err("Unexpected Minus in rule2term\n");
    exit(1);
  }
}

rule_t escape_cs_rule_UT(rule_t r){
  // FIX: need to implement.
//   let cs = rule2cs(r);
  return mkterm_UT( fresh_tag("ESCAPE_CS"), r);
}
rule_t escape_lit_UT(const char ?`H s){
  return mkterm_UT( fresh_tag("ESCAPE_LIT"), LIT(s) );
}

static
rule_t rule2term_UT(rule_t r) {
  let res = NULL;
  switch (r->r) {
  case &Rcount(n,r2):
    if (is_cs(r2)) {
      let escaped = escape_cs_rule_UT(r2);
      return mkterm_UT( fresh_tag("RCount"), RCOUNT(n,escaped) );
    }
    return mkterm_UT( fresh_tag("RCount"), r2);
  case &Star(m,N,r2):
    if (is_cs(r2)) {
      let escaped = escape_cs_rule_UT(r2);
      return mkterm_UT( fresh_tag("Star"), STAR(m,N,escaped) );
    }
    return mkterm_UT( fresh_tag("Star"), STAR(m,N,rule2term_UT(r2)) );
  case &Hash(m,N,r2):
    return mkterm_UT( fresh_tag("Hash"), HASH(m,N,rule2term_UT(r2)) );
  case &Opt(r2):
    let some_term = mkterm_UT( fresh_tag("Some"), rule2term_UT(r2) );
    let none_term = mkterm_UT( fresh_tag("None"), LIT("") );
    return ALT(some_term,none_term);
  case &Alt(_,_):
    return alt2term_UT(r);
  case &Symb(_,_):
    return r;
  case &CharRange(_,_):
    return escape_cs_rule_UT(r);
  case &Lit(s):
    return escape_lit_UT(s);

  case &Seq(_,_):
    let r2 = seq2term_UT(r);
    if (r2) return r2;
    else {
      internal_err("rule2term: could not convert rule:\n");
      pr_rule(stderr,r);
      eprintf("\n");
      return LIT("[]");
    }

    /* Error cases */
  case &Prose(x):
    internal_err("Unexpected Prose(%s) in rule2term\n",x);
    exit(1);
  case &Minus(_,_):
    internal_err("Unexpected Minus in rule2term\n");
    exit(1);
  }
}

/* Is a rule a necessary argument? */
static
int is_arg(rule_t r) {
  switch (r->r) {
  case &Symb(_,_):
  case &Star(_,_,_):
  case &CharRange(_,_):
    return (arity_rule(r) > 0);
  case &Alt(_,_):
  case &Opt(_):
  case &Rcount(_,_):
  case &Hash(_,_,_):
    return 1;
  case &Seq(_,_):
  case &Lit(_):
  case &Prose(_):
  case &Minus(_,_):
    return 0;
  }
}

/* Is a rule a necessary argument? */
static
int is_arg_UT(rule_t r) {
  switch (r->r) {
    // Are these artity checks correct?
  case &Star(_,_,_):
  case &CharRange(_,_):
    return (arity_rule(r) > 0);
  case &Symb(_,_):
  case &Alt(_,_):
  case &Opt(_):
  case &Rcount(_,_):
  case &Hash(_,_,_):
  case &Lit(_):
    return 1;
  case &Seq(_,_):  // What is a sub-sequence doing here?
  case &Prose(_):  // What is this???
  case &Minus(_,_):  // What is this???
    return 0;
  }
}

static
list_t<rule_t> rule2args(rule_t r) {
  return filter(is_arg,seq2rules(r));
}

static
list_t<rule_t> rule2args_UT(rule_t r) {
  return seq2rules(r);
}

static
rule_t alt2term(rule_t r) {
  switch (r->r) {
  case &Alt(r1,r2):
    return ALT(alt2term(r1),alt2term(r2));
  default:
    let tag = seqtag(r);
    if (!tag) {
      internal_err("alt2term: could not find tag:\n");
      pr_rule(stderr,r);
      eprintf("\n");
      return r;
    }
    let args = rule2args(r);
    if (args == NULL)
      return tag;
    else
      return SEQ(tag,LIT("("),with_commas(map(rule2term,args)),LIT(")"));
  }
}

// Unique-tags version.
static
rule_t alt2term_UT(rule_t r) {
  switch (r->r) {
  case &Alt(r1,r2):
    return ALT(alt2term_UT(r1),alt2term_UT(r2));
  default:
    let tag = fresh_tag("Alt");
    let args = rule2args_UT(r);
    return mkterm_UT( tag, with_spaces(map(rule2term_UT,args)) );
  }
}

static
int is_term(rule_t r) {
  if (is_cs(r)) return 1;
  switch (r->r) {
  case &Symb(_,_): return 1;
  default:
    break;
  }
  return !arity_rule(r); // An arity-0 rule is a term (a string literal)
}

static
int non_zero_arity(rule_t r) {
  /* Can't pass arity_rule to exists because it returns unsigned int instead
     of int.  Have to do this annoying cast. */
  return (arity_rule(r) != 0);
}

static
Rule_t seq2term(rule_t r0) {
  let rs = seq2rules(r0);
  let args = filter(is_arg,rs);
  let len = length(args);

  if (len == 0) {
    internal_err("seq2term: no args in sequence:\n");
    pr_rule(stderr,r0);
    eprintf("\n");
    return LIT("[]");
  }

  if (len == 1) {
    return rule2term(args->hd);
  }

  /* Look for an Alt which could serve as a tag */
  list_t<rule_t,`H> revargs = NULL;
  for (let x = args; x; x = x->tl) {
    let r = x->hd;
    switch (r->r) {
    case &Alt(_,_):
      let alts = alt2rules(r);
      if (exists(non_zero_arity,alts)) {
        revargs = new List(r,revargs);
        continue;
      }
      else {
        /* All alternatives have zero arity, so r can be used as a tag.
           Gather up all the rest of the args and return. */
        x = x->tl; // remove r from the list of args
        for (; revargs; revargs = revargs->tl) // put back the already-examined args
          x = new List(revargs->hd,x);
        return SEQ(r,LIT("("),with_commas(map(rule2term,x)),LIT(")"));
      }
    default:
      revargs = new List(r,revargs);
      break;
    }
  }

 litsearch:
  /* No Alt could be a tag, look for a Lit instead */
  for (; rs; rs = rs->tl) {
    let r = rs->hd;
    switch (r->r) {
    case &Lit(_):
      return SEQ(r,LIT("("),with_commas(map(rule2term,args)),LIT(")"));
    default:
      break;
    }
  }

  /* Nothing worked */
  return NULL;
}

grammar_t grammar2termgrammar(grammar_t ds) {
  init_arityt(ds);
  let res = NULL;
  for (; ds; ds = ds->tl) {
    let &$(n,r,a) = ds->hd;
    let r2;
    let args = rule2args(r);
    if (args == NULL)
      r2 = LIT(n);
    else
      r2 = SEQ(LIT(n),LIT("("),with_commas(map(rule2term,args)),LIT(")"));
    res = new List(new $(n,r2,a),res);
    //    res = new List(new $(n,r2t(r),a),res);
  }
  res = imp_rev(res);
  return res;
}

static
Rule_t seq2term_UT(rule_t r0) {
//   let rs = seq2rules(r0);
//   let args = filter(is_arg_UT,rs);
  let args = seq2rules(r0);
  let len = length(args);

  if (len == 0) {
    internal_err("seq2term_UT: no args in sequence:\n");
    pr_rule(stderr,r0);
    eprintf("\n");
    return LIT("[]");
  }

  if (len == 1) {
    return rule2term_UT(args->hd);
  }

  return mkterm_UT(fresh_tag("Seq"), with_spaces(map(rule2term_UT,args)));
}

grammar_t grammar2termgrammar_UT(grammar_t ds) {
  init_arityt(ds);

  let res = NULL;
  for (; ds; ds = ds->tl) {
    let &$(n,r,a) = ds->hd;
    let r2;
    let args = rule2args_UT(r);
    r2 = mkterm_UT(LIT(n),with_spaces(map(rule2term_UT,args)));
    res = new List(new $(n,r2,a),res);
    //    res = new List(new $(n,r2t(r),a),res);
  }

  res = imp_rev(res);

  // Add the production that corresponds to the dummy rule (symbol
  // __TERM__) used to mark terms. Probably not necessary, but ensures
  // that the grammar is coherent (because the dummy-term symbol is
  // defined.)
//   let term_def = new $((const char ?)"TERM_DUMMY",LIT("t"),
// 		       Attr{.ws=0,.re=0,.paramtype=NULL,.rettype=NULL});
//   res = new List(term_def,res);

  return res;
}

// RRT = remove redundant tags
/*

    r : U
-----------------
   (T r) --> r


 */

// Invariant: r is a term iff the return value is a term.
rule_t rewrite_RRT(rule_t r){
    if (is_term_UT(r)) { 
      let $(tag,r_inner) = term_UT_elim(r);

      // Check if nested rule is a term too. if so, strip the outer
      // term wrapping by just returning the inner term.
      if (contains_term_UT(r_inner))
	return rewrite_RRT(r_inner);

      // Otherwise, rewrite and rewrap.
      return mkterm_UT(tag, rewrite_RRT(r_inner));
    }

    switch (r->r) {
    case &Opt(r1):
      return OPT(rewrite_RRT(r1));
    case &Seq(r1,r2):
      return SEQ(rewrite_RRT(r1), rewrite_RRT(r2));
    case &Alt(r1,r2):
      return ALT(rewrite_RRT(r1), rewrite_RRT(r2));
    case &Rcount(n,r1):
      return RCOUNT(n,rewrite_RRT(r1));
    case &Star(m,N,r1):
      return STAR(m,N,rewrite_RRT(r1));
    case &Hash(m,N,r1):
      return HASH(m,N,rewrite_RRT(r1));
    default:
      return r;
    }
}

grammar_t grammar_RRT(grammar_t ds) {
  init_arityt(ds);
  let res = NULL;
  for (; ds; ds = ds->tl) {
    let &$(n,r,a) = ds->hd;
    let r2 = rewrite_RRT(r);
    res = new List(new $(n,r2,a),res);
  }
  res = imp_rev(res);
  return res;
}

// Final pass on grammar. Currently, just used to cleanup dummy tags from terms.

rule_t rewrite_final(rule_t r){
    if (is_term_UT(r)) { 
      let $(tag,r_inner) = term_UT_elim(r);
      return mkterm_UT_nodummy(tag, rewrite_final(r_inner));
    }

    switch (r->r) {
    case &Opt(r1):
      return OPT(rewrite_final(r1));
    case &Seq(r1,r2):
      return SEQ(rewrite_final(r1), rewrite_final(r2));
    case &Alt(r1,r2):
      return ALT(rewrite_final(r1), rewrite_final(r2));
    case &Rcount(n,r1):
      return RCOUNT(n,rewrite_final(r1));
    case &Star(m,N,r1):
      return STAR(m,N,rewrite_final(r1));
    case &Hash(m,N,r1):
      return HASH(m,N,rewrite_final(r1));
    default:
      return r;
    }
}

grammar_t grammar_final(grammar_t ds) {
  init_arityt(ds);
  let res = NULL;
  for (; ds; ds = ds->tl) {
    let &$(n,r,a) = ds->hd;
    let r2 = rewrite_final(r);
    res = new List(new $(n,r2,a),res);
  }
  res = imp_rev(res);
  return res;
}
