#include <string.h>
#include <core.h>
#include <list.h>

#include "earley-parsetree.h"

namespace EarleyParsetree;

void print_LT_parse_forest(shared_parse_forest_t pf, int depth);

void print_LT(datatype SharedParseTree @pt, int depth){
  switch (pt) {
  case &NonTerm(name,l,r,w,children):
    printf("<t s=\"%s(%s)\" l=\"%d\" r=\"%d\">",name,Semiring::print_weight(w),l,r);
  print_LT_parse_forest(children, depth);
    printf("</t>");
    break;
  case &SharedNonTerm(name,l,r,w,children_list):
    printf("<t s=\"%s(%s)\" l=\"%d\" r=\"%d\">",name,Semiring::print_weight(w),l,r);
  print_LT_parse_forest(children_list->hd,depth);
    printf("</t>");
    break;
  }
}

void print_LT_parse_forest(shared_parse_forest_t pf, int depth){
  if (depth > 0){
    let d = depth - 1;
    for(let ts = (_*)List::rev(pf); ts; ts = ts->tl)
      print_LT(ts->hd, d);
  } else if(depth == -1) {
    for(let ts = (_*)List::rev(pf); ts; ts = ts->tl)
      print_LT(ts->hd, -1);
  }
}

void print_tree(parse_tree_t pt, int depth){
  let &parse_tree(name,l,r,w,children) = pt;
  printf("<t s=\"%s(%s)\" l=\"%d\" r=\"%d\">",name,Semiring::print_weight(w),l,r);

  if (depth > 0){
	  let n = numelts(children);
	  for (int i = 0; i < n; i++){
	  	print_tree(children[i],depth-1);
	  }
  } else if(depth == -1){
	  let n = numelts(children);
	  for (int i = 0; i < n; i++){
	  	print_tree(children[i],-1);
	  }  
  }
  
  printf("</t>");
}

/**
 * returns whether ambiguity was found.
 */
void print_forest(spf_t spf, string_t indent){
  let &shared_parse_forest(name,l,r,w,trees) = spf;
  
  let n = numelts(trees);

  //printf("%sProcessing non terminal %s @[%d,%d] with %d children.\n",indent, name,l,r,n);

  for (let i=0; i<n; i++){
    printf("%sPath %d: ",indent, i+1);
    for (let xs = trees[i]; xs; xs = xs->tl){
      let &shared_parse_forest(nt,l,r,_,_) = xs->hd;
      printf("%s[%d,%d] ",nt,l,r);
    }
    printf("\n");
    for (let xs = trees[i]; xs; xs = xs->tl){
      print_forest(xs->hd, aprintf("%s  ",indent));
    }
  }
}

/**
 * returns whether ambiguity was found.
 */
int print_first_ambiguity(spf_t spf){
  let &shared_parse_forest(name,l,r,w,trees) = spf;
  
  let n = numelts(trees);

  printf("Processing non terminal %s @[%d,%d] with %d children.\n",name,l,r,n);

  if (n == 1){
    // No ambiguities at this level of the parse forest, check next level.
    for (let xs = trees[0]; xs; xs = xs->tl){
      if (print_first_ambiguity(xs->hd))
        return 1;
    }

    return 0;
  }
  
  for (let i=0; i<n; i++){
    printf("Path %d: ",i+1);
    for (let xs = trees[i]; xs; xs = xs->tl){
      let &shared_parse_forest(nt,l,r,_,_) = xs->hd;
      printf("%s[%d,%d] ",nt,l,r);
    }
    printf("\n");
  }
  printf("\n");
  return 1;
  
//  List::list_t<spf_t> ? trees_copy = new {for i < n: trees[i]};
//
//  let amb = 0;
//  let first = 1;
//  while (!amb){
//    if (first) first = 0;
//    else {
//      // Advance all pointers
//      for (let i=0; i<n; i++)
//        trees_copy[i] = trees_copy[i]->tl;
//    }
//
//    if (!trees_copy[0]){
//      // then the rest must be NULL, or there's a disagreement.
//      for (let i=1; i<n && !amb; i++){
//        if (trees_copy[i]) amb = i;
//      }
//      // Either all lists are done or we've found an ambiguity, so we're done.
//      break;
//    }
//    
//    
//    let &shared_parse_forest(nonterm_0,l_0,r_0,_,_) = trees_copy[0]->hd;
//    for (let i=1; i<n && !amb; i++){
//      if (!trees_copy[i] || 
//          strcmp(nonterm_0, trees_copy[i]->hd->nonterminal) ||
//          l_0 != trees_copy[i]->hd->left ||
//          r_0 != trees_copy[i]->hd->right){
//        amb = i;
//      }
//    }
//  }  
  
//  if (amb){
//    if (!trees_copy[amb])
//      printf("Path %d ends before earlier paths.\n",amb+1);
//    else {
//      printf("Ambiguity found in path %d.\n",amb+1);
//      printf("Path 1: ");
//      for (let xs = trees[0]; xs; xs = xs->tl){
//        let &shared_parse_forest(nt,l,r,_,_) = xs->hd;
//        printf("%s[%d,%d] ",nt,l,r);
//      }
//      printf("\nPath %d: ",amb+1);
//      for (let xs = trees[amb]; xs; xs = xs->tl){
//        let &shared_parse_forest(nt,l,r,_,_) = xs->hd;
//        printf("%s[%d,%d] ",nt,l,r);
//      }
//      printf("\n\n");
//    }   
//  }
//  return 1;
}
