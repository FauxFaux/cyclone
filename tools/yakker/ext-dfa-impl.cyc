/*
 * "Functor" implementing an extensible DFA. Parameters are checked below.
 */

#if !defined(EXT_DFA_NAMESPACE) || !defined(EB_NAMESPACE) || !defined(EB_EXT_NAMESPACE)
#error "Missing parameters to ext-dfa-impl.cyc"
#endif

#include "dfa-impl.h"

namespace EXT_DFA_NAMESPACE;

using EB_EXT_NAMESPACE;

//////////////////////////////////
// Internally-visible functions //
//////////////////////////////////

// Simplest strucuture needed for extending a DFA. 
// DFA::edfa_t extends this structure with some more states used for executing DFA.
struct ext_edfa {
  // Extensions to the transition function
  Hashtable::table_t<$(st_t,act_t) @`H, $(st_t,Semiring::weight_t) @`H> trans_exts;
  unsigned int number_of_states;
};

typedef struct ext_edfa @ext_edfa_t;

// Extension functions
extern ext_edfa_t create_ext_edfa(EB_NAMESPACE::DFA::grammar_edfa_t gd);

extern void add_trans(ext_edfa_t ed, st_t s, act_t a, st_t f,
    Semiring::weight_t w);
extern st_t fresh_state(ext_edfa_t ed);

////////
// Convenience functions for extending the dfa in various ways.
////////

extern st_t mk_call(ext_edfa_t ed, EB_NAMESPACE::DFA::grammar_edfa_t gd, string_t<`H> symb, st_t final);
extern st_t mk_lit(ext_edfa_t ed, string_t lit, st_t final);
extern st_t mk_char(ext_edfa_t ed, unsigned int c, st_t final);

static int st_act_cmp($(st_t,act_t) @sa1,$(st_t,act_t) @sa2) {
  let c_st = st_cmp(sa1->f0,sa2->f0);
  if (c_st) return c_st;
  return act_cmp(sa1->f1,sa2->f1);
}

static int st_act_hash($(st_t,act_t) @sa) {
  return st_hash(sa->f0) ^ act_hash(sa->f1);
}

static ext_edfa_t create_ext_edfa(EB_NAMESPACE::DFA::grammar_edfa_t gd) {
  return new ext_edfa(Hashtable::create(50,st_act_cmp,st_act_hash),
      GRM_DFA_GET_NUM_STATES(gd));
}

static void add_trans(ext_edfa_t ed, st_t s, act_t a, st_t f, Semiring::weight_t w) {
  Hashtable::insert(ed->trans_exts, new $(s,a), new $(f,w));
}

static st_t fresh_state(ext_edfa_t ed) {
  return ed->number_of_states++;
}

#define CASE_INSENSITIVE 1

static st_t mk_call(ext_edfa_t ed, EB_NAMESPACE::DFA::grammar_edfa_t gd, string_t<`H> symb, st_t final) {
  // get symbol action
  let s_a = GRM_DFA_GET_SYMB_ACTION(gd, symb);
  // get symbol start state
  let start = GRM_DFA_GET_SYMB_START(gd, s_a);
  let s = fresh_state(ed);
  add_trans(ed, s, Earley::callout_action(), start, Semiring::zero_weight);
  add_trans(ed, s,s_a,final,Semiring::one_weight);
  return s;
}

static st_t mk_lit(ext_edfa_t ed, string_t lit, st_t final) {
  assert (lit[0] != '\0');
  int n = strlen(lit);
  st_t dst = final;
  for (int i=n-1; i >= 0; i--) {
    let s = fresh_state(ed);
    if (CASE_INSENSITIVE && tolower(lit[i]) != toupper(lit[i])) {
      let w = Semiring::from_inv_prob(2);
      add_trans(ed, s,tolower(lit[i]),dst,w);
      add_trans(ed, s,toupper(lit[i]),dst,w);
    }
    else
    add_trans(ed, s,lit[i],dst,Semiring::one_weight);
    dst = s;
  }
  return dst;
}

static st_t mk_char(ext_edfa_t ed, unsigned int c, st_t final) {
  let s = fresh_state(ed);
  if (CASE_INSENSITIVE && tolower(c) != toupper(c)) {
    let w = Semiring::from_inv_prob(2);
    add_trans(ed, s,tolower(c),final,w);
    add_trans(ed, s,toupper(c),final,w);
  }
  else
  add_trans(ed, s,c,final,Semiring::one_weight);
  return s;
}

///////////////////////////////////////////////////////////////////////////////
// Externally-visible functions
/////////////////////////////////

st_t trans(DFA::edfa_t ed, st_t s, act_t a){
  let t = DFA_TRANS(ed->d,s,a);
  if (t) return t;
  let p_tw_opt = Hashtable::lookup_opt(ed->trans_exts,new $(s,a));
  if (!p_tw_opt)
    return t;
  return (*p_tw_opt)->f0;
}

$(st_t,Semiring::weight_t) trans_w(DFA::edfa_t ed, st_t s, act_t a){
  let tw = DFA_TRANS_W(ed->d,s,a);
  if (tw.f0) return tw;
  let p_tw_opt = Hashtable::lookup_opt(ed->trans_exts,new $(s,a));
  if (!p_tw_opt)
    return tw;
  return **p_tw_opt;
}

int in_final(DFA::edfa_t ed, act_t a, st_t s){
  return DFA_IN_FINAL(ed->d,a,s);
}

int is_final(DFA::edfa_t ed, st_t s){
  return DFA_IS_FINAL(ed->d,s) || s == ed->final;
}

Semiring::weight_t final_weight(DFA::edfa_t ed, st_t s){
  if (s == ed->final) 
    return Semiring::one_weight;  
  return DFA_FINAL_WEIGHT(ed->d,s);
}

act_t ?final_attrs(DFA::edfa_t ed, st_t s){
  if (s == ed->final) return new {};
  
  return DFA_FINAL_ATTRS(ed->d,s);
}

st_t get_start(DFA::edfa_t ed){
  return DFA_GET_START(ed->d);
}

string_t act_2_symb(DFA::edfa_t ed, act_t a){
  return DFA_ACT2SYMB(ed->d, a);
}

$(act_t, act_t, st_t, st_t) get_repeat_info(DFA::edfa_t ed, st_t state){
  return DFA_GET_REPEAT_INFO(ed->d, state);
}

// Construct a repeat dfa: ...
// The new  state is connected to the specified final state "f".
st_t construct_repeat_dfa(DFA::edfa_t ed, act_t next, 
                          act_t target_act, st_t target_s, 
                          act_t final_act, st_t final){
  let s = fresh_state( (ext_edfa_t)ed );
  // Transitions don't sum to one b/c we've really compacted many states into one.
  add_trans( (ext_edfa_t)ed, s, target_act, target_s, Semiring::from_inv_prob(2));
  add_trans( (ext_edfa_t)ed, s, final_act,  final,    Semiring::one_weight );
  add_trans( (ext_edfa_t)ed, s, next,       s,        
       Semiring::from_inv_prob(2));
  return s;
}

static void dot_trans_iter($(st_t,act_t) @`H src, 
    $(st_t,Semiring::weight_t) @`H tgt,
    DFA::edfa_t ed){
  let &$(s,a) = src;
  let &$(t,_) = tgt;
  let act = a > 255 ? DFA_ACT2SYMB(ed->d,a) : cs2string(cs_range(a,a+1),NULL);
  printf("%d -> %d [ label = \"%s\" ];\n",s,t,act);
}

// prints to standard error.
void dfa_dot(DFA::edfa_t ed) {
  printf("digraph g {\n");
  printf("%d [ shape = \"doublecircle\" ];\n", DFA_GET_START(ed->d));
  Hashtable::iter_c(dot_trans_iter,ed->trans_exts,ed);
  printf("}\n");
}

static st_t pat2dfa0(rule_pat_t p, ext_edfa_t ed, EB_NAMESPACE::DFA::grammar_edfa_t gd, st_t final) {
  switch (p) {
  case &SymbPat(x):
    fallthru(x);
  case &BinderPat(x):
    // TODO: mk_call will need to somehow ensure that if this is executed, the data is bound.
    // This will need t o be done in a crawl because of ambiguity issues (e.g. you can start a 
    // path which doesn't complete, so don't want to bind until you know that path completed).
    return mk_call(ed, gd, x, final);
  case &LitPat(x):
    return mk_lit(ed, x, final);
  case &CharPat(c):
    return mk_char(ed, c, final);
  case &SeqPat(p1, p2):
    let s2 = pat2dfa0(p2, ed, gd, final);
    return pat2dfa0(p1, ed, gd, s2);
  }
}

DFA::edfa_t pat2dfa(rule_pat_t p, EB_NAMESPACE::DFA::grammar_edfa_t grm_dfa) {
  let ed = create_ext_edfa(grm_dfa);
  let final_state = fresh_state(ed);
  let start_state = pat2dfa0(p, ed, grm_dfa, final_state);
  return new DFA::edfa(ed->trans_exts, ed->number_of_states, GRM_DFA_GET_DFA(grm_dfa,start_state), final_state);
}

DEFINE_MK_ANY_EB(EB_EXT_NAMESPACE)
//EarleyAnyBackend::DFA::edfa_t mk_any_eb(EB_EXT_NAMESPACE::DFA::edfa_t impl_dfa){
//  return new EarleyAnyBackend::DFA::edfa(impl_dfa,
//      trans, trans_w, in_final, is_final, final_weight, final_attrs, get_start, act_2_symb,
//      get_repeat_info, construct_repeat_dfa);
//}
