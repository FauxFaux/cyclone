#include <buffer.h>
#include <string.h>
#include <core.h>
#include <stdlib.h>
#include <list.h>
#include <graph.h>
#include <hashtable.h>

#include "fa.h"
#include "axarray.h"
#include "earley.h"
#include "earley-parsetree.h"
#include "semiring.h"
#include "earley-backend.h"

#include "ykbuf.h"
#define YKLIMIT ykb->lim
#define YKCURSOR ykb->cur
#define YKFILL(n) (ykfill(ykb,(n)))
#define YKPOSN ((ykb->cur-ykb->bot)+ykb->discarded)
#define YKMARKER ykb->mark
#define YKSAVE ({ let x = 0; ykb->save_count++; if (ykb->save) x = ykb->cur-ykb->save; else ykb->save = ykb->cur; x; })
#define YKRESTORE(x) ({ let p = ykb->save+x; if (--ykb->save_count == 0) ykb->save=NULL; p; })
//int ykdebug = 0;
//datatype exn { Parse_error };
//datatype exn.Parse_error Parse_error_val = Parse_error;

using List;
using Semiring;

#include "dfa.h"
#include "dfa-impl.h"


namespace EarleyAnyBackend;

#define DFA_IS_DFA_FINAL(dfa,s) \
  ({let as = DFA_FINAL_ATTRS(dfa,s); as && numelts(as) == 0;})

/* An automaton state and parent pointer */
typedef $(st_t,unsigned int) @earley_item_t;

static int earley_item_cmp(earley_item_t a,earley_item_t b) {
  let $(ai,aj) = *a;
  let $(bi,bj) = *b;
  let c = Core::intcmp(ai,bi);
  if (c) return c;
  return Core::intcmp(aj,bj);
}

typedef $(st_t,unsigned int,unsigned int) @earley_node_t;
typedef $(st_t,unsigned int,unsigned int) *earley_node_opt_t;
typedef  Hashtable::table_t<earley_item_t,List::list_t<earley_node_t,`r>,`r> earley_graph_t<`r>;
static int earley_node_cmp(earley_node_t a,earley_node_t b) {
  let $(ai,aj,ak) = *a;
  let $(bi,bj,bk) = *b;
  let c = Core::intcmp(ai,bi);
  if (c) return c;
  c = Core::intcmp(aj,bj);
  if (c) return c;
  return Core::intcmp(ak,bk);
}

static int earley_node_hash(earley_node_t a) {
  let $(ai,aj,ak) = *a;
  /* All ai, aj, and ak are ints starting at 0, ai maxes out at the
     number of states, aj and ak max out at the input length.
     TODO: see what typical sizes are for these and adjust the
     hash function accordingly.
  */
  return ai ^ (aj+ak);
}

typedef Set::set_t<earley_item_t> earley_state_t;

struct elink {
  earley_node_t      pred;
  Semiring::weight_t p_weight; // predecessor weight
  earley_node_opt_t  retn;
  act_t              resp_act; // action responsible for link.
};
typedef struct elink @`H elink_t;

struct rstate {
  DFA::edfa_t dfa;
  Axarray::xarray_t<earley_state_t> estates;
  Hashtable::table_t<earley_node_t,List::list_t<struct elink @`H,`H>,`H> links;
  Hashtable::table_t<earley_node_t,$(Semiring::weight_t,Semiring::weight_t)@> weights; //PROB
  Hashtable::table_t<st_t,int @,`H> repeat_counts;
};
typedef struct rstate @rstate_t;

static act_t callout_action() {
  return 256;
}
static act_t repeat_action() {
  return 257;
}
static act_t final_st_action() {
  return 258;
}
static act_t repeat_decr_action() {
  return 259;
}

static act_t repeat_final_action() {
  return 260;
}

static void set_repeat_count(rstate_t rs, st_t s, int n){
  Hashtable::insert(rs->repeat_counts,s, new n);
}

static int decr_repeat_count(rstate_t rs, st_t s){
  let rc = Hashtable::lookup(rs->repeat_counts,s);
  return (*rc)--;
}

static void remove_repeat_count(rstate_t rs, st_t s){
  Hashtable::remove(rs->repeat_counts,s);
}

static int do_reconstruct = 1;

void point_to(Hashtable::table_t<earley_node_t,List::list_t<`a,`H>,`H> tbl,
              earley_node_t source,
              `a target) {

  let ptr = Hashtable::lookup_opt(tbl,source);
  if (ptr != NULL) {
    Hashtable::remove(tbl,source);
    Hashtable::insert(tbl,source,new List::List(target,*ptr));
  }
  else Hashtable::insert(tbl,source,List::list(target));
}

// Retrieve bounds of previously-appearing non terminal within currently parsing RHS.
// If appears multiple times, only returns one answer.
// If can't be found, return NULL;
$(unsigned int, unsigned int) *
get_bounds(Hashtable::table_t<earley_node_t, list_t<elink_t>,`H> links,
     DFA::edfa_t dfa,
     earley_node_t en, act_t nt){

  let maybe_links = Hashtable::lookup_opt(links,en);
  if (maybe_links == NULL) 
    return NULL;
  else {
    // OPTIMIZATION: we could use a loop instead of recursion if there
    // is only one link.

    // Search all predecessor paths
    for (let xs = *maybe_links; xs; xs = xs->tl) {
      let &elink(pred_link,_,retn_link,_) = xs->hd;

      if (retn_link) {
        let &$(x,i,j) = (_@)retn_link;
        if (DFA_IN_FINAL(dfa,nt,x))
        // found it
        return new $(i,j);
      }

      // keep looking -- recurse.
      let b = get_bounds(links, dfa, pred_link, nt);
      if (b) return b;

    }
  }

  return NULL;
}

//PROB
void add_weights(rstate_t rs, earley_node_t node, weight_t forward, weight_t inner) { //PROB
  let ptr = Hashtable::lookup_opt(rs->weights,node);                            //PROB
  if (ptr != NULL) {                                                            //PROB
    $(weight_t,weight_t)@y = *ptr;                                                    //PROB
    y->f0 = Semiring::add( y->f0, forward );                                    //PROB
    y->f1 = Semiring::add( y->f1, inner );                                      //PROB
  }                                                                             //PROB
  else Hashtable::insert(rs->weights,node,new $(forward,inner));                //PROB

  return;
}                                                                               //PROB


/* Add an item to an Earley state.
   If the item has an automaton state that transitions to another state
   by epsilon, add items for those states too.
   Epsilons may be for CALLS to parse non-terminals or
   RETURNS from parsing non-terminals.
 */
void
push_closure(rstate_t rs,
    unsigned char ? @nozeroterm input,
    unsigned int i,
    earley_item_t ei, // YHM: I think this should be an early node
    // instead of an earley item for
    // efficiency sake (to save allocations).
    earley_node_opt_t back,
    earley_node_opt_t up,
    act_t resp_act // action responsible for transition.
    , weight_t forward, weight_t inner //PROB
) {

  let &$(s,backptr) = ei;
  let node = new $(s,backptr,i);
  add_weights(rs,node,forward,inner); //PROB
  if (back != NULL) {
    point_to(rs->links,node,new elink(back,inner,up, resp_act));
  }

  let es = Axarray::get(rs->estates,i);
  if (Set::member(es,ei)) {
    // TODO: XXX: is it okay to return if the weight has changed???
    return;
  }
  // fprintf(stderr,"estates[%d] += (%d,%d)\n",i,ei->f0,ei->f1);fflush(stderr);
  Axarray::set(rs->estates,i,Set::insert(es,ei));

  /* Close under CALLS. We don't use the weight here. */
  let t = DFA_TRANS(rs->dfa,s,callout_action()); 
  if (t != 0) {
#if defined(NULL_PLAN_B) || defined(NULL_PLAN_C)    
    // Check for RETURN of nullable symbols
    // TODO: do the same for REPEAT calls.
    if (DFA_IS_FINAL(rs->dfa,t)) {
      let final_w = DFA_FINAL_WEIGHT(rs->dfa,t);

      /* For every completed symbol... */
      let ss = DFA_FINAL_ATTRS(rs->dfa,t);
      let n = numelts(ss);
      for (int sym_i=0; sym_i < n; sym_i++) {
        let symb_act = ss[sym_i];

        let starget = DFA_TRANS(rs->dfa,s,symb_act);
        if (starget != 0) {
          // Earley node that completed nullable RHS.
          let causal_node = new $(t,i,i);
          let &$(node_forward,node_inner) = Hashtable::lookup(rs->weights,node); //PROB
          let w_m = mult(inner, final_w);
          push_closure(rs,input,i,new $(starget,backptr),
              node, causal_node, symb_act
              ,mult( w_m, node_forward), //PROB
              mult( w_m, node_inner) //PROB
          );
        }
        
        let ttarget = DFA_TRANS(rs->dfa,t,symb_act);
        if (ttarget != 0) {
          // Earley node that completed nullable RHS.
          let causal_node = new $(t,i,i);
          let &$(node_forward,node_inner) = Hashtable::lookup(rs->weights,node); //PROB
          let w_m = mult(inner, final_w);
          push_closure(rs,input,i,new $(ttarget,i),
              node, causal_node, symb_act
              ,mult( w_m, node_forward), //PROB
              mult( w_m, node_inner) //PROB
          );
        }
      
        // Sanity check:
#ifdef NULL_PLAN_B
        if (ttarget == 0 && starget == 0) {
          fprintf(stderr,"Error: target for %d not found in call source state %d or target state %d.\n",symb_act,s,t);
        } 
#endif
      }
    }
#endif
    
    push_closure(rs,input,i,new $(t,i),NULL,NULL, /* bogus action: */ 0
        ,forward,Semiring::one_weight //PROB
    );
  } /* End, Close under CALLS. */

  /* Close under REPEAT-DECR (special type of CALL). */
  let t = DFA_TRANS(rs->dfa,s,repeat_decr_action());
  if (t != 0) {
    // Lookup and decrement repeat count
    let rc = decr_repeat_count(rs,s);
    // if zero, remove transition on repeat_final and continue.
    if (rc == 0){
      remove_repeat_count(rs,s);
      let t = DFA_TRANS(rs->dfa,s,repeat_final_action());
      /* Call push_closure again as if we started in this
   state. ie. t replaces s. So, we reuse back, up and resp_act. */
      push_closure(rs,input,i,new $(t,backptr),back,up, resp_act
       ,forward,inner //PROB
       );
      return;
    }
    // If non zero, continue as in call
    push_closure(rs,input,i,new $(t,i),NULL,NULL, /* bogus action: */ 0
     ,forward,Semiring::one_weight //PROB
                 );
  }

  /* Close under REPEATS. Only works if target has *one* non-call target. */  
  let t = DFA_TRANS(rs->dfa,s,repeat_action());
  if (t != 0) {
    /* 0. Get the parameters of the repeat: repeater, repeatee, repeatee start state, and 
     *    follow state of the repeat. */
    let $(rpter_act,rptee_act, rptee_start, repeat_follow) = DFA_GET_REPEAT_INFO(rs->dfa,t);
    
    /* 1. Retrieve the number from the Earley graph.*/

    // get the bounds (inclusive) of parsed repeater non-terminal (with action rpter_act) 
    // from the Earley graph.
    let bounds_opt = get_bounds(rs->links, rs->dfa, node,rpter_act);
    if (!bounds_opt){
      fprintf(stderr,"Error: bounds could not be found for non terminal.\n");
      return;
    }
    let &$(j,k) = (_@)bounds_opt;
    let num = atoi(substring(input,j,k-j+1));

    /* 2. Build new DFA using retrieved number. */
    let t_new = DFA_R_EXTEND(rs->dfa, rptee_act,rptee_start,repeat_follow);
    set_repeat_count(rs,t_new,num);

    /* 3. Call push_closure again as if we started in this
       state. ie. t_new replaces s. So, we reuse back, up and resp_act. */
    push_closure(rs,input,i,new $(t_new,backptr),back,up,resp_act
                 ,forward,inner //PROB
                 );
  }

  /* Close under RETURNS.  Use else, because a REPEAT state can't
     also be a final state. */
  else if (
      // TODO: commenting-out the following line is only a short-term solution to dealing with 
      // nullable elements. It is inefficient -- we should look for another way to do
      // this.
#if defined(NULL_PLAN_A) || defined(NULL_PLAN_C)      
       i != backptr && // we parsed the empty string, RETURN handled by dfa already
#endif
       DFA_IS_FINAL(rs->dfa,s)) {
    /* Some symbol is completed.
       es_back is the Earley state that CALLed the symbol. */
    let es_back = Axarray::get(rs->estates,backptr);
    let final_w = DFA_FINAL_WEIGHT(rs->dfa,s);

    /* For every completed symbol... */
    let ss = DFA_FINAL_ATTRS(rs->dfa,s);
    let n = numelts(ss);
    for (int sym_i=0; sym_i < n; sym_i++) {
      let symb_act = ss[sym_i];

      /* ... look at every DFA state in es_back... */
      for (let es_back_list = Set::to_list(es_back);
      es_back_list != NULL;
      es_back_list = es_back_list->tl) {

        let &$(t,tbackptr) = es_back_list->hd;
        let ttarget = DFA_TRANS(rs->dfa,t,symb_act);
        /* ... see if the DFA state did a CALL and RETURN if so. */
        if (ttarget != 0) {
          // Earley node w/ dot before symb.
          let backnode = new $(t,tbackptr,backptr);
          let &$(backnode_forward,backnode_inner) = 
            Hashtable::lookup(rs->weights,backnode); //PROB
          let w_m = mult(inner, final_w);
          push_closure(rs,input,i,new $(ttarget,tbackptr), 
          backnode, node, symb_act
          ,mult( w_m, backnode_forward), //PROB
          mult( w_m, backnode_inner) //PROB
          );
        }
      }
    }
  }
}

using EarleyParsetree;

shared_parse_tree_t
mk_parse_forest(rstate_t rs,
     string_t input,
     earley_node_t en,
     act_t resp_act);

// List::List_t<parse_forest_t> prefix_all(parse_tree_t,List::List_t<parse_forest_t>);
// imperative update of fs.
void prefix_all_imp(shared_parse_tree_t t,List::list_t<shared_parse_forest_t> fs){
  for (;fs;fs = fs->tl){
    fs->hd = new List::List(t,fs->hd);
  }
}

//List::list_t<$(parse_forest_t,Semiring::weight_t) @>
List::list_t<shared_parse_forest_t>
mk_parse_branches(rstate_t rs,
          string_t input,
          earley_node_t en){
  let derivations = NULL;
  let maybe_links = Hashtable::lookup_opt(rs->links,en);
  if (maybe_links != NULL) {

    // Compute all derivations.
    for (let xs = *maybe_links; xs; xs = xs->tl) {
      let &elink(pred_link,w,retn_link,resp_act) = xs->hd;

      let pred_derivations = mk_parse_branches(rs, input, pred_link);
      if (retn_link) {
        let child_tree = mk_parse_forest(rs, input, retn_link, resp_act);
        // prefix all forests of pred_derivations with child_tree.
        prefix_all_imp(child_tree, pred_derivations);
      }

      derivations = List::append(derivations, pred_derivations);
    }

  }else
    // A single, empty derivation.
    derivations = List::list(NULL);


  //////////// Debug Code ///////////
//   if (derivations != NULL && derivations->tl != NULL) {
//     // More than one derivation, so ambiguous.
//     fprintf(stderr,"Ambiguous parse, (%d,%d,%d) has multiple derivations\n",
//       en->f0,en->f1,en->f2);
//     fflush(stderr);
//   }
  //////////////////////////////////

  return derivations;
}

/**
 * INVARIANT: state of en must be final.
 * */
shared_parse_tree_t
mk_parse_forest(rstate_t rs,
     string_t input,
     earley_node_t en,
     act_t resp_act) {
  
  let &$(x,i,j) = en;

  // Sanity check
  if (debug){
    if (!DFA_IN_FINAL(rs->dfa,resp_act,x)){
      fprintf(stderr,"Action %s is not an attribute of state %d.\n",DFA_ACT2SYMB(rs->dfa,resp_act),x);
    }
  }
  
  string_t name = DFA_ACT2SYMB(rs->dfa,resp_act);

  // Handle case of top-level call, for which there will be no responsible action.
  let completed = DFA_FINAL_ATTRS(rs->dfa,x);
  // Sanity check
  if (!completed){
    throw new Core::Invalid_argument(aprintf("State %d is not a final state.",x));
  }
  if (numelts(completed) == 0) {
    name = "TOP";
  }

  shared_parse_tree_t tree;

  let h_derivations = mk_parse_branches(rs,input,en);
  let &$(w_forward,w_inner) = Hashtable::lookup(rs->weights, en);
  // distinguish ambiguous from unamb. parses.
  if (h_derivations == NULL){
    // YHM: can len == 0 ? If so, how did entry ever get created?
    // Yes, because it can be a string of terminals.
    //fprintf(stderr,"No derivations returned.\n");
    tree = new NonTerm(name,i,j,w_forward,NULL);
  } else if(h_derivations->tl == NULL){
    // Unambiguous
    tree = new NonTerm(name,i,j,w_forward,h_derivations->hd);
  } else {
     // Ambiguous
    tree = new SharedNonTerm(name,i,j,w_forward,h_derivations);
  }

  return tree;
  

}

////////////////////////

#define RESOLVE_AMBS

// Reconstruct a parse tree. Throws Invalid_argument if earley graph is ambiguous 
parse_tree_t
mk_parse_tree(rstate_t rs,
     string_t<`H> top_level_name,
     earley_node_t en,
     act_t resp_act) {
  // map: early_node_t -> parse_tree_t
  let trees = Hashtable::create(11,earley_node_cmp,earley_node_hash);
  
  let &$(x,i,j) = en;
  
  // Sanity check
  if (debug){
    if (!DFA_IN_FINAL(rs->dfa,resp_act,x)){
      fprintf(stderr,"Action %s is not an attribute of state %d.\n",DFA_ACT2SYMB(rs->dfa,resp_act),x);
    }
  }

  string_t name = DFA_ACT2SYMB(rs->dfa,resp_act);
  // Handle case of top-level call, for which there will be no responsible action.
  let completed = DFA_FINAL_ATTRS(rs->dfa,x);
  if (!completed){ // Sanity check
    throw new Core::Invalid_argument(aprintf("State %d is not a final state.",x));
  }
  if (numelts(completed) == 0) {
    if (top_level_name == NULL)
      throw new Core::Failure(aprintf("Final DFA state encountered unexpectedly in (%d,%d,%d).",x,i,j));
    name = top_level_name;
  }

  // reconstruct trees of children (i.e. RHS).
  let children_trees = NULL;
  let maybe_links = Hashtable::lookup_opt(rs->links,en);
  while (maybe_links != NULL) {
    let links = *maybe_links;
    // Check for ambiguity.
    if (links->tl != NULL){
#ifndef RESOLVE_AMBS     
      throw new Core::Invalid_argument(aprintf("Earley graph is ambiguous for symbol %s at substring [%d,%d).",name,i,j));
#else
      if (debug)
        fprintf(stderr,"Earley graph is ambiguous for symbol %s at substring [%d,%d). Choosing first derivation.\n",name,i,j);
#endif
      //links=links->tl;
    }
    let &elink(pred_link, w, retn_link, resp_act) = links->hd;

    if (retn_link) {
      let retn_tree_opt = Hashtable::lookup_opt(trees,retn_link);
      let retn_tree;
      if (!retn_tree_opt){
        retn_tree = mk_parse_tree(rs, NULL, retn_link, resp_act);
        Hashtable::insert(trees,retn_link,retn_tree);
      } else
        retn_tree = *retn_tree_opt;
      // we can build the list backwards because we are starting at the end of 
      // the RHS and traversing pred links towards the beginning.
      children_trees = new List::List(retn_tree,
                                   children_trees);
    }
    maybe_links = Hashtable::lookup_opt(rs->links,pred_link);
  }
  
  let &$(w_forward,w_inner) = Hashtable::lookup(rs->weights, en);
  return new parse_tree(name,i,j,w_forward, List::to_array( children_trees ));
}

/////////////////////////////////////////
// Print the earley graph in dot format
///////////////////////////////////////////

static void dot_pred_iter(earley_node_t s, List::list_t<struct elink @`H,`H> ts, rstate_t rs) {
  let &$(si,sj,sk) = s;
  for (; ts; ts = ts->tl) {
    let &$(ti,tj,tk) = ts->hd->pred;
    printf("\"(%d,%d,%d)\" -> ",si,sj,sk);
    printf("\"(%d,%d,%d)\"",ti,tj,tk);
    printf(" [ label = \"%s\" ];\n",DFA_ACT2SYMB(rs->dfa,ts->hd->resp_act));
  }
}

static void dot_retn_iter(earley_node_t s, List::list_t<struct elink @`H,`H> ts, rstate_t rs) {
  let &$(si,sj,sk) = s;
  for (; ts; ts = ts->tl) {
    let r = ts->hd->retn;
    if (r != NULL){
      let $(ti,tj,tk) = *r;
      printf("\"(%d,%d,%d)\" -> ",si,sj,sk);
      printf("\"(%d,%d,%d)\"",ti,tj,tk);
      printf(" [ label = \"%s\" ];\n",DFA_ACT2SYMB(rs->dfa,ts->hd->resp_act));
    }
  }
}

static void rstate_dot(rstate_t rs) {
  printf("digraph g {\n");
  printf("edge [style=dotted]\n");
  Hashtable::iter_c(dot_pred_iter,rs->links,rs);
  printf("edge [style=bold]\n");
  Hashtable::iter_c(dot_retn_iter,rs->links,rs);
//  Hashtable::iter(dot_iter,rs->call);
  printf("}\n");
}

/////////////////////////////////////////////////

$(List::list_t<$(parse_tree_t,Semiring::weight_t)@>,int,int)
ykb_parse(DFA::edfa_t dfa, ykbuf_t@ ykb, int parse_until_eof) {
  /* Keep track of parse trees */
  let
  links = Hashtable::create(11,earley_node_cmp,earley_node_hash);
  let //PROB
  weights = Hashtable::create(11,earley_node_cmp,earley_node_hash); //PROB
  let
  rcounts = Hashtable::create(11,st_cmp,st_hash);

  /* Initialize the sequence of Earley states with s0 */
  let estates = /* Earley states  s0, s1, s2, ... */
  Axarray::create(11,Set::empty(earley_item_cmp));
  let earley_item_0 = new $(DFA_GET_START(dfa),0); //  0 is i in si
  let rs = new rstate {
    dfa,
    estates,links
    ,weights //PROB
    ,rcounts
  };
  
  // Save the input form the beginning so that we have access to it later.
  let input_save = YKSAVE;
  
  push_closure(rs,
      ykb->save + input_save,
      0,
      earley_item_0,
      NULL,NULL, /* bogus action: */ 0
      ,Semiring::one_weight,Semiring::one_weight //PROB
  );
  
  let t = DFA_GET_START(dfa);
  let i = 0;
#if defined(NULL_PLAN_B) || defined(NULL_PLAN_C)    
  /* Check for RETURN of nullable symbols */
  if (DFA_IS_FINAL(rs->dfa,t)) {
    let final_w = DFA_FINAL_WEIGHT(rs->dfa,t);

    /* For every completed symbol... */
    let ss = DFA_FINAL_ATTRS(rs->dfa,t);
    let n = numelts(ss);
    for (int sym_i=0; sym_i < n; sym_i++) {
      let symb_act = ss[sym_i];

      let ttarget = DFA_TRANS(rs->dfa,t,symb_act);
      if (ttarget != 0) {
        // Earley node that completed nullable RHS.
        let causal_node = new $(t,i,i);
        let w_m = final_w;
        push_closure(rs,ykb->save + input_save,i,new $(ttarget,i),
            causal_node, causal_node, symb_act
            ,w_m, w_m //PROB
        );
      } 
#ifdef NULL_PLAN_C
      else {// Sanity check:
        fprintf(stderr,"Error: target for %d not found in initial state.\n",symb_act);
      } 
#endif
    }
  }
#endif

  int hit_final = 0;
  let no_error = 1;

  if (!parse_until_eof){
    // Check to see whether we've reached a final state
    for (let si_list = Set::to_list(Axarray::get(estates,i));
        si_list != NULL;
        si_list = si_list->tl) {

      let &$(state,parent) = si_list->hd;
      if (parent == 0 && DFA_IS_DFA_FINAL(dfa,state)){
          hit_final = 1;
          break;
      }
    }
  }
  
  if (!hit_final) {
    /* Scan the input */
    YKFILL(1); // Make sure we have at least one element in the buffer.
    int c = *YKCURSOR; 

    
    for (; no_error && !(*YKCURSOR == 0 && ykb->eof); i++) {
      //YKCURSOR++; forgetting to set c results in bus error. Why?
      c = *YKCURSOR++; // consume current element.

      // reset for this round.
      // will be set to one if there is at least one transition on 
      // input character c.
      no_error = 0;
      
      // Process character c. 
      //fprintf(stderr,"input[%d]==%s\n",i,cs_char_escape(c));fflush(stderr);
      for (let si_list = Set::to_list(Axarray::get(estates,i));
          si_list != NULL;
          si_list = si_list->tl) {
  
        let &$(state,parent) = si_list->hd;
        //fprintf(stderr,"Considering (%d,%d) for %c. ",state,parent,input[i]);
        let $(k,w) = DFA_TRANS_W(dfa,state,c); //PROB
        //fprintf(stderr,"k = %d.\n",k);
        if (k != 0) {// where k==0 indicates there is no valid target.
          no_error = 1;
          let enode = new $(state,parent,i);
          let &$(forward,inner) = Hashtable::lookup(rs->weights,enode);
          push_closure(rs,ykb->save + input_save,i+1,new $(k,parent),enode,NULL, c
              ,Semiring::mult(w, forward), Semiring::mult(w, inner) //PROB
          );
        }
      }
      
      if (!parse_until_eof){
        // Check whether we've reached a final state
        hit_final = 0;
        for (let si_list = Set::to_list(Axarray::get(estates,i+1));
            si_list != NULL;
            si_list = si_list->tl) {
    
          let &$(state,parent) = si_list->hd;
          if (parent == 0 && DFA_IS_DFA_FINAL(dfa,state)){
              hit_final = 1;
              break;
          }
        }
        if (hit_final) {
          // We're done parsing, so break out of the loop. Increment i, though, to record advance to next input element.
          i++;
          break;
        }
      }
      if ((YKLIMIT - YKCURSOR) < 1) YKFILL(1);
    }
  }
  
  if (no_error){
    if (debug)
      fprintf(stderr, "No parse errors detected. Searching for final states at position %d.\n", i);
    //rstate_dot(rs);
  } else {
    if (debug)
      fprintf(stderr, "Parse error at input character %d.\n",i-1);
    YKCURSOR = YKRESTORE(input_save);
    return $(NULL,0,0);
  }

  /* See if we ended up in a final state */
  let partial_parses = 0;
  let complete_parses = 0;
  let trees = NULL;
  for (let slast_list = Set::to_list(Axarray::get(estates,i));
      slast_list != NULL;
      slast_list = slast_list->tl) {
    partial_parses++;
    let &$(state,parent) = slast_list->hd;
    if (DFA_IS_DFA_FINAL(dfa,state) && parent == 0) {
      complete_parses++;

        if (do_reconstruct) {
          let en = new $(state,parent /*== 0*/,i);
          try{
            let derivation_tree = mk_parse_tree(rs,"TOP LEVEL",en, /* bogus action: */ 0);
            let &$(w_forward,w_inner) = Hashtable::lookup(rs->weights, en);
            trees = new List::List(new $(derivation_tree,w_forward),trees);
          } catch {
            case &Core::Invalid_argument(msg):
              fprintf(stderr,"Ambiguous tree at early node (%d,0,%d):\n\t%s\n",state,i,msg);
            break;  
          }
        }
    }
  }

  YKRESTORE(input_save); // commit: don't set YKCURSOR, because we don't want to rewind the input.
                         // the purpose of the save was only to prevent discarding.
  
  return $(trees,complete_parses,partial_parses);  
}

$(List::list_t<$(parse_tree_t,Semiring::weight_t)@>,int,int) 
parse(DFA::edfa_t dfa, const char? input) {
  let ykinput = string2ykbuf(input);
  return ykb_parse(dfa, ykinput,1);
}
