#include <buffer.h>
#include <string.h>
#include <core.h>
#include <stdlib.h>
#include <list.h>
#include <graph.h>
#include <hashtable.h>

#include "fa.h"
#include "axarray.h"
#include "earley.h"
#include "earley-parsetree.h"
#include "semiring.h"
#include "earley-backend.h"

#include "ykbuf.h"
#define YKLIMIT ykb->lim
#define YKCURSOR ykb->cur
#define YKFILL(n) (ykfill(ykb,(n)))
#define YKPOSN ((ykb->cur-ykb->bot)+ykb->discarded)
#define YKMARKER ykb->mark
#define YKSAVE ({ let x = 0; ykb->save_count++; if (ykb->save) x = ykb->cur-ykb->save; else ykb->save = ykb->cur; x; })
#define YKRESTORE(x) ({ let p = ykb->save+x; if (--ykb->save_count == 0) ykb->save=NULL; p; })
//int ykdebug = 0;
//datatype exn { Parse_error };
//datatype exn.Parse_error Parse_error_val = Parse_error;

using List;
using Semiring;

#include "dfa.h"
#include "dfa-impl.h"


namespace EarleyAnyBackend;

#define DFA_IS_DFA_FINAL(dfa,s) \
  ({let as = DFA_FINAL_ATTRS(dfa,s); as && numelts(as) == 0;})

/* An automaton state and parent pointer */
typedef $(st_t,unsigned int) @earley_item_t;

static int earley_item_cmp(earley_item_t a,earley_item_t b) {
  let $(ai,aj) = *a;
  let $(bi,bj) = *b;
  let c = Core::intcmp(ai,bi);
  if (c) return c;
  return Core::intcmp(aj,bj);
}

typedef $(st_t,unsigned int,unsigned int) @earley_node_t;
typedef $(st_t,unsigned int,unsigned int) *earley_node_opt_t;
typedef  Hashtable::table_t<earley_item_t,List::list_t<earley_node_t,`r>,`r> earley_graph_t<`r>;
static int earley_node_cmp(earley_node_t a,earley_node_t b) {
  let $(ai,aj,ak) = *a;
  let $(bi,bj,bk) = *b;
  let c = Core::intcmp(ai,bi);
  if (c) return c;
  c = Core::intcmp(aj,bj);
  if (c) return c;
  return Core::intcmp(ak,bk);
}

static int earley_node_hash(earley_node_t a) {
  let $(ai,aj,ak) = *a;
  /* All ai, aj, and ak are ints starting at 0, ai maxes out at the
     number of states, aj and ak max out at the input length.
     TODO: see what typical sizes are for these and adjust the
     hash function accordingly.
  */
  return ai ^ (aj+ak);
}

typedef Set::set_t<earley_item_t> earley_state_t;

struct elink {
  earley_node_t      pred;
  Semiring::weight_t p_weight; // predecessor weight
  earley_node_opt_t  retn;
  act_t              resp_act; // action responsible for link.
};
typedef struct elink @`H elink_t;

struct rstate {
  DFA::edfa_t dfa;
  Axarray::xarray_t<earley_state_t> estates;
  Hashtable::table_t<earley_node_t,List::list_t<struct elink @`H,`H>,`H> links;
  Hashtable::table_t<earley_node_t,$(Semiring::weight_t,Semiring::weight_t)@> weights; //PROB
  Hashtable::table_t<st_t,int @,`H> repeat_counts;
};
typedef struct rstate @rstate_t;

static act_t callout_action() {
  return 256;
}
static act_t repeat_action() {
  return 257;
}
static act_t final_st_action() {
  return 258;
}
static act_t repeat_decr_action() {
  return 259;
}

static act_t repeat_final_action() {
  return 260;
}

static void set_repeat_count(rstate_t rs, st_t s, int n){
  Hashtable::insert(rs->repeat_counts,s, new n);
}

static int decr_repeat_count(rstate_t rs, st_t s){
  let rc = Hashtable::lookup(rs->repeat_counts,s);
  return (*rc)--;
}

static void remove_repeat_count(rstate_t rs, st_t s){
  Hashtable::remove(rs->repeat_counts,s);
}

static int do_reconstruct = 1;

void point_to(Hashtable::table_t<earley_node_t,List::list_t<`a,`H>,`H> tbl,
              earley_node_t source,
              `a target) {

  let ptr = Hashtable::lookup_opt(tbl,source);
  if (ptr != NULL) {
    Hashtable::remove(tbl,source);
    Hashtable::insert(tbl,source,new List::List(target,*ptr));
  }
  else Hashtable::insert(tbl,source,List::list(target));
}

// Retrieve bounds of previously-appearing non terminal within currently parsing RHS.
// If appears multiple times, only returns one answer.
// If can't be found, return NULL;
$(unsigned int, unsigned int) *
get_bounds(Hashtable::table_t<earley_node_t, list_t<elink_t>,`H> links,
     DFA::edfa_t dfa,
     earley_node_t en, act_t nt){

  let maybe_links = Hashtable::lookup_opt(links,en);
  if (maybe_links == NULL) 
    return NULL;
  else {
    // OPTIMIZATION: we could use a loop instead of recursion if there
    // is only one link.

    // Search all predecessor paths
    for (let xs = *maybe_links; xs; xs = xs->tl) {
      let &elink(pred_link,_,retn_link,_) = xs->hd;

      if (retn_link) {
        let &$(x,i,j) = (_@)retn_link;
        if (DFA_IN_FINAL(dfa,nt,x))
        // found it
        return new $(i,j);
      }

      // keep looking -- recurse.
      let b = get_bounds(links, dfa, pred_link, nt);
      if (b) return b;

    }
  }

  return NULL;
}

//PROB
void add_weights(rstate_t rs, earley_node_t node, weight_t forward, weight_t inner) { //PROB
  let ptr = Hashtable::lookup_opt(rs->weights,node);                            //PROB
  if (ptr != NULL) {                                                            //PROB
    $(weight_t,weight_t)@y = *ptr;                                                    //PROB
    y->f0 = Semiring::add( y->f0, forward );                                    //PROB
    y->f1 = Semiring::add( y->f1, inner );                                      //PROB
  }                                                                             //PROB
  else Hashtable::insert(rs->weights,node,new $(forward,inner));                //PROB

  return;
}                                                                               //PROB


/* Add an item to an Earley state.
   If the item has an automaton state that transitions to another state
   by epsilon, add items for those states too.
   Epsilons may be for CALLS to parse non-terminals or
   RETURNS from parsing non-terminals.
 */
void
push_closure(rstate_t rs,
    unsigned char ? @nozeroterm input,
    unsigned int i,
    earley_item_t ei, // YHM: I think this should be an early node
    // instead of an earley item for
    // efficiency sake (to save allocations).
    earley_node_opt_t back,
    earley_node_opt_t up,
    act_t resp_act // action responsible for transition.
    , weight_t forward, weight_t inner //PROB
) {

  let &$(s,backptr) = ei;
  let node = new $(s,backptr,i);
  add_weights(rs,node,forward,inner); //PROB
  if (back != NULL) {
    point_to(rs->links,node,new elink(back,inner,up, resp_act));
  }

  let es = Axarray::get(rs->estates,i);
  if (Set::member(es,ei)) {
    // TODO: XXX: is it okay to return if the weight has changed???
    return;
  }
  // fprintf(stderr,"estates[%d] += (%d,%d)\n",i,ei->f0,ei->f1);fflush(stderr);
  Axarray::set(rs->estates,i,Set::insert(es,ei));

  /* Close under CALLS. We don't use the weight here. */
  let t = DFA_TRANS(rs->dfa,s,callout_action()); 
  if (t != 0) {
#if defined(NULL_PLAN_B) || defined(NULL_PLAN_C)    
    // Check for RETURN of nullable symbols
    // TODO: do the same for REPEAT calls.
    if (DFA_IS_FINAL(rs->dfa,t)) {
      let final_w = DFA_FINAL_WEIGHT(rs->dfa,t);

      /* For every completed symbol... */
      let ss = DFA_FINAL_ATTRS(rs->dfa,t);
      let n = numelts(ss);
      for (int sym_i=0; sym_i < n; sym_i++) {
        let symb_act = ss[sym_i];

        let starget = DFA_TRANS(rs->dfa,s,symb_act);
        if (starget != 0) {
          // Earley node that completed nullable RHS.
          let causal_node = new $(t,i,i);
          let &$(node_forward,node_inner) = Hashtable::lookup(rs->weights,node); //PROB
          let w_m = mult(inner, final_w);
          push_closure(rs,input,i,new $(starget,backptr),
              node, causal_node, symb_act
              ,mult( w_m, node_forward), //PROB
              mult( w_m, node_inner) //PROB
          );
        }
        
        let ttarget = DFA_TRANS(rs->dfa,t,symb_act);
        if (ttarget != 0) {
          // Earley node that completed nullable RHS.
          let causal_node = new $(t,i,i);
          let &$(node_forward,node_inner) = Hashtable::lookup(rs->weights,node); //PROB
          let w_m = mult(inner, final_w);
          push_closure(rs,input,i,new $(ttarget,i),
              node, causal_node, symb_act
              ,mult( w_m, node_forward), //PROB
              mult( w_m, node_inner) //PROB
          );
        }
      
        // Sanity check:
#ifdef NULL_PLAN_B
        if (ttarget == 0 && starget == 0) {
          fprintf(stderr,"Error: target for %d not found in call source state %d or target state %d.\n",symb_act,s,t);
        } 
#endif
      }
    }
#endif
    
    push_closure(rs,input,i,new $(t,i),NULL,NULL, /* bogus action: */ 0
        ,forward,Semiring::one_weight //PROB
    );
  } /* End, Close under CALLS. */

  /* Close under REPEAT-DECR (special type of CALL). */
  let t = DFA_TRANS(rs->dfa,s,repeat_decr_action());
  if (t != 0) {
    // Lookup and decrement repeat count
    let rc = decr_repeat_count(rs,s);
    // if zero, remove transition on repeat_final and continue.
    if (rc == 0){
      remove_repeat_count(rs,s);
      let t = DFA_TRANS(rs->dfa,s,repeat_final_action());
      /* Call push_closure again as if we started in this
   state. ie. t replaces s. So, we reuse back, up and resp_act. */
      push_closure(rs,input,i,new $(t,backptr),back,up, resp_act
       ,forward,inner //PROB
       );
      return;
    }
    // If non zero, continue as in call
    push_closure(rs,input,i,new $(t,i),NULL,NULL, /* bogus action: */ 0
     ,forward,Semiring::one_weight //PROB
                 );
  }

  /* Close under REPEATS. Only works if target has *one* non-call target. */  
  let t = DFA_TRANS(rs->dfa,s,repeat_action());
  if (t != 0) {
    /* 0. Get the parameters of the repeat: repeater, repeatee, repeatee start state, and 
     *    follow state of the repeat. */
    let $(rpter_act,rptee_act, rptee_start, repeat_follow) = DFA_GET_REPEAT_INFO(rs->dfa,t);
    
    /* 1. Retrieve the number from the Earley graph.*/

    // get the bounds (inclusive) of parsed repeater non-terminal (with action rpter_act) 
    // from the Earley graph.
    let bounds_opt = get_bounds(rs->links, rs->dfa, node,rpter_act);
    if (!bounds_opt){
      fprintf(stderr,"Error: bounds could not be found for non terminal.\n");
      return;
    }
    let &$(j,k) = (_@)bounds_opt;
    let num = atoi(substring(input,j,k-j+1));

    /* 2. Build new DFA using retrieved number. */
    let t_new = DFA_R_EXTEND(rs->dfa, rptee_act,rptee_start,repeat_follow);
    set_repeat_count(rs,t_new,num);

    /* 3. Call push_closure again as if we started in this
       state. ie. t_new replaces s. So, we reuse back, up and resp_act. */
    push_closure(rs,input,i,new $(t_new,backptr),back,up,resp_act
                 ,forward,inner //PROB
                 );
  }

  /* Close under RETURNS.  Use else, because a REPEAT state can't
     also be a final state. */
  else if (
      // TODO: commenting-out the following line is only a short-term solution to dealing with 
      // nullable elements. It is inefficient -- we should look for another way to do
      // this.
#if defined(NULL_PLAN_A) || defined(NULL_PLAN_C)      
       i != backptr && // we parsed the empty string, RETURN handled by dfa already
#endif
       DFA_IS_FINAL(rs->dfa,s)) {
    /* Some symbol is completed.
       es_back is the Earley state that CALLed the symbol. */
    let es_back = Axarray::get(rs->estates,backptr);
    let final_w = DFA_FINAL_WEIGHT(rs->dfa,s);

    /* For every completed symbol... */
    let ss = DFA_FINAL_ATTRS(rs->dfa,s);
    let n = numelts(ss);
    for (int sym_i=0; sym_i < n; sym_i++) {
      let symb_act = ss[sym_i];

      /* ... look at every DFA state in es_back... */
      for (let es_back_list = Set::to_list(es_back);
      es_back_list != NULL;
      es_back_list = es_back_list->tl) {

        let &$(t,tbackptr) = es_back_list->hd;
        let ttarget = DFA_TRANS(rs->dfa,t,symb_act);
        /* ... see if the DFA state did a CALL and RETURN if so. */
        if (ttarget != 0) {
          // Earley node w/ dot before symb.
          let backnode = new $(t,tbackptr,backptr);
          let &$(backnode_forward,backnode_inner) = 
            Hashtable::lookup(rs->weights,backnode); //PROB
          let w_m = mult(inner, final_w);
          push_closure(rs,input,i,new $(ttarget,tbackptr), 
          backnode, node, symb_act
          ,mult( w_m, backnode_forward), //PROB
          mult( w_m, backnode_inner) //PROB
          );
        }
      }
    }
  }
}

using EarleyParsetree;

/**
 * INVARIANT: state of en must be final.
 * */
spf_t
mk_parse_forest(rstate_t rs,
     string_t<`H> top_level_name,
     earley_node_t en,
     act_t resp_act) {
  // map: early_node_t -> parse_tree_t
  let trees = Hashtable::create(11,earley_node_cmp,earley_node_hash);
  
  let &$(x,i,j) = en;

  // Handle case of top-level call, for which there will be no responsible action.
  let completed = DFA_FINAL_ATTRS(rs->dfa,x);
  if (!completed){ // Sanity check
    throw new Core::Invalid_argument(aprintf("State %d is not a final state.",x));
  }
  
  string_t name;
  if (numelts(completed) == 0) {
    // We're in a top-level call ...
    if (top_level_name == NULL)
      throw new Core::Failure(aprintf("Final DFA state encountered unexpectedly in (%d,%d,%d).",x,i,j));
    name = top_level_name;
  }else{
    name = DFA_ACT2SYMB(rs->dfa,resp_act);

    // Sanity check to make sure that responsible action claimed by the
    // caller is indeed an attribute of this state.
    if (debug){
      if (!DFA_IN_FINAL(rs->dfa,resp_act,x)){
        fprintf(stderr,"Symbol %s is not an attribute of state %d.\n",name,x);
      }
    }
  }

  if (debug){
    fprintf(stderr, "Building forest for %s[%d,%d].\n",name,i,j);
  }
  
  /**
   * A list of RHSs-under-construction, which are themselves lists, paired with 
   * the (optional) Earley link that indicates the head of the path (or NULL if the path is complete).
   * So, its a list of of pairs of Earley link and lists. It tracks all the possible 
   * alternative parses of the original nonterminal.
   */
  let live_paths = List::list(new $(Hashtable::lookup_opt(rs->links,en), NULL));

  /**
   * Completed child forests.
   */
  List::list_t<List::list_t<spf_t>> forests = NULL;

  while (live_paths != NULL) {
    // pop first live path;
    let &$(maybe_links, partial_rhs) = live_paths->hd;
    live_paths = live_paths->tl;
    
    if (!maybe_links){
      // The path is complete. Add a forest to forests.
      // let spfs = List::to_array( partial_rhs );
      forests = new List::List(partial_rhs, forests);
    } else {
      // Advance the current live path by one link (possibly resulting in more paths).
      for (let xs = *maybe_links; xs; xs = xs->tl) {
        let &elink(pred_link,w,retn_link,resp_act) = xs->hd;

        // Each link can potentially extend the RHS taken from live_paths above.
        // So, each time around the tloop we use reinitialize it to the original partial_rhs.
        let ext_partial_rhs = partial_rhs;
        if (retn_link) {
          let retn_tree_opt = Hashtable::lookup_opt(trees,retn_link);
          let retn_tree;
          if (!retn_tree_opt){
            retn_tree = mk_parse_forest(rs, NULL, retn_link, resp_act);
            Hashtable::insert(trees,retn_link,retn_tree);
          } else
            retn_tree = *retn_tree_opt;

          // we can build the list backwards because we are starting at the end of 
          // the RHS and traversing pred links towards the beginning.
          ext_partial_rhs = new List::List(retn_tree,
              partial_rhs);
        }
        
        let maybe_links = Hashtable::lookup_opt(rs->links,pred_link);
        live_paths = new List::List( new $(maybe_links, ext_partial_rhs), live_paths );
      }   
    }
  }

  // Invariant: live_paths is NULL, and forests contains all completed RHSs.
  
  // Used later when completing a forest.
  let &$(w_forward,w_inner) = Hashtable::lookup(rs->weights, en);
  return new shared_parse_forest(name,i,j,w_forward, List::to_array( forests ));
}

////////////////////////

/*
 * What different ambiguity resolutions schemes do we want to support and how? Can we support  a mix
 * of static and dynamic schemes? If so, how?
 */
// Next step:
// See how to make choice based on weights.

// Check for ambiguities and resolve as necessary.
static
elink_t resolve_ambs(rstate_t rs, string_t<`H> name, int start, int end, 
      List::list_t<struct elink @`H,`H> links){
  // Check for ambiguities.
  if (links->tl == NULL) 
    // no ambiguities
    return links->hd;
  
//   throw new Core::Invalid_argument(aprintf("Earley graph is ambiguous for symbol <%s> at substring [%d,%d).",name,i,j));
  if (debug){
    fprintf(stderr,
        "Earley graph is ambiguous for symbol %s at substring [%d,%d). "
        "Choosing first derivation.\nPath weights:\n", name,start,end);
    for (let xs = links; xs; xs = xs->tl){
      fprintf(stderr,
          "   %s: %s\n", DFA_ACT2SYMB(rs->dfa,xs->hd->resp_act), Semiring::print_weight(xs->hd->p_weight));      
    }
    fprintf(stderr,"\n");      
  }
  
  return links->hd;
}

// Reconstruct a parse tree. 
parse_tree_t
mk_parse_tree(rstate_t rs,
     string_t<`H> top_level_name,
     earley_node_t en,
     act_t resp_act) {
  // map: early_node_t -> parse_tree_t
  let trees = Hashtable::create(11,earley_node_cmp,earley_node_hash);
  
  let &$(x,i,j) = en;
  
  // Handle case of top-level call, for which there will be no responsible action.
  let completed = DFA_FINAL_ATTRS(rs->dfa,x);
  if (!completed){ // Sanity check
    throw new Core::Invalid_argument(aprintf("State %d is not a final state.",x));
  }
  
  string_t name;
  if (numelts(completed) == 0) {
    // We're in a top-level call ...
    if (top_level_name == NULL)
      throw new Core::Failure(aprintf("Final DFA state encountered unexpectedly in (%d,%d,%d).",x,i,j));
    name = top_level_name;
  }else{
    name = DFA_ACT2SYMB(rs->dfa,resp_act);

    // Sanity check to make sure that responsible action claimed by the
    // caller is indeed an attribute of this state.
    if (debug){
      if (!DFA_IN_FINAL(rs->dfa,resp_act,x)){
        fprintf(stderr,"Symbol %s is not an attribute of state %d.\n",name,x);
      }
    }
  }

  // reconstruct trees of children (i.e. RHS).
  let children_trees = NULL;
  let maybe_links = Hashtable::lookup_opt(rs->links,en);
  while (maybe_links != NULL) {
    let links = *maybe_links;
    let &elink(pred_link, w, retn_link, resp_act) = resolve_ambs(rs, name, i, j, links);

    if (retn_link) {
      let retn_tree_opt = Hashtable::lookup_opt(trees,retn_link);
      let retn_tree;
      if (!retn_tree_opt){
        retn_tree = mk_parse_tree(rs, NULL, retn_link, resp_act);
        Hashtable::insert(trees,retn_link,retn_tree);
      } else
        retn_tree = *retn_tree_opt;

      // we can build the list backwards because we are starting at the end of 
      // the RHS and traversing pred links towards the beginning.
      children_trees = new List::List(retn_tree,
                                   children_trees);
    }
    maybe_links = Hashtable::lookup_opt(rs->links,pred_link);
  }
  
  let &$(w_forward,w_inner) = Hashtable::lookup(rs->weights, en);
  return new parse_tree(name,i,j,w_forward, List::to_array( children_trees ));
}

/////////////////////////////////////////
// Print the earley graph in dot format
///////////////////////////////////////////

static void dot_pred_iter(earley_node_t s, List::list_t<struct elink @`H,`H> ts, rstate_t rs) {
  let &$(si,sj,sk) = s;
  for (; ts; ts = ts->tl) {
    let &$(ti,tj,tk) = ts->hd->pred;
    printf("\"(%d,%d,%d)\" -> ",si,sj,sk);
    printf("\"(%d,%d,%d)\"",ti,tj,tk);
    printf(" [ label = \"%s\" ];\n",DFA_ACT2SYMB(rs->dfa,ts->hd->resp_act));
  }
}

static void dot_retn_iter(earley_node_t s, List::list_t<struct elink @`H,`H> ts, rstate_t rs) {
  let &$(si,sj,sk) = s;
  for (; ts; ts = ts->tl) {
    let r = ts->hd->retn;
    if (r != NULL){
      let $(ti,tj,tk) = *r;
      printf("\"(%d,%d,%d)\" -> ",si,sj,sk);
      printf("\"(%d,%d,%d)\"",ti,tj,tk);
      printf(" [ label = \"%s\" ];\n",DFA_ACT2SYMB(rs->dfa,ts->hd->resp_act));
    }
  }
}

static void rstate_dot(rstate_t rs) {
  printf("digraph g {\n");
  printf("edge [style=dotted]\n");
  Hashtable::iter_c(dot_pred_iter,rs->links,rs);
  printf("edge [style=bold]\n");
  Hashtable::iter_c(dot_retn_iter,rs->links,rs);
//  Hashtable::iter(dot_iter,rs->call);
  printf("}\n");
}

/////////////////////////////////////////////////

$(List::list_t<$(parse_tree_t,Semiring::weight_t)@>,int,int)
ykb_parse(DFA::edfa_t dfa, ykbuf_t@ ykb, int parse_until_eof) {
  /* Keep track of parse trees */
  let
  links = Hashtable::create(11,earley_node_cmp,earley_node_hash);
  let //PROB
  weights = Hashtable::create(11,earley_node_cmp,earley_node_hash); //PROB
  let
  rcounts = Hashtable::create(11,st_cmp,st_hash);

  /* Initialize the sequence of Earley states with s0 */
  let estates = /* Earley states  s0, s1, s2, ... */
  Axarray::create(11,Set::empty(earley_item_cmp));
  let earley_item_0 = new $(DFA_GET_START(dfa),0); //  0 is i in si
  let rs = new rstate {
    dfa,
    estates,links
    ,weights //PROB
    ,rcounts
  };
  
  // Save the input from the beginning so that we have access to it later.
  let input_save = YKSAVE;
  
  push_closure(rs,
      ykb->save + input_save,
      0,
      earley_item_0,
      NULL,NULL, /* bogus action: */ 0
      ,Semiring::one_weight,Semiring::one_weight //PROB
  );
  
  let t = DFA_GET_START(dfa);
  let i = 0;
#if defined(NULL_PLAN_B) || defined(NULL_PLAN_C)    
  /* Check for RETURN of nullable symbols */
  if (DFA_IS_FINAL(rs->dfa,t)) {
    let final_w = DFA_FINAL_WEIGHT(rs->dfa,t);

    /* For every completed symbol... */
    let ss = DFA_FINAL_ATTRS(rs->dfa,t);
    let n = numelts(ss);
    for (int sym_i=0; sym_i < n; sym_i++) {
      let symb_act = ss[sym_i];

      let ttarget = DFA_TRANS(rs->dfa,t,symb_act);
      if (ttarget != 0) {
        // Earley node that completed nullable RHS.
        let causal_node = new $(t,i,i);
        let w_m = final_w;
        push_closure(rs,ykb->save + input_save,i,new $(ttarget,i),
            causal_node, causal_node, symb_act
            ,w_m, w_m //PROB
        );
      } 
#ifdef NULL_PLAN_C
      else {// Sanity check:
        fprintf(stderr,"Error: target for %d not found in initial state.\n",symb_act);
      } 
#endif
    }
  }
#endif

  int hit_final = 0;
  let no_error = 1;

  if (!parse_until_eof){
    // Check to see whether we've reached a final state
    for (let si_list = Set::to_list(Axarray::get(estates,i));
        si_list != NULL;
        si_list = si_list->tl) {

      let &$(state,parent) = si_list->hd;
      if (parent == 0 && DFA_IS_DFA_FINAL(dfa,state)){
          hit_final = 1;
          break;
      }
    }
  }
  
  if (!hit_final) {
    /* Scan the input */
    YKFILL(1); // Make sure we have at least one element in the buffer.
    int c = *YKCURSOR; 

    
    for (; no_error && !(*YKCURSOR == 0 && ykb->eof); i++) {
      //YKCURSOR++; forgetting to set c results in bus error. Why?
      c = *YKCURSOR++; // consume current element.

      // reset for this round.
      // will be set to one if there is at least one transition on 
      // input character c.
      no_error = 0;
      
      // Process character c. 
      //fprintf(stderr,"input[%d]==%s\n",i,cs_char_escape(c));fflush(stderr);
      for (let si_list = Set::to_list(Axarray::get(estates,i));
          si_list != NULL;
          si_list = si_list->tl) {
  
        let &$(state,parent) = si_list->hd;
        //fprintf(stderr,"Considering (%d,%d) for %c. ",state,parent,input[i]);
        let $(k,w) = DFA_TRANS_W(dfa,state,c); //PROB
        //fprintf(stderr,"k = %d.\n",k);
        if (k != 0) {// where k==0 indicates there is no valid target.
          no_error = 1;
          let enode = new $(state,parent,i);
          let &$(forward,inner) = Hashtable::lookup(rs->weights,enode);
          push_closure(rs,ykb->save + input_save,i+1,new $(k,parent),enode,NULL, c
              ,Semiring::mult(w, forward), Semiring::mult(w, inner) //PROB
          );
        }
      }
      
      if (!parse_until_eof){
        // Check whether we've reached a final state
        hit_final = 0;
        for (let si_list = Set::to_list(Axarray::get(estates,i+1));
            si_list != NULL;
            si_list = si_list->tl) {
    
          let &$(state,parent) = si_list->hd;
          if (parent == 0 && DFA_IS_DFA_FINAL(dfa,state)){
              hit_final = 1;
              break;
          }
        }
        if (hit_final) {
          // We're done parsing, so break out of the loop. Increment i, though, to record advance to next input element.
          i++;
          break;
        }
      }
      if ((YKLIMIT - YKCURSOR) < 1) YKFILL(1);
    }
  }
  
  if (no_error){
    if (debug)
      fprintf(stderr, "No parse errors detected. Searching for final states at position %d.\n", i);
    //rstate_dot(rs);
  } else {
    if (debug)
      fprintf(stderr, "Parse error at input character %d.\n",i-1);
    YKCURSOR = YKRESTORE(input_save);
    return $(NULL,0,0);
  }

  /* See if we ended up in a final state */
  let partial_parses = 0;
  let complete_parses = 0;
  let trees = NULL;
  for (let slast_list = Set::to_list(Axarray::get(estates,i));
      slast_list != NULL;
      slast_list = slast_list->tl) {
    partial_parses++;
    let &$(state,parent) = slast_list->hd;
    if (DFA_IS_DFA_FINAL(dfa,state) && parent == 0) {
      complete_parses++;

        if (do_reconstruct) {
          let en = new $(state,parent /*== 0*/,i);
          try{
            if (debug){
              print_forest(mk_parse_forest(rs,"TOP LEVEL",en, /* bogus action: */ 0),"");
            }
            let &$(w_forward,w_inner) = Hashtable::lookup(rs->weights, en);
            let derivation_tree = mk_parse_tree(rs,"TOP LEVEL",en, /* bogus action: */ 0);
            trees = new List::List(new $(derivation_tree,w_forward),trees);
          } catch {
            case &Core::Invalid_argument(msg):
              fprintf(stderr,"Ambiguous tree at early node (%d,0,%d):\n\t%s\n",state,i,msg);
            break;  
          }
        }
    }
  }

  YKRESTORE(input_save); // commit: don't set YKCURSOR, because we don't want to rewind the input.
                         // the purpose of the save was only to prevent discarding.
  
  return $(trees,complete_parses,partial_parses);  
}

$(List::list_t<$(parse_tree_t,Semiring::weight_t)@>,int,int) 
parse(DFA::edfa_t dfa, const char? input) {
  let ykinput = string2ykbuf(input);
  return ykb_parse(dfa, ykinput,1);
}
