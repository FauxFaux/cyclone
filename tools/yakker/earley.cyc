/* (So far incomplete) Earley parser */

#include <buffer.h>
#include <string.h>
#include <core.h>
#include <list.h>
#include <graph.h>
#include "bnf.h"
#include "fa.h"
#include "axarray.h"
#include "cs.h"
#include "analyze.h"

#include "nfa_eager.h"
using Nfa_eager;

namespace Earley;

typedef List::list_t<datatype ParseTree @`H,`H> parse_forest_t;
typedef List::List_t<datatype ParseTree @`H,`H> Parse_forest_t;

typedef datatype ParseTree @`H parse_tree_t;

datatype ParseTree{
  NonTerm(const char ?`H, int, int, parse_forest_t);
  SharedNonTerm(const char ?`H, int, int, List::List_t<parse_forest_t,`H>);
};

void print_LD_parse_forest(parse_forest_t pf);

void print_LD(datatype ParseTree @pt){
  switch (pt) {
  case &NonTerm(name,l,r,children):
    printf("<t s=\"%s\" l=\"%d\" r=\"%d\">",name,l,r);
    print_LD_parse_forest(children);
    printf("</t>");
    break;
  case &SharedNonTerm(name,l,r,children_list):
    printf("<t s=\"%s\" l=\"%d\" r=\"%d\">",name,l,r);
    print_LD_parse_forest(children_list->hd);
    printf("</t>");
    break;
  }
}

void print_LD_parse_forest(parse_forest_t pf){
  List::iter(print_LD,pf);
}

void print_RD_parse_forest(parse_forest_t pf);

`a reflect(`a last_seen,`a current){return current;}

void print_RD(datatype ParseTree @pt){
  switch (pt) {
  case &NonTerm(name,l,r,children):
    printf("<t s=\"%s\" l=\"%d\" r=\"%d\">",name,l,r);
    print_RD_parse_forest(children);
    printf("</t>");
    break;
  case &SharedNonTerm(name,l,r,children_list):
    printf("<t s=\"%s\" l=\"%d\" r=\"%d\">",name,l,r);
    let last_derivation = List::fold_left(reflect,children_list->hd,children_list);
    print_RD_parse_forest(last_derivation);
    printf("</t>");
    break;
  }
}

void print_RD_parse_forest(parse_forest_t pf){
  List::iter(print_RD,pf);
}

void print_parse_forest(parse_forest_t pf);

void print_parse_tree(datatype ParseTree @pt){
  switch (pt) {
  case &NonTerm(name,l,r,children):
    printf("<t s=\"%s\" l=\"%d\" r=\"%d\">",name,l,r);
    print_parse_forest(children);
    printf("</t>");
    break;
  default:
    fprintf(stderr,"Ambiguous parse tree!\n");
    break;
  }
}

void print_parse_forest(parse_forest_t pf){
  List::iter(print_parse_tree,pf);
}


/* The alphabet of the automaton is the set of terminals and
   non-terminals.  Assume for now that cs_t can represent a set of
   terminals and non-terminals.  Number our new actions starting
   at 256.

   NB: there is a max number of actions hard-coded in cs.h.
*/

static unsigned int symb_action_counter = 257;
static struct Hashtable::Table<str_t,act_t> *symb_action_table = NULL;
static struct Hashtable::Table<act_t,str_t> *action_symb_table = NULL;
static act_t callout_action() {
  return 256;
}
static act_t new_action() {
  let a = symb_action_counter++;
  if (a > MAXACTION) {
    fprintf(stderr,"Internal error: maximum number of actions exceeded\n");
    fflush(stderr);
    exit(1);
  }
  return a;
}
static cs_t callout_cs() {
  return cs_singleton(callout_action());
}
const char ?act2symb(act_t act) {
  let sopt = Hashtable::lookup_opt(action_symb_table,act);
  if (sopt == NULL || *sopt == NULL) return NULL;
  else return **sopt;
}
static act_t symb2act(const char ?`H symb) {
  if (symb_action_table == NULL)
    symb_action_table =
      Hashtable::create(11,strptrcmp,Hashtable::hash_stringptr);
  if (action_symb_table == NULL) {
    action_symb_table =
      Hashtable::create(11,st_cmp,st_hash);
    Hashtable::insert(action_symb_table,callout_action(),new "CALL");
  }
  let symbptr = new symb;
  let aptr = Hashtable::lookup_opt(symb_action_table,symbptr);
  if (aptr != NULL) return *aptr;
  let a = new_action();
  fprintf(stderr,"Symbol %s has action 0x%x\n",symb,a);
  Hashtable::insert((_@)symb_action_table,symbptr,a);
  Hashtable::insert((_@)action_symb_table,a,symbptr);
  return a;
}
static cs_t consume_symb_cs(const char ?`H symb) {
  return cs_singleton(symb2act(symb));
}

/* An automaton state and parent pointer */
typedef $(st_t,unsigned int) @earley_item_t;

static int earley_item_cmp(earley_item_t a,earley_item_t b) {
  let $(ai,aj) = *a;
  let $(bi,bj) = *b;
  let c = Core::intcmp(ai,bi);
  if (c) return c;
  return Core::intcmp(aj,bj);
}

typedef $(st_t,unsigned int,unsigned int) @earley_node_t;
typedef $(st_t,unsigned int,unsigned int) *earley_node_opt_t;
typedef  Hashtable::table_t<earley_item_t,List::list_t<earley_node_t,`r>,`r> earley_graph_t<`r>;
static int earley_node_cmp(earley_node_t a,earley_node_t b) {
  let $(ai,aj,ak) = *a;
  let $(bi,bj,bk) = *b;
  let c = Core::intcmp(ai,bi);
  if (c) return c;
  c = Core::intcmp(aj,bj);
  if (c) return c;
  return Core::intcmp(ak,bk);
}
static void earley_node_pr(FILE @f,earley_node_t a) {
  let $(ai,aj,ak) = *a;
  fprintf(f,"(%d,%d,%d)",ai,aj,ak);
}

static int earley_node_hash(earley_node_t a) {
  let $(ai,aj,ak) = *a;
  /* All ai, aj, and ak are ints starting at 0, ai maxes out at the
     number of states, aj and ak max out at the input length.
     TODO: see what typical sizes are for these and adjust the
     hash function accordingly.
  */
  return ai ^ (aj+ak);
}

typedef Set::set_t<earley_item_t> earley_state_t;

/* Create the control NFA for Earley parsing.
   The rule specifies what to parse.
   Symbols from the grammar will be used if needed, otherwise ignored.
   The symb_st table maps used symbols to states and should be
   initialized to the empty table.
   On return the table will hold mappings for all symbols encountered.
   */
$(st_t,st_t,st_t)
  merge(Hashtable::table_t<str_t,st_t> symb_st,
        grammar_t grm,
        rule_t r);

st_t rule2earley0(Hashtable::table_t<str_t,st_t> symb_st,
                  grammar_t grm,
                  rule_t r) {
  switch (r->r) {
  case &Symb(x,_):
    let xptr = new x;
    st_t x_start; /* start state of the NFA for the symbol */
    if (!Hashtable::try_lookup(symb_st,xptr,&x_start)) {
      /* Symbol has not been converted to NFA yet */
      Rule_t x_rule = lookup_symbol(grm, x);
      if (!x_rule) {
	warn("missing definition for %s in rule2earley()\n",x);
	return mklit("");
      }
      /* Allocate a start state for the symbol.  Do this before
         converting to NFA in case the symbol is defined recursively. */
      let s = nfa_fresh_state(); let f = nfa_fresh_state(); final(s,f);
      Hashtable::insert(symb_st,xptr,s);
      let $(s_body,f_body,_) = merge(symb_st,grm,x_rule);
      final(s,f_body); // merge does not do this
      etrans(s,s_body);
      x_start = s;
    }
    let s = nfa_fresh_state();
    let s2 = nfa_fresh_state();
    let f = nfa_fresh_state(); final(s,f);
    action(s,callout_cs(),x_start);
    etrans(s,s2);
    action(s2,consume_symb_cs(x),f);
    /* If the symbol can derive the empty string make sure this gets
       reflected into the automaton --- effectively doing a RETURN in
       the automaton instead of the Earley evaluator itself */
    if (empty_rule(SYMB(x)))
      etrans(s2,f);
    return s;
  case &Lit(x):
    return mklit(x);
  case &CharRange(low,high):
    if (low > high) {
      internal_err("invalid character range in rule2earley()\n");
      return mklit("");
    }
    return mkact(cs_range(low,high+1));
  case &Opt(r2):
    let s2 = rule2earley0(symb_st,grm,r2); let s3 = mklit("");
    return mkalt(s2,s3);
  case &Seq(r2,r3):
    let s2 = rule2earley0(symb_st,grm,r2); let s3 = rule2earley0(symb_st,grm,r3);
    return mkseq(s2,s3);
  case &Alt(r2,r3):
    let s2 = rule2earley0(symb_st,grm,r2); let s3 = rule2earley0(symb_st,grm,r3);
    return mkalt(s2,s3);
  case &Rcount(_,r2):
    /* Conservative approximation */
    warn_repeat();
    fallthru(r2);
  case &Star(0,&Infinity,r2):
    let s2 = rule2earley0(symb_st,grm,r2);
    return mkstar(s2);
  case &Star(m,i as &Infinity,r2):
    let r_seq = SEQ(r2,STAR(m-1,i,r2));
    return rule2earley0(symb_st,grm,r_seq);
  case &Star(0,&Num(0),r2):
    return mklit("");

  case &Star(0,&Num(n),r2):
    let r_opt = OPT(SEQ(r2,STAR(0, new Num(n-1),r2)));
    return rule2earley0(symb_st,grm,r_opt);
  case &Star(m,&Num(n),r2):
    if (m > n) return mklit("");
    let r_seq = SEQ(r2,STAR(m-1, new Num(n-1),r2));
    return rule2earley0(symb_st,grm, r_seq);

  case &Hash(0,N,r2):
    // same as [ r2 *{N-1}(commas r2) ]
    return rule2earley0(symb_st,grm,
                        OPT(SEQ(r2,STAR(0,minus_one(N),SEQ(commas(),r2)))));
  case &Hash(m,N,r2):
    // same as r2 {m-1}*{N-1}(commas r2)
    return rule2earley0(symb_st,grm,
                        SEQ(r2,STAR(m-1,minus_one(N),SEQ(commas(),r2))));
  case &Prose(_):
    warn("Prose not supported in rule2earley()\n");
    return mklit("");
  case &Minus(_,_):
    warn("Minus not supported in rule2earley()\n");
    return mklit("");
  }
}

$(st_t,st_t,st_t)
  merge(Hashtable::table_t<str_t,st_t> symb_st,
        grammar_t grm,
        rule_t r) {
  switch (r->r) {
  case &Symb(x,_):
    let xptr = new x;
    st_t x_start; /* start state of the NFA for the symbol */
    if (!Hashtable::try_lookup(symb_st,xptr,&x_start)) {
      /* Symbol has not been converted to NFA yet */
      Rule_t x_rule = lookup_symbol(grm, x);
      if (!x_rule) {
	warn("missing definition for %s in merge()\n",x);
	return merge(symb_st,grm,LIT(""));
      }
      /* Allocate a start state for the symbol.  Do this before
         converting to NFA in case the symbol is defined recursively. */
      let s = nfa_fresh_state(); let f = nfa_fresh_state();
      Hashtable::insert(symb_st,xptr,s);
      let $(s_body,f_body,_) = merge(symb_st,grm,x_rule);
      // need e_body too???
      final(s,f_body); // merge does not do this
      etrans(s,s_body);
      x_start = s;
    }
    let s = nfa_fresh_state();
    let s2 = nfa_fresh_state();
    let e = nfa_fresh_state();
    let f = nfa_fresh_state();
    action(s,EPSILON,x_start);
    etrans(s,s2);
    action(s2,consume_symb_cs(x),f);
    /* If the symbol can derive the empty string make sure this gets
       reflected into the automaton --- effectively doing a RETURN in
       the automaton instead of the Earley evaluator itself */
    if (empty_rule(SYMB(x)))
      etrans(s2,e);
    return $(s,f,e);
  case &Lit(x):
    if (!strcmp(x,"")) {
      let s = nfa_fresh_state();
      let f = nfa_fresh_state();
      let e = nfa_fresh_state();
      etrans(s,e);
      return $(s,f,e);
    }
    else {
      let s = mklit(x);
      let f = get_final(s);
      let e = nfa_fresh_state();
      return $(s,f,e);
    }
  case &CharRange(low,high):
    if (low > high) {
      internal_err("invalid character range in merge()\n");
      let s = nfa_fresh_state();
      let f = nfa_fresh_state();
      return $(s,f,s);
    }
    else {
      let s = mkact(cs_range(low,high+1));
      let f = get_final(s);
      let e = nfa_fresh_state();
      return $(s,f,e);
    }
  case &Opt(r2):
    let s = nfa_fresh_state();
    let e = nfa_fresh_state();
    let $(s2,f2,e2) = merge(symb_st,grm,r2);
    etrans(s,s2);
    action(s,EPSILON,e);
    etrans(e2,e);
    return $(s,f2,e);
  case &Seq(r2,r3):
    let s = nfa_fresh_state();
    let f = nfa_fresh_state();
    let e = nfa_fresh_state();
    let $(s2,f2,e2) = merge(symb_st,grm,r2);
    let $(s3,f3,e3) = merge(symb_st,grm,r3);
    let scall = rule2earley0(symb_st,grm,r3);
    let fcall = get_final(scall);
    etrans(s,s2);
    etrans(f2,scall);
    etrans(e2,s3);
    etrans(f3,f);
    etrans(fcall,f);
    etrans(e3,e);
    return $(s,f,e);
  case &Alt(r2,r3):
    let s = nfa_fresh_state();
    let f = nfa_fresh_state();
    let e = nfa_fresh_state();
    let $(s2,f2,e2) = merge(symb_st,grm,r2);
    let $(s3,f3,e3) = merge(symb_st,grm,r3);
    etrans(s,s2);
    action(s,EPSILON,s3);
    etrans(f2,f);
    etrans(f3,f);
    etrans(e2,e);
    etrans(e3,e);
    return $(s,f,e);
  case &Rcount(_,r2):
    /* Conservative approximation */
    warn_repeat();
    fallthru(r2);
  case &Star(0,&Infinity,r2):
    let s = nfa_fresh_state();
    let f = nfa_fresh_state();
    let e = nfa_fresh_state();
    let $(s2,f2,e2) = merge(symb_st,grm,r2);
    let scall = rule2earley0(symb_st,grm,r2);
    let fcall = get_final(scall);
    etrans(s,s2);
    action(s,EPSILON,e);
    etrans(e2,s2);
    action(e2,EPSILON,e);
    etrans(f2,scall);
    action(f2,EPSILON,f);
    etrans(fcall,scall);
    action(fcall,EPSILON,f);
    return $(s,f,e);
  case &Star(m,i as &Infinity,r2):
    let r_seq = SEQ(r2,STAR(m-1,i,r2));
    return merge(symb_st,grm,r_seq);
  case &Star(0,&Num(0),r2):
    return merge(symb_st,grm,LIT(""));
  case &Star(0,&Num(n),r2):
    let r_opt = OPT(SEQ(r2,STAR(0, new Num(n-1),r2)));
    return merge(symb_st,grm,r_opt);
  case &Star(m,&Num(n),r2):
    if (m > n) return merge(symb_st,grm,LIT(""));
    let r_seq = SEQ(r2,STAR(m-1, new Num(n-1),r2));
    return merge(symb_st,grm, r_seq);

  case &Hash(0,N,r2):
    // same as [ r2 *{N-1}(commas r2) ]
    return merge(symb_st,grm,
                 OPT(SEQ(r2,STAR(0,minus_one(N),SEQ(commas(),r2)))));
  case &Hash(m,N,r2):
    // same as r2 {m-1}*{N-1}(commas r2)
    return merge(symb_st,grm,
                 SEQ(r2,STAR(m-1,minus_one(N),SEQ(commas(),r2))));
  case &Prose(_):
    warn("Prose not supported in merge()\n");
    return merge(symb_st,grm,LIT(""));
  case &Minus(_,_):
    warn("Minus not supported in merge()\n");
    return merge(symb_st,grm,LIT(""));
  }
}

$(dfa_t,Set::set_t<st_t>) rule2earley(grammar_t grm, rule_t r) {
  /* Build the NFA for the grammar */

  /* symb_st maps symbols to start states */
  Hashtable::table_t<str_t,st_t> symb_st =
    Hashtable::create(101,strptrcmp,Hashtable::hash_stringptr);

  nfa_init(grm);
  let $(start_state,f,e) = merge(symb_st,grm,r);
  let final_state = nfa_fresh_state();
  etrans(f,final_state);
  etrans(e,final_state);
  final(start_state,final_state);
  fprintf(stderr,"Start state is %d, final state is %d\n",start_state,final_state);
  if (debug)
    nfa_dot(stderr,Set::singleton(st_cmp,final_state),act2symb);

  /* Collect the set of final states for symbols... */
  let symb_final_states = Set::empty(st_cmp);
  /* ... and the mapping from symbol actions to symbols */
  let act_table = Hashtable::create(11,st_cmp,st_hash); // should be act_cmp
  for (let rules = grm; rules != NULL; rules = rules->tl) {
    let &$(symb,_,_) = rules->hd;
    let st_opt = Hashtable::lookup_opt(symb_st,new symb);
    if (!st_opt) continue;
    let symb_final = get_final(*st_opt);
    symb_final_states = Set::insert(symb_final_states,symb_final);
    Hashtable::insert(act_table,
                      symb_final,
                      symb2act(symb));
  }

  /* Convert to DFA */
  let dfa = nfa2dfa(start_state,
                    Set::insert(symb_final_states,final_state));
  dfa = dfa_minimize(dfa);

  /* We want an automata with final attributes that indicate which
     symbol has been completed, but our NFAs do not have final
     attributes.  The nfa2dfa conversion creates a DFA whose final
     states have as attributes the corresponding NFA final states.
     Therefore we can post-process the DFA to map these attributes to
     indicate the symbol (as indicated by symb2act()).

     We also record in dfa_final the subset of final states that
     correspond to the full RHS that is being parsed, as distinguished
     from the final states that indicate parsing of symbols.
  */
  let dfa_final = Set::empty(st_cmp);
  for (let states = Set::to_list(dfa_final_states(dfa));
       states != NULL; states = states->tl) {
    let s = states->hd;
    let action_attrs = Set::empty(st_cmp); // should be attr_cmp
    for (let s_attrs = Set::to_list(dfa_final_attrs(dfa,s));
         s_attrs != NULL; s_attrs = s_attrs->tl) {
      let a = s_attrs->hd;
      if (a == final_state) {
        dfa_final = Set::insert(dfa_final,s);
        // final_state of the original rule r does not correspond to
        // the parsing of a symbol hence does not return.  So we do not
        // want it in the attributes which indicate what symbols are
        // returning.
        continue;
      }
      let act = Hashtable::lookup(act_table,a);
      action_attrs = Set::insert(action_attrs,act);
    }
    dfa_set_final(dfa,s,action_attrs);
  }
  return $(dfa,dfa_final);
}

struct rstate {
  dfa_t dfa;
  Axarray::xarray_t<earley_state_t> estates;
  Hashtable::table_t<earley_node_t,List::list_t<earley_node_t,`H>,`H> pred;
  Hashtable::table_t<earley_node_t,List::list_t<$(earley_node_opt_t,earley_node_t) @`H,`H>,`H> retn;
  Hashtable::table_t<earley_node_t,List::list_t<earley_node_t,`H>,`H> call;
};
typedef struct rstate @rstate_t;

static void dot_iter(earley_node_t s,List::list_t<earley_node_t> ts) {
  let &$(si,sj,sk) = s;
  for (; ts; ts = ts->tl) {
    let &$(ti,tj,tk) = ts->hd;
    printf("\"(%d,%d,%d)\" -> ",si,sj,sk);
    printf("\"(%d,%d,%d)\";\n",ti,tj,tk);
  }
}

static void dot_pred_iter(earley_node_t s,List::list_t<$(earley_node_opt_t,earley_node_t) @`H> ts) {
  let &$(si,sj,sk) = s;
  for (; ts; ts = ts->tl) {
    let &$(_,p) = ts->hd; // only bind pred edge.
    let &$(ti,tj,tk) = p;
    printf("\"(%d,%d,%d)\" -> ",si,sj,sk);
    printf("\"(%d,%d,%d)\";\n",ti,tj,tk);
  }
}

static void dot_retn_iter(earley_node_t s,List::list_t<$(earley_node_opt_t,earley_node_t) @`H> ts) {
  let &$(si,sj,sk) = s;
  for (; ts; ts = ts->tl) {
    let &$(r,_) = ts->hd; // only bind retn edge, not pred edge.
    if (r != NULL){
      let &$(ti,tj,tk) = r;
      printf("\"(%d,%d,%d)\" -> ",si,sj,sk);
      printf("\"(%d,%d,%d)\";\n",ti,tj,tk);
    }
  }
}

static void rstate_dot(rstate_t rs) {
  printf("digraph g {\n");
//   Hashtable::iter(dot_pred_iter,rs->pred);
  Hashtable::iter(dot_pred_iter,rs->retn);
  printf("edge [style=bold]\n");
  Hashtable::iter(dot_retn_iter,rs->retn);
  printf("edge [style=dotted]\n");
  Hashtable::iter(dot_iter,rs->call);
  printf("}\n");
}

void point_to(Hashtable::table_t<earley_node_t,List::list_t<`a,`H>,`H> tbl,
              earley_node_t source,
              `a target) {

  let ptr = Hashtable::lookup_opt(tbl,source);
  if (ptr != NULL) {
    Hashtable::remove(tbl,source);
    Hashtable::insert(tbl,source,new List::List(target,*ptr));
  }
  else Hashtable::insert(tbl,source,List::list(target));
}

/* Add an item to an Earley state.
   If the item has an automaton state that transitions to another state
   by epsilon, add items for those states too.
   Epsilons may be for CALLS to parse non-terminals or
   RETURNS from parsing non-terminals.
 */
void
push_closure(rstate_t rs,
             unsigned int i,
             earley_item_t ei, // YHM: I think this should be an early node
			       // instead of an earley item for
			       // efficiency sake (to save allocations).
             const char ?reason,
             earley_node_opt_t back,
	     earley_node_opt_t up) {

  let &$(s,backptr) = ei;
  let node = new $(s,backptr,i);
  if (back != NULL) {
    point_to(rs->pred,node,back);
    point_to(rs->retn,node,new $(up,back));
  }

  let es = Axarray::get(rs->estates,i);
  if (Set::member(es,ei)) return;
  fprintf(stderr,"estates[%d] += (%d,%d) %s\n",i,ei->f0,ei->f1,reason);fflush(stderr);
  Axarray::set(rs->estates,i,Set::insert(es,ei));

  /* Close under CALLS */
  let t = target(rs->dfa,s,callout_action());
  if (t != 0) {
    point_to(rs->call,new $(t,i,i),node);
    push_closure(rs,i,new $(t,i),"(call)",NULL,NULL);
  }

  /* Close under RETURNS */
  if (i != backptr // we parsed the empty string, RETURN handled by dfa already
      && dfa_is_final(rs->dfa,s)) {
    /* Some symbol is completed.
       es_back is the Earley state that CALLed the symbol. */
    let es_back = Axarray::get(rs->estates,backptr);

    /* For every completed symbol... */
    for (let completed = Set::to_list(dfa_final_attrs(rs->dfa,s));
         completed != NULL; completed = completed->tl) {
      let symb = completed->hd;

      /* ... look at every DFA state in es_back... */
      for (let es_back_list = Set::to_list(es_back);
           es_back_list != NULL;
           es_back_list = es_back_list->tl) {

        let &$(t,tbackptr) = es_back_list->hd;
        let ttarget = target(rs->dfa,t,symb);
        /* ... see if the DFA state did a CALL and RETURN if so. */
        if (ttarget != 0) {
	  // Earley node w/ dot before symb.
	  let backnode = new $(t,tbackptr,backptr);
	  // Earley node w/ dot after symb.
          let retnode = new $(ttarget,tbackptr,i);
          push_closure(rs,i,new $(ttarget,tbackptr),
                       aprintf("(return %s)",act2symb(symb)),
                       backnode, node);
        }
      }
    }
  }
}

//
// function : derivation
// returns  : 1 if ambiguous, 0 otherwise
//
struct Buffer::t *b = NULL;

// int derivation(Hashtable::table_t<earley_node_t,List::list_t<earley_node_t>,`H> pred,
//                Hashtable::table_t<earley_node_t,List::list_t<$(earley_node_t,earley_node_t) @`H>,`H> retn,
//                earley_node_t ei,
//                const char ?input,
//                dfa_t dfa) {

//   let retcode = 0;
//   let maybe_retn = Hashtable::lookup_opt(retn,ei);
//   if (maybe_retn != NULL) {
//     let len = List::length(*maybe_retn);
//     if (len > 1){
//       retcode = 1;
//       fprintf(stderr,"Ambiguous parse, (%d,%d,%d) has multiple RETURNs\n",
//               ei->f0,ei->f1,ei->f2);
//       for (let bf = *maybe_retn; bf; bf = bf->tl) {
//         fprintf(stderr,"(%d,%d,%d)\n",bf->hd->f0->f0,bf->hd->f0->f1,bf->hd->f0->f2);
//       }
//       fflush(stderr);
//     } 
//     // only print one derivation even if > 1
//     if (len > 0) {
//       let l = Buffer::length(b);
//       if (l > 0) {
//         // DOESN'T WORK -- CYCLONE BUG        
// //        let z = Buffer::extract(b);
// //        char maybe_brace = z[l-1];
// //        Buffer::restore(b,z);
//         // INEFFICIENT WORKAROUND
//         let z = Buffer::contents(b);
//         char maybe_brace = z[l-1];
//         if (maybe_brace == '}')
//           Buffer::add_string(b,",");
//       }
//       let &$(x,i,j) = (*maybe_retn)->hd->f0;
//       // x is state, parse started at i, finished at j
//       let completed = Set::to_list(dfa_final_attrs(dfa,x));
//       if (completed != NULL) {
// 	// YHM: why don't we warn/report whether completed has more than one element?
//         let attr = completed->hd;
//         Buffer::add_string(b,
//                            aprintf("<t s=\"%s\" l=\"%d\" r=\"%d\">",
//                                    act2symb(attr),i,j));
//       }
//       else
//         // should never happen
//         Buffer::add_string(b,
//                            aprintf("<t s=\"???\" l=\"%d\" r=\"%d\">",
//                                    i,j));
//       //        printf(" <- ??? [%d,%d]\n",i,j);

//       let rc = derivation(pred,retn,(*maybe_retn)->hd->f0,input,dfa);
//       retcode = retcode || rc;
//       Buffer::add_string(b,"</t>");
//     }
//   }

//   let before_opt = Hashtable::lookup_opt(pred,ei);
//   // YHM: why return here?
//   if (before_opt == NULL) return retcode;

//   let before = *before_opt;
//   let len = List::length(before);

//   if (len > 1) {
//     retcode = 1;
//     fprintf(stderr,"Ambiguous parse, (%d,%d,%d) has multiple predecessors\n",
//             ei->f0,ei->f1,ei->f2);
    
//     for (let bf = before; bf; bf = bf->tl) {
//       fprintf(stderr,"(%d,%d,%d)\n",bf->hd->f0,bf->hd->f1,bf->hd->f2);
//     }
//     fflush(stderr);
//   }
//   if (len > 0) {
//     //    fprintf(stderr,"following (%d,%d,%d)\n",before->hd->f0,before->hd->f1,before->hd->f2);
//     // YHM: nearly a tail call.
//     let rc = derivation(pred,retn,before->hd,input,dfa);
//     retcode = retcode || rc;
//   }

//   // YHM: Dead code?
//   if (maybe_retn == NULL) {
//     // did not get here by RETURN, so we read a terminal, print it
//     let i = ei->f2;
//     //    printf("%c",input[i-1]);
//   }
//   else {
//     // got here by a RETURN, therefore we just parsed a nonterminal, print it
//     let &$(x,i,j) = (*maybe_retn)->hd;
//     // x is state, parse started at i, finished at j
//     let completed = Set::to_list(dfa_final_attrs(dfa,x));
//     if (completed != NULL) {
//       let attr = completed->hd;
//       //      printf(" %s ",act2symb(attr));
//     }
//     else
//       // should never happen
//       0;
//       //      printf(" ??? ");
//   }
//   // YHM: End ead code.

//   return retcode;
// }

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// YHM: (current) invariant: always called with final state in early item ei.

parse_tree_t
derivation_redux(Hashtable::table_t<earley_node_t,List::list_t<earley_node_t>,`H> pred,
		 Hashtable::table_t<earley_node_t,List::list_t<$(earley_node_opt_t,earley_node_t) @`H>,`H> retn,
		 const char ?input,
		 dfa_t dfa,
		 earley_node_t ei);

// List::List_t<parse_forest_t> prefix_all(parse_tree_t,List::List_t<parse_forest_t>);
// imperative update of fs.
void prefix_all_imp(parse_tree_t t,List::list_t<parse_forest_t> fs){
  for (;fs;fs = fs->tl){
    fs->hd = new List::List(t,fs->hd);
  }
}

List::list_t<parse_forest_t>
derivation_horizontal(Hashtable::table_t<earley_node_t,List::list_t<earley_node_t>,`H> pred,
		      Hashtable::table_t<earley_node_t,List::list_t<$(earley_node_opt_t,earley_node_t) @`H>,`H> retn,
		      const char ?input,
		      dfa_t dfa,
		      earley_node_t ei){

  List::list_t<parse_forest_t> derivations = NULL;
  let maybe_links = Hashtable::lookup_opt(retn,ei);
  if (maybe_links != NULL) {

    // Compute all derivations.
    for (let xs = *maybe_links; xs; xs = xs->tl) {
      let &$(retn_link,pred_link) = xs->hd;
      
      let pred_derivations = derivation_horizontal(pred,retn,input,dfa, 
						   pred_link);
      if (retn_link){
	let child_tree = derivation_redux(pred,retn,input,dfa,
					  retn_link);
	// prefix all forests of pred_derivations with child_tree.
	prefix_all_imp(child_tree,pred_derivations);
      } 

      derivations = List::append(derivations,pred_derivations);
    }
      
  }else
    // A single, empty derivation.
    derivations = List::list(NULL);

    
  //////////// Debug Code ///////////
//   if (derivations != NULL && derivations->tl != NULL) {
//     // More than one derivation, so ambiguous.
//     fprintf(stderr,"Ambiguous parse, (%d,%d,%d) has multiple derivations\n",
// 	    ei->f0,ei->f1,ei->f2);
//     fflush(stderr);
//   }
  //////////////////////////////////

  return derivations;
}

parse_tree_t
derivation_redux(Hashtable::table_t<earley_node_t,List::list_t<earley_node_t>,`H> pred,
		 Hashtable::table_t<earley_node_t,List::list_t<$(earley_node_opt_t,earley_node_t) @`H>,`H> retn,
		 const char ?input,
		 dfa_t dfa,
		 earley_node_t ei) {
  let &$(x,i,j) = ei;
  const char? name = "TOP";
  let completed = Set::to_list(dfa_final_attrs(dfa,x));
  if (completed == NULL) {
    // FIX: add real error handling code.
    // ERROR: precondition of this function is that x is a final state.
//     return tree;
  } 
  else {
    // pick any attribute (we choose the first)
    // FIX: use *all* attributes.
    let attr = completed->hd;
    name = act2symb(attr);
// THIS CODE CAUSES A CYCLONE BUG !!!
//     switch (h_derivations) {
//     case NULL  : 
//       // YHM: can len == 0 ? If so, how did entry ever get created?
//       // ERROR?
//       break;
//     case &List::List{.hd=d, .tl=NULL} : 
//       // Unambiguous
//       tree = new NonTerm(act2symb(attr),i,j,d);
//       break;
//     case &List::List{.hd=d, .tl=NULL} : 
//       // Unambiguous
//       tree = new NonTerm(act2symb(attr),i,j,d);
//       break;
//     default :
//       // Ambiguous
//       tree = new SharedNonTerm(act2symb(attr),i,j,h_derivations);
//     }
  } 

  parse_tree_t tree;

  let h_derivations = derivation_horizontal(pred,retn,input,dfa, ei);
  // distinguish ambiguous from unamb. parses.
  if (h_derivations == NULL){
    // YHM: can len == 0 ? If so, how did entry ever get created?
    // Yes, because it can be a string of terminals.
    fprintf(stderr,"No derivations returned.\n");
    tree = new NonTerm(name,i,j,NULL);
  } else if(h_derivations->tl == NULL){
    // Unambiguous
    tree = new NonTerm(name,i,j,h_derivations->hd);
  } else {
    // Ambiguous
    tree = new SharedNonTerm(name,i,j,h_derivations);
  }

  return tree;
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

typedef Graph::graph_t<earley_node_t> egraph_t;
egraph_t *ggg;
void cvti(earley_node_t s,List::list_t<earley_node_t> ts) {
  for (; ts; ts = ts->tl)
    *ggg = Graph::add_edge(*ggg,s,ts->hd);
}
egraph_t cvt(Hashtable::table_t<earley_node_t,List::list_t<earley_node_t>,`H> tbl) {
  ggg = new Graph::empty(earley_node_cmp);
  Hashtable::iter(cvti,tbl);
  return *ggg;
}

/* Earley recognizer.
   Returns 1 if input is recognized, 0 otherwise.
 */
int recognize(grammar_t grm, rule_t r,const char ?input) {
  init_maybe_empty(grm);
  let $(dfa,dfa_final) = rule2earley(grm,r);
  if (debug)
    dfa_dot(stderr,dfa,act2symb);
  fflush(stderr);

  /* Keep track of parse trees */
  let
    pred = Hashtable::create(11,earley_node_cmp,earley_node_hash);
  let
    retn = Hashtable::create(11,earley_node_cmp,earley_node_hash);
  let
    call = Hashtable::create(11,earley_node_cmp,earley_node_hash);

  /* Initialize the sequence of Earley states with s0 */
  let estates = /* Earley states  s0, s1, s2, ... */
    Axarray::create(11,Set::empty(earley_item_cmp));
  let earley_item_0 = new $(1,0); // 1 is initial state of dfa, 0 is i in si
  let rs = new rstate {dfa,estates,pred,retn,call};
  push_closure(rs,
               0,
               earley_item_0,
               "(initial)",
               NULL,NULL);
               
  /* Scan the input */
  let input_len = strlen(input);
  for (let i = 0; i < input_len; i++) {
    fprintf(stderr,"input[%d]==%s\n",i,cs_char_escape(input[i]));fflush(stderr);
    for (let si_list = Set::to_list(Axarray::get(estates,i));
         si_list != NULL;
         si_list = si_list->tl) {

      let &$(state,parent) = si_list->hd;
      let k = target(dfa,state,input[i]);
      if (k != 0) // where k==0 indicates there is no valid target.
        push_closure(rs,i+1,new $(k,parent),"(input)",new $(state,parent,i),NULL);
    }
  }

  /* See if we ended up in a final state */
  fprintf(stderr,"Looking in estates[%d] for:",input_len);
  for (let fs = Set::to_list(dfa_final); fs != NULL; fs = fs->tl)
    fprintf(stderr," (%d,0)",fs->hd);
  fprintf(stderr,"\n");fflush(stderr);

  printf("AA\n");
  rstate_dot(rs);
  //  Graph::print(stdout,cvt(pred),earley_node_pr);
  printf("BB\n");
  //  Graph::print(stdout,cvt(retn),earley_node_pr);

  for (let slast_list = Set::to_list(Axarray::get(estates,input_len));
       slast_list != NULL;
       slast_list = slast_list->tl) {
    let &$(state,parent) = slast_list->hd;
    if (Set::member(dfa_final,state) && parent == 0) {
//       b = Buffer::create(1024);
//       derivation(pred,retn,new $(state,parent /*== 0*/,input_len),input,dfa);
//       printf("Input:\n%s\nParse:\n",input);
//       printf("%s\n",Buffer::contents(b));
      let completed = Set::to_list(dfa_final_attrs(dfa,state));
      let derivation_tree = derivation_redux(pred,retn,input,dfa,new $(state,parent /*== 0*/,input_len));
      printf("Input:\n%s\nLeftmost derivation:\n",input);
      print_LD(derivation_tree);
      printf("\nRightmost derivation:\n");
      print_RD(derivation_tree);
      printf("\n");
      return 1;
    }
  }
  return 0;
}
