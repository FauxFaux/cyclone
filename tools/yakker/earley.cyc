/* (So far incomplete) Earley parser */

#include <buffer.h>
#include <string.h>
#include <core.h>
#include <stdlib.h>
#include <list.h>
#include <graph.h>
#include "bnf.h"
#include "fa.h"
#include "axarray.h"
#include "cs.h"
#include "analyze.h"
#include "pm_bnf.h"

#include "nfa_eager.h"
#include "semiring.h"

#include "earley.h"

using Nfa_eager;
using Semiring;

namespace Earley;


/* Global variable that saves last derivation tree.*/
datatype ParseTree *last_derivation_tree = NULL;

// Flag indicating whether to print parsing progress to stderr.
static int show_prog = 0;
static int show_prog_start = 0;

void print_LT_parse_forest(parse_forest_t pf, int depth);

void print_LT(datatype ParseTree @pt, int depth){
  switch (pt) {
  case &NonTerm(name,l,r,w,children):
    printf("<t s=\"%s(%s)\" l=\"%d\" r=\"%d\">",name,Semiring::print_weight(w),l,r);
  print_LT_parse_forest(children, depth);
    printf("</t>");
    break;
  case &SharedNonTerm(name,l,r,w,children_list):
    printf("<t s=\"%s(%s)\" l=\"%d\" r=\"%d\">",name,Semiring::print_weight(w),l,r);
  print_LT_parse_forest(children_list->hd,depth);
    printf("</t>");
    break;
  }
}

void print_LT_parse_forest(parse_forest_t pf, int depth){
  if (depth > 0){
    let d = depth - 1;
    for(let ts = (_*)List::rev(pf); ts; ts = ts->tl)
      print_LT(ts->hd, d);
  } else if(depth == -1) {
    for(let ts = (_*)List::rev(pf); ts; ts = ts->tl)
      print_LT(ts->hd, -1);
  }
}

void print_RT_parse_forest(parse_forest_t pf, int depth);

`a reflect(`a last_seen,`a current){return current;}

void print_RT(datatype ParseTree @pt, int depth){
  switch (pt) {
  case &NonTerm(name,l,r,w,children):
    printf("<t s=\"%s(%s)\" l=\"%d\" r=\"%d\">",name,Semiring::print_weight(w),l,r);
  print_RT_parse_forest(children,depth);
    printf("</t>");
    break;
  case &SharedNonTerm(name,l,r,w,children_list):
    printf("<t s=\"%s(%s)\" l=\"%d\" r=\"%d\">",name,Semiring::print_weight(w),l,r);
    let last_derivation = List::fold_left(reflect,children_list->hd,children_list);
    print_RT_parse_forest(last_derivation,depth);
    printf("</t>");
    break;
  }
}

void print_RT_parse_forest(parse_forest_t pf, int depth){
  if (depth > 0){
    let d = depth - 1;
    for(let ts = (_*)List::rev(pf); ts; ts = ts->tl)
      print_RT(ts->hd, d);
  } else if(depth == -1) {
    for(let ts = (_*)List::rev(pf); ts; ts = ts->tl)
      print_RT(ts->hd, -1);
  }
}


void print_parse_forest(parse_forest_t pf);

void print_parse_tree(datatype ParseTree @pt){
  switch (pt) {
  case &NonTerm(name,l,r,w,children):
    printf("<t s=\"%s(%s)\" l=\"%d\" r=\"%d\">",name,Semiring::print_weight(w),l,r);
    print_parse_forest(children);
    printf("</t>");
    break;
  default:
    fprintf(stderr,"Ambiguous parse tree!\n");
    break;
  }
}

void print_parse_forest(parse_forest_t pf){
  List::iter(print_parse_tree,pf);
}


int isAmb_parse_forest(parse_forest_t pf);

int isAmb_parse_tree0(int isAmb, datatype ParseTree @pt){
  if (isAmb) return 1;

  switch (pt) {
  case &NonTerm(name,l,r,w,children):
    return isAmb_parse_forest(children);
  default:
    return 1;
  }
}

int isAmb_parse_tree(datatype ParseTree @pt){
  return isAmb_parse_tree0(0,pt);
}

int isAmb_parse_forest(parse_forest_t pf){
  return List::fold_left(isAmb_parse_tree0,0,pf);
}

/* The alphabet of the automaton is the set of terminals and
   non-terminals.  Assume for now that cs_t can represent a set of
   terminals and non-terminals.  Number our new actions starting
   at 256.

   NB: there is a max number of actions hard-coded in cs.h.
*/

struct symbInfo {
  unsigned int symb_action_counter;
  struct Hashtable::Table<str_t,act_t> @symb_action_table;
  struct Hashtable::Table<act_t,str_t> @action_symb_table;
};

Hashtable::table_t<act_t,str_t> get_as_table(symb_info_t si){return si->action_symb_table;}

static act_t callout_action() {
  return 256;
}
static act_t repeat_action() {
  return 257;
}
static act_t final_st_action() {
  return 258;
}
static act_t repeat_decr_action() {
  return 259;
}

static act_t repeat_final_action() {
  return 260;
}

#define MIN_ACTION 261

symb_info_t new_symb_info(){
  struct Hashtable::Table<act_t,str_t> @ as_table =
    Hashtable::create(11,st_cmp,st_hash);
  Hashtable::insert(as_table,callout_action(),new "CALL");
  Hashtable::insert(as_table,repeat_action(),new "REPEAT");
  Hashtable::insert(as_table,repeat_decr_action(),new "REPEAT-DECR");
  Hashtable::insert(as_table,repeat_final_action(),new "REPEAT-FINAL");
  Hashtable::insert(as_table,final_st_action(),new "FINAL-STATE");

  struct Hashtable::Table<str_t,act_t> @sa_table =
    Hashtable::create(11,strptrcmp,Hashtable::hash_stringptr);
  Hashtable::insert(sa_table,new "CALL",callout_action());
  Hashtable::insert(sa_table,new "REPEAT",repeat_action());
  Hashtable::insert(sa_table,new "REPEAT-DECR",repeat_decr_action());
  Hashtable::insert(sa_table,new "REPEAT-FINAL",repeat_final_action());
  Hashtable::insert(sa_table,new "FINAL-STATE",final_st_action());

  let ssnf_table = Hashtable::create(11,strptrcmp,Hashtable::hash_stringptr);

  return new symbInfo(MIN_ACTION,sa_table,as_table);
}

static act_t new_action(symb_info_t si) {
  let a = si->symb_action_counter++;
  if (a > MAXACTION) {
    fprintf(stderr,"Internal error: maximum number of actions exceeded\n");
    fflush(stderr);
    exit(1);
  }
  return a;
}
static cs_t callout_cs() {
  return cs_singleton(callout_action());
}
static cs_t repeat_cs() {
  return cs_singleton(repeat_action());
}
static cs_t final_st_cs() {
  return cs_singleton(final_st_action());
}
const char ?act2symb(act_t act, Hashtable::table_t<act_t,str_t> as_table) {
////////////////////////////////////////////////////////////////////////
// CAUSES COMPILER EXCEPTION:
//   let as_table = 
//     Hashtable::create(11,st_cmp,st_hash);
//   Hashtable::insert(as_table,callout_action(),new "CALL");
//   Hashtable::insert(as_table,repeat_action(),new "REPEAT");
//   Hashtable::insert(as_table,final_st_action(),new "FINAL-STATE");
////////////////////////////////////////////////////////////////////////
  let sopt = Hashtable::lookup_opt(as_table,act);
  if (sopt == NULL || *sopt == NULL) return NULL;
  else return **sopt;
}
void act2symb_cyclone(FILE @f, symb_info_t si) {
    fprintf(f,"const char ?act2symb(act_t a) {\n");
    fprintf(f,"  switch (a) {\n");
  for (let a = repeat_action()+1; a < si->symb_action_counter; a++) {
    fprintf(f,"  case %d: return \"%s\";\n",a,act2symb(a,si->action_symb_table));
  }
    fprintf(f,"  default: return \"?unknown?\";\n");
    fprintf(f,"  }\n");
    fprintf(f,"}\n");
}
void act2symb_haxe(FILE @f, symb_info_t si) {
    fprintf(f,"static public function act2symb(a:Int) {\n");
    fprintf(f,"  switch (a) {\n");
  for (let a = repeat_action()+1; a < si->symb_action_counter; a++) {
    fprintf(f,"  case %d: return \"%s\";\n",a,act2symb(a,si->action_symb_table));
  }
    fprintf(f,"  default: return \"?unknown?\";\n");
    fprintf(f,"  }\n");
    fprintf(f,"}\n");
}

static act_t symb2act(const char ?`H symb, symb_info_t si) {
//   let symbptr = new symb;
  let symbptr = new (const char ?)aprintf("%s",symb);
  let aptr = Hashtable::lookup_opt(si->symb_action_table,symbptr);
  if (aptr != NULL) return *aptr;
  let a = new_action(si);
  if (debug)
    fprintf(stderr,"Symbol %s has action 0x%x\n",symb,a);
  // allocate a new string before putting it in table to ensure
  // that
  Hashtable::insert((_@)si->symb_action_table,symbptr,a);
  Hashtable::insert((_@)si->action_symb_table,a,symbptr);
  return a;
}

static cs_t consume_symb_cs(const char ?`H symb,symb_info_t si) {
  return cs_singleton(symb2act(symb,si));
}

/* An automaton state and parent pointer */
typedef $(st_t,unsigned int) @earley_item_t;

static int earley_item_cmp(earley_item_t a,earley_item_t b) {
  let $(ai,aj) = *a;
  let $(bi,bj) = *b;
  let c = Core::intcmp(ai,bi);
  if (c) return c;
  return Core::intcmp(aj,bj);
}

typedef $(st_t,unsigned int,unsigned int) @earley_node_t;
typedef $(st_t,unsigned int,unsigned int) *earley_node_opt_t;
typedef  Hashtable::table_t<earley_item_t,List::list_t<earley_node_t,`r>,`r> earley_graph_t<`r>;
static int earley_node_cmp(earley_node_t a,earley_node_t b) {
  let $(ai,aj,ak) = *a;
  let $(bi,bj,bk) = *b;
  let c = Core::intcmp(ai,bi);
  if (c) return c;
  c = Core::intcmp(aj,bj);
  if (c) return c;
  return Core::intcmp(ak,bk);
}
static void earley_node_pr(FILE @f,earley_node_t a) {
  let $(ai,aj,ak) = *a;
  fprintf(f,"(%d,%d,%d)",ai,aj,ak);
}

static int earley_node_hash(earley_node_t a) {
  let $(ai,aj,ak) = *a;
  /* All ai, aj, and ak are ints starting at 0, ai maxes out at the
     number of states, aj and ak max out at the input length.
     TODO: see what typical sizes are for these and adjust the
     hash function accordingly.
  */
  return ai ^ (aj+ak);
}

typedef Set::set_t<earley_item_t> earley_state_t;

/* Create the control NFA for Earley parsing.
   The rule specifies what to parse.
   Symbols from the grammar will be used if needed, otherwise ignored.
   The symb_st table maps used symbols to states and should be
   initialized to the empty table.
   On return the table will hold mappings for all symbols encountered.
   */
$(st_t,st_t,st_t)
  merge(Hashtable::table_t<str_t,st_t> symb_st,
        grammar_t grm,
        rule_t r,
	symb_info_t symb_info);

st_t rule2earley0(Hashtable::table_t<str_t,st_t> symb_st,
                  grammar_t grm,
                  rule_t r,
		  symb_info_t symb_info) {
  switch (r->r) {
  case &Symb(x,_):
    let xptr = new x;
    st_t x_start; /* start state of the NFA for the symbol */
    if (!Hashtable::try_lookup(symb_st,xptr,&x_start)) {
      /* Symbol has not been converted to NFA yet */
      Rule_t x_rule = lookup_symbol(grm, x);
      if (!x_rule) {
	warn("missing definition for %s in rule2earley()\n",x);
	return mklit("");
      }
      /* Allocate a start state for the symbol.  Do this before
         converting to NFA in case the symbol is defined recursively. */
      let s = nfa_fresh_state(); let f = nfa_fresh_state(); final(s,f);
      Hashtable::insert(symb_st,xptr,s);
      let $(s_body,f_body,_) = merge(symb_st,grm,x_rule,symb_info);
      final(s,f_body); // merge does not do this
      etrans(s,s_body);
      x_start = s;
    }
    let s = nfa_fresh_state();
    let s2 = nfa_fresh_state();
    let f = nfa_fresh_state(); final(s,f);
    action(s,callout_cs(),x_start);
    etrans(s,s2);
    action(s2,consume_symb_cs(x,symb_info),f);
    /* If the symbol can derive the empty string make sure this gets
       reflected into the automaton --- effectively doing a RETURN in
       the automaton instead of the Earley evaluator itself */
    if (empty_rule(SYMB(x)))
      etrans(s2,f);
    return s;
  case &Lit(x):
    return mklit(x);
  case &CharRange(low,high):
    if (low > high) {
      internal_err("invalid character range in rule2earley()\n");
      return mklit("");
    }
    return mkact(cs_range(low,high+1));
  case &Opt(r2):
    let s2 = rule2earley0(symb_st,grm,r2,symb_info); let s3 = mklit("");
    return mkalt(s2,s3);
  case &Seq(r2,r3):
    let s2 = rule2earley0(symb_st,grm,r2,symb_info); let s3 = rule2earley0(symb_st,grm,r3,symb_info);
    return mkseq(s2,s3);
  case &Alt(r2,r3):
    let s2 = rule2earley0(symb_st,grm,r2,symb_info); let s3 = rule2earley0(symb_st,grm,r3,symb_info);
    return mkalt(s2,s3);
  case &Rcount(var,r2):
    /* Conservative approximation */
    warn_repeat();
    // 1. check that r2 is valid -- only symbols allowed.
    // TODO

    // 2. s2 <- generate NFA for r2.
    let s2 = rule2earley0(symb_st,grm,r2,symb_info);

    // 2.a. Convert var -- the "repeater" because it determines the repetition -- to action.
    let repeater_cs =  consume_symb_cs(var,symb_info);
    // 2.b. Convert target -- the "repeatee" because gets repeated -- to action.
    let repeatee_cs;
    switch (r2->r) {
    case &Symb(x,_):
      // overwrite s2 with start state of symbol *definition*.
      Hashtable::try_lookup(symb_st,new x,&s2);
      repeatee_cs = consume_symb_cs(x,symb_info);
      break;
    default:
      fprintf(stderr,"Error: repeatee of repeat is not a symbol.\n");
      return mklit("");
    }
    // 2.c.  and add to final state of s2. FIX: can't do this, b/c no
    // attrs for NFA final states. For now, just enforce that user use
    // unique nonterm in which case, var will be added automatically.

    // 3. Create start and final state for the repeat.
    let s = nfa_fresh_state();
    let f = nfa_fresh_state();
    final(s,f);

    // 4. add fresh states that CALL to s2 and transition (to final
    // state) on var. Not a real states -- just used to store info
    // about s_rep: the NFA to call, nonterm symbol (action), and
    // final state of repeat. Could use separate table.
    let s_rep_call = nfa_fresh_state();
    let s_rep_trans_repeater = nfa_fresh_state();
    let s_rep_trans_repeatee = nfa_fresh_state();
    action(s_rep_call,callout_cs(),s2);
    etrans(s_rep_call,s_rep_trans_repeater);
    action(s_rep_trans_repeater,repeater_cs,s_rep_trans_repeatee);
    action(s_rep_trans_repeatee,repeatee_cs,f);

    // 4. Transition start state to CALL state on repeat to indicate a
    // repeat is happening.
    action(s,repeat_cs(),s_rep_call);

    return s;
  case &Star(0,&Infinity,r2):
    let s2 = rule2earley0(symb_st,grm,r2,symb_info);
    return mkstar(s2);
  case &Star(m,i as &Infinity,r2):
    let r_seq = SEQ(r2,STAR(m-1,i,r2));
    return rule2earley0(symb_st,grm,r_seq,symb_info);
  case &Star(0,&Num(0),r2):
    return mklit("");

  case &Star(0,&Num(n),r2):
    let r_opt = OPT(SEQ(r2,STAR(0, new Num(n-1),r2)));
    return rule2earley0(symb_st,grm,r_opt,symb_info);
  case &Star(m,&Num(n),r2):
    if (m > n) return mklit("");
    let r_seq = SEQ(r2,STAR(m-1, new Num(n-1),r2));
    return rule2earley0(symb_st,grm, r_seq,symb_info);

  case &Hash(0,N,r2):
    // same as [ r2 *{N-1}(commas r2) ]
    return rule2earley0(symb_st,grm,
                        OPT(SEQ(r2,STAR(0,minus_one(N),SEQ(commas(),r2)))),
			symb_info);
  case &Hash(m,N,r2):
    // same as r2 {m-1}*{N-1}(commas r2)
    return rule2earley0(symb_st,grm,
                        SEQ(r2,STAR(m-1,minus_one(N),SEQ(commas(),r2))),
			symb_info);
  case &Prose(_):
    warn("Prose not supported in rule2earley()\n");
    return mklit("");
  case &Minus(_,_):
    warn("Minus not supported in rule2earley()\n");
    return mklit("");
  }
}

$(st_t,st_t,st_t)
  merge(Hashtable::table_t<str_t,st_t> symb_st,
        grammar_t grm,
        rule_t r,
	symb_info_t symb_info) {
  switch (r->r) {
  case &Symb(x,_):
    let xptr = new x;
    st_t x_start; /* start state of the NFA for the symbol */
    if (!Hashtable::try_lookup(symb_st,xptr,&x_start)) {
      /* Symbol has not been converted to NFA yet */
      Rule_t x_rule = lookup_symbol(grm, x);
      if (!x_rule) {
	warn("missing definition for %s in merge()\n",x);
	return merge(symb_st,grm,LIT(""),symb_info);
      }
      /* Allocate a start state for the symbol.  Do this before
         converting to NFA in case the symbol is defined recursively. */
      let s = nfa_fresh_state(); let f = nfa_fresh_state();
      Hashtable::insert(symb_st,xptr,s);
      let $(s_body,f_body,_) = merge(symb_st,grm,x_rule,symb_info);
      // need e_body too???
      final(s,f_body); // merge does not do this
      etrans(s,s_body);
      x_start = s;
    }
    let s = nfa_fresh_state();
    let s2 = nfa_fresh_state();
    let e = nfa_fresh_state();
    let f = nfa_fresh_state();
    action(s,EPSILON,x_start);
    etrans(s,s2);
    action(s2,consume_symb_cs(x,symb_info),f);
    /* If the symbol can derive the empty string make sure this gets
       reflected into the automaton --- effectively doing a RETURN in
       the automaton instead of the Earley evaluator itself */
    if (empty_rule(SYMB(x)))
      etrans(s2,e);
    return $(s,f,e);
  case &Lit(x):
    if (!strcmp(x,"")) {
      let s = nfa_fresh_state();
      let f = nfa_fresh_state();
      let e = nfa_fresh_state();
      etrans(s,e);
      return $(s,f,e);
    }
    else {
      let s = mklit(x);
      let f = get_final(s);
      let e = nfa_fresh_state();
      return $(s,f,e);
    }
  case &CharRange(low,high):
    if (low > high) {
      internal_err("invalid character range in merge()\n");
      let s = nfa_fresh_state();
      let f = nfa_fresh_state();
      return $(s,f,s);
    }
    else {
      let s = mkact(cs_range(low,high+1));
      let f = get_final(s);
      let e = nfa_fresh_state();
      return $(s,f,e);
    }
  case &Opt(r2):
    let s = nfa_fresh_state();
    let e = nfa_fresh_state();
    let $(s2,f2,e2) = merge(symb_st,grm,r2,symb_info);
    etrans(s,s2);
    action(s,EPSILON,e);
    etrans(e2,e);
    return $(s,f2,e);
  case &Seq(r2,r3):
    let s = nfa_fresh_state();
    let f = nfa_fresh_state();
    let e = nfa_fresh_state();
    let $(s2,f2,e2) = merge(symb_st,grm,r2,symb_info);
    let $(s3,f3,e3) = merge(symb_st,grm,r3,symb_info);
    let scall = rule2earley0(symb_st,grm,r3,symb_info);
    let fcall = get_final(scall);
    etrans(s,s2);
    etrans(f2,scall);
    etrans(e2,s3);
    etrans(f3,f);
    etrans(fcall,f);
    etrans(e3,e);
    return $(s,f,e);
  case &Alt(r2,r3):
    let s = nfa_fresh_state();
    let f = nfa_fresh_state();
    let e = nfa_fresh_state();
    let $(s2,f2,e2) = merge(symb_st,grm,r2,symb_info);
    let $(s3,f3,e3) = merge(symb_st,grm,r3,symb_info);
    etrans(s,s2);
    action(s,EPSILON,s3);
    etrans(f2,f);
    etrans(f3,f);
    etrans(e2,e);
    etrans(e3,e);
    return $(s,f,e);
  case &Rcount(var,r2):
    warn_repeat();
    //  repeat should never show up in a merge, because that implies
    // that it might be preceded by epsilon, in which case it will have
    // no value on which to depend.
    warn("@repeat appears, in a sequence, possibly preceded by epsilon.\n");
    fallthru(r2);
  case &Star(0,&Infinity,r2):
    let s = nfa_fresh_state();
    let f = nfa_fresh_state();
    let e = nfa_fresh_state();
    let $(s2,f2,e2) = merge(symb_st,grm,r2,symb_info);
    let scall = rule2earley0(symb_st,grm,r2,symb_info);
    let fcall = get_final(scall);
    etrans(s,s2);
    action(s,EPSILON,e);
    etrans(e2,s2);
    action(e2,EPSILON,e);
    etrans(f2,scall);
    action(f2,EPSILON,f);

    // We could replace the following two transitions
    // with this single transition:
    // etrans(fcall,f2);
    // and then this would resemble the standard
    // Star construction,  with f2 playing the
    // role of s.
    etrans(fcall,scall);
    action(fcall,EPSILON,f);
    return $(s,f,e);
  case &Star(m,i as &Infinity,r2):
    let r_seq = SEQ(r2,STAR(m-1,i,r2));
    return merge(symb_st,grm,r_seq,symb_info);
  case &Star(0,&Num(0),r2):
    return merge(symb_st,grm,LIT(""),symb_info);
  case &Star(0,&Num(n),r2):
    let r_opt = OPT(SEQ(r2,STAR(0, new Num(n-1),r2)));
    return merge(symb_st,grm,r_opt,symb_info);
  case &Star(m,&Num(n),r2):
    if (m > n) return merge(symb_st,grm,LIT(""),symb_info);
    let r_seq = SEQ(r2,STAR(m-1, new Num(n-1),r2));
    return merge(symb_st,grm, r_seq,symb_info);

  case &Hash(0,N,r2):
    // same as [ r2 *{N-1}(commas r2) ]
    return merge(symb_st,grm,
                 OPT(SEQ(r2,STAR(0,minus_one(N),SEQ(commas(),r2)))),symb_info);
  case &Hash(m,N,r2):
    // same as r2 {m-1}*{N-1}(commas r2)
    return merge(symb_st,grm,
                 SEQ(r2,STAR(m-1,minus_one(N),SEQ(commas(),r2))),symb_info);
  case &Prose(_):
    warn("Prose not supported in merge()\n");
    return merge(symb_st,grm,LIT(""),symb_info);
  case &Minus(_,_):
    warn("Minus not supported in merge()\n");
    return merge(symb_st,grm,LIT(""),symb_info);
  }
}

$(st_t,st_t,st_t)
merge_wfsm(FILE@f_fsm, Hashtable::table_t<str_t,st_t> symb_st,
        grammar_t grm,
        rule_t r,
	symb_info_t symb_info);

st_t rule2wfsm0(FILE@f_fsm, Hashtable::table_t<str_t,st_t> symb_st,
                  grammar_t grm,
                  rule_t r,
		  symb_info_t symb_info) {
  switch (r->r) {
  case &Symb(x,_):
    let xptr = new x;
    st_t x_start; /* start state of the NFA for the symbol */
    if (!Hashtable::try_lookup(symb_st,xptr,&x_start)) {
      /* Symbol has not been converted to NFA yet */
      Rule_t x_rule = lookup_symbol(grm, x);
      if (!x_rule) {
	warn("missing definition for %s in rule2wfsm()\n",x);
	return mklit("");
      }
      /* Allocate a start state for the symbol.  Do this before
         converting to NFA in case the symbol is defined recursively. */
      let s = nfa_fresh_state(); let f = nfa_fresh_state(); final(s,f);
      Hashtable::insert(symb_st,xptr,s);
      let $(s_body,f_body,e_body) = merge_wfsm(f_fsm,symb_st,grm,x_rule,symb_info);
      final_fsm(f_fsm, s, e_body,x); // merge_wfsm does not do this
      final_fsm(f_fsm, s, f_body,x); // merge_wfsm does not do this
      etrans_fsm(f_fsm, s,s_body,Semiring::one_weight);
      x_start = s;
    }
    let s = nfa_fresh_state();
    let s2 = nfa_fresh_state();
    let f = nfa_fresh_state(); final(s,f);
    // NOTE: probs don't add up, b/c CALL prob is ignored.
    // CALLS get zero b/c, in essence, they are *never*
    // traversed. They are just stand-ins for the real traversal on
    // the symbol.
//    if (empty_rule(SYMB(x))){
//    /* If the symbol can derive the empty string make sure this gets
//       reflected into the automaton --- effectively doing a RETURN in
//       the automaton instead of the Earley evaluator itself */
//      single_action_fsm(f_fsm, s,callout_action(),"CALL",x_start, Semiring::zero_weight);
//      etrans_fsm(f_fsm, s, s2,Semiring::one_weight);
//      etrans_fsm(f_fsm, s2,f,Semiring::from_inv_prob(2));
//      single_action_fsm(f_fsm, s2,symb2act(x,symb_info),x,f,Semiring::from_inv_prob(2));
//    } else 
    {
      single_action_fsm(f_fsm, s,callout_action(),"CALL",x_start, Semiring::zero_weight);
      etrans_fsm(f_fsm, s,s2,                   Semiring::one_weight);
      single_action_fsm(f_fsm, s2,symb2act(x,symb_info),x,f,Semiring::one_weight);
    }

    return s;
  case &Lit(x):
    return mklit_fsm(f_fsm, x);
  case &CharRange(low,high):
    if (low > high) {
      internal_err("invalid character range in rule2wfsm()\n");
      return mklit("");
    }
    return mkact_fsm(f_fsm, cs_range(low,high+1));
  case &Opt(r2):
    let s2 = rule2wfsm0(f_fsm,symb_st,grm,r2,symb_info); 
    return mkopt_fsm(f_fsm, s2);
  case &Seq(r2,r3):
    let s2 = rule2wfsm0(f_fsm,symb_st,grm,r2,symb_info); let s3 = rule2wfsm0(f_fsm,symb_st,grm,r3,symb_info);
    return mkseq_fsm(f_fsm,s2,s3);
  case &Alt(r2,r3):
    let s = nfa_fresh_state();
    let f = nfa_fresh_state();
    final(s,f);

    let rules = alt2rules(r);
    let n = List::length(rules);
    let w = Semiring::from_inv_prob(n);

    for (; rules; rules = rules->tl){
      let s2 = rule2wfsm0(f_fsm,symb_st,grm,rules->hd,symb_info);
      let f2 = get_final(s2);
      etrans_fsm(f_fsm, s,s2, w);
      etrans_fsm(f_fsm, f2,f, Semiring::one_weight);
    }

    return s;
  case &Rcount(var,r2):
    /* Conservative approximation */
    warn_repeat();
    // 1. check that r2 is valid -- only symbols allowed.
    // TODO

    // 2. s2 <- generate NFA for r2.
    let s2 = rule2wfsm0(f_fsm,symb_st,grm,r2,symb_info);

    // 2.a. Convert var -- the "repeater" because it determines the repetition -- to action.
    let repeater_act =  symb2act(var,symb_info);
    // 2.b. Convert target -- the "repeatee" because gets repeated -- to action.
    let repeatee_act;
    let repeatee_sym;
    switch (r2->r) {
    case &Symb(x,_):
      // overwrite s2 with start state of symbol *definition*.
      Hashtable::try_lookup(symb_st,new x,&s2);
      repeatee_act = symb2act(x,symb_info);
      repeatee_sym = x;
      break;
    default:
      fprintf(stderr,"Error: repeatee of repeat is not a symbol.\n");
      return mklit("");
    }
    // 2.c.  and add to final state of s2. FIX: can't do this, b/c no
    // attrs for NFA final states. For now, just enforce that user use
    // unique nonterm in which case, var will be added automatically.

    // 3. Create start and final state for the repeat.
    let s = nfa_fresh_state();
    let f = nfa_fresh_state();
    final(s,f);

    // 4. add fresh states that CALL to s2 and transition (to final
    // state) on var. Not a real states -- just used to store info
    // about s_rep: the NFA to call, nonterm symbol (action), and
    // final state of repeat. Could use separate table.
    let s_rep_call = nfa_fresh_state();
    let s_rep_trans_repeater = nfa_fresh_state();
    let s_rep_trans_repeatee = nfa_fresh_state();

    // These weights are not used, so only need to make sure they make sense.
    single_action_fsm(f_fsm, s_rep_call,callout_action(),"CALL",s2, Semiring::from_inv_prob(2));
    etrans_fsm(f_fsm, s_rep_call,s_rep_trans_repeater, Semiring::from_inv_prob(2));
    single_action_fsm(f_fsm, s_rep_trans_repeater,repeater_act,var,
		      s_rep_trans_repeatee, Semiring::from_inv_prob(2));
    single_action_fsm(f_fsm, s_rep_trans_repeatee,repeatee_act,repeatee_sym,f, Semiring::from_inv_prob(2));

    // 4. Transition start state to CALL state on repeat to indicate a
    // repeat is happening.
    single_action_fsm(f_fsm, s,repeat_action(),"REPEAT",s_rep_call, Semiring::one_weight);

    return s;
  case &Star(0,&Infinity,r2):
    let s2 = rule2wfsm0(f_fsm,symb_st,grm,r2,symb_info);
    return mkstar_fsm(f_fsm,s2);
  case &Star(m,i as &Infinity,r2):
    let r_seq = SEQ(r2,STAR(m-1,i,r2));
    return rule2wfsm0(f_fsm,symb_st,grm,r_seq,symb_info);
  case &Star(0,&Num(0),r2):
    return mklit_fsm(f_fsm,"");

  case &Star(0,&Num(n),r2):
    let r_opt = OPT(SEQ(r2,STAR(0, new Num(n-1),r2)));
    return rule2wfsm0(f_fsm,symb_st,grm,r_opt,symb_info);
  case &Star(m,&Num(n),r2):
    if (m > n) return mklit_fsm(f_fsm,"");
    let r_seq = SEQ(r2,STAR(m-1, new Num(n-1),r2));
    return rule2wfsm0(f_fsm,symb_st,grm, r_seq,symb_info);

  case &Hash(0,N,r2):
    // same as [ r2 *{N-1}(commas r2) ]
    return rule2wfsm0(f_fsm,symb_st,grm,
                        OPT(SEQ(r2,STAR(0,minus_one(N),SEQ(commas(),r2)))),
			symb_info);
  case &Hash(m,N,r2):
    // same as r2 {m-1}*{N-1}(commas r2)
    return rule2wfsm0(f_fsm,symb_st,grm,
                        SEQ(r2,STAR(m-1,minus_one(N),SEQ(commas(),r2))),
			symb_info);
  case &Prose(_):
    warn("Prose not supported in rule2wfsm()\n");
    return mklit("");
  case &Minus(_,_):
    warn("Minus not supported in rule2wfsm()\n");
    return mklit("");
  }
}

$(st_t,st_t,st_t)
  merge_wfsm(FILE@f_fsm, Hashtable::table_t<str_t,st_t> symb_st,
        grammar_t grm,
        rule_t r,
	symb_info_t symb_info) {
  switch (r->r) {
  case &Symb(x,_):
    let xptr = new x;
    st_t x_start; /* start state of the NFA for the symbol */
    if (!Hashtable::try_lookup(symb_st,xptr,&x_start)) {
      /* Symbol has not been converted to NFA yet */
      Rule_t x_rule = lookup_symbol(grm, x);
      if (!x_rule) {
	warn("missing definition for %s in merge_wfsm(f_fsm,)\n",x);
	return merge_wfsm(f_fsm,symb_st,grm,LIT(""),symb_info);
      }
      /* Allocate a start state for the symbol.  Do this before
         converting to NFA in case the symbol is defined recursively. */
      let s = nfa_fresh_state(); let f = nfa_fresh_state();
      Hashtable::insert(symb_st,xptr,s);
      let $(s_body,f_body,e_body) = merge_wfsm(f_fsm,symb_st,grm,x_rule,symb_info);
      // 1. need e_body too??? Yes, in case symb is nullable.      
      // 2. only marked final in FSM because this is a symbol.
      final_fsm(f_fsm, s, e_body, x); // merge_wfsm does not do this
      final_fsm(f_fsm, s, f_body, x); // merge_wfsm does not do this
      etrans_fsm(f_fsm, s,s_body,Semiring::one_weight);
      x_start = s;
    }
    let s = nfa_fresh_state();
    let e = nfa_fresh_state();
    let f = nfa_fresh_state();

//    if (empty_rule(SYMB(x))){
//    /* If the symbol can derive the empty string make sure this gets
//       reflected into the automaton --- effectively doing a RETURN in
//       the automaton instead of the Earley evaluator itself */
//      let s2 = nfa_fresh_state();
//      action_fsm(f_fsm, s,EPSILON,x_start, Semiring::one_weight);
//      etrans_fsm(f_fsm, s, s2,Semiring::one_weight);
//      etrans_fsm(f_fsm, s2,e,Semiring::from_inv_prob(2));
//      single_action_fsm(f_fsm, s2,symb2act(x,symb_info),x,f,Semiring::from_inv_prob(2));
//    } else 
    {
      etrans_fsm(f_fsm, s,x_start,Semiring::one_weight);
      single_action_fsm(f_fsm, s,symb2act(x,symb_info),x,f,Semiring::one_weight);
    }

    return $(s,f,e);
  case &Lit(x):
    if (!strcmp(x,"")) {
      let s = nfa_fresh_state();
      let f = nfa_fresh_state();
      let e = nfa_fresh_state();
      etrans_fsm(f_fsm, s,e,Semiring::one_weight);
      return $(s,f,e);
    }
    else {
      let s = mklit_fsm(f_fsm, x);
      let f = get_final(s);
      let e = nfa_fresh_state();
      return $(s,f,e);
    }
  case &CharRange(low,high):
    if (low > high) {
      internal_err("invalid character range in merge_wfsm(f_fsm,)\n");
      let s = nfa_fresh_state();
      let f = nfa_fresh_state();
      return $(s,f,s);
    }
    else {
      let s = mkact_fsm(f_fsm, cs_range(low,high+1));
      let f = get_final(s);
      let e = nfa_fresh_state();
      return $(s,f,e);
    }
  case &Opt(r2):
    let s = nfa_fresh_state();
    let e = nfa_fresh_state();
    let $(s2,f2,e2) = merge_wfsm(f_fsm,symb_st,grm,r2,symb_info);
    etrans_fsm(f_fsm,s,s2,Semiring::from_prob(0.5));
    action_fsm(f_fsm,s,EPSILON,e,Semiring::from_prob(0.5));
    etrans_fsm(f_fsm,e2,e,Semiring::one_weight);
    return $(s,f2,e);
  case &Seq(r2,r3):
    let s = nfa_fresh_state();
    let f = nfa_fresh_state();
    let e = nfa_fresh_state();
    let $(s2,f2,e2) = merge_wfsm(f_fsm,symb_st,grm,r2,symb_info);
    let $(s3,f3,e3) = merge_wfsm(f_fsm,symb_st,grm,r3,symb_info);
    let scall = rule2wfsm0(f_fsm,symb_st,grm,r3,symb_info);
    let fcall = get_final(scall);
    etrans_fsm(f_fsm, s,s2,     Semiring::one_weight);
    etrans_fsm(f_fsm, f2,scall, Semiring::one_weight);
    etrans_fsm(f_fsm, e2,s3,    Semiring::one_weight);
    etrans_fsm(f_fsm, f3,f,     Semiring::one_weight);
    etrans_fsm(f_fsm, fcall,f,  Semiring::one_weight);
    etrans_fsm(f_fsm, e3,e,     Semiring::one_weight);
    return $(s,f,e);
  case &Alt(_,_):
    let s = nfa_fresh_state();
    let f = nfa_fresh_state();
    let e = nfa_fresh_state();

    let rules = alt2rules(r);
    let n = List::length(rules);
    let w = Semiring::from_inv_prob(n);

    for (; rules; rules = rules->tl){
      let $(s2,f2,e2) = merge_wfsm(f_fsm,symb_st,grm,rules->hd,symb_info);
      etrans_fsm(f_fsm, s,s2, w);
      etrans_fsm(f_fsm, f2,f, Semiring::one_weight);
      etrans_fsm(f_fsm, e2,e, Semiring::one_weight);
    }

    return $(s,f,e);
  case &Rcount(var,r2):
    warn_repeat();
    //  repeat should never show up in a merge_wfsm, because that implies
    // that it might be preceded by epsilon, in which case it will have
    // no value on which to depend.
    warn("@repeat appears, in a sequence, possibly preceded by epsilon.\n");
    fallthru(r2);
  case &Star(0,&Infinity,r2):
    let s = nfa_fresh_state();
    let f = nfa_fresh_state();
    let e = nfa_fresh_state();
    let $(s2,f2,e2) = merge_wfsm(f_fsm,symb_st,grm,r2,symb_info);
    let scall = rule2wfsm0(f_fsm,symb_st,grm,r2,symb_info);
    let fcall = get_final(scall);
    etrans_fsm(f_fsm, s,s2, Semiring::from_prob(0.5));
    action_fsm(f_fsm, s,EPSILON,e, Semiring::from_prob(0.5));
    etrans_fsm(f_fsm, e2,s2, Semiring::from_prob(0.5));
    action_fsm(f_fsm, e2,EPSILON,e, Semiring::from_prob(0.5));
    etrans_fsm(f_fsm, f2,scall, Semiring::from_prob(0.5));
    action_fsm(f_fsm, f2,EPSILON,f, Semiring::from_prob(0.5));

    // We could replace the following two transitions
    // with this single transition:
    // etrans_fsm(f_fsm, fcall,f2);
    // and then this would resemble the standard
    // Star construction,  with f2 playing the
    // role of s.
    etrans_fsm(f_fsm, fcall,scall, Semiring::from_prob(0.5));
    action_fsm(f_fsm, fcall,EPSILON,f, Semiring::from_prob(0.5));
    return $(s,f,e);
  case &Star(m,i as &Infinity,r2):
    let r_seq = SEQ(r2,STAR(m-1,i,r2));
    return merge_wfsm(f_fsm,symb_st,grm,r_seq,symb_info);
  case &Star(0,&Num(0),r2):
    return merge_wfsm(f_fsm,symb_st,grm,LIT(""),symb_info);
  case &Star(0,&Num(n),r2):
    let r_opt = OPT(SEQ(r2,STAR(0, new Num(n-1),r2)));
    return merge_wfsm(f_fsm,symb_st,grm,r_opt,symb_info);
  case &Star(m,&Num(n),r2):
    if (m > n) return merge_wfsm(f_fsm,symb_st,grm,LIT(""),symb_info);
    let r_seq = SEQ(r2,STAR(m-1, new Num(n-1),r2));
    return merge_wfsm(f_fsm,symb_st,grm, r_seq,symb_info);

  case &Hash(0,N,r2):
    // same as [ r2 *{N-1}(commas r2) ]
    return merge_wfsm(f_fsm,symb_st,grm,
                 OPT(SEQ(r2,STAR(0,minus_one(N),SEQ(commas(),r2)))),symb_info);
  case &Hash(m,N,r2):
    // same as r2 {m-1}*{N-1}(commas r2)
    return merge_wfsm(f_fsm,symb_st,grm,
                 SEQ(r2,STAR(m-1,minus_one(N),SEQ(commas(),r2))),symb_info);
  case &Prose(_):
    warn("Prose not supported in merge_wfsm(f_fsm,)\n");
    return merge_wfsm(f_fsm,symb_st,grm,LIT(""),symb_info);
  case &Minus(_,_):
    warn("Minus not supported in merge_wfsm(f_fsm,)\n");
    return merge_wfsm(f_fsm,symb_st,grm,LIT(""),symb_info);
  }
}

// Convert and print the rule as an NFA in FSM format.
// Writes two files based on the filename_base: .fsm and .sym. The
// former holds the NFA, the latter the mapping from symbolic names to
// numbers.
void rule_fsm(const char ?fsm_file,const char ?sym_file, grammar_t grm, rule_t r) {
  /* Build the NFA for the grammar */
  init_maybe_empty(grm);

  /* symb_st maps symbols to start states */
  Hashtable::table_t<str_t,st_t> symb_st =
    Hashtable::create(101,strptrcmp,Hashtable::hash_stringptr);

  nfa_init(grm);
  let symb_info = new_symb_info();

  FILE *f = fopen(fsm_file,"w");
  if (f) { 
    // N.B. MUST ensure that start state is printed first.
    // Print transition to dummy state. weight doesn't matter b/c
    // determinization will eliminate this transition.
    let start_s = nfa_fresh_state();
    etrans_fsm(f,start_s,NOTRANSITION,Semiring::from_inv_prob(2.0));
    let $(r_start_state,f_s,e_s) = merge_wfsm(f, symb_st,grm,r,symb_info);
    action_fsm(f, start_s, EPSILON, r_start_state, Semiring::one_weight);
    // Don't know if the following is necessary:
    let final_state = nfa_fresh_state();
    etrans_fsm(f,f_s,final_state, Semiring::one_weight);
    etrans_fsm(f,e_s,final_state, Semiring::one_weight);
    final_fsm(f, r_start_state,final_state, NULL);

    fclose(f); 
  }



//   let $(start_state,f,e) = merge(symb_st,grm,r,symb_info);
//   let final_state = nfa_fresh_state();
//   etrans(f,final_state);
//   etrans(e,final_state);
//   final(start_state,final_state);
//   fprintf(stderr,"Start state is %d, final state is %d\n",start_state,final_state);

//   /* Collect the set of final states for symbols... */
//   let symb_final_states = Set::empty(st_cmp);
//   /* ... and the mapping from final states to symbol actions */
//   let act_table = Hashtable::create(11,st_cmp,st_hash); // should be act_cmp
//   for (let rules = grm; rules != NULL; rules = rules->tl) {
//     let &$(symb,_,_) = rules->hd;
//     let st_opt = Hashtable::lookup_opt(symb_st,new symb);
//     if (!st_opt) continue;
//     let symb_final = get_final(*st_opt);
//     symb_final_states = Set::insert(symb_final_states,symb_final);
//     Hashtable::insert(act_table,
//                       symb_final,
//                       symb2act(symb,symb_info));
//   }

//   let fsm_file = aprintf("%s.fsm",filename_base);
//   FILE *f = fopen(fsm_file,"w");
//   if (f) { nfa_fsm(f,symb_final_states,symb_info->action_symb_table,act_table); fclose(f); }
  else fprintf(stderr, "Failed to open file %s.\n",fsm_file);

  FILE *f = fopen(sym_file,"w");
  if (f) {
    fprintf(f,"%s",yk_inputs);
    symbols_fsm(f,symb_info->action_symb_table);
    fclose(f);
  }
  else fprintf(stderr, "Failed to open file %s.\n",sym_file);
}

$(dfa_t,Set::set_t<st_t>,symb_info_t) *fsm2dfa(const char ?filename) {
  let si = new_symb_info();
  let r = fsm_dfa(filename,symb2act,si);
  if (!r) return NULL;
  else{
    let &$(dfa,final_states) = (_@)r;
    return new $(dfa,final_states,si);
  }
}

static struct Hashtable::Table<act_t,str_t> *fa_dot_as_table = NULL;

const char ?fa_act2symb(act_t a){
  if (!fa_dot_as_table)
    return NULL;
  return act2symb(a,fa_dot_as_table);
}

void dfa2dot(dfa_t dfa, symb_info_t symb_info, const char ?dot_file){
  FILE *f = fopen(dot_file,"w");
  if (f) { 
    fa_dot_as_table = symb_info->action_symb_table;
    dfa_dot(f,dfa,fa_act2symb); 
    fclose(f); 
  }
  else fprintf(stderr, "Failed to open file %s.\n",dot_file);
}

$(dfa_t,Set::set_t<st_t>,symb_info_t) rule2earley(grammar_t grm, rule_t r) {
  /* Build the NFA for the grammar */

  /* symb_st maps symbols to start states */
  Hashtable::table_t<str_t,st_t> symb_st =
    Hashtable::create(101,strptrcmp,Hashtable::hash_stringptr);

  let symb_info = new_symb_info();

  nfa_init(grm);
  let $(start_state,f,e) = merge(symb_st,grm,r,symb_info);
  let final_state = nfa_fresh_state();
  etrans(f,final_state);
  etrans(e,final_state);
  final(start_state,final_state);
  fprintf(stderr,"Start state is %d, final state is %d\n",start_state,final_state);
  if (debug > 1){
	fa_dot_as_table = symb_info->action_symb_table;
    nfa_dot(stderr,Set::singleton(st_cmp,final_state),fa_act2symb);
  }

  /* Collect the set of final states for symbols... */
  let symb_final_states = Set::empty(st_cmp);
  /* ... and the mapping from final states to symbol actions */
  let act_table = Hashtable::create(11,st_cmp,st_hash); // should be act_cmp
  for (let rules = grm; rules != NULL; rules = rules->tl) {
    let &$(symb,_,_) = rules->hd;
    let st_opt = Hashtable::lookup_opt(symb_st,new symb);
    if (!st_opt) continue;
    let symb_final = get_final(*st_opt);
    symb_final_states = Set::insert(symb_final_states,symb_final);
    Hashtable::insert(act_table,
                      symb_final,
                      symb2act(symb, symb_info));
  }

  if (debug){
    FILE *f = fopen("ykdebug/nfa.fsm","w");
    if (f) { nfa_fsm(f,symb_final_states,symb_info->action_symb_table,act_table); fclose(f); }
    else fprintf(stderr, "Failed to open file ykdebug/nfa.fsm.\n");

    FILE *f = fopen("ykdebug/nfa.sym","w");
    if (f) {
      fprintf(f,"%s",yk_inputs);
      symbols_fsm(f,symb_info->action_symb_table);
      fclose(f);
    }
    else
      fprintf(stderr, "Failed to open file ykdebug/nfa.sym.\n");
  }

  /* Convert to DFA */
  let dfa = nfa2dfa(start_state,
                    Set::insert(symb_final_states,final_state));
  dfa = dfa_minimize(dfa);

  /* We want an automata with final attributes that indicate which
     symbol has been completed, but our NFAs do not have final
     attributes.  The nfa2dfa conversion creates a DFA whose final
     states have as attributes the corresponding NFA final states.
     Therefore we can post-process the DFA to map these attributes to
     indicate the symbol (as indicated by symb2act()).

     We also record in dfa_final the subset of final states that
     correspond to the full RHS that is being parsed, as distinguished
     from the final states that indicate parsing of symbols.
  */
  let dfa_final = Set::empty(st_cmp);
  for (let states = Set::to_list(dfa_final_states(dfa));
       states != NULL; states = states->tl) {
    let s = states->hd;
    let action_attrs = Set::empty(st_cmp); // should be attr_cmp
    for (let s_attrs = Set::to_list(dfa_final_attrs(dfa,s));
         s_attrs != NULL; s_attrs = s_attrs->tl) {
      let a = s_attrs->hd;
      if (a == final_state) {
        dfa_final = Set::insert(dfa_final,s);
        // final_state of the original rule r does not correspond to
        // the parsing of a symbol hence does not return.  So we do not
        // want it in the attributes which indicate what symbols are
        // returning.
        continue;
      }
      let act = Hashtable::lookup(act_table,a);
      action_attrs = Set::insert(action_attrs,act);
    }
    dfa_set_final(dfa,s,action_attrs);
  }
  return $(dfa,dfa_final,symb_info);
}

struct rstate {
  dfa_t dfa;
  Hashtable::table_t<act_t,str_t> as_table;
  act_t start_act; // the action for the symbol being parsed; -1 ,if
		   // there is no such action (e.g. we're not parsing
		   // a particular symbol).
  Axarray::xarray_t<earley_state_t> estates;
  Hashtable::table_t<earley_node_t,List::list_t<earley_node_t,`H>,`H> pred;
  Hashtable::table_t<earley_node_t,List::list_t<$(earley_node_opt_t,earley_node_t) @`H,`H>,`H> retn;
  Hashtable::table_t<earley_node_t,List::list_t<earley_node_t,`H>,`H> call;
  Hashtable::table_t<earley_node_t,$(weight_t,weight_t)@> weights; //PROB
  Hashtable::table_t<st_t,int @,`H> repeat_counts;
};
typedef struct rstate @rstate_t;

static void set_repeat_count(rstate_t rs, st_t s, int n){
  Hashtable::insert(rs->repeat_counts,s, new n);
}

static int decr_repeat_count(rstate_t rs, st_t s){
  let rc = Hashtable::lookup(rs->repeat_counts,s);
  return (*rc)--;
}

static void remove_repeat_count(rstate_t rs, st_t s){
  Hashtable::remove(rs->repeat_counts,s);
}

static void dot_iter(earley_node_t s,List::list_t<earley_node_t> ts) {
  let &$(si,sj,sk) = s;
  for (; ts; ts = ts->tl) {
    let &$(ti,tj,tk) = ts->hd;
    printf("\"(%d,%d,%d)\" -> ",si,sj,sk);
    printf("\"(%d,%d,%d)\";\n",ti,tj,tk);
  }
}

static void dot_pred_iter(earley_node_t s,List::list_t<$(earley_node_opt_t,earley_node_t) @`H> ts) {
  let &$(si,sj,sk) = s;
  for (; ts; ts = ts->tl) {
    let &$(_,p) = ts->hd; // only bind pred edge.
    let &$(ti,tj,tk) = p;
    printf("\"(%d,%d,%d)\" -> ",si,sj,sk);
    printf("\"(%d,%d,%d)\";\n",ti,tj,tk);
  }
}

static void dot_retn_iter(earley_node_t s,List::list_t<$(earley_node_opt_t,earley_node_t) @`H> ts) {
  let &$(si,sj,sk) = s;
  for (; ts; ts = ts->tl) {
    let &$(r,_) = ts->hd; // only bind retn edge, not pred edge.
    if (r != NULL){
      let &$(ti,tj,tk) = r;
      printf("\"(%d,%d,%d)\" -> ",si,sj,sk);
      printf("\"(%d,%d,%d)\";\n",ti,tj,tk);
    }
  }
}

static void rstate_dot(rstate_t rs) {
  printf("digraph g {\n");
//   Hashtable::iter(dot_pred_iter,rs->pred);
  Hashtable::iter(dot_pred_iter,rs->retn);
  printf("edge [style=bold]\n");
  Hashtable::iter(dot_retn_iter,rs->retn);
  printf("edge [style=dotted]\n");
  Hashtable::iter(dot_iter,rs->call);
  printf("}\n");
}

static int do_reconstruct = 1;

void point_to(Hashtable::table_t<earley_node_t,List::list_t<`a,`H>,`H> tbl,
              earley_node_t source,
              `a target) {

  let ptr = Hashtable::lookup_opt(tbl,source);
  if (ptr != NULL) {
    Hashtable::remove(tbl,source);
    Hashtable::insert(tbl,source,new List::List(target,*ptr));
  }
  else Hashtable::insert(tbl,source,List::list(target));
}

//PROB
$(weight_t,weight_t) add_weights(rstate_t rs, earley_node_t node, weight_t forward, weight_t inner) { //PROB
  let ptr = Hashtable::lookup_opt(rs->weights,node);                            //PROB
  let old_f = Semiring::one_weight;
  let old_i = Semiring::one_weight;
  if (ptr != NULL) {                                                            //PROB
    $(weight_t,weight_t)@y = *ptr;                                                    //PROB
    old_f = y->f0; old_i = y->f1;
    y->f0 = Semiring::add( y->f0, forward );                                    //PROB
    y->f1 = Semiring::add( y->f1, inner );                                      //PROB
  }                                                                             //PROB
  else Hashtable::insert(rs->weights,node,new $(forward,inner));                //PROB

  return $(old_f,old_i);
}                                                                               //PROB

$(unsigned int, unsigned int) *
get_bounds(Hashtable::table_t<earley_node_t,List::list_t<$(earley_node_opt_t,earley_node_t) @`H>,`H> retn,
	   dfa_t dfa, earley_node_t en, act_t nt);

/* Add an item to an Earley state.
   If the item has an automaton state that transitions to another state
   by epsilon, add items for those states too.
   Epsilons may be for CALLS to parse non-terminals or
   RETURNS from parsing non-terminals.
 */
void
push_closure(rstate_t rs,
	     const char ?input,
             unsigned int i,
             earley_item_t ei, // YHM: I think this should be an early node
			       // instead of an earley item for
			       // efficiency sake (to save allocations).
             const char ?reason,
             earley_node_opt_t back,
	     earley_node_opt_t up
             , weight_t forward, weight_t inner //PROB
             ) {

  let &$(s,backptr) = ei;
  let node = new $(s,backptr,i);
  let $(old_f,old_i) = add_weights(rs,node,forward,inner); //PROB
  if (back != NULL) {
    point_to(rs->pred,node,back);
    point_to(rs->retn,node,new $(up,back));
  }

  let es = Axarray::get(rs->estates,i);
  if (Set::member(es,ei)) {
    if (show_prog && show_prog_start <= i){
      let &$(new_f,new_i) = Hashtable::lookup(rs->weights, node);
      fprintf(stderr,"estates[%d]: (%d,%d,%s,%s -> [%s,%s] -> %s,%s) %s\n",i,ei->f0,ei->f1,
	      Semiring::print_weight(old_f),Semiring::print_weight(old_i),
	      Semiring::print_weight(forward),Semiring::print_weight(inner),
	      Semiring::print_weight(new_f),Semiring::print_weight(new_i),
	      reason);fflush(stderr);
    }
    return;
  }
  if (show_prog && show_prog_start <= i){
    fprintf(stderr,"estates[%d] += (%d,%d,%s,%s) %s\n",i,ei->f0,ei->f1,
	    Semiring::print_weight(forward),Semiring::print_weight(inner),reason);fflush(stderr);
  }
  Axarray::set(rs->estates,i,Set::insert(es,ei));

  /* Close under CALLS. We don't use the weight here. */
  let t = target(rs->dfa,s,callout_action()); //PROB
  if (t != 0) {
    point_to(rs->call,new $(t,i,i),node);
    push_closure(rs,input,i,new $(t,i),"(call)",NULL,NULL
                 ,forward,Semiring::one_weight //PROB
//                  ,mult(w, forward),Semiring::one_weight //PROB
                 );
  } 

  /* Close under REPEAT-DECR (special type of call). */
  let t = target(rs->dfa,s,repeat_decr_action());
  if (t != 0) {
    // Lookup and decrement repeat count
    let rc = decr_repeat_count(rs,s);
    // if zero, remove transition on repeat_final and continue.
    if (rc == 0){
      remove_repeat_count(rs,s);
      let t =  target(rs->dfa,s,repeat_final_action());
      /* Call push_closure again as if we started in this
	 state. ie. t replaces s. So, we reuse back and up. */
      push_closure(rs,input,i,new $(t,backptr),"(repeat-final)",back,up
		   ,forward,inner //PROB
		   );
      return;
    }
    // If non zero, continue as in call
    point_to(rs->call,new $(t,i,i),node);
    push_closure(rs,input,i,new $(t,i),"(repeat-decr)",NULL,NULL
		 ,forward,Semiring::one_weight //PROB
                 );
  }

  /* Close under REPEATS. Only works if target has *one* non-call target. */  
  let t = target(rs->dfa,s,repeat_action());
  if (t != 0) {
    /* 1. Retrieve the number from the Earley parse trail.*/

    // Find the non-term to which repeat is bound.
    // Note: after determinizing, possibly many calls from single
    // state, but shouldn't be any terminals (is this true?). So, we
    // will need to perform repeat for *all* nonterminals that appear.
    if (debug)
      fprintf(stderr,"Looking for non-CALL transition.\n");
    fflush(stderr);

    let nt_opt = first_action_after(rs->dfa,t,callout_action());
    if (!nt_opt){
      fprintf(stderr,"Error: repeat state does not transition on non-call.\n");
      return;
    }
    let repeater_nt = *nt_opt;
    if (debug)
      fprintf(stderr,"Repeat based on non terminal %s.\n",act2symb(repeater_nt,rs->as_table));
    // get the bounds (inclusive) of parsed non-terminal nt from the
    // Earley parse history.
    let bounds_opt = get_bounds(rs->retn,rs->dfa,node,repeater_nt);
    if (!bounds_opt){
      fprintf(stderr,"Error: bounds could not be find for non terminal %s.\n",
	      act2symb(repeater_nt,rs->as_table));
      return;
    }
    let &$(j,k) = (_@)bounds_opt;
    let num = atoi(substring(input,j,k-j+1));
    if (debug)
      fprintf(stderr,"Repeat encountered with n=%d.\n",num);

    /* 2. Build new DFA using retrieved number. */

    // Find the action of the repeated symbol.
    let s_repeatee = target(rs->dfa,t,repeater_nt);
    let nt_opt = first_action_after(rs->dfa,s_repeatee,0);
    if (!nt_opt){
      fprintf(stderr,"Error: repeatee state does not transition.\n");
      return;
    }
    let repeatee_nt = *nt_opt;
    if (debug)
      fprintf(stderr,"Repeat non terminal %s.\n",act2symb(repeatee_nt,rs->as_table));

    // Find the start state of the repeated DFA.
    let nt_start = target(rs->dfa,t,callout_action());
    let nt_final = target(rs->dfa,s_repeatee,repeatee_nt);
    // Construct chain of states that transition on repeatee_nt and each call
    // this DFA (nt_start). Chain has length "num". The chain ends
    // with the final state.
    let t_new = construct_repeat_dfa(rs->dfa,repeatee_nt,
				     repeat_decr_action(),nt_start,
				     repeat_final_action(), nt_final);
    set_repeat_count(rs,t_new,num);

    if (debug > 1){
      fprintf(stderr,"Printing DFA after unrolling repeat.\n");
      fa_dot_as_table = rs->as_table;
      dfa_dot(stderr,rs->dfa,fa_act2symb);
      fflush(stderr);
    }

    /* 3. Call push_closure again as if we started in this
       state. ie. t_new replaces s. So, we reuse back and up. */
    push_closure(rs,input,i,new $(t_new,backptr),"(repeat)",back,up
                 ,forward,inner //PROB
                 );
  }

  /* Close under RETURNS.  Use else, because a REPEAT state can't
     also be a final state. */
  else if (i != backptr // we parsed the empty string, RETURN handled by dfa already
      && dfa_is_final(rs->dfa,s)) {
    /* Some symbol is completed.
       es_back is the Earley state that CALLed the symbol. */
    let es_back = Axarray::get(rs->estates,backptr);
    let final_w = dfa_final_weight(rs->dfa,s);

    /* For every completed symbol... */
    for (let completed = Set::to_list(dfa_final_attrs(rs->dfa,s));
         completed != NULL; completed = completed->tl) {
      let symb_act = completed->hd;

      // don't perform a completion if the this is the final
      // state for the start symbol.
      if (symb_act == rs->start_act && backptr == 0)
	continue;

//       printf("... look at every DFA state in es_back...\n");
      /* ... look at every DFA state in es_back... */
      for (let es_back_list = Set::to_list(es_back);
           es_back_list != NULL;
           es_back_list = es_back_list->tl) {

        let &$(t,tbackptr) = es_back_list->hd;
        let ttarget = target(rs->dfa,t,symb_act);
// 	printf("... see if the DFA state did a CALL and RETURN if so.\n");
        /* ... see if the DFA state did a CALL and RETURN if so. */
        if (ttarget != 0) {
	  // Earley node w/ dot before symb.
	  let backnode = new $(t,tbackptr,backptr);
	  // Earley node w/ dot after symb.
          let retnode = new $(ttarget,tbackptr,i);
          let &$(backnode_forward,backnode_inner) = Hashtable::lookup(rs->weights,backnode); //PROB
	  fflush(stdout);
	  let symb = act2symb(symb_act,rs->as_table);
	  let w_m = mult(inner, final_w);
          push_closure(rs,input,i,new $(ttarget,tbackptr),
                       aprintf("(return %s)",symb),
                       backnode, node
                       ,mult( w_m, backnode_forward), //PROB
		       mult( w_m, backnode_inner) //PROB
                       );
        }
      }
    }
  }
}

//
// function : derivation
// returns  : 1 if ambiguous, 0 otherwise
//
struct Buffer::t *b = NULL;

// int derivation(Hashtable::table_t<earley_node_t,List::list_t<earley_node_t>,`H> pred,
//                Hashtable::table_t<earley_node_t,List::list_t<$(earley_node_t,earley_node_t) @`H>,`H> retn,
//                earley_node_t ei,
//                const char ?input,
//                dfa_t dfa) {

//   let retcode = 0;
//   let maybe_retn = Hashtable::lookup_opt(retn,ei);
//   if (maybe_retn != NULL) {
//     let len = List::length(*maybe_retn);
//     if (len > 1){
//       retcode = 1;
//       fprintf(stderr,"Ambiguous parse, (%d,%d,%d) has multiple RETURNs\n",
//               ei->f0,ei->f1,ei->f2);
//       for (let bf = *maybe_retn; bf; bf = bf->tl) {
//         fprintf(stderr,"(%d,%d,%d)\n",bf->hd->f0->f0,bf->hd->f0->f1,bf->hd->f0->f2);
//       }
//       fflush(stderr);
//     }
//     // only print one derivation even if > 1
//     if (len > 0) {
//       let l = Buffer::length(b);
//       if (l > 0) {
//         // DOESN'T WORK -- CYCLONE BUG
// //        let z = Buffer::extract(b);
// //        char maybe_brace = z[l-1];
// //        Buffer::restore(b,z);
//         // INEFFICIENT WORKAROUND
//         let z = Buffer::contents(b);
//         char maybe_brace = z[l-1];
//         if (maybe_brace == '}')
//           Buffer::add_string(b,",");
//       }
//       let &$(x,i,j) = (*maybe_retn)->hd->f0;
//       // x is state, parse started at i, finished at j
//       let completed = Set::to_list(dfa_final_attrs(dfa,x));
//       if (completed != NULL) {
// 	// YHM: why don't we warn/report whether completed has more than one element?
//         let attr = completed->hd;
//         Buffer::add_string(b,
//                            aprintf("<t s=\"%s\" l=\"%d\" r=\"%d\">",
//                                    act2symb(attr),i,j));
//       }
//       else
//         // should never happen
//         Buffer::add_string(b,
//                            aprintf("<t s=\"???\" l=\"%d\" r=\"%d\">",
//                                    i,j));
//       //        printf(" <- ??? [%d,%d]\n",i,j);

//       let rc = derivation(pred,retn,(*maybe_retn)->hd->f0,input,dfa);
//       retcode = retcode || rc;
//       Buffer::add_string(b,"</t>");
//     }
//   }

//   let before_opt = Hashtable::lookup_opt(pred,ei);
//   // YHM: why return here?
//   if (before_opt == NULL) return retcode;

//   let before = *before_opt;
//   let len = List::length(before);

//   if (len > 1) {
//     retcode = 1;
//     fprintf(stderr,"Ambiguous parse, (%d,%d,%d) has multiple predecessors\n",
//             ei->f0,ei->f1,ei->f2);

//     for (let bf = before; bf; bf = bf->tl) {
//       fprintf(stderr,"(%d,%d,%d)\n",bf->hd->f0,bf->hd->f1,bf->hd->f2);
//     }
//     fflush(stderr);
//   }
//   if (len > 0) {
//     //    fprintf(stderr,"following (%d,%d,%d)\n",before->hd->f0,before->hd->f1,before->hd->f2);
//     // YHM: nearly a tail call.
//     let rc = derivation(pred,retn,before->hd,input,dfa);
//     retcode = retcode || rc;
//   }

//   // YHM: Dead code?
//   if (maybe_retn == NULL) {
//     // did not get here by RETURN, so we read a terminal, print it
//     let i = ei->f2;
//     //    printf("%c",input[i-1]);
//   }
//   else {
//     // got here by a RETURN, therefore we just parsed a nonterminal, print it
//     let &$(x,i,j) = (*maybe_retn)->hd;
//     // x is state, parse started at i, finished at j
//     let completed = Set::to_list(dfa_final_attrs(dfa,x));
//     if (completed != NULL) {
//       let attr = completed->hd;
//       //      printf(" %s ",act2symb(attr));
//     }
//     else
//       // should never happen
//       0;
//       //      printf(" ??? ");
//   }
//   // YHM: End ead code.

//   return retcode;
// }


// Retrieve bounds of previously-appearing non terminal within currently parsing RHS.
// If appears multiple times, only returns one answer.
// If can't be found, return NULL;
$(unsigned int, unsigned int) *
get_bounds(Hashtable::table_t<earley_node_t,List::list_t<$(earley_node_opt_t,earley_node_t) @`H>,`H> retn,
	   dfa_t dfa, earley_node_t en, act_t nt){

  List::list_t<parse_forest_t> derivations = NULL;
  let maybe_links = Hashtable::lookup_opt(retn,en);
  if (maybe_links != NULL) {

    // OPTIMIZATION: we could use a loop instead of recursion if there
    // is only one link.

    // Search all predecessor paths
    for (let xs = *maybe_links; xs; xs = xs->tl) {
      let &$(retn_link,pred_link) = xs->hd;

      if (retn_link){
	let &$(x,i,j) = (_@)retn_link;
	if (Set::member(dfa_final_attrs(dfa,x),nt))
	  // found it
	  return new $(i,j);
      }

      // keep looking -- recurse.
      let b = get_bounds(retn, dfa, pred_link, nt);
      if (b) return b;

    }
  }

  return NULL;
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// YHM: (current) invariant: always called with final state in early item ei.

parse_tree_t
derivation_redux(rstate_t rs,
		 const char ?input,
		 earley_node_t en);

// List::List_t<parse_forest_t> prefix_all(parse_tree_t,List::List_t<parse_forest_t>);
// imperative update of fs.
void prefix_all_imp(parse_tree_t t,List::list_t<parse_forest_t> fs){
  for (;fs;fs = fs->tl){
    fs->hd = new List::List(t,fs->hd);
  }
}

List::list_t<parse_forest_t>
derivation_horizontal(rstate_t rs,
		      const char ?input,
		      earley_node_t en){

  List::list_t<parse_forest_t> derivations = NULL;
  let maybe_links = Hashtable::lookup_opt(rs->retn,en);
  if (maybe_links != NULL) {

    // Compute all derivations.
    for (let xs = *maybe_links; xs; xs = xs->tl) {
      let &$(retn_link,pred_link) = xs->hd;

      let pred_derivations = derivation_horizontal(rs,input, pred_link);
      if (retn_link){
	let child_tree = derivation_redux(rs,input, retn_link);
	// prefix all forests of pred_derivations with child_tree.
	prefix_all_imp(child_tree,pred_derivations);
      }

      derivations = List::append(derivations,pred_derivations);
    }

  }else
    // A single, empty derivation.
    derivations = List::list(NULL);


  //////////// Debug Code ///////////
//   if (derivations != NULL && derivations->tl != NULL) {
//     // More than one derivation, so ambiguous.
//     fprintf(stderr,"Ambiguous parse, (%d,%d,%d) has multiple derivations\n",
// 	    en->f0,en->f1,en->f2);
//     fflush(stderr);
//   }
  //////////////////////////////////

  return derivations;
}

parse_tree_t
derivation_redux(rstate_t rs,
		 const char ?input,
		 earley_node_t en) {
  let &$(x,i,j) = en;
  string_t name;
  let completed = Set::to_list(dfa_final_attrs(rs->dfa,x));
  if (completed) {
    // pick any attribute (we choose the first)
    // TODO: use *all* attributes.
    let attr = completed->hd;
    name = act2symb(attr,rs->as_table);
  }else // it must be the final state of the dfa:
  	name = "TOP";

  parse_tree_t tree;

  let h_derivations = derivation_horizontal(rs,input,en);
  let &$(w_forward,w_inner) = Hashtable::lookup(rs->weights, en);
  // distinguish ambiguous from unamb. parses.
  if (h_derivations == NULL){
    // YHM: can len == 0 ? If so, how did entry ever get created?
    // Yes, because it can be a string of terminals.
    fprintf(stderr,"No derivations returned.\n");
    tree = new NonTerm(name,i,j,w_forward,NULL);
  } else if(h_derivations->tl == NULL){
    // Unambiguous
    tree = new NonTerm(name,i,j,w_forward,h_derivations->hd);
  } else {
     // Ambiguous
    tree = new SharedNonTerm(name,i,j,w_forward,h_derivations);
  }

  return tree;
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

typedef Graph::graph_t<earley_node_t> egraph_t;
egraph_t *ggg;
void cvti(earley_node_t s,List::list_t<earley_node_t> ts) {
  for (; ts; ts = ts->tl)
    *ggg = Graph::add_edge(*ggg,s,ts->hd);
}
egraph_t cvt(Hashtable::table_t<earley_node_t,List::list_t<earley_node_t>,`H> tbl) {
  ggg = new Graph::empty(earley_node_cmp);
  Hashtable::iter(cvti,tbl);
  return *ggg;
}

/* Earley recognizer.
   Returns 1 if input is recognized, 0 otherwise.
 */
$(dfa_t,Set::set_t<st_t>,symb_info_t) compile(grammar_t grm, rule_t r) {
  init_maybe_empty(grm);
  let $(dfa,dfa_final,symb_info) = rule2earley(grm,r);
  if (debug > 1){
    fa_dot_as_table = symb_info->action_symb_table;
    dfa_dot(stderr,dfa,fa_act2symb);
  }
  fflush(stderr);

  return $(dfa,dfa_final,symb_info);
}

//parse_forest_t recognize_frag(dfa_t dfa, symb_info_t symb_info, 
//			      const char?`H symb_name,
//			      const char ?input, int show_progress) {
//  
//  show_prog = show_progress;
//
//  /* Keep track of parse trees */
//  let
//    pred = Hashtable::create(11,earley_node_cmp,earley_node_hash);
//  let
//    retn = Hashtable::create(11,earley_node_cmp,earley_node_hash);
//  let
//    call = Hashtable::create(11,earley_node_cmp,earley_node_hash);
//  let                                                                 //PROB
//    weights = Hashtable::create(11,earley_node_cmp,earley_node_hash); //PROB
//  let
//    rcounts = Hashtable::create(11,st_cmp,st_hash);
//
//  let r = symb2snf(symb_name,symb_info);
//  if (!r){
//    fprintf(stderr,"Invalid symbol (%s) given to recognize_frag.\n",symb_name);
//    return NULL;
//  }
//  let $(symb_start, symb_final) = *r;
//
//  /* Initialize the sequence of Earley states with s0 */
//  let estates = /* Earley states  s0, s1, s2, ... */
//    Axarray::create(11,Set::empty(earley_item_cmp));
//  let earley_item_0 = new $(symb_start,0); // symb_start is initial state of symb in dfa, 0 is i in si
//  let rs = new rstate {dfa,symb_info,symb2act(symb_name,symb_info),estates,pred,retn,call
//                       ,weights //PROB
//		       , rcounts
//  };
//  push_closure(rs,
//	       input,
//               0,
//               earley_item_0,
//               "(initial)",
//               NULL,NULL
//               ,Semiring::one_weight,Semiring::one_weight //PROB
//               );
//
//  /* Scan the input */
//  fprintf(stderr,"Scanning the input.\n");
//  let i = 0;
//  for (let estate_i = Axarray::get(estates,0); !Set::is_empty(estate_i); estate_i = Axarray::get(estates,++i)) {
//
//    if (show_prog && show_prog_start <= i){
//      fprintf(stderr,"input[%d]==%s\n",i,cs_char_escape(input[i]));fflush(stderr);
//    }
//
//    for (let si_list = Set::to_list(estate_i);
//         si_list != NULL;
//         si_list = si_list->tl) {
//
//      let &$(state,parent) = si_list->hd;
//      let $(k,w) = target_w_weight(dfa,state,input[i]); //PROB
//      if (k != 0) {// where k==0 indicates there is no valid target.
//	let enode = new $(state,parent,i);
//	let &$(forward,inner) = Hashtable::lookup(rs->weights,enode);
//        push_closure(rs,input,i+1,new $(k,parent),"(input)",enode,NULL
//                     ,Semiring::mult(w, forward), Semiring::mult(w, inner) //PROB
//                     );
//      }
//    }
//  }
//
//  // Search for last final state(s)
//  let derivations = NULL;
//  for (; i >= 0 && derivations == NULL; i--){
//    for (let si_list = Set::to_list(Axarray::get(estates,i));
//	 si_list != NULL;
//	 si_list = si_list->tl) {
//
//      let &$(state,parent) = si_list->hd;
//      if (Set::member(symb_final,state) && parent == 0) {
//	let en = new $(state,parent /*== 0*/,i);
//	let h_derivations = derivation_horizontal(rs,input,en);
//	let &$(forward,_) = Hashtable::lookup(rs->weights,en);
//	parse_tree_t tree;
//	if (h_derivations == NULL){
//	  tree = new NonTerm(symb_name,0,i,forward,NULL);
//	} else if(h_derivations->tl == NULL){
//	  tree = new NonTerm(symb_name,0,i,forward,h_derivations->hd);
//	} else {
//	  tree = new SharedNonTerm(symb_name,0,i,forward,h_derivations);
//	}
//	derivations = new List::List(tree, derivations);
//      }
//    }
//  }
//  return derivations;
//}

$(int,int) recognize(dfa_t dfa, symb_info_t symb_info, Set::set_t<st_t> dfa_final, 
		     const char ?input, int show_progress) {

  show_prog = show_progress;

  /* Keep track of parse trees */
  let
    pred = Hashtable::create(11,earley_node_cmp,earley_node_hash);
  let
    retn = Hashtable::create(11,earley_node_cmp,earley_node_hash);
  let
    call = Hashtable::create(11,earley_node_cmp,earley_node_hash);
  let                                                                 //PROB
    weights = Hashtable::create(11,earley_node_cmp,earley_node_hash); //PROB
  let
    rcounts = Hashtable::create(11,st_cmp,st_hash);

  /* Initialize the sequence of Earley states with s0 */
  let estates = /* Earley states  s0, s1, s2, ... */
    Axarray::create(11,Set::empty(earley_item_cmp));
  let earley_item_0 = new $(1,0); // 1 is initial state of dfa, 0 is i in si
  let rs = new rstate {dfa,symb_info->action_symb_table,-1,estates,pred,retn,call
                       ,weights //PROB
		       ,rcounts
  };
  push_closure(rs,
	       input,
               0,
               earley_item_0,
               "(initial)",
               NULL,NULL
               ,Semiring::one_weight,Semiring::one_weight //PROB
               );

  /* Scan the input */
  fprintf(stderr,"Scanning the input.\n");
  let input_len = strlen(input);
  for (let i = 0; i < input_len; i++) {

    if (show_prog && show_prog_start <= i){
      fprintf(stderr,"input[%d]==%s\n",i,cs_char_escape(input[i]));fflush(stderr);
    }

    for (let si_list = Set::to_list(Axarray::get(estates,i));
         si_list != NULL;
         si_list = si_list->tl) {

      let &$(state,parent) = si_list->hd;
      let $(k,w) = target_w_weight(dfa,state,input[i]); //PROB
      if (k != 0) {// where k==0 indicates there is no valid target.
	let enode = new $(state,parent,i);
	let &$(forward,inner) = Hashtable::lookup(rs->weights,enode);
	if (show_prog && show_prog_start <= i){
	  printf("Weights are w=%s, forw=%s, inn=%s.\n",
		 Semiring::print_weight(w),Semiring::print_weight(forward),
		 Semiring::print_weight(inner));
	}
        push_closure(rs,input,i+1,new $(k,parent),"(input)",enode,NULL
                     ,Semiring::mult(w, forward), Semiring::mult(w, inner) //PROB
                     );
      }
    }
  }

  /* See if we ended up in a final state */
  /*
  fprintf(stderr,"Looking in estates[%d] for:",input_len);
  for (let fs = Set::to_list(dfa_final); fs != NULL; fs = fs->tl)
    fprintf(stderr," (%d,0)",fs->hd);
  fprintf(stderr,"\n");fflush(stderr);

  printf("AAs\n");
  if (debug)
    rstate_dot(rs);
  //  Graph::print(stdout,cvt(pred),earley_node_pr);
  printf("BB\n");
  //  Graph::print(stdout,cvt(retn),earley_node_pr);
  */
  let partial_parses = 0;
  let complete_parses = 0;
  for (let slast_list = Set::to_list(Axarray::get(estates,input_len));
       slast_list != NULL;
       slast_list = slast_list->tl) {
    partial_parses++;
    let &$(state,parent) = slast_list->hd;
    if (Set::member(dfa_final,state) && parent == 0) {
//       b = Buffer::create(1024);
//       derivation(pred,retn,new $(state,parent /*== 0*/,input_len),input,dfa);
//       printf("Input:\n%s\nParse:\n",input);
//       printf("%s\n",Buffer::contents(b));

      complete_parses++;

      if (do_reconstruct){
	let en = new $(state,parent /*== 0*/,input_len);
	let derivation_tree = derivation_redux(rs,input,en);
	if (debug) {
	  printf("Input:\n%s\nLeftmost tree:\n",input);
	  print_LT(derivation_tree,-1);
	  printf("\nRightmost tree:\n");
	  print_RT(derivation_tree,-1);
	  printf("\n");
	}

	last_derivation_tree = derivation_tree;
	let &$(w_forward,w_inner) = Hashtable::lookup(rs->weights, en);
	if ( !Semiring::check_nonzero(w_forward) )
	  printf("Weight: ~Zero.\n");
	else {
	  printf("Weight: %s\n",Semiring::print_weight(w_forward));
	}
      }
    }
  }
  return $(complete_parses,partial_parses);
}

const char ?yk_inputs =
"EPSILON 0\n"
"\\000\t1\n"
"\\001\t2\n"
"\\002\t3\n"
"\\003\t4\n"
"\\004\t5\n"
"\\005\t6\n"
"\\006\t7\n"
"\\007\t8\n"
"\\008\t9\n"
"\\t\t10\n"
"\\n\t11\n"
"\\011\t12\n"
"\\012\t13\n"
"\\013\t14\n"
"\\014\t15\n"
"\\015\t16\n"
"\\016\t17\n"
"\\017\t18\n"
"\\018\t19\n"
"\\019\t20\n"
"\\020\t21\n"
"\\021\t22\n"
"\\022\t23\n"
"\\023\t24\n"
"\\024\t25\n"
"\\025\t26\n"
"\\026\t27\n"
"\\027\t28\n"
"\\028\t29\n"
"\\029\t30\n"
"\\030\t31\n"
"\\031\t32\n"
"SPACE\t33\n"
"!\t34\n"
"\\\"\t35\n"
"#\t36\n"
"$\t37\n"
"%\t38\n"
"&\t39\n"
"\\'\t40\n"
"(\t41\n"
")\t42\n"
"*\t43\n"
"+\t44\n"
",\t45\n"
"-\t46\n"
".\t47\n"
"/\t48\n"
"0\t49\n"
"1\t50\n"
"2\t51\n"
"3\t52\n"
"4\t53\n"
"5\t54\n"
"6\t55\n"
"7\t56\n"
"8\t57\n"
"9\t58\n"
":\t59\n"
";\t60\n"
"<\t61\n"
"=\t62\n"
">\t63\n"
"?\t64\n"
"@\t65\n"
"A\t66\n"
"B\t67\n"
"C\t68\n"
"D\t69\n"
"E\t70\n"
"F\t71\n"
"G\t72\n"
"H\t73\n"
"I\t74\n"
"J\t75\n"
"K\t76\n"
"L\t77\n"
"M\t78\n"
"N\t79\n"
"O\t80\n"
"P\t81\n"
"Q\t82\n"
"R\t83\n"
"S\t84\n"
"T\t85\n"
"U\t86\n"
"V\t87\n"
"W\t88\n"
"X\t89\n"
"Y\t90\n"
"Z\t91\n"
"[\t92\n"
"\\\t93\n"
"]\t94\n"
"^\t95\n"
"_\t96\n"
"`\t97\n"
"a\t98\n"
"b\t99\n"
"c\t100\n"
"d\t101\n"
"e\t102\n"
"f\t103\n"
"g\t104\n"
"h\t105\n"
"i\t106\n"
"j\t107\n"
"k\t108\n"
"l\t109\n"
"m\t110\n"
"n\t111\n"
"o\t112\n"
"p\t113\n"
"q\t114\n"
"r\t115\n"
"s\t116\n"
"t\t117\n"
"u\t118\n"
"v\t119\n"
"w\t120\n"
"x\t121\n"
"y\t122\n"
"z\t123\n"
"{\t124\n"
"|\t125\n"
"}\t126\n"
"~\t127\n"
"\\127\t128\n"
"\\128\t129\n"
"\\129\t130\n"
"\\130\t131\n"
"\\131\t132\n"
"\\132\t133\n"
"\\133\t134\n"
"\\134\t135\n"
"\\135\t136\n"
"\\136\t137\n"
"\\137\t138\n"
"\\138\t139\n"
"\\139\t140\n"
"\\140\t141\n"
"\\141\t142\n"
"\\142\t143\n"
"\\143\t144\n"
"\\144\t145\n"
"\\145\t146\n"
"\\146\t147\n"
"\\147\t148\n"
"\\148\t149\n"
"\\149\t150\n"
"\\150\t151\n"
"\\151\t152\n"
"\\152\t153\n"
"\\153\t154\n"
"\\154\t155\n"
"\\155\t156\n"
"\\156\t157\n"
"\\157\t158\n"
"\\158\t159\n"
"\\159\t160\n"
"\\160\t161\n"
"\\161\t162\n"
"\\162\t163\n"
"\\163\t164\n"
"\\164\t165\n"
"\\165\t166\n"
"\\166\t167\n"
"\\167\t168\n"
"\\168\t169\n"
"\\169\t170\n"
"\\170\t171\n"
"\\171\t172\n"
"\\172\t173\n"
"\\173\t174\n"
"\\174\t175\n"
"\\175\t176\n"
"\\176\t177\n"
"\\177\t178\n"
"\\178\t179\n"
"\\179\t180\n"
"\\180\t181\n"
"\\181\t182\n"
"\\182\t183\n"
"\\183\t184\n"
"\\184\t185\n"
"\\185\t186\n"
"\\186\t187\n"
"\\187\t188\n"
"\\188\t189\n"
"\\189\t190\n"
"\\190\t191\n"
"\\191\t192\n"
"\\192\t193\n"
"\\193\t194\n"
"\\194\t195\n"
"\\195\t196\n"
"\\196\t197\n"
"\\197\t198\n"
"\\198\t199\n"
"\\199\t200\n"
"\\200\t201\n"
"\\201\t202\n"
"\\202\t203\n"
"\\203\t204\n"
"\\204\t205\n"
"\\205\t206\n"
"\\206\t207\n"
"\\207\t208\n"
"\\208\t209\n"
"\\209\t210\n"
"\\210\t211\n"
"\\211\t212\n"
"\\212\t213\n"
"\\213\t214\n"
"\\214\t215\n"
"\\215\t216\n"
"\\216\t217\n"
"\\217\t218\n"
"\\218\t219\n"
"\\219\t220\n"
"\\220\t221\n"
"\\221\t222\n"
"\\222\t223\n"
"\\223\t224\n"
"\\224\t225\n"
"\\225\t226\n"
"\\226\t227\n"
"\\227\t228\n"
"\\228\t229\n"
"\\229\t230\n"
"\\230\t231\n"
"\\231\t232\n"
"\\232\t233\n"
"\\233\t234\n"
"\\234\t235\n"
"\\235\t236\n"
"\\236\t237\n"
"\\237\t238\n"
"\\238\t239\n"
"\\239\t240\n"
"\\240\t241\n"
"\\241\t242\n"
"\\242\t243\n"
"\\243\t244\n"
"\\244\t245\n"
"\\245\t246\n"
"\\246\t247\n"
"\\247\t248\n"
"\\248\t249\n"
"\\249\t250\n"
"\\250\t251\n"
"\\251\t252\n"
"\\252\t253\n"
"\\253\t254\n"
"\\254\t255\n"
"\\255\t256\n"
""
;


// x Add report of "valid parse in progress"
// x Add command to shell: "amb?"
// Does FSM need symbols? I think it would be much simpler if we dropped the symbols names
// and just used numbers.
