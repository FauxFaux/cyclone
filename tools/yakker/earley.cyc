/* (So far incomplete) Earley parser */

#include <string.h>
#include <core.h>
#include <list.h>
#include "bnf.h"
#include "fa.h"
#include "axarray.h"
#include "cs.h"
#include "analyze.h"

#include "nfa_eager.h"
using Nfa_eager;

namespace Earley;

/* The alphabet of the automaton is the set of terminals and
   non-terminals.  Assume for now that cs_t can represent a set of
   terminals and non-terminals.  Number our new actions starting
   at 256.

   NB: there is a max number of actions hard-coded in cs.h.
*/

static unsigned int symb_action_counter = 257;
static struct Hashtable::Table<str_t,act_t> *symb_action_table = NULL;
static struct Hashtable::Table<act_t,str_t> *action_symb_table = NULL;
static act_t callout_action() {
  return 256;
}
static act_t new_action() {
  let a = symb_action_counter++;
  if (a > MAXACTION) {
    fprintf(stderr,"Internal error: maximum number of actions exceeded\n");
    fflush(stderr);
    exit(1);
  }
  return a;
}
static cs_t callout_cs() {
  return cs_singleton(callout_action());
}
const char ?act2symb(act_t act) {
  let sopt = Hashtable::lookup_opt(action_symb_table,act);
  if (sopt == NULL || *sopt == NULL) return NULL;
  else return **sopt;
}
static act_t symb2act(const char ?`H symb) {
  if (symb_action_table == NULL)
    symb_action_table =
      Hashtable::create(11,strptrcmp,Hashtable::hash_stringptr);
  if (action_symb_table == NULL) {
    action_symb_table =
      Hashtable::create(11,st_cmp,st_hash);
    Hashtable::insert(action_symb_table,callout_action(),new "CALL");
  }
  let symbptr = new symb;
  let aptr = Hashtable::lookup_opt(symb_action_table,symbptr);
  if (aptr != NULL) return *aptr;
  let a = new_action();
  fprintf(stderr,"Symbol %s has action 0x%x\n",symb,a);
  Hashtable::insert((_@)symb_action_table,symbptr,a);
  Hashtable::insert((_@)action_symb_table,a,symbptr);
  return a;
}
static cs_t consume_symb_cs(const char ?`H symb) {
  return cs_singleton(symb2act(symb));
}

/* An automaton state and parent pointer */
typedef $(st_t,unsigned int) @earley_item_t;

static int earley_item_cmp(earley_item_t a,earley_item_t b) {
  let $(ai,aj) = *a;
  let $(bi,bj) = *b;
  let c = Core::intcmp(ai,bi);
  if (c) return c;
  return Core::intcmp(aj,bj);
}

typedef $(st_t,unsigned int,unsigned int) @earley_node_t;
typedef $(st_t,unsigned int,unsigned int) *earley_node_opt_t;
typedef  Hashtable::table_t<earley_item_t,List::list_t<earley_node_t,`r>,`r> earley_graph_t<`r>;
static int earley_node_cmp(earley_node_t a,earley_node_t b) {
  let $(ai,aj,ak) = *a;
  let $(bi,bj,bk) = *b;
  let c = Core::intcmp(ai,bi);
  if (c) return c;
  c = Core::intcmp(aj,bj);
  if (c) return c;
  return Core::intcmp(ak,bk);
}

static int earley_node_hash(earley_node_t a) {
  let $(ai,aj,ak) = *a;
  /* All ai, aj, and ak are ints starting at 0, ai maxes out at the
     number of states, aj and ak max out at the input length.
     TODO: see what typical sizes are for these and adjust the
     hash function accordingly.
  */
  return ai ^ (aj+ak);
}

typedef Set::set_t<earley_item_t> earley_state_t;

/* Create the control NFA for Earley parsing.
   The rule specifies what to parse.
   Symbols from the grammar will be used if needed, otherwise ignored.
   The symb_st table maps used symbols to states and should be
   initialized to the empty table.
   On return the table will hold mappings for all symbols encountered.
   */
$(st_t,st_t,st_t)
  merge(Hashtable::table_t<str_t,st_t> symb_st,
        grammar_t grm,
        rule_t r);

st_t rule2earley0(Hashtable::table_t<str_t,st_t> symb_st,
                  grammar_t grm,
                  rule_t r) {
  switch (r->r) {
  case &Symb(x,_):
    let xptr = new x;
    st_t x_start; /* start state of the NFA for the symbol */
    if (!Hashtable::try_lookup(symb_st,xptr,&x_start)) {
      /* Symbol has not been converted to NFA yet */
      Rule_t x_rule = lookup_symbol(grm, x);
      if (!x_rule) {
	warn("missing definition for %s in rule2earley()\n",x);
	return mklit("");
      }
      /* Allocate a start state for the symbol.  Do this before
         converting to NFA in case the symbol is defined recursively. */
      let s = nfa_fresh_state(); let f = nfa_fresh_state(); final(s,f);
      Hashtable::insert(symb_st,xptr,s);
      let $(s_body,f_body,_) = merge(symb_st,grm,x_rule);
      final(s,f_body); // merge does not do this
      etrans(s,s_body);
      x_start = s;
    }
    let s = nfa_fresh_state();
    let s2 = nfa_fresh_state();
    let f = nfa_fresh_state(); final(s,f);
    action(s,callout_cs(),x_start);
    etrans(s,s2);
    action(s2,consume_symb_cs(x),f);
    /* If the symbol can derive the empty string make sure this gets
       reflected into the automaton --- effectively doing a RETURN in
       the automaton instead of the Earley evaluator itself */
    if (empty_rule(SYMB(x)))
      etrans(s2,f);
    return s;
  case &Lit(x):
    return mklit(x);
  case &CharRange(low,high):
    if (low > high) {
      internal_err("invalid character range in rule2earley()\n");
      return mklit("");
    }
    return mkact(cs_range(low,high+1));
  case &Opt(r2):
    let s2 = rule2earley0(symb_st,grm,r2); let s3 = mklit("");
    return mkalt(s2,s3);
  case &Seq(r2,r3):
    let s2 = rule2earley0(symb_st,grm,r2); let s3 = rule2earley0(symb_st,grm,r3);
    return mkseq(s2,s3);
  case &Alt(r2,r3):
    let s2 = rule2earley0(symb_st,grm,r2); let s3 = rule2earley0(symb_st,grm,r3);
    return mkalt(s2,s3);
  case &Rcount(_,r2):
    /* Conservative approximation */
    warn_repeat();
    fallthru(r2);
  case &Star(0,&Infinity,r2):
    let s2 = rule2earley0(symb_st,grm,r2);
    return mkstar(s2);
  case &Star(m,i as &Infinity,r2):
    let r_seq = SEQ(r2,STAR(m-1,i,r2));
    return rule2earley0(symb_st,grm,r_seq);
  case &Star(0,&Num(0),r2):
    return mklit("");

  case &Star(0,&Num(n),r2):
    let r_opt = OPT(SEQ(r2,STAR(0, new Num(n-1),r2)));
    return rule2earley0(symb_st,grm,r_opt);
  case &Star(m,&Num(n),r2):
    if (m > n) return mklit("");
    let r_seq = SEQ(r2,STAR(m-1, new Num(n-1),r2));
    return rule2earley0(symb_st,grm, r_seq);

  case &Hash(0,N,r2):
    // same as [ r2 *{N-1}(commas r2) ]
    return rule2earley0(symb_st,grm,
                        OPT(SEQ(r2,STAR(0,minus_one(N),SEQ(commas(),r2)))));
  case &Hash(m,N,r2):
    // same as r2 {m-1}*{N-1}(commas r2)
    return rule2earley0(symb_st,grm,
                        SEQ(r2,STAR(m-1,minus_one(N),SEQ(commas(),r2))));
  case &Prose(_):
    warn("Prose not supported in rule2earley()\n");
    return mklit("");
  case &Minus(_,_):
    warn("Minus not supported in rule2earley()\n");
    return mklit("");
  }
}

$(st_t,st_t,st_t)
  merge(Hashtable::table_t<str_t,st_t> symb_st,
        grammar_t grm,
        rule_t r) {
  switch (r->r) {
  case &Symb(x,_):
    let xptr = new x;
    st_t x_start; /* start state of the NFA for the symbol */
    if (!Hashtable::try_lookup(symb_st,xptr,&x_start)) {
      /* Symbol has not been converted to NFA yet */
      Rule_t x_rule = lookup_symbol(grm, x);
      if (!x_rule) {
	warn("missing definition for %s in merge()\n",x);
	return merge(symb_st,grm,LIT(""));
      }
      /* Allocate a start state for the symbol.  Do this before
         converting to NFA in case the symbol is defined recursively. */
      let s = nfa_fresh_state(); let f = nfa_fresh_state();
      Hashtable::insert(symb_st,xptr,s);
      let $(s_body,f_body,_) = merge(symb_st,grm,x_rule);
      // need e_body too???
      final(s,f_body); // merge does not do this
      etrans(s,s_body);
      x_start = s;
    }
    let s = nfa_fresh_state();
    let s2 = nfa_fresh_state();
    let e = nfa_fresh_state();
    let f = nfa_fresh_state();
    action(s,EPSILON,x_start);
    etrans(s,s2);
    action(s2,consume_symb_cs(x),f);
    /* If the symbol can derive the empty string make sure this gets
       reflected into the automaton --- effectively doing a RETURN in
       the automaton instead of the Earley evaluator itself */
    if (empty_rule(SYMB(x)))
      etrans(s2,e);
    return $(s,f,e);
  case &Lit(x):
    if (!strcmp(x,"")) {
      let s = nfa_fresh_state();
      let f = nfa_fresh_state();
      let e = nfa_fresh_state();
      etrans(s,e);
      return $(s,f,e);
    }
    else {
      let s = mklit(x);
      let f = get_final(s);
      let e = nfa_fresh_state();
      return $(s,f,e);
    }
  case &CharRange(low,high):
    if (low > high) {
      internal_err("invalid character range in merge()\n");
      let s = nfa_fresh_state();
      let f = nfa_fresh_state();
      return $(s,f,s);
    }
    else {
      let s = mkact(cs_range(low,high+1));
      let f = get_final(s);
      let e = nfa_fresh_state();
      return $(s,f,s);
    }
  case &Opt(r2):
    let s = nfa_fresh_state();
    let e = nfa_fresh_state();
    let $(s2,f2,e2) = merge(symb_st,grm,r2);
    etrans(s,s2);
    action(s,EPSILON,e);
    etrans(e2,e);
    return $(s,f2,e);
  case &Seq(r2,r3):
    let s = nfa_fresh_state();
    let f = nfa_fresh_state();
    let e = nfa_fresh_state();
    let $(s2,f2,e2) = merge(symb_st,grm,r2);
    let $(s3,f3,e3) = merge(symb_st,grm,r3);
    let scall = rule2earley0(symb_st,grm,r3);
    let fcall = get_final(scall);
    etrans(s,s2);
    etrans(f2,scall);
    etrans(e2,s3);
    etrans(f3,f);
    etrans(fcall,f);
    etrans(e3,e);
    return $(s,f,e);
  case &Alt(r2,r3):
    let s = nfa_fresh_state();
    let f = nfa_fresh_state();
    let e = nfa_fresh_state();
    let $(s2,f2,e2) = merge(symb_st,grm,r2);
    let $(s3,f3,e3) = merge(symb_st,grm,r3);
    etrans(s,s2);
    action(s,EPSILON,s3);
    etrans(f2,f);
    etrans(f3,f);
    etrans(e2,e);
    etrans(e3,e);
    return $(s,f,e);
  case &Rcount(_,r2):
    /* Conservative approximation */
    warn_repeat();
    fallthru(r2);
  case &Star(0,&Infinity,r2):
    let s = nfa_fresh_state();
    let f = nfa_fresh_state();
    let e = nfa_fresh_state();
    let $(s2,f2,e2) = merge(symb_st,grm,r2);
    let scall = rule2earley0(symb_st,grm,r2);
    let fcall = get_final(scall);
    etrans(s,s2);
    action(s,EPSILON,e);
    etrans(e2,s2);
    action(e2,EPSILON,e);
    etrans(f2,scall);
    action(f2,EPSILON,f);
    etrans(fcall,scall);
    action(fcall,EPSILON,f);
    return $(s,f,e);
  case &Star(m,i as &Infinity,r2):
    let r_seq = SEQ(r2,STAR(m-1,i,r2));
    return merge(symb_st,grm,r_seq);
  case &Star(0,&Num(0),r2):
    return merge(symb_st,grm,LIT(""));
  case &Star(0,&Num(n),r2):
    let r_opt = OPT(SEQ(r2,STAR(0, new Num(n-1),r2)));
    return merge(symb_st,grm,r_opt);
  case &Star(m,&Num(n),r2):
    if (m > n) return merge(symb_st,grm,LIT(""));
    let r_seq = SEQ(r2,STAR(m-1, new Num(n-1),r2));
    return merge(symb_st,grm, r_seq);

  case &Hash(0,N,r2):
    // same as [ r2 *{N-1}(commas r2) ]
    return merge(symb_st,grm,
                 OPT(SEQ(r2,STAR(0,minus_one(N),SEQ(commas(),r2)))));
  case &Hash(m,N,r2):
    // same as r2 {m-1}*{N-1}(commas r2)
    return merge(symb_st,grm,
                 SEQ(r2,STAR(m-1,minus_one(N),SEQ(commas(),r2))));
  case &Prose(_):
    warn("Prose not supported in merge()\n");
    return merge(symb_st,grm,LIT(""));
  case &Minus(_,_):
    warn("Minus not supported in merge()\n");
    return merge(symb_st,grm,LIT(""));
  }
}

$(dfa_t,Set::set_t<st_t>) rule2earley(grammar_t grm, rule_t r) {
  /* Build the NFA for the grammar */

  /* symb_st maps symbols to start states */
  Hashtable::table_t<str_t,st_t> symb_st =
    Hashtable::create(101,strptrcmp,Hashtable::hash_stringptr);

  nfa_init(grm);
  let $(start_state,f,e) = merge(symb_st,grm,r);
  let final_state = nfa_fresh_state();
  etrans(f,final_state);
  etrans(e,final_state);
  final(start_state,final_state);
  fprintf(stderr,"Start state is %d, final state is %d\n",start_state,final_state);
  nfa_dot(stderr,Set::singleton(st_cmp,final_state),act2symb);

  /* Collect the set of final states for symbols... */
  let symb_final_states = Set::empty(st_cmp);
  /* ... and the mapping from symbol actions to symbols */
  let act_table = Hashtable::create(11,st_cmp,st_hash); // should be act_cmp
  for (let rules = grm; rules != NULL; rules = rules->tl) {
    let &$(symb,_,_) = rules->hd;
    let st_opt = Hashtable::lookup_opt(symb_st,new symb);
    if (!st_opt) continue;
    let symb_final = get_final(*st_opt);
    symb_final_states = Set::insert(symb_final_states,symb_final);
    Hashtable::insert(act_table,
                      symb_final,
                      symb2act(symb));
  }

  /* Convert to DFA */
  let dfa = nfa2dfa(start_state,
                    Set::insert(symb_final_states,final_state));
  dfa = dfa_minimize(dfa);

  /* We want an automata with final attributes that indicate which
     symbol has been completed, but our NFAs do not have final
     attributes.  The nfa2dfa conversion creates a DFA whose final
     states have as attributes the corresponding NFA final states.
     Therefore we can post-process the DFA to map these attributes to
     indicate the symbol (as indicated by symb2act()).

     We also record in dfa_final the subset of final states that
     correspond to the full RHS that is being parsed, as distinguished
     from the final states that indicate parsing of symbols.
  */
  let dfa_final = Set::empty(st_cmp);
  for (let states = Set::to_list(dfa_final_states(dfa));
       states != NULL; states = states->tl) {
    let s = states->hd;
    let action_attrs = Set::empty(st_cmp); // should be attr_cmp
    for (let s_attrs = Set::to_list(dfa_final_attrs(dfa,s));
         s_attrs != NULL; s_attrs = s_attrs->tl) {
      let a = s_attrs->hd;
      if (a == final_state) {
        dfa_final = Set::insert(dfa_final,s);
        // final_state of the original rule r does not correspond to
        // the parsing of a symbol hence does not return.  So we do not
        // want it in the attributes which indicate what symbols are
        // returning.
        continue;
      }
      let act = Hashtable::lookup(act_table,a);
      action_attrs = Set::insert(action_attrs,act);
    }
    dfa_set_final(dfa,s,action_attrs);
  }
  return $(dfa,dfa_final);
}

/* Add an item to an Earley state.
   If the item has an automaton state that transitions to another state
   by epsilon, add items for those states too.
   Epsilons may be for CALLS to parse non-terminals or
   RETURNS from parsing non-terminals.
 */
void
push_closure(dfa_t dfa,
             Axarray::xarray_t<earley_state_t> estates,
             unsigned int i,
             earley_item_t ei,
             const char ?reason,
             Hashtable::table_t<earley_node_t,List::list_t<earley_node_t,`H>,`H> pred,
             Hashtable::table_t<earley_node_t,List::list_t<earley_node_t,`H>,`H> retn,
             earley_node_opt_t back) {

  let &$(s,backptr) = ei;
  let node = new $(s,backptr,i);
  if (back != NULL) {
    let backlistptr = Hashtable::lookup_opt(pred,node);
    if (backlistptr != NULL) {
      Hashtable::remove(pred,node);
      Hashtable::insert(pred,node,new List::List(back,*backlistptr));
    }
    else Hashtable::insert(pred,node,List::list(back));
  }

  let es = Axarray::get(estates,i);
  if (Set::member(es,ei)) return;
  fprintf(stderr,"estates[%d] += (%d,%d) %s\n",i,ei->f0,ei->f1,reason);fflush(stderr);
  Axarray::set(estates,i,Set::insert(es,ei));

  /* Close under CALLS */
  let t = target(dfa,s,callout_action());
  if (t != 0)
    push_closure(dfa,estates,i,new $(t,i),"(call)",pred,retn,NULL);

  /* Close under RETURNS */
  if (i != backptr // we parsed the empty string, RETURN handled by dfa already
      && dfa_is_final(dfa,s)) {
    /* Some symbol is completed.
       es_back is the Earley state that CALLed the symbol. */
    let es_back = Axarray::get(estates,backptr);

    /* For every completed symbol... */
    for (let completed = Set::to_list(dfa_final_attrs(dfa,s));
         completed != NULL; completed = completed->tl) {
      let symb = completed->hd;

      /* ... look at every DFA state in es_back... */
      for (let es_back_list = Set::to_list(es_back);
           es_back_list != NULL;
           es_back_list = es_back_list->tl) {

        let &$(t,tbackptr) = es_back_list->hd;
        let ttarget = target(dfa,t,symb);
        /* ... see if the DFA state did a CALL and RETURN if so. */
        if (ttarget != 0) {
          push_closure(dfa,estates,i,new $(ttarget,tbackptr),
                       aprintf("(return 0x%x)",symb),
                       pred,retn,new $(t,tbackptr,backptr));
          let retnode = new $(ttarget,tbackptr,i);
          let backlistptr = Hashtable::lookup_opt(retn,retnode);
          if (backlistptr != NULL) {
            Hashtable::remove(retn,retnode);
            Hashtable::insert(retn,retnode,new List::List(node,*backlistptr));
          }
          else Hashtable::insert(retn,retnode,List::list(node));
        }
      }
    }
  }
}


// returns 1 if ambiguous, 0 otherwise
int derivation(Hashtable::table_t<earley_node_t,List::list_t<earley_node_t>,`H> pred,
               Hashtable::table_t<earley_node_t,List::list_t<earley_node_t>,`H> retn,
               earley_node_t ei,
               const char ?input,
               dfa_t dfa) {
  let retcode = 0;
  let maybe_retn = Hashtable::lookup_opt(retn,ei);
  if (maybe_retn != NULL) {
    let len = List::length(*maybe_retn);
    if (len > 1){
      retcode = 1;
      fprintf(stderr,"Ambiguous parse, (%d,%d,%d) has multiple RETURNs\n",
              ei->f0,ei->f1,ei->f2);
    } 
    // only print one derivation even if > 1
    if (len > 0) {
      retcode = retcode || derivation(pred,retn,(*maybe_retn)->hd,input,dfa);
      let &$(x,i,j) = (*maybe_retn)->hd;
      // x is state, parse started at i, finished at j
      let completed = Set::to_list(dfa_final_attrs(dfa,x));
      if (completed != NULL) {
        let attr = completed->hd;
        printf(" <- %s [%d,%d]\n",act2symb(attr),i,j);
      }
      else
        // should never happen
        printf(" <- ??? [%d,%d]\n",i,j);
    }
  }

  let before_opt = Hashtable::lookup_opt(pred,ei);
  if (before_opt == NULL) return retcode;

  let before = *before_opt;
  let len = List::length(before);

  if (len > 1) {
    retcode = 1;
    fprintf(stderr,"Ambiguous parse, (%d,%d,%d) has multiple predecessors\n",
            ei->f0,ei->f1,ei->f2);
//    while (before) {
//      fprintf(stderr,"(%d,%d,%d)\n",before->hd->f0,before->hd->f1,before->hd->f2);
//      before = before->tl;
//    }
//    fflush(stderr);
  }
  if (len > 0)
    retcode = retcode || derivation(pred,retn,before->hd,input,dfa);

  if (maybe_retn == NULL) {
    // did not get here by RETURN, so we read a terminal, print it
    let i = ei->f2;
    printf("%c",input[i-1]);
  }
  else {
    // got here by a RETURN, therefore we just parsed a nonterminal, print it
    let &$(x,i,j) = (*maybe_retn)->hd;
    // x is state, parse started at i, finished at j
    let completed = Set::to_list(dfa_final_attrs(dfa,x));
    if (completed != NULL) {
      let attr = completed->hd;
      printf(" %s ",act2symb(attr));
    }
    else
      // should never happen
      printf(" ??? ");
  }
  return retcode;
}

/* Earley recognizer.
   Returns 1 if input is recognized, 0 otherwise.
 */
int recognize(grammar_t grm, rule_t r,const char ?input) {
  init_maybe_empty(grm);
  let $(dfa,dfa_final) = rule2earley(grm,r);
  dfa_dot(stderr,dfa,act2symb);
  fflush(stderr);

  /* Keep track of parse trees */
  let
    pred = Hashtable::create(11,earley_node_cmp,earley_node_hash);
  let
    retn = Hashtable::create(11,earley_node_cmp,earley_node_hash);

  /* Initialize the sequence of Earley states with s0 */
  let estates = /* Earley states  s0, s1, s2, ... */
    Axarray::create(11,Set::empty(earley_item_cmp));
  let earley_item_0 = new $(1,0); // 1 is initial state of dfa, 0 is i in si
  push_closure(dfa,
               estates,
               0,
               earley_item_0,
               "(initial)",
               pred,
               retn,
               NULL);
               
  /* Scan the input */
  let input_len = strlen(input);
  for (let i = 0; i < input_len; i++) {
    fprintf(stderr,"input[%d]==%s\n",i,cs_char_escape(input[i]));fflush(stderr);
    for (let si_list = Set::to_list(Axarray::get(estates,i));
         si_list != NULL;
         si_list = si_list->tl) {

      let &$(state,parent) = si_list->hd;
      let k = target(dfa,state,input[i]);
      if (k != 0)
        push_closure(dfa,estates,i+1,new $(k,parent),"(input)",pred,retn,new $(state,parent,i));
    }
  }

  /* See if we ended up in a final state */
  fprintf(stderr,"Looking in estates[%d] for:",input_len);
  for (let fs = Set::to_list(dfa_final); fs != NULL; fs = fs->tl)
    fprintf(stderr," (%d,0)",fs->hd);
  fprintf(stderr,"\n");fflush(stderr);

  for (let slast_list = Set::to_list(Axarray::get(estates,input_len));
       slast_list != NULL;
       slast_list = slast_list->tl) {
      let &$(state,parent) = slast_list->hd;
      if (Set::member(dfa_final,state) && parent == 0) {
        derivation(pred,retn,new $(state,parent,input_len),input,dfa);
        printf(" <- START\n");
        return 1;
      }
  }
  return 0;
}
