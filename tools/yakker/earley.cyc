/* (So far incomplete) Earley parser */

#include <buffer.h>
#include <string.h>
#include <core.h>
#include <stdlib.h>
#include <list.h>
#include <graph.h>
#include "bnf.h"
#include "fa.h"
#include "axarray.h"
#include "cs.h"
#include "analyze.h"

#include "nfa_eager.h"
using Nfa_eager;

namespace Earley;

typedef List::list_t<datatype ParseTree @`H,`H> parse_forest_t;
typedef List::List_t<datatype ParseTree @`H,`H> Parse_forest_t;

typedef datatype ParseTree @`H parse_tree_t;

datatype ParseTree{
  NonTerm(const char ?`H, int, int, parse_forest_t);
  SharedNonTerm(const char ?`H, int, int, List::List_t<parse_forest_t,`H>);
};

/* Global variable that saves last derivation tree.*/
datatype ParseTree *last_derivation_tree = NULL;

// Flag indicating whether to print parsing progress to stderr.
static int show_prog = 0;

void print_LT_parse_forest(parse_forest_t pf, int depth);

void print_LT(datatype ParseTree @pt, int depth){
  switch (pt) {
  case &NonTerm(name,l,r,children):
    printf("<t s=\"%s\" l=\"%d\" r=\"%d\">",name,l,r);
  print_LT_parse_forest(children, depth);
    printf("</t>");
    break;
  case &SharedNonTerm(name,l,r,children_list):
    printf("<t s=\"%s\" l=\"%d\" r=\"%d\">",name,l,r);
  print_LT_parse_forest(children_list->hd,depth);
    printf("</t>");
    break;
  }
}

void print_LT_parse_forest(parse_forest_t pf, int depth){
  if (depth > 0){
    let d = depth - 1;
    for(let ts = (_*)pf; ts; ts = ts->tl)
      print_LT(ts->hd, d);
  } else if(depth == -1) {
    for(let ts = (_*)pf; ts; ts = ts->tl)
      print_LT(ts->hd, -1);
  }
}

void print_RT_parse_forest(parse_forest_t pf, int depth);

`a reflect(`a last_seen,`a current){return current;}

void print_RT(datatype ParseTree @pt, int depth){
  switch (pt) {
  case &NonTerm(name,l,r,children):
    printf("<t s=\"%s\" l=\"%d\" r=\"%d\">",name,l,r);
  print_RT_parse_forest(children,depth);
    printf("</t>");
    break;
  case &SharedNonTerm(name,l,r,children_list):
    printf("<t s=\"%s\" l=\"%d\" r=\"%d\">",name,l,r);
    let last_derivation = List::fold_left(reflect,children_list->hd,children_list);
    print_RT_parse_forest(last_derivation,depth);
    printf("</t>");
    break;
  }
}

void print_RT_parse_forest(parse_forest_t pf, int depth){
  if (depth > 0){
    let d = depth - 1;
    for(let ts = (_*)pf; ts; ts = ts->tl)
      print_RT(ts->hd, d);
  } else if(depth == -1) {
    for(let ts = (_*)pf; ts; ts = ts->tl)
      print_RT(ts->hd, -1);
  }
}


void print_parse_forest(parse_forest_t pf);

void print_parse_tree(datatype ParseTree @pt){
  switch (pt) {
  case &NonTerm(name,l,r,children):
    printf("<t s=\"%s\" l=\"%d\" r=\"%d\">",name,l,r);
    print_parse_forest(children);
    printf("</t>");
    break;
  default:
    fprintf(stderr,"Ambiguous parse tree!\n");
    break;
  }
}

void print_parse_forest(parse_forest_t pf){
  List::iter(print_parse_tree,pf);
}


int isAmb_parse_forest(parse_forest_t pf);

int isAmb_parse_tree0(int isAmb, datatype ParseTree @pt){
  if (isAmb) return 1;

  switch (pt) {
  case &NonTerm(name,l,r,children):
    return isAmb_parse_forest(children);
  default:
    return 1;
  }
}

int isAmb_parse_tree(datatype ParseTree @pt){
  return isAmb_parse_tree0(0,pt);
}

int isAmb_parse_forest(parse_forest_t pf){
  return List::fold_left(isAmb_parse_tree0,0,pf);
}

/* The alphabet of the automaton is the set of terminals and
   non-terminals.  Assume for now that cs_t can represent a set of
   terminals and non-terminals.  Number our new actions starting
   at 256.

   NB: there is a max number of actions hard-coded in cs.h.
*/

static unsigned int symb_action_counter = 259;
static struct Hashtable::Table<str_t,act_t> *symb_action_table = NULL;
static struct Hashtable::Table<act_t,str_t> *action_symb_table = NULL;
static act_t callout_action() {
  return 256;
}
static act_t repeat_action() {
  return 257;
}
static act_t final_st_action() {
  return 258;
}
static act_t new_action() {
  let a = symb_action_counter++;
  if (a > MAXACTION) {
    fprintf(stderr,"Internal error: maximum number of actions exceeded\n");
    fflush(stderr);
    exit(1);
  }
  return a;
}
static cs_t callout_cs() {
  return cs_singleton(callout_action());
}
static cs_t repeat_cs() {
  return cs_singleton(repeat_action());
}
static cs_t final_st_cs() {
  return cs_singleton(final_st_action());
}
const char ?act2symb(act_t act) {
  if (action_symb_table == NULL) {
    action_symb_table =
      Hashtable::create(11,st_cmp,st_hash);
    Hashtable::insert(action_symb_table,callout_action(),new "CALL");
    Hashtable::insert(action_symb_table,repeat_action(),new "REPEAT");
    Hashtable::insert(action_symb_table,final_st_action(),new "FINAL-STATE");
  }

  let sopt = Hashtable::lookup_opt(action_symb_table,act);
  if (sopt == NULL || *sopt == NULL) return NULL;
  else return **sopt;
}
void act2symb_haxe(FILE @f) {
    fprintf(f,"static public function act2symb(a:Int) {\n");
    fprintf(f,"  switch (a) {\n");
  for (let a = repeat_action()+1; a < symb_action_counter; a++) {
    fprintf(f,"  case %d: return \"%s\";\n",a,act2symb(a));
  }
    fprintf(f,"  default: return \"?unknown?\";\n");
    fprintf(f,"  }\n");
    fprintf(f,"}\n");
}

static act_t symb2act(const char ?`H symb) {
  if (action_symb_table == NULL) {
    action_symb_table =
      Hashtable::create(11,st_cmp,st_hash);
    Hashtable::insert(action_symb_table,callout_action(),new "CALL");
    Hashtable::insert(action_symb_table,repeat_action(),new "REPEAT");
    Hashtable::insert(action_symb_table,final_st_action(),new "FINAL-STATE");
  }
  if (symb_action_table == NULL){
    symb_action_table =
      Hashtable::create(11,strptrcmp,Hashtable::hash_stringptr);
    Hashtable::insert(symb_action_table,new "CALL",callout_action());
    Hashtable::insert(symb_action_table,new "REPEAT",repeat_action());
    Hashtable::insert(symb_action_table,new "FINAL-STATE",final_st_action());
  }
//   let symbptr = new symb;
  let symbptr = new (const char ?)aprintf("%s",symb);
  let aptr = Hashtable::lookup_opt(symb_action_table,symbptr);
  if (aptr != NULL) return *aptr;
  let a = new_action();
  fprintf(stderr,"Symbol %s has action 0x%x\n",symb,a);
  // allocate a new string before putting it in table to ensure
  // that
  Hashtable::insert((_@)symb_action_table,symbptr,a);
  Hashtable::insert((_@)action_symb_table,a,symbptr);
  return a;
}
static cs_t consume_symb_cs(const char ?`H symb) {
  return cs_singleton(symb2act(symb));
}

/* An automaton state and parent pointer */
typedef $(st_t,unsigned int) @earley_item_t;

static int earley_item_cmp(earley_item_t a,earley_item_t b) {
  let $(ai,aj) = *a;
  let $(bi,bj) = *b;
  let c = Core::intcmp(ai,bi);
  if (c) return c;
  return Core::intcmp(aj,bj);
}

typedef $(st_t,unsigned int,unsigned int) @earley_node_t;
typedef $(st_t,unsigned int,unsigned int) *earley_node_opt_t;
typedef  Hashtable::table_t<earley_item_t,List::list_t<earley_node_t,`r>,`r> earley_graph_t<`r>;
static int earley_node_cmp(earley_node_t a,earley_node_t b) {
  let $(ai,aj,ak) = *a;
  let $(bi,bj,bk) = *b;
  let c = Core::intcmp(ai,bi);
  if (c) return c;
  c = Core::intcmp(aj,bj);
  if (c) return c;
  return Core::intcmp(ak,bk);
}
static void earley_node_pr(FILE @f,earley_node_t a) {
  let $(ai,aj,ak) = *a;
  fprintf(f,"(%d,%d,%d)",ai,aj,ak);
}

static int earley_node_hash(earley_node_t a) {
  let $(ai,aj,ak) = *a;
  /* All ai, aj, and ak are ints starting at 0, ai maxes out at the
     number of states, aj and ak max out at the input length.
     TODO: see what typical sizes are for these and adjust the
     hash function accordingly.
  */
  return ai ^ (aj+ak);
}

typedef Set::set_t<earley_item_t> earley_state_t;

/* Create the control NFA for Earley parsing.
   The rule specifies what to parse.
   Symbols from the grammar will be used if needed, otherwise ignored.
   The symb_st table maps used symbols to states and should be
   initialized to the empty table.
   On return the table will hold mappings for all symbols encountered.
   */
$(st_t,st_t,st_t)
  merge(Hashtable::table_t<str_t,st_t> symb_st,
        grammar_t grm,
        rule_t r);

st_t rule2earley0(Hashtable::table_t<str_t,st_t> symb_st,
                  grammar_t grm,
                  rule_t r) {
  switch (r->r) {
  case &Symb(x,_):
    let xptr = new x;
    st_t x_start; /* start state of the NFA for the symbol */
    if (!Hashtable::try_lookup(symb_st,xptr,&x_start)) {
      /* Symbol has not been converted to NFA yet */
      Rule_t x_rule = lookup_symbol(grm, x);
      if (!x_rule) {
	warn("missing definition for %s in rule2earley()\n",x);
	return mklit("");
      }
      /* Allocate a start state for the symbol.  Do this before
         converting to NFA in case the symbol is defined recursively. */
      let s = nfa_fresh_state(); let f = nfa_fresh_state(); final(s,f);
      Hashtable::insert(symb_st,xptr,s);
      let $(s_body,f_body,_) = merge(symb_st,grm,x_rule);
      final(s,f_body); // merge does not do this
      etrans(s,s_body);
      x_start = s;
    }
    let s = nfa_fresh_state();
    let s2 = nfa_fresh_state();
    let f = nfa_fresh_state(); final(s,f);
    action(s,callout_cs(),x_start);
    etrans(s,s2);
    action(s2,consume_symb_cs(x),f);
    /* If the symbol can derive the empty string make sure this gets
       reflected into the automaton --- effectively doing a RETURN in
       the automaton instead of the Earley evaluator itself */
    if (empty_rule(SYMB(x)))
      etrans(s2,f);
    return s;
  case &Lit(x):
    return mklit(x);
  case &CharRange(low,high):
    if (low > high) {
      internal_err("invalid character range in rule2earley()\n");
      return mklit("");
    }
    return mkact(cs_range(low,high+1));
  case &Opt(r2):
    let s2 = rule2earley0(symb_st,grm,r2); let s3 = mklit("");
    return mkalt(s2,s3);
  case &Seq(r2,r3):
    let s2 = rule2earley0(symb_st,grm,r2); let s3 = rule2earley0(symb_st,grm,r3);
    return mkseq(s2,s3);
  case &Alt(r2,r3):
    let s2 = rule2earley0(symb_st,grm,r2); let s3 = rule2earley0(symb_st,grm,r3);
    return mkalt(s2,s3);
  case &Rcount(var,r2):
    /* Conservative approximation */
    warn_repeat();
    // 1. check that r2 is valid -- only symbols allowed.
    // TODO

    // 2. s2 <- generate NFA for r2.
    let s2 = rule2earley0(symb_st,grm,r2);

    // 2.a. Convert var -- the "repeater" because it determines the repetition -- to action.
    let repeater_cs =  consume_symb_cs(var);
    // 2.b. Convert target -- the "repeatee" because gets repeated -- to action.
    let repeatee_cs;
    switch (r2->r) {
    case &Symb(x,_):
      // overwrite s2 with start state of symbol *definition*.
      Hashtable::try_lookup(symb_st,new x,&s2);
      repeatee_cs = consume_symb_cs(x);
      break;
    default:
      fprintf(stderr,"Error: repeatee of repeat is not a symbol.\n");
      return mklit("");
    }
    // 2.c.  and add to final state of s2. FIX: can't do this, b/c no
    // attrs for NFA final states. For now, just enforce that user use
    // unique nonterm in which case, var will be added automatically.

    // 3. Create start and final state for the repeat.
    let s = nfa_fresh_state();
    let f = nfa_fresh_state();
    final(s,f);

    // 4. add fresh states that CALL to s2 and transition (to final
    // state) on var. Not a real states -- just used to store info
    // about s_rep: the NFA to call, nonterm symbol (action), and
    // final state of repeat. Could use separate table.
    let s_rep_call = nfa_fresh_state();
    let s_rep_trans_repeater = nfa_fresh_state();
    let s_rep_trans_repeatee = nfa_fresh_state();
    action(s_rep_call,callout_cs(),s2);
    etrans(s_rep_call,s_rep_trans_repeater);
    action(s_rep_trans_repeater,repeater_cs,s_rep_trans_repeatee);
    action(s_rep_trans_repeatee,repeatee_cs,f);

    // 4. Transition start state to CALL state on repeat to indicate a
    // repeat is happening.
    action(s,repeat_cs(),s_rep_call);

    return s;
  case &Star(0,&Infinity,r2):
    let s2 = rule2earley0(symb_st,grm,r2);
    return mkstar(s2);
  case &Star(m,i as &Infinity,r2):
    let r_seq = SEQ(r2,STAR(m-1,i,r2));
    return rule2earley0(symb_st,grm,r_seq);
  case &Star(0,&Num(0),r2):
    return mklit("");

  case &Star(0,&Num(n),r2):
    let r_opt = OPT(SEQ(r2,STAR(0, new Num(n-1),r2)));
    return rule2earley0(symb_st,grm,r_opt);
  case &Star(m,&Num(n),r2):
    if (m > n) return mklit("");
    let r_seq = SEQ(r2,STAR(m-1, new Num(n-1),r2));
    return rule2earley0(symb_st,grm, r_seq);

  case &Hash(0,N,r2):
    // same as [ r2 *{N-1}(commas r2) ]
    return rule2earley0(symb_st,grm,
                        OPT(SEQ(r2,STAR(0,minus_one(N),SEQ(commas(),r2)))));
  case &Hash(m,N,r2):
    // same as r2 {m-1}*{N-1}(commas r2)
    return rule2earley0(symb_st,grm,
                        SEQ(r2,STAR(m-1,minus_one(N),SEQ(commas(),r2))));
  case &Prose(_):
    warn("Prose not supported in rule2earley()\n");
    return mklit("");
  case &Minus(_,_):
    warn("Minus not supported in rule2earley()\n");
    return mklit("");
  }
}

$(st_t,st_t,st_t)
  merge(Hashtable::table_t<str_t,st_t> symb_st,
        grammar_t grm,
        rule_t r) {
  switch (r->r) {
  case &Symb(x,_):
    let xptr = new x;
    st_t x_start; /* start state of the NFA for the symbol */
    if (!Hashtable::try_lookup(symb_st,xptr,&x_start)) {
      /* Symbol has not been converted to NFA yet */
      Rule_t x_rule = lookup_symbol(grm, x);
      if (!x_rule) {
	warn("missing definition for %s in merge()\n",x);
	return merge(symb_st,grm,LIT(""));
      }
      /* Allocate a start state for the symbol.  Do this before
         converting to NFA in case the symbol is defined recursively. */
      let s = nfa_fresh_state(); let f = nfa_fresh_state();
      Hashtable::insert(symb_st,xptr,s);
      let $(s_body,f_body,_) = merge(symb_st,grm,x_rule);
      // need e_body too???
      final(s,f_body); // merge does not do this
      etrans(s,s_body);
      x_start = s;
    }
    let s = nfa_fresh_state();
    let s2 = nfa_fresh_state();
    let e = nfa_fresh_state();
    let f = nfa_fresh_state();
    action(s,EPSILON,x_start);
    etrans(s,s2);
    action(s2,consume_symb_cs(x),f);
    /* If the symbol can derive the empty string make sure this gets
       reflected into the automaton --- effectively doing a RETURN in
       the automaton instead of the Earley evaluator itself */
    if (empty_rule(SYMB(x)))
      etrans(s2,e);
    return $(s,f,e);
  case &Lit(x):
    if (!strcmp(x,"")) {
      let s = nfa_fresh_state();
      let f = nfa_fresh_state();
      let e = nfa_fresh_state();
      etrans(s,e);
      return $(s,f,e);
    }
    else {
      let s = mklit(x);
      let f = get_final(s);
      let e = nfa_fresh_state();
      return $(s,f,e);
    }
  case &CharRange(low,high):
    if (low > high) {
      internal_err("invalid character range in merge()\n");
      let s = nfa_fresh_state();
      let f = nfa_fresh_state();
      return $(s,f,s);
    }
    else {
      let s = mkact(cs_range(low,high+1));
      let f = get_final(s);
      let e = nfa_fresh_state();
      return $(s,f,e);
    }
  case &Opt(r2):
    let s = nfa_fresh_state();
    let e = nfa_fresh_state();
    let $(s2,f2,e2) = merge(symb_st,grm,r2);
    etrans(s,s2);
    action(s,EPSILON,e);
    etrans(e2,e);
    return $(s,f2,e);
  case &Seq(r2,r3):
    let s = nfa_fresh_state();
    let f = nfa_fresh_state();
    let e = nfa_fresh_state();
    let $(s2,f2,e2) = merge(symb_st,grm,r2);
    let $(s3,f3,e3) = merge(symb_st,grm,r3);
    let scall = rule2earley0(symb_st,grm,r3);
    let fcall = get_final(scall);
    etrans(s,s2);
    etrans(f2,scall);
    etrans(e2,s3);
    etrans(f3,f);
    etrans(fcall,f);
    etrans(e3,e);
    return $(s,f,e);
  case &Alt(r2,r3):
    let s = nfa_fresh_state();
    let f = nfa_fresh_state();
    let e = nfa_fresh_state();
    let $(s2,f2,e2) = merge(symb_st,grm,r2);
    let $(s3,f3,e3) = merge(symb_st,grm,r3);
    etrans(s,s2);
    action(s,EPSILON,s3);
    etrans(f2,f);
    etrans(f3,f);
    etrans(e2,e);
    etrans(e3,e);
    return $(s,f,e);
  case &Rcount(var,r2):
    warn_repeat();
    //  repeat should never show up in a merge, because that implies
    // that it might be preceded by epsilon, in which case it will have
    // no value on which to depend.
    warn("@repeat appears, in a sequence, possibly preceded by epsilon.\n");
    fallthru(r2);
  case &Star(0,&Infinity,r2):
    let s = nfa_fresh_state();
    let f = nfa_fresh_state();
    let e = nfa_fresh_state();
    let $(s2,f2,e2) = merge(symb_st,grm,r2);
    let scall = rule2earley0(symb_st,grm,r2);
    let fcall = get_final(scall);
    etrans(s,s2);
    action(s,EPSILON,e);
    etrans(e2,s2);
    action(e2,EPSILON,e);
    etrans(f2,scall);
    action(f2,EPSILON,f);

    // We could replace the following two transitions
    // with this single transition:
    // etrans(fcall,f2);
    // and then this would resemble the standard
    // Star construction,  with f2 playing the
    // role of s.
    etrans(fcall,scall);
    action(fcall,EPSILON,f);
    return $(s,f,e);
  case &Star(m,i as &Infinity,r2):
    let r_seq = SEQ(r2,STAR(m-1,i,r2));
    return merge(symb_st,grm,r_seq);
  case &Star(0,&Num(0),r2):
    return merge(symb_st,grm,LIT(""));
  case &Star(0,&Num(n),r2):
    let r_opt = OPT(SEQ(r2,STAR(0, new Num(n-1),r2)));
    return merge(symb_st,grm,r_opt);
  case &Star(m,&Num(n),r2):
    if (m > n) return merge(symb_st,grm,LIT(""));
    let r_seq = SEQ(r2,STAR(m-1, new Num(n-1),r2));
    return merge(symb_st,grm, r_seq);

  case &Hash(0,N,r2):
    // same as [ r2 *{N-1}(commas r2) ]
    return merge(symb_st,grm,
                 OPT(SEQ(r2,STAR(0,minus_one(N),SEQ(commas(),r2)))));
  case &Hash(m,N,r2):
    // same as r2 {m-1}*{N-1}(commas r2)
    return merge(symb_st,grm,
                 SEQ(r2,STAR(m-1,minus_one(N),SEQ(commas(),r2))));
  case &Prose(_):
    warn("Prose not supported in merge()\n");
    return merge(symb_st,grm,LIT(""));
  case &Minus(_,_):
    warn("Minus not supported in merge()\n");
    return merge(symb_st,grm,LIT(""));
  }
}

// Convert and print the rule as an NFA in FSM format.
// Writes two files based on the filename_base: .fsm and .sym. The
// former holds the NFA, the latter the mapping from symbolic names to
// numbers.
void rule_fsm(const char ?filename_base, grammar_t grm, rule_t r) {
  /* Build the NFA for the grammar */
  init_maybe_empty(grm);

  /* symb_st maps symbols to start states */
  Hashtable::table_t<str_t,st_t> symb_st =
    Hashtable::create(101,strptrcmp,Hashtable::hash_stringptr);

  nfa_init(grm);
  let $(start_state,f,e) = merge(symb_st,grm,r);
  let final_state = nfa_fresh_state();
  etrans(f,final_state);
  etrans(e,final_state);
  final(start_state,final_state);
  fprintf(stderr,"Start state is %d, final state is %d\n",start_state,final_state);

  /* Collect the set of final states for symbols... */
  let symb_final_states = Set::empty(st_cmp);
  /* ... and the mapping from final states to symbol actions */
  let act_table = Hashtable::create(11,st_cmp,st_hash); // should be act_cmp
  for (let rules = grm; rules != NULL; rules = rules->tl) {
    let &$(symb,_,_) = rules->hd;
    let st_opt = Hashtable::lookup_opt(symb_st,new symb);
    if (!st_opt) continue;
    let symb_final = get_final(*st_opt);
    symb_final_states = Set::insert(symb_final_states,symb_final);
    Hashtable::insert(act_table,
                      symb_final,
                      symb2act(symb));
  }

  let fsm_file = aprintf("%s.fsm",filename_base);
  FILE *f = fopen(fsm_file,"w");
  if (f) { nfa_fsm(f,symb_final_states,action_symb_table,act_table); fclose(f); }
  else fprintf(stderr, "Failed to open file %s.\n",fsm_file);

  let sym_file = aprintf("%s.sym",filename_base);
  FILE *f = fopen(sym_file,"w");
  if (f) { symbols_fsm(f,action_symb_table); fclose(f); }
  else fprintf(stderr, "Failed to open file %s.\n",sym_file);
}

$(dfa_t,Set::set_t<st_t>) *fsm2dfa(const char ?filename, const char ?`H start_symb) {
  return fsm_dfa(filename,start_symb,symb2act);
}

void dfa2dot(dfa_t dfa, const char ?dot_file){
  FILE *f = fopen(dot_file,"w");
  if (f) { dfa_dot(f,dfa,act2symb); fclose(f); }
  else fprintf(stderr, "Failed to open file %s.\n",dot_file);
}

$(dfa_t,Set::set_t<st_t>) rule2earley(grammar_t grm, rule_t r) {
  /* Build the NFA for the grammar */

  /* symb_st maps symbols to start states */
  Hashtable::table_t<str_t,st_t> symb_st =
    Hashtable::create(101,strptrcmp,Hashtable::hash_stringptr);

  nfa_init(grm);
  let $(start_state,f,e) = merge(symb_st,grm,r);
  let final_state = nfa_fresh_state();
  etrans(f,final_state);
  etrans(e,final_state);
  final(start_state,final_state);
  fprintf(stderr,"Start state is %d, final state is %d\n",start_state,final_state);
  if (debug > 1){
    nfa_dot(stderr,Set::singleton(st_cmp,final_state),act2symb);
  }

  /* Collect the set of final states for symbols... */
  let symb_final_states = Set::empty(st_cmp);
  /* ... and the mapping from final states to symbol actions */
  let act_table = Hashtable::create(11,st_cmp,st_hash); // should be act_cmp
  for (let rules = grm; rules != NULL; rules = rules->tl) {
    let &$(symb,_,_) = rules->hd;
    let st_opt = Hashtable::lookup_opt(symb_st,new symb);
    if (!st_opt) continue;
    let symb_final = get_final(*st_opt);
    symb_final_states = Set::insert(symb_final_states,symb_final);
    Hashtable::insert(act_table,
                      symb_final,
                      symb2act(symb));
  }

  if (debug){
    FILE *f = fopen("ykdebug/nfa.fsm","w");
    if (f) { nfa_fsm(f,symb_final_states,action_symb_table,act_table); fclose(f); }
    else fprintf(stderr, "Failed to open file ykdebug/nfa.fsm.\n");

    FILE *f = fopen("ykdebug/nfa.sym","w");
    if (f) { symbols_fsm(f,action_symb_table); fclose(f); }
    else fprintf(stderr, "Failed to open file ykdebug/nfa.sym.\n");
  }

  /* Convert to DFA */
  let dfa = nfa2dfa(start_state,
                    Set::insert(symb_final_states,final_state));
  dfa = dfa_minimize(dfa);

  /* We want an automata with final attributes that indicate which
     symbol has been completed, but our NFAs do not have final
     attributes.  The nfa2dfa conversion creates a DFA whose final
     states have as attributes the corresponding NFA final states.
     Therefore we can post-process the DFA to map these attributes to
     indicate the symbol (as indicated by symb2act()).

     We also record in dfa_final the subset of final states that
     correspond to the full RHS that is being parsed, as distinguished
     from the final states that indicate parsing of symbols.
  */
  let dfa_final = Set::empty(st_cmp);
  for (let states = Set::to_list(dfa_final_states(dfa));
       states != NULL; states = states->tl) {
    let s = states->hd;
    let action_attrs = Set::empty(st_cmp); // should be attr_cmp
    for (let s_attrs = Set::to_list(dfa_final_attrs(dfa,s));
         s_attrs != NULL; s_attrs = s_attrs->tl) {
      let a = s_attrs->hd;
      if (a == final_state) {
        dfa_final = Set::insert(dfa_final,s);
        // final_state of the original rule r does not correspond to
        // the parsing of a symbol hence does not return.  So we do not
        // want it in the attributes which indicate what symbols are
        // returning.
        continue;
      }
      let act = Hashtable::lookup(act_table,a);
      action_attrs = Set::insert(action_attrs,act);
    }
    dfa_set_final(dfa,s,action_attrs);
  }
  return $(dfa,dfa_final);
}

struct rstate {
  dfa_t dfa;
  Axarray::xarray_t<earley_state_t> estates;
  Hashtable::table_t<earley_node_t,List::list_t<earley_node_t,`H>,`H> pred;
  Hashtable::table_t<earley_node_t,List::list_t<$(earley_node_opt_t,earley_node_t) @`H,`H>,`H> retn;
  Hashtable::table_t<earley_node_t,List::list_t<earley_node_t,`H>,`H> call;
  Hashtable::table_t<earley_node_t,$(float,float)@> weights; //PROB
};
typedef struct rstate @rstate_t;

static float zeroWeight = 1.0; //PROB

static void dot_iter(earley_node_t s,List::list_t<earley_node_t> ts) {
  let &$(si,sj,sk) = s;
  for (; ts; ts = ts->tl) {
    let &$(ti,tj,tk) = ts->hd;
    printf("\"(%d,%d,%d)\" -> ",si,sj,sk);
    printf("\"(%d,%d,%d)\";\n",ti,tj,tk);
  }
}

static void dot_pred_iter(earley_node_t s,List::list_t<$(earley_node_opt_t,earley_node_t) @`H> ts) {
  let &$(si,sj,sk) = s;
  for (; ts; ts = ts->tl) {
    let &$(_,p) = ts->hd; // only bind pred edge.
    let &$(ti,tj,tk) = p;
    printf("\"(%d,%d,%d)\" -> ",si,sj,sk);
    printf("\"(%d,%d,%d)\";\n",ti,tj,tk);
  }
}

static void dot_retn_iter(earley_node_t s,List::list_t<$(earley_node_opt_t,earley_node_t) @`H> ts) {
  let &$(si,sj,sk) = s;
  for (; ts; ts = ts->tl) {
    let &$(r,_) = ts->hd; // only bind retn edge, not pred edge.
    if (r != NULL){
      let &$(ti,tj,tk) = r;
      printf("\"(%d,%d,%d)\" -> ",si,sj,sk);
      printf("\"(%d,%d,%d)\";\n",ti,tj,tk);
    }
  }
}

static void rstate_dot(rstate_t rs) {
  printf("digraph g {\n");
//   Hashtable::iter(dot_pred_iter,rs->pred);
  Hashtable::iter(dot_pred_iter,rs->retn);
  printf("edge [style=bold]\n");
  Hashtable::iter(dot_retn_iter,rs->retn);
  printf("edge [style=dotted]\n");
  Hashtable::iter(dot_iter,rs->call);
  printf("}\n");
}

void point_to(Hashtable::table_t<earley_node_t,List::list_t<`a,`H>,`H> tbl,
              earley_node_t source,
              `a target) {

  let ptr = Hashtable::lookup_opt(tbl,source);
  if (ptr != NULL) {
    Hashtable::remove(tbl,source);
    Hashtable::insert(tbl,source,new List::List(target,*ptr));
  }
  else Hashtable::insert(tbl,source,List::list(target));
}

//PROB
void add_weights(rstate_t rs, earley_node_t node, float forward, float inner) { //PROB
  let ptr = Hashtable::lookup_opt(rs->weights,node);                            //PROB
  if (ptr != NULL) {                                                            //PROB
    $(float,float)@y = *ptr;                                                    //PROB
    y->f0 += forward;                                                           //PROB
    y->f1 += inner;                                                             //PROB
  }                                                                             //PROB
  else Hashtable::insert(rs->weights,node,new $(forward,inner));                //PROB
}                                                                               //PROB

$(unsigned int, unsigned int) *
get_bounds(Hashtable::table_t<earley_node_t,List::list_t<$(earley_node_opt_t,earley_node_t) @`H>,`H> retn,
	   dfa_t dfa, earley_node_t en, act_t nt);

/* Add an item to an Earley state.
   If the item has an automaton state that transitions to another state
   by epsilon, add items for those states too.
   Epsilons may be for CALLS to parse non-terminals or
   RETURNS from parsing non-terminals.
 */
void
push_closure(rstate_t rs,
	     const char ?input,
             unsigned int i,
             earley_item_t ei, // YHM: I think this should be an early node
			       // instead of an earley item for
			       // efficiency sake (to save allocations).
             const char ?reason,
             earley_node_opt_t back,
	     earley_node_opt_t up
             , float forward, float inner //PROB
             ) {

  let &$(s,backptr) = ei;
  let node = new $(s,backptr,i);
  if (back != NULL) {
    point_to(rs->pred,node,back);
    point_to(rs->retn,node,new $(up,back));
  }
  add_weights(rs,node,forward,inner); //PROB

  let es = Axarray::get(rs->estates,i);
  if (Set::member(es,ei)) return;
  if (show_prog){
    fprintf(stderr,"estates[%d] += (%d,%d) %s\n",i,ei->f0,ei->f1,reason);fflush(stderr);
  }
  Axarray::set(rs->estates,i,Set::insert(es,ei));

  /* Close under CALLS */
  let $(t,w) = target_w_weight(rs->dfa,s,callout_action()); //PROB
  if (t != 0) {
    point_to(rs->call,new $(t,i,i),node);
    push_closure(rs,input,i,new $(t,i),"(call)",NULL,NULL
                 ,w*forward,zeroWeight //PROB
                 );
  }

  /* Close under REPEATS. Only works if target has *one* non-call target. */
  let t = target(rs->dfa,s,repeat_action());
  if (t != 0) {
    /* 1. Retrieve the number from the Earley parse trail.*/

    // Find the non-term to which repeat is bound.
    // Note: after determinizing, possibly many calls from single
    // state, but shouldn't be any terminals (is this true?). So, we
    // will need to perform repeat for *all* nonterminals that appear.
    fprintf(stderr,"Looking for non-CALL transition.\n");
    fflush(stderr);

    let nt_opt = first_action_but(rs->dfa,t,callout_action());
    if (!nt_opt){
      fprintf(stderr,"Error: repeat state does not transition on non-call.\n");
      return;
    }
    let repeater_nt = *nt_opt;
    fprintf(stderr,"Repeat based on non terminal %s.\n",act2symb(repeater_nt));
    // get the bounds (inclusive) of parsed non-terminal nt from the
    // Earley parse history.
    let bounds_opt = get_bounds(rs->retn,rs->dfa,node,repeater_nt);
    if (!bounds_opt){
      fprintf(stderr,"Error: bounds could not be find for non terminal %s.\n",act2symb(repeater_nt));
      return;
    }
    let &$(j,k) = (_@)bounds_opt;
    let num = atoi(substring(input,j,k-j+1));
    fprintf(stderr,"Repeat encountered with n=%d.\n",num);

    /* 2. Build new DFA using retrieved number. */

    // Find the action of the repeated symbol.
    let s_repeatee = target(rs->dfa,t,repeater_nt);
    let nt_opt = first_action_but(rs->dfa,s_repeatee,0);
    if (!nt_opt){
      fprintf(stderr,"Error: repeatee state does not transition.\n");
      return;
    }
    let repeatee_nt = *nt_opt;
    fprintf(stderr,"Repeat non terminal %s.\n",act2symb(repeatee_nt));

    // Find the start state of the repeated DFA.
    let nt_start = target(rs->dfa,t,callout_action());
    let nt_final = target(rs->dfa,s_repeatee,repeatee_nt);
    // Construct chain of states that transition on repeatee_nt and each call
    // this DFA (nt_start). Chain has length "num". The chain ends
    // with the final state.
    let t_new = construct_repeat_dfa(rs->dfa,num,repeatee_nt,nt_start,callout_action(),nt_final);

    if (debug > 1){
      fprintf(stderr,"Printing DFA after unrolling repeat.\n");
      dfa_dot(stderr,rs->dfa,act2symb);
      fflush(stderr);
    }

    /* 3. Call push_closure again as if we started in this
       state. ie. t_new replaces s. So, we reuse back and up. */
    push_closure(rs,input,i,new $(t_new,backptr),"(repeat)",back,up
                 ,forward,inner //PROB
                 );
  }
  /* Close under RETURNS.  Use else, becaause a REPEAT state can't
     also be a final state. */
  else if (i != backptr // we parsed the empty string, RETURN handled by dfa already
      && dfa_is_final(rs->dfa,s)) {
    /* Some symbol is completed.
       es_back is the Earley state that CALLed the symbol. */
    let es_back = Axarray::get(rs->estates,backptr);
    let final_w = dfa_final_prob(rs->dfa,s);

    /* For every completed symbol... */
    for (let completed = Set::to_list(dfa_final_attrs(rs->dfa,s));
         completed != NULL; completed = completed->tl) {
      let symb = completed->hd;

      /* ... look at every DFA state in es_back... */
      for (let es_back_list = Set::to_list(es_back);
           es_back_list != NULL;
           es_back_list = es_back_list->tl) {

        let &$(t,tbackptr) = es_back_list->hd;
        let ttarget = target(rs->dfa,t,symb);
        /* ... see if the DFA state did a CALL and RETURN if so. */
        if (ttarget != 0) {
	  // Earley node w/ dot before symb.
	  let backnode = new $(t,tbackptr,backptr);
	  // Earley node w/ dot after symb.
          let retnode = new $(ttarget,tbackptr,i);
//           let w = zeroWeight; //PROB: should be prob of return on symb
          let &$(backnode_forward,backnode_inner) = Hashtable::lookup(rs->weights,backnode); //PROB
          push_closure(rs,input,i,new $(ttarget,tbackptr),
                       aprintf("(return %s)",act2symb(symb)),
                       backnode, node
                       ,final_w*inner*backnode_forward,final_w*inner*backnode_inner //PROB
                       );
        }
      }
    }
  }
}

//
// function : derivation
// returns  : 1 if ambiguous, 0 otherwise
//
struct Buffer::t *b = NULL;

// int derivation(Hashtable::table_t<earley_node_t,List::list_t<earley_node_t>,`H> pred,
//                Hashtable::table_t<earley_node_t,List::list_t<$(earley_node_t,earley_node_t) @`H>,`H> retn,
//                earley_node_t ei,
//                const char ?input,
//                dfa_t dfa) {

//   let retcode = 0;
//   let maybe_retn = Hashtable::lookup_opt(retn,ei);
//   if (maybe_retn != NULL) {
//     let len = List::length(*maybe_retn);
//     if (len > 1){
//       retcode = 1;
//       fprintf(stderr,"Ambiguous parse, (%d,%d,%d) has multiple RETURNs\n",
//               ei->f0,ei->f1,ei->f2);
//       for (let bf = *maybe_retn; bf; bf = bf->tl) {
//         fprintf(stderr,"(%d,%d,%d)\n",bf->hd->f0->f0,bf->hd->f0->f1,bf->hd->f0->f2);
//       }
//       fflush(stderr);
//     }
//     // only print one derivation even if > 1
//     if (len > 0) {
//       let l = Buffer::length(b);
//       if (l > 0) {
//         // DOESN'T WORK -- CYCLONE BUG
// //        let z = Buffer::extract(b);
// //        char maybe_brace = z[l-1];
// //        Buffer::restore(b,z);
//         // INEFFICIENT WORKAROUND
//         let z = Buffer::contents(b);
//         char maybe_brace = z[l-1];
//         if (maybe_brace == '}')
//           Buffer::add_string(b,",");
//       }
//       let &$(x,i,j) = (*maybe_retn)->hd->f0;
//       // x is state, parse started at i, finished at j
//       let completed = Set::to_list(dfa_final_attrs(dfa,x));
//       if (completed != NULL) {
// 	// YHM: why don't we warn/report whether completed has more than one element?
//         let attr = completed->hd;
//         Buffer::add_string(b,
//                            aprintf("<t s=\"%s\" l=\"%d\" r=\"%d\">",
//                                    act2symb(attr),i,j));
//       }
//       else
//         // should never happen
//         Buffer::add_string(b,
//                            aprintf("<t s=\"???\" l=\"%d\" r=\"%d\">",
//                                    i,j));
//       //        printf(" <- ??? [%d,%d]\n",i,j);

//       let rc = derivation(pred,retn,(*maybe_retn)->hd->f0,input,dfa);
//       retcode = retcode || rc;
//       Buffer::add_string(b,"</t>");
//     }
//   }

//   let before_opt = Hashtable::lookup_opt(pred,ei);
//   // YHM: why return here?
//   if (before_opt == NULL) return retcode;

//   let before = *before_opt;
//   let len = List::length(before);

//   if (len > 1) {
//     retcode = 1;
//     fprintf(stderr,"Ambiguous parse, (%d,%d,%d) has multiple predecessors\n",
//             ei->f0,ei->f1,ei->f2);

//     for (let bf = before; bf; bf = bf->tl) {
//       fprintf(stderr,"(%d,%d,%d)\n",bf->hd->f0,bf->hd->f1,bf->hd->f2);
//     }
//     fflush(stderr);
//   }
//   if (len > 0) {
//     //    fprintf(stderr,"following (%d,%d,%d)\n",before->hd->f0,before->hd->f1,before->hd->f2);
//     // YHM: nearly a tail call.
//     let rc = derivation(pred,retn,before->hd,input,dfa);
//     retcode = retcode || rc;
//   }

//   // YHM: Dead code?
//   if (maybe_retn == NULL) {
//     // did not get here by RETURN, so we read a terminal, print it
//     let i = ei->f2;
//     //    printf("%c",input[i-1]);
//   }
//   else {
//     // got here by a RETURN, therefore we just parsed a nonterminal, print it
//     let &$(x,i,j) = (*maybe_retn)->hd;
//     // x is state, parse started at i, finished at j
//     let completed = Set::to_list(dfa_final_attrs(dfa,x));
//     if (completed != NULL) {
//       let attr = completed->hd;
//       //      printf(" %s ",act2symb(attr));
//     }
//     else
//       // should never happen
//       0;
//       //      printf(" ??? ");
//   }
//   // YHM: End ead code.

//   return retcode;
// }


// Retrieve bounds of previously-appearing non terminal within currently parsing RHS.
// If appears multiple times, only returns one answer.
// If can't be found, return NULL;
$(unsigned int, unsigned int) *
get_bounds(Hashtable::table_t<earley_node_t,List::list_t<$(earley_node_opt_t,earley_node_t) @`H>,`H> retn,
	   dfa_t dfa, earley_node_t en, act_t nt){

  List::list_t<parse_forest_t> derivations = NULL;
  let maybe_links = Hashtable::lookup_opt(retn,en);
  if (maybe_links != NULL) {

    // OPTIMIZATION: we could use a loop instead of recursion if there
    // is only one link.

    // Search all predecessor paths
    for (let xs = *maybe_links; xs; xs = xs->tl) {
      let &$(retn_link,pred_link) = xs->hd;

      if (retn_link){
	let &$(x,i,j) = (_@)retn_link;
	if (Set::member(dfa_final_attrs(dfa,x),nt))
	  // found it
	  return new $(i,j);
      }

      // keep looking -- recurse.
      let b = get_bounds(retn, dfa, pred_link, nt);
      if (b) return b;

    }
  }

  return NULL;
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// YHM: (current) invariant: always called with final state in early item ei.

parse_tree_t
derivation_redux(Hashtable::table_t<earley_node_t,List::list_t<earley_node_t>,`H> pred,
		 Hashtable::table_t<earley_node_t,List::list_t<$(earley_node_opt_t,earley_node_t) @`H>,`H> retn,
		 const char ?input,
		 dfa_t dfa,
		 earley_node_t ei);

// List::List_t<parse_forest_t> prefix_all(parse_tree_t,List::List_t<parse_forest_t>);
// imperative update of fs.
void prefix_all_imp(parse_tree_t t,List::list_t<parse_forest_t> fs){
  for (;fs;fs = fs->tl){
    fs->hd = new List::List(t,fs->hd);
  }
}

List::list_t<parse_forest_t>
derivation_horizontal(Hashtable::table_t<earley_node_t,List::list_t<earley_node_t>,`H> pred,
		      Hashtable::table_t<earley_node_t,List::list_t<$(earley_node_opt_t,earley_node_t) @`H>,`H> retn,
		      const char ?input,
		      dfa_t dfa,
		      earley_node_t en){

  List::list_t<parse_forest_t> derivations = NULL;
  let maybe_links = Hashtable::lookup_opt(retn,en);
  if (maybe_links != NULL) {

    // Compute all derivations.
    for (let xs = *maybe_links; xs; xs = xs->tl) {
      let &$(retn_link,pred_link) = xs->hd;

      let pred_derivations = derivation_horizontal(pred,retn,input,dfa,
						   pred_link);
      if (retn_link){
	let child_tree = derivation_redux(pred,retn,input,dfa,
					  retn_link);
	// prefix all forests of pred_derivations with child_tree.
	prefix_all_imp(child_tree,pred_derivations);
      }

      derivations = List::append(derivations,pred_derivations);
    }

  }else
    // A single, empty derivation.
    derivations = List::list(NULL);


  //////////// Debug Code ///////////
//   if (derivations != NULL && derivations->tl != NULL) {
//     // More than one derivation, so ambiguous.
//     fprintf(stderr,"Ambiguous parse, (%d,%d,%d) has multiple derivations\n",
// 	    en->f0,en->f1,en->f2);
//     fflush(stderr);
//   }
  //////////////////////////////////

  return derivations;
}

parse_tree_t
derivation_redux(Hashtable::table_t<earley_node_t,List::list_t<earley_node_t>,`H> pred,
		 Hashtable::table_t<earley_node_t,List::list_t<$(earley_node_opt_t,earley_node_t) @`H>,`H> retn,
		 const char ?input,
		 dfa_t dfa,
		 earley_node_t ei) {
  let &$(x,i,j) = ei;
  const char? name = "TOP";
  let completed = Set::to_list(dfa_final_attrs(dfa,x));
  if (completed == NULL) {
    // FIX: add real error handling code.
    // ERROR: precondition of this function is that x is a final state.
//     return tree;
  }
  else {
    // pick any attribute (we choose the first)
    // FIX: use *all* attributes.
    let attr = completed->hd;
    name = act2symb(attr);
// THIS CODE CAUSES A CYCLONE BUG !!!
//     switch (h_derivations) {
//     case NULL  :
//       // YHM: can len == 0 ? If so, how did entry ever get created?
//       // ERROR?
//       break;
//     case &List::List{.hd=d, .tl=NULL} :
//       // Unambiguous
//       tree = new NonTerm(act2symb(attr),i,j,d);
//       break;
//     case &List::List{.hd=d, .tl=NULL} :
//       // Unambiguous
//       tree = new NonTerm(act2symb(attr),i,j,d);
//       break;
//     default :
//       // Ambiguous
//       tree = new SharedNonTerm(act2symb(attr),i,j,h_derivations);
//     }
  }

  parse_tree_t tree;

  let h_derivations = derivation_horizontal(pred,retn,input,dfa, ei);
  // distinguish ambiguous from unamb. parses.
  if (h_derivations == NULL){
    // YHM: can len == 0 ? If so, how did entry ever get created?
    // Yes, because it can be a string of terminals.
    fprintf(stderr,"No derivations returned.\n");
    tree = new NonTerm(name,i,j,NULL);
  } else if(h_derivations->tl == NULL){
    // Unambiguous
    tree = new NonTerm(name,i,j,h_derivations->hd);
  } else {
    // Ambiguous
    tree = new SharedNonTerm(name,i,j,h_derivations);
  }

  return tree;
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

typedef Graph::graph_t<earley_node_t> egraph_t;
egraph_t *ggg;
void cvti(earley_node_t s,List::list_t<earley_node_t> ts) {
  for (; ts; ts = ts->tl)
    *ggg = Graph::add_edge(*ggg,s,ts->hd);
}
egraph_t cvt(Hashtable::table_t<earley_node_t,List::list_t<earley_node_t>,`H> tbl) {
  ggg = new Graph::empty(earley_node_cmp);
  Hashtable::iter(cvti,tbl);
  return *ggg;
}

/* Earley recognizer.
   Returns 1 if input is recognized, 0 otherwise.
 */
$(dfa_t,Set::set_t<st_t>) compile(grammar_t grm, rule_t r) {
  init_maybe_empty(grm);
  let $(dfa,dfa_final) = rule2earley(grm,r);
  if (debug > 1)
    dfa_dot(stderr,dfa,act2symb);
  fflush(stderr);

  return $(dfa,dfa_final);
}

$(int,int) recognize(dfa_t dfa, Set::set_t<st_t> dfa_final, const char ?input, int show_progress) {

  show_prog = show_progress;

  /* Keep track of parse trees */
  let
    pred = Hashtable::create(11,earley_node_cmp,earley_node_hash);
  let
    retn = Hashtable::create(11,earley_node_cmp,earley_node_hash);
  let
    call = Hashtable::create(11,earley_node_cmp,earley_node_hash);
  let                                                                 //PROB
    weights = Hashtable::create(11,earley_node_cmp,earley_node_hash); //PROB

  /* Initialize the sequence of Earley states with s0 */
  let estates = /* Earley states  s0, s1, s2, ... */
    Axarray::create(11,Set::empty(earley_item_cmp));
  let earley_item_0 = new $(1,0); // 1 is initial state of dfa, 0 is i in si
  let rs = new rstate {dfa,estates,pred,retn,call
                       ,weights //PROB
  };
  push_closure(rs,
	       input,
               0,
               earley_item_0,
               "(initial)",
               NULL,NULL
               ,zeroWeight,zeroWeight //PROB
               );

  /* Scan the input */
  fprintf(stderr,"Scanning the input.\n");
  let input_len = strlen(input);
  for (let i = 0; i < input_len; i++) {

    if (show_prog){
      fprintf(stderr,"input[%d]==%s\n",i,cs_char_escape(input[i]));fflush(stderr);
    }

    for (let si_list = Set::to_list(Axarray::get(estates,i));
         si_list != NULL;
         si_list = si_list->tl) {

      let &$(state,parent) = si_list->hd;
      let $(k,w) = target_w_weight(dfa,state,input[i]); //PROB
      let eitem = new $(state,parent,i);
      let &$(forward,inner) = Hashtable::lookup(rs->weights,eitem);
      if (k != 0) // where k==0 indicates there is no valid target.
        push_closure(rs,input,i+1,new $(k,parent),"(input)",eitem,NULL
                     ,w*forward,w*inner //PROB
                     );
    }
  }

  /* See if we ended up in a final state */
  fprintf(stderr,"Looking in estates[%d] for:",input_len);
  for (let fs = Set::to_list(dfa_final); fs != NULL; fs = fs->tl)
    fprintf(stderr," (%d,0)",fs->hd);
  fprintf(stderr,"\n");fflush(stderr);

  printf("AA\n");
  if (debug)
    rstate_dot(rs);
  //  Graph::print(stdout,cvt(pred),earley_node_pr);
  printf("BB\n");
  //  Graph::print(stdout,cvt(retn),earley_node_pr);

  let partial_parses = 0;
  let complete_parses = 0;
  for (let slast_list = Set::to_list(Axarray::get(estates,input_len));
       slast_list != NULL;
       slast_list = slast_list->tl) {
    partial_parses++;
    let &$(state,parent) = slast_list->hd;
    if (Set::member(dfa_final,state) && parent == 0) {
//       b = Buffer::create(1024);
//       derivation(pred,retn,new $(state,parent /*== 0*/,input_len),input,dfa);
//       printf("Input:\n%s\nParse:\n",input);
//       printf("%s\n",Buffer::contents(b));

      complete_parses++;

      let en = new $(state,parent /*== 0*/,input_len);
      let derivation_tree = derivation_redux(pred,retn,input,dfa,en);
      if (debug) {
	printf("Input:\n%s\nLeftmost tree:\n",input);
	print_LT(derivation_tree,-1);
	printf("\nRightmost tree:\n");
	print_RT(derivation_tree,-1);
	printf("\n");
      }

      last_derivation_tree = derivation_tree;
      let &$(w_forward,w_inner) = Hashtable::lookup(rs->weights, en);
      printf("Probability: %lf\n",w_forward);
    }
  }
  return $(complete_parses,partial_parses);
}


// x Add report of "valid parse in progress"
// x Add command to shell: "amb?"
// Does FSM need symbols? I think it would be much simpler if we dropped the symbols names
// and just used numbers.
