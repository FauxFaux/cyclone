#include <core.h>
#include <list.h>
#include <stdio.h>
#include <string.h>

// #include "bnf.h"
#include "util.h"
#include "funtable.h"
#include "pm_bnf.h"

using List;

datatype exn{
  Pat_exception;
};

rule_pat_t pats2seq(list_t<rule_pat_t> pats){
  if (!pats)
    return new LitPat("");

  let res = pats->hd;
  pats = pats->tl;
  for (;pats; pats = pats->tl){
    res = new SeqPat(res,pats->hd);
  }
  return res;
}


typedef List::list_t<const char ?`H@`H,`H> ps_list;

ps_list pat2string0(ps_list ps, rule_pat_t p){
  switch (p) {
  case &SymbPat(x):
    return new List(new x, ps);
  case &LitPat(x):
    return new List(new (const char ?)aprintf("\"%s\"",string_escape(x)), ps);
  case &CharPat(x):
    return new List(new (const char ?)aprintf("%%d%u",x), ps);
  case &SeqPat(p1,p2):
    let ps1 = pat2string0(ps,p1);
    let ps_sp = new List(new " ",ps1);
    let ps2 = pat2string0(ps_sp,p2);
    return ps2;
  case &BinderPat(x):
    ps = new List(new "%r(",ps);
    ps = new List(new x, ps);
    ps = new List(new ")",ps);
    return ps;
  }
}

const char ?pat2string(rule_pat_t p){
  let ps = pat2string0(NULL, p);
  return strconcat_l(List::imp_rev(ps));
}

ps_list ast2string0(ps_list ps, rule_pat_t p){
  switch (p) {
  case &SymbPat(x):
    // SymbPats are deprecated
    throw new Pat_exception;
  case &LitPat(x):
    return new List(new x, ps);
  case &CharPat(x):
    char ? s = calloc(2,sizeof(char));
    s[0] = x;
    return new List(new (string_t)s, ps);
  case &SeqPat(p1,p2):
    let ps1 = pat2string0(ps,p1);
    let ps_sp = new List(new " ",ps1);
    let ps2 = pat2string0(ps_sp,p2);
    return ps2;
  case &BinderPat(x):
    throw new Pat_exception;
  }
}

// Treat a pattern as an AST and translate back into source
// string. Raises exception Pat_exception if cannot be translated
// (e.g. contains binders).
const char ?ast2string(rule_pat_t p){
  let ps = ast2string0(NULL, p);
  return strconcat_l(List::imp_rev(ps));
}


/*
rule_t pat2parse_rule(rule_pat_t p){
  switch (p) {
  case &SymbPat(x):
    return SYMB(x);
  case &LitPat(x):
    return LIT(x);
  case &CharPat(x):
    return CHARRANGE(x,x);
  case &SeqPat(p1,p2):
    return SEQ(pat2parse_rule(p1),pat2parse_rule(p2));
  case &BinderPat(x):
    let r = SYMB(x);

    let fn = fresh_name();
    r->v = fn;
    r->a = aprintf("yk_store(%s);",fn);

    return r;
  }
}
*/

bool is_special_char(unsigned int i) {
  char c = (char)i;
  return (c<' ' || c>'~' || c=='\042' || c=='\\');
}

typedef List::list_t<const char ?@> arg_list;
typedef $(char ?`r1 ?`r2, arg_list)@ pc_args<`r1,`r2>;

$(ps_list, pc_args<`r1,`r2>)@
pat2print_code0(rule_pat_t p, ps_list ps, pc_args<`r1,`r2> args){
  switch (p) {

  case &SymbPat(x):
    return new $(new List(new x, ps), args);

  case &LitPat(x):
    return new $(new List(new string_escape(x), ps), args);

  case &CharPat(x):
    if (!is_special_char(x)){
      ps = new List(new (const char ?)aprintf("%c",x), ps);
      return new $(ps,args);
    }

    // as x is a special char, we don't put it in the format string.
    // instead, we add %c to the format string and add x to the argument
    // list.
    ps = new List(new "%c", ps);
    let &$(args_in,args_out) = args;
    args_out = new List(new (const char ?)aprintf("%u",x), args_out);

    return new $(ps, new $(args_in,args_out));

  case &SeqPat(p1,p2):
    let &$(ps1, args1) = pat2print_code0(p1, ps, args);
    return pat2print_code0(p2, ps1, args1);

  case &BinderPat(_):
    // we can ignore the underlying symbol, for now, as we do no extra checking.

    ps = new List(new "%s",ps);
    let &$(args_in,args_out) = args;
    // transfer an argument from args_in to args_out
    // FIX: should check for too few args in args_in.
    args_out = new List(new (const char ?)strdup(args_in[0]), args_out);
    args_in++;

    return new $(ps, new $(args_in, args_out));
  }
}

const char ?pat2print_code(rule_pat_t p, char ?? args){
  let &$(ps, &$(args_in, args_out)) = 
    pat2print_code0(p, list(new "printf(\""), new $(args, NULL));
  ps = new List(new (args_out ? "\"," : "\""), ps);
  let args_s = str_sepstr(imp_rev(args_out), ",");
  ps = new List(new (const char ?)args_s, ps);
  ps = new List(new ")", ps);
  ps = imp_rev(ps);
  return strconcat_l(ps);
}

static const char ?escape_str = "%";
static char escape_char = '%';

static void init_esc_char(char c){
  escape_str = aprintf("%c",c);
  escape_char = c;
}

static bool is_escape_lit(rule_pat_t p){
  switch(p){
  case &LitPat(x): return strcmp(x,escape_str) == 0;
  case &CharPat(x): return x == escape_char;
  default: return false;
  }
}

static rule_pat_t unescape_char(rule_pat_t p){
  switch(p){
  case &CharPat(x): return p;
  default: 
    internal_err("Escape character not followed by CharPat.\n");
    return p;
  }
}

static const char ?unescape_lit(const char ?`H s){
  let n = strlen(s); // use strlen instead of numelts, as the latter can include padding.

  // at most, we'll need n+1 chars for the unescaped string.
  char ?@notnull s_un = calloc(n + 1, sizeof(char)); 
  int i,j;
  for (i = 0, j = 0; i < n; i++, j++){
    if (s[i] == escape_char) {
      i++; // just skip the escape char.
      if (i == n-1)
	internal_err("Found escape character %c at end of string.\n",escape_char);
    }    
    s_un[j] = s[i];
  }
  s_un[j] = '\0';
  return s_un;
}

rule_pat_t unescape_pat0(rule_pat_t p){
  switch (p) {
  case &LitPat(x):
    return new LitPat(unescape_lit(x));
  case &SeqPat(p1,p2):
    if (is_escape_lit(p1))
      return unescape_char(p2);
    return new SeqPat(unescape_pat0(p1), unescape_pat0(p2));
  case &SymbPat(_):
  case &CharPat(_):
  case &BinderPat(_):
    return p;
  }
}

rule_pat_t unescape_pat(rule_pat_t p, char esc_char){
  init_esc_char(esc_char);
  return unescape_pat0(p);
}


// Complete a sequence from a partial list of its elements,
// a list of its expected elements
// expected_args must have at least one element.
// rule_pat_t compelete_seq(list<$(int, rule_pat_t) *> args, 
// 			 const char?`H ?@notnull expected_args)
// {
//   args = sort_by_number(args);
  
//   let arg = remove(args, 1);
//   rule_pat_t seq = arg ? (rule_pat_t) arg : new MissingPat(expected_args[0]);

//   let n = numelts(expected_args);
//   for (int i=1; i<n; i++){
//     arg = remove(args, i+1);
//     if (!arg) 
//       arg = new MissingPat(expected_args[i]);
//     seq = new SeqPat(seq,arg);
//   }

//   return seq;
// }


//////////////////////////////////////////////////////////////////////
// Taken from generated code.
//////////////////////////////////////////////////////////////////////

#define YKLIMIT ykb->lim
#define YKCURSOR ykb->cur
#define YKFILL(n) (ykfill(ykb,(n)))
#define YKPOSN ((ykb->cur-ykb->bot)+ykb->discarded)
#define YKMARKER ykb->mark
#define YKSAVE ({ let x = 0; ykb->save_count++; if (ykb->save) x = ykb->cur-ykb->save; else ykb->save = ykb->cur; x; })
#define YKRESTORE(x) ({ let p = ykb->save+x; if (--ykb->save_count == 0) ykb->save=NULL; p; })

extern datatype exn {extern Parse_error };
extern datatype exn.Parse_error Parse_error_val;

//////////////////////////////////////////////////////////////////////

// We use lazyfill to simplify the fill process and to avoid having to
// eagerly compute the fill amount.  However, it should not matter
// whether any parsing functions that we link to uses lazy or eager
// fill.
static void lazyfill(ykbuf_t @ykb, unsigned int fa) {
  if (fa && ((YKLIMIT - YKCURSOR) < fa))
      YKFILL(fa);
}

static void parse_lit(ykbuf_t @ykb, const char ?x)
{
  int c; // PHASE
  int len = strlen(x);
  for (int k = 0; k < len; k++) {
    lazyfill(ykb, 1);
    c = *YKCURSOR++; //PHASE
    let orig = x[k];
    let l = tolower(orig);
    let u = toupper(orig);
    if (c!=l && c!=u) throw &Parse_error_val; // PHASE
  }

//   lazyfill(ykb, len);
//   for (int k = 0; k < len; k++) {
//     c = *YKCURSOR++; //PHASE
//     let orig = x[k];
//     let l = tolower(orig);
//     let u = toupper(orig);
//     if (c!=l && c!=u) throw &Parse_error_val; // PHASE
//   }
}

static void parse_char(ykbuf_t @ykb, unsigned int x)
{
  int c; // PHASE
  lazyfill(ykb,1);
  c = *YKCURSOR++; //PHASE
  let l = tolower(x);
  let u = toupper(x);
  if (c!=l && c!=u) throw &Parse_error_val; // PHASE  
}

static void parse_sym(ykbuf_t @`r ykb, Funtable::table_t parse_funs, const char ?`H x)
{
  try{
    let parse_x = Funtable::lookup(parse_funs, x);
    parse_x(ykb);
  }catch {
  case &Core::Not_found: 
    eprintf("Failed to find definition of symbol %s. Skipping...\n", x);    
    break;
  }
}

strptr_array<`r1,`r2>
parse_with_pat0(ykbuf_t @`r ykb, Funtable::table_t parse_funs, 
	       rule_pat_t p, strptr_array<`r1,`r2> args){
  switch (p) {
  case &SymbPat(x):
    parse_sym(ykb,parse_funs,x);
    return args;
  case &LitPat(x):
    parse_lit(ykb,x);
    return args;  
  case &CharPat(c):
    parse_char(ykb,c);
    return args;  
  case &SeqPat(p1,p2):
    args = parse_with_pat0(ykb,parse_funs,p1,args);
    args = parse_with_pat0(ykb,parse_funs,p2,args);
    return args;  
//   case &RepeatPat(n,p1):
//     for (int i=0; i<n; i++)
//       args = parse_with_pat0(ykb,parse_funs,p1,args);
//     return args;
//   case &DepSeqPat(p1,f):
//     let save = YKSAVE;
//     args = parse_with_pat0(ykb,parse_funs,p1,args);    
//     unsigned char ?@nozeroterm ykr = YKRESTORE(save);
//     let x = substring((const char ?@nozeroterm)ykr,0,YKCURSOR-ykr);
//     let p2 = Fn::apply(f,x);
//     args = parse_with_pat0(ykb,parse_funs,p2,args);
//     return args;
  case &BinderPat(x):
    let save = YKSAVE;
    parse_sym(ykb,parse_funs,x);
    unsigned char ?@nozeroterm ykr = YKRESTORE(save);
    let x_str = substring((const char ?@nozeroterm)ykr,0,YKCURSOR-ykr);
    **args = x_str;
    return ++args;  
  }
}

void
parse_with_pat(ykbuf_t @`r ykb, Funtable::table_t parse_funs, 
	       rule_pat_t p, strptr_array<`r1,`r2> args){
  parse_with_pat0(ykb,parse_funs,p,args);
}

int
crawl_with_pat0(rule_pat_t p, EarleyParsetree::parse_tree_t ? children, 
    unsigned char ? @nozeroterm ykinput,
    strptr_array<`r1,`r2> args) {
  int num_scanned = 0;
  
  let pats = List::list(p);
  while (pats) {
    switch (pats->hd) {
    case &SymbPat(x):
      children++;
      pats = pats->tl;
      break;
    case &BinderPat(x):
      let x_str = substring(ykinput, children[0]->left, children[0]->right - children[0]->left);
      **args = x_str;
      args++;
      children++;
      pats = pats->tl;
      num_scanned++;
      break;
    case &LitPat(_):
    case &CharPat(_):
      // do nothing -- just advance pats. literals don't show up in parse tree;
      pats = pats->tl;
      break;
    case &SeqPat(p1,p2):
      // replace the hd with p1 and p2.
      pats = new List::List(p1, new List::List(p2, pats->tl));
      break;
    }

  }
  
  return num_scanned;
}

int
crawl_with_pat(rule_pat_t p, EarleyParsetree::parse_tree_t pt, 
    unsigned char ? @nozeroterm ykinput,
    strptr_array<`r1,`r2> args){
  let &EarleyParsetree::parse_tree(name,i,j,w,children) = pt;
  return crawl_with_pat0(p,children,ykinput,args);
}

//   switch (p) {
//   case &SymbPat(x):
//   case &LitPat(x):
//   case &CharPat(c):
//   case &SeqPat(p1,p2):
//   case &BinderPat(x):
//   }
