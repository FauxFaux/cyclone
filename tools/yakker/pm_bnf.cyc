#include <core.h>
#include <list.h>
#include <stdio.h>
#include <string.h>

#include "bnf.h"
#include "util.h"
#include "pm_bnf.h"

using List;

rule_pat_t pats2seq(list_t<rule_pat_t> pats){
  if (!pats)
    return new LitPat("");

  let res = pats->hd;
  pats = pats->tl;
  for (;pats; pats = pats->tl){
    res = new SeqPat(res,pats->hd);
  }
  return res;
}


typedef List::list_t<const char ?`H@`H,`H> ps_list;

ps_list pat2string0(ps_list ps, rule_pat_t p){
  switch (p) {
  case &SymbPat(x):
    return new List(new x, ps);
  case &LitPat(x):
    return new List(new (const char ?)aprintf("\"%s\"",string_escape(x)), ps);
  case &CharPat(x):
    return new List(new (const char ?)aprintf("%%d%u",x), ps);
  case &SeqPat(p1,p2):
    let ps1 = pat2string0(ps,p1);
    let ps_sp = new List(new " ",ps1);
    let ps2 = pat2string0(ps_sp,p2);
    return ps2;
  case &WildcardPat(x):
    ps = new List(new "%r(",ps);
    ps = new List(new x, ps);
    ps = new List(new ")",ps);
    return ps;
  }
}

const char ?pat2string(rule_pat_t p){
  let ps = pat2string0(NULL, p);
  return strconcat_l(List::imp_rev(ps));
}


rule_t pat2parse_rule(rule_pat_t p){
  switch (p) {
  case &SymbPat(x):
    return SYMB(x);
  case &LitPat(x):
    return LIT(x);
  case &CharPat(x):
    return CHARRANGE(x,x);
  case &SeqPat(p1,p2):
    return SEQ(pat2parse_rule(p1),pat2parse_rule(p2));
  case &WildcardPat(x):
    let r = SYMB(x);

    let fn = fresh_name();
    r->v = fn;
    r->a = aprintf("yk_store(%s);",fn);

    return r;
  }
}

bool is_special_char(unsigned int i) {
  char c = (char)i;
  return (c<' ' || c>'~' || c=='\042' || c=='\\');
}

typedef List::list_t<const char ?@> arg_list;
typedef $(char ?`r1 ?`r2, arg_list)@ pc_args<`r1,`r2>;

$(ps_list, pc_args<`r1,`r2>)@
pat2print_code0(rule_pat_t p, ps_list ps, pc_args<`r1,`r2> args){
  switch (p) {

  case &SymbPat(x):
    return new $(new List(new x, ps), args);

  case &LitPat(x):
    return new $(new List(new string_escape(x), ps), args);

  case &CharPat(x):
    if (!is_special_char(x)){
      ps = new List(new (const char ?)aprintf("%c",x), ps);
      return new $(ps,args);
    }

    // as x is a special char, we don't put it in the format string.
    // instead, we add %c to the format string and add x to the argument
    // list.
    ps = new List(new "%c", ps);
    let &$(args_in,args_out) = args;
    args_out = new List(new (const char ?)aprintf("%u",x), args_out);

    return new $(ps, new $(args_in,args_out));

  case &SeqPat(p1,p2):
    let &$(ps1, args1) = pat2print_code0(p1, ps, args);
    return pat2print_code0(p2, ps1, args1);

  case &WildcardPat(_):
    // we can ignore the underlying symbol, for now, as we do no extra checking.

    ps = new List(new "%s",ps);
    let &$(args_in,args_out) = args;
    // transfer an argument from args_in to args_out
    // FIX: should check for too few args in args_in.
    args_out = new List(new (const char ?)strdup(args_in[0]), args_out);
    args_in++;

    return new $(ps, new $(args_in, args_out));
  }
}

const char ?pat2print_code(rule_pat_t p, char ?? args){
  let &$(ps, &$(args_in, args_out)) = 
    pat2print_code0(p, list(new "printf(\""), new $(args, NULL));
  ps = new List(new (args_out ? "\"," : "\""), ps);
  let args_s = str_sepstr(imp_rev(args_out), ",");
  ps = new List(new (const char ?)args_s, ps);
  ps = new List(new ")", ps);
  ps = imp_rev(ps);
  return strconcat_l(ps);
}

static const char ?escape_str = "%";
static const char escape_char = '%';

static bool is_escape_lit(rule_pat_t p){
  switch(p){
  case &LitPat(x): return strcmp(x,escape_str) == 0;
  case &CharPat(x): return x == escape_char;
  default: return false;
  }
}

static rule_pat_t unescape_char(rule_pat_t p){
  switch(p){
  case &CharPat(x): return p;
  default: 
    internal_err("Escape character not followed by CharPat.\n");
    return p;
  }
}

static const char ?unescape_lit(const char ?`H s){
  let n = strlen(s); // use strlen instead of numelts, as the latter can include padding.

  // at most, we'll need n+1 chars for the unescaped string.
  char ?@notnull s_un = malloc((n + 1)* sizeof(char)); 
  int i,j;
  for (i = 0, j = 0; i < n; i++, j++){
    if (s[i] == escape_char) {
      i++; // just skip the escape char.
      if (i == n-1)
	internal_err("Found escape character %c at end of string.\n",escape_char);
    }    
    s_un[j] = s[i];
  }
  s_un[j] = '\0';
  return s_un;
}

rule_pat_t unescape_pat(rule_pat_t p){
  switch (p) {
  case &LitPat(x):
    return new LitPat(unescape_lit(x));
  case &SeqPat(p1,p2):
    if (is_escape_lit(p1))
      return unescape_char(p2);
    return new SeqPat(unescape_pat(p1), unescape_pat(p2));
  case &SymbPat(_):
  case &CharPat(_):
  case &WildcardPat(_):
    return p;
  }
}

