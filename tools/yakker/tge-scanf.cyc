#include <core.h>
#include <stdio.h>
#include "earley-parsetree.h"
#include "earley-backend.h"
#include "dfa.h"
#include "pm_bnf.h"

#include "tge-scanf.h"

#include "ykbuf.h"
#define YKLIMIT ykb->lim
#define YKCURSOR ykb->cur
#define YKFILL(n) (ykfill(ykb,(n)))
#define YKPOSN ((ykb->cur-ykb->bot)+ykb->discarded)
#define YKMARKER ykb->mark
#define YKSAVE ({ let x = 0; ykb->save_count++; if (ykb->save) x = ykb->cur-ykb->save; else ykb->save = ykb->cur; x; })
#define YKRESTORE(x) ({ let p = ykb->save+x; if (--ykb->save_count == 0) ykb->save=NULL; p; })


static struct EarleyAnyBackend::DFA::grammar_edfa *grammar = NULL;

static EarleyAnyBackend::DFA::grammar_edfa_t 
get_grammar(){
  if (!grammar){
    // fprintf(stderr, "Loading grammar dfa from grammar_dfa.txt.\n");
    let gr_edfa = FsmDFA::fsm2grm_edfa("grammar_dfa.txt");
    grammar = gr_edfa;
    return gr_edfa;
  } else 
    return grammar;
}


//int internal_scanf (EarleyCycBackend::DFA:edfa_t dfa_rep,
//                    ykbuf_t@ ykb_source, ykbuf_t@ ykb_fmt, const char?`H @ ?args){

int internal_ykb_scanf (
    EarleyAnyBackend::DFA::edfa_t fs_dfa_obj, fmt_crawl_fun fmt_crawl,
    EarleyAnyBackend::DFA::grammar_edfa_t gr_edfa,
    ykbuf_t@ ykb, string_t format_string, string_t<`H> @ ?args){

  // Parse the format string
  let $(trees, valid, valid_prefix) = EarleyAnyBackend::parse(fs_dfa_obj,format_string); 
  if (!valid) { 
    return -1;
  }
  
//  if (trees->tl) {
//    fprintf(stderr,"Ambiguous parse. Choosing first derivation.\n");
//  }

  // "tree" encodes top-level regexp, but we want to crawl starting from symbol
  // with regexp.
  let child_tree = trees->hd->f0->children[0];
  let rule_pat = fmt_crawl(child_tree, format_string);

//  fprintf(stderr,"Parsed pattern %s.\n",pat2string(rule_pat));

  let input_ext_dfa_obj = ExtAnyDFA::pat2dfa(rule_pat, gr_edfa);

//  ExtDFA::dfa_dot(ext_edfa);
  
//  fprintf(stderr,"Parsing input.\n");
  let input_dfa_obj = ExtAnyDFA::mk_any_eb(input_ext_dfa_obj); // "upcast" to plain edfa.

  let ykb_save = YKSAVE;
  // Parse the actual input
  fprintf(stderr,"Parsing actual input.\n");  
  let $(input_trees, input_valid, input_valid_prefix) = 
    EarleyAnyBackend::ykb_parse(input_dfa_obj,ykb,0);
  fprintf(stderr,"Done parsing actual input.\n");  

  if (!input_valid) {
    YKCURSOR = YKRESTORE(ykb_save);
    return -1;
  }
  
//  fprintf(stderr,"done -- is valid string :%d; is valid prefix: %d\n", input_valid,
//      input_valid_prefix);
//  if (input_trees->tl) {
//    fprintf(stderr,"Ambiguous parse. Choosing first derivation.\n");
//  }
//  if (do_print_input) {
//    EarleyParsetree::print_tree(input_trees->hd->f0,input_print_depth);
//    printf("\n");
//  }

  let res = crawl_with_pat(rule_pat, input_trees->hd->f0, ykb->save + ykb_save, args);
  YKRESTORE(ykb_save); // commit: don't set YKCURSOR, because we don't want to rewind the input.
                       // the purpose of the save was only to prevent discarding.
  return res;
}

int internal_scanf (
    EarleyAnyBackend::DFA::edfa_t fs_dfa_obj, fmt_crawl_fun fmt_crawl,
    EarleyAnyBackend::DFA::grammar_edfa_t gr_edfa,
    string_t input, string_t format_string, string_t<`H> @ ?args)
{
  let ykinput = string2ykbuf(input);
  return internal_ykb_scanf(fs_dfa_obj, fmt_crawl<>, gr_edfa, ykinput, format_string, args);
}
