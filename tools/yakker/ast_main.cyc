#include <buffer.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "bnf.h"
#include "pr.h"
#include "ykbuf.h"
#include "tg_stack.h"
#include "pm_bnf.h"

#define YKPOSN ((ykb->cur-ykb->bot)+ykb->discarded)

extern int ykdebug;
extern datatype exn {extern Parse_error };
extern datatype exn.Parse_error Parse_error_val;

extern rule_pat_t p_command(ykbuf_t @ykb);
extern rule_pat_t p_seq_range(ykbuf_t @ykb);
// extern void p_command_pm(ykbuf_t @ykb);
// extern void p_seq_range_pm(ykbuf_t @ykb);

enum Root_rule{
  Command, Seq_range
};

enum Mode{ Print, Parse };

#define USAGE \
"Usage:%s [OPTIONS]\n"\
"Options: -root <sym>            parse starting from rule <sym>\n"\
"         -d                     increase debug level by 1.\n"\
"         -help                  print this message\n"

static void die(const char ?prog_name) {
  fprintf(stderr,USAGE,prog_name);
  exit(1);
}

static struct Attr empty_attr = Attr{.ws=0,.re=0,.paramtype=NULL,.rettype=NULL};

int main(int argc, char ??argv) {
  // position of last record in the stream.
  int last_record_posn = 0;
  int do_unescape_pat = 0;
  enum Root_rule root = Command;
  enum Mode mode = Parse;

  const char ? def_name = "my-command"; // implicit name of symbol defined by format string.

  unsigned int start_args = argc; // index in argv of first argument
				  // to our printer. Default indicates
				  // that no arguments arg present in
				  // argv.

  for (int i = 1; i < argc; i++) {
    if (     strcmp(argv[i],  "-help") == 0) die(argv[0]);
    else if (strcmp(argv[i],  "-d"   ) == 0) ykdebug++;
    else if (strcmp(argv[i],  "-print"   ) == 0) mode = Print;
    else if (strcmp(argv[i],  "-unescape-pat"   ) == 0) do_unescape_pat = 1;
    else if (strcmp(argv[i],  "-args") == 0) {start_args = i+1; break;}
    else if(strcmp(argv[i],   "-root") == 0){
      if (i+1 >= argc) die(argv[0]);
      if (strcmp(argv[i+1],"command") == 0)         root = Command;
      else if (strcmp(argv[i+1],"seq-range") == 0)  root =  Seq_range;
      else { fprintf(stderr,"Unrecognized rule name: %s\n",argv[i+1]); exit(1); }
      i += 1;
    }
    else if(strcmp(argv[i],   "-name") == 0){
      if (i+1 >= argc) die(argv[0]);
      def_name = strdup(argv[++i]);
    }
    else { fprintf(stderr,"Unrecognized option: %s\n",argv[i]); exit(1); }
  }


  // Initialize term grammar stack
  tg_init(argv + start_args);

  ykbuf_t @ykb = fd2ykbuf(0); // read from stdin
  rule_pat_t p;
  try {
    // parse input until we hit an error (or EOF)
    while (1) { 
//       char ?@nozeroterm b =
//       ykbuf_t @ykb = data2ykbuf(b); 
//       read(0,b,n); // read from stdin
      tg_init(argv);

      switch(root){
      case Command : 
	p = p_command(ykb); break;
      case Seq_range : 
	p = p_seq_range(ykb); break;
      default :
	fprintf(stderr,"Unknown symbol."); 
	exit(1);
      }

      if (do_unescape_pat) p = unescape_pat(p);

      switch(mode){
      case Parse:
	let r = pat2parse_rule(p);
	let grm_r = List::list(new $(def_name,r,empty_attr));
	pr_definitions(stdout, grm_r);
	fprintf(stdout,"{#include \"small_imap.h\"}\n");
	fprintf(stdout,"{#include \"tg_stack.h\"}\n");
//    gen(grm_r, def_name, 
// 	  List::list(new "#include \"small_imap.h\"", "#include \"tg_stack.h\""), 1, 0);
	break;
      case Print:
	let s = pat2print_code(p,argv + start_args);
	printf("%s\n",s);
	break;
      default:
	fprintf(stderr,"Unrecognized mode.");
      }
      //let n = YKPOSN;
      //if (n<60) for (int i = 0; i < n; i++) printf("^");
      //printf(" accepted %d (0x%x) characters\n",n,n);

//       printf("Result: %s\n", tg_pop());

      // consume newline
      char c = 0;
      let sz = ykbread(&c,1,ykb);
      if (1 != sz || '\n' != c)  // missing newline.
	throw &Parse_error_val;      
      printf("\n");
      last_record_posn = YKPOSN;
    }
  }
  catch {
  case &Parse_error:
    let n = YKPOSN - last_record_posn;
    if (n == 0){
      break; // stopped because reached empty line; program done.
    }
    // Otherwise, there was an error.
    printf("\n");
    if (n<60) for (int i = 0; i < n; i++) printf(" ");
    printf("^ failed at position %d (0x%x)\n",n,n);
    break;
  }
  

  return 0;
}
