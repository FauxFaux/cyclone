/* This file is part of the Cyclone Library.
   Copyright (C) 1999-2001 Greg Morrisett, Dan Grossman

   This library is free software; you can redistribute it and/or it
   under the terms of the GNU Lesser General Public License as
   published by the Free Software Foundation; either version 2.1 of
   the License, or (at your option) any later version.

   This library is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with this library; see the file COPYING.LIB.  If not,
   write to the Free Software Foundation, Inc., 59 Temple Place, Suite
   330, Boston, MA 02111-1307 USA. */

// defines generic imperative queues and various operations
// following the conventions of the Ocaml queue library as much
// as possible.

#include <core.h>
#include <list.h>
#include <queue.h>

namespace Queue;

using List;

struct Queue<`a,`r::R> { 
  list_t<`a,`r> front; 
  list_t<`a,`r> rear; 
  unsigned int len;
};

// true when the queue is empty
bool is_empty(queue_t q)  {
   return(q->front == NULL);
}

// raised by take and peek
xtunion exn { Empty };

// create a new queue
queue_t create() {
  return new Queue(NULL,NULL,0);
}

// insert an element into the rear of the queue (side effect)
void radd(region_t<`r> r, queue_t<`a,`r> q,`a x) {
  list_t cell = rnew(r) List(x,NULL);

  if (q->front == NULL) {
    q->front = cell;
    q->rear = cell;
  } else {
    q->rear->tl = cell;
    q->rear = cell;
  }
  q->len++;
}

void add(queue_t<`a,`H> q, `a x) {
  radd(Core::heap_region,q,x);
}

// insert an element into the front of the queue (side effect)
void rpush(region_t<`r> r, queue_t<`a,`r> q,`a x) {
  q->front = rnew(r) List(x,q->front);
  if (q->rear == NULL)
    q->rear = q->front;
  q->len++;
}

void push(queue_t<`a,`H> q, `a x) {
  rpush(Core::heap_region,q,x);
}

// get and remove an element from the front of the queue (side effect)
`a take(queue_t<`a> q) {
  if (q->front == NULL)
    throw Empty; // FIX: toc problems if we try to return this.
  //    return (throw Empty);
  else {
    let x = q->front->hd;
    q->front = q->front->tl;
    if (q->front == NULL) {  // necessary to ensure last cell is
      q->rear = NULL;        // garbage collected
    }
    q->len--;
    return x;
  }
}

// return the first element in the queue without removing it
`a peek(queue_t<`a> q) {
  if (q->front == NULL)
    throw Empty; // FIX: toc problems if we try to return this.
  else {
    return(q->front->hd);
  }
}

// clear out the entire queue (side effect)
void clear(queue_t<`a> q) {
  q->front = NULL;
  q->rear = NULL;
  q->len = 0;
}

// remove a specific member (side effect)
void remove(queue_t<`a,`r> q,`a v) {
  list_t<`a,`r> x, y;
  for (x = q->front, y = NULL; x != NULL; y = x, x = x->tl) {
    if (x->hd == v) {
      // fix pointers at the front of the q
      if (q->front == x)
	q->front = x->tl;
      else
	y->tl = x->tl;
      // fix pointers at the rear
      if (q->rear == x) {
	q->rear = y;
      }
      break;
    }      
  }
}

list_t<`a,`r> rfilter_c(region_t<`r> r, bool f(`b,`a), `b env, queue_t<`a> q){
  return List::rfilter_c(r,f,env,q->front);
}

// return the number of elements in the queue
int length(queue_t<`a> q) {
//    return(List::length(q->front));
  return q->len;
}

// apply f to each element in the queue from the front to the back
void iter(void f(`a), queue_t<`a> q) {
  for (list_t<`a> x = q->front; x != NULL; x = x->tl) {
    f(x->hd);
  }
}
void app(`b f(`a), queue_t<`a> q) {
  for (list_t<`a> x = q->front; x != NULL; x = x->tl) {
    f(x->hd);
  }
}
