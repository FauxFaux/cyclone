/* This file is part of the Cyclone Library.
   Copyright (C) 1999-2001 Greg Morrisett, Dan Grossman

   This library is free software; you can redistribute it and/or it
   under the terms of the GNU Lesser General Public License as
   published by the Free Software Foundation; either version 2.1 of
   the License, or (at your option) any later version.

   This library is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with this library; see the file COPYING.LIB.  If not,
   write to the Free Software Foundation, Inc., 59 Temple Place, Suite
   330, Boston, MA 02111-1307 USA. */

// defines generic imperative queues and various operations
// following the conventions of the Ocaml queue library as much
// as possible.

#include <list.h>
#include <queue.h>

namespace Queue;

using List;

struct Queue<`a,`r::R> { glist_t<`a,`r> front; glist_t<`a,`r> rear; };

// true when the queue is empty
bool is_empty(gqueue_t<`a,`r> q)  {
   return(q->front == null);
}

// raised by take and peek
xtunion exn { Empty };

// create a new queue
queue_t<`a> create() {
  return new Queue(null,null);
}

// insert an element into the rear of the queue (side effect)
void add(queue_t<`a> q,`a x) {
  list_t<`a> cell = new List(x,null);

  if (q->front == null) {
    q->front = cell;
    q->rear = cell;
  } else {
    q->rear->tl = cell;
    q->rear = cell;
  }
}

// get and remove an element from the front of the queue (side effect)
`a take(gqueue_t<`a,`r> q) {
  if (q->front == null)
    throw Empty; // FIX: toc problems if we try to return this.
  //    return (throw Empty);
  else {
    let x = q->front->hd;
    q->front = q->front->tl;
    if (q->front == null) {  // necessary to ensure last cell is
      q->rear = null;        // garbage collected
    }
    return x;
  }
}

// return the first element in the queue without removing it
`a peek(gqueue_t<`a,`r> q) {
  if (q->front == null)
    throw Empty; // FIX: toc problems if we try to return this.
  else {
    return(q->front->hd);
  }
}

// clear out the entire queue (side effect)
void clear(gqueue_t<`a,`r> q) {
  q->front = null;
  q->rear = null;
}

// return the number of elements in the queue
int length(gqueue_t<`a,`r> q) {
  return(List::length(q->front));
}

// apply f to each element in the queue from the front to the back
void iter(void f(`a), gqueue_t<`a,`r> q) {
  for (glist_t<`a,`r> x = q->front; x != null; x = x->tl) {
    f(x->hd);
  }
}
void app(`b f(`a), gqueue_t<`a,`r> q) {
  for (glist_t<`a,`r> x = q->front; x != null; x = x->tl) {
    f(x->hd);
  }
}
