/* This file is part of the Cyclone Library.
   Copyright (C) 2001 Greg Morrisett, AT&T

   This library is free software; you can redistribute it and/or it
   under the terms of the GNU Lesser General Public License as
   published by the Free Software Foundation; either version 2.1 of
   the License, or (at your option) any later version.

   This library is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with this library; see the file COPYING.LIB.  If not,
   write to the Free Software Foundation, Inc., 59 Temple Place, Suite
   330, Boston, MA 02111-1307 USA. */

/* This file defines the low-level representation of Cyclone data
   for implementing generic marshallers. */

#define TYPEREP_CYC /* instantiate the the type */

#include "typerep.h"
#include <stdio.h>
#include <dict.h>
#include <string.h>

using Typerep;
using Dict;


namespace Typerep;


static int int_cmp(unsigned int a, unsigned int b) {
  if(a == b) return 0;
  else if (a < b) return 1;
  else return -1;
}

addr_set_t empty_addr_set () {
  return Set::empty(int_cmp);
}


/*-------------------------------------------------------------------------*/
/* given a tag and a list of typereps, each assumed to be a TUnionField,
   look up the tag in the list and return the corresponding type
   (assumed to be a tuple) */
tunion `r Typestruct
get_unionbranch(unsigned int tag,
		$(unsigned int,tunion `r Typestruct)@ ? l)
{
//    fprintf(stderr,"looking for tag %d\n",tag);
  for (int i = 0; i < l.size; i++) {
    let $(btag,typ) = *(l[i]);
//      fprintf(stderr,"  checking tag %d\n",btag);
    if (btag == tag)
      return typ;
  }
//    fprintf(stderr,"didn't find it\n");
  throw new Core::Failure("Could not find tag in TUnion");
}


/*-------------------------------------------------------------------------*/
/* given a tag and a list of typereps, each assumed to be a TUnionField,
   look up the tag in the list and return the corresponding type
   (assumed to be a tuple) */
tunion `r Typestruct
get_xtunionbranch(string_t<`H> tag,
		$(string_t<`H>,tunion `r Typestruct)@ ? l)
{
  //fprintf(stderr,"looking for tag %s (%x)\n",tag,(int)tag);
  for (int i = 0; i < l.size; i++) {
    let $(btag,typ) = *(l[i]);
    //fprintf(stderr,"  checking tag %s (%x)\n",btag,(int)btag);
    if (strcmp(btag,tag) == 0)
      return typ;
  }
  //fprintf(stderr,"didn't find it\n");
  throw new Core::Failure("Could not find tag in XTUnion");
}

/*-------------------------------------------------------------------------*/
/* returns the size, in bytes, of the toplevel type */
unsigned int 
size_type(typestruct_t rep) 
{
  switch (rep) {
  case &Int(szbits): return (szbits>>3);
  case Float: return sizeof(float);
  case Double: return sizeof(double);
  case &ThinPtr(_,_): return sizeof(void *);
  case &FatPtr(_): return sizeof(void ?);
  case &Tuple(szb,_): return szb;
  case &TUnion(_): return sizeof(void *);
  case &XTUnion(_): return sizeof(void *);
  case &Union(tss): 
    int max = 0;
    for(int i = 0; i < tss.size; i++) {
      let sz = size_type(*tss[i]);
      max = (max < sz)? sz : max;
    }
    return max;
  case &Var(_): return sizeof(void*); // everything of mem kind has same size as void*
  case &Forall(_,rep): return sizeof(rep);
  case &App(rep,_): return sizeof(rep);

    //  default: throw new Core::Failure("Unhandled case in size_type");
  }
}



// returns whether elt is a member, inserts if it's not
$(bool, addr_set_t)@ member_insert(addr_set_t set, unsigned int val) {
  return new $(Set::member(set,val), Set::insert(set,val));
}


/*-------------------------------------------------------------------------*/
/* Pretty-prints a typestruct for debugging purposes */
void 
print_typestruct(typestruct_t rep) 
{
  switch (rep) {
  case &Var(name):
    printf("Var(%s)",*name);
    break;

  case &Int(sz):
    printf("Int(%d)",sz);
    break;

  case Float:
    printf ("Float");
    break;

  case Double:
    printf ("Double");
    break;

  case &ThinPtr(sz,typ):
    printf("ThinPtr(%d,", sz);
    print_typestruct(typ);
    printf(")");
    break;

  case &FatPtr(typ): 
    printf("FatPtr(");
    print_typestruct(typ);
    printf(")");
    break;

  case &Tuple(sz,l):
    printf("Tuple(%d,[",sz);
    for (int i = 0; i < l.size; i++) {
      let $(ofs,typ) = *(l[i]);
      printf ("$(%d,",ofs);
      print_typestruct(typ);
      printf (")%c", (i != (l.size-1) ? ',' : ' '));
    }
    printf(" ]");
    break;

  case &TUnion(l):
    printf("TUnion(");
    for (int i = 0; i < l.size; i++) {
      let $(tag,typ) = *(l[i]);
      printf ("$(%d,",tag);
      print_typestruct(typ);
      printf (")%c", (i != (l.size-1) ? ',' : ' '));
    }    
    printf(" )");
    break;
  case &XTUnion(l):
    printf("XTUnion(");
    for (int i = 0; i < l.size; i++) {
      let $(tag,typ) = *(l[i]);
      printf ("$(%s,",tag+4);
      print_typestruct(typ);
      printf (")%c", (i != (l.size-1) ? ',' : ' '));
    }    
    printf(" )");
    break;
 case &Union(l):
   printf("Union(");
   for (int i = 0; i < l.size; i++) {
      print_typestruct(*l[i]);
      printf ("%c", (i != (l.size-1) ? ',' : ' '));
    }   
   printf(")");
   break;
 case &Forall(names,ts):
   printf("Forall([");
   for(int i = 0; i < names.size; i++) {
     printf(*names[i]);
     printf ("%c", (i != (names.size-1) ? ',' : ' '));
   }
   printf("],");
   print_typestruct(*ts);
   printf(")");
   break;
 case &App(ts,params):
   printf("App(");
   print_typestruct(ts);
   printf(",[");
   for(int i = 0; i < params.size; i++) {
     print_typestruct(params[i]);
     printf ("%c", (i != (params.size-1) ? ',' : ' '));
   }
   printf("])");
   break;
  }

}


/*-------------------------------------------------------------------------*/
/* XMLizes a typestruct for debugging purposes */
void 
xmlize_typestruct(typestruct_t rep) 
{
  switch (rep) {
  case &Var(name):
    printf("<Var name=\"%s\"/>",*name);
    break;
  case &Int(sz):
    printf("<Int sz=\"%d\"/>",sz);
    break;

  case Float:
    printf ("<Float/>");
    break;

  case Double:
    printf ("<Double/>");
    break;

  case &ThinPtr(sz,typ):
    printf("<ThinPtr sz=\"%d\">", sz);
    xmlize_typestruct(typ);
    printf("</ThinPtr");
    break;

  case &FatPtr(typ): 
    printf("<FatPtr>");
    xmlize_typestruct(typ);
    printf("</FatPtr>");
    break;

  case &Tuple(sz,l):
    printf("<Tuple sz=\"%d\">",sz);
    for (int i = 0; i < l.size; i++) {
      let $(ofs,typ) = *(l[i]);
      printf ("<Component ofs=\"%d\">",ofs);
      xmlize_typestruct(typ);
      printf ("</Component>");
    }
    printf("</Tuple>");
    break;

  case &TUnion(l):
    printf("<TUnion>");
    for (int i = 0; i < l.size; i++) {
      let $(tag,typ) = *(l[i]);
      printf ("<Tag tag=\"%d\">",tag);
      xmlize_typestruct(typ);
      printf ("</Tag>");
    }    
    printf("</Tunion>");
    break;
  case &XTUnion(l):
    printf("<XTUnion>");
    for (int i = 0; i < l.size; i++) {
      let $(tag,typ) = *(l[i]);
      printf ("<Tag tag=\"%s\">",tag+4);
      xmlize_typestruct(typ);
      printf ("</Tag>");
    }    
    printf("</XTunion>");
    break;
 case &Union(l):
   printf("<Union>");
   for (int i = 0; i < l.size; i++) {
      printf ("<Case>");
      xmlize_typestruct(*l[i]);
      printf ("</Case>");
    }   
   printf("</Union>");
   break;
 case &Forall(names,ts):
   printf("<Forall vars=\"");
   for(int i = 0; i < names.size; i++) {
     if(i != 0) printf(", ");
     printf(*names[i]);
   }
   printf("\">");
   xmlize_typestruct(*ts);
   printf("</Forall>");
   break;
 case &App(ts,params):
   printf("<App>");
   xmlize_typestruct(ts);
   for(int i = 0; i < params.size; i++) {
     if(i != 0) printf(", ");
     xmlize_typestruct(params[i]);
   }
   printf("</App>");
   break;
  }
}


static typestruct_t<`H>
normalize_env(dict_t<name_t,typestruct_t<`H>,`H> env,
	      typestruct_t<`H> ts) {
  switch (ts) {
  case &Var(name): 
    return Dict::lookup(env,(string_t@`H)name);
  
  case &Int(_): fallthru;
  case Float:  fallthru;
  case Double:
    return ts;
  case &ThinPtr(wd,ts2):
    return new ThinPtr(wd,normalize_env(env,ts2));
  case &FatPtr(ts2):
    return new FatPtr(normalize_env(env,ts2));
  case &Tuple(sz, fields):
    let newfields = new {for i < fields.size: NULL};
    for(int i = 0; i < fields.size; i++) {
      let &$(x,tsi) = fields[i];
      newfields[i] = new $(x,normalize_env(env,tsi));
    }
    let newfields2 = new {for i < fields.size: (_@)newfields[i]};
    
    return new Tuple(sz,(_?)newfields2);

  case &TUnion(fields):
    let newfields = new {for i < fields.size: NULL};
    for(int i = 0; i < fields.size; i++) {
      let &$(x,tsi) = fields[i];
      newfields[i] = new $(x,normalize_env(env,tsi));
    }
    let newfields2 = new {for i < fields.size: (_@)newfields[i]};
    
    return new TUnion((_?)newfields2);


  case &XTUnion(fields):
    let newfields = new {for i < fields.size: NULL};
    for(int i = 0; i < fields.size; i++) {
      let &$(x,tsi) = fields[i];
      newfields[i] = new $(x,normalize_env(env,tsi));
    }
    let newfields2 = new {for i < fields.size: (_@)newfields[i]};
    
    return new XTUnion((_?)newfields2);


  case &Union(tss):
    let newfields = new{for i < tss.size:NULL};
    for(int i = 0; i < tss.size; i++) {
      newfields[i] = new normalize_env(env,*tss[i]);
    }
    let newfields2 = new {for i < tss.size: (_@)newfields[i]};
    
    return new Union((_?)newfields2);

  case &Forall(names,ts2):
    return new Forall(names,new normalize_env(env,*ts2));
  case &App(ts2, tss):
    switch(normalize_env(env,ts2)) { // Slow!
    case &Forall(names,ts3) :
      if(tss.size != names.size) 
	throw new Core::Failure("app appiled wrong number of arguments");
      for(int i = 0; i < tss.size; i++) {
	env=Dict::insert(env,names[i],tss[i]);
      }
      return normalize_env(env,*ts3);
    default: throw new Core::Failure("app misapplied");
    }

  }
}
	
int name_order(name_t s1, name_t s2) {
  return strcmp(*s1,*s2);
}

typestruct_t<`H> normalize(typestruct_t<`H> ts) {
  return normalize_env(Dict::empty(name_order),ts);
}			  

/*
$(addr_set_t,int) genreic_cmp_base(typestruct_t rep, 
				   addr_set_t base, 
				   `a@ val1, `a@ val2) {
  switch (rep) {
  case &Int(sz):
    switch (sz) {
    case 8:
      char @x = unsafe_cast(val1);
      char @y = unsafe_cast(val2);
      if(*x < *y) return 1;
      else if (*x == *y) return 0;
      else return -1;
      break;
    case 16:
      short @x = unsafe_cast(val1);
      short @y = unsafe_cast(val2);
      if(*x < *y) return 1;
      else if (*x == *y) return 0;
      else return -1;
      break;
    case 32:
      int @x = unsafe_cast(val1);
      int @y = unsafe_cast(val2);
      if(*x < *y) return 1;
      else if (*x == *y) return 0;
      else return -1;
      break;
    default:
      fprintf(stderr,"print_type_base: illegal int size %d bits\n", sz);
      exit(1);
    }
    break;
  
  case Float:
    float @x = unsafe_cast(val1);
    float @y = unsafe_cast(val2);
    if(*x < *y) return 1;
    else if (*x == *y) return 0;
    else return -1;
    break;
  
  case Double:
    double @x = unsafe_cast(val1);
    souble @y = unsafe_cast(val2);
    if(*x < *y) return 1;
    else if (*x == *y) return 0;
    else return -1;
    break;
  
  case &ThinPtr(sz,typ):
    // val is a pointer to a pointer to whatever typ represents
    int *x = unsafe_cast(val1);
    int *y = unsafe_case(val2);
    int xx = *x;
    int yy = *y;
    let &$(mem,env2) = member_insert(env,xx);
    env = env2;
    // lexicographic order
    if(!mem) {
      printf("{(@%x) ",xx);
      if (y != 0) {
	int typ_szb = size_type(typ);
	for (int i = 0; i<sz; i++) {
	  let &$(env2,lt
	  env = print_type_base(typ,env, (`a@)unsafe_cast(xx));
	  if (i != (sz-1))
	    printf(", ");
	  y += typ_szb;
	}
      }
      else printf ("NULL");
      printf(" }");
    }
    else {
      printf("(#%x)",y);
    }
    break;

  case &FatPtr(typ): 
    $(unsigned int, unsigned int, unsigned int) @`H x = unsafe_cast(val);
    unsigned int typ_szb = size_type(typ);
    unsigned int base = (*x)[0], curr = (*x)[1], last_plus_one = (*x)[2];
    let &$(mem,env2) = member_insert(env,base);
    env = env2;
    if(!mem) {
      printf("[(@%x) ",base);
      for (unsigned int i = base; i<last_plus_one; i += typ_szb) {
	env = print_type_base(typ, env, (`a@)unsafe_cast(i));
	if ((i+typ_szb) < last_plus_one)
	  printf(", ");
      }
      printf(" ]");
    }
    else {
      printf("(#%x)",base);
    }
    break;

  case &Tuple(_,l):
    printf("$( ");
    int x = unsafe_cast(val); 
    for (int i = 0; i < l.size; i++) {
      let $(ofs,typ) = *(l[i]);
      int x_ofs = x + ofs;
      env = print_type_base(typ, env, (`a@)unsafe_cast(x_ofs));
      if (i != (l.size-1))
	printf(", ");
    }
    printf(" )");
    break;

  case &TUnion(l):
    printf("&[( ");
    // get the tag
    unsigned int@ tagp = unsafe_cast(val);
    if (*tagp < 1024) {
      printf("%d",*tagp);
    }
    else {
      let &$(mem,env2) = member_insert(env,*tagp);
      env = env2;
      if(!mem) {
	printf("(@%x)",*tagp);
	unsigned int @x = unsafe_cast(*tagp);
	unsigned int tag = *x;
	// figure out which variant it is 
	typestruct_t typ = get_unionbranch(tag,l);
	env = print_type_base(typ, env, x);
      }
      else {
	printf("(#%x)",*tagp);
      }
    }
    printf(" )]");
    break;

  case &XTUnion(l):
    // val is a pointer to a xtunion, hich is a pointer to a struct consisting of a char* tag that points to "\0\0\0\0Name", followed by any arguments
    unsigned int@ xtunionp = unsafe_cast(val);
    let &$(mem,env2) = member_insert(env,*xtunionp);
    env = env2;
    if(!mem) {
      printf("(@%x)",*xtunionp);
      // get the pointer to the name string "\0\0\0\0Name"
      unsigned int* xtstructp = unsafe_cast(*xtunionp);
      if(*xtstructp != 0) {
	Cstring<`H> xtnamec = unsafe_cast(*xtstructp+4);
	string_t<`H> xtname = Core::Cstring_to_string(xtnamec);
	printf("&%s[( ",xtname);
	// figure out which variant it is 
	typestruct_t typ = get_xtunionbranch(xtname,l);
	env = print_type_base(typ, env, (_@)xtstructp);
      }
      else {
	Cstring<`H> xtnamec = unsafe_cast(*xtunionp+4);
	string_t<`H> xtname = Core::Cstring_to_string(xtnamec);
	printf("&%s[( ",xtname);
      }
    }
    else {
      printf("(#%x)",*xtunionp);
    }
    printf(" )]");
    break;

  case &Union(l):
    printf("[[");
    // Print out each case; safe because no pointers
    for(int i = 0; i < l.size; i++) {
      print_type_base(*l[i],env,val);
      if(i < l.size-1) printf(" | ");
    }
    printf("]]");
    break;
    

  default: throw new Core::Failure("Unhandled case in print_type_base");
  }
  return env;
}

int generic_cmp(typestruct_t rep, `a@ val1, `a@ val2) {
  return generic_cmp_base(typestruct_t rep, addr_set_t env, `a@ val1, `a@ val2)[1];
}

*/
