/* This file is part of the Cyclone Library.
   Copyright (C) 2001 Greg Morrisett, AT&T

   This library is free software; you can redistribute it and/or it
   under the terms of the GNU Lesser General Public License as
   published by the Free Software Foundation; either version 2.1 of
   the License, or (at your option) any later version.

   This library is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with this library; see the file COPYING.LIB.  If not,
   write to the Free Software Foundation, Inc., 59 Temple Place, Suite
   330, Boston, MA 02111-1307 USA. */

#include <core.h>
#include <stdlib.h>
#include <array.h>

namespace Cstdlib {
  extern "C" {
    double atof(const Cstring);
    int atoi(const Cstring);
    long atol(const Cstring);
    Cstring getenv(const Cstring);
    int putenv(const Cstring);
    double strtod(Cstring, Cstring *`r);
    long strtol(Cstring, Cstring *`r, int);
    unsigned long strtoul(Cstring, Cstring *`r, int);
    void qsort(`a::A *base, size_t nmemb, size_t size,
	       int (*compar)(const `a@, const `a@));

    int system(Cstring);
#define s2c(x) (string_to_Cstring(x))
  }
}

using Core;
namespace Std {
  double atof(const char ?`r _nptr) {
    return Cstdlib::atof(s2c(_nptr));
  }
  int atoi(const char ?`r _nptr) {
    return Cstdlib::atoi(s2c(_nptr));
  }
  long atol(const char ?`r _nptr) {
    return Cstdlib::atol(s2c(_nptr));
  }
  mstring_t getenv(string_t name) {
    return Cstring_to_string(Cstdlib::getenv(s2c(name)));
  }
  int putenv(string_t s) {
    return Cstdlib::putenv(s2c(s));
  }
  static void check_valid_cstring(const char ?`r s) {
    if (s == NULL) throw new Invalid_argument("strtox NULL pointer");
    bool found_zero = false;
    for (int i = s.size - 1; i >= 0; i--)
      if (s[i] == '\0') { found_zero = true; break; }
    if (!found_zero) throw new Invalid_argument("strtox: not a C string");
  }

  double strtod(const char ?`r nptr, const char ?`r *`r2 endptr) {
    // need to ensure that the string has a '\0' in it before
    // handing it off to C.
    check_valid_cstring(nptr);
    // FIX:  TOTAL HACK ALERT
    Cstring c = underlying_Cstring(nptr); // so far so good
    Cstring e = (endptr == NULL) ? NULL : c;
    double d = Cstdlib::strtod(c, &e);
    if (endptr != NULL) {
      // need to adjust the endptr -- the best we can do is calculate
      // the diff between e and c.  And our pointer arithmetic doesn't
      // support subtraction on * types.  So I'm casting to unsigned int.
      int n = (unsigned int)e - (unsigned int)c;
      *endptr = nptr + n;
    }
    return d;
  }

  long strtol(const char ?`r n, const char ?`r *`r2 endptr, int base) {
    // need to ensure that the string has a '\0' in it before
    // handing it off to C.
    check_valid_cstring(n);
    // FIX:  TOTAL HACK ALERT
    Cstring c = underlying_Cstring(n); // so far so good
    Cstring e = (endptr == NULL) ? NULL : c;
    long r = Cstdlib::strtol(c, &e, base);
    if (endptr != NULL) {
      // need to adjust the end -- the best we can do is calculate
      // the diff between e and c.  And our pointer arithmetic doesn't
      // support subtraction on * types.  So I'm casting to unsigned int.
      int m = (unsigned int)e - (unsigned int)c;
      *endptr = n + m;
    }
    return r;
  }

  unsigned long strtoul(const char ?`r n,const char ?`r *`r2 endptr,int base){
    // need to ensure that the string has a '\0' in it before
    // handing it off to C.
    check_valid_cstring(n);
    // FIX:  TOTAL HACK ALERT
    Cstring c = underlying_Cstring(n); // so far so good
    Cstring e = (endptr == NULL) ? NULL : c;
    unsigned long r = Cstdlib::strtoul(c, &e, base);
    if (endptr != NULL) {
      // need to adjust the end -- the best we can do is calculate
      // the diff between e and c.  And our pointer arithmetic doesn't
      // support subtraction on * types.  So I'm casting to unsigned int.
      int m = (unsigned int)e - (unsigned int)c;
      *endptr = n + m;
    }
    return r;
  }

  unsigned long mstrtoul(char ?`r n,char ?`r *`r2 endptr,int base){
    // need to ensure that the string has a '\0' in it before
    // handing it off to C.
    check_valid_cstring(n);
    // FIX:  TOTAL HACK ALERT
    Cstring c = underlying_Cstring(n); // so far so good
    Cstring e = (endptr == NULL) ? NULL : c;
    unsigned long r = Cstdlib::strtoul(c, &e, base);
    if (endptr != NULL) {
      // need to adjust the end -- the best we can do is calculate
      // the diff between e and c.  And our pointer arithmetic doesn't
      // support subtraction on * types.  So I'm casting to unsigned int.
      int m = (unsigned int)e - (unsigned int)c;
      *endptr = n + m;
    }
    return r;
  }

  /*
  void qsort<`a::B,`r::R>(`a ?`r tab, size_t nmemb, size_t szmemb, 
		       Array::cmpfn_t<`a,`r,`r> compfn) {
    Array::qsort(compfn, tab, nmemb);
  }
  */
  void qsort<`a::A,`r::R>(`a ?`r tab, size_t nmemb, sizeof_t<`a> szmemb, 
			    int (@`H compar)(const `a@`r, const `a@`r)) {
    if(tab==NULL || tab.size < nmemb) 
      throw new Invalid_argument("Std::qsort");
    Cstdlib::qsort((_*)tab,nmemb,szmemb,compar);
  }

  int system(string_t cmd) {
    return Cstdlib::system(s2c(cmd));
}

// A no-op. 
  void free(`a* ptr) {}
}
