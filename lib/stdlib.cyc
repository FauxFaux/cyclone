#include <core.h>
#include <stdlib.h>

namespace Cstdlib {
  extern "C" {
    double _EXFUN(atof,(const Cstring _nptr));
#ifndef __STRICT_ANSI__
/*
    float _EXFUN(atoff,(const Cstring _nptr));
*/
#endif
    int   _EXFUN(atoi,(const Cstring _nptr));
    long  _EXFUN(atol,(const Cstring _nptr));
    Cstring _EXFUN(getenv,(const Cstring __string));
    //Cstring _EXFUN(_getenv_r,(struct _reent @, const Cstring __string));
    Cstring _EXFUN(_findenv,(const Cstring, int *));
    //Cstring _EXFUN(_findenv_r,(struct _reent *, const Cstring, int *));
    int _EXFUN(putenv,(const Cstring __string));
    //int	_EXFUN(_putenv_r,(struct _reent @, const Cstring __string));
/* Commented out because it's not available in IRIX
    int	_EXFUN(setenv,(const Cstring __string, const Cstring __value, int __overwrite));
    int	_EXFUN(_setenv_r,(struct _reent @, const Cstring __string, const Cstring __value, int __overwrite));
*/
    double _EXFUN(strtod,(Cstring, Cstring *`r));
    long _EXFUN(strtol,(Cstring, Cstring *`r, int base));
    unsigned long _EXFUN(strtoul,(Cstring, Cstring *`r, int base));
#ifdef __CYGWIN__
/* Commented out because it's not available in IRIX
    void _EXFUN(unsetenv,(const Cstring __string));
    void _EXFUN(_unsetenv_r,(struct _reent @, const Cstring __string));
*/
#endif

#define s2c(x) (string_to_Cstring(x))
  }
}

using Core;
namespace Stdlib {
  double atof(const char ?`r _nptr) {
    return Cstdlib::atof(s2c(_nptr));
  }
#ifndef __STRICT_ANSI__
/*
  float atoff(string _nptr) {
    return Cstdlib::atoff(s2c(_nptr));
  }
*/
#endif
  int atoi(const char ?`r _nptr) {
    return Cstdlib::atoi(s2c(_nptr));
  }
  long atol(const char ?`r _nptr) {
    return Cstdlib::atol(s2c(_nptr));
  }
  mstring_t getenv(string_t name) {
    return Cstring_to_string(Cstdlib::getenv(s2c(name)));
  }
  /*
  string _getenv_r(struct _reent @r, string name) {
    return Cstring_to_string(Cstdlib::_getenv_r(r,s2c(name)));
  }
  string _findenv(string n, int *i) {
    return Cstring_to_string(Cstdlib::_findenv(s2c(n),i));
  }
  string _findenv_r(struct _reent @r, string n, int *i) {
    return Cstring_to_string(Cstdlib::_findenv_r(r,s2c(n),i));
  }
  */
  int putenv(string_t s) {
    return Cstdlib::putenv(s2c(s));
  }
  /*
  int _putenv_r(struct _reent @r, string s) {
    return Cstdlib::_putenv_r(r,s2c(s));
  }
   */
/* Commented out because it's not available in IRIX
  int setenv(string_t s, string_t v, int overwrite) {
    return Cstdlib::setenv(s2c(s),s2c(v),overwrite);
  }
*/
  /*
  int _setenv_r(struct _reent @r, string s, string v, int overwrite) {
    return Cstdlib::_setenv_r(r,s2c(s),s2c(v),overwrite);
  }
  */
  static void check_valid_cstring(const char ?`r s) {
    if (s == NULL) throw new InvalidArg("strtox NULL pointer");
    bool found_zero = false;
    for (int i = s.size - 1; i >= 0; i--) 
      if (s[i] == '\0') { found_zero = true; break; }
    if (!found_zero) throw new InvalidArg("strtox: not a C string");
  }

  double strtod(const char ?`r nptr, const char ?`r *`r2 endptr) {
    // need to ensure that the string has a '\0' in it before
    // handing it off to C.
    check_valid_cstring(nptr);
    // FIX:  TOTAL HACK ALERT
    Cstring c = underlying_Cstring(nptr); // so far so good
    Cstring e = (endptr == NULL) ? NULL : c; 
    double d = Cstdlib::strtod(c, &e); 
    if (endptr != NULL) { 
      // need to adjust the endptr -- the best we can do is calculate
      // the diff between e and c.  And our pointer arithmetic doesn't
      // support subtraction on * types.  So I'm casting to unsigned int.
      int n = (unsigned int)e - (unsigned int)c;
      *endptr = nptr + n;
    }
    return d;
  }

  long strtol(const char ?`r n, const char ?`r *`r2 endptr, int base) {
    // need to ensure that the string has a '\0' in it before
    // handing it off to C.
    check_valid_cstring(n);
    // FIX:  TOTAL HACK ALERT
    Cstring c = underlying_Cstring(n); // so far so good
    Cstring e = (endptr == NULL) ? NULL : c; 
    long r = Cstdlib::strtol(c, &e, base); 
    if (endptr != NULL) { 
      // need to adjust the end -- the best we can do is calculate
      // the diff between e and c.  And our pointer arithmetic doesn't
      // support subtraction on * types.  So I'm casting to unsigned int.
      int m = (unsigned int)e - (unsigned int)c;
      *endptr = n + m;
    }
    return r;
  }

  unsigned long strtoul(const char ?`r n,const char ?`r *`r2 endptr,int base){
    // need to ensure that the string has a '\0' in it before
    // handing it off to C.
    check_valid_cstring(n);
    // FIX:  TOTAL HACK ALERT
    Cstring c = underlying_Cstring(n); // so far so good
    Cstring e = (endptr == NULL) ? NULL : c; 
    unsigned long r = Cstdlib::strtoul(c, &e, base); 
    if (endptr != NULL) { 
      // need to adjust the end -- the best we can do is calculate
      // the diff between e and c.  And our pointer arithmetic doesn't
      // support subtraction on * types.  So I'm casting to unsigned int.
      int m = (unsigned int)e - (unsigned int)c;
      *endptr = n + m;
    }
    return r;
  }

#ifdef __CYGWIN__
/* Commented out because it's not available in IRIX
  void unsetenv(string_t s) {
    Cstdlib::unsetenv(s2c(s));
  }
  void _unsetenv_r(struct _reent @r, string s) {
    Cstdlib::_unsetenv_r(r,s2c(s));
  }
*/
#endif
}
