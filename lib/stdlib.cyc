/* This file is part of the Cyclone Library.
   Copyright (C) 2001 Greg Morrisett, AT&T

   This library is free software; you can redistribute it and/or it
   under the terms of the GNU Lesser General Public License as
   published by the Free Software Foundation; either version 2.1 of
   the License, or (at your option) any later version.

   This library is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with this library; see the file COPYING.LIB.  If not,
   write to the Free Software Foundation, Inc., 59 Temple Place, Suite
   330, Boston, MA 02111-1307 USA. */

#include <core.h>
#include <stdlib.h>

namespace Cstdlib {
  extern "C" {
    double atof(const Cstring);
    int atoi(const Cstring);
    long atol(const Cstring);
    Cstring getenv(const Cstring);
    int putenv(const Cstring);
    double strtod(Cstring, Cstring *`r);
    long strtol(Cstring, Cstring *`r, int);
    unsigned long strtoul(Cstring, Cstring *`r, int);
#define s2c(x) (string_to_Cstring(x))
  }
}

using Core;
namespace std {
  double atof(const char ?`r _nptr) {
    return Cstdlib::atof(s2c(_nptr));
  }
  int atoi(const char ?`r _nptr) {
    return Cstdlib::atoi(s2c(_nptr));
  }
  long atol(const char ?`r _nptr) {
    return Cstdlib::atol(s2c(_nptr));
  }
  mstring_t getenv(string_t name) {
    return Cstring_to_string(Cstdlib::getenv(s2c(name)));
  }
  int putenv(string_t s) {
    return Cstdlib::putenv(s2c(s));
  }
  static void check_valid_cstring(const char ?`r s) {
    if (s == NULL) throw new InvalidArg("strtox NULL pointer");
    bool found_zero = false;
    for (int i = s.size - 1; i >= 0; i--)
      if (s[i] == '\0') { found_zero = true; break; }
    if (!found_zero) throw new InvalidArg("strtox: not a C string");
  }

  double strtod(const char ?`r nptr, const char ?`r *`r2 endptr) {
    // need to ensure that the string has a '\0' in it before
    // handing it off to C.
    check_valid_cstring(nptr);
    // FIX:  TOTAL HACK ALERT
    Cstring c = underlying_Cstring(nptr); // so far so good
    Cstring e = (endptr == NULL) ? NULL : c;
    double d = Cstdlib::strtod(c, &e);
    if (endptr != NULL) {
      // need to adjust the endptr -- the best we can do is calculate
      // the diff between e and c.  And our pointer arithmetic doesn't
      // support subtraction on * types.  So I'm casting to unsigned int.
      int n = (unsigned int)e - (unsigned int)c;
      *endptr = nptr + n;
    }
    return d;
  }

  long strtol(const char ?`r n, const char ?`r *`r2 endptr, int base) {
    // need to ensure that the string has a '\0' in it before
    // handing it off to C.
    check_valid_cstring(n);
    // FIX:  TOTAL HACK ALERT
    Cstring c = underlying_Cstring(n); // so far so good
    Cstring e = (endptr == NULL) ? NULL : c;
    long r = Cstdlib::strtol(c, &e, base);
    if (endptr != NULL) {
      // need to adjust the end -- the best we can do is calculate
      // the diff between e and c.  And our pointer arithmetic doesn't
      // support subtraction on * types.  So I'm casting to unsigned int.
      int m = (unsigned int)e - (unsigned int)c;
      *endptr = n + m;
    }
    return r;
  }

  unsigned long strtoul(const char ?`r n,const char ?`r *`r2 endptr,int base){
    // need to ensure that the string has a '\0' in it before
    // handing it off to C.
    check_valid_cstring(n);
    // FIX:  TOTAL HACK ALERT
    Cstring c = underlying_Cstring(n); // so far so good
    Cstring e = (endptr == NULL) ? NULL : c;
    unsigned long r = Cstdlib::strtoul(c, &e, base);
    if (endptr != NULL) {
      // need to adjust the end -- the best we can do is calculate
      // the diff between e and c.  And our pointer arithmetic doesn't
      // support subtraction on * types.  So I'm casting to unsigned int.
      int m = (unsigned int)e - (unsigned int)c;
      *endptr = n + m;
    }
    return r;
  }

}
