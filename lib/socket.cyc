/* This file is part of the Cyclone Library.
   Copyright (C) 2001 Greg Morrisett, AT&T

   This library is free software; you can redistribute it and/or it
   under the terms of the GNU Lesser General Public License as
   published by the Free Software Foundation; either version 2.1 of
   the License, or (at your option) any later version.

   This library is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with this library; see the file COPYING.LIB.  If not,
   write to the Free Software Foundation, Inc., 59 Temple Place, Suite
   330, Boston, MA 02111-1307 USA. */

#include <core.h>
#include <string.h>
#include <stdio.h>
#include <sys/socket.h>

namespace Std;

namespace Csocket {
  extern "C" {
    /* Later we'll add, e.g., accept_in6, bind_in6, etc. */
    int accept(int, const struct sockaddr @, socklen_t @);
    int accept_in(int, const struct sockaddr_in @, socklen_t @);
    int bind(int, const struct sockaddr @, socklen_t);
    int bind_in(int, const struct sockaddr_in @, socklen_t);
    int connect(int, const struct sockaddr @, socklen_t);
    int connect_in(int, const struct sockaddr_in @, socklen_t);
    int getpeername(int, const struct sockaddr @, socklen_t @);
    int getpeername_in(int, const struct sockaddr_in @, socklen_t @);
    int getsockname(int, const struct sockaddr @, socklen_t @);
    int getsockname_in(int, const struct sockaddr_in @, socklen_t @);
    ssize_t recvfrom(int, char ?, size_t, int,
                        const struct sockaddr @, socklen_t @);
    ssize_t recvfrom_in(int, char ?, size_t, int,
                        const struct sockaddr_in @, socklen_t @);
    ssize_t sendto(int, const char ?, size_t, int,
                      const struct sockaddr @, socklen_t);
    ssize_t sendto_in(int, const char ?, size_t, int,
                      const struct sockaddr_in @, socklen_t);

    ssize_t send_wrapped(int, const char ?, size_t, int);
    ssize_t recv_wrapped(int, char ?, size_t, int);

    /* Add: _linger, _in_addr, _u_char, _ip_mreq, _sockaddr, etc. */
    int getsockopt_int(int, int, int, int @, socklen_t @);
    int setsockopt_int(int, int, int, const int @, socklen_t);
    int getsockopt_timeval(int, int, int, struct timeval @, socklen_t @);
    int setsockopt_timeval(int, int, int, const struct timeval @, socklen_t);
  }  
}

xtunion exn { SocketError(string_t); };

static mstring_t<`H> sopts2string(SO ?args) {
  mstring_t<`H> res = new { '\0' };
  for (int i = 0; i<args.size; i++) {
    switch (args[i]) {
    case &SO_int(_):
      res = strconcat(res,"|SO_int");
      break;
    case &SO_timeval(_):
      res = strconcat(res,"|SO_timeval");
      break;
    case &SO_socklenptr(_):
      res = strconcat(res,"|SO_socklenptr");
      break;
    case &SO_socklen(_):
      res = strconcat(res,"|SO_socklen");
      break;
    }
  }
  return res;
}

int accept(int fd, ... inject SA ap) {
  if (ap.size != 2) throw new SocketError("accept---need 2 args");
  switch ($(ap[0],ap[1])) {
  case $(&SA_sockaddr_in(x),&SA_socklenptr(y)):
    return Csocket::accept_in(fd,x,y);
  case $(&SA_sockaddr(x),&SA_socklenptr(y)):
    return Csocket::accept(fd,x,y);
  default: throw new SocketError("accept---bad args");
  }
}

int bind(int fd, ... inject SA ap) {
  if (ap.size != 2) throw new SocketError("bind---need 2 args");
  switch ($(ap[0],ap[1])) {
  case $(&SA_sockaddr_in(x),&SA_socklen(y)):
    return Csocket::bind_in(fd,x,y);
  case $(&SA_sockaddr(x),&SA_socklen(y)):
    return Csocket::bind(fd,x,y);
  default: throw new SocketError("bind---bad args");
  }
}

int connect(int fd, ... inject SA ap) {
  if (ap.size != 2) throw new SocketError("connect---need 2 args");
  switch ($(ap[0],ap[1])) {
  case $(&SA_sockaddr_in(x),&SA_socklen(y)):
    return Csocket::connect_in(fd,x,y);
  case $(&SA_sockaddr(x),&SA_socklen(y)):
    return Csocket::connect(fd,x,y);
  default: throw new SocketError("connect---bad args");
  }
}

int getpeername(int fd, ... inject SA ap) {
  if (ap.size != 2) throw new SocketError("getpeername---need 2 args");
  switch ($(ap[0],ap[1])) {
  case $(&SA_sockaddr_in(x),&SA_socklenptr(y)):
    return Csocket::getpeername_in(fd,x,y);
  case $(&SA_sockaddr(x),&SA_socklenptr(y)):
    return Csocket::getpeername(fd,x,y);
  default: throw new SocketError("getpeername---bad args");
  }
}

int getsockname(int fd, ... inject SA ap) {
  if (ap.size != 2) throw new SocketError("getsockname---need 2 args");
  switch ($(ap[0],ap[1])) {
  case $(&SA_sockaddr_in(x),&SA_socklenptr(y)):
    return Csocket::getsockname_in(fd,x,y);
  case $(&SA_sockaddr(x),&SA_socklenptr(y)):
    return Csocket::getsockname(fd,x,y);
  default: throw new SocketError("getsockname---bad args");
  }
}

ssize_t recvfrom(int fd, char ?buf, size_t n, int flags, ... inject SA ap) {
  if (ap.size != 2) throw new SocketError("recvfrom---need 2 args");
  switch ($(ap[0],ap[1])) {
  case $(&SA_sockaddr_in(x),&SA_socklenptr(y)):
    return Csocket::recvfrom_in(fd,buf,n,flags,x,y);
  case $(&SA_sockaddr(x),&SA_socklenptr(y)):
    return Csocket::recvfrom(fd,buf,n,flags,x,y);
  default: throw new SocketError("recvfrom---bad args");
  }
}

ssize_t sendto(int fd, const char ?buf, size_t n, int flags,
               ... inject SA ap) {
  if (ap.size != 2) throw new SocketError("sendto---need 2 args");
  switch ($(ap[0],ap[1])) {
  case $(&SA_sockaddr_in(x),&SA_socklen(y)):
    return Csocket::sendto_in(fd,buf,n,flags,x,y);
  case $(&SA_sockaddr(x),&SA_socklen(y)):
    return Csocket::sendto(fd,buf,n,flags,x,y);
  default: throw new SocketError("sendto---bad args");
  }
}

ssize_t send(int fd, const char ?buf, size_t n, int flags) {
  return Csocket::send_wrapped(fd,buf,n,flags);
}

ssize_t recv(int fd, char ?buf, size_t n, int flags) {
  return Csocket::recv_wrapped(fd,buf,n,flags);
}

int getsockopt(int fd, int level, int optname, ... inject SO ap) {
  if (ap.size != 2) throw new SocketError("getsockopt---need 2 args");
  switch ($(ap[0],ap[1])) {
  case $(&SO_int(x),&SO_socklenptr(y)):
    return Csocket::getsockopt_int(fd,level,optname,x,y);
  /* FIX: shouldn't have to do this */
  case $(&SO_int(x),&SO_int(y)):
    return Csocket::getsockopt_int(fd,level,optname,x,(socklen_t @)y);
  case $(&SO_timeval(x),&SO_socklenptr(y)):
    return Csocket::getsockopt_timeval(fd,level,optname,x,y);
  /* FIX: shouldn't have to do this */
  case $(&SO_timeval(x),&SO_int(y)):
    return Csocket::getsockopt_timeval(fd,level,optname,x,(socklen_t @)y);
  default: throw new SocketError(aprintf("getsockopt---bad args %s",
					 sopts2string(ap)));
  }
}

int setsockopt(int fd, int level, int optname, ... inject SO ap) {
  if (ap.size != 2) throw new SocketError("setsockopt---need 2 args");
  switch ($(ap[0],ap[1])) {
  case $(&SO_int(x),&SO_socklen(y)):
    return Csocket::setsockopt_int(fd,level,optname,x,y);
  case $(&SO_timeval(x),&SO_socklen(y)):
    return Csocket::setsockopt_timeval(fd,level,optname,x,y);
  default: throw new SocketError(aprintf("getsockopt---bad args %s",
					 sopts2string(ap)));
  }
}
