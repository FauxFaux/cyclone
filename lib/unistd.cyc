/* This file is part of the Cyclone Library.
   Copyright (C) 2000-2001 Greg Morrisett

   This library is free software; you can redistribute it and/or it
   under the terms of the GNU Lesser General Public License as
   published by the Free Software Foundation; either version 2.1 of
   the License, or (at your option) any later version.

   This library is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with this library; see the file COPYING.LIB.  If not,
   write to the Free Software Foundation, Inc., 59 Temple Place, Suite
   330, Boston, MA 02111-1307 USA. */

#include <core.h>
#include <unistd.h>
using Core;

namespace Cunistd {
  extern "C" {
    int chdir(Cstring);
    Cstring<`r> getcwd(Cstring<`r> buf, size_t size);
    int execv(Cstring path, Cstring *argv);
    int execvp(Cstring file, Cstring *argv);
    int execve(Cstring path, Cstring *argv, Cstring *envp);
    ssize_t read(int fd, Cstring buf, size_t count);
    ssize_t write(int fd, Cstring buf, size_t count);
    int unlink(Cstring pathname);
  }
}

namespace Std;

int chdir(string_t path) {
  return Cunistd::chdir(string_to_Cstring(path));
}

char ?`r getcwd(char ?`r buf, size_t size) {
  if (!buf || buf.size < size) {
    throw new Failure("getcwd: invalid buf argument");
  }
  Cstring response = Cunistd::getcwd((Cstring)buf, size);
  return response ? buf : NULL;
}

// This is untested; I'd be surprised if it actually works
int execl(string_t path, string_t arg0, ...`r string_t argv) {
  if (argv[argv.size - 1] != NULL)
    throw new Failure("execl: arg list must be NULL-terminated");

  // We allocate 1+argv.size because we need to prepend arg0
  Cstring ?newargs = new {for i < 1 + argv.size : NULL};
  newargs[0] = string_to_Cstring(arg0);
  for (int i = 0; i < argv.size; i++)
    newargs[i+1] = string_to_Cstring(argv[i]);
  return Cunistd::execv(string_to_Cstring(path), (Cstring*) newargs);
}

int execlp(string_t path, string_t arg0, ...`r string_t argv) {
  if (argv[argv.size - 1] != NULL)
    throw new Failure("execl: arg list must be NULL-terminated");

  // We allocate 1+argv.size because we need to prepend arg0
  Cstring ?newargs = new {for i < 1 + argv.size : NULL};
  newargs[0] = string_to_Cstring(arg0);
  for (int i = 0; i < argv.size; i++)
    newargs[i+1] = string_to_Cstring(argv[i]);
  return Cunistd::execvp(string_to_Cstring(path), (Cstring*) newargs);
}

int execve(string_t filename, string_t const ?argv, string_t const ?envp) {
  if (argv[argv.size - 1] != NULL)
    throw new Failure("execve: arg list must be NULL-terminated");

  Cstring ?newargs = new {for i < argv.size : NULL};
  for (int i = 0; i < argv.size; i++)
    newargs[i] = string_to_Cstring(argv[i]);

  Cstring ?newenvp = new {for i < envp.size : NULL};
  for (int i = 0; i < envp.size; i++)
    newenvp[i] = string_to_Cstring(envp[i]);

  return Cunistd::execve(string_to_Cstring(filename),
                         (Cstring*) newargs, (Cstring*) newenvp);
}

ssize_t read(int fd, mstring_t buf, size_t count) {
  if (count > buf.size)
    throw new Failure("read: called with count > buf.size");
  return Cunistd::read(fd, underlying_Cstring(buf), count);
}

ssize_t write(int fd, string_t buf, size_t count) {
  if (count > buf.size)
    throw new Failure("write: called with count > buf.size");
  return Cunistd::write(fd, string_to_Cstring(buf), count);
}

int unlink(string_t pathname) {
  return Cunistd::unlink(string_to_Cstring(pathname));
}
