#include <core.h>
#include <unistd.h>
using Core;

namespace Cunistd {
  extern "C" {
    int chdir(Cstring);
    Cstring<`r> getcwd(Cstring<`r> buf, size_t size);
    int execv(Cstring path, Cstring *argv);
    int execvp(Cstring file, Cstring *argv);
    int execve(Cstring path, Cstring *argv, Cstring *envp);
    ssize_t read(int fd, Cstring buf, size_t count);
    ssize_t write(int fd, Cstring buf, size_t count);
    int unlink(Cstring pathname);
  }
}

namespace Unistd;

int chdir(string_t path) {
  return Cunistd::chdir(string_to_Cstring(path));
}

char ?`r getcwd(char ?`r buf, size_t size) {
  if (!buf || buf.size < size) {
    throw new Failure("getcwd: invalid buf argument");
  }
  Cstring response = Cunistd::getcwd((Cstring)buf, size);
  return response ? buf : NULL;
}

// This is untested; I'd be surprised if it actually works
int execl(string_t path, string_t arg0, ...`r string_t argv) {
  if (argv[argv.size - 1] != NULL)
    throw new Failure("execl: arg list must be NULL-terminated");

  // We allocate 1+argv.size because we need to prepend arg0
  Cstring ?newargs = new {for i < 1 + argv.size : NULL};
  newargs[0] = string_to_Cstring(arg0);
  for (int i = 0; i < argv.size; i++)
    newargs[i+1] = string_to_Cstring(argv[i]);
  return Cunistd::execv(string_to_Cstring(path), (Cstring*) newargs);
}

int execlp(string_t path, string_t arg0, ...`r string_t argv) {
  if (argv[argv.size - 1] != NULL)
    throw new Failure("execl: arg list must be NULL-terminated");

  // We allocate 1+argv.size because we need to prepend arg0
  Cstring ?newargs = new {for i < 1 + argv.size : NULL};
  newargs[0] = string_to_Cstring(arg0);
  for (int i = 0; i < argv.size; i++)
    newargs[i+1] = string_to_Cstring(argv[i]);
  return Cunistd::execvp(string_to_Cstring(path), (Cstring*) newargs);
}

int execve(string_t filename, string_t const ?argv, string_t const ?envp) {
  if (argv[argv.size - 1] != NULL)
    throw new Failure("execve: arg list must be NULL-terminated");

  Cstring ?newargs = new {for i < argv.size : NULL};
  for (int i = 0; i < argv.size; i++)
    newargs[i] = string_to_Cstring(argv[i]);

  Cstring ?newenvp = new {for i < envp.size : NULL};
  for (int i = 0; i < envp.size; i++)
    newenvp[i] = string_to_Cstring(envp[i]);

  return Cunistd::execve(string_to_Cstring(filename),
                         (Cstring*) newargs, (Cstring*) newenvp);
}

ssize_t read(int fd, mstring_t buf, size_t count) {
  if (count > buf.size)
    throw new Failure("read: called with count > buf.size");
  return Cunistd::read(fd, underlying_Cstring(buf), count);
}

ssize_t write(int fd, string_t buf, size_t count) {
  if (count > buf.size)
    throw new Failure("write: called with count > buf.size");
  return Cunistd::write(fd, string_to_Cstring(buf), count);
}

int unlink(string_t pathname) {
  return Cunistd::unlink(string_to_Cstring(pathname));
}
