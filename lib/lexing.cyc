// Dan Grossman, April 1999 

// Run-time library for files created by popocamllex 

// This is the merged port of lexing.ml and lexing.c with lexing.ml
// basically coming first 

#include "core.h"
#include "stdio.h"
#include "lexing.h"
#include "string.h"

using Core;
using Stdio;

namespace Lexing;

// AUX_SIZE should be half BUFFER_SIZE
#define BUFFER_SIZE 8192
#define AUX_SIZE    4096

xtunion exn { Error(string) };

struct lexbuf<`a> { // use `a for state that refill_buff might need 

  void   (@refill_buff)(struct lexbuf<`a> @;{});
  `a     refill_state;

  string lex_buffer;
  int    lex_buffer_len;
  int    lex_abs_pos;
  int    lex_start_pos;
  int    lex_curr_pos;
  int    lex_last_pos;
  int    lex_last_action;
  bool   lex_eof_reached;
};

struct function_lexbuf_state<`b> {
// instantiation for using function to read
  int (@read_fun)(string,int,`b;{});
  `b read_fun_state;
};

struct lex_tables {
// for space this should probably be shorts, but who cares
  int ?lex_base;
  int ?lex_backtrk;
  int ?lex_default;
  int ?lex_trans;
  int ?lex_check;
};

static string aux_buffer = "";

void lex_refill(Lexbuf<Function_lexbuf_state<`c>> lexbuf) {
  if (aux_buffer.size==1) aux_buffer = new_string(AUX_SIZE);
  int read =
    lexbuf->refill_state->read_fun(aux_buffer,
                                   aux_buffer.size,
                                   lexbuf->refill_state->read_fun_state);
  int n = read > 0 ? read : (lexbuf->lex_eof_reached = true, 0);
  if (lexbuf->lex_start_pos < n) {
    int    oldlen = lexbuf->lex_buffer_len;
    int    newlen = oldlen*2;

    string newbuf = new_string(newlen+1);
    String::zstrncpy(newbuf, oldlen, lexbuf->lex_buffer, 0, oldlen);
    lexbuf->lex_buffer     = newbuf;
    lexbuf->lex_buffer_len = newlen;
    lexbuf->lex_abs_pos    = lexbuf->lex_abs_pos   - oldlen;
    lexbuf->lex_curr_pos   = lexbuf->lex_curr_pos  + oldlen;
    lexbuf->lex_start_pos  = lexbuf->lex_start_pos + oldlen;
    lexbuf->lex_last_pos   = lexbuf->lex_last_pos  + oldlen;
  }
  String::zstrncpy(lexbuf->lex_buffer, 0,
                   lexbuf->lex_buffer, n,
                   lexbuf->lex_buffer_len-n);
  String::zstrncpy(lexbuf->lex_buffer, lexbuf->lex_buffer_len-n,
                   aux_buffer, 0,  n);
  lexbuf->lex_abs_pos    = lexbuf->lex_abs_pos   + n;
  lexbuf->lex_curr_pos   = lexbuf->lex_curr_pos  - n;
  lexbuf->lex_start_pos  = lexbuf->lex_start_pos - n;
  lexbuf->lex_last_pos   = lexbuf->lex_last_pos  - n;
}

Lexbuf<Function_lexbuf_state<`b>>
from_function(int read_fun(string,int,`b;{}),
                  `b read_fun_state) {
  return new lexbuf(lex_refill, // @ <`b>,
                    new function_lexbuf_state(read_fun, read_fun_state),
                    new_string(BUFFER_SIZE),
                    BUFFER_SIZE, -BUFFER_SIZE,
                    BUFFER_SIZE, BUFFER_SIZE, BUFFER_SIZE,
                    0,
                    false);
}

int read_from_file(string aux, int n, FILE @f) {
//                           <<FILE>function_lexbuf_state>lexbuf lbuf) {
  return file_string_read(f, aux, 0, n);
}

// corresponds to ocaml's from_channel
Lexbuf<Function_lexbuf_state<FILE@>> from_file(FILE @f) {
  //  return (from_function @<FILE@>) (read_from_file, f);
  return from_function(read_from_file, f);
}

static void set_eof(Lexbuf<bool> lbuf) {
  lbuf->lex_eof_reached = true;
}

Lexbuf<bool> from_string(string s) {
  return 
    new lexbuf(set_eof,
               false,     //ignored but can't instantiate with void
               String::strdup(s), // copy to keep lexer shielded from updates
               s.size,
               0,0,0,0,0,
               true);
}

string lexeme(Lexbuf<`a> lbuf) {
   int    len = lbuf->lex_curr_pos - lbuf->lex_start_pos;
   string s   = new_string(len+1);
   String::zstrncpy(s, 0, lbuf->lex_buffer, lbuf->lex_start_pos, len);
   s[len] = '\000';
//     if (len == 0) {
//       fprintf(cyc_stderr,"Lexing::lexeme: 0 length!!\n");
//     } else if (String::strlen(s)==0) {
//       fprintf(cyc_stderr,"!! Lexing::lexeme: 0 length!!\n");
//     }
   return s;
}

char lexeme_char(Lexbuf<`a> lbuf, int i) {
   return lbuf->lex_buffer[lbuf->lex_start_pos + i];
}

int lexeme_start(Lexbuf<`a> lbuf) {
   return lbuf->lex_abs_pos + lbuf->lex_start_pos;
}

int lexeme_end(Lexbuf<`a> lbuf) {
   return lbuf->lex_abs_pos + lbuf->lex_curr_pos;
}

////////////////// Now here's what was lexing.c /////////////

int lex_engine(LexTables tbl, int start_state, Lexbuf<`a> lbuf) {

   int state, base, backtrk;
   int c;
   state = start_state;

   if (state >= 0) {
     // First entry 
     lbuf->lex_last_pos = lbuf->lex_start_pos = lbuf->lex_curr_pos;
     lbuf->lex_last_action = -1;
   } else {
     // Reentry after refill 
     state = -state-1;
  }
  while (true) {
     base = tbl->lex_base[state];
     if (base < 0) return -base-1;
     // See if it's a backtrack point 
     backtrk = tbl->lex_backtrk[state];
     if (backtrk >= 0) {
        lbuf->lex_last_pos    = lbuf->lex_curr_pos;
        lbuf->lex_last_action = backtrk;
     }
     // See if we need a refill 
     if (lbuf->lex_curr_pos >= lbuf->lex_buffer_len) {
       if (!lbuf->lex_eof_reached)
	 return -state-1;
       else
	 c = 256;
     } else {
       // Read next input char 
       c = (int) (lbuf->lex_buffer[lbuf->lex_curr_pos++]);
       if (c==EOF) c=256;
     }
     // Determine next state 
     if (tbl->lex_check[base+c]==state)
	state = tbl->lex_trans[base+c];
     else
        state = tbl->lex_default[state];
     // If no transition on this char, return to last backtrack point 
     if (state < 0) {
        lbuf->lex_curr_pos = lbuf->lex_last_pos;
	if (lbuf->lex_last_action == -1)
	   throw new Error("empty token");
        else {
	  return lbuf->lex_last_action;
	}
     } else {
       // Erase the EOF condition only if the EOF pseudo-character was
       // consumed by the automaton (i.e., there was no backtrack above)
       if (c == 256) lbuf->lex_eof_reached = false;
     }
  }
}
