#include "core.h"
#include "list.h"
#include "stdio.h"
#include "position.h"
#include "string.h"
namespace Position;
using Core;
using List;
using Stdio;
using String;

xenum exn {Exit};

/////////// Location tracking///////////
static string source = ""; // initialized by overall control
struct Segment { int start; int end; };

seg_t segment_of_abs(int start, int end) { return &Segment(start,end); }
seg_t segment_join(seg_t s1, seg_t s2) { 
  if(s1 == null) return s2;
  if(s2 == null) return s1;
  return &Segment(s1->start,s2->end); 
}

string string_of_loc(int loc) {
  Lineno::pos_t pos = Lineno::pos_of_abs(source,loc);
  return xprintf("%s (%d:%d)",pos->logical_file,pos->line_no,pos->col);
}

static string string_of_pos_pr(Lineno::pos_t pos_s, Lineno::pos_t pos_e) {
  if (strcmp(pos_s->logical_file,pos_e->logical_file)==0)
    return xprintf("%s(%d:%d-%d:%d)", pos_s->logical_file,
		   pos_s->line_no,pos_s->col,
		   pos_e->line_no,pos_e->col);
  else
    return xprintf("%s(%d:%d)-%s(%d:%d)",
		   pos_s->logical_file,pos_s->line_no,pos_s->col,
		   pos_e->logical_file,pos_e->line_no,pos_e->col);
}

string string_of_segment(seg_t s) {
  if(s == null)
    return xprintf("%s(unknown)",source);
  Lineno::pos_t pos_s = Lineno::pos_of_abs(source,s->start);
  Lineno::pos_t pos_e = Lineno::pos_of_abs(source,s->end);
  return string_of_pos_pr(pos_s,pos_e);
}

static Lineno::pos_t new_pos() {
  return &Lineno::Pos("","",0,0);
}

list_t<stringptr> strings_of_segments(glist_t<seg_t,`r> segs) {
  list_t<$(int,Lineno::pos_t)@> places = null;
  for(let segs2 = segs; segs2 != null; segs2 = segs2->tl) {
    if(segs2->hd == null)
      continue;
    places = &List(&$(segs2->hd->end,   new_pos()),
	     &List(&$(segs2->hd->start, new_pos()),
		   places));
  }
  Lineno::poss_of_abss(source, places); // mutates places
  list_t<stringptr> ans = null;
  places = List::imp_rev(places);
  for(; segs != null; segs = segs->tl) 
    if(segs->hd == null)
      // FIX:  the cast to stringptr is needed for some reason...
      ans = &List((stringptr) new {xprintf("%s(unknown)", source)}, ans);
    else {
      ans = &List((stringptr) new {string_of_pos_pr((*places->hd)[1], 
						    (*places->tl->hd)[1])}, 
		  ans);
      places = places->tl->tl;
    }
  return ans;
}

///////////// Errors ////////////

enum Error_kind { Lex, Parse, Elab };
struct Error {
  string       source;
  seg_t        seg;
  error_kind_t kind;
  string       desc;
};
error_t mk_err_lex(seg_t l, string desc) {
  return &Error(source, l, Lex, desc);
}
error_t mk_err_parse(seg_t l, string desc) {
  return &Error(source, l, Parse, desc);
}
error_t mk_err_elab(seg_t l, string desc) {
  return &Error(source, l, Elab, desc);
}

/////////// Error Reporting ///////////

// If there are errors getting stuff from the source file then raise Nocontext
// and just don't print the source context

xenum exn {Nocontext};

static string trunc(int n, string s) {
  int len = strlen(s);
  if (len < n) 
    return s;
  int len_one = (n-3)/2;
  int len_two = n-3-len_one;
  string ans = new_string(n+1);
  strncpy(ans, 0,         s,     0,           len_one);
  strncpy(ans, len_one,   "...", 0,           3);
  strncpy(ans, len_one+3, s,     len-len_two, len_two);
  return ans;
}

static int line_length = 76;

// Produce a one line string that shows the peice of the source file containing
// the error; return also the column numbers the error starts and finishes at.
static $(string,int,int)@ get_context(seg_t seg) {
  if(seg == null)
    throw Nocontext;
  Lineno::pos_t pos_s, pos_e;
  try {
    pos_s = Lineno::pos_of_abs(source,seg->start);
    pos_e = Lineno::pos_of_abs(source,seg->end);
  } catch {
  default: throw Nocontext;
  }
  
  string sline = pos_s->line;     string eline = pos_e->line;
  int    sl    = pos_s->line_no;  int    el    = pos_e->line_no;
  int    sc    = pos_s->col;      int    ec    = pos_e->col;
  
  if (sl == el) {
    // Case 1: error is all on one line, 
    // give 1/3 of line to before, error, and after
    int n = line_length / 3;
    string sec_one   = trunc(n, substring(sline, 0,  sc            ));
    string sec_two   = trunc(n, substring(sline, sc, ec-sc         ));
    string sec_three = trunc(n, substring(sline, sc, strlen(sline)-ec));
    return &$(xprintf("%s%s%s",sec_one,sec_two,sec_three),(int)strlen(sec_one),
	      (int)(strlen(sec_one)+strlen(sec_two)));
  }
  else {
    // Case 2: error on multiple lines,
    // give 1/4 to start, start line rror, end line error, and end
    int n = (line_length-3)/4;
    string sec_one   = trunc(n, substring(sline, 0,  sc            ));
    string sec_two   = trunc(n, substring(sline, sc, strlen(sline)-sc));
    string sec_three = trunc(n, substring(eline, 0,  ec            ));
    string sec_four  = trunc(n, substring(eline, ec, strlen(eline)-ec));
    return &$(xprintf("%s%s.\\.%s%s",sec_one,sec_two,sec_three,sec_four),
	      (int)strlen(sec_one),
	      (int)(strlen(sec_one)+strlen(sec_two)+3+strlen(sec_three)));
  }
}

static bool error_b = false;
bool error_p() { return error_b; }

xenum exn {Error(error_t)};

bool print_context = false;

bool first_error = true;

void post_error(error_t e) {
  error_b = true;
  fflush(stdout);
  if (first_error) {
    fprintf(stderr, "\n");
    first_error = false;
  }
  // why are we not using the source stored in e????
  fprintf(stderr, "%s: %s\n", string_of_segment(e->seg), e->desc);
  if (print_context) {
    try {
      $(string,int,int)@ x = get_context(e->seg);
      string marker_str = new {for i < (*x)[2]+1 : '\000'};
      int i = -1;
      while (++i < (*x)[1]) marker_str[i] = ' ';
      while (++i < (*x)[2]) marker_str[i] = '^';
      fprintf(stderr, "  %s\n  %s\n", (*x)[0], marker_str);
    } catch {
    case Nocontext: break; 
    }
  }
  fflush(stderr);
}

//////////// Overall Control ///////////
void reset_position(string s)    { source = s; error_b = false; }
void set_position_file(string s) { source = s; error_b = false; }
string get_position_file() { return source; }

