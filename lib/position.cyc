/* This file is part of the Cyclone Library.
   Copyright (C) 2000-2001 Greg Morrisett

   This library is free software; you can redistribute it and/or it
   under the terms of the GNU Lesser General Public License as
   published by the Free Software Foundation; either version 2.1 of
   the License, or (at your option) any later version.

   This library is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with this library; see the file COPYING.LIB.  If not,
   write to the Free Software Foundation, Inc., 59 Temple Place, Suite
   330, Boston, MA 02111-1307 USA. */

#include <core.h>
#include <list.h>
#include <stdio.h>
#include <position.h>
#include <string.h>
#include <positionrep.h>

namespace Position {
using Core;
using List;

// When set to true, uses format:
//   <filename>:<lineno>:<message>
// and otherwise uses format
//   <filename>:(<lineno>:<char>-<lineno>:<char>):<message>
bool use_gcc_style_location = true;

datatype exn @extensible {Exit};

/////////// Location tracking///////////
static string_t source = ""; // initialized by overall control
struct Segment { int start; int end; };


seg_t segment_of_abs(int start, int end) { return new Segment(start,end); }
seg_t segment_join(seg_t s1, seg_t s2) { 
  if(s1 == NULL) return s2;
  if(s2 == NULL) return s1;
  return new Segment(s1->start,s2->end); 
}
bool segment_equals(seg_t s1, seg_t s2) {
  if (s1 == s2) return true;
  if (s1 == NULL) return (s2 == NULL);
  return (s2 != NULL) && (s1->start == s2->start && s1->end == s2->end);
}

mstring_t string_of_loc(int loc) {
  Lineno::pos_t pos = Lineno::pos_of_abs(source,loc);
  if (use_gcc_style_location) 
    return aprintf("%s:%d",pos->logical_file,pos->line_no);
  else 
    return aprintf("%s:(%d:%d)",pos->logical_file,pos->line_no,pos->col);
}

static mstring_t string_of_pos_pr(Lineno::pos_t pos_s, Lineno::pos_t pos_e) {
  if (use_gcc_style_location) 
    return aprintf("%s:%d",pos_s->logical_file,pos_s->line_no);
  else if (strcmp(pos_s->logical_file,pos_e->logical_file)==0)
    return aprintf("%s(%d:%d-%d:%d)", pos_s->logical_file,
		   pos_s->line_no,pos_s->col,
		   pos_e->line_no,pos_e->col);
  else
    return aprintf("%s(%d:%d)-%s(%d:%d)",
		   pos_s->logical_file,pos_s->line_no,pos_s->col,
		   pos_e->logical_file,pos_e->line_no,pos_e->col);
}

mstring_t string_of_segment(seg_t s) {
  if(s == NULL)
    return aprintf("%s",source);
  Lineno::pos_t pos_s = Lineno::pos_of_abs(source,s->start);
  Lineno::pos_t pos_e = Lineno::pos_of_abs(source,s->end);
  return string_of_pos_pr(pos_s,pos_e);
}

static Lineno::pos_t new_pos() {
  return new Lineno::Pos("",new_string(0),0,0);
}

list_t<mstringptr_t> strings_of_segments(list_t<seg_t,`r> segs) {
  list_t<$(int,Lineno::pos_t)@> places = NULL;
  for(let segs2 = segs; segs2 != NULL; segs2 = segs2->tl) {
    if(segs2->hd == NULL)
      continue;
    places = new List(new $(segs2->hd->end,   new_pos()),
                      new List(new $(segs2->hd->start, new_pos()),
                               places));
  }
  Lineno::poss_of_abss(source, places); // mutates places
  list_t<mstringptr_t> ans = NULL;
  places = List::imp_rev(places);
  for(; segs != NULL; segs = segs->tl) 
    if(segs->hd == NULL)
      ans = new List(new aprintf("%s(unknown)", source), ans);
    else {
      ans = new List(new string_of_pos_pr((*places->hd)[1],
					  (*places->tl->hd)[1]),
                     ans);
      places = places->tl->tl;
    }
  return ans;
}

///////////// Errors ////////////

datatype Error_kind { Lex, Parse, Elab };
struct Error {
  string_t     source;
  seg_t        seg;
  error_kind_t kind;
  string_t     desc;
};
error_t mk_err_lex(seg_t l, string_t<`H> desc) {
  return new Error(source, l, Lex, desc);
}
error_t mk_err_parse(seg_t l, string_t<`H> desc) {
  return new Error(source, l, Parse, desc);
}
error_t mk_err_elab(seg_t l, string_t<`H> desc) {
  return new Error(source, l, Elab, desc);
}

/////////// Error Reporting ///////////

// If there are errors getting stuff from the source file then raise Nocontext
// and just don't print the source context

datatype exn @extensible {Nocontext};

static mstring_t trunc(int n, mstring_t<`H> s) {
  int len = strlen(s);
  if (len < n) 
    return s;
  int len_one = (n-3)/2;
  int len_two = n-3-len_one;
  mstring_t mans = new_string(n+1);
  char ? @nozeroterm ans = (char ? @nozeroterm)mans;
  strncpy(ans,             s,               len_one);
  strncpy(ans + len_one,   "...",           3);
  strncpy(ans + (len_one+3), s + (len-len_two), len_two);
  return mans;
}

static int line_length = 76;

// Produce a one line string that shows the peice of the source file containing
// the error; return also the column numbers the error starts and finishes at.
static $(mstring_t,int,int)@ get_context(seg_t seg) {
  if(seg == NULL)
    throw Nocontext;
  Lineno::pos_t pos_s, pos_e;
  try {
    pos_s = Lineno::pos_of_abs(source,seg->start);
    pos_e = Lineno::pos_of_abs(source,seg->end);
  } catch {
  default: throw Nocontext;
  }
  
  let &Lineno::Pos(_,sline,sl,sc) = pos_s;
  let &Lineno::Pos(_,eline,el,ec) = pos_e;
  if (sl == el) {
    // Case 1: error is all on one line, 
    // give 1/3 of line to before, error, and after
    int n = line_length / 3;
    mstring_t sec_one   = trunc(n, substring(sline, 0,  sc            ));
    mstring_t sec_two   = trunc(n, substring(sline, sc, ec-sc         ));
    mstring_t sec_three = trunc(n, substring(sline, sc, strlen(sline)-ec));
    return new $(aprintf("%s%s%s",sec_one,sec_two,sec_three),
                 (int)strlen(sec_one),
                 (int)(strlen(sec_one)+strlen(sec_two)));
  }
  else {
    // Case 2: error on multiple lines,
    // give 1/4 to start, start line rror, end line error, and end
    int n = (line_length-3)/4;
    mstring_t sec_one   = trunc(n, substring(sline, 0,  sc            ));
    mstring_t sec_two   = trunc(n, substring(sline, sc, strlen(sline)-sc));
    mstring_t sec_three = trunc(n, substring(eline, 0,  ec            ));
    mstring_t sec_four  = trunc(n, substring(eline, ec, strlen(eline)-ec));
    return new $(aprintf("%s%s.\\.%s%s",sec_one,sec_two,sec_three,sec_four),
                 (int)strlen(sec_one),
                 (int)(strlen(sec_one)+strlen(sec_two)+3+strlen(sec_three)));
  }
}

static bool error_b = false;
bool error_p() { return error_b; }

datatype exn @extensible {Error(error_t)};

bool print_context = false;

bool first_error = true;

int num_errors = 0;
int max_errors = 10;

void post_error(error_t e) {
  error_b = true;
  fflush(stdout);
  if (first_error) {
    fprintf(stderr, "\n");
    first_error = false;
  }
  if(num_errors <=max_errors) {
    // why are we not using the source stored in e????
    fprintf(stderr, "%s: %s\n", string_of_segment(e->seg), e->desc);
    if (print_context) {
      try {
	$(mstring_t,int,int)@ x = get_context(e->seg);
	mstring_t marker_str = new {for i < (*x)[2]+1 : '\000'};
	int i = -1;
	while (++i < (*x)[1]) marker_str[i] = ' ';
	while (++i < (*x)[2]) marker_str[i] = '^';
	fprintf(stderr, "  %s\n  %s\n", (*x)[0], marker_str);
      } catch {
      case Nocontext: break; 
      }
    }
  }
  if(num_errors == max_errors) {
    fprintf(stderr, "Too many error messages!\n");
  }
  fflush(stderr);
  num_errors++;
}

//////////// Overall Control ///////////
void reset_position(string_t<`H> s)    { source = s; error_b = false; }
void set_position_file(string_t<`H> s) { source = s; error_b = false; }
string_t get_position_file() { return source; }


string_t get_line_directive(seg_t s) {
  Lineno::pos_t pos_s = Lineno::pos_of_abs(source,s->start);
  if(pos_s != NULL)  
    return aprintf("\n#line %d \"%s\"\n", pos_s->line_no, pos_s->logical_file);
  else 
    return NULL;
}
  
}


using Typerep;

datatype Typestruct segment_rep = __gen(struct Position::Segment);
