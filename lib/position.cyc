#include <core.h>
#include <list.h>
#include <stdio.h>
#include <position.h>
#include <string.h>
namespace Position;
using Core;
using List;
using Stdio;
using String;

xtunion exn {Exit};

/////////// Location tracking///////////
static string_t source = ""; // initialized by overall control
struct Segment { int start; int end; };

seg_t segment_of_abs(int start, int end) { return new{Segment(start,end)}; }
seg_t segment_join(seg_t s1, seg_t s2) { 
  if(s1 == null) return s2;
  if(s2 == null) return s1;
  return new{Segment(s1->start,s2->end)}; 
}

mstring_t string_of_loc(int loc) {
  Lineno::pos_t pos = Lineno::pos_of_abs(source,loc);
  return xprintf("%s (%d:%d)",pos->logical_file,pos->line_no,pos->col);
}

static mstring_t string_of_pos_pr(Lineno::pos_t pos_s, Lineno::pos_t pos_e) {
  if (strcmp(pos_s->logical_file,pos_e->logical_file)==0)
    return xprintf("%s(%d:%d-%d:%d)", pos_s->logical_file,
		   pos_s->line_no,pos_s->col,
		   pos_e->line_no,pos_e->col);
  else
    return xprintf("%s(%d:%d)-%s(%d:%d)",
		   pos_s->logical_file,pos_s->line_no,pos_s->col,
		   pos_e->logical_file,pos_e->line_no,pos_e->col);
}

mstring_t string_of_segment(seg_t s) {
  if(s == null)
    return xprintf("%s(unknown)",source);
  Lineno::pos_t pos_s = Lineno::pos_of_abs(source,s->start);
  Lineno::pos_t pos_e = Lineno::pos_of_abs(source,s->end);
  return string_of_pos_pr(pos_s,pos_e);
}

static Lineno::pos_t new_pos() {
  return new {Lineno::Pos("",new_string(0),0,0)};
}

list_t<mstringptr_t> strings_of_segments(glist_t<seg_t,`r> segs) {
  list_t<$(int,Lineno::pos_t)@> places = null;
  for(let segs2 = segs; segs2 != null; segs2 = segs2->tl) {
    if(segs2->hd == null)
      continue;
    places = new List(new $(segs2->hd->end,   new_pos()),
                      new List(new $(segs2->hd->start, new_pos()),
                               places));
  }
  Lineno::poss_of_abss(source, places); // mutates places
  list_t<mstringptr_t> ans = null;
  places = List::imp_rev(places);
  for(; segs != null; segs = segs->tl) 
    if(segs->hd == null)
      ans = new List(new {xprintf("%s(unknown)", source)}, ans);
    else {
      ans = new List(new {string_of_pos_pr((*places->hd)[1],
                                           (*places->tl->hd)[1])},
                     ans);
      places = places->tl->tl;
    }
  return ans;
}

///////////// Errors ////////////

tunion Error_kind { Lex, Parse, Elab };
struct Error {
  string_t       source;
  seg_t        seg;
  error_kind_t kind;
  string_t       desc;
};
error_t mk_err_lex(seg_t l, string_t desc) {
  return new Error(source, l, Lex, desc);
}
error_t mk_err_parse(seg_t l, string_t desc) {
  return new Error(source, l, Parse, desc);
}
error_t mk_err_elab(seg_t l, string_t desc) {
  return new Error(source, l, Elab, desc);
}

/////////// Error Reporting ///////////

// If there are errors getting stuff from the source file then raise Nocontext
// and just don't print the source context

xtunion exn {Nocontext};

static mstring_t trunc(int n, mstring_t s) {
  int len = strlen(s);
  if (len < n) 
    return s;
  int len_one = (n-3)/2;
  int len_two = n-3-len_one;
  mstring_t ans = new_string(n+1);
  strncpy(ans, 0,         s,     0,           len_one);
  strncpy(ans, len_one,   "...", 0,           3);
  strncpy(ans, len_one+3, s,     len-len_two, len_two);
  return ans;
}

static int line_length = 76;

// Produce a one line string that shows the peice of the source file containing
// the error; return also the column numbers the error starts and finishes at.
static $(mstring_t,int,int)@ get_context(seg_t seg) {
  if(seg == null)
    throw Nocontext;
  Lineno::pos_t pos_s, pos_e;
  try {
    pos_s = Lineno::pos_of_abs(source,seg->start);
    pos_e = Lineno::pos_of_abs(source,seg->end);
  } catch {
  default: throw Nocontext;
  }
  
  let &Lineno::Pos(_,sline,sl,sc) = pos_s;
  let &Lineno::Pos(_,eline,el,ec) = pos_e;
  if (sl == el) {
    // Case 1: error is all on one line, 
    // give 1/3 of line to before, error, and after
    int n = line_length / 3;
    mstring_t sec_one   = trunc(n, substring(sline, 0,  sc            ));
    mstring_t sec_two   = trunc(n, substring(sline, sc, ec-sc         ));
    mstring_t sec_three = trunc(n, substring(sline, sc, strlen(sline)-ec));
    return new $(xprintf("%s%s%s",sec_one,sec_two,sec_three),
                 (int)strlen(sec_one),
                 (int)(strlen(sec_one)+strlen(sec_two)));
  }
  else {
    // Case 2: error on multiple lines,
    // give 1/4 to start, start line rror, end line error, and end
    int n = (line_length-3)/4;
    mstring_t sec_one   = trunc(n, substring(sline, 0,  sc            ));
    mstring_t sec_two   = trunc(n, substring(sline, sc, strlen(sline)-sc));
    mstring_t sec_three = trunc(n, substring(eline, 0,  ec            ));
    mstring_t sec_four  = trunc(n, substring(eline, ec, strlen(eline)-ec));
    return new $(xprintf("%s%s.\\.%s%s",sec_one,sec_two,sec_three,sec_four),
                 (int)strlen(sec_one),
                 (int)(strlen(sec_one)+strlen(sec_two)+3+strlen(sec_three)));
  }
}

static bool error_b = false;
bool error_p() { return error_b; }

xtunion exn {Error(error_t)};

bool print_context = false;

bool first_error = true;

void post_error(error_t e) {
  error_b = true;
  fflush(stdout);
  if (first_error) {
    fprintf(stderr, "\n");
    first_error = false;
  }
  // why are we not using the source stored in e????
  fprintf(stderr, "%s: %s\n", string_of_segment(e->seg), e->desc);
  if (print_context) {
    try {
      $(mstring_t,int,int)@ x = get_context(e->seg);
      mstring_t marker_str = new {for i < (*x)[2]+1 : '\000'};
      int i = -1;
      while (++i < (*x)[1]) marker_str[i] = ' ';
      while (++i < (*x)[2]) marker_str[i] = '^';
      fprintf(stderr, "  %s\n  %s\n", (*x)[0], marker_str);
    } catch {
    case Nocontext: break; 
    }
  }
  fflush(stderr);
}

//////////// Overall Control ///////////
void reset_position(string_t s)    { source = s; error_b = false; }
void set_position_file(string_t s) { source = s; error_b = false; }
string_t get_position_file() { return source; }

