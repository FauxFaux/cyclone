/* This file is part of the Cyclone Library.
   Copyright (C) 2001 Mike Hicks, AT&T

   This library is free software; you can redistribute it and/or it
   under the terms of the GNU Lesser General Public License as
   published by the Free Software Foundation; either version 2.1 of
   the License, or (at your option) any later version.

   This library is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with this library; see the file COPYING.LIB.  If not,
   write to the Free Software Foundation, Inc., 59 Temple Place, Suite
   330, Boston, MA 02111-1307 USA. */

// String library, base on code from Mike Hicks, modified by T. Jim

#include <core.h>
#include <list.h>
#include <ctype.h>
#include <string.h>
#include <strings.h>
#include <stddef.h> // for size_t

//  #define static_c2s(x) (Cstring_to_string(x))
#define static_c2s(x) (wrap_Cstring_as_string(x,-1))

namespace Std {
using Core;
using List;

///////////////////////// WRAPPERS
namespace C_string {
  extern "C" {
    Cstring strerror(int errnum);
  }
}
string_t strerror(int errnum) {
  return static_c2s(C_string::strerror(errnum));
}

///////////////////////// LENGTH
size_t strlen(string_t s) {
  size_t i;
  for (i = 0; i<s.size; i++) {
    if (s[i] == '\000')
      return i;
  }
  return i;
}

// Internal length after offset function, parameterized by what
// to throw if the offset is out of range.
static size_t int_strleno(string_t s, string_t<`H> error) {
  int i;
  for (i = 0; i<s.size; i++) {
    if (s[i] == '\000')
      break;
  }
  return (size_t)(i);
}

///////////////////////// COMPARISONS
static int case_cmp(char c1, char c2) {
  return (c1-c2);
}

static int cmp(string_t s1, size_t len1,
               string_t s2, size_t len2,
               int f(char, char))
{
  size_t min_length = (len1 < len2) ? len1 : len2;
  int i = -1;
  while (++i < min_length) {
    int diff = f(s1[i],s2[i]);
    if (diff != 0)
      return diff;
  }
  return ((int)len1)-((int)len2);
}

// Compare two strings lexicographically.
// Return <0, 0, or >0 depending on whether s1<s2, s1==s2, or s1>s2.
int strcmp(string_t s1, string_t s2) {
  if (s1 == s2)
    return 0;
  size_t len1 = int_strleno(s1,"Std::strcmp");
  size_t len2 = int_strleno(s2,"Std::strcmp");
  return cmp(s1,len1,s2,len2,case_cmp);
}

int strptrcmp(stringptr_t s1, stringptr_t s2) {
  return strcmp(*s1, *s2);
}

static int ncmp(string_t s1, size_t len1,
                string_t s2, size_t len2,
                size_t n, int f(char, char))
{
  if (n <= 0) return 0;

  size_t min_len = (len1 > len2) ? len2 : len1;
  size_t bound = (min_len > n) ? n : min_len;

  for (int i=0; i < bound; i++) {
    int retc;
    if ((retc = f(s1[i],s2[i])) != 0)
      return retc;
  }
  if (len1 < n || len2 < n)
    return ((int)len1)-((int)len2);
  return(0);
}

// Like strcmp but compare no more than n characters.
// If n<0 return 0 (equal).
int strncmp(string_t s1, string_t s2, size_t n) {
  size_t len1 = int_strleno(s1,"Std::strncmp");
  size_t len2 = int_strleno(s2,"Std::strncmp");
  return ncmp(s1,len1,s2,len2,n,case_cmp);
}

// Like strcmp but don't consider zeros (NUL characters) as marking
// the end of strings.
int zstrcmp(string_t a, string_t b) {
  if(a == b)
    return 0;
  size_t as = a.size;
  size_t bs = b.size;
  size_t min_length = (as < bs) ? as : bs;
  int i  = -1;
  while (++i < min_length) {
    int diff = (int)(a[i]) - (int)(b[i]);
    if (diff != 0)
      return diff;
  }
  return ((int)as)-((int)bs);
}
// Like zstrcmp but consider at most n characters
int zstrncmp(string_t s1, string_t s2,size_t n) {
  if (n <= 0) return 0;

  size_t s1size = s1.size;
  size_t s2size = s2.size;
  size_t min_size = (s1size > s2size) ? s2size : s1size;
  size_t bound = (min_size > n) ? n : min_size;

  for (int i=0; i < bound; i++) {
    if (s1[i] < s2[i])
      return(-1);
    else if (s2[i] < s1[i])
      return(1);
  }
  if (min_size <= bound)
    return(0);
  if (s1size < s2size)
    return(-1);
  else 
    return(1);
}

// like zstrcmp but operates on pointers -- useful for hashtables
int zstrptrcmp(stringptr_t a, stringptr_t b) {
  return(zstrcmp(*a,*b));
}


///////////////////////// CONCATENATION

// Internal string concatenation function, parametized by what
// to throw on bounds error
static mstring_t<`r> int_strcato(mstring_t<`r> dest,string_t src,string_t<`H> error) {
  int i;
  size_t dsize, slen, dlen;

  dsize = dest.size;
  dlen = strlen(dest);
  slen = int_strleno(src,error);
  
  if ((slen + dlen) <= dsize) {
    for (i = 0; i<slen; i++) {
      dest[i+dlen] = src[i];
    }
    if (i != dsize)
      dest[i+dlen] = '\000';
  }
  else
    throw new Invalid_argument(error);
  return dest;
}

// Destructive concatenation: the first argument is modified,
// and returned
mstring_t<`r> strcat(mstring_t<`r> dest,string_t src) {
  return int_strcato(dest,src,"Std::strcat");
}

// Allocate a new string and fill it with the concatenation of a and b
mstring_t<`r> rstrconcat(region_t<`r> r, string_t a, string_t b) {
  let alen = strlen(a);
  let blen = strlen(b);
  mstring_t<`r> ans = rnew_string(r,alen+blen+1);
  int i, j;
  for (i=0; i < alen; ++i) ans[i]   = a[i];
  for (j=0; j < blen; ++j) ans[i+j] = b[j];
  return ans;
}

mstring_t strconcat(string_t a, string_t b) {
  return rstrconcat(heap_region, a, b);
}

// Allocate a new string and fill it with the concatenation of strs
mstring_t<`r> rstrconcat_l(region_t<`r> r,list_t<stringptr_t>strs)
{
  size_t len;                           // temp
  size_t total_len  = 0;                // sum of lengths of the strings
  mstring_t<`r> ans;
  region temp {
    list_t<size_t,`temp> lens = 
      rnew(temp) List((size_t)0,        // save length of each string
                      NULL);            // (with junk 0 on front)
    list_t<size_t,`temp> end = lens;   // last cons cell in 'lens'
    for(_ p = strs; p!=NULL; p = p->tl) {
      len = strlen(*(p->hd));
      total_len += len;
      end->tl = rnew(temp) List(len,NULL);
      end = end->tl;
    } 
    lens = lens->tl;                      // remove junk/temporary 0
    ans = rnew_string(r,total_len+1);
    size_t i = 0;
    while (strs != NULL) {
      let next    = *(strs->hd);
      len            = lens->hd;
      strncpy(ans+i,next,len);
      i += len;
      strs = strs->tl;
      lens = lens->tl;
    }
  }
  return ans;
}

mstring_t strconcat_l(list_t<stringptr_t> strs)
{
  return rstrconcat_l(heap_region,strs);
}

// Allocate a new string and fill it with the concatenation of strs,
// using separator between each element
mstring_t<`r> rstr_sepstr(region_t<`r> r,list_t<stringptr_t> strs, string_t separator) {
  if (strs == NULL)    return rnew_string(r,0);
  if (strs->tl == NULL) return rstrdup(r,*(strs->hd));
  let p = strs;
  region temp {
    list_t lens = rnew(temp) List((size_t)0,NULL);// see comments in strconcat_l
    list_t end = lens;
    size_t len        = 0;   // initialized to avoid warning
    size_t total_len  = 0;
    size_t list_len   = 0;
    for(;p!=NULL;p=p->tl) {
      len = strlen(*(p->hd));
      total_len += len;
      end->tl = rnew(temp) List(len,NULL);
      end = end->tl;
      ++list_len;
    }
    lens = lens->tl;
    size_t seplen = strlen(separator);
    total_len += (list_len - 1)*seplen;
    mstring_t ans = rnew_string(r,total_len);
    size_t i = 0;
    while (strs->tl != NULL) {
      let next    = *(strs->hd);
      len            = lens->hd;
      strncpy(ans+i,next,len);
      i += len;
      strncpy(ans+i,separator,seplen);
      i += seplen;
      strs = strs->tl;
      lens = lens->tl;
    }
    strncpy(ans+i,*(strs->hd),lens->hd);
    return ans;
  }
}

mstring_t str_sepstr(list_t<stringptr_t> strs, string_t separator) {
  return rstr_sepstr(heap_region,strs,separator);
}
///////////////////////// COPYING
// Destructively copy at most n characters from src into dest
mstring_t<`r> strncpy(mstring_t<`r> dest, string_t src, size_t n) {
  // Range checking
  let destSz = dest.size;
  let srcSz = src.size;
  if (n <= 0) return dest;
  if (n > destSz || n > srcSz)
    throw new Invalid_argument("Std::strncpy");
  int i;
  for (i=0; i<n; i++) {
    let srcChar = src[i];
    if (srcChar == '\000') break;
    dest[i] = srcChar;
  }
  for (; i<n; i++)
    dest[i] = '\000';

  return dest;

  // FIX: This isn't right.  src->contents and dest->contents
  // might be the same (e.g., from casting) !!
  // We don't currently have a way to detect this at the Cyclone level,
  // so we take C's approach and leave behavior ambiguous in this case.
//   if (src != dest
//      || destOfs + n < srcOfs 
//      || srcOfs  + n < destOfs)
//     for (int i=0; i<n; i++)
//       dest[destOfs+i] = src[srcOfs+i];
//   else {
//     // we could do better, but this is correct
//     mstring_t buffer = new_string(n);
//     for (int i=0; i<n; i++)
//       buffer[i] = src[srcOfs+i];
//     for (int i=0; i<n; i++)
//       dest[destOfs+i] = buffer[i];
//   }
}

// Strncpy that does not pay attention to zero chars
mstring_t<`r> zstrncpy(mstring_t<`r> dest, string_t src, size_t n) {
  // Range checking
  let destSz = dest.size;
  let srcSz  = src.size;
  if (n <= 0) return dest;
  if (n > destSz || n > srcSz)
    throw new Invalid_argument("Std::zstrncpy");
  int i;
  for (i=0; i<n; i++) 
    dest[i] = src[i];
  return dest;
}
// Non-allocating string copy: first arg is returned
mstring_t<`r> strcpy(mstring_t<`r> dest, string_t src) {
  size_t len = strlen(src);
  strncpy(dest,src,len);
  if (len != dest.size)
    dest[len] = '\000';
  return dest;
}

// Allocating functions

// Not an ISO function, but available in gcc
mstring_t<`r> rstrdup(region_t<`r> r, string_t src) {
  size_t len;
  mstring_t<`r> temp;

  len = strlen(src);
  temp = rnew_string(r,len+1);
  strncpy(temp,src,len);
  return temp;
}

mstring_t strdup(string_t src) {
  return rstrdup(heap_region, src);
}

mstring_t<`r> rexpand(region_t<`r> r,string_t s, size_t sz) {
  mstring_t temp;
  size_t slen;

  slen = strlen(s);
  sz = (sz>slen)?sz:slen;
  temp = rnew_string(r,sz);

  strncpy(temp,s,slen);

  if (slen != s.size)
    temp[slen] = '\000';

  return temp;
}

mstring_t expand(string_t s, size_t sz) {
  return rexpand(heap_region,s,sz);
}

mstring_t<`r> rrealloc_str(region_t<`r> r, mstring_t<`r> str, size_t sz)
{
  size_t maxsizeP = str.size;

  if (maxsizeP == 0) {
    maxsizeP = (30>sz)?30:sz;	/* arbitrary */
    str = rnew_string(r,maxsizeP);
    str[0] = '\000';
  }
  else if (sz > maxsizeP) {
    maxsizeP = (maxsizeP * 2 > sz * 5 / 4)?(maxsizeP * 2):(sz * 5 / 4);
    str = rexpand(r, str, maxsizeP);
  }

  return str;
}

mstring_t realloc_str(mstring_t<`H> str, size_t sz) {
  return rrealloc_str(heap_region,str,sz);
}


///////////////////////// TRANSFORMATIONS
// Return a substring of a string, by allocation.
// FIX: This adds an extra NUL character at the end of the string.
// I'd like to remove it but it causes a bug in the lexer on bootstrapping.
mstring_t<`r> rsubstring(region_t<`r> r,string_t s, 
                     int start, size_t amt) {
  if (start < 0 || amt < 0 || start + ((int)amt) - 1 > (int)(s.size))
    throw new Invalid_argument("Std::substring");
  mstring_t ans = rnew_string(r,amt+1);
  for(size_t i=0; i<amt; ++i)
    ans[i] = s[start+i];
  ans[amt] = '\000';
  return ans;
}

mstring_t substring(string_t s, int start, size_t amt) {
  return rsubstring(heap_region,s,start,amt);
}

// replace last with second at end of first
// raise Invalid_argument if second is not end of first.
mstring_t<`r> rreplace_suffix (region_t<`r> r,string_t src, string_t curr_suffix, string_t new_suffix) {
  size_t m = src.size;
  size_t n = curr_suffix.size;
  string_t err = "Std::replace_suffix";
  if (m < n) 
    throw new Invalid_argument(err);
  for (size_t i = 1; i <= n; ++i)
    if (src[m-i] != curr_suffix[n-i])
      throw new Invalid_argument(err);
  mstring_t ans = rnew_string(r,m-n+new_suffix.size);
  strncpy(ans,src,m-n);
  strncpy(ans+m-n,new_suffix,new_suffix.size);
  return ans;
}

mstring_t replace_suffix (string_t src, string_t curr_suffix, string_t new_suffix) {
  return rreplace_suffix(heap_region,src,curr_suffix,new_suffix);
}
////////////////////////// SEARCHING

// Search for any character of accept in s.
// Return a ? pointer to the first such character, or NULL if none.
string_t<`r> strpbrk(string_t<`r> s, string_t accept) {
  int len = int_strleno(s,"Std::strpbrk");
  char c = '\000';

  for (; len>0 && (c=*s)!=0; len--,s++) {
    for (int j=0; j<accept.size; j++)
      if (c == accept[j])
	return s;
  }
  return NULL;
}

mstring_t<`r> mstrpbrk(mstring_t<`r> s, string_t accept) {
  int len = int_strleno(s,"Std::strpbrk");
  char c = '\000';

  for (; len>0 && (c=*s)!=0; len--,s++) {
    for (int j=0; j<accept.size; j++)
      if (c == accept[j])
	return s;
  }
  return NULL;
}

// Return a pointer to the first occurrence of c in s, 
// or NULL if none.
mstring_t<`r> mstrchr(mstring_t<`r> s, char c) {
  int len = int_strleno(s,"Std::strchr");
  char c2 = '\000';

  for (; len>0 && (c2=*s)!=0; len--,s++) {
    if (c2 == c)
      return s;
  }
  return NULL;
}

string_t<`r> strchr(string_t<`r> s, char c) {
  int len = int_strleno(s,"Std::strchr");
  char c2 = '\000';

  for (; len>0 && (c2=*s)!=0; len--,s++) {
    if (c2 == c)
      return s;
  }
  return NULL;
}

// Return a pointer to the last occurrence of c in s,
// or NULL if none.
string_t<`r> strrchr(string_t<`r> s, char c) {
  int len = int_strleno(s,"Std::strrchr");
  int i = len - 1;
  s += i;

  for (; i>=0; i--, s--) {
    if (*s == c)
      return s;
  }
  return NULL;
}

mstring_t<`r> mstrrchr(mstring_t<`r> s, char c) {
  int len = int_strleno(s,"Std::mstrrchr");
  int i = len - 1;
  s += i;

  for (; i>=0; i--, s--) {
    if (*s == c)
      return s;
  }
  return NULL;
}

// Return a pointer to the beginning of the substring needle within
// haystack, or NULL if the substring is not found.
string_t<`r> strstr(string_t<`r> haystack, string_t needle) {
  if (!haystack || !needle) throw new Invalid_argument("Std::strstr");
  if (*needle == '\0') return haystack;

  int len = int_strleno(needle, "Std::strstr");
  for (string_t<`r> start = haystack;
       (start = strchr(start, *needle)) != NULL;
       start = strchr(start+1, *needle))
    if (strncmp(start, needle, len) == 0)
      return start;

  return NULL;
}

mstring_t<`r> mstrstr(mstring_t<`r> haystack, string_t needle) {
  if (!haystack || !needle) throw new Invalid_argument("Std::mstrstr");
  if (*needle == '\0') return haystack;

  int len = int_strleno(needle, "Std::mstrstr");
  for (mstring_t<`r> start = haystack;
       (start = mstrchr(start, *needle)) != NULL;
       start = mstrchr(start+1, *needle))
    if (strncmp(start, needle, len) == 0)
      return start;

  return NULL;
}

// Search s for an occurrence of a character not in accept.
// Return the offset to the first such character, or the length
// of s if none.
size_t strspn(string_t s, string_t accept) {
  size_t len = int_strleno(s,"Std::strspn");

  for (size_t i=0; i<len; i++) {
    int j;
    for (j=0; j<accept.size; j++)
      if (s[i] == accept[j])
	break; /* inner loop */
    if (j == accept.size) /* didn't find it */
      return i;
  }
      
  return len;
}

// Search s for an occurrence of a character in accept.
// Return the offset to the first such character, or the length
// of s if none.
size_t strcspn(string_t s, string_t accept) {
  size_t len = int_strleno(s,"Std::strspn");

  for (size_t i=0; i<len; i++) {
    int j;
    for (j=0; j<accept.size; j++)
      if (s[i] != accept[j])
	break; /* inner loop */
    if (j == accept.size) /* didn't find it */
      return i;
  }
      
  return len;
}


////////////////////////// CONVERSIONS
list_t<int,`r> rexplode(region_t<`r> r,string_t s) {
  list_t result = NULL;
  for (int i = strlen(s) - 1; i >= 0; i--)
    result = rnew(r) List((int)s[i],result);
  return result;
}

list_t<int> explode(string_t s) {
  return rexplode(heap_region, s);
}

mstring_t implode(list_t<int> chars) {
  mstring_t s = new_string(List::length(chars));
  size_t i = 0;
  while (chars != NULL) {
    s[i++] = (char)chars->hd;
    chars = chars->tl;
  }
  return(s);
}

// Like strcmp, but case insensitive.
int strcasecmp(string_t s1, string_t s2) {
  if (s1 == s2)
    return 0;
  size_t len1 = int_strleno(s1,"Std::strcasecmp");
  size_t len2 = int_strleno(s2,"Std::strcasecmp");
  return cmp(s1,len1,s2,len2,case_cmp);
}

static int nocase_cmp(char c1, char c2) {
  return case_cmp((char)toupper(c1),(char)toupper(c2));
}

// Like strncmp, but case insensitive.
int strncasecmp(string_t s1, string_t s2, size_t n) {
  size_t len1 = int_strleno(s1,"Std::strncasecmp");
  size_t len2 = int_strleno(s2,"Std::strncasecmp");
  return ncmp(s1,len1,s2,len2,n,nocase_cmp);
}

}
