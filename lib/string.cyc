// String library, base on code from Mike Hicks, modified by T. Jim

#include <core.h>
#include <list.h>
#include <ctype.h>
#include <string.h>
#include <stdio.h> // for size_t
#include <math.h> //  for pow

namespace String;
using Core;
using List;
using Stdio; // for size_t

///////////////////////// WRAPPERS
namespace C_string {
  extern "C" {
    Cstring strerror(int errnum);
  }
}
mstring_t strerror(int errnum) {
  return Cstring_to_string(C_string::strerror(errnum));
}

///////////////////////// LENGTH
size_t strlen(string_t s) {
  size_t i;
  for (i = 0; i<s.size; i++) {
    if (s[i] == '\000')
      return i;
  }
  return i;
}

// Internal length after offset function, parameterized by what
// to throw if the offset is out of range.
static size_t int_strleno(string_t s, int ofs, string_t error) {
  if (ofs > s.size || ofs < 0) throw new InvalidArg(error);
  int i;
  for (i = ofs; i<s.size; i++) {
    if (s[i] == '\000')
      break;
  }
  return (size_t)(i-ofs);
}

///////////////////////// COMPARISONS
static int case_cmp(char c1, char c2) {
  return (c1-c2);
}

static int nocase_cmp(char c1, char c2) {
  return case_cmp((char)Ctype::toupper(c1),(char)Ctype::toupper(c2));
}

static int cmp(string_t s1, int ofs1, size_t len1,
               string_t s2, int ofs2, size_t len2,
               int f(char, char))
{
  size_t min_length = (len1 < len2) ? len1 : len2;
  int i = -1;
  while (++i < min_length) {
    int diff = f(s1[i+ofs1],s2[i+ofs2]);
    if (diff != 0)
      return diff;
  }
  return ((int)len1)-((int)len2);
}

// Compare two strings lexicographically.
// Return <0, 0, or >0 depending on whether s1<s2, s1==s2, or s1>s2.
int strcmp(string_t s1, string_t s2) {
  if (s1 == s2)
    return 0;
  size_t len1 = int_strleno(s1,0,"String::strcmp");
  size_t len2 = int_strleno(s2,0,"String::strcmp");
  return cmp(s1,0,len1,s2,0,len2,case_cmp);
}

int strptrcmp(stringptr_t s1, stringptr_t s2) {
  return strcmp(*s1, *s2);
}

static int ncmp(string_t s1, int ofs1, size_t len1,
                string_t s2, int ofs2, size_t len2,
                size_t n, int f(char, char))
{
  if (n <= 0) return 0;

  size_t min_len = (len1 > len2) ? len2 : len1;
  size_t bound = (min_len > n) ? n : min_len;

  for (int i=0; i < bound; i++) {
    int retc;
    if ((retc = f(s1[i+ofs1],s2[i+ofs2])) != 0)
      return retc;
  }
  return(0);
}

// Like strcmp but compare no more than n characters.
// If n<0 return 0 (equal).
int strncmp(string_t s1, string_t s2, size_t n) {
  size_t len1 = int_strleno(s1,0,"String::strncmp");
  size_t len2 = int_strleno(s2,0,"String::strncmp");
  return ncmp(s1,0,len1,s2,0,len2,n,case_cmp);
}

// Like strncmp, but case insensitive.  GCC has it but not C.
int strncasecmp(string_t s1, string_t s2, size_t n) {
  size_t len1 = int_strleno(s1,0,"String::strncasecmp");
  size_t len2 = int_strleno(s2,0,"String::strncasecmp");
  return ncmp(s1,0,len1,s2,0,len2,n,nocase_cmp);
}


// Like strcmp but don't consider zeros (null characters) as marking
// the end of strings.
int zstrcmp(string_t a, string_t b) {
  if(a == b)
    return 0;
  size_t as = a.size;
  size_t bs = b.size;
  size_t min_length = (as < bs) ? as : bs;
  int i  = -1;
  while (++i < min_length) {
    int diff = (int)(a[i]) - (int)(b[i]);
    if (diff != 0)
      return diff;
  }
  return ((int)as)-((int)bs);
}
// Like zstrcmp but consider at most n characters
int zstrncmp(string_t s1,string_t s2,size_t n) {
  if (n <= 0) return 0;

  size_t s1size = s1.size;
  size_t s2size = s2.size;
  size_t min_size = (s1size > s2size) ? s2size : s1size;
  size_t bound = (min_size > n) ? n : min_size;

  for (int i=0; i < bound; i++) {
    if (s1[i] < s2[i])
      return(-1);
    else if (s2[i] < s1[i])
      return(1);
  }
  if (min_size <= bound)
    return(0);
  if (s1size < s2size)
    return(-1);
  else 
    return(1);
}
// like zstrcmp but operates on pointers -- useful for hashtables
int zstrptrcmp(stringptr_t a, stringptr_t b) {
  return(zstrcmp(*a,*b));
}


///////////////////////// CONCATENATION

// Internal string concatenation function, parametized by what
// to throw on bounds error
static mstring_t int_strcato(mstring_t dest,string_t src,int srcOfs,string_t error) {
  int i;
  size_t dsize, slen, dlen;

  dsize = dest.size;
  dlen = strlen(dest);
  slen = int_strleno(src,srcOfs,error);
  
  if ((slen + dlen) <= dsize) {
    for (i = 0; i<slen; i++) {
      dest[i+dlen] = src[i+srcOfs];
    }
    if (i != dsize)
      dest[i+dlen] = '\000';
  }
  else
    throw new InvalidArg(error);
  return dest;
}

// Destructive concatenation: the first argument is modified,
// and returned
mstring_t strcat(mstring_t dest,string_t src) {
  return int_strcato(dest,src,0,"String::strcat");
}

// Allocate a new string and fill it with the concatenation of a and b
mstring_t strconcat(string_t a, string_t b) {
  let alen = strlen(a);
  let blen = strlen(b);
  mstring_t ans = new_string(alen+blen);
  int i, j;
  for (i=0; i < alen; ++i) ans[i]   = a[i];
  for (j=0; j < blen; ++j) ans[i+j] = b[j];
  return ans;
}

// Allocate a new string and fill it with the concatenation of strs
mstring_t strconcat_l(glist_t<stringptr_t,`r> strs) {
  size_t len;                           // temp
  size_t total_len  = 0;                // sum of lengths of the strings
  list_t<size_t> lens = 
    new List((size_t)0,                    // save length of each string
             null);                        // (with junk 0 on front)
  list_t<size_t> end = lens;            // last cons cell in 'lens'
  for(_ p = strs; p!=null; p = p->tl) {
    len = strlen(*(p->hd));
    total_len += len;
    end->tl = new List(len,null);
    end = end->tl;
  } 
  lens = lens->tl;                      // remove junk/temporary 0
  mstring_t ans = new_string(total_len);
  size_t i = 0;
  while (strs != null) {
    let next    = *(strs->hd);
    len            = lens->hd;
    strncpy(ans,i,next,0,len);
    i += len;
    strs = strs->tl;
    lens = lens->tl;
  }
  return ans;
}

// Allocate a new string and fill it with the concatenation of strs,
// using separator between each element
mstring_t str_sepstr(glist_t<stringptr_t,`r> strs, string_t separator) {
  if (strs == null)    return new_string(0);
  if (strs->tl == null) return strdup(*(strs->hd));
  glist_t<stringptr_t,`r> p = strs;
  list_t<size_t> lens = new List((size_t)0,null);// see comments in strconcat_l
  list_t<size_t> end = lens;
  size_t len        = 0;   // initialized to avoid warning
  size_t total_len  = 0;
  size_t list_len   = 0;
  for(;p!=null;p=p->tl) {
    len = strlen(*(p->hd));
    total_len += len;
    end->tl = new List(len,null);
    end = end->tl;
    ++list_len;
  }
  lens = lens->tl;
  size_t seplen = strlen(separator);
  total_len += (list_len - 1)*seplen;
  mstring_t ans = new_string(total_len);
  size_t i = 0;
  while (strs->tl != null) {
    let next    = *(strs->hd);
    len            = lens->hd;
    strncpy(ans,i,next,0,len);
    i += len;
    strncpy(ans,i,separator,0,seplen);
    i += seplen;
    strs = strs->tl;
    lens = lens->tl;
  }
  strncpy(ans,i,*(strs->hd),0,lens->hd);
  return ans;
}

///////////////////////// COPYING
// Destructively copy at most n characters from src into dest, starting
// at the given offsets
// (C version does not take offsets)
mstring_t strncpy(mstring_t dest, int destOfs, string_t src, int srcOfs, size_t n) {
  // Range checking
  let destSz = dest.size;
  let srcSz = src.size;
  if (destOfs < 0)
    throw new InvalidArg("String::strncpy");
  if (srcOfs < 0 || (n > 0 && srcOfs >= srcSz))
    throw new InvalidArg("String::strncpy");
  if (n <= 0) return dest;
  if (destOfs + n > destSz || srcOfs + n > srcSz)
    throw new InvalidArg("String::strncpy");
  int i;
  for (i=0; i<n; i++) {
    let srcChar = src[srcOfs+i];
    if (srcChar == '\000') break;
    dest[destOfs+i] = srcChar;
  }
  for (; i<n; i++)
    dest[destOfs+i] = '\000';

  return dest;

  // FIX: This isn't right.  src->contents and dest->contents
  // might be the same (e.g., from casting) !!
  // We don't currently have a way to detect this at the Cyclone level,
  // so we take C's approach and leave behavior ambiguous in this case.
//   if (src != dest
//      || destOfs + n < srcOfs 
//      || srcOfs  + n < destOfs)
//     for (int i=0; i<n; i++)
//       dest[destOfs+i] = src[srcOfs+i];
//   else {
//     // we could do better, but this is correct
//     mstring_t buffer = new_string(n);
//     for (int i=0; i<n; i++)
//       buffer[i] = src[srcOfs+i];
//     for (int i=0; i<n; i++)
//       dest[destOfs+i] = buffer[i];
//   }
}

// Strncpy that does not pay attention to zero chars
mstring_t zstrncpy(mstring_t dest, int destOfs, string_t src, int srcOfs, size_t n) {
  // Range checking
  let destSz = dest.size;
  let srcSz  = src.size;
  if (destOfs < 0)
    throw new InvalidArg("String::zstrncpy");
  if (srcOfs < 0 || (n > 0 && srcOfs >= srcSz))
    throw new InvalidArg("String::zstrncpy");
  if (n <= 0) return dest;
  if (destOfs + n > destSz || srcOfs + n > srcSz)
    throw new InvalidArg("String::zstrncpy");
  int i;
  for (i=0; i<n; i++) 
    dest[destOfs+i] = src[srcOfs+i];
  return dest;
}
// Non-allocating string copy: first arg is returned
mstring_t strcpy(mstring_t dest,string_t src) {
  size_t len = strlen(src);
  strncpy(dest,0,src,0,len);
  if (len != dest.size)
    dest[len] = '\000';
  return dest;
}

// Allocating functions

// Not an ISO function, but available in gcc
mstring_t strdup(string_t src) {
  size_t len;
  mstring_t temp;

  len = strlen(src);
  temp = new_string(len);
  strncpy(temp,0,src,0,len);
  return temp;
}

mstring_t expand(string_t s, size_t sz) {
  mstring_t temp;
  size_t slen;

  slen = strlen(s);
  sz = (sz>slen)?sz:slen;
  temp = new_string(sz);

  strncpy(temp,0,s,0,slen);

  if (slen != s.size)
    temp[slen] = '\000';

  return temp;
}

mstring_t realloc_str(mstring_t str, size_t sz)
{
  size_t maxsizeP = str.size;

  if (maxsizeP == 0) {
    maxsizeP = (30>sz)?30:sz;	/* arbitrary */
    str = new_string(maxsizeP);
    str[0] = '\000';
  }
  else if (sz > maxsizeP) {
    maxsizeP = (maxsizeP * 2 > sz * 5 / 4)?(maxsizeP * 2):(sz * 5 / 4);
    str = expand(str, maxsizeP);
  }

  return str;
}


///////////////////////// TRANSFORMATIONS
// Return a substring of a string, by allocation.
// FIX: This adds an extra null character at the end of the string.
// I'd like to remove it but it causes a bug in the lexer on bootstrapping.
mstring_t substring(string_t s, int start, size_t amt) {
  if (start < 0 || amt < 0 || start + ((int)amt) - 1 > (int)(s.size))
    throw new InvalidArg("String::substring");
  mstring_t ans = new_string(amt+1);
  for(size_t i=0; i<amt; ++i)
    ans[i] = s[start+i];
  ans[amt] = '\000';
  return ans;
}

// replace last with second at end of first
// raise InvalidArg if second is not end of first.
mstring_t replace_suffix (string_t src, string_t curr_suffix, string_t new_suffix) {
  size_t m = src.size;
  size_t n = curr_suffix.size;
  string_t err = "String::replace_suffix";
  if (m < n) 
    throw new InvalidArg(err);
  for (size_t i = 1; i <= n; ++i)
    if (src[m-i] != curr_suffix[n-i])
      throw new InvalidArg(err);
  mstring_t ans = new_string(m-n+new_suffix.size);
  strncpy(ans,0,src,0,m-n);
  strncpy(ans,m-n,new_suffix,0,new_suffix.size);
  return ans;
}

////////////////////////// SEARCHING

// Search for any character of accept in s.
// Return a ? pointer to the first such character, or null if none.
mstring_t strpbrk(mstring_t s, string_t accept) {
  int len = int_strleno(s,0,"String::strpbrk");
  char c = '\000';

  for (; len>0 && (c=*s)!=0; len--,s++) {
    for (int j=0; j<accept.size; j++)
      if (c == accept[j])
	return s;
  }
  return null;
}

// Return a pointer to the first occurrence of c in s, 
// or null if none.
string_t strchr(string_t s, char c) {
  int len = int_strleno(s,0,"String::strchr");
  char c2 = '\000';

  for (; len>0 && (c2=*s)!=0; len--,s++) {
    if (c2 == c)
      return s;
  }
  return null;
}

// Return a pointer to the last occurrence of c in s,
// or null if none.
mstring_t strrchr(mstring_t s, char c) {
  int len = int_strleno(s,0,"String::strrchr");
  int i = len - 1;
  s += i;

  for (; i>=0; i--, s--) {
    if (*s == c)
      return s;
  }
  return null;
}

// Search s for an occurrence of a character not in accept.
// Return the offset to the first such character, or the length
// of s if none.
size_t strspn(string_t s, string_t accept) {
  size_t len = int_strleno(s,0,"String::strspn");

  for (size_t i=0; i<len; i++) {
    int j;
    for (j=0; j<accept.size; j++)
      if (s[i] == accept[j])
	break; /* inner loop */
    if (j == accept.size) /* didn't find it */
      return i;
  }
      
  return len;
}

////////////////////////// CONVERSIONS
list_t<int> explode(string_t s) {
  list_t<int> result = null;
  for (int i = strlen(s) - 1; i >= 0; i--)
    result = new List((int)s[i],result);
  return result;
}

mstring_t implode(glist_t<int,`r> chars) {
  mstring_t s = new_string(List::length(chars));
  size_t i = 0;
  while (chars != null) {
    s[i++] = (char)chars->hd;
    chars = chars->tl;
  }
  return(s);
}


// Fix:  should check for overflow
int to_int(string_t s, int *`r offset) {
  int ans = 0;
  int sn = 1;
  bool digit_seen = false;
  int i = (offset == null) ? 0 : *offset;

  // skip any white space
  while (i < s.size && Ctype::isspace(s[i])) i++;
  // check for a sign
  if (i < s.size && s[i] == '-') {
    i++;
    sn = -1;
  }
  // skip any white space
  while (i < s.size && Ctype::isspace(s[i])) i++;
  // parse digits
  while (i < s.size && Ctype::isdigit(s[i])) {
    digit_seen = true;
    ans = (ans * 10) + (int)(s[i] - '0');
    i++;
  }
  ans = ans*sn;
  if (!digit_seen) throw new InvalidArg("String::to_int");
  if (offset != null) *offset = i;
  return ans;
}

// FIX:  this probably does NOT preserve precision appropriately
// FIX:  this does not deal with overflow properly
// FIX:  would use the built in version of strtod but it appears to be
// broken...
double to_double(string_t s, int *`r offset) {
  double ans = 0.0;
  int sn = 1;
  bool digit_seen = false;
  int i = (offset == null) ? 0 : *offset;
  
  // skip any white space
  while (i < s.size && Ctype::isspace(s[i])) i++;
  // check for a sign
  if (i < s.size && s[i] == '-') {
    i++;
    sn = -1;
  }
  // get mantissa
  while (i < s.size && Ctype::isdigit(s[i])) {
    digit_seen = true;
    ans = (ans * 10.0) + (double)(s[i] - '0');
    i++;
  }
  // look for period -- not locale like, but oh well.
  if (i < s.size && s[i] == '.') {
    i++;
    // get fractional part
    double divisor = 0.1;
    while (i < s.size && Ctype::isdigit(s[i])) {
      digit_seen = true;
      ans = ans + (((double)(s[i] - '0')) * divisor);
      divisor = divisor / 10.0;
      i++;
    }
  }
  if (!digit_seen) throw new InvalidArg("String::to_double");
  // look for exponent
  if (i < s.size && (s[i] == 'e' || s[i] == 'E')) {
    i++;
    int exponent = 0;
    int exp_sign = 1;
    digit_seen = false;
    // look for sign for the exponent
    if (i < s.size && s[i] == '-') {
      i++;
      exp_sign = -1;
    } else if (i < s.size && s[i] == '+') i++;
    // get exponent
    while (i < s.size && Ctype::isdigit(s[i])) {
      digit_seen = true;
      exponent = exponent * 10 + ((int)(s[i] - '0'));
      i++;
    }
    if (!digit_seen) throw new InvalidArg("String::to_double");
    ans = ans * Math::pow(10.0, (double)(exponent*exp_sign));
  }
  if (offset != null) *offset = i;
  return ans*sn;
}
