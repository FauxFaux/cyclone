/* This file is part of the Cyclone Library.
   Copyright (C) 2001 Mike Hicks, AT&T

   This library is free software; you can redistribute it and/or it
   under the terms of the GNU Lesser General Public License as
   published by the Free Software Foundation; either version 2.1 of
   the License, or (at your option) any later version.

   This library is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with this library; see the file COPYING.LIB.  If not,
   write to the Free Software Foundation, Inc., 59 Temple Place, Suite
   330, Boston, MA 02111-1307 USA. */

// String library, base on code from Mike Hicks, modified by T. Jim

#include <core.h>
#include <list.h>
#include <ctype.h>
#include <string.h>
#include <strings.h>
#include <stdio.h> // for size_t
#include <math.h> //  for pow

namespace String {
using Core;
using List;
using Stdio; // for size_t

///////////////////////// WRAPPERS
namespace C_string {
  extern "C" {
    Cstring strerror(int errnum);
  }
}
string_t strerror(int errnum) {
  return Cstring_to_string(C_string::strerror(errnum));
}

///////////////////////// LENGTH
size_t strlen(const char ? s) {
  size_t i;
  for (i = 0; i<s.size; i++) {
    if (s[i] == '\000')
      return i;
  }
  return i;
}

// Internal length after offset function, parameterized by what
// to throw if the offset is out of range.
static size_t int_strleno(const char ? s, int ofs, string_t<`H> error) {
  if (ofs > s.size || ofs < 0) throw new InvalidArg(error);
  int i;
  for (i = ofs; i<s.size; i++) {
    if (s[i] == '\000')
      break;
  }
  return (size_t)(i-ofs);
}

///////////////////////// COMPARISONS
static int case_cmp(char c1, char c2) {
  return (c1-c2);
}

static int cmp(const char ?`r1 s1, int ofs1, size_t len1,
               const char ?`r2 s2, int ofs2, size_t len2,
               int f(char, char))
{
  size_t min_length = (len1 < len2) ? len1 : len2;
  int i = -1;
  while (++i < min_length) {
    int diff = f(s1[i+ofs1],s2[i+ofs2]);
    if (diff != 0)
      return diff;
  }
  return ((int)len1)-((int)len2);
}

// Compare two strings lexicographically.
// Return <0, 0, or >0 depending on whether s1<s2, s1==s2, or s1>s2.
int strcmp(const char ?`r1 s1, const char ?`r2 s2) {
  if (s1 == s2)
    return 0;
  size_t len1 = int_strleno(s1,0,"String::strcmp");
  size_t len2 = int_strleno(s2,0,"String::strcmp");
  return cmp(s1,0,len1,s2,0,len2,case_cmp);
}

int strptrcmp(const char ?@ s1, const char ?@ s2) {
  return strcmp(*s1, *s2);
}

static int ncmp(const char ? s1, int ofs1, size_t len1,
                const char ? s2, int ofs2, size_t len2,
                size_t n, int f(char, char))
{
  if (n <= 0) return 0;

  size_t min_len = (len1 > len2) ? len2 : len1;
  size_t bound = (min_len > n) ? n : min_len;

  for (int i=0; i < bound; i++) {
    int retc;
    if ((retc = f(s1[i+ofs1],s2[i+ofs2])) != 0)
      return retc;
  }
  return(0);
}

// Like strcmp but compare no more than n characters.
// If n<0 return 0 (equal).
int strncmp(const char ? s1, const char? s2, size_t n) {
  size_t len1 = int_strleno(s1,0,"String::strncmp");
  size_t len2 = int_strleno(s2,0,"String::strncmp");
  return ncmp(s1,0,len1,s2,0,len2,n,case_cmp);
}

// Like strcmp but don't consider zeros (null characters) as marking
// the end of strings.
int zstrcmp(const char ? a, const char ? b) {
  if(a == b)
    return 0;
  size_t as = a.size;
  size_t bs = b.size;
  size_t min_length = (as < bs) ? as : bs;
  int i  = -1;
  while (++i < min_length) {
    int diff = (int)(a[i]) - (int)(b[i]);
    if (diff != 0)
      return diff;
  }
  return ((int)as)-((int)bs);
}
// Like zstrcmp but consider at most n characters
int zstrncmp(const char ? s1,const char ? s2,size_t n) {
  if (n <= 0) return 0;

  size_t s1size = s1.size;
  size_t s2size = s2.size;
  size_t min_size = (s1size > s2size) ? s2size : s1size;
  size_t bound = (min_size > n) ? n : min_size;

  for (int i=0; i < bound; i++) {
    if (s1[i] < s2[i])
      return(-1);
    else if (s2[i] < s1[i])
      return(1);
  }
  if (min_size <= bound)
    return(0);
  if (s1size < s2size)
    return(-1);
  else 
    return(1);
}
// like zstrcmp but operates on pointers -- useful for hashtables
int zstrptrcmp(const char ?@ a, const char ?@ b) {
  return(zstrcmp(*a,*b));
}


///////////////////////// CONCATENATION

// Internal string concatenation function, parametized by what
// to throw on bounds error
static char ?`r int_strcato(char ?`r dest,const char ? src,int srcOfs,string_t<`H> error) {
  int i;
  size_t dsize, slen, dlen;

  dsize = dest.size;
  dlen = strlen(dest);
  slen = int_strleno(src,srcOfs,error);
  
  if ((slen + dlen) <= dsize) {
    for (i = 0; i<slen; i++) {
      dest[i+dlen] = src[i+srcOfs];
    }
    if (i != dsize)
      dest[i+dlen] = '\000';
  }
  else
    throw new InvalidArg(error);
  return dest;
}

// Destructive concatenation: the first argument is modified,
// and returned
char ?`r strcat(char ?`r dest,const char ? src) {
  return int_strcato(dest,src,0,"String::strcat");
}

// Allocate a new string and fill it with the concatenation of a and b
char ?`r rstrconcat(region_t<`r> r, const char ? a, const char ? b) {
  let alen = strlen(a);
  let blen = strlen(b);
  char ?`r ans = rnew_string(r,alen+blen+1);
  int i, j;
  for (i=0; i < alen; ++i) ans[i]   = a[i];
  for (j=0; j < blen; ++j) ans[i+j] = b[j];
  return ans;
}

mstring_t strconcat(const char ? a, const char ? b) {
  return rstrconcat(heap_region, a, b);
}

// Allocate a new string and fill it with the concatenation of strs
char ?`r rstrconcat_l(region_t<`r> r,list_t<const char ?@>strs)
{
  size_t len;                           // temp
  size_t total_len  = 0;                // sum of lengths of the strings
  char ?`r ans;
  region temp {
    list_t<size_t,`temp> lens = 
      rnew(temp) List((size_t)0,        // save length of each string
                      null);            // (with junk 0 on front)
    list_t<size_t,`temp> end = lens;   // last cons cell in 'lens'
    for(_ p = strs; p!=null; p = p->tl) {
      len = strlen(*(p->hd));
      total_len += len;
      end->tl = rnew(temp) List(len,null);
      end = end->tl;
    } 
    lens = lens->tl;                      // remove junk/temporary 0
    ans = rnew_string(r,total_len+1);
    size_t i = 0;
    while (strs != null) {
      let next    = *(strs->hd);
      len            = lens->hd;
      strncpy(ans+i,next,len);
      i += len;
      strs = strs->tl;
      lens = lens->tl;
    }
  }
  return ans;
}

mstring_t strconcat_l(list_t<const char ?@> strs)
{
  return rstrconcat_l(heap_region,strs);
}

// Allocate a new string and fill it with the concatenation of strs,
// using separator between each element
char ?`r rstr_sepstr(region_t<`r> r,list_t<const char ?@> strs, const char ? separator) {
  if (strs == null)    return rnew_string(r,0);
  if (strs->tl == null) return rstrdup(r,*(strs->hd));
  let p = strs;
  region temp {
    list_t lens = rnew(temp) List((size_t)0,null);// see comments in strconcat_l
    list_t end = lens;
    size_t len        = 0;   // initialized to avoid warning
    size_t total_len  = 0;
    size_t list_len   = 0;
    for(;p!=null;p=p->tl) {
      len = strlen(*(p->hd));
      total_len += len;
      end->tl = rnew(temp) List(len,null);
      end = end->tl;
      ++list_len;
    }
    lens = lens->tl;
    size_t seplen = strlen(separator);
    total_len += (list_len - 1)*seplen;
    char ? ans = rnew_string(r,total_len);
    size_t i = 0;
    while (strs->tl != null) {
      let next    = *(strs->hd);
      len            = lens->hd;
      strncpy(ans+i,next,len);
      i += len;
      strncpy(ans+i,separator,seplen);
      i += seplen;
      strs = strs->tl;
      lens = lens->tl;
    }
    strncpy(ans+i,*(strs->hd),lens->hd);
    return ans;
  }
}

mstring_t str_sepstr(list_t<const char ?@> strs, const char ? separator) {
  return rstr_sepstr(heap_region,strs,separator);
}
///////////////////////// COPYING
// Destructively copy at most n characters from src into dest, starting
// at the given offsets
// (C version does not take offsets)
char ?`r strncpy(char ?`r dest, const char ? src, size_t n) {
  // Range checking
  let destSz = dest.size;
  let srcSz = src.size;
  if (n <= 0) return dest;
  if (n > destSz || n > srcSz)
    throw new InvalidArg("String::strncpy");
  int i;
  for (i=0; i<n; i++) {
    let srcChar = src[i];
    if (srcChar == '\000') break;
    dest[i] = srcChar;
  }
  for (; i<n; i++)
    dest[i] = '\000';

  return dest;

  // FIX: This isn't right.  src->contents and dest->contents
  // might be the same (e.g., from casting) !!
  // We don't currently have a way to detect this at the Cyclone level,
  // so we take C's approach and leave behavior ambiguous in this case.
//   if (src != dest
//      || destOfs + n < srcOfs 
//      || srcOfs  + n < destOfs)
//     for (int i=0; i<n; i++)
//       dest[destOfs+i] = src[srcOfs+i];
//   else {
//     // we could do better, but this is correct
//     mstring_t buffer = new_string(n);
//     for (int i=0; i<n; i++)
//       buffer[i] = src[srcOfs+i];
//     for (int i=0; i<n; i++)
//       dest[destOfs+i] = buffer[i];
//   }
}

// Strncpy that does not pay attention to zero chars
char ?`r zstrncpy(char ?`r dest, const char ? src, size_t n) {
  // Range checking
  let destSz = dest.size;
  let srcSz  = src.size;
  if (n <= 0) return dest;
  if (n > destSz || n > srcSz)
    throw new InvalidArg("String::zstrncpy");
  int i;
  for (i=0; i<n; i++) 
    dest[i] = src[i];
  return dest;
}
// Non-allocating string copy: first arg is returned
char ?`r strcpy(char ?`r dest, const char ? src) {
  size_t len = strlen(src);
  strncpy(dest,src,len);
  if (len != dest.size)
    dest[len] = '\000';
  return dest;
}

// Allocating functions

// Not an ISO function, but available in gcc
char ?`r rstrdup(region_t<`r> r, const char ? src) {
  size_t len;
  char ?`r temp;

  len = strlen(src);
  temp = rnew_string(r,len+1);
  strncpy(temp,src,len);
  return temp;
}

mstring_t strdup(const char ? src) {
  return rstrdup(heap_region, src);
}

char ?`r rexpand(region_t<`r> r,const char ? s, size_t sz) {
  char ? temp;
  size_t slen;

  slen = strlen(s);
  sz = (sz>slen)?sz:slen;
  temp = rnew_string(r,sz);

  strncpy(temp,s,slen);

  if (slen != s.size)
    temp[slen] = '\000';

  return temp;
}

mstring_t expand(const char ? s, size_t sz) {
  return rexpand(heap_region,s,sz);
}

char ?`r rrealloc_str(region_t<`r> r, char ?`r str, size_t sz)
{
  size_t maxsizeP = str.size;

  if (maxsizeP == 0) {
    maxsizeP = (30>sz)?30:sz;	/* arbitrary */
    str = rnew_string(r,maxsizeP);
    str[0] = '\000';
  }
  else if (sz > maxsizeP) {
    maxsizeP = (maxsizeP * 2 > sz * 5 / 4)?(maxsizeP * 2):(sz * 5 / 4);
    str = rexpand(r, str, maxsizeP);
  }

  return str;
}

mstring_t realloc_str(mstring_t<`H> str, size_t sz) {
  return rrealloc_str(heap_region,str,sz);
}


///////////////////////// TRANSFORMATIONS
// Return a substring of a string, by allocation.
// FIX: This adds an extra null character at the end of the string.
// I'd like to remove it but it causes a bug in the lexer on bootstrapping.
char ?`r rsubstring(region_t<`r> r,const char ? s, 
                     int start, size_t amt) {
  if (start < 0 || amt < 0 || start + ((int)amt) - 1 > (int)(s.size))
    throw new InvalidArg("String::substring");
  char ? ans = rnew_string(r,amt+1);
  for(size_t i=0; i<amt; ++i)
    ans[i] = s[start+i];
  ans[amt] = '\000';
  return ans;
}

mstring_t substring(const char ?`r1 s, int start, size_t amt) {
  return rsubstring(heap_region,s,start,amt);
}

// replace last with second at end of first
// raise InvalidArg if second is not end of first.
char ?`r rreplace_suffix (region_t<`r> r,const char ? src, const char ? curr_suffix, const char ? new_suffix) {
  size_t m = src.size;
  size_t n = curr_suffix.size;
  string_t err = "String::replace_suffix";
  if (m < n) 
    throw new InvalidArg(err);
  for (size_t i = 1; i <= n; ++i)
    if (src[m-i] != curr_suffix[n-i])
      throw new InvalidArg(err);
  char ? ans = rnew_string(r,m-n+new_suffix.size);
  strncpy(ans,src,m-n);
  strncpy(ans+m-n,new_suffix,new_suffix.size);
  return ans;
}

mstring_t replace_suffix (const char ? src, const char ? curr_suffix, const char ? new_suffix) {
  return rreplace_suffix(heap_region,src,curr_suffix,new_suffix);
}
////////////////////////// SEARCHING

// Search for any character of accept in s.
// Return a ? pointer to the first such character, or null if none.
char ?`r strpbrk(char ?`r s, const char ? accept) {
  int len = int_strleno(s,0,"String::strpbrk");
  char c = '\000';

  for (; len>0 && (c=*s)!=0; len--,s++) {
    for (int j=0; j<accept.size; j++)
      if (c == accept[j])
	return s;
  }
  return null;
}

// Return a pointer to the first occurrence of c in s, 
// or null if none.
const char ?`r1 strchr(const char ?`r1 s, char c) {
  int len = int_strleno(s,0,"String::strchr");
  char c2 = '\000';

  for (; len>0 && (c2=*s)!=0; len--,s++) {
    if (c2 == c)
      return s;
  }
  return null;
}

// Return a pointer to the last occurrence of c in s,
// or null if none.
char ?`r1 strrchr(char ?`r1 s, char c) {
  int len = int_strleno(s,0,"String::strrchr");
  int i = len - 1;
  s += i;

  for (; i>=0; i--, s--) {
    if (*s == c)
      return s;
  }
  return null;
}

// Search s for an occurrence of a character not in accept.
// Return the offset to the first such character, or the length
// of s if none.
size_t strspn(const char ?`r1 s, const char ? accept) {
  size_t len = int_strleno(s,0,"String::strspn");

  for (size_t i=0; i<len; i++) {
    int j;
    for (j=0; j<accept.size; j++)
      if (s[i] == accept[j])
	break; /* inner loop */
    if (j == accept.size) /* didn't find it */
      return i;
  }
      
  return len;
}

////////////////////////// CONVERSIONS
list_t<int,`r> rexplode(region_t<`r> r,const char ? s) {
  list_t result = null;
  for (int i = strlen(s) - 1; i >= 0; i--)
    result = rnew(r) List((int)s[i],result);
  return result;
}

list_t<int> explode(const char ? s) {
  return rexplode(heap_region, s);
}

mstring_t implode(list_t<int> chars) {
  mstring_t s = new_string(List::length(chars));
  size_t i = 0;
  while (chars != null) {
    s[i++] = (char)chars->hd;
    chars = chars->tl;
  }
  return(s);
}


// Fix:  should check for overflow
int to_int(const char ? s, int * offset) {
  int ans = 0;
  int sn = 1;
  bool digit_seen = false;
  int i = (offset == null) ? 0 : *offset;

  // skip any white space
  while (i < s.size && Ctype::isspace(s[i])) i++;
  // check for a sign
  if (i < s.size && s[i] == '-') {
    i++;
    sn = -1;
  }
  // skip any white space
  while (i < s.size && Ctype::isspace(s[i])) i++;
  // parse digits
  while (i < s.size && Ctype::isdigit(s[i])) {
    digit_seen = true;
    ans = (ans * 10) + (int)(s[i] - '0');
    i++;
  }
  ans = ans*sn;
  if (!digit_seen) throw new InvalidArg("String::to_int");
  if (offset != null) *offset = i;
  return ans;
}

// FIX:  this probably does NOT preserve precision appropriately
// FIX:  this does not deal with overflow properly
// FIX:  would use the built in version of strtod but it appears to be
// broken...
double to_double(const char ? s, int * offset) {
  double ans = 0.0;
  int sn = 1;
  bool digit_seen = false;
  int i = (offset == null) ? 0 : *offset;
  
  // skip any white space
  while (i < s.size && Ctype::isspace(s[i])) i++;
  // check for a sign
  if (i < s.size && s[i] == '-') {
    i++;
    sn = -1;
  }
  // get mantissa
  while (i < s.size && Ctype::isdigit(s[i])) {
    digit_seen = true;
    ans = (ans * 10.0) + (double)(s[i] - '0');
    i++;
  }
  // look for period -- not locale like, but oh well.
  if (i < s.size && s[i] == '.') {
    i++;
    // get fractional part
    double divisor = 0.1;
    while (i < s.size && Ctype::isdigit(s[i])) {
      digit_seen = true;
      ans = ans + (((double)(s[i] - '0')) * divisor);
      divisor = divisor / 10.0;
      i++;
    }
  }
  if (!digit_seen) throw new InvalidArg("String::to_double");
  // look for exponent
  if (i < s.size && (s[i] == 'e' || s[i] == 'E')) {
    i++;
    int exponent = 0;
    int exp_sign = 1;
    digit_seen = false;
    // look for sign for the exponent
    if (i < s.size && s[i] == '-') {
      i++;
      exp_sign = -1;
    } else if (i < s.size && s[i] == '+') i++;
    // get exponent
    while (i < s.size && Ctype::isdigit(s[i])) {
      digit_seen = true;
      exponent = exponent * 10 + ((int)(s[i] - '0'));
      i++;
    }
    if (!digit_seen) throw new InvalidArg("String::to_double");
    ans = ans * Math::pow(10.0, (double)(exponent*exp_sign));
  }
  if (offset != null) *offset = i;
  return ans*sn;
}

}

/* Perhaps the remainder should be broken out into a separate file */
namespace Strings {

// Like strcmp, but case insensitive.
int strcasecmp(const char ?`r1 s1, const char ?`r2 s2) {
  if (s1 == s2)
    return 0;
  size_t len1 = String::int_strleno(s1,0,"Strings::strcasecmp");
  size_t len2 = String::int_strleno(s2,0,"Strings::strcasecmp");
  return String::cmp(s1,0,len1,s2,0,len2,String::case_cmp);
}

static int nocase_cmp(char c1, char c2) {
  return String::case_cmp((char)Ctype::toupper(c1),(char)Ctype::toupper(c2));
}

// Like strncmp, but case insensitive.
int strncasecmp(const char ?`r1 s1, const char ?`r2 s2, size_t n) {
  size_t len1 = String::int_strleno(s1,0,"Strings::strncasecmp");
  size_t len2 = String::int_strleno(s2,0,"Strings::strncasecmp");
  return String::ncmp(s1,0,len1,s2,0,len2,n,nocase_cmp);
}

}
