/* This file is part of the Cyclone Library.
   Copyright (C) 2001 Greg Morrisett, AT&T

   This library is free software; you can redistribute it and/or it
   under the terms of the GNU Lesser General Public License as
   published by the Free Software Foundation; either version 2.1 of
   the License, or (at your option) any later version.

   This library is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with this library; see the file COPYING.LIB.  If not,
   write to the Free Software Foundation, Inc., 59 Temple Place, Suite
   330, Boston, MA 02111-1307 USA. */

/* This file defines the low-level representation of Cyclone data
   for implementing generic marshallers. */

#include <set.h>
#include <typerep.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <marshal.h>

using Typerep;
using Marshal;


extern "C" `b unsafe_cast<`b,`a>(`a x);

namespace Marshal;



/*-------------------------------------------------------------------------*/
/* Invariant: val points to a value of the type that rep represents      
 * env contains all addresses of tunion or pointer types
 * (these are the only possible sources of sharing/cycles)
 * before we follow a dereference through a pointer or tunion, 
 * we look it up to make sure that it's not a repeat
 */
addr_set_t
print_type_base(typestruct_t rep, addr_set_t env, `a @ val) 
{
  switch (rep) {
  case &Int(sz):
    switch (sz) {
    case 8:
      char @x = unsafe_cast(val);
      if(isprint(*x)) printf("'%c'",*x);
      else printf("'\\%d'",*x);
      break;
    case 16:
      short @x = unsafe_cast(val);
      printf("%d",*x);
      break;
    case 32:
      int @x = unsafe_cast(val);
      printf("%d",*x);
      break;
    default:
      fprintf(stderr,"print_type_base: illegal int size %d bits\n", sz);
      exit(1);
    }
    break;
  
  case Float:
    float @x = unsafe_cast(val);
    printf ("%f",*x);
    break;
  
  case Double:
    double @x = unsafe_cast(val);
    printf ("%f",*x);
    break;

  case &ThinPtr(sz,typ):
    // val is a pointer to a pointer to whatever typ represents
    int *x = unsafe_cast(val); 
    int y = *x;
    let &$(mem,env2) = member_insert(env,y);
    env = env2;
    if(!mem) {
      printf("{(@%x) ",y);
      if (y != 0) {
	int typ_szb = size_type(typ);
	for (int i = 0; i<sz; i++) {
	  env = print_type_base(typ,env, (`a@)unsafe_cast(y));
	  if (i != (sz-1))
	    printf(", ");
	  y += typ_szb;
	}
      }
      else printf ("NULL");
      printf(" }");
    }
    else {
      printf("(#%x)",y);
    }
    break;

  case &FatPtr(typ): 
    $(unsigned int, unsigned int, unsigned int) @`H x = unsafe_cast(val);
    unsigned int typ_szb = size_type(typ);
    unsigned int base = (*x)[0], curr = (*x)[1], last_plus_one = (*x)[2];
    let &$(mem,env2) = member_insert(env,base);
    env = env2;
    if(!mem) {
      printf("[(@%x) ",base);
      for (unsigned int i = base; i<last_plus_one; i += typ_szb) {
	env = print_type_base(typ, env, (`a@)unsafe_cast(i));
	if ((i+typ_szb) < last_plus_one)
	  printf(", ");
      }
      printf(" ]");
    }
    else {
      printf("(#%x)",base);
    }
    break;

  case &Tuple(_,l):
    printf("$( ");
    int x = unsafe_cast(val); 
    for (int i = 0; i < l.size; i++) {
      let $(ofs,typ) = *(l[i]);
      int x_ofs = x + ofs;
      env = print_type_base(typ, env, (`a@)unsafe_cast(x_ofs));
      if (i != (l.size-1))
	printf(", ");
    }
    printf(" )");
    break;

  case &TUnion(l):
    printf("&[( ");
    /* get the tag */
    unsigned int@ tagp = unsafe_cast(val);
    if (*tagp < 1024) {
      printf("%d",*tagp);
    }
    else {
      let &$(mem,env2) = member_insert(env,*tagp);
      env = env2;
      if(!mem) {
	printf("(@%x)",*tagp);
	unsigned int @x = unsafe_cast(*tagp);
	unsigned int tag = *x;
	/* figure out which variant it is */
	typestruct_t typ = get_unionbranch(tag,l);
	env = print_type_base(typ, env, x);
      }
      else {
	printf("(#%x)",*tagp);
      }
    }
    printf(" )]");
    break;

  case &XTUnion(l):
    // val is a pointer to a xtunion, hich is a pointer to a struct consisting of a char* tag that points to "\0\0\0\0Name", followed by any arguments
    unsigned int@ xtunionp = unsafe_cast(val);
    let &$(mem,env2) = member_insert(env,*xtunionp);
    env = env2;
    if(!mem) {
      printf("(@%x)",*xtunionp);
      // get the pointer to the name string "\0\0\0\0Name"
      unsigned int* xtstructp = unsafe_cast(*xtunionp);
      if(*xtstructp != 0) {
	Cstring<`H> xtnamec = unsafe_cast(*xtstructp+4);
	/* XXX do we really want to copy this, or just mess
	   with the underlying string? */
	string_t<`H> xtname = Core::Cstring_to_string(xtnamec);
	printf("&%s[( ",xtname);
	/* figure out which variant it is */
	typestruct_t typ = get_xtunionbranch(xtname,l);
	env = print_type_base(typ, env, (_@)xtstructp);
      }
      else {
	Cstring<`H> xtnamec = unsafe_cast(*xtunionp+4);
	/* XXX do we really want to copy this, or just mess
	   with the underlying string? */
	string_t<`H> xtname = Core::Cstring_to_string(xtnamec);
	printf("&%s[( ",xtname);
      }
    }
    else {
      printf("(#%x)",*xtunionp);
    }
    printf(" )]");
    break;

  case &Union(l):
    printf("[[");
    // Print out each case; safe because no pointers
    for(int i = 0; i < l.size; i++) {
      print_type_base(*l[i],env,val);
      if(i < l.size-1) printf(" | ");
    }
    printf("]]");
    break;
    

  default: throw new Core::Failure("Unhandled case in print_type_base");
  }
  return env;
}

void print_type(typestruct_t ts, `a@ val) {
  try{
  print_type_base(ts,empty_addr_set(),val);
  } catch {
  case &Core::Failure(s):
    fprintf(stderr,"Core::Failure(%s)\n",s);
    throw new Core::Failure(s);
  }
}

#if 0
void
xmlize_ptr_type(typestruct_t typ,
	       unsigned int val)
{
  switch (typ) {
  /* All FLAT types go through unchanged */
  case &Int(_):
  case Float:
  case Double:
  case &FatPtr(_):
  case &Tuple(_,_):
    int @ptr = unsafe_cast(val);
//      printf("FLAT type ->%x ",val);
//      print_typestruct(typ);
    xmlize_type(typ, ptr); 
    return;
  
  /* All POINTER types need an additional dereference */
  case &ThinPtr(_,_):
  case &TUnion(_):
    int @@ptr = unsafe_cast(val);
//      printf("PTR type ->%x ",val);
//      print_typestruct(typ);
    xmlize_type(typ, *ptr);
    
    return;
  case &Union(_):
    throw new Core::Failure("Cannot xmlize Unions");
  default: throw new Core::Failure("Unhandled case in xmlize_ptr_type");

  }
}

// Emits an XML form of a value with given typerep'd type



void 
xmlize_type(typestruct_t rep, `a @ val) 
{

  switch (rep) {

  /* FLAT type; assume we have a pointer to it */
  case &Int(sz):
    switch (sz) {
    case 8:
      char @x = unsafe_cast(val);
      printf("<int size=\"8\">%c</int>",*x);
      break;
    case 16:
      short @x = unsafe_cast(val);
      printf("<int size=\"16\">%d</int>",*x);
      break;
    case 32:
      int @x = unsafe_cast(val);
      printf("<int size=\"32\">%d</int>",*x);
      break;
    default:
      fprintf(stderr,"xmlize_type: illegal int size %d bits\n", sz);
      exit(1);
    }
    break;

  /* FLAT type; assume we have a pointer to it */
  case Float:
    float @x = unsafe_cast(val);
    printf ("<float>%f</float>",*x);
    break;

  /* FLAT type; assume we have a pointer to it */
  case Double:
    double @x = unsafe_cast(val);
    printf ("<double>%f</double>",*x);
    break;

  /* POINTER type */
  case &ThinPtr(sz,typ):
    printf("<thinptr sz=\"%d\">",sz);
    int x = unsafe_cast(val); /* x is a pointer to the buffer */
    if (x != 0) {
      int typ_szb = size_type(typ);
      for (int i = 0; i<sz; i++) {
	xmlize_ptr_type(typ,x);
	x += typ_szb;
      }
    }
    else printf("<null/>");
    printf("</thinptr>");
    break;

  /* FLAT type; assume we have a pointer to it */
  case &FatPtr(typ): 
    /* x is a pointer to the three-tuple for the array */
    $(unsigned int, unsigned int, unsigned int) @`H x = unsafe_cast(val);
    unsigned int typ_szb = size_type(typ);
    unsigned int base = (*x)[0], curr = (*x)[1], last_plus_one = (*x)[2];
    unsigned int sz = (last_plus_one - base) / typ_szb;
    unsigned int index = (curr - base) / typ_szb;
    printf("<fatptr index=\"%d\" sz=\"%d\">",index,sz); 
    for (unsigned int i = base; i<last_plus_one; i += typ_szb) {
      xmlize_ptr_type(typ, i);

    }
    printf("</fatptr>");
    break;

  /* FLAT type; assume we have a pointer to it */
  case &Tuple(_,l):
    printf("<tuple>");
    int x = unsafe_cast(val); /* x is a pointer to the buffer */
//      printf("%x -> Tuple\n",x);
    for (int i = 0; i < l.size; i++) {
      let $(ofs,typ) = *(l[i]);
      int x_ofs = x + ofs;
//        printf ("ofs = %d, x_ofs = %x, typ =",ofs,x_ofs);
//        print_typestruct(typ);
//        printf("\n");
      xmlize_ptr_type(typ, /* env, */ x_ofs);
    }
    printf("</tuple>");
    break;

  /* POINTER type */
  case &TUnion(l):
    /* get the tag */
    unsigned int tag = unsafe_cast(val);
    if (tag < 1024) {
      printf("<tunion tag=\"%d\"/>",tag);
    }
    else {
      unsigned int @x = unsafe_cast(val);
      tag = *x;
      /* figure out which variant it is */
      typestruct_t typ = get_unionbranch(tag,l);
      printf("<tunion tag=\"%d\">", 1024+tag); // better idea?  
      xmlize_type(typ, /* env, */ val);
      printf("</tunion>");

    }
    break;
  case &Union(_):
    throw new Core::Failure("Cannot xmlize Unions");
  default: throw new Core::Failure("Unhandled case in xmlize_type");
  }
  
}
 
#endif
