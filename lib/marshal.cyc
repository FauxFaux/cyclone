/* This file is part of the Cyclone Library.
   Copyright (C) 2001 Greg Morrisett, AT&T

   This library is free software; you can redistribute it and/or it
   under the terms of the GNU Lesser General Public License as
   published by the Free Software Foundation; either version 2.1 of
   the License, or (at your option) any later version.

   This library is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with this library; see the file COPYING.LIB.  If not,
   write to the Free Software Foundation, Inc., 59 Temple Place, Suite
   330, Boston, MA 02111-1307 USA. */

/* This file defines the low-level representation of Cyclone data
   for implementing generic marshallers. */

#include <set.h>
#include <typerep.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <marshal.h>
#include <set.h>
#include <dict.h>

using Typerep;
using Marshal;


extern "C" `b unsafe_cast<`a,`b>(`a x);

namespace Marshal;

//  typedef unsigned int addr_t;

//  // utilities for addressing
//  typedef Set::set_t<addr_t> addr_set_t;

//  // NULL always maps to 0
//  typedef $(Dict::dict_t<addr_t,int>,int) addr_index_t;
//  // 0 always maps to NULL
//  typedef $(addr_t?, int) addr_table_t;

static int uint_cmp(addr_t a, addr_t b) {
  if(a == b) return 0;
  else if (a < b) return 1;
  else return -1;
}

static addr_set_t empty_addr_set () {
  return Set::insert(Set::empty(uint_cmp),0);
}

// returns whether elt is a member, inserts if it's not
static $(bool, addr_set_t)@ member_insert(addr_set_t set, addr_t val) {
  return new $(Set::member(set,val), Set::insert(set,val));
}

static inline bool index_member(addr_index_t idx, addr_t m) {
  let $(_,n) = idx;
  return (m < n);
}

addr_index_t empty_addr_index() {
  return $(Dict::insert(Dict::empty(uint_cmp),0,0),1);
}




static addr_t index_lookup(addr_index_t index, addr_t val) {
  let $(dict,n) = index;
  let indopt = Dict::lookup_opt(dict,val);
  if(indopt != NULL) {
    return indopt->v;
  }
  else return n;
}

static addr_index_t index_insert(addr_index_t index, addr_t val) {
  let $(dict,n) = index;
  return $(Dict::insert(dict,val,n),n+1);
}

static addr_table_t empty_addr_table() {
  return $(new {for i < 1: 0},1);
}
static inline bool table_member(addr_table_t table, addr_t m) {
  let $(_,n) = table;
  return (m < n);
}

static addr_table_t table_insert(addr_table_t tbl, addr_t i) {
  let $(vec,n) = tbl;
  if(vec.size == n) {
    vec = new {for j < 2*n: (j < n) ? vec[j] : 0};
  }
  vec[n] = i;
  return $(vec,n+1);
}

static addr_t table_lookup(addr_table_t tbl, int i) {
  return tbl[0][i];
}

static void fprint_ref(FILE@ fp,addr_t ref) {
  if(ref==0) fprintf(fp,"NULL");
  else fprintf(fp,"(#%x)",ref);
}
/*-------------------------------------------------------------------------*/
/* Invariant: val points to a value of the type that rep represents      
 * env contains all addresses of tunion or pointer types
 * (these are the only possible sources of sharing/cycles)
 * before we follow a dereference through a pointer or tunion, 
 * we look it up to make sure that it's not a repeat
 */
addr_set_t
fprint_type_base(typestruct_t rep, addr_set_t env, FILE@ fp,`a::A @ val) 
{
  switch (rep) {
  case &Int(sn,sz):
    switch (sz) {
    case 8:
      char @x = unsafe_cast(val);
      if(isprint(*x)) fprintf(fp,"'%c'",*x);
      else fprintf(fp,"'\\%d'",*x);
      break;
    case 16:
      short @x = unsafe_cast(val);
      fprintf(fp,sn?"%d":"%u",*x);
      break;
    case 32:
      int @x = unsafe_cast(val);
      fprintf(fp,sn?"%d":"%u",*x);
      break;
    default:
      fprintf(stderr,"fprint_type_base: illegal int size %d bits\n", sz);
      exit(1);
    }
    break;
  
  case Float:
    float @x = unsafe_cast(val);
    fprintf (fp,"%f",*x);
    break;
  
  case Double:
    double @x = unsafe_cast(val);
    fprintf (fp,"%f",*x);
    break;

  case &ThinPtr(sz,typ):
    // val is a pointer to a pointer to whatever typ represents
    int *x = unsafe_cast(val); 
    int y = *x;
    let &$(mem,env2) = member_insert(env,y);
    env = env2;
    if(!mem) {
      fprintf(fp,"{(@%x) ",y);
      if (y != 0) {
	int typ_szb = size_type(typ);
	for (int i = 0; i<sz; i++) {
	  env = fprint_type_base(typ,env, fp,unsafe_cast(y));
	  if (i != (sz-1))
	    fprintf(fp,", ");
	  y += typ_szb;
	}
      }
      else fprintf (fp,"NULL");
      fprintf(fp," }");
    }
    else {
      fprint_ref(fp,y);
    }
    break;

  case &FatPtr(typ): 
    $(addr_t, addr_t, addr_t) @`H x = unsafe_cast(val);
    addr_t typ_szb = size_type(typ);
    addr_t base = (*x)[0], curr = (*x)[1], last_plus_one = (*x)[2];
    let &$(mem,env2) = member_insert(env,base);
    env = env2;
    if(!mem) {
      fprintf(fp,"[(@%x) ",base);
      for (addr_t i = base; i<last_plus_one; i += typ_szb) {
	env = fprint_type_base(typ, env, fp,unsafe_cast(i));
	if ((i+typ_szb) < last_plus_one)
	  fprintf(fp,", ");
      }
      fprintf(fp," ]");
    }
    else {
      fprint_ref(fp,base);
    }
    break;

  case &Struct(name,_,l):
    if(name == NULL) fprintf(fp,"{ ");
    else fprintf(fp,"%s{ ",*name);
    int x = unsafe_cast(val); 
    for (int i = 0; i < l.size; i++) {
      let $(ofs,nm,typ) = *(l[i]);
      fprintf(fp,"%s=",nm);
      int x_ofs = x + ofs;
      env = fprint_type_base(typ, env, fp,unsafe_cast(x_ofs));
      if (i != (l.size-1))
	fprintf(fp,", ");
    }
    fprintf(fp," }");
    break;

  case &Tuple(_,l):
    fprintf(fp,"$( ");
    int x = unsafe_cast(val); 
    for (int i = 0; i < l.size; i++) {
      let $(ofs,typ) = *(l[i]);
      int x_ofs = x + ofs;
      env = fprint_type_base(typ, env, fp,unsafe_cast@<_,`a@>(x_ofs));
      if (i != (l.size-1))
	fprintf(fp,", ");
    }
    fprintf(fp," )");
    break;
  
    
  case &TUnionField(tname,fname,_,l):
    fprintf(fp,"%s.%s(",tname,fname);
    int x = unsafe_cast(val); 
    // skip tag value by starting at 1:
    for (int i = 1; i < l.size; i++) {
      let $(ofs,typ) = *(l[i]);
      int x_ofs = x + ofs;
      env = fprint_type_base(typ, env, fp,unsafe_cast@<_,`a@>(x_ofs));
      if (i != (l.size-1))
	fprintf(fp,", ");
    }
    fprintf(fp," )");
    break;
  
  case &TUnion(name,t,l):
    /* get the tag */
    addr_t@ tagp = unsafe_cast(val);
    if (*tagp < 1024) {
      fprintf(fp,"%s",get_tagname(*tagp,t));
    }
    else {
      let &$(mem,env2) = member_insert(env,*tagp);
      env = env2;
      if(!mem) {
	fprintf(fp,"(@%x)",*tagp);
	addr_t @x = unsafe_cast(*tagp);
	unsigned int tag = *x;
	/* figure out which variant it is */
	let $(off,typ) = get_unionbranch(tag,l);
	`a@ xoff = unsafe_cast(*tagp+off);
	fprintf(fp,"&%s[",get_tagname2(tag,l));
	env = fprint_type_base(typ, env, fp,xoff);
	fprintf(fp,"]");
      }
      else {
	fprint_ref(fp,*tagp);
      }
    }
    break;

    // Problem: This copies the string instead of using the canonical copy that lives on the receiver's machine... thus, switches on the resulting values will be wrong.  Fix this!
  case &XTUnion(name,l):
    // val is a pointer to a xtunion, hich is a pointer to a struct consisting of a char* tag that points to "\0\0\0\0Name", followed by any arguments
    addr_t@ xtunionp = unsafe_cast(val);
    let &$(mem,env2) = member_insert(env,*xtunionp);
    env = env2;
    if(!mem) {
      fprintf(fp,"(@%x)",*xtunionp);
      // get the pointer to the name string "\0\0\0\0Name"
      addr_t* xtstructp = unsafe_cast(*xtunionp);
      if(*xtstructp != 0) {
	Cstring<`H> xtnamec = unsafe_cast(*xtstructp+4);
	/* XXX do we really want to copy this, or just mess
	   with the underlying string? */
	string_t<`H> xtname = Core::Cstring_to_string(xtnamec);
	fprintf(fp,"&%s[( ",xtname);
	/* figure out which variant it is */
	let $(off,typ) = get_xtunionbranch(xtname,l);
	`a@ xoff = unsafe_cast(*xtunionp+off);
	env = fprint_type_base(typ, env, fp,xoff);
	fprintf(fp," )]");
      }
      else {
	Cstring<`H> xtnamec = unsafe_cast(*xtunionp+4);
	/* XXX do we really want to copy this, or just mess
	   with the underlying string? */
	string_t<`H> xtname = Core::Cstring_to_string(xtnamec);
	fprintf(fp,"%s",xtname);
      }
    }
    else {
      fprint_ref(fp,*xtunionp);
    }
    break;

  case &Union(name,_,l):
    if(name == NULL) fprintf(fp,"{");
    else fprintf(fp,"%s{",*name);
    // Print out each case; safe because no pointers
    for(int i = 0; i < l.size; i++) {
      let $(nm,ts) = *(l[i]);
      fprintf(fp,"%s=",nm);
      fprint_type_base(ts,env,fp,val);
      if(i < l.size-1) fprintf(fp," | ");
    }
    fprintf(fp,"}");
    break;

  case &Enum(_,szb,l): // assume szb=sizeof(int) FIX
    /* get the tag */
    addr_t@ tagp = unsafe_cast(val);
    fprintf(fp,"%s",get_tagname(*tagp,l));
    break;

    //default: throw new Core::Failure("Unhandled case in fprint_type_base");
  }
  return env;
}

#include "errno.h"

void fprint_type(typestruct_t ts, FILE@ fp, `a::A@ val) {
  try{
  fprint_type_base(ts,empty_addr_set(),fp,val);
  } catch {
  case &Core::Failure(s):
    fprintf(stderr,"Core::Failure(%s)\n",s);
    throw new Core::Failure(s);
  }
}

void print_type(typestruct_t ts, `a::A@ val) {
  fprint_type(ts, stdout, val);
}



// FIX: getw returns -1==EOF both when EOF is reached and when the next wird is a -1.  Write put/get{8,16,32} functions using fread, fwrite.  Redo using those.

#define CYCPUT(X) void cycput##X(X x, FILE@ fp) { \
  if(fwrite( (char?)(X?)&x, sizeof(X), 1, fp) < 1) { \
    throw new Core::Failure("Write failure"); \
  } \
} 

CYCPUT(char)
CYCPUT(short)
CYCPUT(int)
CYCPUT(float)
CYCPUT(double)


void cycputvarint(addr_t i, FILE@ fp) {
  int width = 0;
  addr_t mask = 0xffffff00;
  while(mask) {
    if(i & mask) width++;
    mask <<= 8;
  }
  fputc((width << 6) | (i & 0x3f), fp);
  i >>= 6;
  for(int j = 0; j < width; j++) {
    fputc(i & 0xff,fp);
    i >>= 8;
  }
}

#define CYCGET(X) X cycget##X(FILE@ fp) { \
  region r { \
    char? x = rnew(r) {for i < sizeof(X):0}; \
    if(fread(x,sizeof(X),1,fp) < 1) { \
      throw new Core::Failure("Read failure"); \
    } \
    X@ xx = unsafe_cast((_*) x); \
  return *xx; \
  } \
}



CYCGET(char)
CYCGET(short)
CYCGET(int)
CYCGET(float)
CYCGET(double)

addr_t cycgetvarint(FILE@ fp) {
  int i = 0;
  int j = cycgetchar(fp);
  int width = (j & 0xc0) >> 6;
  int pos = 6;
  i += j & 0x3f;
  for(int k = 0; k < width; k++) {
    j = cycgetchar(fp);
    i |= (j << pos);
    pos += 8;
  }
  return i;
}


/* Writes a type out as binary out to a FILE* */
/*-------------------------------------------------------------------------*/
/* Invariant: val points to a value of the type that rep represents      
 * env contains all addresses of tunion or pointer types
 * (these are the only possible sources of sharing/cycles)
 * before we follow a dereference through a pointer or tunion, 
 * we look it up to make sure that it's not a repeat
 */
addr_index_t
write_type_base(typestruct_t rep, addr_index_t env, FILE@ fp, `a::A @ val) 
{
  switch (rep) {
  case &Int(_,sz): // ignore sign
    switch (sz) {
    case 8:
      char @x = unsafe_cast(val);
      //fputc(*x,fp);
      cycputchar(*x,fp);
      break;
    case 16:
      short @x = unsafe_cast(val);
      //putw(*x,fp);
      cycputshort(*x,fp);
      break;
    case 32:
      int @x = unsafe_cast(val);
      //putw(*x,fp);
      cycputint(*x,fp);
      break;
    default:
      fprintf(stderr,"write_type_base: illegal int size %d bits\n", sz);
      exit(1);
    }
    break;
  
  case Float:
    float@ x = unsafe_cast(val);
    //fwrite( (char?)(float?)x, sizeof(float), 1, fp);
    cycputfloat(*x,fp);
    break;
  
  case Double:
    double@ x = unsafe_cast(val);
    cycputdouble(*x,fp);
    //fwrite( (char?)(double?)x, sizeof(double), 1, fp);
    break;

  case &ThinPtr(sz,typ):
    // val is a pointer to a pointer to whatever typ represents
    int *x = unsafe_cast(val); 
    int y = *x;
    let mem = index_lookup(env,y); // null always shared
    cycputvarint(mem,fp);
    if(!index_member(env,mem)) {
      env = index_insert(env,y);
      int typ_szb = size_type(typ);
      for (int i = 0; i<sz; i++) {
	env = write_type_base(typ,env, fp, unsafe_cast@<_,`a@>(y));
	y += typ_szb;
      }
    }
    break;

  case &FatPtr(typ):
    $(addr_t, addr_t, addr_t) @`H x = unsafe_cast(val);
    addr_t typ_szb = size_type(typ);
    addr_t base = (*x)[0], curr = (*x)[1], last_plus_one = (*x)[2];
    addr_t pos = (curr-base)/typ_szb;
    addr_t sz = (last_plus_one - base)/typ_szb;
    let mem = index_lookup(env,base); // null always shared
    cycputvarint(mem,fp);
    cycputvarint(pos,fp);
    cycputvarint(sz,fp);
    if(!index_member(env,mem)) {
      env=index_insert(env,base);
      for (addr_t i = base; i<last_plus_one; i += typ_szb) {
	env = write_type_base(typ, env, fp, unsafe_cast@<_,`a@>(i));
      }
    }
    break;

  case &Struct(_,_,l):  //ignore name
    int x = unsafe_cast(val); 
    for (int i = 0; i < l.size; i++) {
      let $(ofs,_,typ) = *(l[i]);
      int x_ofs = x + ofs;
      env = write_type_base(typ, env, fp, unsafe_cast@<_,`a@>(x_ofs));
    }
    break;

  case &Tuple(_,l):
    int x = unsafe_cast(val); 
    for (int i = 0; i < l.size; i++) {
      let $(ofs,typ) = *(l[i]);
      int x_ofs = x + ofs;
      env = write_type_base(typ, env, fp, unsafe_cast@<_,`a@>(x_ofs));
    }
    break;

  case &TUnionField(_,_,_,l):
    int x = unsafe_cast(val); 
    for (int i = 0; i < l.size; i++) {
      let $(ofs,typ) = *(l[i]);
      int x_ofs = x + ofs;
      env = write_type_base(typ, env, fp, unsafe_cast@<_,`a@>(x_ofs));
    }
    break;

  case &TUnion(_,t,l):
    /* get the tag */
    addr_t@ tagp = unsafe_cast(val);
    if (*tagp < 1024) {
      cycputvarint(*tagp,fp); 
    }
    else {
      let mem = index_lookup(env,*tagp);
      cycputvarint(mem+1024,fp);
      if(!index_member(env,mem)) {
	env = index_insert(env,*tagp);
	addr_t @x = unsafe_cast(*tagp);
	unsigned int tag = *x;
	cycputvarint(tag,fp);
	/* figure out which variant it is */
	let $(off, typ) = get_unionbranch(tag,l);
	`a@ xoff = unsafe_cast(*tagp+off);
	env = write_type_base(typ, env, fp, xoff);
      }
    }
    break;
    

  case &XTUnion(_,l):
    // val is a pointer to a xtunion, which is a pointer to a struct consisting of a char* tag that points to "\0\0\0\0Name", followed by any arguments
    addr_t@ xtunionp = unsafe_cast(val);
    let mem = index_lookup(env,*xtunionp);
    cycputvarint(mem,fp);
    if(!index_member(env,mem)) {
      env = index_insert(env,*xtunionp);
      // get the pointer to the name string "\0\0\0\0Name"
      addr_t* xtstructp = unsafe_cast(*xtunionp);
      if(*xtstructp != 0) {
	cycputchar(1,fp);
	Cstring<`H> xtnamec = unsafe_cast(*xtstructp+4);
	string_t<`H> xtname = Core::Cstring_to_string(xtnamec);
	fprintf(fp,"%s",xtname);
	cycputchar(0,fp);
	let $(off,typ) = get_xtunionbranch(xtname,l);
	`a@ xoff = unsafe_cast(*xtunionp+off);
	env = write_type_base(typ, env, fp, xoff);
      }
      else {
	cycputchar(0,fp);
	Cstring<`H> xtnamec = unsafe_cast(*xtunionp+4);
	string_t<`H> xtname = Core::Cstring_to_string(xtnamec);
	fprintf(fp,"%s",xtname);
	cycputchar(0,fp);
      }
    }
    break;



    // messy...better to just do a flat write somehow
  case &Union(_,szb,_): 
    // Claim: impossible that env actually changes here.
    env = write_type_base(new Tuple(szb,new {for i < szb: new $(i,new Int(false,8))}), env, fp, val);
    break;
    
  case &Enum(_,szb,_):
    env = write_type_base(new Int(false,szb<<3), env, fp, val);
    //default: throw new Core::Failure("Unhandled case in write_type_base");
    
  }
  return env;
}

#define MAXXTUNIONSIZE 100

void write_type(typestruct_t ts, FILE@ fp, `a::A@ val) {
  try{
  write_type_base(ts,empty_addr_index(),fp, val);
  } catch {
  case &Core::Failure(s):
    fprintf(stderr,"Core::Failure(%s)\n",s);
    throw new Core::Failure(s);
  }
}

void fscanntstring(FILE@ fp, mstring_t s) {
  int c;
  int i = 0;
  while(c = fgetc(fp)) {
    if(c == EOF) throw new Core::Failure("Read error");
    s[i] = (char)c;
    i++;
  }
  s[i] = 0;
}

addr_table_t rread_type_base(region_t<`r> r,typestruct_t rep, addr_table_t env, FILE@ fp, `a::A@`r result) {
  switch(rep) {
  case &Int(_,sz): // ignore sign
    switch(sz) {
    case 8:
      char@ x = unsafe_cast(result);
      *x = cycgetchar(fp);//(char)fgetc(fp); // beware EOF
      break;
    case 16:
      short@ x = unsafe_cast(result);
      *x = cycgetshort(fp);//(short)getw(fp);
      break;
    case 32:
      int@ x = unsafe_cast(result);
      *x = cycgetint(fp);//getw(fp);
      break;
    default:
      throw new Core::Failure("read_type_base: illegal int size bits");
    }
    break;
  case Float:
    float@ y = unsafe_cast(result);
    *y = cycgetfloat(fp);
    break;
    
    
  case Double:
    double@ y = unsafe_cast(result);
    *y = cycgetdouble(fp);
    break;

  case &ThinPtr(sz,typ):
    int mem = cycgetvarint(fp); // null always shared
    if(!table_member(env,mem)) { // not shared; read in value
      int typ_szb = size_type(typ);
      // allocate block
      char? buf = new {for i < sz*typ_szb: 0};  
      // add to table
      addr_t bufptr = (addr_t)(_*)buf;
      addr_t@ x = unsafe_cast(result);
      *x=bufptr;
      env = table_insert(env,bufptr);
      // fill it in
      int y = bufptr;
      for(int i = 0; i < sz; i++) {
	env = rread_type_base(r,typ,env,fp,unsafe_cast@<_,`a@>(y));
	y += typ_szb;
      }
    } else { // return pointer to shared thing
      addr_t@ x = unsafe_cast(result);
      *x = table_lookup(env,mem);
    }
    break;

  case &FatPtr(typ):
    int mem = cycgetvarint(fp);
    int pos = cycgetvarint(fp);
    int sz = cycgetvarint(fp);
    int typ_szb = size_type(typ);
    if(!table_member(env,mem)) { // not shared; read in value
      // allocate block
      char? buf = new {for i < sz*typ_szb: 0};  
      // add to table
      addr_t bufptr = (addr_t)(_*)buf;
      $(addr_t, addr_t, addr_t)@ x = unsafe_cast(result);
      (*x)[0] = bufptr;
      (*x)[1] = bufptr+pos*typ_szb;
      (*x)[2] = bufptr + sz*typ_szb;
      env = table_insert(env,bufptr);
      // fill it in
      int y = bufptr;
      for(int i = 0; i < sz; i++) {
	env = rread_type_base(r,typ,env,fp,unsafe_cast@<_,`a@>(y));
	y += typ_szb;
      }
    } else { // return pointer to shared thing
      $(addr_t, addr_t, addr_t)@ x = unsafe_cast(result);
      (*x)[0] = table_lookup(env,mem);
      (*x)[1] = (*x)[0] + typ_szb * pos;
      (*x)[2] = (*x)[0] + typ_szb * sz;
    }
    break;

  case &Struct(_,_,l): // ignore name
    addr_t x = unsafe_cast(result);
    for(int i = 0; i < l.size; i++) {
      let $(ofs, _,typ) = *(l[i]);
      int x_ofs = x+ofs;
      env = rread_type_base(r,typ,env,fp,unsafe_cast@<_,`a@>(x_ofs));
   } 
    break;

  case &Tuple(_,l):
    addr_t x = unsafe_cast(result);
    for(int i = 0; i < l.size; i++) {
      let $(ofs, typ) = *(l[i]);
      int x_ofs = x+ofs;
      env = rread_type_base(r,typ,env,fp,unsafe_cast@<_,`a@>(x_ofs));
    } 
    break;

  case &TUnionField(_,_,_,l):
    addr_t x = unsafe_cast(result);
    for(int i = 0; i < l.size; i++) {
      let $(ofs, typ) = *(l[i]);
      int x_ofs = x+ofs;
      env = rread_type_base(r,typ,env,fp,unsafe_cast@<_,`a@>(x_ofs));
    } 
    break;

  case &TUnion(_,t,l): 
    int tagmem = cycgetvarint(fp); 
    if(tagmem < 1024) {
      int tag = tagmem;
      addr_t@ x = unsafe_cast(result);
      *x=tag;
    } else {
      int mem = tagmem-1024;
      if(!table_member(env,mem)) {
	int tag = cycgetvarint(fp);
	// figure out which variant it is
	let $(off,typ) = get_unionbranch(tag,l);
	// allocate memory for new tuple
	char? buf = new {for i < off+size_type(typ) : 0};
	addr_t bufptr = (addr_t)(_*)buf;
	// add to table
	env = table_insert(env,bufptr);
	// assign to result
	addr_t@ x = unsafe_cast(result);
	*x=bufptr;
	// fill in buf
	addr_t@ tagptr = unsafe_cast(bufptr);
	*tagptr = tag;
	env = rread_type_base(r,typ, env, fp, unsafe_cast@<_,`a@>(bufptr+off));
      } else {
	// look up the corresponding pointer and fill in result
	addr_t@ x = unsafe_cast(result);
	*x = table_lookup(env,mem);
      }
    }
    break;

    // somewhat messy
    // suboptimal because it allocates and links in a new string for every tag encountered.  these strings already statically live in the program, so instead it would be better to use them directly.
    // plan:  build a list of pointers to the tagname strings in l.
    // read one character at a time, iterate through the list and remove 
    // every pointer that doesn't match.
    // if we hit \0 on both the (unique) remaining string and the input
    // then we have a match, otherwise we have to fail with "don't know 
    // what to do here"
  case &XTUnion(_,l):
    int mem = cycgetvarint(fp);
    if(!table_member(env,mem)) {
      char nonnull = (char)cycgetchar(fp);
      mstring_t s = new {for i < MAXXTUNIONSIZE : 0};
      mstring_t xtname = s+4;
      fscanntstring(fp,xtname);
      if(nonnull) {
	// figure out what branch
	let $(off,typ) = get_xtunionbranch(xtname, l);
	// allocate a new blob of the right size
	char? buf = new {for i < off+size_type(typ): 0};
	addr_t bufptr = (addr_t)(_*)buf;
	// add to table
	env = table_insert(env, bufptr);
	// assign to result
	addr_t@ x = unsafe_cast(result);
	*x = bufptr;
	// fill in buf
	addr_t@ tagptr = unsafe_cast(bufptr);
	*tagptr = (addr_t)(_*)s;
	env=rread_type_base(r,typ, env, fp, unsafe_cast@<_,`a@>(bufptr+off));
      } else { // build a non-data carrying xtunion: a pointer to NULL followed by an untagged pointer to 0000Tagname.
	addr_t@ x = unsafe_cast(result);
	*x = (addr_t)(_*)s;
	env = table_insert(env, *x);
      }
    } else {
      // look up the corresponding pointer and fill in result
      addr_t@ x = unsafe_cast(result);
      *x = table_lookup(env,mem);
    }
    break;
  case &Union(_,szb,_): 
    // Claim: impossible that env actually changes here.
    env = rread_type_base(r,new Tuple(szb,new {for i < szb: new $(i,new Int(0,8))}), env, fp, result);
    break;
  case &Enum(_,szb,_): // just write out the int
    env = rread_type_base(r,new Int(false,szb<<3), env, fp, result);
    //default: throw new Core::Failure("Unhandled case in read_type_base");
  }
  return env;
}

// warning: pretty nasty
`a::A@`r rread_type(region_t<`r> r,typestruct_t ts, FILE@ fp) {
  try{
    char? buf = rnew(r) {for i < size_type(ts):0}; // allocate buf for type
    `a::A@`r result = unsafe_cast( (_*) buf); // result should point to the beginning of buf/s storage, not to the tagged array triple
    rread_type_base(r,ts,empty_addr_table(),fp,result);
    return result;
  } catch {
  case &Core::Failure(s):
    fprintf(stderr,"Core::Failure(%s)\n",s);
    throw new Core::Failure(s);
  }
}

`a::A@ read_type(typestruct_t ts, FILE@ fp) {
  return rread_type(Core::heap_region,ts,fp);
}

// polytypic deep copy


typedef Dict::dict_t<addr_t, addr_t> addr_map_t;

static addr_map_t empty_addr_map() {
  return Dict::insert(Dict::empty(uint_cmp),0,0);
}

addr_map_t rcopy_type_base(region_t<`r> r,typestruct_t rep, addr_map_t env, `a::A@ val, `a::A@`r result) {
  switch(rep) {
  case &Int(_,8):
    char@ val0 = unsafe_cast(val);
    char@ result0 = unsafe_cast(result);
    *result0 = *val0;
    break;

  case &Int(_,16):
    short@ val0 = unsafe_cast(val);
    short@ result0 = unsafe_cast(result);
    *result0 = *val0;
    break;  

  case &Int(_,32):
    int@ val0 = unsafe_cast(val);
    int@ result0 = unsafe_cast(result);
    *result0 = *val0;
    break;  
 
  case &Int(_,64):
    long long@ val0 = unsafe_cast(val);
    long long@ result0 = unsafe_cast(result);
    *result0 = *val0;
    break;

  case Float:
    float@ val0 = unsafe_cast(val);
    float@ result0 = unsafe_cast(result);
    *result0 = *val0;
    break;   

  case Double:
    double@ val0 = unsafe_cast(val);
    double@ result0 = unsafe_cast(result);
    *result0 = *val0;
    break;

  case &ThinPtr(sz,typ):
    addr_t @ val0 = unsafe_cast(val);
    addr_t @ result0 = unsafe_cast(result);
    int addr = *val0;
    if(Dict::member(env,addr)) { // since (NULL,NULL) is already in dict, this handles nulls
      // already copied, fill in result0 with existing copy's address 
      *result0 = Dict::lookup(env,addr);
    } else { // not in dict, so make a new copy & add it
      int typ_szb = size_type(typ);
      char? buf = rnew(r) {for i<sz*typ_szb:0};
      addr_t bufptr = (addr_t)(_*)buf;
      *result0 = bufptr;
      env = Dict::insert(env,addr,bufptr);
      // copy entries
      int x = addr;
      int y = bufptr;
      for(int i = 0; i < sz; i++) {
	env = rcopy_type_base(r,typ,env,unsafe_cast@<_,`a@>(x),unsafe_cast@<_,`a@>(y));
	x += typ_szb;
	y += typ_szb;
      } 
    }
    break;
  case &FatPtr(typ):
    $(addr_t, addr_t, addr_t) @`H val0 = unsafe_cast(val);
    $(addr_t, addr_t, addr_t) @`H result0 = unsafe_cast(result);
    let $(base,curr,last_plus_one) = *val0;
    int typ_szb = size_type(typ);
    int size = (last_plus_one-base)/typ_szb;
    int pos = (curr-base)/typ_szb;
    if(Dict::member(env,base)) {
      let bufptr = Dict::lookup(env,base);
      *result0 = $(bufptr,bufptr+pos*typ_szb,bufptr+size*typ_szb);
    } else {
      char? buf = rnew(r) {for i < last_plus_one-base:0};
      addr_t bufptr = (addr_t)(_*)buf;
      *result0 = $(bufptr,bufptr+pos*typ_szb,bufptr+size*typ_szb);
      env = Dict::insert(env,base,bufptr);
      int y = base;
      int z = bufptr;
      for(int i = 0; i < size; i++) {
	env = rcopy_type_base(r,typ,env,unsafe_cast@<_,`a@>(y),unsafe_cast@<_,`a@>(z));
	y += typ_szb;
	z += typ_szb;
      } 
    }
    break;

  case &Struct(_,_,l):
    int x = unsafe_cast(val);
    int y = unsafe_cast(result);
    for (int i = 0; i < l.size; i++) {
      let $(ofs,_,typ) = *(l[i]);
      int x_ofs = x + ofs;
      int y_ofs = y + ofs;
      env = rcopy_type_base(r,typ, env, unsafe_cast@<_,`a@>(x_ofs), unsafe_cast@<_,`a@>(y_ofs));
    }
    break;

  case &Tuple(_,l):
    int x = unsafe_cast(val);
    int y = unsafe_cast(result);
    for (int i = 0; i < l.size; i++) {
      let $(ofs,typ) = *(l[i]);
      int x_ofs = x + ofs;
      int y_ofs = y + ofs;
      env = rcopy_type_base(r,typ, env, unsafe_cast@<_,`a@>(x_ofs), unsafe_cast@<_,`a@>(y_ofs));
    }
    break;

  case &TUnionField(_,_,_,l):
    int x = unsafe_cast(val);
    int y = unsafe_cast(result);
    for (int i = 0; i < l.size; i++) {
      let $(ofs,typ) = *(l[i]);
      int x_ofs = x + ofs;
      int y_ofs = y + ofs;
      env = rcopy_type_base(r,typ, env, unsafe_cast@<_,`a@>(x_ofs), unsafe_cast@<_,`a@>(y_ofs));
    }
    break;

  case &TUnion(_,t,l):
    /* get the tag */
    addr_t@ val0 = unsafe_cast(val);
    addr_t@ result0 = unsafe_cast(result);
    if (*val0 < 1024) {
      *result0 = *val0;
    }
    else {
      addr_t addr = *val0; // addr of $(tag,data1,...,datan) tuple
      if(Dict::member(env,addr)) { // already copied this
	*result0 = Dict::lookup(env,addr);
      } else {
	addr_t@ tufp = unsafe_cast(*val0);
	unsigned int tag = *tufp;
	let $(off,typ) = get_unionbranch(tag,l);
	char? buf = rnew(r) {for i < off+size_type(typ) : 0};
	addr_t bufptr = (addr_t)(_*)buf;
	// add to table
	env = Dict::insert(env,addr,bufptr);
	// fill in result
	*result0 = bufptr;
	// fill in buf: tag
	unsigned int@ newtagp = unsafe_cast(bufptr);
	*newtagp = tag;
	env = rcopy_type_base(r,typ,env,unsafe_cast(addr+off),unsafe_cast(bufptr+off));
      }
    }
    break;

  case &XTUnion(_,l):
    addr_t@ val0 = unsafe_cast(val);
    addr_t@ result0 = unsafe_cast(result);
    addr_t addr = *val0;
    if(Dict::member(env,addr)) {
      *result0 = Dict::lookup(env,addr);
    } else {
      addr_t@ xtstructp = unsafe_cast(*val0);
      if(*xtstructp != 0) {
	addr_t xtnamep = *xtstructp;
	Cstring<`H> xtnamec = unsafe_cast(xtnamep+4);
	string_t<`H> xtname = Core::Cstring_to_string(xtnamec);
	// figure out what branch
	let $(off,typ) = get_xtunionbranch(xtname, l);
	// allocate a new blob of the right size
	char? buf = rnew(r) {for i < off+size_type(typ): 0};
	addr_t bufptr = (addr_t)(_*)buf;
	// assign to result
	*result0 = bufptr;
	// fill in buf
	addr_t@ tagptr = unsafe_cast(bufptr);
	*tagptr = xtnamep;
	`a@ xoff = unsafe_cast(*val0+off);
	
	env=rcopy_type_base(r,typ, env, xoff, unsafe_cast@<_,`a@>(bufptr+off));
	// add to table
	env = Dict::insert(env, addr,bufptr);
      } else { // build a non-data carrying xtunion: a pointer to NULL followed by an untagged pointer to 0000Tagname.
	*result0 = *val0;
      }
    }
    break;



    // lame; really want to use memcpy here...
  case &Union(_,szb,_):
    env = rcopy_type_base(r,new Tuple(szb,new {for i < szb: new $(i,new Int(false,8))}), env,  val, result);
    break;

  case &Enum(_,szb,_):
      env = rcopy_type_base(r,new Int(false,szb<<3), env, val, result);
    break;
  default: throw new Core::Failure("Unhandled case in copy_type_base");
  }
  return env;
}

`a::A@`r rcopy_type(region_t<`r> r, typestruct_t ts, `a::A@ val) {
  try {
    char? buf = rnew(r) {for i < size_type(ts):0};
    `a::A@`r result = unsafe_cast( (_*) buf);
    rcopy_type_base(r,ts,empty_addr_map(),val,result);
    return result;
  } catch {
  case &Core::Failure(s):
    fprintf(stderr,"Core::Failure(%s)\n",s);
    throw new Core::Failure(s);
  }
}

`a::A@ copy_type(typestruct_t ts, `a::A@ val) {
  return rcopy_type(Core::heap_region,ts,val);
}

typedef tunion Order {Gt_ord;Eq_ord;Lt_ord;} order_t;


#define compare_ord(x,y) ((x)==(y)?Eq_ord:((x)<=(y)?Lt_ord:Gt_ord))

order_t order_lex(order_t ord1, order_t ord2) {
  // if prefix1 < prefix2 then <, e.g. abc < abd => abcx < abdy
  if(ord1 != Eq_ord) return ord1;  
  // otherwise ordering depends on next element, e.g. abc == abc => abcx R abcy where x R y.
  else return ord2; 
}

typedef Dict::dict_t<$(addr_t,addr_t)@,order_t> eq_dict_t ;

static int addrp_cmp($(addr_t,addr_t)@addrp1,$(addr_t,addr_t)@addrp2) {
  if(((*addrp1)[0] < (*addrp2)[0])) return 1;
  else if((*addrp1)[0] == (*addrp2)[0])
    return uint_cmp((*addrp1)[1],(*addrp2)[1]);
  else return -1;
}

eq_dict_t empty_eq_dict() {
  return Dict::insert(Dict::empty(addrp_cmp),new $(0,0),Eq_ord);
}

// PROBLEM: Need to make env be a dictionary mapping address pairs to results
// To handle loops, insert $(true,true) for a possible loop pair and recurse.
// Then, update the loop with the result.
// Use a dataflow argument to argue that this is correct.  (ie onyl one evaluation of the loop is needed to get the right answer.)

$(order_t, eq_dict_t) 
return_update($(addr_t,addr_t)@`H pair, $(order_t,eq_dict_t) ordenv) {
  let $(ord,env) = ordenv;
  env = Dict::insert(env,pair,ord);
  return $(ord,env);
}

$(order_t,eq_dict_t) 
leq_eq_type(typestruct_t rep, eq_dict_t env, `a::A@ x, `a@ y) {
  // avoid redoing work if there is sharing
  if(x == y) return $(Eq_ord,env);

  switch(rep) {
  case &Int(false,8):
    unsigned char@ x0 = unsafe_cast(x);
    unsigned char@ y0 = unsafe_cast(y);
    return $(compare_ord(*x0,*y0),env);

  case &Int(true,8):
    signed char@ x0 = unsafe_cast(x);
    signed char@ y0 = unsafe_cast(y);
    return $(compare_ord(*x0,*y0),env);

  case &Int(true,16):
    signed short@ x0 = unsafe_cast(x);
    signed short@ y0 = unsafe_cast(y);
    return $(compare_ord(*x0,*y0),env);

  case &Int(false,16):
    unsigned short@ x0 = unsafe_cast(x);
    unsigned short@ y0 = unsafe_cast(y);
    return $(compare_ord(*x0,*y0),env);

  case &Int(true,32):
    int@ x0 = unsafe_cast(x);
    int@ y0 = unsafe_cast(y);
    return $(compare_ord(*x0,*y0),env);
 
  case &Int(false,32):
    unsigned int@ x0 = unsafe_cast(x);
    unsigned int@ y0 = unsafe_cast(y);
    return $(compare_ord(*x0,*y0),env);
 
  case &Int(true,64):
    signed long long@ x0 = unsafe_cast(x);
    signed long long@ y0 = unsafe_cast(y);
    return $(compare_ord(*x0,*y0),env);
   
  case &Int(false,64):
    unsigned long long@ x0 = unsafe_cast(x);
    unsigned long long@ y0 = unsafe_cast(y);
    return $(compare_ord(*x0,*y0),env);

  case Float:
    float@ x0 = unsafe_cast(x);
    float@ y0 = unsafe_cast(y);
    return $(compare_ord(*x0,*y0),env);

  case Double:
    double@ x0 = unsafe_cast(x);
    double@ y0 = unsafe_cast(y);
    return $(compare_ord(*x0,*y0),env);

  case &ThinPtr(sz,typ):
    addr_t @ x0 = unsafe_cast(x);
    addr_t @ y0 = unsafe_cast(y);
    addr_t addrx = *x0;
    addr_t addry = *y0;
    let pair = new $(addrx,addry);
    if(Dict::member(env,pair)) { // dict contains pairs already visited; assume equal (if they're not, this will be discovered as the recursion unwinds.)
      return $(Dict::lookup(env,pair),env);
    } else if (addrx == 0) return $(Lt_ord,env);
    else if (addry == 0) return $(Gt_ord,env);
    else { 
      env = Dict::insert(env, pair, Eq_ord);
      int typ_szb = size_type(typ);
      int xa = addrx;
      int ya = addry;
      order_t ord = Eq_ord;
      for(int i = 0; i < sz; i++) {
	let $( ord2,env2) = leq_eq_type(typ,env,unsafe_cast@<_,`a@>(xa),unsafe_cast@<_,`a@>(ya));
	ord = order_lex(ord,ord2);
	env = env2;
	xa += typ_szb;
	ya += typ_szb;
      } 
      return return_update(pair,$(ord,env));
    }

    // This is tricky.  There are two interpretations of "does `a? x == `a? y":
    // 1.  x and y point to equal (single) things
    // 2.  x and y point to equal arrays.
    // #2 seems most appropriate, since we could similate 1 by asking
    // "does (_*)x == (_*)y"
    // However, in #2, do we compare the entire array or just starting from xcurr and ycurr?
    // I think a reasonable structural equality condition is that any function 
    // of x (disregarding things that cast x to an address, etc) produces the same value as that function of y.  So, we need to ensure that --x == --y etc.
    // Fat pointer equality test:
    // The arrays are of the same size
    // The positions are equal
    // All the elements of the pointed-to arrays are equal (this is slow, so we guard with the easy tests)
    // <= if:
    // x.size <= y.size
    // x.curr <= y.curr
    // x lex <= y
  case &FatPtr(typ):
    $(addr_t, addr_t, addr_t) @`H x0 = unsafe_cast(x);
    $(addr_t, addr_t, addr_t) @`H y0 = unsafe_cast(y);
    let $(xbase,xcurr,xlast_plus_one) = *x0;
    let $(ybase,ycurr,ylast_plus_one) = *y0;
    int typ_szb = size_type(typ);
    int xpos = (xcurr-xbase)/typ_szb;
    int ypos = (ycurr-ybase)/typ_szb;
    if(xpos > ypos) return $(Gt_ord,env);
    int xsize = (xlast_plus_one-xbase)/typ_szb;
    int ysize = (ylast_plus_one-ybase)/typ_szb;
    if(xsize > ysize) return $(Gt_ord,env);
    // they might be <= or ==
    let pair = new $(xbase,ybase);
    if(Dict::member(env,pair)) {
      return $(Dict::lookup(env,pair),env);
    } else if (xbase == 0) return $(Lt_ord,env);
    else if (ybase == 0) return $(Gt_ord,env);
    else { 
      env = Dict::insert(env, pair, Eq_ord);
      int xb = xbase;
      int yb = ybase;
      order_t ord = Eq_ord;
      // know xsize <= ysize
      for(int i = 0; i < xsize; i++) {
	let $(ord2,env2) = leq_eq_type(typ,env,unsafe_cast@<_,`a@>(xb),unsafe_cast@<_,`a@>(yb));
	ord = order_lex(ord,ord2);
	env = env2;
	xb += typ_szb;
	yb += typ_szb;
      }
      // equality test: equal if all components are and sizes equal (no tail left on y)
      if(ord == Eq_ord && xsize < ysize) ord = Lt_ord;
      return return_update(pair,$(ord, env));
    }

  case &Tuple(_,l):
    int x0 = unsafe_cast(x);
    int y0 = unsafe_cast(y);
    order_t ord = Eq_ord;
    for(int i = 0; i < l.size; i++) {
      let $(ofs,typ) = *(l[i]);
      int x_ofs = x0+ofs;
      int y_ofs = y0+ofs;
      let $(ord2,env2) = leq_eq_type(typ,env,unsafe_cast@<_,`a@>(x_ofs), unsafe_cast@<_,`a@>(y_ofs));
      ord = order_lex(ord,ord2);
      env = env2;
    }
    return $(ord,env);

  case &Struct(_,_,l):
    int x0 = unsafe_cast(x);
    int y0 = unsafe_cast(y);
    order_t ord = Eq_ord;
    for(int i = 0; i < l.size; i++) {
      let $(ofs,_,typ) = *(l[i]);
      int x_ofs = x0+ofs;
      int y_ofs = y0+ofs;
      let $(ord2,env2) = leq_eq_type(typ,env,unsafe_cast@<_,`a@>(x_ofs), unsafe_cast@<_,`a@>(y_ofs));
      ord = order_lex(ord,ord2);
      env = env2;
    }
    return $(ord,env);
    
  case &TUnionField(_,_,_,l):
    int x0 = unsafe_cast(x);
    int y0 = unsafe_cast(y);
    // tags must be equal since both x and y have same tunionfield type
    order_t ord = Eq_ord;
    for(int i = 1; i < l.size; i++) {
      let $(ofs,typ) = *(l[i]);
      int x_ofs = x0+ofs;
      int y_ofs = y0+ofs;
      let $(ord2,env2) = leq_eq_type(typ,env,unsafe_cast@<_,`a@>(x_ofs), unsafe_cast@<_,`a@>(y_ofs));
      ord = order_lex(ord,ord2);
      env = env2;
    }
    return $(ord,env);

  case &TUnion(_,t,l):
    addr_t@ x0 = unsafe_cast(x);
    addr_t@ y0 = unsafe_cast(y);
    if(*x0 < 1024 && *y0 < 1024) {
      return $(compare_ord(*x0,*y0),env);
    } else if (*x0 < 1024) return $(Lt_ord,env); // any tag-only < and tag-data
    else if (*y0 < 1024) return $(Gt_ord,env); // and tag-data > any tag-only
    else { // both are tag-data
      // seen it before?
      let pair = new $(*x0,*y0);
      if(Dict::member(env,pair)) {
	return $(Dict::lookup(env,pair),env);
      } else {
	env = Dict::insert(env, pair, Eq_ord);
	unsigned int@ xtagp = unsafe_cast(*x0);
	unsigned int@ ytagp = unsafe_cast(*y0);
	// if tags differ...
	if(*xtagp != *ytagp) return return_update(pair,$(compare_ord(*xtagp,*ytagp),env));
	else { // same tag, compare data 
	  let $(off,typ) = get_unionbranch(*xtagp,l);
	  `a@ xoff = unsafe_cast(*x0+off);
	  `a@ yoff = unsafe_cast(*y0+off);
	  return return_update(pair,leq_eq_type(typ,env,xoff,yoff));
	}
      }
    }

  case &XTUnion(_,l):
    addr_t@ x0 = unsafe_cast(x);
    addr_t@ y0 = unsafe_cast(y);
    let pair = new $(*x0,*y0);
    if(Dict::member(env,pair)) {
      return $(Dict::lookup(env,pair),env);
    } else {
      env = Dict::insert(env,new $(*x0,*y0),Eq_ord);
      addr_t@ xp = unsafe_cast(*x0);
      addr_t@ yp = unsafe_cast(*y0);
      if(*xp == 0 && *yp == 0) { // both are tag-only
	Cstring<`H> xnamec = unsafe_cast(*x0+4);
	Cstring<`H> ynamec = unsafe_cast(*y0+4);
	string_t<`H> xname = Core::Cstring_to_string(xnamec);
	string_t<`H> yname = Core::Cstring_to_string(ynamec);
	int cmp = strcmp(xname,yname);
	if(cmp < 0) return return_update(pair,$(Gt_ord,env));
	else if (cmp == 0) return return_update(pair,$(Eq_ord,env));
	else return return_update(pair,$(Lt_ord,env));
      } else if (*xp == 0) return return_update(pair,$(Lt_ord,env));
      else if (*yp == 0) return return_update(pair,$(Gt_ord,env));
      else { // both are tag-data
	Cstring<`H> xnamec = unsafe_cast(*xp+4);
	Cstring<`H> ynamec = unsafe_cast(*yp+4);
	string_t<`H> xname = Core::Cstring_to_string(xnamec);
	string_t<`H> yname = Core::Cstring_to_string(ynamec);
	int cmp = strcmp(xname,yname);
	if(cmp < 0) return return_update(pair,$(Gt_ord,env));
	else if (cmp == 0) { //same case, so must compare fields
	  let $(off,typ) = get_xtunionbranch(xname,l);
	  `a@ xoff = unsafe_cast(*x0+off);
	  `a@ yoff = unsafe_cast(*y0+off);
	  return return_update(pair,leq_eq_type(typ,env,xoff,yoff));
	}
	else return return_update(pair,$(Lt_ord,env));
      }
      
    }

  case &Union(_,szb,l):
    return leq_eq_type(new Tuple(szb,new {for i < szb: new $(i,new Int(false,8))}), env, x, y);
    
  case &Enum(_,szb,_):
    return leq_eq_type(new Int(false,szb<<3), env, x, y);

  default: // this would catch any illegal int sizes
    // maybe change Int typerep to Int(Signed|Unsigned,B8|B16|B32|B64) so that we can do this exhaustively
    throw new Core::Failure("leq_eq_type case unmatched");
  }
}

bool eq_type(typestruct_t ts, `a::A@ x, `a::A@ y) {
  try {
    let $(order,_) = leq_eq_type(ts,empty_eq_dict(),x,y);
    return (order == Eq_ord);
  } catch {
  case &Core::Failure(s):
    fprintf(stderr,"Core::Failure(%s)\n",s);
    throw new Core::Failure(s);
  }
}

bool leq_type(typestruct_t ts, `a::A@ x, `a::A@ y) {
  try {
    let $(order,_) = leq_eq_type(ts,empty_eq_dict(),x,y);
    return (order != Gt_ord);
  } catch {
  case &Core::Failure(s):
    fprintf(stderr,"Core::Failure(%s)\n",s);
    throw new Core::Failure(s);
  }
}

int cmp_type(typestruct_t ts, `a::A@ x, `a::A@ y) {
  try {
    let $(order,_) = leq_eq_type(ts,empty_eq_dict(),x,y);
switch(order) {
    case Gt_ord: return -1;
    case Eq_ord: return 0;
    case Lt_ord: return 1;
    }
  } catch {
  case &Core::Failure(s):
    fprintf(stderr,"Core::Failure(%s)\n",s);
    throw new Core::Failure(s);
  }
}
