/* This file is part of the Cyclone Library.
   Copyright (C) 2001 Greg Morrisett

   This library is free software; you can redistribute it and/or it
   under the terms of the GNU Lesser General Public License as
   published by the Free Software Foundation; either version 2.1 of
   the License, or (at your option) any later version.

   This library is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with this library; see the file COPYING.LIB.  If not,
   write to the Free Software Foundation, Inc., 59 Temple Place, Suite
   330, Boston, MA 02111-1307 USA. */

#include <core.h>
using Core;
#include <cdirent.h>

namespace Cdirent {
  extern "C" Std::DIR *opendir(Cstring name);
}

namespace Std {
DIR *opendir(string_t name) {
  return Cdirent::opendir(string_to_Cstring(name));
}
}

#include <cfcntl.h>

namespace Cfcntl {
  extern "C" int fcntl(int fd, int cmd);
  extern "C" int fcntl_with_arg(int fd, int cmd, long arg);
  extern "C" int fcntl_with_lock(int fd, int cmd, struct Std::flock *lock);
  extern "C" int creat(const Cstring,mode_t);
  extern "C" int open_without_mode(const Cstring,int);
  extern "C" int open_with_mode(const Cstring,int,mode_t);
}

namespace Std {

int fcntl(int fd, int cmd, ... inject fcntlarg_t argv) {
  if (argv.size == 0) return Cfcntl::fcntl(fd, cmd);
  else if (argv.size != 1) throw new Failure("fcntl: too many args");
  else switch (argv[0]) {
  case &Long(arg): return Cfcntl::fcntl_with_arg(fd, cmd, arg);
  case &Flock(lock): return Cfcntl::fcntl_with_lock(fd, cmd, lock);
  }
}

int creat(string_t s, mode_t m) {
  return Cfcntl::creat(string_to_Cstring(s),m);
}

int open(string_t s, int i, ... mode_t ms) {
  /* Note: if open is called with more than 3 arguments, the
     additional args are simply ignored. */
  if (ms.size >= 1)
    return Cfcntl::open_with_mode(string_to_Cstring(s),i,ms[0]);
  else
    return Cfcntl::open_without_mode(string_to_Cstring(s),i);
}
}

#include <cnetdb.h>

namespace Cnetdb {
  abstract struct Cservent {
    Cstring s_name;
    Cstring @s_aliases;
    Std::in_port_t s_port;
    Cstring s_proto;
  };
  abstract struct Chostent {
    Cstring h_name;
    Cstring @h_aliases;
#if defined(__CYGWIN32__) || defined(__CYGWIN__)
    short h_addrtype;
    short h_length;   // always 4
#else
    int h_addrtype;
    int h_length;     // always 4
#endif
    struct Std::in_addr *@h_addr_list;
  };
  abstract struct Cprotoent {
    Cstring p_name;        /* official protocol name */
    Cstring @p_aliases;    /* alias list */
    int     p_proto;        /* protocol number */
  };
  extern "C" {
    struct Cservent *getservbyname(const Cstring name, const Cstring proto);
    struct Chostent *gethostbyname(const Cstring name);
    struct Cprotoent * getprotobyname(const Cstring name);
    void herror(Cstring);
    struct Std::in_addr *?pntlp_toCyc(struct Std::in_addr *@);
  }
#define s2c(x) (string_to_Cstring(x))
#define c2s(x) (Cstring_to_string(x))
}

namespace Std {

struct servent *getservbyname(string_t name, string_t proto) {
  struct Cnetdb::Cservent *src = Cnetdb::getservbyname(s2c(name),s2c(proto));
  return src ? new servent{.s_name = c2s(src->s_name),
                           .s_aliases = ntCsl_to_ntsl(src->s_aliases),
                           .s_port = src->s_port,
                           .s_proto = c2s(src->s_proto)}
    : NULL;
}

struct hostent *gethostbyname(string_t name) {
  struct Cnetdb::Chostent *src = Cnetdb::gethostbyname(s2c(name));
  return src ? new hostent{.h_name = c2s(src->h_name),
                           .h_aliases = ntCsl_to_ntsl(src->h_aliases),
                           .h_addrtype = src->h_addrtype,
                           .h_length = src->h_length,
                           .h_addr_list = Cnetdb::pntlp_toCyc(src->h_addr_list)}
    : NULL;
}

struct protoent * getprotobyname(string_t name) {
  struct Cnetdb::Cprotoent *src = Cnetdb::getprotobyname(s2c(name));
  return src ? new protoent{.p_name = c2s(src->p_name),
			      .p_aliases = ntCsl_to_ntsl(src->p_aliases),
			      .p_proto=src->p_proto} 
    : NULL;
}
void herror(const char ?`r s) { Cnetdb::herror(s2c(s)); }
}

#include <netinet/in.h>
#include <sys/socket.h>

namespace Std {
extern xtunion sockaddr {
  sockaddr_in(struct sockaddr_in);
};
}

#include <arpa/cinet.h>

namespace Cinet {
  extern "C" {
    int inet_aton(const Cstring cp, struct Std::in_addr @`r inp);
    Cstring inet_ntoa(struct Std::in_addr);
    unsigned long inet_addr(const Cstring);
  }
#define s2c(x) (string_to_Cstring(x))
//  #define static_c2s(x) (Cstring_to_string(x))
#define static_c2s(x) (wrap_Cstring_as_string(x,-1))
}

namespace Std {
int inet_aton(string_t cp, struct in_addr @`r inp) {
  return Cinet::inet_aton(s2c(cp), inp);
}

char ?inet_ntoa(struct in_addr x) {
  return static_c2s(Cinet::inet_ntoa(x));
}

unsigned long inet_addr(string_t addr) {
  return Cinet::inet_addr(s2c(addr));
}
}

#include <signal.h>

namespace Csignal {
  extern "C" {
    __sighandler_t signal_func(int sig, __sighandler_t func);
  }
}

namespace Std {

void _SIG_DFL(int n;{}) {} // equate to 0
void _SIG_IGN(int n;{}) {} // equate to 1
void _SIG_ERR(int n;{}) {} // equate to -1

__sighandler_t signal(int sig, __sighandler_t func) {
  return Csignal::signal_func(sig, func);
}
}

#include <sys/stat.h>

namespace Cstat {
  extern "C" {
    int stat(Cstring filename, struct stat_t @`r buf);
    int fstat(int fd, struct stat_t @`r buf);
    int lstat(Cstring filename, struct stat_t @`r buf);
    int mkdir(Cstring pathname, mode_t mode);
    int chmod(Cstring pathname, mode_t mode);
  }
#define s2c(x) (string_to_Cstring(x))
}

namespace Std {

int stat(string_t filename, struct stat_t @`r buf) {
  return Cstat::stat(s2c(filename), buf);
}

int lstat(string_t filename, struct stat_t @`r buf) {
  return Cstat::lstat(s2c(filename), buf);
}

int mkdir(string_t pathname, mode_t mode) {
  return Cstat::mkdir(s2c(pathname), mode);
}

int chmod(string_t pathname, mode_t mode) {
  return Cstat::chmod(s2c(pathname),mode);
}
}

/* Some definitions taken from the GNU C Library, released under LGPL:
   Copyright (C) 1991-1999, 2000 Free Software Foundation, Inc. */

#include <stdio.h>
#include <string.h> // for strcpy

namespace Cstdio {
extern "C" {
extern struct __abstractFILE;
typedef struct Cstdio::__abstractFILE __cFILE;
int remove(Cstring);
int rename(Cstring, Cstring);
int fclose(__cFILE @`r);
int fflush(__cFILE *`r);
__cFILE *fopen (Cstring __filename, Cstring __modes);
__cFILE *freopen(Cstring __filename, Cstring __modes, __cFILE @__stream);
__cFILE *fdopen (int __fd, Cstring __modes);
int setvbuf (__cFILE @ __stream, Cstring __buf, int __modes, size_t __n);
  //NB: cygwin uses int as last arg of setbuffer, not size_t
void setbuffer (__cFILE @__stream, Cstring __buf, size_t __size);
void setlinebuf (__cFILE @__stream);
int fgetc(__cFILE @__stream);
int getc(__cFILE @__stream);
int fputc(int __c, __cFILE @__stream);
int putc(int __c, __cFILE @__stream);
int getw(__cFILE @__stream);
int putw(int __w, __cFILE @__stream);
Cstring fgets(Cstring __s, int __n, __cFILE @__stream);
Cstring gets(Cstring __s);
int fputs(Cstring __s, __cFILE @__stream);
int puts(Cstring __s);
int ungetc(int __c, __cFILE @__stream);
size_t fread(Cstring __ptr,size_t __size,size_t __n,__cFILE @__stream);
size_t fwrite(Cstring __ptr,size_t __size,size_t __n,__cFILE @__s);
int fseek(__cFILE @__stream, long __off, int __whence);
long ftell(__cFILE @__stream);
void rewind(__cFILE @__stream);
int fgetpos(__cFILE @__stream, fpos_t @__pos);
int fsetpos(__cFILE @__stream, fpos_t @__pos);
void clearerr(__cFILE @__stream);
int feof(__cFILE @__stream);
int ferror(__cFILE @__stream);
void perror(Cstring __s);
int fileno(__cFILE @__stream);
__cFILE *popen(Cstring, Cstring);
int pclose(__cFILE @__stream);
#define s2c(x) (string_to_Cstring(x))
//  #define static_c2s(x) (Cstring_to_string(x))
#define static_c2s(x) (wrap_Cstring_as_string(x,-1))
}}

namespace Std {

abstract struct __cycFILE {
  Cstdio::__cFILE *file; // Mirror any changes in cstubs.c
};

FILE*`H fromCfile(Cstdio::__cFILE *`H cf) {
  return cf ? new __cycFILE(cf) : NULL;
}

int remove(const char ?`r filename) {
  return Cstdio::remove(s2c(filename));
}

int rename(const char ?`r1 old_filename, const char ?`r2 new_filename) {
  return Cstdio::rename(s2c(old_filename), s2c(new_filename));
}

int fclose(FILE @`r f) {
  int r = Cstdio::fclose((Cstdio::__cFILE @) f->file);
  if (r == 0) {
    f->file = NULL;
  }
  return r;
}

int fflush(FILE *`r f) {
  // This works even if f->file == NULL; there's no implicit NULL check.
  return f ? Cstdio::fflush(f->file) : Cstdio::fflush(NULL);
}

FILE *freopen(const char ?`r1 x, const char ?`r2 y, FILE @`r3 f) {
  Cstdio::__cFILE *cf = Cstdio::freopen(s2c(x), s2c(y),
                                               (Cstdio::__cFILE @) f->file);
  return cf ? new __cycFILE(cf) : NULL;
}

void setbuf(FILE @`r1 f, char ?`r2 buf) {
  setvbuf(f, buf, buf ? _IOFBF : _IONBF, BUFSIZ);
}

void setbuffer(FILE @`r1 f, char ?`r2 buf, size_t size) {
  setvbuf(f, buf, buf ? _IOFBF : _IONBF, size);
}

void setlinebuf(FILE @`r f) {
  setvbuf(f, NULL, _IOLBF, 0);
}

int setvbuf(FILE @`r1 f, char ?`r2 buf, int mode, size_t size) {
  if (buf.size < size)
    throw new Failure("setvbuf: buffer insufficient");
  return Cstdio::setvbuf((Cstdio::__cFILE @) f->file,
                         underlying_Cstring(buf),
                         mode, size);
}

int fgetc(FILE @`r f) { return Cstdio::fgetc((Cstdio::__cFILE @) f->file); }

char ?`r fgets(char ?`r s, int n, FILE @`r2 f) {
  Cstring result;
  Cstring buffer = underlying_Cstring(s); 
  unsigned int len = s.size;
  n = (len < n) ? len : n;
  result = Cstdio::fgets(buffer, n, (Cstdio::__cFILE @) f->file);
  if (result == NULL) 
    return NULL;
  else 
    return s;
}

int fputc(int i, FILE @`r f) {
  return Cstdio::fputc(i, (Cstdio::__cFILE @) f->file);
}

int fputs(const char ?`r1 s, FILE @`r2 f) {
  return Cstdio::fputs(s2c(s), (Cstdio::__cFILE @) f->file);
}

int getc(FILE @`r f) { return Cstdio::getc((Cstdio::__cFILE @) f->file); }

int putc(int i, FILE @`r f) {
  return Cstdio::putc(i, (Cstdio::__cFILE @) f->file);
}

int puts(const char ?`r s) { return Cstdio::puts(s2c(s)); }

int ungetc(int i, FILE @`r f) {
  return Cstdio::ungetc(i,(Cstdio::__cFILE @) f->file);
}

size_t fread(char ?`r1 ptr, size_t size, size_t nmemb, FILE @`r2 f) {
  if (size * nmemb > ptr.size)
    throw new Failure("fread: buffer insufficient");
  return Cstdio::fread(underlying_Cstring(ptr), size, nmemb,
                       (Cstdio::__cFILE @) f->file);
}

size_t fwrite(const char ?`r1 ptr, size_t size, size_t nmemb, FILE @`r2 f) {
  if (size * nmemb > ptr.size)
    throw new Failure("fwrite: buffer insufficient");
  return Cstdio::fwrite(underlying_Cstring(ptr), size, nmemb,
                        (Cstdio::__cFILE @) f->file);
}

int fgetpos(FILE @`r1 f, fpos_t @`r2 x) {
  return Cstdio::fgetpos((Cstdio::__cFILE @) f->file,x);
}

int fseek(FILE @`r f, long offset, int whence) {
  return Cstdio::fseek((Cstdio::__cFILE @) f->file,offset,whence);
}

int fsetpos(FILE @`r f, fpos_t @`r2 x) {
  return Cstdio::fsetpos((Cstdio::__cFILE @) f->file,x);
}

long ftell(FILE @`r f) { return Cstdio::ftell((Cstdio::__cFILE @) f->file); }

void rewind(FILE @`r f) { Cstdio::rewind((Cstdio::__cFILE @) f->file); }

void clearerr(FILE @`r f) { Cstdio::clearerr((Cstdio::__cFILE @) f->file); }

int feof(FILE @`r f) { return Cstdio::feof((Cstdio::__cFILE @) f->file); }

int ferror(FILE @`r f) {
  return Cstdio::ferror((Cstdio::__cFILE @) f->file);
}

void perror(const char ?`r s) { Cstdio::perror(s2c(s)); }

FILE *fopen(const char ?`r1 name, const char ?`r2 type) {
  Cstdio::__cFILE *cf = Cstdio::fopen(s2c(name), s2c(type));
  return cf ? new __cycFILE(cf) : NULL;
}

FILE *fdopen(int i, const char ?`r1 s) {
  Cstdio::__cFILE *cf = Cstdio::fdopen(i,s2c(s));
  return cf ? new __cycFILE(cf) : NULL;
}

int fileno(FILE @`r f) { return Cstdio::fileno((Cstdio::__cFILE @) f->file); }

int getw(FILE @`r f) { return Cstdio::getw((Cstdio::__cFILE @) f->file); }

int pclose(FILE @`r f) { return Cstdio::pclose((Cstdio::__cFILE @) f->file); }

FILE *popen(const char ? s, const char ? m) {
  Cstdio::__cFILE *cf = Cstdio::popen(s2c(s),s2c(m));
  return (cf ? new __cycFILE(cf) : NULL);
}

int putw(int i, FILE @`r f) {
  return Cstdio::putw(i,(Cstdio::__cFILE @) f->file);
}

xtunion exn { 
  FileOpenError(const char ?); 
  FileCloseError;
};

FILE @ file_open(const char ?`r1 fname, const char ?`r2 mode) {
  FILE *f = fopen(fname, mode);
  if (f == NULL) {
    const char ? fn = new {for i < fname.size : fname[i]};
    throw new FileOpenError(fn);
  }
  return (FILE @)f; // FIX: get rid of cast?
}

void file_close(FILE @`r f) {
  if (fclose(f) != 0) throw FileCloseError;
}
}

#include <stdlib.h>
#include <array.h>

namespace Cstdlib {
  extern "C" {
    double atof(const Cstring);
    int atoi(const Cstring);
    long atol(const Cstring);
    Cstring getenv(const Cstring);
    int putenv(const Cstring);
    double strtod(Cstring, Cstring *`r);
    long strtol(Cstring, Cstring *`r, int);
    unsigned long strtoul(Cstring, Cstring *`r, int);
    void qsort(`a::A *base, size_t nmemb, size_t size,
	       int (*compar)(const `a@, const `a@));

    int system(Cstring);
#define s2c(x) (string_to_Cstring(x))
  }
}

namespace Std {
  double atof(const char ?`r _nptr) {
    return Cstdlib::atof(s2c(_nptr));
  }
  int atoi(const char ?`r _nptr) {
    return Cstdlib::atoi(s2c(_nptr));
  }
  long atol(const char ?`r _nptr) {
    return Cstdlib::atol(s2c(_nptr));
  }
  mstring_t getenv(string_t name) {
    return Cstring_to_string(Cstdlib::getenv(s2c(name)));
  }
  int putenv(string_t s) {
    return Cstdlib::putenv(s2c(s));
  }
  static void check_valid_cstring(const char ?`r s) {
    if (s == NULL) throw new Invalid_argument("strtox NULL pointer");
    bool found_zero = false;
    for (int i = s.size - 1; i >= 0; i--)
      if (s[i] == '\0') { found_zero = true; break; }
    if (!found_zero) throw new Invalid_argument("strtox: not a C string");
  }

  double strtod(const char ?`r nptr, const char ?`r *`r2 endptr) {
    // need to ensure that the string has a '\0' in it before
    // handing it off to C.
    check_valid_cstring(nptr);
    // FIX:  TOTAL HACK ALERT
    Cstring c = underlying_Cstring(nptr); // so far so good
    Cstring e = (endptr == NULL) ? NULL : c;
    double d = Cstdlib::strtod(c, &e);
    if (endptr != NULL) {
      // need to adjust the endptr -- the best we can do is calculate
      // the diff between e and c.  And our pointer arithmetic doesn't
      // support subtraction on * types.  So I'm casting to unsigned int.
      int n = (unsigned int)e - (unsigned int)c;
      *endptr = nptr + n;
    }
    return d;
  }

  long strtol(const char ?`r n, const char ?`r *`r2 endptr, int base) {
    // need to ensure that the string has a '\0' in it before
    // handing it off to C.
    check_valid_cstring(n);
    // FIX:  TOTAL HACK ALERT
    Cstring c = underlying_Cstring(n); // so far so good
    Cstring e = (endptr == NULL) ? NULL : c;
    long r = Cstdlib::strtol(c, &e, base);
    if (endptr != NULL) {
      // need to adjust the end -- the best we can do is calculate
      // the diff between e and c.  And our pointer arithmetic doesn't
      // support subtraction on * types.  So I'm casting to unsigned int.
      int m = (unsigned int)e - (unsigned int)c;
      *endptr = n + m;
    }
    return r;
  }

  unsigned long strtoul(const char ?`r n,const char ?`r *`r2 endptr,int base){
    // need to ensure that the string has a '\0' in it before
    // handing it off to C.
    check_valid_cstring(n);
    // FIX:  TOTAL HACK ALERT
    Cstring c = underlying_Cstring(n); // so far so good
    Cstring e = (endptr == NULL) ? NULL : c;
    unsigned long r = Cstdlib::strtoul(c, &e, base);
    if (endptr != NULL) {
      // need to adjust the end -- the best we can do is calculate
      // the diff between e and c.  And our pointer arithmetic doesn't
      // support subtraction on * types.  So I'm casting to unsigned int.
      int m = (unsigned int)e - (unsigned int)c;
      *endptr = n + m;
    }
    return r;
  }

  unsigned long mstrtoul(char ?`r n,char ?`r *`r2 endptr,int base){
    // need to ensure that the string has a '\0' in it before
    // handing it off to C.
    check_valid_cstring(n);
    // FIX:  TOTAL HACK ALERT
    Cstring c = underlying_Cstring(n); // so far so good
    Cstring e = (endptr == NULL) ? NULL : c;
    unsigned long r = Cstdlib::strtoul(c, &e, base);
    if (endptr != NULL) {
      // need to adjust the end -- the best we can do is calculate
      // the diff between e and c.  And our pointer arithmetic doesn't
      // support subtraction on * types.  So I'm casting to unsigned int.
      int m = (unsigned int)e - (unsigned int)c;
      *endptr = n + m;
    }
    return r;
  }

  /*
  void qsort<`a::B,`r::R>(`a ?`r tab, size_t nmemb, size_t szmemb, 
		       Array::cmpfn_t<`a,`r,`r> compfn) {
    Array::qsort(compfn, tab, nmemb);
  }
  */
  void qsort<`a::A,`r::R>(`a ?`r tab, size_t nmemb, sizeof_t<`a> szmemb, 
			    int (@`H compar)(const `a@`r, const `a@`r)) {
    if(tab==NULL || tab.size < nmemb) 
      throw new Invalid_argument("Std::qsort");
    Cstdlib::qsort((_*)tab,nmemb,szmemb,compar);
  }

  int system(string_t cmd) {
    return Cstdlib::system(s2c(cmd));
}

// A no-op. 
  void free(`a::A ? ptr) {}
}

#include <string.h>
#include <stdio.h>
#include <sys/socket.h>

namespace Std {

namespace Csocket {
  extern "C" {
    /* Later we'll add, e.g., accept_in6, bind_in6, etc. */
    int accept(int, const struct sockaddr @, socklen_t @);
    int accept_in(int, const struct sockaddr_in @, socklen_t @);
    int bind(int, const struct sockaddr @, socklen_t);
    int bind_in(int, const struct sockaddr_in @, socklen_t);
    int connect(int, const struct sockaddr @, socklen_t);
    int connect_in(int, const struct sockaddr_in @, socklen_t);
    int getpeername(int, const struct sockaddr @, socklen_t @);
    int getpeername_in(int, const struct sockaddr_in @, socklen_t @);
    int getsockname(int, const struct sockaddr @, socklen_t @);
    int getsockname_in(int, const struct sockaddr_in @, socklen_t @);
    ssize_t recvfrom(int, char ?, size_t, int,
                        const struct sockaddr @, socklen_t @);
    ssize_t recvfrom_in(int, char ?, size_t, int,
                        const struct sockaddr_in @, socklen_t @);
    ssize_t sendto(int, const char ?, size_t, int,
                      const struct sockaddr @, socklen_t);
    ssize_t sendto_in(int, const char ?, size_t, int,
                      const struct sockaddr_in @, socklen_t);

    ssize_t send_wrapped(int, const char ?, size_t, int);
    ssize_t recv_wrapped(int, char ?, size_t, int);

    /* Add: _linger, _in_addr, _u_char, _ip_mreq, _sockaddr, etc. */
    int getsockopt_int(int, int, int, int @, socklen_t @);
    int setsockopt_int(int, int, int, const int @, socklen_t);
    int getsockopt_timeval(int, int, int, struct timeval @, socklen_t @);
    int setsockopt_timeval(int, int, int, const struct timeval @, socklen_t);
  }  
}

xtunion exn { SocketError(string_t); };

static mstring_t<`H> sopts2string(SO ?args) {
  mstring_t<`H> res = new { '\0' };
  for (int i = 0; i<args.size; i++) {
    switch (args[i]) {
    case &SO_int(_):
      res = strconcat(res,"|SO_int");
      break;
    case &SO_timeval(_):
      res = strconcat(res,"|SO_timeval");
      break;
    case &SO_socklenptr(_):
      res = strconcat(res,"|SO_socklenptr");
      break;
    case &SO_socklen(_):
      res = strconcat(res,"|SO_socklen");
      break;
    }
  }
  return res;
}

int accept(int fd, ... inject SA ap) {
  if (ap.size != 2) throw new SocketError("accept---need 2 args");
  switch ($(ap[0],ap[1])) {
  case $(&SA_sockaddr_in(x),&SA_socklenptr(y)):
    return Csocket::accept_in(fd,x,y);
  case $(&SA_sockaddr(x),&SA_socklenptr(y)):
    return Csocket::accept(fd,x,y);
  default: throw new SocketError("accept---bad args");
  }
}

int bind(int fd, ... inject SA ap) {
  if (ap.size != 2) throw new SocketError("bind---need 2 args");
  switch ($(ap[0],ap[1])) {
  case $(&SA_sockaddr_in(x),&SA_socklen(y)):
    return Csocket::bind_in(fd,x,y);
  case $(&SA_sockaddr(x),&SA_socklen(y)):
    return Csocket::bind(fd,x,y);
  default: throw new SocketError("bind---bad args");
  }
}

int connect(int fd, ... inject SA ap) {
  if (ap.size != 2) throw new SocketError("connect---need 2 args");
  switch ($(ap[0],ap[1])) {
  case $(&SA_sockaddr_in(x),&SA_socklen(y)):
    return Csocket::connect_in(fd,x,y);
  case $(&SA_sockaddr(x),&SA_socklen(y)):
    return Csocket::connect(fd,x,y);
  default: throw new SocketError("connect---bad args");
  }
}

int getpeername(int fd, ... inject SA ap) {
  if (ap.size != 2) throw new SocketError("getpeername---need 2 args");
  switch ($(ap[0],ap[1])) {
  case $(&SA_sockaddr_in(x),&SA_socklenptr(y)):
    return Csocket::getpeername_in(fd,x,y);
  case $(&SA_sockaddr(x),&SA_socklenptr(y)):
    return Csocket::getpeername(fd,x,y);
  default: throw new SocketError("getpeername---bad args");
  }
}

int getsockname(int fd, ... inject SA ap) {
  if (ap.size != 2) throw new SocketError("getsockname---need 2 args");
  switch ($(ap[0],ap[1])) {
  case $(&SA_sockaddr_in(x),&SA_socklenptr(y)):
    return Csocket::getsockname_in(fd,x,y);
  case $(&SA_sockaddr(x),&SA_socklenptr(y)):
    return Csocket::getsockname(fd,x,y);
  default: throw new SocketError("getsockname---bad args");
  }
}

ssize_t recvfrom(int fd, char ?buf, size_t n, int flags, ... inject SA ap) {
  if (ap.size != 2) throw new SocketError("recvfrom---need 2 args");
  switch ($(ap[0],ap[1])) {
  case $(&SA_sockaddr_in(x),&SA_socklenptr(y)):
    return Csocket::recvfrom_in(fd,buf,n,flags,x,y);
  case $(&SA_sockaddr(x),&SA_socklenptr(y)):
    return Csocket::recvfrom(fd,buf,n,flags,x,y);
  default: throw new SocketError("recvfrom---bad args");
  }
}

ssize_t sendto(int fd, const char ?buf, size_t n, int flags,
               ... inject SA ap) {
  if (ap.size != 2) throw new SocketError("sendto---need 2 args");
  switch ($(ap[0],ap[1])) {
  case $(&SA_sockaddr_in(x),&SA_socklen(y)):
    return Csocket::sendto_in(fd,buf,n,flags,x,y);
  case $(&SA_sockaddr(x),&SA_socklen(y)):
    return Csocket::sendto(fd,buf,n,flags,x,y);
  default: throw new SocketError("sendto---bad args");
  }
}

ssize_t send(int fd, const char ?buf, size_t n, int flags) {
  return Csocket::send_wrapped(fd,buf,n,flags);
}

ssize_t recv(int fd, char ?buf, size_t n, int flags) {
  return Csocket::recv_wrapped(fd,buf,n,flags);
}

int getsockopt(int fd, int level, int optname, ... inject SO ap) {
  if (ap.size != 2) throw new SocketError("getsockopt---need 2 args");
  switch ($(ap[0],ap[1])) {
  case $(&SO_int(x),&SO_socklenptr(y)):
    return Csocket::getsockopt_int(fd,level,optname,x,y);
  /* FIX: shouldn't have to do this */
  case $(&SO_int(x),&SO_int(y)):
    return Csocket::getsockopt_int(fd,level,optname,x,(socklen_t @)y);
  case $(&SO_timeval(x),&SO_socklenptr(y)):
    return Csocket::getsockopt_timeval(fd,level,optname,x,y);
  /* FIX: shouldn't have to do this */
  case $(&SO_timeval(x),&SO_int(y)):
    return Csocket::getsockopt_timeval(fd,level,optname,x,(socklen_t @)y);
  default: throw new SocketError(aprintf("getsockopt---bad args %s",
					 sopts2string(ap)));
  }
}

int setsockopt(int fd, int level, int optname, ... inject SO ap) {
  if (ap.size != 2) throw new SocketError("setsockopt---need 2 args");
  switch ($(ap[0],ap[1])) {
  case $(&SO_int(x),&SO_socklen(y)):
    return Csocket::setsockopt_int(fd,level,optname,x,y);
  case $(&SO_timeval(x),&SO_socklen(y)):
    return Csocket::setsockopt_timeval(fd,level,optname,x,y);
  default: throw new SocketError(aprintf("getsockopt---bad args %s",
					 sopts2string(ap)));
  }
}
}

#include <time.h>
#include <sys/time.h>
#include <string.h>

namespace Ctime {
  extern "C" {
    Cstring<`H> asctime(const struct tm @`r timeptr);
    Cstring<`H> ctime(const time_t @`r timep);
    size_t strftime(Cstring s, size_t maxsize, const Cstring fmt,
                    const struct tm @`r t);
    Cstring<`r2> asctime_r(const struct tm @`r, Cstring<`r2>);
    Cstring<`r2> ctime_r(const time_t @`r, Cstring<`r2>);
  }
//  #define static_c2s(x) (Cstring_to_string(x))
#define static_c2s(x) (wrap_Cstring_as_string(x,-1))
}

namespace Std {

mstring_t asctime(const struct tm @`r timeptr) {
  return static_c2s(Ctime::asctime(timeptr));
}

mstring_t ctime(const time_t @`r timep) {
  return static_c2s(Ctime::ctime(timep));
}

size_t strftime(string_t s, size_t maxsize, string_t fmt,
                const struct tm @`r t) {
  size_t m = (s.size < maxsize) ? s.size : maxsize;
  return Ctime::strftime(underlying_Cstring(s),m,
                         underlying_Cstring(fmt),t);
}

// FIX: should check that s is long enough
mstring_t<`H> asctime_r(const struct tm @`r t, mstring_t<`H> s) {
//    if (s.size < 50) 
//      throw new Invalid_argument("Time::asctime_r: string too small (< 50)");
//    return Cstring_to_string(Ctime::asctime_r(t,underlying_Cstring(s)));
  let sr = static_c2s(Ctime::asctime(t));
  if (strlen(sr)+1 > s.size)
    throw new Invalid_argument("Time::asctime_r: string too small");
  else {
    strcpy(s,sr);
    return s;
  }
}

mstring_t<`H> ctime_r(const time_t @`r t, mstring_t<`H> s) {
  let sr = static_c2s(Ctime::ctime(t));
  if (strlen(sr)+1 > s.size)
    throw new Invalid_argument("Time::ctime_r: string too small");
  else {
    strcpy(s,sr);
    return s;
  }
//    if (s.size < 50) 
//      throw new Invalid_argument("Time::ctime_r: string too small (< 50)");
//    return Cstring_to_string(Ctime::ctime_r(t,underlying_Cstring(s)));
}
}

#include <unistd.h>

namespace Cunistd {
  extern "C" {
    int access(Cstring,int);
    int chdir(Cstring);
    int chown(Cstring,uid_t,gid_t);
    Cstring<`r> getcwd(Cstring<`r> buf, size_t size);
    int execv(Cstring path, Cstring *argv);
    int execvp(Cstring file, Cstring *argv);
    int execve(Cstring path, Cstring *argv, Cstring *envp);
    int link(Cstring path1, Cstring path2);
    ssize_t read(int fd, Cstring buf, size_t count);
    int rmdir(Cstring);
    int symlink(Cstring path1, Cstring path2);
    int truncate(Cstring,off_t);
    ssize_t write(int fd, Cstring buf, size_t count);
    int unlink(Cstring pathname);
    int gethostname(Cstring,size_t);
    int chroot(Cstring);
    Cstring getpass(const Cstring);
  }
}
//  #define static_c2s(x) (Cstring_to_string(x))
#define static_c2s(x) (wrap_Cstring_as_string(x,-1))

namespace Std {

int access(string_t path, int mode) {
  return Cunistd::access(string_to_Cstring(path),mode);
}

int chdir(string_t path) {
  return Cunistd::chdir(string_to_Cstring(path));
}

int chown(string_t path, uid_t owner, gid_t group) {
  return Cunistd::chown(string_to_Cstring(path),owner,group);
}

char ?`r getcwd(char ?`r buf, size_t size) {
  if (!buf || buf.size < size) {
    throw new Failure("getcwd: invalid buf argument");
  }
  Cstring response = Cunistd::getcwd((Cstring)buf, size);
  return response ? buf : NULL;
}

// This is untested; I'd be surprised if it actually works
int execl(string_t path, string_t arg0, ... string_t argv) {
  if (argv[argv.size - 1] != NULL)
    throw new Failure("execl: arg list must be NULL-terminated");

  // We allocate 1+argv.size because we need to prepend arg0
  Cstring ?newargs = new {for i < 1 + argv.size : NULL};
  newargs[0] = string_to_Cstring(arg0);
  for (int i = 0; i < argv.size; i++)
    newargs[i+1] = string_to_Cstring(argv[i]);
  return Cunistd::execv(string_to_Cstring(path), (Cstring*) newargs);
}

int execlp(string_t path, string_t arg0, ... string_t argv) {
  if (argv[argv.size - 1] != NULL)
    throw new Failure("execl: arg list must be NULL-terminated");

  // We allocate 1+argv.size because we need to prepend arg0
  Cstring ?newargs = new {for i < 1 + argv.size : NULL};
  newargs[0] = string_to_Cstring(arg0);
  for (int i = 0; i < argv.size; i++)
    newargs[i+1] = string_to_Cstring(argv[i]);
  return Cunistd::execvp(string_to_Cstring(path), (Cstring*) newargs);
}

int execve(string_t filename, mstring_t ?argv, mstring_t ?envp) {
  if (argv[argv.size - 1] != NULL)
    throw new Failure("execve: arg list must be NULL-terminated");

  Cstring ?newargs = new {for i < argv.size : NULL};
  for (int i = 0; i < argv.size; i++)
    newargs[i] = string_to_Cstring(argv[i]);

  Cstring ?newenvp = new {for i < envp.size : NULL};
  for (int i = 0; i < envp.size; i++)
    newenvp[i] = string_to_Cstring(envp[i]);

  return Cunistd::execve(string_to_Cstring(filename),
                         (Cstring*) newargs, (Cstring*) newenvp);
}

int link(string_t path1,string_t path2) {
  return Cunistd::link(string_to_Cstring(path1),string_to_Cstring(path2));
}

ssize_t read(int fd, mstring_t buf, size_t count) {
  if (count > buf.size)
    throw new Failure("read: called with count > buf.size");
  return Cunistd::read(fd, underlying_Cstring(buf), count);
}

int rmdir(string_t path) {
  return Cunistd::rmdir(string_to_Cstring(path));
}

int symlink(string_t path1,string_t path2) {
  return Cunistd::symlink(string_to_Cstring(path1),string_to_Cstring(path2));
}

int truncate(string_t path, off_t length) {
  return Cunistd::truncate(string_to_Cstring(path),length);
}

ssize_t write(int fd, string_t buf, size_t count) {
  if (count > buf.size)
    throw new Failure("write: called with count > buf.size");
  return Cunistd::write(fd, underlying_Cstring(buf), count);
}

int unlink(string_t pathname) {
  return Cunistd::unlink(string_to_Cstring(pathname));
}

int gethostname(mstring_t buf, size_t count) {
  if (count > buf.size)
    throw new Failure("gethostname: called with count > buf.size");
  return Cunistd::gethostname(underlying_Cstring(buf), count);
}

int chroot(string_t pathname) {
  return Cunistd::chroot(string_to_Cstring(pathname));
}

char ?getpass(const char? prompt) {
  return static_c2s(Cunistd::getpass(string_to_Cstring(prompt)));
}
}

#include <utime.h>

namespace Cutime {
  extern "C" {
    int utime(Cstring filename, struct utimbuf* buf);
  }
}

namespace Std {
int utime(string_t filename, struct utimbuf* buf) {
  return Cutime::utime(Core::string_to_Cstring(filename),buf);
}
}
