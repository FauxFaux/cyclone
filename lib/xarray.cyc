/* This file is part of the Cyclone Library.
   Copyright (C) 2001 Greg Morrisett, AT&T

   This library is free software; you can redistribute it and/or it
   under the terms of the GNU Lesser General Public License as
   published by the Free Software Foundation; either version 2.1 of
   the License, or (at your option) any later version.

   This library is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with this library; see the file COPYING.LIB.  If not,
   write to the Free Software Foundation, Inc., 59 Temple Place, Suite
   330, Boston, MA 02111-1307 USA. */

#include <core.h>
#include <xarray.h>

namespace Xarray;
using Core;

int length(xarray_t<`a> xarr) {
  return xarr->num_elmts;
}

`a get(xarray_t<`a> xarr, int i) {
  if (i < 0 || i >= xarr->num_elmts)
    throw new InvalidArg("Xarray::get: bad index");
  return xarr->elmts[i];
}

void set(xarray_t<`a> xarr, int i, `a a) {
  if (i < 0 || i >= xarr->num_elmts)
    throw new InvalidArg("Xarray::set: bad index");
  xarr->elmts[i] = a;
}

xarray_t<`a> create_empty() {
  `a ?x = new { };
  return new Xarray{.elmts=x,.num_elmts=0};
}

 // create an xarray with zero elements, but space for len elements
xarray_t<`a> create(int len, `a a) {
  if (len < 0)
    throw new InvalidArg("xarrays must have a non-negative size buffer");
  return new Xarray{.elmts=new {for i < len : a}, .num_elmts=0};
}

xarray_t<`a> singleton(int len, `a a) {
  if(len<1) throw new InvalidArg("singleton xarray must have size >=1");
  xarray_t<`a> x = create(len,a);
  x->num_elmts=1;
  return x;
}

void add(xarray_t<`a> xarr, `a a) {
  if (xarr->num_elmts == (xarr->elmts).size) {
    if (xarr->num_elmts == 0)
      xarr->elmts = new {for i < 10 : a};
    else {
      `a ?newarr = new {for i < xarr->num_elmts*2 : xarr->elmts[0]};
      for (int i=1; i < xarr->num_elmts; ++i)
        newarr[i] = xarr->elmts[i];
      xarr->elmts = newarr;
    }
  }
  xarr->elmts[xarr->num_elmts++] = a;
}

int add_ind(xarray_t<`a> xarr, `a a) {
  add(xarr,a);
  return xarr->num_elmts-1;
}

`a ?to_array(xarray_t<`a> xarr) {
  if (xarr->num_elmts == 0)
    return new {};
  `a ?ans = new {for i < xarr->num_elmts : xarr->elmts[i]};
  return ans;
}

xarray_t<`a> from_array(`a ?arr) {
  if (arr.size == 0)
    return create_empty();
  xarray_t<`a> ans = new Xarray{.elmts=new {for i<arr.size : arr[i]},
                                   .num_elmts=arr.size};
  return ans;
}

// append is functional -- it creates a new xarray every time
xarray_t<`a> append(xarray_t<`a> xarr1, xarray_t<`a> xarr2) {
  int newsz = (xarr1->elmts).size + (xarr2->elmts).size;
  if(newsz == 0)
    return create_empty();
  `a init = (xarr1->elmts).size == 0 ? xarr2->elmts[0] : xarr1->elmts[0];
  xarray_t<`a> ans = new Xarray{.elmts=new {for i < newsz : init},
                                   .num_elmts=0};
  for(int i=0; i < xarr1->num_elmts; ++i)
    add(ans, xarr1->elmts[i]);
  for(int i=0; i < xarr2->num_elmts; ++i)
    add(ans, xarr2->elmts[i]);
  return ans;
}

void app(`b f(`a), xarray_t<`a> xarr) {
  for(int i=0; i<xarr->num_elmts; ++i)
    f(xarr->elmts[i]);
}

void app_c(`b f(`c,`a), `c env, xarray_t<`a> xarr) {
  for(int i=0; i<xarr->num_elmts; ++i)
    f(env, xarr->elmts[i]);
}

void iter(void f(`a), xarray_t<`a> xarr) {
  for(int i=0; i<xarr->num_elmts; ++i)
    f(xarr->elmts[i]);
}

void iter_c(void f(`c,`a), `c env, xarray_t<`a> xarr) {
  for(int i=0; i<xarr->num_elmts; ++i)
    f(env, xarr->elmts[i]);
}

xarray_t<`b> map(`b f(`a), xarray_t<`a> xarr) {
  if(xarr->num_elmts==0) return create_empty();

  xarray_t<`b> ans =
    new Xarray{.elmts=new {for i< (xarr->elmts).size : f(xarr->elmts[0])},
                  .num_elmts=xarr->num_elmts};
  for(int i=1; i<xarr->num_elmts; ++i)
    ans->elmts[i] = f(xarr->elmts[i]);
  return ans;
}

xarray_t<`b> map_c(`b f(`c,`a), `c env, xarray_t<`a> xarr) {
  if(xarr->num_elmts==0) return create_empty();

  xarray_t<`b> ans =
    new Xarray{.elmts=new {for i < (xarr->elmts).size : f(env,xarr->elmts[0])},
                  .num_elmts=xarr->num_elmts};
  for(int i=1; i<xarr->num_elmts; ++i)
    ans->elmts[i] = f(env, xarr->elmts[i]);
  return ans;
}

void reuse(xarray_t<`a> xarr) {
  xarr->num_elmts = 0;
}
