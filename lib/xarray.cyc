#include <core.h>
#include <xarray.h>

namespace Xarray;
using Core;

int length(xarray_t<`a> xarr) {
  return xarr->num_elmts;
}

`a get(xarray_t<`a> xarr, int i) {
  if (i < 0 || i >= xarr->num_elmts)
    throw new InvalidArg("Xarray::get: bad index");
  return xarr->elmts[i];
}

void set(xarray_t<`a> xarr, int i, `a a) {
  if (i < 0 || i >= xarr->num_elmts)
    throw new InvalidArg("Xarray::set: bad index");
  xarr->elmts[i] = a;
}

xarray_t<`a> create_empty() {
  `a ?x = new { };
  return new Xarray{.elmts=x,.num_elmts=0};
}

 // create an xarray with zero elements, but space for len elements
xarray_t<`a> create(int len, `a a) {
  if (len < 0)
    throw new InvalidArg("xarrays must have a non-negative size buffer");
  return new Xarray{.elmts=new {for i < len : a}, .num_elmts=0};
}

xarray_t<`a> singleton(int len, `a a) {
  if(len<1) throw new InvalidArg("singleton xarray must have size >=1");
  xarray_t<`a> x = create(len,a);
  x->num_elmts=1;
  return x;
}

void add(xarray_t<`a> xarr, `a a) {
  if (xarr->num_elmts == (xarr->elmts).size) {
    if (xarr->num_elmts == 0)
      xarr->elmts = new {for i < 10 : a};
    else {
      `a ?newarr = new {for i < xarr->num_elmts*2 : xarr->elmts[0]};
      for (int i=1; i < xarr->num_elmts; ++i)
        newarr[i] = xarr->elmts[i];
      xarr->elmts = newarr;
    }
  }
  xarr->elmts[xarr->num_elmts++] = a;
}

int add_ind(xarray_t<`a> xarr, `a a) {
  add(xarr,a);
  return xarr->num_elmts-1;
}

`a ?to_array(xarray_t<`a> xarr) {
  if (xarr->num_elmts == 0)
    return new {};
  `a ?ans = new {for i < xarr->num_elmts : xarr->elmts[i]};
  return ans;
}

xarray_t<`a> from_array(`a ?arr) {
  if (arr.size == 0)
    return create_empty();
  xarray_t<`a> ans = new Xarray{.elmts=new {for i<arr.size : arr[i]},
                                   .num_elmts=arr.size};
  return ans;
}

// append is functional -- it creates a new xarray every time
xarray_t<`a> append(xarray_t<`a> xarr1, xarray_t<`a> xarr2) {
  int newsz = (xarr1->elmts).size + (xarr2->elmts).size;
  if(newsz == 0)
    return create_empty();
  `a init = (xarr1->elmts).size == 0 ? xarr2->elmts[0] : xarr1->elmts[0];
  xarray_t<`a> ans = new Xarray{.elmts=new {for i < newsz : init},
                                   .num_elmts=0};
  for(int i=0; i < xarr1->num_elmts; ++i)
    add(ans, xarr1->elmts[i]);
  for(int i=0; i < xarr2->num_elmts; ++i)
    add(ans, xarr2->elmts[i]);
  return ans;
}

void app(`b f(`a), xarray_t<`a> xarr) {
  for(int i=0; i<xarr->num_elmts; ++i)
    f(xarr->elmts[i]);
}

void app_c(`b f(`c,`a), `c env, xarray_t<`a> xarr) {
  for(int i=0; i<xarr->num_elmts; ++i)
    f(env, xarr->elmts[i]);
}

void iter(void f(`a), xarray_t<`a> xarr) {
  for(int i=0; i<xarr->num_elmts; ++i)
    f(xarr->elmts[i]);
}

void iter_c(void f(`c,`a), `c env, xarray_t<`a> xarr) {
  for(int i=0; i<xarr->num_elmts; ++i)
    f(env, xarr->elmts[i]);
}

xarray_t<`b> map(`b f(`a), xarray_t<`a> xarr) {
  if(xarr->num_elmts==0) return create_empty();

  xarray_t<`b> ans =
    new Xarray{.elmts=new {for i< (xarr->elmts).size : f(xarr->elmts[0])},
                  .num_elmts=xarr->num_elmts};
  for(int i=1; i<xarr->num_elmts; ++i)
    ans->elmts[i] = f(xarr->elmts[i]);
  return ans;
}

xarray_t<`b> map_c(`b f(`c,`a), `c env, xarray_t<`a> xarr) {
  if(xarr->num_elmts==0) return create_empty();

  xarray_t<`b> ans =
    new Xarray{.elmts=new {for i < (xarr->elmts).size : f(env,xarr->elmts[0])},
                  .num_elmts=xarr->num_elmts};
  for(int i=1; i<xarr->num_elmts; ++i)
    ans->elmts[i] = f(env, xarr->elmts[i]);
  return ans;
}

void reuse(xarray_t<`a> xarr) {
  xarr->num_elmts = 0;
}
