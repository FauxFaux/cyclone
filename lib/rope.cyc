#include "rope.h"
#include "string.h"

namespace Rope;
using Core;

static enum R {
  String_rope(string),
  Array_rope(rope_t?)
};
abstract struct Rope_node {
  enum R v;
};

rope_t from_string(string s) {
  return new Rope_node{String_rope(s)};
}
rope_t concat(rope_t r1,rope_t r2) {
  return new Rope_node{Array_rope(new {r1,r2})};
}
rope_t concata(rope_t ?rs) {
  return new Rope_node(Array_rope(rs));
}
rope_t concatl(List::list_t<rope_t> l) {
  return new Rope_node(Array_rope(new {for i < List::length(l) : 
    ({rope_t r = l->hd; l = l->tl; r;})}));
}

uint length(rope_t r) {
  switch (r->v) {
  case String_rope(ss): return String::strlen(ss);
  case Array_rope(rs):
    uint total = 0, sz = rs.size;
    for (uint i = 0; i < sz; i++)
      total += length(rs[i]);
    return total;
  }
}

static uint flatten_it(string s, uint i, rope_t r) {
  switch (r->v) {
  case String_rope(ss):
    let len = String::strlen(ss);
    String::strncpy(s,i,ss,0,len);
    return i+len;
  case Array_rope(rs):
    let len = rs.size;
    for (int j = 0; j < len; j++)
      i = flatten_it(s,i,rs[j]);
    return i;
  }
}

string to_string(rope_t r) {
  string s = new_string(length(r));
  flatten_it(s,0,r);
  // memoize the flattening
  r->v = String_rope(s);
  return s;
}

int cmp(rope_t r1, rope_t r2) {
  return String::strcmp(to_string(r1), to_string(r2));
}
