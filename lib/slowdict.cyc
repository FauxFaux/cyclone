
// Port of the splay tree based dictionary implementation (c) Morrisett, Glew,
// Walker, Crary.
// Port by Dan, June 1999

#include "core.h"
#include "list.h"
#include "splay.h"
#include "slowdict.h"

namespace SlowDict;
using   Splay;

xenum exn {Absent,Present};

abstract struct Dict<`a,`b,`e::E> {
  int       (@reln)(`a,`a;`e);
  enum tree<`a,`b> tree;
};

// should be the commented out one, but unification is buggy
hdict_t<`a,`b,`e1> empty(int comp(`a,`a;`e1)) {
  enum tree<`a,`b> t = Leaf;
  return new Dict(comp, t);
}
//hdict_t<`a,`b,`e> empty(int comp(`a,`a)) {
//  return new Dict(comp, Leaf);
//}

bool is_empty(hdict_t<`a,`b,`e> d) {
  switch (d->tree) {
  case Leaf:    return true;
  case Node(_): return false;
  }
}

bool member(hdict_t<`a,`b,`e> d, `a key) {
  return splay(d->reln, key, d->tree);
}

hdict_t<`a,`b,`e> insert(hdict_t<`a,`b,`e> d, `a key, `b data) {
  enum tree<`a,`b> newleft = Leaf, newright = Leaf;
  if (splay(d->reln, key, d->tree)) {
    // we're functional, so have to make a new root node?
    switch (d->tree) {
    case Node(n):
      newleft     = n->v->left;
      newright    = n->v->right;
      break;
    default:
      break;
    }
  }
  else {
    switch (d->tree) {
    case Node(nr):
      let n = nr->v;
      if (d->reln(key,n->key) < 0) {
	newleft  = n->left;
	newright = Node(new noderef(new 
                                    node(n->key, n->data, Leaf, n->right)));
      } else {
	newleft  = Node(new noderef(new 
                                    node(n->key, n->data, n->left, Leaf)));
	newright = n->right;
      }
      break;
    case Leaf:
      break; // newleft and newright are already Leaf
    }
  }
  return new Dict(d->reln, Node(new 
                                noderef(new node(key,data,newleft,newright))));
}

hdict_t<`a,`b,`e> insert_new(hdict_t<`a,`b,`e> d, `a key, `b data) {
  // somewhat wasteful this way (makes two new top nodes)
  if (splay(d->reln, key, d->tree))
    throw Present;
  return insert(d, key, data);
}

hdict_t<`a,`b,`e> inserts(hdict_t<`a,`b,`e> d,
                          List::glist_t<$(`a,`b)@`r1,`r2> kds) {  
  for (; kds != null; kds = kds->tl)
    d = insert(d, (*kds->hd)[0], (*kds->hd)[1]);
  return d;
}

hdict_t<`a,`b,`e> singleton(int comp(`a,`a;`e),`a key,`b data) {
  return new Dict(comp, Node(new noderef(new node(key, data, Leaf, Leaf))));
}

`b lookup(hdict_t<`a,`b,`e> d,`a key) {
  if (splay(d->reln, key, d->tree))
    switch (d->tree) {
    case Node(nr): return nr->v->data;
    case Leaf:     throw Core::Impossible("Dict::lookup");
  }
  throw Absent;
}

Core::opt_t<`b> lookup_opt(hdict_t<`a,`b,`e> d,`a key) {
  if (splay(d->reln, key, d->tree))
    switch (d->tree) {
    case Node(nr): return new Core::Opt(nr->v->data);
    case Leaf:     throw Core::Impossible("Dict::lookup");
  }
  return null;
}

static int get_largest(`a x, `a y) { return 1; }

hdict_t<`a,`b,`e> delete(hdict_t<`a,`b,`e> d,`a key) {
  if (splay(d->reln, key, d->tree))
    switch (d->tree) {
    case Leaf: throw Core::Impossible("Dict::lookup");
    case Node(nr):
      struct node<`a,`b> @n = nr->v;
      switch (n->left) {
      case Leaf:    return new Dict(d->reln, n->right);
      case Node(noderef_left): 
	switch (n->right) {
	case Leaf:    return new Dict(d->reln, n->left);
	case Node(node_ref_right): 
	  splay(get_largest, key, n->left);
	  struct node<`a,`b> @newtop = noderef_left->v; // splay changes this
	  return new Dict(d->reln,
		       Node(new noderef(new node(newtop->key, newtop->data,
                                                 newtop->left, n->right))));
	}
      }
  }
  else
    return d;
}
      
hdict_t<`a,`b,`e> delete_present(hdict_t<`a,`b,`e> d,`a key) {
  let d2 = delete(d,key);
  if (d == d2)
    throw Absent;
  return d2;
}

static `c fold_tree(`c f(`a,`b,`c), enum tree<`a,`b> t, `c accum) {
  switch (t) {
  case Leaf: 
    return accum;
  case Node(nr): 
    struct node<`a,`b> @n = nr->v;
    return f(n->key, n->data, fold_tree(f, n->left, 
                                        fold_tree(f, n->right, accum)));
  }
}
`c fold(`c f(`a,`b,`c),hdict_t<`a,`b,`e> d,`c accum) {
  return fold_tree(f, d->tree, accum);
}

static `c fold_tree_c(`c f(`d,`a,`b,`c),`d env, enum tree<`a,`b> t,`c accum) {
  switch (t) {
  case Leaf: 
    return accum;
  case Node(nr): 
    struct node<`a,`b> @n = nr->v;
    return f(env, n->key, n->data,
             fold_tree_c(f,env,n->left,fold_tree_c(f,env,n->right,accum)));
  }
}
`c fold_c(`c f(`d,`a,`b,`c),`d env, hdict_t<`a,`b,`e> dict,`c accum) {
  return fold_tree_c(f,env,dict->tree,accum);
}

static void app_tree(`c f(`a,`b),enum tree<`a,`b> t) {
  switch (t) {
  case Leaf: break;
  case Node(nr):
    let n = nr->v;
    app_tree(f, n->left);
    f(n->key, n->data);
    app_tree(f, n->right);
    break;
  }
}
void app(`c f(`a,`b),hdict_t<`a,`b,`e> d) {
  app_tree(f,d->tree);
}

static void iter_tree(void f(`a,`b),enum tree<`a,`b> t) {
  switch (t) {
  case Leaf: break;
  case Node(nr):
    struct node<`a,`b> @n = nr->v;
    iter_tree(f, n->left);
    f(n->key, n->data);
    iter_tree(f, n->right);
    break;
  }
}
void iter(void f(`a,`b),hdict_t<`a,`b,`e> d) {
  iter_tree(f,d->tree);
}

static void app_tree_c(`c f(`d,`a,`b),`d env,enum tree<`a,`b> t) {
  switch (t) {
  case Leaf: break;
  case Node(nr):
    struct node<`a,`b> @n = nr->v;
    app_tree_c(f, env, n->left);
    f(env, n->key, n->data);
    app_tree_c(f, env, n->right);
    break;
  }
}
void app_c(`c f(`d,`a,`b),`d env,hdict_t<`a,`b,`e> d) {
  app_tree_c(f,env,d->tree);
}

static void iter_tree_c(void f(`c,`a,`b),`c env,enum tree<`a,`b> t) {
  switch (t) {
  case Leaf: break;
  case Node(nr):
    struct node<`a,`b> @n = nr->v;
    iter_tree_c(f, env, n->left);
    f(env, n->key, n->data);
    iter_tree_c(f, env, n->right);
    break;
  }
}
void iter_c(void f(`c,`a,`b),`c env,hdict_t<`a,`b,`e> d) {
  iter_tree_c(f,env,d->tree);
}

static enum tree<`a,`c> map_tree(`c f(`b), enum tree<`a,`b> t) {
  switch (t) {
  case Leaf: return Leaf;
  case Node(nr):
    let n = nr->v;
    return Node(new noderef(new node(n->key,
                                     f(n->data), 
                                     map_tree(f, n->left), 
                                     map_tree(f, n->right))));
  }
}
hdict_t<`a,`c,`e> map(`c f(`b), hdict_t<`a,`b,`e> d) {
  return new Dict(d->reln, map_tree(f, d->tree));
}

static enum tree<`a,`c> map_tree_c(`c f(`d,`b), `d env, enum tree<`a,`b> t) {
  switch (t) {
  case Leaf: return Leaf;
  case Node(nr):
    struct node<`a,`b> @n = nr->v;
    return Node(new noderef(new node(n->key, f(env, n->data), 
                                     map_tree_c(f, env, n->left), 
                                     map_tree_c(f, env, n->right))));
  }
}
hdict_t<`a,`c,`e> map_c(`c f(`d,`b), `d env, hdict_t<`a,`b,`e> d) {
  return new Dict(d->reln, map_tree_c(f, env, d->tree));
}

$(`a,`b)@ choose(hdict_t<`a,`b,`e> d) {
  switch (d->tree) {
  case Leaf:     throw Absent;
  case Node(nr): return new $(nr->v->key, nr->v->data);
  }
}

List::list_t<$(`a,`b)@> to_list_f(`a k, `b v, List::list_t<$(`a,`b)@> accum) {
  return new List::List(new $(k,v),accum);
}

List::list_t<$(`a,`b)@> to_list(hdict_t<`a,`b,`e> d) {
  return fold(to_list_f, d, null);
}

