
// Dan blatantly stole this from these guys:
/***********************************************************************)
(*                                                                     *)
(*                           Objective Caml                            *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************/
#include "stdio.h"
#include "string.h"
#include "arg.h"
namespace Arg;
using Core;
using Stdio;
using List;

xtunion exn {Error, Bad(string_t)};

tunion Spec<`e::E> {
  Unit_spec(void (@f)(;`e)),        // Call f with unit argument
  Flag_spec(void (@f)(string_t;`e)),  // Call f with flag argument
  FlagString_spec(void (@f)(string_t,string_t;`e)),
                                    // Call f with flag & string arguments
  Set_spec(bool@),                  // Set the reference to true
  Clear_spec(bool@),                // Set the reference to false
  String_spec(void (@f)(string_t;`e)),// Call f with a string argument
  Int_spec(void (@f)(int;`e)),      // Call f with an int argument
  Rest_spec(void (@f)(string_t;`e))   // Stop interpreting keywords and call the
                                    // function with each remaining argument
};

static tunion error {
  Unknown(string_t),
  Missing(string_t),
  Message(string_t),
    // option, actual, expected
  Wrong(string_t,string_t,string_t)  
};

static gspec_t<`e> lookup (glist_t<$(string_t,gspec_t<`e>,string_t)@`r1,`r2> l, 
                           string_t x) {
  while (l != null) {
    let flag = (*l->hd)[0];
    let len = String::strlen(flag);
    if (len > 0 && flag[len-1] == '*') {
      if (String::strncmp(x,(*l->hd)[0],len-1) == 0)
        return (*l->hd)[1];
    }
    else if (String::strcmp(x,(*l->hd)[0]) == 0)
      return (*l->hd)[1];
    l = l->tl;
  }
  throw Not_found;
}

void usage(glist_t<$(string_t,gspec_t<`e>,string_t)@`r1,`r2> speclist, 
           string_t errmsg) {
  fprintf(stderr, "%s\n", errmsg);
  while (speclist != null) {
    fprintf(stderr, " %s %s\n", (*speclist->hd)[0], (*speclist->hd)[2]);
    speclist = speclist->tl;
  }
}

int current = 0;
static string_t ?args = null;

static void stop(int prog_pos, tunion error e,
		 glist_t<$(string_t,gspec_t<`e>,string_t)@`r1,`r2> speclist, 
                 string_t errmsg) {
  string_t progname = prog_pos < args.size ? args[prog_pos] : "(?)";
  switch (e) {
  case &Unknown(s):
     if (String::strcmp(s,"-help")!=0)
       fprintf(stderr, "%s: unknown option `%s'.\n", progname, s);
     break;
  case &Missing(s):
     fprintf(stderr, "%s: option `%s' needs an argument.\n", progname, s);
     break;
  case &Wrong(flag,cmd,t):
     fprintf(stderr, "%s: wrong argument `%s'; option `%s' expects %s.\n",
             progname, cmd, flag, t);
     break;
  case &Message(s):
     fprintf(stderr, "%s: %s.\n", progname, s);
     break;
  }
  usage(speclist, errmsg);
  current = args.size; // skip everything else
}

void parse(glist_t<$(string_t,gspec_t<`e>,string_t)@`r1,`r2> speclist, 
           void anonfun(string_t),
	   string_t errmsg,
	   string_t ? orig_args) {
  args = orig_args;

  int initpos = current;
  int l       = args.size;
  ++current;
  while (current < l) {
    string_t s = args[current];
    if (s.size >= 1 && s[0] == '-') {
      gspec_t<`e> action;
      try action = lookup(speclist, s);
      catch {
      case Not_found: stop(initpos, new Unknown(s), speclist, errmsg); return;
      }
      try
	switch (action) {
	case &Unit_spec(f)  : f();        break;
	case &Flag_spec(f)  : f(s);       break;
	case &Set_spec(r)   : *r = true;  break;
	case &Clear_spec(r) : *r = false; break;
	case &FlagString_spec(f):
	  if (current+1 < l) {
	    f(s,args[current+1]);
	    ++current;
	  } else
	    stop(initpos, new Missing(s), speclist, errmsg);
	  break;
	case &String_spec(f):
	  if (current+1 < l) {
	    f(args[current+1]);
	    ++current;
	  } else
	    stop(initpos, new Missing(s), speclist, errmsg);
	  break;
	case &Int_spec(f):
	  string_t arg = args[current+1];
	  int n;
	  try n = int_of_string(arg);
	  catch {
	  case &InvalidArg(x):
	    stop(initpos,new Wrong(s,arg,"an integer"),speclist,errmsg);
	    return;
	  }
	  f(n);
	  ++current;
	  break;
	case &Rest_spec(f):
	  while (current < l-1) {
	    f(args[current+1]);
	    ++current;
	  }
	  break;
	}
      catch {
      case &Bad(s2): stop(initpos, new Message(s2), speclist, errmsg); break;
      }
      ++current;
    }
    else {
      try anonfun(s);
      catch {
      case &Bad(s2): stop(initpos, new Message(s2), speclist, errmsg); break;
      }
      ++current;
    }
  }
}
