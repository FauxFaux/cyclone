/* This file is part of the Cyclone Library.
   Copyright (C) 2000, 2001 Greg Morrisett, AT&T

   This library is free software; you can redistribute it and/or it
   under the terms of the GNU Lesser General Public License as
   published by the Free Software Foundation; either version 2.1 of
   the License, or (at your option) any later version.

   This library is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with this library; see the file COPYING.LIB.  If not,
   write to the Free Software Foundation, Inc., 59 Temple Place, Suite
   330, Boston, MA 02111-1307 USA. */


////////////////////////////////////////////////////////////////////////////
// Defines "closures" and operations on them                              //
////////////////////////////////////////////////////////////////////////////
#include <fn.h>

namespace Fn;

// JGM: you'll note that a lot of explicit abstraction and
// instantiation is necessary due to the shortcomings of the
// unifier...or my ability to figure out what effects to put
// on things.

struct Function<`arg,`res,`e1::E> { <`env>
  `res (@f)(`env,`arg;`e1);
  `env env;
  };

// make a closure out of a function pointer and environment
fn_t<`arg,`res,`e1> make_fn(`res f(`env,`arg;`e1), `env x;`e2) {
  return new Function(f,x);
}

static `res fp_apply(`res f(`arg;`e1), `arg x; `e1) {
  return f(x);
}

// convert a function pointer to a closure
fn_t<`arg,`res,`e1> fp2fn(`res f(`arg;`e1)) {
  return make_fn(fp_apply, f);
}

// apply closure f to argument x
`res apply(fn_t<`arg,`res,`eff> f, `arg x; `eff) {
  let &Function{<`env> code,env} = f;
  return code(env,x);
}

// heh, heh, heh:  try explaining this to your Mom...
static 
`c fn_compose<`a,`b,`c,`e1,`e2>
             ($(fn_t<`b,`c,`e1>, fn_t<`a,`b,`e2>)@`H f_and_g,`a arg;`e1+`e2) {
  let &$(f,g) = f_and_g;
  return apply(f,apply(g,arg));
}

// compose closures
fn_t<`a,`c,`e1+`e2> compose<`a,`b,`c,`e1,`e2,`e3>(fn_t<`a,`b,`e1> g, 
                                                  fn_t<`b,`c,`e2> f;
                                                  `e1+`e2+`e3) {
  return make_fn(fn_compose@<`a,`b,`c,`e2,`e1>,new $(f,g));
}


// These next two functions are used for curring
static `c inner($(fn_t<$(`a,`b)@`H,`c,`e1>,`a)@`H env, `b second;`e1) {
  return apply((*env)[0],new $((*env)[1],second));
}

static fn_t<`b,`c,`e1> outer(fn_t<$(`a,`b)@`H,`c,`e1> f,`a first; 
                             `e1+`e2) {
  return make_fn(inner, new $(f,first));
}

// curry a closure that takes a pair
fn_t<`a,fn_t<`b,`c,`e1>,`e1+`e2> curry(fn_t<$(`a,`b)@`H,`c,`e1> f) {
  return make_fn(outer,f);
}

static `c lambda<`a,`b,`c,`e1,`e2>(fn_t<`a,fn_t<`b,`c,`e1>,`e2> f,
                                   $(`a,`b)@`H arg; 
                                   `e1+`e2) {
  return apply(apply(f,(*arg)[0]),(*arg)[1]);
}

// uncurry a closure
fn_t<$(`a,`b)@,`c,`e1+`e2> uncurry(fn_t<`a,fn_t<`b,`c,`e1>,`e2> f) {
  return make_fn(lambda@<`a,`b,`c,`e1,`e2>,f);
}

// map a closure across a list
List::list_t<`b,`H> map_fn(fn_t<`a,`b,`e> f,List::list_t<`a> x) {
  // return List::map_c(apply,f,x);
  List::list_t res = NULL;
  for (; x != NULL; x = x->tl) 
    res = new List::List(apply(f,x->hd), res);
  res = List::imp_rev(res);
  return res;
}


