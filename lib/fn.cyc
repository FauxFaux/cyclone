/* This file is part of the Cyclone Library.
   Copyright (C) 2000, 2001 Greg Morrisett, AT&T

   This library is free software; you can redistribute it and/or it
   under the terms of the GNU Lesser General Public License as
   published by the Free Software Foundation; either version 2.1 of
   the License, or (at your option) any later version.

   This library is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with this library; see the file COPYING.LIB.  If not,
   write to the Free Software Foundation, Inc., 59 Temple Place, Suite
   330, Boston, MA 02111-1307 USA. */


////////////////////////////////////////////////////////////////////////////
// Defines "closures" and operations on them                              //
////////////////////////////////////////////////////////////////////////////
#include <fn.h>

namespace Fn;

// JGM: you'll note that a lot of explicit abstraction and
// instantiation is necessary due to the shortcomings of the
// unifier...or my ability to figure out what effects to put
// on things.

struct Function<`arg,`res,`bd::R> { <`env> : regions(`env) > `bd
  `res (@`bd f)(`env,`arg);
  `env env;
};

// make a closure out of a function pointer and environment
fn_t<`arg,`res,`bd> make_fn(`res (@`bd f)(`env,`arg), `env x : regions(`env) > `bd) {
  return new Function(f,x);
}

static `res fp_apply(`res (@`bd f)(`arg), `arg x) {
  return f(x);
}

// convert a function pointer to a closure
fn_t<`arg,`res,`bd> fp2fn(`res (@`bd f)(`arg) : regions($(`arg,`res)) > `bd) {
  return make_fn(fp_apply, f);
}

// apply closure f to argument x
`res apply(fn_t<`arg,`res> f, `arg x) {
  let &Function{<`env> code,env} = f;
  return code(env,x);
}

// heh, heh, heh:  try explaining this to your Mom...
static `c fn_compose($(fn_t<`b,`c,`bd>, fn_t<`a,`b,`bd>)@`H f_and_g,`a arg) {
  let &$(f,g) = f_and_g;
  return apply(f,apply(g,arg));
}

// compose closures
fn_t<`a,`c,`bd> compose(fn_t<`a,`b,`bd> g, fn_t<`b,`c,`bd> f 
			: regions($(`a,`b,`c)) > `bd) {
  return make_fn(fn_compose,new $(f,g));
}


// These next two functions are used for currying
static `c inner($(fn_t<$(`a,`b)@`H,`c,`bd>,`a*`H)@`H env, `b second) {
  return apply((*env)[0],new $(*(*env)[1],second));
}
static fn_t<`b,`c,`bd> outer($(fn_t<`b,`c,`bd>, `a*@`H)@`H env, `a first) {
  *(*env)[1] = new first;
  return (*env)[0];
}

// curry a closure that takes a pair
fn_t<`a,fn_t<`b,`c,`bd>,`bd> curry(fn_t<$(`a,`b)@`H,`c,`bd> f
				   : regions($(`a,`b,`c)) > `bd) {
  $(fn_t<$(`a,`b)@`H,`c,`bd>, `a*`H)@ inner_env = new $(f, NULL);
  fn_t<`b,`c,`bd> inner_fn = make_fn(inner, inner_env);
  return make_fn(outer, new $(inner_fn, &((*inner_env)[1])));
}

static `c lambda(fn_t<`a,fn_t<`b,`c,`bd>,`bd> f, $(`a,`b)@`H arg) {
  return apply(apply(f,(*arg)[0]),(*arg)[1]);
}

// uncurry a closure
fn_t<$(`a,`b)@,`c,`bd> uncurry(fn_t<`a,fn_t<`b,`c,`bd>,`bd> f
			       : regions($(`a,`b,`c)) > `bd) {
  return make_fn(lambda,f);
}

// map a closure across a list
List::list_t<`b,`H> map_fn(fn_t<`a,`b,`bd> f,List::list_t<`a> x) {
  List::list_t res = NULL;
  for (; x != NULL; x = x->tl) 
    res = new List::List(apply(f,x->hd), res);
  res = List::imp_rev(res);
  return res;
}
