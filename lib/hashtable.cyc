/* This file is part of the Cyclone Library.
   Copyright (C) 2000-2001 Greg Morrisett, AT&T

   This library is free software; you can redistribute it and/or it
   under the terms of the GNU Lesser General Public License as
   published by the Free Software Foundation; either version 2.1 of
   the License, or (at your option) any later version.

   This library is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with this library; see the file COPYING.LIB.  If not,
   write to the Free Software Foundation, Inc., 59 Temple Place, Suite
   330, Boston, MA 02111-1307 USA. */

// a simple chaining, polymorphic hash table with restore
// of course this is not functional

// MWH 12/13/99 -- added support for resizing the table.  Based it
//   on the OCaml 2.02 Hashtbl implementation

#include <list.h>
#include <core.h>
#include <hashtable.h>
#include <string.h>

namespace Hashtable;
using List;

/*abstract*/
struct Table<`a,`b,`e1::E,`e2::E> {
  int          (@cmp)(`a,`a; `e1);
  int          (@hash)(`a; `e2);
  int	       max_len; // maximum length of bucket list before resize
  list_t<$(`a,`b)@> ?tab;
};

table_t<`a,`b,`e1,`e2> create(int sz, int (@cmp)(`a,`a;`e1), 
                            int (@hash)(`a;`e2)) {
  list_t<$(`a,`b)@> mt = null;
  return new Table(cmp, hash, 3, new {for i<sz :mt});
}

void insert(table_t<`a,`b,`e1,`e2> t, `a key, `b val) {
  list_t<$(`a,`b)@> ?tab   = t->tab;
  int             bucket = (*t->hash)(key) % tab.size;
  tab[bucket] = new List(new $(key,val),tab[bucket]);
  if (length(tab[bucket]) > t->max_len) 
    resize(t);
}

`b lookup(table_t<`a,`b,`e1,`e2> t, `a key) {
  // throws Not_found
  list_t<$(`a,`b)@> ?tab   = t->tab;
  list_t<$(`a,`b)@> l      = tab[(*t->hash)(key) % tab.size];
  return assoc_cmp(t->cmp, l, key);
}

void remove(table_t<`a,`b,`e1,`e2> t, `a key) {
  // remove only most recent binding.  Silently return if none.
  // does a destructive list update since this data structure is not functional
  // UNTESTED!
  list_t<$(`a,`b)@> ?tab      = t->tab;
  int         (@cmp)(`a,`a;`e1) = t->cmp;
  int              bucket   = (*t->hash)(key) % tab.size;
  list_t<$(`a,`b)@> l         = tab[bucket];
  if(l == null)
    return;
  if((*cmp)(key,l->hd[0][0])==0) {
    tab[bucket] = l->tl;
    return;
  }
  list_t<$(`a,`b)@> prev = l;
  l = l->tl;
  for(; l->tl!=null; prev = l, l=l->tl)
    if((*cmp)(key,l->hd[0][0])==0) {
      prev->tl = l->tl;
      return;
    }
}

int hash_string(string_t s) {
  // could be made faster by explicit loop unrolling
  int ans   = 0;
  int sz    = s.size;
  int shift = 0;
  for (int i=0; i < sz; ++i) {
    ans = ans ^ (s[i] << shift);
    shift += 8;
    if(shift == 32)
      shift = 0;
  }
  return ans;
}

int hash_stringptr(stringptr_t s) {
  return hash_string(*s);
}

// For resizing
void insert_bucket(list_t<$(`a,`b)@> ?tab, int (@hash)(`a),
                   list_t<$(`a,`b)@> elems) {
  if (elems == null) return;
  insert_bucket(tab,hash,elems->tl); // preserve the original order
  `a  key  = elems->hd[0][0];
  `b  val  = elems->hd[0][1];
  int nidx = (*hash)(key) % tab.size;
  tab[nidx] = new List(new $(key,val),tab[nidx]);
}

void resize(table_t<`a,`b,`e1,`e2> t) {
  list_t<$(`a,`b)@> ?odata   = t->tab;
  int             osize    = odata.size;
  int             nsize    = 2 * osize + 1;
  list_t<$(`a,`b)@> mt       = null;
  list_t<$(`a,`b)@> ?ndata   = new {for i < nsize : mt};
  for (int i = 0; i<osize; i++)
    insert_bucket(ndata,t->hash,odata[i]);
  t->tab     = ndata;
  t->max_len = 2 * t->max_len;
}

// Iterating over a hashtable
void iter(void f(`a,`b), table_t<`a,`b,`e1,`e2> t) {
  list_t<$(`a,`b)@> ?odata   = t->tab;
  int             osize    = odata.size;
  for (int i = 0; i<osize; i++) 
    for(list_t<$(`a,`b)@> iter = odata[i]; iter != null; iter = iter->tl) 
      f(iter->hd[0][0],iter->hd[0][1]);
}

// debugging
void print_table_map(table_t<`a,`b,`e1,`e2> t, 
                     void prn_key(`a), void prn_val(`b)){
  list_t<$(`a,`b)@> ?odata = t->tab;
  int osize = odata.size;
  for (int i = 0; i<osize; i++) {
    printf("%d: ",i);
    for(list_t<$(`a,`b)@> iter = odata[i]; iter != null; iter = iter->tl) {
      printf("(");
      prn_key(iter->hd[0][0]);
      printf(",");
      prn_val(iter->hd[0][1]);
      printf(") ");
    }
    printf("\n");
  }
}  
