////////////////////////////////////////////////////////////////////////////
// Cyclone library, file list.pop                                         //
// Copyright Greg Morrisett                                               //
// January 2000, all rights reserved                                      //
//                                                                        //
////////////////////////////////////////////////////////////////////////////
// list.cyc: defines generic lists and various operations over them,
//           following the conventions of the Ocaml list library as much
//           as possible.  Also, a reasonable attempt to make things as
//           space efficient as possible, while remaining "functional".
//

#include "list.h"

namespace List;

// Return the length of a list. 
int length(glist_t<`a,`r> x) {
  int i = 0;

  while (x != null) {
    ++i;
    x = x->tl;
  }
  return i;
}

// thrown when some function expects a non-empty list 
// Note that there's no need to declare a type with the exception.
// If we wanted List_empty to carry an int value, we would write:
// exception int List_empty;
xenum exn {List_empty};

// return the first element in a list, if any, throw List_empty otherwise. 
`a hd(glist_t<`a,`r> x) {
  if (x == null) throw List_empty;
  return x->hd;
}

// return the tail of a list, if any, throw List_empty otherwise. 
glist_t<`a,`r> tl(glist_t<`a,`r> x) {
  if (x == null) throw List_empty;
  return x->tl;
}

// return a fresh copy of the list (same as map of the identity) 
list_t<`a> copy(glist_t<`a,`r> x) {
  list_t<`a> result, prev;

  if (x == null) return null;
  result = &List{.hd=x->hd,.tl=null};
  prev = result;
  for (x=x->tl; x != null; x=x->tl) {
    prev->tl = &List(x->hd,null);
    prev = prev->tl;
  }
  return result;
}  

// Apply a function to each element in a list, returning a new list. 
list_t<`b> map(`b f(`a),glist_t<`a,`r> x) {
  list_t<`b> result,prev;

  if (x == null) return null;
  result = &List(f(x->hd),null);
  prev = result;
  for (x=x->tl; x != null; x=x->tl) {
    list_t<`b> temp = &List(f(x->hd),null);
    prev->tl = temp;
    prev = temp;
  }
  return(result);
}

// Apply a function to each element in a list, returning a new list. 
list_t<`b> map_c(`b f(`c,`a),`c env,glist_t<`a,`r> x) {
  list_t<`b> result, prev;

  if (x == null) return null;
  result = &List(f(env,x->hd),null);
  prev = result;
  for (x=x->tl; x != null; x=x->tl) {
    prev->tl = &List(f(env,x->hd),null);
    prev = prev->tl;
  }
  return(result);
}

// thrown when two lists don't have the same size 
xenum exn {List_mismatch};

// Given two lists of the same length and a function, apply the function
// to each pair of elements (in order) and collect the results in a new list.
// Throws List_mismatch if the sizes of the lists aren't the same.
list_t<`c> map2(`c f(`a,`b),glist_t<`a,`r1> x,glist_t<`b,`r2> y) {
  list_t<`c> result, prev;

  if (x == null && y == null) return null;
  if (x == null || y == null) throw List_mismatch;

  result = &List(f(x->hd,y->hd),null);
  prev = result;

  x = x->tl;
  y = y->tl;

  while (x != null && y != null) {
    prev->tl = &List(f(x->hd,y->hd),null);
    prev = prev->tl;
    x = x->tl;
    y = y->tl;
  }
  if (x != null || y != null) throw List_mismatch;
  return(result);
}

// Apply some function to each element of the list, but don't bother to
// save the result.  Similar to Ocaml's List.iter but doesn't require
// void type for the result of the function.
void app(`b f(`a),glist_t<`a,`r> x) {
  while (x != null) {
    f(x->hd);
    x = x->tl;
  }
}

void app_c(`c f(`a,`b),`a env,glist_t<`b,`r> x) {
  while (x != null) {
    f(env,x->hd);
    x = x->tl;
  }
}

// same as app but with void functions -- unlike Popcorn, the iter
// functions are no longer needed because we treat "void" as a boxed
// type.  
void iter(void f(`a),glist_t<`a,`r> x) {
  while (x != null) {
    f(x->hd);
    x = x->tl;
  }
}
// same as app_c but with void functions
void iter_c(void f(`b,`a),`b env,glist_t<`a,`r> x) {
  while (x != null) {
    f(env,x->hd);
    x = x->tl;
  }
}

// Same as app, but generalized to a pair of lists.  Throws List_mismatch
// if the lengths of the list aren't the same.  
void app2(`c f(`a,`b),glist_t<`a,`r1> x,glist_t<`b,`r2> y) {
  while (x != null && y != null) {
    f(x->hd,y->hd);
    x = x->tl;
    y = y->tl;
  }
  if (x != null || y != null) throw List_mismatch;
}

void app2_c(`d f(`a,`b,`c),`a env,glist_t<`b,`r1> x,glist_t<`c,`r2> y) {
  while (x != null && y != null) {
    f(env,x->hd,y->hd);
    x = x->tl;
    y = y->tl;
  }
  if (x != null || y != null) throw List_mismatch;
}

// Same as iter, but generalized to a pair of lists.  Throws List_mismatch
// if the lengths of the list aren't the same.  
void iter2(void f(`a,`b),glist_t<`a,`r1> x,glist_t<`b,`r2> y) {
  while (x != null && y != null) {
    f(x->hd,y->hd);
    x = x->tl;
    y = y->tl;
  }
  if (x != null || y != null) throw List_mismatch;
}
void iter2_c(void f(`a,`b,`c),`a env,glist_t<`b,`r1> x,glist_t<`c,`r2> y) {
  while (x != null && y != null) {
    f(env,x->hd,y->hd);
    x = x->tl;
    y = y->tl;
  }
  if (x != null || y != null) throw List_mismatch;
}

// Given a list [x1,x2,...,xn-1,xn], a function f, and an accumulator a,
// return f(f(...(f(x2,f(x1,a))),xn-1),xn).  Notice that the function is
// first applied to the left-most element of the list.
`a fold_left(`a f(`a,`b),`a accum,glist_t<`b,`r> x) {
  while (x != null) {
    accum = f(accum,x->hd);
    x = x->tl;
  }
  return(accum);
}

`a fold_left_c(`a f(`c,`a,`b),`c env,`a accum,glist_t<`b,`r> x) {
  while (x != null) {
    accum = f(env,accum,x->hd);
    x = x->tl;
  }
  return(accum);
}

// Given a list [x1,x2,....,xn-1,xn], a function f, and an accumulator a,
// return f(x1,f(x2,...,f(xn-1,f(xn,a))...)).  Notice that the function is
// first applied to the right-most element of the list. 
`b fold_right(`b f(`a,`b),glist_t<`a,`r> x,`b accum) {
  if (x == null) return accum;
  else return(f(x->hd,fold_right(f,x->tl,accum)));
}
`b fold_right_c(`b f(`c,`a,`b),`c env,glist_t<`a,`r> x,`b accum) {
  if (x == null) return accum;
  else return(f(env,x->hd,fold_right_c(f,env,x->tl,accum)));
}

// Given [x1,...,xn] and [y1,...,ym], return [xn,...,x1,y1,...,ym].
// That is, the first list reversed and appended to the second list.
list_t<`a> revappend(glist_t<`a,`r> x,list_t<`a> y) {
  while (x != null) {
    y = &List(x->hd,y);
    x = x->tl;
  }
  return(y);
}

// Return the reverse of a list. 
list_t<`a> rev(glist_t<`a,`r> x) {
  // avoid allocation for length-one lists
  if(x==null) // || x->tl==null)
    return null;
  return(revappend(x,null));
}

// Imperatively reverse a list 
glist_t<`a,`r> imp_rev(glist_t<`a,`r> x) {
  if (x == null) return x;
  else {
    glist_t<`a,`r> first  = x;
    glist_t<`a,`r> second = x->tl;
    x->tl = null;
    while (second != null) {
      glist_t<`a,`r> temp = second->tl;
      second->tl = first;
      first = second;
      second = temp;
    } 
    return first;
  }
}
      
// Return two appended lists -- creates sharing.
list_t<`a> append(glist_t<`a,`r> x,list_t<`a> y) {
  list_t<`a> result, prev;

  if (x == null) return y;
  if (y == null) return copy(x); // copy needed to get in right region
  result = &List(x->hd,null);
  prev = result;
  for (x=x->tl; x != null; x=x->tl) {
    prev->tl = &List(x->hd,null);
    prev = prev->tl;
  }
  prev->tl = y;
  return(result);
}

// Modify x so that y is appended to it -- if x is empty, return y else
// return the modified list x.
glist_t<`a,`r> imp_append(glist_t<`a,`r> x,glist_t<`a,`r> y) {
  glist_t<`a,`r> z;

  if (x == null) return y;
  if (y == null) return x;
  for(z = x; z->tl != null; z = z->tl) 
    // skip
    ;
  z->tl = y;
  return x;
}

// Flatten a list of lists into a new list 
list_t<`a> flatten(glist_t<glist_t<`a,`r1>,`r2> x) {
  return fold_right(append,x,null);
}

// Given a partial order less_eq on 'a elements and a list, return
// the list sorted by less_eq.  Uses a merge sort.  The less_eq
// function should return 0 if the elements are equal, i < 0 if
// the first is less than the second, and i > 0 otherwise.
list_t<`a> merge_sort(int less_eq(`a,`a), glist_t<`a,`r> x)
{
  list_t<`a> a = null;
  list_t<`a> b = null;
  
  if ((x == null) || (x->tl == null))
    return(copy(x)); // copy needed to get in right region

  // split into two lists
  while (x != null) {
    a = &List(x->hd,a);
    x = x->tl;
    if (x != null) {
      b = &List(x->hd,b);
      x = x->tl;
    }
  }
  a = merge_sort(less_eq,a);
  b = merge_sort(less_eq,b);
  return(merge(less_eq,a,b));
}

list_t<`a> merge(int less_eq(`a,`a),list_t<`a> a,list_t<`a> b) {
  list_t<`a> c,d;

  // Dan bug fix: now works on empty lists by special-casing it first:
  if (a==null) return b;
  if (b==null) return a;
  
  // merge the two lists:
  //   d = beginning of the merged list
  //   c = current cons cell
 
  if (less_eq(a->hd,b->hd) <= 0) {
    c = a; d = a; a = a->tl; 
  } else {
    c = b; d = b; b = b->tl;
  }
  // walk through a and b
  while ((a != null) && (b != null)) {
    // add a to the list else add b
    if (less_eq(a->hd, b->hd) <= 0) {
      c->tl = a;
      c = a;
      a = a->tl;
    } else {
      c->tl = b;
      c = b;
      b = b->tl;
    }
  }
  // splice in the rest of the other list
  if (a == null)
    c->tl = b;
  else
    c->tl = a;
  return(d);
}

// thrown when nth doesn't have enough elements in the list. 
xenum exn {Nth};

// Given [x0,x1,...,xn], return the ith element of the list (0 <= i <= n).
// Throw Nth if the list doesn't have enough elements.  Notice that the
// indexing is zero-based.
`a nth(glist_t<`a,`r> x,int i) {

  while (i > 0 && x != null) {
    --i;
    x = x->tl;
  }
  if (i < 0 || x == null) throw Nth;
  return(x->hd);
}

// Given a predicate on 'a values, determine whether every element in a list
// satisfies the predicate.
bool forall(bool pred(`a),glist_t<`a,`r> x) {
  while (x != null && pred(x->hd)) x=x->tl; // modified by Dan
  return(x == null);
}
bool forall_c(bool pred(`a,`b),`a env,glist_t<`b,`r> x) {
  while (x != null && pred(env,x->hd)) x=x->tl; 
  return(x == null);
}

// Given a predicate on 'a values, determine whether there exists an element
// in the list that satisfies the predicate.
bool exists(bool pred(`a),glist_t<`a,`r> x) {
  while (x != null && (!pred(x->hd))) x=x->tl; // modified by Dan
  return(x != null);
}
bool exists_c(bool pred(`a,`b),`a env,glist_t<`b,`r> x) {
  while (x != null && (!pred(env,x->hd))) x=x->tl; // modified by Dan
  return(x != null);
}

// Given [x1,...,xn] and [y1,...,yn], return [(x1,y1),...,(xn,yn)].  
// Throws List_mismatch if the lengths are not the same.
list_t<$(`a,`b)@> zip(glist_t<`a,`r1> x,glist_t<`b,`r2> y) {
  list_t<$(`a,`b)@> result, prev;
  
  if (x == null && y == null) return null;
  if (x == null || y == null) throw List_mismatch;

  result = &List(&$(x->hd,y->hd),null);
  prev = result;

  x = x->tl;
  y = y->tl;

  while (x != null && y != null) {
    prev->tl = &List(&$(x->hd,y->hd),null);
    prev = prev->tl;
    x = x->tl;
    y = y->tl;
  }
  if (x != null || y != null) throw List_mismatch;
  return(result);
}

// Given [(x1,y1),...,(xn,yn)], return ([x1,...,xn],[y1,...,yn]) 
$(list_t<`a>,list_t<`b>) split(glist_t<$(`a,`b)@`r1,`r2> x) {
  list_t<`a> result1, prev1;
  list_t<`b> result2, prev2;
  
  if (x == null) return $(null,null);

  prev1 = result1 = &List(x->hd[0][0],null);
  prev2 = result2 = &List(x->hd[0][1],null);

  for (x=x->tl; x != null; x=x->tl) {
    prev1->tl = &List(x->hd[0][0],null);
    prev2->tl = &List(x->hd[0][1],null);
    prev1 = prev1->tl;
    prev2 = prev2->tl;
  }
  return $(result1,result2);
}

// Given [(x1,y1,z1),...,(xn,yn,zn)], return
// ([x1,...,xn],[y1,...,yn],[z1,...,zn]) 
$(list_t<`a>,list_t<`b>,list_t<`c>) split3(glist_t<$(`a,`b,`c)@`r1,`r2> x) {
  list_t<`a> result1,prev1;
  list_t<`b> result2,prev2;
  list_t<`c> result3,prev3;
  
  if (x == null) return $(null,null,null);

  prev1 = result1 = &List(x->hd[0][0],null);
  prev2 = result2 = &List(x->hd[0][1],null);
  prev3 = result3 = &List(x->hd[0][2],null);

  for (x=x->tl; x != null; x=x->tl) {
    prev1->tl = &List(x->hd[0][0],null);
    prev2->tl = &List(x->hd[0][1],null);
    prev3->tl = &List(x->hd[0][2],null);
    prev1 = prev1->tl;
    prev2 = prev2->tl;
    prev3 = prev3->tl;
  }
  return $(result1,result2,result3);
}


// Given a list [x1,...,xn] and x, determine if x is in the list.  Uses
// physical equality for comparison.
bool memq(glist_t<`a,`r> l, `a x) {
  while (l != null) {
    if (l->hd == x) return(true);
    l = l->tl;
  }
  return(false);
}

bool mem(int compare(`a,`a), glist_t<`a,`r> l, `a x) {
  while (l != null) {
    if (compare(l->hd,x)==0) return true;
    l = l->tl;
  }
  return false;
}

// now defined in Core
// exn Not_found;

// Given an association list [(k1,d1),...,(kn,dn)] and a key x,
// return the first di such that ki = x.  Uses physical equality.
// Throws Not_found if no such ki exists.
`b assoc(glist_t<$(`a,`b)@`r1,`r2> l,`a x) {
  while (l != null) {
    if (l->hd[0][0] == x) return(l->hd[0][1]);
    l = l->tl;
  }
  throw Core::Not_found;
}

`b assoc_cmp(int compare(`a,`a),glist_t<$(`a,`b)@`r1,`r2> l,`a x) {
  while (l != null) {
    if (compare(x,l->hd[0][0]) == 0) return(l->hd[0][1]);
    l = l->tl;
  }
  throw Core::Not_found;
}

// Given an association list [(k1,d1),...,(kn,dn)] and a key x,
// returns true iff there exists a ki = x.
bool mem_assoc(glist_t<$(`a,`b)@`r1,`r2> l,`a x) {
  while (l != null) {
    if (l->hd[0][0] == x) return(true);
    l = l->tl;
  }
  return(false);
}

// checks that a list of elements is unique -- assumes they're sorted
// returns an element that is duplicated if one exists, otherwise returns
// null.
Core::opt_t<`a> check_unique(int compare(`a,`a),glist_t<`a,`r> x) {
  while (x != null) {
    if (x->tl != null) 
      if (compare(x->hd,x->tl->hd) == 0) return &Core::Opt(x->hd);
    x = x->tl;
  }
  return null;
}

// makes a new array with index i being the ith element of the list
`a ?to_array(glist_t<`a,`r> x) {
  int s;
  `a ?arr;

  s = length(x);
  arr = new {for i < s : x->hd};
  for(int i = 0; i < s; ++i, x = x->tl)
    arr[i] = x->hd;
  return arr;
}

// makes a new list with ith element arr[i]
list_t<`a> from_array(`a ?`r arr) {
  list_t<`a> ans = null;
  for(unsigned int i = arr.size-1; i >= 0; --i)
    ans = &List(arr[i],ans);
  return ans;
}

list_t<`a> tabulate(int n, `a f(int)) {
  list_t<`a> res = null;
  for (int i = 0; i < n; ++i) {
    res = &List(f(i),res);
  }
  return imp_rev(res);
}

list_t<`a> tabulate_c(int n, `a f(`b,int), `b env) {
  list_t<`a> res = null;
  for (int i = 0; i < n; ++i) {
    res = &List(f(env,i),res);
  }
  return imp_rev(res);
}

list_t<`a> filter_c(bool f(`b,`a), `b env, glist_t<`a,`r> l) {
  if(l == null)
    return null;
  list_t<`a> result = &List(l->hd,null); // First elt is purposefully junk!
  list_t<`a> end = result; // pointer to last cons cell
  for(;l != null;l=l->tl) {
    if(f(env,l->hd)) {
      end->tl = &List(l->hd,null);
      end = end->tl;
    }
  }
  return result->tl; // Ditch the placeholder we inserted earlier.
}

list_t<`a> filter(bool f(`a), glist_t<`a,`r> l) {
  if(l == null)
    return null;
  list_t<`a> result = &List(l->hd,null); // First elt is purposefully junk!
  list_t<`a> end = result; // pointer to last cons cell
  for(;l != null;l=l->tl) {
    if(f(l->hd)) {
      end->tl = &List(l->hd,null);
      end = end->tl;
    }
  }
  return (result->tl); // Ditch the placeholder we inserted earlier.
}

