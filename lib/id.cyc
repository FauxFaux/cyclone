
////////////////////////////////////////////////////////////////////////////
// Popcorn library, file id->pop                                           //
// Copyright Greg Morrisett, Dan Grossman                                 //
// January 1999, all rights reserved                                      //
//                                                                        //
////////////////////////////////////////////////////////////////////////////

// This implementation suffers two shortcomings:
// 1. It does no string sharing -- crucial for talc efficiency in the ocaml
//    implementation.
// 2. It does copy incoming strings, allowing for later mutation via external
//    code.  Could probably live without this one

#include <core.h>
#include <stdio.h>
#include <string.h>
#include <list.h>
#include <id.h>

using Core;
using String;
using List;
using Stdio;

namespace Id;

abstract struct id {
  string_t s;
  int i;
};

Id id_make(string_t s,int i) {  return new id(s,i); }

static int counter = 0;

Id id_new(string_t s) {
  ++counter;
  return id_make(s,counter);
}

Id id_renew(Id i) {
  ++counter;
  return id_make(i->s,counter);
}

Id id_of_string(string_t s) { return id_make(s,-1); }
Id id_unique   (string_t s) { return id_new(s); }

mstring_t id_to_string(Id x) {
  if (x->i == -1)
    return String::strdup(x->s);
  return strconcat_l(new List(new {x->s},
                              new List(new ((string_t)"$"), 
                                       new List(new {(string_t)string_of_int(x->i)},
                                                null))));
}
void id_prn(FILE @f, Id x) { fprintf(f, "%s", id_to_string(x)); }

mstring_t id_to_source(Id x) { return strdup(x->s); }

int id_compare(Id x1,Id x2) {
  if (x1->i == x2->i)
    return(String::zstrcmp(x1->s,x2->s));
  else if (x1->i < x2->i) return(-1);
  else return(1);
}
