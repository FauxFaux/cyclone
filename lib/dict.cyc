
#include "core.h"
#include "list.h"
#include "dict.h"

namespace Dict;

xenum exn {Absent,Present};

static enum Color { R, B };

static struct T<`a,`b> {
  enum   Color color;
  struct T<`a,`b> *   left;
  struct T<`a,`b> *   right;
  $(`a,`b)     key_val; // flattened, but tuple convenient for patterns
};
typedef struct T<`a,`b> * tree<`a,`b>;

abstract struct dict<`a,`b> {
  int (@rel)(`a,`a);
  tree<`a,`b> t;
};

Dict<`a,`b> empty<`a,`b>(int comp(`a,`a)) {
  return &dict(comp,null);
}
Dict<`a,`b> singleton<`a,`b>(int comp(`a,`a),`a key,`b data) {
  return &dict(comp,&T(B,null,null,$(key,data)));
}

bool is_empty<`a,`b>(Dict<`a,`b> d) {
  return d->t == null;
}

bool member<`a,`b>(Dict<`a,`b> d, `a key) {
  let rel = d->rel;
  let t   = d->t;
  while(t != null) {
    let i = rel(key,t->key_val[0]);
    if(i < 0) t = t->left;
    else if (i > 0) t = t->right;
    else return true;
  }
  return false;
}
`b lookup<`a,`b>(Dict<`a,`b> d, `a key) {
  let rel = d->rel;
  let t   = d->t;
  while(t != null) {
    let i = rel(key,t->key_val[0]);
    if(i < 0) t = t->left;
    else if (i > 0) t = t->right;
    else return t->key_val[1];
  }
  throw Absent;
}
Core::Opt_t<`b> lookup_opt<`a,`b>(Dict<`a,`b> d, `a key) {
  let rel = d->rel;
  let t   = d->t;
  while(t != null) {
    let i = rel(key,t->key_val[0]);
    if(i < 0) t = t->left;
    else if (i > 0) t = t->right;
    else return &Core::Opt(t->key_val[1]);
  }
  return null;
}

static tree<`a,`b> 
balance<`a,`b>($(enum Color, tree<`a,`b>, tree<`a,`b>, $(`a,`b)) quad) {
  switch(quad) {
  case $(B,&T(R,&T(R,a,b,x),c,y),d,z): return &T(R,&T(B,a,b,x),&T(B,c,d,z),y);
  case $(B,&T(R,a,&T(R,b,c,y),x),d,z): return &T(R,&T(B,a,b,x),&T(B,c,d,z),y);
  case $(B,a,&T(R,&T(R,b,c,y),d,z),x): return &T(R,&T(B,a,b,x),&T(B,c,d,z),y);
  case $(B,a,&T(R,b,&T(R,c,d,z),y),x): return &T(R,&T(B,a,b,x),&T(B,c,d,z),y);
  case $(a,b,c,d): return &T(a,b,c,d);
  }
}
static tree<`a,`b>
ins<`a,`b>(int rel(`a,`a), $(`a,`b) key_val, tree<`a,`b> t) {
  switch (t) {
  case null: return &T(R,null,null,key_val);
  case &T(color, a, b, y):
    let i = rel(key_val[0], y[0]);
    if(i < 0)       return balance($(color, ins(rel,key_val,a), b, y));
    else if (i > 0) return balance($(color, a, ins(rel,key_val,b), y));
    else            return &T(color,a,b,key_val);
  }
}

Dict<`a,`b> insert<`a,`b>(Dict<`a,`b> d,`a key,`b data) {
  let ans = ins(d->rel, $(key,data), d->t);
  ans->color = B;
  return &dict(d->rel, ans);
}

// notice we descend twice -- we can live
Dict<`a,`b> insert_new<`a,`b>(Dict<`a,`b> d,`a key,`b data) {
  if(member(d,key))
    throw Absent;
  return insert(d, key, data);
}

Dict<`a,`b> inserts<`a,`b>(Dict<`a,`b> d,List::list<$(`a,`b)@> kds) {
  for(; kds != null; kds = kds->tl)
    d = insert(d, kds->hd[0][0], kds->hd[0][1]);
  return d;
}

static `c fold_tree<`a,`b,`c>(`c f(`a,`b,`c), struct T<`a,`b> @ t, `c accum) {
  let &T(_,left,right,$(key,val)) = t;
  accum = f(key, val, accum);
  if(left  != null) accum = fold_tree(f,(struct T<`a,`b>@)left,accum);
  if(right != null) accum = fold_tree(f,(struct T<`a,`b>@)right,accum);
  return accum;
}
`c fold<`a,`b,`c>(`c f(`a,`b,`c),Dict<`a,`b> d,`c accum) {
  if(d->t == null)
    return accum;
  return fold_tree(f, (struct T<`a,`b>@)(d->t), accum);
}

static `c fold_tree_c<`a,`b,`c,`d>(`c f(`d,`a,`b,`c),   `d env,
				   struct T<`a,`b> @ t, `c accum) {
  let &T(_,left,right,$(key,val)) = t;
  accum = f(env, key, val, accum);
  if(left  != null) accum = fold_tree_c(f,env,(struct T<`a,`b>@)left,accum);
  if(right != null) accum = fold_tree_c(f,env,(struct T<`a,`b>@)right,accum);
  return accum;
}
`c fold_c<`a,`b,`c,`d>(`c f(`d,`a,`b,`c),`d env,Dict<`a,`b> d,`c accum) {
  if(d->t == null)
    return accum;
  return fold_tree_c(f, env, (struct T<`a,`b>@)(d->t), accum);
}

static void app_tree<`a,`b,`c>(`c f(`a,`b), struct T<`a,`b> @ t) {
  let &T(_,left,right,$(key,val)) = t;
  f(key, val);
  if(left  != null) app_tree(f,(struct T<`a,`b>@)left);
  if(right != null) app_tree(f,(struct T<`a,`b>@)right);
}
void app<`a,`b,`c>(`c f(`a,`b),Dict<`a,`b> d) {
  if(d->t != null)
    app_tree(f,(struct T<`a,`b>@)(d->t));
}

static void app_tree_c<`a,`b,`c,`d>(`c f(`d,`a,`b), `d env, struct T<`a,`b>@ t){
  let &T(_,left,right,$(key,val)) = t;
  f(env, key, val);
  if(left  != null) app_tree_c(f,env,(struct T<`a,`b>@)left);
  if(right != null) app_tree_c(f,env,(struct T<`a,`b>@)right);
}
void app_c<`a,`b,`c,`d>(`c f(`d,`a,`b),`d env, Dict<`a,`b> d) {
  if(d->t != null)
    app_tree_c(f,env,(struct T<`a,`b>@)(d->t));
}

static void iter_tree<`a,`b>(void f(`a,`b), struct T<`a,`b> @ t) {
  let &T(_,left,right,$(key,val)) = t;
  f(key, val);
  if(left  != null) iter_tree(f,(struct T<`a,`b>@)left);
  if(right != null) iter_tree(f,(struct T<`a,`b>@)right);
}
void iter<`a,`b>(void f(`a,`b),Dict<`a,`b> d) {
  if(d->t != null)
    iter_tree(f,(struct T<`a,`b>@)(d->t));
}

static void iter_tree_c<`a,`b,`c>(void f(`c,`a,`b), `c env, struct T<`a,`b>@ t){
  let &T(_,left,right,$(key,val)) = t;
  f(env, key, val);
  if(left  != null) iter_tree_c(f,env,(struct T<`a,`b>@)left);
  if(right != null) iter_tree_c(f,env,(struct T<`a,`b>@)right);
}
void iter_c<`a,`b,`c>(void f(`c,`a,`b),`c env, Dict<`a,`b> d) {
  if(d->t != null)
    iter_tree_c(f,env,(struct T<`a,`b>@)(d->t));
}

static tree<`a,`c> map_tree<`a,`b,`c>(`c f(`b), struct T<`a,`b>@ t) {
  let &T(c,left,right,$(key,val)) = t;
  let new_left  = left  == null ? null : map_tree(f,(struct T<`a,`b>@)left);
  let new_right = right == null ? null : map_tree(f,(struct T<`a,`b>@)right);
  return &T(c,new_left,new_right,$(key,f(val)));
} 

Dict<`a,`c> map<`a,`b,`c>(`c f(`b),Dict<`a,`b> d) {
  if(d->t == null)
    return &dict(d->rel,null);
  return &dict(d->rel,map_tree(f,(struct T<`a,`b>@)(d->t)));
}

// Note: walk is post-order
static tree<`a,`c> map_tree_c<`a,`b,`c,`d>(`c f(`d,`b), `d env,
					   struct T<`a,`b>@ t) {
  let &T(c,left,right,$(key,val)) = t;
  let new_left = left ==null ? null : map_tree_c(f,env,(struct T<`a,`b>@)left);
  let new_right= right==null ? null : map_tree_c(f,env,(struct T<`a,`b>@)right);
  return &T(c,new_left,new_right,$(key,f(env,val)));
} 

Dict<`a,`c> map_c<`a,`b,`c,`d>(`c f(`d,`b),`d env,Dict<`a,`b> d) {
  if(d->t == null)
    return &dict(d->rel,null);
  return &dict(d->rel,map_tree_c(f,env,(struct T<`a,`b>@)(d->t)));
}

$(`a,`b)@ choose<`a,`b>(Dict<`a,`b> d) {
  if(d->t == null)
    throw Absent;
  return &$(d->t->key_val[0], d->t->key_val[1]);
}

static bool forall_tree_c<`a,`b,`c>(bool f(`c,`a,`b),`c env,struct T<`a,`b>@ t){
  let &T(_,left,right,$(key,val)) = t;
  return 
    f(env,key,val) 
    && (left  == null || forall_tree_c(f,env,(struct T<`a,`b>@)left))
    && (right == null || forall_tree_c(f,env,(struct T<`a,`b>@)right));
}

bool forall_c<`a,`b,`c>(bool f(`c,`a,`b), `c env, Dict<`a,`b> d) {
  if(d->t == null)
    return true;
  return forall_tree_c(f, env, (struct T<`a,`b>@)d->t);
}

// TO DO: Add the env version for union and intersect.
static Dict<`a,`b> union_f<`a,`b>(`b f(`b,`b), `a a, `b b, Dict<`a,`b> d1) {
  if(Dict::member(d1,a))
    return Dict::insert(d1, a, f(Dict::lookup(d1, a), b));
  else
    return Dict::insert(d1, a, b);
}
Dict<`a,`b> union_two<`a,`b>( `b f(`b,`b), Dict<`a,`b> d1, Dict<`a,`b> d2) {
  if(d1 == d2)
    return d1;
  return Dict::fold_c(union_f, f, d2, d1);
}

static void intersect_f<`a,`b>($(`b (@f)(`b,`b),Dict<`a,`b>,Dict<`a,`b>) @ trip,
			       `a a, `b b) {
  let &$(f,d1,*d3_ptr) = trip;
  if(Dict::member(d1,a))
    *d3_ptr = Dict::insert(*d3_ptr, a, f(Dict::lookup(d1, a), b));
}
Dict<`a,`b> intersect<`a,`b>(`b (@f)(`b,`b), Dict<`a,`b> d1, Dict<`a,`b> d2) {
  if(d1 == d2)
    return d1;
  // must enrich regions so env can be stack allocated
  let env = &$(f, d1, Dict::empty(d1->rel));
  Dict::iter_c(intersect_f, env, d2);
  return (*env)[2];
}

List::list<$(`a,`b)@> to_list_f<`a,`b>(`a k, `b v, List::list<$(`a,`b)@> accum){
  return &List::cons(&$(k,v),accum);
}

List::list<$(`a,`b)@> to_list<`a,`b>(Dict<`a,`b> d) {
  return fold(to_list_f, d, null);
}
