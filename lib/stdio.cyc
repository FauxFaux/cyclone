/* This file is part of the Cyclone Library.
   Copyright (C) 2001 Greg Morrisett, AT&T

   This library is free software; you can redistribute it and/or it
   under the terms of the GNU Lesser General Public License as
   published by the Free Software Foundation; either version 2.1 of
   the License, or (at your option) any later version.

   This library is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with this library; see the file COPYING.LIB.  If not,
   write to the Free Software Foundation, Inc., 59 Temple Place, Suite
   330, Boston, MA 02111-1307 USA. */

/* Some definitions taken from the GNU C Library, released under LGPL:
   Copyright (C) 1991-1999, 2000 Free Software Foundation, Inc. */

#include <core.h>
#include <stdio.h>
#include <string.h> // for strcpy
using Core;

namespace Cstdio {
extern "C" {
extern struct __sFILE;
typedef struct Cstdio::__sFILE __sFILE;
int remove(Cstring);
int rename(Cstring, Cstring);
__sFILE *tmpfile();
Cstring	tmpnam(Cstring);
int fclose(__sFILE @`r);
int fflush(__sFILE *`r);
__sFILE *fopen (Cstring __filename, Cstring __modes);
__sFILE *freopen(Cstring __filename, Cstring __modes, __sFILE @__stream);
__sFILE *fdopen (int __fd, Cstring __modes);
int setvbuf (__sFILE @ __stream, Cstring __buf, int __modes, size_t __n);
  //NB: cygwin uses int as last arg of setbuffer, not size_t
void setbuffer (__sFILE @__stream, Cstring __buf, size_t __size);
void setlinebuf (__sFILE @__stream);
int fgetc(__sFILE @__stream);
int getc(__sFILE @__stream);
int fputc(int __c, __sFILE @__stream);
int putc(int __c, __sFILE @__stream);
int getw(__sFILE @__stream);
int putw(int __w, __sFILE @__stream);
Cstring fgets(Cstring __s, int __n, __sFILE @__stream);
Cstring gets(Cstring __s);
int fputs(Cstring __s, __sFILE @__stream);
int puts(Cstring __s);
int ungetc(int __c, __sFILE @__stream);
size_t fread(Cstring __ptr,size_t __size,size_t __n,__sFILE @__stream);
size_t fwrite(Cstring __ptr,size_t __size,size_t __n,__sFILE @__s);
int fseek(__sFILE @__stream, long __off, int __whence);
long ftell(__sFILE @__stream);
void rewind(__sFILE @__stream);
int fgetpos(__sFILE @__stream, fpos_t @__pos);
int fsetpos(__sFILE @__stream, fpos_t @__pos);
void clearerr(__sFILE @__stream);
int feof(__sFILE @__stream);
int ferror(__sFILE @__stream);
void perror(Cstring __s);
int fileno(__sFILE @__stream);
__sFILE *popen(Cstring, Cstring);
int pclose(__sFILE @__stream);
#define s2c(x) (string_to_Cstring(x))
//  #define static_c2s(x) (Cstring_to_string(x))
#define static_c2s(x) (wrap_Cstring_as_string(x,-1))
}}

namespace Std;

abstract struct __sFILE {
  Cstdio::__sFILE *file; // Mirror any changes in runtime_cyc.c
};

int remove(const char ?`r filename) {
  return Cstdio::remove(s2c(filename));
}

int rename(const char ?`r1 old_filename, const char ?`r2 new_filename) {
  return Cstdio::rename(s2c(old_filename), s2c(new_filename));
}

FILE *tmpfile() {
  Cstdio::__sFILE *cf = Cstdio::tmpfile();
  return cf ? new __sFILE(cf) : NULL;
}

char ?`H tmpnam(char ?`H s) {
  char ?name = static_c2s(Cstdio::tmpnam(NULL));
  return s ? strcpy(s, name) : name;
}

int fclose(FILE @`r f) {
  int r = Cstdio::fclose((Cstdio::__sFILE @) f->file);
  if (r == 0) {
    f->file = NULL;
  }
  return r;
}

int fflush(FILE *`r f) {
  // This works even if f->file == NULL; there's no implicit NULL check.
  return f ? Cstdio::fflush(f->file) : Cstdio::fflush(NULL);
}

FILE *freopen(const char ?`r1 x, const char ?`r2 y, FILE @`r3 f) {
  Cstdio::__sFILE *cf = Cstdio::freopen(s2c(x), s2c(y),
                                        (Cstdio::__sFILE @) f->file);
  return cf ? new __sFILE(cf) : NULL;
}

void setbuf(FILE @`r1 f, char ?`r2 buf) {
  setvbuf(f, buf, buf ? _IOFBF : _IONBF, BUFSIZ);
}

void setbuffer(FILE @`r1 f, char ?`r2 buf, size_t size) {
  setvbuf(f, buf, buf ? _IOFBF : _IONBF, size);
}

void setlinebuf(FILE @`r f) {
  setvbuf(f, NULL, _IOLBF, 0);
}

int setvbuf(FILE @`r1 f, char ?`r2 buf, int mode, size_t size) {
  if (buf.size < size)
    throw new Failure("setvbuf: buffer insufficient");
  return Cstdio::setvbuf((Cstdio::__sFILE @) f->file,
                         underlying_Cstring(buf),
                         mode, size);
}

int fgetc(FILE @`r f) { return Cstdio::fgetc((Cstdio::__sFILE @) f->file); }

char ?`r fgets(char ?`r s, int n, FILE @`r2 f) {
  Cstring result;
  Cstring buffer = underlying_Cstring(s); 
  unsigned int len = s.size;
  n = (len < n) ? len : n;
  result = Cstdio::fgets(buffer, n, (Cstdio::__sFILE @) f->file);
  if (result == NULL) 
    return NULL;
  else 
    return s;
}

int fputc(int i, FILE @`r f) {
  return Cstdio::fputc(i, (Cstdio::__sFILE @) f->file);
}

int fputs(const char ?`r1 s, FILE @`r2 f) {
  return Cstdio::fputs(s2c(s), (Cstdio::__sFILE @) f->file);
}

int getc(FILE @`r f) { return Cstdio::getc((Cstdio::__sFILE @) f->file); }

int putc(int i, FILE @`r f) {
  return Cstdio::putc(i, (Cstdio::__sFILE @) f->file);
}

int puts(const char ?`r s) { return Cstdio::puts(s2c(s)); }

int ungetc(int i, FILE @`r f) {
  return Cstdio::ungetc(i,(Cstdio::__sFILE @) f->file);
}

size_t fread(char ?`r1 ptr, size_t size, size_t nmemb, FILE @`r2 f) {
  if (size * nmemb > ptr.size)
    throw new Failure("fread: buffer insufficient");
  return Cstdio::fread(underlying_Cstring(ptr), size, nmemb,
                       (Cstdio::__sFILE @) f->file);
}

size_t fwrite(const char ?`r1 ptr, size_t size, size_t nmemb, FILE @`r2 f) {
  if (size * nmemb > ptr.size)
    throw new Failure("fwrite: buffer insufficient");
  return Cstdio::fwrite(underlying_Cstring(ptr), size, nmemb,
                        (Cstdio::__sFILE @) f->file);
}

int fgetpos(FILE @`r1 f, fpos_t @`r2 x) {
  return Cstdio::fgetpos((Cstdio::__sFILE @) f->file,x);
}

int fseek(FILE @`r f, long offset, int whence) {
  return Cstdio::fseek((Cstdio::__sFILE @) f->file,offset,whence);
}

int fsetpos(FILE @`r f, fpos_t @`r2 x) {
  return Cstdio::fsetpos((Cstdio::__sFILE @) f->file,x);
}

long ftell(FILE @`r f) { return Cstdio::ftell((Cstdio::__sFILE @) f->file); }

void rewind(FILE @`r f) { Cstdio::rewind((Cstdio::__sFILE @) f->file); }

void clearerr(FILE @`r f) { Cstdio::clearerr((Cstdio::__sFILE @) f->file); }

int feof(FILE @`r f) { return Cstdio::feof((Cstdio::__sFILE @) f->file); }

int ferror(FILE @`r f) {
  return Cstdio::ferror((Cstdio::__sFILE @) f->file);
}

void perror(const char ?`r s) { Cstdio::perror(s2c(s)); }

FILE *fopen(const char ?`r1 name, const char ?`r2 type) {
  Cstdio::__sFILE *cf = Cstdio::fopen(s2c(name), s2c(type));
  return cf ? new __sFILE(cf) : NULL;
}

FILE *fdopen(int i, const char ?`r1 s) {
  Cstdio::__sFILE *cf = Cstdio::fdopen(i,s2c(s));
  return cf ? new __sFILE(cf) : NULL;
}

int fileno(FILE @`r f) { return Cstdio::fileno((Cstdio::__sFILE @) f->file); }

int getw(FILE @`r f) { return Cstdio::getw((Cstdio::__sFILE @) f->file); }

int pclose(FILE @`r f) { return Cstdio::pclose((Cstdio::__sFILE @) f->file); }

FILE *popen(const char ? s, const char ? m) {
  Cstdio::__sFILE *cf = Cstdio::popen(s2c(s),s2c(m));
  return (cf ? new __sFILE(cf) : NULL);
}

int putw(int i, FILE @`r f) {
  return Cstdio::putw(i,(Cstdio::__sFILE @) f->file);
}

xtunion exn { 
  FileOpenError(const char ?); 
  FileCloseError;
};

FILE @ file_open(const char ?`r1 fname, const char ?`r2 mode) {
  FILE *f = fopen(fname, mode);
  if (f == NULL) {
    const char ? fn = new {for i < fname.size : fname[i]};
    throw new FileOpenError(fn);
  }
  return (FILE @)f; // FIX: get rid of cast?
}

void file_close(FILE @`r f) {
  if (fclose(f) != 0) throw FileCloseError;
}
