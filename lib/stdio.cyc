#include <core.h>
#include <stdio.h>
#include <string.h> // for strcpy
using Core;

namespace Cstdio {
using Stdio;
extern "C" {
extern struct __sFILE;
typedef struct Cstdio::__sFILE __sFILE;
int	remove(Cstring);
int	rename(Cstring, Cstring);
__sFILE *tmpfile();
Cstring	tmpnam(Cstring);
int	fclose(__sFILE @`r);
int	fflush(__sFILE *`r);
__sFILE *freopen(Cstring, Cstring, __sFILE @`r);
int	setvbuf(__sFILE @`r, Cstring, int, size_t);
int	fgetc(__sFILE @`r);
Cstring fgets(Cstring, int, __sFILE @`r);
int	fputc(int, __sFILE @`r);
int	fputs(Cstring, __sFILE @`r);
int	getc(__sFILE @`r);
Cstring gets(Cstring);
int	putc(int, __sFILE @`r);
int	puts(Cstring);
int	ungetc(int, __sFILE @`r);
size_t	fread(Cstring,size_t _size,size_t _n,__sFILE @`r);
size_t	fwrite(Cstring,size_t _size,size_t _n,__sFILE @`r);
int	fgetpos(__sFILE @`r1, fpos_t @`r2);
int	fseek(__sFILE @`r1, long, int);
int	fsetpos(__sFILE @`r1, fpos_t @`r2);
long	ftell(__sFILE @`r);
void	rewind(__sFILE @`r);
void	clearerr(__sFILE @`r);
int	feof(__sFILE @`r);
int	ferror(__sFILE @`r);
void    perror(Cstring);
__sFILE *	fopen(Cstring _name, Cstring _type);
__sFILE *	fdopen(int, Cstring);
int	fileno(__sFILE @`r);
int	getw(__sFILE @`r);
  //int	pclose(__sFILE @);
  //__sFILE *  popen(Cstring, Cstring);
int	putw(int, __sFILE @`r);
void    setbuffer(__sFILE @`r, Cstring, int);
int	setlinebuf(__sFILE @`r);
#define s2c(x) (string_to_Cstring(x))
}}

namespace Stdio;

abstract struct __sFILE {
  Cstdio::__sFILE *file; // Mirror any changes in runtime_cyc.c
};

int remove(const char ?`r filename) {
  return Cstdio::remove(s2c(filename));
}

int rename(const char ?`r1 old_filename, const char ?`r2 new_filename) {
  return Cstdio::rename(s2c(old_filename), s2c(new_filename));
}

FILE *tmpfile() {
  Cstdio::__sFILE *cf = Cstdio::tmpfile();
  return cf ? new __sFILE(cf) : NULL;
}

char ?`H tmpnam(char ?`H s) {
  char ?name = Cstring_to_string(Cstdio::tmpnam(NULL));
  return s ? String::strcpy(s, name) : name;
}

int fclose(FILE @`r f) {
  int r = Cstdio::fclose((Cstdio::__sFILE @) f->file);
  if (r == 0) {
    f->file = NULL;
  }
  return r;
}

int fflush(FILE *`r f) {
  // This works even if f->file == NULL; there's no implicit NULL check.
  return f ? Cstdio::fflush(f->file) : Cstdio::fflush(NULL);
}

FILE *freopen(const char ?`r1 x, const char ?`r2 y, FILE @`r3 f) {
  Cstdio::__sFILE *cf = Cstdio::freopen(s2c(x), s2c(y),
                                        (Cstdio::__sFILE @) f->file);
  return cf ? new __sFILE(cf) : NULL;
}

void setbuf(FILE @`r1 f, char ?`r2 buf) {
  setvbuf(f, buf, buf ? _IOFBF : _IONBF, BUFSIZ);
}

void setbuffer(FILE @`r1 f, char ?`r2 buf, size_t size) {
  setvbuf(f, buf, buf ? _IOFBF : _IONBF, size);
}

void setlinebuf(FILE @`r f) {
  setvbuf(f, NULL, _IOLBF, 0);
}

int setvbuf(FILE @`r1 f, char ?`r2 buf, int mode, size_t size) {
  if (buf.size < size)
    throw new Failure("setvbuf: buffer insufficient");
  return Cstdio::setvbuf((Cstdio::__sFILE @) f->file,
                         underlying_Cstring(buf),
                         mode, size);
}

int fgetc(FILE @`r f) { return Cstdio::fgetc((Cstdio::__sFILE @) f->file); }

char ?`r fgets(char ?`r s, int n, FILE @`r2 f) {
  Cstring result;
  Cstring buffer = underlying_Cstring(s); 
  unsigned int len = s.size;
  n = (len < n) ? len : n;
  result = Cstdio::fgets(buffer, n, (Cstdio::__sFILE @) f->file);
  if (result == NULL) 
    return NULL;
  else 
    return s;
}

int fputc(int i, FILE @`r f) {
  return Cstdio::fputc(i, (Cstdio::__sFILE @) f->file);
}

int fputs(const char ?`r1 s, FILE @`r2 f) {
  return Cstdio::fputs(s2c(s), (Cstdio::__sFILE @) f->file);
}

int getc(FILE @`r f) { return Cstdio::getc((Cstdio::__sFILE @) f->file); }

int putc(int i, FILE @`r f) {
  return Cstdio::putc(i, (Cstdio::__sFILE @) f->file);
}

int puts(const char ?`r s) { return Cstdio::puts(s2c(s)); }

int ungetc(int i, FILE @`r f) {
  return Cstdio::ungetc(i,(Cstdio::__sFILE @) f->file);
}

size_t fread(char ?`r1 ptr, size_t size, size_t nmemb, FILE @`r2 f) {
  if (size * nmemb > ptr.size)
    throw new Failure("fread: buffer insufficient");
  return Cstdio::fread(underlying_Cstring(ptr), size, nmemb,
                       (Cstdio::__sFILE @) f->file);
}

size_t fwrite(const char ?`r1 ptr, size_t size, size_t nmemb, FILE @`r2 f) {
  if (size * nmemb > ptr.size)
    throw new Failure("fwrite: buffer insufficient");
  return Cstdio::fwrite(underlying_Cstring(ptr), size, nmemb,
                        (Cstdio::__sFILE @) f->file);
}

int fgetpos(FILE @`r1 f, fpos_t @`r2 x) {
  return Cstdio::fgetpos((Cstdio::__sFILE @) f->file,x);
}

int fseek(FILE @`r f, long offset, int whence) {
  return Cstdio::fseek((Cstdio::__sFILE @) f->file,offset,whence);
}

int fsetpos(FILE @`r f, fpos_t @`r2 x) {
  return Cstdio::fsetpos((Cstdio::__sFILE @) f->file,x);
}

long ftell(FILE @`r f) { return Cstdio::ftell((Cstdio::__sFILE @) f->file); }

void rewind(FILE @`r f) { Cstdio::rewind((Cstdio::__sFILE @) f->file); }

void clearerr(FILE @`r f) { Cstdio::clearerr((Cstdio::__sFILE @) f->file); }

int feof(FILE @`r f) { return Cstdio::feof((Cstdio::__sFILE @) f->file); }

int ferror(FILE @`r f) {
  return Cstdio::ferror((Cstdio::__sFILE @) f->file);
}

void perror(const char ?`r s) { Cstdio::perror(s2c(s)); }

FILE *fopen(const char ?`r1 name, const char ?`r2 type) {
  Cstdio::__sFILE *cf = Cstdio::fopen(s2c(name), s2c(type));
  return cf ? new __sFILE(cf) : NULL;
}

FILE *fdopen(int i, const char ?`r1 s) {
  Cstdio::__sFILE *cf = Cstdio::fdopen(i,s2c(s));
  return cf ? new __sFILE(cf) : NULL;
}

int fileno(FILE @`r f) { return Cstdio::fileno((Cstdio::__sFILE @) f->file); }

int getw(FILE @`r f) { return Cstdio::getw((Cstdio::__sFILE @) f->file); }

//int pclose(FILE @f) { return Cstdio::pclose((Cstdio::__sFILE @) f->file); }

//FILE *popen(string s, string m) {
//  Cstdio::__sFILE *cf = Cstdio::popen(s2c(s),s2c(m));
//  return cf ? new __sFILE(cf) : NULL;
//}

int putw(int i, FILE @`r f) {
  return Cstdio::putw(i,(Cstdio::__sFILE @) f->file);
}

xtunion exn { 
  FileOpenError(const char ?); 
  FileCloseError;
};

FILE @ file_open(const char ?`r1 fname, const char ?`r2 mode) {
  FILE *f = fopen(fname, mode);
  if (f == NULL) {
    const char ? fn = new {for i < fname.size : fname[i]};
    throw new FileOpenError(fn);
  }
  return (FILE @)f; // FIX: get rid of cast?
}

void file_close(FILE @`r f) {
  if (fclose(f) != 0) throw FileCloseError;
}
