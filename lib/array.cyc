#include "core.h"
#include "array.h"

#include "list.h"
using List;
using Core;

namespace Array;




/* Array sorting algorithm using Quicksort.  Ported from: */

/******************************************************************/
/* qsort.c  --  Non-Recursive ANSI Quicksort function             */
/*                                                                */
/* Public domain by Raymond Gardner, Englewood CO  February 1991  */
/*                                                                */
/* Usage:                                                         */
/*     qsort(base, nbr_elements, width_bytes, compare_function);  */
/*        void *base;                                             */
/*        size_t nbr_elements, width_bytes;                       */
/*        int (*compare_function)(const void *, const void *);    */
/*                                                                */
/* Sorts an array starting at base, of length nbr_elements, each  */
/* element of size width_bytes, ordered via compare_function,     */
/* which is called as  (*compare_function)(ptr_to_element1,       */
/* ptr_to_element2) and returns < 0 if element1 < element2,       */
/* 0 if element1 = element2, > 0 if element1 > element2.          */
/* Most refinements are due to R. Sedgewick. See "Implementing    */
/* Quicksort Programs", Comm. ACM, Oct. 1978, and Corrigendum,    */
/* Comm. ACM, June 1979.                                          */
/******************************************************************/

#define  SWAP(a, b)  { temp = arr[a]; arr[a] = arr[b]; arr[b] = temp; }
#define  COMP(a, b)  (less_eq(arr[a], arr[b]))
#define  T           3    /* subfiles of T or fewer elements will */
                          /* be sorted by a simple insertion sort */
                          /* Note!  T must be at least 3          */


// FIX: had to lift this out of the qsort function.  The problem is,
// no default initializers, and translation of initializers within
// function does not give legal C.
static int sp[40] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};

void qsort<`a>(int less_eq(`a,`a),`a arr[?],int base_ofs, int len)
{
  `a temp;
  // int sp[40]; // FIX: complains not initialized
  int sp_ofs;           /* stack and stack pointer        */
  int i, j, limit_ofs;         /* scan and limit pointers        */

  if (base_ofs < 0 || base_ofs + len > arr.size || len < 0)
    throw Core::InvalidArg("Array::qsort");

  limit_ofs = base_ofs + len;
  sp_ofs = 0;

  for ( ;; ) {                  /* repeat until break...          */
    if ( limit_ofs - base_ofs > T ) { /* if more than T elements  */
                                      /*   swap base with middle  */
         SWAP((limit_ofs-base_ofs)/2 + base_ofs, base_ofs);
         i = base_ofs + 1;            /* i scans left to right    */
         j = limit_ofs - 1;           /* j scans right to left    */
         if ( COMP(i, j) > 0 )        /* Sedgewick's              */
            SWAP(i, j);               /*    three-element sort    */
         if ( COMP(base_ofs, j) > 0 ) /*        sets things up    */
            SWAP(base_ofs, j);        /*            so that       */
         if ( COMP(i, base_ofs) > 0 ) /*      *i <= *base <= *j   */
            SWAP(i, base_ofs);        /* *base is pivot element   */
         for ( ;; ) {                 /* loop until break         */
            do                        /* move i right             */
               i ++;                  /*        until *i >= pivot */
            while ( COMP(i, base_ofs) < 0 );
            do                        /* move j left              */
               j --;                  /*        until *j <= pivot */
            while ( COMP(j, base_ofs) > 0 );
            if ( i > j )              /* if pointers crossed      */
               break;                 /*     break loop           */
            SWAP(i, j);       /* else swap elements, keep scanning*/
         }
         SWAP(base_ofs, j);     /* move pivot into correct place  */
                                        /* if left subfile larger */
         if ( j - base_ofs > limit_ofs - i ) {  
            sp[sp_ofs] = base_ofs;    /* stack left subfile base  */
            sp[sp_ofs+1] = j;         /*    and limit             */
            base_ofs = i;             /* sort the right subfile   */
         } else {                     /* else right subfile larger*/
            sp[sp_ofs] = i;           /* stack right subfile base */
            sp[sp_ofs+1] = limit_ofs; /*    and limit             */
            limit_ofs = j;            /* sort the left subfile    */
         }
         sp_ofs += 2;                 /* increment stack pointer  */
      } else {      /* else subfile is small, use insertion sort  */
         for ( j = base_ofs, i = j+1; i < limit_ofs; j = i, i ++ )
            for ( ; COMP(j, j+1) > 0; j -- ) {
               SWAP(j, j+1);
               if ( j == base_ofs )
                  break;
            }
         if ( sp_ofs != 0 ) {         /* if any entries on stack  */
            sp_ofs -= 2;              /* pop the base and limit   */
            base_ofs = sp[sp_ofs];
            limit_ofs = sp[sp_ofs+1];
         } else                       /* else stack empty, done   */
            break;
      }
   }
}



//-------------------------------------------
// Jeff Vinocur


// Mergesort (stable)

#define LESSEQ(a,b) (less_eq(from[a],from[b]))
#define MIN(a,b) (a < b ? a : b)
#define PUT(a) to[dest++] = from[a++]


void msort<`a>(int less_eq(`a,`a),`a arr[?],int base_ofs, int len) {

  if (base_ofs < 0 || base_ofs + len > arr.size || len < 0)
    throw Core::InvalidArg("Array::msort");

  int limit_ofs = base_ofs + len; // This is one past the last elt to sort

  // This doesn't need two scratch arrays, since we could go back and 
  // forth from the to-be-sorted slice of the original array, but
  // I'm not sure how the need to add base_ofs to every subscript and
  // update would compare with the cost of the extra copy and space
  // usage, but it really made my head hurt to think about, so I
  // decided not to do it both ways just to benchmark.
  `a from[?] = new {for i < len : arr[0]}; // fill with junk
  `a to[?] = new {for i < len : arr[i+base_ofs]};
  `a swap[?];
   
  int stepsize; // Non-recursive mergesort repeatedly walks over
                // the array, each time in bigger steps.
  int start;    // For each "stepsize", we "start" at different 
                // offsets and merge two segments of that length.
  int lstart, lend, rstart, rend;
                // These are start, end of left (l) and right(r)
                // segments being merged.
  int dest;     // This is the offset currently being filled in
                // the "to" array.  (Smaller element from the
                // left and right halves is written to to[dest].)

  for (stepsize = 1; stepsize < len; stepsize = stepsize * 2) {
    swap = from;
    from = to;
    to = swap;
    dest = 0;

    for (start = 0; start < limit_ofs; start = start + (stepsize * 2)) {
      lstart = start;
      rstart = MIN(start + stepsize, limit_ofs);
      lend = rstart;
      rend = MIN(start + (stepsize * 2), limit_ofs);

      while (lstart < lend && rstart < rend) {
        if (LESSEQ(lstart,rstart) <= 0) { // The <= makes it a stable sort
          PUT(lstart);
        } else {
          PUT(rstart);
        }
      }

      // Copy remaining elements.  Only one of these loops runs.
      while (lstart < lend) {
        PUT(lstart);
      }
      while (rstart < rend) {
        PUT(rstart);
      }
    }
  }

  for (int i = 0; i < len; i++) arr[i+base_ofs] = to[i];
}









//////// Below are bunches of stuff mimicking the List library

`a from_list<`a>(List::list<`a> x) [?] {
  return List::to_array(x);
}

list<`a> to_list<`a>(`a x[?]) {
  return List::from_array(x);
}

// return a fresh copy of the array (same as map of the identity) 
`a copy<`a>(`a x[?]) [?] {
  int sx = x.size;
  return new {for i < sx : x[i]};
}

// Apply a function to each element in an array, returning a new array. 
`b map<`a,`b>(`b f(`a),`a x[?]) [?] {
  int sx = x.size;
  return new {for i < sx : f(x[i])};
}
// Apply a function to each element in an array, returning a new array. 
// This uses an additional argument to simulate function closures.
`b map_c<`a,`b,`c>(`b f(`c,`a),`c env,`a x[?]) [?] {
  int sx = x.size;
  return new {for i < sx : f(env,x[i])};
}

// Apply a function to each element in an array, writing the results
// back into the array.
void imp_map<`a>(`a f(`a),`a x[?]) {
  int sx = x.size;
  for (int i = 0; i<sx; i++) x[i]=f(x[i]);
}
void imp_map_c<`a,`b>(`a f(`b,`a),`b env,`a x[?]) {
  int sx = x.size;
  for (int i = 0; i<sx; i++) x[i]=f(env,x[i]);
}

// thrown when two arrays don't have the same size 
xenum exn {Array_mismatch};

// Given two arrays of the same length and a function, apply the function
// to each pair of elements (in order) and collect the results in a new array.
// Throws Array_mismatch if the sizes of the arrays aren't the same.
`c map2<`a,`b,`c>(`c f(`a,`b),`a x[?],`b y[?]) [?] {
  int sx = x.size;
  if (sx != y.size) throw Array_mismatch;
  return new {for i < sx : f(x[i],y[i])};
}



// Apply some function to each element of the array, but don't bother to
// save the result.  Similar to Ocaml's List.iter but doesn't require
// void type for the result of the function.
void app<`a,`b>(`b f(`a),`a x[?]) {
  int sx = x.size;
  for (int i = 0; i < sx; i++) f(x[i]);
}
void app_c<`a,`b,`c>(`c f(`a,`b),`a env,`b x[?]) {
  int sx = x.size;
  for (int i = 0; i < sx; i++) f(env,x[i]);
}

// same as app but with void functions -- unlike Popcorn, the iter
// functions are no longer needed because we treat "void" as a boxed
// type.  
void iter<`a>(void f(`a),`a x[?]) {
  int sx = x.size;
  for (int i = 0; i < sx; i++) f(x[i]);
}

// same as app_c but with void functions
void iter_c<`a,`b>(void f(`b,`a),`b env,`a x[?]) {
  int sx = x.size;
  for (int i = 0; i < sx; i++) f(env,x[i]);
}

// Same as app, but generalized to a pair of arrays.  Throws Array_mismatch
// if the lengths of the arrays aren't the same.  
void app2<`a,`b,`c>(`c f(`a,`b),`a x[?],`b y[?]) {
  int sx = x.size;
  if (sx != y.size) throw Array_mismatch;
  for (int i=0; i < sx; i++) f(x[i],y[i]);
}

void app2_c<`a,`b,`c,`d>(`d f(`a,`b,`c),`a env,`b x[?],`c y[?]) {
  int sx = x.size;
  if (sx != y.size) throw Array_mismatch;
  for (int i=0; i < sx; i++) f(env,x[i],y[i]);
} 

// Same as iter, but generalized to a pair of arrays.  Throws Array_mismatch
// if the lengths of the arrays aren't the same.  
void iter2<`a,`b>(void f(`a,`b),`a x[?],`b y[?]) {
  int sx = x.size;
  if (sx != y.size) throw Array_mismatch;
  for (int i=0; i < sx; i++) f(x[i],y[i]);
}

void iter2_c<`a,`b,`c>(void f(`a,`b,`c),`a env,`b x[?],`c y[?]) {
  int sx = x.size;
  if (sx != y.size) throw Array_mismatch;
  for (int i=0; i < sx; i++) f(env,x[i],y[i]);
}



// Given an array [|x1,x2,...,xn-1,xn|], a function f, and an accumulator
// a, return f(f(...(f(x2,f(x1,a))),xn-1),xn).  Notice that the function
// is first applied to the left-most element of the array.
`a fold_left<`a,`b>(`a f(`a,`b),`a accum,`b x[?]) {
  int sx = x.size;
  for(int i=0; i < sx; i++) {
    accum = f(accum,x[i]);
  }
  return accum;
}

`a fold_left_c<`a,`b,`c>(`a f(`c,`a,`b),`c env,`a accum,`b x[?]) {
  int sx = x.size;
  for(int i=0; i < sx; i++) {
    accum = f(env,accum,x[i]);
  }
  return accum;
}

// Given an array [|x1,x2,....,xn-1,xn|], a function f, and an accumulator
// a, return f(x1,f(x2,...,f(xn-1,f(xn,a))...)).  Notice that the function
// is first applied to the right-most element of the list. 
`b fold_right<`a,`b>(`b f(`a,`b),`a x[?],`b accum) {
  for(int i=x.size-1; i >= 0; i--) {
    accum = f(x[i],accum);
  }
  return accum;
}
`b fold_right_c<`a,`b,`c>(`b f(`c,`a,`b),`c env,`a x[?],`b accum) {
  for(int i=x.size-1; i>=0; i--) {
    accum = f(env,x[i],accum);
  }
  return accum;
}

// Return a copy of an array in reverse.
`a rev_copy<`a>(`a x[?]) [?] {
  int sx = x.size;
  int n = sx - 1;
  return new {for i < sx : x[n-i]};
}

// Imperatively reverse an array.
void imp_rev<`a>(`a x[?]) {
  `a temp;
  int i = 0;
  int j = x.size-1;
  while (i < j) {
    temp = x[i];
    x[i] = x[j];
    x[j] = temp;
    i++;
    j--;
  }
}

// Given a predicate on 'a values, determine whether every element in an
// array satisfies the predicate.
bool forall<`a>(bool pred(`a),`a x[?]) {
  int sx = x.size;
  for(int i=0; i < sx; i++) {
    if (! pred(x[i])) return false;
  }
  return true;
}
bool forall_c<`a,`b>(bool pred(`a,`b),`a env,`b x[?]) {
  int sx = x.size;
  for(int i=0; i < sx; i++) {
    if (! pred(env,x[i])) return false;
  }
  return true;
}

// Given a predicate on 'a values, determine whether there exists an element
// in the array that satisfies the predicate.
bool exists<`a>(bool pred(`a),`a x[?]) {
  int sx = x.size;
  for(int i=0; i < sx; i++) {
    if (pred(x[i])) return true;
  }
  return false;
}
bool exists_c<`a,`b>(bool pred(`a,`b),`a env,`b x[?]) {
  int sx = x.size;
  for(int i=0; i < sx; i++) {
    if (pred(env,x[i])) return true;
  }
  return false;
}

// Given [|x1,...,xn|] and [|y1,...,yn|], return [|(x1,y1),...,(xn,yn)|].  
// Throws Array_mismatch if the lengths are not the same.
$(`a,`b) zip<`a,`b>(`a x[?],`b y[?]) [?] {
  int sx = x.size;
  if (sx != y.size) throw Array_mismatch;

  return new { for i < sx : $(x[i],y[i]) };
}

// Given [|(x1,y1),...,(xn,yn)|], return ([|x1,...,xn|],[|y1,...,yn|]) 
$(`a [?],`b[?]) split<`a,`b>($(`a,`b) x[?]) {
  int sx = x.size;
  return $(new {for i < sx : (x[i])[0]},
           new {for i < sx : (x[i])[1]});
}


// Given an array [|x1,...,xn|] and x, determine if x is in the array.
// Uses physical equality for comparison.
bool memq<`a>(`a l[?], `a x) {
  int s = l.size;
  for(int i = 0; i < s; i++) {
    if (l[i] == x) return true;
  }
  return false;
}

bool mem<`a>(int compare(`a,`a), `a l[?], `a x) {
  int s = l.size;
  for(int i = 0; i < s; i++) {
    if (0==compare(l[i],x)) return true;
  }
  return false;
}

// Creates a new (smaller) array containing the specified slice of the
// target array.  The last parameter is an int option of the number of 
// elements to take, or null for "take until the end of the array".
`a extract<`a>(`a x[?],int start,Core::Opt_t<int> n_opt) [?] {
  int sx = x.size;
  int n = (n_opt == null ? sx - start : n_opt->v);

  if (start < 0 || n <= 0 || start + (n_opt == null ? 0 : n) > sx)
    throw Core::InvalidArg("Array::extract");

  return new {for i < n : x[start+i]};
}
