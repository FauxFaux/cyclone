
{ 
  /* Ported by Dan from the ocaml implementation */
#include "core.h"
#include "stdio.h"
#include "lexing.h"
#include "string.h"
#include "lineno.h"

namespace Lineno;

#define NEWLINE 1
#define LINEDEF 2
#define END     3

}

let newline = ('\n' | '\r' | "\r\n")
  
rule token = parse 
  "#" [^ '\n' '\r']* newline { return LINEDEF; }
| [^ '\n' '\r']* newline     { return NEWLINE; }
| [^ '\n' '\r']* eof         { return END;     }

{

using Core;
using Stdio;
using Lexing;
using String;

struct Pos {
  string logical_file;
  string line;
  int    line_no;
  int    col;
};

static opt_t<$(string,int)@> parse_linedef(string line) {
  try {
    int i = 0;
    while (i < line.size && (line[i] < '0' || line[i] > '9')) ++i;
    int j = i;
    while (j < line.size && line[j] >= '0' && line[j] <= '9') ++j;
    if (i == line.size) return null; // if there's no number
    int number = int_of_string(substring(line,i,j-i));
    while (j < line.size && line[j] != '"') ++j;
    int k = ++j;
    while (k < line.size && line[k] != '"') ++k;
    if (j == line.size || k == line.size) return null; // if there's no name
    string fname = substring(line,j,k-j);

    return new Opt(new $(fname,number));
  } catch {
  default:
    return null;
  }      
}

int place_cmp($(int,pos_t)@ place1, $(int,pos_t)@ place2) {
  return intcmp((*place1)[0],(*place2)[0]);
}

// mutates its second argument's elements
void poss_of_abss(string filename, List::list_t<$(int,pos_t)@> places) {
  places = List::merge_sort(place_cmp, places);
  FILE @f = file_open(filename, "r");
  try {
    Lexbuf<Function_lexbuf_state<FILE@>> lbuf = from_file(f);
    string source_file = filename;
    int    line        = 1;

    string this_line;
    int eol, next;
    while(places != null) {
      while (true) {
	next      = token(lbuf);
	eol       = lexeme_end(lbuf);
	this_line = lexeme(lbuf); // FIX: expensive string copy
	if (eol >= (*places->hd)[0]) 
	  break;
	
	switch (next) {
	case END:     throw new Failure("Lineno: Invalid file position");
	case NEWLINE: ++line; break;
	case LINEDEF: 
	  opt_t<$(string,int)@> fno = parse_linedef(this_line);
	  if (fno == null) {
	    ++line;
	    fprintf(stderr, "Unknown directive: %s\n", this_line);
	  } else {
	    source_file = (*fno->v)[0]; 
	    line        = (*fno->v)[1];
	  }
	  break;
	default: throw new Failure("Lineno: Impossible");
	}
      }
      while(places != null && eol >= (*places->hd)[0]) {
	let p = (*places->hd)[1];
	p->logical_file = source_file;
	p->line         = this_line;
	p->line_no      = line;
	p->col          = strlen(this_line)-(eol-(*places->hd)[0]);
	places = places->tl;
      }
      ++line;
    }
  } catch { case y: file_close(f); throw (y); }
  file_close(f);
  return;
}

pos_t pos_of_abs(string filename, int abs) {
  pos_t ans = new Pos("","",0,0);
  poss_of_abss(filename, new List::List(new $(abs,ans),null));
  return ans;
}

}
