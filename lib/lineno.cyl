
{ 
  /* Ported by Dan from the ocaml implementation */
#include "core.h"
#include "lexing.h"
#include "string.h"
#include "lineno.h"

namespace Lineno;

#define NEWLINE 1
#define LINEDEF 2
#define END     3

}

let newline = ('\010' | '\013' | "\013\010")
  
rule token = parse 
  "#" [^ '\010' '\013']* newline { return LINEDEF; }
| [^ '\010' '\013']* newline     { return NEWLINE; }
| [^ '\010' '\013']* eof         { return END;     }

{

using Core;
using Lexing;
using String;

struct pos {
  string logical_file;
  string line;
  int    line_no;
  int    col;
};

static Opt_t<$(string,int)@> parse_linedef(string line) {
  try {
    int i = 0;
    while (i < size(line) && (line[i] < '0' || line[i] > '9')) ++i;
    int j = i;
    while (j < size(line) && line[j] >= '0' && line[j] <= '9') ++j;
    if (i == size(line)) return null; // if there's no number
    int number = int_of_string(substring(line,i,j-i));
    while (j < size(line) && line[j] != '"') ++j;
    int k = ++j;
    while (k < size(line) && line[k] != '"') ++k;
    if (j == size(line) || k == size(line)) return null; // if there's no name
    string fname = substring(line,j,k-j);

    return &Opt(&$(fname,number));
  } catch {
  default:
    return null;
  }      
}

int place_cmp($(int,Pos)@ place1, $(int,Pos)@ place2) {
  return intcmp(place1[0],place2[0]);
}

// mutates its second argument's elements
void poss_of_abss(string filename, List::list<$(int,Pos)@> places) {
  places = List::merge_sort(place_cmp, places);
  FILE @f = file_open(filename, "r");
  try {
    Lexbuf<Function_lexbuf_state<FILE@>> lbuf = from_file(f);
    string source_file = filename;
    int line = 1;

    // initializations unnecessary after def. assignment better about loops
    string this_line="";
    int eol=0, next=0;
    while(places != null) {
      while (true) {
	next = token(lbuf);
	eol  = lexeme_end(lbuf);
	if (eol >= places->hd[0]) break;
	this_line = lexeme(lbuf);
	
	switch (next) {
	case END:     throw Failure("Lineno: Invalid file position");
	case NEWLINE: ++line; break;
	case LINEDEF: 
	  Opt_t<$(string,int)@> fno = parse_linedef(this_line);
	  if (fno == null) {
	    ++line;
	    fprintf(cyc_stderr, "Unknown directive: %s\n", this_line);
	  } else {
	    source_file = fno->v[0]; 
	    line        = fno->v[1];
	  }
	  break;
	default: throw Failure("Lineno: Impossible");
	}
      }
      while(places != null && eol >= places->hd[0]) {
	let p = places->hd[1];
	p->logical_file = source_file;
	p->line         = this_line;
	p->line_no      = line;
	p->col          = strlen(this_line)-(eol-places->hd[0]);
	places = places->tl;
      }
      ++line;
    }
  } catch {
  case y:
    file_close(f); throw (y);
  }
  file_close(f);
  return;
}

Pos pos_of_abs(string filename, int abs) {
  Pos ans = &pos("","",0,0);
  poss_of_abss(filename, &List::cons(&$(abs,ans),null));
  return ans;
}

}
