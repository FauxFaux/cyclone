
{ 
  /* Ported by Dan from the ocaml implementation */
#include "core.h"
#include "lexing.h"
#include "string.h"
#include "lineno.h"

namespace Lineno;

#define NEWLINE 1
#define LINEDEF 2
#define END     3

}

let newline = ('\012' | '\015' | "\015\012")
  
rule token = parse 
  "#" [^ '\012' '\015']* newline { return LINEDEF; }
| [^ '\012' '\015']* newline     { return NEWLINE; }
| [^ '\012' '\015']* eof         { return END;     }

{

using Core;
using Lexing;
using String;

struct pos {
  string logical_file;
  string line;
  int    line_no;
  int    col;
};

static Opt_t<$(string,int)@> parse_linedef(string line) {
  try {
    int i = 0;
    while (i < line.size && (line[i] < '0' || line[i] > '9')) ++i;
    int j = i;
    while (j < line.size && line[j] >= '0' && line[j] <= '9') ++j;
    if (i == line.size) return null; // if there's no number
    int number = int_of_string(substring(line,i,j-i));
    while (j < line.size && line[j] != '"') ++j;
    int k = ++j;
    while (k < line.size && line[k] != '"') ++k;
    if (j == line.size || k == line.size) return null; // if there's no name
    string fname = substring(line,j,k-j);

    return &Opt(&$(fname,number));
  } catch {
  default:
    return null;
  }      
}

int place_cmp($(int,Pos)@ place1, $(int,Pos)@ place2) {
  return intcmp(place1[0],place2[0]);
}

// mutates its second argument's elements
void poss_of_abss(string filename, List::list<$(int,Pos)@> places) {
  places = List::merge_sort(place_cmp, places);
  FILE @f = file_open(filename, "r");
  try {
    Lexbuf<Function_lexbuf_state<FILE@>> lbuf = from_file(f);
    string source_file = filename;
    int    line        = 1;

    string this_line;
    int eol, next;
    while(places != null) {
      while (true) {
	next      = token(lbuf);
	eol       = lexeme_end(lbuf);
	this_line = lexeme(lbuf); // FIX: expensive string copy
	if (eol >= places->hd[0]) 
	  break;
	
	switch (next) {
	case END:     throw Failure("Lineno: Invalid file position");
	case NEWLINE: ++line; break;
	case LINEDEF: 
	  Opt_t<$(string,int)@> fno = parse_linedef(this_line);
	  if (fno == null) {
	    ++line;
	    fprintf(cyc_stderr, "Unknown directive: %s\n", this_line);
	  } else {
	    source_file = fno->v[0]; 
	    line        = fno->v[1];
	  }
	  break;
	default: throw Failure("Lineno: Impossible");
	}
      }
      while(places != null && eol >= places->hd[0]) {
	let p = places->hd[1];
	p->logical_file = source_file;
	p->line         = this_line;
	p->line_no      = line;
	p->col          = strlen(this_line)-(eol-places->hd[0]);
	places = places->tl;
      }
      ++line;
    }
  } catch { case y: file_close(f); throw (y); }
  file_close(f);
  return;
}

Pos pos_of_abs(string filename, int abs) {
  Pos ans = &pos("","",0,0);
  poss_of_abss(filename, &List::cons(&$(abs,ans),null));
  return ans;
}

}
