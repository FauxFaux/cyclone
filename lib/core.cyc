#include "core.h"

////////////////////////////////////////////////////////////////////////////
// Popcorn library, file core.pop                                         //
// Copyright Greg Morrisett, Dan Grossman                                 //
// January 1999, all rights reserved                                      //
//                                                                        //
////////////////////////////////////////////////////////////////////////////

namespace String {
extern string strconcat(string,string);
}

// The rest is all Cyclone
namespace Core;

xtunion exn { InvalidArg(string) };
xtunion exn { SysError(int) };

/////////////////////////////Generally Useful Things//////////////
xtunion exn { Failure(string) };
xtunion exn { Impossible(string) };
xtunion exn { Not_found };
xtunion exn { Unreachable(string) };

opt_t<`b> opt_map(`b f(`a), opt_t<`a> o) {
  if (o==null)
    return null;
  return new Opt(f(o->v));
}

string new_string(int i) {
  return (new {for j < i : '\000'});
}

bool true_f(`a x)  {  return true;  }
bool false_f(`a x) {  return false; }

int intcmp(int a, int b)   { return a - b; }
int charcmp(char a,char b) { return (int)a - (int)b; }
int ptrcmp(`a::M @ `r a, `a @ `r b) {
  if(a == b) return 0;
  if(a >  b) return 1;
  return -1;
}

`a fst($(`a,`b) @`r pair) { return (*pair)[0]; }
`b snd($(`a,`b) @`r pair) { return (*pair)[1]; }
`c third($(`a,`b,`c) @`r triple) { return (*triple)[2];}

`a identity(`a x) {
  return x;
}

bool is_space(char c) {
  switch ((int)c) {
  case  9: return true;
  case 10: return true;
  case 11: return true;
  case 12: return true;
  case 13: return true;
  case 32: return true;
  default: return false;
  }
}

static int int_of_char(char c) {
  if ('0'<=c && c<='9')      return c-'0';
  else if ('a'<=c && c<='f') return 10+c-'a';
  else if ('A'<=c && c<='F') return 10+c-'A';
  else throw new InvalidArg("string to integer conversion");
}

int int_of_string(string s)
{
  int n, i, base;
  int sign = 1;

  // skip leading whitespace and eat the sign
  for(i=0; i<s.size && is_space(s[i]); ++i)
    ;
  while (i<s.size &&(s[i]=='-' || s[i]=='+')) {
    if (s[i]=='-') sign = - sign;
    i++;
  } 
  if (i==s.size) 
    throw new InvalidArg("string to integer conversion");

  // determine the base
  if (i+1 == s.size || s[i]!='0') 
    base = 10;
  else {
    switch (s[++i]) {
    case 'x': base = 16;  ++i; break;
    case 'o': base =  8;  ++i; break;
    case 'b': base =  2;  ++i; break;
    default:  base = 10; break;
    }
  }
  // do the math
  for(n=0; i<s.size && s[i] != '\000'; ++i) {
    int digit = int_of_char(s[i]);
    if (digit >= base) 
      throw new InvalidArg("string to integer conversion");
    n = n*base+digit;
  }
  return sign*n;
}

string string_of_int_width(int n, int minWidth) {
  int i, len = 0;
  bool negative = false;
  if (n < 0) {
    negative=true;
    ++len;
    n = -n;
  }
  int m = n;
  do ++len; while ((m /= 10) > 0);
  len = len > minWidth ? len : minWidth;
  string ans = new_string(len+1);
  for(i=len-1; n > 0; --i) { 
    ans[i] = (char)('0' + (n % 10));
    n /= 10;
  }
  for (; i>=0; --i)
    ans[i] = '0';

  // this line should be here (Luke 11-10-99)
  if (negative) ans[0] = '-';
  return ans;
}

string string_of_int(int n) {
  return string_of_int_width(n,0);
}

string string_of_uint(unsigned int n) {
  int len = 0;
  unsigned int m = n;
  do ++len; while ((m /= 10) > 0);
  string ans = new_string(len+1);
  for(int i=len-1; i>=0; --i) {
    ans[i] = (char)('0' + n % 10);
    n /= 10;
  }
  return ans;
}

string string_of_char(char c) {
  string ans = new_string(2);
  ans[0] = c;
  return ans;
}
