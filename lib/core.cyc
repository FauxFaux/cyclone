/* This file is part of the Cyclone Library.
   Copyright (C) 1999-2001 Greg Morrisett, Dan Grossman, AT&T

   This library is free software; you can redistribute it and/or it
   under the terms of the GNU Lesser General Public License as
   published by the Free Software Foundation; either version 2.1 of
   the License, or (at your option) any later version.

   This library is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with this library; see the file COPYING.LIB.  If not,
   write to the Free Software Foundation, Inc., 59 Temple Place, Suite
   330, Boston, MA 02111-1307 USA. */

#include <core.h>

// The rest is all Cyclone
namespace Core;

xtunion exn { InvalidArg(string_t) };
xtunion exn { SysError(int) };

/////////////////////////////Generally Useful Things//////////////
xtunion exn { Failure(string_t) };
xtunion exn { Impossible(string_t) };
xtunion exn { Not_found };
xtunion exn { Unreachable(string_t) };
struct Opt<`a> { `a v; };
opt_t<`b,`H> opt_map(`b f(`a), opt_t<`a> o) {
  if (o==NULL)
    return NULL;
  return new Opt(f(o->v));
}

mstring_t<`H> new_string(int i) {
  return (new {for j < i : '\000'});
}

char ?`r rnew_string(region_t<`r> r, int i) {
  return (rnew(r) {for j < i : '\000'});
}

bool true_f(`a x)  {  return true;  }
bool false_f(`a x) {  return false; }

int intcmp(int a, int b)   { return a - b; }
int charcmp(char a,char b) { return (int)a - (int)b; }
int ptrcmp(`a::M @ `r a, `a @ `r b) {
  if(a == b) return 0;
  if(a >  b) return 1;
  return -1;
}

`a fst($(`a,`b) @ pair) { return (*pair)[0]; }
`b snd($(`a,`b) @ pair) { return (*pair)[1]; }
`c third($(`a,`b,`c) @ triple) { return (*triple)[2];}

`a identity(`a x) {
  return x;
}

bool is_space(char c) {
  switch ((int)c) {
  case  9: return true;
  case 10: return true;
  case 11: return true;
  case 12: return true;
  case 13: return true;
  case 32: return true;
  default: return false;
  }
}

static int int_of_char(char c) {
  if ('0'<=c && c<='9')      return c-'0';
  else if ('a'<=c && c<='f') return 10+c-'a';
  else if ('A'<=c && c<='F') return 10+c-'A';
  else throw new InvalidArg("string to integer conversion");
}

int int_of_string(string_t s)
{
  int n, i, base;
  int sign = 1;

  // skip leading whitespace and eat the sign
  for(i=0; i<s.size && is_space(s[i]); ++i)
    ;
  while (i<s.size &&(s[i]=='-' || s[i]=='+')) {
    if (s[i]=='-') sign = - sign;
    i++;
  } 
  if (i==s.size) 
    throw new InvalidArg("string to integer conversion");

  // determine the base
  if (i+1 == s.size || s[i]!='0') 
    base = 10;
  else {
    switch (s[++i]) {
    case 'x': base = 16;  ++i; break;
    case 'o': base =  8;  ++i; break;
    case 'b': base =  2;  ++i; break;
    default:  base = 10; break;
    }
  }
  // do the math
  for(n=0; i<s.size && s[i] != '\000'; ++i) {
    int digit = int_of_char(s[i]);
    if (digit >= base) 
      throw new InvalidArg("string to integer conversion");
    n = n*base+digit;
  }
  return sign*n;
}

mstring_t<`H> string_of_int_width(int n, int minWidth) {
  int i, len = 0;
  bool negative = false;
  if (n < 0) {
    negative=true;
    ++len;
    n = -n;
  }
  int m = n;
  do ++len; while ((m /= 10) > 0);
  len = len > minWidth ? len : minWidth;
  mstring_t ans = new_string(len+1);
  for(i=len-1; n > 0; --i) { 
    ans[i] = (char)('0' + (n % 10));
    n /= 10;
  }
  for (; i>=0; --i)
    ans[i] = '0';

  // this line should be here (Luke 11-10-99)
  if (negative) ans[0] = '-';
  return ans;
}

mstring_t<`H> string_of_int(int n) {
  return string_of_int_width(n,0);
}

mstring_t<`H> string_of_uint(unsigned int n) {
  int len = 0;
  unsigned int m = n;
  do ++len; while ((m /= 10) > 0);
  mstring_t ans = new_string(len+1);
  for(int i=len-1; i>=0; --i) {
    ans[i] = (char)('0' + n % 10);
    n /= 10;
  }
  return ans;
}

mstring_t<`H> string_of_char(char c) {
  mstring_t ans = new_string(2);
  ans[0] = c;
  return ans;
}
