/* This file is part of the Cyclone Library.
   Copyright (C) 2001 Greg Morrisett

   This library is free software; you can redistribute it and/or it
   under the terms of the GNU Lesser General Public License as
   published by the Free Software Foundation; either version 2.1 of
   the License, or (at your option) any later version.

   This library is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with this library; see the file COPYING.LIB.  If not,
   write to the Free Software Foundation, Inc., 59 Temple Place, Suite
   330, Boston, MA 02111-1307 USA. */

#include <core.h>
#include <execinfo.h>
using Core;

#include <stdio.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <signal.h>

#ifdef __linux__
#include <unistd.h>
namespace Cexecinfo {
  extern "C" int backtrace(int *, int);
}
#endif

namespace Execinfo;

int backtrace(int ?array, int size) {
#ifdef __linux__
  if (size > array.size) throw new Failure("backtrace: size > array.size");
  return Cexecinfo::backtrace((int*)array, size);
#else
  throw new Failure("backtrace: unsupported except under Linux");
  return 0;
#endif
}

#ifndef __linux__
int bt(void) { return 1; }
#else
int bt(void) {
  int bt[20] = { for i < 20 : 0 }; // should be able to omit bound
  int tochild[2] = {0,0}, fromchild[2] = {0,0};
  pid_t pid, self_pid;

  if (pipe(tochild) || pipe(fromchild)) return 1;

  self_pid = getpid(); // gotta get it before we fork
  if ((pid = fork()) == 0) { // we are child
    if (dup2(tochild[0], STDIN_FILENO) == -1 ||
        dup2(fromchild[1], STDOUT_FILENO) == -1)
      return 1;
    execlp("addr2line", "addr2line", "--functions", "-e",
                   aprintf("/proc/%d/exe", self_pid), NULL);
    return 1;
  } else if (pid < 0) { // fork failed
    close(tochild[0]); close(tochild[1]);
    close(fromchild[0]); close(fromchild[1]);
    return 1;
  }

  FILE @w = ({ FILE *f = fdopen(tochild[1], "w");
               if (!f) return 1; (FILE@)f; });
  FILE @r = ({ FILE *f = fdopen(fromchild[0], "r");
               if (!f) {fclose(w);return 1;} (FILE@)f; });

  int n = backtrace(bt, bt.size);
  for (int c = 0; c < n; c++)
    fprintf(w,"%#x\n", bt[c]);
  fflush(w);
  printf("Backtrace:\n"
         "  Function          Location\n"
         "  ----------------  --------------------------------\n");
  for (int c = 0; c < n; c++) {
    int d, pos=0;
    printf("  ");
    while ((d = getc(r)) != '\n') {
      putchar(d), pos++;
    }
    while (pos++ < 16)
      putchar(' ');
    printf("  ");
    while ((d = getc(r)) != '\n')
      putchar(d);
    putchar('\n');
  }
  fclose(r); fclose(w);
  kill(pid, SIGTERM);
  waitpid(pid, NULL, 0);
  return 0;
}
#endif
