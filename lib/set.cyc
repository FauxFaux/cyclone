
////////////////////////////////////////////////////////////////////////////
// Popcorn library, file set.pop                                          //
// Copyright Greg Morrisett, Dan Grossman                                 //
// January 1999, all rights reserved                                      //
//                                                                        //
////////////////////////////////////////////////////////////////////////////

#include "list.h"
#include "set.h"

namespace Set;
using List;


/* Sets are a comparison function and a list of elements.
 * The comparison function should return 0 when elements are equal, i
 * < 0 if the first elt is less than the second, and i > 0 if the
 * first elt is greater than the second elt.  The list of nodes is
 * always maintained in sorted order with no duplicates.
 */
abstract struct Set<`a,`r::R,`e::E> {
  int (@compare)(`a,`a;`e);
  int cardinality;
  glist_t<`a,`r> nodes;
};

/* Given a comparison function, return an empty set. */
hset_t<`a,`e> empty(int (@comp)(`a,`a;`e)) {
  return new Set(comp,0,null);
}

hset_t<`a,`e> singleton(int (@comp)(`a,`a;`e),`a x) {
  return new Set(comp,1,new List(x,null));
}

int cardinality(gset_t<`a,`r,`e> s) {
  return(s->cardinality);
}

/* Determine whether a set is empty */
bool is_empty(gset_t<`a,`r,`e> s) {
  return(s->cardinality == 0);
}

/* Return true if element is present, false otherwise */
static bool member_b(int compare(`a,`a;`e),glist_t<`a,`r> n,`a elt) {
  while (n != null) {
    int i = compare(elt,n->hd);
    if (i == 0) return(true);
    else if (i < 0) return(false);
    else n = n->tl;
  }
  return(false);
}

bool member(gset_t<`a,`r,`e> s,`a elt) {
  return(member_b(s->compare,s->nodes,elt));
}

/* Internal function to insert an elt into a sorted list of nodes,
 * returning a new list of nodes (that shares with the old one).
 * Assumes elt is not in the list.
 */
static list_t<`a> insert_b(int compare(`a,`a;`e),list_t<`a> n,`a elt) {

  if (n == null)
    return new List(elt,null);
  else {
    int i = compare(elt,n->hd);
    if (i < 0) 
      return new List(elt,n);
    else {
      list_t<`a> result = new List(n->hd,null);
      list_t<`a> prev = result;
      n = n->tl;
      while (n != null && (i = compare(n->hd,elt)) < 0) {
	prev->tl = new List(n->hd,null);
	prev = prev->tl;
	n = n->tl;
      }
      prev->tl = new List(elt,n);
      return(result);
    }
  }
}

/* Inserts an elt into a set. */
hset_t<`a,`e> insert(hset_t<`a,`e> s,`a elt) {
  if (member(s,elt)) return(s);
  else return new Set(s->compare,s->cardinality+1,
                      insert_b(s->compare,s->nodes,elt));
}

/* Unions two sets by merging the nodes */
hset_t<`a,`e> union_two(hset_t<`a,`e> s1,hset_t<`a,`e> s2) {
  if(s1 == s2)
    return s1;
  if(s1->cardinality == 0)
    return s2;
  if(s2->cardinality == 0)
    return s1;

  list_t<`a> nodes = null;
  int cardinality = 0;
  int (@comp)(`a,`a;`e) = s1->compare;

  list_t<`a> x1 = s1->nodes;
  list_t<`a> x2 = s2->nodes;
  list_t<`a> curr = null;

  while ((x1 != null) && (x2 != null)) {
    int i = comp(x1->hd,x2->hd);
    if (i == 0) {
      // they're equal -- discard one copy
      x2 = x2->tl;
    } else if (i < 0) {
      // x1->hd <= x2->hd -- insert x1 into nodes
      if (curr == null) {
	nodes = new List(x1->hd,null);
	curr = nodes;
      } else {
	curr->tl = new List(x1->hd,null);
	curr = curr->tl;
      }
      x1 = x1->tl;
      ++cardinality;
    } else {
      // x2->hd <= x1->hd -- insert x2 into nodes
      if (curr == null) {
	nodes = new List(x2->hd,null);
	curr = nodes;
      } else {
	curr->tl = new List(x2->hd,null);
	curr = curr->tl;
      }
      x2 = x2->tl;
      ++cardinality;
    }
  }
  if (x1 != null) {
    // splice x1 into the tail
    if (curr == null)
      nodes = x1;
    else 
      curr->tl = x1;
    cardinality += List::length(x1);
  } else if (x2 != null) {
    // splice x2 into the tail
    if (curr == null)
      nodes = x2;
    else 
      curr->tl = x2;
    cardinality += List::length(x2);
  }
  return new Set(comp,cardinality,nodes);
}
      
/* Internal function used to delete an elt from a list of nodes --
 * assumes the elt is in the list exactly once and that the nodes are sorted.
 */
static list_t<`a> delete_b(int compare(`a,`a;`e),list_t<`a> n,`a elt) {
  if (compare(n->hd,elt) == 0) return(n->tl);

  list_t<`a> result = new List(n->hd,null);
  list_t<`a> prev = result;
  n = n->tl;
  while (n != null && (compare(n->hd,elt) != 0)) {
    prev->tl = new List(n->hd,null);
    prev = prev->tl;
    n = n->tl;
  }
  prev->tl = n->tl;
  return(result);
}

/* Delete a elt/pair from the set if present. */
hset_t<`a,`e> delete(hset_t<`a,`e> s,`a elt) {
  if (member(s,elt)) 
    return new Set(s->compare,s->cardinality - 1,
                   delete_b(s->compare,s->nodes,elt));
  else return(s);
}

list_t<`a> elements(hset_t<`a,`e> s) {
/* Note: For efficiency we don't copy, but that means clients can
         screw up our invariants!
*/
  return(s->nodes);
}

/* Fold a function f across the set yielding an accumulator. */
`b fold(`b f(`a,`b),gset_t<`a,`r,`e> s,`b accum) {
  glist_t<`a,`r> n = s->nodes;

  while (n != null) {
    accum = f(n->hd,accum);
    n = n->tl;
  }
  return(accum);
}
`b fold_c(`b f(`c,`a,`b),`c env,gset_t<`a,`r,`e> s,`b accum) {
  glist_t<`a,`r> n = s->nodes;

  while (n != null) {
    accum = f(env,n->hd,accum);
    n = n->tl;
  }
  return(accum);
}


/* Apply a function to each element in a set */
void app(`b f(`a),gset_t<`a,`r,`e> s) {
  List::app(f,s->nodes);
}
void iter(void f(`a),gset_t<`a,`r,`e> s) {
  List::iter(f,s->nodes);
}
void iter_c(void f(`c,`a),`c env,gset_t<`a,`r,`e> s) {
  List::iter_c(f,env,s->nodes);
}


/* return the intersection of two sets */
// could try to prevent more allocation with subset checks
hset_t<`a,`e> intersect(hset_t<`a,`e> s1,hset_t<`a,`e> s2) {
  if(s1 == s2) 
    return s1;
  int (@comp)(`a,`a;`e) = s1->compare;
  list_t<`a> x1 = s1->nodes;
  list_t<`a> x2 = s2->nodes;
  list_t<`a> result=null,prev=null;
  int card = 0;
  if(x1 == null)
    return s1;
  if(x2 == null)
    return s2;

  while (x1 != null && x2 != null) {
    int i = comp(x1->hd,x2->hd);
    if (i == 0) {
      if (result == null) {
	result = new List(x1->hd,null);
	prev = result;
      } else {
	prev->tl = new List(x1->hd,null);
	prev = prev->tl;
      }
      ++card;
      x1 = x1->tl;
      x2 = x2->tl;
    } else if (i < 0) {
      x1 = x1->tl;
    } else {
      x2 = x2->tl;
    }
  }
  return new Set(comp,card,result);
}

hset_t<`a,`e> from_list(int comp(`a,`a;`e),glist_t<`a,`r> x) {
  list_t<`a> z = List::merge_sort(comp,x);
  // remove duplicates
  for (list_t<`a> y=z; y!=null; y=y->tl) {
    if ((y->tl != null) && (comp(y->hd,y->tl->hd) == 0))
      y->tl = y->tl->tl;
  }
  return new Set(comp,List::length(z),z);
}

bool subset(gset_t<`a,`r1,`e> s1,gset_t<`a,`r2,`e> s2) {
  int (@comp)(`a,`a;`e) = s1->compare;
  glist_t<`a,`r1> x1 = s1->nodes;
  glist_t<`a,`r2> x2 = s2->nodes;

  while (true) {
    if (x1 == null) return true;
    if (x2 == null) return false;
    int i = comp(x1->hd,x2->hd);
    if (i == 0) {
      x1 = x1->tl;
      x2 = x2->tl;
    } else if (i > 0) {
      x2 = x2->tl;
    } else return false;
  }
  return true;
}

hset_t<`a,`e> diff(hset_t<`a,`e> s1,hset_t<`a,`e> s2) {
  int (@comp)(`a,`a;`e) = s1->compare;
  list_t<`a> x1 = s1->nodes;
  list_t<`a> x2 = s2->nodes;
  int card = s1->cardinality;

  if (x2 == null) return(s1); 

  while (x2 != null) {
    `a elt = x2->hd;  

    if (member_b(comp,x1,elt)) {
      --card;
      x1 = delete_b(comp,x1,elt);
    }
    x2 = x2->tl;
  }
  return new Set(comp,card,x1);
}

int compare(gset_t<`a,`r1,`e> s1,gset_t<`a,`r2,`e> s2) {
  // type-checker doesn't allow us to compare because the types aren't the same
  // if (s1 == s2) return 0; 
  if (s1->cardinality != s2->cardinality) return s1->cardinality-s2->cardinality;

  glist_t<`a,`r1> x1 = s1->nodes;
  glist_t<`a,`r2> x2 = s2->nodes;
  int (@comp)(`a,`a;`e) = s1->compare;
  while (x1 != null) {
    int diff = comp(x1->hd,x2->hd);
    if (diff != 0) return diff;
    x1 = x1->tl;
    x2 = x2->tl;
  }
  return 0;
}

bool equals(gset_t<`a,`r1,`e> s1, gset_t<`a,`r2,`e> s2) {
  return compare(s1,s2) == 0;
}
    
xtunion exn {Absent};

/* Return an elt (in this case -- the first one in the set).
 * If the set is empty, throw Absent.
 */
`a choose(gset_t<`a,`r,`e> s) {
  if (s->nodes == null) throw new Absent;
  return(s->nodes->hd);
}
