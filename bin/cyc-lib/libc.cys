// Realtime
// Has a structure containing void *
// Not supported yet
aio.h:
;

arpa/inet.h:
cpp {
 // OS X does not include struct in_addr in arpa/inet.h, but here instead
 #include <sys/types.h>
 #include <netinet/in.h>
}
include {
in_port_t
in_addr_t
in_addr
INET_ADDRSTRLEN
INET6_ADDRSTRLEN
uint32_t
uint16_t
}
epilogue {
  /* Cygwin does not define these types so we take a guess :-( */
  /* FIX: make this specific to cygwin ?? */
  #ifndef _in_addr_t_def_
  #define _in_addr_t_def_
  typedef unsigned long in_addr_t;
  #endif
  #ifndef _uint16_t_def_
  #define _uint16_t_def_
  typedef unsigned short uint16_t;
  #endif
  #ifndef _uint32_t_def_
  #define _uint32_t_def_
  typedef unsigned long uint32_t;
  #endif
}
epilogue htonl {
  extern "C" uint32_t htonl(uint32_t);
}
epilogue htons {
  extern "C" uint16_t htons(uint16_t);
}
epilogue ntohl {
  extern "C" uint32_t ntohl(uint32_t);
}
epilogue ntohs {
  extern "C" uint16_t ntohs(uint16_t);
}
epilogue inet_addr {
  // FIX: should I worry about Cstring being not-NULL?
  extern "C" in_addr_t inet_addr(const char *);
}
epilogue inet_aton {
  /* Note, inet_aton is not required by POSIX */
  // FIX: should I worry about char * being not-NULL?
  extern "C" int inet_aton(const char *, struct in_addr @);
}
epilogue inet_ntoa {
  extern "C" char * inet_ntoa(struct in_addr);
}
epilogue inet_ntop {
  // inet_ntop is not supported yet
}
epilogue inet_pton {
  // inet_pton is not supported yet
}
;

// Our compiler can't handle this yet.  E.g., it doesn't like
// types such as 'long double complex'.
complex.h:
// include {
// complex
// _Complex_I
// imaginary
// _Imaginary_I
// I
// }
// epilogue cabs {
//   extern "C" double cabs(double complex);
// }
// epilogue cabsf {
//   extern "C" float cabsf(float complex);
// }
// epilogue cabsl {
//   extern "C" long double cabsl(long double complex);
// }
// epilogue cacos {
//   extern "C" double complex cacos(double complex);
// }
// epilogue cacosf {
//   extern "C" float complex cacosf(float complex);
// }
// epilogue cacosh {
//   extern "C" double complex cacosh(double complex);
// }
// epilogue cacoshf {
//   extern "C" float complex cacoshf(float complex);
// }
// epilogue cacoshl {
//   extern "C" long double complex cacoshl(long double complex);
// }
// epilogue cacosl {
//   extern "C" long double complex cacosl(long double complex);
// }
// epilogue carg {
//   extern "C" double carg(double complex);
// }
// epilogue cargf {
//   extern "C" float cargf(float complex);
// }
// epilogue cargl {
//   extern "C" long double cargl(long double complex);
// }
// epilogue casin {
//   extern "C" double complex casin(double complex);
// }
// epilogue casinf {
//   extern "C" float complex casinf(float complex);
// }
// epilogue casinh {
//   extern "C" double complex casinh(double complex);
// }
// epilogue casinhf {
//   extern "C" float complex casinhf(float complex);
// }
// epilogue casinhl {
//   extern "C" long double complex casinhl(long double complex);
// }
// epilogue casinl {
//   extern "C" long double complex casinl(long double complex);
// }
// epilogue catan {
//   extern "C" double complex catan(double complex);
// }
// epilogue catanf {
//   extern "C" float complex catanf(float complex);
// }
// epilogue catanh {
//   extern "C" double complex catanh(double complex);
// }
// epilogue catanhf {
//   extern "C" float complex catanhf(float complex);
// }
// epilogue catanhl {
//   extern "C" long double complex catanhl(long double complex);
// }
// epilogue catanl {
//   extern "C" long double complex catanl(long double complex);
// }
// epilogue ccos {
//   extern "C" double complex ccos(double complex);
// }
// epilogue ccosf {
//   extern "C" float complex ccosf(float complex);
// }
// epilogue ccosh {
//   extern "C" double complex ccosh(double complex);
// }
// epilogue ccoshf {
//   extern "C" float complex ccoshf(float complex);
// }
// epilogue ccoshl {
//   extern "C" long double complex ccoshl(long double complex);
// }
// epilogue ccosl {
//   extern "C" long double complex ccosl(long double complex);
// }
// epilogue cexp {
//   extern "C" double complex cexp(double complex);
// }
// epilogue cexpf {
//   extern "C" float complex cexpf(float complex);
// }
// epilogue cexpl {
//   extern "C" long double complex cexpl(long double complex);
// }
// epilogue cimag {
//   extern "C" double cimag(double complex);
// }
// epilogue cimagf {
//   extern "C" float cimagf(float complex);
// }
// epilogue cimagl {
//   extern "C" long double cimagl(long double complex);
// }
// epilogue clog {
//   extern "C" double complex clog(double complex);
// }
// epilogue clogf {
//   extern "C" float complex clogf(float complex);
// }
// epilogue clogl {
//   extern "C" long double complex clogl(long double complex);
// }
// epilogue conj {
//   extern "C" double complex conj(double complex);
// }
// epilogue conjf {
//   extern "C" float complex conjf(float complex);
// }
// epilogue conjl {
//   extern "C" long double complex conjl(long double complex);
// }
// epilogue cpow {
//   extern "C" double complex cpow(double complex, double complex);
// }
// epilogue cpowf {
//   extern "C" float complex cpowf(float complex, float complex);
// }
// epilogue cpowl {
//   extern "C" long double complex cpowl(long double complex, long double complex);
// }
// epilogue cproj {
//   extern "C" double complex cproj(double complex);
// }
// epilogue cprojf {
//   extern "C" float complex cprojf(float complex);
// }
// epilogue cprojl {
//   extern "C" long double complex cprojl(long double complex);
// }
// epilogue creal {
//   extern "C" double creal(double complex);
// }
// epilogue crealf {
//   extern "C" float crealf(float complex);
// }
// epilogue creall {
//   extern "C" long double creall(long double complex);
// }
// epilogue csin {
//   extern "C" double complex csin(double complex);
// }
// epilogue csinf {
//   extern "C" float complex csinf(float complex);
// }
// epilogue csinh {
//   extern "C" double complex csinh(double complex);
// }
// epilogue csinhf {
//   extern "C" float complex csinhf(float complex);
// }
// epilogue csinhl {
//   extern "C" long double complex csinhl(long double complex);
// }
// epilogue csinl {
//   extern "C" long double complex csinl(long double complex);
// }
// epilogue csqrt {
//   extern "C" double complex csqrt(double complex);
// }
// epilogue csqrtf {
//   extern "C" float complex csqrtf(float complex);
// }
// epilogue csqrtl {
//   extern "C" long double complex csqrtl(long double complex);
// }
// epilogue ctan {
//   extern "C" double complex ctan(double complex);
// }
// epilogue ctanf {
//   extern "C" float complex ctanf(float complex);
// }
// epilogue ctanh {
//   extern "C" double complex ctanh(double complex);
// }
// epilogue ctanhf {
//   extern "C" float complex ctanhf(float complex);
// }
// epilogue ctanhl {
//   extern "C" long double complex ctanhl(long double complex);
// }
// epilogue ctanl {
//   extern "C" long double complex ctanl(long double complex);
// }
;

cpio.h:
include {
C_IRUSR
C_IWUSR
C_IXUSR
C_IRGRP
C_IWGRP
C_IXGRP
C_IROTH
C_IWOTH
C_IXOTH
C_ISUID
C_ISGID
C_ISVTX
C_ISDIR
C_ISFIFO
C_ISREG
C_ISBLK
C_ISCHR
C_ISCTG
C_ISLNK
C_ISSOCK
MAGIC
}
;

ctype.h:
epilogue {
  extern "C" int isalnum(int);
}
epilogue {
  extern "C" int isalpha(int);
}
epilogue {
  extern "C" int isascii(int);
}
epilogue {
  extern "C" int iscntrl(int);
}
epilogue {
  extern "C" int isdigit(int);
}
epilogue {
  extern "C" int isgraph(int);
}
epilogue {
  extern "C" int islower(int);
}
epilogue {
  extern "C" int isprint(int);
}
epilogue {
  extern "C" int ispunct(int);
}
epilogue {
  extern "C" int isspace(int);
}
epilogue {
  extern "C" int isupper(int);
}
epilogue {
  extern "C" int isxdigit(int);
}
epilogue {
  extern "C" int toascii(int);
}
epilogue {
  extern "C" int tolower(int);
}
epilogue {
  extern "C" int toupper(int);
}
epilogue _tolower {
  extern "C" int _tolower(int);
}
epilogue _toupper {
  extern "C" int _toupper(int);
}
;

// Dynamic linking
// Not supported yet
dlfcn.h:
;

dirent.h:
cpp {
  #include <sys/types.h>
}
include {
dirent
ino_t
NAME_MAX
}
epilogue {
  // We define DIR as an abstract struct because it can contain
  // pointers, e.g., in cygwin
  extern struct __cycDIR;  
  typedef struct __cycDIR DIR;
}
cycstub {
  namespace Cdirent {
    extern "C" struct __abstractDIR;
    typedef struct __abstractDIR __cDIR;
  }
  abstract struct __cycDIR { // must match defn in c stub
    Cdirent::__cDIR @dir;
  };
}
cstub {
  /* OS X needs sys/types.h before dirent.h */
  #include <sys/types.h>
  #include <dirent.h>
  struct Cyc_Std___cycDIR { // must match defn in cyclone stub
    DIR *dir;
  };
}
epilogue closedir {
  extern int closedir(DIR @);
}
cycstub closedir {
  namespace Cdirent {
    extern "C" int closedir(__cDIR @d);
  }
  int closedir(DIR @d) {
    return Cdirent::closedir(d->dir);
  }
}
epilogue opendir {
  extern DIR *opendir(const char @);
}
cycstub opendir {
  namespace Cdirent {
    extern "C" __cDIR *opendir(const char @);
  }
  static xtunion exn.Failure __opendir_failure =
    Failure("opendir called with NULL string");
  DIR *opendir(const char @ f) {
    let cd = Cdirent::opendir(f);
    // FIX: get rid of heap allocation
    return cd ? new __cycDIR((Cdirent::__cDIR @)cd) : NULL;
  }
}
epilogue readdir {
  extern struct dirent @readdir(DIR @);
}
cycstub readdir {
  namespace Cdirent {
    extern "C" struct dirent @readdir(__cDIR @);
  }
  struct dirent @readdir(DIR @d) {
    return Cdirent::readdir(d->dir);
  }
}
epilogue {
  // FIX: We don't handle this yet. The third arg is an array,
  // needs a wrapper
  //int readdir_r(DIR *, struct dirent *, struct dirent **);
}
epilogue rewinddir {
  extern void rewinddir(DIR @);
}
cycstub rewinddir {
  namespace Cdirent {
    extern "C" void rewinddir(__cDIR @d);
  }
  void rewinddir(DIR @d) {
    return Cdirent::rewinddir(d->dir);
  }
}
epilogue seekdir {
  extern void seekdir(DIR @, long);
}
cycstub seekdir {
  namespace Cdirent {
    extern "C" void seekdir(__cDIR @d, long);
  }
  void seekdir(DIR @d, long x) {
    return Cdirent::seekdir(d->dir,x);
  }
}
epilogue telldir {
  extern long telldir(DIR @);
}
cycstub telldir {
  namespace Cdirent {
    extern "C" long telldir(__cDIR @d);
  }
  long telldir(DIR @d) {
    return Cdirent::telldir(d->dir);
  }
};

errno.h:
include {
E2BIG
EACCES
EADDRINUSE
EADDRNOTAVAIL
EAFNOSUPPORT
EAGAIN
EALREADY
EBADF
EBADMSG
EBUSY
ECANCELED
ECHILD
ECONNABORTED
ECONNREFUSED
ECONNRESET
EDEADLK
EDESTADDRREQ
EDOM
EDQUOT
EEXIST
EFAULT
EFBIG
EHOSTUNREACH
EIDRM
EILSEQ
EINPROGRESS
EINTR
EINVAL
EIO
EISCONN
EISDIR
ELOOP
EMFILE
EMSGSIZE
EMULTIHOP
ENAMETOOLONG
ENETDOWN
ENETUNREACH
ENFILE
ENOBUFS
ENODATA
ENODEV
ENOENT
ENOEXEC
ENOLCK
ENOLINK
ENOMEM
ENOMSG
ENOPROTOOPT
ENOSPC
ENOSR
ENOSTR
ENOSYS
ENOTCONN
ENOTDIR
ENOTEMPTY
ENOTSOCK
ENOTSUP
ENOTTY
ENXIO
EOPNOTSUPP
EOVERFLOW
EPERM
EPIPE
EPROTO
EPROTONOSUPPORT
EPROTOTYPE
ERANGE
EROFS
ESPIPE
ESRCH
ESTALE
ETIME
ETIMEDOUT
ETXTBSY
EWOULDBLOCK
EXDEV
}
epilogue {
extern "C" int __CYCLONE_ERRNO();
#define errno (__CYCLONE_ERRNO())
}
cstub {
  // We do this because errno is probably a C macro
  #include <errno.h>
  int __CYCLONE_ERRNO() {
    return errno;
  }
}
;

fcntl.h:
include {
F_DUPFD
F_GETFD
F_SETFD
F_GETFL
F_SETFL
F_GETLK
F_SETLK
F_SETLKW
F_GETOWN
F_SETOWN
FD_CLOEXEC
F_RDLCK
F_UNLCK
F_WRLCK
SEEK_SET
SEEK_CUR
SEEK_END
O_CREAT
O_EXCL
O_NOCTTY
O_TRUNC
O_APPEND
O_DSYNC
O_NONBLOCK
O_RSYNC
O_SYNC
O_ACCMODE
O_RDONLY
O_RDWR
O_WRONLY
flock
mode_t
off_t
pid_t
}
epilogue {
  // FIX: ADV is not supported

  tunion FcntlArg<`r::R> {
    Flock(struct flock @`r);
    Long(long);
  };
  typedef tunion `r FcntlArg<`r> fcntlarg_t<`r>;

  extern int fcntl(int fd, int cmd, ... inject fcntlarg_t);
  extern int open(const char *, int, ... mode_t);
  // FIX: should arg be non-NULL?
  extern "C" int creat(const char *,mode_t);
}
cycstub {
  namespace Cfcntl {
    extern "C" int fcntl(int fd, int cmd);
    extern "C" int fcntl_with_arg(int fd, int cmd, long arg);
    extern "C" int fcntl_with_lock(int fd, int cmd, struct Std::flock *lock);
    extern "C" int open_without_mode(const char *,int);
    extern "C" int open_with_mode(const char *,int,mode_t);
  }
  static xtunion exn.Failure __fcntl_failure =
    Failure("fcntl: too many args");
  int fcntl(int fd, int cmd, ... inject fcntlarg_t argv) {
    if (argv.size == 0) return Cfcntl::fcntl(fd, cmd);
    else if (argv.size != 1) throw &__fcntl_failure;
    else switch (argv[0]) {
    case &Long(arg): return Cfcntl::fcntl_with_arg(fd, cmd, arg);
    case &Flock(lock): return Cfcntl::fcntl_with_lock(fd, cmd, lock);
    }
  }

  int open(const char * s, int i, ... mode_t ms) {
    /* Note: if open is called with more than 3 arguments, the
       additional args are simply ignored. */
    if (ms.size >= 1)
      return Cfcntl::open_with_mode(s,i,ms[0]);
    else
      return Cfcntl::open_without_mode(s,i);
  }
}
cstub {
  #include "precore_c.h"
  #include <fcntl.h>
  int fcntl_with_arg(int fd, int cmd, long arg) {
    return fcntl(fd, cmd, arg);
  }
  // We call lock a void* so we don't have to #include anything else
  int fcntl_with_lock(int fd, int cmd, void *lock) {
    return fcntl(fd, cmd, lock);
  }

  int open_with_mode(const char * s, int flags, mode_t m) {
    return open(s,flags,m);
  }

  int open_without_mode(const char * s, int flags) {
    /* Use 0 as the mode argument, in case flags contains O_CREAT.  In
       that case the file will be created with 0 permissions; if we
       omitted the 0 it would be created with random permissions. */
    return open(s,flags,0);
  }
}
;

fenv.h:
include {
fenv_t
fexcept_t
FE_DIVBYZERO
FE_INEXACT
FE_INVALID
FE_OVERFLOW
FE_UNDERFLOW
FE_ALL_EXCEPT
FE_DOWNWARD
FE_TONEAREST
FE_TOWARDZERO
FE_UPWARD
FE_DFL_ENV
}
epilogue feclearexcept {
  extern "C" int feclearexcept(int);
}
epilogue fegetexceptflag {
  extern "C" int fegetexceptflag(fexcept_t @, int);
}
epilogue feraiseexcept {
  extern "C" int feraiseexcept(int);
}
epilogue fesetexceptflag {
  extern "C" int fesetexceptflag(const fexcept_t @, int);
}
epilogue fetestexcept {
  extern "C" int fetestexcept(int);
}
epilogue fegetround {
  extern "C" int fegetround(void);
}
epilogue fesetround {
  extern "C" int fesetround(int);
}
epilogue fegetenv {
  extern "C" int fegetenv(fenv_t @);
}
epilogue feholdexcept {
  extern "C" int feholdexcept(fenv_t @);
}
epilogue fesetenv {
  extern "C" int fesetenv(const fenv_t @);
}
epilogue feupdateenv {
  extern "C" int feupdateenv(const fenv_t @);
}
;

float.h:
include {
FLT_ROUNDS
FLT_EVAL_METHOD
FLT_RADIX
FLT_MANT_DIG
DBL_MANT_DIG
LDBL_MANT_DIG
DECIMAL_DIG
FLT_DIG
DBL_DIG
LDBL_DIG
FLT_MIN_EXP
DBL_MIN_EXP
LDBL_MIN_EXP
FLT_MIN_10_EXP
DBL_MIN_10_EXP
LDBL_MIN_10_EXP
FLT_MAX_EXP
DBL_MAX_EXP
LDBL_MAX_EXP
FLT_MAX_10_EXP
DBL_MAX_10_EXP
LDBL_MAX_10_EXP
FLT_MAX
DBL_MAX
LDBL_MAX
FLT_EPSILON
DBL_EPSILON
LDBL_EPSILON
FLT_MIN
DBL_MIN
LDBL_MIN
}
;

fmtmsg.h:
include {
MM_HARD
MM_SOFT
MM_FIRM
MM_APPL
MM_UTIL
MM_OPSYS
MM_RECOVER
MM_NRECOV
MM_HALT
MM_ERROR
MM_WARNING
MM_INFO
MM_NOSEV
MM_PRINT
MM_CONSOLE
MM_NULLSEV
MM_NULLMC
MM_OK
MM_NOTOK
MM_NOMSG
MM_NOCON
}
epilogue {
#define MM_NULLLBL ((const char ?)NULL)
#define MM_NULLTXT ((const char ?)NULL)
#define MM_NULLACT ((const char ?)NULL)
#define MM_NULLTAG ((const char ?)NULL)
/* FIX: should I worry about these char *s being non-NULL */
extern "C" int fmtmsg(long a, const char * b, int c, const char * d,
		      const char * e, const char * f);
}
;

fnmatch.h:
include {
FNM_NOMATCH
FNM_PATHNAME
FNM_PERIOD
FNM_NOESCAPE
FNM_NOSYS
}
epilogue {
  // FIX: does this old comment still apply:
  // Our implementation copies the first two arguments.  This is
  // only a stopgap measure, the function should be rewitten in
  // Cyclone.
  extern "C" int fnmatch(char @, char @, int);
}
;

// This one requires true closures, or an implementation
// completely in Cyclone.
// Our parser dies on it in Linux
ftw.h:
// omitvariables { stat }
// include {
// FTW
// FTW_F
// FTW_D
// FTW_DNR
// FTW_DP
// FTW_NS
// FTW_SL
// FTW_SLN
// FTW_PHYS
// FTW_MOUNT
// FTW_DEPTH
// FTW_CHDIR
// stat
// S_IFMT
// S_IFBLK
// S_IFCHR
// S_IFIFO
// S_IFREG
// S_IFDIR
// S_IFLNK
// S_IFSOCK
// S_IRWXU
// S_IRUSR
// S_IWUSR
// S_IXUSR
// S_IRWXG
// S_IRGRP
// S_IWGRP
// S_IXGRP
// S_IRWXO
// S_IROTH
// S_IWOTH
// S_IXOTH
// S_ISUID
// S_ISGID
// S_ISVTX
// S_ISBLK
// S_ISCHR
// S_ISDIR
// S_ISFIFO
// S_ISREG
// S_ISLNK
// S_ISSOCK
// S_TYPEISMQ
// S_TYPEISSEM
// S_TYPEISSHM
// S_TYPEISTMO
// }
// epilogue ftw {
//   extern int ftw(const char ?,
//                  int (@)(const char ?, const struct stat @, int),
//                  int);
// }
// epilogue nftw {
//   extern int nftw(const char ?
//                   int (@)(const char ?, const struct stat @, int, struct FTW @),
//                   int,
//                   int);
// }
;

// This may need to be written entirely in Cyclone, since it manipulates
// arrays of paths
glob.h:
;

// This may need to be written entirely in Cyclone, since it manipulates
// arrays of paths
// grp.h:
// ;

// Not supported yet
inttypes.h:
// include {
// imaxdiv_t
// }
// epilogue {
//   // This isn't quite right.  Posix requires <inttypes.h> to include
//   // <stdint.h>, but this include is not making the definitions of
//   // <stdint.h> available in the Std namespace.
// #include <stdint.h>
// }
;

iso646.h:
include {
and
and_eq
bitand
bitor
compl
not
not_eq
or
or_eq
xor
xor_eq
}
;

// Not supported yet
langinfo.h:
;

libgen.h:
epilogue {
  // Probably best to do entirely in Cyclone
}
;

limits.h:
include {
AIO_LISTIO_MAX
_POSIX_AIO_LISTIO_MAX
AIO_MAX
_POSIX_AIO_MAX
AIO_PRIO_DELTA_MAX
ARG_MAX
_POSIX_ARG_MAX
ATEXIT_MAX
CHILD_MAX
_POSIX_CHILD_MAX
DELAYTIMER_MAX
_POSIX_DELAYTIMER_MAX
HOST_NAME_MAX
_POSIX_HOST_NAME_MAX
IOV_MAX
_XOPEN_IOV_MAX
LOGIN_NAME_MAX
_POSIX_LOGIN_NAME_MAX
MQ_OPEN_MAX
_POSIX_MQ_OPEN_MAX
MQ_PRIO_MAX
_POSIX_MQ_PRIO_MAX
OPEN_MAX
_POSIX_OPEN_MAX
PAGESIZE
PAGE_SIZE
PTHREAD_DESTRUCTOR_ITERATIONS
_POSIX_THREAD_DESTRUCTOR_ITERATIONS
PTHREAD_KEYS_MAX
_POSIX_THREAD_KEYS_MAX
PTHREAD_STACK_MIN
PTHREAD_THREADS_MAX
_POSIX_THREAD_THREADS_MAX
RE_DUP_MAX
_POSIX2_RE_DUP_MAX
RTSIG_MAX
_POSIX_RTSIG_MAX
SEM_NSEMS_MAX
_POSIX_SEM_NSEMS_MAX
SEM_VALUE_MAX
_POSIX_SEM_VALUE_MAX
SIGQUEUE_MAX
_POSIX_SIGQUEUE_MAX
SS_REPL_MAX
_POSIX_SS_REPL_MAX
STREAM_MAX
_POSIX_STREAM_MAX
SYMLOOP_MAX
_POSIX_SYMLOOP_MAX
TIMER_MAX
_POSIX_TIMER_MAX
TRACE_EVENT_NAME_MAX
_POSIX_TRACE_EVENT_NAME_MAX
TRACE_NAME_MAX
_POSIX_TRACE_NAME_MAX
TRACE_SYS_MAX
_POSIX_TRACE_SYS_MAX
TRACE_USER_EVENT_MAX
_POSIX_TRACE_USER_EVENT_MAX
TTY_NAME_MAX
_POSIX_TTY_NAME_MAX
TZNAME_MAX
_POSIX_TZNAME_MAX
FILESIZEBITS
LINK_MAX
_POSIX_LINK_MAX
MAX_CANON
_POSIX_MAX_CANON
MAX_INPUT
_POSIX_MAX_INPUT
NAME_MAX
_POSIX_NAME_MAX
_XOPEN_NAME_MAX
PATH_MAX
_POSIX_PATH_MAX
_XOPEN_PATH_MAX
PIPE_BUF
_POSIX_PIPE_BUF
POSIX_ALLOC_SIZE_MIN
POSIX_REC_INCR_XFER_SIZE
POSIX_REC_MAX_XFER_SIZE
POSIX_REC_MIN_XFER_SIZE
POSIX_REC_XFER_ALIGN
SYMLINK_MAX
_POSIX_SYMLINK_MAX
BC_BASE_MAX
_POSIX2_BC_BASE_MAX
BC_DIM_MAX
_POSIX2_BC_DIM_MAX
BC_SCALE_MAX
_POSIX2_BC_SCALE_MAX
BC_STRING_MAX
_POSIX2_BC_STRING_MAX
CHARCLASS_NAME_MAX
_POSIX2_CHARCLASS_NAME_MAX
COLL_WEIGHTS_MAX
_POSIX2_COLL_WEIGHTS_MAX
EXPR_NEST_MAX
_POSIX2_EXPR_NEST_MAX
LINE_MAX
_POSIX2_LINE_MAX
NGROUPS_MAX
_POSIX_NGROUPS_MAX
RE_DUP_MAX
_POSIX2_RE_DUP_MAX
_POSIX_CLOCKRES_MIN
_POSIX_AIO_LISTIO_MAX
_POSIX_AIO_MAX
_POSIX_ARG_MAX
_POSIX_CHILD_MAX
_POSIX_DELAYTIMER_MAX
_POSIX_HOST_NAME_MAX
_POSIX_LINK_MAX
_POSIX_LOGIN_NAME_MAX
_POSIX_MAX_CANON
_POSIX_MAX_INPUT
_POSIX_MQ_OPEN_MAX
_POSIX_MQ_PRIO_MAX
_POSIX_NAME_MAX
_POSIX_NGROUPS_MAX
_POSIX_OPEN_MAX
_POSIX_PATH_MAX
_POSIX_PIPE_BUF
_POSIX_RE_DUP_MAX
_POSIX_RTSIG_MAX
_POSIX_SEM_NSEMS_MAX
_POSIX_SEM_VALUE_MAX
_POSIX_SIGQUEUE_MAX
_POSIX_SSIZE_MAX
_POSIX_STREAM_MAX
_POSIX_SS_REPL_MAX
_POSIX_SYMLINK_MAX
_POSIX_SYMLOOP_MAX
_POSIX_THREAD_DESTRUCTOR_ITERATIONS
_POSIX_THREAD_KEYS_MAX
_POSIX_THREAD_THREADS_MAX
_POSIX_TIMER_MAX
_POSIX_TRACE_EVENT_NAME_MAX
_POSIX_TRACE_NAME_MAX
_POSIX_TRACE_SYS_MAX
_POSIX_TRACE_USER_EVENT_MAX
_POSIX_TTY_NAME_MAX
_POSIX_TZNAME_MAX
_POSIX2_BC_BASE_MAX
_POSIX2_BC_DIM_MAX
_POSIX2_BC_SCALE_MAX
_POSIX2_BC_STRING_MAX
_POSIX2_CHARCLASS_NAME_MAX
_POSIX2_COLL_WEIGHTS_MAX
_POSIX2_EXPR_NEST_MAX
_POSIX2_LINE_MAX
_POSIX2_RE_DUP_MAX
_XOPEN_IOV_MAX
_XOPEN_NAME_MAX
_XOPEN_PATH_MAX
CHAR_BIT
CHAR_MAX
CHAR_MIN
INT_MAX
LONG_BIT
LONG_MAX
MB_LEN_MAX
SCHAR_MAX
SHRT_MAX
SSIZE_MAX
_POSIX_SSIZE_MAX
UCHAR_MAX
UINT_MAX
ULONG_MAX
USHRT_MAX
WORD_BIT
INT_MIN
LONG_MIN
SCHAR_MIN
SHRT_MIN
LLONG_MIN
LLONG_MAX
ULLONG_MAX
CHARCLASS_NAME_MAX
NL_ARGMAX
NL_LANGMAX
NL_MSGMAX
NL_NMAX
NL_SETMAX
NL_TEXTMAX
_POSIX2_LINE_MAX
NZERO
}
;

// Defines a struct containing char *
// Not supported yet
locale.h:
;

math.h:
include {
float_t
double_t
FLT_EVAL_METHOD
fpclassify
isfinite
isinf
isnan
isnormal
signbit
isgreater
isgreaterequal
isless
islessequal
islessgreater
isunordered
M_E
M_LOG2E
M_LOG10E
M_LN2
M_LN10
M_PI
M_PI_2
M_PI_4
M_1_PI
M_2_PI
M_2_SQRTP
M_SQRT2
M_SQRT1_2
MAXFLOAT
HUGE_VALF
HUGE_VALL
INFINITY
NAN
FP_INFINITE
FP_NAN
FP_NORMAL
FP_SUBNORMAL
FP_ZERO
FP_FAST_FMA
FP_FAST_FMAF
FP_FAST_FMAL
FP_ILOGB0
FP_ILOGBNAN
MATH_ERRNO
MATH_ERREXCEPT
math_errhandling
}
epilogue {
  /* I'd like to do
     include { HUGE_VAL }
     but under Cygwin this brings in 
     extern const union __dmath  __attribute__((dllimport))__infinity[];
     which does not have an array size.
     Works fine in Linux, though.
  */
}

epilogue acos {
  extern "C" double acos(double);
}
epilogue acosf {
  extern "C" float acosf(float);
}
epilogue acosh {
  extern "C" double acosh(double);
}
epilogue acoshf {
  extern "C" float acoshf(float);
}
epilogue acoshl {
  extern "C" long double acoshl(long double);
}
epilogue acosl {
  extern "C" long double acosl(long double);
}
epilogue asin {
  extern "C" double asin(double);
}
epilogue asinf {
  extern "C" float asinf(float);
}
epilogue asinh {
  extern "C" double asinh(double);
}
epilogue asinhf {
  extern "C" float asinhf(float);
}
epilogue asinhl {
  extern "C" long double asinhl(long double);
}
epilogue asinl {
  extern "C" long double asinl(long double);
}
epilogue atan {
  extern "C" double atan(double);
}
epilogue atan2 {
  extern "C" double atan2(double, double);
}
epilogue atan2f {
  extern "C" float atan2f(float, float);
}
epilogue atan2l {
  extern "C" long double atan2l(long double, long double);
}
epilogue atanf {
  extern "C" float atanf(float);
}
epilogue atanh {
  extern "C" double atanh(double);
}
epilogue atanhf {
  extern "C" float atanhf(float);
}
epilogue atanhl {
  extern "C" long double atanhl(long double);
}
epilogue atanl {
  extern "C" long double atanl(long double);
}
epilogue cbrt {
  extern "C" double cbrt(double);
}
epilogue cbrtf {
  extern "C" float cbrtf(float);
}
epilogue cbrtl {
  extern "C" long double cbrtl(long double);
}
epilogue ceil {
  extern "C" double ceil(double);
}
epilogue ceilf {
  extern "C" float ceilf(float);
}
epilogue ceill {
  extern "C" long double ceill(long double);
}
epilogue copysign {
  extern "C" double copysign(double, double);
}
epilogue copysignf {
  extern "C" float copysignf(float, float);
}
epilogue copysignl {
  extern "C" long double copysignl(long double, long double);
}
epilogue cos {
  extern "C" double cos(double);
}
epilogue cosf {
  extern "C" float cosf(float);
}
epilogue cosh {
  extern "C" double cosh(double);
}
epilogue coshf {
  extern "C" float coshf(float);
}
epilogue coshl {
  extern "C" long double coshl(long double);
}
epilogue cosl {
  extern "C" long double cosl(long double);
}
epilogue erf {
  extern "C" double erf(double);
}
epilogue erfc {
  extern "C" double erfc(double);
}
epilogue erfcf {
  extern "C" float erfcf(float);
}
epilogue erfcl {
  extern "C" long double erfcl(long double);
}
epilogue erff {
  extern "C" float erff(float);
}
epilogue erfl {
  extern "C" long double erfl(long double);
}
epilogue exp {
  extern "C" double exp(double);
}
epilogue exp2 {
  extern "C" double exp2(double);
}
epilogue exp2f {
  extern "C" float exp2f(float);
}
epilogue exp2l {
  extern "C" long double exp2l(long double);
}
epilogue expf {
  extern "C" float expf(float);
}
epilogue expl {
  extern "C" long double expl(long double);
}
epilogue expm1 {
  extern "C" double expm1(double);
}
epilogue expm1f {
  extern "C" float expm1f(float);
}
epilogue expm1l {
  extern "C" long double expm1l(long double);
}
epilogue fabs {
  extern "C" double fabs(double);
}
epilogue fabsf {
  extern "C" float fabsf(float);
}
epilogue fabsl {
  extern "C" long double fabsl(long double);
}
epilogue fdim {
  extern "C" double fdim(double, double);
}
epilogue fdimf {
  extern "C" float fdimf(float, float);
}
epilogue fdiml {
  extern "C" long double fdiml(long double, long double);
}
epilogue floor {
  extern "C" double floor(double);
}
epilogue floorf {
  extern "C" float floorf(float);
}
epilogue floorl {
  extern "C" long double floorl(long double);
}
epilogue fma {
  extern "C" double fma(double, double, double);
}
epilogue fmaf {
  extern "C" float fmaf(float, float, float);
}
epilogue fmal {
  extern "C" long double fmal(long double, long double, long double);
}
epilogue fmax {
  extern "C" double fmax(double, double);
}
epilogue fmaxf {
  extern "C" float fmaxf(float, float);
}
epilogue fmaxl {
  extern "C" long double fmaxl(long double, long double);
}
epilogue fmin {
  extern "C" double fmin(double, double);
}
epilogue fminf {
  extern "C" float fminf(float, float);
}
epilogue fminl {
  extern "C" long double fminl(long double, long double);
}
epilogue fmod {
  extern "C" double fmod(double, double);
}
epilogue fmodf {
  extern "C" float fmodf(float, float);
}
epilogue fmodl {
  extern "C" long double fmodl(long double, long double);
}
epilogue frexp {
  extern "C" double frexp(double, int @);
}
epilogue frexpf {
  extern "C" float frexpf(float value, int @);
}
epilogue frexpl {
  extern "C" long double frexpl(long double value, int @);
}
epilogue hypot {
  extern "C" double hypot(double, double);
}
epilogue hypotf {
  extern "C" float hypotf(float, float);
}
epilogue hypotl {
  extern "C" long double hypotl(long double, long double);
}
epilogue ilogb {
  extern "C" int ilogb(double);
}
epilogue ilogbf {
  extern "C" int ilogbf(float);
}
epilogue ilogbl {
  extern "C" int ilogbl(long double);
}
epilogue j0 {
  extern "C" double j0(double);
}
epilogue j1 {
  extern "C" double j1(double);
}
epilogue jn {
  extern "C" double jn(int, double);
}
epilogue ldexp {
  extern "C" double ldexp(double, int);
}
epilogue ldexpf {
  extern "C" float ldexpf(float, int);
}
epilogue ldexpl {
  extern "C" long double ldexpl(long double, int);
}
epilogue lgamma {
  extern "C" double lgamma(double);
}
epilogue lgammaf {
  extern "C" float lgammaf(float);
}
epilogue lgammal {
  extern "C" long double lgammal(long double);
}
epilogue llrint {
  extern "C" long long llrint(double);
}
epilogue llrintf {
  extern "C" long long llrintf(float);
}
epilogue llrintl {
  extern "C" long long llrintl(long double);
}
epilogue llround {
  extern "C" long long llround(double);
}
epilogue llroundf {
  extern "C" long long llroundf(float);
}
epilogue llroundl {
  extern "C" long long llroundl(long double);
}
epilogue log {
  extern "C" double log(double);
}
epilogue log10 {
  extern "C" double log10(double);
}
epilogue log10f {
  extern "C" float log10f(float);
}
epilogue log10l {
  extern "C" long double log10l(long double);
}
epilogue log1p {
  extern "C" double log1p(double);
}
epilogue log1pf {
  extern "C" float log1pf(float);
}
epilogue log1pl {
  extern "C" long double log1pl(long double);
}
epilogue log2 {
  extern "C" double log2(double);
}
epilogue log2f {
  extern "C" float log2f(float);
}
epilogue log2l {
  extern "C" long double log2l(long double);
}
epilogue logb {
  extern "C" double logb(double);
}
epilogue logbf {
  extern "C" float logbf(float);
}
epilogue logbl {
  extern "C" long double logbl(long double);
}
epilogue logf {
  extern "C" float logf(float);
}
epilogue logl {
  extern "C" long double logl(long double);
}
epilogue lrint {
  extern "C" long lrint(double);
}
epilogue lrintf {
  extern "C" long lrintf(float);
}
epilogue lrintl {
  extern "C" long lrintl(long double);
}
epilogue lround {
  extern "C" long lround(double);
}
epilogue lroundf {
  extern "C" long lroundf(float);
}
epilogue lroundl {
  extern "C" long lroundl(long double);
}
epilogue modf {
  extern "C" double modf(double, double @);
}
epilogue modff {
  extern "C" float modff(float, float @);
}
epilogue modfl {
  extern "C" long double modfl(long double, long double @);
}
epilogue nan {
  // FIX: not yet implemented
  //  extern "C" double nan(const char *);
}
epilogue nanf {
  // FIX: not yet implemented
  //  extern "C" float nanf(const char *);
}
epilogue nanl {
  // FIX: not yet implemented
  //  extern "C" long double nanl(const char *);
}
epilogue nearbyint {
  extern "C" double nearbyint(double);
}
epilogue nearbyintf {
  extern "C" float nearbyintf(float);
}
epilogue nearbyintl {
  extern "C" long double nearbyintl(long double);
}
epilogue nextafter {
  extern "C" double nextafter(double, double);
}
epilogue nextafterf {
  extern "C" float nextafterf(float, float);
}
epilogue nextafterl {
  extern "C" long double nextafterl(long double, long double);
}
epilogue nexttoward {
  extern "C" double nexttoward(double, long double);
}
epilogue nexttowardf {
  extern "C" float nexttowardf(float, long double);
}
epilogue nexttowardl {
  extern "C" long double nexttowardl(long double, long double);
}
epilogue pow {
  extern "C" double pow(double, double);
}
epilogue powf {
  extern "C" float powf(float, float);
}
epilogue powl {
  extern "C" long double powl(long double, long double);
}
epilogue remainder {
  extern "C" double remainder(double, double);
}
epilogue remainderf {
  extern "C" float remainderf(float, float);
}
epilogue remainderl {
  extern "C" long double remainderl(long double, long double);
}
epilogue remquo {
  extern "C" double remquo(double, double, int @);
}
epilogue remquof {
  extern "C" float remquof(float, float, int @);
}
epilogue remquol {
  extern "C" long double remquol(long double, long double, int @);
}
epilogue rint {
  extern "C" double rint(double);
}
epilogue rintf {
  extern "C" float rintf(float);
}
epilogue rintl {
  extern "C" long double rintl(long double);
}
epilogue round {
  extern "C" double round(double);
}
epilogue roundf {
  extern "C" float roundf(float);
}
epilogue roundl {
  extern "C" long double roundl(long double);
}
epilogue scalb {
  extern "C" double scalb(double, double);
}
epilogue scalbln {
  extern "C" double scalbln(double, long);
}
epilogue scalblnf {
  extern "C" float scalblnf(float, long);
}
epilogue scalblnl {
  extern "C" long double scalblnl(long double, long);
}
epilogue scalbn {
  extern "C" double scalbn(double, int);
}
epilogue scalbnf {
  extern "C" float scalbnf(float, int);
}
epilogue scalbnl {
  extern "C" long double scalbnl(long double, int);
}
epilogue sin {
  extern "C" double sin(double);
}
epilogue sinf {
  extern "C" float sinf(float);
}
epilogue sinh {
  extern "C" double sinh(double);
}
epilogue sinhf {
  extern "C" float sinhf(float);
}
epilogue sinhl {
  extern "C" long double sinhl(long double);
}
epilogue sinl {
  extern "C" long double sinl(long double);
}
epilogue sqrt {
  extern "C" double sqrt(double);
}
epilogue sqrtf {
  extern "C" float sqrtf(float);
}
epilogue sqrtl {
  extern "C" long double sqrtl(long double);
}
epilogue tan {
  extern "C" double tan(double);
}
epilogue tanf {
  extern "C" float tanf(float);
}
epilogue tanh {
  extern "C" double tanh(double);
}
epilogue tanhf {
  extern "C" float tanhf(float);
}
epilogue tanhl {
  extern "C" long double tanhl(long double);
}
epilogue tanl {
  extern "C" long double tanl(long double);
}
epilogue tgamma {
  extern "C" double tgamma(double);
}
epilogue tgammaf {
  extern "C" float tgammaf(float);
}
epilogue tgammal {
  extern "C" long double tgammal(long double);
}
epilogue trunc {
  extern "C" double trunc(double);
}
epilogue truncf {
  extern "C" float truncf(float);
}
epilogue truncl {
  extern "C" long double truncl(long double);
}
epilogue y0 {
  extern "C" double y0(double);
}
epilogue y1 {
  extern "C" double y1(double);
}
epilogue yn {
  extern "C" double yn(int, double);
}
epilogue {
  extern "C" int signgam;
}
;

// Defines a printf-like function, so we need to define it in Cyclone
// Not supported yet
monetary.h:
;

// Realtime
// Not supported yet
mqueue.h:
;

// Defines a structure containing a void *
// Not supported yet
ndbm.h:
;

// Defines a structure containing a char *
// Not supported yet
net/if.h:
;

netdb.h:
include {
in_port_t
in_addr
uint32_t
IPPORT_RESERVED
HOST_NOT_FOUND
NO_DATA
NO_RECOVERY
TRY_AGAIN
socklen_t
servent
hostent
protoent
}
epilogue {
  /* Not defined in OS X or cygwin so we guess :-( */
  #ifndef _in_port_t_def_
  #define _in_port_t_def_
  typedef unsigned short in_port_t;
  #endif
}
epilogue {
#define h_addr h_addr_list[0]
}
epilogue getservbyname {
  // FIX: might this be unsafe?  In particular, we might either end up
  //   with a memory leak, since this was probably malloced, or
  //   with some clobbered memory if it's using a static buffer.
  // FIX: should strings be non-NULL?
  extern "C" struct servent *getservbyname(const char * name, const char * proto);
}
epilogue gethostbyname {
  // FIX: see getservbyname comment
  extern "C" struct hostent *gethostbyname(const char * name);
}
epilogue getprotobyname {
  // FIX: see getservbyname comment
  extern "C" struct protoent * getprotobyname(const char * name);
}
epilogue herror {
  // FIX: should string be non-NULL
  extern "C" void herror(const char *);
}
;

netinet/in.h:
cpp {
  #include <sys/types.h>
}
include {
in_port_t
in_addr_t
sa_family_t
uint8_t
uint32_t
in_addr
sockaddr_in
in6_addr
sockaddr_in6
in6addr_any
IN6ADDR_ANY_INIT
in6addr_loopback
IN6ADDR_LOOPBACK_INIT
ipv6_mreq
IPPROTO_IP
IPPROTO_IPV6
IPPROTO_ICMP
IPPROTO_RAW
IPPROTO_TCP
IPPROTO_UDP
INADDR_ANY
INADDR_BROADCAST
INET_ADDRSTRLEN
INET6_ADDRSTRLEN
IPV6_JOIN_GROUP
IPV6_LEAVE_GROUP
IPV6_MULTICAST_HOPS
IPV6_MULTICAST_IF
IPV6_MULTICAST_LOOP
IPV6_UNICAST_HOPS
IPV6_V6ONLY
IN6_IS_ADDR_UNSPECIFIED
IN6_IS_ADDR_MULTICAST
IN6_IS_ADDR_MC_NODELOCAL
IN6_IS_ADDR_MC_LINKLOCAL
IN6_IS_ADDR_MC_SITELOCAL
IN6_IS_ADDR_MC_ORGLOCAL
IN6_IS_ADDR_MC_GLOBAL
}
epilogue {
  /* We'd like to do
     include {
     IN6_IS_ADDR_LINKLOCAL
     IN6_IS_ADDR_LOOPBACK
     IN6_IS_ADDR_SITELOCAL
     IN6_IS_ADDR_V4COMPAT
     IN6_IS_ADDR_V4MAPPED
     }
     but these bring in declarations for htonl and ntohl, which
     conflict with the declarations below.
  */
}
epilogue {
  /* These aren't defined in OS X or Cygwin so we guess :-( */
  #ifndef _in_port_t_def_
  #define _in_port_t_def_
  typedef unsigned short in_port_t;
  #endif
  #ifndef _in_addr_t_def_
  #define _in_addr_t_def_
  typedef unsigned int in_addr_t;
  #endif
}
// Not sure why these were here -- they aren't according to POSIX
// epilogue htonl {
//   extern "C" uint32_t htonl(uint32_t);
// }
// epilogue htons {
//   extern "C" uint16_t htons(uint16_t);
// }
// epilogue ntohl {
//   extern "C" uint32_t ntohl(uint32_t);
// }
// epilogue ntohs {
//   extern "C" uint16_t ntohs(uint16_t);
// }
;

netinet/tcp.h:
include {
TCP_NODELAY
}
;

// Locale stuff
// Not supported yet
nl_types.h:
;

poll.h:
include {
pollfd
nfds_t
POLLIN
POLLRDNORM
POLLRDBAND
POLLPRI
POLLOUT
POLLWRNORM
POLLWRBAND
POLLERR
POLLHUP
POLLNVAL
}
epilogue {
  /* Cygwin does not define this type so we take a guess :-( */
  /* FIX: make this specific to cygwin ?? */
  #ifndef _nfds_t_def_
  #define _nfds_t_def_
  typedef unsigned int nfds_t;
  #endif
}
epilogue poll {
  extern int poll (struct pollfd?, nfds_t, int);
}
cycstub poll {
  namespace Cpoll {
    extern "C" int poll(struct pollfd @{0}, nfds_t b, int c);
  }
  static xtunion exn.Failure __poll_failure_1 =
    Failure("poll called with NULL");
  static xtunion exn.Failure __poll_failure_2 =
    Failure("poll called with out-of-bounds pointer");
  int poll(struct pollfd?a, nfds_t b, int c) {
    if (!a) throw &__poll_failure_1;
    try *a;
    catch {
    case Array_bounds: throw &__poll_failure_2;
    }
    int len = a.size;
    return Cpoll::poll((struct pollfd @{0})a,
                       (b<(nfds_t)len)?b:(nfds_t)len,
                       c);
  }
}
;

// Threads
// Not supported yet
pthread.h:
;

// Defines a structure containing a char *
// Not supported yet
// pwd.h:
// ;

// Our parser dies on it in Linux
// Uses strings extensively, probably best to rewrite in Cyclone
// Not supported yet
regexp.h:
;

// Real time
// Not supported yet
sched.h:
;

// Defines a structure containing a char *
// Not supported yet
search.h:
;

// Not supported yet
semaphore.h:
;

// Not supported yet
setjmp.h:
;

signal.h:
omitvariables { sigaction }
include {
sig_atomic_t
pid_t
SIGEV_NONE
SIGEV_SIGNAL
SIGEV_THREAD
SIGABRT
SIGALRM
SIGBUS
SIGCHLD
SIGCONT
SIGFPE
SIGHUP
SIGILL
SIGINT
SIGKILL
SIGPIPE
SIGQUIT
SIGSEGV
SIGSTOP
SIGTERM
SIGTSTP
SIGTTIN
SIGTTOU
SIGUSR1
SIGUSR2
SIGPOLL
SIGPROF
SIGSYS
SIGTRAP
SIGURG
SIGVTALRM
SIGXCPU
SIGXFSZ
SA_NOCLDSTOP
SIG_BLOCK
SIG_UNBLOCK
SIG_SETMASK
SA_ONSTACK
SA_RESETHAND
SA_RESTART
SA_SIGINFO
SA_NOCLDWAIT
SA_NODEFER
SA_ONSTACK
SA_DISABLE
MINSIGSTACKSZ
SIGSTACKSZ
ucontext_t
mcontext_t
SIG_HOLD
sigset_t
}
epilogue {
  // We'd like to
  // include { sigevent sigval stack_t sigstack siginfo_t }
  // but in Linux this pulls in structures that contain void *'s.

  // If SIG_HOLD is defined in the C library, it is defined as an
  // integer cast to a function pointer, which won't be allowed in
  // Cyclone, so we undef it here.  We define _SIG_HOLD_def_ to
  // remember that we should support it, though.
  #ifdef SIG_HOLD
  #define _SIG_HOLD_def_
  #undef SIG_HOLD
  #endif
}
epilogue kill {
  extern "C" int kill(pid_t, int);
}
epilogue raise {
  extern "C" int raise(int);
}
epilogue sigaddset {
  #ifndef __CYGWIN__
  /* In Cygwin, the #include <setjmp.h> in precore_c.h pollutes
     the namespace of the C output with a different declaration
     for sigaddset, sigdelset, sigemptyset, sigfillset,
     sigismember, and signal, so we have to disable them for now. */
  extern "C" int sigaddset(sigset_t@, int);  
  #endif
}
epilogue sigdelset {
  #ifndef __CYGWIN__
  extern "C" int sigdelset(sigset_t@, int);
  #endif
}
epilogue sigemptyset {
  #ifndef __CYGWIN__
  extern "C" int sigemptyset(sigset_t@);
  #endif
}
epilogue sigfillset {
  #ifndef __CYGWIN__
  extern "C" int sigfillset(sigset_t@);
  #endif
}
epilogue sighold {
  extern "C" int sighold(int);
}
epilogue sigignore {
  extern "C" int sigignore(int);
}
epilogue siginterrupt {
  extern "C" int siginterrupt(int,int);
}
epilogue sigismember {
  #ifndef __CYGWIN__
  extern "C" int sigismember(sigset_t@, int);
  #endif
}
epilogue sigpause {
  extern "C" int sigpause(int);
}
epilogue sigrelse {
  extern "C" int sigrelse(int);
}
epilogue {
  extern tunion SigBuiltin {
    SIG_DFL;
    SIG_ERR;
    SIG_IGN;
  #ifdef _SIG_HOLD_def_
    SIG_HOLD;  // Rare
  #endif
  };
  extern tunion SigArg {
    __SIG_BUILTIN(tunion SigBuiltin);
    __SIG_HANDLER(void (@)(int)); // Note, must be heap allocated
  };
  typedef tunion `r SigArg sigarg_t<`r>;
}
cycstub {
  #include <csignal.h>
}
epilogue sigset {
  extern sigarg_t sigset(int, sigarg_t);
}
cycstub {
  namespace Csignal {
    extern "C" sigarg_t sigset_SIG_DFL(int);
    extern "C" sigarg_t sigset_SIG_ERR(int);
    extern "C" sigarg_t sigset_SIG_IGN(int);
  #ifdef _SIG_HOLD_def_
    extern "C" sigarg_t sigset_SIG_HOLD(int);
  #endif
    extern "C" sigarg_t sigset_SIG_HANDLER(int, void (@`H)(int));
    // for the use of the C sigset stubs
    sigarg_t make_SIG_DFL() {
      return new __SIG_BUILTIN(SIG_DFL);
    }
    sigarg_t make_SIG_ERR() {
      return new __SIG_BUILTIN(SIG_ERR);
    }
    sigarg_t make_SIG_IGN() {
      return new __SIG_BUILTIN(SIG_ERR);
    }
  #ifdef _SIG_HOLD_def_
    sigarg_t make_SIG_HOLD() {
      return new __SIG_BUILTIN(SIG_HOLD);
    }
  #endif
    sigarg_t make_SIG_HANDLER(void f(int)) {
      return new __SIG_HANDLER(f);
    }
  }
}
cycstub sigset {
  sigarg_t sigset(int a, sigarg_t b) {
    switch (b) {
    case &__SIG_BUILTIN(SIG_DFL):
      return Csignal::sigset_SIG_DFL(a);
    case &__SIG_BUILTIN(SIG_ERR):
      return Csignal::sigset_SIG_ERR(a);
  #ifdef _SIG_HOLD_def_
    case &__SIG_BUILTIN(SIG_HOLD):
      return Csignal::sigset_SIG_HOLD(a);
  #endif
    case &__SIG_BUILTIN(SIG_IGN):
      return Csignal::sigset_SIG_IGN(a);
    case &__SIG_HANDLER(f):
      return Csignal::sigset_SIG_HANDLER(a,f);
    }
  }
}
cstub {
  #include <signal.h>
  typedef void *Cyc_Std_sigarg_t;
  extern Cyc_Std_sigarg_t Cyc_Std_Csignal_make_SIG_DFL();
  extern Cyc_Std_sigarg_t Cyc_Std_Csignal_make_SIG_ERR();
  extern Cyc_Std_sigarg_t Cyc_Std_Csignal_make_SIG_IGN();
  extern Cyc_Std_sigarg_t Cyc_Std_Csignal_make_SIG_HOLD();
  extern Cyc_Std_sigarg_t Cyc_Std_Csignal_make_SIG_HANDLER(void (*)(int));
  Cyc_Std_sigarg_t sig_wrap(void (*f)(int)) {
    if (f == SIG_DFL)
      return Cyc_Std_Csignal_make_SIG_DFL();
    if (f == SIG_ERR)
      return Cyc_Std_Csignal_make_SIG_ERR();
    if (f == SIG_IGN)
      return Cyc_Std_Csignal_make_SIG_IGN();
  #ifdef SIG_HOLD
    if (f == SIG_HOLD)
      return Cyc_Std_Csignal_make_SIG_HOLD();
  #endif
      return Cyc_Std_Csignal_make_SIG_HANDLER(f);
  }
}
cstub sigset {
  Cyc_Std_sigarg_t sigset_SIG_DFL(int a) {
    return sig_wrap(sigset(a,SIG_DFL));
  }
  Cyc_Std_sigarg_t sigset_SIG_ERR(int a) {
    return sig_wrap(sigset(a,SIG_ERR));
  }
  Cyc_Std_sigarg_t sigset_SIG_IGN(int a) {
    return sig_wrap(sigset(a,SIG_IGN));
  }
#ifdef _SIG_HOLD_def_
  Cyc_Std_sigarg_t sigset_SIG_HOLD(int a) {
    return sig_wrap(sigset(a,SIG_HOLD));
  }
#endif
  Cyc_Std_sigarg_t sigset_SIG_HANDLER(int a, void (*f)(int)) {
    return sig_wrap(sigset(a,f));
  }
}
epilogue signal {
  #ifndef __CYGWIN__
  extern sigarg_t signal(int, ... inject sigarg_t);
  #endif
}
cycstub signal {
  #ifndef __CYGWIN__
  namespace Csignal {
    extern "C" sigarg_t signal_SIG_DFL(int);
    extern "C" sigarg_t signal_SIG_ERR(int);
#ifdef _SIG_HOLD_def_
    extern "C" sigarg_t signal_SIG_HOLD(int);
#endif
    extern "C" sigarg_t signal_SIG_IGN(int);
    extern "C" sigarg_t signal(int, void (@`H)(int));
  }
  static xtunion exn.Failure __signal_failure =
    Failure("signal called with the wrong number of arguments");
  sigarg_t signal(int a, ... inject sigarg_t b) {
    if (b.size != 1)
      throw &__signal_failure;
    switch (b[0]) {
    case &__SIG_BUILTIN(SIG_DFL): return Csignal::signal_SIG_DFL(a);
    case &__SIG_BUILTIN(SIG_ERR): return Csignal::signal_SIG_ERR(a);
#ifdef _SIG_HOLD_def_
    case &__SIG_BUILTIN(SIG_HOLD): return Csignal::signal_SIG_HOLD(a);
#endif
    case &__SIG_BUILTIN(SIG_IGN): return Csignal::signal_SIG_IGN(a);
    case &__SIG_HANDLER(f):
      return Csignal::signal(a,f);
    }
  }
  #endif
}
cstub signal {
  #ifndef __CYGWIN__
  Cyc_Std_sigarg_t signal_SIG_DFL(int a) {
    return sig_wrap(signal(a,SIG_DFL));
  }
  Cyc_Std_sigarg_t signal_SIG_ERR(int a) {
    return sig_wrap(signal(a,SIG_ERR));
  }
  #ifdef _SIG_HOLD_def_
  Cyc_Std_sigarg_t signal_SIG_HOLD(int a) {
    return sig_wrap(signal(a,SIG_HOLD));
  }
  #endif
  Cyc_Std_sigarg_t signal_SIG_IGN(int a) {
    return sig_wrap(signal(a,SIG_IGN));
  }
  #endif
}
epilogue {
  // If we do 
  // include { sigaction }
  // in Linux we pull in a bad type

  // FIX: struct sigaction needs to be fixed so that field
  // sa_handler has type sigarg_t
  //extern "C" sigaction(int, const struct sigaction *, struct sigaction *);
}
;

// Realtime
// Not supported yet
spawn.h:
;

// We have safe ways of handling varargs in Cyclone already
// Not supported
stdarg.h:
;

// Maybe this should replace Cyclone's treatment of bool?
// Not supported yet
stdbool.h:
;

stddef.h:
include {
ptrdiff_t
wchar_t
size_t
}
epilogue {
  // NULL is not defined here because it is a keyword in Cyclone
}
;

stdint.h:
include {
int8_t
int16_t
int32_t
uint8_t
uint16_t
uint32_t
int64_t
uint64_t
int_least8_t
int_least16_t
int_least32_t
int_least64_t
uint_least8_t
uint_least16_t
uint_least32_t
uint_least64_t
int_fast8_t
int_fast16_t
int_fast32_t
int_fast64_t
uint_fast8_t
uint_fast16_t
uint_fast32_t
uint_fast64_t
intptr_t
uintptr_t
intmax_t
uintmax_t
INTN_MIN
INTN_MAX
UINTN_MAX
INT_LEASTN_MIN
INT_LEASTN_MAX
UINT_LEASTN_MAX
INT_FASTN_MIN
INT_FASTN_MAX
UINT_FASTN_MAX
INTPTR_MIN
INTPTR_MAX
UINTPTR_MAX
INTMAX_MIN
INTMAX_MAX
UINTMAX_MAX
PTRDIFF_MIN
PTRDIFF_MAX
SIG_ATOMIC_MIN
SIG_ATOMIC_MAX
SIZE_MAX
WCHAR_MIN
WCHAR_MAX
WINT_MIN
WINT_MAX
INTN_C
UINTN_C
INTMAX_C
UINTMAX_C
}
epilogue {
  // Note that intptr_t, uintptr_t, and related macros
  // all involve casting to and from void *, so they
  // are probably useless in Cyclone
}
;

stdio.h:
include {
BUFSIZ
_IOFBF
_IOLBF
_IONBF
L_ctermid
L_tmpnam
SEEK_CUR
SEEK_END
SEEK_SET
FILENAME_MAX
FOPEN_MAX
TMP_MAX
EOF
P_tmpdir
fpos_t
size_t
}
prologue {
  #include <core.h>
}
epilogue {
  // NOTES:
  // NULL is not defined because it is a keyword in Cyclone.
  // va_list is not defined because Cyclone has safe varargs.
}
epilogue {
  extern struct __cycFILE;  
  typedef struct __cycFILE FILE;
  extern FILE @stdout;
  extern FILE @stdin;
  extern FILE @stderr;
}
epilogue {
  namespace Cstdio {
    extern "C" struct __abstractFILE;    // needed by tmp.cyc
  }
}
cycstub {
  namespace Cstdio {
    extern "C" struct __abstractFILE;
    typedef struct __abstractFILE __cFILE;
  }
  abstract struct __cycFILE { // must match defn in c stub
    Cstdio::__cFILE @file;
  };
}
epilogue {
  // fromCfile needed by tmp.cyc
  extern FILE *`H fromCfile(struct Cstdio::__abstractFILE *`H cf);
}
cycstub {
  FILE*`H fromCfile(Cstdio::__cFILE *`H cf) {
    return cf ? new __cycFILE(cf) : NULL;
  }
}
cstub {
  #include <stdio.h>
  // Define struct Std::__cycFILE, and initialize stdin, stdout, stderr
  struct Cyc_Std___cycFILE { // must match defn in cyclone stub
    FILE *file;
  } Cyc_Std_stdin_v, Cyc_Std_stdout_v, Cyc_Std_stderr_v,
    *Cyc_Std_stdin = &Cyc_Std_stdin_v,
    *Cyc_Std_stdout = &Cyc_Std_stdout_v,
    *Cyc_Std_stderr = &Cyc_Std_stderr_v;
}
epilogue {
  // vararg for printf functions.  The functions themselves are defined
  // in printf.cyc.
  extern tunion PrintArg<`r::R> {
    String_pa(const char ?`r);
    Int_pa(unsigned long);
    Double_pa(double);
    ShortPtr_pa(short @`r);
    Buffer_pa(const char ?NOZEROTERM`r);
    IntPtr_pa(unsigned long @`r);
  };
  typedef tunion `r PrintArg<`r> parg_t<`r>;

  // Cyclone specific.
  // Similar to sprintf but allocates a result of the right size on the heap.
  extern char ?aprintf(const char ?, ... inject parg_t)
    __attribute__((format(printf,1,2)))
    ;
}
epilogue clearerr {
  extern void clearerr(FILE @);
}
cycstub clearerr {
  namespace Cstdio {
    extern "C" void clearerr(__cFILE @);
  }
  void clearerr(FILE @f) {
    return Cstdio::clearerr(f->file);
  }
}
epilogue ctermid {
  // FIX: not supported yet
  //  char *ctermid(char *);
}
epilogue fclose {
  extern int fclose(FILE @);
}
cycstub fclose {
  namespace Cstdio {
    extern "C" int fclose(__cFILE @);
  }
  int fclose(FILE @f) {
    return Cstdio::fclose(f->file);
  }
}
epilogue fdopen {
  // FIX: second arg allowed to be NULL?
  extern FILE *fdopen(int, const char *);
}
cycstub fdopen {
  namespace Cstdio {
    extern "C" Cstdio::__cFILE *fdopen(int,const char *);
  }
  FILE *fdopen(int i, const char * s) {
    let cf = Cstdio::fdopen(i,s);
    // FIX: get rid of the heap allocation
    return cf ? new __cycFILE((Cstdio::__cFILE @)cf) : NULL;
  }
}
epilogue feof {
  extern int feof(FILE @);
}
cycstub feof {
  namespace Cstdio {
    extern "C" int feof(__cFILE @);
  }
  int feof(FILE @f) {
    return Cstdio::feof(f->file);
  }
}
epilogue ferror {
  extern int ferror(FILE @);
}
cycstub ferror {
  namespace Cstdio {
    extern "C" int ferror(__cFILE @);
  }
  int ferror(FILE @f) {
    return Cstdio::ferror(f->file);
  }
}
epilogue fflush {
  extern int fflush(FILE *);
}
cycstub fflush {
  namespace Cstdio {
    extern "C" int fflush(__cFILE *);
  }
  int fflush(FILE *f) {
    if (f)
      return Cstdio::fflush(f->file);
    else return Cstdio::fflush(NULL);
  }
}
epilogue fgetc {
  extern int fgetc(FILE @);
}
cycstub fgetc {
  namespace Cstdio {
    extern "C" int fgetc(__cFILE @);
  }
  int fgetc(FILE @f) {
    return Cstdio::fgetc(f->file);
  }
}
epilogue fgetpos {
  extern int fgetpos(FILE @, fpos_t @);
}
cycstub fgetpos {
  namespace Cstdio {
    extern "C" int fgetpos(__cFILE @, fpos_t @);
  }
  int fgetpos(FILE @f, fpos_t @x) {
    return Cstdio::fgetpos(f->file,x);
  }
}
epilogue fgets {
  extern char ?NOZEROTERM`r fgets(char ?NOZEROTERM`r, int, FILE @);
}
cycstub fgets {
  namespace Cstdio {
    extern "C" char *NOZEROTERM`r fgets(char *NOZEROTERM`r, int, __cFILE @);
  }
  static xtunion exn.Failure __fgets_failure_1 =
    Failure("fgets called with NULL string");
  static xtunion exn.Failure __fgets_failure_2 =
    Failure("fgets: buffer insufficient");
  char ?NOZEROTERM`r fgets(char ?NOZEROTERM`r s, int n, FILE @f) {
    if (!s) throw &__fgets_failure_1;
    char *NOZEROTERM`r result;
    char *NOZEROTERM buffer = (char *NOZEROTERM)s;
    unsigned int len = s.size;
    if (len < n) throw &__fgets_failure_2; 
    // n = (len < n) ? len : n;
    result = Cstdio::fgets(buffer, n, f->file);
    if (result == NULL) 
      return NULL;
    else 
      return s;
  }
}
epilogue fileno {
  extern int fileno(FILE @);
}
cycstub fileno {
  namespace Cstdio {
    extern "C" int fileno(__cFILE @);
  }
  int fileno(FILE @f) {
    return Cstdio::fileno(f->file);
  }
}
epilogue flockfile {
  extern void flockfile(FILE @);
}
cycstub flockfile {
  namespace Cstdio {
    extern "C" void flockfile(__cFILE @);
  }
  void flockfile(FILE @f) {
    return Cstdio::flockfile(f->file);
  }
}
epilogue fopen {
  extern FILE *fopen(const char @, const char @);
}
cycstub fopen {
  namespace Cstdio {
    extern "C" __cFILE *fopen(const char @, const char @);
  }
  FILE *fopen(const char @ name, const char @ type) {
    let cf = Cstdio::fopen(name, type);
    // FIX: get rid of the heap allocation
    return cf ? new __cycFILE((Cstdio::__cFILE @)cf) : NULL;
  }
}
epilogue {
  extern int fprintf(FILE @,const char ?, ... inject parg_t)
    __attribute__((format(printf,2,3)))
    ;
}
epilogue fputc {
  extern int fputc(int, FILE @);
}
cycstub fputc {
  namespace Cstdio {
    extern "C" int fputc(int, __cFILE @);
  }
  int fputc(int x, FILE @f) {
    return Cstdio::fputc(x,f->file);
  }
}
epilogue fputs {
  extern int fputs(const char @, FILE @);
}
cycstub fputs {
  namespace Cstdio {
    extern "C" int fputs(const char @, __cFILE @);
  }
  int fputs(const char @ x, FILE @f) {
    return Cstdio::fputs(x,f->file);
  }
}
epilogue fread {
  extern size_t fread(char ?NOZEROTERM, size_t, size_t, FILE @);
}
cycstub fread {
  namespace Cstdio {
    extern "C" size_t fread(char *NOZEROTERM, size_t, size_t, __cFILE @);
  }
  static xtunion exn.Failure __fread_failure =
    Failure("fread: buffer insufficient");
  size_t fread(char ?NOZEROTERM ptr, size_t size, size_t nmemb, FILE @f) {
    if (size * nmemb > ptr.size) throw &__fread_failure;
    return Cstdio::fread((char *NOZEROTERM)ptr, size, nmemb, f->file);
  }
}
epilogue freopen {
  extern FILE *`r freopen(const char *, const char @, FILE @`r);
}
cycstub freopen {
  namespace Cstdio {
    extern "C" __cFILE *`r freopen(const char *, const char @, 
				   __cFILE @`r);
  }
  FILE *`r freopen(const char * filename, const char @ modes, FILE @`r f) {
    // Note, filename is allowed to be NULL
    let cf = Cstdio::freopen(filename,modes,f->file);
    // FIX: get rid of the heap allocation
    return cf ? new __cycFILE((Cstdio::__cFILE @)cf) : NULL;
  }
}
epilogue {
  // vararg for scanf functions.  The functions themselves are defined
  // in scanf.cyc.
  extern tunion ScanfArg<`r::R> {
    ShortPtr_sa(short @`r);
    UShortPtr_sa(unsigned short @`r);
    IntPtr_sa(int @`r);
    UIntPtr_sa(unsigned int @`r);
    StringPtr_sa(char ?`r);
    DoublePtr_sa(double @`r);
    FloatPtr_sa(float @`r);
    CharPtr_sa(char ?NOZEROTERM`r)
  };
  typedef tunion `r2 ScanfArg<`r1> sarg_t<`r1,`r2>;
}
epilogue {
  extern int fscanf(FILE @, const char ?, ... inject sarg_t)
    __attribute__((format(scanf,2,3)))
    ;
}
epilogue fseek {
  extern int fseek(FILE @, long, int);
}
cycstub fseek {
  namespace Cstdio {
    extern "C" int fseek(__cFILE @, long, int);
  }
  int fseek(FILE @a, long b, int c) {
    return Cstdio::fseek(a->file,b,c);
  }
}
epilogue fseeko {
  extern int fseeko(FILE @, off_t, int);
}
cycstub fseeko {
  namespace Cstdio {
    extern "C" int fseeko(__cFILE @, off_t, int);
  }
  int fseeko(FILE @a, off_t b, int c) {
    return Cstdio::fseeko(a->file,b,c);
  }
}
epilogue fsetpos {
  extern int fsetpos(FILE @, const fpos_t @);
}
cycstub fsetpos {
  namespace Cstdio {
    extern "C" int fsetpos(__cFILE @, const fpos_t @);
  }
  int fsetpos(FILE @f, const fpos_t @b) {
    return Cstdio::fsetpos(f->file,b);
  }
}
epilogue ftell {
  extern long ftell(FILE @);
}
cycstub ftell {
  namespace Cstdio {
    extern "C" long ftell(__cFILE @);
  }
  long ftell(FILE @f) {
    return Cstdio::ftell(f->file);
  }
}
epilogue ftello {
  extern off_t ftello(FILE @);
}
cycstub ftello {
  namespace Cstdio {
    extern "C" off_t ftello(__cFILE @);
  }
  off_t ftello(FILE @f) {
    return Cstdio::ftello(f->file);
  }
}
epilogue ftrylockfile {
  extern int ftrylockfile(FILE @);
}
cycstub ftrylockfile {
  namespace Cstdio {
    extern "C" int ftrylockfile(__cFILE @);
  }
  int ftrylockfile(FILE @f) {
    return Cstdio::ftrylockfile(f->file);
  }
}
epilogue ftryunlockfile {
  extern int ftryunlockfile(FILE @);
}
cycstub ftryunlockfile {
  namespace Cstdio {
    extern "C" int ftryunlockfile(__cFILE @);
  }
  int ftryunlockfile(FILE @f) {
    return Cstdio::ftryunlockfile(f->file);
  }
}
epilogue funlockfile {
  extern void funlockfile(FILE @);
}
cycstub funlockfile {
  namespace Cstdio {
    extern "C" void funlockfile(__cFILE @);
  }
  void funlockfile(FILE @f) {
    return Cstdio::funlockfile(f->file);
  }
}
epilogue fwrite {
  extern size_t fwrite(const char ?NOZEROTERM, size_t, size_t, FILE @);
}
cycstub fwrite {
  namespace Cstdio {
    extern "C" size_t fwrite(const char @NOZEROTERM, size_t, size_t, __cFILE @);
  }
  static xtunion exn.Failure __fwrite_failure_1 =
    Failure("fwrite called with NULL string");
  static xtunion exn.Failure __fwrite_failure_2 =
    Failure("fwrite: buffer insufficient");
  size_t fwrite(const char ?NOZEROTERM`r ptr, size_t size, size_t nmemb, FILE @f) {
    if (!ptr) { throw &__fwrite_failure_1; } 
    else {
      if (size * nmemb > ptr.size) throw &__fwrite_failure_2;
      return Cstdio::fwrite((const char @NOZEROTERM)ptr, size, nmemb, f->file);
    }
  }
}
epilogue getc {
  extern int getc(FILE @);
}
cycstub getc {
  namespace Cstdio {
    extern "C" int getc(__cFILE @);
  }
  int getc(FILE @f) {
    return Cstdio::getc(f->file);
  }
}
epilogue getchar {
  extern int getchar(void);
}
cycstub getchar {
  namespace Cstdio {
    extern "C" int getchar(void);
  }
  int getchar(void) {
    return Cstdio::getchar();
  }
}
epilogue getc_unlocked {
  extern int getc_unlocked(FILE @);
}
cycstub getc_unlocked {
  namespace Cstdio {
    extern "C" int getc_unlocked(__cFILE @);
  }
  int getc_unlocked(FILE @f) {
    return Cstdio::getc_unlocked(f->file);
  }
}
epilogue getchar_unlocked {
  extern int getchar_unlocked(void);
}
cycstub getchar_unlocked {
  namespace Cstdio {
    extern "C" int getchar_unlocked(void);
  }
  int getchar_unlocked(void) {
    return Cstdio::getchar_unlocked();
  }
}
epilogue gets {
  // FIX: we don't support gets because the C version is completely
  // unsafe.  We could support it safely by writing it in Cyclone.
  //  extern char *gets(char *);
}
epilogue pclose {
  extern int pclose(FILE @);
}
cycstub pclose {
  namespace Cstdio {
    extern "C" int pclose(__cFILE @);
  }
  int pclose(FILE @f) {
    return Cstdio::pclose(f->file);
  }
}
epilogue perror {
  // FIX: worry about char * being NULL?
  extern "C" void perror(const char *);
}
epilogue popen {
  extern FILE *popen(const char @, const char @);
}
cycstub popen {
  namespace Cstdio {
    extern "C" __cFILE *popen(const char @, const char @);
  }
  FILE *popen(const char @ name, const char @ type) {
    let cf = Cstdio::popen(name, type);
    // FIX: get rid of the heap allocation
    return cf ? new __cycFILE((Cstdio::__cFILE @)cf) : NULL;
  }
}
epilogue {
  extern int printf(const char ?, ... inject parg_t)
    __attribute__((format(printf,1,2)))
    ;
}
epilogue putc {
  extern int putc(int, FILE @);
}
cycstub putc {
  namespace Cstdio {
    extern "C" int putc(int, __cFILE @);
  }
  int putc(int x, FILE @f) {
    return Cstdio::putc(x,f->file);
  }
}
epilogue putchar {
  extern "C" int putchar(int);
}
epilogue putc_unlocked {
  extern int putc_unlocked(int, FILE @);
}
cycstub putc_unlocked {
  namespace Cstdio {
    extern "C" int putc_unlocked(int, __cFILE @);
  }
  int putc_unlocked(int x, FILE @f) {
    return Cstdio::putc_unlocked(x,f->file);
  }
}
epilogue putchar_unlocked {
  extern "C" int putchar_unlocked(int);
}
epilogue puts {
  extern "C" int puts(const char @);
}
epilogue remove {
  extern "C" int remove(const char @);
}
epilogue rename {
  extern "C" int rename(const char @, const char @);
}
epilogue rewind {
  extern void rewind(FILE @);
}
cycstub rewind {
  namespace Cstdio {
    extern "C" void rewind(__cFILE @);
  }
  void rewind(FILE @f) {
    return Cstdio::rewind(f->file);
  }
}
epilogue {
  // Cyclone specific.
  extern char ?`r rprintf(region_t<`r>, const char ?, ... inject parg_t)
    __attribute__((format(printf,2,3)))
    ;
}
epilogue {
  extern int scanf(const char ?, ... inject sarg_t)
    __attribute__((format(scanf,1,2)))
    ;
}
epilogue setvbuf {
  // FIX: should the second arg be const?
  extern int setvbuf(FILE @, char ?NOZEROTERM`H, int, size_t);
  // The second arg of setvbuf must be heap-allocated because
  // it will be used by the IO library after setvbuf returns.
}
cycstub setvbuf {
  namespace Cstdio {
    extern "C" int setvbuf(__cFILE @, char *NOZEROTERM`H, int, size_t);
  }
  static xtunion exn.Failure __setvbuf_failure_1 =
    Failure("setvbuf: buffer is NULL");
  static xtunion exn.Failure __setvbuf_failure_2 =
    Failure("setvbuf: buffer insufficient");
  int setvbuf(FILE @f, char ?NOZEROTERM`H buf, int type, size_t size) {
    if (!buf) throw &__setvbuf_failure_1;
    if (buf.size < size) throw &__setvbuf_failure_2;
    return Cstdio::setvbuf(f->file,(char *NOZEROTERM`H)buf,type,size);
  }
}
epilogue setbuf {
  extern void setbuf(FILE @, char ?NOZEROTERM`H);
}
cycstub setbuf {
  void setbuf(FILE @f, char ?NOZEROTERM`H buf) {
    setvbuf(f, buf, buf ? _IOFBF : _IONBF, BUFSIZ);
    return;
  }
}
epilogue {
  extern int snprintf(char ?, size_t, const char ?, ... inject parg_t)
    __attribute__((format(printf,3,4)))
    ;
}
epilogue {
  extern int sprintf(char ?, const char ?, ... inject parg_t)
    __attribute__((format(printf,2,3)))
    ;
}
epilogue {
  extern int sscanf(const char ?, const char ?, ... inject sarg_t)
    __attribute__((format(scanf,2,3)))
    ;
}
epilogue tempnam {
  // FIX: tempnam is not yet supported.  The C version does a heap
  // allocation (with malloc).  We need to write a C stub to free
  // this.
  // Note, tempnam is considered insecure because in between the call
  // of tempnam and open, a file can be created with the supposedly
  // fresh name.
  //  extern char *tempnam(const char *, const char *);
}
epilogue tmpfile {
  extern FILE *tmpfile(void);
}
cycstub tmpfile {
// currently in tmp.cyc
//  namespace Cstdio {
//    extern "C" __cFILE *tmpfile(void);
//  }
//  extern FILE *tmpfile(void) {
//    let cf = Cstdio::tmpfile();
//    // FIX: get rid of the heap allocation
//    return cf ? new __cycFILE((Cstdio::__cFILE @)cf) : NULL;
//  }
}
epilogue tmpnam {
  // Note, tmpnam is considered insecure because in between the call
  // of tmpnam and open, a file can be created with the supposedly
  // fresh name.
  // Note, we require the argument of tmpnam to be heap-allocated.
  // This is because if tmpnam is called with NULL, it is supposed
  // to return a pointer to a static (heap allocated) buffer, while if
  // tmpnam is called with a non-NULL argument, it returns that
  // argument.  So the only way to type tmpnam is to require the arg
  // to be heap allocated.
  extern char ? tmpnam(char ?`H);
}
cycstub tmpnam {
// currently defined in tmp.cyc
//  extern char ?`r strcpy(char ?`r,const char ?); 
//  // Instead of putting this in the stub file, we should just
//  // have a separate file for it.  That way the linker can leave
//  // it out if it isn't used, preventing a warning about the
//  // security problem.
//  namespace Cstdio {
//    extern "C" char * tmpnam(char *);
//  }
//  char ?`H tmpnam(char ?`H s) {
//    char ?name = static_c2s(Cstdio::tmpnam(NULL));
//    return s ? strcpy(s, name) : name;
//  }
}
epilogue ungetc {
  extern int ungetc(int, FILE @);
}
cycstub ungetc {
  namespace Cstdio {
    extern "C" int ungetc(int, __cFILE @);
  }
  int ungetc(int x, FILE @f) {
    return Cstdio::ungetc(x,f->file);
  }
}
epilogue vfprintf {
  extern int vfprintf(FILE @, const char ?, parg_t ?)
    __attribute__((format(printf,2,0)))
    ;
}
epilogue vfscanf {
  extern int vfscanf(FILE @, const char ?, sarg_t ?)
    __attribute__((format(scanf,2,0)))
    ;
}
epilogue vprintf {
  extern int vprintf(const char ?, parg_t ?)
    __attribute__((format(printf,1,0)))
    ;
}
epilogue {
  extern char ?`r vrprintf(region_t<`r>, const char ?, parg_t ?)
    __attribute__((format(printf,2,0)))
    ;
}
epilogue vscanf {
  // WE NEED TO ADD THIS TO SCANF.CYC
  //  extern int vscanf(const char *restrict, va_list);
}
epilogue vsnprintf {
  extern int vsnprintf(char ?, size_t, const char ?, parg_t ?) 
    __attribute__((format(printf,3,0)))
    ;
}
epilogue vsprintf {
  extern int vsprintf(char ?, const char ?, parg_t ?)
    __attribute__((format(printf,2,0)))
    ;
}
epilogue vsscanf {
  extern int vsscanf(const char ?, const char ?, sarg_t ?)
    __attribute__((format(scanf,2,0)))
    ;
}
epilogue getw {
  // getw is a glibc function but does not appear in posix; remove ??
  extern int getw(FILE @);
}
cycstub getw {
  namespace Cstdio {
    extern "C" int getw(__cFILE @);
  }
  int getw(FILE @f) {
    return Cstdio::getw(f->file);
  }
}
epilogue putw {
  // putw is a glibc function but does not appear in posix; remove ??
  extern int putw(int, FILE @);
}
cycstub putw {
  namespace Cstdio {
    extern "C" int putw(int, __cFILE @);
  }
  int putw(int x, FILE @f) {
    return Cstdio::putw(x,f->file);
  }
}
epilogue {
  // These functions appear in glibc but are not part of the posix
  // standard.  They are omitted for now.
  //  extern void setbuffer (FILE @, char ?, size_t);
  //  extern void setlinebuf (FILE @);
}
epilogue {
  // FIX: These functions are are not part of POSIX, they
  // are Cyclone-specific.  We should get rid of them or move
  // them elsewhere.

  // FIX: Not sure if these should use NULL-terminated strings or not
  extern xtunion exn {
    extern FileOpenError(const char ?);
    extern FileCloseError;
  };
  extern FILE @file_open(const char ?, const char ?);
  extern void file_close(FILE @);

  // These two don't seem to be defined anywhere.
  //  extern void file_delete(const char ?);
  //  extern void file_length(const char ?);

  // these two provided in c stubs
  extern int file_string_read(FILE @, char ?dest, int dest_offset, 
                              int max_count);
  extern int file_string_write(FILE @, const char ?src, int src_offset, 
                               int max_count);
}
cstub {
  FILE *_sfile_to_file(struct Cyc_Std___cycFILE *sf) {
    if(!sf) {
      fprintf(stderr,"Attempt to access null file descriptor.\n");
      exit(255);
    }
    if(!sf->file)
      throw(Cyc_Null_Exception); // FIX:  should be more descriptive?
    return sf->file;
  }
  int Cyc_Std_file_string_read(struct Cyc_Std___cycFILE *sf, 
                                 struct _tagged_arr dest,
                                 int dest_offset, int max_count) {
    unsigned char *new_curr = dest.curr + dest_offset;
    size_t sz = dest.last_plus_one - new_curr;
    FILE *fd = _sfile_to_file(sf);
    if (new_curr < dest.base || new_curr >= dest.last_plus_one)
      throw(Cyc_Null_Exception);
    if(dest_offset + max_count > sz) {
      fprintf(stderr,"Attempt to read off end of string.\n");
      exit(255);
    }
    return fread(new_curr, 1, max_count, fd);
  }
  int Cyc_Std_file_string_write(struct Cyc_Std___cycFILE *sf, 
                                  struct _tagged_arr src,
                                  int src_offset, int max_count) {
    size_t sz = src.last_plus_one - src.curr;
    unsigned char *new_curr = src.curr + src_offset;
    FILE *fd = _sfile_to_file(sf);
    if (new_curr < src.base || new_curr >= src.last_plus_one)
      throw(Cyc_Null_Exception);
    if(src_offset + max_count > sz) {
      fprintf(stderr,"Attempt to write off end of string.\n");
      exit(255);
    } 
    return fwrite(new_curr, 1, max_count, fd);
  }
}
cycstub {
  xtunion exn { 
    FileOpenError(const char ?); 
    FileCloseError;
  };

  FILE @file_open(const char ?fname, const char ?mode) {
    FILE *f = fopen((const char @)fname, (const char @)mode);
    if (f == NULL) {
      const char ? fn = new {for i < fname.size : fname[i]};
      throw new FileOpenError(fn);
    }
    return (FILE @)f; // FIX: get rid of cast?
  }

  void file_close(FILE @ f) {
    if (fclose(f) != 0) throw FileCloseError;
  }
}
;

stdlib.h:
include {
EXIT_FAILURE
EXIT_SUCCESS
RAND_MAX
MB_CUR_MAX
div_t
ldiv_t
lldiv_t
size_t
wchar_t
WNOHANG
WUNTRACED
WEXITSTATUS
WIFEXITED
WIFSIGNALED
WIFSTOPPED
WSTOPSIG
WTERMSIG
}
prologue {
  #include <core.h>
}
epilogue {
  // malloc is a primitive in Cyclone so we don't need this declaration
  //  extern "C" void *malloc(size_t);

  // These functions aren't supported in Cyclone
  //  extern "C" void *calloc(size_t, size_t);
  //  extern "C" void *realloc(void *, size_t);

  // This group of functions is not yet supported in Cyclone
  //  extern "C" long a64l(const char *);
  //  extern "C" void *bsearch(const void *, const void *, size_t, size_t, int (*)(const void *, const void *));
  //  extern "C" char *ecvt(double, int, int *restrict, int *restrict); (LEGACY)
  //                                                                      extern "C" char *fcvt(double, int, int *restrict, int *restrict); // (LEGACY)
  //  extern "C" char *gcvt(double, int, char *); // (LEGACY)
  //  extern "C" int getsubopt(char **, char *const *, char **);
  //  extern "C" char *initstate(unsigned, char *, size_t);
  //  extern "C" char *l64a(long);
  //  extern "C" int mblen(const char *, size_t);
  //  extern "C" size_t mbstowcs(wchar_t *restrict, const char *restrict, size_t);
  //  extern "C" int mbtowc(wchar_t *restrict, const char *restrict, size_t);
  //  extern "C" char *mktemp(char *); // (LEGACY)
  //  extern "C" int mkstemp(char *);
  //  extern "C" int posix_memalign(void **, size_t, size_t);
  //  extern "C" int posix_openpt(int);
  //  extern "C" char *ptsname(int);
  //  extern "C" char *realpath(const char *restrict, char *restrict);
  //  extern "C" int setenv(const char *, const char *, int);
  //  extern "C" void setkey(const char *);
  //  extern "C" char *setstate(const char *);
  //  extern "C" float strtof(const char *restrict, char **restrict);
  //  extern "C" long double strtold(const char *restrict, char **restrict);
  //  extern "C" long long strtoll(const char *restrict, char **restrict, int);
  //  extern "C" unsigned long long strtoull(const char *restrict, char **restrict, int);
  //  extern "C" int unsetenv(const char *);
  //  extern "C" size_t wcstombs(char *restrict, const wchar_t *restrict, size_t);
  //  extern "C" int wctomb(char *, wchar_t);

}
epilogue _Exit {
  extern "C" void _Exit(int);
}
epilogue abort {
  // This is the type of abort according to Posix, but we have a
  // conflicting type for abort in core.h
  //  extern "C" void abort(void);
}
epilogue abs {
  extern "C" int abs(int);
}
epilogue atexit {
  // FIX: this might not be safe.  The posix docs say that if
  // a function registered with atexit uses longjmp when called
  // by exit(), the results are undefined.  Since we use longjmp
  // for exceptions, we should look into this.  We may end up
  // having to write our own exit() function.
  extern "C" int atexit(void (@)(void));
}
epilogue atof {
  extern "C" double atof(const char @);
}
epilogue atoi {
  extern "C" int atoi(const char @);
}
epilogue atol {
  extern "C" long atol(const char @);
}
epilogue atoll {
  extern long long atoll(const char @);
}
epilogue div {
  extern "C" div_t div(int, int);
}
epilogue drand48 {
  extern "C" double drand48(void);
}
epilogue erand48 {
  extern "C" double erand48(unsigned short @{3});
}
epilogue exit {
// currently causes ambiguity
//  extern "C" void exit(int);
}
epilogue free {
  extern void free(`a::A ?);
}
cycstub free {
  void free(`a::A ?ptr) {}
}
epilogue getenv {
  // FIX: should this be const?  Seems like we want these things
  //   immutable
  extern "C" char @ getenv(const char @);
}
epilogue grantpt {
  extern "C" int grantpt(int);
}
epilogue jrand48 {
  extern "C" long jrand48(unsigned short @{3});
}
epilogue labs {
  // This is the correct type according to Posix but it produces
  // an error under Linux.  It looks like we are translating long
  // to int; not sure if this is the problem.
  //  extern "C" long labs(long);
}
epilogue lcong48 {
  extern "C" void lcong48(unsigned short @{7});
}
epilogue ldiv {
  extern "C" ldiv_t ldiv(long, long);
}
epilogue llabs {
  extern "C" long long llabs(long long);
}
epilogue lldiv {
  extern "C" lldiv_t lldiv(long long, long long);
}
epilogue lrand48 {
  extern "C" long lrand48(void);
}
epilogue mrand48 {
  extern "C" long mrand48(void);
}
epilogue nrand48 {
  extern "C" long nrand48(unsigned short @{3});
}
epilogue putenv {
  extern "C" int putenv(const char @);
}
epilogue {
  extern void qsort(`a::A ?, size_t, sizeof_t<`a>,
                    int (@)(const `a @, const `a @));
}
cycstub {
  namespace Cstdlib {
    extern "C" void qsort(`a::A @, size_t, size_t,
                          int (@)(const `a @, const `a @));
  }
  static xtunion exn.Failure __qsort_failure_1 =
    Failure("qsort called with NULL");
  static xtunion exn.Failure __qsort_failure_2 =
    Failure("qsort called with insufficient array size");
  void qsort(`a::A ? tab, size_t nmemb, sizeof_t<`a> szmemb, 
             int (@compar)(const `a @, const `a @)) {
    if (!tab) throw &__qsort_failure_1;
    if (tab.size < nmemb) throw &__qsort_failure_2;
    Cstdlib::qsort((_@)tab,nmemb,szmemb,compar);
  }
}
epilogue rand {
  extern "C" int rand(void);
}
epilogue rand_r {
  extern "C" int rand_r(unsigned @);
}
epilogue random {
  extern "C" long random(void);
}
epilogue seed48 {
  extern "C" unsigned short seed48(unsigned short @{3});
}
epilogue srand {
  extern "C" void srand(unsigned);
}
epilogue srand48 {
  extern "C" void srand48(long);
}
epilogue srandom {
  extern "C" void srandom(unsigned);
}
epilogue strtod {
  // FIX: should be const?
  extern "C" double strtod(char @`r, char @`r *);
}
epilogue strtol {
  // FIX: should be const?
  extern "C" long strtol(char @`r, char @`r *, int);
}
epilogue strtoul {
  // FIX: should be const?
  extern "C" unsigned long strtoul(char @`r, char @`r *, int);
}
epilogue system {
  extern "C" int system(const char @);
}
epilogue unlockpt {
  extern "C" int unlockpt(int);
}
;

// We do this all in Cyclone
// string.h:
// ;

// We do this all in Cyclone
// strings.h:
// ;

stropts.h:
epilogue {
  // FIX: stropts.h is not yet supported.
  // The problem is that the strbuf structure has a char * field. 
}
;

sys/dir.h:
epilogue {
  #include <cdirent.h>
}
;

sys/file.h:
include {
L_SET
L_CURR
L_INCR
L_XTND
F_OK
X_OK
W_OK
R_OK
}
prologue {
  #include <cfcntl.h>
}
;

sys/ioctl.h:
cpp {
/* Cygwin doesn't define the ioctl constants in ioctl.h */
#if defined(__CYGWIN32__) || defined(__CYGWIN__)
#include <sys/socket.h>
#endif
}
include {
FIONREAD
FIONBIO
}
epilogue ioctl {
  // ioctl normally takes a void * as its arg, but
  //   for the moment we forbid it to taking only ints.
  //   Ultimately should change to use tunions as
  //   socket commands do
  extern "C" int ioctl(int fd, int cmd, int @arg);
}
;

sys/ipc.h:
include {
ipc_perm
uid_t
gid_t
mode_t
key_t
IPC_CREAT  
IPC_EXCL   
IPC_NOWAIT 
IPC_PRIVATE
IPC_RMID   
IPC_SET    
IPC_STAT   
}
prologue {
  #include <core.h>
}
epilogue ftok {
  extern "C" key_t ftok(const char @, int);
}
;

sys/mman.h:
include {
size_t
off_t
MAP_FAILED
PROT_READ
MAP_SHARED
MAP_PRIVATE
}
prologue {
  #include <core.h>
}
epilogue {
  // We leave out many of the functions/flags, and just allow
  // mapping in read-only, shared files and unmapping them.

  // The traditional first arg to mmap should be 0 anyway, so don't
  // even bother to pass it to us.
  extern const char ?NOZEROTERM mmap(size_t length, int prot, int flags, 
		       int fd, off_t offset);

  extern int munmap(const char ?NOZEROTERM start, size_t length);
}
cycstub mmap {
  namespace Cmman {
    extern "C" char *NOZEROTERM
      mmap(char *NOZEROTERM start, size_t length, int prot,
           int flags, int fd, off_t offset);
    extern "C" int munmap(const char *NOZEROTERM start, size_t length);
  }
  static xtunion exn.Failure __mmap_failure =
    Failure("mmap called with illegal prot/flags");
  const char ?NOZEROTERM mmap(size_t length, int prot, 
		int flags, int fd, off_t offset) {
    if (prot == PROT_READ &&
        (flags == MAP_PRIVATE || flags == MAP_SHARED))
      return wrap_Cstring_as_string
        (Cmman::mmap(NULL, length, prot, flags, fd, offset),
         length);
    else
      throw &__mmap_failure;
  }
  // Is it unsafe to ask the user for the size?  I'd like to take it
  // from the char? type, but that could have been cast around...
  int munmap(const char ?NOZEROTERM start, size_t length) {
    // We definitely do NOT want to copy the "string"
    return Cmman::munmap((const char *NOZEROTERM)start, length);
  }
}
;

sys/msg.h:
epilogue {
  // We don't support this yet
}
;

sys/resource.h:
cpp {
  // This is needed on OS X to get struct timeval
  #include <sys/time.h>
}
include {
PRIO_PROCESS
PRIO_PGRP
PRIO_USER
rlim_t
RLIM_INFINITY
RLIM_SAVED_MAX
RLIM_SAVED_CUR
RUSAGE_SELF
RUSAGE_CHILDREN
rlimit
rusage
timeval
id_t
}
epilogue {
  // We'd like to
  // include {
  // RLIMIT_CORE
  // RLIMIT_CPU
  // RLIMIT_DATA
  // RLIMIT_FSIZE
  // RLIMIT_NOFILE
  // RLIMIT_STACK
  // RLIMIT_AS
  // }
  // but in Linux this brings in code similar to
  // enum { foo, bar = foo };
  // which Cyclone can't handle
}
epilogue getpriority {
  /* OS X doesn't define id_t */
  #ifndef _id_t_def_
  #define _id_t_def_
  typedef int id_t;
  #endif
  extern "C" int getpriority(int, id_t);
}
epilogue getrlimit {
  extern "C" int getrlimit(int, struct rlimit @);
}
epilogue getrusage {
  extern "C" int getrusage(int, struct rusage @);
}
epilogue setpriority {
  extern "C" int setpriority(int, id_t, int);
}
epilogue setrlimit {
  extern "C" int setrlimit(int, const struct rlimit @);
}
;

// Semaphores -- not supported yet
sys/sem.h:
;

sys/select.h:
include {
time_t
suseconds_t
timeval
sigset_t
timespec
fd_set
FD_SETSIZE
}
epilogue {
  /* FIX: Cygwin defines a struct _types_fd_set and then a typedef with the
     same name.  Our current scheme for omitting repeated declarations does
     not use separate namespaces for structs and typedefs, so the typedef
     is omitted by mistake.  This ugly hack fixes it in Cygwin for now. */
  #ifdef __types_fd_set_def_
  typedef struct _types_fd_set _types_fd_set;
  #endif
}
epilogue {
  /* FIX: OS X defines a struct fd_set and then a typedef with the
     same name.  Our current scheme for omitting repeated declarations does
     not use separate namespaces for structs and typedefs, so the typedef
     is omitted by mistake.  This ugly hack fixes it in OS X for now. */
  #ifdef __APPLE__
  typedef struct fd_set fd_set;
  #endif
}
epilogue pselect {
  /* FIX: check for possible fd_set overflow */
  extern "C" int pselect(int, fd_set *, fd_set *, fd_set *,
                       const struct timespec *, const sigset_t *);
}
epilogue select {
  /* FIX: check for possible fd_set overflow */
  extern "C" int select(int, fd_set *, fd_set *, fd_set *, struct timeval *);
}
epilogue {
  /* Posix says these can be macros or functions.  Typically they are
     macros but in Linux at least they use asm, which we don't support
     in Cyclone.  So, we make them functions. */
  extern void FD_CLR(int, fd_set @);
  extern int FD_ISSET(int, fd_set @);
  extern void FD_SET(int, fd_set @);
  extern void FD_ZERO(fd_set @);
}
cycstub {
  namespace Csysselect {
    extern "C" void __stub_FD_CLR(int, fd_set @);
    extern "C" int __stub_FD_ISSET(int, fd_set @);
    extern "C" void __stub_FD_SET(int, fd_set @);
    extern "C" void __stub_FD_ZERO(fd_set @);
  }
  /* FIX: check for possible fd_set overflow on these */
  void FD_CLR(int a, fd_set @b) {
    return Csysselect::__stub_FD_CLR(a,b);
  }
  int FD_ISSET(int a, fd_set @b) {
    return Csysselect::__stub_FD_ISSET(a,b);
  }
  void FD_SET(int a, fd_set @b) {
    return Csysselect::__stub_FD_SET(a,b);
  }
  void FD_ZERO(fd_set @a) {
    return Csysselect::__stub_FD_ZERO(a);
  }
}
cstub {
  #include <sys/select.h>
  void __stub_FD_CLR(int a, fd_set *b) {
    FD_CLR(a,b);
  }
  int __stub_FD_ISSET(int a, fd_set *b) {
    return FD_ISSET(a,b);
  }
  void __stub_FD_SET(int a, fd_set *b) {
    FD_SET(a,b);
  }
  void __stub_FD_ZERO(fd_set *a) {
    FD_ZERO(a);
  }
}
;

// Shared memory stuff
// Not supported yet
sys/shm.h:
;

sys/socket.h:
include {
socklen_t
sa_family_t
cmsghdr
SCM_RIGHTS
CMSG_DATA
linger
SOCK_DGRAM
SOCK_RAW
SOCK_SEQPACKET
SOCK_STREAM
SOL_SOCKET
SO_ACCEPTCONN
SO_BROADCAST
SO_DEBUG
SO_DONTROUTE
SO_ERROR
SO_KEEPALIVE
SO_LINGER
SO_OOBINLINE
SO_RCVBUF
SO_RCVLOWAT
SO_RCVTIMEO
SO_REUSEADDR
SO_SNDBUF
SO_SNDLOWAT
SO_SNDTIMEO
SO_TYPE
SOMAXCONN
MSG_CTRUNC
MSG_DONTROUTE
MSG_EOR
MSG_OOB
MSG_PEEK
MSG_TRUNC
MSG_WAITALL
AF_INET
AF_INET6
AF_UNIX
AF_UNSPEC
SHUT_RD
SHUT_RDWR
SHUT_WR
ssize_t
}
epilogue {
  /* We omit struct sockaddr because we don't use it in Cyclone */
  /* We omit struct sockaddr_storage because we don't use it in Cyclone */
  /* We omit struct msghdr because it contains a void * field */
  /* We omit CMSG_NXTHDR and CMSG_FIRSTHDR because they pull in msghdr */
  /* We omit struct iovec because it contains a void * field */

  /* We omit these because they rely on msghdr */
  /*
    extern ssize_t sendmsg(int fd, const struct msghdr *message, int flags);
    extern ssize_t recvmsg(int fd, struct msghdr *message, int flags);
  */
}
epilogue {
  /* Many architectures don't define this :-( */
  #ifndef _socklen_t_def_
  #define _socklen_t_def_
  #ifndef socklen_t
  /* Cygwin #defines socklen_t */
  typedef int socklen_t;
  #endif
  #endif
}
epilogue {
  extern tunion SockAddr<`r::R> {
    SA_sockaddr_in(struct sockaddr_in @`r);
    /* We will add other cases as necessary, e.g., SockAddr_In6 */

    /* The remaining cases are for the argument following the type-varying
       argument; they could be eliminated if we had per-arg injection. */
    /* NOTE: ORDER MATTERS! on these inject things */
    SA_socklenptr(socklen_t @`r); // accept, getpeername, getsockname, recvfrom
    SA_socklen(socklen_t); // bind, connect, sendto
  };
  typedef tunion `r SockAddr<`r> SA<`r>;
}
epilogue {
  extern tunion SockOpt<`r::R> {
    SO_int(int @`r);
    SO_timeval(struct timeval @`r);
    /* The remaining cases are for the argument following the type-varying
       argument; they could be eliminated if we had per-arg injection. */
    SO_socklenptr(socklen_t @`r); // getsockopt
    SO_socklen(socklen_t);        // setsockopt
  };
  typedef tunion `r SockOpt<`r> SO<`r>;
}
epilogue accept {
  extern int accept(int fd, ... inject SA);
}
cycstub {
  xtunion exn { SocketError };
}
cstub {
  #include <sys/socket.h>
  #include <netinet/in.h>
}
cstub {
  #ifdef __APPLE__
  typedef int socklen_t;
  #endif
}
cycstub accept {
  namespace Csocket {
    extern "C" int accept_in(int, const struct sockaddr_in @, socklen_t @);
  }
  int accept(int fd, ... inject SA ap) {
    if (ap.size != 2) throw SocketError;
    switch ($(ap[0],ap[1])) {
    case $(&SA_sockaddr_in(x),&SA_socklenptr(y)):
      return Csocket::accept_in(fd,x,y);
    default: throw SocketError;
    }
  }
}
cstub accept {
  int accept_in(int a, const struct sockaddr_in *b, socklen_t *c) {
    return accept(a,(struct sockaddr *)b,c);
  }
}
epilogue bind {
  extern int bind(int fd, ... inject SA);
}
cycstub bind {
  namespace Csocket {
    extern "C" int bind_in(int, const struct sockaddr_in @, socklen_t);
  }
  int bind(int fd, ... inject SA ap) {
    if (ap.size != 2) throw SocketError;
    switch ($(ap[0],ap[1])) {
    case $(&SA_sockaddr_in(x),&SA_socklen(y)):
      return Csocket::bind_in(fd,x,y);
    default: throw SocketError;
    }
  }
}
cstub bind {
  int bind_in(int a, const struct sockaddr_in *b, socklen_t c) {
    return bind(a,(struct sockaddr *)b,c);
  }
}
epilogue connect {
  extern int connect(int fd, ... inject SA);
}
cycstub connect {
  namespace Csocket {
    extern "C" int connect_in(int, const struct sockaddr_in @, socklen_t);
  }
  int connect(int fd, ... inject SA ap) {
    if (ap.size != 2) throw SocketError;
    switch ($(ap[0],ap[1])) {
    case $(&SA_sockaddr_in(x),&SA_socklen(y)):
      return Csocket::connect_in(fd,x,y);
    default: throw SocketError;
    }
  }
}
cstub connect {
  int connect_in(int a, const struct sockaddr_in *b, socklen_t c) {
    return connect(a,(struct sockaddr *)b,c);
  }
}
epilogue getpeername {
  extern int getpeername(int fd, ... inject SA);
}
cycstub getpeername {
  namespace Csocket {
    extern "C" int getpeername_in(int, const struct sockaddr_in @, socklen_t @);
  }
  int getpeername(int fd, ... inject SA ap) {
    if (ap.size != 2) throw SocketError;
    switch ($(ap[0],ap[1])) {
    case $(&SA_sockaddr_in(x),&SA_socklenptr(y)):
      return Csocket::getpeername_in(fd,x,y);
    default: throw SocketError;
    }
  }
}
cstub getpeername {
  int getpeername_in(int a, const struct sockaddr_in *b, socklen_t *c) {
    return getpeername(a,(struct sockaddr *)b,c);
  }
}
epilogue getsockname {
  extern int getsockname(int fd, ... inject SA);
}
cycstub getsockname {
  namespace Csocket {
    extern "C" int getsockname_in(int, const struct sockaddr_in @, socklen_t @);
  }
  int getsockname(int fd, ... inject SA ap) {
    if (ap.size != 2) throw SocketError;
    switch ($(ap[0],ap[1])) {
    case $(&SA_sockaddr_in(x),&SA_socklenptr(y)):
      return Csocket::getsockname_in(fd,x,y);
    default: throw SocketError;
    }
  }
}
cstub getsockname {
  int getsockname_in(int a, const struct sockaddr_in *b, socklen_t *c) {
    return getsockname(a,(struct sockaddr *)b,c);
  }
}
epilogue getsockopt {
  extern int getsockopt(int fd, int level, int optname, ... inject SO);
}
cycstub getsockopt {
  namespace Csocket {
    extern "C" int getsockopt_int(int, int, int, int @, socklen_t @);
    extern "C" int getsockopt_timeval(int, int, int, struct timeval @, socklen_t @);
  }
  int getsockopt(int fd, int level, int optname, ... inject SO ap) {
    if (ap.size != 2) throw SocketError;
    switch ($(ap[0],ap[1])) {
    case $(&SO_int(x),&SO_socklenptr(y)):
      return Csocket::getsockopt_int(fd,level,optname,x,y);
    case $(&SO_int(x),&SO_int(y)): // FIX: inject problem b/c socklen_t=int
      return Csocket::getsockopt_int(fd,level,optname,x,(socklen_t @)y);
    case $(&SO_timeval(x),&SO_socklenptr(y)):
      return Csocket::getsockopt_timeval(fd,level,optname,x,y);
    case $(&SO_timeval(x),&SO_int(y)): // FIX: inject problem b/c socklen_t=int
      return Csocket::getsockopt_timeval(fd,level,optname,x,(socklen_t @)y);
    default: throw SocketError;
    }
  }
}
cstub getsockopt {
  /* sys/time.h is needed on some systems (OS X) for struct timeval */
  #include <sys/time.h>
  int getsockopt_int(int a, int b, int c, int *d, socklen_t *e) {
    return getsockopt(a,b,c,d,e);
  }
  int getsockopt_timeval(int a, int b, int c, struct timeval *d, socklen_t *e) {
    return getsockopt(a,b,c,d,e);
  }
}
epilogue listen {
  extern "C" int listen(int fd, int n);
}
epilogue recv {
  extern ssize_t recv(int fd, char ?NOZEROTERM buf, size_t n, int flags);
}
cycstub recv {
  namespace Csocket {
    extern "C" ssize_t recv_wrapped(int, char ?NOZEROTERM, size_t, int);
  }
  // FIX: kill the extra level of indirection?  That is, rename the
  //   C function to be Cyc_Std__recv and call it directly ...
  ssize_t recv(int fd, char ?NOZEROTERM buf, size_t n, int flags) {
    return Csocket::recv_wrapped(fd,buf,n,flags);
  }
}
cstub recv {
  ssize_t recv_wrapped(int a, struct _tagged_arr b, size_t c, int d) {
    char *p = _check_unknown_subscript(b,1,0);
    unsigned n = _get_arr_size(b,1);  
    if (n<c) _throw_arraybounds();
    return recv(a,p,c,d);
  }
}
epilogue recvfrom {
  extern ssize_t recvfrom(int fd, char ?NOZEROTERM buf, size_t n, int flags,
                          ... inject SA);
}
cycstub recvfrom {
  namespace Csocket {
    extern "C" ssize_t recvfrom_in(int, char ?NOZEROTERM, size_t, int,
                                   const struct sockaddr_in @, socklen_t @);
  }
  ssize_t recvfrom(int fd, char ?NOZEROTERM buf, size_t n, int flags, 
		   ... inject SA ap) {
    if (ap.size != 2) throw SocketError;
    switch ($(ap[0],ap[1])) {
    case $(&SA_sockaddr_in(x),&SA_socklenptr(y)):
      return Csocket::recvfrom_in(fd,buf,n,flags,x,y);
    default: throw SocketError;
    }
  }
}
cstub recvfrom {
  ssize_t recvfrom_in(int a, struct _tagged_arr b, size_t c, int d,
                      const struct sockaddr_in *e, socklen_t *f) {
    char *p = _check_unknown_subscript(b,1,0);
    unsigned n = _get_arr_size(b,1);  
    if (n<c) _throw_arraybounds();
    return recvfrom(a,p,c,d,(struct sockaddr *)e,f);
  }
}
epilogue send {
  extern ssize_t send(int fd, const char ?NOZEROTERM buf, size_t n, int flags);
}
cycstub send {
  namespace Csocket {
    extern "C" ssize_t send_wrapped(int, const char ?NOZEROTERM, size_t, int);
  }
  ssize_t send(int fd, const char ?NOZEROTERM buf, size_t n, int flags) {
    return Csocket::send_wrapped(fd,buf,n,flags);
  }
}
cstub send {
  ssize_t send_wrapped(int a, struct _tagged_arr b, size_t c, int d) {
    char *p = _check_unknown_subscript(b,1,0);
    unsigned n = _get_arr_size(b,1);  
    if (n<c) _throw_arraybounds();
    return send(a,p,c,d);
  }
}
epilogue sendto {
  extern ssize_t sendto(int fd, const char ?NOZEROTERM buf, size_t n, int flags,
                        ... inject SA);
}
cycstub sendto {
  namespace Csocket {
    extern "C" ssize_t sendto_in(int, const char ?NOZEROTERM, size_t, int,
                                 const struct sockaddr_in @, socklen_t);
  }
  ssize_t sendto(int fd, const char ?NOZEROTERM buf, size_t n, int flags,
                 ... inject SA ap) {
    if (ap.size != 2) throw SocketError;
    switch ($(ap[0],ap[1])) {
    case $(&SA_sockaddr_in(x),&SA_socklen(y)):
      return Csocket::sendto_in(fd,buf,n,flags,x,y);
    default: throw SocketError;
    }
  }
}
cstub sendto {
  ssize_t sendto_in(int a, struct _tagged_arr b, size_t c, int d,
                    const struct sockaddr_in *e, socklen_t f) {
    char *p = _check_unknown_subscript(b,1,0);
    unsigned n = _get_arr_size(b,1);  
    if (n<c) _throw_arraybounds();
    return sendto(a,p,c,d,(struct sockaddr *)e,f);
  }
}
epilogue setsockopt {
  extern int setsockopt(int fd, int level, int optname, ... inject SO);
}
cycstub setsockopt {
  namespace Csocket {
    extern "C" int setsockopt_int(int, int, int, const int @, socklen_t);
    extern "C" int setsockopt_timeval(int, int, int, const struct timeval @, socklen_t);
  }
  int setsockopt(int fd, int level, int optname, ... inject SO ap) {
    if (ap.size != 2) throw SocketError;
    switch ($(ap[0],ap[1])) {
    case $(&SO_int(x),&SO_socklen(y)):
      return Csocket::setsockopt_int(fd,level,optname,x,y);
    case $(&SO_timeval(x),&SO_socklen(y)):
      return Csocket::setsockopt_timeval(fd,level,optname,x,y);
    default: throw SocketError;
    }
  }
}
cstub setsockopt {
  int setsockopt_int(int a, int b, int c, const int *d, socklen_t e) {
    return setsockopt(a,b,c,d,e);
  }
  int setsockopt_timeval(int a, int b, int c, const struct timeval *d, socklen_t e) {
    return setsockopt(a,b,c,d,e);
  }
}
epilogue shutdown {
  extern "C" int shutdown(int fd, int how);
}
epilogue sockatmark {
  extern "C" int sockatmark(int);
}
epilogue socket {
  extern "C" int socket(int domain, int type, int protocol);
}
epilogue socketpair {
  extern "C" int socketpair(int domain, int type, int protocol, int @{2} fds);
}
;

sys/stat.h:
omitvariables { stat }
include {
stat
blkcnt_t
blksize_t
dev_t
ino_t
mode_t
nlink_t
uid_t
gid_t
off_t
time_t
S_IFMT
S_IFBLK
S_IFCHR
S_IFIFO
S_IFREG
S_IFDIR
S_IFLNK
S_IFSOCK
S_IRWXU
S_IRUSR
S_IWUSR
S_IXUSR
S_IRWXG
S_IRGRP
S_IWGRP
S_IXGRP
S_IRWXO
S_IROTH
S_IWOTH
S_IXOTH
S_ISUID
S_ISGID
S_ISVTX
S_ISBLK
S_ISCHR
S_ISDIR
S_ISFIFO
S_ISREG
S_ISLNK
S_ISSOCK
S_TYPEISMQ
S_TYPEISSEM
S_TYPEISSHM
S_TYPEISTMO
}
prologue {
  #include <core.h>
}
epilogue {
  // EXTREMELY irritating: under Linux, mode_t, etc., are not defined
  // in sys/stat.h, CONTRARY to the posix spec.  Instead __mode_t, etc.,
  // are defined.  This makes mode_t, etc., defined under Linux.
  #if defined(___blkcnt_t_def_) && !defined(_blkcnt_t_def_)
  #define _blkcnt_t_def_
  typedef __blkcnt_t blkcnt_t;
  #endif
  #if defined(___blksize_t_def_) && !defined(_blksize_t_def_)
  #define _blksize_t_def_
  typedef __blksize_t blksize_t;
  #endif
  #if defined(___dev_t_def_) && !defined(_dev_t_def_)
  #define _dev_t_def_
  typedef __dev_t dev_t;
  #endif
  #if defined(___ino_t_def_) && !defined(_ino_t_def_)
  #define _ino_t_def_
  typedef __ino_t ino_t;
  #endif
  #if defined(___mode_t_def_) && !defined(_mode_t_def_)
  #define _mode_t_def_
  typedef __mode_t mode_t;
  #endif
  #if defined(___nlink_t_def_) && !defined(_nlink_t_def_)
  #define _nlink_t_def_
  typedef __nlink_t nlink_t;
  #endif
  #if defined(___uid_t_def_) && !defined(_uid_t_def_)
  #define _uid_t_def_
  typedef __uid_t uid_t;
  #endif
  #if defined(___gid_t_def_) && !defined(_gid_t_def_)
  #define _gid_t_def_
  typedef __gid_t gid_t;
  #endif
  #if defined(___off_t_def_) && !defined(_off_t_def_)
  #define _off_t_def_
  typedef __off_t off_t;
  #endif
  #if defined(___time_t_def_) && !defined(_time_t_def_)
  #define _time_t_def_
  typedef __time_t time_t;
  #endif
}
epilogue chmod {
  extern "C" int chmod(const char @, mode_t);
}
epilogue fchmod {
  extern "C" int fchmod(int, mode_t);
}
epilogue fstat {
  extern "C" int fstat(int fd, struct stat @buf);
}
epilogue lstat {
  extern "C" int lstat(const char @ filename, struct stat @buf);
}
epilogue mkdir {
  extern "C" int mkdir(const char @ pathname, mode_t mode);
}
epilogue mkfifo {
  extern "C" int mkfifo(const char @ pathname, mode_t mode);
}
epilogue mknod {
  extern "C" int mknod(const char @ pathname, mode_t mode, dev_t);
}
epilogue stat {
  extern "C" int stat(const char @, struct stat @);
}
epilogue umask {
  extern "C" mode_t umask(mode_t mask);
}
;

// Our parser gets a parse error on this file in Linux
sys/statvfs.h:
;

// This seems to work but produces plenty of warnings so I'm waiting
tgmath.h:
;

sys/time.h:
include {
timeval
itimerval
time_t
suseconds_t
ITIMER_REAL
ITIMER_VIRTUAL
ITIMER_PROF
timezone
fd_set
FD_SETSIZE
}
prologue {
  #include <core.h>
}
epilogue getitimer {
  extern "C" int getitimer(int, struct itimerval @);
}
epilogue gettimeofday {
  /* The second arg here looks like it is a legacy feature.  The POSIX
     docs say that if it is non-NULL, then the behavior is undefined.
     Therefore, we have a stub that forces the argument to be NULL. */
  extern int gettimeofday(struct timeval @, struct timezone *);
}
cycstub gettimeofday {
  namespace Csystime {
    extern "C" int gettimeofday(struct timeval @, struct timezone *);
  }
  int gettimeofday(struct timeval @a, struct timezone *b) {
    return Csystime::gettimeofday(a,NULL);
  }
}
epilogue select {
  /* FIX: check for possible fd_set overflow */
  extern "C" int select(int, fd_set *, fd_set *, fd_set *, struct timeval *);
  /* Stubs for these are defined by sys/select.h */
  extern void FD_CLR(int, fd_set @);
  extern int FD_ISSET(int, fd_set @);
  extern void FD_SET(int, fd_set @);
  extern void FD_ZERO(fd_set @);
}
epilogue setitimer {
  extern "C" int setitimer(int, const struct itimerval @, struct itimerval *);
}
epilogue utimes {
  extern "C" int utimes(const char @, const struct timeval *{2}); // LEGACY
}
;

sys/timeb.h:
include {
time_t
timeb
}
epilogue ftime {
  extern "C" int ftime(struct timeb @); // (LEGACY)
}
;

sys/times.h:
include {
clock_t
tms
}
epilogue times {
  extern "C" clock_t times(struct tms @);
}
;

sys/types.h:
include {
blkcnt_t
blksize_t
clock_t
clockid_t
dev_t
fsblkcnt_t
fsfilcnt_t
gid_t
id_t
ino_t
key_t
mode_t
nlink_t
off_t
pid_t
size_t
ssize_t
suseconds_t
time_t
timer_t
uid_t
useconds_t
}
epilogue {
/* The pthread types are omitted for now since we don't support
   threads */
/* The trace types are also omitted */
}
;

// Defines a struct containing a void *, not supported.
sys/uio.h:
;

sys/un.h:
include {
sockaddr_un
sa_family_t
}
;

sys/utsname.h:
include {
utsname
}
epilogue uname {
  extern "C" int uname(struct utsname @);
}
;

sys/wait.h:
include {
WNOHANG
WUNTRACED
WEXITSTATUS
WIFCONTINUED
WIFEXITED
WIFSIGNALED
WIFSTOPPED
WSTOPSIG
WTERMSIG
WEXITED
WSTOPPED
WCONTINUED
WNOHANG
WNOWAIT
idtype_t
id_t
__pid_t
pid_t
rusage
}
epilogue {
  /* siginfo_t is omitted because it contains a pointer */
  /* waitid is omitted because it needs siginfo_t */
  /*
    extern "C" int waitid(idtype_t, id_t, siginfo_t @, int);
  */
}
epilogue {
  // EXTREMELY irritating: under Linux, pid_t is not defined
  // in sys/wait.h, CONTRARY to the posix spec.  Instead __pid_t
  // is defined.  So we include __pid_t above and do the following:
  #if defined(___pid_t_def_) && !defined(_pid_t_def_)
  #define _pid_t_def_
  typedef __pid_t pid_t;
  #endif
}
epilogue wait {
  extern "C" pid_t wait(int *);
}
epilogue waitpid {
  extern "C" pid_t waitpid(pid_t, int *, int);
}
;

sys/syslog.h:
include {
LOG_EMERG
LOG_ALERT
LOG_CRIT
LOG_ERR
LOG_WARNING
LOG_NOTICE
LOG_INFO
LOG_DEBUG
LOG_PRIMASK
LOG_PRI
LOG_MAKEPRI
LOG_KERN
LOG_USER
LOG_MAIL
LOG_DAEMON
LOG_AUTH
LOG_SYSLOG
LOG_LPR
LOG_NEWS
LOG_UUCP
LOG_CRON
LOG_AUTHPRIV
LOG_FTP
LOG_LOCAL0
LOG_LOCAL1
LOG_LOCAL2
LOG_LOCAL3
LOG_LOCAL4
LOG_LOCAL5
LOG_LOCAL6
LOG_LOCAL7
LOG_NFACILITIES
LOG_FACMASK
LOG_FAC
LOG_MASK
LOG_UPTO
LOG_PID
LOG_CONS
LOG_ODELAY
LOG_NDELAY
LOG_NOWAIT
LOG_PERROR
}
epilogue {
extern "C" void closelog (void);
extern "C" int setlogmask (int);
  // This declares a not quite printf like function, we need to write
  // it in Cyclone.
  // void openlog (const char *, int, int);
  // void syslog (int, const char *, ...);
}
;

tar.h:
include {
TMAGIC     
TMAGLEN    
TVERSION   
TVERSLEN   
REGTYPE    
AREGTYPE   
LNKTYPE    
SYMTYPE    
CHRTYPE    
BLKTYPE    
DIRTYPE    
FIFOTYPE   
CONTTYPE   
TSUID      
TSGID
TSVTX
TUREAD
TUWRITE
TUEXEC     
TGREAD     
TGWRITE    
TGEXEC     
TOREAD     
TOWRITE    
TOEXEC     
}
;

// Terminal I/O interface
// Not supported yet
termios.h:
;

time.h:
include {
tm
CLOCKS_PER_SEC
CLOCK_PROCESS_CPUTIME_ID
CLOCK_THREAD_CPUTIME_ID
timespec
itimerspec
CLOCK_REALTIME
TIMER_ABSTIME
CLOCK_MONOTONIC
clock_t
size_t
time_t
clockid_t
timer_t
}
prologue {
  #include <core.h>
}
epilogue {
  /* Missing declarations for
     strptime
     tzname;
  */

  /* We'd like to
     include {tm}
     but in Linux tm is a struct containing a pointer
          no biggie---just treat it as if it only has one character;
	  don't always use it anyway.
  */

  // We'd like to
  // include { sigevent }
  // but in Linux this pulls in structures that contain void *'s.

}
// FIX: should these be null-terminated?
epilogue asctime {
  extern "C" char @{26} asctime(const struct tm @);
}
epilogue asctime_r {
  extern "C" char @{26}`r asctime_r(const struct tm @, char @{26}`r);
}
epilogue clock {
  extern "C" clock_t clock(void);
}
epilogue clock_getcpuclockid {
  extern "C" int clock_getcpuclockid(pid_t, clockid_t @);
}
epilogue clock_getres {
  // Note, posix says the second arg of clock_getres can be NULL
  extern "C" int clock_getres(pid_t, struct timespec *);
}
epilogue clock_gettime {
  extern "C" int clock_gettime(pid_t, struct timespec @);
}
epilogue clock_nanosleep {
  extern "C" int clock_nanosleep(clockid_t, itn, const struct timespec @,
                                 struct timespec @);
}
epilogue clock_settime {
  extern "C" int clock_settime(pid_t, const struct timespec @);
}
epilogue ctime {
  extern "C" char @{26} ctime(const time_t @);
}
epilogue ctime_r {
  extern "C" char @{26}`r ctime_r(const time_t @, char @{26}`r);
}
epilogue difftime {
  extern "C" double difftime(time_t,time_t);
}
epilogue getdate {
  extern struct tm *getdate(const char @);
}
epilogue getdate {
extern "C" int __CYCLONE_GETDATE_ERR();
#define getdate_err (__CYCLONE_GETDATE_ERR())
}
cstub getdate {
  // We do this because getdate_err is probably a C macro
  #include <time.h>
  int __CYCLONE_GETDATE_ERR() {
    return getdate_err;
  }
}
epilogue gmtime {
  extern "C" struct tm @gmtime(const time_t @);
}
epilogue gmtime_r {
  extern "C" struct tm @`r gmtime_r(const time_t @, struct tm @`r);
}
epilogue localtime {
  extern "C" struct tm @localtime(const time_t @);
}
epilogue localtime_r {
  extern "C" struct tm @`r localtime_r(const time_t @, struct tm @`r);
}
epilogue mktime {
  extern "C" time_t mktime(const struct tm @);
}
epilogue nanosleep {
  // Note, posix says the second arg of nanosleep may be NULL
  //  extern "C" int nanosleep(const struct timespec @, struct timespec *);
}
epilogue strftime {
  extern size_t strftime(char ?, size_t, const char ?, const struct tm @);
}
// FIX: see if these should be NULL-terminated
cycstub strftime {
  namespace Ctime {
    extern "C" size_t strftime(char *, size_t, const char *,
                               const struct tm @);
  }
  static xtunion exn.Failure __strftime_failure =
    Failure("fgets: buffer insufficient");
  size_t strftime(char ?s, size_t maxsize, const char ?fmt,
                  const struct tm @t) {
    if (maxsize > s.size) throw &__strftime_failure; 
    return Ctime::strftime(s,maxsize,fmt,t);
  }
}
epilogue strptime {
  // Not supported for now, needs a stub to be written
  //  extern char ?`r strptime(const char ?`r, const char ?, struct tm @);
}
epilogue time {
  extern "C" time_t time(time_t *);
}
epilogue timer_create {
  // Omitted because of the sigevent problem
  // Note, posix says the second arg of timer_create may be NULL
  //  extern "C" int timer_create(clockid_t, struct sigevent *, timer_t @);
}
epilogue timer_delete {
  extern "C" int timer_delete(timer_t);
}
epilogue timer_getoverrun {
  extern "C" int timer_getoverrun(timer_t);
}
epilogue timer_gettime {
  extern "C" int timer_gettime(timer_t, struct itimerspec @);
}
epilogue timer_settime {
  // Note, posix says the third arg of timer_settime may be NULL
  extern "C" int timer_settime(timer_t, int, const struct itimerspec @,
                               struct itimerspec *);
}
epilogue tzset {
  extern "C" void tzset(void);
}
epilogue timezone {
  extern "C" long timezone;
}
epilogue daylight {
  extern "C" int daylight;
}
;

// Tracing
// Not supported yet
trace.h:
;

// User context
// Defines a pointer-containing struct, not supported yet
ucontext.h:
;

// Defines a vararg function, needs a stub to be written
// Not supported yet
ulimit.h:
;

unistd.h:
include {
_POSIX_VERSION
_POSIX2_VERSION
_XOPEN_VERSION
_POSIX_ADVISORY_INFO
_POSIX_ASYNCHRONOUS_IO
_POSIX_BARRIERS
_POSIX_CHOWN_RESTRICTED
_POSIX_CLOCK_SELECTION
_POSIX_CPUTIME
_POSIX_FSYNC
_POSIX_JOB_CONTROL
_POSIX_MAPPED_FILES
_POSIX_MEMLOCK
_POSIX_MEMLOCK_RANGE
_POSIX_MEMORY_PROTECTION
_POSIX_MESSAGE_PASSING
_POSIX_MONOTONIC_CLOCK
_POSIX_NO_TRUNC
_POSIX_PRIORITIZED_IO
_POSIX_PRIORITY_SCHEDULING
_POSIX_RAW_SOCKETS
_POSIX_READER_WRITER_LOCKS
_POSIX_REALTIME_SIGNALS
_POSIX_REGEXP
_POSIX_SAVED_IDS
_POSIX_SEMAPHORES
_POSIX_SHARED_MEMORY_OBJECTS
_POSIX_SHELL
_POSIX_SPAWN
_POSIX_SPIN_LOCKS
_POSIX_SPORADIC_SERVER
_POSIX_SYNCHRONIZED_IO
_POSIX_THREAD_ATTR_STACKADDR
_POSIX_THREAD_ATTR_STACKSIZE
_POSIX_THREAD_CPUTIME
_POSIX_THREAD_PRIO_INHERIT
_POSIX_THREAD_PRIO_PROTECT
_POSIX_THREAD_PRIORITY_SCHEDULING
_POSIX_THREAD_PROCESS_SHARED
_POSIX_THREAD_SAFE_FUNCTIONS
_POSIX_THREAD_SPORADIC_SERVER
_POSIX_THREADS
_POSIX_TIMEOUTS
_POSIX_TIMERS
_POSIX_TRACE
_POSIX_TRACE_EVENT_FILTER
_POSIX_TRACE_INHERIT
_POSIX_TRACE_LOG
_POSIX_TYPED_MEMORY_OBJECTS
_POSIX_VDISABLE
_POSIX2_C_BIND
_POSIX2_C_DEV
_POSIX2_CHAR_TERM
_POSIX2_FORT_DEV
_POSIX2_FORT_RUN
_POSIX2_LOCALEDEF
_POSIX2_PBS
_POSIX2_PBS_ACCOUNTING
_POSIX2_PBS_CHECKPOINT
_POSIX2_PBS_LOCATE
_POSIX2_PBS_MESSAGE
_POSIX2_PBS_TRACK
_POSIX2_SW_DEV
_POSIX2_UPE
_V6_ILP32_OFF32
_V6_ILP32_OFFBIG
_V6_LP64_OFF64
_V6_LPBIG_OFFBIG
_XBS5_ILP32_OFF32
_XBS5_ILP32_OFFBIG
_XBS5_LP64_OFF64
_XBS5_LPBIG_OFFBIG
_XOPEN_CRYPT
_XOPEN_ENH_I18N
_XOPEN_LEGACY
_XOPEN_REALTIME
_XOPEN_REALTIME_THREADS
_XOPEN_SHM
_XOPEN_STREAMS
_XOPEN_UNIX
_POSIX_ASYNC_IO
_POSIX_PRIO_IO
_POSIX_SYNC_IO
F_OK
R_OK
W_OK
X_OK
_CS_PATH
_CS_POSIX_V6_ILP32_OFF32_CFLAGS
_CS_POSIX_V6_ILP32_OFF32_LDFLAGS
_CS_POSIX_V6_ILP32_OFF32_LIBS
_CS_POSIX_V6_ILP32_OFFBIG_CFLAGS
_CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS
_CS_POSIX_V6_ILP32_OFFBIG_LIBS
_CS_POSIX_V6_LP64_OFF64_CFLAGS
_CS_POSIX_V6_LP64_OFF64_LDFLAGS
_CS_POSIX_V6_LP64_OFF64_LIBS
_CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS
_CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS
_CS_POSIX_V6_LPBIG_OFFBIG_LIBS
_CS_POSIX_V6_WIDTH_RESTRICTED_ENVS
SEEK_CUR
SEEK_END
SEEK_SET
F_LOCK
F_TEST
F_TLOCK
F_ULOCK
_PC_ALLOC_SIZE_MIN
_PC_ASYNC_IO
_PC_CHOWN_RESTRICTED
_PC_FILESIZEBITS
_PC_LINK_MAX
_PC_MAX_CANON
_PC_MAX_INPUT
_PC_NAME_MAX
_PC_NO_TRUNC
_PC_PATH_MAX
_PC_PIPE_BUF
_PC_PRIO_IO
_PC_REC_INCR_XFER_SIZE
_PC_REC_MAX_XFER_SIZE
_PC_REC_MIN_XFER_SIZE
_PC_REC_XFER_ALIGN
_PC_SYNC_IO
_PC_VDISABLE
STDERR_FILENO
STDIN_FILENO
STDOUT_FILENO
size_t
ssize_t
uid_t
gid_t
off_t
pid_t
__useconds_t
useconds_t
}
prologue {
  #include <core.h>
}
epilogue {
  // EXTREMELY irritating: under Linux, useconds_t is not defined
  // in sys/wait.h, CONTRARY to the posix spec.  Instead __useconds_t
  // is defined.  So we include __useconds_t above and do the following:
  #if defined(___useconds_t_def_) && !defined(_useconds_t_def_)
  #define _useconds_t_def_
  typedef __useconds_t useconds_t;
  #endif
}
epilogue {
  /* Cygwin does not define this type so we take a guess :-( */
  /* FIX: make this specific to cygwin ?? */
  #ifndef _useconds_t_def_
  #define _useconds_t_def_
  typedef unsigned int useconds_t;
  #endif
}
epilogue {
  // We'd like to do
  // include {
  // _SC_2_C_BIND
  // _SC_2_C_DEV
  // _SC_2_C_VERSION
  // _SC_2_CHAR_TERM
  // _SC_2_FORT_DEV
  // _SC_2_FORT_RUN
  // _SC_2_LOCALEDEF
  // _SC_2_PBS
  // _SC_2_PBS_ACCOUNTING
  // _SC_2_PBS_CHECKPOINT
  // _SC_2_PBS_LOCATE
  // _SC_2_PBS_MESSAGE
  // _SC_2_PBS_TRACK
  // _SC_2_SW_DEV
  // _SC_2_UPE
  // _SC_2_VERSION
  // _SC_ADVISORY_INFO
  // _SC_ARG_MAX
  // _SC_AIO_LISTIO_MAX
  // _SC_AIO_MAX
  // _SC_AIO_PRIO_DELTA_MAX
  // _SC_ASYNCHRONOUS_IO
  // _SC_ATEXIT_MAX
  // _SC_BARRIERS
  // _SC_BC_BASE_MAX
  // _SC_BC_DIM_MAX
  // _SC_BC_SCALE_MAX
  // _SC_BC_STRING_MAX
  // _SC_CHILD_MAX
  // _SC_CLK_TCK
  // _SC_CLOCK_SELECTION
  // _SC_COLL_WEIGHTS_MAX
  // _SC_CPUTIME
  // _SC_DELAYTIMER_MAX
  // _SC_EXPR_NEST_MAX
  // _SC_FILE_LOCKING
  // _SC_FSYNC
  // _SC_GETGR_R_SIZE_MAX
  // _SC_GETPW_R_SIZE_MAX
  // _SC_HOST_NAME_MAX
  // _SC_IOV_MAX
  // _SC_JOB_CONTROL
  // _SC_LINE_MAX
  // _SC_LOGIN_NAME_MAX
  // _SC_MAPPED_FILES
  // _SC_MEMLOCK
  // _SC_MEMLOCK_RANGE
  // _SC_MEMORY_PROTECTION
  // _SC_MESSAGE_PASSING
  // _SC_MONOTONIC_CLOCK
  // _SC_MQ_OPEN_MAX
  // _SC_MQ_PRIO_MAX
  // _SC_NGROUPS_MAX
  // _SC_OPEN_MAX
  // _SC_PAGE_SIZE
  // _SC_PAGESIZE
  // _SC_PRIORITIZED_IO
  // _SC_PRIORITY_SCHEDULING
  // _SC_RE_DUP_MAX
  // _SC_READER_WRITER_LOCKS
  // _SC_REALTIME_SIGNALS
  // _SC_REGEXP
  // _SC_RTSIG_MAX
  // _SC_SAVED_IDS
  // _SC_SEMAPHORES
  // _SC_SEM_NSEMS_MAX
  // _SC_SEM_VALUE_MAX
  // _SC_SHARED_MEMORY_OBJECTS
  // _SC_SHELL
  // _SC_SIGQUEUE_MAX
  // _SC_SPAWN
  // _SC_SPIN_LOCKS
  // _SC_SPORADIC_SERVER
  // _SC_STREAM_MAX
  // _SC_SYNCHRONIZED_IO
  // _SC_THREAD_ATTR_STACKADDR
  // _SC_THREAD_ATTR_STACKSIZE
  // _SC_THREAD_CPUTIME
  // _SC_THREAD_DESTRUCTOR_ITERATIONS
  // _SC_THREAD_KEYS_MAX
  // _SC_THREAD_PRIO_INHERIT
  // _SC_THREAD_PRIO_PROTECT
  // _SC_THREAD_PRIORITY_SCHEDULING
  // _SC_THREAD_PROCESS_SHARED
  // _SC_THREAD_SAFE_FUNCTIONS
  // _SC_THREAD_SPORADIC_SERVER
  // _SC_THREAD_STACK_MIN
  // _SC_THREAD_THREADS_MAX
  // _SC_TIMEOUTS
  // _SC_THREADS
  // _SC_TIMER_MAX
  // _SC_TIMERS
  // _SC_TRACE
  // _SC_TRACE_EVENT_FILTER
  // _SC_TRACE_INHERIT
  // _SC_TRACE_LOG
  // _SC_TTY_NAME_MAX
  // _SC_TYPED_MEMORY_OBJECTS
  // _SC_TZNAME_MAX
  // _SC_V6_ILP32_OFF32
  // _SC_V6_ILP32_OFFBIG
  // _SC_V6_LP64_OFF64
  // _SC_V6_LPBIG_OFFBIG
  // _SC_VERSION
  // _SC_XBS5_ILP32_OFF32
  // _SC_XBS5_ILP32_OFFBIG
  // _SC_XBS5_LP64_OFF64
  // _SC_XBS5_LPBIG_OFFBIG
  // _SC_XOPEN_CRYPT
  // _SC_XOPEN_ENH_I18N
  // _SC_XOPEN_LEGACY
  // _SC_XOPEN_REALTIME
  // _SC_XOPEN_REALTIME_THREADS
  // _SC_XOPEN_SHM
  // _SC_XOPEN_STREAMS
  // _SC_XOPEN_UNIX
  // _SC_XOPEN_VERSION
  // _SC_XOPEN_XCU_VERSION
  // }
  // but we can't because under linux this pulls in some code like
  //   enum { foo, bar = foo };
  // and cyclone complains that the expression (foo) of field bar is not
  // a constant.
}
epilogue access {
  extern "C" int access(const char @,int);
}
epilogue alarm {
  extern "C" unsigned alarm(unsigned);
}
epilogue chdir {
  extern "C" int chdir(const char @);
}
epilogue chown {
  extern "C" int chown(const char @,uid_t,gid_t);
}
epilogue chroot {
  extern "C" int chroot(const char @);
}
epilogue close {
  extern "C" int close(int);
}
epilogue confstr {
  // Not supported yet
  // extern size_t confstr(int, char *, size_t);
}
epilogue crypt {
  extern "C" char @ crypt(const char @ key, const char @ salt);
}
epilogue ctermid {
  // Not supported yet
  // extern char *ctermid(char *);
}
epilogue dup {
  extern "C" int dup(int);
}
epilogue dup2 {
  extern "C" int dup2(int, int);
}
epilogue encrypt {
  // FIX: should this be null-terminated or not?
  extern "C" void encrypt(char @{64}, int);
}
epilogue execl {
  //  extern int execl(const char ?, const char ?, ... const char ?);
}
cycstub execl {
  // This is untested; I'd be surprised if it actually works
  //  int execl(const char ? path, const char ? arg0, ... const char ? argv) {
  //    if (argv[argv.size - 1] != NULL)
  //      throw new Failure("execl: arg list must be NULL-terminated");
  //
  //    // We allocate 1+argv.size because we need to prepend arg0
  //    char * ?newargs = new {for i < 1 + argv.size : NULL};
  //    newargs[0] = string_to_char *(arg0);
  //    for (int i = 0; i < argv.size; i++)
  //      newargs[i+1] = string_to_char *(argv[i]);
  //    return Cunistd::execv(string_to_char *(path), (char **) newargs);
  //  }
}
epilogue execle {
  // Not supported yet
  // extern int execle(const char *, const char *, ...);
}
epilogue execlp {
  extern int execlp(const char @, const char @`r, ... const char *`r);
}
cycstub execvp {
  namespace Cunistd {
    // needed by execlp, so out of order
    extern "C" int execvp(const char @ file, const char **argv);
  }
}
cycstub execlp {
  static xtunion exn.Failure __execlp_failure =
    Failure("execlp arg list not NULL-terminated");
  int execlp(const char @ path, const char @`r arg0, ... const char *`r argv) {
    if (argv[argv.size - 1] != NULL) throw &__execlp_failure;
    // We allocate 1+argv.size because we need to prepend arg0
    // FIX: can region-allocate ...
    const char *`r ?newargs = new {for i < argv.size : (const char *`r)NULL};
    newargs[0] = arg0;
    for (int i = 0; i < argv.size; i++)
      newargs[i+1] = argv[i];
    return Cunistd::execvp(path, (const char **) newargs);
  }
}
epilogue execv {
  // Not supported yet
  // extern int execv(const char *, char *const []);
}
cycstub execv {
  //  namespace Cunistd {
  //    extern "C" int execv(char * path, char * *argv);
  //  }
}
epilogue execve {
  // FIX: what did I lose by removing the const from this spec?
  //  extern int execve(const char ?, const char ? const ?, const char ? const ?);
    extern "C" int execve(char @ path, char @ *argv, char @ *envp);
//    extern int execve(const char ?, char ? const ?, char ? const ?);
}
cycstub execve {
//    namespace Cunistd {
//      extern "C" int execve(char * path, char @ *argv, char @ *envp);
//    }
//    static xtunion exn.Failure __execve_failure =
//      Failure("execve: arg list must be NULL-terminated");
//    int execve(const char ? filename, char ? const ?argv, char ? const ?envp) {
//      if (argv[argv.size - 1] != NULL)
//        throw &__execve_failure;

//      char * ?newargs = new {for i < argv.size : NULL};
//      for (int i = 0; i < argv.size; i++)
//        newargs[i] = string_to_char *(argv[i]);

//      char * ?newenvp = new {for i < envp.size : NULL};
//      for (int i = 0; i < envp.size; i++)
//        newenvp[i] = string_to_char *(envp[i]);

//      return Cunistd::execve(string_to_char *(filename),
//                             (char **) newargs, (char **) newenvp);
//    }
}
epilogue execvp {
  // Not supported yet
  // extern int execvp(const char *, char *const []);
}
epilogue _exit {
  extern "C" void _exit(int);
}
epilogue fchown {
  extern "C" int fchown(int, uid_t, gid_t);
}
epilogue fchdir {
  extern "C" int fchdir(int);
}
epilogue fdatasync {
  extern "C" int fdatasync(int);
}
epilogue fork {
  extern "C" pid_t fork(void);
}
epilogue fpathconf {
  extern "C" long fpathconf(int, int);
}
epilogue fsync {
  extern "C" int fsync(int);
}
epilogue ftruncate {
  extern "C" int ftruncate(int, off_t);
}
epilogue getcwd {
  extern char ?`r getcwd(char ?`r buf, size_t size);
}
cycstub getcwd {
  // FIX: this should really use a buffer, rather than a string, but
  //   I can't get it to work otherwise
  namespace Cunistd {
    extern "C" char *`r getcwd(char *`r buf, size_t size);
  }
  static xtunion exn.Failure __getcwd_failure =
    Failure("getcwd: invalid buf argument");
  char ?`r getcwd(char ?`r buf, size_t size) {
    if (buf.size < size) throw &__getcwd_failure;
    let response = Cunistd::getcwd((char *)buf, size);
    return response ? buf : NULL;
  }
}
epilogue getegid {
  extern "C" gid_t getegid(void);
}
epilogue geteuid {
  extern "C" uid_t geteuid(void);
}
epilogue getgid {
  extern "C" gid_t getgid(void);
}
epilogue getgroups {
  // Not supported yet
  // extern int getgroups(int, gid_t []);
}
epilogue gethostid {
  extern "C" long gethostid(void);
}
epilogue gethostname {
  // FIX: add stuff for initialization
  extern int gethostname(char ?NOZEROTERM, size_t);
}
cycstub gethostname {
  namespace Cunistd {
    extern "C" int gethostname(char @NOZEROTERM,size_t);
  }
  static xtunion exn.Failure __gethostname_failure_1 =
    Failure("gethostname: called with NULL buf");
  static xtunion exn.Failure __gethostname_failure_2 =
    Failure("gethostname: called with count > buf.size");
  int gethostname(char ?NOZEROTERM buf, size_t count) {
    if (!buf) throw &__gethostname_failure_1;
    else {
      if (count > buf.size) throw &__gethostname_failure_2;
      return Cunistd::gethostname((char @NOZEROTERM)buf, count);
    }
  }
}
epilogue getlogin {
  // Not supported yet
  // extern char *getlogin(void);
}
epilogue getlogin_r {
  // Not supported yet
  // extern int getlogin_r(char *, size_t);
}
epilogue getopt {
  // Not supported yet
  // extern int getopt(int, char * const [], const char *);
}
epilogue getpass {
  /* Note, getpass is not required by POSIX */
  extern "C" char * getpass(const char @);
}
epilogue getpgid {
  extern "C" pid_t getpgid(pid_t);
}
epilogue getpgrp {
  extern "C" pid_t getpgrp(void);
}
epilogue getpid {
  extern "C" pid_t getpid(void);
}
epilogue getppid {
  extern "C" pid_t getppid(void);
}
epilogue getsid {
  extern "C" pid_t getsid(pid_t);
}
epilogue getuid {
  extern "C" uid_t getuid(void);
}
epilogue getwd {
  // Not supported yet
  // extern char *getwd(char *); (LEGACY)
}
epilogue isatty {
  extern "C" int isatty(int);
}
epilogue lchown {
  // Not supported yet
  // extern int lchown(const char *, uid_t, gid_t);
}
epilogue link {
  extern "C" int link(const char @,const char @);
}
epilogue lockf {
  extern "C" int lockf(int, int, off_t);
}
epilogue lseek {
  extern "C" off_t lseek(int, off_t, int);
}
epilogue nice {
  extern "C" int nice(int);
}
epilogue pathconf {
  // Not supported yet
  // extern long pathconf(const char *, int);
}
epilogue pause {
  extern "C" int pause(void);
}
epilogue pipe {
  extern "C" int pipe(int @{2});
}
epilogue pread {
  // Not supported yet
  // extern ssize_t pread(int, void *, size_t, off_t);
}
epilogue pwrite {
  // Not supported yet
  // extern ssize_t pwrite(int, const void *, size_t, off_t);
}
epilogue read {
  extern ssize_t read(int, char ?NOZEROTERM, size_t);
}
cycstub read {
  namespace Cunistd {
    extern "C" ssize_t read(int fd, char *NOZEROTERM buf, size_t count);
  }
  static xtunion exn.Failure __read_failure =
    Failure("read: called with count > buf.size");
  ssize_t read(int fd, char ?NOZEROTERM buf, size_t count) {
    if (count > buf.size) throw &__read_failure;
    return Cunistd::read(fd, (char *NOZEROTERM)buf, count);
  }
}
epilogue readlink {
  // Not supported yet
  // extern ssize_t readlink(const char *restrict, char *restrict, size_t);
}
epilogue rmdir {
  extern "C" int rmdir(const char @);
}
epilogue setegid {
  extern "C" int setegid(gid_t);
}
epilogue seteuid {
  extern "C" int seteuid(uid_t);
}
epilogue setgid {
  extern "C" int setgid(gid_t);
}
epilogue setpgid {
  extern "C" int setpgid(pid_t, pid_t);
}
epilogue setpgrp {
  extern "C" pid_t setpgrp(void);
}
epilogue setregid {
  extern "C" int setregid(gid_t, gid_t);
}
epilogue setreuid {
  extern "C" int setreuid(uid_t, uid_t);
}
epilogue setsid {
  extern "C" pid_t setsid(void);
}
epilogue setuid {
  extern "C" int setuid(uid_t);
}
epilogue sleep {
  extern "C" unsigned sleep(unsigned);
}
epilogue swab {
  // Not supported yet
  // extern void swab(const void *restrict, void *restrict, ssize_t);
}
epilogue symlink {
  extern "C" int symlink(const char @ path1, const char @ path2);
}
epilogue sync {
  extern "C" void sync(void);
}
epilogue sysconf {
  extern "C" long sysconf(int);
}
epilogue tcgetpgrp {
  extern "C" pid_t tcgetpgrp(int);
}
epilogue tcsetpgrp {
  extern "C" int tcsetpgrp(int, pid_t);
}
epilogue truncate {
  extern int truncate(const char @, off_t);
}
epilogue ttyname {
  // Not supported yet
  // extern char *ttyname(int);
}
epilogue ttyname_r {
  // Not supported yet
  // extern int ttyname_r(int, char *, size_t);
}
epilogue ualarm {
  extern "C" useconds_t ualarm(useconds_t, useconds_t);
}
epilogue unlink {
  extern "C" int unlink(const char @ pathname);
}
epilogue usleep {
  extern "C" int usleep(useconds_t);
}
epilogue vfork {
  extern "C" pid_t vfork(void);
}
epilogue write {
  extern ssize_t write(int, const char ?NOZEROTERM, size_t);
}
cycstub write {
  namespace Cunistd {
    extern "C" ssize_t write(int fd, const char @NOZEROTERM buf, size_t count);
  }
  static xtunion exn.Failure __write_failure =
    Failure("write: called with count > buf.size");
  ssize_t write(int fd, const char ?NOZEROTERM buf, size_t count) {
    if (count > buf.size) throw &__write_failure;
    return Cunistd::write(fd, (const char @NOZEROTERM)buf, count);
  }
}
epilogue {
  /* intptr_t is omitted */
  /* optarg is omitted */
}
epilogue optind {
// Conflict with hand-coded getopt.h so not supported yet
//  extern "C" int optind;
}
epilogue opterr {
// Conflict with hand-coded getopt.h so not supported yet
//  extern "C" int opterr;
}
epilogue optopt {
// Conflict with hand-coded getopt.h so not supported yet
//  extern "C" int optopt;
}
;

utime.h:
include {
utimbuf
time_t
}
prologue {
  #include <core.h>
}
epilogue {
  // Note, posix says the second arg of utime may be NULL
  extern "C" int utime(const char @, const struct utimbuf *);
}
;

// User accounting database definitions
// Not supported yet
utmpx.h:
;

// This gives a parse error in Cygwin because their wchar.h
// contains an actual parse error: they don't define size_t
wchar.h:
;

// Wide characters are not supported yet in Cyclone
wctype.h:
;

// Word expansions
// Not supported yet
wordexp.h:
;
