/* Parsing and checking format strings.
   Copyright (C) 2001 AT&T
   This file is part of the Cyclone compiler.

   The Cyclone compiler is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   The Cyclone compiler is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with the Cyclone compiler; see the file COPYING. If not,
   write to the Free Software Foundation, Inc., 59 Temple Place -
   Suite 330, Boston, MA 02111-1307, USA. */

#include <core.h>
#include <list.h>
#include <ctype.h>
#include <string.h>
#include <position.h>
#include <stdio.h>
#include "absyn.h"
#include "tcutil.h"
#include "tcenv.h"
#include "formatstr.h"
using Core;
using List;
using Position;
using Absyn;
using Tcutil;
using Tcenv;

namespace Formatstr;

static struct Opt<kind_t> rk = {RgnKind};

// Parse a conversion specification starting at index i in string s.
// s[i] should be the first character after the leading '%'.
// If there is an error, return NULL.
// Otherwise, return the flags, width, precision, and length modifier from s,
// as lists of ints (boxed chars).  Also return the conversion specifier as a 
// char, and the index of the character following the conversion specifier.
opt_t<$(list_t<int>, list_t<int>, list_t<int>, list_t<int>, char, int)@>
parse_conversionspecification(string_t s, int i) {
  //  fprintf(cyc_stderr, "String: %s\n" "Position: %d\n",s,i);
  let len = strlen(s);
  if (i<0 || i>=len) return NULL;

  // Parse flags: ['+' '-' ' ' '#' '0']*
  let flags = NULL;
  char c = ' ';
  for (; i<len; i++) {
    c = s[i];
    switch (c) {
    case '+': 
    case '-': 
    case ' ': 
    case '#': 
    case '0': flags = new List((int)c,flags); continue;
    default: break;
    }
    break;
  }
  if (i>=len) return NULL;
  flags = imp_rev(flags);

  // Parse width: ('*' | ['0'-'9']+)?
  let width = NULL;
  c = s[i]; // redundant
  if (c=='*') {
    width = new List((int)c,width);
    i++;
  } else {
    for (; i<len; i++) {
      c = s[i];
      if (isdigit(c)) width = new List((int)c,width);
      else break;
    }
  }
  if (i>=len) return NULL;
  width = imp_rev(width);

  // Parse precision: ('.' ('*' | ['0'-'9']+)? )?
  let precision = NULL;
  c = s[i]; // not redundant
  if (c == '.') {
    precision = new List((int)c,precision);
    i++;
    if (i>=len) return NULL;
    c = s[i];    
    if (c == '*') {
      precision = new List((int)c,precision);
      i++;
    } else
      for (; i<len; i++) {
        c = s[i];
        if (isdigit(c)) precision = new List((int)c,precision);
        else break;
      }
  }
  if (i>=len) return NULL;
  precision = imp_rev(precision);

  // Parse length modifier:
  //  (['h' 'l' 'j' 'z' 't' 'L'] | 'h' 'h' | 'l' 'l')
  let lenmod = NULL;
  c = s[i]; // not redundant
  switch (c) {
  case 'h':
    lenmod = new List((int)c,lenmod);
    i++;
    if (i>=len) return NULL;
    c = s[i];
    if (c == 'h') { lenmod = new List((int)c,lenmod); i++; }
    break;
  case 'l':
    lenmod = new List((int)c,lenmod);
    i++;
    if (i>=len) return NULL;
    c = s[i];
    if (c == 'l') { lenmod = new List((int)c,lenmod); i++; }
    break;
  case 'j': 
  case 'z': 
  case 't': 
  case 'L':
    lenmod = new List((int)c,lenmod);
    i++;
    break;
  default: break;
  }
  if (i>=len) return NULL;
  lenmod = imp_rev(lenmod); // unnecessary

  // Parse conversion specifier
  c = s[i]; // not redundant
  switch (c) {
  case 'd': 
  case 'i': 
  case 'o': 
  case 'u': 
  case 'x': 
  case 'X': 
  case 'f': 
  case 'F': 
  case 'e': 
  case 'E': 
  case 'g': 
  case 'G': 
  case 'a': 
  case 'A': 
  case 'c': 
  case 's': 
  case 'p': 
  case 'n': 
  case '%': break;
  default: return NULL;
  }
  //  fprintf(cyc_stderr,
  //          "Flags: %s\n"
  //          "Width: %s\n"
  //          "Precision: %s\n"
  //          "Lenmod: %s\n",
  //          implode(flags),
  //          implode(width),
  //          implode(precision),
  //          implode(lenmod));
  return new Opt(new $(flags,width,precision,lenmod,c,i+1));
}

list_t<type_t> get_format_typs(tenv_t te,string_t s,seg_t loc) {
  // FIX: on error we return NULL.  This will probably lead to
  // cascading errors (e.g., too many arguments to printf).
  let len = strlen(s);
  let typs = NULL;
  int i;
  for (i=0; i<len; i++) {
    if (s[i] != '%') continue;
    let cs = parse_conversionspecification(s,i+1);
    if (cs == NULL) {
      terr(loc,"bad format string");
      return NULL; // bad conversion specification
    }
    let &$(flags,width,precision,lenmod,c,j) = cs->v;
    i = j-1; // Subtract 1 because for-loop ends with i++
    switch (lenmod) {
    case &List(x,NULL) && (x == 'j' || x == 'z' || x == 't'):
      // These length modifiers are OK in C99 but we don't support them yet
      // FIX: is this true now?
      terr(loc,"length modifier '%c' is not supported",x);
      return NULL;
    default: break;
    }
    switch (width) {
    case &List(x,NULL) && x=='*': typs = new List(sint_typ,typs); break;
    default: break;
    }
    switch (precision) {
    case &List(x,&List(y,NULL)) && x=='.' && y=='*':
      typs = new List(sint_typ,typs); break;
    default: break;
    }
    type_t t;
    switch (c) {
    case 'd':
    case 'i':
      for (_ f = flags; f != NULL; f = f->tl)
        if (f->hd == '#') {
          terr(loc,"flag '#' is not valid with %%%c",c);
          return NULL;
        }
      switch (lenmod) {
      case NULL:                    t = sint_typ;   break;
      case &List(x,NULL) && x=='l': t = slong_typ;  break;
      case &List(x,NULL) && x=='h': t = sshort_typ; break;
      case &List(x,&List(y,NULL)) && (x=='h' && y=='h'): t = schar_typ; break;
      default: // We don't support ll
        terr(loc,"length modifier '%s' is not allowed with %%%c",
	     implode(lenmod), c);
        return NULL;
      }
      typs = new List(t,typs);
      break;
    case 'u':
      for (_ f = flags; f != NULL; f = f->tl)
        if (f->hd == '#') {
          terr(loc,"Flag '#' not valid with %%u");
          return NULL;
        }
      fallthru;
    case 'o': 
    case 'x': 
    case 'X':
      switch (lenmod) {
      case NULL:                    t = uint_typ; break;
      case &List(x,NULL) && x=='l': t = ulong_typ; break;
      case &List(x,NULL) && x=='h': t = ushort_typ; break;
      case &List(x,&List(y,NULL)) && (x=='h' && y=='h'): t = uchar_typ; break;
      // We don't support ll
      default:
        terr(loc,"length modifier '%s' is not allowed with %%%c",
             implode(lenmod), c);
        return NULL;
      }
      typs = new List(t,typs);
      break;
    case 'f': 
    case 'F': 
    case 'e': 
    case 'E': 
    case 'g': 
    case 'G': 
    case 'a': 
    case 'A':
      // We don't allow any length modifiers for floating point numbers;
      // in particular, we don't allow L (long double)
      if (lenmod != NULL) {
        terr(loc,"length modifiers are not allowed with %%%c",c);
        return NULL;
      }
      typs = new List(double_typ(false),typs);
      break;
    case 'c':
      for (_ f = flags; f != NULL; f = f->tl)
        if (f->hd == '#' || f->hd == '0') {
          terr(loc,"flag '%c' not allowed with %%c",f->hd);
          return NULL;
        }
      // We don't allow any length modifiers for characters;
      // in particular, we don't allow l (wint_t)
      if (lenmod != NULL) {
        terr(loc,"length modifier '%s' not allowed with %%c", implode(lenmod));
        return NULL;
      }
      if (precision != NULL) {
        terr(loc,"precision '%s' not allowed with %%c",
             implode(precision));
        return NULL;
      }
      typs = new List(sint_typ,typs);
      break;
    case 's':
       // Only flag '-' is allowed for %s
       for (_ f = flags; f != NULL; f = f->tl)
         if (f->hd != '-') {
           terr(loc,"a flag not allowed with %%s");
           return NULL;
         }
       // We don't allow any length modifiers for %s;
       // in particular, we don't allow l (wchar_t[?])
       if (lenmod != NULL) {
         terr(loc,"length modifiers not allowed with %%s");
         return NULL;
       }
      typs = new List(const_string_typ(new_evar(&rk,new Opt(lookup_type_vars(te)))),typs);
      break;
    case 'p':
      // Note:  we require pointers to be cast to integers
      typs = new List(uint_typ,typs);
      break;
    case 'n':
      for (_ f = flags; f != NULL; f = f->tl)
        if (f->hd == '#' || f->hd == '0') {
          terr(loc,"flag '%c' not allowed with %%n",f->hd);
          return NULL;
        }
      if (precision != NULL) {
        terr(loc,"precision '%s' not allowed with %%n",
             implode(precision));
        return NULL;
      }
      let tvs = new Opt(lookup_type_vars(te));
      switch (lenmod) {
      case NULL: t = sint_typ; break;
      case &List(x,NULL) && x=='l': t = ulong_typ; break; // DAN: slong_typ???
      case &List(x,NULL) && x=='h': t = sshort_typ; break;
      case &List(x,&List(y,NULL)) && (x=='h' && y=='h'): t = schar_typ; break;
      default: // We don't support ll
        terr(loc,"length modifier '%s' is not allowed with %%%c",
	     implode(lenmod), c);
        return NULL;
      }
      t = at_typ(t,new_evar(&rk,tvs),empty_tqual());
      typs = new List(t,typs);
      break;
    case '%':
      if (flags != NULL) {
        terr(loc,"flags '%s' not allowed with %%%%", implode(flags));
        return NULL;
      }
      if (width != NULL) {
        terr(loc,"width '%s' not allowed with %%%%", implode(width));
        return NULL;
      }
      if (precision != NULL) {
        terr(loc,"precision '%s' not allowed with %%%%", implode(precision));
        return NULL;
      }
      if (lenmod != NULL) {
        terr(loc,"length modifier '%s' not allowed with %%%%", implode(lenmod));
        return NULL;
      }
      break;
    default:
      return NULL; // impossible
    }
  }
  return imp_rev(typs);
}

// Parse a scanf conversion specification starting at index i in string s.
// s[i] should be the first character after the leading '%'.
// If there is an error, return NULL.
// Otherwise, return whether assignment should be suppressed (a bool),
// the width and length modifier (lists of ints [boxed chars]),
// the conversion specifier (a char),
// and the index of the character following the conversion specifier.
opt_t<$(bool, list_t<int>, list_t<int>, char, int)@>
parse_inputformat(string_t s, int i) {
  let len = strlen(s);
  if (i<0 || i>=len) return NULL;

  let suppress = false;
  let c = s[i];
  if (c == '*') {
    suppress = true;
    i++;
    if (i>=len) return NULL;
  }

  let width = NULL;
  for (; i<len; i++) {
    c = s[i];
    if (isdigit(c)) width = new List((int)c,width);
    else break;
  }
  if (i>=len) return NULL;
  width = imp_rev(width);

  // Parse length modifier:
  //  ('h' | 'l' | 'j' | 'z' | 't' | 'L' | 'h' 'h' | 'l' 'l')
  let lenmod = NULL;
  c = s[i]; // not redundant
  switch (c) {
  case 'h':
    lenmod = new List((int)c,lenmod);
    i++;
    if (i>=len) return NULL;
    c = s[i];
    if (c == 'h') { lenmod = new List((int)c,lenmod); i++; }
    break;
  case 'l':
    lenmod = new List((int)c,lenmod);
    i++;
    if (i>=len) return NULL;
    c = s[i];
    if (c == 'l') { lenmod = new List((int)c,lenmod); i++; }
    break;
  case 'j': 
  case 'z': 
  case 't': 
  case 'L':
    lenmod = new List((int)c,lenmod);
    i++;
    break;
  default: break;
  }
  if (i>=len) return NULL;
  lenmod = imp_rev(lenmod); // unnecessary

  // Parse conversion specifier
  c = s[i]; // not redundant
  switch (c) {
  case 'd': 
  case 'i': 
  case 'o': 
  case 'u': 
  case 'x': 
  case 'X': 
  case 'f': 
  case 'F': 
  case 'e': 
  case 'E': 
  case 'g': 
  case 'G': 
  case 'a': 
  case 'A': 
  case 'c': 
  case 's': 
  case 'p': 
  case 'n': 
  case '%': break;
  default: return NULL;
  }
  return new Opt(new $(suppress,width,lenmod,c,i+1));
}
list_t<type_t> get_scanf_typs(tenv_t te,string_t s,seg_t loc) {
  // FIX: on error we return NULL.  This will probably lead to
  // cascading errors (e.g., too many arguments to scanf).
  let len = strlen(s);
  let typs = NULL;
  int i;
  for (i=0; i<len; i++) {
    if (s[i] != '%') continue;
    let x = parse_inputformat(s,i+1);
    if (x == NULL) {
      terr(loc,"bad format string");
      return NULL; // bad conversion specification
    }
    let &$(suppress,width,lenmod,c,j) = x->v;
    i = j-1; // Subtract 1 because for-loop ends with i++
    switch (lenmod) {
    case &List(x,NULL) && (x == 'j' || x == 'z' || x == 't'):
      // These length modifiers are OK in C99 but we don't support them yet
      terr(loc,"length modifier '%c' is not supported",x);
      return NULL;
    default: break;
    }
    if (suppress) continue;
    type_t t;
    switch (c) {
    case 'd': 
    case 'i':
      let tvs = new Opt(lookup_type_vars(te));
      switch (lenmod) {
      case NULL: t = sint_typ; break;
      case &List(x,NULL) && x=='l': t = slong_typ; break;
      case &List(x,NULL) && x=='h': t = sshort_typ; break;
      case &List(x,&List(y,NULL)) && (x=='h' && y=='h'): t = schar_typ; break;
      default: // We don't support ll
        terr(loc,"length modifier '%s' is not allowed with %%%c",
              implode(lenmod), c);
        return NULL;
      }
      t = at_typ(t,new_evar(&rk,tvs),empty_tqual());
      typs = new List(t,typs);
      break;
    case 'u':
    case 'o': 
    case 'x': 
    case 'X':
      let tvs = new Opt(lookup_type_vars(te));
      switch (lenmod) {
      case NULL: t = uint_typ; break;
      case &List(x,NULL) && x=='l': t = ulong_typ;  break;
      case &List(x,NULL) && x=='h': t = ushort_typ; break;
      case &List(x,&List(y,NULL)) && (x=='h' && y=='h'): t = uchar_typ; break;
      default: // We don't support ll
        terr(loc,"length modifier '%s' is not allowed with %%%c",
	     implode(lenmod), c);
        return NULL;
      }
      t = at_typ(t,new_evar(&rk,tvs),empty_tqual());
      typs = new List(t,typs);
      break;
    case 'f': 
    case 'F': 
    case 'e': 
    case 'E': 
    case 'g': 
    case 'G': 
    case 'a': 
    case 'A':
      let tvs = new Opt(lookup_type_vars(te));
      switch (lenmod) {
      case NULL: t = float_typ; break;
        // Note, %f means float in scanf, double in printf!!
      case &List(x,NULL) && x=='l': t = double_typ(false); break;
      default: // We don't support L
        terr(loc,"length modifier '%s' is not allowed with %%%c",
              implode(lenmod), c);
        return NULL;
      }
      t = at_typ(t,new_evar(&rk,tvs),empty_tqual());
      typs = new List(t,typs);
      break;
      //JGM: need to fix and synch up with lib/scanf.cyc
    case 'c':
    case 's':
      let tvs = new Opt(lookup_type_vars(te));
      typs = new List(string_typ(new_evar(&rk,tvs)),typs);
      break;
    case '[':
    case 'p':
      terr(loc,"%%%c is not supported",c);
      return NULL;
    case 'n':
      let tvs = new Opt(lookup_type_vars(te));
      switch (lenmod) {
      case NULL: t = sint_typ; break;
      case &List(x,NULL) && x=='l': t = ulong_typ; break; // DAN: slong_typ???
      case &List(x,NULL) && x=='h': t = sshort_typ; break;
      case &List(x,&List(y,NULL)) && (x=='h' && y=='h'): t = schar_typ; break;
      default: // We don't support ll
        terr(loc,"length modifier '%s' is not allowed with %%%c",
	     implode(lenmod), c);
        return NULL;
      }
      t = at_typ(t,new_evar(&rk,tvs),empty_tqual());
      typs = new List(t,typs);
      break;
    case '%':
      if (suppress) {
        terr(loc,"Assignment suppression (*) is not allowed with %%%%");
        return NULL;
      }
      if (width != NULL) {
        terr(loc,"width '%s' not allowed with %%%%", implode(width));
        return NULL;
      }
      if (lenmod != NULL) {
        terr(loc,"length modifier '%s' not allowed with %%%%", implode(lenmod));
        return NULL;
      }
      break;
    default:
      return NULL; // impossible
    }
  }
  return imp_rev(typs);
}
