/* Parsing and checking format strings.
   Copyright (C) 2001 AT&T
   This file is part of the Cyclone compiler.

   The Cyclone compiler is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   The Cyclone compiler is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with the Cyclone compiler; see the file COPYING. If not,
   write to the Free Software Foundation, Inc., 59 Temple Place -
   Suite 330, Boston, MA 02111-1307, USA. */

#include <core.h>
#include <list.h>
#include <ctype.h>
#include <string.h>
#include <position.h>
#include <stdio.h>
#include "absyn.h"
#include "tcutil.h"
#include "tcenv.h"
#include "formatstr.h"
using Core;
using List;
using Stdio;
using Position;
using Absyn;
using Tcutil;
using Tcenv;

namespace Formatstr;

static struct Opt<kind_t> rk = {RgnKind};

// Parse a conversion specification starting at index i in string s.
// s[i] should be the first character after the leading '%'.
// If there is an error, return null.
// Otherwise, return the flags, width, precision, length modifier,
// from s, as lists of ints (boxed chars).  Also return the conversion 
// specifier as a char, and the index of the character following the conversion
// specifier.
opt_t<$(list_t<int>, list_t<int>, list_t<int>, list_t<int>, char, int)@>
parse_conversionspecification(string_t s, int i) {
  //  fprintf(cyc_stderr, "String: %s\n" "Position: %d\n",s,i);
  let len = String::strlen(s);
  if (i<0 || i>=len) return null;

  // Parse flags: ['+' '-' ' ' '#' '0']*
  let flags = null;
  char c = ' ';
  for (; i<len; i++) {
    c = s[i];
    switch (c) {
    case '+': fallthru;
    case '-': fallthru;
    case ' ': fallthru;
    case '#': fallthru;
    case '0': flags = new List((int)c,flags); continue;
    default: break;
    }
    break;
  }
  if (i>=len) return null;
  flags = List::imp_rev(flags);

  // Parse width: ('*' | ['0'-'9']+)?
  let width = null;
  c = s[i]; // redundant
  if (c=='*') {
    width = new List((int)c,width);
    i++;
  } else {
    for (; i<len; i++) {
      c = s[i];
      if (Ctype::isdigit(c)) width = new List((int)c,width);
      else break;
    }
  }
  if (i>=len) return null;
  width = List::imp_rev(width);

  // Parse precision: ('.' ('*' | ['0'-'9']+)? )?
  let precision = null;
  c = s[i]; // not redundant
  if (c == '.') {
    precision = new List((int)c,precision);
    i++;
    if (i>=len) return null;
    c = s[i];    
    if (c == '*') {
      precision = new List((int)c,precision);
      i++;
    } else {
      for (; i<len; i++) {
        c = s[i];
        if (Ctype::isdigit(c)) precision = new List((int)c,precision);
        else break;
      }
    }
  }
  if (i>=len) return null;
  precision = List::imp_rev(precision);

  // Parse length modifier:
  //  (['h' 'l' 'j' 'z' 't' 'L'] | 'h' 'h' | 'l' 'l')
  let lenmod = null;
  c = s[i]; // not redundant
  switch (c) {
  case 'h':
    lenmod = new List((int)c,lenmod);
    i++;
    if (i>=len) return null;
    c = s[i];
    if (c == 'h') { lenmod = new List((int)c,lenmod); i++; }
    break;
  case 'l':
    lenmod = new List((int)c,lenmod);
    i++;
    if (i>=len) return null;
    c = s[i];
    if (c == 'l') { lenmod = new List((int)c,lenmod); i++; }
    break;
  case 'j': fallthru; 
  case 'z': fallthru; 
  case 't': fallthru; 
  case 'L':
    lenmod = new List((int)c,lenmod);
    i++;
    break;
  default: break;
  }
  if (i>=len) return null;
  lenmod = List::imp_rev(lenmod); // unnecessary

  // Parse conversion specifier
  c = s[i]; // not redundant
  switch (c) {
  case 'd': break;
  case 'i': break;
  case 'o': break;
  case 'u': break;
  case 'x': break;
  case 'X': break;
  case 'f': break;
  case 'F': break;
  case 'e': break;
  case 'E': break;
  case 'g': break;
  case 'G': break;
  case 'a': break;
  case 'A': break;
  case 'c': break;
  case 's': break;
  case 'p': break;
  case 'n': break;
  case '%': break;
  default: return null;
  }
  //  fprintf(cyc_stderr,
  //          "Flags: %s\n"
  //          "Width: %s\n"
  //          "Precision: %s\n"
  //          "Lenmod: %s\n",
  //          String::implode(flags),
  //          String::implode(width),
  //          String::implode(precision),
  //          String::implode(lenmod));
  return new Opt(new $(flags,width,precision,lenmod,c,i+1));
}

list_t<type_t> get_format_typs(tenv_t te,string_t s,seg_t loc) {
  // FIX: on error we return null.  This will probably lead to
  // cascading errors (e.g., too many arguments to printf).
  let len = String::strlen(s);
  let typs = null;
  int i;
  for (i=0; i<len; i++) {
    if (s[i] != '%') continue;
    let cs = parse_conversionspecification(s,i+1);
    if (cs == null) {
      terr(loc,"bad format string");
      return null; // bad conversion specification
    }
    let &$(flags,width,precision,lenmod,c,j) = cs->v;
    i = j-1; // Subtract 1 because for-loop ends with i++
    switch (lenmod) {
    case &List(x,null) && (x == 'j' || x == 'z' || x == 't'):
      // These length modifiers are OK in C99 but we don't support them yet
      terr(loc,aprintf("length modifier '%c' is not supported",x));
      return null;
    default: break;
    }
    switch (width) {
    case &List(x,null) && x=='*':
      typs = new List(sint_t,typs); break;
    default: break;
    }
    switch (precision) {
    case &List(x,&List(y,null)) && x=='.' && y=='*':
      typs = new List(sint_t,typs); break;
    default: break;
    }
    type_t t;
    switch (c) {
    case 'd': fallthru;
    case 'i':
      for (_ f = flags; f != null; f = f->tl)
        if (f->hd == '#') {
          terr(loc,aprintf("flag '#' is not valid with %%%c",c));
          return null;
        }
      switch (lenmod) {
      case null:                     t = sint_t; break;
      case &List(x,null) && x=='l':  t = slong_t; break;
      case &List(x,null) && x=='h':  t = sshort_t; break;
      case &List(x,&List(y,null))
        && (x=='h' && y=='h'):       t = schar_t; break;
      // We don't support ll
      default:
        terr(loc,
             aprintf("length modifier '%s' is not allowed with %%%c",
                     String::implode(lenmod), c));
        return null;
      }
      typs = new List(t,typs);
      break;
    case 'u':
      for (_ f = flags; f != null; f = f->tl)
        if (f->hd == '#') {
          terr(loc,"Flag '#' not valid with %%u");
          return null;
        }
      fallthru;
    case 'o': fallthru;
    case 'x': fallthru;
    case 'X':
      switch (lenmod) {
      case null:                     t = uint_t; break;
      case &List(x,null) && x=='l':  t = ulong_t; break;
      case &List(x,null) && x=='h':  t = ushort_t; break;
      case &List(x,&List(y,null))
        && (x=='h' && y=='h'):       t = uchar_t; break;
      // We don't support ll
      default:
        terr(loc,
             aprintf("length modifier '%s' is not allowed with %%%c",
                     String::implode(lenmod), c));
        return null;
      }
      typs = new List(t,typs);
      break;
    case 'f': fallthru;
    case 'F': fallthru;
    case 'e': fallthru;
    case 'E': fallthru;
    case 'g': fallthru;
    case 'G': fallthru;
    case 'a': fallthru;
    case 'A':
      // We don't allow any length modifiers for floating point numbers;
      // in particular, we don't allow L (long double)
      if (lenmod != null) {
        terr(loc,aprintf("length modifiers are not allowed with %%%c",c));
        return null;
      }
      typs = new List(double_t,typs);
      break;
    case 'c':
      for (_ f = flags; f != null; f = f->tl)
        if (f->hd == '#' || f->hd == '0') {
          terr(loc,aprintf("flag '%c' not allowed with %%c",f->hd));
          return null;
        }
      // We don't allow any length modifiers for characters;
      // in particular, we don't allow l (wint_t)
      if (lenmod != null) {
        terr(loc,aprintf("length modifier '%s' not allowed with %%c",
                         String::implode(lenmod)));
        return null;
      }
      if (precision != null) {
        terr(loc,aprintf("precision '%s' not allowed with %%c",
                         String::implode(precision)));
        return null;
      }
      typs = new List(sint_t,typs);
      break;
    case 's':
// FIX: temporarily we don't allow any variations on %s.  To do that
// we'd have to modify toc.cyc
      if (flags != null) {
        terr(loc,aprintf("flags '%s' not allowed with %%s",
                         String::implode(flags)));
        return null;
      }
      if (width != null) {
        terr(loc,aprintf("width '%s' not allowed with %%s",
                         String::implode(width)));
        return null;
      }
      if (precision != null) {
        terr(loc,aprintf("precision '%s' not allowed with %%s",
                         String::implode(precision)));
        return null;
      }
      if (lenmod != null) {
        terr(loc,aprintf("length modifier '%s' not allowed with %%s",
                         String::implode(lenmod)));
        return null;
      }
//       // Only flag '-' is allowed for %s
//       for (_ f = flags; f != null; f = f->tl)
//         if (f->hd != '-') {
//           terr(loc,"a flag not allowed with %%s");
//           return null;
//         }
//       // We don't allow any length modifiers for %s;
//       // in particular, we don't allow l (wchar_t[?])
//       if (lenmod != null) {
//         terr(loc,"length modifiers not allowed with %%s");
//         return null;
//       }
      typs = new List(const_string_typ(new_evar(&rk,new Opt(lookup_type_vars(te)))),typs);
      break;
    case 'p':
      // We don't support pointer printing
      terr(loc,"%%p not supported");
      return null;
    case 'n':
      for (_ f = flags; f != null; f = f->tl)
        if (f->hd == '#' || f->hd == '0') {
          terr(loc,aprintf("flag '%c' not allowed with %%n",f->hd));
          return null;
        }
      if (precision != null) {
        terr(loc,aprintf("precision '%s' not allowed with %%n",
                         String::implode(precision)));
        return null;
      }
      let tenv_tvs = new Opt(lookup_type_vars(te));
      switch (lenmod) {
      case null:
        t = at_typ(sint_t,new_evar(&rk,tenv_tvs),empty_tqual()); break;
      case &List(x,null) && x=='l':
        t = at_typ(ulong_t,new_evar(&rk,tenv_tvs),empty_tqual()); break;
      case &List(x,null) && x=='h':
        t = at_typ(sshort_t,new_evar(&rk,tenv_tvs),empty_tqual()); break;
      case &List(x,&List(y,null)) && (x=='h' && y=='h'):
          t = at_typ(schar_t,new_evar(&rk,tenv_tvs),empty_tqual()); break;
      // We don't support ll
      default:
        terr(loc,aprintf("length modifier '%s' not allowed with %%n",
                         String::implode(lenmod)));
        return null;
      }
      typs = new List(t,typs);
      break;
    case '%':
      if (flags != null) {
        terr(loc,aprintf("flags '%s' not allowed with %%%%",
                         String::implode(flags)));
        return null;
      }
      if (width != null) {
        terr(loc,aprintf("width '%s' not allowed with %%%%",
                         String::implode(width)));
        return null;
      }
      if (precision != null) {
        terr(loc,aprintf("precision '%s' not allowed with %%%%",
                         String::implode(precision)));
        return null;
      }
      if (lenmod != null) {
        terr(loc,aprintf("length modifier '%s' not allowed with %%%%",
                         String::implode(lenmod)));
        return null;
      }
      break;
    default:
      return null; // impossible
    }
  }
  return List::imp_rev(typs);
}

// Parse a scanf conversion specification starting at index i in string s.
// s[i] should be the first character after the leading '%'.
// If there is an error, return null.
// Otherwise, return whether assignment should be suppressed (a bool),
// the width and length modifier (lists of ints [boxed chars]),
// the conversion specifier (a char),
// and the index of the character following the conversion specifier.
opt_t<$(bool, list_t<int>, list_t<int>, char, int)@>
parse_inputformat(string_t s, int i) {
  let len = String::strlen(s);
  if (i<0 || i>=len) return null;

  let suppress = false;
  let c = s[i];
  if (c == '*') {
    suppress = true;
    i++;
    if (i>=len) return null;
  }

  let width = null;
  for (; i<len; i++) {
    c = s[i];
    if (Ctype::isdigit(c)) width = new List((int)c,width);
    else break;
  }
  if (i>=len) return null;
  width = List::imp_rev(width);

  // Parse length modifier:
  //  ('h' | 'l' | 'j' | 'z' | 't' | 'L' | 'h' 'h' | 'l' 'l')
  let lenmod = null;
  c = s[i]; // not redundant
  switch (c) {
  case 'h':
    lenmod = new List((int)c,lenmod);
    i++;
    if (i>=len) return null;
    c = s[i];
    if (c == 'h') { lenmod = new List((int)c,lenmod); i++; }
    break;
  case 'l':
    lenmod = new List((int)c,lenmod);
    i++;
    if (i>=len) return null;
    c = s[i];
    if (c == 'l') { lenmod = new List((int)c,lenmod); i++; }
    break;
  case 'j': fallthru; 
  case 'z': fallthru; 
  case 't': fallthru; 
  case 'L':
    lenmod = new List((int)c,lenmod);
    i++;
    break;
  default: break;
  }
  if (i>=len) return null;
  lenmod = List::imp_rev(lenmod); // unnecessary

  // Parse conversion specifier
  c = s[i]; // not redundant
  switch (c) {
  case 'd': break;
  case 'i': break;
  case 'o': break;
  case 'u': break;
  case 'x': break;
  case 'X': break;
  case 'f': break;
  case 'F': break;
  case 'e': break;
  case 'E': break;
  case 'g': break;
  case 'G': break;
  case 'a': break;
  case 'A': break;
  case 'c': break;
  case 's': break;
  case 'p': break;
  case 'n': break;
  case '%': break;
  default: return null;
  }
  return new Opt(new $(suppress,width,lenmod,c,i+1));
}
list_t<type_t> get_scanf_typs(tenv_t te,string_t s,seg_t loc) {
  // FIX: on error we return null.  This will probably lead to
  // cascading errors (e.g., too many arguments to scanf).
  let len = String::strlen(s);
  let typs = null;
  int i;
  for (i=0; i<len; i++) {
    if (s[i] != '%') continue;
    let x = parse_inputformat(s,i+1);
    if (x == null) {
      terr(loc,"bad format string");
      return null; // bad conversion specification
    }
    let &$(suppress,width,lenmod,c,j) = x->v;
    i = j-1; // Subtract 1 because for-loop ends with i++
    switch (lenmod) {
    case &List(x,null) && (x == 'j' || x == 'z' || x == 't'):
      // These length modifiers are OK in C99 but we don't support them yet
      terr(loc,aprintf("length modifier '%c' is not supported",x));
      return null;
    default: break;
    }
    if (suppress) continue;
    type_t t;
    switch (c) {
    case 'd': fallthru;
    case 'i':
      let tvs = new Opt(lookup_type_vars(te));
      switch (lenmod) {
      case null:
        t = at_typ(sint_t,new_evar(&rk,tvs),empty_tqual()); break;
      case &List(x,null) && x=='l':
        t = at_typ(slong_t,new_evar(&rk,tvs),empty_tqual()); break;
      case &List(x,null) && x=='h':
        t = at_typ(sshort_t,new_evar(&rk,tvs),empty_tqual()); break;
      case &List(x,&List(y,null)) && (x=='h' && y=='h'):
        t = at_typ(schar_t,new_evar(&rk,tvs),empty_tqual()); break;
      // We don't support ll
      default:
        terr(loc,
             aprintf("length modifier '%s' is not allowed with %%%c",
                     String::implode(lenmod), c));
        return null;
      }
      typs = new List(t,typs);
      break;
    case 'u':
      fallthru;
    case 'o': fallthru;
    case 'x': fallthru;
    case 'X':
      let tvs = new Opt(lookup_type_vars(te));
      switch (lenmod) {
      case null:
        t = at_typ(uint_t,new_evar(&rk,tvs),empty_tqual()); break;
      case &List(x,null) && x=='l':
        t = at_typ(ulong_t,new_evar(&rk,tvs),empty_tqual()); break;
      case &List(x,null) && x=='h':
        t = at_typ(ushort_t,new_evar(&rk,tvs),empty_tqual()); break;
      case &List(x,&List(y,null))
        && (x=='h' && y=='h'):
          t = at_typ(uchar_t,new_evar(&rk,tvs),empty_tqual()); break;
      // We don't support ll
      default:
        terr(loc,
             aprintf("length modifier '%s' is not allowed with %%%c",
                     String::implode(lenmod), c));
        return null;
      }
      typs = new List(t,typs);
      break;
    case 'f': fallthru;
    case 'F': fallthru;
    case 'e': fallthru;
    case 'E': fallthru;
    case 'g': fallthru;
    case 'G': fallthru;
    case 'a': fallthru;
    case 'A':
      let tvs = new Opt(lookup_type_vars(te));
      switch (lenmod) {
      case null:
        // Note, %f means float in scanf, double in printf!!
        t = at_typ(float_t,new_evar(&rk,tvs),empty_tqual()); break;
      case &List(x,null) && x=='l':
        t = at_typ(double_t,new_evar(&rk,tvs),empty_tqual()); break;
      // We don't support L
      default:
        terr(loc,
             aprintf("length modifier '%s' is not allowed with %%%c",
                     String::implode(lenmod), c));
        return null;
      }
      typs = new List(t,typs);
      break;
    case 'c':
      terr(loc,"%%c is not supported");
      return null;
    case 's':
      terr(loc,"%%s is not supported");
      return null;
    case '[':
      terr(loc,"%%[ is not supported");
      return null;
    case 'p':
      terr(loc,"%%p is not supported");
      return null;
    case 'n':
      let tvs = new Opt(lookup_type_vars(te));
      switch (lenmod) {
      case null:
        t = at_typ(sint_t,new_evar(&rk,tvs),empty_tqual()); break;
      case &List(x,null) && x=='l':
        t = at_typ(ulong_t,new_evar(&rk,tvs),empty_tqual()); break;
      case &List(x,null) && x=='h':
        t = at_typ(sshort_t,new_evar(&rk,tvs),empty_tqual()); break;
      case &List(x,&List(y,null)) && (x=='h' && y=='h'):
	t = at_typ(schar_t,new_evar(&rk,tvs),empty_tqual()); break;
      // We don't support ll
      default:
        terr(loc,aprintf("length modifier '%s' not allowed with %%n",
                         String::implode(lenmod)));
        return null;
      }
      typs = new List(t,typs);
      break;
    case '%':
      if (suppress) {
        terr(loc,"Assignment suppression (*) is not allowed with %%%%");
        return null;
      }
      if (width != null) {
        terr(loc,aprintf("width '%s' not allowed with %%%%",
                         String::implode(width)));
        return null;
      }
      if (lenmod != null) {
        terr(loc,aprintf("length modifier '%s' not allowed with %%%%",
                         String::implode(lenmod)));
        return null;
      }
      break;
    default:
      return null; // impossible
    }
  }
  return (List::imp_rev(typs));
}
