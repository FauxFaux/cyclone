/* Translate Cyclone abstract syntax to C abstract syntax.
   Copyright (C) 2001 Greg Morrisett, AT&T
   This file is part of the Cyclone compiler.

   The Cyclone compiler is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   The Cyclone compiler is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with the Cyclone compiler; see the file COPYING. If not,
   write to the Free Software Foundation, Inc., 59 Temple Place -
   Suite 330, Boston, MA 02111-1307, USA. */

// Translation of Cyclone abstract syntax to C abstract syntax.
// Assumes that the type-checker has been successfully run on the
// Cyclone AST.  Uses lots of GCC-specific features (that should be in
// C-9X) to simplify the translation -- in particular, we use struct
// expressions "(struct foo){.f1=e1,.f2=e2,...,.fn=en}" and statement
// expressions "({int temp = e; temp++})".  The latter is used for
// declaring temps needed in the translation of expressions.

// The translation is mostly done in place in an imperative style
// (i.e., we overwrite AST nodes) so it's fairly crucial that we don't
// have sharing in the AST.  The one exception is that the type
// translation is functional.

// Look for "unimp" or comments that start with FIX: for missing
// or broken pieces.

// FIX: we could probably use "const" in lots of places where we're not.

// Note: Do NOT use unresolvedmem_exp except at top-level or you will break
//  the Tovc module

#include <core.h>
#include <stdio.h>
#include <list.h>
#include <string.h>
#include <set.h>
#include <dict.h>
#include <position.h>
#include "absyn.h"
#include "absynpp.h"
#include "tcutil.h"
#include "evexp.h"
#include "formatstr.h"
#include "cf_flowinfo.h"
#include "toc.h"
using Core;
using List;
using Set;
using Position;
using Absyn;
using Absynpp;
using Tcutil;

namespace Toc;

// used for creation of all abstract syntax node locations created here
#define DL NULL

//#define BCE_DEBUG
bool warn_bounds_checks = false;
unsigned total_bounds_checks = 0;
unsigned bounds_checks_eliminated = 0;

// we aren't re-entrant -- we build this list of output decls (in
// reverse order)  It's global b/c tuple types, tagged pointer types, and
// strange top-level initializers need to "splice in" toplevel decls and
// it's a pain to pass this list around everywhere
static list_t<decl_t> result_decls = NULL;
// for gensymming, etc.
static list_t<$(var_t,list_t<type_t>)@> tuple_types = NULL;
static int tuple_type_counter = 0;
static int temp_var_counter = 0;
static int fresh_label_counter = 0;

// errors and reporting
xtunion exn {Toc_Unimplemented};
xtunion exn {Toc_Impossible};
static `a unimp(string_t fmt, ... inject parg_t<`r2> ap) 
  __attribute__((format(printf,1,2), noreturn))
{
  vfprintf(stderr,fmt,ap);
  fprintf(stderr,"\n");
  fflush(stderr);
  throw Toc_Unimplemented;
}
static `a toc_impos(string_t fmt, ... inject parg_t<`r2> ap) 
  __attribute__((format(printf,1,2), noreturn))
{
  vfprintf(stderr,fmt,ap);
  fprintf(stderr,"\n");
  fflush(stderr);
  throw Toc_Impossible;
}
xtunion exn {Match_error};

/////////////////////////// Pre-Allocated Stuff /////////////////////////////
// Don't use any of these things if they might get mutated!!!

// some pre-allocated boxed strings -- use foo_sp for char ?* w/ contents "foo"
#define MAKE_STRING(str)\
  static string_t    str##_string = #str; \
  static stringptr_t str##_sp     = &str##_string

MAKE_STRING(curr);
MAKE_STRING(tag);
MAKE_STRING(_handler_cons);
MAKE_STRING(handler);
MAKE_STRING(_RegionHandle);

// some pre-allocated qvars -- use foo_e for exp that is var "foo"
#define MAKE_VAR(str)\
  static string_t              str##_str = #str;\
  static $(nmspace_t, var_t)   str##_pr  = $((nmspace_t)&rel_ns_null_value,\
					     &str##_str);\
  static tunion Raw_exp.Var_e  str##_re  = Var_e(&str##_pr,Unresolved_b);\
  static struct Exp            str##_ev  = Exp{NULL,&str##_re,NULL,EmptyAnnot};\
  static exp_t                 str##_e   = &str##_ev

MAKE_VAR(_throw);
MAKE_VAR(setjmp);
MAKE_VAR(_push_handler);
MAKE_VAR(_pop_handler);
MAKE_VAR(_exn_thrown);
MAKE_VAR(_npop_handler);
MAKE_VAR(_check_null);
MAKE_VAR(_check_known_subscript_null);
MAKE_VAR(_check_known_subscript_notnull);
MAKE_VAR(_check_unknown_subscript);
MAKE_VAR(_tagged_arr);
MAKE_VAR(_tag_arr);
MAKE_VAR(_init_tag_arr);
MAKE_VAR(_untag_arr);
MAKE_VAR(_get_arr_size);
MAKE_VAR(_tagged_arr_plus);
MAKE_VAR(_tagged_arr_inplace_plus);
MAKE_VAR(_tagged_arr_inplace_plus_post);
MAKE_VAR(_cycalloc);
MAKE_VAR(_cyccalloc);
MAKE_VAR(_cycalloc_atomic);
MAKE_VAR(_cyccalloc_atomic);
MAKE_VAR(_region_malloc);
MAKE_VAR(_region_calloc);
MAKE_VAR(_check_times);
MAKE_VAR(_new_region);
MAKE_VAR(_push_region);
MAKE_VAR(_pop_region);
MAKE_VAR(_reset_region);

#undef MAKE_STRING
#undef MAKE_VAR

static tunion AggrInfoU.UnknownAggr tagged_arr_typ_u = 
                           UnknownAggr(StructA,&_tagged_arr_pr);
static tunion Type.AggrType tagged_arr_typ_v =
                           AggrType(AggrInfo(&tagged_arr_typ_u,NULL));
static tunion Type tagged_arr_typ = &tagged_arr_typ_v;

static tqual_t mt_tq = Tqual(false,false,false);

static stmt_t skip_stmt_dl() {
  static stmt_t * skip_stmt_opt = NULL;
  if(skip_stmt_opt == NULL)
    skip_stmt_opt = new skip_stmt(DL);
  return *skip_stmt_opt;
}

///////////////////////////// Various Utilities /////////////////////////////

static bool is_zero(exp_t e) {
  switch (e->r) {
  case &Const_e(&Char_c(_,c)): return c == '\0';
  case &Const_e(&Short_c(_,i)): return i == 0;
  case &Const_e(&Int_c(_,i)): return i == 0;
  case &Const_e(&LongLong_c(_,i)): return i == 0;
  case &Const_e(Null_c): return true;
  case &Cast_e(_,e1): return is_zero(e1);
  case &Tuple_e(es): return List::forall(is_zero,es);
  case &Array_e(dles): fallthru(dles);
  case &Struct_e(_,_,dles,_):  fallthru(dles);
  case &CompoundLit_e(_,dles): fallthru(dles);
  case &UnresolvedMem_e(_,dles):
    for (; dles != NULL; dles = dles->tl) 
      if (!is_zero((*dles->hd)[1])) return false;
    return true;
  default: return false;
  }
}

// return true if t is a nullable pointer type i.e., *
static bool is_nullable(type_t t) {
  switch (compress(t)) {
  case &PointerType(PtrInfo{_,_,b,_,_}): return conref_def(false,b);
  default: toc_impos("is_nullable");
  }
}

// FIX: Share the results to save compile-time space and time.
//      Alternately, put struct names for tunion variants in the environment.
static qvar_t collapse_qvar_tag(qvar_t x,string_t tag) {
  return new $((*x)[0], 
               new (string_t)strconcat(*((*x)[1]),tag));
}

// used to generate struct definitions for tuple types
// we share the struct definitions where possible.  
static var_t add_tuple_type(list_t<$(tqual_t,type_t)@,`r> tqs0) {
  // look for the same tuple-type already declared
  for (let tts = tuple_types; tts != NULL; tts = tts->tl) {
    let &$(x,ts) = tts->hd;
    let tqs = tqs0;
    for (; tqs != NULL && ts != NULL; tqs = tqs->tl, ts = ts->tl)
      if (!unify((*tqs->hd)[1],ts->hd))
	break;
    if(tqs == NULL && ts == NULL)
      return x;
  }
  // haven't seen this one before, add a declaration
  stringptr_t x = new (string_t)aprintf("_tuple%d",tuple_type_counter++);
  list_t<type_t> ts = List::map(snd_tqt,tqs0);
  let fs = NULL;
  list_t<type_t> ts2 = ts;
  for (int i=1; ts2 != NULL; ts2 = ts2->tl, i++)
    fs = new List(new Aggrfield(fieldname(i),mt_tq,ts2->hd,NULL,NULL),fs);
  fs = List::imp_rev(fs);
  let sd = new Aggrdecl{.kind=StructA, .sc = Public, 
		       .name = new $(rel_ns_null,x), .tvs = NULL, 
			.impl = new AggrdeclImpl{.exist_vars = NULL, 
						 .rgn_po = NULL,
						 .fields = fs},
			.attributes = NULL};
  result_decls = new List(new_decl(new Aggr_d(sd),DL),result_decls);
  tuple_types  = new List(new $(x,ts),tuple_types);
  return x;
}

// generate a temporary variable
// FIX: need to guarantee these can't conflict
qvar_t temp_var() {
  return new $(Loc_n,new (string_t)aprintf("_tmp%X",temp_var_counter++));
}

// generate a fresh label
// FIX: need to guarantee these can't conflict
static var_t fresh_label() {
  return new (string_t)aprintf("_LL%X",fresh_label_counter++);
}

// These two functions should never be used for xtunions. Should memoize?
// Note the former used to use static const int variables, but couldn't
// at top-level.
static exp_t tunion_tag(tuniondecl_t td, qvar_t name, bool carries_value) {
  int ans = 0;
  let fs  = td->fields->v;
  while(qvar_cmp(name,fs->hd->name)!=0) {
    if((carries_value && fs->hd->typs != NULL)
       || (!carries_value && fs->hd->typs == NULL))
      ++ans;
    fs = fs->tl;
  }
  return uint_exp(ans,DL);    
}
static int num_void_tags(tuniondecl_t td) {
  int ans = 0;
  for(let fs = td->fields->v; fs != NULL; fs = fs->tl)
    if(fs->hd->typs == NULL)
      ++ans;
  return ans;    
}

///////////////////////////////////////////////////////////////
//         Convert a Cyclone type to a C type                //
///////////////////////////////////////////////////////////////
static type_t typ_to_c(type_t t); // forward declaration

static $(opt_t<var_t,`r>,tqual_t,type_t)@ 
arg_to_c($(opt_t<var_t,`r>,tqual_t,type_t)@ a) {
  let $(x,y,z) = *a;
  return new $(x,y,typ_to_c(z));
}
static $(tqual_t,type_t)@ typ_to_c_f($(tqual_t,type_t)@ x) {
  let $(a,b) = *x;
  return new $(a,typ_to_c(b));
}
// Sometimes we translate arrays t[] and t[N] to t*, and sometimes
// we leave them alone.  We must leave them alone in the following
// circumstances:
// 1. as the argument of sizeof
// 2. in typedef
// 3. in declarations
// 4. as the element type of an array
// 5. as the type part of a C9X compound literal
// 6. as the type of a struct field
// We must change them to pointers in the following circumstances:
// 1. as the argument of cast
// We can do either in the following circumstances:
// 1. as the parameter of a function
// The function typ_to_c_array leaves them alone, while typ_to_c
// changes them to pointers.
static type_t typ_to_c_array(type_t t) {
  switch(t) {
  case &ArrayType(t2,tq,x): // FIX: do we handle tq correctly?
    return new ArrayType(typ_to_c_array(t2),tq,x);
  case &Evar(_,&Opt{.v=t2},_,_): return typ_to_c_array(t2);
  default: return typ_to_c(t);
  }
}

static aggrfield_t aggrfield_to_c(aggrfield_t f) {
  return new Aggrfield{.name=f->name, .tq=f->tq, .type = typ_to_c(f->type),
                       .width=f->width, .attributes=f->attributes};
}

static void enumfields_to_c(list_t<enumfield_t> fs) {
  for (let fs = fs; fs != NULL; fs = fs->tl)
    if (fs->hd->tag != NULL) {
      unsigned int i = Evexp::eval_const_uint_exp((exp_t)fs->hd->tag);
      fs->hd->tag = uint_exp(i,NULL);
    }
}

static type_t typ_to_c(type_t t) {
  switch (t) {
  case VoidType: return t;
  case &Evar(_,NULL,_,_): return sint_typ; // pick something widely useful
  case &Evar(_,&Opt{.v=t2},_,_): return typ_to_c(t2); 
  case &VarType(tv): 
    if (tvar_kind(tv) == AnyKind) return VoidType;
    else return void_star_typ(); // map `a to void *
  case &TunionType(TunionInfo{&KnownTunion(_),_,_}): return void_star_typ();
  case &TunionType(_): toc_impos("unresolved TunionType");
  case &TunionFieldType(TunionFieldInfo{&KnownTunionfield(tud,tuf),_}):
    // for tunion fields that carry no arguments, it's an unsigned int
    // for xtunion fields that carry no argument, it's a char *.
    // for fields that carry arguments, it's a struct _Field_struct;
    if (tuf->typs == NULL) 
      if(tud->is_xtunion) return star_typ(char_typ,HeapRgn,mt_tq);
      else return uint_typ;
    else return strctq(collapse_qvar_tag(tuf->name,"_struct"));
  case &TunionFieldType(_): toc_impos("unresolved TunionFieldType");
  case &PointerType(PtrInfo{t2,_,_,tq,bnds}):
    // t2? maps to struct tagged_arr.
    // t2* and t2@ map to t2*.  Regions are irrelevant.
    t2 = typ_to_c_array(t2);
    switch (compress_conref(bnds)->v) {
    case &Eq_constr(Unknown_b): return tagged_arr_typ;
    default: return star_typ(t2,HeapRgn,tq);
    }
  case &IntType(_,_): 
  case FloatType:     
  case &DoubleType(_): return t;
  case &ArrayType(t2,tq,e): return new ArrayType(typ_to_c_array(t2),tq,e);
  case &FnType(FnInfo{_,_,t2,args,c_vararg,cyc_vararg,_,atts}):
    // just drop the type arguments & effect and translate the nested types
    // also, drop any format descriptors 
    // FIX:  problem with higher-order functions?  Again C's rules are strange.
    // FIX:  dropping noreturn and const attributes b/c C is complaining.
    let new_atts = NULL;
    for (; atts != NULL; atts = atts->tl)
      switch (atts->hd) {
      case Noreturn_att: 
      case Const_att   : 
      case &Format_att(_,_,_): continue;
      default: new_atts = new List(atts->hd,new_atts); break;
      }
    let new_args = List::map(arg_to_c,args);
    if (cyc_vararg != NULL) {
      // region for array type irrelevant
      let t = typ_to_c(tagged_typ(cyc_vararg->type,HeapRgn,mt_tq));
      let vararg = new $(cyc_vararg->name,cyc_vararg->tq,t);
      new_args = List::imp_append(new_args,new List(vararg,NULL));
    }
    return new FnType(FnInfo{NULL,NULL,typ_to_c(t2),new_args,
                               c_vararg,NULL,NULL,new_atts});
  case &TupleType(tqs):
    // $(t1,...,tn) maps to struct tuple_type_n where we define
    // struct tuple_type_n { t1 f1; ...; tn fn; };
    tqs = List::map(typ_to_c_f,tqs);
    let n = add_tuple_type(tqs);
    return strct(n);
  // FIX: we may have to actually declare these things and use them
  // consistently to make GCC happy.
  case &AnonAggrType(k,fs): 
    return new AnonAggrType(k,List::map(aggrfield_to_c,fs));
  case &AggrType(AggrInfo(info,ts)):
    let ad = get_known_aggrdecl(info);
    if(ad->kind==UnionA)
      return unionq_typ(ad->name);
    return strctq(ad->name);
  case &EnumType(tdn,_): return t;
  case &AnonEnumType(fs): enumfields_to_c(fs); return t;
  case &TypedefType(tdn,ts,td,topt):
    if (topt == NULL) 
      return new TypedefType(tdn,NULL,td,NULL);
    // just drop the type arguments and translate the nested types
    else return new TypedefType(tdn,NULL,td,new Opt(typ_to_c_array(topt->v)));
  case &SizeofType(_): return uint_typ;
  case &TagType(_): return sint_typ;
  case &RgnHandleType(t):
    return cstar_typ(strct(_RegionHandle_sp),mt_tq); // could be shared
  case &TypeInt(_): 
    toc_impos("Toc::typ_to_c: type translation passed a type integer");
  case HeapRgn:
    toc_impos("Toc::typ_to_c: type translation passed the heap region");
  case &AccessEff(_):
    toc_impos("Toc::typ_to_c: type translation passed the access eff");
  case &JoinEff(_):
    toc_impos("Toc::typ_to_c: type translation passed the join eff");
  case &RgnsEff(_):
    toc_impos("Toc::typ_to_c: type translation passed the regions eff");
  }
}

static exp_t array_to_ptr_cast(type_t t,exp_t e,seg_t l) {
  switch (t) {
  case &ArrayType(t2,tq,_): return cast_exp(star_typ(t2,HeapRgn,tq),e,l);
  default:                  return cast_exp(t,e,l);
  }
}

// returns true when the type contains no pointers. Is conservative
// (does not look at instantiations)
static bool atomic_typ(type_t t) {
  switch (compress(t)) {
  case VoidType:       return true;
  case &VarType(_):    return false;
  case &IntType(_,_):  
  case &EnumType(_,_): 
  case &AnonEnumType(_): 
  case FloatType:      
  case &DoubleType(_): 
  case &FnType(_):     
  case &TagType(_):
  case &SizeofType(_): return true;
  case &ArrayType(t,_,_): return atomic_typ(t);
    // FIX: really should compute in terms of the instantiation
    // to be as aggressive as possible.
    // note even without this we'll allocate Position::seg_t with atomic.
    // NOTE: cannot call get_known_aggrdecl b/c we sometimes call this
    // post-translation (with unchecked C types)?? (We shouldn't)
  case &AggrType(AggrInfo(info,_)):
    switch(info) {
    case &UnknownAggr(_,_): return false; // see above!
    default: break;
    }
    let ad = get_known_aggrdecl(info);
    if(ad->impl == NULL)
      return false;
    for(let fs = ad->impl->fields; fs != NULL; fs = fs->tl)
      if (!atomic_typ(fs->hd->type)) return false;
    return true;
  case &AnonAggrType(_,fs):
    for (; fs != NULL; fs = fs->tl)
      if (!atomic_typ(fs->hd->type)) return false;
    return true;
  case &TunionFieldType(TunionFieldInfo{&KnownTunionfield(tud,tuf),_}):
    fallthru(tuf->typs);
  case &TupleType(tqs):
    for (; tqs != NULL; tqs = tqs->tl)
      if (!atomic_typ((*tqs->hd)[1])) return false;
    return true;
    // FIX: can do better if all variants are fieldless (but then they could
    //      have used an enum)
  case &TunionType(_):    
  case &PointerType(_):   
  case &RgnHandleType(_): return false;
  default: toc_impos("atomic_typ:  bad type %s",typ2string(t));
  }
}

static bool is_void_star(type_t t) {
  switch (compress(t)) {
  case &PointerType(PtrInfo{t2,_,_,_,_}):
    switch (compress(t2)) {
    case VoidType: return true;
    default:       return false;
    }
  default: return false;
  }
}

// returns true when field f of the struct/union t has type void*.
static bool is_poly_field(type_t t, field_name_t f) {
  switch (compress(t)) {
  case &AggrType(AggrInfo(info,_)):
    let ad = get_known_aggrdecl(info);
    if (ad->impl == NULL)
      toc_impos("is_poly_field: type missing fields");
    fallthru(ad->impl->fields);
  case &AnonAggrType(_,fs):
    let field = lookup_field(fs,f);
    if (field == NULL) 
      toc_impos("is_poly_field: bad field %s",*f);
    return is_void_star(field->type);
  default: toc_impos("is_poly_field: bad type %s",typ2string(t));
  }
}

// returns true when e is projection of a field in a struct that has a 
// variable type before instantiation.  For instance, the field hd has
// type `a before instantiation in struct cons.
static bool is_poly_project(exp_t e) {
  switch (e->r) {
  case &AggrMember_e(e1,f): return is_poly_field(e1->topt->v,f);
  case &AggrArrow_e(e1,f):
    switch (compress(e1->topt->v)) {
    case &PointerType(PtrInfo{t,_,_,_,_}): return is_poly_field(t,f);
    default: toc_impos("is_poly_project:  bad type %s",typ2string(e1->topt->v));
    }
  default: return false;
  }
}

// possible pointer malloc
static exp_t malloc_ptr(exp_t s) {
  return fncall_exp(_cycalloc_e, new List(s,NULL),DL);
}
// no pointers possible malloc
static exp_t malloc_atomic(exp_t s) {
  return fncall_exp(_cycalloc_atomic_e, new List(s,NULL),DL);
}
// malloc something -- choose malloc routine according to the (Cyclone) type
static exp_t malloc_exp(type_t t,exp_t s) {
  if (atomic_typ(t))
    return malloc_atomic(s);
  return malloc_ptr(s);
}
// region malloc something
static exp_t rmalloc_exp(exp_t rgn, exp_t s) {
  return fncall_exp(_region_malloc_e, list(rgn,s), DL);
}
// calloc something
static exp_t calloc_exp(type_t elt_type, exp_t s, exp_t n) {
  if (atomic_typ(elt_type))
    return fncall_exp(_cyccalloc_atomic_e, list(s,n), DL);
  else 
    return fncall_exp(_cyccalloc_e, list(s,n), DL);
}
// rcalloc something
static exp_t rcalloc_exp(exp_t rgn, exp_t s, exp_t n) {
  return fncall_exp(_region_calloc_e, list(rgn,s,n), DL);
}

// throw an exception -- this is turned into a function call
static exp_t newthrow_exp(exp_t e) {
  return fncall_exp(_throw_e, new List(e,NULL), DL);
}

// t*{sz} -> t? at top-level
static exp_t make_toplevel_tagged_arr(type_t t, exp_t sz, exp_t e) {
  // Note e must be either (a) a string or else (b) a [possibly cast] 
  // identifier that is an array.
  // For case a, we generate
  //   t x[sz] = e;
  //   {x,x,x+sz};
  // For case b, we generate
  //   {e,e,e+sz};
  bool is_string = false;
  switch (e->r) {
  case &Const_e(&String_c(_)): is_string = true; break;
  default: break;
  }
  exp_t xexp;
  exp_t xplussz;
  if (is_string) {
    qvar_t    x      = temp_var();
    type_t    vd_typ = new ArrayType(char_typ,mt_tq,sz);
    vardecl_t vd     = static_vardecl(x,vd_typ,e);
    result_decls = new List(new_decl(new Var_d(vd),DL),result_decls);
    xexp = var_exp(x,DL);
    xplussz = add_exp(xexp,sz,DL);
  } else {
    xexp = cast_exp(void_star_typ(),e,DL);
    // Note: If e is NULL, element size of 0 is fine!
    xplussz = cast_exp(void_star_typ(),add_exp(e,sz,DL),DL);
  }
  exp_t urm_exp = unresolvedmem_exp(NULL,list(new $(NULL,xexp),
					      new $(NULL,xexp),
					      new $(NULL,xplussz)),DL);
  return urm_exp;
}

///////////////////////////////////////////////////////////////
//              Translation Environments                     //
///////////////////////////////////////////////////////////////
// When break_lab is NULL, translate break to break.  Otherwise,
// translate break to goto of the given label.  Similarly for
// continue.  This is used in the translation of switches and
// exception handlers to get the right control-flow.
//
// The varmap is used to map source identifiers to certain expressions.
// This is primarily used in the pattern match compilation.
//
// Translation of fallthru(e1,...,en) is
// varmap'(qv1) = trans(e1); ... varmap'(qvn) = trans(en);
// goto fallthru_info->v[0]
// where the ith element of fallthru_info->v[1] is qvi
// and varmap' is fallthru_info->v[2]
// (We also have to pop handlers as explained above.)
static struct Env {
  opt_t<var_t> break_lab;
  opt_t<var_t> continue_lab;
  opt_t<$(var_t,list_t<qvar_t>,Dict::dict_t<qvar_t,exp_t>)@> fallthru_info;
  Dict::dict_t<qvar_t,exp_t> varmap;
  bool toplevel;
};
typedef struct Env @env_t;

// the empty environment
static env_t empty_env() {
  return new Env{.break_lab     = NULL,
                 .continue_lab  = NULL,
                 .fallthru_info = NULL,
                 .varmap        = Dict::empty(qvar_cmp),
                 .toplevel      = true};
}

static env_t clear_toplevel(env_t e) {
  env_t ans = new *e;
  ans->toplevel = false;
  return ans;
}

// add x->y to variable map in environment
// The type allows y to be a general exp, but in practice it is always a var_exp
static env_t add_varmap(env_t e, qvar_t x, exp_t y) {
  switch ((*x)[0]) {
  case &Rel_n(_): toc_impos("Toc::add_varmap on Rel_n: %s\n", qvar2string(x));
  default: break;
  }
  env_t ans = new *e;
  ans->varmap = Dict::insert(ans->varmap, x, y);
  return ans;
}

// env for loop body: break and continue labels are set to null,
// exception handler pop counters for break and continue are zeroed
static env_t loop_env(env_t e) {
  env_t ans = new *e;
  ans->break_lab    = NULL;
  ans->continue_lab = NULL;
  return ans;
}

// env for a switch clause: give new label for break, and zero its pop counter
static env_t non_last_switchclause_env(env_t e, var_t break_l, var_t fallthru_l,
				     list_t<vardecl_t> fallthru_binders,
				     env_t next_case_env) {
  let fallthru_vars = NULL;
  for(; fallthru_binders != NULL; fallthru_binders = fallthru_binders->tl)
    fallthru_vars = new List(fallthru_binders->hd->name, fallthru_vars);
  fallthru_vars = List::imp_rev(fallthru_vars);
    
  env_t ans = new *e;
  ans->break_lab       = new Opt(break_l);
  ans->fallthru_info   = new Opt(new $(fallthru_l,
                                       fallthru_vars,
                                       next_case_env->varmap));
  return ans;
}

static env_t last_switchclause_env(env_t e, var_t break_l) {
  env_t ans = new *e;
  ans->break_lab     = new Opt(break_l);
  ans->fallthru_info = NULL; // not allowed in last case
  return ans;
}

// must have no pattern vars and type is int, char, or tunion of a type
// with no value constructors. (If it weren't for allowing fallthru
// anywhere, we wouldn't need the next_l.)
static env_t switch_as_switch_env(env_t e, var_t next_l) {
  env_t ans = new *e;
  ans->break_lab     = NULL;
  ans->fallthru_info = new Opt(new $(next_l,NULL,Dict::empty(qvar_cmp)));
  return ans;
}

///////////////////////////////////////////////////////////////
//              Translation of Expressions                   //
///////////////////////////////////////////////////////////////
static void exp_to_c(env_t nv, exp_t e); // forward declaration
static void stmt_to_c(env_t nv, stmt_t s); // forward declaration

static bool need_null_check(exp_t e) { // e must be pre-translation!
  switch(e->annot) {
  case &CfFlowInfo::UnknownZ(_): return is_nullable(e->topt->v);
  case &CfFlowInfo::NotZero(_):  return false;
  case &CfFlowInfo::IsZero(_): 
    Tcutil::terr(e->loc,"dereference of NULL pointer"); 
    return false;
  case EmptyAnnot:
    // warning is unfounded under sizeof as in memcpy
    // Tcutil::warn(e->loc,"unreachable dereference");
    return false;
  default: throw new Core::Impossible("need_null_check");
  }
}

static CfFlowInfo::relns_t get_relns(exp_t e) { // e must be pre-translation!
  switch (e->annot) {
  case &CfFlowInfo::UnknownZ(r): return r;
  case &CfFlowInfo::NotZero(r):  return r;
  case &CfFlowInfo::IsZero(_): 
    Tcutil::terr(e->loc,"dereference of NULL pointer"); 
    return NULL;
  case EmptyAnnot: return NULL;
  default: throw new Core::Impossible("get_relns");
  }
}

// returns true when i is <= the number of elements in t
static bool check_const_array(unsigned i, type_t t) {
  //fprintf(stderr,"checking const array %d and %s\n",i,typ2string(t));
  switch (compress(t)) {
  case &PointerType(PtrInfo{_,_,_,_,b}):
    switch (conref_def(bounds_one,b)) {
    case Unknown_b: return false;
    case &Upper_b(e):
      unsigned j = Evexp::eval_const_uint_exp(e);
      return i <= j;
    }
  case &ArrayType(_,_,e):
    if (e == NULL) return false;
    unsigned j = Evexp::eval_const_uint_exp((exp_t)e);
    return i <= j;
  default: return false;
  }
}

// see if y is <= v.size
static bool check_leq_size_var(CfFlowInfo::relns_t relns, vardecl_t v, 
                               vardecl_t y) {
  for (; relns != NULL; relns = relns->tl) {
    let r = relns->hd;
    if (r->vd != y) continue;
    switch (r->rop) {
    case &CfFlowInfo::LessSize(z) : fallthru(z);
    case &CfFlowInfo::LessEqSize(z): if (z == v) return true; else break; 
    default: continue;
    }
  }
  return false;
}

// see if e is <= v.size
static bool check_leq_size(CfFlowInfo::relns_t relns, vardecl_t v, exp_t e) {
  switch (e->r) {
  case &Var_e(_,&Pat_b(y)): fallthru(y);
  case &Var_e(_,&Local_b(y)): fallthru(y);
  case &Var_e(_,&Global_b(y)): fallthru(y);
  case &Var_e(_,&Param_b(y)):
    if (y->escapes) return false;
    // see if y <= v.size
    if (check_leq_size_var(relns,v,y)) return true;
    break;
  case &Primop_e(Size,&List(e2,_)):
    // see if e2 is v
    switch (e2->r) {
    case &Var_e(_,&Pat_b(y)): fallthru(y);
    case &Var_e(_,&Local_b(y)): fallthru(y);
    case &Var_e(_,&Global_b(y)): fallthru(y);
    case &Var_e(_,&Param_b(y)):
      return y == v;
    default: break;
    }
    break;
  default: break;
  }
  return false;
}

// return true if we can prove from relns that i < a.size
//  FIX: doesn't deal with the case where i is a constant and a's size
//  can be found.
static bool check_bounds(CfFlowInfo::relns_t relns, exp_t a, exp_t i) {
#ifdef BCE_DEBUG
  fprintf(stderr,"bounds check on %s and %s\n",exp2string(a),exp2string(i));
  fprintf(stderr,"relns: ["); CfFlowInfo::print_relns(relns); 
  fprintf(stderr,"]\n");
#endif
  switch (a->r) {
  case &Var_e(_,&Pat_b(x)): fallthru(x);
  case &Var_e(_,&Local_b(x)): fallthru(x);
  case &Var_e(_,&Global_b(x)): fallthru(x);
  case &Var_e(_,&Param_b(x)):
    if (x->escapes) return false; // no point in looking for escaping vars

  inner_loop:
    switch (i->r) {
    case &Cast_e(t,e2): i = e2; goto inner_loop;
    case &Const_e(&Int_c(None,i)): fallthru(i);
    case &Const_e(&Int_c(Signed,i)): 
      return ((i >= 0) && check_const_array(i+1,x->type));
    case &Const_e(&Int_c(Unsigned,i)): 
      return check_const_array(i+1,x->type);
    case &Primop_e(Mod,&List(e1,&List(e2,_))):
      // we have x[e1 % e2]
      // if e2 is x.size or z such that z <= x.size then it's okay
      return check_leq_size(relns, x, e2);
    case &Var_e(_,&Pat_b(y)): fallthru(y);
    case &Var_e(_,&Local_b(y)): fallthru(y);
    case &Var_e(_,&Global_b(y)): fallthru(y);
    case &Var_e(_,&Param_b(y)):
      if (y->escapes) return false;
      // the expression we're checking is x[y].
      // find something such that y < something
      for (let rs = relns; rs != NULL; rs = rs->tl) {
        let r = rs->hd;
        if (r->vd == y) {
          switch (r->rop) {
            // y < x.size
          case &CfFlowInfo::LessSize(z): if (x == z) return true; else break;
          case &CfFlowInfo::LessVar(z):
            // y < z -- try to find z == x.size or z <= x.size
            for (let rs = relns; rs != NULL; rs = rs->tl) {
              let r = rs->hd;
              if (r->vd == z) 
                switch (r->rop) {
                case &CfFlowInfo::LessEqSize(w): fallthru(w);
                case &CfFlowInfo::LessSize(w):
                  if (x == w) return true; else break;
                case &CfFlowInfo::EqualConst(c): 
                  return check_const_array(c,x->type);
                case &CfFlowInfo::LessVar(w):
                  if (check_leq_size_var(relns, x, w)) return true; else break;
                default: break;
                }
            }
            break;
          case &CfFlowInfo::LessConst(c):
            // y < c -- see if c <= x.size 
            return check_const_array(c,x->type);
          default: break;
          }
        }
      }
      break;
    default: break;
    }
    break;
  default: break;
  }
  return false;
}


static type_t get_c_typ(exp_t e) {
  if (e->topt == NULL) toc_impos("Missing type in primop ");
  return typ_to_c(e->topt->v);
}
static type_t get_cyc_typ(exp_t e) {
  if (e->topt == NULL) toc_impos("Missing type in primop ");
  return e->topt->v;
}
static $(tqual_t, type_t)@ tup_to_c(exp_t e) {
  return new $(mt_tq, typ_to_c(e->topt->v));
}
static $(list_t<designator_t>,exp_t)@ add_designator(env_t nv, exp_t e) {
  exp_to_c(nv,e);
  return new $(NULL,e);
}

static exp_t make_struct(env_t nv, qvar_t x, type_t struct_typ, stmt_t s,
                         bool pointer, exp_opt_t rgnopt, bool is_atomic) {
  exp_opt_t eo;
  type_t    t;
  if (pointer) {
    t  = cstar_typ(struct_typ, mt_tq);
    let se = sizeofexp_exp(deref_exp(var_exp(x,DL),DL),DL);
    if (rgnopt == NULL)
      eo = is_atomic ? malloc_atomic(se) : malloc_ptr(se);
    else {
      exp_t r = (exp_t)rgnopt;
      exp_to_c(nv, r);
      eo = rmalloc_exp(r,se);
    }
  } else {
    t  = struct_typ;
    eo = NULL;
  }
  return stmt_exp(declare_stmt(x,t,eo,s,DL),DL);
}

static stmt_t init_comprehension(env_t nv, exp_t lhs, vardecl_t vd, 
                                 exp_t e1, exp_t e2, stmt_t s, 
                                 bool e1_already_translated);

static stmt_t init_anon_struct(env_t nv, exp_t lhs, type_t struct_type,
                               list_t<$(list_t<designator_t>,exp_t)@> dles,
                               stmt_t s);

// code to initialize an array
static stmt_t init_array(env_t nv, exp_t lhs, 
                         list_t<$(list_t<designator_t>,exp_t)@> dles0,
                         stmt_t s) {
  int count = List::length(dles0)-1;
  for (let dles = List::rev(dles0); dles != NULL; dles = dles->tl) {
    // add lhs[e_index] = e to sequence of assignments
    let &$(dl,e1) = dles->hd;
    // calculate the index expression -- the front end checks that
    // the designators are in ascending order...
    // FIX:  real designator lists
    exp_t e_index;
    if (dl == NULL)
      e_index = signed_int_exp(count--,DL);
    else {
      if (dl->tl != NULL) unimp("multiple designators in array");
      let d = dl->hd;
      switch (d) {
      case &ArrayElement(e3):
        exp_to_c(nv,e3);
        e_index = e3;
        break;
      case &FieldName(_): unimp("field name designators in array");
      }
    }
    exp_t lval = subscript_exp(lhs,e_index,DL);
    switch (e1->r) {
    case &Array_e(dles0):
      s = init_array(nv, lval, dles0, s);
      break;
    case &Comprehension_e(vd,g1,g2):
      s = init_comprehension(nv, lval, vd, g1, g2, s, false);
      break;
    case &AnonStruct_e(st,dles):
      s = init_anon_struct(nv, lval, st, dles, s);
      break;
    default:
      exp_to_c(nv,e1);
      s = seq_stmt(assign_stmt(subscript_exp(lhs,e_index,DL),e1,DL),s,DL);
      break;
    }
  }
  return s;
}

// code to initialize a comprehension
// WARNING: Changing the translation here will break Tovc.
static stmt_t init_comprehension(env_t nv, exp_t lhs, vardecl_t vd, 
                                 exp_t e1, exp_t e2, stmt_t s, 
                                 bool e1_already_translated) {
  let x1 = vd->name;
  if (!e1_already_translated)
    exp_to_c(nv,e1);
  env_t nv2 = add_varmap(nv,x1,varb_exp(x1,new Local_b(vd),DL));
  qvar_t max = temp_var();
  exp_t ea = assign_exp(var_exp(x1,DL),signed_int_exp(0,DL),DL);
  exp_t eb = lt_exp(var_exp(x1,DL),var_exp(max,DL),DL);
  exp_t ec = post_inc_exp(var_exp(x1,DL),DL);
  exp_t lval = subscript_exp(lhs,var_exp(x1,DL),DL);
  stmt_t body;
  // since we don't yet allow arrays or comprehensions within comprehensions
  // these two cases shouldn't arise -- but we ought to support this.
  switch (e2->r) {
  case &Array_e(dles):
    body = init_array(nv2, lval, dles, skip_stmt_dl());
    break;
  case &Comprehension_e(vd2,g1,g2):
    body = init_comprehension(nv2, lval, vd2, g1,g2, skip_stmt_dl(), false);
    break;
  case &AnonStruct_e(st,dles):
    body = init_anon_struct(nv, lval, st, dles, skip_stmt_dl());
    break;
  default:
    exp_to_c(nv2,e2);
    body = assign_stmt(lval,e2,DL);
    break;
  }
  stmt_t s2 = for_stmt(ea,eb,ec,body,DL);
  // note that we get rid of the const on the index variable x1 here
  return seq_stmt(declare_stmt(max,uint_typ,e1,
			       declare_stmt(x1,uint_typ,NULL,s2,DL),DL),s,DL);
}

static stmt_t init_anon_struct(env_t nv, exp_t lhs, type_t struct_type,
                               list_t<$(list_t<designator_t>,exp_t)@> dles,
                               stmt_t s) {
  for(let es = List::rev(dles); es != NULL; es = es->tl) {
    let &$(ds,e) = es->hd;
    if(ds == NULL)
      toc_impos("empty designator list");
    if(ds->tl != NULL) 
      toc_impos("too many designators in anonymous struct");
    switch (ds->hd) {
    case &FieldName(f):
      exp_t lval = aggrmember_exp(lhs,f,DL);
      switch (e->r) {
      case &Array_e(dles):
        s = init_array(nv, lval, dles, s); break;
      case &Comprehension_e(vd,e1,e2):
        s = init_comprehension(nv, lval, vd, e1, e2, s, false); break;
      case &AnonStruct_e(st2,dles):
        s = init_anon_struct(nv, lval, st2, dles, s); break;
      default:
        exp_to_c(nv,e);
        // cast to void* if necessary
        if (is_poly_field(struct_type,f))
          e = cast_exp(void_star_typ(),e,DL);
        // FIX: deal with nested arrays and comprehensions
        s = seq_stmt(exp_stmt(assign_exp(lval, e, DL), DL), s, DL);
        break;
      }
      break;
    default: toc_impos("array designator in struct");
    }
  }
  return s;
}

// Would be nice to share more code with init_struct
// but the designators get in the way.
static exp_t init_tuple(env_t nv, bool pointer, 
                        exp_opt_t rgnopt, list_t<exp_t> es) {
  // $(e1,...,en)  -> ({ t x;   x.f1 = e1; ... x.fn = en; x})
  // &$(e1,...,en) -> ({ t * x=malloc(sizeof(t); x->f1 = e1; ... x->fn = en; x})
  region r {
    let tqs = List::rmap(r,tup_to_c,es);
    let n   = add_tuple_type(tqs);
    
    let x    = temp_var();
    let xexp = var_exp(x,DL);
    let s    = exp_stmt(xexp,DL);

    let lval_f = pointer ? aggrarrow_exp : aggrmember_exp;

    bool is_atomic = true;
    let es = List::rrev(r,es);
    for (int i = length(es); es != NULL; es = es->tl, --i) {
      exp_t e = es->hd;
      exp_t lval = lval_f(xexp, fieldname(i), DL);
      is_atomic = is_atomic && atomic_typ(e->topt->v);
      switch (e->r) {
      case &Array_e(dles):
        s = init_array(nv, lval, dles, s);
        break;
      case &Comprehension_e(vd,e1,e2):
        s = init_comprehension(nv, lval, vd, e1, e2, s, false);
        break;
        // FIX: deal with comprehensions
      default:
        exp_to_c(nv,e);
        s = seq_stmt(exp_stmt(assign_exp(lval_f(xexp,fieldname(i),
                                                DL),e, DL), DL), s, DL);
        break;
      }
    }
    return make_struct(nv,x,strct(n),s,pointer,rgnopt,is_atomic);
  }
}

static exp_t init_struct(env_t nv, type_t struct_type, bool has_exists,
                         bool pointer, exp_opt_t rgnopt, 
                         list_t<$(list_t<designator_t>,exp_t)@> dles, 
                         typedef_name_t tdn) {
  let x    = temp_var();
  let xexp = var_exp(x,DL);
  let s    = exp_stmt(xexp,DL);

  let lval_f = pointer ? aggrarrow_exp : aggrmember_exp;

  bool is_atomic = true;
  aggrdecl_t ad;
  switch(compress(struct_type)) {
  case &AggrType(AggrInfo(info,_)): ad = get_known_aggrdecl(info); break;
  default: toc_impos("init_struct: bad struct type");
  }

  region r {
    for(let es = List::rrev(r,dles); es != NULL; es = es->tl) {
      let &$(ds,e) = es->hd;
      is_atomic = is_atomic && atomic_typ(e->topt->v);
      if(ds == NULL)
        toc_impos("empty designator list");
      if(ds->tl != NULL) {
        // untested
        // JGM: I don't understand this code
        let y    = temp_var();
        let yexp = var_exp(y,DL);
        for(; ds != NULL; ds = ds->tl)
          switch (ds->hd) {
          case &FieldName(f):
            // cast to void* if necessary
            if (is_poly_field(struct_type,f))
              yexp = cast_exp(void_star_typ(),yexp,DL);
            s = seq_stmt(exp_stmt(assign_exp(lval_f(xexp,f,DL), yexp, DL), DL),
                         s, DL);
            break;
          default: toc_impos("array designator in struct");
          }
        // FIX:  need to deal with nested arrays, comprehensions, etc.
        exp_to_c(nv,e);
        s = seq_stmt(exp_stmt(assign_exp(yexp, e, DL), DL), s, DL);
      } else
        switch (ds->hd) {
        case &FieldName(f):
          exp_t lval = lval_f(xexp,f,DL);
          switch (e->r) {
          case &Array_e(dles):
            s = init_array(nv, lval, dles, s); break;
          case &Comprehension_e(vd,e1,e2):
            s = init_comprehension(nv, lval, vd, e1, e2, s, false); break;
          case &AnonStruct_e(st,dles):
            s = init_anon_struct(nv, lval, st, dles, s); break;
          default:
	    bool was_ptr_type = is_pointer_type(e->topt->v);
            exp_to_c(nv,e);
            // cast to void* to vaoid gcc warnings (does it more than needed)
	    if (is_poly_field(struct_type,f) && !was_ptr_type)
	      e = cast_exp(void_star_typ(),e,DL);
	    // more warning avoidance -- watch out if existentials are common
	    if(has_exists)
	      e = cast_exp(lookup_decl_field(ad,f)->type,e,DL);
            // FIX: deal with nested arrays and comprehensions
            s = seq_stmt(exp_stmt(assign_exp(lval, e, DL), DL), s, DL);
            break;
          }
          break;
        default: toc_impos("array designator in struct");
        }
    }
    return make_struct(nv, x, strctq(tdn), s, pointer, rgnopt, is_atomic);
  }
}

// functions for passing to lvalue_assign (see below)
static exp_t assignop_lvalue(exp_t el, $(opt_t<primop_t,`H>,exp_t)@ pr) {
  return assignop_exp(el,(*pr)[0],(*pr)[1],DL);
}
static exp_t address_lvalue(exp_t e1, bool ignore) {
  return address_exp(e1,DL);
}
static exp_t incr_lvalue(exp_t e1, incrementor_t incr) {
  return new_exp(new Increment_e(e1,incr),DL);
}

static void lvalue_assign_stmt(stmt_t s,list_t<field_name_t> fs,
			       exp_t f(exp_t,`a), `a f_env);
// e1 is the result of translating an lvalue.  fs is the path of struct
// fields that we're assigning to on e1 (if any).  The translation
//  may have inserted NULL checks, etc., but buried within e1 is an lvalue.
// We find the underlying lvalue, call it el.
// We replace el in e1 with f(el,env)
// We assume that variables in f(el,env) will not be captured by any
static void lvalue_assign(exp_t e1, list_t<field_name_t> fs, 
			  exp_t f(exp_t,`a), `a f_env){
  switch (e1->r) {
  case &StmtExp_e(s): lvalue_assign_stmt(s,fs,f,f_env); break;
  case &Cast_e(t,e):  lvalue_assign(e,fs,f,f_env); break;
  case &AggrMember_e(e,fld):
    // Hack: strip off the struct member -- the base case adds it back in.
    e1->r = e->r;
    lvalue_assign(e1,new List(fld,fs),f,f_env);
    break;
  default:
    // Note: this may not be an lvalue b/c of &arr where arr has an array type.
    // WARNING: If the translation of lvalues changes, we may need to change
    //          how we find the "inner lvalue".
    // make a copy so we don't create a loop
    exp_t e1_copy = copy_exp(e1);
    // add the path back on to the expression
    for (; fs != NULL; fs = fs->tl)
      e1_copy = aggrmember_exp(e1_copy,fs->hd,e1_copy->loc);
    e1->r = f(e1_copy, f_env)->r;
    break;
  }
}
static void lvalue_assign_stmt(stmt_t s,list_t<field_name_t> fs, 
			       exp_t f(exp_t,`a), `a f_env) {
  switch (s->r) {
  case &Exp_s(e1):    lvalue_assign(e1,fs,f,f_env);      break;
    // we assume free vars of e2 are not captured by d
  case &Decl_s(d,s2): lvalue_assign_stmt(s2,fs,f,f_env); break;
  case &Seq_s(_,s2):  lvalue_assign_stmt(s2,fs,f,f_env); break;
  default: toc_impos("lvalue_assign_stmt: %s",stmt2string(s));
  }
}

// similar to map_c but flips order of arguments
static list_t<`b,`r2> rmap_2c(region_t<`r2> r2,`b f(`a,`c),`c env,
                               list_t<`a,`r1> x) {
  list_t<`b,`r2> result, prev;

  if (x == NULL) return NULL;
  result = rnew(r2) List(f(x->hd,env),NULL);
  prev = result;
  for (x=x->tl; x != NULL; x=x->tl) {
    prev->tl = rnew(r2) List(f(x->hd,env),NULL);
    prev = prev->tl;
  }
  return(result);
}
static list_t<`b> map_2c(`b f(`a,`c), `c env, list_t<`a,`r> x) {
  return rmap_2c(heap_region,f,env,x);
}

static $(list_t<designator_t>,exp_t)@ make_dle(exp_t e) {
  return new $(NULL,e);
}

static struct PtrInfo get_ptr_type(type_t t) {
  switch (compress(t)) {
  case &PointerType(p): return p;
  default: toc_impos("get_ptr_typ: not a pointer!");
  }
}

static void exp_to_c(env_t nv, exp_t e) {
  let r = e->r;
  if(e->topt == NULL)
    toc_impos("exp_to_c: no type for %s",exp2string(e));
  type_t old_typ = e->topt->v;
  switch (r) {
  case &Const_e(Null_c):
    // NULL translate to 0 unless a tagged array, then {0,0,0}, via runtime
    // call unless at top-level
    // note: we don't need the element type b/c the length is 0 (so we lie)
    // note: should share all these uint_exp(0,DL) things
    let zero = uint_exp(0,DL);
    if(is_tagged_pointer_typ(old_typ))
      if(nv->toplevel) 
	e->r = make_toplevel_tagged_arr(old_typ, zero, zero)->r;
      else
	e->r = fncall_exp(_tag_arr_e, list(zero,zero,zero), DL)->r;
    else
      e->r = signed_int_exp(0,DL)->r; 
    break;
  case &Const_e(_): break;
  case &Var_e(qv,b): 
    try e->r = Dict::lookup(nv->varmap,qv)->r;
    catch { case Dict::Absent:
       toc_impos("Can't find %s in exp_to_c, Var\n", qvar2string(qv));
    }
    break;
  case &UnknownId_e(qv): toc_impos("unknownid");
  case &Primop_e(p,es):
    // Save Cyclone types -- needed for pointer arith stuff
    let old_typs = List::map(get_cyc_typ,es);
    // Translate args
    List::iter_c(exp_to_c,nv,es);
    switch (p) {
    case Size:
      exp_t arg = es->hd;
      switch (compress(arg->topt->v)) {
      case &ArrayType(_,_,e2): e->r = e2->r;  break;
      case &PointerType(PtrInfo{elt_typ,_,nbl,_,bound}):
	switch(conref_def(bounds_one,bound)) {
	case Unknown_b: // retrieve (last_plus_one - curr) via runtime call
	  e->r = fncall_exp(_get_arr_size_e,
			    list(es->hd, 
				 sizeoftyp_exp(typ_to_c(elt_typ),DL)), DL)->r;
	  break;
	case &Upper_b(e2): 
          // careful! when this is a nullable pointer, the size might be 0
          if (conref_def(false,nbl)) {
            e->r = conditional_exp(arg,e2,uint_exp(0,DL),DL)->r;
          } else {
            e->r = e2->r; break; // compile-time evaluation
          }
	}
	break;
      default: 
	toc_impos("size primop applied to non-array %s (%s)",
                  typ2string(arg->topt->v),typ2string(arg->topt->v)); 
      }
      break;
    case Plus:
      // only translation is for tagged arrays:
      //   _tag_arr_plus(e1,sizeof(elt_typ),e2)
      // FIX: allow arithmetic on t ? types at top-level!
      type_t elt_typ = VoidType;
      if(is_tagged_pointer_typ_elt(old_typs->hd,&elt_typ)) {
	exp_t e1 = es->hd;
	exp_t e2 = es->tl->hd;
	e->r = fncall_exp(_tagged_arr_plus_e,
			  list(e1,sizeoftyp_exp(typ_to_c(elt_typ),DL),e2),
			  DL)->r;
      }
      break;
    case Minus:
      // only translation is for tagged arrays:
      // if e2 is not a tagged array, do just like plus of negation,
      // else result type is unsigned int, so subtract curr fields
      type_t elt_typ = VoidType;
      if(is_tagged_pointer_typ_elt(old_typs->hd,&elt_typ)) {
	exp_t e1 = es->hd;
	exp_t e2 = es->tl->hd;
	if(is_tagged_pointer_typ(old_typs->tl->hd)) {
	  e1->r = aggrmember_exp(new_exp(e1->r,DL),curr_sp,DL)->r;
	  e2->r = aggrmember_exp(new_exp(e2->r,DL),curr_sp,DL)->r;
	  e->r  = divide_exp(copy_exp(e),
			     sizeoftyp_exp(typ_to_c(elt_typ),DL),DL)->r;
	} else {
	  e->r = fncall_exp(_tagged_arr_plus_e,
			    list(e1,sizeoftyp_exp(typ_to_c(elt_typ),DL),
				 prim1_exp(Minus,e2,DL)), DL)->r;
	}
      }
      break;
    case Eq: 
    case Neq: 
    case Gt: 
    case Gte: 
    case Lt: 
    case Lte: 
      // need to extract .curr field of tagged arrays for comparisons
      exp_t e1 = es->hd;
      exp_t e2 = es->tl->hd;
      type_t t1 = old_typs->hd;
      type_t t2 = old_typs->tl->hd;
      if (is_tagged_pointer_typ(t1))
	e1->r = aggrmember_exp(new_exp(e1->r,DL),curr_sp,DL)->r;
      if (is_tagged_pointer_typ(t2))
	e2->r = aggrmember_exp(new_exp(e2->r,DL),curr_sp,DL)->r;
      break;
    default: break; //skip
    }
    break;
  case &Increment_e(e2,incr):
    type_t e2_cyc_typ = e2->topt->v;
    exp_to_c(nv,e2);
    // only t ? types are translated funny, note that e2 is an lvalue!
    type_t elt_typ = VoidType;
    if(is_tagged_pointer_typ_elt(old_typ,&elt_typ)) {
      // eg. x++ becomes _tagged_arr_inplace_plus_post(&x,sizeof(elt_typ),1)
      let fn_e =
	(incr==PostInc || incr==PostDec) ? _tagged_arr_inplace_plus_post_e
	                                 : _tagged_arr_inplace_plus_e;
      let change = (incr==PreInc || incr==PostInc) ? 1 : -1;
      e->r = fncall_exp(fn_e, list(address_exp(e2,DL),
				   sizeoftyp_exp(typ_to_c(elt_typ),DL),
				   signed_int_exp(change,DL)), DL)->r;
    }
    if(elt_typ == VoidType && !is_lvalue(e2)) {
      lvalue_assign(e2,NULL,incr_lvalue,incr);
      e->r = e2->r;
    }
    break;
  case &AssignOp_e(e1,popt,e2):
    // FIX: not sure all these special-cases work right *together*
    // See if e1 is a polymorphic field (i.e., is an instantiated type
    // variable) -- if so, coerce e2 to void*.
    bool e1_poly    = is_poly_project(e1);
    type_t  e1_old_typ = e1->topt->v;
    type_t  e2_old_typ = e2->topt->v;
    exp_to_c(nv,e1); 
    exp_to_c(nv,e2);
    // special case for pointer arithmetic of t ? types
    bool done = false;
    if(popt != NULL) {
      type_t elt_typ = VoidType;
      if(is_tagged_pointer_typ_elt(old_typ,&elt_typ)) {
	_ change;
	switch(popt->v) {
	case Plus:  change = e2; break;
	case Minus: change = prim1_exp(Minus,e2,DL); break;
	default:    toc_impos("bad t ? pointer arithmetic");
	}
	done = true;
	// FIX: Is e1 definitely still an lvalue? Probably not!!
	e->r = fncall_exp(_tagged_arr_inplace_plus_e,
			  list(address_exp(e1,DL),
			       sizeoftyp_exp(typ_to_c(elt_typ),DL),
			       change), DL)->r;
      }
    }
    if(!done) {
      // this cast is necessary to avoid gcc warnings
      if (e1_poly) 
	e2->r = cast_exp(void_star_typ(), new_exp(e2->r, DL), DL)->r;
      // The typechecker guarantees that e1 starts out as an lvalue, but
      // the translation might have to insert casts, NULL checks,
      // declarations of temps, bound checks, etc.  If so we look into e1,
      // find the lvalue, and put the assignment there.
      if (!is_lvalue(e1)) {
	lvalue_assign(e1,NULL,assignop_lvalue,new{$(popt,e2)});
	e->r = e1->r;
      }
    }
    break;
  case &Conditional_e(e1,e2,e3):
    exp_to_c(nv,e1);
    exp_to_c(nv,e2);
    exp_to_c(nv,e3);
    break;
  case &SeqExp_e(e1,e2):
    exp_to_c(nv,e1);
    exp_to_c(nv,e2);
    break;
  case &UnknownCall_e(e1,es): fallthru(e1,es);
  case &FnCall_e(e1,es,NULL):
    exp_to_c(nv,e1);
    List::iter_c(exp_to_c,nv,es);
    break;
  case &FnCall_e(e1,es,&VarargCallInfo{num_varargs,injectors,vai}):
    // if vai->inject:
    //    t vn = injector[n](es[n])
    //    ...
    //    t v0 = injector[0](es[n-num_varargs+1])
    //    t argv[num_varargs] = {&v0, ..., &vn};
    // else
    //    t argv[num_varargs] = {es[n-num_varargs+1], ..., es[n]};
    // e1(es[0], ..., es[n-num_varargs], tag_arr(argv, sizeof(t), num_varargs));
    region r {
      qvar_t argv     = temp_var();
      exp_t  argvexp  = var_exp(argv,DL);
      exp_t  num_varargs_exp = uint_exp(num_varargs,DL);
      type_t cva_type = typ_to_c(vai->type);
      type_t arr_type = new ArrayType(cva_type,mt_tq,num_varargs_exp);

      int num_args     = List::length(es);
      int num_normargs = num_args - num_varargs;

      // build argument list and set es to the varargs portion
      list_t<exp_t> new_args = NULL;
      for(int i=0; i < num_normargs; ++i, es=es->tl) {
	exp_to_c(nv,es->hd);
	new_args = new List(es->hd, new_args);
      }
      new_args = new List(fncall_exp(_tag_arr_e, 
				     list(argvexp, 
					  sizeoftyp_exp(cva_type,DL), 
					  num_varargs_exp), DL),
			  new_args);
      new_args = imp_rev(new_args);
      // make the function call
      exp_to_c(nv,e1);
      stmt_t s = exp_stmt(fncall_exp(e1,new_args,DL),DL);
     
      // make the declarations and prepend them
      if(vai->inject) {
	tuniondecl_t tud;
	switch(compress(vai->type)) {
	case &TunionType(TunionInfo(&KnownTunion(&x),_,_)): tud = x; break;
	default: toc_impos("toc: unknown tunion in vararg with inject");
	}
	qvar_t ?`r vs = rnew(r) {for i < num_varargs : temp_var()};
	// declare argv = {&v1,&v2,...,&vnum_varargs}
	let array_args = NULL;
	for(int i=num_varargs-1; i >= 0; --i)
	  array_args = new List(make_dle(address_exp(var_exp(vs[i],DL),DL)),
				array_args);
	s = declare_stmt(argv, arr_type, unresolvedmem_exp(NULL,array_args,DL),
			 s,DL);
	// evaluate varargs (notice we're using a screwy evaluation order now)
	for (int i=0; es != NULL; es = es->tl, injectors = injectors->tl, ++i) {
	  exp_t  arg      = es->hd;
	  type_t arg_type = arg->topt->v;
	  qvar_t var      = vs[i];
	  exp_t  varexp   = var_exp(var,DL);
          let &Tunionfield{qv,tqts,_,_} = injectors->hd;
          type_t field_typ = typ_to_c((*tqts->hd)[1]);
	  exp_to_c(nv,arg);
          if (is_void_star(field_typ))
            arg = cast_exp(field_typ,arg,DL);
	  // DAN: We don't use an initializer b/c we're afraid of the GCC bug,
	  //   but I doubt it would happen and it causes a lot of gunk. :-(
          // struct qv_tag temp x;
          // x.tag = i; 
	  // x.f1  = arg;
          s = seq_stmt(assign_stmt(aggrmember_exp(varexp,fieldname(1),DL),
				   arg,DL),
		       s,DL);
          s = seq_stmt(assign_stmt(aggrmember_exp(varexp,tag_sp,DL),
				   tunion_tag(tud,qv,true),DL),
		       s,DL);
          s = declare_stmt(var,strctq(collapse_qvar_tag(qv,"_struct")), NULL,
			   s,DL);
        }
      } else {
	// we'd like: argv = { e1, ..., en} where ei is the ith vararg, but
	// alas I hit the GCC BUG when I did that (in one place in the 
	// pretty printer -- everything else went through fine).  So we do:
	// t argv[n];
	// argv[0] = e1; ... argv[n-1] = en;
	// Sigh.
	for(int i=0; es != NULL; es = es->tl, ++i) {
	  exp_to_c(nv, es->hd);
	  s = seq_stmt(assign_stmt(subscript_exp(argvexp,uint_exp(i,DL),DL),
				   es->hd, DL),
		       s, DL);
	}
	s = declare_stmt(argv, arr_type, NULL, s, DL);
	/*	list_t<exp_t,`r> array_args = NULL;
	for(; es != NULL; es = es->tl) {
	  exp_to_c(nv, es->hd);
	  array_args = rnew(r) List(es->hd, array_args);
	}
	array_args = List::imp_rev(array_args);
	let init = unresolvedmem_exp(NULL,List::map(make_dle,array_args),DL);
	s = declare_stmt(argv, arr_type, init,
			 s,DL);
	*/
      }
      
      e->r = stmt_exp(s,NULL)->r;                         
    }
    break; 
  case &Throw_e(e1):
    // throw e -> (t)(throw(e)), the latter being a function call to throw
    exp_to_c(nv,e1);
    e->r = array_to_ptr_cast(typ_to_c(old_typ),newthrow_exp(e1),DL)->r;
    break;
  case &NoInstantiate_e(e1): exp_to_c(nv,e1); break;
  case &Instantiate_e(e1,ts):
    exp_to_c(nv,e1);
    // only cast when the instantiation has type variables,
    // you can cast other times, but you'll spit out much more C code.
    // Note: we don't bother to cast if type is void * anyway (b/c that's
    //       what type variables get translated to)
    // Note: we could be even more aggressive -- often the instantiated types
    //  don't show up in the translated type.  Moreover, we probably don't
    //  get warnings when the only use of the tyvar is as a parameter b/c
    //  it's just an implicit cast to void * (so long as inst type isn't int)
    for(; ts != NULL; ts = ts->tl) {
      kind_t k = typ_kind(ts->hd);
      if(k != EffKind && k != RgnKind) {
	switch(compress(ts->hd)) {
	case &VarType(_):    
	case &TunionType(_): continue;
	default: 
	  e->r = array_to_ptr_cast(typ_to_c(e->topt->v),e1,DL)->r;
	  break;
	}
	break;
      }
    }
    break;
  case &Cast_e(*t,e1):
    type_t old_t2  = e1->topt->v;
    type_t new_typ = *t;
    *t = typ_to_c(new_typ);
    exp_to_c(nv, e1);
    // a few Cyclone casts are translated into C effects other than casts:
    switch ($(compress(old_t2),compress(new_typ))) {
    case $(&PointerType(p1),&PointerType(p2)):
      let n1 = conref_def(false,p1.nullable);
      let n2 = conref_def(false,p2.nullable);
      let b1 = conref_def(bounds_one,p1.bounds);
      let b2 = conref_def(bounds_one,p2.bounds);
      switch($(b1,b2)) {
      case $(&Upper_b(_), &Upper_b(_)):
	if(n1 && !n2) {
	  if(nv->toplevel)
	    unimp("can't do NULL-check conversion at top-level");
	  // cast from t* to t@ -- run-time check: (t*)_check_null(e)
	  // flow analysis may not set annotation correctly here!
	  e->r = cast_exp(*t,fncall_exp(_check_null_e,
					new List(e1,NULL),DL),DL)->r;
	}
	break;
      case $(&Upper_b(e2), Unknown_b):
	if(nv->toplevel)
	  // can't use a function at top-level and don't want macros
	  e->r = make_toplevel_tagged_arr(old_t2,e2,e1)->r;
	else
	  // cast from t*{n} or t@{n} to t ? -- build the t ? struct
	  e->r = fncall_exp(_tag_arr_e,
			    list(e1, sizeoftyp_exp(typ_to_c(p2.elt_typ),DL),
				 e2), DL)->r;
	break;
      case $(Unknown_b, &Upper_b(e2)):
	if(nv->toplevel)
	  unimp("can't coerce t? to t* or t@ at the top-level");
	// cast from t ? to t* or t@ -- run-time check: 
	// for t*: (t *)_untag_arr(e1, sizeof(t), e2)
	// for t@: (t *)_check_null(_untag_arr(e1, sizeof(t), e2))
	let ptr_exp = fncall_exp(_untag_arr_e,
				 list(e1,sizeoftyp_exp(typ_to_c(p1.elt_typ),DL),
				      e2), DL);
	if(n2)
	  ptr_exp->r = fncall_exp(_check_null_e,
				  new List(copy_exp(ptr_exp), NULL), DL)->r;
	e->r = cast_exp(*t, ptr_exp, DL)->r;
	break;
      default: break;
      }
      break;
    case $(&PointerType(p1), &IntType(_,_)):
      switch(conref_def(bounds_one,p1.bounds)) {
      case Unknown_b: // cast t? to int -- cast curr field to int
	e1->r = aggrmember_exp(new_exp(e1->r,e1->loc),curr_sp,DL)->r; break;
      default: break;
      }
      break;
    default: break;
    }
    break;

  case &Address_e(e1):
    // When e1 is a struct or a tuple, this is really a "new".
    switch (e1->r) {
    case &Struct_e(tdn,ts,es,_):
      if (nv->toplevel)
	unimp("%s: & on non-identifiers at the top-level",
              Position::string_of_segment(e1->loc));
      e->r = init_struct(nv, e1->topt->v, ts != NULL, true, NULL, es, tdn)->r;
      break;
    case &Tuple_e(es):
      if (nv->toplevel)
	unimp("%s: & on non-identifiers at the top-level",
              Position::string_of_segment(e1->loc));
      e->r = init_tuple(nv, true, NULL, es)->r;
      break;
    default: // it's actually an address-of.
      exp_to_c(nv,e1);
      if(!is_lvalue(e1)) {
	lvalue_assign(e1,NULL,address_lvalue,true);
	// the wrong cast got pushed out, so as a kludge, just re-cast
	e->r = cast_exp(typ_to_c(e->topt->v),e1,DL)->r;
      }
      break;
    }
    break;
  case &New_e(rgnopt,e1):
    if (nv->toplevel)
      unimp("%s: new at top-level", Position::string_of_segment(e1->loc));
    switch (e1->r) {
    case &Array_e(dles0):
      // FIX: MAY BE SUSCEPTIBLE TO GCC BUG!
      // ({ t *x = (t*)(malloc(sizeof(t)*length(dles0)));
      //    x[d1] = e1; ... x[dn] = en; x; })
      let x = temp_var();
      let xexp = var_exp(x,DL);
      let s = init_array(nv, xexp, dles0, exp_stmt(xexp,DL));
      type_t old_elt_typ;
      switch (compress(old_typ)) {
      case &PointerType(PtrInfo{et,_,_,tq,_}):
	old_elt_typ = et; break;
      default:
	old_elt_typ =
          toc_impos("exp_to_c:new array expression doesn't have ptr type");
      }
      type_t elt_typ=typ_to_c(old_elt_typ);
      let ptr_typ = cstar_typ(elt_typ,mt_tq);
      let e2 = times_exp(sizeoftyp_exp(elt_typ,DL),
                         signed_int_exp(List::length(dles0),DL),DL);
      exp_t e1;
      if (rgnopt == NULL) {
        e1 = malloc_exp(old_elt_typ,e2);
      } else {
        exp_t r = (exp_t)rgnopt;
        exp_to_c(nv,r);
        e1 = rmalloc_exp(r,e2);
      }
      //      let e0 = cast_exp(ptr_typ,e1,DL);
      e->r = stmt_exp(declare_stmt(x,ptr_typ,e1,s,DL),DL)->r;
      break;

    case &Comprehension_e(vd,e1,e2):
      // Drop the "tagged_ptr_t" struct stuff when type is a fixed-size array
      // ({ unsigned int max = e1;
      //    t *a = (t*)malloc(sizeof(t)*max);
      //    struct tagged_arr b = _tag_arr(a);
      //    unsigned int x ;
      //    for (x = 0; x < max; x++) a[x] = e2;
      //    b; })
      bool is_tagged_ptr = false;
      switch (compress(old_typ)) {
      case &PointerType(PtrInfo{et,_,_,tq,b}):
        is_tagged_ptr = (conref_def(bounds_one,b) == Unknown_b);
        break;
      default: toc_impos("exp_to_c: comprehension not an array type");
      }
      qvar_t max = temp_var();
      qvar_t a = temp_var();
      type_t old_elt_typ = e2->topt->v;
      type_t elt_typ = typ_to_c(old_elt_typ);
      type_t ptr_typ = cstar_typ(elt_typ,mt_tq);
      exp_to_c(nv,e1);
      stmt_t s = init_comprehension(nv, var_exp(a,DL), vd, var_exp(max,DL), 
                                    e2, skip_stmt_dl(), true);
      // FIX:  casts needed on exp_opts
      region r {
        list_t<$(qvar_t,type_t,exp_opt_t)@`r,`r> decls = 
          rnew(r) List(rnew(r) $(max,uint_typ,(exp_opt_t)e1),NULL);
        exp_t ai;
        if (rgnopt == NULL)
          ai = malloc_exp(old_elt_typ,
			  fncall_exp(_check_times_e,
				     list(sizeoftyp_exp(elt_typ,DL),
					  var_exp(max,DL)), DL));
        else {
          exp_t r = (exp_t)rgnopt;
          exp_to_c(nv,r);
          ai = rmalloc_exp(r, fncall_exp(_check_times_e,
					 list(sizeoftyp_exp(elt_typ,DL),
					      var_exp(max,DL)), DL));

        }
        exp_t ainit = cast_exp(ptr_typ,ai,DL);
        decls = rnew(r) List(rnew(r) $(a,ptr_typ,(exp_opt_t)ainit),decls);
        if (is_tagged_ptr) {
          let b = temp_var();
          let t = typ_to_c(old_typ);
          let binit = 
	    fncall_exp(_tag_arr_e,
		       list(var_exp(a,DL), sizeoftyp_exp(elt_typ, DL), e1), DL);
          decls = rnew(r) List(rnew(r) $(b,t,(exp_opt_t)binit),decls);
          s = seq_stmt(s,exp_stmt(var_exp(b,DL),DL),DL);
        } else // not a tagged array -- just return a
          s = seq_stmt(s,exp_stmt(var_exp(a,DL),DL),DL);
        for (let ds = decls; ds != NULL; ds = ds->tl) {
          let $(d0,d1,d2) = *(ds->hd);
          s = declare_stmt(d0,d1,d2,s,DL);
        }
        e->r = stmt_exp(s,DL)->r;
      }
      break;
    case &Struct_e(tdn,ts,es,_):
      // try to avoid the GCC bug
      e->r = init_struct(nv, e1->topt->v, ts != NULL, true, rgnopt, es, tdn)->r;
      break;
    case &Tuple_e(es):
      // try to avoid the GCC bug
      e->r = init_tuple(nv, true, rgnopt, es)->r;
      break;
    default:
      // treated just like an array of size 1
      // FIX: MAY BE SUSCEPTIBLE TO GCC BUG!
      // ({ t *x = (t*)(malloc(sizeof(t)));
      //    x[0] = e1; x; })
      type_t old_elt_typ = e1->topt->v;
      type_t elt_typ = typ_to_c(old_elt_typ);
      // build up the malloc expression: (t *)(malloc(sizeof(t)))
      let x = temp_var();
      let xexp = var_exp(x,DL);
      exp_t mexp = sizeofexp_exp(deref_exp(xexp,DL),DL);
      exp_t inner_mexp = mexp;
      if (rgnopt == NULL) 
        mexp = malloc_exp(old_elt_typ,mexp);
      else {
        exp_t r = (exp_t)rgnopt;
        exp_to_c(nv,r);
        mexp = rmalloc_exp(r,mexp);
      }
      //      mexp = cast_exp(cstar_typ(elt_typ,mt_tq),mexp,DL);
      // For tagged arrays, I have gotten burned by the GCC BUG 
      // (they're structs), so we special-case it right here
      // I HAVE NO IDEA IF I'M CATCHING ENOUGH CASES.
      bool done = false;
      switch(e1->r) {
      case &Cast_e(t2,e2):
	switch($(compress(t2),compress(e2->topt->v))) {
	case $(&PointerType(PtrInfo(arr_typ,_,_,_,bc)),
	       &PointerType(PtrInfo(_,_,_,_,be))):
	  switch($(conref_def(bounds_one,bc),conref_def(bounds_one,be))) {
	  case $(Unknown_b,&Upper_b(arr_sz)):
	    exp_to_c(nv,e2);
	    inner_mexp->r = sizeoftyp_exp(elt_typ,DL)->r;
	    done = true;
	    e->r = fncall_exp(_init_tag_arr_e,
			      list(mexp, e2,
				   sizeoftyp_exp(typ_to_c(arr_typ),DL),arr_sz),
			      DL)->r;
	    break;
	  default: break;
	  }
	break;
	default: break;
	}
	break;
      default: break;
      }
      if(!done) {
	let s = exp_stmt(xexp,DL);
	let e_index = signed_int_exp(0,DL);
	exp_to_c(nv,e1);
	s = seq_stmt(assign_stmt(subscript_exp(xexp,e_index,DL),
				 e1,DL),s,DL);
	let ptr_typ = cstar_typ(elt_typ,mt_tq);
	e->r = stmt_exp(declare_stmt(x,ptr_typ,mexp,s,DL),DL)->r;
      }
      break;
    }
    break;
  case &Sizeofexp_e(e1): exp_to_c(nv,e1); break;
  case &Sizeoftyp_e(t):  e->r = new Sizeoftyp_e(typ_to_c_array(t));  break;
  case &Gentyp_e(_,_): toc_impos("__gen() in code generator"); 
  case &Offsetof_e(t,&StructField(n)): 
    e->r = new Offsetof_e(typ_to_c_array(t),new StructField(n)); break;
  case &Offsetof_e(t,&TupleIndex(n)): 
    switch(compress(t)) {
    case &AggrType(AggrInfo(info,_)):
      let ad = get_known_aggrdecl(info);
      if(ad->impl==NULL)
	toc_impos("struct fields must be known");
      fallthru(ad->impl->fields);
    case &AnonAggrType(_,fields):
      let nth_field = List::nth(fields,n);
      e->r = new Offsetof_e(typ_to_c_array(t),new StructField(nth_field->name));
      break;
    case &TupleType(_):
      e->r = new Offsetof_e(typ_to_c_array(t),new StructField(fieldname(n+1)));
      break;
    case &TunionFieldType(_):
      if(n == 0)
	e->r = new Offsetof_e(typ_to_c_array(t),new StructField(tag_sp));
      else
	e->r = new Offsetof_e(typ_to_c_array(t),new StructField(fieldname(n)));
      break;
    default: toc_impos("impossible type for offsetof tuple index");
    }
    break;
  case &Deref_e(e1):
    let e1_typ = compress(e1->topt->v);
    switch (e1_typ) {
    case &PointerType(PtrInfo{t2,rgn,cr,tq,b}):
      switch (conref_def(bounds_one,b)) {
      case &Upper_b(_):
	bool do_null_check = need_null_check(e1);
	exp_to_c(nv,e1);
	if (do_null_check) {
	  // *((t *)_check_null(e))
	  e->r = deref_exp(cast_exp(typ_to_c(e1->topt->v),
				    fncall_exp(_check_null_e,
					       new List(e1,NULL),DL),DL),DL)->r;
	}
	break;
      case Unknown_b:
	// do it as e1[0], could share all the 0's but who cares
	let ind_e = uint_exp(0,DL);
	ind_e->topt = new Opt(uint_typ);
	e->r = subscript_exp(e1, ind_e, DL)->r;
	exp_to_c(nv,e);
	break;
      }
      break;
    default: toc_impos("exp_to_c: Deref: non-pointer");
    }
    break;
  case &AggrMember_e(e1,f):
    exp_to_c(nv, e1);
    if(is_poly_project(e))
      e->r = array_to_ptr_cast(typ_to_c(e->topt->v),new_exp(e->r,DL),DL)->r;
    break;
  case &AggrArrow_e(e1,f):
    type_t e1typ = compress(e1->topt->v);
    bool do_null_check = need_null_check(e1);
    exp_to_c(nv, e1);
    bool is_poly = is_poly_project(e); // decide before mutating e
    let PtrInfo{ta,rgn,bcr,tq,b} = get_ptr_type(e1typ);
    switch (conref_def(bounds_one,b)) {
    case &Upper_b(esz):
      // the type-checker should've ensured the size is at least 1
      if (Evexp::eval_const_uint_exp(esz) < 1)
        impos("exp_to_c:  AggrArrow_e on pointer of size 0");
      if (do_null_check) {
	// ((t *)_check_null(e))->f
	e->r = aggrarrow_exp(cast_exp(typ_to_c(e1->topt->v),
				      fncall_exp(_check_null_e,
						 new List(e1,NULL),DL), DL),
			     f, DL)->r;
      }
      break;
    case Unknown_b:
      // ((ta1 *)_check_unknown_subscript(e1, sizeof(ta1), 0))->f
      type_t ta1 = typ_to_c_array(ta);
      e1->r = cast_exp(cstar_typ(ta1,tq),
		       fncall_exp(_check_unknown_subscript_e,
				  list(copy_exp(e1),
				       sizeoftyp_exp(ta1,DL),
				       uint_exp(0,DL)),
				  DL),DL)->r;
      break;
    }
    if(is_poly)
      e->r = array_to_ptr_cast(typ_to_c(e->topt->v),new_exp(e->r,DL),DL)->r;
    break;
  case &Subscript_e(e1,e2):
    let e1_typ = compress(e1->topt->v);
    //fprintf(stderr,"subscript %s:",exp2string(e));
    //CfFlowInfo::print_relns(relns); fprintf(stderr,"\n");
    //fprintf(stderr,"in_bnds = %s\n",in_bnds ? "true " : "false");
    // e1 could be a tuple or an array of various sorts
    switch (e1_typ) {
    case &TupleType(ts):
      // e1->fi  where i = e2+1
      exp_to_c(nv, e1);
      exp_to_c(nv, e2);
      unsigned int i = Evexp::eval_const_uint_exp(e2)+1;
      e->r = aggrmember_exp(e1,fieldname(i),DL)->r;
      break;
    case &PointerType(PtrInfo{ta,rgn,bcr,tq,b}):
      let relns = get_relns(e1);
      let in_bnds = check_bounds(relns,e1,e2);
      if(warn_bounds_checks && !in_bnds) 
	Tcutil::warn(e->loc,"bounds check necessary for %s", exp2string(e));
	
#ifdef BCE_DEBUG
      fprintf(stderr,"check bounds returned %s\n", in_bnds ? "true " : "false");
#endif
      exp_to_c(nv, e1);
      exp_to_c(nv, e2);
      total_bounds_checks++;
      switch (conref_def(bounds_one,b)) {
      case &Upper_b(esz):
	esz = uint_exp(Evexp::eval_const_uint_exp(esz),DL);
        bool possibly_null = conref_def(false,bcr);
	type_t ta1 = typ_to_c(ta);
	type_t ta2 = cstar_typ(ta1, tq);
        if (in_bnds)
	  bounds_checks_eliminated++;
	else if(possibly_null)
	  // *((ta2)_check_known_subscript_null(e1, esz, sizeof(ta), e2)
	  e->r = deref_exp(cast_exp(ta2,
				    fncall_exp(_check_known_subscript_null_e,
					       list(e1,esz,
						    sizeoftyp_exp(ta1,DL),
						    e2),DL),DL),
			   DL)->r;
	else
	  // e1[_check_known_subscript_notnull(esz,e2)]
	  e2->r = fncall_exp(_check_known_subscript_notnull_e,
			     list(esz,copy_exp(e2)),DL)->r;
	break;
      case Unknown_b:
	type_t ta1 = typ_to_c_array(ta);
        if (in_bnds) {
          // there's no need for a null-check here either because
          // a NULL ? pointer has size 0
          bounds_checks_eliminated++;
          e->r = subscript_exp(cast_exp(cstar_typ(ta1,tq),
                                        aggrmember_exp(e1,curr_sp,DL),DL),
                               e2,DL)->r;
        } else {
          // *((ta1 *) _check_unknown_subscript(e1, sizeof(ta1), e2))
          e->r = deref_exp(cast_exp(cstar_typ(ta1,tq),
                                    fncall_exp(_check_unknown_subscript_e,
                                               list(e1,sizeoftyp_exp(ta1,DL),
                                                    e2),DL),DL),
                           DL)->r;
        }
	break;
      }
      break;
    default: toc_impos("exp_to_c: Subscript on non-tuple/array/tuple ptr");
    }
    break;
  case &Tuple_e(es):
    if(!nv->toplevel)
      e->r = init_tuple(nv,false,NULL,es)->r;
    else {
      // At top-level use an initializer
      // $(e1,...,en) -> {e1,...,en}
      let tqs = List::map(tup_to_c,es);
      let n = add_tuple_type(tqs);
      list_t<$(list_t<designator_t,`H>,exp_t)@`H,`H> dles = NULL;
      for (int i = 1; es != NULL; es = es->tl, i++) {
	exp_to_c(nv,es->hd);
	dles = new List(new $(NULL,es->hd),dles);
      }
      dles = List::imp_rev(dles);
      e->r = unresolvedmem_exp(NULL,dles,DL)->r;
    }
    break;
  case &Array_e(dles0):
    // An array not under a "new" -- should only occur in initializer positions.
    // {e1,...,en}
    e->r = unresolvedmem_exp(NULL,dles0,DL)->r;
    for (let dles = dles0; dles != NULL; dles = dles->tl) {
      let &$(_,e) = dles->hd;
      exp_to_c(nv,e);
    }
    break;
  case &Comprehension_e(vd,e1,e2):
    // a comprehension not under a "new" -- should only be the case
    // when e1 is constant.  For now, e2 must be too...
    let sz = Evexp::eval_const_uint_exp(e1);
    exp_to_c(nv,e2);
    list_t<$(list_t<designator_t>,exp_t)@> es = NULL;
    // generate an "empty" array intializer to avoid giant arrays
    if (!is_zero(e2))
      for (unsigned int i = 0; i < sz; i++)
        es = new List(new $(NULL,e2),es);
    e->r = unresolvedmem_exp(NULL,es,DL)->r;
    break;
  case &Struct_e(tdn,ts,dles,sd):
    // Due to a GCC bug w.r.t. to nested designators, we expand this out
    // to ({ t temp; t.f1 = e1, ..., t.fn = en; t}).
    if(!nv->toplevel)
      e->r = init_struct(nv,old_typ,ts != NULL,false,NULL,dles,tdn)->r;
    else {
      // At top-level must create an initializer.  For MSVC, sort fields
      // and drop initializers (sorting okay b/c we're at top-level)
      if(sd == NULL)
	toc_impos("Struct_e: missing aggrdecl pointer");
      aggrdecl_t sd2 = (aggrdecl_t)sd;
      region rgn {
      let fields = Tcutil::resolve_struct_designators(rgn, e->loc, dles, 
                                                      sd2->impl->fields);
      // here is where we now sort
      let newdles = NULL;
      let sdfields = sd2->impl->fields;
      for(; sdfields!=NULL; sdfields=sdfields->tl)
	for (let fields2 = fields; fields2 != NULL; fields2 = fields2->tl) {
	  if((*fields2->hd)[0] == sdfields->hd) {
	    let &$(field,fieldexp) = fields2->hd;
	    let fieldtyp = field->type;
	    exp_to_c(nv,fieldexp);
	    if (is_void_star(fieldtyp))
	      fieldexp->r = cast_exp(void_star_typ(), 
				     new_exp(fieldexp->r,DL),DL)->r;
	    newdles = new List(new $(NULL,fieldexp), newdles);
	    break;
	  }
	}
      e->r = unresolvedmem_exp(NULL,imp_rev(newdles),DL)->r;
      }
    }
    break;
  case &AnonStruct_e(st,dles):
    list_t<aggrfield_t> fs;
    switch (compress(st)) {
    case &AnonAggrType(_,afs): fs = afs; break;
    default: toc_impos("anon struct has type %s",typ2string(st));
    }
    region rgn {
      let fields = Tcutil::resolve_struct_designators(rgn, e->loc, dles, fs);
      for (; fields != NULL; fields = fields->tl) {
        let &$(field,fieldexp) = fields->hd;
        let fieldtyp = field->type;
        exp_to_c(nv,fieldexp);
        if (is_void_star(fieldtyp))
          fieldexp->r = cast_exp(void_star_typ(),
				 new_exp(fieldexp->r,DL),DL)->r;
      }
      //for (let es = dles; es != NULL; es = es->tl)
      //  exp_to_c(nv,es->hd[1]);
      //FIX: this has GCC bug written all over it.
      e->r = unresolvedmem_exp(NULL,dles,DL)->r;
    }
    break;
  
  case &Tunion_e(NULL,tud,tuf):
    qvar_t qv = tuf->name;
    // non-value-carrying constructor
    exp_t tag_exp = tud->is_xtunion ? var_exp(qv,DL) : tunion_tag(tud,qv,false);
    e->r = tag_exp->r;
    break;
  case &Tunion_e(es,tud,tuf):
    let qv   = tuf->name;
    let tqts = tuf->typs;

    let x = temp_var();
    let xexp = var_exp(x,DL);
    let strct_typ = strctq(collapse_qvar_tag(qv,"_struct"));
    exp_t tag_exp = tud->is_xtunion ? var_exp(qv,DL) : tunion_tag(tud,qv,true);
    // we have to do this differently for the toplevel
    if (nv->toplevel) {
      // {i, e1, ... , en};
      list_t<$(list_t<designator_t,`H>,exp_t)@`H,`H> dles = NULL;
      for(; es != NULL; es = es->tl, tqts = tqts->tl) {
	exp_t cur_e = es->hd;
	type_t field_typ = typ_to_c((*tqts->hd)[1]);
	exp_to_c(nv,cur_e);
	if (is_void_star(field_typ))
	  cur_e = cast_exp(field_typ,cur_e,DL);
	dles = new List(new $(NULL,cur_e),dles);
      }
      dles = new List(new $(NULL,tag_exp),imp_rev(dles));
      e->r = unresolvedmem_exp(new Opt(collapse_qvar_tag(qv,"_struct")),
                               dles,DL)->r;
    } else {
      // value-carrying constructor
      // ({ struct qv_tag x; x.tag = i; x.f1 = e1; ...; x.fn = en; x; })
      // Due to GCC bug we can't just use a struct expression.
      let rev_assign =
	new List(assign_stmt(aggrmember_exp(xexp,tag_sp,DL), tag_exp, DL),
                 NULL);
      for (int i = 1; es != NULL; es = es->tl, i++, tqts = tqts->tl) {
	exp_t cur_e = es->hd;
	type_t field_typ = typ_to_c((*tqts->hd)[1]);
	exp_to_c(nv,cur_e);
	if (is_void_star(field_typ))
	  cur_e = cast_exp(field_typ,cur_e,DL);
	let a = assign_stmt(aggrmember_exp(xexp,fieldname(i), DL),
			    cur_e,DL);
	rev_assign = new List(a,rev_assign);
      }
      let final_stmt = exp_stmt(xexp,DL);
      let s2         = seq_stmts(imp_rev(new List(final_stmt,rev_assign)),DL);
      e->r = stmt_exp(declare_stmt(x,strct_typ,NULL,s2,DL),DL)->r;
    }
    break;

  case &Enum_e(_,_,_):
  case &AnonEnum_e(_,_,_): break;

  case &Malloc_e(MallocInfo{is_calloc,rgnopt,topt,num_elts,is_fat}): 
    type_t t_c = typ_to_c(*topt);
    exp_to_c(nv,num_elts);
    if (is_fat) {
      let x = temp_var();
      let p = temp_var();
      exp_t pexp, xexp, rexp;
      if (is_calloc) {
        xexp = num_elts;
        if (rgnopt != NULL) {
          exp_t rgn = (exp_t)rgnopt;
          exp_to_c(nv,rgn);
          pexp = rcalloc_exp(rgn, sizeoftyp_exp(t_c,DL), var_exp(x,DL));
        } else {
          pexp = calloc_exp(*topt,sizeoftyp_exp(t_c,DL), var_exp(x,DL));
        }
        rexp = fncall_exp(_tag_arr_e, list(var_exp(p,DL),sizeoftyp_exp(t_c,DL),
                                           var_exp(x,DL)), DL);
      } else {
        xexp = times_exp(sizeoftyp_exp(t_c,DL),num_elts,DL);
        if (rgnopt != NULL) {
          exp_t rgn = (exp_t)rgnopt;
          exp_to_c(nv,rgn);
          pexp = rmalloc_exp(rgn, var_exp(x,DL));
        } else { 
          pexp = malloc_exp(*topt, var_exp(x,DL));
        }
        rexp = fncall_exp(_tag_arr_e, list(var_exp(p,DL),uint_exp(1,DL),
                                           var_exp(x,DL)), DL);
      }
      let s = declare_stmt(x, uint_typ, xexp,
                           declare_stmt(p,cstar_typ(t_c,mt_tq),pexp,
                                        exp_stmt(rexp,DL),DL),DL);
      e->r = stmt_exp(s,DL)->r;
    } else {
      if (rgnopt != NULL) {
        exp_t rgn = (exp_t)rgnopt;
        exp_to_c(nv,rgn);
        e->r = rmalloc_exp(rgn, sizeoftyp_exp(t_c,DL))->r;
      } else {
        e->r = malloc_exp(*topt, sizeoftyp_exp(t_c,DL))->r;
      }
    }
    break;

  case &StmtExp_e(s): stmt_to_c(nv,s);  break;
  case &UnresolvedMem_e(_,_): toc_impos("UnresolvedMem"); 
  case &CompoundLit_e(_,_):   unimp("compoundlit");
  case &Codegen_e(fd):        unimp("codegen");
  case &Fill_e(_):            unimp("fill");
  }
}

// Translate a pattern generating tests which jump goes to fail_lab
// on unsuccessful match.
// Returns:
// * a new translation environment (mapping variables bound in the pattern
//   to temps generated)
// * a list of temps to be declared (along with their types.)
//   This list contains the decls parameter
// * The statement for actually doing the test.
//
// (The temps must be declared with a wide enough
// scope to cover the tests and any cases in a switch (hence the reason
// they're pulled out.  Also needed for translating fallthru.)
//
// xlate_pat(env,t,r,path,p,fail_lab)
//
//  r is the "root" variable that contains the value we're matching.
//  path is the address of this value -- used in the Reference pattern.
//  p is the pattern
//  we do nothing on successful match -- caller puts the right code next
//  fail_lab is where to go upon failure to match
//
// FIX: adapt the decision tree code in the type-checker so that we
// have much more efficient traversal of patterns.
//
// Note: Extra labels and gotos aren't a big deal b/c gcc -O collapses them.
//
// Warning: We end sharing the fail_exps -- they should be copied if they
//          might be mutated later!
static stmt_t if_neq_stmt(exp_t e1,exp_t e2,stmt_t fail_stmt) {
  return ifthenelse_stmt(neq_exp(e1,e2,DL),
			 fail_stmt,
			 skip_stmt_dl(),DL);
}
static $(env_t,list_t<$(qvar_t,type_t)@`rgn,`rgn>,stmt_t)
xlate_pat(env_t nv, region_t<`rgn> rgn, type_t t, exp_t r, exp_t path, pat_t p,
	  stmt_t fail_stmt, list_t<$(qvar_t,type_t)@`rgn,`rgn> decls) {
  stmt_t s; // the test statement
  switch (p->r) {
  case &Var_p(&Vardecl(_,x,_,_,_,_,_,_)):
    // in essence, x = r; but achieved through the varmap
    nv = add_varmap(nv,x,r);
    fallthru;
  case Wild_p: s = skip_stmt_dl(); break; // potentially wasteful
  case &Reference_p(vd):
    // v = path
    let v = temp_var();
    decls = rnew(rgn) List(rnew(rgn) $(v,cstar_typ(typ_to_c(t),mt_tq)),decls);
    nv    = add_varmap(nv,vd->name,var_exp(v,DL));
    // cast is needed to avoid a C warning when pointing to a polymorphic field
    s     = assign_stmt(var_exp(v,DL),
			cast_exp(cstar_typ(typ_to_c(t),mt_tq),
				 address_exp(path,DL),DL),DL);
    break;

  case Null_p:       s=if_neq_stmt(r,signed_int_exp(0,DL),fail_stmt); break;
  case &Int_p(sn,i): s=if_neq_stmt(r,int_exp(sn,i,DL),    fail_stmt); break;
  case &Char_p(c):   s=if_neq_stmt(r,char_exp(c,DL),      fail_stmt); break;
  case &Float_p(f):  s=if_neq_stmt(r,float_exp(f,DL),     fail_stmt); break;

  case &Enum_p(ed,ef): 
    s = if_neq_stmt(r,new_exp(new Enum_e(ef->name,ed,ef),NULL),fail_stmt); 
    break;
  case &AnonEnum_p(t2,ef):
    s = if_neq_stmt(r,new_exp(new AnonEnum_e(ef->name,t2,ef),NULL),fail_stmt); 
    break;

  case &Tunion_p(tud,tuf,NULL):
    // when ps == NULL:  if (r == tag) goto succ_lab else goto fail_lab;
    // Note: This should be correct for tunion and xtunion!
    exp_t cmp_exp;
    if(tud->is_xtunion)
      cmp_exp = var_exp(tuf->name,DL);
    else {
      cmp_exp = tunion_tag(tud,tuf->name,false);
      r = cast_exp(sint_typ,r,DL);
    }
    s = if_neq_stmt(r, cmp_exp, fail_stmt);
    break;

  case &Pointer_p(&Pat{&Tunion_p(tud,tuf,ps),_,_}) && ps != NULL:
    // when ps is p1,...,pn:
    //   if ((unsigned int)r > max_tag && ((t)r)->tag == qv_tag)
    //      <similar to tuple and struct patterns>
    //   else goto fail_lab
    // (no max tag check on xtunions)
    // FIX: When type is TunionField, can avoid all checks
    // It's unfortunate that we have to always check that r > max_tag.
    // If we had the decision tree information, we could avoid doing so.
    s = skip_stmt_dl();
    int    cnt      = 1;
    qvar_t tufstrct = collapse_qvar_tag(tuf->name,"_struct");
    exp_t  rcast    = cast_exp(cstar_typ(strctq(tufstrct),mt_tq),r,DL);
    let tuf_tqts = tuf->typs;
    for(; ps != NULL; ps = ps->tl, tuf_tqts = tuf_tqts->tl, ++cnt) {
      let p2  = ps->hd;
      if(p2->r == Wild_p)
	continue;
      let tuf_typ = (*tuf_tqts->hd)[1];
      let v   = temp_var();
      let t2  = p2->topt->v;
      let t2c = typ_to_c(t2);
      let arrow_exp = aggrarrow_exp(rcast, fieldname(cnt), DL);
      if(is_void_star(typ_to_c(tuf_typ)))
	arrow_exp = cast_exp(t2c, arrow_exp, DL);
      decls = rnew(rgn) List(rnew (rgn) $(v,t2c),decls);
      let result = xlate_pat(nv,rgn,t2,var_exp(v,DL), arrow_exp,
			     p2,fail_stmt,decls);
      nv = result[0];
      decls = result[1];
      let s3 = result[2];
      let s1 = assign_stmt(var_exp(v,DL), arrow_exp, DL);
      s = seq_stmt(s, seq_stmt(s1,s3,DL), DL);
    }
    exp_t test_exp;
    if(tud->is_xtunion) {
      exp_t e2 = cast_exp(cstar_typ(void_star_typ(),mt_tq), r,DL);
      exp_t e1 = deref_exp(e2,DL);
      exp_t e  = var_exp(tuf->name,DL);
      test_exp = neq_exp(e1,e,DL);
    } else {
      int max_tag = num_void_tags(tud);
      exp_t max_tag_exp = uint_exp(max_tag,DL);
      exp_t e3 = cast_exp(cstar_typ(sint_typ,mt_tq), r,DL);
      exp_t e1 = deref_exp(e3,DL);
      exp_t e5 = lte_exp(r, cast_exp(void_star_typ(),max_tag_exp,DL), DL);
      exp_t e  = tunion_tag(tud,tuf->name,true);
      test_exp = (max_tag>0)? or_exp(e5,neq_exp(e1,e,DL),DL) : neq_exp(e1,e,DL);
    }
    s = seq_stmt(ifthenelse_stmt(test_exp, fail_stmt, skip_stmt_dl(), DL),
		 s, DL);
    break;

  case &Tunion_p(_,_,ps): fallthru(ps); // okay for xtunion too
  case &Tuple_p(ps):
    // given the pattern $(p1,p2,...,pn)
    //    v1 = r->f1; if (matches(v1,p1)) goto L1 else goto fail_lab;
    // L1:v2 = r->f2; if (matches(v2,p2)) goto L2 else goto fail_lab;
    // L2:v3 = r->f3; if (matches(v3,p2)) goto L3 else goto fail_lab;
    //    ...
    // Ln-1:vn = r->fn; if (matches(vn,p2)) goto succ_lab else goto fail_lab;
    s = skip_stmt_dl(); // wasteful
    int cnt = 1;
    for(; ps != NULL; ps = ps->tl, ++cnt) {
      let p2  = ps->hd;
      if(p2->r == Wild_p)
	continue;
      let v   = temp_var();
      let t2  = p2->topt->v;
      decls = rnew(rgn) List(rnew(rgn) $(v,typ_to_c(t2)),decls);
      let result = xlate_pat(nv,rgn,t2,var_exp(v,DL),
                             aggrmember_exp(path,fieldname(cnt),DL),
			     p2,fail_stmt,decls);
      nv = result[0];
      decls = result[1];
      let s2 = result[2];
      let s3 = assign_stmt(var_exp(v,DL),
			   aggrmember_exp(r,fieldname(cnt),DL),DL);
      s = seq_stmt(s,seq_stmt(s3,s2,DL),DL);
    }
    break;
  case &Aggr_p(AggrInfo(info,_),_,dlps):
    let ad = get_known_aggrdecl(info);
    // similar to translation of tuple pattern
    s = skip_stmt_dl();
    for (; dlps != NULL; dlps = dlps->tl) {
      let tup = dlps->hd;
      let p2  = (*tup)[1];
      if(p2->r == Wild_p)
	continue;
      _ f;
      switch ((*tup)[0]->hd) {
        case &FieldName(f2): f=f2; break;
        default: throw Match_error; // FIX:  assumes one field name designator
      }
      let v   = temp_var();
      let t2  = p2->topt->v;
      let t2c = typ_to_c(t2);
      decls = rnew(rgn) List(rnew(rgn) $(v,t2c),decls);
      let result = xlate_pat(nv,rgn,t2,var_exp(v,DL),
                             aggrmember_exp(path,f,DL),p2,
                             fail_stmt,decls);
      nv = result[0];
      decls = result[1];
      let memexp = aggrmember_exp(r,f,DL);
      if(is_void_star(lookup_field(ad->impl->fields,f)->type))
	memexp = cast_exp(t2c, memexp, DL);
      let s2 = result[2];
      let s3 = assign_stmt(var_exp(v,DL), memexp, DL);
      s = seq_stmt(s, seq_stmt(s3,s2,DL), DL);
    }
    break;

  case &Pointer_p(p2):
    // if (r == 0) goto fail_lab; v = *r; match(v,p2);
    let v = temp_var();
    let t2 = p2->topt->v;
    decls = rnew(rgn) List(rnew(rgn) $(v,typ_to_c(t2)),decls);
    let result = xlate_pat(nv,rgn,t2,var_exp(v,DL),deref_exp(path,DL),p2,
			   fail_stmt,decls);
    nv = result[0];
    decls = result[1];
    let s2 = result[2];
    let s3 = seq_stmt(assign_stmt(var_exp(v,DL),deref_exp(r,DL),DL),s2,DL);
    if (is_nullable(t))
      s = seq_stmt(ifthenelse_stmt(eq_exp(r,signed_int_exp(0,DL),DL),
				   fail_stmt,
				   skip_stmt_dl(), DL),
		   s3,DL);
    else
      s = s3;
    break;
  case &UnknownId_p(_):     toc_impos("unknownid");
  case &UnknownCall_p(_,_): toc_impos("unknowncall");
  }
  return $(nv,decls,s);
}

///////////////////////////////////////////////////////////////
//              Translation of Switch Statements             //
///////////////////////////////////////////////////////////////
// FIX:  Should use decision tree stuff from tcpat.
//
// For performance, we try to leave switches as switches.  We do this when
// all of the following hold:
// * We are switching on a char or int type.
//   (Could also do tunion without value contructors, but we didn't pass in
//    access to the type definitions!)
// * No switch_clause has any variables. (reject switch(3) { case x: ... }
// The hitch is we could still have something like
//    switch(e) { case 0: if(b) fallthru; else return; }
// Therefore, we give each case body
// a fresh label so we can translate fallthru to goto.
// Then we just hope gcc cleans up the mess and can still use jump tables.
//
// For all other switches,
// switch (e) { case p1: s1 ... case pn:sn } turns into (roughly)
//
//  x = e;
//  <lots of temp declarations>
//    if !matches(p1,x) goto L2; L1: s1;
// L2:if !matches(p2,x) goto L4; L3: s2;
// L4:if !matches(p3,x) goto L4; L5: s3;
//     ...
// L2n: ; // destination of break within the original switch cases
// L2n-2:if matches(pn,x) goto L2n-1 else goto L2n;
// L1: s1;
// L3: s2;
// L5: s3;
// ...
// L2n-1: sn;
// L2n: ;
static $(var_t,var_t,switch_clause_t)@`r gen_label(region_t<`r> r,
                                                   switch_clause_t sc) {
  return rnew(r) $(fresh_label(),fresh_label(),sc);
}
static void xlate_switch(env_t nv, stmt_t whole_s, 
			 exp_t e, list_t<switch_clause_t> scs) {
  exp_to_c(nv,e);
  let t = e->topt->v;

  // decide if we can leave it as a switch
  // FIX: cannot have Float_p in any cases.
  bool leave_as_switch;
  switch (compress(t)) {
  case &IntType(_,_):  
  case &EnumType(_,_): leave_as_switch = true;  break;
  default:             leave_as_switch = false; break;
  }
  for(let scs1 = scs; scs1 != NULL; scs1 = scs1->tl)
    if(scs1->hd->pat_vars->v != NULL || scs1->hd->where_clause != NULL) {
      leave_as_switch = false;
      break;
    }
  if(leave_as_switch) {
    // note: fallthru in last case can't happen, else this is busted
    var_t next_l = fresh_label();
    for(let scs1 = scs; scs1 != NULL; scs1 = scs1->tl) {
      let s = scs1->hd->body;
      scs1->hd->body = label_stmt(next_l,s,DL);
      next_l = fresh_label();
      stmt_to_c(switch_as_switch_env(nv,next_l),s);
    }
    return;
  }
  // no dice, translate to a nest of gotos...
  qvar_t v     = temp_var();
  exp_t  r     = var_exp(v,DL);
  exp_t  path  = var_exp(v,DL);
  var_t  end_l = fresh_label();
  // for each case, generate a test label and an entry label
  region rgn {
    list_t<$(var_t,var_t,switch_clause_t)@`rgn,`rgn> lscs = 
      List::rmap_c(rgn,gen_label,rgn,scs);
    list_t<stmt_t,`rgn>                test_stmts = NULL;
    list_t<env_t,`rgn>                 nvs        = NULL;
    list_t<$(qvar_t,type_t)@`rgn,`rgn> decls      = NULL;
    // generate the tests for each case, continuing to the case's
    // label on success and to the next test on false.
    // do tests first so as to get vars for fallthrus
    // the last case is different b/c there's no fallthru so fake it with end_l
    for (let lscs2 = lscs; lscs2 != NULL; lscs2 = lscs2->tl) {
      switch_clause_t sc = (*lscs2->hd)[2];
      var_t fail_lab = (lscs2->tl == NULL) ? end_l : (*lscs2->tl->hd)[0];
      let $(nv2,decls2,test_stmt) = xlate_pat(nv,rgn,t,r,path,sc->pattern,
					      goto_stmt(fail_lab,DL),decls);
      if(sc->where_clause!=NULL) {
	let e = (exp_t)sc->where_clause;
	exp_to_c(nv2,e); // nv2 b/c pattern vars are in scope
	test_stmt = seq_stmt(test_stmt, ifthenelse_stmt(prim1_exp(Not,e,DL),
							goto_stmt(fail_lab,DL),
							skip_stmt_dl(), DL),DL);
      }
      decls = decls2;
      nvs = rnew(rgn) List(nv2,nvs);
      test_stmts = rnew(rgn) List(test_stmt,test_stmts);
    }
    nvs = List::imp_rev(nvs);
    test_stmts = List::imp_rev(test_stmts);
    list_t<stmt_t> stmts = NULL;
    // now generate all of the statements for the cases
    // note: first test_lab is unnecessary
    for (; lscs != NULL;
	 lscs = lscs->tl, nvs = nvs->tl, test_stmts = test_stmts->tl) {
      let &$(test_lab,body_lab,body_sc) = lscs->hd;
      let env = nvs->hd;
      stmt_t s = body_sc->body;
      if(lscs->tl != NULL) {
	let &$(_,fallthru_lab,next_sc) = lscs->tl->hd;
	stmt_to_c(non_last_switchclause_env(env, end_l, fallthru_lab,
					    next_sc->pat_vars->v, nvs->tl->hd),
		  s);
      } else
	stmt_to_c(last_switchclause_env(env, end_l), s);
      s = seq_stmt(label_stmt(test_lab,test_stmts->hd,DL),
		   label_stmt(body_lab,s,DL), DL);
      stmts = rnew(rgn) List(s, stmts);
    }
    stmt_t res = seq_stmt(seq_stmts(List::imp_rev(stmts),DL),
			  label_stmt(end_l, skip_stmt_dl(), DL), DL);
    // add in all of the variable declarations with a wide enough scope
    for (decls; decls != NULL; decls = decls->tl) {
      let &$(qv,t) = decls->hd;
      res = declare_stmt(qv, t, NULL, res, DL);
    }
    // add in the variable holding the test and clobber the abstract syntax
    whole_s->r = declare_stmt(v,typ_to_c(e->topt->v),e, res, DL)->r;
  }
}

// forward declarations
static stmt_t letdecl_to_c(env_t nv, pat_t p, type_t t, exp_t e, stmt_t s);
static void local_decl_to_c(env_t body_nv,env_t init_nv,vardecl_t vd,stmt_t s);

///////////////////////////////////////////////////////////////
//              Translation of Statements                    //
///////////////////////////////////////////////////////////////
stmt_t make_npop_handler(int n) {
  return exp_stmt(fncall_exp(_npop_handler_e,
			     new List(uint_exp(n-1,DL),NULL), DL), DL);
}
void do_npop_before(int n, stmt_t s) { // mutates s as necessary!
  if(n > 0)
    s->r = seq_stmt(make_npop_handler(n),new_stmt(s->r,DL),DL)->r;
}

static void stmt_to_c(env_t nv, stmt_t s) {
  // written to be self-tail recursive
  while (true) {
    switch (s->r) {
    case Skip_s:
      return;
    case &Exp_s(e):
      exp_to_c(nv, e);
      return;
    case &Seq_s(s1,s2):
      stmt_to_c(nv,s1);
      s = s2;
      continue;
    case &Return_s(eopt):
      opt_t<type_t> topt = NULL;
      if (eopt != NULL) {
	topt = new Opt(typ_to_c(eopt->topt->v));
	exp_to_c(nv,(exp_t)eopt);
      }
      // reset handler **after** evaluating expression
      if (s->try_depth > 0) 
	if (topt != NULL) {
	  let x = temp_var();
	  let retn_stmt = return_stmt(var_exp(x,DL),DL);
	  s->r = declare_stmt(x,topt->v, eopt,
			      seq_stmt(make_npop_handler(s->try_depth),
				       retn_stmt,DL),DL)->r;
	} else {
	  do_npop_before(s->try_depth,s);
	}
      return;
    case &IfThenElse_s(e,s1,s2):
      exp_to_c(nv,e);
      stmt_to_c(nv,s1);
      s = s2;
      continue;
    case &While_s($(e,_),s2):
      exp_to_c(nv,e);
      stmt_to_c(loop_env(nv),s2);
      return;
    case &Break_s(dest_opt): // dest is NULL when break to end of void function
      if (nv->break_lab != NULL)
	s->r = goto_stmt(nv->break_lab->v, DL)->r;
      // reset handler
      int dest_depth = dest_opt == NULL ? 0 : dest_opt->try_depth;
      do_npop_before(s->try_depth - dest_depth, s);
      return;
    case &Continue_s(dest):
      if (nv->continue_lab != NULL)
	s->r = goto_stmt(nv->continue_lab->v, DL)->r;
      fallthru(dest);
    case &Goto_s(_,dest): 
      // reset handler (note: earlier checks prevent jump into handler)
      do_npop_before(s->try_depth - dest->try_depth, s);
      return;
    case &For_s(e1,$(e2,_),$(e3,_),s2):
      // FIX:  should e3 be translated in nv?
      exp_to_c(nv,e1); exp_to_c(nv,e2); exp_to_c(nv,e3);
      stmt_to_c(loop_env(nv),s2);
      return;
    case &Switch_s(e,scs):
      xlate_switch(nv,s,e,scs);
      return;
    case &Fallthru_s(es,dest_clause):
      if(nv->fallthru_info == NULL)
	toc_impos("fallthru in unexpected place"); 
      let &$(l,vs,other_vmap) = nv->fallthru_info->v;
      stmt_t s2 = goto_stmt(l, DL);
      // reset handler (after the es evaluation)
      do_npop_before(s->try_depth - (*dest_clause)->body->try_depth, s2);
      let vs2 = List::rev(vs);
      let es2 = List::rev(es);
      for(; vs2 != NULL; vs2 = vs2->tl, es2 = es2->tl) {
	exp_to_c(nv,es2->hd);
	s2 = seq_stmt(assign_stmt(Dict::lookup(other_vmap,vs2->hd), es2->hd,DL),
		      s2,DL);
      }
      s->r = s2->r;
      return;
    case &Decl_s(d,s1):
      // we have to treat Let_d and Var_d where we bind a comprehension
      // (not at the top-level) specially because these have to return 
      // "statements".  See letdecl_to_c and decls_to_c below.
      switch (d->r) {
      case &Var_d(vd):
	let nv2 = add_varmap(nv,vd->name,varb_exp(vd->name,new Local_b(vd),DL));
	local_decl_to_c(nv2, nv2, vd, s1);
	break;
      case &Let_d(p,_,e):
        // Handle the special case where the pattern is a variable just like
	// a variable declaration, except variable's scope does NOT include e
        switch (p->r) {
        case &Var_p(vd):
	  qvar_t old_name = vd->name;
	  qvar_t new_name = temp_var();
	  vd->name = new_name;
          vd->initializer = e;
          d->r = new Var_d(vd);
	  let nv2 = 
	    add_varmap(nv,old_name,varb_exp(new_name,new Local_b(vd),DL));
	  local_decl_to_c(nv2, nv, vd, s1);
          break;
        default: 
	  // we treat let declarations specially because they may need
	  // statements in addition to declarations, so we splice them in
	  // as a statement.  Other declarations only produce declarations.
	  s->r = letdecl_to_c(nv, p, e->topt->v, e, s1)->r;
	  break;
        }
	break;
      case &Letv_d(vds):
        //let nv2 = nv;
        //for (; vds != NULL; vds = vds->tl) {
        //  let vd = vds->hd;
        //  let c_name = vd->name;
        //  vd->type = typ_to_c_array(vd->type);
        //  nv2 = add_varmap(nv2,c_name,varb_exp(c_name,new Local_b(vd),DL));
        //}
        //stmt_to_c(nv2,s1);

        // Transform Letv_d into a sequence of Var_d, and call stmt_to_c on
        // the result.
        let rvds = List::rev(vds);
        if (rvds == NULL)
          impos("empty Letv_d");
        d->r = new Var_d(rvds->hd);
        rvds = rvds->tl;
        for (; rvds != NULL; rvds = rvds->tl) {
          let d2 = new_decl(new Var_d(rvds->hd),DL);
          s->r = decl_stmt(d2,new_stmt(s->r,DL),DL)->r;
        }
        stmt_to_c(nv,s);
        break;
      default: impos("bad nested declaration within function");
      }
      return;
    case &Label_s(lab,s1):
      s = s1; continue;
    case &Do_s(s2,$(e,_)):
      stmt_to_c(loop_env(nv),s2);
      exp_to_c(nv,e);
      return;
    case &TryCatch_s(body,scs):
      // NOTE: Because explicit fallthru is not allowed in the last case,
      //       appending a new last case can't change the meaning of any
      //       control flow.
      // struct handler_cons h;
      // _push_handler(&h);
      // int was_thrown = 0; 
      // if (setjmp(h.handler)) was_thrown = 1;
      // if (!was_thrown) {
      //   body
      //   _pop_handler();
      // } else {
      //   exn e = (exn)_exn_thrown;
      //   switch (e) scs
      // }
      // [Auxillary functions are defined in runtime_cyc.c]
      qvar_t h_var = temp_var();
      qvar_t e_var = temp_var();
      qvar_t was_thrown_var = temp_var();
      exp_t  h_exp = var_exp(h_var,DL);
      exp_t  e_exp = var_exp(e_var,DL);
      exp_t  was_thrown_exp = var_exp(was_thrown_var,DL);
      type_t h_typ = strct(_handler_cons_sp);
      type_t e_typ = typ_to_c(exn_typ);
      type_t was_thrown_typ = typ_to_c(sint_typ);
      // e_exp needs a typ because it'll go through exp_to_c;
      // as well, it must be in varmap
      e_exp->topt = new Opt(e_typ);
      nv = add_varmap(nv,e_var,e_exp);

      // translate the body
      stmt_to_c(nv,body);
      let tryandpop_stmt = seq_stmt(body,
                                    exp_stmt(fncall_exp(_pop_handler_e, NULL,
                                                        DL), DL),DL);

      // add a default case which re-throws the exception
      let x    = temp_var();
      let xexp = var_exp(x,DL);
      let x_vd = new_vardecl(x,exn_typ,NULL);
      xexp->topt = new Opt(exn_typ);
      let p = new Pat{.r=new Var_p(x_vd), .topt=new Opt(exn_typ), .loc=DL};
      let te = throw_exp(xexp,DL);
      te->topt = new Opt(VoidType);
      let rs = exp_stmt(te,DL);
      let default_case =
        new Switch_clause{.pattern=p,.pat_vars=new Opt(new List(x_vd,NULL)),
                          .where_clause=NULL,.body=rs,.loc=DL};
      let handler_stmt = switch_stmt(e_exp,
                                     List::append(scs,
                                                  new List(default_case,NULL)),DL);
      // translate the switches
      stmt_to_c(nv,handler_stmt);

      // wrap with the conditional, declarations, and setjmp
      let setjmp_call = // setjmp(h.handler)
        fncall_exp(setjmp_e,
                   new List(aggrmember_exp(h_exp,handler_sp,DL), NULL),
                   DL);
      let pushhandler_call = // _pushhandler(h);
        exp_stmt(fncall_exp(_push_handler_e, 
                            new List(address_exp(h_exp,DL), NULL),
                            DL),
                 DL);
      let zero_exp = int_exp(Signed,0,DL);
      let one_exp = int_exp(Signed,1,DL);
      s->r =
        declare_stmt(h_var, h_typ, NULL,
        seq_stmt(pushhandler_call,
        declare_stmt(was_thrown_var,was_thrown_typ,zero_exp,
        seq_stmt(ifthenelse_stmt(setjmp_call,
                                 assign_stmt(was_thrown_exp,one_exp,DL),
                                 skip_stmt_dl(),
                                 DL),
        ifthenelse_stmt(prim1_exp(Not, was_thrown_exp,DL),
                        tryandpop_stmt,
                        declare_stmt(e_var,e_typ,
                                     cast_exp(e_typ,_exn_thrown_e,DL),
                        handler_stmt,DL),DL),DL),DL),DL),DL)->r;
      return;
    case &Region_s(tv, vd, resetable, body):
      // NOTE:  _npop_handler has to deal with regions as well as exceptions
      // { struct _RegionHandle rh = _new_region();
      //   struct _RegionHandle *x = &rh;
      //   _push_region(x);
      //   body; 
      //   _pop_region(x);
      // }
      type_t rh_struct_typ     = strct(_RegionHandle_sp);
      type_t rh_struct_ptr_typ = cstar_typ(rh_struct_typ,mt_tq);
      qvar_t rh_var = temp_var();
      qvar_t x_var  = vd->name;
      exp_t  rh_exp = var_exp(rh_var,DL);
      exp_t  x_exp  = var_exp(x_var, DL);

      stmt_to_c(add_varmap(nv,x_var,x_exp),body);

      s->r = 
	declare_stmt(rh_var,rh_struct_typ, 
		     fncall_exp(_new_region_e,
				new List(string_exp(qvar2string(x_var),DL),
					 NULL),DL),
	declare_stmt(x_var, rh_struct_ptr_typ,address_exp(rh_exp,DL),
  	seq_stmt(exp_stmt(fncall_exp(_push_region_e, list(x_exp), DL),DL),
        seq_stmt(body,
		 exp_stmt(fncall_exp(_pop_region_e,  list(x_exp), DL),DL),
		 DL),DL),DL),DL)->r;
      return;
    case &ResetRegion_s(e):
      exp_to_c(nv,e);
      s->r = exp_stmt(fncall_exp(_reset_region_e,new List(e,NULL),DL),DL)->r;
      return;
    case &SwitchC_s(_,_): toc_impos("switchC_s");
    case &Cut_s(_):       unimp("cut");
    case &Splice_s(_):    unimp("splice");
    case &ForArray_s(_):  unimp("forarray");
    }
  }
}

///////////////////////////////////////////////////////////////
//              Translation of Declarations                  //
///////////////////////////////////////////////////////////////
// function declaration translation -- straightforward
static void fndecl_to_c(env_t nv, fndecl_t f) {
  //fprintf(stderr,"translating %s\n",qvar2string(f->name));
  f->tvs      = NULL;
  f->effect   = NULL;
  f->rgn_po   = NULL;
  f->ret_type = typ_to_c(f->ret_type);
  for (let args=f->args; args != NULL; args = args->tl) {
    (*args->hd)[2] = typ_to_c((*args->hd)[2]);
    let x = new $((nmspace_t)Loc_n,(*args->hd)[0]);
    nv = add_varmap(nv,x,var_exp(x,DL));
  }
  if (f->cyc_varargs && f->cyc_varargs->name != NULL) {
    let VarargInfo{n,tq,t,i} = *f->cyc_varargs;
    let t2 = typ_to_c(tagged_typ(t,HeapRgn,tq));// region irrelevant
    let x2 = new $((nmspace_t)Loc_n,n->v);
    f->args = List::append(f->args,new List(new $(n->v,tq,t2),NULL));
    nv = add_varmap(nv,x2,var_exp(x2,DL));
    f->cyc_varargs = NULL;
  }
  // Tovc would like to use param_vardecls:
  for(let arg_vds = f->param_vardecls->v; arg_vds!=NULL; arg_vds=arg_vds->tl) {
    arg_vds->hd->type = typ_to_c(arg_vds->hd->type);
  }
  stmt_to_c(clear_toplevel(nv),f->body);
}

// there's no abstract scope in C
static scope_t scope_to_c(scope_t s) {
  switch (s) {
  case Abstract: return Public;
  case ExternC : return Extern;
  default:       return s;
  }
}

// struct declarations -- straightforward
opt_t<Dict::dict_t<var_t,aggrdecl_t>> aggrs_so_far = NULL;
static void aggrdecl_to_c(aggrdecl_t ad) {
  let n = ad->name;
  if (aggrs_so_far == NULL) 
    aggrs_so_far = new Opt(Dict::empty(zstrptrcmp));
  bool seen_defn_before;
  let dopt = Dict::lookup_opt(aggrs_so_far->v, (*n)[1]);
  if (dopt == NULL) {
    seen_defn_before = false;
    aggrs_so_far->v = Dict::insert(aggrs_so_far->v,(*n)[1],ad);
  } else {
    if (dopt->v->impl == NULL) {
      aggrs_so_far->v = Dict::insert(aggrs_so_far->v,(*n)[1],ad);
      seen_defn_before = false;
    } else
      seen_defn_before = true;
  }

  ad->sc   = Public; // gcc warns if we have Extern or Static here
  ad->tvs  = NULL;
  if(ad->impl != NULL) {
    ad->impl->exist_vars = NULL;
    ad->impl->rgn_po     = NULL;
    if (seen_defn_before)
      ad->impl = NULL;
    else
      for (let fields = ad->impl->fields; fields != NULL; fields = fields->tl)
        fields->hd->type = typ_to_c_array(fields->hd->type);
  }
}

// tunion declarations -- tricky
// for "tunion foo {Bar,Blah,Baz(t1,t2,t3),Baf(t4,t5)}" we generate
//   typedef void *foo;
//   struct Baz_struct {
//     int tag;  // always == 0
//     t1 f1;
//     t2 f2;
//     t3 f3;
//   }
//   struct Baf_struct {
//     int tag;  // always == 1
//     t4 f1;
//     t5 f2;
//   }
// for xtunion, we pull a really slimy trick: By using char arrays instead
// of ints, the uses get promoted to addresses just like we want.
// When the tunion is "extern" then we don't generate initializers
// for the tags (that should be done elsewhere.)
//
// NB: we allow any number of repeated declarations but we can only
//     declare and initialize global variables once.  So we keep track
//     of what we've seen so far.  And we make the globals static so that
//     extern and what not is only a link-checker thing.  Unfortunately,
//     the static trick doesn't work for xtunion, which uses the addresses.
static opt_t<Set::set_t<qvar_t>> tunions_so_far = NULL;
static void tuniondecl_to_c(tuniondecl_t tud) {
  if (tunions_so_far == NULL)
    tunions_so_far = new Opt(Set::empty(qvar_cmp));
  let n = tud->name;
  if(tud->fields == NULL || Set::member(tunions_so_far->v, n))
    return;
  tunions_so_far->v = Set::insert(tunions_so_far->v, n);

  for (let fields = tud->fields->v; fields != NULL; fields = fields->tl) {
    tunionfield_t f = fields->hd;
    if (f->typs != NULL) {
      // compute the fields for the struct, adding in a tag field
      let fs = NULL;
      int i  = 1;
      for (let ts = f->typs; ts != NULL; ts = ts->tl, i++) {
	let fname = fieldname(i);
	let f = new Aggrfield(fname,(*ts->hd)[0],
			      typ_to_c_array((*ts->hd)[1]),NULL,NULL);
	fs = new List(f,fs);
      }
      fs = List::imp_rev(fs);
      fs = new List(new Aggrfield(tag_sp,mt_tq,sint_typ,NULL,NULL),fs);
      let ad = 
	new Aggrdecl{.kind = StructA, .sc = Public,
		     .name = collapse_qvar_tag(f->name,"_struct"),
		     .tvs = NULL, 
		     .impl = new AggrdeclImpl(NULL,NULL,fs),
		     .attributes = NULL};
      result_decls = new List(new_decl(new Aggr_d(ad),DL),result_decls);
    }
  }
}

// xtunion declarations -- similar to tunion declarations
// For a declaration extending an existing xtunion, e.g.,
//   "xtunion foo {Bar,Baz(t1,t2)}"
// we generate
//   char Bar[4] = "\0\0\0\0Bar";
//   struct Bar_struct { char *tag; };
//   char Baz[4] = "\0\0\0\0Baz";
//   struct Baz_struct { char *tag; t1 f1; t2 f2; };
// When the xtunion is extern, then we don't do initializers for the tags.
// The 0s are a crazy trick for letting void variants not have to be boxed
// (value variants can still follow the pointer and then their check fails)
//
// Thus "Baz(e1,e2)" maps to
// ({struct _Baz_struct *t =
//     (struct _Baz_struct*)malloc(sizeof(struct _Baz_struct));
//   *t = (struct _Baz_struct){.tag=Baz, .f1 = e1, .f2 = e2};
//   t;})
static opt_t<Dict::dict_t<qvar_t, bool>> xtunion_fields_so_far = NULL;
//true if already seen & initialized, false if seen but non initialized (extern)

static void xtuniondecl_to_c(tuniondecl_t xd) {
  if (xtunion_fields_so_far == NULL)
    xtunion_fields_so_far = new Opt(Dict::empty(qvar_cmp));
  if(xd->fields == NULL)
    return;
  let n = xd->name;
  for (let fs = xd->fields->v; fs != NULL; fs = fs->tl) {
    tunionfield_t f  = fs->hd;
    stringptr_t fn = (*f->name)[1];
    let sz_exp  = uint_exp((*fn).size+4,DL);
    let tag_typ = new ArrayType(char_typ,mt_tq,sz_exp);
    // FIX: making bad alignment and pointer-size assumptions!
    switch (Dict::lookup_opt(xtunion_fields_so_far->v,f->name)) {
    case NULL:
      exp_opt_t initopt = NULL;
      if (f->sc != Extern) {
	initopt = string_exp(aprintf("%c%c%c%c%s",'\0','\0','\0','\0',*fn),DL);
      }
      let tag_decl = new_vardecl(f->name, tag_typ, initopt);
      tag_decl->sc = f->sc;
      result_decls = new List(new_decl(new Var_d(tag_decl),DL),result_decls);
      xtunion_fields_so_far->v = 
	Dict::insert(xtunion_fields_so_far->v, f->name, f->sc != Extern);
      if(f->typs != NULL) {
	list_t<aggrfield_t> fields = NULL;
	int i = 1;
	for (let tqts = f->typs; tqts != NULL; tqts = tqts->tl,i++) {
	  let field_n = new ((string_t)aprintf("f%d",i));
	  let newf = new Aggrfield(field_n,(*tqts->hd)[0],
				   typ_to_c_array((*tqts->hd)[1]),NULL,NULL);
	  fields = new List(newf,fields);
	}
	fields = new List(new Aggrfield(tag_sp,mt_tq,
					cstar_typ(char_typ,mt_tq),NULL,NULL),
			  List::imp_rev(fields));
	let strct_decl =
	  new Aggrdecl{.kind = StructA, .sc = Public,
		       .name = collapse_qvar_tag(f->name,"_struct"),
		       .tvs  = NULL, 
		       .impl = new AggrdeclImpl(NULL,NULL,fields),
		       .attributes = NULL};
	result_decls = new List(new_decl(new Aggr_d(strct_decl),DL),
				result_decls);
      }
      break;

    case &Opt(false):
      if (f->sc != Extern) {
	let initopt = string_exp(aprintf("%c%c%c%c%s",'\0','\0','\0','\0',*fn),
				 DL);
	let tag_decl = new_vardecl(f->name, tag_typ, initopt);
	tag_decl->sc = f->sc;
	result_decls = new List(new_decl(new Var_d(tag_decl),DL),result_decls);
	xtunion_fields_so_far->v = Dict::insert(xtunion_fields_so_far->v, 
						f->name, true);
      }
      break;
    default: break;
    }
  }
}

static void enumdecl_to_c(env_t nv,enumdecl_t ed) {
  ed->sc = Public; // gcc warns if we have Extern or Static on an enum
  if(ed->fields != NULL)
    enumfields_to_c(ed->fields->v);
}

// we've decided let x = e and t x = e have different rules on e's
// environment, so we make the caller pass us an environment.
static void local_decl_to_c(env_t body_nv,env_t init_nv,vardecl_t vd,stmt_t s) {
  vd->type = typ_to_c_array(vd->type);
  stmt_to_c(body_nv,s);
  if(vd->initializer != NULL) {
    exp_t init = (exp_t)vd->initializer;
    switch(init->r) {
    case &Comprehension_e(vd2,e1,e2):
      vd->initializer = NULL;
      s->r = init_comprehension(init_nv, var_exp(vd->name, DL), vd2, e1, e2,
				new_stmt(s->r,DL), false)->r;
      break;
    default:
      if (vd->sc == Static) {
        // static declarations have to be treated as if they're toplevel
        // w.r.t. the translation.  NB: Any other generated declarations
	// will also be left at top-level??
        let nv2 = new *init_nv;
        nv2->toplevel = true;
        exp_to_c(nv2, init);
      } else 
        exp_to_c(init_nv, init);
      break;
    }
  }
}

static stmt_t* throw_match_stmt_opt = NULL;
static stmt_t throw_match_stmt() {
  if(throw_match_stmt_opt==NULL)
    throw_match_stmt_opt = new exp_stmt(newthrow_exp(match_exn_exp(DL)),DL);
  return *throw_match_stmt_opt;
}
// let declarations -- tricky
// Unlike other declarations, lets need to execute statements and
// so return a statement.  (See stmt_to_c, case for Decl above.)
// We treat this similar to the compilation of a switch (see xlate_switch
// above) with one case, but where the failure throws Match_Exception
static stmt_t letdecl_to_c(env_t nv, pat_t p, type_t t, exp_t e, stmt_t s) {
  exp_to_c(nv,e);
  qvar_t x = temp_var();
  region prgn {
    let $(nv,vars,test_stmt) =
      xlate_pat(nv, prgn, t, var_exp(x,DL), var_exp(x,DL), p, 
		throw_match_stmt(),NULL);
    stmt_to_c(nv,s);
    s = declare_stmt(x,typ_to_c(t),e,seq_stmt(test_stmt,s,DL),DL);
    for (; vars != NULL; vars = vars->tl) {
      let &$(qv,t2) = vars->hd;
      s = declare_stmt(qv,t2,NULL,s,DL);
    }
  }
  return s;
}

// Translate the given declarations, producing a new list of declarations
// and a new translation environment.  All source-level variables should
// be entered in the varmap of the env.  Note that top-level variable
// declarations are treated differently.
static env_t decls_to_c(env_t nv, list_t<decl_t> ds, bool top) {
  for (; ds != NULL; ds = ds->tl) {
    if (!nv->toplevel)
      impos("decls_to_c: not at toplevel!");
    decl_t d = ds->hd;
    switch (d->r) {
    case &Var_d(vd):
      let c_name = vd->name;
      // strip any namespace from an extern C declaration
      if (vd->sc == ExternC) 
	c_name = new $(rel_ns_null,(*c_name)[1]);
      if (vd->initializer != NULL)
	exp_to_c(nv, (exp_t)vd->initializer);
      nv = add_varmap(nv,vd->name,varb_exp(c_name,new Global_b(vd),DL));
      vd->name = c_name;
      vd->sc   = scope_to_c(vd->sc);
      vd->type = typ_to_c_array(vd->type);
      result_decls = new List(d,result_decls);
      break;
    case &Fn_d(fd):
      let c_name = fd->name;
      // strip any namespace from an extern C declaration
      if (fd->sc == ExternC)
	c_name = new $(rel_ns_null,(*c_name)[1]);
      nv = add_varmap(nv,fd->name,var_exp(c_name,DL));
      fd->name = c_name;
      fndecl_to_c(nv, fd);
      result_decls = new List(d,result_decls);
      break;
    case &Let_d(_,_,_): 
    case &Letv_d(_):
      toc_impos("letdecl at toplevel");
    case &Aggr_d(sd):
      aggrdecl_to_c(sd);
      result_decls = new List(d,result_decls);
      break;
    case &Tunion_d(tud):
      if(tud->is_xtunion)
	xtuniondecl_to_c(tud);
      else
	tuniondecl_to_c(tud);
      break;
    case &Enum_d(ed):
      enumdecl_to_c(nv,ed);
      result_decls = new List(d,result_decls);
      break;
    case &Typedef_d(td):
      td->name = td->name;
      td->tvs  = NULL;
      if (td->defn != NULL) 
        td->defn = new Opt(typ_to_c_array(td->defn->v));
      else {
        switch (td->kind->v) {
        case BoxKind: td->defn = new Opt(void_star_typ()); break;
        default: td->defn = new Opt(VoidType); break;
        }
      }
      result_decls = new List(d,result_decls);
      break;
    case &Namespace_d(_,ds2): fallthru(ds2);
    case &Using_d(_,ds2):     fallthru(ds2);
    case &ExternC_d(ds2): nv = decls_to_c(nv,ds2,top); break;
    }
  }
  return nv;
}

// initialize all globals
static void init() {
  result_decls = NULL;
  tuple_types = NULL;
  tuple_type_counter = 0;
  temp_var_counter = 0;
  fresh_label_counter = 0;
  aggrs_so_far = NULL;
  tunions_so_far = NULL;
  xtunion_fields_so_far = NULL;
  total_bounds_checks = 0;
  bounds_checks_eliminated = 0;
}

// The entry point:  translate the list of Cyclone declarations to
// a list of C declarations.
list_t<decl_t> toc(list_t<decl_t> ds) {
  init();
  decls_to_c(empty_env(),ds,true);
#ifdef BCE_DEBUG
  fprintf(stderr,"***eliminated %d out of %d bounds checks\n",
          bounds_checks_eliminated, total_bounds_checks);
#endif
  return imp_rev(result_decls);
}
