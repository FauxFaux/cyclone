/* Translate Cyclone abstract syntax to C abstract syntax.
   Copyright (C) 2001 Greg Morrisett, AT&T
   This file is part of the Cyclone compiler.

   The Cyclone compiler is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   The Cyclone compiler is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with the Cyclone compiler; see the file COPYING. If not,
   write to the Free Software Foundation, Inc., 59 Temple Place -
   Suite 330, Boston, MA 02111-1307, USA. */

// Translation of Cyclone abstract syntax to C abstract syntax.
// Assumes RemoveAggrs and Toseqc will be run subsequently (thoough
// the latter should be optional if we knew the underlying C compiler
// used left-to-right evaluation).  We use GCC-sepcific features (especially
// statement-expressions as convenient).

// The translation is mostly done in place in an imperative style
// (i.e., we overwrite AST nodes) so it's fairly crucial that we don't
// have sharing in the AST.  However, the type translation is functional.

//Look for "unimp" or comments that start with FIX for missing or broken pieces.

// FIX: we could probably use "const" in lots of places where we're not.

// unresolvedmem_exp should only be used (1) to build arrays; or (2) to build
// other things (structs etc.) at top level only; Tovc relies on this.

#include <string.h>
#include <set.h>
#include <dict.h>
#include <xarray.h>
#include "warn.h"
#include "flags.h"
#include "unify.h"
#include "tcutil.h"
#include "kinds.h"
#include "attributes.h"
#include "evexp.h"
#include "insert_checks.h"
#include "toc.h"
#include "tcpat.h"
#include "absynpp.h"
using Core;
using List;
using Absyn;
using Tcutil;
namespace Toc;

// used for creation of all abstract syntax node locations created here
#define DL 0

// padding for variable-length array allocations
#define PAD_BYTES sizeof(double)

// for passing New_e destinations to RemoveAggrs
@extensible datatype Absyn::AbsynAnnot {
  NewInfo(exp_t,type_t);
};

static `a unimp(string_t<`H> str) __attribute__((noreturn)) {
  Warn::impos2(str);
}
static `a toc_impos(...inject Warn::warg_t ap) __attribute__((noreturn)) {
  Warn::warg_t   toc  = new Warn::String("Toc: ");
  Warn::warg_t ? args = new {for i < (numelts(ap)+1) : (i==0 ? toc : ap[i-1])};
  Warn::vimpos2(args);
}

stringptr_t ?globals = NULL;

// Should be folded into environment, but for now use globals.
// In particular, global pop_tables complicate nested function handling
static table_t<fndecl_t,table_t<stmt_t,int>> * gpop_tables  = NULL;
static table_t<stmt_t,int>                   * fn_pop_table = NULL;
static int tuple_type_counter  = 0;
static int temp_var_counter    = 0;
static int fresh_label_counter = 0;

// we aren't re-entrant -- we build this list of output decls (in
// reverse order)  It's global b/c tuple types, tagged pointer types, and
// strange top-level initializers need to "splice in" toplevel decls and
// it's a pain to pass this list around everywhere
static list_t<decl_t> result_decls = NULL;

static int get_npop(stmt_t s) {
  return Hashtable::lookup(*fn_pop_table,s);
}

// for gensymming, etc.
struct TocState<`d> {
  // tuple types seen so far and the struct they map to
  list_t<$(type_t,list_t<type_t,`d>)@`d,`d> @`d tuple_types;
  // anonymous aggr types seen so far and the struct they map to (rare)
  // FIX: would be nice to share more code with tuple translation
  list_t<$(type_t,aggr_kind_t,list_t<aggrfield_t>)@`d,`d> @`d anon_aggr_types;
  // (non-tagged) aggregates seen so far, their declaration, and C type
  Dict::dict_t<qvar_t,$(aggrdecl_t,type_t)@`d,`d> @`d aggrs_so_far;
  //instantiations of abstract structs generated
  list_t<$(qvar_t,list_t<type_t>,type_t)@`d,`d> @`d abs_struct_types;
  // datatypes seen so far
  Set::set_t<qvar_t,`d> @`d                    datatypes_so_far;
  // xdatatypes seen so far -- bool is false if seen but not initialized (extern)
  Dict::dict_t<qvar_t,bool,`d> @`d             xdatatypes_so_far;
  // generated identifiers from combining other identifiers -- used when
  // collapsing datatype members with the datatype itself.
  Dict::dict_t<$(qvar_t,qvar_t)@`d,qvar_t,`d>@`d qvar_tags;
  // generated labels -- get re-used across functions
  Xarray::xarray_t<var_t,`d>                    temp_labels;
};
static int qvar_tag_cmp($(qvar_t,qvar_t)@ x, $(qvar_t,qvar_t)@ y) {
  int i = qvar_cmp((*x)[0],(*y)[0]);
  if (i != 0) return i;
  return qvar_cmp((*x)[1],(*y)[1]);
}

// create a fresh TocState given the region
static struct TocState<`d>@`d empty_toc_state(region_t<`d> d) {
  return rnew(d)
    TocState{.tuple_types       = rnew(d) NULL,
	     .anon_aggr_types   = rnew(d) NULL,
             .aggrs_so_far      = rnew(d) Dict::rempty(d,qvar_cmp),
             .abs_struct_types  = rnew(d) NULL,
             .datatypes_so_far  = rnew(d) Set::rempty(d,qvar_cmp),
             .xdatatypes_so_far = rnew(d) Dict::rempty(d,qvar_cmp),
             .qvar_tags         = rnew(d) Dict::rempty(d,qvar_tag_cmp),
             .temp_labels       = Xarray::rcreate_empty(d)
            };
}

struct TocStateWrap {
  <`d::E>
  //  Core::real_rcregion_key_t<`d> dyn;
  Core::rcregion_key_t<`d> dyn;
  struct TocState<`d>@`d state;
};
typedef struct TocStateWrap*`U toc_state_t;
static toc_state_t toc_state = NULL;

// a generic function for using the toc state:  we pass in an
// argument arg and function f and end up passing f the current
// toc_state component after opening the toc_state's wrapped
// dynamic region.
static `res use_toc_state(`a arg,
                          `res f<`d,`r>(region_t<`d>,
					$(struct TocState<`d>@`d,`a)@`r)) {
  toc_state_t ts = NULL;
  ts :=: toc_state;
  let TocStateWrap{<`dyn> dyn, s} = *ts;
  let dyn2 = alias_refptr(dyn);
  *ts = TocStateWrap{dyn,s};
  ts :=: toc_state;
  let res;
  {region h = open((_ @)dyn2);
  let env = $(s, arg);
  res = f(h,&env);}
  //  real_free_rckey(dyn2); // should be equivalent to drop_refptr
  free_rckey((_ @)dyn2); // should be equivalent to drop_refptr
  return res;
}

static type_t aggrdecl_type_body<`r2,`d,`r>(region_t<`d> d,
                                 $(struct TocState<`d>@`d,
                                 $(qvar_t q,type_t (@`H)(qvar_t))@`r2)@`r env) {
  let $(s, &$(q, type_maker)) = *env;
  $(aggrdecl_t,type_t)@`d*`d v = Dict::lookup_opt(*s->aggrs_so_far,q);
  return v==NULL ? type_maker(q) : (**v)[1];
}

static type_t aggrdecl_type(qvar_t q, type_t (@`H type_maker)(qvar_t)) {
  _ env = $(q, type_maker);
  return use_toc_state(&env, (aggrdecl_type_body@<`aggrdecl_type>)<>);
}

// each tagged union member has a struct corresponding to it -- we
// look up the name using this function.
static type_t tagged_union_field_struct(type_t t, field_name_t f) {
  // a cache to avoid recomputing this stuff
  static list_t<$(var_t,field_name_t,type_t)@> cache = NULL;
  switch (compress(t)) {
  case &AppType(&AggrCon(AggrInfo{.KnownAggr = &ad}),...): fallthru(ad->name);
  case &AppType(&AggrCon(AggrInfo{.UnknownAggr = $(_,name,_)}),...):
    let &$(_,n) = name;
    for (let c = cache; c != NULL; c = c->tl) {
      let &$(n2,f2,t) = c->hd;
      if (strptrcmp(n2,n) == 0 && strptrcmp(f,f2) == 0) return t;
    }
    string_t str = aprintf("_union_%s_%s",*n,*f);
    t = strct(new str);
    cache = new List{new $(n,f,t),cache};
    return t;
  default: toc_impos("tagged_union_field_struct");
  }
}

/////////////////////////// Pre-Allocated Stuff /////////////////////////////
// Don't use any of these things if they might get mutated!!!

// some pre-allocated boxed strings -- use foo_sp for char ?* w/ contents "foo"
#define MAKE_STRING(str)\
  static string_t    str##_string = #str; \
  static stringptr_t str##_sp     = &str##_string

MAKE_STRING(curr);
MAKE_STRING(tag);
MAKE_STRING(val);
MAKE_STRING(_handler_cons);
MAKE_STRING(handler);
MAKE_STRING(_RegionHandle);

/* Some pre-allocated qvars -- use foo_e for exp that is var "foo".
   NB we must record all of these so that tovc knows about them;
   this is done by initializing the external variable globals in the
   function init(), below. */
#define MAKE_VAR(str)\
  static string_t            str##_str = #str;\
  static $(nmspace_t, var_t) str##_pr  = $(Nmspace{.Abs_n=NULL},&str##_str);\
  static datatype Binding.Unresolved_b str##_bnd = Unresolved_b(&str##_pr);\
  static datatype Raw_exp.Var_e        str##_re  = Var_e(&str##_bnd);\
  static struct Exp          str##_ev  = Exp{NULL,&str##_re,0,&EmptyAnnot_val};\
  static exp_t               str##_e   = &str##_ev

MAKE_VAR(_throw);
MAKE_VAR(setjmp);
MAKE_VAR(_push_handler);
MAKE_VAR(_pop_handler);
MAKE_VAR(_exn_thrown);
MAKE_VAR(_npop_handler);
MAKE_VAR(_check_null);
MAKE_VAR(_check_known_subscript_null);
MAKE_VAR(_check_known_subscript_notnull);
MAKE_VAR(_check_fat_subscript);
MAKE_VAR(_fat_ptr);
MAKE_VAR(_tag_fat);
MAKE_VAR(_untag_fat_ptr_check_bound);
MAKE_VAR(_untag_fat_ptr);
MAKE_VAR(_check_fat_at_base);
MAKE_VAR(_get_fat_size);
MAKE_VAR(_fat_ptr_decrease_size);
MAKE_VAR(_get_zero_arr_size_char);
MAKE_VAR(_get_zero_arr_size_other);
MAKE_VAR(_fat_ptr_plus);
MAKE_VAR(_zero_arr_plus_char);
MAKE_VAR(_zero_arr_plus_other);
MAKE_VAR(_fat_ptr_inplace_plus);
MAKE_VAR(_zero_arr_inplace_plus_char);
MAKE_VAR(_zero_arr_inplace_plus_other);
MAKE_VAR(_fat_ptr_inplace_plus_post);
MAKE_VAR(_zero_arr_inplace_plus_post_char);
MAKE_VAR(_zero_arr_inplace_plus_post_other);
MAKE_VAR(_cycalloc);
MAKE_VAR(_cyccalloc);
MAKE_VAR(_cycalloc_atomic);
MAKE_VAR(_cyccalloc_atomic);
MAKE_VAR(_region_malloc);
MAKE_VAR(_region_calloc);
MAKE_VAR(_region_vmalloc);
MAKE_VAR(_aqual_malloc);
MAKE_VAR(_aqual_calloc);
MAKE_VAR(_fast_region_malloc);
MAKE_VAR(_check_times);
MAKE_VAR(_new_region);
MAKE_VAR(_push_region);
MAKE_VAR(_pop_region);
MAKE_VAR(_throw_arraybounds);
MAKE_VAR(_throw_match);
MAKE_VAR(_rethrow);
MAKE_VAR(_throw_assert);

#undef MAKE_STRING
#undef MAKE_VAR

static tqual_t mt_tq = Tqual(false,false,false,false,0);

static exp_t deep_copy(exp_t e) {
  return Tcutil::deep_copy_exp(true,e);
}

type_t void_star_type() {
  static type_opt_t t = NULL;
  if (t == NULL)
    t = star_type(void_type,heap_rgn_type,al_qual_type,empty_tqual(0), false_type, false_type);
  return (type_t)t;
}
static type_t fat_ptr_type() {
  static type_opt_t t = NULL;
  if (t == NULL)
    t = aggr_type(UnknownAggr(StructA,&_fat_ptr_pr,NULL),NULL);
  return (type_t)t;
}
static type_t rgn_type() {
  static type_opt_t r = NULL;
  if (r == NULL)
    r = cstar_type(strct(_RegionHandle_sp),mt_tq);
  return (type_t)r;
}
static type_t aqualt_type() {
  return uint_type;
}
static exp_t aliasable_qual_exp() {
  static exp_opt_t aq = NULL;
  if(aq == NULL)
    aq = set_type(uint_exp(0, 0), uint_type);
  return aq;
}
static stmt_t skip_stmt_dl() {
  return skip_stmt(DL);
}

static $(list_t<designator_t>,exp_t)@ make_field(var_t name,exp_t e) {
  return new $(new List(new FieldName(name),NULL), e);
}

static exp_t fncall_exp_dl(exp_t f, ... exp_t args) {
  return fncall_exp(f,List::from_array(args),DL);
}
static exp_t cast_it(type_t t, exp_t e) { // DJG: sound for numeric casts?
  switch (e->r) {
  case &Cast_e(_,e,_,No_coercion): return cast_it(t,e);
  default: return set_type(cast_exp(t,e,false,No_coercion,DL),t);
  }
}

exp_t get_exn_thrown_expression() {
  static exp_opt_t _get_exn_thrown_e = NULL;
  //  $(nmspace_t, var_t)
  if(_get_exn_thrown_e)
    return deep_copy((exp_t)_get_exn_thrown_e);
  qvar_t    qv = new $(Nmspace{.Abs_n=list(new "Core")}, new "get_exn_thrown");
  binding_t bnd       = new Unresolved_b(qv);
  exp_t     fnname    = new Exp(NULL, new Var_e(bnd), 0, &EmptyAnnot_val);
  raw_exp_t fncall_re = new FnCall_e(fnname,NULL,NULL,false);
  fnname->topt = 
    cstar_type(function_type(NULL,NULL,mt_tq,void_star_type(),
                             NULL,false,NULL,NULL,NULL,NULL,
                             NULL,NULL,NULL,NULL),mt_tq);
  _get_exn_thrown_e = new Exp(NULL,fncall_re,0,&EmptyAnnot_val);
  _get_exn_thrown_e->topt = void_star_type();
  return (exp_t)_get_exn_thrown_e;
}

// These constructors are useful when we want to just update the
// raw part of an expression or statement.
static raw_exp_t cast_it_r(type_t t, exp_t e) {
  return new Cast_e(t,e,false,No_coercion);
}
static raw_exp_t deref_exp_r(exp_t e) {
  return new Deref_e(e);
}
static raw_exp_t subscript_exp_r(exp_t e1, exp_t e2) {
  return new Subscript_e(e1,e2);
}
static raw_exp_t stmt_exp_r(stmt_t s) {
  return new StmtExp_e(s);
}
static raw_exp_t sizeoftype_exp_r(type_t t) {
  return new Sizeoftype_e(t);
}
static raw_exp_t fncall_exp_r(exp_t e, ... exp_t es) {
  return new FnCall_e(e,List::from_array(es),NULL,true);
}
static raw_stmt_t seq_stmt_r(stmt_t s1, stmt_t s2) {
  return new Seq_s(s1,s2);
}
static raw_exp_t conditional_exp_r(exp_t e1, exp_t e2, exp_t e3) {
  return new Conditional_e(e1,e2,e3);
}
static raw_exp_t aggrmember_exp_r(exp_t e, field_name_t n) {
  return new AggrMember_e(e,n,false,false);
}
static raw_exp_t unresolvedmem_exp_r(opt_t<typedef_name_t,`H> tdopt,
                                     list_t<$(list_t<designator_t,`H>,exp_t)@`H,`H> ds)
{
  return new UnresolvedMem_e(tdopt,ds);
}
static raw_stmt_t goto_stmt_r(var_t v) {
  return new Goto_s(v);
}

static datatype Raw_exp @zero_exp() {
  return new Const_e(Cnst{.Int_c= $(Signed,0)});
}

// same as aggrmember_e(e,f,DL) but when e is a deref_e(e1), replaces with
// aggrarrow_e(e1,f,DL)
static exp_t member_exp(exp_t e, field_name_t f, seg_t loc) {
  switch (e->r) {
  case &Deref_e(e1): return aggrarrow_exp(e1,f,loc);
  default: return aggrmember_exp(e,f,loc);
  }
}

// get the curr field of a fat pointer
static exp_t get_curr(exp_t e) {
  return set_type(member_exp(e,curr_sp,DL),cstar_type(uchar_type,mt_tq));
}

static bool isCharStar(exp_t e) {
  switch (compress((type_t)e->topt)) {
  case &PointerType(pi): return Tcutil::is_char_type(pi.elt_type);
  default: return false;
  }
}

#define sizeoftype_exp(e,i) (set_type(sizeoftype_exp(e,i),uint_type))

///////////////////////////// Various Utilities /////////////////////////////

// more lenient than the function in Tcutil
static bool is_zero(exp_t e) {
  switch (e->r) {
  case &Const_e({.Null_c = _}):  return true;
  case &Cast_e(_,e1,_,_):        return is_zero(e1);
  case &Array_e(dles):           fallthru(dles);
  case &AnonStruct_e(_,_,dles):  fallthru(dles);
  case &Aggregate_e(_,_,dles,_): fallthru(dles);
  case &CompoundLit_e(_,dles):   fallthru(dles);
  case &UnresolvedMem_e(_,dles):
    for (; dles != NULL; dles = dles->tl)
      if (!is_zero((*dles->hd)[1])) return false;
    return true;
  default: return Tcutil::is_zero(e);
  }
}

// If x = X1::X2::...::Xn::v, generate s_X1_X2_..._Xn_v_struct
static string_t collapse_qvar(stringptr_t s, qvar_t x) {
  let &$(ns,v) = x;
  switch (ns) {
  case {.Loc_n = _}:  fallthru(NULL);
  case {.Rel_n = vs}: fallthru(vs);
  case {.Abs_n = vs}: fallthru(vs);
  case {.C_n = vs}:
    // special-case trims out an '_' which isn't necessary, but we do it
    // (affects the struct name for exception variants)
    if(vs==NULL)
      return aprintf("%s_%s_struct",*s,*v);
    region r;
    return aprintf("%s_%s_%s_struct",*s,rstr_sepstr(r,vs,"_"),*v);
  }
}

// Used when generating the struct name for a datatype field.
// If fieldname = N1::N2::...::Nn::f and the datatype name is
// M1::M2::...::Mm::d, then we generate the qvar that looks
// like N1::N2::....::Nn::f_M1_M2_..._Mm_d_struct.
// FIX: this could conflict with a user-defined struct which
// can cause errors at C-compile time.
static qvar_t collapse_qvars_body<`r2,`d,`r>(region_t<`d> d,
                                             $(struct TocState<`d>@`d,
                                               $(qvar_t,qvar_t)@`r2)@`r env) {
  let $(&TocState{.qvar_tags = qvs,...}, pair) = *env;
  let $(fieldname,dtname) = *pair;
  try return Dict::lookup_other(*qvs,qvar_tag_cmp,pair);
  catch { case &Dict::Absent:
    let new_pair = rnew(d) $(fieldname,dtname);
    let &$(nmspace,fieldvar) = fieldname;
    string_t newvar = collapse_qvar(fieldvar,dtname);
    qvar_t res = new $(nmspace, new newvar);
    *qvs = Dict::insert(*qvs,new_pair,res);
    return res;
  }
}
static qvar_t collapse_qvars(qvar_t fieldname,qvar_t dtname) {
  _ env = $(fieldname, dtname);
  return use_toc_state(&env, (collapse_qvars_body@<`collapse_qvars>)<>);
}

// there are several places we generate C struct types
// FIX? by using Rel_n instead of Abs_n, we do not prepend Cyc_
static aggrdecl_t make_c_struct_defn(var_t name, list_t<aggrfield_t,`H> fs) {
  return new Aggrdecl{.kind=StructA, .sc=Public, .tvs=NULL,
		      .attributes=NULL, .expected_mem_kind=false,
		      .name= new $(Rel_n(NULL),name),
		      .impl= new AggrdeclImpl{NULL,NULL,fs,false,NULL}};
}

// used to generate struct definitions for tuple types
// we share the struct definitions where possible (need to for C compiler!)
static type_t add_tuple_type_body(region_t<`d> d,
				  $(struct TocState<`d>@`d,
				    list_t<$(tqual_t,type_t)@`H,`H>)@`r env) {
  let $(&TocState{.tuple_types = tuple_types, ...},tqs0) = *env;
  // look for the same tuple-type already declared
  for (let tts = *tuple_types; tts != NULL; tts = tts->tl) {
    let &$(x,ts) = tts->hd;
    let tqs = tqs0;
    for (; tqs != NULL && ts != NULL; tqs = tqs->tl, ts = ts->tl)
      if (!Unify::unify((*tqs->hd)[1],ts->hd))
        break;
    if(tqs == NULL && ts == NULL)
      return x;
  }
  // haven't seen this one before, add a declaration
  // need to set up a real struct declaration for get_varsizeexp and RemoveAggrs
  stringptr_t xname = new (string_t)aprintf("_tuple%d",tuple_type_counter++);
  let fs = NULL;
  let ts = NULL;
  for (int i=1; tqs0 != NULL; tqs0 = tqs0->tl, i++) {
    type_t t = (*tqs0->hd)[1];
    fs = new List(new Aggrfield(fieldname(i),mt_tq,t,NULL,NULL,NULL),fs);
    ts = rnew(d) List(t,ts);
  }
  fs = imp_rev(fs);
  ts = imp_rev(ts);
  let sd  = make_c_struct_defn(xname,fs);
  let ans = aggr_type(KnownAggr(new sd),NULL);
  result_decls = new List(new_decl(new Aggr_d(sd),DL),result_decls);
  *tuple_types = rnew(d) List(rnew(d) $(ans,ts),*tuple_types);
  return ans;
}
static type_t add_tuple_type(list_t<$(tqual_t,type_t)@`H,`H> tqs0) {
  return use_toc_state(tqs0, add_tuple_type_body<>);
}

// similar to add_tuple_type, but for anonymous aggregates (should try to share)
static type_t add_anon_aggr_type_body(region_t<`d> d,
				      $(struct TocState<`d>@`d,
					$(aggr_kind_t,list_t<aggrfield_t,`H>)@`H)@`r env) {
  let &$(&TocState{.anon_aggr_types = anon_aggr_types,...},&$(ak,fs)) = env;
  // look for the same type already declared
  for(let ts = *anon_aggr_types; ts != NULL; ts=ts->tl) {
    let &$(x,ak2,fs2) = ts->hd;
    if(ak == ak2 && !list_cmp(Tcutil::aggrfield_cmp,fs2,fs))
      return x;
  }
  // haven't seen this one before, add a declaration
  // need to set up a real struct declaration for get_varsizeexp and RemoveAggrs
  stringptr_t xname = new (string_t)aprintf("_tuple%d",tuple_type_counter++);
  let sd = make_c_struct_defn(xname,fs);
  sd->kind = ak; // might be a union
  let ans = aggr_type(KnownAggr(new sd),NULL);
  result_decls = new List(new_decl(new Aggr_d(sd),DL),result_decls);
  *anon_aggr_types = rnew(d) List(rnew(d) $(ans,ak,fs),*anon_aggr_types);
  return ans;
}
static type_t add_anon_aggr_type(aggr_kind_t ak, list_t<aggrfield_t,`H> fs) {
  return use_toc_state(new $(ak,fs), add_anon_aggr_type_body<>);
}

// similar to the above, except that we're working with an instantiated
// abstract struct.  The fieldnames are thus drawn from the actual
// struct fields and in addition, we have to worry about the instantiation.
// It's very important that we share as many instantiations as possible
// to get the translation right.
static type_t
add_struct_type_body<`r2,`r3,`d,`r>(region_t<`d> d,
				    $(struct TocState<`d>@`d s,
				      $(qvar_t struct_name,
					list_t<tvar_t,`H> type_vars,
					list_t<type_t,`H> type_args,
					list_t<aggrfield_t,`r2> fields)@`r3)@`r env) {
  // first, filter out the type_vars and type_args that are not of
  // type or integer kind.
  let $(&TocState{.abs_struct_types = abs_struct_types, ...},
        &$(struct_name, type_vars, type_args, fields)) = *env;

  // look for the same instantiation of abstract-struct-type already declared
  for (let tts = *abs_struct_types; tts != NULL; tts = tts->tl) {
    let &$(x,ts2,t) = tts->hd;
    if (qvar_cmp(x,struct_name) == 0 &&
        List::length(type_args) == List::length(ts2)) {
      bool okay = true;
      for (let ts = type_args; ts != NULL; ts=ts->tl, ts2=ts2->tl) {
        let t = ts->hd;
        let t2 = ts2->hd;
        switch (type_kind(t)) {
        case &Kind{.kind = EffKind, _}:continue;//Effects/regions won't appear in C types
	  //        case &Kind{.kind = RgnKind, _}:
        default:
          // Check if they're the same before translating them to C
          if (Unify::unify(t,t2) || Unify::unify(typ_to_c(t),typ_to_c(t2)))
            continue;
          okay = false;
          break;
        }
        break;
      }
      if (okay) // found pre-existing type
        return t;
    }
  }
  // haven't seen this one before, add a declaration
  // we're calling it a "tuple" so we don't have to worry about name clashes.
  stringptr_t xname = new (string_t)aprintf("_tuple%d",tuple_type_counter++);
  type_t x = strct(xname);
  let fs = NULL;
  // go ahead and add this to the struct types
  *abs_struct_types  = rnew(d) List{rnew(d) $(struct_name,type_args,x),
                                    *abs_struct_types};
  // copy the fields over
  region r;
  let inst = List::rzip(r,r,type_vars,type_args);
  for (; fields != NULL; fields = fields->tl) {
    let f = fields->hd;
    type_t t = f->type;
    attributes_t atts = f->attributes;
    // if the original type was abstract, then we must force the field
    // to be aligned.
    //DJG: FIX I think this is broken for an array with element-type
    //     of abstract mem kind
    if (fields->tl == NULL
	&& Kinds::kind_leq(&Kinds::ak,type_kind(t))
	&& !is_array_type(t))
      atts = new List(new Aligned_att(NULL),atts);
    t = typ_to_c(rsubstitute(r,inst,t));
    // still could be abstract and end up void -- if so, make it
    // a zero-sized array of void*'s and force it to be aligned.
    if (Unify::unify(t,void_type))
      t = new ArrayType(ArrayInfo(void_star_type(), mt_tq,
                                  set_type(uint_exp(0,DL), uint_type),
                                  false_type, DL));
    fs = new List(new Aggrfield{f->name,mt_tq,t,f->width,atts,NULL},fs);
  }
  fs = List::imp_rev(fs);
  let sd = make_c_struct_defn(xname,fs);
  result_decls = new List(new_decl(new Aggr_d(sd),DL),result_decls);
  return x;
}

static type_t add_struct_type(qvar_t struct_name,
                              list_t<tvar_t,`H> type_vars,
                              list_t<type_t,`H> type_args,
                              list_t<aggrfield_t,`r> fields) {
  _ env = $(struct_name, type_vars, type_args, fields);
  return use_toc_state(&env, (add_struct_type_body@<`r,`add_struct_type>)<>);
}


// generate a temporary variable
// FIX: need to guarantee these can't conflict
// FIX: we share labels but not variables (why?)
qvar_t temp_var() {
  return new $(Loc_n(),new (string_t)aprintf("_tmp%X",temp_var_counter++));
}
$(qvar_t,exp_t) temp_var_and_exp() {
  qvar_t v = temp_var();
  return $(v,var_exp(v,DL));
}

// generate a fresh label
// FIX: need to guarantee these can't conflict
static var_t fresh_label_body<`d,`r>(region_t<`d> d, $(struct TocState<`d>@`d,int)@`r env) {
  let $(&TocState{.temp_labels = temp_labels, ...},_) = *env;
  let i = fresh_label_counter++;
  if (i < Xarray::length(temp_labels))
    return Xarray::get(temp_labels,i);
  var_t res = new (string_t)aprintf("_LL%X",i);
  if (Xarray::add_ind(temp_labels,res) != i)
    toc_impos("fresh_label: add_ind returned bad index...");
  return res;
}
static var_t fresh_label() {
  return use_toc_state(0, fresh_label_body<>);
}

// This should never be used for xdatatypes. Should memoize?
// The former used to use static const int variables, but couldn't at top-level.
static exp_t datatype_tag(datatypedecl_t td, qvar_t name) {
  int ans = 0;
  for(let fs  = td->fields->v; qvar_cmp(name,fs->hd->name)!=0; fs=fs->tl)
    ++ans;
  return set_type(signed_int_exp(ans,DL),sint_type);
}

///////////////////////////////////////////////////////////////
//         Convert a Cyclone type to a C type                //
///////////////////////////////////////////////////////////////
static void enumdecl_to_c(enumdecl_t);
static void aggrdecl_to_c(aggrdecl_t);
static void datatypedecl_to_c(datatypedecl_t);
static void exptypes_to_c(exp_t);
static void stmttypes_to_c(stmt_t);

// just drop the vars to reduce output
static $(var_opt_t,tqual_t,type_t)@ arg_to_c($(var_opt_t,tqual_t,type_t)@ a) {
  return new $(NULL,(*a)[1],typ_to_c((*a)[2]));
}

// Sometimes we translate arrays t[] and t[N] to t*, and sometimes
// we leave them alone.  We must leave them alone in the following
// circumstances:
// 1. as the argument of sizeof
// 2. in typedef
// 3. in declarations
// 4. as the element type of an array
// 5. as the type part of a C9X compound literal
// 6. as the type of a struct field
// We must change them to pointers in the following circumstances:
// 1. as the argument of cast
// We can do either in the following circumstances:
// 1. as the parameter of a function
// The function typ_to_c_array changes them, while typ_to_c
// changes them to pointers.
static type_t typ_to_c_array(type_t t) {
  switch(compress(t)) { // FIX: do we handle tq correctly?
  case &ArrayType(ai): return cstar_type(typ_to_c_array(ai.elt_type),ai.tq);
  default: return typ_to_c(t);
  }
}

static aggrfield_t aggrfield_to_c(aggrfield_t f, type_t new_type) {
  // JGM: I'm making the qualifiers non-const here to allow initialization
  let ans = new *f;
  ans->type = new_type;
  ans->requires_clause = NULL;
  ans->tq = mt_tq;
  return ans;
}

static void enumfields_to_c(list_t<enumfield_t> fs) {
  return;   // FIX: assumes all constant expressions are fine as C expressions
}

static bool is_boxed_tvar(type_t t) {
  switch (compress(t)) {
  case &VarType(tv): return Kinds::kind_leq(type_kind(t),&Kinds::bk);
  default: return false;
  }
}
static bool is_abstract_type(type_t t) {
  switch (type_kind(t)) {
  case &Kind{.kind = AnyKind, ...}: return true;
  default: return false;
  }
}
static bool is_void_star(type_t t) {
  switch (compress(t)) {
  case &PointerType(PtrInfo{t2,_,_}): return is_void_type(t2);
  default: return false;
  }
}
static bool is_void_star_or_boxed_tvar(type_t t) {
  return is_void_star(t) || is_boxed_tvar(t);
}
static bool is_pointer_or_boxed_tvar(type_t t) {
  return is_pointer_type(t) || is_boxed_tvar(t);
}

type_t typ_to_c(type_t t) {
  switch (t) {
  case &AppType(&VoidCon,_): return t;
  case &Cvar(...): return void_star_type(); //Cvar's are purely Cyclone types
  case &Evar(_,*t2,_,_):
    if (*t2 != NULL)
      return typ_to_c((type_t)(*t2));
    return *t2 = void_star_type();
  case &VarType(tv):
    if (Kinds::tvar_kind(tv,&Kinds::bk)->kind == AnyKind)
      return void_type;
    return void_star_type(); // map `a to void *
  case &AppType(&DatatypeCon(_),_): return void_type;
  case &AppType(&DatatypeFieldCon({.KnownDatatypefield=$(tud,tuf)}),_):
    return strctq(collapse_qvars(tuf->name,tud->name));
  case &AppType(&DatatypeFieldCon(_),_):
    toc_impos("unresolved DatatypeFieldType");
  case &PointerType(PtrInfo(t2,tq,PtrAtts(_,_,bnds,...))):
    // t2? maps to struct fat_ptr.
    // t2* and t2@ map to t2*.  Regions and zero-term are irrelevant.
    t2 = typ_to_c(t2);
    if (get_bounds_exp_constrain(bounds_one(),bnds,true) == NULL)
      return fat_ptr_type();
    return star_type(t2,heap_rgn_type,al_qual_type,tq,false_type,false_type);
  case &AppType(&IntCon(_,_),_):
  case &AppType(&FloatCon(_),_): return t;
  case &ArrayType(ArrayInfo{t2,tq,e,_,ztl}):
    return array_type(typ_to_c(t2),tq,e,false_type,ztl);
  case &FnType(FnInfo{_,_,tq2,t2,args,c_vararg,cyc_vararg,_,atts,...}):
    // just drop the type arguments & effect and translate the nested types
    // also, drop any format descriptors
    let new_atts = Atts::atts2c(atts);
    let new_args = List::map(arg_to_c,args);
    if (cyc_vararg != NULL) {
      // region for array type irrelevant
      let t =typ_to_c(fatptr_type(cyc_vararg->type,heap_rgn_type,al_qual_type,mt_tq,false_type,false_type));
      let vararg = new $(cyc_vararg->name,cyc_vararg->tq,t);
      new_args = List::imp_append(new_args,new List(vararg,NULL));
    }
    return new FnType(FnInfo{NULL,NULL,tq2,typ_to_c(t2),new_args,
                               c_vararg,NULL,NULL,new_atts,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL});
  case &AnonAggrType(k,_,fs):
    // similar to tuple translation (introduce sharing to appease C)
    // but we have full aggrfields to deal with
    let fs2 = NULL;
    for(; fs!=NULL; fs=fs->tl)
      fs2 = new List(aggrfield_to_c(fs->hd,typ_to_c(fs->hd->type)), fs2);
    return add_anon_aggr_type(k,imp_rev(fs2));
  case &AppType(c as &AggrCon(info),ts):
    // If we are in C code, the implementation may not be set here.
    switch (info) {
    case {.UnknownAggr = _}: // drop any type args
      return (ts==NULL) ? t : new AppType(c,NULL);
    default: break;
    }
    let ad = get_known_aggrdecl(info);
    // check that it turned out to be a mem!
    if (ad->expected_mem_kind && ad->impl == NULL)
      Warn::warn2(0, ad, " was never defined.");
    // Have to watch out for flaky gcc ...
    if(ad->kind==UnionA)
      return aggrdecl_type(ad->name,unionq_type);
    let fs = (ad->impl == NULL) ? NULL : ad->impl->fields;
    if (fs == NULL) return aggrdecl_type(ad->name,strctq);
    for (; fs->tl != NULL; fs = fs->tl);
    let last_type = fs->hd->type;
    if (Kinds::kind_leq(&Kinds::ak,type_kind(last_type))) {
      if (ad->expected_mem_kind)
        Warn::warn2(0, ad, " ended up being abstract.");
      // To avoid looping, make sure the instantiation of the last type
      // is not still abstract.  If it is, we can just return the struct type.
      region r;
      let inst = rzip(r,r,ad->tvs,ts);
      let t = rsubstitute(r,inst,last_type);
      if (is_abstract_type(t)) return aggrdecl_type(ad->name,strctq);
      return add_struct_type(ad->name,ad->tvs,ts,ad->impl->fields);
    }
    return aggrdecl_type(ad->name,strctq);
  case &AppType(&EnumCon(tdn,_),_): return t;
  case &AppType(&AnonEnumCon(fs),_): enumfields_to_c(fs); return t;
  case &TypedefType(tdn,ts,td,topt):
    // jrust drop the type arguments and translate the nested types
    // typedef expansion is done in Absynpp::to_tms.
    if (topt == NULL) // drop type args
      return (ts == NULL) ? t : new TypedefType(tdn,NULL,td,NULL);
    return new TypedefType(tdn,NULL,td,typ_to_c(topt));
  case &AppType(&TagCon,_):          return uint_type; // must be unsigned!
  case &AppType(&RgnHandleCon,_):    return rgn_type();
  case &AppType(&AqualHandleCon,_):  return aqualt_type();
  case &AppType(&BuiltinCon(...),_): return t;
  case &AppType(&ComplexCon,_)     : return t;
  // these types get translated when we instantiate aggregates with
  // abstract members -- we just translate them to void* to save pain.
  case &AppType(_,_): return void_star_type();
    // FIX: when we instantiate a struct parameterized by `i::I with
    // valueof_t(42), then we want the 42 to get propagated to any arrays
    // that might occur within.  So, for now, we don't do any translation.
    // This will bite me somewhere else...
  case &ValueofType(e): return t;
  case &TypeofType(e):
    // JGM: we have to eliminate typeof(e)'s since these might
    // occur within a type declaration and we will pull the
    // type-declaration out of scope and put it to the top-level.
    exptypes_to_c(e);
    return (e->topt == NULL) ? t : typ_to_c((type_t)e->topt);
  case &TypeDeclType(&{.r = &Aggr_td(ad),...},_):
    aggrdecl_to_c(ad);
    return aggrdecl_type(ad->name,((ad->kind==UnionA)?unionq_type:strctq));
  case &TypeDeclType(&{.r = &Enum_td(ed),...},_):
    enumdecl_to_c(ed);
    return t;
  case &TypeDeclType(&{.r = &Datatype_td(dd),...},t):
    datatypedecl_to_c(dd);
    return typ_to_c(*t);
  case &SubsetType(vd,...): return typ_to_c(vd->type);
  }
}

static exp_t array_to_ptr_cast(type_t t,exp_t e,seg_t l) {
  switch (t) {
  case &ArrayType(ArrayInfo{t2,tq,_,_,_}):
    return cast_it(star_type(t2,heap_rgn_type,al_qual_type,tq,false_type,false_type),e);
  default: return cast_it(t,e);
  }
}

// returns true when the type contains no pointers. Is conservative
// (does not look at instantiations)
static bool atomic_type(type_t t) {
  switch (compress(t)) {
  case &VarType(_):    return false;
  case &AppType(c,ts):
    switch (c) {
    case &VoidCon: case &IntCon(_,_): case &FloatCon(_):
    case &TagCon: case &EnumCon(...): case &AnonEnumCon(...): return true;
    case &DatatypeCon(_):
    case &RgnHandleCon:
    case &BuiltinCon(...):   return false;
    // FIX: really should compute in terms of the instantiation
    // to be as aggressive as possible.
    // note even without this we'll allocate Position::seg_t with atomic.
    // NOTE: cannot call get_known_aggrdecl b/c we sometimes call this
    // post-translation (with unchecked C types)?? (We shouldn't)
    case &AggrCon(info):
      switch(info) {
      case {.UnknownAggr = _}: return false;
      default: break;
      }
      let ad = get_known_aggrdecl(info);
      if(ad->impl == NULL)
        return false;
      for(let fs = ad->impl->fields; fs != NULL; fs = fs->tl)
        if (!atomic_type(fs->hd->type)) return false;
      return true;
    case &DatatypeFieldCon({.KnownDatatypefield=$(tud,tuf)}):
      for (let tqs = tuf->typs; tqs != NULL; tqs = tqs->tl)
        if (!atomic_type((*tqs->hd)[1])) return false;
      return true;
    default: toc_impos("atomic_typ: bad type ",t);
    }
  case &FnType(_): return true;
  case &ArrayType(ArrayInfo{t,...}): return atomic_type(t);
  case &AnonAggrType(_,_,fs):
    for (; fs != NULL; fs = fs->tl)
      if (!atomic_type(fs->hd->type)) return false;
    return true;
  case &PointerType(_): return false;
  default: toc_impos("atomic_typ:  bad type ",t);
  }
}

// returns true when field f of the struct/union t has type void*.
static bool is_poly_field(type_t t, field_name_t f) {
 loop:
  switch (compress(t)) {
  case &SubsetType(vd,...): t = vd->type; goto loop;
  case &AppType(&AggrCon(info),_):
    let ad = get_known_aggrdecl(info);
    if (ad->impl == NULL)
      toc_impos("is_poly_field: type missing fields");
    fallthru(ad->impl->fields);
  case &AnonAggrType(_,_,fs):
    let field = lookup_field(fs,f);
    if (field == NULL)
      toc_impos("is_poly_field: bad field ",*f);
    return is_void_star_or_boxed_tvar(field->type);
  default: toc_impos("is_poly_field: bad type ",t);
  }
}

// returns true when e is projection of a field in a struct that has a
// variable type before instantiation.  For instance, the field hd has
// type `a before instantiation in struct List.
static bool is_poly_project(exp_t e) {
  switch (e->r) {
  case &AggrMember_e(e1,f,_,_):
    return is_poly_field((type_t)e1->topt,f) &&
      !is_void_star_or_boxed_tvar((type_t)e->topt);
  case &AggrArrow_e(e1,f,_,_):
    switch (compress((type_t)e1->topt)) {
    case &PointerType(PtrInfo{t,_,_}):
      return is_poly_field(t,f) && !is_void_star_or_boxed_tvar((type_t)e->topt);
    default: toc_impos("is_poly_project: bad type ",(type_t)e1->topt);
    }
  default: return false;
  }
}

// malloc something -- choose malloc routine according to the (Cyclone) type
static exp_t malloc_exp(type_t t,exp_t s) {
  exp_t fn_e = atomic_type(t) ? _cycalloc_atomic_e : _cycalloc_e;
  return set_type(fncall_exp_dl(fn_e,s),void_star_type());
}
// calloc something -- choose calloc routine according to the (Cyclone) type
static exp_t calloc_exp(type_t elt_type, exp_t s, exp_t n) {
  exp_t fn_e = atomic_type(elt_type) ? _cyccalloc_atomic_e : _cyccalloc_e;
  return set_type(fncall_exp_dl(fn_e,s,n),void_star_type());
}
// region malloc something
static exp_t rmalloc_exp(exp_t rgn, exp_t aq, exp_t s) {
  return set_type(fncall_exp_dl(_region_malloc_e,rgn,aq,s),void_star_type());
}
static exp_t aqmalloc_exp(exp_t aq, exp_t s) {
  return set_type(fncall_exp_dl(_aqual_malloc_e,aq,s),void_star_type());
}
// region vmalloc something
static exp_t rvmalloc_exp(exp_t rgn, exp_t s) {
  return set_type(fncall_exp_dl(_region_vmalloc_e,rgn,s),void_star_type());
}
// region malloc (inlined) something
static exp_t rmalloc_inline_exp(exp_t rgn, exp_t aq, exp_t s) {
  return set_type(fncall_exp_dl(_fast_region_malloc_e,rgn,aq,s),void_star_type());
}
// rcalloc something
static exp_t rcalloc_exp(exp_t rgn, exp_t aq, exp_t s, exp_t n) {
  return set_type(fncall_exp_dl(_region_calloc_e,rgn,aq,s,n),void_star_type());
}
static exp_t aqcalloc_exp(exp_t aq, exp_t s, exp_t n) {
  return set_type(fncall_exp_dl(_aqual_calloc_e,aq,s,n),void_star_type());
}
// throw a match exception
static stmt_t throw_match_stmt() {
  return exp_stmt(set_type(fncall_exp_dl(_throw_match_e),
                           void_star_type()),DL);
}

// t*{sz} -> t? at top-level
static exp_t make_toplevel_dyn_arr(type_t t, exp_t sz, exp_t e) {
  // Note e must be either (a) a string or else (b) a [possibly cast]
  // identifier that is an array.
  // For case a, we generate
  //   t x[sz] = e;
  //   {x,x,x+sz};
  // For case b, we generate
  //   {e,e,e+sz};
  exp_t xexp;
  exp_t xplussz;
  switch (e->r) {
  case &Const_e({.String_c  = _}):
  case &Const_e({.Wstring_c = _}):
    qvar_t    x      = temp_var();
    type_t    vd_typ = array_type(char_type,mt_tq,sz,false_type,DL);
    vardecl_t vd     = static_vardecl(x,vd_typ,e);
    result_decls = new List(new_decl(new Var_d(vd),DL),result_decls);
    xexp = cast_it(cstar_type(uchar_type,mt_tq),
                   set_type(var_exp(x,DL),cstar_type(char_type,mt_tq)));
    xplussz = set_type(add_exp(xexp,sz,DL),cstar_type(uchar_type,mt_tq));
    break;
  default:
    xexp = cast_it(void_star_type(),e);
    // Note: If e is NULL, element size of 0 is fine!
    xplussz = cast_it(void_star_type(),add_exp(deep_copy(e),sz,DL));
    break;
  }
  return unresolvedmem_exp(NULL,list(new $(NULL,xexp),
				     new $(NULL,deep_copy(xexp)),
				     new $(NULL,xplussz)),DL);
}

///////////////////////////////////////////////////////////////
//              Translation Environments                     //
///////////////////////////////////////////////////////////////
// When break_lab is NULL, translate break to break.  Otherwise,
// translate break to goto of the given label.  Similarly for
// continue.  This is used in the translation of switches and
// exception handlers to get the right control-flow.
//
// Translation of fallthru(e1,...,en) is
// v1 = trans(e1); ... vn = trans(en);
// goto fallthru_info->v[0]
// where the ith element of fallthru_info->v[1] is vi
//
// We can alpha-convert just by mutating a vd->name.  When we hoist
// a declaration (in pattern-compilation), we must alpha-convert.
static struct FallthruInfo {
  var_t label;
  list_t<vardecl_t> binders;
};
static struct Env<`r> {
  var_t *`r break_lab;
  var_t *`r continue_lab;
  struct FallthruInfo *`r fallthru_info;
  bool toplevel;
  bool @`r in_lhs;
  region_t<`r> rgn;
};
typedef struct Env<`r> @`r env_t<`r>;

static env_t<`r> empty_env(region_t<`r> r) {
  return rnew(r) Env(NULL,NULL,NULL,true,rnew(r) false,r);
}

static bool is_toplevel(env_t nv) {
  let &Env{.toplevel=t,...} = nv;
  return t;
}
static env_t<`r+`r2> clear_toplevel(region_t<`r> r, env_t<`r2> e){
  let &Env{b,c,f,t,lhs,_} = e;
  return rnew(r) Env{b,c,f,false,lhs,r};
}
static env_t<`r+`r2> set_toplevel(region_t<`r> r, env_t<`r2> e) {
  let &Env{b,c,f,t,lhs,_} = e;
  return rnew(r) Env{b,c,f,true,lhs,r};
}
static bool in_lhs(env_t nv) {
  let &Env{.in_lhs=b,...} = nv;
  return *b;
}
static void set_lhs(env_t<`r> e, bool b) {
  let &Env{.in_lhs = lhs,...} = e;
  *lhs = b;
}

static env_t<`r+`r2> share_env(region_t<`r> r, env_t<`r2> e) {
  let &Env{b,c,f,t,lhs,_} = e;
  return rnew(r) Env{b,c,f,t,lhs,r};
}

// env for loop body: break and continue labels are set to null,
// exception handler pop counters for break and continue are zeroed
static env_t<`r+`r2> loop_env(region_t<`r> r, env_t<`r2> e){
  let &Env{b,c,f,t,lhs,_} = e;
  return rnew(r) Env{NULL,NULL,f,t,lhs,r};
}

// env for a switch clause: give new label for break, and zero its pop counter
static env_t<`r+`r2>
non_last_switchclause_env(region_t<`r> r, env_t<`r2> e,
			  var_t break_l, var_t fallthru_l,
                          list_t<vardecl_t,`H> fallthru_binders){
  let &Env{b,c,f,t,lhs,_} = e;
  struct FallthruInfo*`r fi =
    rnew(r) FallthruInfo{fallthru_l,fallthru_binders};
  return rnew(r) Env{rnew(r) break_l, c, fi, t,lhs,r};
}
static env_t<`r+`r2>
last_switchclause_env(region_t<`r> r, env_t<`r2> e, var_t break_l){
  let &Env{b,c,f,t,lhs,_} = e;
  return rnew(r) Env{rnew(r) break_l, c,NULL,t,lhs,r};
}

#ifdef COARSE_REGIONS
#define TOC_RGN(env,r) let &Env{.rgn = r, ...} = (env);
#else
#define TOC_RGN(env,r) region r;
#endif

///////////////////////////////////////////////////////////////
//              Translation of Expressions                   //
///////////////////////////////////////////////////////////////
static void exp_to_c(env_t, exp_t); // forward declarations
static void stmt_to_c(env_t, stmt_t);
static stmt_t letdecl_to_c(env_t, pat_t, Tcpat::decision_opt_t,
                           type_t, exp_t, stmt_t);
static void local_decl_to_c(env_t,vardecl_t,stmt_t);
static void fndecl_to_c(env_t, fndecl_t, bool cinclude);

static void asm_iolist_types_toc(list_t<$(string_t, exp_t)@> l) {
  for(; l!=NULL; l = l->tl)
    exptypes_to_c((*l->hd)[1]);
}

static bool do_null_check(exp_t e) {
  switch(e->annot) {
  case &InsertChecks::NoCheck: return false;
  case &InsertChecks::NullOnly:
  case &InsertChecks::NullAndFatBound:
  case &InsertChecks::NullAndThinBound(_): return true;
  case &InsertChecks::FatBound:
  case &InsertChecks::ThinBound(_): return false;
  default: Warn::impos_loc2(e->loc,"Toc: do_null_check");
  }
}
// shared by exp_to_c cases for Subscript_e, AggrArrow_e, and Deref_e
// translates and mutates ptr by adding necessary checks
// input: no index means 0 (usually leads to smaller code than actually using 0)
// result: DIRECT_DEREF means the index has **already been calculated in mutated ptr** so
//         caller should drop the index and just do a dereference.  Drop subscript just
//         means that caller shouldn't do a dereference and should drop subscript.
//         LEAVE_SUBSCRIPT means to leave the expression as a subscript operation.
//   (result is irrelevant to caller when index is NULL)
enum PTR_ANS { DIRECT_DEREF, DROP_SUBSCRIPT, LEAVE_SUBSCRIPT};

static enum PTR_ANS ptr_use_to_c(env_t nv, exp_t ptr, absyn_annot_t annot,
                                 exp_opt_t index) {
  enum PTR_ANS  ans;
  let   old_lhs = in_lhs(nv);
  let   old_typ = compress((type_t)ptr->topt);
  let   new_typ = typ_to_c(old_typ);
  exp_t fn_e    = _check_known_subscript_notnull_e; // see last two cases
  set_lhs(nv,false);
  exp_to_c(nv, ptr);
  if(index != NULL)
    exp_to_c(nv,index);
  switch(old_typ) {
  case &PointerType(PtrInfo{ta,tq,PtrAtts(_,_,b,zt,...)}):
    switch(annot) {
    case &InsertChecks::NoCheck:
      if(!get_bounds_exp_constrain(bounds_one(),b,true)) {
        // must make sure to update the type on any modified expression
        // so that toseq knows how to deal with it.
        let newt = cstar_type(typ_to_c(ta),tq);
	ptr->r = cast_it_r(newt,get_curr(deep_copy(ptr)));
        ptr->topt = newt;
      }
      ans = LEAVE_SUBSCRIPT;
      break;
    case &InsertChecks::NullOnly:
      if(!get_bounds_exp_constrain(bounds_one(),b,true)) {
        // rewrite e to be e.curr
        let newt = cstar_type(typ_to_c(ta),tq);
	ptr->r = cast_it_r(newt,get_curr(deep_copy(ptr)));
        ptr->topt = newt;
        // if we have x[e] where x is a fat pointer and have proven that
        // no bounds check is needed, then it must be that e is unsigned-<
        // numelts(x).  In turn, this implies that numelts(x) >= 0 which
        // implies x is not NULL.  (See insert_checks.)
	//         if (index != NULL)
	//           toc_impos("subscript of ? with no bounds check but need null check");
      }
      // _check_null(e)
      ptr->r=fncall_exp_dl(_check_null_e,deep_copy(ptr))->r;
      ans = LEAVE_SUBSCRIPT;
      break;
    case &InsertChecks::NullAndFatBound: fallthru; // null check comes for free
    case &InsertChecks::FatBound:
      // ((ta1 *)_check_fat_subscript(e1, sizeof(ta1), ind))
      type_t ta1 = typ_to_c(ta);
      type_t newt = cstar_type(ta1,tq);
      exp_t  ind = index ? index : set_type(uint_exp(0,DL),uint_type);
      ptr->r = cast_it_r(newt, 
                         set_type(fncall_exp_dl(_check_fat_subscript_e,
                                                deep_copy(ptr),
                                                sizeoftype_exp(ta1,DL),
                                                ind),cstar_type(uchar_type,mt_tq)));
      ptr->topt = newt;
      ans = DIRECT_DEREF;
      break;
    case &InsertChecks::NullAndThinBound(bd):
      fn_e = _check_known_subscript_null_e;
      fallthru(bd);
    case &InsertChecks::ThinBound(bd):
      type_t ta1 = typ_to_c(ta);
      exp_t  ind = index ? index : set_type(uint_exp(0,DL),uint_type);

      // requiring the bound to be 1 is a hack, but avoids strange
      // performance degradation (surprising searches for 0)
      let $(i,valid) = Evexp::eval_const_uint_exp(bd);
      if(!valid || i != 1 || !is_zeroterm_pointer_type((type_t)ptr->topt)) {
	// ((ta1*)_fn_e(e1, esz, sizeof(ta1), ind)
        // JGM: must do something different when ta1 is an array type.
        let newp = deep_copy(ptr);
        switch (Absyn::compress(ta1)) {
        case &ArrayType(ainfo):
          newp->topt = cstar_type(ainfo.elt_type,tq);
          ptr->r = cast_it_r(cstar_type(ainfo.elt_type,tq),
                             set_type(fncall_exp_dl(fn_e, newp,
                                                    bd, 
                                                    set_type(times_exp((exp_t)ainfo.num_elts,
                                                                       sizeoftype_exp(ainfo.elt_type,DL),
                                                                       0),uint_type), 
                                                    ind),cstar_type(char_type,tq)));
          ans = DROP_SUBSCRIPT;
          break;
        default:
          newp->topt = cstar_type(ta1,tq);
          ptr->r = cast_it_r(cstar_type(ta1,tq),
                             set_type(fncall_exp_dl(fn_e, newp,
                                                    bd, sizeoftype_exp(ta1,DL), ind),
                                      cstar_type(char_type,tq)));
          ans = DIRECT_DEREF;
          break;
        }
      } else {
	// special case: null-check suffices when ind is zero
	if(is_zero(bd)) {
	  if(fn_e == _check_known_subscript_null_e)
	    // _check_null(e))
	    ptr->r = fncall_exp_dl(_check_null_e, deep_copy(ptr))->r;
	  ans = LEAVE_SUBSCRIPT;
	} else {
	  // get the right run-time function (always does a null-check)
	  // *((ta2)_zero_arr_plus(e1, esz, e2)
	  if(isCharStar(ptr))
	    ptr->r = fncall_exp_r(_zero_arr_plus_char_e,
				   deep_copy(ptr),bd,ind);
	  else
	    ptr->r = cast_it_r(typ_to_c(old_typ),
			       fncall_exp_dl(_zero_arr_plus_other_e,
					     sizeoftype_exp(pointer_elt_type(typ_to_c(old_typ)),DL),
					     deep_copy(ptr),bd,ind));
	  ans = DIRECT_DEREF;
	}
      }
      break;
    default: toc_impos("FIX: ptr_use_to_c, bad annotation");
    }
    set_lhs(nv,old_lhs);
    return ans;
  default: toc_impos("ptr_use_to_c: non-pointer-type");
  }
}

static type_t get_cyc_type(exp_t e) {
  if (e->topt == NULL) toc_impos("Missing type in primop ");
  return (type_t)e->topt;
}
static $(tqual_t, type_t)@ tup_to_c(exp_t e) {
  return new $(mt_tq, typ_to_c((type_t)e->topt));
}

// adds one for zeroterm.  does not multiply by element size
static exp_opt_t array_length_exp(exp_t e) {
  switch(e->r) {
  case &Array_e(dles):
    for(let dles2=dles; dles2 != NULL; dles2 = dles2->tl)
      if((*dles2->hd)[0] != NULL) // sanity check
	unimp("array designators for abstract-field initialization");
    fallthru(set_type(signed_int_exp(length(dles),DL),sint_type),false);
  case &Comprehension_e(_,bd,_,zt): fallthru(bd,zt);
  case &ComprehensionNoinit_e(bd,_,zt):
    bd = deep_copy(bd);
    return zt ? set_type(add_exp(bd,set_type(uint_exp(1,DL),uint_type),DL),uint_type) : bd;
  default: return NULL;
  }
}
// when using a struct-hack, find what we need to add to a malloc-argument.
// while tempting to say "keep track of this when you translate the expression"
// in all we are seeing if it is simpler not to keep track of when we are
// "directly under a new" (see New_e case of exp_to_c)
static exp_opt_t get_varsizeexp(exp_t e) {
  // * we just need to detect struct-hacks, where we have a zero-length array
  //   because the initializer has unknown length
  // * few cases because we have already translated e to C and we are
  //   concerned only with a (nested) array initializer
  // * watch out for casts?? (make sure translation to C doesn't put them in
  // * also make sure the aggr is "known"
  // * FIX? can unions still be around here?
  let dles;
  let field_types;
  switch(e->r) {
  case &Aggregate_e(_,_,dles2,_): dles=dles2; break;
  default: return NULL; // if not a struct, then no struct hack possible
  }
  switch(compress((type_t)e->topt)) {
  case &AppType(&AggrCon({.KnownAggr = &ad}),_):
    if(ad->impl==NULL || ad->kind == UnionA)
      return NULL; // correct and otherwise will not find "last field"
    field_types = ad->impl->fields;
    break;
    // else silently return because something translated to an aggregate
    // may not have set the topt field
  default: return NULL;
  }
  if(field_types==NULL) // weird case: struct with no fields (possible?)
    return NULL;
  for(; field_types->tl != NULL; field_types = field_types->tl)
    ;
  let last_type_field = field_types->hd;
  for(; dles != NULL; dles=dles->tl) {
    let &$(ds,e2) = dles->hd;
    let f = designatorlist_to_fieldname(ds);
    if(!strptrcmp(f,last_type_field->name)) {
      let nested_ans = get_varsizeexp(e2);
      if(nested_ans != NULL)
	return nested_ans;
      switch(compress(last_type_field->type)) {
      case &ArrayType(ArrayInfo{.elt_type=elt_type,.num_elts=type_bd,...}):
	// key invariant: zero-length array means struct hack
	if(type_bd == NULL || !is_zero(type_bd))
	  return NULL;
	// DJG: not sure these pad bytes are necessary, but the old
	//      version had them
	// FIX: as was try before, we execute the bound twice, and once
	//      in a position where the flow analysis does not expect
	return 
          set_type(add_exp(set_type(fncall_exp_dl(_check_times_e,
                                                  (exp_t)array_length_exp(e2),
                                                  sizeoftype_exp(elt_type,DL)),
                                    uint_type),
                           set_type(signed_int_exp(PAD_BYTES,DL),sint_type),
                           DL),uint_type);
      default: return NULL;
      }
    }
  }
  toc_impos("get_varsizeexp: did not find last struct field");
}

static int get_member_offset(aggrdecl_t ad, field_name_t f) {
  let fs = ad->impl->fields;
  for (int i=1; fs != NULL; fs = fs->tl, ++i)
    if (strcmp(*fs->hd->name,*f) == 0)
      return i;
  toc_impos("get_member_offset ", *f, " failed");
}

// functions for passing to lvalue_assign (see below)
static exp_t assignop_lvalue(exp_t el, $(opt_t<primop_t,`H>,exp_t)@ pr) {
  let res = assignop_exp(el,(*pr)[0],(*pr)[1],DL);
  res->topt = el->topt;
  return res;
}
static exp_t address_lvalue(exp_t e1, bool ignore) {
  let res = address_exp(e1,DL);
  if (e1->topt != NULL) res->topt = cstar_type(e1->topt,mt_tq);
  return res;
}
static exp_t incr_lvalue(exp_t e1, incrementor_t incr) {
  let res = new_exp(new Increment_e(e1,incr),DL);
  res->topt = e1->topt;
  return res;
}

static void lvalue_assign_stmt(stmt_t s,list_t<field_name_t,`H> fs,
			       exp_t f(exp_t,`a), `a f_env);

// e1 is the result of translating an lvalue.  fs is the path of struct
// fields that we're assigning to on e1 (if any).  The translation
//  may have inserted NULL checks, etc., but buried within e1 is an lvalue.
// We find the underlying lvalue, call it el.
// We replace el in e1 with f(el,env)
// We assume that variables in f(el,env) will not be captured by any
static void lvalue_assign(exp_t e1, list_t<field_name_t,`H> fs,
			  exp_t f(exp_t,`a), `a f_env){
  switch (e1->r) {
  case &StmtExp_e(s): lvalue_assign_stmt(s,fs,f,f_env); break;
  case &Cast_e(t,e,_,_):  lvalue_assign(e,fs,f,f_env); break;
  case &AggrMember_e(e,fld,is_tagged,is_read):
    // Hack: strip off the struct member -- the base case adds it back in.
    e1->r = e->r;
    lvalue_assign(e1,new List(fld,fs),f,f_env);
    break;
  default:
    // Note: this may not be an lvalue b/c of &arr where arr has an array type.
    // WARNING: If the translation of lvalues changes, we may need to change
    //          how we find the "inner lvalue".
    // make a copy so we don't create a loop
    exp_t e1_copy = deep_copy(e1);
    // add the path back on to the expression
    for (; fs != NULL; fs = fs->tl)
      e1_copy = member_exp(e1_copy,fs->hd,e1_copy->loc);
    e1->r = f(e1_copy, f_env)->r;
    break;
  }
}
static void lvalue_assign_stmt(stmt_t s,list_t<field_name_t,`H> fs,
			       exp_t f(exp_t,`a), `a f_env) {
  switch (s->r) {
  case &Exp_s(e1):    lvalue_assign(e1,fs,f,f_env);      break;
    // we assume free vars of e2 are not captured by d
  case &Decl_s(d,s2): lvalue_assign_stmt(s2,fs,f,f_env); break;
  case &Seq_s(_,s2):  lvalue_assign_stmt(s2,fs,f,f_env); break;
  default: toc_impos("lvalue_assign_stmt: ",s);
  }
}

// we want to take the address of e but it may no longer be a valid
// lhs, due to a cast or null-check or whatever.
static void push_address_stmt(stmt_t); // mutual recursion
static exp_t push_address_exp(exp_t e) {
  switch (e->r) {
  case &Cast_e(*t,*e1,_,_):
    *e1 = push_address_exp(*e1);
    *t = cstar_type(*t,mt_tq);
    e->topt = *t;
    return e;
  case &Deref_e(e1): return e1;
    // we only have the StmtExp_e case because of assignments to
    // tagged union members -- see tagged_union_assignop
  case &StmtExp_e(s): push_address_stmt(s); return e;
  default:
    if (is_lvalue(e)) return address_lvalue(e,DL);
    toc_impos("can't take & of exp ",e);
  }
}
static void push_address_stmt(stmt_t s) {
  switch (s->r) {
  case &Seq_s(_,s2): fallthru(s2);
  case &Decl_s(_,s2): push_address_stmt(s2); break;
  case &Exp_s(*e): *e = push_address_exp(*e); break;
  default: toc_impos("can't take & of stmt ",s);
  }
}

// We're translating e which is of the form e_1 op= e_2 where e_1
// involves a zero-terminated pointer and is of the form *ea or
// ea[eb].  We need to prevent overwriting the last zero in the array.
static void zero_ptr_assign_to_c(env_t nv, exp_t e,
                                 exp_t e1, opt_t<primop_t> popt, exp_t e2,
                                 type_t ptr_type,
                                 bool is_fat,
                                 type_t elt_type) {
  // To simplify the translation, we always use a fat pointer and generate:
  //  ({ fat_ptr_type x = ((fat_ptr_type)ea) + eb;
  //     elt_type y = *x; // check here that x is not null and in bounds
  //     elt_type z = y op e2;
  //     if (numelts(x) == 1 && y == zero && z != zero) _throw_arraybounds();
  //     *x.curr = z; })
  // This is generated and *then* translated to ensure the proper constraints.
  type_t fat_ptr_type = fatptr_type(elt_type, heap_rgn_type, al_qual_type, mt_tq, true_type, false_type);
  let c_elt_type = typ_to_c(elt_type);
  let c_fat_ptr_type = typ_to_c(fat_ptr_type);
  let c_ptr_type = cstar_type(c_elt_type, mt_tq);
  let c_ptr_type_opt = new Opt(c_ptr_type);
  exp_t xinit;
  switch (e1->r) {
  case &Deref_e(ea):
    if (!is_fat) {
      ea = cast_exp(fat_ptr_type,ea,false,Other_coercion,DL);
      ea->topt = fat_ptr_type;
      ea->annot = &InsertChecks::NoCheck_val;
    }
    exp_to_c(nv,ea);
    xinit = ea;
    break;
  case &Subscript_e(ea,eb):
    if (!is_fat) {
      ea = cast_exp(fat_ptr_type,ea,false,Other_coercion,DL);
      ea->topt = fat_ptr_type;
      ea->annot = &InsertChecks::NoCheck_val;
    }
    exp_to_c(nv,ea); exp_to_c(nv,eb);
    xinit = fncall_exp_dl(_fat_ptr_plus_e,
			  ea,sizeoftype_exp(typ_to_c(elt_type),DL),eb);
    xinit->topt = c_fat_ptr_type;
    break;
  default: toc_impos("found bad lhs for zero-terminated pointer assignment");
  }
  let x = temp_var();                // build ptr_type x = ea + eb;
  TOC_RGN(nv, rgn2) {
    let x_vd = new Vardecl {Public,x,0,mt_tq,c_fat_ptr_type,xinit,NULL,NULL,false,false,NULL};
    let x_bnd = new Local_b(x_vd);     // build *x -- need to translate here
    let x_exp = varb_exp(x_bnd,DL);  // to check the bound and for NULL
    x_exp->topt = fat_ptr_type;
    let deref_x = deref_exp(x_exp,DL);
    deref_x->topt = elt_type;
    // if e1 is a fat pointer indexing of the form e11[e12] and
    // then *(e11+e12) should have the same kind of check as e11[e12]
    if (is_fat) deref_x->annot = e1->annot; //check bound and NULL only if e1 needed to
    else deref_x->annot = &InsertChecks::NullAndFatBound_val; // check bound and NULL
    exp_to_c(nv,deref_x);
    let y = temp_var();                // build elt_type y = *x;
    let y_vd = new Vardecl {Public,y,0,mt_tq,c_elt_type,deref_x,NULL,NULL,false,false,NULL};
    let y_bnd = new Local_b(y_vd);
    exp_t z_init = e2;                 // build y op e2 and translate
    if (popt != NULL) {
      let y_exp = varb_exp(y_bnd,DL);
      y_exp->topt = deref_x->topt;
      z_init = prim2_exp(popt->v,y_exp,deep_copy(e2),DL);
      z_init->topt = y_exp->topt;
      z_init->annot = &InsertChecks::NoCheck_val;
    }
    exp_to_c(nv,z_init);
    let z = temp_var();                // build z = y op e2;
    let z_vd = new Vardecl {Public,z,0,mt_tq,c_elt_type,z_init,NULL,NULL,false,false,NULL};
    let z_bnd = new Local_b(z_vd);
    // build y == zero and translate -- here, we need to know what
    // the element type is to generate the right zero.
    let y2_exp = varb_exp(y_bnd,DL); y2_exp->topt = deref_x->topt;
    let zero1_exp = signed_int_exp(0,DL);
    let comp1_exp = prim2_exp(Eq,y2_exp,zero1_exp,DL);
    zero1_exp->topt = sint_type;
    comp1_exp->topt = sint_type;
    exp_to_c(nv,comp1_exp);
    // build z != zero and translate
    let z_exp = varb_exp(z_bnd,DL); z_exp->topt = deref_x->topt;
    let zero2_exp = signed_int_exp(0,DL);
    let comp2_exp = prim2_exp(Neq,z_exp,zero2_exp,DL);
    zero2_exp->topt = sint_type;
    comp2_exp->topt = sint_type;
    exp_to_c(nv,comp2_exp);
    // build numelts(x) == 1 directly (no translation)
    let xsizeargs = list(set_type(varb_exp(x_bnd,DL),c_fat_ptr_type),
                         sizeoftype_exp(typ_to_c(elt_type),DL));
    let oneexp = set_type(uint_exp(1,DL),uint_type);
    exp_t xsize;
    xsize = prim2_exp(Eq,set_type(fncall_exp(_get_fat_size_e,xsizeargs,DL),
                                  uint_type),oneexp,DL);
    // start assembling the statement
    let comp_exp = and_exp(xsize,and_exp(comp1_exp,comp2_exp,DL),DL);
    let thr_stmt = exp_stmt(set_type(fncall_exp_dl(_throw_arraybounds_e),void_star_type()),DL);
    let xcurr = get_curr(set_type(varb_exp(x_bnd,DL),c_fat_ptr_type));
    xcurr = cast_it(c_ptr_type,xcurr);
    let deref_xcurr = set_type(deref_exp(xcurr,DL),c_elt_type);
    let asn_exp = set_type(assign_exp(deref_xcurr,set_type(var_exp(z,DL),c_elt_type),DL),c_elt_type);
    let s = exp_stmt(asn_exp,DL);
    s = seq_stmt(ifthenelse_stmt(comp_exp,thr_stmt,skip_stmt(DL),DL),s,DL);
    s = decl_stmt(new Decl(new Var_d(z_vd),DL),s,DL);
    s = decl_stmt(new Decl(new Var_d(y_vd),DL),s,DL);
    s = decl_stmt(new Decl(new Var_d(x_vd),DL),s,DL);
    e->r = stmt_exp_r(s);
  }
}

// we have a read of e1.f or e1->f where e1 does any needed null checks,
// but we now have to do a tag-check.  We translate this to:
//  ({ temp = e1;
//     if (temp->f.tag != f_tag) throw_match();
//     temp->f.val;
//  })
// unless we are in a left-hand-side context, in which case we translate to
//  ({ temp = &e1->f; // okay because e1->f is a legal lhs
//     if (temp->tag != f_tag) throw_match();
//     &temp->val; // DJG: why shouldn't this be temp->val??
//  })
static raw_exp_t check_tagged_union(type_t res_type,
                                    exp_t e1,type_t e1_c_type,
                                    type_t aggrtype,field_name_t f,
                                    bool in_lhs,
                                    exp_t aggrproj(exp_t,field_name_t,seg_t)) {
  aggrdecl_t ad;
  switch (compress(aggrtype)) {
  case &AppType(&AggrCon(info),_): ad = get_known_aggrdecl(info); break;
  default: toc_impos("expecting union but found ", aggrtype,
		     " in check_tagged_union");
  }
  let strct_name = tagged_union_field_struct(aggrtype,f);
  let $(temp,temp_exp) = temp_var_and_exp();
  let f_tag = set_type(signed_int_exp(get_member_offset(ad,f),DL),uint_type);
  if (in_lhs) {
    let e1_p_type = cstar_type(e1_c_type,mt_tq);
    set_type(temp_exp,e1_p_type);
    let temp_f_tag = set_type(aggrarrow_exp(temp_exp,tag_sp,DL),uint_type);
    let test_exp = set_type(neq_exp(temp_f_tag,f_tag,DL),sint_type);
    let temp_f_val = set_type(aggrarrow_exp(deep_copy(temp_exp),val_sp,DL),
                              res_type);
    let sres = exp_stmt(set_type(address_exp(temp_f_val,DL),cstar_type(res_type,mt_tq)),DL);
    let ifs = ifthenelse_stmt(test_exp,throw_match_stmt(),skip_stmt_dl(),DL);
    let e1_f = set_type(address_exp(set_type(aggrproj(e1,f,DL),res_type),DL),e1_p_type);
    let s = declare_stmt(temp,e1_p_type,e1_f,seq_stmt(ifs,sres,DL),DL);
    return stmt_exp_r(s);
  } else {
    set_type(temp_exp,e1_c_type);
    let temp_f_tag = set_type(member_exp(set_type(aggrproj(temp_exp,f,DL),strct_name),tag_sp,DL),uint_type);
    let test_exp = neq_exp(temp_f_tag,f_tag,DL);
    let temp_f_val = member_exp(set_type(aggrproj(deep_copy(temp_exp),f,DL),strct_name),val_sp,DL);
    set_type(temp_f_val,res_type);
    let sres = exp_stmt(temp_f_val,DL);
    let ifs = ifthenelse_stmt(test_exp,throw_match_stmt(),skip_stmt_dl(),DL);
    let s = declare_stmt(temp,e1_c_type,e1,seq_stmt(ifs,sres,DL),DL);
    return stmt_exp_r(s);
  }
}

static bool is_tagged_union_project_impl(type_t t, field_name_t f,
					 int @f_tag, type_t @ tagged_member_type,
					 bool clear_read, bool *is_read) {
  switch (compress(t)) {
  case &AppType(&AggrCon(info),_):
    let ad = get_known_aggrdecl(info);
    *f_tag = get_member_offset(ad,f);
    *tagged_member_type = tagged_union_field_struct(t,f);
    if (clear_read) *is_read = false;
    return ad->impl->tagged;
  default: return false;
  }
}

// return true if e is e1.f or e1->f where e1 is a (pointer to a)
// tagged union.  While we're at it, calculate the tag for the
// corresponding member f_tag.
static bool is_tagged_union_project(exp_t e, int @f_tag,
                                    type_t @ tagged_member_type,
                                    bool clear_read) {
  switch (e->r) {
  case &Cast_e(_,e1,_,_): toc_impos("cast on lhs!");
  case &AggrMember_e(e1,f,_,*is_read):
    return is_tagged_union_project_impl((type_t)e1->topt,f,f_tag,
					tagged_member_type,clear_read,is_read);
  case &AggrArrow_e(e1,f,_,*is_read):
    switch (compress((type_t)e1->topt)) {
    case &PointerType(PtrInfo{.elt_type = et,...}):
      return is_tagged_union_project_impl(et,f,f_tag,
					  tagged_member_type,clear_read,is_read);
    default: return false;
    }
  default: return false;
  }
}

// special case for assignment to a tagged union member (either e1.f
// or e1->f.  In particular, when we have e1->f = e2, we rewrite to:
// ({ temp = &e1->f;
//    temp->tag = f_tag;
//    temp->val = e2; })
// and if we have e1->f op= e2 we rewrite to:
// ({ temp = &e1->f;
//    if (temp->tag != f_tag) throw_match();
//    temp->val op= e2; })
static raw_exp_t tagged_union_assignop(exp_t e1, type_t e1_cyc_type,
                                       opt_t<primop_t,`H> popt,
                                       exp_t e2, type_t e2_cyc_type,
                                       int tag_num, type_t member_type) {
  let $(temp,temp_exp) = temp_var_and_exp();
  set_type(temp_exp,cstar_type(member_type,mt_tq));
  exp_t temp_val = set_type(aggrarrow_exp(temp_exp,val_sp,DL),member_type);
  exp_t temp_tag = set_type(aggrarrow_exp(temp_exp,tag_sp,DL),uint_type);
  exp_t f_tag = set_type(signed_int_exp(tag_num,DL),uint_type);
  stmt_t s3 = exp_stmt(assignop_exp(temp_val,popt,e2,DL),DL);
  stmt_t s2;
  if (popt == NULL)
    s2 = exp_stmt(assign_exp(temp_tag,f_tag,DL),DL);
  else {
    let test_exp = neq_exp(temp_tag,f_tag,DL);
    s2 = ifthenelse_stmt(test_exp,throw_match_stmt(),skip_stmt_dl(),DL);
  }
  stmt_t s1 = declare_stmt(temp,cstar_type(member_type,mt_tq),
                           push_address_exp(e1),
                           seq_stmt(s2,s3,DL),DL);
  return stmt_exp_r(s1);
}


static void exp_to_c(env_t nv, exp_t e) {
  if(e->topt == NULL)
    Warn::impos_loc2(e->loc,"exp_to_c: no type for ",e);
  type_t old_typ = (type_t)e->topt;
  type_t new_typ = typ_to_c(old_typ);
  e->topt = new_typ;
  
  // cases where we think to do checks, set this bool as a sanity check
  bool did_inserted_checks = false;
  switch(e->annot) {
  case &EmptyAnnot: // for Cyclone code generated in Toc that needs no checks
  case &InsertChecks::NoCheck: did_inserted_checks = true; break;
  default: break;
  }
  switch (e->r) {
  case &Pragma_e(...):
    e->r = (raw_exp_t)(zero_exp());
    break;
  case &Const_e({.Null_c = _}):
    // NULL translate to 0 unless a fat pointer, then {0,0,0}, via runtime
    // call unless at top-level
    // note: we don't need the element type b/c the length is 0 (so we lie)
    let zero = set_type(signed_int_exp(0,DL),void_star_type());
    
    if(get_bounds_exp_constrain(bounds_one(),(type_t)get_pointer_bounds(old_typ), true) == NULL) {
      if(is_toplevel(nv))
	e->r = make_toplevel_dyn_arr(old_typ, zero, zero)->r;
      else
	e->r = fncall_exp_r(_tag_fat_e,zero,zero,zero);
    } else
      e->r = (raw_exp_t)(zero_exp());
    break;
  case &Const_e(_): break;
  case &Var_e(_):   break;
  case &Assert_e(e1,static_only,do_check): 
    if (static_only || !do_check)
      e->r = int_exp(Signed,1,DL)->r; 
    else {
      // turn this into:  e1 ? 1 : throw_match()
      exp_to_c(nv,e1);
      e->r = conditional_exp(e1,int_exp(Signed,1,DL),
                             array_to_ptr_cast(typ_to_c(old_typ),
                                               set_type(fncall_exp_dl(_throw_assert_e),void_star_type()),DL),DL)->r;
    }
    break;
  case &Assert_false_e(_): e->r = int_exp(Signed,0,DL)->r; break;
  case &Extension_e(e1): exp_to_c(nv,e1); break;
  case &Primop_e(p,es):
    // Save Cyclone types -- needed for pointer arith stuff
    let old_types = List::map(get_cyc_type,es);
    // Translate args
    List::iter_c(exp_to_c,nv,es);
    switch (p) {
    case Tagof:
      // arg is a pointer to a datatype -- cast it to (unsigned int *) and then
      // dereference it.
      exp_t arg = es->hd;
      e->r = deref_exp(cast_it(cstar_type(uint_type, const_tqual(0)),arg),0)->r;
      break;
    case Numelts:
      exp_t arg = es->hd;
      switch (compress(old_types->hd)) {
      case &PointerType(PtrInfo(elt_type,_,PtrAtts(_,nbl,bound,zt,...))):
        let eopt = get_bounds_exp_constrain(bounds_one(),bound,true);
        if (eopt == NULL)
          // retrieve (last_plus_one - curr) via runtime call
	  e->r = fncall_exp_r(_get_fat_size_e,
			      es->hd,sizeoftype_exp(typ_to_c(elt_type),DL));
        else if (force_type2bool(false,zt)) {
          // when zero-terminated, we have to call "strlen"
	  if(isCharStar(es->hd))
	    e->r = fncall_exp_r(_get_zero_arr_size_char_e,es->hd,eopt);
	  else
	    e->r = fncall_exp_r(_get_zero_arr_size_other_e,
				sizeoftype_exp(typ_to_c(pointer_elt_type(old_types->hd)),DL),
				es->hd,eopt);
	} else if (force_type2bool(false,nbl)) {
	  if (!Evexp::c_can_eval(eopt))
	    Warn::err2(e->loc,"can't calculate numelts");
	  // careful! when this is a nullable pointer, the size might be 0
	  e->r = conditional_exp_r(arg,eopt,set_type(uint_exp(0,DL),uint_type));
	} else
	  e->r = eopt->r; // compile-time evaluation
	break;
      default: toc_impos("numelts primop applied to non-pointer ",
			  ((type_t)arg->topt));
      }
      break;
    case Plus:
      // only translation is for ? pointers or zero-terminated arrays
      //   _dynxxx_ptr_plus(e1,sizeof(elt_type),e2)
      // FIX: allow arithmetic on t ? types at top-level!
      if(is_toplevel(nv))
	unimp("can't do pointer arithmetic at top-level");
      switch (compress(old_types->hd)) {
      case &PointerType(PtrInfo(elt_type,_,PtrAtts(_,_,b,zt,...))):
        let eopt = get_bounds_exp_constrain(bounds_one(),b,true);
	exp_t e1 = es->hd;
	exp_t e2 = es->tl->hd;
        if (eopt == NULL)
          e->r = fncall_exp_r(_fat_ptr_plus_e,
			     e1,sizeoftype_exp(typ_to_c(elt_type),DL),e2);
        else if (force_type2bool(false,zt)) {
	  if(isCharStar(e1))
	    e->r = fncall_exp_r(_zero_arr_plus_char_e,e1,eopt,e2);
	  else
	    e->r = fncall_exp_r(_zero_arr_plus_other_e,
				sizeoftype_exp(typ_to_c(pointer_elt_type(old_types->hd)),DL),
				eopt,e2);
	}
        break;
      default: break;
      }
      break;
    case Minus:
      // only translation is for ? pointers.
      // if e2 is not a fat array, do just like plus of negation,
      // else result type is unsigned int, so subtract curr fields
      type_t elt_type = void_type;
      if(is_fat_pointer_type_elt(old_types->hd,&elt_type)) {
	exp_t e1 = es->hd;
	exp_t e2 = es->tl->hd;
	if(is_fat_pointer_type(old_types->tl->hd)) {
	  e1->r = aggrmember_exp_r(deep_copy(e1),curr_sp);
	  e2->r = aggrmember_exp_r(deep_copy(e2),curr_sp);
	  e1->topt = e2->topt = cstar_type(uchar_type,mt_tq);
	  e->r  = divide_exp(deep_copy(e),
			     sizeoftype_exp(typ_to_c(elt_type),DL),DL)->r;
	} else
	  e->r = fncall_exp_r(_fat_ptr_plus_e,
			      e1,sizeoftype_exp(typ_to_c(elt_type),DL),
			      set_type(prim1_exp(Minus,e2,DL),sint_type));
      }
      break;
    case Eq: case Neq: 
    case Gt: case Gte: case Lt: case Lte:
    case UGt: case UGte: case ULt: case ULte:
      // need to extract .curr field of fat arrays for comparisons
      exp_t e1 = es->hd;
      exp_t e2 = es->tl->hd;
      type_t t1 = old_types->hd;
      type_t t2 = old_types->tl->hd;
      type_t elt_type = void_type; // set in next call
      if (is_fat_pointer_type_elt(t1,&elt_type)) {
	let t = cstar_type(typ_to_c(elt_type),mt_tq);
	e1->r = cast_it_r(t,get_curr(deep_copy(e1)));
	e1->topt = t;
      }
      if (is_fat_pointer_type(t2)) {
	let t = cstar_type(typ_to_c(elt_type),mt_tq);
	e2->r = cast_it_r(t,get_curr(deep_copy(e2)));
	e2->topt = t;
      }
      break;
    default: break; //skip
    }
    break;
  case &Increment_e(e2,incr):
    type_t e2_cyc_typ = (type_t)e2->topt;
    // we need to worry about the case where e2 is of the form
    // *ea or ea[eb] and ea is a zero-terminated pointer, for
    // then we need to know that the inc/dec doesn't destroy the
    // trailing 0.  See the special code in the AssignOp_e case.
    // To combat this, I'm simply disallowing it.
    //
    // Similarly, we need to worry about the case where e2 is a
    // tagged union projection.
    type_t   ignore_typ  = void_type;
    bool     ignore_bool = false;
    int      ignore_int  = 0;
    string_t incr_str    = "increment";
    if (incr == PreDec || incr == PostDec) incr_str = "decrement";
    if (is_zero_ptr_deref(e2,&ignore_typ,&ignore_bool,&ignore_typ))
      Warn::impos_loc2(e->loc,"in-place ", incr_str, " is not supported when ",
		       "dereferencing a zero-terminated pointer");
    if (is_tagged_union_project(e2,&ignore_int,&ignore_typ,true)) {
      exp_t    one = signed_int_exp(1,DL);
      primop_t op;
      one->topt = sint_type;
      switch (incr) {
      case PreInc: op = Plus;  break;
      case PreDec: op = Minus; break;
      default: Warn::impos_loc2(e->loc,"in-place post", incr_str,
				" is not supported on @tagged union members");
      }
      e->r = new AssignOp_e(e2,new Opt(op),one);
      exp_to_c(nv,e);
      return; // recursive call should check for inserted checks
    }
    set_lhs(nv,true);
    exp_to_c(nv,e2);
    set_lhs(nv,false);
    // only t ? or zero-terminated types are translated funny,
    // note that e2 is an lvalue!
    type_t elt_typ = void_type;
    if(is_fat_pointer_type_elt(old_typ,&elt_typ)) {
      int change = 1;
      let fn_e = (incr==PostInc || incr==PostDec) ?
        _fat_ptr_inplace_plus_post_e : _fat_ptr_inplace_plus_e;
      if (incr == PreDec || incr == PostDec)
        change = -1;
      e->r = fncall_exp_r(fn_e, push_address_exp(e2),
			  sizeoftype_exp(typ_to_c(elt_typ),DL),
			  set_type(signed_int_exp(change,DL),sint_type));
    } else if (is_zero_pointer_type_elt(old_typ,&elt_typ)) {
      // we treat ++x specially -- this becomes
      //   if (x != 0 && *x != 0) ++x; else _throw_arraybounds()
      // or even
      //   if (*x != 0) ++x; else _throw_arraybounds()
      // if we can show x is not null.
      did_inserted_checks = true;
      if (incr != PostInc) {
        let x = temp_var();
        let et = typ_to_c(old_typ);
        let t = cstar_type(et,mt_tq);
        let xe = set_type(var_exp(x,DL),t);
        let deref_x = set_type(deref_exp(xe,DL),et);
        let xexp = push_address_exp(e2);
        let test_left = set_type(deref_exp(deref_x,DL),sint_type);
        let testexp = neq_exp(test_left,set_type(int_exp(None,0,DL),sint_type),DL);
        if (do_null_check(e))
          testexp = and_exp(neq_exp(deep_copy(deref_x),
                                    set_type(int_exp(None,0,DL),sint_type),DL),
                            testexp,DL);
        let s = ifthenelse_stmt(testexp,
              exp_stmt(increment_exp(deep_copy(deref_x),PreInc,DL),DL),
	      exp_stmt(set_type(fncall_exp_dl(_throw_arraybounds_e),
                                void_star_type()),DL),DL);
        s = seq_stmt(s,exp_stmt(deep_copy(deref_x),DL),DL);
        e->r = stmt_exp(declare_stmt(x,t,xexp,s,DL),DL)->r;
      } else {
        // e.g, x++ becomes _zero_arr_inplace_plus_post(x,1) (does null check)
	if(isCharStar(e2))
	  e->r = fncall_exp_r(_zero_arr_inplace_plus_post_char_e,
			      push_address_exp(e2),
                              set_type(signed_int_exp(1,DL),sint_type));
	else
	  e->r = cast_it_r(typ_to_c(e2_cyc_typ),
			   fncall_exp_dl(_zero_arr_inplace_plus_post_other_e,
					 sizeoftype_exp(pointer_elt_type(typ_to_c(e2_cyc_typ)),DL),
					 push_address_exp(e2),
					 set_type(signed_int_exp(1,DL),sint_type)));
      }
    } else if(elt_typ == void_type && !is_lvalue(e2)) {
      lvalue_assign(e2,NULL,incr_lvalue,incr);
      *e = *e2;
    }
    break;
  case &AssignOp_e(e1,popt,e2):
    // FIX: not sure all these special-cases work right *together*...
    //
    // We need to know whether or not the expression is of the form
    // *ea op= e2 or ea[eb] op= e2 where ea is a zero-terminated pointer.
    // The reason is that we need to ensure not only that the pointer
    // is in bounds, but also, if it's pointing to the last element
    // (i.e., the zero) then the value written in should continue to
    // be zero.  So, for instance, if we have *ea = e2, then either ea
    // can't point to the last element or e2 must be 0.  If we have
    // *ea op= e2 then we need to know that either ea can't point to
    // the last element or (0 op= e2) is 0.
    //
    // Similarly, when e1 is a tagged union member, then we need to
    // update its tag as well as the value.  This is problematic when
    // we have something like e.x += 1 which is both a read and a write
    // of the member.
    // See if e1 is a projection on a tagged union member.
    type_t  e1_old_typ = (type_t)e1->topt;
    type_t  e2_old_typ = (type_t)e2->topt;
    int f_tag = 0; // bogus unless e1_tagged_proj
    type_t tagged_member_struct_type = void_type; // bogus unless e1_tagged_proj
    if (is_tagged_union_project(e1,&f_tag,&tagged_member_struct_type,true)) {
      set_lhs(nv,true);
      exp_to_c(nv,e1);
      set_lhs(nv,false);
      exp_to_c(nv,e2);
      e->r = tagged_union_assignop(e1,e1_old_typ,popt,e2,e2_old_typ,f_tag,
                                   tagged_member_struct_type);
      break;
    }
    type_t ptr_type = void_type;
    type_t elt_type = void_type;
    bool is_fat = false;
    if (is_zero_ptr_deref(e1,&ptr_type,&is_fat,&elt_type)) {
      zero_ptr_assign_to_c(nv, e, e1, popt, e2, ptr_type, is_fat, elt_type);
      return; //trust that call to zero_ptr_assign_to_c does any inserted checks
    }
    // See if e1 is a polymorphic field (i.e., is an instantiated type
    // variable) -- if so, coerce e2 to void*.
    bool e1_poly = is_poly_project(e1);
    set_lhs(nv,true);
    exp_to_c(nv,e1);
    set_lhs(nv,false);
    exp_to_c(nv,e2);
    // special case for pointer arithmetic of t ? or zero-terminated types
    bool done = false;
    if(popt != NULL) {
      type_t elt_typ = void_type;
      if(is_fat_pointer_type_elt(old_typ,&elt_typ)) {
        _ change;
        switch(popt->v) {
        case Plus:  change = e2; break;
        case Minus: change = set_type(prim1_exp(Minus,e2,DL),sint_type); break;
        default:    toc_impos("bad t ? pointer arithmetic");
        }
        done = true;
        // FIX: Is e1 definitely still an lvalue? Probably not!!
        let fn_e = _fat_ptr_inplace_plus_e;
        e->r = fncall_exp_r(fn_e,push_address_exp(e1),
			    sizeoftype_exp(typ_to_c(elt_typ),DL),
			    change);
      } else if (is_zero_pointer_type_elt(old_typ,&elt_typ))
        // We're doing x += e where x is a zero-terminated pointer.
        // Make sure we don't run off the end.
        switch (popt->v) {
        case Plus:
          done = true;
	  if(isCharStar(e1))
	    e->r = fncall_exp_r(_zero_arr_inplace_plus_char_e,
				e1,e2);
	  else
	    e->r = cast_it_r(typ_to_c(e1_old_typ),
			     fncall_exp_dl(_zero_arr_inplace_plus_other_e,
					   sizeoftype_exp(pointer_elt_type(typ_to_c(e1_old_typ)),DL),
					   e1,e2));
          break;
        default: toc_impos("bad zero-terminated pointer arithmetic");
        }
    }
    if(!done) {
      // this cast is necessary to avoid gcc warnings
      if (e1_poly) {
        e2->r = cast_it_r(void_star_type(), deep_copy(e2));
        e2->topt = void_star_type();
      }
      // The typechecker guarantees that e1 starts out as an lvalue, but
      // the translation might have to insert casts, NULL checks,
      // declarations of temps, bound checks, etc.  If so we look into e1,
      // find the lvalue, and put the assignment there.
      if (!is_lvalue(e1)) {
        lvalue_assign(e1,NULL,assignop_lvalue,new $(popt,e2));
        *e = *e1;
      }
    }
    break;
  case &Conditional_e(e1,e2,e3):
    exp_to_c(nv,e1);
    exp_to_c(nv,e2);
    exp_to_c(nv,e3);
    break;
  case &And_e(e1,e2): fallthru(e1,e2);
  case &Or_e(e1,e2):  fallthru(e1,e2);
  case &SeqExp_e(e1,e2):
    exp_to_c(nv,e1);
    exp_to_c(nv,e2);
    break;
  case &FnCall_e(e1,es,NULL,_):
    type_t e1_typ = (type_t)e1->topt;
    exp_to_c(nv,e1);
    did_inserted_checks = true;
    if(do_null_check(e))
      e1->r = fncall_exp_dl(_check_null_e,deep_copy(e1))->r;
    List::iter_c(exp_to_c,nv,es);
    break;
  case &FnCall_e(e1,es,&VarargCallInfo{num_varargs,injectors,vai},_):
    // if vai->inject:
    //    t vm = injector[m](es[n])
    //    ...
    //    t v0 = injector[0](es[n-num_varargs+1])
    //    t argv[num_varargs] = {&v0, ..., &vm};
    // else
    //    t argv[num_varargs] = {es[n-num_varargs+1], ..., es[n]};
    // e1(es[0], ..., es[n-num_varargs], tag_fat(argv, sizeof(t), num_varargs));
    TOC_RGN(nv,r) {
      let $(argv,argvexp) = temp_var_and_exp();
      exp_t  num_varargs_exp = set_type(signed_int_exp(num_varargs,DL),sint_type);
      type_t cva_type = typ_to_c(vai->type);
      type_t arr_type = array_type(cva_type,mt_tq,num_varargs_exp,false_type,
                                  DL);

      int num_args     = List::length(es);
      int num_normargs = num_args - num_varargs;

      // build argument list and set es to the varargs portion
      list_t<exp_t> new_args = NULL;
      for(int i=0; i < num_normargs; ++i, es=es->tl) {
	exp_to_c(nv,es->hd);
	new_args = new List(es->hd, new_args);
      }
      new_args = new List(set_type(fncall_exp_dl(_tag_fat_e,
                                                 set_type(
                                                 (num_varargs==0?
                                                  uint_exp(0,DL):argvexp),
                                                 uint_type),
                                                 set_type(sizeoftype_exp(cva_type,DL),uint_type),
                                                 num_varargs_exp),fat_ptr_type()),
			  new_args);
      new_args = imp_rev(new_args);
      // make the function call
      type_t e1_typ = (type_t)e1->topt;
      exp_to_c(nv,e1);
      did_inserted_checks = true;
      if(do_null_check(e))
	e1->r = fncall_exp_dl(_check_null_e,deep_copy(e1))->r;
      if(num_varargs==0) {
	e->r = fncall_exp(e1,new_args,DL)->r;
	break;
      }
      stmt_t s = exp_stmt(set_type(fncall_exp(e1,new_args,DL),typ_to_c((type_t)e->topt)),DL);

      // make the declarations and prepend them
      if(vai->inject) {
	datatypedecl_t tud;
	switch(compress(pointer_elt_type(vai->type))) {
	case &AppType(&DatatypeCon({.KnownDatatype=&x}),_): tud = x; break;
	default: toc_impos("unknown datatype in vararg with inject");
	}
	$(qvar_t,type_opt_t) ? vs = rnew(r) {for i < num_varargs : $(temp_var(),NULL)};
        // figure out the types of the args
        let is2 = rev(injectors);
        let i = length(es)-1;
        for (let es2 = es; es2 != NULL; es2 = es2->tl, is2=is2->tl, --i) {
          exp_t arg = es2->hd;
          type_t arg_type = (type_t)arg->topt;
          qvar_t var = vs[i].f0;
          let &Datatypefield{qv,tqts,...} = is2->hd;
	  let tdn = collapse_qvars(qv,tud->name);
          let t = new AppType(new AggrCon(UnknownAggr(StructA, tdn, NULL)), NULL);
          //type_t field_typ = typ_to_c((*tqts->hd)[1]);
          vs[i].f1 = t;
        }
	// declare argv = {&v1,&v2,...,&vnum_varargs}
	// we now make it an Array_e, which RemoveAggrs converts to a
	// sequence of assignments
	let array_args = NULL;
	for(int i=num_varargs-1; i >= 0; --i) {
          let $(v,t) = vs[i];
          let e1 = set_type(var_exp(v,DL),(type_t)t);
          let e2 = set_type(address_exp(e1,DL),cstar_type(t,mt_tq));
	  array_args = new List(e2,array_args);
        }
	s = declare_stmt(argv, arr_type, 
                         set_type(array_exp(array_args,DL),arr_type), s, DL);
	// evaluate varargs (reverse to get left-to-right)
	es = imp_rev(es);
	injectors = imp_rev(injectors);
	int i = length(es)-1;
	for (; es != NULL; es=es->tl, injectors=injectors->tl, --i) {
	  exp_t  arg      = es->hd;
	  type_t arg_type = (type_t)arg->topt;
	  qvar_t var      = vs[i].f0;
          type_t field_typ = (type_t)vs[i].f1;
	  let &Datatypefield{qv,tqts,_,_} = injectors->hd;
	  exp_to_c(nv,arg);
	  if (is_void_star_or_boxed_tvar(field_typ))
	    arg = cast_it(field_typ,arg);
	  // just make an Aggregate_e and pass the buck to RemoveAggrs
	  let tdn = collapse_qvars(qv,tud->name);
	  let dles = list(make_field(tag_sp,datatype_tag(tud,qv)),
			  make_field(fieldname(1),arg));
	  s = declare_stmt(var, strctq(tdn),
			   set_type(new_exp(new Aggregate_e(tdn,NULL,dles,NULL),DL),
                                    field_typ),
			   s, DL);
	}
      } else {
	// now just make an Array_e and pass the buck to RemoveAggrs to
	// expand it out to avoid the GCC bug
	list_t<exp_t> array_args = NULL;
	for(; es != NULL; es = es->tl) {
	  exp_to_c(nv, es->hd);
	  array_args = new List(es->hd, array_args);
	}
	let init = set_type(array_exp(imp_rev(array_args),DL),arr_type);
	s = declare_stmt(argv, arr_type, init, s,DL);
      }
    e->r = stmt_exp_r(s);
    }
    break;
  case &Throw_e(e1,b):
    // throw e -> (t)(throw(e)), the latter being a function call to throw
    exp_to_c(nv,e1);
    exp_t fn_e = b ? _rethrow_e : _throw_e;
    let ctype = typ_to_c(old_typ);
    e->r = array_to_ptr_cast(ctype,
                             set_type(fncall_exp_dl(fn_e,e1),ctype),DL)->r;
    break;
  case &NoInstantiate_e(e1): 
    exp_to_c(nv,e1); 
    *e = *e1;
    break;
  case &Instantiate_e(e1,ts):
    exp_to_c(nv,e1);
    // only cast when the instantiation has type variables,
    // you can cast other times, but you'll spit out much more C code.
    // Note: we don't bother to cast if type is void * anyway (b/c that's
    //       what type variables get translated to)
    // Note: we could be even more aggressive -- often the instantiated types
    //  don't show up in the translated type.  Moreover, we probably don't
    //  get warnings when the only use of the tyvar is as a parameter b/c
    //  it's just an implicit cast to void * (so long as inst type isn't int)
    let tc = typ_to_c((type_t)old_typ);
    let tc1 = typ_to_c((type_t)e1->topt);
    if(!Tcutil::typecmp(tc,tc1)==0) {
      // // HACK ALERT:
      // // gcc 3.4 refuses to compile a function call ( (t)f )(...)
      // // for types t that we need, so use ({(t)f})(...) instead.
      // // This turns out to be easiest to code here, in Instantiate,
      // // because functions are always instantiated before calling.
      // e->r = array_to_ptr_cast(tc,e1,DL)->r;
      // e->r = stmt_exp_r(exp_stmt(new_exp(e->r,e->loc),e->loc));
      // HACK ALERT: in addition, gcc 4.0 doesn't like ({(t)f})(...).
      // So use ({ t g = (t) f; g; })(...) instead.
      let $(temp,temp_exp) = temp_var_and_exp();
      e->r = stmt_exp_r(declare_stmt(temp,tc,array_to_ptr_cast(tc,e1,DL),
                                     exp_stmt(temp_exp,e->loc),e->loc));
    }
    break;
  case &Cast_e(*t,e1,user_inserted,coercion):
    type_t old_t2  = (type_t)e1->topt;
    type_t old_t2_c = typ_to_c(old_t2);
    type_t new_typ = *t;
    type_t new_typ_c = typ_to_c(new_typ);
    *t = new_typ_c;
    exp_to_c(nv, e1);
    // a few Cyclone casts are translated into C effects other than casts:
    switch ($(compress(old_t2),compress(new_typ))) {
    case $(&PointerType(p1),&PointerType(p2)):
      let b1  = get_bounds_exp_constrain(bounds_one(),p1.ptr_atts.bounds,true);
      let b2  = get_bounds_exp_constrain(bounds_one(),p2.ptr_atts.bounds,true);
      let zt1 = force_type2bool(false,p1.ptr_atts.zero_term);
      let zt2 = force_type2bool(false,p2.ptr_atts.zero_term);
      switch($(b1,b2)) {
      case $(&_, &_):
	// neither fat -- bound guaranteed in type-checker, so just check NULL
	did_inserted_checks = true;
	if(do_null_check(e))
	  e->r = fncall_exp_dl(_check_null_e,e1)->r;
	else if (Unify::unify(old_t2_c,new_typ_c))
	  *e = *e1; // Must copy over annot in case of New_e!!!
        // FIX: the type-checker doesn't currently allow the case
        // where b1 > b2, but this can be allowed for zero-terminated
        // arrays (since the true length isn't known.)  Of course,
        // this obligates a run-time check.
	break;
      case $(&_, NULL): // InsertChecks ensures bound is known
        let e2 = (exp_t)b1;
        let $(i,valid) = Evexp::eval_const_uint_exp(e2);
	if(is_toplevel(nv)) {
	  // can't use a function at top-level and don't want macros
	  // If p2 is not zero-terminated and not const, then we subtract
	  // one from the size so that no one can write the last location.
          if (zt1 && !p2.elt_tq.real_const && !zt2)
            e2 = set_type(prim2_exp(Minus,e2,set_type(uint_exp(1,DL),uint_type),DL),(type_t)e2->topt);
	  e->r = make_toplevel_dyn_arr(old_t2,e2,e1)->r;
	} else if(zt1) {
	  // cast from t*{n} or t@{n} to t? or t?
	  // if p1 is zero-terminated then calculate the size dynamically:
	  //   ({ t *x = e1;
	  //      _tag_fat(x, sizeof(t), _get_zero_arr_size(x,n));
	  //   })
	  let $(x,x_exp) = temp_var_and_exp();
          set_type(x_exp,typ_to_c(old_t2));
	  exp_t arg3;
	  // if what we're casting is a string constant or an array
	  // variable, we can avoid computing the "size" at run-time.
	  switch (e1->r) {
	  case &Const_e({.String_c = _}):  arg3 = e2; break;
	  case &Const_e({.Wstring_c = _}): arg3 = e2; break;
	  case &Var_e(&Global_b(vd)): fallthru(vd);
	  case &Var_e(&Local_b(vd)):
	    if (!Tcutil::is_array_type(vd->type))
	      fallthru;
	    arg3 = e2;
	    break;
	  default:
	    // if what we're casting has a known size > 1 then
	    // we use it instead of calculating the size at run-time
	    x_exp = cast_it(void_star_type(),x_exp);
	    if (valid && i != 1)
	      arg3 = e2;
	    else if(isCharStar(e1))
	      arg3 = fncall_exp_dl(_get_zero_arr_size_char_e,x_exp,e2);
	    else
	      arg3 = fncall_exp_dl(_get_zero_arr_size_other_e,
				   set_type(sizeoftype_exp(pointer_elt_type(typ_to_c(old_t2)),DL),uint_type),
				   x_exp,e2);
            arg3->topt = uint_type;
	    break;
	  }
	  // If p2 is not zero-terminated and not const, then we subtract
	  // one from the size so that no one can write the last location.
	  bool use_temp = (arg3!=e2);
	  if (!zt2 && !p2.elt_tq.real_const)
	    arg3 = set_type(prim2_exp(Minus,arg3,set_type(uint_exp(1,DL),uint_type),DL),(type_t)arg3->topt);
	  let arg2 = set_type(sizeoftype_exp(typ_to_c(p1.elt_type),DL),uint_type);
	  if(use_temp) {
	    let tg_exp = fncall_exp_dl(_tag_fat_e,x_exp,arg2,arg3);
            tg_exp->topt = fat_ptr_type();
	    let s = exp_stmt(tg_exp,DL);
	    s = declare_stmt(x,typ_to_c(old_t2),e1,s,DL);
	    e->r = stmt_exp_r(s);
	  } else
	    e->r = fncall_exp_r(_tag_fat_e,e1,arg2,arg3);
	} else
	  // build the t ? struct
	  e->r = fncall_exp_r(_tag_fat_e, e1,
			      set_type(sizeoftype_exp(typ_to_c(p1.elt_type),DL),uint_type), e2);
	break;
      case $(NULL, &_): //InsertChecks ensures not-at-toplevel and b2 is known
        // When we have t?ZEROTERM and are casting to
        // t*{e2} or t@{e2} *without* the ZEROTERM, then we
        // can't allow e2 to be the actual size of the array --
        // it needs to be one less to ensure that you can't
        // overwrite the trailing 0.  We achieve this by
        // incrementing e2 by one.  That is if x has type t?Z,
        // and we're casting it to t@{2}, then we'd better check
        // that the size is at least 2+1=3.
        let new_e2 = (exp_t)b2;
        if (zt1 && !zt2)
          new_e2 = set_type(add_exp(b2,set_type(uint_exp(1,DL),uint_type),DL),uint_type);
	let ptr_exp = e1;

        // ?`RC to *`RC requires current to be at base, else arraybounds
/*         if (is_noalias_region(p1.ptr_atts.rgn,false)  // p1 is unique or refcounted... */
/*             && !is_noalias_region(p1.ptr_atts.rgn,true)) // ...and not unique (so, refcounted) */
        if (is_noalias_qual(p1.ptr_atts.aqual,false)  // p1 is unique or refcounted...
            && !is_noalias_qual(p1.ptr_atts.aqual,true)) // ...and not unique (so, refcounted)
          ptr_exp = set_type(fncall_exp_dl(_check_fat_at_base_e, ptr_exp),fat_ptr_type());

        switch(e->annot) {
	case &InsertChecks::FatBound:
	case &InsertChecks::NullAndFatBound:
	// FIX: allow bounds check to be elided
	// cast from t ? to t* or t@ -- run-time check:
	// for t*: (t *)_untag_arr(e1, sizeof(t), new_e2)
	// for t@: _check_null(_untag_arr(e1, sizeof(t), new_e2))
	  ptr_exp = 
            set_type(fncall_exp_dl(_untag_fat_ptr_check_bound_e,
                                   ptr_exp,
                                   set_type(sizeoftype_exp(typ_to_c(p1.elt_type),DL),
                                            uint_type),
                                   new_e2),cstar_type(uchar_type,mt_tq));
	  break;
	default:
	  ptr_exp = 
            set_type(fncall_exp_dl(_untag_fat_ptr_e,
                                   ptr_exp,
                                   set_type(sizeoftype_exp(typ_to_c(p1.elt_type),DL),
                                            uint_type),
                                   new_e2),cstar_type(uchar_type,mt_tq));
	  break;
	}
	did_inserted_checks = true;
	if(do_null_check(e)) // DJG: redundant unless bound is 0?
	  ptr_exp->r = fncall_exp_r(_check_null_e, deep_copy(ptr_exp));
	e->r = cast_it_r(*t, ptr_exp);
	break;
      // If p1 is zero-terminated and p2 is not, then p2 had better
      // be const or else we have to decrement its size by 1.
      case $(NULL, NULL):
        if (zt1 && !zt2 && !p2.elt_tq.real_const) {
          if (is_toplevel(nv)) // FIX: move to InsertChecks
            unimp("can't coerce a ZEROTERM to a non-const NOZEROTERM pointer at toplevel");
          e->r = fncall_exp_r(_fat_ptr_decrease_size_e,
                              e1,
                              set_type(sizeoftype_exp(typ_to_c(p1.elt_type),DL),
                                       uint_type),
			      set_type(uint_exp(1,DL),uint_type));
        }
	break;
      }
      break;
    case $(&PointerType(p1), &AppType(&IntCon(_,_),_)):
      switch(get_bounds_exp_constrain(bounds_one(),p1.ptr_atts.bounds,true)) {
      case NULL: // cast t? to char *
	e1->r = aggrmember_exp_r(deep_copy(e1),curr_sp);
	e1->topt = cstar_type(uchar_type, mt_tq);
	break;
      default: break;
      }
      break;
    default:
      if (Unify::unify(old_t2_c,new_typ_c))
        *e = *e1;
      break;
    }
    break;

  case &Address_e(e1): // FIX: support & e as malloc-and-initialize?
    set_lhs(nv,true);
    exp_to_c(nv,e1);
    set_lhs(nv,false);
    if(!is_lvalue(e1)) {
      lvalue_assign(e1,NULL,address_lvalue,true);
      // the wrong cast got pushed out, so as a kludge, just re-cast
      e->r = cast_it_r(typ_to_c((type_t)old_typ),e1);
    } else if (Kinds::kind_leq(&Kinds::ak,type_kind((type_t)e1->topt)))
      // we could be taking the address of an abstract member, so insert a cast
      e->r = cast_it_r(typ_to_c((type_t)old_typ),
                       set_type(address_exp(e1,DL),
                                cstar_type((type_t)e1->topt,mt_tq)));
    break;

  case &New_e(rgnopt,e1,qual): //ignore qual for now
    // we share the work with RemoveAggrs:
    // * we create the malloc-exp and if necessary, the tag_fat and cast
    // * we pass the malloc-exp as an attribute to RemoveAggrs,
    //   which gets rid of the New_e
    exp_to_c(nv,e1);
    // determine elt_typ after translating e1 due to the struct hack
    type_t elt_typ = typ_to_c((type_t)e1->topt);
    switch(compress(elt_typ)) {
    case &ArrayType(ArrayInfo(t2,...)): elt_typ = typ_to_c(t2); break;
    default: break;
    }
    exp_opt_t array_len = array_length_exp(e1);
    qvar_opt_t lenvar = NULL;
    exp_opt_t lenexp = NULL;
    exp_t mexp;
    if (array_len != NULL) {
      lenvar = temp_var();
      lenexp = set_type(var_exp((qvar_t)lenvar,DL),uint_type);
      mexp = fncall_exp_dl(_check_times_e,lenexp,sizeoftype_exp(elt_typ,DL));
      // e1 could be a comprehension -- in which case, we're duplicating
      // the bounds expression here (which could have effects.)  So we
      // change the bounds expression on the comprehension to be lenvar.
      switch (e1->r) {
      case &Comprehension_e(_,*bd,_,_): fallthru(bd);
      case &ComprehensionNoinit_e(*bd,_,_):
        *bd = deep_copy(lenexp);
        break;
      default: break;
      }
    } else
      mexp = sizeoftype_exp(elt_typ,DL); // :( don't have destination anymore
    mexp->topt = uint_type;
    // deal with the struct hack (executing the bound twice and suffering
    // an unnecessary copy of the data)
    let vse = get_varsizeexp(e1);
    if(vse != NULL)
      mexp = set_type(add_exp(mexp,vse,DL),uint_type);
    
    if((rgnopt == NULL && qual == NULL) || Flags::no_regions)
      mexp = malloc_exp(elt_typ,mexp);
    else {
      if(qual != NULL) exp_to_c(nv, qual);
      if(rgnopt != NULL) {
	exp_to_c(nv,rgnopt);
	mexp = rmalloc_exp(rgnopt,
			   (qual == NULL ? aliasable_qual_exp() : qual),
			   mexp);
      }
      else {
	mexp = aqmalloc_exp(qual,mexp);
      }
    }
    set_type(mexp,cstar_type(elt_typ,mt_tq));
    e->annot = new NewInfo(mexp,cstar_type(elt_typ,mt_tq));
    if(is_fat_ptr(old_typ)) {
      let e2 = set_type(deep_copy(e),cstar_type(elt_typ,mt_tq));
      e->r = fncall_exp_dl(_tag_fat_e,e2,
			   sizeoftype_exp(elt_typ,DL),
			   (lenexp ? lenexp : 
                            set_type(uint_exp(1,DL),uint_type)))->r;
    }
    if(vse != NULL) // in case of the struct hack, types do not line up
      e->r = cast_it_r(typ_to_c(old_typ),deep_copy(e));
    if(array_len) {
      let s = declare_stmt((qvar_t)lenvar,uint_type,(exp_t)array_len,
			   exp_stmt(deep_copy(e),DL),DL);
      e->r = stmt_exp_r(s);
    }
    break;

    // InsertChecks ensures we don't do checks under a sizeof
  case &Sizeofexp_e(e1):  exp_to_c(nv,e1); break;
  case &Sizeoftype_e(t):  e->r = new Sizeoftype_e(typ_to_c(t));  break;
  case &Offsetof_e(t,fs):
    e->r = new Offsetof_e(typ_to_c(t),fs);
    break;
  case &AggrMember_e(e1,f,is_tagged,is_read):
    bool   is_poly     = is_poly_project(e);
    type_t e1_cyc_type = (type_t)e1->topt;
    type_t t = typ_to_c_array(old_typ);
    type_t res_type = is_poly ? void_star_type() : t;
    exp_to_c(nv, e1);
    if (is_tagged && is_read)
      e->r = check_tagged_union(res_type, 
                                e1,typ_to_c(e1_cyc_type),e1_cyc_type,f,
				in_lhs(nv), member_exp);
    else if (is_tagged)
      e->topt = tagged_union_field_struct(e1_cyc_type,f);
    if(is_poly) { 
      let e2 = deep_copy(e);
      e2->topt = void_star_type();
      e->r = cast_it_r(t,e2);
      e->topt = t;
    }
    break;
  case &AggrArrow_e(e1,f,is_tagged,is_read):
    bool   is_poly = is_poly_project(e); // decide before mutating e
    type_t e1typ   = (type_t)e1->topt;
    type_t ta;
    type_t t = typ_to_c_array(old_typ);
    type_t res_type = is_poly ? void_star_type() : t;
    switch(compress(e1typ)) {
    case &PointerType(p): ta = p.elt_type; break;
    default: toc_impos("get_ptr_typ: not a pointer!");
    }
    did_inserted_checks = true;
    ptr_use_to_c(nv,e1,e->annot,NULL);
    if (is_tagged && is_read)
      e->r=check_tagged_union(res_type,e1,typ_to_c(e1typ),ta,f,in_lhs(nv),aggrarrow_exp);
    else if (is_tagged) {
      e->topt = tagged_union_field_struct(ta,f);
    }
    if(is_poly && is_read) {
      let e2 = deep_copy(e);
      e2->topt = void_star_type();
      e->r=cast_it_r(t,e2);
      e->topt = t;
    } else if (is_poly) {
      e->topt = void_star_type();
    }
    break;
  case &Deref_e(e1):
    did_inserted_checks = true;
    ptr_use_to_c(nv,e1,e->annot,NULL);
    break;
  case &Subscript_e(e1,e2):
    did_inserted_checks = true;
    enum PTR_ANS res = ptr_use_to_c(nv,e1,e->annot,e2);
    if(res == DIRECT_DEREF)
      e->r = deref_exp_r(e1);
    else if (res == DROP_SUBSCRIPT)
      e->r = e1->r;
    break;
  case &Array_e(dles0):
    // We now leave this to RemoveAggrs, which converts this to assignments
    // (it can only occur as an initializer)
    // but toplevel arrays must be converted to unresolvedMem to appease
    // passes downstream
    for (let dles = dles0; dles != NULL; dles = dles->tl)
      exp_to_c(nv,(*dles->hd)[1]);
    if(is_toplevel(nv))
      e->r = unresolvedmem_exp_r(NULL,dles0);
    break;
  case &Comprehension_e(vd,e1,e2,iszeroterm):
    // at top-level e1 and e2 must be constant and we make an unresolvedmem_exp.
    // inside a function, we now pass the buck to RemoveAggrs
    exp_to_c(nv,e1);
    exp_to_c(nv,e2);
    if(is_toplevel(nv)) {
      let $(sz,known) = Evexp::eval_const_uint_exp(e1);
      let elt_typ = typ_to_c((type_t)e2->topt);
      list_t<$(list_t<designator_t>,exp_t)@> es = NULL;
      // if e2 is 0, generate an "empty" array intializer to avoid giant arrays
      if (!is_zero(e2)) {
	if(!known) // FIX: type-checker should do the same test
	  Warn::err2(e1->loc, "cannot determine value of constant");
	for (unsigned int i = 0; i < sz; i++)
	  es = new List(new $(NULL,e2),es);
	// for a zero-terminated comprehension, add in an implicit 0 to the end
	if (iszeroterm) {
	  let ezero = cast_it(elt_typ,set_type(uint_exp(0,DL),uint_type));
	  es = List::imp_append(es,new List{new $(NULL,ezero), NULL});
	}
      }
      e->r = unresolvedmem_exp_r(NULL,es);
    }
    break;
  case &ComprehensionNoinit_e(e1,t1,iszeroterm):
    // at toplevel, we can just make an empty array and rely on the
    // expression's type to build an array of the right size
    // inside a function, we now pass the buck to RemoveAggrs
    // FIX?: not sure if zeroterm should be allowed here since we do not
    //       initialize?
    if(is_toplevel(nv))
      e->r = unresolvedmem_exp_r(NULL,NULL);
    else
      exp_to_c(nv,e1);
    break;

  case &AnonStruct_e(st,_,dles): // note: no support for struck hacks
    for(let dles2=dles; dles2!=NULL; dles2=dles2->tl)
      exp_to_c(nv,(*dles2->hd)[1]);
    let strct_typ = typ_to_c(old_typ);
    e->topt = strct_typ;
    if(!is_toplevel(nv))
      switch(compress(strct_typ)) {
      case &AppType(&AggrCon(aggrinfo),NULL):
	aggrdecl_t sd = get_known_aggrdecl(aggrinfo);
	e->r    = new Aggregate_e(sd->name,NULL,dles,sd);
	e->topt = strct_typ;
	break;
      default: toc_impos("anonStruct type not an aggregate");
      }
    else
      e->r = unresolvedmem_exp_r(NULL,dles);
    break;

  case &Aggregate_e(*tdn,exist_ts,dles,sd):
    // now relegate rewriting to RemoveAggrs, but we still may need to
    // generate struct definitions and other nasty stuff
    if(sd==NULL || sd->impl==NULL)
      toc_impos("exp_to_c, Aggregate_e: missing aggrdecl pointer or fields");
    let new_typ = typ_to_c(old_typ);
    switch(compress(new_typ)) { // typ_to_c may change the struct name!
    case &AppType(&AggrCon(info),_): *tdn = aggr_kinded_name(info)[1]; break;
    default: toc_impos("exp_to_c, Aggregate_e: bad type translation");
    }
    // to handle struct kludges for the last field of the type
    // definition, we grab the last field
    // FIX?: should probably support these kludges for tuples and datatypes
    // too, which suggests doing it after translating more things to aggregates
    let typ_fields = sd->impl->fields;
    if(typ_fields==NULL) break; // no fields (maybe possible)
    for(; typ_fields->tl != NULL; typ_fields = typ_fields->tl)
      ;
    let last_typ_field = typ_fields->hd;
    let fields = resolve_aggregate_designators(heap_region, e->loc, dles,
					       sd->kind, sd->impl->fields);
    if(!is_toplevel(nv)) {
    loop:
      switch(compress(old_typ)) {
      case &SubsetType(vd,...): old_typ = vd->type; goto loop;
      case &AppType(&AggrCon(_),param_ts):
	// now translate the fields, with special cases noted as they occur
	for(let fields2=fields; fields2!=NULL; fields2=fields2->tl) {
	  let &$(aggrfield,fieldexp) = fields2->hd;
	  let old_field_typ = fieldexp->topt; // for kludge below
	  exp_to_c(nv,fieldexp);
	  // warning avoidance
	  if (is_void_star_or_boxed_tvar(aggrfield->type) &&
	      !is_pointer_or_boxed_tvar((type_t)fieldexp->topt)) {
            let t = typ_to_c(aggrfield->type);
	    fieldexp->r = cast_it(t,deep_copy(fieldexp))->r;
            fieldexp->topt = t;
          }
	  // tagged unions: have to add the tag field
	  if(sd->impl->tagged) {
	    let n = aggrfield->name;
	    let tag_exp = set_type(uint_exp(get_member_offset(sd,n),DL),uint_type);
	    let tag_dle = make_field(tag_sp,tag_exp);
	    let val_dle = make_field(val_sp,fieldexp);
	    qvar_t s = new $(Abs_n(NULL,true),
			     new (string_t)aprintf("_union_%s_%s",
						   *(*sd->name)[1],*n));
            let aggr_exp = new_exp(new Aggregate_e(s,NULL,list(tag_dle,val_dle),NULL),DL);
            set_type(aggr_exp,tagged_union_field_struct(old_typ,n));
	    let u_dle = make_field(n,aggr_exp);
	    e->r = new Aggregate_e(*tdn,NULL,list(u_dle),sd);
	  }
	  // if the last field has abstract mem-kind (after instantiating
	  // the type-parameters), we have to generate a type here.
	  // (If the instantiation is concrete, typ_to_c handles it)
	  // Note: unions cannot have abstract mem-kind fields
	  if(is_abstract_type(old_typ) && last_typ_field==aggrfield) {
	    let inst = append(zip(sd->impl->exist_vars,exist_ts),
			      zip(sd->tvs,param_ts));
	    list_t<aggrfield_t> new_fields = NULL;
	    for(let fs = sd->impl->fields; fs!=NULL; fs=fs->tl) {
	      let old_f = fs->hd;
	      let old_ftyp = substitute(inst,old_f->type);
	      let new_f = aggrfield_to_c(old_f,
					 typ_to_c(substitute(inst,old_ftyp)));
	      new_fields = new List(new_f,new_fields);
	      // if we do not know the last field's size, we must
	      // use a struct hack (in coordination with the New_e case,
	      // which uses get_varsizeexp
	      // KLUDGE: we must set the topt of the field in case we are
	      //  a nested aggregate, so the outer one uses the right type
	      if(fs->tl==NULL) {
		switch(compress(new_f->type)) {
		case &ArrayType(ai):
		  if(!Evexp::c_can_eval((exp_t)(ai.num_elts))) {
		    let ai2 = ai;
		    ai2.num_elts = set_type(uint_exp(0,DL),uint_type); // zero-length array type
		    new_f->type = new ArrayType(ai2);
		  }
		  break;
		default:
		  // see kludge above: we may be the outer aggregate, so we
		  // we have to get the new inner-aggregate's type
		  if(fieldexp->topt==NULL)
		    break;
		  switch(compress((type_t)fieldexp->topt)) {
		  case &AppType(&AggrCon(_),_):
		    new_f->type = (type_t)fieldexp->topt; break;
		  default: break;
		  }
		  break;
		}
		//DJG: FIX I think this is broken for an array with element-type
		//     of abstract mem kind
		if(!is_array_type(old_f->type) &&
		   Kinds::kind_leq(&Kinds::ak,type_kind(old_f->type)))
		  new_f->attributes = new List(new Aligned_att(NULL),
					       new_f->attributes);
	      }
	    }
	    sd = make_c_struct_defn(new (string_t)aprintf("_genStruct%d",
						  tuple_type_counter++),
				    imp_rev(new_fields));
	    *tdn = sd->name;
	    aggrdecl_to_c(sd); // to add the decl
	    // see kludge above: must set topt in case we are an inner aggregate
	    e->topt = aggr_type(KnownAggr(new(aggrdecl_t)sd),NULL);
	  }
	}
	break;
      default: toc_impos("exp_to_c, Aggregate_e: bad struct type");
      }
    } else {
      // At top-level must create an initializer.  For MSVC, sort fields
      // and drop initializers (sorting okay b/c we're at top-level)
      //
      // JGM: unfortunately, doesn't work for tagged unions -- we need
      // the designators to distinguish the various cases.
      if (sd->impl->tagged) {
        // should only be one field
        let &$(field,fieldexp) = fields->hd;
        let fieldexp_type = (type_t)fieldexp->topt;
        let fieldtyp = field->type;
        exp_to_c(nv,fieldexp);
        if (is_void_star_or_boxed_tvar(fieldtyp) &&
            !is_void_star_or_boxed_tvar(fieldexp_type))
          fieldexp->r =
            cast_it_r(void_star_type(),deep_copy(fieldexp));
        // for tagged unions, must insert tag here
        int i = get_member_offset(sd,field->name);
        exp_t field_tag_exp = set_type(signed_int_exp(i,0),sint_type);
	let newdles = list(new $(NULL,field_tag_exp), new $(NULL,fieldexp));
        exp_t umem = unresolvedmem_exp(NULL,newdles,0);
        e->r = unresolvedmem_exp_r(NULL,list(make_field(field->name,umem)));
      } else { // not tagged
        // here is where we now sort
        let newdles = NULL;
        let sdfields = sd->impl->fields;
        for(; sdfields!=NULL; sdfields=sdfields->tl)
          for (let fields2 = fields; fields2 != NULL; fields2 = fields2->tl) {
            if((*fields2->hd)[0] == sdfields->hd) {
              let &$(field,fieldexp) = fields2->hd;
              let fieldtyp = typ_to_c(field->type);
              let fieldexp_typ = typ_to_c((type_t)fieldexp->topt);
              exp_to_c(nv,fieldexp);
              // must cast when the types don't match up -- except when
              // the last type is of abstract kind, for then we should've
              // generated a specialized struct...
              if (!Unify::unify(fieldtyp,void_type) &&
                  !Unify::unify(fieldtyp, fieldexp_typ))
                // unless they are both arithmetic types -- C can handle this.
                if (!is_arithmetic_type(fieldtyp) ||
                    !is_arithmetic_type(fieldexp_typ))
                fieldexp = cast_it(fieldtyp, deep_copy(fieldexp));
              newdles = new List(new $(NULL,fieldexp), newdles);
              break;
            }
          }
        e->r = unresolvedmem_exp_r(NULL,imp_rev(newdles));
      }
    }
    break;

  case &Datatype_e(es,tud,tuf):
    // convert the es, inserting casts to avoid GCC warnings
    let tqts = tuf->typs;
    for(let es2 = es; es2!=NULL; es2=es2->tl, tqts=tqts->tl) {
      exp_t  cur_e     = es2->hd;
      let    cur_e_typ = (type_t)cur_e->topt;
      type_t field_typ = typ_to_c((*tqts->hd)[1]);
      exp_to_c(nv,cur_e);
      if (is_void_star_or_boxed_tvar(field_typ) &&
	  !is_pointer_or_boxed_tvar(cur_e_typ))
	  cur_e->r = cast_it(field_typ,deep_copy(cur_e))->r;
    }
    // create the tag initializer
    let tag_exp =
      tud->is_extensible ? set_type(var_exp(tuf->name,DL),cstar_type(char_type,mt_tq)) : datatype_tag(tud,tuf->name);
    
    // convert to a struct
    if(!is_toplevel(nv)) {
      // make an Aggregate_e and rely on RemoveAggrs (similar to tuple case)
      list_t<$(list_t<designator_t>,_)@> dles = NULL;
      for(int i=1; es!=NULL; es=es->tl, ++i)
	dles = new List(make_field(fieldname(i),es->hd), dles);
      // FIX? leaves the last field NULL (TocState does not have what we want)
      // RemoveAggrs does not currently use the field, but for computing
      // the malloc-exp, we will assume the last field is not an abstract-mem
      let tag_dle = make_field(tag_sp,tag_exp);
      e->r = new Aggregate_e(collapse_qvars(tuf->name,tud->name), NULL,
			     new List(tag_dle, imp_rev(dles)), NULL);
    } else {
      // At top-level use an initializer (identical code in tuple case;
      // should share in RemoveAggrs)
      let dles = NULL;
      for(; es!=NULL; es=es->tl)
	dles = new List(new $(NULL,es->hd), dles);
      e->r = unresolvedmem_exp_r(NULL,new List(new $(NULL,tag_exp),
					       imp_rev(dles)));
    }
    break;

  case &Enum_e(...):
  case &AnonEnum_e(...): break;

  case &Malloc_e(MallocInfo{mknd,rgnopt,aqopt,topt,num_elts,is_fat,inline_call}):
    type_t t_c = typ_to_c(*topt);
    exp_to_c(nv,num_elts);
    qvar_opt_t x = NULL;
    exp_t pexp;
    exp_t num_elts2 = num_elts;
    if (is_fat) { // necessary to avoid evaluating num_elts twice!
      x = temp_var();
      num_elts2 = var_exp(x,DL);
    }
    if (mknd == Calloc) { //ignores aqopt for now ... revisit
      if((rgnopt == NULL && aqopt == NULL) || Flags::no_regions) {
	pexp = calloc_exp(*topt,sizeoftype_exp(t_c,DL), num_elts2);
      } else {
	if(aqopt != NULL) exp_to_c(nv,aqopt);
	if(rgnopt != NULL) {
	  exp_to_c(nv,rgnopt);
	  pexp = rcalloc_exp(rgnopt, (aqopt == NULL ? aliasable_qual_exp() : aqopt),
			     sizeoftype_exp(t_c,DL), num_elts2);
	}
	else {
	  pexp = aqcalloc_exp(aqopt, sizeoftype_exp(t_c,DL), num_elts2);
	}
      }
    } else {
      if((rgnopt == NULL && aqopt == NULL) || Flags::no_regions) {
	pexp = malloc_exp(*topt, num_elts2);
      } else {
	if(aqopt != NULL) exp_to_c(nv,aqopt);
	if (rgnopt != NULL) {
	  exp_to_c(nv,rgnopt);
	  if(mknd == Vmalloc) {
	    pexp = rvmalloc_exp(rgnopt, num_elts2);
	  } else {
	    let fn_e = (inline_call ? rmalloc_inline_exp : rmalloc_exp);
	    pexp = fn_e(rgnopt, (aqopt == NULL ? aliasable_qual_exp() : aqopt), num_elts2);
	  }
	}
	else
	  pexp = aqmalloc_exp(aqopt, num_elts2);
      }
    }
    if (is_fat) {
      exp_t  elt_sz = (mknd==Calloc ? sizeoftype_exp(t_c,DL) : set_type(uint_exp(1,DL),uint_type));
      exp_t  rexp   = fncall_exp_dl(_tag_fat_e,pexp,elt_sz,num_elts2);
      rexp->topt = fat_ptr_type();
      stmt_t s      = declare_stmt((qvar_t)x, uint_type, num_elts,
				   exp_stmt(rexp,DL),DL);
      e->r = stmt_exp_r(s);
    } else
      e->r = cast_it_r(typ_to_c(old_typ),pexp);
    // necessary so a later pass does not remove the cast we put in 1 line up
    // (the cast is usually, but not always, unnecessary)
    // NS: but this breaks when the toseqc pass for evaluation order converts an assignment 
    // to an element of an array of fat ptrs
    //    e->topt = void_star_type();
    break;

  case &Swap_e(e1,e2):
    // e1 :=: e2 becomes ({ typeof(e1) tmp = e1; typeof(e2) tmp2 = e2;
    //                      e1 = tmp2; e2 = tmp; })
    // This assumes that e1 and e2 are effect-free lvalues.  We implement
    // this by replacing e with a Cyclone expression implementing the swap,
    // and then reuse the existing code generator to get everything to work out,
    // e.g. to handle tagged unions.
    type_t e1_old_typ = (type_t)e1->topt;
    type_t e2_old_typ = (type_t)e2->topt;
    if (!is_boxed(e1_old_typ) && !is_pointer_type(e1_old_typ))
      toc_impos("Swap_e: is_pointer_or_boxed: not a pointer or boxed type");

    // create the Cyclone expression for the swap.  Need to deep copy the
    // expressions since the translation to C is by side-effect, and the rhs
    // and lhs of tagged unions are translated differently.
    let loc = e->loc;
    let v1  = temp_var();
    let v1e = var_exp(v1,loc); v1e->topt = e1_old_typ;
    let v2  = temp_var();
    let v2e = var_exp(v2,loc); v2e->topt = e2_old_typ;

    let s1e = assign_exp(deep_copy(e1),v2e,loc); s1e->topt = e1_old_typ;
    let s1 = exp_stmt(s1e,loc); // e1 = v2
    let s2e = assign_exp(deep_copy(e2),v1e,loc); s2e->topt = e2_old_typ;
    let s2 = exp_stmt(s2e,loc); // e2 = v1

    let s = declare_stmt(v1,e1_old_typ,e1, // typeof(e1) v1 = e1
	    declare_stmt(v2,e2_old_typ,e2, // typeof(e2) v2 = e2
			 seq_stmt(s1,s2,loc),loc),loc); // above asgns
    stmt_to_c(nv,s);
    e->r = stmt_exp_r(s);
    break;
  case &Tagcheck_e(e1,f):
    // e1.f.tag == f_tag
    let e1_typ = compress((type_t)e1->topt);
    exp_to_c(nv,e1);
    switch (e1_typ) {
    case &AppType(&AggrCon({.KnownAggr = &ad}), _):
      let f_tag = set_type(signed_int_exp(get_member_offset(ad,f),DL),uint_type);
      let e1_f = set_type(member_exp(e1,f,DL),tagged_union_field_struct(e1_typ,f));
      let e1_f_tag = set_type(member_exp(e1_f,tag_sp,DL),uint_type);
      e->r = eq_exp(e1_f_tag,f_tag,DL)->r;
      break;
    default: toc_impos("non-aggregate type in tagcheck");
    }
    break;
  case &StmtExp_e(s): stmt_to_c(nv,s);  break;
  case &UnresolvedMem_e(_,_): toc_impos("UnresolvedMem");
  case &CompoundLit_e(_,_):   toc_impos("compoundlit");
  case &Valueof_e(_):         toc_impos("valueof(-)");
  case &Asm_e(_,_,o,i,_):
    asm_iolist_types_toc(o);
    asm_iolist_types_toc(i);
    break;
  }
  if(!did_inserted_checks)
    Warn::impos_loc2(e->loc,"Toc did not examine an inserted check: ", e);
}


///////////////////////////////////////////////////////////////
//              Translation of Switch Statements             //
///////////////////////////////////////////////////////////////
// We use the decision tree built by tcpat to compile switch/catch
// statements.  This is somewhat complicated by fallthru and
// where clauses as noted.  We use a switch statement if the
// pattern tests admit it and there's more than 1 alternative.
// Otherwise, we use if-then-else's.  The basic idea is to take
// the decision tree and compile it so that each right-hand-side (rhs)
// has two entry points:  One entry point, called init, extracts all of the values
// for the variables in the pattern and initializes the associated
// compiler temporary variables with those values.  The other entry
// point, called body, has the actual statement for the switch clause.
// For a fallthru, we jump to the next clauses's body.  If a statement
// shows up multiple times in the decision tree, we only generate
// the body once, and goto the body the other times.


// generates a bool and two labels to be associated with the right-hand-side
// of a switch clause.  The bool records whether we've already emitted the
// code for this clause.  The first label is used for the code that extracts
// and initializes the variables of the pattern.  The second label is the
// entry point for the right-hand-side and is used for fallthru of previous
// switch cases.
static $(bool used,var_t,var_t,switch_clause_t)@`r gen_labels(region_t<`r> r,
                                                              switch_clause_t sc) {
  return rnew(r) $(false,fresh_label(),fresh_label(),sc);
}

using Tcpat {
// given a path from the match compiler and a root expression v,
// generate code for extracting the value.
static exp_t compile_path(path_t ps, exp_t v) {
  for (; ps != NULL; ps = ps->tl) {
    let p = ps->hd;
    // we cast the expression at each stage to avoid having to deal
    // with polymorphism and the like.  This generates bigger code
    // but it's a lot more uniform.
    if (tagcheck(p->orig_pat.pattern)) {
      type_t t = (type_t)p->orig_pat.pattern->topt;
      type_t t2 = compress(typ_to_c_array(t));
      switch (t2) {
        // avoid casts that C will not like.
      case &AppType(&VoidCon,_):
      case &AppType(&AggrCon(...),_):
      case &AnonAggrType(...): break;
      default:  v = cast_it(t2,v); break;
      }
    }
    switch (p->access) {
    case &Dummy:
      // dummy accesses correspond to the extra tuple inserted to deal
      // with && clauses in patterns.  We handle those somewhat separately.
      break;
    case &Deref(res_type):
      // if the next access is a datatypefield, then we want to
      // make sure that we cast the pointer to the appropriate
      // struct pointer before dereferencing.
      if (ps->tl != NULL)
        switch (ps->tl->hd->access) {
        case &DatatypeField(tud, tuf, i, res_type2):
          ps = ps->tl;
          v = cast_it(cstar_type(strctq(collapse_qvars(tuf->name, tud->name)),mt_tq),v);
          v = set_type(aggrarrow_exp(v, fieldname(i+1), DL),typ_to_c_array(res_type2));
          continue;
        default: break;
        }
      v = set_type(deref_exp(v,DL),typ_to_c_array(res_type));
      break;
    case &DatatypeField(_,_,i,res_type): 
      v = set_type(member_exp(v,fieldname(i+1),DL),typ_to_c_array(res_type));
      break;
    case &AggrField(at,tagged,f,res_type):
      v = member_exp(v,f,DL);
      if (tagged)  {
        // tagged unions require getting the .val member
        set_type(v,tagged_union_field_struct(at,f));
        v = member_exp(v,val_sp,DL);
      }
      v = set_type(v,typ_to_c_array(res_type));
      break;
    }
  }
  return v;
}

// given a root expression v and a pattern test, generate an
// expression suitable for an if-then-else.
static exp_t compile_pat_test(exp_t v, pat_test_t t) {
  switch (t) {
  case &WhereTest(e): return (e==NULL) ? v : e; // FIX: e shouldn't be NULL?
  case &EqNull: 
    return set_type(eq_exp(v, set_type(signed_int_exp(0,DL),void_star_type()),DL),sint_type);
  case &NeqNull:          
    return set_type(neq_exp(v, set_type(signed_int_exp(0,DL),void_star_type()),DL),sint_type);
  case &EqEnum(ed, ef):   
    return set_type(eq_exp(v, set_type(new_exp(new Enum_e(ed, ef),DL),
                                       enum_type(ed->name,ed)),
                           DL),sint_type);
  case &EqAnonEnum(t,ef): 
    return set_type(eq_exp(v, set_type(new_exp(new AnonEnum_e(t,ef),DL),
                                       sint_type),DL),sint_type);
  case &EqFloat(s,i):     
    return set_type(eq_exp(v, set_type(float_exp(s,i,DL), gen_float_type(i)),DL),
                    sint_type);
  case &EqConst(i):       
    return set_type(eq_exp(v, set_type(signed_int_exp(i,DL),sint_type), DL),sint_type);
  case &EqDatatypeTag(i,tud,tuf):
    // The compilation of the path has already done a dereference, so
    // get rid of any dereference in the path (peeking under casts.)
  LOOP1:
    switch (v->r) {
    case &Cast_e(_,e,...): v = e; goto LOOP1;
    case &Deref_e(e):      v = e; break;
    default: break;
    }
    // cast v to a pointer to the datatype field
    //v = cast_it(cstar_type(strctq(collapse_qvars(tuf->name,tud->name)),mt_tq),
    //		v);
    //return eq_exp(aggrarrow_exp(v,tag_sp,DL), uint_exp(i,DL),DL);
    v = cast_it(cstar_type(sint_type,mt_tq),v); // FIX: share type
    return set_type(eq_exp(set_type(deref_exp(v,DL),sint_type), 
                           set_type(signed_int_exp(i,DL),sint_type),DL),sint_type);
  case &EqTaggedUnion(atype,f,i):
    let e0 = member_exp(v,f,DL);
    let t = tagged_union_field_struct(atype,f);
    set_type(e0,t);
    let e = set_type(member_exp(e0,tag_sp,DL),uint_type);
    return set_type(eq_exp(e,set_type(signed_int_exp(i,DL),sint_type),DL),sint_type);
  case &EqExtensibleDatatype(tud,tuf):
    // Same as with datatypes, so get rid of any dereference in the path.
  LOOP2:
    switch (v->r) {
    case &Cast_e(_,e,...): v = e; goto LOOP2;
    case &Deref_e(e): v = e; break;
    default: break;
    }
    // cast v to a pointer to the datatype field
    v = cast_it(cstar_type(strctq(collapse_qvars(tuf->name, tud->name)), mt_tq),v);
    return eq_exp(set_type(aggrarrow_exp(v,tag_sp,DL),
                           cstar_type(char_type,mt_tq)), 
                  set_type(var_exp(tuf->name,DL),cstar_type(char_type,mt_tq)), 
                  DL);
  }
}

// used to determine what kind of code to emit for the test of the switch
datatype TestKind {
  OtherTest;
  DatatypeTagTest;
  WhereTest(exp_t);
  TaggedUnionTest(type_t,field_name_t);
};
datatype TestKind.OtherTest OtherTest_val = OtherTest;
datatype TestKind.DatatypeTagTest DatatypeTagTest_val = DatatypeTagTest;

// returns the number of pattern tests that admit a switch, and whether
// the pattern test is a datatype test, a tagged union test, a where-clause
// test, or something else. If any pattern test does not support a switch,
// then we return 0.
static $(int,datatype TestKind@)
admits_switch(list_t<$(pat_test_t,decision_t)@> ss) {
  int c = 0;
  datatype TestKind @ k = &OtherTest_val;
  for (; ss != NULL; ss = ss->tl, c = c+1) {
    let $(ptest,_) = *ss->hd;
    switch (ptest) {
      // these can all be put in switches
    case &EqEnum(_,_):
    case &EqAnonEnum(_,_):
    case &EqConst(_): continue;
    case &EqTaggedUnion(t,f,_):
      if (k == &OtherTest_val)
        k = new TaggedUnionTest(t,f);
      continue;
    case &EqDatatypeTag(...): k = &DatatypeTagTest_val; continue;
      // the rest cannot be in a switch.
    case &Tcpat::WhereTest(e) && e!=NULL: k = new WhereTest(e); return $(0, k);
    case &Tcpat::WhereTest(_):
    case &EqNull:
    case &NeqNull:
    case &EqFloat(_,_):
    case &EqExtensibleDatatype(_,_): return $(0,k);
    }
  }
  return $(c,k);
}

// given a pattern test to be used in a generated switch statement,
// extract the appropriate C-pattern (i.e., an integer).
static pat_t compile_pat_test_as_case(Tcpat::pat_test_t p) {
  exp_t e;
  switch (p) {
  case &EqEnum(ed,ef):        e = new_exp(new Enum_e(ed, ef),    DL); break;
  case &EqAnonEnum(t, ef):    e = new_exp(new AnonEnum_e(t, ef), DL); break;
  case &EqConst(i):           fallthru(i);
  case &EqDatatypeTag(i,_,_): fallthru(i);
  case &EqTaggedUnion(_,_,i):   e = set_type(signed_int_exp(i,DL),sint_type); break;
  default: toc_impos("compile_pat_test_as_case!");
  }
  return new_pat(new Exp_p(e), DL);
}
}
// sequence two optional statements.
static stmt_opt_t seq_stmt_opt(stmt_opt_t s1, stmt_opt_t s2) {
  if (s1 == NULL) return s2;
  if (s2 == NULL) return s1;
  return seq_stmt(s1,s2,DL);
}

// this includes the old vardecl as specified by the programmer,
// ie. &SomeDT(x, y):, and the new
// vardecl as created by extract_pattern_vars and specifically temp_var()
typedef list_t<$(vardecl_t oldv,vardecl_t newv)@`r,`r> patdecls_t<`r>;
typedef list_t<$(vardecl_t oldv,vardecl_t newv,type_t oldvt,bool cast)@`r,`r> patdeclsextra_t<`r>;

bool vd_in_use(vardecl_t other_vd, patdeclsextra_t<`rgn> @ newdecls) {
  for(let ds = *newdecls; ds != NULL; ds = ds->tl)
    // if other_vd points to the same thing as an already used decls
    // then keep looking
    if(other_vd == (*ds->hd)[1]) return true;
  return false;
}

static bool is_usuable_type(type_t ctype, type_t other) {
  switch(compress(ctype)) {
  case &PointerType(PtrInfo(_,tq,_)):
    if(equal_tqual(tq,mt_tq) && is_void_star(other))
      return true;
    fallthru;
  default: return (Tcutil::typecmp(ctype, other) == 0);
  }
}
static bool can_use_voidstar(type_t ctype) {
  switch(compress(ctype)) {
  case &PointerType(PtrInfo(_,tq,_)): return equal_tqual(tq, mt_tq);
  default: return false;
  }
}

// given a pattern, produce code and environment to initialize the pattern
// variables with the appropriate values.  Updates the environment and
// decls which are passed in by reference.  The lpath is used for 
// reference patterns and is the complete path from the original route.
// The rpath, in contrast, may use intermediate temps.  
static stmt_opt_t extract_pattern_vars(region_t<`rgn> rgn, env_t<`rgn> @nv,
				       patdeclsextra_t<`rgn> @ newdecls,
				       patdecls_t<`rgn> @ prevdecls,
                                       exp_t lpath, exp_t rpath,
                                       pat_t p) {
  type_t t = (type_t)p->topt;
  switch (p->r) {
  case &AliasVar_p(_,vd):
    let p2 = new_pat(&Wild_p_val,0);
    p2->topt = p->topt;
    fallthru(vd,p2);
  case &Var_p(vd,p2):
      // v = r (hoisted and renamed later) and continue matching p2 against r
      let ctype = typ_to_c_array(vd->type);

      for(let pds = *prevdecls; pds != NULL; pds = pds->tl) {
	let $(_, other_vd) = *pds->hd;
	// instead of just checking if its a boxed type which might be an
	// int we just want to see that the c type is a pointer type
	if(is_usuable_type(ctype,other_vd->type)
	   && !vd_in_use(other_vd,newdecls)) {
	  *newdecls = rnew(rgn) List{rnew(rgn) $(vd,other_vd,ctype,false),
				     *newdecls};
          let lhs = set_type(varb_exp(new Local_b(other_vd),DL),ctype);
	  let s = assign_stmt(lhs,deep_copy(rpath),DL);
	  return seq_stmt_opt(s,extract_pattern_vars(rgn,nv,newdecls,
						     prevdecls,lpath,
                                                     deep_copy(lhs),p2));
	}
      }
      // if we get here then we looked through all prev decls
      // and found nothing (available), so we create a new vardecl
      vardecl_t new_vd;
      exp_t lhs;
      new_vd = new_vardecl(DL, temp_var(), ctype, NULL, NULL);
      *newdecls = rnew(rgn) List{rnew(rgn) $(vd,new_vd,ctype,false),
                                 *newdecls};
      let lhs = set_type(varb_exp(new Local_b(new_vd),DL),new_vd->type);
      let s = assign_stmt(lhs,deep_copy(rpath),DL);
      return seq_stmt_opt(s,extract_pattern_vars(rgn,nv,newdecls,
                                                 prevdecls,lpath,
                                                 deep_copy(lhs),p2));
  case &TagInt_p(_,vd): // type translation erases tvar
      // v = r  (hoisted and renamed later)
      let ctype = typ_to_c_array(vd->type);

      for(let pds = *prevdecls; pds != NULL; pds = pds->tl) {
          let $(_, other_vd) = *pds->hd;
          // instead of just checking if its a boxed type which might be an
          // int we just want to see that the c type is a pointer type
          if(is_usuable_type(ctype,other_vd->type)
             && !vd_in_use(other_vd,newdecls)) {
              *newdecls = rnew(rgn) List{rnew(rgn) $(vd,other_vd,ctype,false),
                                         *newdecls};
              let lhs = set_type(varb_exp(new Local_b(other_vd),DL),
                                 other_vd->type);
              return assign_stmt(lhs,deep_copy(rpath),DL);
          }
      }

      vardecl_t new_vd;
      if(can_use_voidstar(ctype)) {
          new_vd = new_vardecl(DL, temp_var(), void_star_type(), NULL, NULL);
          *newdecls = rnew(rgn) List{rnew(rgn) $(vd,new_vd,ctype,true),
                                     *newdecls};
      } else {
          new_vd = new_vardecl(DL, temp_var(), ctype, NULL, NULL);
          *newdecls = rnew(rgn) List{rnew(rgn) $(vd,new_vd,ctype,false),
                                     *newdecls};
      }
      return assign_stmt(set_type(varb_exp(new Local_b(new_vd),DL),
                                  new_vd->type),deep_copy(rpath),DL);
  case &Wild_p: return NULL;
  case &Reference_p(vd,p2):
      // v = &path
      vd->type = cstar_type(t,mt_tq); //DJG: apparently necessary -- bug in tcPat?

      let ctype = typ_to_c_array(vd->type);

      for(let pds = *prevdecls; pds != NULL; pds = pds->tl) {
          let $(_, other_vd) = *pds->hd;
          // instead of just checking if its a boxed type which might be an
          // int we just want to see that the c type is a pointer type
          if(is_usuable_type(ctype,other_vd->type)
             && !vd_in_use(other_vd,newdecls)) {
              *newdecls = rnew(rgn) List{rnew(rgn) $(vd,other_vd,ctype,false),
                                         *newdecls};
              let ptype = cstar_type(typ_to_c_array(t),mt_tq);
              // cast is needed to avoid a C warning when pointing ...
              let vb = set_type(varb_exp(new Local_b(other_vd),DL),
                                other_vd->type);
              let ptr = set_type(push_address_exp(deep_copy(lpath)),ptype);
              let s = assign_stmt(vb,cast_it(ptype,ptr),DL);
              return seq_stmt_opt(s, extract_pattern_vars(rgn,nv,newdecls,
                                                          prevdecls,lpath,
                                                          rpath,p2));
          }
      }

      vardecl_t new_vd;
      if(can_use_voidstar(ctype)) {
          new_vd = new_vardecl(DL, temp_var(), void_star_type(), NULL, NULL);
          *newdecls = rnew(rgn) List{rnew(rgn) $(vd,new_vd,ctype,true),
                                     *newdecls};
      } else {
          new_vd = new_vardecl(DL, temp_var(), ctype, NULL, NULL);
          *newdecls = rnew(rgn) List{rnew(rgn) $(vd,new_vd,ctype,false),
                                     *newdecls};
      }

      // cast is needed to avoid a C warning when pointing to a polymorphic field
      let ptype = cstar_type(typ_to_c_array(t),mt_tq);
      let ptr = set_type(push_address_exp(deep_copy(lpath)),ptype);
      let s = assign_stmt(set_type(varb_exp(new Local_b(new_vd),DL),
                                   new_vd->type),cast_it(ptype,ptr),DL);
      return seq_stmt_opt(s, extract_pattern_vars(rgn,nv,newdecls,prevdecls,lpath,rpath,p2));
      // for these cases, no initialization.
  case &Null_p:
  case &Int_p(...):
  case &Char_p(_):
  case &Float_p(...):
  case &Enum_p(...):
  case &AnonEnum_p(...): return NULL;

    // special case for pointer to datatype
  case &Pointer_p(&Pat{&Datatype_p(tud,tuf,ps,_),_,_}):
    if (ps == NULL) return NULL;
    qvar_t tufstrct = collapse_qvars(tuf->name,tud->name);
    let field_ptr_typ = cstar_type(strctq(tufstrct),mt_tq);
    lpath = cast_it(field_ptr_typ,lpath);
    int cnt      = 1;
    let tuf_tqts = tuf->typs;
    stmt_opt_t s = NULL;
    let new_vd = new_vardecl(DL,temp_var(),field_ptr_typ,
                             cast_it(field_ptr_typ,rpath),NULL);
    let new_rpath = set_type(varb_exp(new Local_b(new_vd),DL),field_ptr_typ);
    for(; ps != NULL; ps = ps->tl, tuf_tqts = tuf_tqts->tl, ++cnt) {
      let p2  = ps->hd;
      if(p2->r == &Wild_p_val) continue;
      let tuf_typ = (*tuf_tqts->hd)[1];
      let t2  = (type_t)p2->topt;
      let t2c = typ_to_c_array(t2);
      let rarrow_exp = aggrarrow_exp(deep_copy(new_rpath), fieldname(cnt), DL);
      let larrow_exp = aggrarrow_exp(deep_copy(lpath), fieldname(cnt), DL);
      set_type(rarrow_exp,t2c);
      set_type(larrow_exp,t2c);
      if(is_void_star_or_boxed_tvar(typ_to_c(tuf_typ))) {
	rarrow_exp = cast_it(t2c, rarrow_exp);
	larrow_exp = cast_it(t2c, larrow_exp);
      }
      s = seq_stmt_opt(s,extract_pattern_vars(rgn,nv,newdecls,prevdecls,larrow_exp,rarrow_exp,p2));
    }
    if (s != NULL) 
      s = decl_stmt(new_decl(new Var_d(new_vd),0),s,0);
    return s;

  case &Datatype_p(_,_,ps,_):
    stmt_opt_t s = NULL;
    for(int cnt = 1; ps != NULL; ps = ps->tl, ++cnt) {
      let p2  = ps->hd;
      if(p2->r == &Wild_p_val)
	continue;
      let t2  = (type_t)p2->topt;
      let t2c = typ_to_c_array(t2);
      let f = fieldname(cnt);
      let lp = set_type(member_exp(lpath,f,DL),t2c);
      let rp = set_type(member_exp(rpath,f,DL),t2c);
      s = seq_stmt_opt(s, extract_pattern_vars(rgn,nv,newdecls,prevdecls,lp,rp,p2));
    }
    return s;

  case &Aggr_p(topt,_,_,dlps,_):
    if (topt == NULL) toc_impos("unresolved aggregate pattern!");
    type_t atype = (type_t)topt;
    list_t<aggrfield_t> fields;
    bool is_tagged = false;
    switch (compress(atype)) {
    case &AppType(&AggrCon(info),_):
      let ad = get_known_aggrdecl(info);
      fields = ad->impl->fields;
      is_tagged = ad->impl->tagged;
      break;
    case &AnonAggrType(ak,is_tuple,fs):
      fields = fs;
      break;
    default: toc_impos("bad type in aggr pattern");
    }
    stmt_opt_t s = NULL;
    for (; dlps != NULL; dlps = dlps->tl) {
      let tup = dlps->hd;
      let p2  = (*tup)[1];
      if(p2->r == &Wild_p_val)
        continue;
      let f = designatorlist_to_fieldname((*tup)[0]);
      let t2 = (type_t)p2->topt;
      let t2c = typ_to_c_array(t2);
      let ftype = lookup_field(fields,f)->type;
      let lmemexp = member_exp(lpath,f,DL);
      let rmemexp = member_exp(rpath,f,DL);
      // tagged unions require an extra .val 
      if (is_tagged) { 
        let u = tagged_union_field_struct(atype,f);
        set_type(lmemexp,u);
        set_type(rmemexp,u);
        lmemexp = member_exp(lmemexp,val_sp,DL);
        rmemexp = member_exp(rmemexp,val_sp,DL);
      }
      lmemexp->topt = typ_to_c_array(ftype);
      rmemexp->topt = typ_to_c_array(ftype);
      if (is_void_star_or_boxed_tvar(ftype)) {
        lmemexp = cast_it(t2c, lmemexp);
        rmemexp = cast_it(t2c, rmemexp);
      } 
      else if (is_array_type(ftype)) {
        rmemexp = deep_copy(lmemexp);
      }
      else if (!is_array_type(ftype)
	       && Kinds::kind_leq(&Kinds::ak,type_kind(ftype))) {
        // for abstract members, we have to convert to the right
        // pointer type...
        let ct = cstar_type(t2c,mt_tq);
        lmemexp = deref_exp(cast_it(ct,set_type(address_exp(lmemexp,DL),ct)),DL);
        lmemexp->topt = t2c;
        rmemexp = deref_exp(cast_it(ct,set_type(address_exp(rmemexp,DL),ct)),DL);
        lmemexp->topt = t2c;
      }
      s = seq_stmt_opt(s, extract_pattern_vars(rgn,nv,newdecls,prevdecls,lmemexp,rmemexp,p2));
    }
    return s;

  case &Pointer_p(p2):
    let t2 = (type_t)p2->topt;
    let t2c = typ_to_c_array(t2);
    let new_vd = new_vardecl(DL,temp_var(),t2c,
                             set_type(deref_exp(rpath,DL),t2c),NULL);
    let rp = set_type(varb_exp(new Local_b(new_vd),DL),t2c);
    let s = extract_pattern_vars(rgn,nv,newdecls,prevdecls,
                                 set_type(deref_exp(lpath,DL),t2c),rp,p2);
    if (s != NULL) 
      s = decl_stmt(new_decl(new Var_d(new_vd),0),s,0);
    return s;

  case &UnknownId_p(_):       toc_impos("unknownid pat");
  case &UnknownCall_p(_,_,_): toc_impos("unknowncall pat");
  case &Exp_p(_):             toc_impos("exp pat");
  }
}

// we have to substitute the associated temps for the
// pattern vars that occur in a where-clause.  This is
// limited to noassign_exp's (see tcstmt.cyc).
static void subst_pattern_vars(patdecls_t env, exp_t e) {
  switch (e->r) {
  case &Var_e(&Pat_b(vd)):  fallthru(vd);
  case &Var_e(&Local_b(vd)):
    // we need to catch Not_found because there might be a local variable
    // which we are say, comparing against which SHOULDN'T be replaced
    try {
      let ctype = typ_to_c_array(vd->type);
      let tmpvd = assoc(env, vd);
      let e1 = new_exp(new Var_e(new Local_b(assoc(env,vd))),DL);
      e1->topt = tmpvd->type;
      e->r = new Cast_e(ctype,e1,false,No_coercion);
    } catch { case &Core::Not_found: break; }
    break;
  case &Conditional_e(e1,e2,e3):
    subst_pattern_vars(env,e1); fallthru(e2,e3);
  case &Comprehension_e(_,e1,e2,_): fallthru(e1,e2);
  case &And_e(e1,e2): fallthru(e1,e2);
  case &Or_e(e1,e2): fallthru(e1,e2);
  case &Subscript_e(e1,e2): fallthru(e1,e2);
  case &SeqExp_e(e1,e2):
    subst_pattern_vars(env,e1); fallthru(e2);
  case &Extension_e(e): fallthru(e);
  case &NoInstantiate_e(e): fallthru(e);
  case &Instantiate_e(e,...): fallthru(e);
  case &Cast_e(_,e,...): fallthru(e);
  case &Sizeofexp_e(e): fallthru(e);
  case &Deref_e(e): fallthru(e);
  case &AggrMember_e(e,...): fallthru(e);
  case &AggrArrow_e(e,...): fallthru(e);
  case &ComprehensionNoinit_e(e,...): fallthru(e);
  case &Address_e(e): subst_pattern_vars(env,e); break;
  case &AssignOp_e(e1,_,e2):
    subst_pattern_vars(env,e1);
    subst_pattern_vars(env,e2);
    break;
  case &FnCall_e(e,es,_,_): subst_pattern_vars(env,e); fallthru(es);
  case &Primop_e(_,es): List::iter_c(subst_pattern_vars,env,es); break;
  case &UnresolvedMem_e(_,dles): fallthru(dles);
  case &Aggregate_e(_,_,dles,_): fallthru(dles);
  case &AnonStruct_e(_,_,dles) : fallthru(dles);
  case &Array_e(dles)          : fallthru(dles);
  case &CompoundLit_e(_,dles)  :
    for (; dles != NULL; dles = dles->tl)
      subst_pattern_vars(env,(*dles->hd)[1]);
    break;
  case &Tagcheck_e(...):
  case &Throw_e(...):
  case &Malloc_e(...):
  case &New_e(...):
  case &Datatype_e(...): Warn::impos2("subst_pattern_vars, unexpected exp");
  default: break;
  }
}

// compiles a decision tree that was generated from the match compiler
// into a set of tests, switches, goto's, etc.  dopt is the decision tree
// and lscs is the original list of switch clauses, together with the labels
// we generated to jump to.  The variable v is used as the root value that
// we're matching on.
static stmt_t
compile_decision_tree(region_t<`rgn> rgn,
		      env_t<`rgn> nv,
		      patdecls_t<`rgn> @ decls,
		      list_t<$(env_t<`rgn>,var_t,stmt_t)@`rgn,`rgn>@ bodies,
		      Tcpat::decision_opt_t dopt,
		      list_t<$(bool,var_t,var_t,switch_clause_t)@> lscs,
		      exp_t v) {
  switch (dopt) {
  // these two cases shouldn't occur -- we let them through silently.
  case NULL: return skip_stmt(0);
  case &Tcpat::Failure(_): return throw_match_stmt();
  case &Tcpat::Success(rhs):
    // find the corresponding rhs in lscs
    for (; lscs != NULL; lscs = lscs->tl) {
      let &$(*already_emitted,init_lab,code_lab,sc) = lscs->hd;
      let body = sc->body;
      if (body == rhs->rhs) {
        // if we've already emitted this rhs, then just goto it.
        if (*already_emitted)
          return goto_stmt(init_lab,DL);
        *already_emitted = true;
        patdeclsextra_t<`rgn> newdecls = NULL;
        // extract all of the pattern variables for this case, the first time this is called
        // from compile_decision_tree, we can pass all of the decls since in the 'case' we are
        // about to check and none of them have been used
        stmt_opt_t init_opt = extract_pattern_vars(rgn,&nv,&newdecls,decls,
                                                   deep_copy(v),
                                                   deep_copy(v),sc->pattern);
        // generate init_lab: <code to extract vars to temps>;
        //          code_lab: <copy-temps-to-declared-patvars>; <rhs>
        stmt_t res = sc->body;
        for (let ds = newdecls; ds != NULL; ds = ds->tl) {
          let $(oldv,newv,oldvt,cast) = *ds->hd;
          *decls = rnew(rgn) List{rnew(rgn) $(oldv,newv),*decls};
          if(cast) 
            oldv->initializer = cast_it(oldvt, set_type(varb_exp(new Local_b(newv), DL),newv->type));
          else oldv->initializer = set_type(varb_exp(new Local_b(newv), DL),newv->type);
          oldv->initializer->topt = newv->type;
          // oldv->type = newv-type; // this was needed because newv has the c type and oldv has the cyc type
          oldv->type = oldvt; // because we might be using a void* for an int* make oldv type whatever it needs to be
          res = decl_stmt(new Decl{new Var_d(oldv),DL}, res, DL);
        }
      res = label_stmt(code_lab,res,DL);
        if (init_opt != NULL)
          res = seq_stmt(init_opt, res, DL);
        res = label_stmt(init_lab, res, DL);
        *bodies = rnew(rgn) List{rnew(rgn) $(nv,code_lab,body), *bodies};
        return res;
      }
    }
    toc_impos("couldn't find rhs!");
  case &Tcpat::SwitchDec(symbolic_path, switches, other_decision):
    // start by compiling the default
    stmt_t res = compile_decision_tree(rgn,nv,decls,bodies,other_decision,lscs,v);
    // now we compile the path to the thing we're testing
    let p = compile_path(List::rev(symbolic_path), deep_copy(v));
    let ss = List::rev(switches);
    // see if we can/should translate this to a switch or a sequence of if's
    let $(allows_switch, test_kind) = admits_switch(ss);
    if (allows_switch > 1) {
      // we'll generate a switch statement here
      // start with the default clause at the end.
      list_t<switch_clause_t> new_lscs =
        new List{new Switch_clause{new_pat(&Wild_p_val,DL),NULL,NULL,res,DL},NULL};
      // add in each switch clause
      for (; ss != NULL; ss = ss->tl) {
        let $(pat_test, dec_tree) = *ss->hd;
        // compile the pattern test for this clause as a case expression
        let case_exp = compile_pat_test_as_case(pat_test);
        // compile the decision tree for this case
        let s = compile_decision_tree(rgn,nv,decls,bodies,dec_tree,lscs,v);
        // add in the new switch clause
        new_lscs = new List(new Switch_clause{case_exp,NULL,NULL,s,DL},new_lscs);
      }
      switch (test_kind) {
      case &DatatypeTagTest:
      LOOP1: // get rid of any extra dereference for datatypes
        switch (p->r) {
        case &Cast_e(_,e,...): p = e; goto LOOP1;
        case &Deref_e(e):      p = e; break;
        default: break;
        }
        p = set_type(deref_exp(cast_it(cstar_type(sint_type,mt_tq),p),DL),uint_type); 
        break;
      case &TaggedUnionTest(t,f): // add an extra .tag for tagged unions
        let t2 = tagged_union_field_struct(t,f);
        p = set_type(member_exp(p,f,DL),t2);
        p = set_type(member_exp(p,tag_sp,DL),uint_type); break;
      case &WhereTest(_): // where shouldn't really happen here.
      case &OtherTest:
	// DJG et al: We are about to make a new switch statement but we are not guaranteed that
	// what we will be switching on has c type int (could be a void*). So, the only way the
	// c compiler won't complain is if we tell it to cast it to an int. Maybe this needs to be
	// other places too?
	p = cast_it(sint_type,p);
	break;
      }
      res = new_stmt(new Switch_s(p,new_lscs,NULL),DL);
    } else {
      // We're going to have to compile the test as an if-then-else
      // We could be down to a where clause
      switch (test_kind) {
      case &WhereTest(e):
        switch (ss) {
          // where-clauses should only occur in a switch with a single case
          // other than the default.
        case &List{&$(pat_test, &Tcpat::Success(rhs)),NULL}:
          // find the corresponding rhs -- this is quite similar to the
          // rhs code above for Success.
          for (; lscs != NULL; lscs = lscs->tl) {
            let &$(*already_emitted,init_lab,code_lab,sc) = lscs->hd;
            let body = sc->body;
            if (body == rhs->rhs) {
              // if we've already emitted code for this case, then goto it.
              if (*already_emitted)
                return goto_stmt(init_lab,DL);
              *already_emitted = true;
              patdeclsextra_t<`rgn> newdecls = NULL;
              // extract all of the pattern variables for this case
              stmt_opt_t init_opt = extract_pattern_vars(rgn,&nv,&newdecls,decls,deep_copy(v),deep_copy(v),sc->pattern);
              // generate init_lab: <code to extract vars>;
              //          if (e) { code_lab: <rhs> } else <default>
              stmt_t r = sc->body;
              for (let ds = newdecls; ds != NULL; ds = ds->tl) {
                let $(oldv,newv,oldvt,cast) = *ds->hd;
                *decls = rnew(rgn) List{rnew(rgn) $(oldv,newv),*decls};
                if(cast) oldv->initializer = cast_it(oldvt, varb_exp(new Local_b(newv), DL));
                else oldv->initializer = varb_exp(new Local_b(newv), DL);
                oldv->initializer->topt = newv->type;
                // oldv->type = newv-type; // this was needed because newv has the c type and oldv has the cyc type
                oldv->type = oldvt; // because we might be using a void* for an int* make oldv type whatever it needs to be
                r = decl_stmt(new Decl{new Var_d(oldv),DL}, r, DL);
              }
              r = label_stmt(code_lab,r,DL);
              // compile the where-clause
              // PROBLEM: we have to map the pattern variables in the
              // where clause to the associated temps.
              exp_to_c(nv,e); // must do before substitution on next line
              subst_pattern_vars(*decls,e);
              r = ifthenelse_stmt(e,r,res,DL);
              if (init_opt != NULL)
                r = seq_stmt(init_opt, r, DL);
              r = label_stmt(init_lab, r, DL);
              *bodies = rnew(rgn) List{rnew(rgn) $(nv,code_lab,body), *bodies};
              return r;
            }
          }
          toc_impos("couldn't find rhs!");
        default: toc_impos("bad where clause in match compiler");
        }
      default:
        // generate a sequence of nested ifs
        for (; ss != NULL; ss = ss->tl) {
          let $(pat_test, dec_tree) = *ss->hd;
          let test_exp = compile_pat_test(p, pat_test);
          let s = compile_decision_tree(rgn,nv,decls,bodies,dec_tree,lscs,v);
          res = ifthenelse_stmt(test_exp,s,res,DL);
        }
      }
    }
    return res;
  }
}

// We record the compiler environment that gets generated for each rhs of
// the case.  This allows us to look it up so that we can use it for fallthru's.
// The only rhs's that will not have an associated env are those that never
// show up in the decision tree.  That should only happen for a catch where
// we added in a default clause that was unnecessary.  The good news is that
// we discover this during switch-compilation and just skip over that clause.
static env_t<`rgn>*`rgn
find_case_env(list_t<$(env_t<`rgn>,var_t,stmt_t)@`rgn,`rgn> bodies, stmt_t s) {
  for (; bodies != NULL; bodies = bodies->tl) {
    let &$(*nv,_,s2) = bodies->hd;
    if (s2 == s) return nv;
  }
  // if we got this far, then we're dealing with a try/catch's default
  // which is never called.
  return NULL;
}

// translate a switch according to the given decision tree.
static void xlate_switch(env_t<`r> nv, stmt_t whole_s,
			 exp_t e, list_t<switch_clause_t> scs,
                         Tcpat::decision_opt_t dopt) {
  let t = (type_t)e->topt;
  exp_to_c(nv,e);

  vardecl_opt_t v = NULL;
  exp_t vexp = e;
  switch(e->r) {
  case &Var_e(b): break;
  default:        
    let x = temp_var();
    v = new_vardecl(0,x,typ_to_c(t),e,NULL);
    vexp = set_type(varb_exp(new Local_b((vardecl_t)v),DL),v->type);
    break;
  }
  var_t end_l = fresh_label();
  TOC_RGN(nv,rgn) {
    let nv = share_env(rgn,nv);
    // for each clause, generate a test label and an entry label, and flag indicating
    // whether we've already emitted code for the rhs of the clause.
    list_t<$(bool,var_t,var_t,switch_clause_t)@> lscs =
      List::rmap_c(rgn,gen_labels,rgn,scs);
    // compile the decision tree -- generates a list of declarations and
    // a list of case bodies with associated labels and environments, as
    // well as a big test statement.
    _ mydecls = NULL;
    _ mybodies = NULL;
    stmt_t test_tree = compile_decision_tree((region_t<`rgn+`r>)rgn, nv, &mydecls, &mybodies,
					     dopt, lscs, vexp);
    // Note that at this point, test_tree contains all of the rhs's, but they
    // have not yet been translated.  That's because we need the compiler environment
    // for the fallthru case which is only generated after compiling the decision
    // tree.  So, now we step through each rhs and compile it.
    for (let lscs2 = lscs; lscs2 != NULL; lscs2 = lscs2->tl) {
      let &$(_,_,body_lab,body_sc) = lscs2->hd;
      stmt_t s = body_sc->body;
      // find the environment for this rhs.
      env_t<`rgn+`r>* envp = find_case_env(mybodies,s);
      // skip over any case that is never called (i.e., has no envp), as it
      // must be dead code (not reachable in the decision tree).
      if (envp == NULL) continue;
      let env = *envp;
      // find the environment for the fallthru case if it's there.
      if (lscs2->tl != NULL) {
        let &$(_,_,fallthru_lab,next_sc) = lscs2->tl->hd;
	// FIX: all we use now is whether next_case_env exists, so this
	//      is a kludge
	let next_case_env = find_case_env(mybodies,next_sc->body);
        // if the next case is never called, then it must've been the default
        // case added for a try/catch in which case, we cannot have this case
        // fallthru to it.  So, we can treat this case as if it were the last
        // of the switch clauses.
        if (next_case_env == NULL)
          stmt_to_c(last_switchclause_env(rgn,env,end_l),s);
        else {
          // set up the environment with the fallthru information.
          list_t<vardecl_t> vs = NULL;
          if (next_sc->pat_vars != NULL) {
            vs = Tcutil::filter_nulls(List::split(next_sc->pat_vars->v)[0]);
            vs = map_c(assoc,mydecls,List::imp_rev(vs));
          }
          stmt_to_c(non_last_switchclause_env(rgn, env, end_l, fallthru_lab,
                                              vs),s);
        }
      } else
        stmt_to_c(last_switchclause_env(rgn,env,end_l),s);
    }
    // almost done -- need to build the declarations, followed by the
    // test tree, followed by the end label.  We construct it backwards...
    stmt_t res = seq_stmt(test_tree,label_stmt(end_l,skip_stmt_dl(),DL),DL);
    // now add in declarations and alpha-convert
    list_t<vardecl_t,`rgn> added = NULL;
    for (; mydecls != NULL; mydecls = mydecls->tl) {
      let $(_,vd) = *mydecls->hd;
      for(let itr = added; itr != NULL; itr = itr->tl)
          if(itr->hd == vd) goto bottom;
      added = rnew(rgn) List{vd, added};
      res = decl_stmt(new_decl(new Var_d(vd), DL), res, DL);
    bottom:
      continue;
    }
    // if we need to declare a variable, do so now.
    if(v != NULL)
      res = decl_stmt(new_decl(new Var_d((vardecl_t)v), DL), res, DL);
    // overwrite original switch with new code.
    whole_s->r = res->r;
    return;
  }
}

///////////////////////////////////////////////////////////////
//              Translation of Statements                    //
///////////////////////////////////////////////////////////////
stmt_t make_npop_handler(int n) {
  return exp_stmt(set_type(fncall_exp_dl(_npop_handler_e,
                                         set_type(signed_int_exp(n-1,DL),sint_type)),void_type),DL);
}
void do_npop_before(int n, stmt_t s) { // mutates s as necessary!
  if(n > 0)
    s->r = seq_stmt_r(make_npop_handler(n),new_stmt(s->r,DL));
}

static void stmt_to_c(env_t nv, stmt_t s) {
  // written to be self-tail recursive
  while (true)
    switch (s->r) {
    case &Skip_s:         return;
    case &Exp_s(e):       exp_to_c(nv, e); return;
    case &Return_s(NULL): do_npop_before(get_npop(s),s); return;
    case &Return_s(e):
      // pop **after** evaluating expression
      type_t t = typ_to_c((type_t)e->topt);
      exp_to_c(nv,e);
      int npop = get_npop(s);
      if(npop > 0) {
	let x = temp_var();
	let retn_stmt = return_stmt(set_type(var_exp(x,DL),t),DL);
	do_npop_before(npop,retn_stmt);
	s->r = declare_stmt(x, t, e, retn_stmt, DL)->r;
      }
      return;
    case &Seq_s(s1,s2):
      stmt_to_c(nv,s1);
      s = s2;
      continue;
    case &IfThenElse_s(e,s1,s2):
      exp_to_c(nv,e);
      stmt_to_c(nv,s1);
      s = s2;
      continue;
    case &For_s(e1,$(e2,_),$(e3,_),s2):
      exp_to_c(nv,e1);
      exp_to_c(nv,e2);
      fallthru(s2,e3);
    case &Do_s(s2,$(e,_)): fallthru(e,s2);
    case &While_s($(e,_),s2):
      exp_to_c(nv,e);
      TOC_RGN(nv,temp) { stmt_to_c(loop_env(temp,nv),s2); }
      return;
    case &Break_s:
      let &Env{.break_lab=b,...} = nv;
      if (b != NULL)
	s->r = goto_stmt_r(*b);
      // reset handler
      do_npop_before(get_npop(s),s);
      return;
    case &Continue_s:
      let &Env{.continue_lab=c,...} = nv;
      if (c != NULL)
	s->r = goto_stmt_r(*c);
      fallthru;
    case &Goto_s(_): // reset handler (earlier checks prevent jump into handler)
      do_npop_before(get_npop(s), s);
      return;
    case &Label_s(lab,s1): s = s1; continue;
    case &Switch_s(e,scs,dec_tree_opt):
      xlate_switch(nv,s,e,scs,dec_tree_opt);
      return;
    case &Fallthru_s(es,dest_clause):
      let &Env{.fallthru_info = fi,...} = nv;
      if(fi == NULL)
	toc_impos("fallthru in unexpected place");
      let FallthruInfo{l,vs} = *fi;
      stmt_t s2 = goto_stmt(l, DL);
      // reset handler (after the es evaluation)
      do_npop_before(get_npop(s), s2);
      let vs2 = List::rev(vs);
      let es2 = List::rev(es);
      for(; vs2 != NULL; vs2 = vs2->tl, es2 = es2->tl) {
	exp_to_c(nv,es2->hd);
	s2 = seq_stmt(assign_stmt(varb_exp(new Pat_b(vs2->hd),DL), es2->hd,DL),
		      s2,DL);
      }
      s->r = s2->r;
      return;
    case &Decl_s(d,body):
      // we have to treat Let_d and Var_d where we bind a comprehension
      // (not at the top-level) specially because these have to return
      // "statements".  See letdecl_to_c and decls_to_c below.
      switch (d->r) {
      case &Var_d(vd): local_decl_to_c(nv, vd, body); break;
      case &Let_d(p,_,e,dec_tree):
        // Handle the special case where the pattern is a variable just like
	// a variable declaration, except variable's scope does NOT include e.
	// copying rather than alpha-conversion is just to help debugging,
	// but for pretty output we compute the special-case of not needing to
        switch (p->r) {
        case &Var_p(vd, &Pat{.r = &Wild_p, ...}):
	  if(var_may_appear_exp(vd->name,e)) {
	    let new_vd = new_vardecl(DL, temp_var(), vd->type, e, NULL);
	    vd->initializer = varb_exp(new Local_b(new_vd),DL);
	    vd->initializer->topt = new_vd->type;
	    s->r = decl_stmt(new_decl(new Var_d(new_vd),s->loc),
			     decl_stmt(new_decl(new Var_d(vd),s->loc),
				       body,s->loc),s->loc)->r;
	  } else {
	    vd->initializer = e;
	    s->r = decl_stmt(new_decl(new Var_d(vd),s->loc),body,s->loc)->r;
	  }
          stmt_to_c(nv, s);
          break;
        default:
	  // we treat let declarations specially because they may need
	  // statements in addition to declarations, so we splice them in
	  // as a statement.  Other declarations only produce declarations.
	  s->r = letdecl_to_c(nv, p, dec_tree, (type_t)e->topt, e, body)->r;
	  break;
        }
	break;
      case &Letv_d(vds):
        // Transform Letv_d into a sequence of Var_d, and call stmt_to_c on
        // the result.
        let rvds = List::rev(vds);
        if (rvds == NULL)
          toc_impos("empty Letv_d");
        d->r = new Var_d(rvds->hd);
        rvds = rvds->tl;
        for (; rvds != NULL; rvds = rvds->tl) {
          let d2 = new_decl(new Var_d(rvds->hd),DL);
          s->r = decl_stmt(d2,new_stmt(s->r,DL),DL)->r;
        }
        stmt_to_c(nv,s);
        break;
      case &Fn_d(fd):
        /* The save/restore is necessary because pop_tables are not
           in the environment but rather in globals at the moment.
           Should change this. */
        let old_pop_table = fn_pop_table; // save
	fndecl_to_c(nv, fd, false);
        fn_pop_table = old_pop_table; // restore
	stmt_to_c(nv,body);
        break;
      case &Region_d(tv, vd, open_exp_opt):
        // NOTE:  _npop_handler has to deal with regions as well as exceptions
        type_t rh_struct_typ     = strct(_RegionHandle_sp);
        type_t rh_struct_ptr_typ = cstar_type(rh_struct_typ,mt_tq);
	let $(rh_var,rh_exp)     = temp_var_and_exp();
        set_type(rh_exp,rh_struct_ptr_typ);
        qvar_t x_var = vd->name;
        exp_t  x_exp = set_type(var_exp(x_var, DL),rh_struct_ptr_typ);

	stmt_to_c(nv,body);
        if (Flags::no_regions)
          s->r = declare_stmt(x_var, rh_struct_ptr_typ,
                              set_type(signed_int_exp(0,DL),sint_type), body, DL)->r;
        else if (open_exp_opt) {
	  // { struct _RegionHandle *x = open_exp_opt -> h; body }
          exp_to_c(nv,open_exp_opt);
          exp_t oparrow = aggrarrow_exp(open_exp_opt,new "h",DL);
          set_type(oparrow,rh_struct_typ);
          exp_t arg = address_exp(oparrow,DL);
          set_type(arg,rh_struct_ptr_typ);
          s->r = declare_stmt(x_var,rh_struct_ptr_typ,arg,body,DL)->r;
        } else {
	  // struct _RegionHandle rh = _new_region();
	  // struct _RegionHandle *x = &rh;
	  // _push_region(x);
	  // body;
	  // _pop_region(x);
	  let _zero_exp = set_type(uint_exp(0,0),uint_type);
	  let _one_exp = set_type(uint_exp(1,0),uint_type);
	  let rgn_flag_exp = Flags::no_reaps ? _one_exp : _zero_exp;
          s->r = declare_stmt(rh_var,rh_struct_typ,
			      set_type(fncall_exp_dl(_new_region_e, rgn_flag_exp, string_exp(*(*x_var)[1],DL)),rh_struct_typ),
			      declare_stmt(x_var, rh_struct_ptr_typ,set_type(address_exp(rh_exp,DL), rh_struct_ptr_typ),
					   seq_stmt(exp_stmt(set_type(fncall_exp_dl(_push_region_e, x_exp),void_type), DL),
						    seq_stmt(body,
							     exp_stmt(set_type(fncall_exp_dl(_pop_region_e),void_type),
								      DL),DL),DL),DL),DL)->r;
	}
	return;
      default: Warn::impos2("bad nested declaration within function");
      }
      return;
    case &TryCatch_s(body,scs,dec_tree):
      // struct handler_cons h;
      // _push_handler(&h);
      // int was_thrown = 0;
      // if (setjmp(h.handler)) was_thrown = 1;
      // if (!was_thrown) {
      //   body
      //   _pop_handler();
      // } else {
      //   exn e = (exn)_exn_thrown;
      //   switch (e) scs
      // }
      // [Auxillary functions are defined in runtime_cyc.c]
      let $(h_var,h_exp) = temp_var_and_exp();
      let $(e_var,e_exp) = temp_var_and_exp();
      let $(was_thrown_var,was_thrown_exp) = temp_var_and_exp();
      type_t h_typ = strct(_handler_cons_sp);
      type_t e_typ = typ_to_c(exn_type());
      type_t was_thrown_typ = typ_to_c(sint_type);
      was_thrown_exp->topt = was_thrown_typ;
      // e_exp needs a typ because it'll go through exp_to_c;
      e_exp->topt = e_typ;
      TOC_RGN(nv, temp) {
        // translate the body
        stmt_to_c(nv,body);
        let tryandpop_stmt = seq_stmt(body,
				      exp_stmt(set_type(fncall_exp_dl(_pop_handler_e),void_type),DL),DL);
        let handler_stmt = new_stmt(new Switch_s(e_exp,scs,dec_tree), DL);
        // translate the switches
        stmt_to_c(nv,handler_stmt);

        // wrap with the conditional, declarations, and setjmp
        let setjmp_call = // setjmp(h.handler)
          set_type(fncall_exp_dl(setjmp_e, 
                                 set_type(member_exp(h_exp,handler_sp,DL),
                                          cstar_type(sint_type,mt_tq))),
                   sint_type);
        let pushhandler_call = // _pushhandler(h);
          exp_stmt(set_type(fncall_exp_dl(_push_handler_e,
                                          set_type(address_exp(h_exp,DL),
                                                   cstar_type(h_typ,mt_tq))),
                            void_type),DL);
        let zero_exp = set_type(int_exp(Signed,0,DL),sint_type);
        let one_exp  = set_type(int_exp(Signed,1,DL),sint_type);
        s->r =
          declare_stmt(h_var, h_typ, NULL,
          seq_stmt(pushhandler_call,
          declare_stmt(was_thrown_var,was_thrown_typ,zero_exp,
          seq_stmt(ifthenelse_stmt(setjmp_call,
                                   assign_stmt(deep_copy(was_thrown_exp),one_exp,DL),
                                   skip_stmt_dl(),DL),
          ifthenelse_stmt(set_type(prim1_exp(Not, was_thrown_exp,DL),sint_type),
                          tryandpop_stmt,
                          declare_stmt(e_var,e_typ,
                                       cast_it(e_typ,set_type(get_exn_thrown_expression(),cstar_type(void_type,mt_tq))), //<--- change _exn_thrown_e to be a call to TLS _exn_thrown
				       handler_stmt,DL),DL),DL),DL),DL),DL)->r;
      }
      return;
    }
}

///////////////////////////////////////////////////////////////
//              Translation of Declarations                  //
///////////////////////////////////////////////////////////////
static void fndecl_to_c(env_t nv, fndecl_t f, bool cinclude) {
  f->i.tvars  = NULL;
  f->i.effect = NULL;
  //  f->i.rgn_po = NULL;
  f->i.qual_bnd = NULL;
  f->i.checks_clause = NULL;
  f->i.requires_clause = NULL;
  f->i.ensures_clause  = NULL;
  f->i.throws_clause = NULL;
  f->i.effconstr = NULL;
  f->i.ret_type  = typ_to_c(f->i.ret_type);
  f->cached_type = typ_to_c((type_t)f->cached_type);
  region frgn;
  let nv = share_env(frgn,nv);
  for (let args=f->i.args; args != NULL; args = args->tl)
    (*args->hd)[2] = typ_to_c((*args->hd)[2]);
  // for C code, we need to go through and convert all of the types
  // from Cyclone types to C, but otherwise leave the code alone.
  if (cinclude) {
    stmttypes_to_c(f->body);
    return;
  }
  fn_pop_table = new Hashtable::lookup(*gpop_tables,f);
  if (f->i.cyc_varargs && f->i.cyc_varargs->name != NULL) {
    let VarargInfo{n,tq,t,i} = *f->i.cyc_varargs;
    let t2 = typ_to_c(fatptr_type(t,heap_rgn_type,al_qual_type,tq,false_type,false_type));// region irrelevant
    let x2 = new $((nmspace_t)Loc_n(),(var_t)n);
    f->i.args = append(f->i.args,new List(new $((var_t)n,tq,t2),NULL));
    f->i.cyc_varargs = NULL;
  }
  // Tovc would like to use param_vardecls:
  for(let arg_vds = f->param_vardecls->v; arg_vds!=NULL; arg_vds=arg_vds->tl)
    arg_vds->hd->type = typ_to_c(arg_vds->hd->type);
  stmt_to_c(clear_toplevel(frgn,nv),f->body);
}

static scope_t scope_to_c(scope_t s) {
  switch (s) {
  case Abstract: return Public; // there's no abstract scope in C
  case ExternC : return Extern;
  default:       return s;
  }
}

// struct & union declarations -- straightforward except when we have
// a tagged union.  When we have:
//   @tagged union Foo { T1 m1; ... Tn mn; };
// this is translated to:
//   struct _union_Foo_m1 { int tag; T1 val; };
//   ...
//   struct _union_Foo_mn { int tag; Tn val; };
//   union Foo { struct _union_Foo_m1 m1; ... struct _union_Foo_mn mn; };
static int aggrdecl_to_c_body<`r2,`d,`r>(region_t<`d> d,
                              $(struct TocState<`d>@`d,aggrdecl_t@`r2)@`r env) {
  let $(s, &ad) = *env;
  let n = ad->name;
  let TocState{.aggrs_so_far = aggrs_so_far, ...} = *s;
  bool seen_defn_before;
  let dopt = Dict::lookup_opt(*aggrs_so_far, n);
  if (dopt == NULL) {
    seen_defn_before = false;
    $(aggrdecl_t,type_t)@ v =
      rnew(d) $(ad, (ad->kind==StructA ? strctq(n) : unionq_type(n)));
    *aggrs_so_far = Dict::insert(*aggrs_so_far,n,v);
  } else {
    let &$(ad2,t) = *dopt;
    if (ad2->impl == NULL) {
      *aggrs_so_far = Dict::insert(*aggrs_so_far,n,rnew(d) $(ad,t));
      seen_defn_before = false;
    } else
      seen_defn_before = true;
  }
  aggrdecl_t new_ad = new Aggrdecl {.kind = ad->kind,
                                    .sc = Public,
                                    .name = ad->name,
                                    .tvs = NULL,
                                    .impl = NULL,
                                    .expected_mem_kind = false,
                                    .attributes = ad->attributes};
  if(ad->impl != NULL && !seen_defn_before) {
    new_ad->impl = new AggrdeclImpl { .exist_vars = NULL,
				      //                                      .rgn_po = NULL,
				      .qual_bnd = NULL,
                                      .fields = NULL,
                                      .tagged = false,
				      .effconstr = NULL};
    list_t<aggrfield_t> new_fields = NULL;
    for (let fields = ad->impl->fields; fields != NULL; fields = fields->tl){
      // JGM: I'm trying to get rid of warnings when we assign "const"
      // locations...
      let old_field = fields->hd;
      let old_type = old_field->type;
      let old_atts = old_field->attributes;
      if (Kinds::kind_leq(&Kinds::ak,type_kind(old_type)) &&
          ((ad->kind == StructA && fields->tl == NULL) ||
           ad->kind == UnionA)) {
        // HACK ALERT:
        // If the last member is abstract we have to do more work:
        //  * if it's an array, we make it an array of size 0
        //  * otherwise as a HACK, we make it an array of void*'s of size 0,
        //    but add the __attribute__((aligned)) to force the thing
        //    to live on a suitable boundary.  This means that any
        //    instantiation has to also be aligned, but it gives us a
        //    way to portably get at the field.
        switch (compress(old_type)) {
        case &ArrayType(ArrayInfo{et,tq,_,zt,ztl}):
          // Note: type checker forces et to be non-abstract
          old_type = new ArrayType(ArrayInfo(et,tq,set_type(uint_exp(0,DL),uint_type),zt,ztl));
          break;
        default:
          old_atts = new List(new Aligned_att(NULL),old_atts);
          old_type = new ArrayType(ArrayInfo(void_star_type(),
                                             mt_tq,
                                             set_type(uint_exp(0,DL),uint_type),
                                             false_type,DL));
        }
      }
      let new_field = new Aggrfield{.name = old_field->name,
                                    .tq = mt_tq,
                                    .type = typ_to_c(old_type),
                                    .width = old_field->width,
                                    .attributes = Atts::atts2c(old_atts), //NKS added conversion to C atts
                                    .requires_clause = NULL};

      // If this is a tagged union, rewrite the member type from T
      // to struct _union_Foo_f {int tag; T val;} where Foo is the name
      // of the union, and f is the name of the member.
      if (ad->impl->tagged) {
        let T = new_field->type;
        let f = new_field->name;
        string_t s = aprintf("_union_%s_%s",*((*ad->name)[1]),*f);
        var_t str = new s;
        let value_field = new Aggrfield(val_sp,mt_tq,T,        NULL,NULL,NULL);
        let tag_field   = new Aggrfield(tag_sp,mt_tq,sint_type,NULL,NULL,NULL);
	let ad2 = make_c_struct_defn(str,list(tag_field,value_field));
        result_decls = new List(new_decl(new Aggr_d(ad2),DL),result_decls);
        new_field->type = strct(str);
      }
      new_fields = new List(new_field,new_fields);
    }
    new_ad->impl->fields = List::imp_rev(new_fields);
  }
  // DJG: !seen_defn_before a hack because of TypedefType
  if (!seen_defn_before)
    result_decls = new List(new Decl(new Aggr_d(new_ad),DL),result_decls);
  return 0;
}
static void aggrdecl_to_c(aggrdecl_t ad) {
  use_toc_state(&ad, (aggrdecl_to_c_body@<`aggrdecl_to_c>)<>);
}

// datatype declarations -- tricky
// For "datatype foo {Bar,Blah,Baz(t1,t2,t3),Baf(t4,t5)}" we generate
//   typedef void *foo;
//   struct Baz_foo_struct {
//     int tag;  // always == 0
//     t1 f1;
//     t2 f2;
//     t3 f3;
//   };
//   struct Baf_foo_struct {
//     int tag;  // always == 1
//     t4 f1;
//     t5 f2;
//   };
// for xdatatype, we pull a really slimy trick: By using char arrays instead
// of ints, the uses get promoted to addresses just like we want.
// When the datatype is "extern" then we don't generate initializers
// for the tags (that should be done elsewhere.)
//
// NB: we allow any number of repeated declarations but we can only
//     declare and initialize global variables once.  So we keep track
//     of what we've seen so far.  And we make the globals static so that
//     extern and what not is only a link-checker thing.  Unfortunately,
//     the static trick doesn't work for xdatatype, which uses the addresses.
static int datatypedecl_to_c_body<`d,`r>(region_t<`d> d,
                                         $(struct TocState<`d>@`d,
                                           datatypedecl_t tud)@`r env) {
  let $(&TocState{.datatypes_so_far = datatypes_so_far, ...},tud) = *env;
  let n = tud->name;
  if(tud->fields == NULL || Set::member(*datatypes_so_far, n))
    return 0;
  *datatypes_so_far = Set::rinsert(d,*datatypes_so_far, n);
  for (let fields = tud->fields->v; fields != NULL; fields = fields->tl) {
    datatypefield_t f = fields->hd;
    // compute the fields for the struct, adding in a tag field
    let fs = NULL;
    int i  = 1;
    for (let ts = f->typs; ts != NULL; ts = ts->tl, i++) {
      let f = new Aggrfield(fieldname(i),(*ts->hd)[0],
                            typ_to_c((*ts->hd)[1]),NULL,NULL,NULL);
      fs = new List(f,fs);
    }
    fs = new List(new Aggrfield(tag_sp,mt_tq,sint_type,NULL,NULL,NULL),
                  imp_rev(fs));
    let ad = make_c_struct_defn(new "", fs);
    ad->name = collapse_qvars(f->name,tud->name);
    result_decls = new List(new_decl(new Aggr_d(ad),DL),result_decls);
  }
  return 0;
}

static void datatypedecl_to_c(datatypedecl_t tud) {
  use_toc_state(tud, datatypedecl_to_c_body<>);
}
// @extensible datatype declarations -- similar to datatype declarations
// For a declaration extending an existing xdatatype, e.g.,
//   "@extensible datatype foo {Bar,Baz(t1,t2)}"
// we generate
//   char Bar[] = "Bar";
//   struct Bar_foo_struct { char *tag; };
//   char Baz[] = "Baz";
//   struct Baz_foo_struct { char *tag; t1 f1; t2 f2; };
// When the xdatatype is extern, then we don't do initializers for the tags.
//
// Thus "Baz(e1,e2)" maps to
// ({struct _Baz_struct *t =
//     (struct _Baz_struct*)malloc(sizeof(struct _Baz_struct));
//   *t = (struct _Baz_struct){.tag=Baz, .f1 = e1, .f2 = e2};
//   t;})
//true if already seen & initialized, false if seen but non initialized (extern)
static int xdatatypedecl_to_c_body<`d,`r>(region_t<`d> d,
                                          $(struct TocState<`d>@`d,
                                            datatypedecl_t xd)@`r env) {
  let $(s,xd) = *env;
  if(xd->fields == NULL)
    return 0;
  let TocState{.xdatatypes_so_far = xdatatypes_so_far, ...} = *s;
  let n = xd->name;
  for (let fs = xd->fields->v; fs != NULL; fs = fs->tl) {
    datatypefield_t f  = fs->hd;
    stringptr_t fn = (*f->name)[1];
    let sz_exp  = set_type(uint_exp(numelts(*fn),DL),uint_type);
    let tag_typ = array_type(char_type,mt_tq,sz_exp,false_type,DL);
    // FIX: making bad alignment and pointer-size assumptions!
    switch (Dict::lookup_opt(*xdatatypes_so_far,f->name)) {
    case NULL:
      exp_opt_t initopt = NULL;
      if (f->sc != Extern)
        initopt = string_exp(*fn,DL);
      let tag_decl = new_vardecl(0,f->name, tag_typ, initopt, NULL);
      tag_decl->sc = f->sc;
      result_decls = new List(new_decl(new Var_d(tag_decl),DL),result_decls);
      *xdatatypes_so_far =
        Dict::insert(*xdatatypes_so_far, f->name, f->sc != Extern);
      list_t<aggrfield_t> fields = NULL;
      int i = 1;
      for (let tqts = f->typs; tqts != NULL; tqts = tqts->tl,i++) {
        let field_n = fieldname(i);
        let newf = new Aggrfield(field_n,(*tqts->hd)[0],
                                 typ_to_c((*tqts->hd)[1]),NULL,NULL,NULL);
        fields = new List(newf,fields);
      }
      fields = new List(new Aggrfield(tag_sp,mt_tq,
                                      cstar_type(char_type,mt_tq),NULL,NULL,NULL),
                        List::imp_rev(fields));
      let strct_decl = make_c_struct_defn(new "",fields);
      strct_decl->name = collapse_qvars(f->name,xd->name);
      result_decls = new List(new_decl(new Aggr_d(strct_decl),DL),result_decls);
      break;
    case &false:
      if (f->sc != Extern) {
        let initopt = string_exp(*fn,DL);
        let tag_decl = new_vardecl(0,f->name, tag_typ, initopt, NULL);
        tag_decl->sc = f->sc;
        result_decls = new List(new_decl(new Var_d(tag_decl),DL),result_decls);
        *xdatatypes_so_far = Dict::insert(*xdatatypes_so_far, f->name, true);
      }
      break;
    default: break;
    }
  }
  return 0;
}

static void xdatatypedecl_to_c(datatypedecl_t xd) {
  use_toc_state(xd, xdatatypedecl_to_c_body<>);
}

static void enumdecl_to_c(enumdecl_t ed) {
  ed->sc = Public; // gcc warns if we have Extern or Static on an enum
  if(ed->fields != NULL)
    enumfields_to_c(ed->fields->v);
}

static void local_decl_to_c(env_t nv,vardecl_t vd,stmt_t s) {
  type_t old_typ = vd->type;
  vd->type = typ_to_c(old_typ);
  // Fat pointers can't be declared with "register" scope
  if (vd->sc == Register && is_fat_pointer_type(old_typ))
    vd->sc = Public;
  stmt_to_c(nv,s);
  if(vd->initializer != NULL) {
    exp_t init = (exp_t)vd->initializer;
    if (vd->sc == Static) {
      // static declarations have to be treated as if they're toplevel
      // w.r.t. the translation.  NB: Any other generated declarations
      // will also be left at top-level??
      TOC_RGN(nv, temp) {
	let nv2 = set_toplevel(temp,nv);
	exp_to_c(nv2, init);
      }
    } else
      exp_to_c(nv, init);
  } else
    // must put in zero for zero-terminated arrays
    switch (compress(old_typ)) {
    case &ArrayType(ArrayInfo{et,_,num_elts_opt,zt,_}):
      if (force_type2bool(false,zt)) {
        if (num_elts_opt == NULL)
          toc_impos("can't initialize zero-terminated array -- size unknown");
        let lhs = subscript_exp(set_type(var_exp(vd->name,DL),
                                         typ_to_c_array(old_typ)),
                                set_type(
                                add_exp(num_elts_opt,
                                        set_type(signed_int_exp(-1,DL),sint_type),DL),sint_type),
                                DL);
        let rhs = set_type(signed_int_exp(0,DL),sint_type);
        s->r = seq_stmt_r(exp_stmt(assign_exp(lhs,rhs,DL),DL),
                          new_stmt(s->r,DL));
      }
      break;
    default: break;
    }
}

// Destructively rewrite the decision tree so that Failure nodes are
// replaced with Success(fail) and Success(_) is replaced with Success(s)
static Tcpat::decision_t rewrite_decision(Tcpat::decision_t d,stmt_t success) {
  switch (d) {
  case &Tcpat::Failure(_):   return d;
  case &Tcpat::Success(rhs): rhs->rhs = success; return d;
  case &Tcpat::SwitchDec(path, sws, *d2):
    *d2 = rewrite_decision(*d2, success);
    for (; sws != NULL; sws = sws->tl) {
      let &$(_,*d2) = sws->hd;
      *d2 = rewrite_decision(*d2, success);
    }
    return d;
  }
}

// let declarations -- tricky
// Unlike other declarations, lets need to execute statements and
// so return a statement.  (See stmt_to_c, case for Decl above.)
// We treat this similar to the compilation of a switch (see xlate_switch
// above) with one case, but where the failure throws Match_Exception.
// Lots of hacks to get this to work right and re-use the pattern
// match compiler.
static stmt_t letdecl_to_c(env_t<`r> nv, pat_t p, Tcpat::decision_opt_t dopt,
                           type_t t, exp_t e, stmt_t s) {
  TOC_RGN(nv,rgn);
  let nv = share_env(rgn,nv);
  let t = (type_t)e->topt;
  exp_to_c(nv,e);

  vardecl_opt_t v = NULL;
  exp_t vexp = e;
  switch(e->r) {
  case &Var_e(b): break;
  default:        
    let x = temp_var();
    v = new_vardecl(0,x,typ_to_c(t),e,NULL);
    vexp = set_type(varb_exp(new Local_b((vardecl_t)v),DL),v->type);
    break;
  }
  exp_t  path  = deep_copy(vexp);
  var_t  end_l = fresh_label();
  // we us a bogus fail statement since it has to pass through translation.
  // we overwrite it with _throw_match() below.  For a success, we goto
  // the end label.
  let succ_stmt = s;
  if (dopt != NULL)
    // rewrite the decision tree so that on failure we throw Match
    // and on success, continue with the body of the let.
    dopt = rewrite_decision(dopt, succ_stmt);

  let c1   = new Switch_clause{p, NULL, NULL, succ_stmt, 0};
  let lscs = List::rmap_c(rgn,gen_labels,rgn,rlist(rgn,c1));
  // declarations and environments generated while compiling decision tree
  //  patdecls_t<`rgn> mydecls = NULL;
  //  list_t<$(env_t<`rgn>,var_t,stmt_t)@`rgn,`rgn> mybodies = NULL;
  _ mydecls = NULL;
  _ mybodies = NULL;
  /*   patdecls_t<`rgn+`r> mydecls = NULL; */
  /*   list_t<$(env_t<`rgn+`r>,var_t,stmt_t)@`rgn+`r,`rgn+`r> mybodies = NULL; */
  // compile the pattern -- this essentially generates
  // if e matches p then <skip> else _throw_match()
  stmt_t test_tree = compile_decision_tree((region_t<`rgn+`r>)rgn, nv, &mydecls,
					   &mybodies, dopt, lscs, vexp);
  // translate the body of the let under the env we get out of match
  // compilation.
  for (; ; mybodies = mybodies->tl) {
    if(mybodies == NULL)
      toc_impos("letdecl_to_c: couldn't find env!");
    let &$(env,_,st) = mybodies->hd;
    if (st == succ_stmt) { stmt_to_c(env,s); break; }
  }
  // put the tests in front
  stmt_t res = test_tree;
  // now add in declarations of temps generated for pattern matching
  for (; mydecls != NULL; mydecls = mydecls->tl) {
    let &$(_,vd) = mydecls->hd;
    res = decl_stmt(new_decl(new Var_d(vd), DL), res, DL);
  }
  if(v != NULL) 
    res = decl_stmt(new_decl(new Var_d((vardecl_t)v), DL), res, DL);
  return res;
}

// These next few functions clean up the types in C code, getting
// rid of stuff inserted by the parser (e.g., region evars).
static bool types_to_c_f1(bool ignore, exp_t e) {
  switch(e->r) {
  case &CompoundLit_e(&$(_,_,*t),_): fallthru(t);
  case &Offsetof_e(*t,_): fallthru(t);
  case &Cast_e(*t,...):   fallthru(t);
  case &Sizeoftype_e(*t): *t = typ_to_c(*t); break;
  case &Malloc_e(*m):
    if (m->elt_type != NULL)
      m->elt_type = new (typ_to_c(*m->elt_type));
    break;
  default: break;
  }
  return true;
}
static bool types_to_c_f2(bool ignore, stmt_t s) {
  switch(s->r) {
  case &Decl_s(d,_):
    switch(d->r) {
    case &Var_d(vd): vd->type = typ_to_c(vd->type); break;
    case &Fn_d(fd):
      fd->i.ret_type = typ_to_c(fd->i.ret_type);
      for (let args=fd->i.args; args != NULL; args = args->tl)
	(*args->hd)[2] = typ_to_c((*args->hd)[2]);
      break;
    case &Aggr_d(ad): aggrdecl_to_c(ad); break;
    case &Enum_d(ed):
      if (ed->fields != NULL)
	for (let fs = ed->fields->v; fs != NULL; fs = fs->tl)
	  if (fs->hd->tag != NULL) exptypes_to_c((exp_t)fs->hd->tag);
      break;
    case &Typedef_d(td): td->defn = typ_to_c((type_t)td->defn); break;
    default: break;
    }
    break;
  case &Fallthru_s(...):
    // in C code, this is implicit, so we replace it with a skip
    s->r = new Skip_s;
    return false;
  default: break;
  }
  return true;
}
static void exptypes_to_c(exp_t e) {
  visit_exp(types_to_c_f1,types_to_c_f2,true,e);
}
static void stmttypes_to_c(stmt_t s) {
  visit_stmt(types_to_c_f1,types_to_c_f2,true,s);
}

// Translate the given declarations, producing a new list of declarations
// and a new translation environment.  Top-level variable
// declarations are treated differently.
static void decls_to_c(env_t nv, list_t<decl_t> ds, bool cinclude) {
  for (; ds != NULL; ds = ds->tl) {
    fresh_label_counter = 0; // DJG: why not?
    decl_t d = ds->hd;
    switch (d->r) {
    case &Var_d(vd):
      let c_name = vd->name;
      // strip any namespace from an extern C declaration
      if (vd->sc == ExternC)
	c_name = new $(Abs_n(NULL,true),(*c_name)[1]);
      if (vd->initializer != NULL) {
        if (vd->sc == ExternC) vd->sc = Public;
        if (cinclude)
          exptypes_to_c((exp_t)vd->initializer);
        else
          exp_to_c(nv, (exp_t)vd->initializer);
      }
      vd->name = c_name;
      vd->sc   = scope_to_c(vd->sc);
      vd->type = typ_to_c(vd->type);
      result_decls = new List(d,result_decls);
      break;
    case &Fn_d(fd):
      // strip any namespace from an extern C declaration
      if (fd->sc == ExternC) { //but subsequent phases should ignore the body
	fd->name = new $(Abs_n(NULL,true),(*fd->name)[1]);
        fd->sc = Public; // function declarations can't be extern
      }
      fndecl_to_c(nv, fd, cinclude);
      result_decls = new List(d,result_decls);
      break;
    case &Let_d(...):
    case &Letv_d(_):     toc_impos("letdecl at toplevel");
    case &Region_d(...): toc_impos("region decl at toplevel");
    case &Aggr_d(sd): aggrdecl_to_c(sd); break;
    case &Datatype_d(tud):
      tud->is_extensible ? xdatatypedecl_to_c(tud) : datatypedecl_to_c(tud);
      break;
    case &Enum_d(ed):
      enumdecl_to_c(ed);
      result_decls = new List(d,result_decls);
      break;
    case &Typedef_d(td):
      td->tvs  = NULL;
      if (td->defn != NULL) {
	td->defn = typ_to_c((type_t)td->defn);
        // JGM: when we're expanding typedef's, we need to add back as
        // a declaration any enum's since they are dropped otherwise.
	switch(td->defn) {
	case &TypeDeclType(&{.r = &Enum_td(ed2),.loc = loc},_):
	  let ed = new Decl{.r = new Enum_d(ed2), .loc = loc};
          result_decls = new List(ed, result_decls);
	  td->defn = new AppType(new EnumCon(ed2->name,ed2),NULL);
	  break;
	default: break;
	}
      } else // abstract typedef; use void or void* depending on kind
	td->defn = (td->kind->v->kind==BoxKind) ? void_star_type() : void_type;
      // for non-anonymous-aggregates, this is wasteful b/c the printer
      // will skip any use of the typedef
      // DJG: anonymous aggregates are now hoisted
      if(Flags::noexpand_r)
	result_decls = new List(d,result_decls);
      break;
    case &Porton_d:
    case &Portoff_d:
    case &Tempeston_d:
    case &Tempestoff_d: break;
    case &Namespace_d(_,ds2):        fallthru(ds2);
    case &Using_d(_,ds2):            fallthru(ds2);
    case &ExternC_d(ds2):            decls_to_c(nv,ds2,cinclude); break;
    case &ExternCinclude_d(ds2,...): decls_to_c(nv,ds2,true);     break;
    }
  }
}

// initialize all globals
//static
void init() {
  //  let RealNewDynamicRegion{dyn} = real_new_rckey();
    let NewDynamicRegion{dyn} = new_rckey();
  let ts;
  {region h = open(dyn);
  ts = empty_toc_state(h);}
  toc_state = qunew TocStateWrap{dyn, ts};
  result_decls = NULL;
  tuple_type_counter = 0;
  temp_var_counter = 0;
  fresh_label_counter = 0;
  // must turn all of the Abs_n's into C_n
  _throw_pr.f0.C_n = NULL;
  setjmp_pr.f0.C_n = NULL;
  _push_handler_pr.f0.C_n = NULL;
  _pop_handler_pr.f0.C_n = NULL;
  _exn_thrown_pr.f0.C_n = NULL;
  _npop_handler_pr.f0.C_n = NULL;
  _check_null_pr.f0.C_n = NULL;
  _check_known_subscript_null_pr.f0.C_n = NULL;
  _check_known_subscript_notnull_pr.f0.C_n = NULL;
  _check_fat_subscript_pr.f0.C_n = NULL;
  _fat_ptr_pr.f0.C_n = NULL;
  _tag_fat_pr.f0.C_n = NULL;
  _untag_fat_ptr_check_bound_pr.f0.C_n = NULL;
  _untag_fat_ptr_pr.f0.C_n = NULL;
  _check_fat_at_base_pr.f0.C_n = NULL;
  _get_fat_size_pr.f0.C_n = NULL;
  _fat_ptr_decrease_size_pr.f0.C_n = NULL;
  _get_zero_arr_size_char_pr.f0.C_n = NULL;
  _get_zero_arr_size_other_pr.f0.C_n = NULL;
  _fat_ptr_plus_pr.f0.C_n = NULL;
  _zero_arr_plus_char_pr.f0.C_n = NULL;
  _zero_arr_plus_other_pr.f0.C_n = NULL;
  _fat_ptr_inplace_plus_pr.f0.C_n = NULL;
  _zero_arr_inplace_plus_char_pr.f0.C_n = NULL;
  _zero_arr_inplace_plus_other_pr.f0.C_n = NULL;
  _fat_ptr_inplace_plus_post_pr.f0.C_n = NULL;
  _zero_arr_inplace_plus_post_char_pr.f0.C_n = NULL;
  _zero_arr_inplace_plus_post_other_pr.f0.C_n = NULL;
  _cycalloc_pr.f0.C_n = NULL;
  _cyccalloc_pr.f0.C_n = NULL;
  _cycalloc_atomic_pr.f0.C_n = NULL;
  _cyccalloc_atomic_pr.f0.C_n = NULL;
  _region_malloc_pr.f0.C_n = NULL;
  _region_calloc_pr.f0.C_n = NULL;
  _region_vmalloc_pr.f0.C_n = NULL;
  _aqual_malloc_pr.f0.C_n = NULL;
  _aqual_calloc_pr.f0.C_n = NULL;
  _fast_region_malloc_pr.f0.C_n = NULL;
  _check_times_pr.f0.C_n = NULL;
  _new_region_pr.f0.C_n = NULL;
  _push_region_pr.f0.C_n = NULL;
  _pop_region_pr.f0.C_n = NULL;
  _throw_arraybounds_pr.f0.C_n = NULL;
  _throw_match_pr.f0.C_n = NULL;
  _rethrow_pr.f0.C_n = NULL;
  _throw_assert_pr.f0.C_n = NULL;

  globals = new {
    &_throw_str,
    &setjmp_str,
    &_push_handler_str,
    &_pop_handler_str,
    &_exn_thrown_str,
    &_npop_handler_str,
    &_check_null_str,
    &_check_known_subscript_null_str,
    &_check_known_subscript_notnull_str,
    &_check_fat_subscript_str,
    &_tag_fat_str,
    &_untag_fat_ptr_check_bound_str,
    &_untag_fat_ptr_str,
    &_check_fat_at_base_str,
    &_get_fat_size_str,
    &_get_zero_arr_size_char_str,
    &_get_zero_arr_size_other_str,
    &_fat_ptr_plus_str,
    &_zero_arr_plus_char_str,
    &_zero_arr_plus_other_str,
    &_fat_ptr_inplace_plus_str,
    &_zero_arr_inplace_plus_char_str,
    &_zero_arr_inplace_plus_other_str,
    &_fat_ptr_inplace_plus_post_str,
    &_zero_arr_inplace_plus_post_char_str,
    &_zero_arr_inplace_plus_post_other_str,
    &_cycalloc_str,
    &_cyccalloc_str,
    &_cycalloc_atomic_str,
    &_cyccalloc_atomic_str,
    &_region_malloc_str,
    &_region_calloc_str,
    &_check_times_str,
    &_new_region_str,
    &_push_region_str,
    &_pop_region_str,
    &_throw_arraybounds_str,
    &_fat_ptr_decrease_size_str,
    &_throw_match_str,
    &_fast_region_malloc_str,
    &_region_vmalloc_str,
    &_aqual_malloc_str,
    &_aqual_calloc_str,
    &_throw_assert_str,
    &_rethrow_str
  };
}

void finish() {
  toc_state_t ts = NULL;
  ts :=: toc_state;
  let TocStateWrap{dyn, s} = *ts;
  // reclaim space used by extensible array for the labels
  {region h = open(dyn);
  let TocState{.temp_labels = tls, ...} = *s;
  Xarray::reuse(tls);}

  //  Core::real_free_rckey(dyn);
  Core::free_rckey(dyn);
  Core::ufree(ts);

  gpop_tables  = NULL;
  fn_pop_table = NULL;
}

// The entry point:  translate the list of Cyclone declarations to
// a list of C declarations.
list_t<decl_t> toc(table_t<fndecl_t,table_t<stmt_t,int>> pop_tables,
		   list_t<decl_t> ds) {
  gpop_tables = new pop_tables;
  init();
  region start;
  decls_to_c(empty_env(start),ds,false);
  return imp_rev(result_decls);
}
