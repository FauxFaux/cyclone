// Toc.pop:  copyright (c) 2000, Greg Morrisett and Trevor Jim
//
// Translation of Cyclone abstract syntax to C abstract syntax.
// Assumes that the type-checker has been successfully run on
// the Cyclone AST.  Uses lots of GCC-specific features (that should
// be in C-9X) to simplify the translation -- in particular, we use
// struct expressions "(struct foo){.f1=e1,.f2=e2,...,.fn=en}" and
// statement expressions "({int temp = e;  temp++})".  The
// latter is crucial for declaring temps needed in the translation
// of expressions.  It would be nice to avoid these and be able
// to generate ANSI C (so we can at least use VC++).

// The translation is mostly done in place in an imperative style
// (i.e., we overwrite AST nodes) so it's fairly crucial that we
// don't have sharing in the AST.  The one exception is that the
// type translation is functional.

// We need to figure out how to do the name mangling systematically,
// especially for namespaces.  Right now, I'm using identifers that
// start with a dollar sign (e.g., "$foo") for "reserved" words and
// temps, and using a dollar sign to separate namespaces (which
// is obviously broken).  This needs to be thought through more carefully.

// Look for "unimp" or comments that start with FIX: for missing
// or broken pieces.

// MAJOR TODO LIST:
//  pull out common things better

// FIX: we could probably use "const" in lots of places where we're not.

// Note: we generate lots of struct and enum types that don't have pointers
//       back to the corresponding decls.  The printer doesn't follow these
//       pointers, else we need to set them.

#include "core.h"
#include "list.h"
#include "string.h"
#include "set.h"
#include "dict.h"
#include "position.h"
#include "absyn.h"
#include "absynpp.h"
#include "tcutil.h"
#include "evexp.h"
#include "formatstr.h"
#include "toc.h"
using Core;
using List;
using Set;
using Position;
using Absyn;
using Absynpp;
using Tcutil;

namespace Toc;

// used for creation of all abstract syntax nodes here
#define DL null
// set to true to force null checking in generated code -- default to
// false for now to simplify the output and make it more readable.
bool check_for_null = false;

// errors and reporting
xenum exn {Toc_Unimplemented};
xenum exn {Toc_Impossible};
static `a unimp<`a>(string s) {
  fprintf(cyc_stderr,"%s\n",s);
  throw Toc_Unimplemented();
}
static `a toc_impos<`a>(string s) {
  fprintf(cyc_stderr,"%s\n",s);
  throw Toc_Impossible();
}

// return true if t is a nullable pointer type i.e., *
static bool is_nullable(typ t) {
  if (!check_for_null) return false;
  switch (compress(t)) {
  case PointerType(_,_,b,_):
    switch (compress_conref(b)->v) {
    case Eq_constr(b2): return b2;
    default:            return false;
    }
  default: toc_impos("is_nullable"); return false;
  }
}
static bool really_is_nullable(typ t) {
  bool b = check_for_null;
  check_for_null = true;
  bool ans = is_nullable(t);
  check_for_null = b;
  return ans;
}

// no longer does anything -- much easier to do in pretty-printer
static qvar collapse_qvar(qvar x) {
  return x;
}
static qvar collapse_qvar_tag(qvar x,string tag) {
  return &$(x[0], String::strconcat(x[1],tag));
}

// used to generate struct definitions for tuple types
// we share the struct definitions where possible.
// FIX: should use an efficient map data structure.
static list<$(var,list<typ>)@> tuple_types = null;
static int tuple_type_counter = 0;
static var add_tuple_type(list<$(tqual,typ)@> tqs0) {
  for (_ tts = tuple_types; tts != null; tts = tts->tl) {
    let &$(x,ts) = tts->hd;
    bool okay = true;
    _    tqs  = tqs0;
    for (; tqs != null && ts != null; tqs = tqs->tl, ts = ts->tl)
      if (!unify(tqs->hd[1],ts->hd)) {
	okay = false;
	break;
      }
    if (!okay || tqs != null || ts != null)
      continue;
    return x;
  }
  string x = xprintf("_tuple%d",tuple_type_counter++);
  tuple_types = &cons(&$(x,List::map(snd,tqs0)),tuple_types);
  return x;
}

// used to generate struct definitions for tagged array types (e.g., t[?])
// we share the struct definitions where possible.
// FIX: should use an efficient map data structure.
static list<$(var,typ)@> tagged_array_types = null;
static int tagged_array_counter = 0;
static var add_tagged_array_type(typ t,tqual tq) {
  // Handle char[?] specially, its C implementation is in cyc_include.h
  switch (t) {
  case IntType(Unsigned,B1,Unboxed): return "_tagged_string";
  default: break; //skip
  }
  for(_ tts = tagged_array_types; tts != null; tts = tts->tl) {
    let &$(x,t2) = tts->hd;
    if (!unify(t,t2)) continue;
    return x;
  }
  string x = xprintf("_tagged_array%d",tagged_array_counter++);
  tagged_array_types = &cons(&$(x,t),tagged_array_types);
  return x;
}

// generate a temporary variable
// FIX: need to guarantee these can't conflict
static int temp_var_counter = 0;
static qvar temp_var() {
  return &$(null,xprintf("_temp%d",temp_var_counter++));
}

// generate a fresh label
// FIX: need to guarantee these can't conflict
static int fresh_label_counter = 0;
static var fresh_label() {
  return xprintf("_LL%d",temp_var_counter++);
}

// generate a top-level declaration -- used during translation of
// top-level initializers that C doesn't support
static list<decl> temp_topdecls = null;

///////////////////////////////////////////////////////////////
//         Convert a Cyclone type to a C type                //
///////////////////////////////////////////////////////////////
static $(List::list<var>,var) longlong_v = $(null,(string)"_LongLong");
static typ longlong_typ = TypedefType(&longlong_v,null,null);

extern typ typ_to_c(typ t);
static $(Opt_t<var>,tqual,typ)@ arg_to_c($(Opt_t<var>,tqual,typ)@ a) {
  return &$(a[0],a[1],typ_to_c(a[2]));
}
static $(tqual,typ)@ typ_to_c_f($(tqual,typ)@ x) {
  return &$(x[0],typ_to_c(x[1]));
}
// Sometimes we translate arrays t[] and t[N] to t*, and sometimes
// we leave them alone.  We must leave them alone in the following
// circumstances:
// 1. as the argument of sizeof
// 2. in typedef
// 3. in declarations
// 4. as the element type of an array
// 5. as the type part of a C9X compound literal
// 6. as the type of a struct field
// We must change them to pointers in the following circumstances:
// 1. as the argument of cast
// We can do either in the following circumstances:
// 1. as the parameter of a function
// The function typ_to_c_array leaves them alone, while typ_to_c
// changes them to pointers.
static typ typ_to_c_array(typ t) {
  switch(t) {
  case ArrayType(t2,tq,UntaggedArray): // FIX: do we handle tq correctly?
    return ArrayType(typ_to_c_array(t2),tq,UntaggedArray);
  case ArrayType(t2,tq,FixedArray(x)): // FIX: do we handle tq correctly?
    return ArrayType(typ_to_c_array(t2),tq,FixedArray(x));
  case Evar(_,&Opt{.v=t2},_): return typ_to_c_array(t2);
  default:
    return typ_to_c(t);
  }
}
static typ typ_to_c(typ t) {
  switch (t) {
  case VoidType:              return t;
      // FIX:  Typically this happens with throw, and void seems to be
      // the right thing to return.  But, I'm not sure.
  case Evar(_,null,_):        return VoidType;
  case Evar(_,&Opt{.v=t2},_): return typ_to_c(t2);
    // type variables (`a) are mapped to void*
  case VarType(_):            return void_star_typ();
  case EnumType(tdnopt,ts,_):
    if (tdnopt == null) unimp("anonymous enum");
    // enum foo is mapped to foo -- see enumdecl_to_c below
    return TypedefType(collapse_qvar(tdnopt->v),null, &Opt(void_star_typ()));
  case XenumType(tdn,_):
    // xenum bar is mapped to bar -- see xenumdecl_to_c below
    // FIX:  the actual type appears both here and in xenumdecl_to_c,
    // get rid of the repetition
    return TypedefType(collapse_qvar(tdn),null,
		       &Opt(nullableptr_typ(strct("_xenum_struct"),
					    empty_tqual())));
  case PointerType(t2,_,b,tq):
    // we map t@ to t*, region is irrelevant
    return PointerType(typ_to_c(t2),HeapRgnType,new_conref(true),tq);
  // We assume that these are suitably defined already in an appropriate
  // include file -- especially the boxed versions and the bools.
  case IntType(sn,B8,Boxed): return longlong_typ;
  case IntType(_,_,_):       return t;
  case FloatType(_):         return t;
  case DoubleType(_):        return t;
  case ArrayType(t2,tq,ak):
    // t2[?] maps to struct tagged_array_t2*, where we define
    // struct tagged_array_t2 { unsigned int sz; t2 contents[]; };
    // t2[] and t2[3] map to t2*.
    t2 = typ_to_c_array(t2);
    switch (ak) {
    case TaggedArray:
      // returns the name of a struct type for the array
      _ n = add_tagged_array_type(t2,tq);
      return nullableptr_typ(strct(n),empty_tqual());
    default:
      return nullableptr_typ(t2,tq);
    }
  case FnType(_,t2,args,vararg):
    // just drop the type arguments and translate the nested types
    // FIX:  problem with higher-order functions?  Again C's rules are strange.
    return FnType(null,typ_to_c(t2),List::map(arg_to_c,args),vararg);
  case TupleType(tqs):
    // $(t1,...,tn) maps to struct tuple_type_n where we define
    // struct tuple_type_n { t1 f1; ...; tn fn; };
    tqs = List::map(typ_to_c_f,tqs);
    _ n = add_tuple_type(tqs);
    return strct(n);
  case StructType(tdnopt,ts,_):
    if (tdnopt == null) unimp("anonymous struct");
    // just drop the type arguments and translate the nested types
    return strctq(collapse_qvar(tdnopt->v));
  case TypedefType(tdn,ts,topt):
    if (topt == null) return toc_impos("Toc::typ_to_c: unresolved TypedefType");
    // just drop the type arguments and translate the nested types
    return TypedefType(collapse_qvar(tdn),null, &Opt(typ_to_c_array(topt->v)));
  case RgnHandleType(t):
    // presumably the runtime will cast this as necessary
    return void_star_typ();
  case HeapRgnType:
    return toc_impos("Toc::typ_to_c: type translation passed the heap region");
  case UnionType:
    return toc_impos("uniontype");
  }
}

// JGM: Fix -- the type translation already does this!
// In some contexts, we need to map t[] or t[3] to *t -- we assume
// that t[?] types have been translated away.  We pass along as well
// an expression and location, so we can omit a cast if possible.
static exp array_to_ptr(typ t,exp e,segment l) {
  switch (t) {
  case ArrayType(t2,tq,ak): return cast_exp(nullableptr_typ(t2,tq),e,l);
  default:                  return e;
  }
}
// The same, but the cast is forced.
static exp array_to_ptr_cast(typ t,exp e,segment l) {
  switch (t) {
  case ArrayType(t2,tq,ak): return cast_exp(nullableptr_typ(t2,tq),e,l);
  default:                  return cast_exp(t,e,l);
  }
}

// returns true when the type contains no pointers
static bool atomic_typ(typ t) {
  switch (compress(t)) {
  case VoidType: return true;
  case VarType(_): return false;
  case IntType(_,B8,Boxed): return false;
  case IntType(_,_,_): return true;
  case FloatType(_): return true;
  case DoubleType(Boxed): return false;
  case DoubleType(Unboxed): return true;
  case ArrayType(_,_,TaggedArray): return false;
  case ArrayType(t,_,_): return atomic_typ(t);
  case FnType(_,_,_,_): return true;
  case TupleType(tqs):
    for (; tqs != null; tqs = tqs->tl)
      if (!atomic_typ(tqs->hd[1])) return false;
    return true;
  // FIX -- really need the struct and enum definitions
    // have them now, really need to compute in terms of the instantiation
    // to be as aggressive as possible.
    // note even without this we'll allocation Position::segment with atomic.
  case StructType(_,_,_): return false;
  case EnumType(_,_,_):   return false;
  case XenumType(_,_):    return false;
  case UnionType: return false;
  case PointerType(_,_,_,_): return false;
  case RgnHandleType(_): return false;
  default:
    toc_impos(xprintf("atomic_typ:  bad type %s",typ2string(t)));
    return false;
  }
}

// possible pointer malloc
static exp malloc_ptr(exp s) {
  return fncall_exp(var_exp(&$(null,(string)"GC_malloc"),DL),&cons(s,null),DL);
}

// no pointers possible malloc
static exp malloc_atomic(exp s) {
  return fncall_exp(var_exp(&$(null,(string)"GC_malloc_atomic"),DL),
		    &cons(s,null),DL);
}

// malloc something -- choose malloc routine according to the (Cyclone) type
static exp malloc_exp(typ t,exp s) {
  if (atomic_typ(t))
    return malloc_atomic(s);
  else
    return malloc_ptr(s);
}

///////////////////////////////////////////////////////////////
//       Conversions for Expressions between Types           //
///////////////////////////////////////////////////////////////
// This section implements the various casts from one Cyclone
// type to another (e.g., boxing, unboxing, tagging, etc.)
static enum Conv {
  BoxLongLong;      // long long -> Long Long
  UnboxLongLong;    // Long Long -> long long
  BoxFloat;         // float -> Float
  UnboxFloat;       // Float -> float
  BoxDouble;        // double -> Double
  UnboxDouble;      // Double -> double
  NullCheck(typ);        // t* -> t@
  TagFixedArray(typ,exp);    // t[e] -> t[?]
  FixTaggedArray(typ,exp);   // t[?] -> t[e]
};
typedef enum Conv conv;

// Calculate the conversions needed to map t1 to t2 -- the conversions
// should be applied in reverse order.
//
// FIX:  should deal with conversions to/from arithmetic types and
// bools and enums.  Should also make sure this is synchronized with
// the type checker -- the right way to do this is to compute the
// conversions within the type checker itself.
static list<conv> conversion(typ t1, typ t2) {
  t1 = compress(t1);
  t2 = compress(t2);
  switch ($(t1,t2)) {
    // large boxed t1's must be unboxed
  case $(IntType(_,B8,Boxed), IntType(_,B8,Boxed)):
    return null;
  case $(IntType(_,B8,Boxed), FloatType(Boxed)):
    return &cons(BoxFloat,&cons(UnboxLongLong,null));
  case $(IntType(_,B8,Boxed), DoubleType(Boxed)):
    return &cons(BoxDouble,&cons(UnboxLongLong,null));
  case $(IntType(_,B8,Boxed), _):
    return &cons(UnboxLongLong,null);

  case $(FloatType(Boxed), IntType(_,B8,Boxed)):
    return &cons(BoxLongLong,&cons(UnboxFloat,null));
  case $(FloatType(Boxed), FloatType(Boxed)):
    return null;
  case $(FloatType(Boxed), DoubleType(Boxed)):
    return &cons(BoxDouble,&cons(UnboxFloat,null));
  case $(FloatType(Boxed), _):
    return &cons(UnboxFloat,null);

  case $(DoubleType(Boxed), IntType(_,B8,Boxed)):
    return &cons(BoxLongLong,&cons(UnboxDouble,null));
  case $(DoubleType(Boxed), FloatType(Boxed)):
    return &cons(BoxFloat,&cons(UnboxDouble,null));
  case $(DoubleType(Boxed), DoubleType(Boxed)):
    return null;
  case $(DoubleType(Boxed), _):
    return &cons(UnboxDouble,null);

    // If we got this far, t1 is not large and boxed
  case $(_, IntType(_,B8,Boxed)): return &cons(BoxLongLong,null);
  case $(_, FloatType(Boxed)):    return &cons(BoxFloat,   null);
  case $(_, DoubleType(Boxed)):   return &cons(BoxDouble,  null);

    // insert null checks if such a thing is turned on
  case $(PointerType(_,_,_,_),PointerType(_,_,_,_)):
    if(is_nullable(t1) && !is_nullable(t2))
      return &cons(NullCheck(t2),null);
    else
      return null;

    // convert arrays
  case $(ArrayType(_,_,TaggedArray),    ArrayType(_,_,FixedArray(e2))):
    return &cons(FixTaggedArray(typ_to_c(t2),e2), null);
  case $(ArrayType(_,_,FixedArray(e1)), ArrayType(_,_,TaggedArray)):
    return &cons(TagFixedArray(typ_to_c(t1),e1), null);

  default: return null;
  }
}

// long long -> Long Long
static exp box_longlong_conv(bool toplevel, exp e) {
  if (toplevel) {
    // struct _boxed_long_long_struct x = { e };
    // &x
    qvar x = temp_var();
    exp init = unresolvedmem_exp(null,&cons(&$(null,e),null),DL);
    vardecl vd = static_vardecl(x,strct("_boxed_long_long_struct"),&Opt(init));
    temp_topdecls = &cons(new_decl(Var_d(vd),DL),temp_topdecls);
    return address_exp(var_exp(x,DL),DL);
  } else {
    // ({ _LongLong x =
    //        (_LongLong)malloc(sizeof(struct _boxed_long_long_struct));
    //    x->v = e; x; })
    qvar x = temp_var();
    exp init = cast_exp(longlong_typ,
			malloc_atomic(sizeof_exp(strct("_boxed_long_long_struct"),DL)),DL);
    stmt s = seq_stmt(assign_stmt(structarrow_exp(var_exp(x,DL),"v",DL),e,DL),
		      exp_stmt(var_exp(x,DL),DL),DL);
    return stmt_exp(declare_stmt(x,longlong_typ,&Opt(init),s,DL),DL);
  }
}

// Long Long -> long long
static exp unbox_longlong_conv(bool toplevel, exp e) {
  // FIX:
  if (toplevel)
    unimp("can't unbox top-level Long Long");
  // ((_LongLong)e)->v
  return structarrow_exp(cast_exp(longlong_typ,e,DL),"v",DL);
}

// float -> Float
static exp box_float_conv(bool toplevel, exp e) {
  // FIX:
  if (toplevel)
    unimp("can't box top-level float");
  // ({ Float x;
  //    float *y = (float *)(&x);
  //    *y = e;
  //    x; })
  qvar x = temp_var();
  qvar y = temp_var();
  exp init_y = cast_exp(nullableptr_typ(float_t,empty_tqual()),
			address_exp(var_exp(x,DL),DL),DL);
  stmt s = seq_stmt(assign_stmt(deref_exp(var_exp(y,DL),DL),e,DL),
		    exp_stmt(var_exp(x,DL),DL),DL);
  s = declare_stmt(y,nullableptr_typ(float_t,empty_tqual()),&Opt(init_y),s,DL);
  return stmt_exp(declare_stmt(x,Float_typ,null,s,DL),DL);
}

// Float -> float
static exp unbox_float_conv(bool toplevel, exp e) {
  // FIX:
  if (toplevel)
    unimp("can't unbox top-level Float");
  // ({ float x;
  //    Float *y = (float *)(&x);
  //    *y = e;
  //    x; })
  qvar x = temp_var();
  qvar y = temp_var();
  exp init_y = cast_exp(nullableptr_typ(Float_typ,empty_tqual()),
			address_exp(var_exp(x,DL),DL),DL);
  stmt s = seq_stmt(assign_stmt(deref_exp(var_exp(y,DL),DL),e,DL),
		    exp_stmt(var_exp(x,DL),DL),DL);
  s=declare_stmt(y,nullableptr_typ(Float_typ,empty_tqual()),&Opt(init_y),s,DL);
  return stmt_exp(declare_stmt(x,float_t,null,s,DL),DL);
}

// double -> Double
static exp box_double_conv(bool toplevel, exp e) {
  if (toplevel) {
    // struct _boxed_double_struct x = { e };
    // &x
    qvar x = temp_var();
    exp init = unresolvedmem_exp(null,&cons(&$(null,e),null),DL);
    vardecl vd = static_vardecl(x,strct("_boxed_double_struct"), &Opt(init));
    temp_topdecls = &cons(new_decl(Var_d(vd),DL),temp_topdecls);
    return address_exp(var_exp(x,DL),DL);
  } else {
    // ({ Double x = (Double)malloc(sizeof(struct _boxed_double_struct));
    //    x->v = e; x; })
    qvar x = temp_var();
    exp init = cast_exp(Double_typ,
			malloc_atomic(sizeof_exp(strct("_boxed_double_struct"),
						 DL)),DL);
    stmt s = seq_stmt(assign_stmt(structarrow_exp(var_exp(x,DL),"v",DL),e,DL),
		      exp_stmt(var_exp(x,DL),DL),DL);
    return stmt_exp(declare_stmt(x,Double_typ,&Opt(init),s,DL),DL);
  }
}

// Double -> double
static exp unbox_double_conv(bool toplevel, exp e) {
  // FIX:
  if (toplevel)
    unimp("can't unbox top-level Double");
  // ((Double)e)->v
  return structarrow_exp(cast_exp(Double_typ,e,DL),"v",DL);
}

// throw an exception -- this is turned into a function call
static exp newthrow_exp(exp e) {
  return fncall_exp(var_exp(&$(null,(string)"_throw"),DL),&cons(e,null),DL);
}

// t* -> t@
static exp null_check_conv(bool toplevel, typ t, exp e) {
  // FIX:?
  if (toplevel)
    unimp("can't do null-check conversion at top-level");
  // ({ t* x = e; if (x == 0) throw(Null); x })
  qvar x = temp_var();
  stmt s = ifthenelse_stmt(eq_exp(var_exp(x,DL),signed_int_exp(0,DL),DL),
			   exp_stmt(newthrow_exp(null_pointer_exn_exp(DL)),DL),
			   skip_stmt(DL),DL);
  s = seq_stmt(s,exp_stmt(var_exp(x,DL),DL),DL);
  return stmt_exp(declare_stmt(x,t,&Opt(cast_exp(t,e,DL)),s,DL),DL);
}

// t[sz] -> t[?]
static exp tag_fixedarray_conv(bool toplevel,typ t, exp sz, exp e) {
  qvar a = temp_var();
  qvar b = temp_var();
  int szvalue = Evexp::eval_const_uint_exp(sz);
  typ strt_typ;
  typ elt_typ;
  switch (compress(t)) {
  //  case ArrayType(elt,tq,FixedArray(_)):
  //    // FIX:  what about tqual ??
  //    elt_typ = elt;
  //    let n = add_tagged_array_type(elt,empty_tqual());
  //    strt_typ = strct(n);
  //    break;
  case PointerType(elt,_,_,_):
    // FIX:  what about tqual ??
    elt_typ = elt;
    _ n = add_tagged_array_type(elt,empty_tqual());
    strt_typ = strct(n);
    break;
  default:
    return toc_impos("tag_fixedarray_conv: not a fixed array");
  }
  typ pstrt_typ = nullableptr_typ(strt_typ,empty_tqual());
  if (toplevel) {
    // t a[sz] = e;
    // struct tagged_array b = {sz, a};
    // &b;
    typ     a_typ   = ArrayType(elt_typ,empty_tqual(),FixedArray(sz));
    vardecl vda     = static_vardecl(a,a_typ,&Opt(new_exp(e->r,DL)));
    exp     urm_exp = unresolvedmem_exp(null,&cons(&$(null,sz),
						   &cons(&$(null,var_exp(a,DL)),
							 null)),DL);
    vardecl vdb     = static_vardecl(b,strt_typ,&Opt(urm_exp));
    temp_topdecls = &cons(&Decl(Var_d(vdb),DL),
                          &cons(&Decl(Var_d(vda),DL),
			        temp_topdecls));
    return address_exp(var_exp(b,DL),DL);
  } else {
    // ({ t a = e;
    //    t b = (t)malloc(sizeof(struct tagged_arrayt));
    //    b->sz = sz;
    //    b->contents = a;
    //    b; })
    stmt s = exp_stmt(var_exp(b,DL),DL);
    s = seq_stmt(assign_stmt(structarrow_exp(var_exp(b,DL),"contents",DL),
			     var_exp(a,DL),DL),s,DL);
    s = seq_stmt(assign_stmt(structarrow_exp(var_exp(b,DL),"sz",DL),
			     uint_exp(szvalue,DL),DL),s,DL);
    exp binit = cast_exp(pstrt_typ,malloc_ptr(sizeof_exp(strt_typ,DL)),DL);
    s = declare_stmt(b,pstrt_typ,&Opt(binit),s,DL);
    s = declare_stmt(a,t,&Opt(cast_exp(t,e,DL)),s,DL);
    return stmt_exp(s,DL);
  }
}

// t[?] -> t[sz]
static exp fix_taggedarray_conv(bool toplevel,typ t1, exp sz, exp e) {
  // FIX: ?
  if (toplevel)
    unimp("can't determine size of [?] array at compile-time");
  // ({ t1 x = e;
  //    if (sz > x->sz) throw(Null); x->contents; })
  qvar x = temp_var();
  int szvalue = Evexp::eval_const_uint_exp(sz);
  stmt s = exp_stmt(structarrow_exp(var_exp(x,DL),"contents",DL),DL);
  s = seq_stmt(ifthenelse_stmt(gt_exp(signed_int_exp(szvalue,DL),
				      structarrow_exp(var_exp(x,DL),"sz",DL),
				      DL),
			       exp_stmt(newthrow_exp(null_pointer_exn_exp(DL))
					,DL),
			       skip_stmt(DL),DL),s,DL);
  s = declare_stmt(x,t1,&Opt(e),s,DL);
  return stmt_exp(s,DL);
}

// convert e (which has source type t1) to have source type t2
// assumes e has already been compiled.
static exp convert_exp(bool toplevel, typ t1, typ t2, exp e) {
  for(list<conv> cs = conversion(t1,t2); cs != null; cs = cs->tl) {
    switch (cs->hd) {
    case BoxLongLong:          e = box_longlong_conv(toplevel,e);         break;
    case UnboxLongLong:        e = unbox_longlong_conv(toplevel,e);       break;
    case BoxFloat:             e = box_float_conv(toplevel,e);            break;
    case UnboxFloat:           e = unbox_float_conv(toplevel,e);          break;
    case BoxDouble:            e = box_double_conv(toplevel,e);           break;
    case UnboxDouble:          e = unbox_double_conv(toplevel,e);         break;
    case NullCheck(t):         e = null_check_conv(toplevel,t,e);         break;
    case TagFixedArray(t,sz):  e = tag_fixedarray_conv(toplevel,t,sz,e);  break;
    case FixTaggedArray(t,sz): e = fix_taggedarray_conv(toplevel,t,sz,e); break;
    }
  }
  return e;
}

///////////////////////////////////////////////////////////////
//              Translation Environments                     //
///////////////////////////////////////////////////////////////
// When break_lab is null, translate break to break.  Otherwise,
// translate break to goto of the given label.  Similarly for
// continue.  This is used in the translation of switches and
// exception handlers to get the right control-flow.
//
// The varmap is used to map source identifiers to certain expressions.
// This is primarily used in the pattern match compilation.
//
// to_pop_XXX where XXX is break, continue, or return, is the number
//   of exception handlers to pop before XXX.
// All the to_pop values are incremented on entry to try.
// to_pop_return is set to zero at the beginning of functions.
// to_pop_break is set to zero at do, for, while, and switch.
// to_pop_continue is set to zero at do, for, and while.
// to_pop_fallthru is set to zero at non-last case.
// Note, a continue in a switch pops out to the nearest loop, it has
// nothing to do with switch.  Fallthru is like a continue for a switch.
//
// Translation of fallthru(e1,...,en) is
// varmap'(qv1) = trans(e1); ... varmap'(qvn) = trans(en);
// goto fallthru_info->v[0]
// where the ith element of fallthru_info->v[1] is qvi
// and varmap' is fallthru_info->v[2]
// (We also have to pop handlers as explained above.)
//
// Note that the varmap has to take into account the shadow number
// from bindings -- hence the domain of the map is qvar*int.
static struct Env {
  Opt_t<var> break_lab;
  Opt_t<var> continue_lab;
  Opt_t<$(var,list<qvar>,Dict::Dict<qvar,exp>)@> fallthru_info;
  Dict::Dict<qvar,exp> varmap;
  int to_pop_break;
  int to_pop_continue;
  int to_pop_return;
  int to_pop_fallthru;
  bool toplevel;
};
typedef struct Env @env;

// the empty environment
static env empty_env() {
  return &Env{.break_lab       = null,
              .continue_lab    = null,
	      .fallthru_info   = null,
              .varmap          = Dict::empty(qvar_cmp),
              .to_pop_break    = 0,
              .to_pop_continue = 0,
              .to_pop_return   = 0,
	      .to_pop_fallthru = 0,
	      .toplevel        = true};
}
static env copy_env(env e) {
  return &Env{.break_lab       = e->break_lab,
              .continue_lab    = e->continue_lab,
	      .fallthru_info   = e->fallthru_info,
	      .varmap          = e->varmap,
	      .to_pop_break    = e->to_pop_break,
              .to_pop_continue = e->to_pop_continue,
              .to_pop_return   = e->to_pop_return,
	      .to_pop_fallthru = e->to_pop_fallthru,
	      .toplevel        = e->toplevel};
}

static env clear_toplevel(env e) {
  env ans = copy_env(e);
  ans->toplevel = false;
  return ans;
}

// add x->y to variable map in environment
// The type allows y to be a general exp, but in practice it is always a var_exp
static env add_varmap(env e, qvar x, exp y) {
  env ans = copy_env(e);
  ans->varmap = Dict::insert(ans->varmap, x, y);
  return ans;
}

// env for loop body: break and continue labels are set to null,
// exception handler pop counters for break and continue are zeroed
static env loop_env(env e) {
  env ans = copy_env(e);
  ans->break_lab       = null;
  ans->continue_lab    = null;
  ans->to_pop_break    = 0;
  ans->to_pop_continue = 0;
  return ans;
}

// env for try: increment exception handler pop counters
static env try_env(env e) {
  env ans = copy_env(e);
  ans->to_pop_break++;
  ans->to_pop_continue++;
  ans->to_pop_return++;
  ans->to_pop_fallthru++;
  return ans;
}

// env for a switch clause: give new label for break, and zero its pop counter
static env non_last_switchclause_env(env e, var break_l, var fallthru_l,
				     list<qvar> fallthru_binders,
				     env next_case_env) {
  env ans = copy_env(e);
  ans->break_lab       = &Opt(break_l);
  ans->fallthru_info   = &Opt(&$(fallthru_l,
				 fallthru_binders,
				 next_case_env->varmap));
  ans->to_pop_break    = 0;
  ans->to_pop_fallthru = 0;
  return ans;
}

static env last_switchclause_env(env e, var break_l) {
  env ans = copy_env(e);
  ans->break_lab     = &Opt(break_l);
  ans->fallthru_info = null; // not allowed in last case
  ans->to_pop_break  = 0;
  return ans;
}

// must have no pattern vars and type is int, char, or enum of a type
// with no value constructors. (If it weren't for allowing fallthru
// anywhere, we wouldn't need the next_l.)
static env switch_as_switch_env(env e, var next_l) {
  env ans = copy_env(e);
  ans->break_lab       = null;
  ans->fallthru_info   = &Opt(&$(next_l,null,Dict::empty(qvar_cmp)));
  ans->to_pop_break    = 0;
  ans->to_pop_fallthru = 0;
  return ans;
}

// printf_to_c(p,aopt,args,typs)
// Translate printf functions to C;
//   p is printf, fprintf, or xprintf
//   aopt is &Opt(e) if p is fprintf and e is its first arg
//   args are the remaining args, already translated
//   typs are the types of the translated args
//
// Most of the work has been done in the typechecker, which inserted
// casts on all the args.  The only remaining thing to do is handle
// %s.  The typechecker casts the corresponding arg to char[?].
// The C printf expects a char *.  So, we extract that from the char[?].
// Furthermore, we have to make sure that the C printf does not
// look past the end of the char[?].  So, we transform %s into %.*s,
// and, if the char[?] arg is x, we turn it into x,size(x).
//
// A final twist: the argument might not be a variable, so we have to
// introduce temporaries.  E.g.,
//   printf("%d%s%d\n",g(x),f(e),y)
// becomes
//   ({ int t1 = g(x);
//      string t2 = f(e);
//      int t3 = y;
//      printf("%d%.*s%d\n",t1,t2->sz,t2->contents,t3);
//   })
static exp printf_to_c(primop p,Opt_t<exp> aopt,list<exp> args,list<typ> typs) {
  // All errors are Impossible because they should have been caught by
  // the typechecker
  if (args == null)
    return toc_impos("expecting a literal format string");

  string fmt_str;
  // get out the literal format string
  switch (args->hd->r) {
  case Const_e(String_c(s)): fmt_str = s; break;
  default: return toc_impos("expecting a literal format string");
  }
  // Check for the usual case: no %s.
  int len = fmt_str.size;
  int i   = 0;
  for (i=0; i<len; i++) {
    if (fmt_str[i] == '%') {
      i++;
      if (i<len && fmt_str[i] == 's') break;
    }
  }
  // If no %s, don't bother to process the args
  if (i == len) {
    if (aopt != null) args = &cons(aopt->v,args);
    return primop_exp(p,args,DL);
  }

  // Otherwise we have %s and must process the args

  args = args->tl; // strip off fmt string
  typs = typs->tl; // and its type

  list<Char>             rev_fmt    = null; // reversed fmt to return
  list<exp>              rev_result = null; // reversed args to return, minus fmt
  list<$(qvar,typ,exp)@> rev_temps  = null; // reversed temps to return

  for (i=0; i<len; i++) {
    char c = fmt_str[i];
    rev_fmt = &cons((Char)c,rev_fmt);
    if (c != '%') continue;
    _ x = Formatstr::parse_conversionspecification(fmt_str,i+1);
    if (x == null) toc_impos("bad format string");
    let &$(flags,width,precision,lenmod,c2,j) = x->v;
    i = j-1; // Subtract 1 because for-loop ends with i++
    if (c2 != 's') {
      // No change in this portion of format string; just copy conversion spec
      rev_fmt =
        List::revappend(List::flatten(&cons(flags,
                                            &cons(width,
                                                  &cons(precision,
                                                        &cons(lenmod,null))))),
                        rev_fmt);
      rev_fmt = &cons((Char)c2,rev_fmt);
      // * width or precision consumes an argument
      switch (width) {
      case &cons(x,null) && x=='*':
        _ temp = temp_var();
        rev_temps  = &cons(&$(temp,typs->hd,args->hd),rev_temps);
        rev_result = &cons(var_exp(temp,DL),rev_result);
        args = args->tl;
        typs = typs->tl;
        break;
      default: break;
      }
      switch (precision) {
      case &cons(x,&cons(y,null)) && x=='.' && y=='*':
        _ temp = temp_var();
        rev_temps  = &cons(&$(temp,typs->hd,args->hd),rev_temps);
        rev_result = &cons(var_exp(temp,DL),rev_result);
        args = args->tl;
        typs = typs->tl;
        break;
      default: break;
      }
      if (c2 != '%') { // all but %% consume an arg and typ
        if (args == null || typs == null)
            toc_impos(xprintf("missing arg to %s", Absynpp::prim2string(p)));
        _ temp = temp_var();
        rev_temps  = &cons(&$(temp,typs->hd,args->hd),rev_temps);
        rev_result = &cons(var_exp(temp,DL),rev_result);
        args = args->tl;
        typs = typs->tl;
      }
    } else {
      // %s case.  Note, tcexp currently prohibits flags, width, precision,
      // and length modifiers for %s, so we don't handle them here;
      // we just insert size into format and args.
      rev_fmt = &cons((Char)'.',rev_fmt);
      rev_fmt = &cons((Char)'*',rev_fmt);
      rev_fmt = &cons((Char)'s',rev_fmt);
      _ temp = temp_var();
      rev_temps = &cons(&$(temp,typs->hd,args->hd),rev_temps);
      _ size_exp    = structarrow_exp(var_exp(temp,DL),"sz",DL);
      _ cstring_exp = structarrow_exp(var_exp(temp,DL),"contents",DL);
      rev_result = &cons(size_exp,rev_result);
      rev_result = &cons(cstring_exp,rev_result);
      args = args->tl;
      typs = typs->tl;
    }
  }
  _ es = &cons(string_exp(String::implode(List::rev(rev_fmt)),DL),
		 List::rev(rev_result));
  if (aopt != null) es = &cons(aopt->v,es);
  _ e = primop_exp(p,es,DL);
  _ s = exp_stmt(e,DL);
  for (; rev_temps != null; rev_temps = rev_temps->tl) {
    s = declare_stmt(rev_temps->hd[0],
                     rev_temps->hd[1],
                     &Opt(rev_temps->hd[2]),
                     s,
                     DL);
  }
  return stmt_exp(s,DL);
}

///////////////////////////////////////////////////////////////
//              Translation of Expressions                   //
///////////////////////////////////////////////////////////////
// Should really break this into smaller functions and factor
// out common code (e.g., Enum and Xenum are the same.)
static typ get_typ(exp e) {
  if (e->topt == null) toc_impos("Missing type in primop ");
  return typ_to_c(e->topt->v);
}
static $(tqual, typ)@ tup_to_c(exp e) {
  return &$(empty_tqual(), typ_to_c(e->topt->v));
}
extern void exp_to_c(env nv, exp e);
static $(list<designator>,exp)@ add_designator(env nv, exp e) {
  exp_to_c(nv,e);
  return &$(null,e);
}

static exp make_struct(qvar x, typ struct_typ, stmt s,
		       bool pointer, bool is_atomic) {
  Opt_t<exp> eo;
  typ        t;
  if(pointer) {
    t  = nullableptr_typ(struct_typ, empty_tqual());
    _ se = sizeof_exp(struct_typ,DL);
    eo = &Opt(cast_exp(t, is_atomic ? malloc_atomic(se) : malloc_ptr(se), DL));
  } else {
    t  = struct_typ;
    eo = null;
  }
  return stmt_exp(declare_stmt(x,t,eo,s,DL),DL);
}

// Would be nice to share moare code with init_struct
// but the designators get in the way.
static exp init_tuple(env nv, bool pointer, list<exp> es) {
  // $(e1,...,en)  -> ({ t x;   x.f1 = e1; ... x.fn = en; x})
  // &$(e1,...,en) -> ({ t * x; x->f1 = e1; ... x->fn = en; x})
  _ tqs = List::map(tup_to_c,es);
  _ n   = add_tuple_type(tqs);

  _ x    = temp_var();
  _ xexp = var_exp(x,DL);
  _ s    = exp_stmt(xexp,DL);

  _ lval_f = pointer ? structarrow_exp : structmember_exp;

  bool is_atomic = true;
  es = List::rev(es);
  for (int i = length(es); es != null; es = es->tl, --i) {
    exp_to_c(nv,es->hd);
    is_atomic = is_atomic && atomic_typ(es->hd->topt->v);
    s = seq_stmt(exp_stmt(assign_exp(lval_f(xexp,xprintf("f%d",i),DL),
				     es->hd, DL), DL),
		 s, DL);
  }
  return make_struct(x,strct(n),s,pointer,is_atomic);
}

static exp init_struct(env nv,bool pointer,list<$(list<designator>,exp)@> dles, 
		       typedef_name_t tdn) {
  _ x    = temp_var();
  _ xexp = var_exp(x,DL);
  _ s    = exp_stmt(xexp,DL);

  _ lval_f = pointer ? structarrow_exp : structmember_exp;

  bool is_atomic = true;

  for(_ es = List::rev(dles); es != null; es = es->tl) {
    let &$(ds,e) = es->hd;
    is_atomic = is_atomic && atomic_typ(e->topt->v);
    if(ds == null)
      toc_impos("empty designator list");
    if(ds->tl != null) {
      // untested
      _ y    = temp_var();
      _ yexp = var_exp(y,DL);
      for(; ds != null; ds = ds->tl)
	switch (ds->hd) {
	case FieldName(f):
	  s = seq_stmt(exp_stmt(assign_exp(lval_f(xexp,f,DL), yexp, DL), DL),
		       s, DL);
	  break;
	default: throw toc_impos("array designator in struct");
	}
      exp_to_c(nv,e);
      s = seq_stmt(exp_stmt(assign_exp(yexp, e, DL), DL), s, DL);
    } else
      switch (ds->hd) {
      case FieldName(f):
	exp_to_c(nv,e);
	s = seq_stmt(exp_stmt(assign_exp(lval_f(xexp,f,DL), e, DL), DL),
		     s, DL);
	break;
      default: throw toc_impos("array designator in struct");
      }
  }
  return make_struct(x, strctq(collapse_qvar(tdn)), s, pointer, is_atomic);
}

extern void lvalue_assign_stmt(stmt s,list<field_name> fs,
			       Opt_t<primop> popt,exp e2);
// e1 is the result of translating an lvalue.  fs is the path of struct
// fields that we're assigning to on e1 (if any).  The translation
//  may have inserted null checks, etc., but buried within e is an lvalue.
// These two functions find that lvalue and insert an assignment to it.
// We assume that variables of e2 will not be captured by any
// declarations in e1 (they should all be temps).
static void lvalue_assign(exp e1,list<field_name> fs,Opt_t<primop> popt,exp e2) {
  switch (e1->r) {
  case StmtExp_e(s): lvalue_assign_stmt(s,fs,popt,e2); break;
  case Cast_e(t,e):  lvalue_assign(e,fs,popt,e2);      break;
  case StructMember_e(e,f):
    // Hack: strip off the struct member -- the base case adds it back in.
    e1->r = e->r;
    lvalue_assign(e1,&cons(f,fs),popt,e2);
    break;
  default:
    // Sanity check: the translation of lvalues may change,
    // so we may need to adjust how we find the inner lvalue.
    if (!is_lvalue(e1))
      toc_impos(xprintf("lvalue_assign: could not find lvalue in `%s'",
			exp2string(e1)));
    // make a copy so we don't create a loop
    exp e1_copy = copy_exp(e1);
    // add the path back on to the expression
    for (; fs != null; fs = fs->tl)
      e1_copy = structmember_exp(e1_copy,fs->hd,e1_copy->loc);
    e1->r = assignop_exp(e1_copy,popt,e2,DL)->r;
    break;
  }
}
static void lvalue_assign_stmt(stmt s,list<field_name> fs,
			       Opt_t<primop> popt,exp e2) {
  switch (s->r) {
  case Exp_s(e1):    lvalue_assign(e1,fs,popt,e2);      break;
    // we assume free vars of e2 are not captured by d
  case Decl_s(d,s2): lvalue_assign_stmt(s2,fs,popt,e2); break;
  case Seq_s(_,s2):  lvalue_assign_stmt(s2,fs,popt,e2); break;
  default: toc_impos(xprintf("lvalue_assign_stmt: %s",stmt2string(s))); break;
  }
}

extern void stmt_to_c(env nv, stmt s);

static void exp_to_c(env nv, exp e) {
  _ r = e->r;
  if(e->topt == null) {
    toc_impos(xprintf("exp_to_c: no type for %s",exp2string(e)));
    return;
  }
  typ old_typ = e->topt->v;
  switch (r) {
  case Const_e(Null_c):
    // null -> 0  -- this is okay according to C's rules!
    e->r = signed_int_exp(0,DL)->r; break;
  case Const_e(_): break;
  case Var_e(qv,b): 
    try e->r = Dict::lookup(nv->varmap,qv)->r;
    catch {
    case Dict::Absent:
       toc_impos(xprintf("Can't find %s in exp_to_c, Var\n", qvar2string(qv)));
       return;
    }
    break;
  case UnknownId_e(qv): toc_impos("unknownid"); break;
  case Primop_e(p,es):
    // Save C types of args, needed for printf
    _ typs = List::map(get_typ,es);
    // Translate args
    List::iter_c(exp_to_c,nv,es);
    // FIX:  look at these carefully and make sure this is okay
    switch (p) {
    case Size:
      exp arg = es->hd;
      switch (arg->topt->v) {
      case ArrayType(_,_,FixedArray(e2)): e->r = e2->r;  break;
      default: e->r = structarrow_exp(arg, "sz", DL)->r; break;
      }
      break;
    case Printf:  e->r = printf_to_c(p,null,es,typs)->r; break;
    case Xprintf: e->r = printf_to_c(p,null,es,typs)->r; break;
    case Fprintf:
      if (es == null) toc_impos("fprintf without arguments");
      e->r = printf_to_c(p,&Opt(es->hd),es->tl,typs->tl)->r;
      break;
    case Sscanf:
      // INSECURE -- but useful for debugging.
      // The problem is that we can't guarantee that the input string
      // is null terminated -- sscanf could start reading past the end
      // of the string.  This could lead to a security breach.
      // Any sscanf expression should be rejected by the typechecker;
      // sometimes we disable this to help debug fscanf and scanf.
      if (es == null) toc_impos("sscanf without arguments");
      es->hd->r = structarrow_exp(new_exp(es->hd->r,es->hd->loc),"contents",DL)->r;
      break;
    default: break; //skip
    }
    break;
  case Increment_e(e2,_):
    // FIX:  works for boxed types?
    exp_to_c(nv,e2);
    break;
  case AssignOp_e(e1,popt,e2):
    // FIX:  works for boxed types?
    exp_to_c(nv,e1); exp_to_c(nv,e2);
    // The typechecker guarantees that e1 starts out as an lvalue, but
    // the translation might have to insert casts, null checks,
    // declarations of temps, bound checks, etc.  If so we look into e1,
    // find the lvalue, and put the assignment there.
    if (!is_lvalue(e1)) {
      lvalue_assign(e1,null,popt,e2);
      e->r = e1->r;
    }
    break;
  case Conditional_e(e1,e2,e3):
    exp_to_c(nv,e1);
    exp_to_c(nv,e2);
    exp_to_c(nv,e3);
    break;
  case SeqExp_e(e1,e2):
    exp_to_c(nv,e1);
    exp_to_c(nv,e2);
    break;
  case UnknownCall_e(e1,es):
    exp_to_c(nv,e1);
    List::iter_c(exp_to_c,nv,es);
    break;
  case FnCall_e(e1,es):
    exp_to_c(nv,e1);
    List::iter_c(exp_to_c,nv,es);
    break;
  case Throw_e(e1):
    // throw e -> (t)(throw(e)), the latter being a function call to throw
    exp_to_c(nv,e1);
    e->r = array_to_ptr_cast(typ_to_c(old_typ),newthrow_exp(e1),DL)->r;
    break;
  case NoInstantiate_e(e1): exp_to_c(nv,e1); break;
  case Instantiate_e(e1,opt_type):
    exp_to_c(nv,e1);
    typ t_inst = typ_to_c(e->topt->v);
    e->r = array_to_ptr_cast(t_inst,e1,DL)->r;
    break;
  case Cast_e(*t,*e1):
    typ old_t2  = (*e1)->topt->v;
    typ new_typ = *t;
    *t = typ_to_c(new_typ);
    exp_to_c(nv, *e1);
    *e1 = convert_exp(nv->toplevel, old_t2, new_typ, *e1);
    break;
  case Address_e(e1):
    // When e1 is a struct or a tuple, this is really a "new".
    switch (e1->r) {
    case Struct_e(tdn,_,es,_):
      if (nv->toplevel)
	unimp(xprintf("%s: & on non-identifiers at the top-level",
                      Position::string_of_segment(e1->loc)));
      e->r = init_struct(nv, true, es, tdn)->r;
      break;
    case Tuple_e(es):
      if (nv->toplevel)
	unimp(xprintf("%s: & on non-identifiers at the top-level",
                      Position::string_of_segment(e1->loc)));
      e->r = init_tuple(nv, true, es)->r;
      break;
    default: // it's actually an address-of.
      exp_to_c(nv,e1);
      break;
    }
    break;
  case Sizeof_e(t): e->r = Sizeof_e(typ_to_c_array(t)); break;
  case Deref_e(e1):
    exp_to_c(nv, e1);
    switch (compress(e1->topt->v)) {
    case PointerType(t2,rgn,cr,tq):
      bool nullable = is_nullable(e1->topt->v);
      if (nullable) {
	// ({t x=e1; if (x == null) throw(NullPointer); *x;})
	qvar x  = temp_var();
	typ  tx = typ_to_c(e1->topt->v);
	exp  e2 = eq_exp(var_exp(x,DL),signed_int_exp(0,DL),DL);
	exp  e3 = newthrow_exp(null_pointer_exn_exp(DL));
	stmt s1 = ifthenelse_stmt(e2,exp_stmt(e3,DL),skip_stmt(DL),DL);
	stmt s2 = exp_stmt(deref_exp(var_exp(x,DL),DL),DL);
	stmt s3 = seq_stmt(s1,s2,DL);
	e->r = stmt_exp(declare_stmt(x,tx,&Opt(e1),s3,DL),DL)->r;
      }
      break;
    default: toc_impos("exp_to_c: Deref: non-pointer"); break;
    }
    break;
  case StructMember_e(e1,f):
    exp_to_c(nv, e1);
    e->r = array_to_ptr_cast(typ_to_c(e->topt->v),new_exp(e->r,DL),DL)->r;
    break;
  case StructArrow_e(e1,f):
    exp_to_c(nv, e1);
    if (is_nullable(e1->topt->v)) {
      // {(t x=e1; if (x == null) throw(NullPointer); x->f;)}
      qvar x  = temp_var();
      typ  tx = typ_to_c(e1->topt->v);
      exp  e2 = eq_exp(var_exp(x,DL),signed_int_exp(0,DL),DL);
      exp  e3 = newthrow_exp(null_pointer_exn_exp(DL));
      stmt s1 = ifthenelse_stmt(e2,exp_stmt(e3,DL),skip_stmt(DL),DL);
      stmt s2 = exp_stmt(structarrow_exp(var_exp(x,DL),f,DL),DL);
      stmt s3 = seq_stmt(s1,s2,DL);
      e->r = stmt_exp(declare_stmt(x,tx,&Opt(e1),s3,DL),DL)->r;
    } else {
      e->r = array_to_ptr_cast(typ_to_c(e->topt->v),new_exp(e->r,DL),DL)->r;
    }
    break;
  case Subscript_e(e1,e2):
    _ e1_typ = compress(e1->topt->v);
    exp_to_c(nv, e1);
    exp_to_c(nv, e2);
    // cast e1 to have the right type so that we can do the projection
    // note:  casts to array types t[] or t[3] should be casts to pointer
    // types *t
    e1->r = array_to_ptr(typ_to_c(e1_typ),new_exp(e1->r,DL),DL)->r;
    // e1 could be a tuple, pointer to tuple, or an array of various sorts
    switch (e1_typ) {
    case TupleType(ts):
      // e1->fi  where i = e2+1
      unsigned int i = Evexp::eval_const_uint_exp(e2)+1;
      e->r = structmember_exp(e1,xprintf("f%d",i),DL)->r;
      break;
    case PointerType(t,rgn,bcr,tq):
      // The type checker ensures that this must be a pointer to a tuple
      string fname = xprintf("f%d",Evexp::eval_const_uint_exp(e2)+1);
      bool nullable = is_nullable(e1->topt->v);
      if (nullable) {
	// ({t x=e1; (x == null) ? throw(NullPointer) : x->fieldname})
	qvar x   = temp_var();
	typ  tx  = typ_to_c(e1->topt->v);
	exp  e2a = eq_exp(var_exp(x,DL),signed_int_exp(0,DL),DL);
	exp  e3  = newthrow_exp(null_pointer_exn_exp(DL));
	exp  e4  = structarrow_exp(var_exp(x,DL),fname,DL);
	stmt s1  = ifthenelse_stmt(e2a,exp_stmt(e3,DL),skip_stmt(DL),DL);
	stmt s2  = seq_stmt(s1,exp_stmt(e4,DL),DL);
	e->r = stmt_exp(declare_stmt(x,tx,&Opt(e1),s2,DL),DL)->r;
      } else
	// e1->fi where i = e2+1
	e->r = structarrow_exp(e1,fname,DL)->r;
      break;
    case ArrayType(ta,q,ak):
      switch (ak) {
      case UntaggedArray: break; // skip -- really impossible!
      case TaggedArray:
	// ({tagarray x=e1; uint i=e2; t *a=(t*)(x->contents);
	//  if (i >= x->sz) throw(ArrayIndex);  a[i]})
	qvar x = temp_var();
	qvar i = temp_var();
	qvar a = temp_var();
	_ ta1 = typ_to_c_array(ta);
	_ n   = add_tagged_array_type(ta1,q);
	typ tx  = nullableptr_typ(strct(n),empty_tqual());
	typ ta2 = nullableptr_typ(ta1,q);
	exp e5  = structarrow_exp(var_exp(x,DL),"sz",DL);
	exp e3  = prim2_exp(Gte, var_exp(i,DL), e5, DL);
	exp a_init = cast_exp(ta2,structarrow_exp(var_exp(x,DL),
						  "contents",DL),DL);
	// FIX:  should throw array out of bounds exception
	exp  e4 = newthrow_exp(null_pointer_exn_exp(DL));
	stmt s5 = exp_stmt(e4,DL);
	stmt s4 = ifthenelse_stmt(e3,s5,skip_stmt(DL),DL);
	stmt s6 = exp_stmt(subscript_exp(var_exp(a,DL),var_exp(i,DL),DL),DL);
	stmt s3 = seq_stmt(s4,s6,DL);
	stmt s2 = declare_stmt(a,ta2,&Opt(a_init),s3,DL);
	stmt s1 = declare_stmt(i,uint_t,&Opt(e2),s2,DL);
	e->r = stmt_exp(declare_stmt(x,tx,&Opt(e1),s1,DL),DL)->r;
        break;
      case FixedArray(esz):
	// ({t *a=e1; uint i=e2; if (i >= esz) throw(ArrayIndex); a[i]})
	unsigned int sz = Evexp::eval_const_uint_exp(esz);
	qvar i = temp_var();
	qvar a = temp_var();
	_ ta1 = typ_to_c(ta);
	typ ta2 = nullableptr_typ(ta1,q);
	exp e3 = prim2_exp(Gte, var_exp(i,DL), uint_exp(sz,DL), DL);
	exp a_init = cast_exp(ta2,structarrow_exp(e3,"contents",DL),DL);
	// FIX:  should throw array out of bounds exception
	exp e4  = newthrow_exp(null_pointer_exn_exp(DL));
	stmt s5 = exp_stmt(e4,DL);
	stmt s4 = ifthenelse_stmt(e3,s5,skip_stmt(DL),DL);
	stmt s6 = exp_stmt(subscript_exp(var_exp(a,DL),var_exp(i,DL),DL),DL);
	stmt s3 = seq_stmt(s4,s6,DL);
	stmt s1 = declare_stmt(i,uint_t,&Opt(e2),s3,DL);
	e->r = stmt_exp(declare_stmt(a,ta2,&Opt(e1),s1,DL),DL)->r;
        break;
      }
      break;
    default:
      toc_impos("exp_to_c: Subscript on non-tuple/array/tuple ptr");
      break;
    }
    break;
  case Tuple_e(es):
    if(!nv->toplevel)
      e->r = init_tuple(nv,false,es)->r;
    else {
      // At top-level must use designators
      // $(e1,...,en) -> (struct _tuple_type_n){.f1=e1,...,.fn=en}
      _ tqs = List::map(tup_to_c,es);
      _ n = add_tuple_type(tqs);
      list<$(list<designator>,exp)@> dles = null;
      for (int i = 1; es != null; es = es->tl, i++) {
	exp_to_c(nv,es->hd);
	_ des = &cons(FieldName(xprintf("f%d",i)),null);
	dles = &cons(&$((list<designator>)des,es->hd),dles);
      }
      dles = List::imp_rev(dles);
      e->r = cast_exp(strct(n),unresolvedmem_exp(null,dles,DL),DL)->r;
    }
    break;
  case CompoundLit_e(_,_):
    // the type-checker doesn't deal with these yet...
    unimp("compoundlit");
    break;
  case Array_e(dles0):
    // FIX: May be susceptible to gcc bug!
    if (nv->toplevel) {
      // {e1,...,en}
      e->r = unresolvedmem_exp(null,dles0,DL)->r;
      for (_ dles = dles0; dles != null; dles = dles->tl) {
	let &$(_,e) = dles->hd;
	exp_to_c(nv,e);
      }
      switch (compress(old_typ)) {
      case ArrayType(et,tq,ak):
	switch (ak) {
	case TaggedArray:
	  // The front-end always turns tagged array initializers into
	  // casts of fixed array initializers.
	  toc_impos("tagged array at top-level!");
          break;
	default: break; // skip
	}
        break;
      default:
        toc_impos("non-array type in array expression at top-level");
        break;
      }
    } else {
      // ({ t *x = (t*)(malloc(sizeof(t)*length(dles0)));
      //    x[d1] = e1; ... x[dn] = en; x; })
      _ x = temp_var();
      _ s = exp_stmt(var_exp(x,DL),DL);
      int count = List::length(dles0)-1;
      for (_ dles = List::rev(dles0); dles != null; dles = dles->tl) {
	// add x[e_index] = e to sequence of assignments
	let &$(dl,e1) = dles->hd;
	// calculate the index expression -- the front end checks that
	// the designators are in ascending order...
	// FIX:  real designator lists
	exp e_index;
	if (dl == null)
	  e_index = signed_int_exp(count--,DL);
	else {
	  if (dl->tl != null) unimp("multiple designators in array");
	  _ d = dl->hd;
	  switch (d) {
	  case ArrayElement(e3):
	    exp_to_c(nv,e3);
	    e_index = e3;
            break;
	  case FieldName(_):
            e_index = unimp("field name designators in array");
            break;
	  }
	}
	exp_to_c(nv,e1);
	s = seq_stmt(assign_stmt(subscript_exp(var_exp(x,DL),e_index,DL),
				 e1,DL),s,DL);
      }
      typ old_elt_typ;
      // FIX:  if array kind is tagged?
      switch (compress(old_typ)) {
      case ArrayType(et,tq,ak):
	old_elt_typ = et; break;
      default:
	old_elt_typ=toc_impos("exp_to_c:array expression doesn't have array type");
        break;
      }
      typ elt_typ=typ_to_c(old_elt_typ);
      _ ptr_typ = nullableptr_typ(elt_typ,empty_tqual());
      _ e2 = times_exp(sizeof_exp(elt_typ,DL),
		       signed_int_exp(List::length(dles0),DL),DL);
      _ e1 = malloc_exp(old_elt_typ,e2);
      _ e0 = cast_exp(ptr_typ,e1,DL);
      e->r = stmt_exp(declare_stmt(x,ptr_typ,&Opt(e0),s,DL),DL)->r;
    }
    break;
  case Comprehension_e(vd,e1,e2):
    // Drop the "tagged_array_t" struct stuff when type is a fixed-size array
    // ({ unsigned int max = e1;
    //    unsigned int x ;
    //    t *a = (t*)malloc(sizeof(t)*max);
    //    struct tagged_array_t *b = (struct tagged_array_t *)
    //        malloc(sizeof(struct tagged_array));
    //    b->sz = max;
    //    b->contents = a;
    //    for (x = 0; x < max; x++) a[x] = e2;
    //    b; })
    qvar x1 = vd->name;
    bool is_tagged_array = false;
    switch (compress(old_typ)) {
    case ArrayType(et,tq,ak):
      if (ak == TaggedArray) is_tagged_array = true;
      break;
    default:
      toc_impos("exp_to_c: comprehension not an array type");
      break;
    }
    typ old_elt_typ = e2->topt->v;
    typ elt_typ = typ_to_c(old_elt_typ);
    typ ptr_typ = nullableptr_typ(elt_typ,empty_tqual());
    exp_to_c(nv,e1);
    env nv2 = add_varmap(nv,x1,varb_exp(x1,Local_b(vd),DL));
    exp_to_c(nv2,e2);
    qvar max = temp_var();
    qvar a = temp_var();
    exp ea = assign_exp(var_exp(x1,DL),signed_int_exp(0,DL),DL);
    exp eb = lt_exp(var_exp(x1,DL),var_exp(max,DL),DL);
    exp ec = post_inc_exp(var_exp(x1,DL),DL);
    stmt s = for_stmt(ea,eb,ec,
		      assign_stmt(subscript_exp(var_exp(a,DL),
						var_exp(x1,DL),DL),e2,DL),DL);
    list<$(qvar,typ,Opt_t<exp>)@> decls =
      &cons(&$(max,uint_t,(Opt_t<exp>)&Opt(e1)),null);
    exp ainit = cast_exp(ptr_typ,malloc_exp(old_elt_typ,
					    times_exp(sizeof_exp(elt_typ,DL),
						      var_exp(max,DL),DL)),DL);
    decls = &cons(&$(a,ptr_typ,(Opt_t<exp>)&Opt(ainit)),decls);
    decls = &cons(&$(x1,uint_t,null),decls);
    if (is_tagged_array) {
      _ b = temp_var();
      _ t = typ_to_c(old_typ);
      typ strt_typ;
      switch (compress(t)) {
      case PointerType(st,_,_,_): strt_typ = st; break;
      default: strt_typ = toc_impos("comprehension: not a pointer"); break;
      }
      _ binit = &Opt(cast_exp(t,malloc_ptr(sizeof_exp(strt_typ,DL)),DL));
      decls = &cons(&$(b,t,(Opt_t<exp>)binit),decls);
      s = seq_stmt(assign_stmt(structarrow_exp(var_exp(b,DL),"sz",DL),
			       var_exp(max,DL),DL),s,DL);
      s = seq_stmt(assign_stmt(structarrow_exp(var_exp(b,DL),"contents",DL),
			       var_exp(a,DL),DL),s,DL);
      s = seq_stmt(s,exp_stmt(var_exp(b,DL),DL),DL);
    } else // not a tagged array -- just return a
      s = seq_stmt(s,exp_stmt(var_exp(a,DL),DL),DL);
    for (_ ds = decls; ds != null; ds = ds->tl) {
      _ d = ds->hd;
      s = declare_stmt(d[0],d[1],d[2],s,DL);
    }
    e->r = stmt_exp(s,DL)->r;
    break;
  case Struct_e(tdn,ots,dles,_):
    // Due to a GCC bug w.r.t. to nested designators, we expand this out
    // to ({ t temp; t.f1 = e1, ..., t.fn = en; t}).
    if(!nv->toplevel)
      e->r = init_struct(nv,false,dles,tdn)->r;
    else {
      // At top-level must use deisignators
      _ n = collapse_qvar(tdn);
      for (_ es = dles; es != null; es = es->tl)
	exp_to_c(nv,es->hd[1]);
      e->r = cast_exp(strctq(n), unresolvedmem_exp(null,dles,DL),DL)->r;
    }
    break;

  case Enum_e(_,_,es,ed,ef):
    qvar qv = ef->name;
    if (es == null) {
      // non-value-carrying constructor -- just use the constructor name
      // (see enumdecl_to_c below)
      if (!nv->toplevel)
	e->r = var_exp(collapse_qvar(qv),DL)->r;
      else {
	// FIX: we should get the tag from a centralized place and we
	// might as well use it everywhere.
	// we can't use the variable name at toplevel
	int tag_count = 0;
	_ fields = (ed->fields == null) ? null : ed->fields->v;
	while (qvar_cmp(qv,fields->hd->name) != 0) {
	  if (fields->hd->typs == null) tag_count++;
	  fields = fields->tl;
	}
	e->r = cast_exp(void_star_typ(),uint_exp(tag_count,DL),DL)->r;
      }
    } else {
      _ x = temp_var();
      _ xexp = var_exp(x,DL);
      _ strct_typ = strctq(collapse_qvar_tag(qv,"_struct"));
      _ pstrct_typ = nullableptr_typ(strct_typ,empty_tqual());
      // we have to do this differently for the toplevel
      if (nv->toplevel) {
	// struct qv_tag x = {->tag = i, ->f1 = e1, ... ,->fn = en};
	// (t)(&x)
	// FIX: we should get the tag from a centralized place and we
	// might as well use it everywhere.
	int tag_count = 0;
	_   fields    = (ed->fields == null) ? null : ed->fields->v;
	while (qvar_cmp(qv,fields->hd->name) != 0) {
	  if (fields->hd->typs != null) tag_count++;
	  fields = fields->tl;
	}
	exp tag_exp = uint_exp(tag_count,DL);
	list<$(list<designator>,exp)@> dles = List::map_c(add_designator,nv,es);
	dles = &cons(&$(null,tag_exp),dles);
	exp init_exp = unresolvedmem_exp(null,dles,DL);
	_ vd = static_vardecl(x,strct_typ,&Opt(init_exp));
	temp_topdecls = &cons(new_decl(Var_d(vd),DL),
	                      temp_topdecls);
	e->r = cast_exp(pstrct_typ,address_exp(xexp,DL),DL)->r;
      } else {
	// value-carrying constructor
	// ({ struct qv_tag *x = (struct qv_tag*)malloc(sizeof(struct qv_tag));
	//    x->tag = i; x->f1 = e1; ...; x->fn = en; (t)x; })
	_ e2 = sizeof_exp(strct_typ,DL);
	_ atomic = true;
	_ rev_assign =
	  &cons(assign_stmt(structarrow_exp(xexp,"tag",DL),
			    var_exp(collapse_qvar_tag(qv,"_tag"),DL),DL),null);
	for (int i = 1; es != null; es = es->tl, i++) {
	  if (!atomic_typ(es->hd->topt->v)) atomic = false;
	  exp_to_c(nv,es->hd);
	  _ a = assign_stmt(structarrow_exp(xexp,xprintf("f%d",i),DL),
			      es->hd,
			      DL);
	  rev_assign = &cons(a,rev_assign);
	}
	_ e1 = cast_exp(pstrct_typ,
			  atomic ? malloc_atomic(e2) : malloc_ptr(e2),DL);
	_ final_cast = exp_stmt(cast_exp(typ_to_c(old_typ),xexp,DL),DL);
	_ s2         = seq_stmts(List::rev(&cons(final_cast,rev_assign)),DL);
	e->r = stmt_exp(declare_stmt(x,pstrct_typ,&Opt(e1),s2,DL),DL)->r;
      }
// GCC BUG: The code
//   *x = (struct qv_tag){.tag = i, .f1 = e1, ..., .fn = en}; (t)x; })
// does not seem to work properly in gcc,
// so we had to recode as above.
//
//       // value-carrying constructor
//       // ({ struct qv_tag *x = (struct qv_tag*)malloc(sizeof(struct qv_tag));
//       //    *x = (struct qv_tag){->tag = i, ->f1 = e1, ..., ->fn = en}; (t)x; })
//       let x = temp_var();
//       let xexp = var_exp(x,DL);
//       let strct_t = strct(collapse_qvar_tag(qv,"_struct")[1]);
//       let pstrct_t = nullableptr_typ(strct_t,empty_tqual());
//       let e2 = sizeof_exp(strct_t,DL);
//       let e1 = cast_exp(pstrct_t,malloc_exp(e2),DL);
//       let dles = null;
//       for (int i = 1; es != null; es = es->tl, i++) {
// 	exp_to_c(nv,es->hd);
// 	let des = &cons(FieldName(xprintf("f%d",i)),null);
// 	dles = &cons(&$(des,es->hd),dles);
//       }
//       dles = List::imp_rev(dles);
//       let d = &cons(FieldName("tag"),null);
//       exp tag_exp = var_exp(collapse_qvar_tag(qv,"_tag"),DL);
//       let dles = &cons(&$(d,tag_exp),dles);
//       let strct_exp = unresolvedmem_exp(null,dles,DL);
//       let s1 = assign_stmt(deref_exp(xexp,DL),cast_exp(strct_t,strct_exp,DL),DL);
//       let s2 = seq_stmt(s1,exp_stmt(cast_exp(typ_to_c(old_typ),xexp,DL),DL),DL);
//       e->r = stmt_exp(declare_stmt(x,pstrct_t,&Opt(e1),s2,DL),DL)->r;
    }
    break;
  case Xenum_e(_,es,xd,ef):
    qvar qv = ef->name;
    // FIX:
    _ x = temp_var();
    _ xexp = var_exp(x,DL);
    _ strct_typ = strctq(collapse_qvar_tag(qv,"_struct"));
    _ pstrct_typ = nullableptr_typ(strct_typ,empty_tqual());
    exp tag_exp = var_exp(collapse_qvar_tag(qv,"_tag"),DL);
    if (nv->toplevel) {
      // struct qv_tag x = {->tag = i, ->f1 = e1, ... , ->fn = en};
      // (t)(&x);
      list<$(list<designator>,exp)@> dles = List::map_c(add_designator,nv,es);
      dles = &cons(&$(null,tag_exp),dles);
      exp init_exp = unresolvedmem_exp(null,dles,DL);
      _ vd = static_vardecl(x,strct_typ,&Opt(init_exp));
      temp_topdecls = &cons(new_decl(Var_d(vd),DL),
			    temp_topdecls);
      e->r = cast_exp(typ_to_c(old_typ),address_exp(xexp,DL),DL)->r;
    } else {
      // ({ struct qv_tag *x = (struct qv_tag*)malloc(sizeof(struct qv_tag));
      //    *x = (struct qv_tag){->tag = i, ->f1 = e1, ..., ->fn = en}; (t)x; })
      _ atomic = true;
      _ e2 = sizeof_exp(strct_typ,DL);
      list<$(list<designator>,exp)@> dles = null;
      for (int i = 1; es != null; es = es->tl, i++) {
	if (!atomic_typ(es->hd->topt->v)) atomic = false;
	exp_to_c(nv,es->hd);
	_ des = &cons(FieldName(xprintf("f%d",i)),null);
	dles = &cons(&$((list<designator>)des,es->hd),dles);
      }
      dles = List::imp_rev(dles);
      // Note:  even though the "tag" is a pointer, it's a pointer to static
      // data -- hence, if all of the arguments are atomic, then the whole
      // structure is atomic.
      _ e1 = cast_exp(pstrct_typ,
		      atomic ? malloc_atomic(e2) : malloc_ptr(e2),DL);
      _ d = &cons(FieldName("tag"),null);
      list<$(list<designator>,exp)@> dles2 =
	&cons(&$((list<designator>)d,tag_exp),dles);
      _ strct_exp = unresolvedmem_exp(null,dles2,DL);
      _ s1 = assign_stmt(deref_exp(xexp,DL),cast_exp(strct_typ,strct_exp,DL),
			 DL);
      _ s2 = seq_stmt(s1,exp_stmt(cast_exp(typ_to_c(old_typ),xexp,DL),DL),DL);
      e->r = stmt_exp(declare_stmt(x,pstrct_typ,&Opt(e1),s2,DL),DL)->r;
    }
    break;
  case StmtExp_e(s): stmt_to_c(nv,s);  break;
  case UnresolvedMem_e(_,_): toc_impos("UnresolvedMem"); break;
  case Codegen_e(fd):        unimp("codegen");           break;
  case Fill_e(_):            unimp("fill");              break;
  }
}

// Translate a pattern generating tests which jump to the succ_lab
// upon successful match and to the fail_lab othewise.  Returns:
// * a new translation environment (mapping variables bound in the pattern
//   to temps generated)
// * a list of temps to be declared (along with their types.)
//   This list contains the decls parameter
// * The statement for actually doing the test.
//
// (The temps must be declared with a wide enough
// scope to cover the tests and any cases in a switch (hence the reason
// they're pulled out.  Also needed for translating fallthru.)
//
// xlate_pat(env,t,r,path,p,succ_lab,fail_lab)
//
//  r is the "root" variable that contains the value we're matching.
//  path is the address of this value -- used in the Address pattern.
//  p is the pattern
//  succ_lab is where to go upon successful match
//  fail_lab is where to go upon failure to match
//
// FIX: adapt the decision tree code in the type-checker so that we
// have much more efficient traversal of patterns.
// FIX: I think the Address pattern (*) code is too liberal -- lets
// you get pointers to a local variable if you do a switch on a
// local variable...
// DO NOT FIX:  though it looks like all of the goto's are bad and
// we could collapse a lot of if-then-else's and avoid some of the
// jumping around, GCC -O does this for us.  So the only reason to
// make that any better is to improve the readability of the code.
static stmt if_eq_goto_stmt(exp e1, exp e2, var succ_lab, var fail_lab) {
  return ifthenelse_stmt(eq_exp(e1,e2,DL),
			 goto_stmt(succ_lab,DL),
			 goto_stmt(fail_lab,DL), DL);
}
static $(env,list<$(qvar,typ)@>,stmt)
xlate_pat(env nv,typ t,exp r,exp path,pat p,var succ_lab,var fail_lab,
	  list<$(qvar,typ)@> decls) {
  stmt s; // the test statement
  switch (p->r) {
  case Wild_p: s = goto_stmt(succ_lab, DL); break;
  case Var_p(&Vardecl(_,x,_,_,_,_,_)):
    // in essence, x = r; but achieved through the varmap
    nv = add_varmap(nv,x,r);
    s  = goto_stmt(succ_lab,DL);
    break;
  case Reference_p(vd):
    // v = path; goto succ_lab
    _ v = temp_var();
    decls = &cons(&$(v,nullableptr_typ(typ_to_c(t),empty_tqual())),decls);
    nv    = add_varmap(nv,vd->name,var_exp(v,DL));
    s     = seq_stmt(assign_stmt(var_exp(v,DL),address_exp(path,DL),DL),
		     goto_stmt(succ_lab,DL),DL);
    break;

  case Null_p: 
    s = if_eq_goto_stmt(r, signed_int_exp(0,DL),succ_lab,fail_lab); break;
  case Int_p(sn,i):
    s = if_eq_goto_stmt(r, int_exp(sn,i,DL),    succ_lab,fail_lab); break;
  case Char_p(c):
    s = if_eq_goto_stmt(r, char_exp(c,DL),      succ_lab,fail_lab); break;
  case Float_p(f):
    s = if_eq_goto_stmt(r, float_exp(f,DL),     succ_lab,fail_lab); break;

  case Enum_p(qv,ot,ts,ps,ed,ef):
    // when ps == null:  if (r == qv) goto succ_lab else goto fail_lab;
    // when ps == p1,...,pn:
    //   if ((unsigned int)r > max_tag && ((t)r)->tag == qv_tag)
    //      <similar to tuple and struct patterns>
    //   else goto fail_lab
    // It's unfortunate that we have to always check that r > max_tag.
    // If we had the decision tree information, we could avoid doing so.
    list<stmt> ss = null;
    int cnt = List::length(ps);
    qvar efstrct = collapse_qvar_tag(ef->name,"_struct");
    exp rcast   = cast_exp(nullableptr_typ(strctq(efstrct),empty_tqual()),r,DL);
    for(_ rps = List::rev(ps); rps != null; rps = rps->tl, cnt--) {
      _ p2  = rps->hd;
      _ v   = temp_var();
      _ t2  = p2->topt->v;
      _ lab = fresh_label();
      decls = &cons(&$(v,typ_to_c(t2)),decls);
      _ result = xlate_pat(nv,t2,var_exp(v,DL),
			   structarrow_exp(rcast,xprintf("f%d",cnt),DL),
			   p2,succ_lab,fail_lab,decls);
      nv    = result[0];
      decls = result[1];
      _ s3 = result[2];
      _ s1 = assign_stmt(var_exp(v,DL),
			 structarrow_exp(rcast,xprintf("f%d",cnt),DL),DL);
      _ s2 = seq_stmt(s1,s3,DL);
      ss = &cons(label_stmt(lab,s2,DL),ss);
      succ_lab = lab;
    }
    if (ps == null) {
      s = if_eq_goto_stmt(r, var_exp(collapse_qvar(qv),DL), succ_lab, fail_lab);
    } else {
      unsigned int max_tag = 0;
      for (_ fs = ed->fields->v; fs != null; fs = fs->tl) {
	_ f = fs->hd;
	if (f->typs == null) {
	  if (f->tag != null) toc_impos("can't deal with explicit tags yet");
	  max_tag++;
	}
      }
      exp max_tag_exp = uint_exp(max_tag,DL);
      exp e3 = cast_exp(nullableptr_typ(strct("_enum_struct"),empty_tqual()),
			r,DL);
      exp e1 = structarrow_exp(e3,"tag",DL);
      exp e5 = gt_exp(cast_exp(uint_t,r,DL), max_tag_exp, DL);
      exp e  = var_exp(collapse_qvar_tag(qv,"_tag"),DL);
      exp test_exp = 
	(max_tag > 0) ? and_exp(e5,eq_exp(e1,e,DL),DL) : eq_exp(e1,e,DL);
      s = ifthenelse_stmt(test_exp,
			  seq_stmts(ss,DL),
			  goto_stmt(fail_lab,DL), DL);
    }
    break;
  case Xenum_p(qv,ts,ps,xd,xf):
    // similar to Enums except that we cast the root to an _xenum_struct
    // and compare r->tag against qv (and then the nested patterns and so
    // forth.)  Lots of casting needed to get this to type-check.
    // Note: There are no non-pointer variants, hence no max tag.
    list<stmt> ss = null;
    int cnt = List::length(ps);
    qvar xfstrct = collapse_qvar_tag(xf->name,"_struct");
    exp rcast = cast_exp(nullableptr_typ(strctq(xfstrct),empty_tqual()),r,DL);
    for(_ rps = List::rev(ps); rps != null; rps = rps->tl, cnt--) {
      _ p2  = rps->hd;
      _ v   = temp_var();
      _ t2  = p2->topt->v;
      _ lab = fresh_label();
      decls = &cons(&$(v,typ_to_c(t2)),decls);
      _ result = xlate_pat(nv,t2,var_exp(v,DL),
			   structarrow_exp(rcast,xprintf("f%d",cnt),DL),p2,
			   succ_lab,fail_lab,decls);
      nv    = result[0];
      decls = result[1];
      _ s3 = result[2];
      _ s1 = assign_stmt(var_exp(v,DL),
			 structarrow_exp(rcast,xprintf("f%d",cnt),DL),DL);
      _ s2 = seq_stmt(s1,s3,DL);
      ss = &cons(label_stmt(lab,s2,DL),ss);
      succ_lab = lab;
    }
    if (ps == null) {
      s = if_eq_goto_stmt(structarrow_exp(r,"tag",DL),
			  var_exp(collapse_qvar_tag(qv,"_tag"),DL),
			  succ_lab,
			  fail_lab);
    } else {
      exp e3 = cast_exp(nullableptr_typ(strct("_xenum_struct"),empty_tqual()),
			r,DL);
      exp e2 = deref_exp(e3,DL);
      exp e1 = structmember_exp(e2,"tag",DL);
      exp e  = var_exp(collapse_qvar_tag(qv,"_tag"),DL);
      s = ifthenelse_stmt(eq_exp(e1,e,DL),
			  seq_stmts(ss,DL),
			  goto_stmt(fail_lab,DL), DL);
    }
    break;

  case Tuple_p(ps):
    // given the pattern $(p1,p2,...,pn)
    //    v1 = r->f1; if (matches(v1,p1)) goto L1 else goto fail_lab;
    // L1:v2 = r->f2; if (matches(v2,p2)) goto L2 else goto fail_lab;
    // L2:v3 = r->f3; if (matches(v3,p2)) goto L3 else goto fail_lab;
    //    ...
    // Ln-1:vn = r->fn; if (matches(vn,p2)) goto succ_lab else goto fail_lab;
    list<stmt> ss  = null;
    int        cnt = List::length(ps);
    for(_ rps = List::rev(ps); rps != null; rps = rps->tl, cnt--) {
      _ p2  = rps->hd;
      _ v   = temp_var();
      _ t2  = p2->topt->v;
      _ lab = fresh_label();
      decls = &cons(&$(v,typ_to_c(t2)),decls);
      _ result = xlate_pat(nv,t2,var_exp(v,DL),
			   structarrow_exp(path,xprintf("f%d",cnt),DL),
			   p2,succ_lab,fail_lab,decls);
      nv    = result[0];
      decls = result[1];
      _ s2 = result[2];
      _ s3 = seq_stmt(assign_stmt(var_exp(v,DL),
				 structmember_exp(r,xprintf("f%d",cnt),DL),DL),
			s2,DL);
      ss = &cons(label_stmt(lab,s3,DL),ss);
      succ_lab = lab;
    }
    s = seq_stmts(ss,DL);
    break;
  case Struct_p(sd,ot,ts,dlps0):
    // similar to translation of tuple pattern
    list<stmt> ss = null;
    for (_ dlps = List::rev(dlps0); dlps != null; dlps = dlps->tl) {
      _ tup = dlps->hd;
      _ p2  = tup[1];
      let FieldName(f) = tup[0]->hd;  // FIX:  assumes one field name designator
      _ v   = temp_var();
      _ t2  = p2->topt->v;
      _ lab = fresh_label();
      decls = &cons(&$(v,typ_to_c(t2)),decls);
      _ result = xlate_pat(nv,t2,var_exp(v,DL), structarrow_exp(path,f,DL),p2,
			   succ_lab,fail_lab,decls);
      nv    = result[0];
      decls = result[1];
      _ s2 = result[2];
      _ s3 = seq_stmt(assign_stmt(var_exp(v,DL),structmember_exp(r,f,DL),DL),
		      s2, DL);
      ss = &cons(label_stmt(lab,s3,DL),ss);
      succ_lab = lab;
    }
    s = seq_stmts(ss,DL);
    break;

  case Pointer_p(p2):
    // if (r == 0) goto fail_lab; v = *r; match(v,p2);
    _ v = temp_var();
    _ t2 = p2->topt->v;
    decls = &cons(&$(v,typ_to_c(t2)),decls);
    _ result = xlate_pat(nv,t2,var_exp(v,DL),r,p2, succ_lab,fail_lab,decls);
    nv    = result[0];
    decls = result[1];
    _ s2 = result[2];
    _ s3 = seq_stmt(assign_stmt(var_exp(v,DL),deref_exp(r,DL),DL),s2,DL);
    if (really_is_nullable(t))
      s = ifthenelse_stmt(eq_exp(r,signed_int_exp(0,DL),DL),
			  goto_stmt(fail_lab,DL),
			  s3,DL);
    else
      s = s3;
    break;
  case UnknownId_p(_):         s = toc_impos("unknownid");     break;
  case UnknownCall_p(_,_,_):   s = toc_impos("unknowncall");   break;
  case UnknownFields_p(_,_,_): s = toc_impos("unknownfields"); break;
  }
  return $(nv,decls,s);
}

///////////////////////////////////////////////////////////////
//              Translation of Switch Statements             //
///////////////////////////////////////////////////////////////
// FIX:  Should use decision tree stuff from tcpat.
//
// For performance, we try to leave switches as switches.  We do this when
// all of the following hold:
// * We are switching on a char or int type.
//   (Could also do enum without value contructors, but we didn't pass in
//    access to the type definitions!)
// * No switch_clause has any variables. (reject switch(3) { case x: ... }
// The hitch is we could still have something like
//    switch(e) { case 0: if(b) fallthru; else return; }
// Therefore, we give each case body
// a fresh label so we can translate fallthru to
// goto.  Then we just hope gcc cleans up the mess and can still use jump
// tables.
//
// For all other switches,
// switch (e) { case p1: s1 ... case pn:sn } turns into (roughly)
//
//  x = e;
//  <lots of temp declarations>
//    if matches(p1,x) goto L1 else goto L2;
// L2:if matches(p2,x) goto L3 else goto L4;
// L4:if matches(p3,x) goto L5 else goto L6;
//     ...
// L2n-2:if matches(pn,x) goto L2n-1 else goto L2n;
// L1: s1;
// L3: s2;
// L5: s3;
// ...
// L2n-1: sn;
// L2n: ;
//
// Note that within s1,...,sn, breaks are translated to "goto L2n".
static $(var,var,switch_clause)@ gen_label(switch_clause sc) {
  return &$(fresh_label(),fresh_label(),sc);
}
static void xlate_switch(env nv, stmt whole_s, exp e, list<switch_clause> scs) {
  exp_to_c(nv,e);
  _ t = e->topt->v;

  // decide if we can leave it as a switch
  bool leave_as_switch;
  switch (compress(t)) {
  case IntType(_,_,Unboxed): leave_as_switch = true;  break;
  default:                   leave_as_switch = false; break;
  }
  for(_ scs1 = scs; scs1 != null; scs1 = scs1->tl)
    if(scs1->hd->pat_vars->v != null) {
      leave_as_switch = false;
      break;
    }
  if(leave_as_switch) {
    // note: fallthru in last case can't happen, else this is busted
    var next_l = fresh_label();
    for(_ scs1 = scs; scs1 != null; scs1 = scs1->tl) {
      _ s = scs1->hd->body;
      scs1->hd->body = label_stmt(next_l,s,DL);
      next_l = fresh_label();
      stmt_to_c(switch_as_switch_env(nv,next_l),s);
    }
    return;
  }

  // no dice, translate to a nest of gotos...
  qvar v     = temp_var();
  exp  r     = var_exp(v,DL);
  exp  path  = address_exp(var_exp(v,DL),DL);
  var  end_l = fresh_label();
  // for each case, generate a test label and an entry label
  list<$(var,var,switch_clause)@> lscs = List::map(gen_label,scs);
  list<stmt>                test_stmts = null;
  list<env>                 nvs        = null;
  list<$(qvar,typ)@>        decls      = null;
  // generate the tests for each case, branching to the case's
  // label on success and to the next test on false.
  // do tests backwards so as to get vars for fallthrus
  for (_ lscs2 = lscs; lscs2 != null; lscs2 = lscs2->tl) {
    switch_clause sc = lscs2->hd[2];
    var fail_lab = (lscs2->tl == null) ? end_l : lscs2->tl->hd[0];
    var succ_lab = lscs2->hd[1];
    if (sc->where_clause == null) {
      _ res = xlate_pat(nv,t,r,path,sc->pattern,succ_lab,fail_lab,decls);
      nvs   = &cons(res[0],nvs);
      decls = res[1];
      test_stmts = &cons(label_stmt(lscs2->hd[0],res[2],DL),test_stmts);
    } else {
      _ e = sc->where_clause->v;
      _ intermed_lab = fresh_label();
      _ res = xlate_pat(nv,t,r,path,sc->pattern,intermed_lab,fail_lab,decls);
      exp_to_c(res[0], e); // Translate where clause with pattern vars in scope
      nvs   = &cons(res[0],nvs);
      decls = res[1];
      stmt s2 = ifthenelse_stmt(e,goto_stmt(succ_lab,DL),
				  goto_stmt(fail_lab,DL),DL);
      stmt s3 = label_stmt(intermed_lab, s2, DL);
      test_stmts = &cons(label_stmt(lscs2->hd[0],seq_stmt(res[2], s3, DL),DL),
			 test_stmts);
    }
  }
  _ test_stmt = seq_stmts(List::imp_rev(test_stmts),DL);
  nvs = List::imp_rev(nvs);
  // now generate all of the statements for the cases
  stmt clauses = skip_stmt(DL);
  if(lscs != null) {
    for (; lscs->tl != null; lscs = lscs->tl, nvs = nvs->tl) {
      _ e = nvs->hd;
      stmt s = lscs->hd[2]->body;
      stmt_to_c(non_last_switchclause_env(e,
					  end_l,
					  lscs->tl->hd[1],
					  lscs->tl->hd[2]->pat_vars->v,
					  nvs->tl->hd),
		s);
      clauses = seq_stmt(clauses, label_stmt(lscs->hd[1], s, DL), DL);
    }
    _    e = nvs->hd;
    stmt s = lscs->hd[2]->body;
    stmt_to_c(last_switchclause_env(e, end_l), s);
    clauses = seq_stmt(clauses, label_stmt(lscs->hd[1], s, DL), DL);
  }
  // glue the test statements, the case statements, and the end label together
  stmt res = seq_stmt(test_stmt,
		      seq_stmt(clauses,
			       label_stmt(end_l, skip_stmt(DL),DL),DL),DL);
  // add in all of the variable declarations with a wide enough scope
  for (decls; decls != null; decls = decls->tl) {
    let &$(qv,t) = decls->hd;
    res = declare_stmt(qv, t, null, res, DL);
  }
  // and finally add in the variable that holds the test and clobber
  // the abstract syntax
  whole_s->r = declare_stmt(v,typ_to_c(e->topt->v),&Opt(e), res, DL)->r;
}

extern stmt letdecl_to_c(env nv, pat p, Opt_t<typ> topt, exp e,
			 bool exhaust, stmt s);
extern $(env,list<decl>) decls_to_c(env nv, list<decl> ds, bool top);


///////////////////////////////////////////////////////////////
//              Translation of Statements                    //
///////////////////////////////////////////////////////////////
// This is surprisingly straightforward... a good sign.
static void stmt_to_c(env nv, stmt s) {
  // written to be self-tail recursive
  while (true) {
    switch (s->r) {
    case Skip_s:
      return;
    case Exp_s(e):
      exp_to_c(nv, e);
      return;
    case Seq_s(s1,s2):
      stmt_to_c(nv,s1);
      s = s2;
      continue;
    case Return_s(eopt):
      Opt_t<typ> topt = null;
      if (eopt != null) {
	topt = &Opt(typ_to_c(eopt->v->topt->v));
	exp_to_c(nv,eopt->v);
      }
      // reset handler
      // FIX:  share code between break, continue, return, fallthru
      if (nv->to_pop_return != 0) {
	_ call_exp = fncall_exp(var_exp(&$(null,(string)"_npop_handler"),DL),
				&cons(uint_exp(nv->to_pop_return-1,DL),null),
				DL);
	_ call_stmt = exp_stmt(call_exp,DL);
	// must run the expression before popping the handler
	if (topt != null) {
	  _ x = temp_var();
	  _ retn_stmt = return_stmt(&Opt(var_exp(x,DL)),DL);
	  s->r = declare_stmt(x,topt->v,eopt,seq_stmt(call_stmt,
							   retn_stmt,DL),
				    DL)->r;
	} else {
	  s->r = seq_stmt(call_stmt,new_stmt(s->r,DL),DL)->r;
	}
      }
      return;
    case IfThenElse_s(e,s1,s2):
      exp_to_c(nv,e);
      stmt_to_c(nv,s1);
      s = s2;
      continue;
    case While_s($(e,_),s2):
      exp_to_c(nv,e);
      stmt_to_c(loop_env(nv),s2);
      return;
    case Break_s(_):
      if (nv->break_lab != null)
	s->r = goto_stmt(nv->break_lab->v, DL)->r;
      // reset handler
      // FIX:  share code between break, continue, return, fallthru
      if (nv->to_pop_break != 0) {
	_ call_exp = fncall_exp(var_exp(&$(null,(string)"_npop_handler"),DL),
				&cons(uint_exp(nv->to_pop_break-1,DL),null),
				DL);
	_ call_stmt = exp_stmt(call_exp,DL);
	s->r = seq_stmt(call_stmt,new_stmt(s->r,DL),DL)->r;
      }
      return;
    case Continue_s(_):
      if (nv->continue_lab != null)
	s->r = goto_stmt(nv->continue_lab->v, DL)->r;
      // reset handler
      // FIX:  share code between break, continue, return, fallthru
      if (nv->to_pop_continue != 0) {
	_ call_exp = fncall_exp(var_exp(&$(null,(string)"_npop_handler"),DL),
				&cons(uint_exp(nv->to_pop_continue-1,DL),null),
				DL);
	_ call_stmt = exp_stmt(call_exp,DL);
	s->r = seq_stmt(call_stmt,new_stmt(s->r,DL),DL)->r;
      }
      return;
    case Goto_s(_,_): return;
    case For_s(e1,$(e2,_),$(e3,_),s2):
      // FIX:  should e3 be translated in nv?
      exp_to_c(nv,e1); exp_to_c(nv,e2); exp_to_c(nv,e3);
      stmt_to_c(loop_env(nv),s2);
      return;
    case Switch_s(e,scs):
      xlate_switch(nv,s,e,scs);
      return;
    case Fallthru_s(es,_):
      if(nv->fallthru_info == null) {
	toc_impos("fallthru in unexpected place"); return;
      }
      let &$(l,vs,other_vmap) = nv->fallthru_info->v;
      stmt s2 = goto_stmt(l, DL);
      _ vs2 = List::rev(vs);
      _ es2 = List::rev(es);
      for(; vs2 != null; vs2 = vs2->tl, es2 = es2->tl) {
	exp_to_c(nv,es2->hd);
	s2 = seq_stmt(assign_stmt(Dict::lookup(other_vmap,vs2->hd),
				  es2->hd,DL),
		      s2,DL);
      }
      s->r = s2->r;
      // reset handler
      // FIX:  share code between break, continue, return, fallthru
      if (nv->to_pop_fallthru != 0) {
	_ call_exp = fncall_exp(var_exp(&$(null,(string)"_npop_handler"),DL),
				 &cons(uint_exp(nv->to_pop_fallthru-1,DL),null),
				 DL);
	_ call_stmt = exp_stmt(call_exp,DL);
	s->r = seq_stmt(call_stmt,new_stmt(s->r,DL),DL)->r;
      }
      return;
    case Decl_s(d,s1):
      switch (d->r) {
      case Let_d(p,topt,e,exhaust):
	// we treat let declarations specially because they may need
	// statements in addition to declarations, so we splice them in
	// as a statement.  Other declarations only produce declarations.
	s->r = letdecl_to_c(nv, p, topt, e, exhaust, s1)->r;
        break;
      default:
	let $(nv,decls) = decls_to_c(nv,&cons(d,null),false);
	stmt_to_c(nv,s1);
	for (; decls != null; decls = decls->tl)
	  s1 = decl_stmt(decls->hd,s1,DL);
	s->r = s1->r;
        break;
      }
      return;
    case Cut_s(_):    unimp("cut");    return;
    case Splice_s(_): unimp("splice"); return;
    case Label_s(lab,s1):
      s = s1; continue;
    case Do_s(s2,$(e,_)):
      stmt_to_c(loop_env(nv),s2);
      exp_to_c(nv,e);
      return;
    case TryCatch_s(body,scs):
      // NOTE: Because explicit fallthru is not allowed in the last case,
      //       appending a new last case can't change the meaning of any
      //       control flow.
      // BROKEN.  Sometimes e does not get the non-null second return value
      // of _trycatch.  _trycatch really does return non-null, but e doesn't
      // see it.  It works sometimes, but not always...
      //
      // exn e = _trycatch();
      // if (!e) {
      //   body
      //   _pop_handler();
      // } else switch (e) scs
      //
      // [Auxillary functions are defined in cyc_runtime.c]
      qvar e = temp_var();
      _ e_exp = var_exp(e,DL);
      // e_exp needs a typ because it'll go through exp_to_c;
      // as well, it must be in varmap
      _ e_typ = typ_to_c(exn_typ);
      e_exp->topt = &Opt(e_typ);
      nv = add_varmap(nv,e,e_exp);
      _ h     = temp_var();
      _ h_exp = var_exp(h,DL);
      _ h_typ = nullableptr_typ(strct("_handler_cons"),empty_tqual());
      _ setjmp_exp      = var_exp(&$(null,(string)"setjmp"),DL);
      _ pushhandler_exp = var_exp(&$(null,(string)"_push_handler"),DL);
      _ pophandler_exp  = var_exp(&$(null,(string)"_pop_handler"),DL);
      //    let trycatch_exp = var_exp(&$(null,(string)"_trycatch"),DL);
      stmt_to_c(try_env(nv),body);
      _ tryandpop_stmt = seq_stmt(body,
				  exp_stmt(fncall_exp(pophandler_exp, null,
						      DL), DL),DL);
      // add a default case which re-throws the exception
      _ x    = temp_var();
      _ xexp = var_exp(x,DL);
      xexp->topt = &Opt(exn_typ);
      _ p = &Pat{.r=Var_p(new_vardecl(x,exn_typ,null)),
		   .topt=&Opt(exn_typ),
		   .loc=DL};
      _ te = throw_exp(xexp,DL);
      te->topt = &Opt(VoidType);
      _ rs = exp_stmt(te,DL);
      _ default_case =
        &Switch_clause{.pattern=p,.pat_vars=&Opt((list<qvar>)&cons(x,null)),
		       .where_clause=null,.body=rs,.loc=DL};
      _ handler_stmt = switch_stmt(e_exp,
				   List::append(scs,
						&cons(default_case,null)),DL);
      stmt_to_c(nv,handler_stmt);
      _ setjmp_call = // (exn)setjmp(h->handler)
	cast_exp(e_typ,
		 fncall_exp(setjmp_exp,
			    &cons(structarrow_exp(h_exp,"handler",DL), null),
			    DL),DL);
      s->r =
	declare_stmt(h,h_typ,
		     &Opt(fncall_exp(pushhandler_exp, null, DL)),
		     declare_stmt(e,e_typ,&Opt(setjmp_call),
				  ifthenelse_stmt(prim1_exp(Not, e_exp,DL),
						  tryandpop_stmt,
						  handler_stmt, DL),DL),DL)->r;
      return;
    }
  }
}

///////////////////////////////////////////////////////////////
//              Translation of Declarations                  //
///////////////////////////////////////////////////////////////
// function declaration translation -- straightforward
static void fndecl_to_c(env nv, fndecl f) {
  f->name     = collapse_qvar(f->name);
  f->tvs      = null;
  f->ret_type = typ_to_c(f->ret_type);
  for (_ args=f->args; args != null; args = args->tl) {
    args->hd[2] = typ_to_c(args->hd[2]);
    _ x = &$(null,args->hd[0]);
    nv = add_varmap(nv,x,var_exp(x,DL));
  }
  stmt_to_c(clear_toplevel(nv),f->body);
}

// there's no abstract scope in C
static scope scope_to_c(scope s) {
  switch (s) {
  case Abstract: return Public;
  default:       return s;
  }
}

// struct declarations -- straightforward
Opt_t<Dict::Dict<var,structdecl>> structs_so_far = null;
static void structdecl_to_c(structdecl s) {
  _ n = collapse_qvar(s->name->v);
  if (structs_so_far == null) structs_so_far =
				&Opt(Dict::empty(String::zstrcmp));
  bool seen_defn_before;
  _ dopt = Dict::lookup_opt(structs_so_far->v, n[1]);
  if (dopt == null) {
    seen_defn_before = false;
    structs_so_far->v = Dict::insert(structs_so_far->v,n[1],s);
  } else {
    if (dopt->v->fields == null) {
      structs_so_far->v = Dict::insert(structs_so_far->v,n[1],s);
      seen_defn_before = false;
    } else
      seen_defn_before = true;
  }

  s->sc =
    // C does not like extern or static on struct declarations -- this avoids
    // a gcc warning
    (s->sc == Extern || s->sc == Static) ? Public : scope_to_c(s->sc);
  s->tvs  = null;
  s->name = &Opt(n);
  if (s->fields != null)
    if (seen_defn_before)
      s->fields = null;
    else {
      for (_ fields = s->fields->v; fields != null; fields = fields->tl)
	fields->hd[2] = typ_to_c_array(fields->hd[2]);
    }
}

// enum declarations -- tricky
// for "enum foo {Bar,Blah,Baz(t1,t2,t3),Baf(t4,t5)}" we generate
//   typedef void *foo;
//   foo Bar = (foo)0;
//   foo Blah = (foo)1;
//   int _Baz_tag = 0;
//   struct _Baz_struct {
//     int tag;  // always _Baz_tag
//     t1 f1;
//     t2 f2;
//     t3 f3;
//   }
//   int _Baf_tag = 1;
//   Struct _Baf_struct {
//     int tag;  // always _Baf_tag
//     t4 f1;
//     t5 f2;
//   }
// When the enum is "extern" then we don't generate initializers
// for the tags (that should be done elsewhere.)
//
// Then "Bar" maps to "Bar" and "Baz(e1,e2,e3)" maps to
// ({ struct _Baz_struct *t = (struct _Baz_struct*)malloc(sizeof(_Baz_struct));
//    *t = (struct _Baz_struct){->tag = _Baz_tag, ->f1 = e1, ->f2 = e2, ->f3 = e3};
//    t; })
//
// NB: we allow any number of extern enum declarations and we require
// a single non-extern enum declaration.  We will need to generate a
// declaration for, e.g., struct _Baz_struct, only at the FIRST enum
// declaration we encounter -- otherwise we'd have multiple declarations
// of the same struct in the output.  Therefore we keep track of the
// structs we've defined so far.
//
static Opt_t<Dict::Dict<var,enumdecl>> enums_so_far = null;
static list<decl> enumdecl_to_c(enumdecl ed, list<decl> res) {
  _ n = collapse_qvar(ed->name->v);
  if (enums_so_far == null)
    enums_so_far = &Opt(Dict::empty(String::zstrcmp));
  bool seen_before;
  bool seen_defn_before;
  _ dopt = Dict::lookup_opt(enums_so_far->v, n[1]);
  if (dopt == null) {
    seen_before      = false;
    seen_defn_before = false;
    enums_so_far->v  = Dict::insert(enums_so_far->v,n[1],ed);
  } else {
    seen_before = true;
    if (dopt->v->fields == null) {
      seen_defn_before = false;
      Dict::insert(enums_so_far->v,n[1],ed);
    } else
      seen_defn_before = true;
  }

  if (!seen_before) {
    // add "typedef void *n" to the declarations
    _ tdef = &Typedefdecl{.name=n,.tvs=null,.defn=void_star_typ()};
    res = &cons(new_decl(Typedef_d(tdef),DL),res);
  }
  typ t = TypedefType(n,null,&Opt(void_star_typ()));
  // counters for the tags
  // FIX:  need to deal with explicit tags
  int tag_count = 0;
  int box_count = 0;
  for (_ fields = (ed->fields == null) ? null : ed->fields->v;
       fields != null; fields = fields->tl) {
    enumfield f = fields->hd;
    // FIX
    if (f->tag != null) toc_impos("can't deal with enum tags yet");
    if (f->typs == null) {
      // Declare an integer constant for the unboxed field
      _ eopt = (ed->sc == Extern) ? null :
	        &Opt(cast_exp(t,signed_int_exp(tag_count++,DL),DL));
      _ vd = new_vardecl(collapse_qvar(f->name), t, eopt);
      vd->sc = scope_to_c(ed->sc);
      vd->tq = &Tqual{.q_const=true, .q_volatile=false, .q_restrict=false};
      res = &cons(new_decl(Var_d(vd),DL),res);
    } else {
      // Declare an integer constant for the tag and a struct for the field
      _ eopt = (ed->sc == Extern) ? null : &Opt(signed_int_exp(box_count++,DL));
      _ vd   = new_vardecl(collapse_qvar_tag(f->name,"_tag"), sint_t, eopt);
      vd->sc = scope_to_c(ed->sc);
      vd->tq = &Tqual{.q_const=true, .q_volatile=false, .q_restrict=false};
      res = &cons(new_decl(Var_d(vd),DL),res);
      // compute the fields for the struct, adding in a tag field
      if (!seen_defn_before) {
        _   fs = null;
        int i  = 1;
        for (_ ts = f->typs; ts != null; ts = ts->tl, i++) {
          _ fname = xprintf("f%d",i);
          fs = &cons(&$(fname,ts->hd[0],typ_to_c_array(ts->hd[1])),fs);
        }
        fs = List::imp_rev(fs);
        fs = &cons(&$((string)"tag",empty_tqual(),sint_t),fs);
        _ sd = &Structdecl{.sc = Public,
			   .name = &Opt(collapse_qvar_tag(f->name,"_struct")),
			   .tvs = null, 
			   .fields = &Opt(fs)};
        res = &cons(new_decl(Struct_d(sd),DL),res);
      }
    }
  }
  return res;
}

// xenum declarations -- similar to enum declarations
// For the declaration of a new xenum, e.g.,
//   "xenum foo;"
// we generate
//   "typedef struct _xenum_struct *foo".
// struct _xenum_struct is defined in cyc_include->h as
//   "struct _xenum_struct { char *tag; }"
// For a declaration extending an existing xenum, e.g.,
//   "xenum foo {Bar,Baz(t1,t2)}"
// we generate
//   char _Bar_tag[4] = "Bar";
//   struct _Bar_struct { char *tag; };
//   char _Baz_tag[4] = "Baz";
//   struct _Baz_struct { char *tag; t1 f1; t2 f2; };
// When the xenum is extern, then we don't do initializers for the tags.
//
// Thus "Baz(e1,e2)" maps to
// ({struct _Baz_struct *t =
//     (struct _Baz_struct*)malloc(sizeof(struct _Baz_struct));
//   *t = (struct _Baz_struct){->tag=_Baz_tag, ->f1 = e1, ->f2 = e2};
//   t;})
//
// We use the same trick as with enums to avoid struct redefinitions
// when there are multiple declarations (all but one, extern) for the
// same xenum field.
//
static Opt_t<Dict::Dict<var,xenumdecl>> xenums_so_far = null;
static list<decl> xenumdecl_to_c(xenumdecl xd, list<decl> res) {
  _ n = collapse_qvar(xd->name);

  if (xd->fields == null) {
    _ t  = nullableptr_typ(strct("_xenum_struct"),empty_tqual());
    _ td = &Typedefdecl{.name = n, .tvs = null, .defn = t};
    res = &cons(new_decl(Typedef_d(td),DL),res);
  } else {
    if (xenums_so_far == null)
      xenums_so_far = &Opt(Dict::empty(String::zstrcmp));
    for (_ fs = xd->fields; fs != null; fs = fs->tl) {
      enumfield f = fs->hd;
      if (f->tag != null) unimp("xenum:  can't deal with explicit tags");
      string fn      = collapse_qvar(f->name)[1];
      _      sz_exp  = uint_exp(fn.size,DL);
      _      tag_typ = ArrayType(uchar_t,empty_tqual(),FixedArray(sz_exp));
      Opt_t<exp> initopt = null;
      if (xd->sc != Extern)
	initopt = &Opt(string_exp(fn,DL));
      _ tag_decl = new_vardecl(collapse_qvar_tag(f->name,"_tag"),
			       tag_typ, initopt);
      tag_decl->sc = xd->sc;
      res = &cons(new_decl(Var_d(tag_decl),DL),res);

      bool seen_before;
      bool seen_defn_before;
      _ dopt = Dict::lookup_opt(xenums_so_far->v,fn);
      if (dopt == null) {
	seen_before      = false;
	seen_defn_before = false;
	xenums_so_far->v = Dict::insert(xenums_so_far->v,fn,xd);
      } else {
	seen_before = true;
	if (dopt->v->fields == null) {
	  xenums_so_far->v = Dict::insert(xenums_so_far->v,fn,xd);
	  seen_defn_before = false;
	} else
	  seen_defn_before = true;
      }

      if (!seen_before) {
        list<$(field_name,tqual,typ)@> fields = null;
        int i = 1;
        for (list<$(tqual,typ)@> ts = f->typs; ts != null; ts = ts->tl, i++) {
          _ newf = &$(xprintf("f%d",i),ts->hd[0],typ_to_c_array(ts->hd[1]));
          fields = &cons(newf,fields);
        }
        fields = &cons(&$((string)"tag",empty_tqual(),
			  nullableptr_typ(uchar_t,empty_tqual())),
        List::rev(fields));
        _ strct_decl =
	  &Structdecl{.sc     = Public,
		      .name   = &Opt(collapse_qvar_tag(f->name,"_struct")),
		      .tvs    = null,
		      .fields = &Opt(fields)};
        res = &cons(new_decl(Struct_d(strct_decl),DL),res);
      }
    }
  }
  return res;
}

// let declarations -- tricky
// Unlike other declarations, lets need to execute statements and
// so return a statement.  (See stmt_to_c, case for Decl above.)
// We treat this similar to the compilation of a switch (see xlate_switch
// above) with one case, but where the failure throws the exception
// Match_Exception
static stmt letdecl_to_c(env nv, pat p, Opt_t<typ> topt, exp e,
			 bool exhaust, stmt s) {
  typ t = topt->v;
  exp_to_c(nv,e);
  qvar x = temp_var();
  var  succ_lab = fresh_label();
  var  fail_lab = exhaust ? succ_lab : fresh_label();
  let $(nv,vars,test_stmt) =
    xlate_pat(nv, t, var_exp(x,DL),address_exp(var_exp(x,DL),DL),p,
	      succ_lab, fail_lab, null);
  stmt_to_c(nv,s);
  _ succ_stmt = label_stmt(succ_lab,s,DL);
  if(exhaust)
    s = declare_stmt(x,typ_to_c(t),&Opt(e),seq_stmt(test_stmt,succ_stmt,DL),DL);
  else {
    _ e3 = newthrow_exp(var_exp(&$(null,(string)"Match_Exception"),DL));
    _ fail_stmt = label_stmt(fail_lab,exp_stmt(e3,DL),DL);
    s = declare_stmt(x,typ_to_c(t),&Opt(e),
		     seq_stmt(test_stmt,
			      seq_stmt(fail_stmt,succ_stmt,DL),DL),DL);
  }
  for (; vars != null; vars = vars->tl) {
    let &$(qv,t2) = vars->hd;
    s = declare_stmt(qv,t2,null,s,DL);
  }
  return s;
}

// Translate the given declarations, producing a new list of declarations
// and a new translation environment.  All source-level variables should
// be entered in the varmap of the env.  Note that top-level variable
// declarations are treated differently.
//
// FIX:  the translation of top-level variable declarations needs to be
// fixed to make expressions "constant" initializers for C (e.g.,
// constructor expressions, new structs, etc.)
static $(env,list<decl>) decls_to_c(env nv, list<decl> ds, bool top) {
  list<decl> res = null;
  for (; ds != null; ds = ds->tl) {
    decl d = ds->hd;
    switch (d->r) {
    case Var_d(vd):
      _ n = collapse_qvar(vd->name);
      if (vd->initializer != null)
	exp_to_c(nv, vd->initializer->v);
      if (nv->toplevel) {
	res = List::append(temp_topdecls,res);
	temp_topdecls = null;
      }
      if (top)
	nv = add_varmap(nv,vd->name,varb_exp(n,Global_b(vd),DL));
      else
	nv = add_varmap(nv,vd->name,varb_exp(n,Local_b(vd),DL));
      vd->name = n;
      vd->sc   = scope_to_c(vd->sc);
      //vd->type = top ? typ_to_c_array(vd->type) : typ_to_c(vd->type);
      vd->type = typ_to_c_array(vd->type);
      res = &cons(d,res);
      break;
    case Fn_d(fd):
      nv = add_varmap(nv,fd->name,var_exp(collapse_qvar(fd->name),DL));
      fndecl_to_c(nv, fd);
      res = &cons(d,res);
      break;
    case Let_d(_,_,_,_):
      // this is handled in stmt_to_c
      toc_impos("letdecl");
      break;
    case Struct_d(sd):
      structdecl_to_c(sd);
      res = &cons(d,res);
      break;
    case Union_d: toc_impos("uniondecl"); break;
    case Enum_d(ed):
      res = enumdecl_to_c(ed,res);
      break;
    case Xenum_d(xd):
      res = xenumdecl_to_c(xd,res); break;
    case Typedef_d(td):
      td->name = collapse_qvar(td->name);
      td->tvs = null;
      td->defn = typ_to_c_array(td->defn);
      res = &cons(d,res);
      break;
    case Namespace_d(v,ds2):
      _ p = decls_to_c(nv,ds2,top);
      nv = p[0];
      res = List::append(List::rev(p[1]),res);
      break;
    case Using_d(q,ds2):
      _ p = decls_to_c(nv,ds2,top);
      nv = p[0];
      res = List::append(List::rev(p[1]),res);
      break;
    }
  }
  return $(nv,List::rev(res));
}

// initialize all globals
static void init() {
  tuple_types = null;
  tuple_type_counter = 0;
  tagged_array_types = null;
  tagged_array_counter = 0;
  temp_var_counter = 0;
  fresh_label_counter = 0;
  temp_topdecls = null;
}

// The entry point:  translate the list of Cyclone declarations to
// a list of C declarations.
//
// FIX:  right now, any types that are generated for tuple types or
// tagged array types are added at the beginning of the declaration
// list.  It's not clear that this respects C's scope rules.  For
// instance, one of the tuple types might contain a forward reference
// to a struct type...  (I think this is okay, though.)
list<decl> toc(list<decl> ds) {
  init();
  let $(_,ds) = decls_to_c(empty_env(),ds,true);
  // add the tagged array types in
  for (_ ts = tagged_array_types; ts != null; ts = ts->tl) {
    let &$(x,t) = ts->hd;
    _ f1 = &$((string)"sz", empty_tqual(), uint_t);
    _ f2 = &$((string)"contents",
		empty_tqual(),
		nullableptr_typ(t,empty_tqual()));
    _ fs = &cons(f1,&cons(f2,null));
    _ sd = &Structdecl{.sc = Public, .name = &Opt(&$(null,x)), .tvs = null,
                         .fields = &Opt((list<$(string,tqual,typ)@>)fs)};
    ds = &cons(new_decl(Struct_d(sd),DL),ds);
  }
  // add the tuple types in
  for (; tuple_types != null; tuple_types = tuple_types->tl) {
    let &$(x,ts) = tuple_types->hd;
    _ fs = null;
    for (int i = 1; ts != null; ts = ts->tl, i++)
      fs = &cons(&$(xprintf("f%d",i),empty_tqual(),ts->hd),fs);
    fs = List::imp_rev(fs);
    _ sd = &Structdecl{.sc = Public, .name = &Opt(&$(null,x)),
			 .tvs = null, .fields = &Opt(fs)};
    ds = &cons(new_decl(Struct_d(sd),DL),ds);
  }
  return ds;
}
