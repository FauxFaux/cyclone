/* Translate Cyclone abstract syntax to C abstract syntax.
   Copyright (C) 2001 Greg Morrisett, AT&T
   This file is part of the Cyclone compiler.

   The Cyclone compiler is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   The Cyclone compiler is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with the Cyclone compiler; see the file COPYING. If not,
   write to the Free Software Foundation, Inc., 59 Temple Place -
   Suite 330, Boston, MA 02111-1307, USA. */

// Translation of Cyclone abstract syntax to C abstract syntax.
// Assumes that the type-checker has been successfully run on the
// Cyclone AST.  Uses lots of GCC-specific features (that should be in
// C-9X) to simplify the translation -- in particular, we use struct
// expressions "(struct foo){.f1=e1,.f2=e2,...,.fn=en}" and statement
// expressions "({int temp = e; temp++})".  The latter is used for
// declaring temps needed in the translation of expressions.

// The translation is mostly done in place in an imperative style
// (i.e., we overwrite AST nodes) so it's fairly crucial that we don't
// have sharing in the AST.  The one exception is that the type
// translation is functional.

// Look for "unimp" or comments that start with FIX: for missing
// or broken pieces.

// FIX: we could probably use "const" in lots of places where we're not.

// Note: unresolvedmem_exp should only be used (1) to build arrays; or
// (2) to build other things (structs etc.) at top level only; Tovc relies on this.

#include <string.h>
#include <dict.h>
#include <xarray.h>
#include "warn.h"
#include "absynpp.h"
#include "tcutil.h"
#include "evexp.h"
#include "relations.h"
#include "cf_flowinfo.h"
#include "toc.h"
#include "tcpat.h"
using Core;
using List;
using Set;
using Absyn;
using Absynpp;
using Tcutil;

// Note: expansion of typedefs is done in Absynpp::to_tms, but here we
//  trim out typedefs that won't be used
extern bool noexpand_r; // in cyclone.cyc

namespace Toc;

// used for creation of all abstract syntax node locations created here
#define DL 0

// padding for variable-length array allocations
#define PAD_BYTES sizeof(double)

// for passing New_e destinations to RemoveAggrs
@extensible datatype Absyn::AbsynAnnot { 
  Dest(exp_t);
};

static `a unimp(string_t fmt, ... inject parg_t<`r2> ap)
  __attribute__((format(printf,1,2), noreturn)) {
  Warn::vimpos(strconcat("Toc (unimplemented): ",fmt), ap);
}
static `a toc_impos(string_t fmt, ... inject parg_t<`r2> ap)
  __attribute__((format(printf,1,2), noreturn)) {
  Warn::vimpos(strconcat("Toc: ",fmt), ap);
}

// #define BCE_DEBUG
bool warn_bounds_checks = false;
bool warn_all_null_deref = false;
unsigned total_bounds_checks = 0;
unsigned bounds_checks_eliminated = 0;

stringptr_t ?globals = NULL;

// should be folded into environment, but for now use globals
static table_t<fndecl_t,table_t<stmt_t,int>> * gpop_tables  = NULL;
static table_t<stmt_t,int>                   * fn_pop_table = NULL;
static int tuple_type_counter  = 0;
static int temp_var_counter    = 0;
static int fresh_label_counter = 0;

// we aren't re-entrant -- we build this list of output decls (in
// reverse order)  It's global b/c tuple types, tagged pointer types, and
// strange top-level initializers need to "splice in" toplevel decls and
// it's a pain to pass this list around everywhere
static list_t<decl_t> result_decls = NULL;

static int get_npop(stmt_t s) {
  return Hashtable::lookup(*fn_pop_table,s);
}

// for gensymming, etc.
struct TocState<`d> {
  // tuple types seen so far and the struct they map to
  list_t<$(type_t,list_t<type_t,`d>)@`d,`d> @`d tuple_types;
  // anonymous aggr types seen so far and the struct they map to (rare)
  // FIX: would be nice to share more code with tuple translation
  list_t<$(type_t,aggr_kind_t,list_t<aggrfield_t>)@`d,`d> @`d anon_aggr_types;
  // (non-tagged) aggregates seen so far, their declaration, and C type
  Dict::dict_t<qvar_t,$(aggrdecl_t,type_t)@`d,`d> @`d aggrs_so_far;
  //instantiations of abstract structs generated
  list_t<$(qvar_t,list_t<type_t>,type_t)@`d,`d> @`d abs_struct_types;
  // datatypes seen so far
  Set::set_t<qvar_t,`d> @`d                    datatypes_so_far;
  // xdatatypes seen so far -- bool is false if seen but not initialized (extern)
  Dict::dict_t<qvar_t,bool,`d> @`d             xdatatypes_so_far;
  // generated identifiers from combining other identifiers -- used when
  // collapsing datatype members with the datatype itself.  
  Dict::dict_t<$(qvar_t,qvar_t)@`d,qvar_t,`d>@`d qvar_tags;
  // generated labels -- get re-used across functions
  Xarray::xarray_t<var_t,`d>                    temp_labels;
};

static int qvar_tag_cmp($(qvar_t,qvar_t)@ x, $(qvar_t,qvar_t)@ y) {
  let $(qx,sx) = *x;
  let $(qy,sy) = *y;
  int i = qvar_cmp(qx,qy);
  if (i != 0) return i;
  return qvar_cmp(sx,sy);
}

// create a fresh TocState given the region
static struct TocState<`d>@`d empty_toc_state(region_t<`d> d) {
  return rnew(d) 
    TocState{.tuple_types       = rnew(d) NULL,
	     .anon_aggr_types   = rnew(d) NULL,
             .aggrs_so_far      = rnew(d) Dict::rempty(d,qvar_cmp),
             .abs_struct_types  = rnew(d) NULL,
             .datatypes_so_far  = rnew(d) Set::rempty(d,qvar_cmp),
             .xdatatypes_so_far = rnew(d) Dict::rempty(d,qvar_cmp),
             .qvar_tags         = rnew(d) Dict::rempty(d,qvar_tag_cmp),
             .temp_labels       = Xarray::rcreate_empty(d)
            };
}

struct TocStateWrap {
  <`d::R>
  Core::rcregion_key_t<`d> dyn;
  struct TocState<`d>@`d state;
};
typedef struct TocStateWrap*`U toc_state_t;
static toc_state_t toc_state = NULL;

// a generic function for using the toc state:  we pass in an
// argument arg and function f and end up passing f the current
// toc_state component after opening the toc_state's wrapped
// dynamic region.  
static `res use_toc_state(`a arg,
                          `res f<`d,`r>(region_t<`d>, 
                                        $(struct TocState<`d>@`d,`a)@`r)) {
  toc_state_t ts = NULL;
  ts :=: toc_state;
  let TocStateWrap{<`dyn> dyn, s} = *ts;
  let dyn2 = alias_refptr(dyn);
  *ts = TocStateWrap{dyn,s};
  ts :=: toc_state;
  let res;
  {region h = open(dyn2);
  let env = $(s, arg);
  res = f(h,&env);}
  free_rckey(dyn2); // should be equivalent to drop_refptr
  return res;
}

static type_t aggrdecl_type_body<`r2,`d,`r>(region_t<`d> d, 
                                 $(struct TocState<`d>@`d, 
                                   $(qvar_t q,type_t (@`H)(qvar_t))@`r2)@`r env) {
  let $(s, &$(q, type_maker)) = *env;
  $(aggrdecl_t,type_t)@`d*`d v = Dict::lookup_opt(*s->aggrs_so_far,q);
  if (v == NULL) {
    return type_maker(q);
  } else {
    let &$(_,t) = *v;
    return t;
  }
}

static type_t aggrdecl_type(qvar_t q, type_t (@`H type_maker)(qvar_t)) {
  _ env = $(q, type_maker);
  return use_toc_state(&env, (aggrdecl_type_body@<`aggrdecl_type>)<>);
}

/////////////////////////// Pre-Allocated Stuff /////////////////////////////
// Don't use any of these things if they might get mutated!!!

// some pre-allocated boxed strings -- use foo_sp for char ?* w/ contents "foo"
#define MAKE_STRING(str)\
  static string_t    str##_string = #str; \
  static stringptr_t str##_sp     = &str##_string

MAKE_STRING(curr);
MAKE_STRING(tag);
MAKE_STRING(val);
MAKE_STRING(_handler_cons);
MAKE_STRING(handler);
MAKE_STRING(_RegionHandle);
MAKE_STRING(_DynRegionHandle);
MAKE_STRING(_DynRegionFrame);

/* Some pre-allocated qvars -- use foo_e for exp that is var "foo".
   NB we must record all of these so that tovc knows about them;
   this is done by initializing the external variable globals in the
   function init(), below. */
#define MAKE_VAR(str)\
  static string_t            str##_str = #str;\
  static $(nmspace_t, var_t) str##_pr  = $(Nmspace{.Loc_n=0},&str##_str);\
  static datatype Binding.Unresolved_b str##_bnd = Unresolved_b(&str##_pr);\
  static datatype Raw_exp.Var_e        str##_re  = Var_e(&str##_bnd);\
  static struct Exp          str##_ev  = Exp{NULL,&str##_re,0,&EmptyAnnot_val};\
  static exp_t               str##_e   = &str##_ev

MAKE_VAR(_throw);
MAKE_VAR(setjmp);
MAKE_VAR(_push_handler);
MAKE_VAR(_pop_handler);
MAKE_VAR(_exn_thrown);
MAKE_VAR(_npop_handler);
MAKE_VAR(_check_null);
MAKE_VAR(_check_known_subscript_null);
MAKE_VAR(_check_known_subscript_notnull);
MAKE_VAR(_check_dyneither_subscript);
MAKE_VAR(_dyneither_ptr);
MAKE_VAR(_tag_dyneither);
MAKE_VAR(_untag_dyneither_ptr);
MAKE_VAR(_get_dyneither_size);
MAKE_VAR(_get_zero_arr_size); // NOT SURE WHETHER WE NEED BOTH?
MAKE_VAR(_get_zero_arr_size_char);
MAKE_VAR(_get_zero_arr_size_short);
MAKE_VAR(_get_zero_arr_size_int);
MAKE_VAR(_get_zero_arr_size_float);
MAKE_VAR(_get_zero_arr_size_double);
MAKE_VAR(_get_zero_arr_size_longdouble);
MAKE_VAR(_get_zero_arr_size_voidstar);
MAKE_VAR(_dyneither_ptr_plus);
MAKE_VAR(_zero_arr_plus);     // NOT SURE WHETHER WE NEED BOTH?
MAKE_VAR(_zero_arr_plus_char);
MAKE_VAR(_zero_arr_plus_short);
MAKE_VAR(_zero_arr_plus_int);
MAKE_VAR(_zero_arr_plus_float);
MAKE_VAR(_zero_arr_plus_double);
MAKE_VAR(_zero_arr_plus_longdouble);
MAKE_VAR(_zero_arr_plus_voidstar);
MAKE_VAR(_dyneither_ptr_inplace_plus);
MAKE_VAR(_zero_arr_inplace_plus); // NOT SURE WHETHER WE NEED BOTH?
MAKE_VAR(_zero_arr_inplace_plus_char);
MAKE_VAR(_zero_arr_inplace_plus_short);
MAKE_VAR(_zero_arr_inplace_plus_int);
MAKE_VAR(_zero_arr_inplace_plus_float);
MAKE_VAR(_zero_arr_inplace_plus_double);
MAKE_VAR(_zero_arr_inplace_plus_longdouble);
MAKE_VAR(_zero_arr_inplace_plus_voidstar);
MAKE_VAR(_dyneither_ptr_inplace_plus_post);
MAKE_VAR(_zero_arr_inplace_plus_post); // NOT SURE WHETHER WE NEED BOTH?
MAKE_VAR(_zero_arr_inplace_plus_post_char);
MAKE_VAR(_zero_arr_inplace_plus_post_short);
MAKE_VAR(_zero_arr_inplace_plus_post_int);
MAKE_VAR(_zero_arr_inplace_plus_post_float);
MAKE_VAR(_zero_arr_inplace_plus_post_double);
MAKE_VAR(_zero_arr_inplace_plus_post_longdouble);
MAKE_VAR(_zero_arr_inplace_plus_post_voidstar);
MAKE_VAR(_cycalloc);
MAKE_VAR(_cyccalloc);
MAKE_VAR(_cycalloc_atomic);
MAKE_VAR(_cyccalloc_atomic);
MAKE_VAR(_region_malloc);
MAKE_VAR(_region_calloc);
MAKE_VAR(_check_times);
MAKE_VAR(_new_region);
MAKE_VAR(_push_region);
MAKE_VAR(_pop_region);
MAKE_VAR(_throw_arraybounds);
MAKE_VAR(_dyneither_ptr_decrease_size);
MAKE_VAR(_throw_match);
MAKE_VAR(_rethrow);
MAKE_VAR(_fast_region_malloc);

#undef MAKE_STRING
#undef MAKE_VAR

static datatype Type.AggrType dyneither_ptr_typ_v =
    AggrType(AggrInfo(AggrInfoU{.UnknownAggr = $(StructA,&_dyneither_ptr_pr,NULL)},NULL));

static datatype Type @ dyneither_ptr_typ = &dyneither_ptr_typ_v;

static tqual_t mt_tq = Tqual(false,false,false,false,0);

static stmt_t skip_stmt_dl() {
  return skip_stmt(DL);
}

static $(list_t<designator_t>,exp_t)@ make_field(var_t name,exp_t e) {
  return new $(new List(new FieldName(name),NULL), e);
}

// These constructors are useful when we want to just update the
// raw part of an expression or statement.
static exp_t cast_it(type_t t, exp_t e) {
  switch (e->r) {
  case &Cast_e(_,e,_,No_coercion): return cast_it(t,e);
  default: return cast_exp(t,e,false,No_coercion,DL);
  }
}
static raw_exp_t cast_it_r(type_t t, exp_t e) {
  return new Cast_e(t,e,false,No_coercion);
}
static raw_exp_t deref_exp_r(exp_t e) {
  return new Deref_e(e);
}
static raw_exp_t subscript_exp_r(exp_t e1, exp_t e2) {
  return new Subscript_e(e1,e2);
}
static raw_exp_t stmt_exp_r(stmt_t s) {
  return new StmtExp_e(s);
}
static raw_exp_t sizeoftyp_exp_r(type_t t) {
  return new Sizeoftyp_e(t);
}
static raw_exp_t fncall_exp_r(exp_t e, list_t<exp_t,`H> es) {
  return new FnCall_e(e,es,NULL,true);
}
static raw_stmt_t exp_stmt_r(exp_t e) {
  return new Exp_s(e);
}
static raw_stmt_t seq_stmt_r(stmt_t s1, stmt_t s2) {
  return new Seq_s(s1,s2);
}
static raw_exp_t conditional_exp_r(exp_t e1, exp_t e2, exp_t e3) {
  return new Conditional_e(e1,e2,e3);
}
static raw_exp_t aggrmember_exp_r(exp_t e, field_name_t n) {
  return new AggrMember_e(e,n,false,false);
}
static raw_exp_t aggrarrow_exp_r(exp_t e, field_name_t n) {
  return new AggrArrow_e(e,n,false,false);
}
static raw_exp_t unresolvedmem_exp_r(opt_t<typedef_name_t,`H> tdopt,
                                     list_t<$(list_t<designator_t,`H>,exp_t)@`H,`H> ds)
{
  return new UnresolvedMem_e(tdopt,ds);
}
static raw_stmt_t goto_stmt_r(var_t v) {
  return new Goto_s(v);
}
static datatype Raw_exp.Const_e zero_exp = Const_e(Cnst{.Int_c= $(Signed,0)});

// same as aggrmember_e(e,f,DL) but when e is a deref_e(e1), replaces with
// aggrarrow_e(e1,f,DL)
static exp_t member_exp(exp_t e, field_name_t f, seg_t loc) {
  switch (e->r) {
  case &Deref_e(e1): return aggrarrow_exp(e1,f,loc);
  default: return aggrmember_exp(e,f,loc);
  }
}

// functionSets are used to call the appropriate function from
// cyc_include.h by casing on the type of the arguments
struct functionSet {
  exp_t fchar; 
  exp_t fshort;
  exp_t fint; 
  exp_t ffloat;
  exp_t fdouble; 
  exp_t flongdouble;
  exp_t fvoidstar;
};

struct functionSet _zero_arr_plus_functionSet = functionSet {
  .fchar = &_zero_arr_plus_char_ev,
  .fshort = &_zero_arr_plus_short_ev,
  .fint = &_zero_arr_plus_int_ev,
  .ffloat = &_zero_arr_plus_float_ev,
  .fdouble = &_zero_arr_plus_double_ev,
  .flongdouble = &_zero_arr_plus_longdouble_ev,
  .fvoidstar = &_zero_arr_plus_voidstar_ev
};
struct functionSet _get_zero_arr_size_functionSet = {
  .fchar = &_get_zero_arr_size_char_ev,
  .fshort = &_get_zero_arr_size_short_ev,
  .fint = &_get_zero_arr_size_int_ev,
  .ffloat = &_get_zero_arr_size_float_ev,
  .fdouble = &_get_zero_arr_size_double_ev,
  .flongdouble = &_get_zero_arr_size_longdouble_ev,
  .fvoidstar = &_get_zero_arr_size_voidstar_ev
};
struct functionSet _zero_arr_inplace_plus_functionSet = {
  .fchar = &_zero_arr_inplace_plus_char_ev,
  .fshort = &_zero_arr_inplace_plus_short_ev,
  .fint = &_zero_arr_inplace_plus_int_ev,
  .ffloat = &_zero_arr_inplace_plus_float_ev,
  .fdouble = &_zero_arr_inplace_plus_double_ev,
  .flongdouble = &_zero_arr_inplace_plus_longdouble_ev,
  .fvoidstar = &_zero_arr_inplace_plus_voidstar_ev
};
struct functionSet _zero_arr_inplace_plus_post_functionSet = {
  .fchar = &_zero_arr_inplace_plus_post_char_ev,
  .fshort = &_zero_arr_inplace_plus_post_short_ev,
  .fint = &_zero_arr_inplace_plus_post_int_ev,
  .ffloat = &_zero_arr_inplace_plus_post_float_ev,
  .fdouble = &_zero_arr_inplace_plus_post_double_ev,
  .flongdouble = &_zero_arr_inplace_plus_post_longdouble_ev,
  .fvoidstar = &_zero_arr_inplace_plus_post_voidstar_ev
};

// choose which function to call based on argument type
static exp_t getFunctionType(struct functionSet @fS, type_t t) {
  exp_t function;
  switch(compress(t)) {
  case &IntType(_,sz):
    switch(sz) {
    case Char_sz:  function = fS->fchar;  break;
    case Short_sz: function = fS->fshort; break;
    case Int_sz:   function = fS->fint;   break;
    default: toc_impos("impossible IntType (not char, short or int)");
    }
    break;
  case &FloatType(0): function = fS->ffloat;      break;
  case &FloatType(1): function = fS->fdouble;     break;
  case &FloatType(_): function = fS->flongdouble; break;
  case &PointerType(_): function = fS->fvoidstar; break;
  default: toc_impos("impossible expression type %s (not int, float, double, or pointer)",typ2string(t));
  }
  return function;
}
static exp_t getFunctionRemovePointer(struct functionSet @fS, exp_t arr) {
  switch (compress((type_t)arr->topt)) {
  case &PointerType(PtrInfo{.elt_typ = et,...}): return getFunctionType(fS,et);
  default: toc_impos("impossible type (not pointer)");
  }
}

///////////////////////////// Various Utilities /////////////////////////////

static bool is_array_type(type_t t) {
  switch (compress(t)) {
  case &ArrayType(_): return true;
  default: return false;
  }
}

/*FIX: this is duplicated in tcutil; but the functions are slightly different */
static bool is_zero(exp_t e) {
  switch (e->r) {
  case &Const_e({.Char_c = $(_,c)}): return c == '\0';
  case &Const_e({.Wchar_c = s}):
    let l = strlen(s);
    int i = 0;
    if (l>=2 && s[0] == '\\') {
      if (s[1] == '0') i = 2; // octal
      else if (s[1] == 'x' && l>=3 && s[2] == '0') i = 3; // hex
      else return false;
      for (; i<l; i++) // remaining chars must be '0'
        if (s[i] != '0') return false;
      return true;
    }
    else return false;
  case &Const_e({.Short_c = $(_,i)}):    return i == 0;
  case &Const_e({.Int_c = $(_,i)}):      return i == 0;
  case &Const_e({.LongLong_c = $(_,i)}): return i == 0;
  case &Pragma_e(...):
  case &Const_e({.Null_c = _}): return true;
  case &Cast_e(_,e1,_,_): return is_zero(e1);
  case &Tuple_e(es): return List::forall(is_zero,es);
  case &Array_e(dles):         fallthru(dles);
  case &Aggregate_e(_,_,dles,_):  fallthru(dles);
  case &CompoundLit_e(_,dles): fallthru(dles);
  case &UnresolvedMem_e(_,dles):
    for (; dles != NULL; dles = dles->tl)
      if (!is_zero((*dles->hd)[1])) return false;
    return true;
  default: return false;
  }
}

// If x = X1::X2::...::Xn::v, generate s_X1_X2_..._Xn_v_struct
// DJG: I changed this to use aprintf and rstr_sepstr; no noticeable slowdown
static string_t collapse_qvar(stringptr_t s, qvar_t x) {
  let &$(ns,v) = x;
  switch (ns) {
  case {.Loc_n = _}:  fallthru(NULL);
  case {.Rel_n = vs}: fallthru(vs);
  case {.Abs_n = vs}: fallthru(vs); 
  case {.C_n = vs}: 
    // special-case trims out an '_' which isn't necessary, but we do it
    // (affects the struct name for exception variants)
    if(vs==NULL)
      return aprintf("%s_%s_struct",*s,*v);
    region r;
    return aprintf("%s_%s_%s_struct",*s,rstr_sepstr(r,vs,"_"),*v);
  }
}

// Used when generating the struct name for a datatype field.  
// If fieldname = N1::N2::...::Nn::f and the datatype name is
// M1::M2::...::Mm::d, then we generate the qvar that looks
// like N1::N2::....::Nn::f_M1_M2_..._Mm_d_struct.  
// FIX: this could conflict with a user-defined struct which
// can cause errors at C-compile time. 
static qvar_t collapse_qvars_body<`r2,`d,`r>(region_t<`d> d, 
                                             $(struct TocState<`d>@`d,
                                               $(qvar_t,qvar_t)@`r2)@`r env) {
  let $(&TocState{.qvar_tags = qvs,...}, pair) = *env;
  let $(fieldname,dtname) = *pair;
  try return Dict::lookup_other(*qvs,qvar_tag_cmp,pair);
  catch { case &Dict::Absent:
    let new_pair = new $(fieldname,dtname);
    let &$(nmspace,fieldvar) = fieldname;
    string_t newvar = collapse_qvar(fieldvar,dtname);
    qvar_t res = new $(nmspace, new newvar);
    *qvs = Dict::insert(*qvs,new_pair,res);
    return res;
  }
}

static qvar_t collapse_qvars(qvar_t fieldname,qvar_t dtname) {
  _ env = $(fieldname, dtname);
  return use_toc_state(&env, (collapse_qvars_body@<`collapse_qvars>)<>);
}

// there are several places we generate C struct types
// FIX? by using Rel_n instead of Abs_n, we do not prepend Cyc_
static aggrdecl_t make_c_struct_defn(var_t name, list_t<aggrfield_t,`H> fs) {
  return new Aggrdecl{.kind=StructA, .sc=Public, .tvs=NULL,
		      .attributes=NULL, .expected_mem_kind=false,
		      .name= new $(Rel_n(NULL),name),
		      .impl = new AggrdeclImpl{.exist_vars=NULL,
					       .rgn_po=NULL,
					       .tagged=false,
					       .fields=fs}};
}

// used to generate struct definitions for tuple types
// we share the struct definitions where possible (need to for C compiler!)
static type_t add_tuple_type_body(region_t<`d> d, 
				  $(struct TocState<`d>@`d, 
				    list_t<$(tqual_t,type_t)@`H,`H>)@`r env) {
  let $(&TocState{.tuple_types = tuple_types, ...},tqs0) = *env;
  // look for the same tuple-type already declared
  for (let tts = *tuple_types; tts != NULL; tts = tts->tl) {
    let &$(x,ts) = tts->hd;
    let tqs = tqs0;
    for (; tqs != NULL && ts != NULL; tqs = tqs->tl, ts = ts->tl)
      if (!unify((*tqs->hd)[1],ts->hd))
        break;
    if(tqs == NULL && ts == NULL)
      return x;
  }
  // haven't seen this one before, add a declaration
  // need to set up a real struct declaration for get_varsizeexp and RemoveAggrs
  stringptr_t xname = new (string_t)aprintf("_tuple%d",tuple_type_counter++);
  list_t<type_t> ts = List::rmap(d,snd_tqt,tqs0);
  let fs = NULL;
  list_t<type_t> ts2 = ts;
  for (int i=1; ts2 != NULL; ts2 = ts2->tl, i++)
    fs = new List(new Aggrfield(fieldname(i),mt_tq,ts2->hd,NULL,NULL,NULL),fs);
  fs = List::imp_rev(fs);
  let sd  = make_c_struct_defn(xname,fs);
  let ans = new AggrType(AggrInfo(KnownAggr(new sd),NULL));
  result_decls = new List(new_decl(new Aggr_d(sd),DL),result_decls);
  *tuple_types = rnew(d) List(rnew(d) $(ans,ts),*tuple_types);
  return ans;
}
static type_t add_tuple_type(list_t<$(tqual_t,type_t)@`H,`H> tqs0) {
  return use_toc_state(tqs0, add_tuple_type_body<>);
}

// similar to add_tuple_type, but for anonymous aggregates (should try to share)
static type_t add_anon_aggr_type_body(region_t<`d> d,
				      $(struct TocState<`d>@`d,
					$(aggr_kind_t,list_t<aggrfield_t,`H>)@`H)@`r env) {
  let &$(&TocState{.anon_aggr_types = anon_aggr_types,...},&$(ak,fs)) = env;
  // look for the same type already declared
  for(let ts = *anon_aggr_types; ts != NULL; ts=ts->tl) {
    let &$(x,ak2,fs2) = ts->hd;
    if(ak!=ak2)
      continue;
    if(!list_cmp(Tcutil::aggrfield_cmp,fs2,fs))
      return x;
  }
  // haven't seen this one before, add a declaration
  // need to set up a real struct declaration for get_varsizeexp and RemoveAggrs
  stringptr_t xname = new (string_t)aprintf("_tuple%d",tuple_type_counter++);
  let sd = make_c_struct_defn(xname,fs);
  sd->kind = ak; // might be a union
  let ans = new AggrType(AggrInfo(KnownAggr(new sd),NULL));
  result_decls = new List(new_decl(new Aggr_d(sd),DL),result_decls);
  *anon_aggr_types = rnew(d) List(rnew(d) $(ans,ak,fs),*anon_aggr_types);
  return ans;
}
static type_t add_anon_aggr_type(aggr_kind_t ak, list_t<aggrfield_t,`H> fs) {
  return use_toc_state(new $(ak,fs), add_anon_aggr_type_body<>);
}

// similar to the above, except that we're working with an instantiated
// abstract struct.  The fieldnames are thus drawn from the actual
// struct fields and in addition, we have to worry about the instantiation.
// It's very important that we share as many instantiations as possible
// to get the translation right.  
static type_t 
add_struct_type_body<`r2,`r3,`d,`r>(region_t<`d> d,
				    $(struct TocState<`d>@`d s,
				      $(qvar_t struct_name,
					list_t<tvar_t,`H> type_vars,
					list_t<type_t,`H> type_args,
					list_t<aggrfield_t,`r2> fields)@`r3)@`r env) {
  // first, filter out the type_vars and type_args that are not of
  // type or integer kind.
  let $(&TocState{.abs_struct_types = abs_struct_types, ...},
        &$(struct_name, type_vars, type_args, fields)) = *env;
                                      
  // look for the same instantiation of abstract-struct-type already declared
  for (let tts = *abs_struct_types; tts != NULL; tts = tts->tl) {
    let &$(x,ts2,t) = tts->hd;
    if (qvar_cmp(x,struct_name) == 0 &&
        List::length(type_args) == List::length(ts2)) {
      bool okay = true;
      for (let ts = type_args; ts != NULL; ts=ts->tl, ts2=ts2->tl) {
        let t = ts->hd;
        let t2 = ts2->hd;
        switch (typ_kind(t)) {
        case &Kind{.kind = EffKind, _}: 
        case &Kind{.kind = RgnKind, _}://Effects/regions won't appear in C types
          continue;
        default:
          // Check if they're the same before translating them to C
          if (unify(t,t2) || unify(typ_to_c(t),typ_to_c(t2)))
            continue;
          okay = false; 
          break;
        }
        break;
      }
      if (okay) // found pre-existing type
        return t;
    }
  }
  //fprintf(stderr,"didn't find pre-existing type\n");
  // haven't seen this one before, add a declaration
  // we're calling it a "tuple" so we don't have to worry about name clashes.
  stringptr_t xname = new (string_t)aprintf("_tuple%d",tuple_type_counter++);
  type_t x = strct(xname);
  let fs = NULL;
  // go ahead and add this to the struct types
  *abs_struct_types  = rnew(d) List{rnew(d) $(struct_name,type_args,x),
                                    *abs_struct_types};
  // copy the fields over
  region r;
  let inst = List::rzip(r,r,type_vars,type_args);
  for (; fields != NULL; fields = fields->tl) {
    let f = fields->hd;
    type_t t = f->type;
    attributes_t atts = f->attributes;
    // if the original type was abstract, then we must force the field
    // to be aligned.
    //DJG: FIX I think this is broken for an array with element-type
    //     of abstract mem kind
    if (fields->tl == NULL 
	&& kind_leq(&ak,typ_kind(t))
	&& !is_array_type(t))
      atts = new List(new Aligned_att(NULL),atts);
    t = typ_to_c(rsubstitute(r,inst,t));
    // still could be abstract and end up void -- if so, make it
    // a zero-sized array of void*'s and force it to be aligned.
    if (unify(t,&VoidType_val)) {
      t = new ArrayType(ArrayInfo(void_star_typ(), empty_tqual(DL),
                                  uint_exp(0,DL), new_conref(false), DL));
    }
    fs = new List(new Aggrfield{f->name,mt_tq,t,f->width,atts,NULL},fs);
  }
  fs = List::imp_rev(fs);
  let sd = make_c_struct_defn(xname,fs);
  result_decls = new List(new_decl(new Aggr_d(sd),DL),result_decls);
  return x;
}

static type_t add_struct_type(qvar_t struct_name,
                              list_t<tvar_t,`H> type_vars,
                              list_t<type_t,`H> type_args,
                              list_t<aggrfield_t,`r> fields) {
  _ env = $(struct_name, type_vars, type_args, fields);
  return use_toc_state(&env, (add_struct_type_body@<`r,`add_struct_type>)<>);
}


// generate a temporary variable
// FIX: need to guarantee these can't conflict
// FIX: we share labels but not variables (why?)
qvar_t temp_var() {
  return new $(Loc_n,new (string_t)aprintf("_tmp%X",temp_var_counter++));
}

// generate a fresh label
// FIX: need to guarantee these can't conflict
static var_t fresh_label_body<`d,`r>(region_t<`d> d, $(struct TocState<`d>@`d,int)@`r env) {
  let $(&TocState{.temp_labels = temp_labels, ...},_) = *env;
  let i = fresh_label_counter++;
  if (i < Xarray::length(temp_labels))
    return Xarray::get(temp_labels,i);
  var_t res = new (string_t)aprintf("_LL%X",i);
  if (Xarray::add_ind(temp_labels,res) != i)
    toc_impos("fresh_label: add_ind returned bad index...");
  return res;
}

static var_t fresh_label() {
  return use_toc_state(0, fresh_label_body<>);
}

// This should never be used for xdatatypes. Should memoize?
// The former used to use static const int variables, but couldn't at top-level.
static exp_t datatype_tag(datatypedecl_t td, qvar_t name) {
  int ans = 0;
  let fs  = td->fields->v;
  while(qvar_cmp(name,fs->hd->name)!=0) {
    ++ans;
    fs = fs->tl;
  }
  return uint_exp(ans,DL);
}

///////////////////////////////////////////////////////////////
//         Convert a Cyclone type to a C type                //
///////////////////////////////////////////////////////////////
static void enumdecl_to_c(enumdecl_t ed);
static void aggrdecl_to_c(aggrdecl_t ad, bool add_to_result_decls);
static void datatypedecl_to_c(datatypedecl_t tud);
static $(var_opt_t,tqual_t,type_t)@ arg_to_c($(var_opt_t,tqual_t,type_t)@ a) {
  let $(x,y,z) = *a;
  return new $(x,y,typ_to_c(z));
}

// Sometimes we translate arrays t[] and t[N] to t*, and sometimes
// we leave them alone.  We must leave them alone in the following
// circumstances:
// 1. as the argument of sizeof
// 2. in typedef
// 3. in declarations
// 4. as the element type of an array
// 5. as the type part of a C9X compound literal
// 6. as the type of a struct field
// We must change them to pointers in the following circumstances:
// 1. as the argument of cast
// We can do either in the following circumstances:
// 1. as the parameter of a function
// The function typ_to_c_array changes them, while typ_to_c
// changes them to pointers.
static type_t typ_to_c_array(type_t t) {
  switch(compress(t)) {
  case &ArrayType(ArrayInfo{t2,tq,x,zt,ztl}): // FIX: do we handle tq correctly?
    return cstar_typ(typ_to_c_array(t2),tq);
  case &Evar(_,t2,_,_) && t2 != NULL: return typ_to_c_array((type_t)t2);
  default: return typ_to_c(t);
  }
}

static aggrfield_t aggrfield_to_c(aggrfield_t f, type_t new_type) {
  // JGM: I'm making the qualifiers non-const here to allow initialization
  let ans = new *f;
  ans->type = new_type;
  ans->requires_clause = NULL;
  ans->tq = mt_tq;
  return ans;
}

static void enumfields_to_c(list_t<enumfield_t> fs) {
  // warning: assumes all constant expressions are fine as C expressions
  return;
}

static type_t char_star_typ() {
  static type_t* cs = NULL;
  if (cs == NULL)
    cs = new star_typ(char_typ,&HeapRgn_val,mt_tq,false_conref);
  return *cs;
}
static type_t rgn_typ() {
  static type_t* r = NULL;
  if (r == NULL)
    r = new cstar_typ(strct(_RegionHandle_sp),mt_tq);
  return *r;
}
static type_t dyn_rgn_typ() {
  static type_t* r = NULL;
  if (r == NULL)
    r = new cstar_typ(strct(_DynRegionHandle_sp),mt_tq);
  return *r;
}
static bool is_boxed_tvar(type_t t) {
  switch (compress(t)) {
  case &VarType(tv): return kind_leq(typ_kind(t),&tbk);
  default: return false;
  }
}
static bool is_abstract_type(type_t t) {
  switch (typ_kind(t)) {
  case &Kind{.kind = AnyKind, ...}: return true;
  default: return false;
  }
}

type_t typ_to_c(type_t t) {
  switch (t) {
  case &VoidType: return t;
  case &Evar(_,*t2,_,_): 
    if (*t2 == NULL) {
      *t2 = sint_typ;
      return sint_typ;
    }
    return typ_to_c((type_t)(*t2));
  case &VarType(tv):
    if (tvar_kind(tv,&bk)->kind == AnyKind) {
//     fprintf(stderr,"Mapping type var %s to void; has AnyKind\n",*(tv->name));
      return &VoidType_val;
    }
    else return void_star_typ(); // map `a to void *
  case &DatatypeType(_):
    return &VoidType_val;
  case &DatatypeFieldType(DatatypeFieldInfo{{.KnownDatatypefield=$(tud,tuf)},_}):
    return strctq(collapse_qvars(tuf->name,tud->name));
  case &DatatypeFieldType(_): toc_impos("unresolved DatatypeFieldType");
  case &PointerType(PtrInfo(t2,tq,PtrAtts(_,_,bnds,_,_))):
    // t2? maps to struct dyneither_ptr.
    // t2* and t2@ map to t2*.  Regions and zero-term are irrelevant.
    t2 = typ_to_c(t2);
    switch (conref_def((bounds_t)&DynEither_b_val,bnds)) {
    case &DynEither_b: return dyneither_ptr_typ;
    default: return star_typ(t2,&HeapRgn_val,tq,false_conref);
    }
  case &IntType(_,_):
  case &FloatType(_): return t;
  case &ArrayType(ArrayInfo{t2,tq,e,_,ztl}):
    return array_typ(typ_to_c(t2),tq,e,false_conref,ztl);
  case &FnType(FnInfo{_,_,tq2,t2,args,c_vararg,cyc_vararg,_,atts,_,_,_,_}):
    // just drop the type arguments & effect and translate the nested types
    // also, drop any format descriptors
    // FIX:  problem with higher-order functions?  Again C's rules are strange.
    // FIX:  dropping noreturn and const attributes b/c C is complaining.
    let new_atts = NULL;
    for (; atts != NULL; atts = atts->tl)
      switch (atts->hd) {
      case &Noreturn_att:
      case &Const_att:
      case &Format_att(_,_,_): continue;
      case &Noconsume_att(_): continue; // correct: a Cyclone addition
      case &Noliveunique_att(_): continue; // correct: a Cyclone addition
      case &Initializes_att(_): continue; // correct: a Cyclone addition
      default: new_atts = new List(atts->hd,new_atts); break;
      }
    let new_args = List::map(arg_to_c,args);
    if (cyc_vararg != NULL) {
      // region for array type irrelevant
      let t =typ_to_c(dyneither_typ(cyc_vararg->type,&HeapRgn_val,mt_tq,false_conref));
      let vararg = new $(cyc_vararg->name,cyc_vararg->tq,t);
      new_args = List::imp_append(new_args,new List(vararg,NULL));
    }
    return new FnType(FnInfo{NULL,NULL,tq2,typ_to_c(t2),new_args,
                               c_vararg,NULL,NULL,new_atts,NULL,NULL,NULL,NULL});
  case &TupleType(tqs):
    // $(t1,...,tn) maps to struct tuple_type_n where we define
    // struct tuple_type_n { t1 f1; ...; tn fn; };
    let tqs2 = NULL;
    for(; tqs != NULL; tqs=tqs->tl)
      tqs2 = new List(new $((*tqs->hd)[0],typ_to_c((*tqs->hd)[1])),tqs2);
    return add_tuple_type(imp_rev(tqs2));
  // FIX: we may have to actually declare these things and use them
  // consistently to make GCC happy.
  case &AnonAggrType(k,fs):
    // similar to tuple translation (introduce sharing to appease C)
    // but we have full aggrfields to deal with
    let fs2 = NULL;
    for(; fs!=NULL; fs=fs->tl) 
      fs2 = new List(aggrfield_to_c(fs->hd,typ_to_c(fs->hd->type)), fs2);
    return add_anon_aggr_type(k,imp_rev(fs2));
  case &AggrType(AggrInfo(info,ts)):
    // If we are in C code, the implementation may not be set here.
    switch (info) {
    case {.UnknownAggr = _}: return t;
    default: break;
    }
    let ad = get_known_aggrdecl(info);
    if (ad->expected_mem_kind) {
      // check that it turned out to be a mem!
      if (ad->impl == NULL) 
        warn(0, "%s %s was never defined.",
	     (ad->kind==UnionA) ? "union" : "struct",
	     qvar2string(ad->name));
    }
    // XXX I think this is where new instantiation types are
    // generated; want to adapt this for unions here.
    // Have to watch out for flaky gcc ...
    if(ad->kind==UnionA)
      return aggrdecl_type(ad->name,unionq_typ);
    let fs = (ad->impl == NULL) ? NULL : ad->impl->fields;
    if (fs == NULL) return aggrdecl_type(ad->name,strctq);
    for (; fs->tl != NULL; fs = fs->tl);
    let last_type = fs->hd->type;
    if (kind_leq(&ak,typ_kind(last_type))) {
      if (ad->expected_mem_kind) {
        warn(0, "struct %s ended up being abstract.", qvar2string(ad->name));
      }                     
      // To avoid looping, make sure the instantiation of the last
      // type is not still abstract.  If it is, we can just return
      // the struct type.
      region r;
      let inst = rzip(r,r,ad->tvs,ts);
      let t = rsubstitute(r,inst,last_type);
      if (is_abstract_type(t)) return aggrdecl_type(ad->name,strctq);
      return add_struct_type(ad->name,ad->tvs,ts,ad->impl->fields);
    }
    return aggrdecl_type(ad->name,strctq);
  case &EnumType(tdn,_): return t;
  case &AnonEnumType(fs): enumfields_to_c(fs); return t;
  case &TypedefType(tdn,ts,td,topt):
    // just drop the type arguments and translate the nested types
    // typedef expansion is done in Absynpp::to_tms.
    if (topt == NULL) {
      if (ts != NULL)
        return new TypedefType(tdn,NULL,td,NULL);
      else return t;
    } else 
      return new TypedefType(tdn,NULL,td,typ_to_c((type_t)topt));
  case &TagType(_): return uint_typ; // must be unsigned!
  case &RgnHandleType(_): return rgn_typ();
  case &DynRgnType(_,_): return dyn_rgn_typ();
  // these types get translated when we instantiate aggregates with
  // abstract members -- we just translate them to void* to save pain.
  case &HeapRgn:
  case &UniqueRgn:
  case &RefCntRgn:
  case &AccessEff(_):
  case &JoinEff(_):
  case &RgnsEff(_): return void_star_typ();
    // FIX: when we instantiate a struct parameterized by `i::I with
    // valueof_t(42), then we want the 42 to get propagated to any arrays
    // that might occur within.  So, for now, we don't do any translation.
    // This will bite me somewhere else...
  case &ValueofType(e): return t;
    // FIX: we really need to translate e!
  case &TypeofType(e): return t;
  case &BuiltinType(...): return t;
  case &TypeDeclType(&{.r = &Aggr_td(ad),...},_):
    aggrdecl_to_c(ad,true);
    if (ad->kind==UnionA)
      return aggrdecl_type(ad->name,unionq_typ);
    else return aggrdecl_type(ad->name,strctq);
  case &TypeDeclType(&{.r = &Enum_td(ed),...},_):
    enumdecl_to_c(ed);
    return t;
  case &TypeDeclType(&{.r = &Datatype_td(dd),...},t):
    datatypedecl_to_c(dd);
    return typ_to_c(*t);
  }
}

static exp_t array_to_ptr_cast(type_t t,exp_t e,seg_t l) {
  switch (t) {
  case &ArrayType(ArrayInfo{t2,tq,_,_,_}):
    return cast_it(star_typ(t2,&HeapRgn_val,tq,false_conref),e);
  default: return cast_it(t,e);
  }
}

// returns true when the type contains no pointers. Is conservative
// (does not look at instantiations)
static bool atomic_typ(type_t t) {
  switch (compress(t)) {
  case &VoidType:      return true;
  case &VarType(_):    return false;
  case &IntType(_,_):
  case &EnumType(_,_):
  case &AnonEnumType(_):
  case &FloatType(_):
  case &FnType(_):
  case &TagType(_): return true;
  case &ArrayType(ArrayInfo{t,...}): return atomic_typ(t);
    // FIX: really should compute in terms of the instantiation
    // to be as aggressive as possible.
    // note even without this we'll allocate Position::seg_t with atomic.
    // NOTE: cannot call get_known_aggrdecl b/c we sometimes call this
    // post-translation (with unchecked C types)?? (We shouldn't)
  case &AggrType(AggrInfo(info,_)):
    switch(info) {
    case {.UnknownAggr = _}: return false; // see above!
    default: break;
    }
    let ad = get_known_aggrdecl(info);
    if(ad->impl == NULL)
      return false;
    for(let fs = ad->impl->fields; fs != NULL; fs = fs->tl)
      if (!atomic_typ(fs->hd->type)) return false;
    return true;
  case &AnonAggrType(_,fs):
    for (; fs != NULL; fs = fs->tl)
      if (!atomic_typ(fs->hd->type)) return false;
    return true;
  case &DatatypeFieldType(DatatypeFieldInfo{{.KnownDatatypefield=$(tud,tuf)},_}):
    fallthru(tuf->typs);
  case &TupleType(tqs):
    for (; tqs != NULL; tqs = tqs->tl)
      if (!atomic_typ((*tqs->hd)[1])) return false;
    return true;
    // FIX: can do better if all variants are fieldless (but then they could
    //      have used an enum)
  case &DatatypeType(_):
  case &PointerType(_):
  case &DynRgnType(_,_):
  case &RgnHandleType(_): return false;
  default: toc_impos("atomic_typ:  bad type %s",typ2string(t));
  }
}

static bool is_void_star(type_t t) {
  switch (compress(t)) {
  case &PointerType(PtrInfo{t2,_,_}):
    switch (compress(t2)) {
    case &VoidType: return true;
    default:        return false;
    }
  default: return false;
  }
}

static bool is_void_star_or_boxed_tvar(type_t t) {
  return is_void_star(t) || is_boxed_tvar(t);
}

static bool is_pointer_or_boxed_tvar(type_t t) {
  return is_pointer_type(t) || is_boxed_tvar(t);
}

// returns true when field f of the struct/union t has type void*.
static bool is_poly_field(type_t t, field_name_t f) {
  switch (compress(t)) {
  case &AggrType(AggrInfo(info,_)):
    let ad = get_known_aggrdecl(info);
    if (ad->impl == NULL)
      toc_impos("is_poly_field: type missing fields");
    fallthru(ad->impl->fields);
  case &AnonAggrType(_,fs):
    let field = lookup_field(fs,f);
    if (field == NULL)
      toc_impos("is_poly_field: bad field %s",*f);
    return is_void_star_or_boxed_tvar(field->type);
  default: toc_impos("is_poly_field: bad type %s",typ2string(t));
  }
}

// returns true when e is projection of a field in a struct that has a
// variable type before instantiation.  For instance, the field hd has
// type `a before instantiation in struct List.
static bool is_poly_project(exp_t e) {
  switch (e->r) {
  case &AggrMember_e(e1,f,_,_): 
    return is_poly_field((type_t)e1->topt,f) && 
      !is_void_star_or_boxed_tvar((type_t)e->topt);
  case &AggrArrow_e(e1,f,_,_):
    switch (compress((type_t)e1->topt)) {
    case &PointerType(PtrInfo{t,_,_}): 
      return is_poly_field(t,f) && !is_void_star_or_boxed_tvar((type_t)e->topt);
    default: toc_impos("is_poly_project: bad type %s",typ2string((type_t)e1->topt));
    }
  default: return false;
  }
}

// possible pointer malloc
static exp_t malloc_ptr(exp_t s) {
  return fncall_exp(_cycalloc_e, new List(s,NULL),DL);
}
// no pointers possible malloc
static exp_t malloc_atomic(exp_t s) {
  return fncall_exp(_cycalloc_atomic_e, new List(s,NULL),DL);
}
// malloc something -- choose malloc routine according to the (Cyclone) type
static exp_t malloc_exp(type_t t,exp_t s) {
  if (atomic_typ(t))
    return malloc_atomic(s);
  return malloc_ptr(s);
}
// region malloc something
static exp_t rmalloc_exp(exp_t rgn, exp_t s) {
  return fncall_exp(_region_malloc_e, list(rgn,s), DL);
}
// region malloc (inlined) something
static exp_t rmalloc_inline_exp(exp_t rgn, exp_t s) {
  return fncall_exp(_fast_region_malloc_e, list(rgn,s), DL);
}
// calloc something
static exp_t calloc_exp(type_t elt_type, exp_t s, exp_t n) {
  if (atomic_typ(elt_type))
    return fncall_exp(_cyccalloc_atomic_e, list(s,n), DL);
  else
    return fncall_exp(_cyccalloc_e, list(s,n), DL);
}
// rcalloc something
static exp_t rcalloc_exp(exp_t rgn, exp_t s, exp_t n) {
  return fncall_exp(_region_calloc_e, list(rgn,s,n), DL);
}
// throw an exception -- this is turned into a function call
static exp_t newthrow_exp(exp_t e) {
  return fncall_exp(_throw_e, new List(e,NULL), DL);
}
static exp_t newrethrow_exp(exp_t e) {
  return fncall_exp(_rethrow_e, new List(e,NULL), DL);
}
// throw a match exception
static stmt_t throw_match_stmt() {
  return exp_stmt(fncall_exp(_throw_match_e,list(),DL),DL);
}

// t*{sz} -> t? at top-level
static exp_t make_toplevel_dyn_arr(type_t t, exp_t sz, exp_t e) {
  // Note e must be either (a) a string or else (b) a [possibly cast]
  // identifier that is an array.
  // For case a, we generate
  //   t x[sz] = e;
  //   {x,x,x+sz};
  // For case b, we generate
  //   {e,e,e+sz};
  bool is_string = false;
  switch (e->r) {
  case &Const_e({.String_c  = _}): 
  case &Const_e({.Wstring_c = _}): is_string = true; break;
  default: break;
  }
  exp_t xexp;
  exp_t xplussz;
  if (is_string) {
    qvar_t    x      = temp_var();
    type_t    vd_typ = array_typ(char_typ,mt_tq,sz,false_conref,DL);
    vardecl_t vd     = static_vardecl(x,vd_typ,e);
    result_decls = new List(new_decl(new Var_d(vd),DL),result_decls);
    xexp = var_exp(x,DL);
    xplussz = add_exp(xexp,sz,DL);
  } else {
    xexp = cast_it(void_star_typ(),e);
    // Note: If e is NULL, element size of 0 is fine!
    xplussz = cast_it(void_star_typ(),add_exp(e,sz,DL));
  }
  return unresolvedmem_exp(NULL,list(new $(NULL,xexp),
				     new $(NULL,xexp),
				     new $(NULL,xplussz)),DL);
}

///////////////////////////////////////////////////////////////
//              Translation Environments                     //
///////////////////////////////////////////////////////////////
// When break_lab is NULL, translate break to break.  Otherwise,
// translate break to goto of the given label.  Similarly for
// continue.  This is used in the translation of switches and
// exception handlers to get the right control-flow.
//
// Translation of fallthru(e1,...,en) is
// v1 = trans(e1); ... vn = trans(en);
// goto fallthru_info->v[0]
// where the ith element of fallthru_info->v[1] is vi
//
// We can alpha-convert just by mutating a vd->name.  When we hoist
// a declaration (in pattern-compilation), we must alpha-convert.
static struct FallthruInfo<`r::R> {
  var_t label;
  list_t<vardecl_t> binders;
};

static struct Env<`r::R> {
  <`r2::R> : {`r2} > `r
  var_t *`r       break_lab;
  var_t *`r       continue_lab;
  struct FallthruInfo<`r2> *`r2 fallthru_info;
  bool toplevel;
  bool @`r2 in_lhs;
  bool @`r2 in_sizeof;
  region_t<`r> rgn;
};
typedef struct Env<`r> @`r env_t<`r>;

static bool is_toplevel(env_t nv) {
  let &Env{.toplevel=t,...} = nv;
  return t;
}
static bool in_lhs(env_t nv) {
  let &Env{.in_lhs=b,...} = nv;
  return *b;
}

// the empty environment
static env_t<`r> empty_env(region_t<`r> r) {
  return rnew(r) Env{.break_lab     = NULL,
                     .continue_lab  = NULL,
                     .fallthru_info = NULL,
                     .toplevel      = true,
                     .in_lhs        = rnew(r) false,
                     .in_sizeof     = rnew(r) false,
                     .rgn           = r};
}

static env_t<`r> share_env(region_t<`r> r, env_t<`r2> e : {`r2} > `r) {
  let &Env{b,c,f,t,lhs,sz,_} = e;
  return rnew(r) Env{b,c,f,t,lhs,sz,r};
}

static env_t<`r> clear_toplevel(region_t<`r> r, env_t<`r2> e : {`r2} > `r) {
  let &Env{b,c,f,t,lhs,sz,_} = e;
  return rnew(r) Env{b,c,f,false,lhs,sz,r};
}
static env_t<`r> set_toplevel(region_t<`r> r, env_t<`r2> e : {`r2} > `r) {
  let &Env{b,c,f,t,lhs,sz,_} = e;
  return rnew(r) Env{b,c,f,true,lhs,sz,r};
}
static void set_lhs(env_t<`r> e, bool b) {
  let &Env{.in_lhs = lhs,...} = e;
  *lhs = b;
}
static bool set_in_sizeof(env_t<`r> e, bool b) {
  let &Env{.in_sizeof = sz,...} = e;
  let old_b = *sz;
  *sz = b;
  return old_b;
}
static bool in_sizeof(env_t<`r> e) {
  let &Env{.in_sizeof = sz,...} = e;
  return *sz;
}

// env for loop body: break and continue labels are set to null,
// exception handler pop counters for break and continue are zeroed
static env_t<`r> loop_env(region_t<`r> r, env_t<`r2> e : {`r2} > `r) {
  let &Env{b,c,f,t,lhs,sz,_} = e;
  return rnew(r) Env{NULL,NULL,f,t,lhs,sz,r};
}

// env for a switch clause: give new label for break, and zero its pop counter
static env_t<`r>
non_last_switchclause_env(region_t<`r> r, env_t<`r2> e, 
			  var_t break_l, var_t fallthru_l,
                          list_t<vardecl_t,`H> fallthru_binders : {`r2} > `r) {
  let &Env{b,c,f,t,lhs,sz,_} = e;
  struct FallthruInfo<`r>*`r fi =
    rnew(r) FallthruInfo{fallthru_l,fallthru_binders};
  return rnew(r) Env{rnew(r) break_l, c, fi, t,lhs,sz,r};
}

static env_t<`r>
last_switchclause_env(region_t<`r> r, env_t<`r2> e, var_t break_l :{`r2} > `r) {
  let &Env{b,c,f,t,lhs,sz,_} = e;
  return rnew(r) Env{rnew(r) break_l, c,NULL,t,lhs,sz,r};
}

// must have no pattern vars and type is int, char, or datatype of a type
// with no value constructors. (If it weren't for allowing fallthru
// anywhere, we wouldn't need the next_l.)
static env_t<`r>
switch_as_switch_env(region_t<`r> r, env_t<`r2> e, var_t next_l :
                     {`r2} > `r) {
  let &Env{b,c,f,t,lhs,sz,_} = e;
  return rnew(r) Env{NULL,c, rnew(r) FallthruInfo{next_l,NULL}, t,lhs,sz,r};
}

#ifdef COARSE_REGIONS
#define TOC_RGN(env,r) let &Env{.rgn = r, ...} = (env);
#else
#define TOC_RGN(env,r) region r;
#endif

///////////////////////////////////////////////////////////////
//              Translation of Expressions                   //
///////////////////////////////////////////////////////////////
static void exp_to_c(env_t nv, exp_t e); // forward declaration
static void stmt_to_c(env_t nv, stmt_t s); // forward declaration

static bool need_null_check(exp_t e) { // e must be pre-translation!
  //fprintf(stderr,"checking need_null_check on %s\n",exp2string(e));
  switch(e->annot) {
  case &CfFlowInfo::UnknownZ(_): 
    //fprintf(stderr,"annotation is unknown\n");
    switch (compress((type_t)e->topt)) {
    case &PointerType(PtrInfo(_,_,PtrAtts(_,n,...))): 
      //fprintf(stderr,"pointer type is %s\n",conref_def(false,n) ? "nullable" : "notnull");
      return conref_def(false,n);
    default: toc_impos("Toc::is_nullable");
  }
  case &CfFlowInfo::NotZero(_):  
    //fprintf(stderr,"annotation is notzero\n");
    return false;
  case &CfFlowInfo::IsZero:
    terr(e->loc,"NULL pointer check will definitely fail");
    return false;
  case &EmptyAnnot:
    // warning is unfounded under sizeof as in memcpy
    // Tcutil::warn(e->loc,"unreachable dereference");
    //fprintf(stderr,"annotation is empty\n");
    return true;
  default: toc_impos("need_null_check");
  }
}

static Relations::relns_t get_relns(exp_t e) { // e must be pre-translation!
  switch (e->annot) {
  case &CfFlowInfo::UnknownZ(r): return r;
  case &CfFlowInfo::NotZero(r):  return r;
  case &CfFlowInfo::IsZero:
    terr(e->loc,"dereference of NULL pointer");
    return NULL;
  case &EmptyAnnot: return NULL;
  default: toc_impos("get_relns");
  }
}

// return true if we can prove from relns that i < numelts(a)
//  FIX: doesn't deal with the case where i is a constant and a's size
//  can be found.
static bool check_bounds(type_t a_typ, Relations::relns_t<`H> relns,
                         exp_t a, exp_t i) {
#ifdef BCE_DEBUG
  fprintf(stderr,"bounds check on %s:%s and %s\n",exp2string(a),
          typ2string(a_typ),exp2string(i));
  fprintf(stderr,"relns: ["); Relations::print_relns(stderr,relns);
  fprintf(stderr,"]\n");
#endif
  // if a has type T*{x} or T[x], then we can pretend like it's
  // a variable to get the rest of this code to work out.
  Relations::reln_op_t rop_i = Relations::RConst(0); // dummy value
  bool valid_rop_i = Relations::exp2relnop(i,&rop_i);

  vardecl_t x;
  switch (a->r) {
  case &Var_e(b):
    let x1 = Tcutil::nonesc_vardecl(b);
    if (x1 == NULL) fallthru;
    x = (vardecl_t)x1;
    break;
  default:
    // we're going to fake up a vardecl here
    static string_t bogus_string = "*bogus*";
    static $(nmspace_t,var_t) bogus_qvar =
      $(Nmspace{.Loc_n = 0},&bogus_string);
    static struct Vardecl bogus_vardecl =
      {.sc = Public, .name = &bogus_qvar,.varloc =0,
     .tq = Tqual{false,false,false,false,0},
     .type = &VoidType_val, .initializer = NULL, .rgn = NULL,
     .attributes = NULL, .escapes = false};

    x = &bogus_vardecl;
    x->type = a_typ;
  }
  // We need to temporarily swap in the original type of the
  // expression so that we have size information correct for
  // the relations machinery.  
  let xtype = a_typ;
  let oldtype = x->type;
  x->type = xtype;
  Relations::reln_op_t rop_a = Relations::RNumelts(x);

  //fprintf(stderr,"vardecl %s has type %s\n",Absynpp::qvar2string(x->name),
  //        Absynpp::typ2string(x->type));
  // if x's type is T*{e}, T@{e}, or T[e] then we want to 
  // add a constraint of the form e <= numelts(x)
  exp_opt_t bound = Tcutil::get_type_bound(xtype);
  if (bound != NULL) {
    //fprintf(stderr,"bound is %s\n",exp2string((exp_t)bound));
    Relations::reln_op_t rop_bound = Relations::RConst(0); // bogus value
    if (Relations::exp2relnop(bound,&rop_bound))
      relns = Relations::add_relation(heap_region,rop_bound,
                                      Relations::Rlte,rop_a,relns);
  }

  // check to see if adding numelts(x) <= i to relns is inconsistent
  if (valid_rop_i) {
    let rlns = Relations::add_relation(heap_region,rop_a,
                                       Relations::Rlte,rop_i,relns);
#ifdef BCE_DEBUG
    fprintf(stderr,"checking consistency of: "); 
    Relations::print_relns(stderr,rlns);
    fprintf(stderr,"\n");
#endif
    let consistent = Relations::consistent_relations(rlns); 
    x->type = oldtype;
    if (!consistent) return true;
  }

inner_loop:
  switch (i->r) {
  case &Cast_e(t,e2,_,_): i = e2; goto inner_loop;
  case &Primop_e(Mod,&List(e1,&List(e2,_))):
    // we have x[e1 % e2]
    // if e2 is numelts(x) or z such that z <= numelts(x) then it's okay
    Relations::reln_op_t rop_z = Relations::RConst(0); // dummy
    if (Relations::exp2relnop(e2,&rop_z)) {
      // add numelts(x) < z and check to see if it's inconsistent
      let rlns = Relations::add_relation(heap_region,rop_a,
                                         Relations::Rlt,rop_z,relns);
      let consist = Relations::consistent_relations(rlns);
      x->type = oldtype;
      return !consist;
    }
    break;
  default: break;
  }
  x->type = oldtype;
  return false;
}

static type_t get_cyc_typ(exp_t e) {
  if (e->topt == NULL) toc_impos("Missing type in primop ");
  return (type_t)e->topt;
}
static $(tqual_t, type_t)@ tup_to_c(exp_t e) {
  return new $(mt_tq, typ_to_c((type_t)e->topt));
}

// adds one for zeroterm.  does not multiply by element size
static exp_opt_t array_length_exp(exp_t e) {
  switch(e->r) {
  case &Array_e(dles):
    for(let dles2=dles; dles2 != NULL; dles2 = dles2->tl)
      if((*dles2->hd)[0] != NULL) // sanity check
	unimp("array designators for abstract-field initialization");
    fallthru(signed_int_exp(length(dles),DL),false);
  case &Comprehension_e(_,bd,_,zt): fallthru(bd,zt);
  case &ComprehensionNoinit_e(bd,_,zt): 
    bd = copy_exp(bd);
    return zt ? add_exp(bd,uint_exp(1,DL),DL) : bd;
  default: return NULL;
  }
}
// when using a struct-hack, find what we need to add to a malloc-argument.
// while tempting to say "keep track of this when you translate the expression"
// in all we are seeing if it is simpler not to keep track of when we are
// "directly under a new" (see New_e case of exp_to_c)
static exp_opt_t get_varsizeexp(exp_t e) {
  // * we just need to detect struct-hacks, where we have a zero-length array
  //   because the initializer has unknown length
  // * few cases because we have already translated e to C and we are
  //   concerned only with a (nested) array initializer
  // * watch out for casts?? (make sure translation to C doesn't put them in
  // * also make sure the aggr is "known"
  // * FIX? can unions still be around here?
  let dles;
  let field_types;
  switch(e->r) {
  case &Aggregate_e(_,_,dles2,_): dles=dles2; break;
  default: return NULL; // if not a struct, then no struct hack possible
  }
  switch(compress((type_t)e->topt)) {
  case &AggrType(AggrInfo({.KnownAggr = &ad},...)): 
    if(ad->impl==NULL)
      return NULL;
    if(ad->kind == UnionA)
      return NULL; // correct and otherwise will not find "last field"
    field_types = ad->impl->fields;
    break;
    // else silently return because something translated to an aggregate
    // may not have set the topt field
  default: return NULL;
  }
  if(field_types==NULL) // weird case: struct with no fields (possible?)
    return NULL; 
  for(; field_types->tl != NULL; field_types = field_types->tl)
    ;
  let last_type_field = field_types->hd;
  for(; dles != NULL; dles=dles->tl) {
    let &$(ds,e2) = dles->hd;
    let f = designatorlist_to_fieldname(ds);
    if(!strptrcmp(f,last_type_field->name)) {
      let nested_ans = get_varsizeexp(e2);
      if(nested_ans != NULL)
	return nested_ans;
      switch(compress(last_type_field->type)) {
      case &ArrayType(ArrayInfo{.elt_type=elt_typ,.num_elts=type_bd,...}):
	// key invariant: zero-length array means struct hack
	if(type_bd == NULL || !is_zero(type_bd))
	  return NULL;
	// DJG: not sure these pad bytes are necessary, but the old 
	//      version had them
	// FIX: as was try before, we execute the bound twice, and once
	//      in a position where the flow analysis does not expect
	return add_exp(fncall_exp(_check_times_e,
				  list((exp_t)array_length_exp(e2),
				       sizeoftyp_exp(elt_typ,DL)),DL),
		       signed_int_exp(PAD_BYTES,DL),DL);
      default: return NULL;
      }
    }
  }
  toc_impos("get_varsizeexp: did not find last struct field");
}

static int get_member_offset(aggrdecl_t ad, field_name_t f) {
  int i = 1;
  for (let fields = ad->impl->fields; fields != NULL; fields = fields->tl) {
    let field = fields->hd;
    if (strcmp(*field->name,*f) == 0) return i;
    ++i;
  }
  toc_impos(aprintf("get_member_offset %s failed",*f));
}

// functions for passing to lvalue_assign (see below)
static exp_t assignop_lvalue(exp_t el, $(opt_t<primop_t,`H>,exp_t)@ pr) {
  return assignop_exp(el,(*pr)[0],(*pr)[1],DL);
}
static exp_t address_lvalue(exp_t e1, bool ignore) {
  return address_exp(e1,DL);
}
static exp_t incr_lvalue(exp_t e1, incrementor_t incr) {
  return new_exp(new Increment_e(e1,incr),DL);
}

static void lvalue_assign_stmt(stmt_t s,list_t<field_name_t> fs,
			       exp_t f(exp_t,`a), `a f_env);

// e1 is the result of translating an lvalue.  fs is the path of struct
// fields that we're assigning to on e1 (if any).  The translation
//  may have inserted NULL checks, etc., but buried within e1 is an lvalue.
// We find the underlying lvalue, call it el.
// We replace el in e1 with f(el,env)
// We assume that variables in f(el,env) will not be captured by any
static void lvalue_assign(exp_t e1, list_t<field_name_t> fs,
			  exp_t f(exp_t,`a), `a f_env){
  switch (e1->r) {
  case &StmtExp_e(s): lvalue_assign_stmt(s,fs,f,f_env); break;
  case &Cast_e(t,e,_,_):  lvalue_assign(e,fs,f,f_env); break;
  case &AggrMember_e(e,fld,is_tagged,is_read):
    // Hack: strip off the struct member -- the base case adds it back in.
    e1->r = e->r;
    lvalue_assign(e1,new List(fld,fs),f,f_env);
    break;
  default:
    // Note: this may not be an lvalue b/c of &arr where arr has an array type.
    // WARNING: If the translation of lvalues changes, we may need to change
    //          how we find the "inner lvalue".
    // make a copy so we don't create a loop
    exp_t e1_copy = copy_exp(e1);
    // add the path back on to the expression
    for (; fs != NULL; fs = fs->tl)
      e1_copy = member_exp(e1_copy,fs->hd,e1_copy->loc);
    e1->r = f(e1_copy, f_env)->r;
    break;
  }
}
static void lvalue_assign_stmt(stmt_t s,list_t<field_name_t> fs,
			       exp_t f(exp_t,`a), `a f_env) {
  switch (s->r) {
  case &Exp_s(e1):    lvalue_assign(e1,fs,f,f_env);      break;
    // we assume free vars of e2 are not captured by d
  case &Decl_s(d,s2): lvalue_assign_stmt(s2,fs,f,f_env); break;
  case &Seq_s(_,s2):  lvalue_assign_stmt(s2,fs,f,f_env); break;
  default: toc_impos("lvalue_assign_stmt: %s",stmt2string(s));
  }
}

static void push_address_stmt(stmt_t s);

// we want to take the address of e but it may no longer be a valid
// lhs, due to a cast or null-check or whatever.
static exp_t push_address_exp(exp_t e) {
  switch (e->r) {
  case &Cast_e(*t,*e1,_,_):
    *e1 = push_address_exp(*e1);
    *t = cstar_typ(*t,mt_tq);
    return e;
  case &Deref_e(e1):
    return e1;
  case &StmtExp_e(s):
    // we only have this case because of assignments to
    // tagged union members -- see tagged_union_assignop
    push_address_stmt(s);
    return e;
  default:
    if (is_lvalue(e)) return address_exp(e,DL);
    toc_impos("can't take & of exp %s",exp2string(e));
  }
}

static void push_address_stmt(stmt_t s) {
  switch (s->r) {
  case &Seq_s(_,s2): fallthru(s2);
  case &Decl_s(_,s2): push_address_stmt(s2); break;
  case &Exp_s(*e): *e = push_address_exp(*e); break;
  default: toc_impos("can't take & of stmt %s",stmt2string(s));
  }
}

static struct PtrInfo get_ptr_type(type_t t) {
  switch (compress(t)) {
  case &PointerType(p): return p;
  default: toc_impos("get_ptr_typ: not a pointer!");
  }
}

// given a type t that admits "zero", return an expression representing
// zero for that type.  For pointers, this is NULL.  For integral types,
// this is the appropriate integral 0.
static exp_t generate_zero(type_t t) {
  exp_t res;
  switch (compress(t)) {
  case &PointerType(_) : res = null_exp(DL); break;
  case &IntType(sn,Char_sz) : res = const_exp(Char_c(sn,0),DL); break;
  case &IntType(sn,Short_sz) : res = const_exp(Short_c(sn,0),DL); break;
  case &EnumType(_,_)  : fallthru;
  case &AnonEnumType(_): fallthru(Unsigned);
  case &IntType(sn,Int_sz) : fallthru(sn);
  case &IntType(sn,Long_sz) :
    res = const_exp(Int_c(sn,0),DL); break;
  case &IntType(sn,LongLong_sz) :
    res = const_exp(LongLong_c(sn,0),DL); break;
  case &FloatType(0): res = const_exp(Float_c("0.0F",0),DL); break;
  case &FloatType(1): res = const_exp(Float_c("0.0",1),DL); break;
  case &FloatType(i): res = const_exp(Float_c("0.0L",i),DL); break;
  default:
    toc_impos("found non-zero type %s in generate_zero",typ2string(t));
  }
  res->topt = t;
  return res;
}

// We're translating e which is of the form e_1 op= e_2 where e_1
// involves a zero-terminated pointer and is of the form *ea or
// ea[eb].  We need to prevent overwriting the last zero in the array.  
static void zero_ptr_assign_to_c(env_t nv, exp_t e,
                                 exp_t e1, opt_t<primop_t> popt, exp_t e2,
                                 type_t ptr_type,
                                 bool is_dyneither,
                                 type_t elt_type) {
  /* Sadly, this sleazy trick doesn't work.  The reason is that
     we need to fail only when writing to the last element of
     the array a non-zero value.  The code here faults whenever
     you overwrite a non-zero value.

  // we pull a very sleazy trick here and translate e1 as if it
  // were a right-hand-side instead of lhs.  Then we get rid of
  // the resulting deref if necessary in order to get a pointer
  // that we can then dereference (to check for zero) and 
  // ultimately update.
  if (!is_dyneither) {
    exp_to_c(nv,e1);
    exp_to_c(nv,e2);
    exp_t lhs;
    switch (e1->r) {
    case &Deref_e(e): lhs = e; break;
    case &Subscript_e(a,b): lhs = add_exp(a,b,0); break;
    default: 
      impos("zero_ptr_assign_to_c: e1 = %s",Absynpp::exp2string(e1));
    }
    let c_elt_type = typ_to_c(elt_type);
    let c_ptr_type = cstar_typ(c_elt_type, mt_tq);
    let lhs_var = temp_var();
    let rhs_var = temp_var();
    let temp = temp_var();
    exp_t rhs_exp = e2;
    stmt_t fail = exp_stmt(fncall_exp(_throw_arraybounds_e,NULL,DL),DL);
    exp_t result = assign_exp(deref_exp(var_exp(lhs_var,DL),DL),
                              var_exp(rhs_var,DL),DL);
    exp_t test1 = eq_exp(var_exp(temp,DL),int_exp(None,0,DL),DL);
    exp_t test2 = neq_exp(var_exp(rhs_var,DL),int_exp(None,0,DL),DL);
    exp_t test_exp = and_exp(test1,test2,DL);
    if (popt != NULL) rhs_exp = prim2_exp(popt->v,var_exp(temp,DL),rhs_exp,DL);
    let s = declare_stmt(lhs_var,cstar_typ(c_elt_type, mt_tq),lhs,
            declare_stmt(temp,c_elt_type,deref_exp(var_exp(lhs_var,DL),DL),
            declare_stmt(rhs_var,c_elt_type,rhs_exp,
            seq_stmt(ifthenelse_stmt(test_exp,fail,skip_stmt(DL),DL),
                     exp_stmt(result,DL),DL),DL),DL),DL);
    e->r = stmt_exp(s,DL)->r;
    return;
  }
  */
  // To simplify the translation, we always use a fat pointer and generate:
  //  ({ fat_ptr_type x = ((fat_ptr_type)ea) + eb;
  //     elt_type y = *x; // check here that x is not null and in bounds
  //     elt_type z = y op e2;
  //     if (numelts(x) == 1 && y == zero && z != zero) _throw_arraybounds();
  //     *x.curr = z; })
  // Note that this is generated and *then* translated to ensure the
  // proper constraints.
  type_t fat_ptr_type = dyneither_typ(elt_type, &HeapRgn_val, mt_tq, true_conref);
  let c_elt_type = typ_to_c(elt_type);
  let c_fat_ptr_type = typ_to_c(fat_ptr_type);
  let c_ptr_type = cstar_typ(c_elt_type, mt_tq);
  let c_ptr_type_opt = new Opt(c_ptr_type);
  exp_t xinit;
  switch (e1->r) {
  case &Deref_e(ea):
    if (!is_dyneither) {
      ea = cast_exp(fat_ptr_type,ea,false,Other_coercion,DL);
      ea->topt = fat_ptr_type;
    }
    exp_to_c(nv,ea); xinit = ea; break;
  case &Subscript_e(ea,eb):
    if (!is_dyneither) {
      ea = cast_exp(fat_ptr_type,ea,false,Other_coercion,DL);
      ea->topt = fat_ptr_type;
    }
    exp_to_c(nv,ea); exp_to_c(nv,eb);
    xinit = fncall_exp(_dyneither_ptr_plus_e,
                       list(ea,sizeoftyp_exp(typ_to_c(elt_type),DL),eb),DL);
    break;
  default: toc_impos("found bad lhs for zero-terminated pointer assignment");
  }
  let x = temp_var();                // build ptr_type x = ea + eb;
  TOC_RGN(nv, rgn2) {
    let x_vd = new Vardecl {Public,x,0,mt_tq,c_fat_ptr_type,xinit,NULL,NULL,false};
    let x_bnd = new Local_b(x_vd);     // build *x -- need to translate here
    let x_exp = varb_exp(x_bnd,DL);  // to check the bound and for NULL
    x_exp->topt = fat_ptr_type;
    let deref_x = deref_exp(x_exp,DL);
    deref_x->topt = elt_type;
    exp_to_c(nv,deref_x);
    let y = temp_var();                // build elt_type y = *x;
    let y_vd = new Vardecl {Public,y,0,mt_tq,c_elt_type,deref_x,NULL,NULL,false};
    let y_bnd = new Local_b(y_vd);
    exp_t z_init = e2;                 // build y op e2 and translate
    if (popt != NULL) {
      let y_exp = varb_exp(y_bnd,DL);
      y_exp->topt = deref_x->topt;
      z_init = prim2_exp(popt->v,y_exp,e2,DL);
      z_init->topt = y_exp->topt;
    }
    exp_to_c(nv,z_init);
    let z = temp_var();                // build z = y op e2;
    let z_vd = new Vardecl {Public,z,0,mt_tq,c_elt_type,z_init,NULL,NULL,false};
    let z_bnd = new Local_b(z_vd);
    // build y == zero and translate -- here, we need to know what
    // the element type is to generate the right zero.
    let y2_exp = varb_exp(y_bnd,DL); y2_exp->topt = deref_x->topt;
    let zero1_exp = generate_zero(elt_type);
    let comp1_exp = prim2_exp(Eq,y2_exp,zero1_exp,DL);
    comp1_exp->topt = sint_typ;
    exp_to_c(nv,comp1_exp);
    // build z != zero and translate
    let z_exp = varb_exp(z_bnd,DL); z_exp->topt = deref_x->topt;
    let zero2_exp = generate_zero(elt_type);
    let comp2_exp = prim2_exp(Neq,z_exp,zero2_exp,DL);
    comp2_exp->topt = sint_typ;
    exp_to_c(nv,comp2_exp);
    // build numelts(x) == 1 directly (no translation)
    let xsizeargs = list(varb_exp(x_bnd,DL),
                         sizeoftyp_exp(typ_to_c(elt_type),DL));
    let oneexp = uint_exp(1,DL);
    exp_t xsize;
    xsize = prim2_exp(Eq,fncall_exp(_get_dyneither_size_e,xsizeargs,DL),
                      oneexp,DL);
    // start assembling the statement
    let comp_exp = and_exp(xsize,and_exp(comp1_exp,comp2_exp,DL),DL);
    let thr_stmt = exp_stmt(fncall_exp(_throw_arraybounds_e,NULL,DL),DL);
    let xcurr = member_exp(varb_exp(x_bnd,DL),curr_sp,DL);
    xcurr = cast_it(c_ptr_type,xcurr);
    let deref_xcurr = deref_exp(xcurr,DL);
    let asn_exp = assign_exp(deref_xcurr,var_exp(z,DL),DL);
    let s = exp_stmt(asn_exp,DL);
    s = seq_stmt(ifthenelse_stmt(comp_exp,thr_stmt,skip_stmt(DL),DL),s,DL);
    s = decl_stmt(new Decl(new Var_d(z_vd),DL),s,DL);
    s = decl_stmt(new Decl(new Var_d(y_vd),DL),s,DL);
    s = decl_stmt(new Decl(new Var_d(x_vd),DL),s,DL);
    e->r = stmt_exp_r(s);
  }
}

// we have a read of e1.f or e1->f where e1 does any needed null checks,
// but we now have to do a tag-check.  We translate this to:
//  ({ temp = e1;
//     if (temp->f.tag != f_tag) throw_match();
//     temp->f.val;
//  })
// unless we are in a left-hand-side context, in which case we translate to
//  ({ temp = &e1->f; // okay because e1 must be a lhs
//     if (temp->tag != f_tag) throw_match();
//     &temp->val;
//  })
static raw_exp_t check_tagged_union(exp_t e1,type_t e1_c_type,
                                    type_t aggrtype,field_name_t f,
                                    bool in_lhs,
                                    exp_t aggrproj(exp_t,field_name_t,seg_t)) {
  aggrdecl_t ad;
  switch (compress(aggrtype)) {
  case &AggrType(AggrInfo(info,_)):
    ad = get_known_aggrdecl(info); break;
  default: impos(aprintf("expecting union but found %s in check_tagged_union",
                         typ2string(aggrtype)));
  }
  let temp = temp_var();
  let temp_exp = var_exp(temp,DL);
  let f_tag = signed_int_exp(get_member_offset(ad,f),DL);
  if (in_lhs) {
    let temp_f_tag = aggrarrow_exp(temp_exp,tag_sp,DL);
    let test_exp = neq_exp(temp_f_tag,f_tag,DL);
    let temp_f_val = aggrarrow_exp(temp_exp,val_sp,DL);
    let sres = exp_stmt(address_exp(temp_f_val,DL),DL);
    let ifs = ifthenelse_stmt(test_exp,throw_match_stmt(),skip_stmt_dl(),DL);
    let e1_p_type = cstar_typ(e1_c_type,mt_tq);
    let e1_f = address_exp(aggrproj(e1,f,DL),DL);
    let s = declare_stmt(temp,e1_p_type,e1_f,seq_stmt(ifs,sres,DL),DL);
    return stmt_exp_r(s);
  } else {
    let temp_f_tag = member_exp(aggrproj(temp_exp,f,DL),tag_sp,DL);
    let test_exp = neq_exp(temp_f_tag,f_tag,DL);
    let temp_f_val = member_exp(aggrproj(temp_exp,f,DL),val_sp,DL);
    let sres = exp_stmt(temp_f_val,DL);
    let ifs = ifthenelse_stmt(test_exp,throw_match_stmt(),skip_stmt_dl(),DL);
    let s = declare_stmt(temp,e1_c_type,e1,seq_stmt(ifs,sres,DL),DL);
    return stmt_exp_r(s);
  }
}

static bool is_tagged_union_project_impl(type_t t, field_name_t f,
					 int @f_tag, type_t @ tagged_member_type,
					 bool clear_read, bool *is_read) {
  switch (compress(t)) {
  case &AggrType(AggrInfo(info,...)):
    let ad = get_known_aggrdecl(info);
    *f_tag = get_member_offset(ad,f);
    // FIX: we need to get unique names for these damned structs...
    string_t str = aprintf("_union_%s_%s",*((*ad->name)[1]),*f);
    *tagged_member_type = strct(new str);
    if (clear_read) *is_read = false;
    return ad->impl->tagged;
  default: return false;
  }
}

// return true if e is e1.f or e1->f where e1 is a (pointer to a)
// tagged union.  While we're at it, calculate the tag for the
// corresponding member f_tag.
static bool is_tagged_union_project(exp_t e, int @f_tag,
                                    type_t @ tagged_member_type,
                                    bool clear_read) {
  switch (e->r) {
  case &Cast_e(_,e1,_,_): toc_impos("cast on lhs!");
  case &AggrMember_e(e1,f,_,*is_read):
    return is_tagged_union_project_impl((type_t)e1->topt,f,f_tag,
					tagged_member_type,clear_read,is_read);
  case &AggrArrow_e(e1,f,_,*is_read):
    switch (compress((type_t)e1->topt)) {
    case &PointerType(PtrInfo{.elt_typ = et,...}):
      return is_tagged_union_project_impl(et,f,f_tag,
					  tagged_member_type,clear_read,is_read);
    default: return false;
    }
  default: return false;
  }
}

// special case for assignment to a tagged union member (either e1.f
// or e1->f.  In particular, when we have e1->f = e2, we rewrite to:
// ({ temp = &e1->f;
//    temp->tag = f_tag;
//    temp->val = e2; })
// and if we have e1->f op= e2 we rewrite to:
// ({ temp = &e1->f;
//    if (temp->tag != f_tag) throw_match();
//    temp->val op= e2; })
static raw_exp_t tagged_union_assignop(exp_t e1, type_t e1_cyc_type,
                                       opt_t<primop_t,`H> popt,
                                       exp_t e2, type_t e2_cyc_type,
                                       int tag_num, type_t member_type) {
  let temp = temp_var();
  exp_t temp_exp = var_exp(temp,DL);
  exp_t temp_val = aggrarrow_exp(temp_exp,val_sp,DL);
  exp_t temp_tag = aggrarrow_exp(temp_exp,tag_sp,DL);
  exp_t f_tag = signed_int_exp(tag_num,DL);
  stmt_t s3 = exp_stmt(assignop_exp(temp_val,popt,e2,DL),DL);
  stmt_t s2;
  if (popt == NULL)
    s2 = exp_stmt(assign_exp(temp_tag,f_tag,DL),DL);
  else {
    let test_exp = neq_exp(temp_tag,f_tag,DL);
    s2 = ifthenelse_stmt(test_exp,throw_match_stmt(),skip_stmt_dl(),DL);
  }
  stmt_t s1 = declare_stmt(temp,cstar_typ(member_type,mt_tq),
                           push_address_exp(e1),
                           seq_stmt(s2,s3,DL),DL);
  return stmt_exp_r(s1);
}

static void exp_to_c(env_t nv, exp_t e) {
  let r = e->r;
  if(e->topt == NULL)
    toc_impos("exp_to_c: no type for %s",exp2string(e));
  type_t old_typ = (type_t)e->topt;
  switch (r) {
  case &Pragma_e(...):
    e->r = (raw_exp_t)(&zero_exp);
    break;
  case &Const_e({.Null_c = _}):
    // NULL translate to 0 unless a tagged array, then {0,0,0}, via runtime
    // call unless at top-level
    // note: we don't need the element type b/c the length is 0 (so we lie)
    // note: should share all these uint_exp(0,DL) things
    let zero = signed_int_exp(0,DL);
    if(is_tagged_pointer_typ(old_typ)) {
      if(is_toplevel(nv))
	e->r = make_toplevel_dyn_arr(old_typ, zero, zero)->r;
      else
	e->r = fncall_exp_r(_tag_dyneither_e, list(zero,zero,zero));
    } else {
      e->r = (raw_exp_t)(&zero_exp);
    }
    break;
  case &Const_e(_): break;
  case &Var_e(_):   break;
  case &Primop_e(p,es):
    // Save Cyclone types -- needed for pointer arith stuff
    let old_typs = List::map(get_cyc_typ,es);
    // Translate args
    List::iter_c(exp_to_c,nv,es);
    switch (p) {
    case Numelts:
      exp_t arg = es->hd;
      switch (compress((type_t)arg->topt)) {
      case &ArrayType(ArrayInfo{_,_,e2,_,_}):
        // FIX: copy the expression e2 here.
        if (!Evexp::c_can_eval((exp_t)e2))
          terr(e->loc,"can't calculate numelts");
        e->r = e2->r;  break;
      case &PointerType(PtrInfo(elt_typ,_,PtrAtts(_,nbl,bound,zt,_))):
	switch(conref_def(bounds_one,bound)) {
        case &DynEither_b: // retrieve (last_plus_one - curr) via runtime call
	  e->r = fncall_exp_r(_get_dyneither_size_e,
                              list(es->hd,
                                   sizeoftyp_exp(typ_to_c(elt_typ),DL)));
          break;
	case &Upper_b(e2):
          // when zero-terminated, we have to call "strlen"
          if (conref_def(false,zt)) {
            exp_t function_e =
	      getFunctionRemovePointer(&_get_zero_arr_size_functionSet,
				       es->hd);
            e->r = fncall_exp_r(function_e,list(es->hd,e2));
          } else if (conref_def(false,nbl)) {
            if (!Evexp::c_can_eval(e2))
              terr(e->loc,"can't calculate numelts");
            // careful! when this is a nullable pointer, the size might be 0
            e->r = conditional_exp_r(arg,e2,uint_exp(0,DL));
          } else {
            e->r = e2->r; break; // compile-time evaluation
          }
	  break;
	}
	break;
      default:
	toc_impos("size primop applied to non-array %s (%s)",
                  typ2string((type_t)arg->topt),typ2string((type_t)arg->topt));
      }
      break;
    case Plus:
      // only translation is for ? pointers or zero-terminated arrays
      //   _dynxxx_ptr_plus(e1,sizeof(elt_typ),e2)
      // FIX: allow arithmetic on t ? types at top-level!
      switch (compress(old_typs->hd)) {
      case &PointerType(PtrInfo(elt_typ,_,PtrAtts(_,_,b,zt,_))):
        switch (conref_def(bounds_one,b)) {
        case &DynEither_b:
          exp_t e1 = es->hd;
          exp_t e2 = es->tl->hd;
          e->r = fncall_exp_r(_dyneither_ptr_plus_e,
                              list(e1,sizeoftyp_exp(typ_to_c(elt_typ),DL),e2));
          break;
        case &Upper_b(esz):
          if (conref_def(false,zt)) {
            exp_t e1 = es->hd;
            exp_t e2 = es->tl->hd;
            e->r = fncall_exp(getFunctionRemovePointer(&_zero_arr_plus_functionSet,e1),list(e1,esz,e2),DL)->r;
          }
          break;
        }
        break;
      default: break;
      }
      break;
    case Minus:
      // only translation is for ? pointers.
      // if e2 is not a tagged array, do just like plus of negation,
      // else result type is unsigned int, so subtract curr fields
      type_t elt_typ = &VoidType_val;
      if(is_tagged_pointer_typ_elt(old_typs->hd,&elt_typ)) {
	exp_t e1 = es->hd;
	exp_t e2 = es->tl->hd;
	if(is_tagged_pointer_typ(old_typs->tl->hd)) {
	  e1->r = aggrmember_exp_r(new_exp(e1->r,DL),curr_sp);
	  e2->r = aggrmember_exp_r(new_exp(e2->r,DL),curr_sp);
	  e1->topt = e2->topt = cstar_typ(uchar_typ,mt_tq);
	  e->r  = divide_exp(copy_exp(e),
			     sizeoftyp_exp(typ_to_c(elt_typ),DL),DL)->r;
	} else {
	  e->r = fncall_exp_r(_dyneither_ptr_plus_e,
                              list(e1,sizeoftyp_exp(typ_to_c(elt_typ),DL),
                                   prim1_exp(Minus,e2,DL)));
	}
      }
      break;
    case Eq:
    case Neq:
    case Gt:
    case Gte:
    case Lt:
    case Lte:
      // need to extract .curr field of tagged arrays for comparisons
      exp_t e1 = es->hd;
      exp_t e2 = es->tl->hd;
      type_t t1 = old_typs->hd;
      type_t t2 = old_typs->tl->hd;
      type_t elt_typ = &VoidType_val; // bogus until next call
      if (is_tagged_pointer_typ_elt(t1,&elt_typ)) {
	let t = cstar_typ(typ_to_c(elt_typ),mt_tq);
	e1->r = cast_it_r(t,member_exp(new_exp(e1->r,DL),curr_sp,DL));
	e1->topt = t;
      }
      if (is_tagged_pointer_typ(t2)) {
	let t = cstar_typ(typ_to_c(elt_typ),mt_tq);
	e2->r = cast_it_r(t,member_exp(new_exp(e2->r,DL),curr_sp,DL));
	e2->topt = t;
      }
      break;
    default: break; //skip
    }
    break;
  case &Increment_e(e2,incr):
    type_t e2_cyc_typ = (type_t)e2->topt;
    // we need to worry about the case where e2 is of the form
    // *ea or ea[eb] and ea is a zero-terminated pointer, for
    // then we need to know that the inc/dec doesn't destroy the
    // trailing 0.  See the special code in the AssignOp_e case.
    // To combat this, I'm simply disallowing it.
    //
    // Similarly, we need to worry about the case where e2 is a
    // tagged union projection.
    type_t ptr_type = &VoidType_val;
    type_t elt_type = &VoidType_val;
    bool is_dyneither = false;
    string_t incr_str = "increment";
    if (incr == PreDec || incr == PostDec) incr_str = "decrement";
    if (is_zero_ptr_deref(e2,&ptr_type,&is_dyneither,&elt_type)) {
      terr(e->loc,"in-place %s is not supported when dereferencing a zero-terminated pointer", incr_str);
      toc_impos("in-place inc/dec on zero-term");
    }
    type_t tunion_member_type = &VoidType_val;
    int f_tag = 0;
    if (is_tagged_union_project(e2,&f_tag,&tunion_member_type,true)) {
      let one = signed_int_exp(1,DL);
      one->topt = sint_typ;
      switch (incr) {
      case PreInc:
        e->r = new AssignOp_e(e2,new Opt(Plus),one);
        exp_to_c(nv,e);
        return;
      case PreDec:
        e->r = new AssignOp_e(e2,new Opt(Minus),one);
        exp_to_c(nv,e);
        return;
      default:
        terr(e->loc,"in-place post%s is not supported on @tagged union members",
	     incr_str);
        toc_impos("in-place inc/dec on @tagged union");
      }
    }
    bool need_null_ck = is_pointer_type(old_typ) && 
      Tcutil::is_nullable_pointer_type(old_typ) && need_null_check(e2);
    set_lhs(nv,true);
    exp_to_c(nv,e2);
    set_lhs(nv,false);
    // only t ? or zero-terminated types are translated funny,
    // note that e2 is an lvalue!
    type_t elt_typ = &VoidType_val;
    if(is_tagged_pointer_typ_elt(old_typ,&elt_typ)) {
      _ fn_e;
      int change = 1;
      fn_e = (incr==PostInc || incr==PostDec) ?
        _dyneither_ptr_inplace_plus_post_e : _dyneither_ptr_inplace_plus_e;
      if (incr == PreDec || incr == PostDec)
        change = -1;
      e->r = fncall_exp_r(fn_e, list(push_address_exp(e2),
                                     sizeoftyp_exp(typ_to_c(elt_typ),DL),
                                     signed_int_exp(change,DL)));
    } else if (is_zero_pointer_typ_elt(old_typ,&elt_typ)) {
      // we treat ++x specially -- this becomes
      //   if (x != 0 && *x != 0) ++x; else _throw_arraybounds()
      // or even
      //   if (*x != 0) ++x; else _throw_arraybounds()
      // if we can show x is not null.
      if (incr != PostInc) {
        let x = temp_var();
        let t = cstar_typ(typ_to_c(old_typ),mt_tq);
        let xexp = push_address_exp(e2);
        let testexp = neq_exp(deref_exp(deref_exp(var_exp(x,DL),DL),DL),
                              int_exp(None,0,DL),DL);
        if (need_null_ck)
          testexp = and_exp(neq_exp(deref_exp(var_exp(x,DL),DL),
                                    int_exp(None,0,DL),DL),testexp,DL);
        let s = ifthenelse_stmt(testexp,
                  exp_stmt(pre_inc_exp(deref_exp(var_exp(x,DL),DL),DL),DL),
                  exp_stmt(fncall_exp(_throw_arraybounds_e,NULL,DL),DL),DL);
        s = seq_stmt(s,exp_stmt(deref_exp(var_exp(x,DL),DL),DL),DL);
        e->r = stmt_exp(declare_stmt(x,t,xexp,s,DL),DL)->r;
      } else {
        // e.g, x++ becomes _zero_arr_inplace_plus_post(x,1)
        let fnSet = &_zero_arr_inplace_plus_post_functionSet;
        exp_t fn_e = getFunctionRemovePointer(fnSet, e2);
        e->r = fncall_exp_r(fn_e, list(push_address_exp(e2),
                                       signed_int_exp(1,DL)));
      }
    } else if(elt_typ == &VoidType_val && !is_lvalue(e2)) {
      lvalue_assign(e2,NULL,incr_lvalue,incr);
      e->r = e2->r;
    }
    break;
  case &AssignOp_e(e1,popt,e2):
    // FIX: not sure all these special-cases work right *together*...
    //
    // We need to know whether or not the expression is of the form
    // *ea op= e2 or ea[eb] op= e2 where ea is a zero-terminated pointer.
    // The reason is that we need to ensure not only that the pointer
    // is in bounds, but also, if it's pointing to the last element
    // (i.e., the zero) then the value written in should continue to
    // be zero.  So, for instance, if we have *ea = e2, then either ea
    // can't point to the last element or e2 must be 0.  If we have
    // *ea op= e2 then we need to know that either ea can't point to
    // the last element or (0 op= e2) is 0.
    //
    // Similarly, when e1 is a tagged union member, then we need to
    // update its tag as well as the value.  This is problematic when
    // we have something like e.x += 1 which is both a read and a write
    // of the member.
    // See if e1 is a projection on a tagged union member.
    type_t  e1_old_typ = (type_t)e1->topt;
    type_t  e2_old_typ = (type_t)e2->topt;
    int f_tag = 0; // bogus unless e1_tagged_proj
    type_t tagged_member_struct_type = &VoidType_val; // bogus unless e1_tagged_proj
    if (is_tagged_union_project(e1,&f_tag,&tagged_member_struct_type,true)) {
      set_lhs(nv,true);
      exp_to_c(nv,e1);
      set_lhs(nv,false);
      exp_to_c(nv,e2);
      e->r = tagged_union_assignop(e1,e1_old_typ,popt,e2,e2_old_typ,f_tag,
                                   tagged_member_struct_type);
      return;
    }
    type_t ptr_type = &VoidType_val;
    type_t elt_type = &VoidType_val;
    bool is_dyneither = false;
    if (is_zero_ptr_deref(e1,&ptr_type,&is_dyneither,&elt_type)) {
      zero_ptr_assign_to_c(nv, e, e1, popt, e2, ptr_type,
                           is_dyneither, elt_type);
      return;
    }
    // See if e1 is a polymorphic field (i.e., is an instantiated type
    // variable) -- if so, coerce e2 to void*.
    bool e1_poly    = is_poly_project(e1);
    set_lhs(nv,true);
    exp_to_c(nv,e1);
    set_lhs(nv,false);
    exp_to_c(nv,e2);
    // special case for pointer arithmetic of t ? or zero-terminated types
    bool done = false;
    if(popt != NULL) {
      type_t elt_typ = &VoidType_val;
      if(is_tagged_pointer_typ_elt(old_typ,&elt_typ)) {
        _ change;
        switch(popt->v) {
        case Plus:  change = e2; break;
        case Minus:
          change = prim1_exp(Minus,e2,DL); break;
        default:    toc_impos("bad t ? pointer arithmetic");
        }
        done = true;
        // FIX: Is e1 definitely still an lvalue? Probably not!!
        let fn_e = _dyneither_ptr_inplace_plus_e;
        e->r = fncall_exp_r(fn_e,list(push_address_exp(e1),
                                      sizeoftyp_exp(typ_to_c(elt_typ),DL),
                                      change));
      } else if (is_zero_pointer_typ_elt(old_typ,&elt_typ)) {
        // We're doing x += e where x is a zero-terminated pointer.
        // Make sure we don't run off the end.
        switch (popt->v) {
        case Plus:
          done = true;
          e->r = fncall_exp_r(getFunctionRemovePointer(&_zero_arr_inplace_plus_functionSet,e1),list(e1,e2));
          break;
        default: toc_impos("bad zero-terminated pointer arithmetic");
        }
      }
    }
    if(!done) {
      // this cast is necessary to avoid gcc warnings
      if (e1_poly)
        e2->r = cast_it_r(void_star_typ(), new_exp(e2->r,DL));
      // The typechecker guarantees that e1 starts out as an lvalue, but
      // the translation might have to insert casts, NULL checks,
      // declarations of temps, bound checks, etc.  If so we look into e1,
      // find the lvalue, and put the assignment there.
      if (!is_lvalue(e1)) {
        lvalue_assign(e1,NULL,assignop_lvalue,new{$(popt,e2)});
        e->r = e1->r;
      }
    }
    break;
  case &Conditional_e(e1,e2,e3):
    exp_to_c(nv,e1);
    exp_to_c(nv,e2);
    exp_to_c(nv,e3);
    break;
  case &And_e(e1,e2): fallthru(e1,e2);
  case &Or_e(e1,e2):  fallthru(e1,e2);
  case &SeqExp_e(e1,e2):
    exp_to_c(nv,e1);
    exp_to_c(nv,e2);
    break;
  case &FnCall_e(e1,es,NULL,_):
    exp_to_c(nv,e1);
    List::iter_c(exp_to_c,nv,es);
    break;
  case &FnCall_e(e1,es,&VarargCallInfo{num_varargs,injectors,vai},_):
    // if vai->inject:
    //    t vn = injector[n](es[n])
    //    ...
    //    t v0 = injector[0](es[n-num_varargs+1])
    //    t argv[num_varargs] = {&v0, ..., &vn};
    // else
    //    t argv[num_varargs] = {es[n-num_varargs+1], ..., es[n]};
    // e1(es[0], ..., es[n-num_varargs], tag_dyneither(argv, sizeof(t), num_varargs));
    TOC_RGN(nv,r) {
      qvar_t argv = temp_var();
      exp_t argvexp = var_exp(argv,DL);
      exp_t  num_varargs_exp = uint_exp(num_varargs,DL);
      type_t cva_type = typ_to_c(vai->type);
      type_t arr_type = array_typ(cva_type,mt_tq,num_varargs_exp,false_conref,
                                  DL);

      int num_args     = List::length(es);
      int num_normargs = num_args - num_varargs;

      // build argument list and set es to the varargs portion
      list_t<exp_t> new_args = NULL;
      for(int i=0; i < num_normargs; ++i, es=es->tl) {
	exp_to_c(nv,es->hd);
	new_args = new List(es->hd, new_args);
      }
      new_args = new List(fncall_exp(_tag_dyneither_e,
				     list(argvexp,
					  sizeoftyp_exp(cva_type,DL),
					  num_varargs_exp), DL),
			  new_args);
      new_args = imp_rev(new_args);
      // make the function call
      exp_to_c(nv,e1);
      stmt_t s = exp_stmt(fncall_exp(e1,new_args,DL),DL);

      // make the declarations and prepend them
      if(vai->inject) {
	datatypedecl_t tud;
	switch(compress(pointer_elt_type(vai->type))) {
	case &DatatypeType(DatatypeInfo({.KnownDatatype=&x},_)): tud = x; break;
	default: toc_impos("toc: unknown datatype in vararg with inject");
	}
	qvar_t ? vs = rnew(r) {for i < num_varargs : temp_var()};

        if (num_varargs != 0) {
          // declare argv = {&v1,&v2,...,&vnum_varargs}
	  // we now make it an Array_e, which RemoveAggrs converts to a 
	  // sequence of assignments
          let array_args = NULL;
          for(int i=num_varargs-1; i >= 0; --i)
            array_args = new List(address_exp(var_exp(vs[i],DL),DL),array_args);
          s = declare_stmt(argv, arr_type, array_exp(array_args,DL), s, DL);
          // evaluate varargs (reverse to get left-to-right)
	  es = imp_rev(es);
	  injectors = imp_rev(injectors);
	  int i = length(es)-1;
          for (; es != NULL; es=es->tl, injectors=injectors->tl, --i) {
            exp_t  arg      = es->hd;
            type_t arg_type = (type_t)arg->topt;
            qvar_t var      = vs[i];
            exp_t  varexp   = var_exp(var,DL);
            let &Datatypefield{qv,tqts,_,_} = injectors->hd;
            type_t field_typ = typ_to_c((*tqts->hd)[1]);
            exp_to_c(nv,arg);
            if (is_void_star_or_boxed_tvar(field_typ))
              arg = cast_it(field_typ,arg);
	    // just make an Aggregate_e and pass the buck to RemoveAggrs
	    let tdn = collapse_qvars(qv,tud->name);
	    let dles = list(make_field(tag_sp,datatype_tag(tud,qv)),
			    make_field(fieldname(1),arg));
	    s = declare_stmt(var, strctq(tdn),
			     new_exp(new Aggregate_e(tdn,NULL,dles,NULL),DL), 
			     s, DL);
          }
        } else {
	  // if there are no var args, then set argv to the empty fat pointer
	  // instead of an array of 0 elements to keep ansi c compilers happy
	  // FIX: this does not look right -- array_args is not used!
          let array_args = list(new $(NULL,uint_exp(0,DL)),
				new $(NULL,uint_exp(0,DL)),
				new $(NULL,uint_exp(0,DL)));
          s = declare_stmt(argv,void_star_typ(),uint_exp(0,DL), s,DL);
        }
      } else {
	// now just make an Array_e and pass the buck to RemoveAggrs to
	// expand it out to avoid the GCC bug
	if(num_varargs != 0) {
	  list_t<exp_t> array_args = NULL;
	  for(; es != NULL; es = es->tl) {
	    exp_to_c(nv, es->hd);
	    array_args = new List(es->hd, array_args);
	  }
	  let init = array_exp(imp_rev(array_args),DL);
	  s = declare_stmt(argv, arr_type, init, s,DL);
	} else // FIX??
          s = declare_stmt(argv,void_star_typ(),uint_exp(0,DL), s,DL);
      }

      e->r = stmt_exp_r(s);
    }
    break;
  case &Throw_e(e1,b):
    // throw e -> (t)(throw(e)), the latter being a function call to throw
    exp_to_c(nv,e1);
    let nt = b ? newrethrow_exp(e1) : newthrow_exp(e1);
    e->r = array_to_ptr_cast(typ_to_c(old_typ),nt,DL)->r;
    break;
  case &NoInstantiate_e(e1): exp_to_c(nv,e1); break;
  case &Instantiate_e(e1,ts):
    exp_to_c(nv,e1);
    // only cast when the instantiation has type variables,
    // you can cast other times, but you'll spit out much more C code.
    // Note: we don't bother to cast if type is void * anyway (b/c that's
    //       what type variables get translated to)
    // Note: we could be even more aggressive -- often the instantiated types
    //  don't show up in the translated type.  Moreover, we probably don't
    //  get warnings when the only use of the tyvar is as a parameter b/c
    //  it's just an implicit cast to void * (so long as inst type isn't int)
    for(; ts != NULL; ts = ts->tl) {
      let k = typ_kind(ts->hd)->kind;
      if(k != EffKind && k != RgnKind) {
	switch(compress(ts->hd)) {
	case &VarType(_):
	case &DatatypeType(_): continue;
	default:
	  e->r = array_to_ptr_cast(typ_to_c((type_t)e->topt),e1,DL)->r;
	  break;
	}
	break;
      }
    }
    break;
  case &Cast_e(*t,e1,user_inserted,coercion):
    type_t old_t2  = (type_t)e1->topt;
    type_t old_t2_c = typ_to_c(old_t2);
    type_t new_typ = *t;
    type_t new_typ_c = typ_to_c(new_typ);
    *t = new_typ_c;
    exp_to_c(nv, e1);
    // a few Cyclone casts are translated into C effects other than casts:
    switch ($(compress(old_t2),compress(new_typ))) {
    case $(&PointerType(p1),&PointerType(p2)):
      let n1 = conref_def(false,p1.ptr_atts.nullable);
      let n2 = conref_def(false,p2.ptr_atts.nullable);
      let b1 = conref_def(bounds_one,p1.ptr_atts.bounds);
      let b2 = conref_def(bounds_one,p2.ptr_atts.bounds);
      let zt1 = conref_def(false,p1.ptr_atts.zero_term);
      let zt2 = conref_def(false,p2.ptr_atts.zero_term);
      switch($(b1,b2)) {
      case $(&Upper_b(b1), &Upper_b(b2)):
        if ((!Evexp::c_can_eval(b1) || !Evexp::c_can_eval(b2)) &&
            !Evexp::same_const_exp(b1,b2))
          terr(e->loc,"can't validate cast due to potential size differences");
	if(n1 && !n2) {
	  if(is_toplevel(nv))
	    unimp("can't do NULL-check conversion at top-level");
	  // cast from t* to t@ -- run-time check: (t*)_check_null(e)
	  // flow analysis may not set annotation correctly here!
          // sanity checking:
          if (coercion != Null_to_NonNull)
            impos("null-check conversion mis-classified: %s",exp2string(e));
          bool do_null_check = need_null_check(e1);
          if (do_null_check) {
            if (!user_inserted)
              warn(e->loc,"inserted null check due to implicit "
		          "cast from * to @ type");
            e->r = cast_it_r(*t,fncall_exp(_check_null_e,
                                           new List(e1,NULL),DL));
          } else {
	    // no check needed -- see if we can drop the cast all together
            if (unify(old_t2_c,new_typ_c))
              e->r = e1->r;
          }
	} else {
          // no check needed -- see if we can drop the cast all together
          if (unify(old_t2_c,new_typ_c))
            e->r = e1->r;
        }
        // FIX: the type-checker doesn't currently allow the case
        // where b1 > b2, but this can be allowed for zero-terminated
        // arrays (since the true length isn't known.)  Of course,
        // this obligates a run-time check.
	break;
      case $(&Upper_b(e2), &DynEither_b):
        if (!Evexp::c_can_eval(e2))
          terr(e->loc,"cannot perform coercion since numelts cannot be determined statically.");
        let $(i,valid) = Evexp::eval_const_uint_exp(e2);
        // sanity checking
        if (coercion == Null_to_NonNull)
            impos("conversion mis-classified as null-check: %s",exp2string(e));
	if(is_toplevel(nv)) {
	  // can't use a function at top-level and don't want macros
          if (zt1 && !p2.elt_tq.real_const && !zt2) {
            // If p2 is not zero-terminated and not const, then we subtract
            // one from the size so that no one can write the last location.
            e2 = prim2_exp(Minus,e2,uint_exp(1,DL),DL);
          }
	  e->r = make_toplevel_dyn_arr(old_t2,e2,e1)->r;
	} else {
          let tag_e = _tag_dyneither_e;
	  // cast from t*{n} or t@{n} to t? or t?
          if (zt1) {
            // if p1 is zero-terminated then calculate the size dynamically:
            //   ({ t *x = e1;
            //      _dynxxx_ptr_arr(x, sizeof(t), _get_zero_arr_size(x,n));
            //   })
            let x = temp_var();
            let x_exp = var_exp(x,DL);
            exp_t arg3;
            // if what we're casting is a string constant or an array
            // variable, we can avoid computing the "size" at run-time.
            switch (e1->r) {
            case &Const_e({.String_c = _}):
              arg3 = e2; break;
            case &Const_e({.Wstring_c = _}):
              arg3 = e2; break;
            case &Var_e(&Global_b(vd)): fallthru(vd);
            case &Var_e(&Local_b(vd)):
              if (!Tcutil::is_array(vd->type)) fallthru;
              arg3 = e2;
              break;
            default:
              // if what we're casting has a known size > 1 then
              // we use it instead of calculating the size at run-time
              if (valid && i != 1) 
                arg3 = e2;
              else 
                arg3 = fncall_exp(getFunctionRemovePointer(
                                                           &_get_zero_arr_size_functionSet,e1),
                                  list(cast_it(void_star_typ(),x_exp),e2),DL);
              break;
            }
            if (!zt2 && !p2.elt_tq.real_const) {
              // If p2 is not zero-terminated and not const, then we subtract
              // one from the size so that no one can write the last location.
              arg3 = prim2_exp(Minus,arg3,uint_exp(1,DL),DL);
            }
            let arg2 = sizeoftyp_exp(typ_to_c(p2.elt_typ),DL);
            let tg_exp = fncall_exp(tag_e,list(x_exp,arg2,arg3),DL);
            let s = exp_stmt(tg_exp,DL);
            s = declare_stmt(x,typ_to_c(old_t2),e1,s,DL);
            e->r = stmt_exp_r(s);
          } else {
            // build the t ? struct
            e->r = fncall_exp_r(tag_e,
                                list(e1,
                                     sizeoftyp_exp(typ_to_c(p2.elt_typ),DL),
                                     e2));
          }
        }
	break;
      case $(&DynEither_b, &Upper_b(e2)):
        if (!Evexp::c_can_eval(e2))
          terr(e->loc,"cannot perform coercion since numelts cannot be determined statically.");
	if(is_toplevel(nv))
	  unimp("can't coerce t? to t* or t@ at the top-level");
        // When we have t?ZEROTERM and are casting to
        // t*{e2} or t@{e2} *without* the ZEROTERM, then we
        // can't allow e2 to be the actual size of the array --
        // it needs to be one less to ensure that you can't
        // overwrite the trailing 0.  We achieve this by
        // incrementing e2 by one.  That is if x has type t?Z,
        // and we're casting it to t@{2}, then we'd better check
        // that the size is at least 2+1=3.
        let new_e2 = e2;
        if (zt1 && !zt2) {
          new_e2 = add_exp(e2,uint_exp(1,DL),DL);
        }
	// cast from t ? to t* or t@ -- run-time check:
	// for t*: (t *)_untag_arr(e1, sizeof(t), new_e2)
	// for t@: (t *)_check_null(_untag_arr(e1, sizeof(t), new_e2))
        let untag_e = _untag_dyneither_ptr_e;
	let ptr_exp = fncall_exp(untag_e,
				 list(e1,
                                      sizeoftyp_exp(typ_to_c(p1.elt_typ),DL),
				      new_e2), DL);
	if(!n2)
	  ptr_exp->r = fncall_exp_r(_check_null_e,
                                    new List(copy_exp(ptr_exp), NULL));
	e->r = cast_it_r(*t, ptr_exp);
	break;
      // If p1 is zero-terminated and p2 is not, then p2 had better
      // be const or else we have to decrement its size by 1.
      case $(&DynEither_b, &DynEither_b):
DynCast:
        if (zt1 && !zt2 && !p2.elt_tq.real_const) {
          if (is_toplevel(nv))
            unimp("can't coerce a ZEROTERM to a non-const NOZEROTERM pointer at toplevel");
          let td_e = _dyneither_ptr_decrease_size_e;
          e->r = fncall_exp_r(td_e,
                              list(e1,sizeoftyp_exp(typ_to_c(p1.elt_typ),DL),
                                   uint_exp(1,DL)));
        }
	break;
      }
      break;
    case $(&PointerType(p1), &IntType(_,_)):
      switch(conref_def(bounds_one,p1.ptr_atts.bounds)) {
      case &DynEither_b: // cast t? to int -- cast curr field to int
	e1->r = aggrmember_exp_r(new_exp(e1->r,e1->loc),curr_sp);
	e1->topt = new_typ_c;
	break;
      default: break;
      }
      break;
    default: 
      if (unify(old_t2_c,new_typ_c))
        e->r = e1->r;
      break;
    }
    break;

  case &Address_e(e1): // FIX: support & e as malloc-and-initialize?
    set_lhs(nv,true);
    exp_to_c(nv,e1);
    set_lhs(nv,false);
    if(!is_lvalue(e1)) {
      lvalue_assign(e1,NULL,address_lvalue,true);
      // the wrong cast got pushed out, so as a kludge, just re-cast
      e->r = cast_it_r(typ_to_c((type_t)e->topt),e1);
    } else if (kind_leq(&ak,typ_kind((type_t)e1->topt))) {
      // we could be taking the address of an abstract member, so
      // insert a cast here.
      e->r = cast_it_r(typ_to_c((type_t)e->topt),e1);
    }
    break;

  case &New_e(rgnopt,e1):
    // we share the work with RemoveAggrs:
    // * we do the malloc and the result expression
    // * we pass the destination for the initializer, which RemoveAggrs
    //   then gets rid of
    exp_to_c(nv,e1);
    // determine elt_typ after translating e1 due to the struct hack
    type_t elt_typ = typ_to_c((type_t)e1->topt); 
    let x = temp_var();
    let xexp = var_exp(x,DL);
    exp_t lhs;
    switch(compress(elt_typ)) {
    case &ArrayType(ArrayInfo(t2,...)): 
      elt_typ = typ_to_c(t2); 
      lhs = copy_exp(xexp);
      break;
    default: 
      lhs = deref_exp(copy_exp(xexp),DL); 
      break;
    }
    exp_opt_t array_len = array_length_exp(e1);
    let lenvar = array_len ? (qvar_opt_t)temp_var() : NULL;
    let lenexp = array_len ? (exp_opt_t)var_exp((qvar_t)lenvar,DL) : NULL;
    exp_t      mexp;
    if(array_len)
      mexp = fncall_exp(_check_times_e,
			list((exp_t)lenexp,sizeoftyp_exp(elt_typ,DL)),DL);
    else
      mexp = sizeofexp_exp(deref_exp(xexp,DL),DL);
    // deal with the struct hack (executing the bound twice and suffering
    // an unnecessary copy of the data)
    let vse = get_varsizeexp(e1);
    if(vse != NULL)
      mexp = add_exp(mexp,vse,DL);
    
    if(rgnopt == NULL || no_regions)
      mexp = malloc_exp(elt_typ,mexp);
    else {
      exp_t r = (exp_t)rgnopt;
      exp_to_c(nv,r);
      mexp = rmalloc_exp(r,mexp);
    }
    exp_t answer;
    if(is_dyneither_ptr(old_typ))
      answer = fncall_exp(_tag_dyneither_e,
			  list(copy_exp(xexp),
			       sizeoftyp_exp(elt_typ,DL),
			       (lenexp ? lenexp : uint_exp(1,DL))),DL);
    else
      answer = copy_exp(xexp);
    e->annot = new Dest(xexp); // RemoveAggrs puts in the assignments
    let s = declare_stmt(x,cstar_typ(elt_typ,mt_tq),mexp,
			 seq_stmt(exp_stmt(copy_exp(e),DL),
				  exp_stmt(answer,DL),DL),DL);
      
    if(array_len)
      s = declare_stmt((qvar_t)lenvar,uint_typ,(exp_t)array_len,s,DL);
    e->r = stmt_exp_r(s);
    if(vse != NULL) // in case of the struct hack, types do not line up
      e->r = cast_it_r(typ_to_c(old_typ),copy_exp(e));
    break;

  case &Sizeofexp_e(e1): 
    // turn off array bounds checking in here...
    let old_in_sizeof = set_in_sizeof(nv,true);
    exp_to_c(nv,e1); 
    set_in_sizeof(nv,old_in_sizeof);
    break;
  case &Sizeoftyp_e(t):  e->r = new Sizeoftyp_e(typ_to_c(t));  break;
  case &Offsetof_e(t,fs):
    let t2 = t;
    let l = fs;
    for (; l != NULL; l=l->tl) {
      switch (l->hd) {
      case &StructField(n): break;
      case &TupleIndex(n):
	switch(compress(t2)) {
	case &AggrType(AggrInfo(info,_)):
	  let ad = get_known_aggrdecl(info);
	  if(ad->impl==NULL)
	    toc_impos("struct fields must be known");
	  fallthru(ad->impl->fields);
	case &AnonAggrType(_,fields):
	  let nth_field = List::nth(fields,n);
	  l->hd = new StructField(nth_field->name);
	  t2 = nth_field->type;
	  break;
	case &TupleType(ts):
	  l->hd = new StructField(fieldname(n+1));
	  t2 = (*List::nth(ts,n))[1];
	  break;
	case &DatatypeFieldType(DatatypeFieldInfo({.KnownDatatypefield=$(_,tuf)},_)):
	  if(n == 0)
	    l->hd = new StructField(tag_sp);
	  else {
	    t2 = (*List::nth(tuf->typs,n-1))[1];
	    l->hd = new StructField(fieldname(n));
	  }
	  break;
	default: toc_impos("impossible type for offsetof tuple index");
	  break;
	}
	break;
      }
    }
    e->r = new Offsetof_e(typ_to_c(t),fs);
    break;
  case &Deref_e(e1):
    let old_lhs = in_lhs(nv);
    set_lhs(nv,false);
    let e1_typ = compress((type_t)e1->topt);
    switch (e1_typ) {
    case &PointerType(PtrInfo{t2,tq,PtrAtts(rgn,cr,b,zt,_)}):
      switch (conref_def(bounds_one,b)) {
      case &Upper_b(nelts):
	bool do_null_check = !in_sizeof(nv) && need_null_check(e1);
	exp_to_c(nv,e1);
        if (do_null_check) {
          if (warn_all_null_deref)
            warn(e->loc, "inserted null check due to dereference");
	  // *((t *)_check_null(e))
          e1->r = cast_it_r(typ_to_c(e1_typ),
                            fncall_exp(_check_null_e,
                                       new List(copy_exp(e1),NULL),DL));
        }
        // Note that a null check is sufficient for zero-terminated arrays
        // too, because we guarantee that there's something to read here,
        // even if it's just a 0.  Note that writes are handled specially
        // by the AssignOp_e case.
        if (!in_sizeof(nv) && !conref_def(false,zt)) {
          let $(i,b) = Evexp::eval_const_uint_exp(nelts);
          // FIX:  should really do like below for the -> case
          // and check at run-time.  We'd still have to rule out
          // those bounds for which C cannot evaluate them (e.g.,
          // due to valueof.)
          if (!b || i <= 0)
            terr(e->loc,"cannot determine dereference is in bounds");
        }
	break;
      case &DynEither_b:
	// do it as e1[0], could share all the 0's but who cares
	let ind_e = uint_exp(0,DL);
	ind_e->topt = uint_typ;
	e->r = subscript_exp_r(e1, ind_e);
	exp_to_c(nv,e);
	break;
      }
      break;
    default: toc_impos("exp_to_c: Deref: non-pointer");
    }
    set_lhs(nv,old_lhs);
    break;
  case &AggrMember_e(e1,f,is_tagged,is_read):
    bool is_poly = is_poly_project(e);
    type_t e1_cyc_type = (type_t)e1->topt;
    exp_to_c(nv, e1);
    if (is_tagged && is_read) {
      e->r = check_tagged_union(e1,typ_to_c(e1_cyc_type),e1_cyc_type,f,
                                in_lhs(nv),
                                member_exp);
    }
    if(is_poly)
      e->r = array_to_ptr_cast(typ_to_c((type_t)e->topt),new_exp(e->r,DL),DL)->r;
    break;
  case &AggrArrow_e(e1,f,is_tagged,is_read):
    let old_lhs = in_lhs(nv);
    set_lhs(nv,false);
    type_t e1typ = compress((type_t)e1->topt);
    bool do_null_check = need_null_check(e1);
    exp_to_c(nv, e1);
    bool is_poly = is_poly_project(e); // decide before mutating e
    let PtrInfo{ta,tq,PtrAtts(rgn,bcr,b,zt,_)} = get_ptr_type(e1typ);
    switch (conref_def(bounds_one,b)) {
    case &Upper_b(esz):
      // the type-checker should've ensured the size is at least 1
      // FIX: on unknown, dynamic bounds check!
      let $(j,known) = Evexp::eval_const_uint_exp(esz);
      if(known) {
	if (j < 1)
	  impos("exp_to_c:  AggrArrow_e on pointer of size 0");
	if (do_null_check) {
          if (warn_all_null_deref)
            warn(e->loc, "inserted null check due to dereference");
	  // ((t *)_check_null(e))->f
	  e1->r = cast_it_r(typ_to_c(e1typ),
                            fncall_exp(_check_null_e,
                                       list(new_exp(e1->r,0)),DL));
	}
      } else {
        if (!Evexp::c_can_eval(esz))
          terr(e->loc,"cannot determine pointer dereference in bounds");
	// very strange case: they may have used sizeof or offsetof to make
	// a zero-size array.  Yeah, that'll happen never.
	e1->r = cast_it_r(typ_to_c(e1typ),
                          fncall_exp(_check_known_subscript_null_e,
                                     list(new_exp(e1->r,0),esz,
                                          sizeoftyp_exp(ta,DL),
                                          uint_exp(0,DL)),DL));
      }
      break;
    case &DynEither_b:
      // ((ta1 *)_check_unknown_subscript(e1, sizeof(ta1), 0))->f
      type_t ta1 = typ_to_c(ta);
      e1->r = cast_it_r(cstar_typ(ta1,tq),
                        fncall_exp(_check_dyneither_subscript_e,
                                   list(new_exp(e1->r,DL),
                                        sizeoftyp_exp(ta1,DL),
                                        uint_exp(0,DL)),DL));


      break;
    }
    if (is_tagged && is_read) {
      e->r = check_tagged_union(e1,typ_to_c(e1typ),ta,f,in_lhs(nv),aggrarrow_exp);
    }
    if(is_poly && is_read)
      e->r = array_to_ptr_cast(typ_to_c((type_t)e->topt),new_exp(e->r,DL),DL)->r;
    set_lhs(nv,old_lhs);
    break;
  case &Subscript_e(e1,e2):
    let old_lhs = in_lhs(nv);
    set_lhs(nv,false);
    let e1_typ = compress((type_t)e1->topt);
    // e1 could be a tuple or an array of various sorts
    switch (e1_typ) {
    case &TupleType(ts):
      // e1->fi  where i = e2+1
      exp_to_c(nv, e1);
      exp_to_c(nv, e2);
      let $(i,known) = Evexp::eval_const_uint_exp(e2);
      if(!known)
	impos("unknown tuple subscript in translation to C");
      e->r = aggrmember_exp_r(e1,fieldname(i+1));
      break;
    case &PointerType(PtrInfo{ta,tq,PtrAtts(rgn,bcr,b,zt,_)}):
      let relns = get_relns(e1);
      let need_nullchk = need_null_check(e1);
      let in_sz = in_sizeof(nv);
#ifdef BCE_DEBUG
      fprintf(stderr,"subscript %s, array has type %s: relns:",exp2string(e),
              typ2string((type_t)e1->topt));
      Relations::print_relns(stderr,relns); fprintf(stderr,"\n");
#endif
      bool in_bnds = in_sz;
      switch (conref_def(bounds_one,b)) {
      default:
	in_bnds = in_bnds || check_bounds(e1_typ,relns,e1,e2);
	if(warn_bounds_checks && !in_bnds)
	  warn(e->loc,"bounds check necessary for %s", exp2string(e));
#ifdef BCE_DEBUG
      fprintf(stderr,"check bounds returned %s\n", in_bnds ? "true " : "false");
#endif
      }
      exp_to_c(nv, e1);
      exp_to_c(nv, e2);
      total_bounds_checks++;
      switch (conref_def(bounds_one,b)) {
      case &Upper_b(esz):
        bool possibly_null = conref_def(false,bcr) && need_nullchk;
	type_t ta1 = typ_to_c(ta);
	type_t ta2 = cstar_typ(ta1, tq);
        let $(i,valid) = Evexp::eval_const_uint_exp(esz);
        if (in_bnds && !possibly_null)
	  bounds_checks_eliminated++;
        else if (in_bnds && possibly_null) {
          bounds_checks_eliminated++;
          if (warn_all_null_deref)
            warn(e->loc, "inserted null check due to dereference");
          e1->r = cast_it_r(ta2,fncall_exp(_check_null_e,
                                           list(copy_exp(e1)),DL));
        // for zero-terminated pointers with a bound of 1, we calculate
        // the bound dynamically.
        } else if (valid && i == 1 && conref_def(false,zt)) {
          // *((ta2)_zero_arr_plus(e1, esz, e2)
          if (!Evexp::c_can_eval(esz))
            terr(e->loc,"cannot determine subscript is in bounds");
          exp_t function_e = getFunctionRemovePointer(&_zero_arr_plus_functionSet,e1);
          e->r = deref_exp_r(cast_it(ta2,
                                     fncall_exp(function_e,
                                                list(e1,esz,e2),DL)));
        } else if(possibly_null) {
          if (!Evexp::c_can_eval(esz))
            terr(e->loc,"cannot determine subscript is in bounds");
          if (warn_all_null_deref)
            warn(e->loc, "inserted null check due to dereference");
	  // *((ta2)_check_known_subscript_null(e1, esz, sizeof(ta), e2)
	  e->r = deref_exp_r(cast_it(ta2,
                                     fncall_exp(_check_known_subscript_null_e,
                                                list(e1,esz,
                                                     sizeoftyp_exp(ta1,DL),
                                                     e2),DL)));
	} else {
          if (!Evexp::c_can_eval(esz))
            terr(e->loc,"cannot determine subscript is in bounds");
	  // e1[_check_known_subscript_notnull(esz,e2)]
	  e2->r = fncall_exp_r(_check_known_subscript_notnull_e,
                               list(esz,copy_exp(e2)));
        }
	break;
      case &DynEither_b:
	type_t ta1 = typ_to_c(ta);
        if (in_bnds) {
          // there's no need for a null-check here either because
          // a NULL ? pointer has size 0
          bounds_checks_eliminated++;
          e->r = subscript_exp_r(cast_it(cstar_typ(ta1,tq),
                                         member_exp(e1,curr_sp,DL)),e2);
        } else {
          // *((ta1 *) _check_unknown_subscript(e1, sizeof(ta1), e2))
          let _check_f = _check_dyneither_subscript_e;
          e->r = deref_exp_r(cast_it(cstar_typ(ta1,tq),
                                     fncall_exp(_check_f,
                                                list(e1,sizeoftyp_exp(ta1,DL),
                                                     e2),DL)));
        }
	break;
      }
      break;
    default: toc_impos("exp_to_c: Subscript on non-tuple/array/tuple ptr");
    }
    set_lhs(nv,old_lhs);
    break;
  case &Tuple_e(es): 
    if(!is_toplevel(nv)) {
      // convert to a struct and rely on RemoveAggrs
      let strct_typ = add_tuple_type(List::map(tup_to_c,es));
      switch(strct_typ) {
      case &AggrType(AggrInfo(aggrinfo,NULL)): 
	list_t<$(list_t<designator_t>,exp_t)@> dles = NULL;
	aggrdecl_t sd = get_known_aggrdecl(aggrinfo);
	for(int i=1; es != NULL; es = es->tl, ++i) {
	  exp_to_c(nv,es->hd);
	  dles = new List(make_field(fieldname(i),es->hd), dles);
	}
	e->r    = new Aggregate_e(sd->name,NULL,imp_rev(dles),sd);
	e->topt = strct_typ;
	break;
      default: toc_impos("tuple type not an aggregate");
      }
      break;
    } else {
      // At top-level use an initializer
      // $(e1,...,en) -> {e1,...,en}
      list_t<$(list_t<designator_t,`H>,exp_t)@`H,`H> dles = NULL;
      for (; es != NULL; es = es->tl) {
	exp_to_c(nv,es->hd);
	dles = new List(new $(NULL,es->hd),dles);
      }
      e->r = unresolvedmem_exp_r(NULL,imp_rev(dles));
    }
    break;
  case &Array_e(dles0):
    // We now leave this to RemoveAggrs, which converts this to assignments
    // (it can only occur as an initializer)
    // but toplevel arrays must be converted to unresolvedMem to appease
    // passes downstream
    for (let dles = dles0; dles != NULL; dles = dles->tl)
      exp_to_c(nv,(*dles->hd)[1]);
    if(is_toplevel(nv))
      e->r = unresolvedmem_exp_r(NULL,dles0);
    break;
  case &Comprehension_e(vd,e1,e2,iszeroterm):
    // at top-level e1 and e2 must be constant and we make an unresolvedmem_exp.
    // inside a function, we now pass the buck to RemoveAggrs
    exp_to_c(nv,e1);
    exp_to_c(nv,e2);
    if(is_toplevel(nv)) {
      let $(sz,known) = Evexp::eval_const_uint_exp(e1);
      let elt_typ = typ_to_c((type_t)e2->topt);
      list_t<$(list_t<designator_t>,exp_t)@> es = NULL;
      // if e2 is 0, generate an "empty" array intializer to avoid giant arrays
      if (!is_zero(e2)) {
	if(!known)
	  terr(e1->loc, "cannot determine value of constant");
	for (unsigned int i = 0; i < sz; i++)
	  es = new List(new $(NULL,e2),es);
	// for a zero-terminated comprehension, add in an implicit 0 to the end
	if (iszeroterm) {
	  let ezero = cast_it(elt_typ,uint_exp(0,DL));
	  es = List::imp_append(es,new List{new $(NULL,ezero), NULL});
	}
      }
      e->r = unresolvedmem_exp_r(NULL,es);
    }
    break;
  case &ComprehensionNoinit_e(e1,t1,iszeroterm):
    // at toplevel, we can just make an empty array and rely on the
    // expression's type to build an array of the right size
    // inside a function, we now pass the buck to RemoveAggrs
    // FIX?: not sure if zeroterm should be allowed here since we do not
    //       initialize?
    if(is_toplevel(nv))
      e->r = unresolvedmem_exp_r(NULL,NULL);
    else
      exp_to_c(nv,e1);
    break;

  case &AnonStruct_e(st,dles): // note: no support for struck hacks
    for(let dles2=dles; dles2!=NULL; dles2=dles2->tl)
      exp_to_c(nv,(*dles2->hd)[1]);
    let strct_typ = typ_to_c((type_t)e->topt);
    e->topt = strct_typ;
    if(!is_toplevel(nv)) {
      switch(compress(strct_typ)) {
      case &AggrType(AggrInfo(aggrinfo,NULL)): 
	aggrdecl_t sd = get_known_aggrdecl(aggrinfo);
	e->r    = new Aggregate_e(sd->name,NULL,dles,sd);
	e->topt = strct_typ;
	break;
      default: toc_impos("anonStruct type not an aggregate");
      }
    } else
      e->r = unresolvedmem_exp_r(NULL,dles);
    break;

  case &Aggregate_e(*tdn,exist_ts,dles,sd):
    // now relegate rewriting to RemoveAggrs, but we still may need to 
    // generate struct definitions and other nasty stuff
    if(sd==NULL || sd->impl==NULL)
      toc_impos("exp_to_c, Aggregate_e: missing aggrdecl pointer or fields");
    let new_typ = typ_to_c(old_typ);
    switch(compress(new_typ)) { // typ_to_c may change the struct name!
    case &AggrType(AggrInfo(info,_)): *tdn = aggr_kinded_name(info)[1]; break;
    default: toc_impos("exp_to_c, Aggregate_e: bad type translation");
    }
    // to handle struct kludges for the last field of the type
    // definition, we grab the last field
    // FIX?: should probably support these kludges for tuples and datatypes
    // too, which suggests doing it after translating more things to aggregates
    let typ_fields = sd->impl->fields;
    if(typ_fields==NULL) return; // no fields (maybe possible)
    for(; typ_fields->tl != NULL; typ_fields = typ_fields->tl)
      ;
    let last_typ_field = typ_fields->hd;
    let fields = resolve_aggregate_designators(heap_region, e->loc, dles,
					       sd->kind, sd->impl->fields);
    if(!is_toplevel(nv)) {
      switch(compress(old_typ)) {
      case &AggrType(AggrInfo(_,param_ts)):
	// now translate the fields, with special cases noted as they occur
	for(let fields2=fields; fields2!=NULL; fields2=fields2->tl) {
	  let &$(aggrfield,fieldexp) = fields2->hd;
	  let old_field_typ = fieldexp->topt; // for kludge below
	  exp_to_c(nv,fieldexp);
	  // warning avoidance
	  if (is_void_star_or_boxed_tvar(aggrfield->type) && 
	      !is_pointer_or_boxed_tvar((type_t)fieldexp->topt))
	    fieldexp->r = cast_it(typ_to_c(aggrfield->type),
				  copy_exp(fieldexp))->r;
	  // tagged unions: have to add the tag field
	  if(sd->impl->tagged) {
	    let n = aggrfield->name;
	    let tag_exp = uint_exp(get_member_offset(sd,n),DL);
	    let tag_dle = make_field(tag_sp,tag_exp);
	    let val_dle = make_field(val_sp,fieldexp);
	    qvar_t s = new $(Abs_n(NULL,true),
			     new (string_t)aprintf("_union_%s_%s",
						   *(*sd->name)[1],*n));
	    let u_dle = 
	      make_field(n,new_exp(new Aggregate_e(s,NULL,list(tag_dle,val_dle),
						   NULL),DL));
	    e->r = new Aggregate_e(*tdn,NULL,list(u_dle),sd);
	  }
	  // if the last field has abstract mem-kind (after instantiating
	  // the type-parameters), we have to generate a type here.
	  // (If the instantiation is concrete, typ_to_c handles it)
	  // Note: unions cannot have abstract mem-kind fields
	  if(is_abstract_type(old_typ) && last_typ_field==aggrfield) {
	    let inst = append(zip(sd->impl->exist_vars,exist_ts),
			      zip(sd->tvs,param_ts));
	    list_t<aggrfield_t> new_fields = NULL;
	    for(let fs = sd->impl->fields; fs!=NULL; fs=fs->tl) {
	      let old_f = fs->hd;
	      let old_ftyp = substitute(inst,old_f->type);
	      let new_f = aggrfield_to_c(old_f,
					 typ_to_c(substitute(inst,old_ftyp)));
	      new_fields = new List(new_f,new_fields);
	      // if we do not know the last field's size, we must
	      // use a struct hack (in coordination with the New_e case,
	      // which uses get_varsizeexp
	      // KLUDGE: we must set the topt of the field in case we are 
	      //  a nested aggregate, so the outer one uses the right type
	      if(fs->tl==NULL) {
		switch(compress(new_f->type)) {
		case &ArrayType(ai):
		  if(!Evexp::c_can_eval((exp_t)(ai.num_elts))) {
		    let ai2 = ai;
		    ai2.num_elts = uint_exp(0,DL); // zero-length array type
		    new_f->type = new ArrayType(ai2);
		  }
		  break;
		default: 
		  // see kludge above: we may be the outer aggregate, so we
		  // we have to get the new inner-aggregate's type
		  if(fieldexp->topt==NULL)
		    break;
		  switch(compress((type_t)fieldexp->topt)) {
		  case &AggrType(_): 
		    new_f->type = (type_t)fieldexp->topt; break;
		  default: break;
		  }
		  break;
		}
		//DJG: FIX I think this is broken for an array with element-type
		//     of abstract mem kind
		if(!is_array_type(old_f->type) &&
		   kind_leq(&ak,typ_kind(old_f->type)))
		  new_f->attributes = new List(new Aligned_att(NULL),
					       new_f->attributes);
	      }
	    }
	    sd = make_c_struct_defn(new (string_t)aprintf("_genStruct%d",
						  tuple_type_counter++),
				    imp_rev(new_fields));
	    *tdn = sd->name;
	    aggrdecl_to_c(sd,true); // to add the decl
	    // see kludge above: must set topt in case we are an inner aggregate
	    e->topt = new AggrType(AggrInfo(KnownAggr(new(aggrdecl_t)sd),NULL));
	  }
	}
	break;
      default: toc_impos("exp_to_c, Aggregate_e: bad struct type");
      }
    } else {
      // At top-level must create an initializer.  For MSVC, sort fields
      // and drop initializers (sorting okay b/c we're at top-level)
      //
      // JGM: unfortunately, doesn't work for tagged unions -- we need
      // the designators to distinguish the various cases.
      if (sd->impl->tagged) {
        // should only be one field
        let &$(field,fieldexp) = fields->hd;
        let fieldexp_type = (type_t)fieldexp->topt;
        let fieldtyp = field->type;
        exp_to_c(nv,fieldexp);
        if (is_void_star_or_boxed_tvar(fieldtyp) &&
            !is_void_star_or_boxed_tvar(fieldexp_type))
          fieldexp->r =
            cast_it_r(void_star_typ(),new_exp(fieldexp->r,DL));
        // for tagged unions, must insert tag here
        int i = get_member_offset(sd,field->name);
        exp_t field_tag_exp = signed_int_exp(i,0);
        let newdles = list(new $(NULL,field_tag_exp), new $(NULL,fieldexp));
        exp_t umem = unresolvedmem_exp(NULL,newdles,0);
        e->r = unresolvedmem_exp_r(NULL,list(make_field(field->name,umem)));
      } else { // not tagged
        // here is where we now sort
        let newdles = NULL;
        let sdfields = sd->impl->fields;
        for(; sdfields!=NULL; sdfields=sdfields->tl)
          for (let fields2 = fields; fields2 != NULL; fields2 = fields2->tl) {
            if((*fields2->hd)[0] == sdfields->hd) {
              let &$(field,fieldexp) = fields2->hd;
              let fieldtyp = typ_to_c(field->type);
              let fieldexp_typ = typ_to_c((type_t)fieldexp->topt);
              exp_to_c(nv,fieldexp);
              // must cast when the types don't match up 
              if (!unify(fieldtyp, fieldexp_typ)) 
                // unless they are both arithmetic types -- C can handle this.
                if (!is_arithmetic_type(fieldtyp) ||
                    !is_arithmetic_type(fieldexp_typ))
                fieldexp = cast_it(fieldtyp, copy_exp(fieldexp));
              newdles = new List(new $(NULL,fieldexp), newdles);
              break;
            }
          }
        e->r = unresolvedmem_exp_r(NULL,imp_rev(newdles));
      }
    }
    break;

  case &Datatype_e(es,tud,tuf):
    // convert the es, inserting casts to avoid GCC warnings
    let tqts = tuf->typs;
    for(let es2 = es; es2!=NULL; es2=es2->tl, tqts=tqts->tl) {
      exp_t cur_e = es2->hd;
      let cur_e_typ = (type_t)cur_e->topt;
      type_t field_typ = typ_to_c((*tqts->hd)[1]);
      exp_to_c(nv,cur_e);
      if (is_void_star_or_boxed_tvar(field_typ) && 
	  !is_pointer_or_boxed_tvar(cur_e_typ))
	  cur_e->r = cast_it(field_typ,cur_e)->r;
    }
    // create the tag initializer
    let tag_exp = (tud->is_extensible) ? var_exp(tuf->name,DL) :
      datatype_tag(tud,tuf->name);
    // convert to a struct
    if(!is_toplevel(nv)) {
      // make an Aggregate_e and rely on RemoveAggrs (similar to tuple case)
      list_t<$(list_t<designator_t>,_)@> dles = NULL;
      for(int i=1; es!=NULL; es=es->tl, ++i)
	dles = new List(make_field(fieldname(i),es->hd), dles);
      // FIX? leaves the last field NULL (TocState does not have what we want)
      // RemoveAggrs does not currently use the field, but for computing
      // the malloc-exp, we will assume the last field is not an abstract-mem
      let tag_dle = make_field(tag_sp,tag_exp);
      e->r = new Aggregate_e(collapse_qvars(tuf->name,tud->name), NULL,
			     new List(tag_dle, imp_rev(dles)), NULL);
    } else {
      // At top-level use an initializer (identical code in tuple case;
      // should share in RemoveAggrs)
      let dles = NULL;
      for(; es!=NULL; es=es->tl)
	dles = new List(new $(NULL,es->hd), dles);
      e->r = unresolvedmem_exp_r(NULL,new List(new $(NULL,tag_exp),
					       imp_rev(dles)));
    }
    break;

  case &Enum_e(...):
  case &AnonEnum_e(...): break;

  case &Malloc_e(MallocInfo{is_calloc,rgnopt,topt,num_elts,is_fat,inline_call}):
    type_t t_c = typ_to_c(*topt);
    exp_to_c(nv,num_elts);
    // FIX: we shouldn't be able to calloc a zero-terminated array of
    // size less than 1.
    if (is_fat) {
      let x = temp_var();
      let p = temp_var();
      exp_t pexp, xexp, rexp;
      if (is_calloc) {
        xexp = num_elts;
        if (rgnopt != NULL && !no_regions) {
          exp_t rgn = (exp_t)rgnopt;
          exp_to_c(nv,rgn);
          pexp = rcalloc_exp(rgn, sizeoftyp_exp(t_c,DL), var_exp(x,DL));
        } else {
          pexp = calloc_exp(*topt,sizeoftyp_exp(t_c,DL), var_exp(x,DL));
        }
        rexp = fncall_exp(_tag_dyneither_e,
                          list(var_exp(p,DL),sizeoftyp_exp(t_c,DL),
                               var_exp(x,DL)), DL);
      } else {
        if (rgnopt != NULL && !no_regions) {
          exp_t rgn = (exp_t)rgnopt;
          exp_to_c(nv,rgn);
          if (inline_call)
            pexp = rmalloc_inline_exp(rgn, var_exp(x,DL));
          else
            pexp = rmalloc_exp(rgn, var_exp(x,DL));
        } else {
          pexp = malloc_exp(*topt, var_exp(x,DL));
        }
        rexp = fncall_exp(_tag_dyneither_e, list(var_exp(p,DL),uint_exp(1,DL),
                                                  var_exp(x,DL)), DL);
      }
      let s = declare_stmt(x, uint_typ, num_elts,
                           declare_stmt(p,cstar_typ(t_c,mt_tq),pexp,
                                        exp_stmt(rexp,DL),DL),DL);
      e->r = stmt_exp_r(s);
    } else {
      if (is_calloc) {
        if (rgnopt != NULL && !no_regions) {
          exp_t rgn = (exp_t)rgnopt;
          exp_to_c(nv,rgn);
          e->r = rcalloc_exp(rgn, sizeoftyp_exp(t_c,DL), num_elts)->r;
        } else {
          e->r = calloc_exp(*topt,sizeoftyp_exp(t_c,DL), num_elts)->r;
        }
      } else {
        if (rgnopt != NULL && !no_regions) {
          exp_t rgn = (exp_t)rgnopt;
          exp_to_c(nv,rgn);
          if (inline_call)
            e->r = rmalloc_inline_exp(rgn, num_elts)->r;
          else
            e->r = rmalloc_exp(rgn, num_elts)->r;
        } else {
          e->r = malloc_exp(*topt, num_elts)->r;
        }
      }
    }
    break;

  case &Swap_e(e1,e2):
    // e1 :=: e2 becomes ({ typeof(e1) tmp = e1; typeof(e2) tmp2 = e2;
    //                      e1 = tmp2; e2 = tmp; })
    // This assumes that e1 and e2 are effect-free lvalues.  We implement
    // this by replacing e with a Cyclone expression implementing the swap,
    // and then reuse the existing code generator to get everything to work out,
    // e.g. to handle tagged unions.
    type_t e1_old_typ = (type_t)e1->topt;
    type_t e2_old_typ = (type_t)e2->topt;
    if (!is_boxed(e1_old_typ) && !is_pointer_type(e1_old_typ))
      toc_impos("Swap_e: is_pointer_or_boxed: not a pointer or boxed type");

    // create the Cyclone expression for the swap.  Need to deep copy the
    // expressions since the translation to C is by side-effect, and the rhs
    // and lhs of tagged unions are translated differently.
    let loc = e->loc;
    let v1 = temp_var();
    let v1e = var_exp(v1,loc); v1e->topt = e1_old_typ;
    let v2 = temp_var();
    let v2e = var_exp(v2,loc); v2e->topt = e2_old_typ;

    let s1e = assign_exp(deep_copy_exp(true,e1),v2e,loc); s1e->topt = e1_old_typ;
    let s1 = exp_stmt(s1e,loc); // e1 = v2
    let s2e = assign_exp(deep_copy_exp(true,e2),v1e,loc); s2e->topt = e2_old_typ;
    let s2 = exp_stmt(s2e,loc); // e2 = v1

    let s = declare_stmt(v1,e1_old_typ,e1, // typeof(e1) v1 = e1
			 declare_stmt(v2,e2_old_typ,e2, // typeof(e2) v2 = e2
				      seq_stmt(s1,s2,loc),loc),loc); // above asgns
    stmt_to_c(nv,s);
    e->r = stmt_exp_r(s);
    break;
  case &Tagcheck_e(e1,f):
    // e1.f.tag == f_tag
    let e1_typ = compress((type_t)e1->topt);
    exp_to_c(nv,e1);
    switch (e1_typ) {
    case &AggrType(AggrInfo({.KnownAggr = &ad}, _)):
      let f_tag = signed_int_exp(get_member_offset(ad,f),DL);
      let e1_f = member_exp(e1,f,DL);
      let e1_f_tag = member_exp(e1_f,tag_sp,DL);
      e->r = eq_exp(e1_f_tag,f_tag,DL)->r;
      break;
    default: toc_impos("non-aggregate type in tagcheck");
    }
    break;
  case &StmtExp_e(s): stmt_to_c(nv,s);  break;
  case &UnresolvedMem_e(_,_): toc_impos("UnresolvedMem");
  case &CompoundLit_e(_,_):   unimp("compoundlit");
  case &Valueof_e(_): toc_impos("valueof(-)");
  case &Asm_e(...): toc_impos("__asm__");
  }
}

///////////////////////////////////////////////////////////////
//              Translation of Switch Statements             //
///////////////////////////////////////////////////////////////
// We use the decision tree built by tcpat to compile switch/catch
// statements.  This is somewhat complicated by fallthru and
// where clauses as noted.  We use a switch statement if the
// pattern tests admit it and there's more than 1 alternative.
// Otherwise, we use if-then-else's.  The basic idea is to take
// the decision tree and compile it so that each right-hand-side (rhs)
// has two entry points:  One entry point, called init, extracts all of the values
// for the variables in the pattern and initializes the associated
// compiler temporary variables with those values.  The other entry
// point, called body, has the actual statement for the switch clause.
// For a fallthru, we jump to the next clauses's body.  If a statement
// shows up multiple times in the decision tree, we only generate
// the body once, and goto the body the other times.  


// generates a bool and two labels to be associated with the right-hand-side
// of a switch clause.  The bool records whether we've already emitted the
// code for this clause.  The first label is used for the code that extracts
// and initializes the variables of the pattern.  The second label is the
// entry point for the right-hand-side and is used for fallthru of previous
// switch cases.
static $(bool used,var_t,var_t,switch_clause_t)@`r gen_labels(region_t<`r> r,
                                                              switch_clause_t sc) {
  return rnew(r) $(false,fresh_label(),fresh_label(),sc);
}

// given a path from the match compiler and a root expression v,
// generate code for extracting the value.
static exp_t compile_path(Tcpat::path_t ps, exp_t v) {
  for (; ps != NULL; ps = ps->tl) {
    let p = ps->hd;
    // we cast the expression at each stage to avoid having to deal
    // with polymorphism and the like.  This generates bigger code
    // but it's a lot more uniform.
    if (tagcheck(p->orig_pat.pattern)) {
      type_t t = (type_t)p->orig_pat.pattern->topt; 
      let t2 = compress(typ_to_c_array(t));
      switch (t2) {
        // avoid casts that C will not like.
      case &VoidType: 
      case &AggrType(...):
      case &AnonAggrType(...): break;
      default:  v = cast_it(typ_to_c_array(t),v); break;
      }
    }
    switch (p->access) {
    case &Tcpat::Dummy: 
      // dummy accesses correspond to the extra tuple inserted
      // to deal with && clauses in patterns.  We handle those
      // somewhat separately.
      break;
    case &Tcpat::Deref: 
      // if the next access is a datatypefield, then we want to
      // make sure that we cast the pointer to the appropriate
      // struct pointer before dereferencing.  
      if (ps->tl != NULL) {
        switch (ps->tl->hd->access) {
        case &Tcpat::DatatypeField(tud, tuf, i):
          ps = ps->tl;
          v = cast_it(cstar_typ(strctq(collapse_qvars(tuf->name, tud->name)),mt_tq),v);
          v = aggrarrow_exp(v, fieldname(i+1), DL);
          continue;
        default: 
          break;
        }
      }
      v = deref_exp(v,DL);
      break;
    case &Tcpat::TupleField(i): v = member_exp(v,fieldname(i+1),DL); break;
    case &Tcpat::AggrField(tagged, f): 
      v = member_exp(v,f,DL); 
      if (tagged)  // tagged unions require getting the .val member
        v = member_exp(v,val_sp,DL);
      break;
    case &Tcpat::DatatypeField(tud, tuf, i): 
      v = member_exp(v, fieldname(i+1), DL);
      break;
    }
  }
  return v;
}

// given a root expression v and a pattern test, generate an
// expression suitable for an if-then-else.
static exp_t compile_pat_test(exp_t v, Tcpat::pat_test_t t) {
  switch (t) {
  case &Tcpat::WhereTest(e): 
    // FIX: we really shouldn't have e being null...
    if (e == NULL) return v; else return e;  
  case &Tcpat::EqNull: return eq_exp(v, signed_int_exp(0,DL),DL);
  case &Tcpat::NeqNull: return neq_exp(v, signed_int_exp(0,DL),DL);
  case &Tcpat::EqEnum(ed, ef): 
    return eq_exp(v, new_exp(new Enum_e(ed, ef),DL), DL);
  case &Tcpat::EqAnonEnum(t, ef): 
    return eq_exp(v, new_exp(new AnonEnum_e(t, ef),DL), DL);
  case &Tcpat::EqFloat(s,i): return eq_exp(v, float_exp(s,i,DL), DL);
  case &Tcpat::EqConst(i): return eq_exp(v, signed_int_exp(i,DL), DL);
  case &Tcpat::EqDatatypeTag(i,tud,tuf):
    // The compilation of the path has already done a dereference, so
    // get rid of any dereference in the path (peeking under casts.)
  LOOP1:
    switch (v->r) {
    case &Cast_e(_,e,...): v = e; goto LOOP1;
    case &Deref_e(e): v = e; break;
    default: break;
    }
    // cast v to a pointer to the datatype field
    v = cast_it(cstar_typ(strctq(collapse_qvars(tuf->name, tud->name)), mt_tq),v);
    return eq_exp(aggrarrow_exp(v,tag_sp,DL), uint_exp(i,DL),DL);
    //v = cast_it(cstar_typ(sint_typ,mt_tq),v); // FIX: share type
    //return eq_exp(deref_exp(v,DL), signed_int_exp(i,DL),DL);
  case &Tcpat::EqTaggedUnion(f,i):
    v = member_exp(member_exp(v,f,DL),tag_sp,DL);
    return eq_exp(v,signed_int_exp(i,DL),DL);
  case &Tcpat::EqExtensibleDatatype(tud,tuf): 
    // Same as with datatypes, so get rid of any dereference in the path.
  LOOP2:
    switch (v->r) {
    case &Cast_e(_,e,...): v = e; goto LOOP2;
    case &Deref_e(e): v = e; break;
    default: break;
    }
    // cast v to a pointer to the datatype field
    v = cast_it(cstar_typ(strctq(collapse_qvars(tuf->name, tud->name)), mt_tq),v);
    return eq_exp(aggrarrow_exp(v,tag_sp,DL), var_exp(tuf->name,DL), DL);
    //v = cast_it(cstar_typ(cstar_typ(char_typ,mt_tq),mt_tq),v); // FIX: share type
    //return eq_exp(deref_exp(v,DL), var_exp(tuf->name,DL), DL);
  }
}

// used to determine what kind of code to emit for the test of the switch
datatype TestKind { 
  OtherTest; 
  DatatypeTagTest;
  WhereTest(exp_t);
  TaggedUnionTest(field_name_t);
};
datatype TestKind.OtherTest OtherTest_val = OtherTest;
datatype TestKind.DatatypeTagTest DatatypeTagTest_val = DatatypeTagTest;


// returns the number of pattern tests that admit a switch, and whether
// the pattern test is a datatype test, a tagged union test, a where-clause
// test, or something else. If any pattern test does not support a switch, 
// then we return 0.
static $(int, datatype TestKind@) 
  admits_switch(list_t<$(Tcpat::pat_test_t, Tcpat::decision_t)@> ss) {
  int c = 0;
  datatype TestKind @ k = &OtherTest_val;
  for (; ss != NULL; ss = ss->tl, c = c+1) {
    let $(ptest,_) = *ss->hd;
    switch (ptest) {
      // these can all be put in switches
    case &Tcpat::EqEnum(_,_): 
    case &Tcpat::EqAnonEnum(_,_): 
    case &Tcpat::EqConst(_): 
      continue;
    case &Tcpat::EqTaggedUnion(f,_): 
      if (k == &OtherTest_val)
        k = new TaggedUnionTest(f);
      continue;
    case &Tcpat::EqDatatypeTag(_,_,_): 
      k = &DatatypeTagTest_val;
      continue;
      // the rest cannot be in a switch.
    case &Tcpat::WhereTest(e) && e != NULL:
      k = new WhereTest(e);
      return $(0, k);
    case &Tcpat::WhereTest(_):
    case &Tcpat::EqNull:
    case &Tcpat::NeqNull:
    case &Tcpat::EqFloat(_,_):
    case &Tcpat::EqExtensibleDatatype(_,_): return $(0,k);
    }
  }
  return $(c,k);
}

// given a pattern test to be used in a generated switch statement,
// extract the appropriate C-pattern (i.e., an integer).
static pat_t compile_pat_test_as_case(Tcpat::pat_test_t p) {
  exp_t e;
  switch (p) {
  case &Tcpat::EqEnum(ed,ef): 
    e = new_exp(new Enum_e(ed, ef), DL); break;
  case &Tcpat::EqAnonEnum(t, ef):
    e = new_exp(new AnonEnum_e(t, ef), DL); break;
  case &Tcpat::EqConst(i): fallthru(i);
  case &Tcpat::EqDatatypeTag(i,_,_): fallthru(i);
  case &Tcpat::EqTaggedUnion(_,i):
    e = uint_exp(i,DL);
    break;
  default: toc_impos("compile_pat_test_as_case!");
  }
  return new_pat(new Exp_p(e), DL);
}

// sequence two optional statements.
static stmt_opt_t seq_stmt_opt(stmt_opt_t s1, stmt_opt_t s2) {
  if (s1 == NULL) return s2;
  if (s2 == NULL) return s1;
  return seq_stmt(s1,s2,DL);
}

// given a pattern, produce code and environment to initialize the pattern
// variables with the appropriate values.  Updates the environment and
// decls which are passed in by reference.
static stmt_opt_t extract_pattern_vars(region_t<`rgn> rgn, env_t<`rgn> @nv,
                                       list_t<vardecl_t,`rgn>@ decls,
                                       exp_t path, pat_t p) {
  type_t t = (type_t)p->topt;
  switch (p->r) {
  case &AliasVar_p(_,vd):
    let p2 = new_pat(&Wild_p_val,0);
    p2->topt = p->topt;
    fallthru(vd,p2);
  case &Var_p(vd,p2):
    // v = r (hoisted and renamed later) and continue matching p2 against r
    *decls = rnew(rgn) List(vd,*decls);
    let s = assign_stmt(varb_exp(new Local_b(vd),DL),copy_exp(path),DL);
    return seq_stmt_opt(s,extract_pattern_vars(rgn,nv,decls,path,p2));
  case &TagInt_p(_,vd): // type translation erases tvar
    // v = r  (hoisted and renamed later)
    *decls = rnew(rgn) List(vd,*decls);
    return assign_stmt(varb_exp(new Local_b(vd),DL),copy_exp(path),DL);
  case &Wild_p: return NULL;
  case &Reference_p(vd,p2):
    // v = &path
    *decls = rnew(rgn) List(vd,*decls);
    vd->type = cstar_typ(t,mt_tq); //DJG: apparently necessary -- bug in tcPat?
    // cast is needed to avoid a C warning when pointing to a polymorphic field
    let s = assign_stmt(varb_exp(new Local_b(vd),DL),
			cast_it(cstar_typ(typ_to_c_array(t),mt_tq),
                                push_address_exp(copy_exp(path))),DL);
    return seq_stmt_opt(s, extract_pattern_vars(rgn,nv,decls,path,p2));
  // for these cases, no initialization.
  case &Null_p:      
  case &Int_p(...):  
  case &Char_p(_):   
  case &Float_p(...):
  case &Enum_p(...): 
  case &AnonEnum_p(...): return NULL;

    // special case for pointer to datatype
  case &Pointer_p(&Pat{&Datatype_p(tud,tuf,ps,_),_,_}):
    if (ps == NULL) return NULL;
    qvar_t tufstrct = collapse_qvars(tuf->name,tud->name);
    let field_ptr_typ = cstar_typ(strctq(tufstrct),mt_tq);
    path = cast_it(field_ptr_typ,path);
    int cnt      = 1;
    let tuf_tqts = tuf->typs;
    stmt_opt_t s = NULL;
    for(; ps != NULL; ps = ps->tl, tuf_tqts = tuf_tqts->tl, ++cnt) {
      let p2  = ps->hd;
      if(p2->r == &Wild_p_val) continue;
      let tuf_typ = (*tuf_tqts->hd)[1];
      let t2  = (type_t)p2->topt;
      let t2c = typ_to_c_array(t2);
      let arrow_exp = aggrarrow_exp(path, fieldname(cnt), DL);
      if(is_void_star_or_boxed_tvar(typ_to_c(tuf_typ)))
	arrow_exp = cast_it(t2c, arrow_exp);
      s = seq_stmt_opt(s,extract_pattern_vars(rgn,nv,decls,arrow_exp,p2));
    }
    return s;

  case &Datatype_p(_,_,ps,_): fallthru(ps);
  case &Tuple_p(ps,_):
    stmt_opt_t s = NULL;
    int cnt = 1;
    for(; ps != NULL; ps = ps->tl, ++cnt) {
      let p2  = ps->hd;
      if(p2->r == &Wild_p_val)
	continue;
      let t2  = (type_t)p2->topt;
      let f = fieldname(cnt);
      s = seq_stmt_opt(s, extract_pattern_vars(rgn,nv,decls,member_exp(path,f,DL),p2));
    }
    return s;
  case &Aggr_p(NULL,...): toc_impos("unresolved aggregate pattern!");
  case &Aggr_p(&AggrInfo(info,_),_,dlps,_):
    // similar to translation of tuple pattern, but must account for designators.
    let ad = get_known_aggrdecl(info);
    stmt_opt_t s = NULL;
    for (; dlps != NULL; dlps = dlps->tl) {
      let tup = dlps->hd;
      let p2  = (*tup)[1];
      if(p2->r == &Wild_p_val)
        continue;
      let f = designatorlist_to_fieldname((*tup)[0]);
      let t2 = (type_t)p2->topt;
      let t2c = typ_to_c_array(t2);
      let memexp = member_exp(path,f,DL);
      // tagged unions require an extra .val
      if (ad->impl->tagged) memexp = member_exp(memexp,val_sp,DL);
      let ftype = lookup_field(ad->impl->fields,f)->type;
      if (is_void_star_or_boxed_tvar(ftype))
        memexp = cast_it(t2c, memexp);
      else if (!is_array_type(ftype) && kind_leq(&ak,typ_kind(ftype))) {
        // for abstract members, we have to convert to the right
        // pointer type...
        memexp = deref_exp(cast_it(cstar_typ(t2c,mt_tq), 
                                   address_exp(memexp,DL)),DL);
      }
      s = seq_stmt_opt(s, extract_pattern_vars(rgn,nv,decls,memexp,p2));
    }
    return s;

  case &Pointer_p(p2): 
    return extract_pattern_vars(rgn,nv,decls,deref_exp(path,DL),p2);

  case &UnknownId_p(_):       toc_impos("unknownid pat");
  case &UnknownCall_p(_,_,_): toc_impos("unknowncall pat");
  case &Exp_p(_):             toc_impos("exp pat");
  }
}

// compiles a decision tree that was generated from the match compiler
// into a set of tests, switches, goto's, etc.  dopt is the decision tree
// and lscs is the original list of switch clauses, together with the labels
// we generated to jump to.  The variable v is used as the root value that
// we're matching on.
static stmt_t compile_decision_tree(region_t<`rgn> rgn,
                                    env_t<`rgn> nv,
                                    list_t<vardecl_t,`rgn>@ decls,
                                    list_t<$(env_t<`rgn>,var_t,stmt_t)@`rgn,`rgn>@ 
                                      bodies,
                                    Tcpat::decision_opt_t dopt,
                                    list_t<$(bool,var_t,var_t,switch_clause_t)@> lscs,
                                    qvar_t v) {
  switch (dopt) {
  // these two cases shouldn't occur -- we let them through silently.
  case NULL: return skip_stmt(0);
  case &Tcpat::Failure(_): return throw_match_stmt();

  case &Tcpat::Success(rhs):
    // find the corresponding rhs in lscs
    for (; lscs != NULL; lscs = lscs->tl) {
      let &$(*already_emitted,init_lab,code_lab,sc) = lscs->hd;
      let body = sc->body;
      if (body == rhs->rhs) {
        // if we've already emitted this rhs, then just goto it.
        if (*already_emitted) 
          return goto_stmt(init_lab,DL);
        *already_emitted = true;
        // extract all of the pattern variables for this case
        stmt_opt_t init_opt = extract_pattern_vars(rgn,&nv,decls,var_exp(v,DL),
                                                   sc->pattern);
        // generate init_lab: <code to extract vars>; code_lab: <rhs>
        stmt_t res = label_stmt(code_lab,sc->body,DL);
        if (init_opt != NULL)
          res = seq_stmt(init_opt, res, DL);
        res = label_stmt(init_lab, res, DL);
        *bodies = rnew(rgn) List{rnew(rgn) $(nv,code_lab,body), *bodies};
        return res;
      }
    }
    toc_impos("couldn't find rhs!");
  case &Tcpat::SwitchDec(symbolic_path, switches, other_decision):
    // start by compiling the default
    stmt_t res = compile_decision_tree(rgn,nv,decls,bodies,other_decision,lscs,v);
    // now we compile the path to the thing we're testing
    let p = compile_path(List::rev(symbolic_path), var_exp(v,DL));
    let ss = List::rev(switches);
    // see if we can/should translate this to a switch or a sequence of if's
    let $(allows_switch, test_kind) = admits_switch(ss);
    if (allows_switch > 1) {
      // we'll generate a switch statement here
      // start with the default clause at the end.
      list_t<switch_clause_t> new_lscs = 
        new List{new Switch_clause{new_pat(&Wild_p_val,DL),NULL,NULL,res,DL},NULL};
      // add in each switch clause
      for (; ss != NULL; ss = ss->tl) {
        let $(pat_test, dec_tree) = *ss->hd;
        // compile the pattern test for this clause as a case expression
        let case_exp = compile_pat_test_as_case(pat_test);
        // compile the decision tree for this case
        let s = compile_decision_tree(rgn,nv,decls,bodies,dec_tree,lscs,v);
        // add in the new switch clause
        new_lscs = new List(new Switch_clause{case_exp,NULL,NULL,s,DL},new_lscs);
      }
      switch (test_kind) {
      case &DatatypeTagTest:
        // get rid of any extra dereference for datatypes
      LOOP1:
        switch (p->r) {
        case &Cast_e(_,e,...): p = e; goto LOOP1;
        case &Deref_e(e): p = e; break;
        default: break;
        }
        p = deref_exp(cast_it(cstar_typ(sint_typ,mt_tq),p),DL); break;
      case &TaggedUnionTest(f): 
        // add an extra .tag for tagged unions
        p = member_exp(member_exp(p,f,DL),tag_sp,DL); break;
        // where shouldn't really happen here.
      case &WhereTest(_): break;
      case &OtherTest: break;
      }
      res = new_stmt(new Switch_s(p,new_lscs,NULL),DL);
    } else {
      // We're going to have to compile the test as an if-then-else
      // We could be down to a where clause
      switch (test_kind) {
      case &WhereTest(e):
        switch (ss) {
          // where-clauses should only occur in a switch with a single case
          // other than the default.
        case &List{&$(pat_test, &Tcpat::Success(rhs)),NULL}:
          // find the corresponding rhs -- this is quite similar to the 
          // rhs code above for Success.
          for (; lscs != NULL; lscs = lscs->tl) {
            let &$(*already_emitted,init_lab,code_lab,sc) = lscs->hd;
            let body = sc->body;
            if (body == rhs->rhs) {
              // if we've already emitted code for this case, then goto it.
              if (*already_emitted) 
                return goto_stmt(init_lab,DL);
              *already_emitted = true;
              // extract all of the pattern variables for this case
              stmt_opt_t init_opt = extract_pattern_vars(rgn,&nv,decls,var_exp(v,DL),
                                                         sc->pattern);
              // compile the where-clause
              exp_to_c(nv,e);
              // generate init_lab: <code to extract vars>; 
              //          if (e) { code_lab: <rhs> } else <default>
              stmt_t r = label_stmt(code_lab,sc->body,DL);
              r = ifthenelse_stmt(e,r,res,DL);
              if (init_opt != NULL)
                r = seq_stmt(init_opt, r, DL);
              r = label_stmt(init_lab, r, DL);
              *bodies = rnew(rgn) List{rnew(rgn) $(nv,code_lab,body), *bodies};
              return r;
            }
          }
          toc_impos("couldn't find rhs!");
        default: toc_impos("bad where clause in match compiler");
        }
      default:
        // generate a sequence of nested ifs
        for (; ss != NULL; ss = ss->tl) {
          let $(pat_test, dec_tree) = *ss->hd;
          let test_exp = compile_pat_test(p, pat_test);
          let s = compile_decision_tree(rgn,nv,decls,bodies,dec_tree,lscs,v);
          res = ifthenelse_stmt(test_exp,s,res,DL);
        }
      }
    }
    return res;
  }
}

// We record the compiler environment that gets generated for each rhs of
// the case.  This allows us to look it up so that we can use it for fallthru's.
// The only rhs's that will not have an associated env are those that never
// show up in the decision tree.  That should only happen for a catch where
// we added in a default clause that was unnecessary.  The good news is that
// we discover this during switch-compilation and just skip over that clause.
static env_t<`rgn>*`rgn 
find_case_env(list_t<$(env_t<`rgn>,var_t,stmt_t)@`rgn,`rgn> bodies, stmt_t s) {
  for (; bodies != NULL; bodies = bodies->tl) {
    let &$(*nv,_,s2) = bodies->hd;
    if (s2 == s) return nv;
  }
  // if we got this far, then we're dealing with a try/catch's default
  // which is never called.
  return NULL;
}

// translate a switch according to the given decision tree.
static void xlate_switch(env_t nv, stmt_t whole_s,
			 exp_t e, list_t<switch_clause_t> scs,
                         Tcpat::decision_opt_t dopt) {
  let t = (type_t)e->topt;
  exp_to_c(nv,e);

  qvar_t v     = temp_var();
  exp_t  path  = var_exp(v,DL);
  var_t  end_l = fresh_label();
  TOC_RGN(nv,rgn) {
    let nv = share_env(rgn,nv);
    // for each clause, generate a test label and an entry label, and flag indicating
    // whether we've already emitted code for the rhs of the clause.
    list_t<$(bool,var_t,var_t,switch_clause_t)@/*`rgn,`rgn*/> lscs =
      List::rmap_c(rgn,gen_labels,rgn,scs);
    // compile the decision tree -- generates a list of declarations and
    // a list of case bodies with associated labels and environments, as
    // well as a big test statement.  
    list_t<vardecl_t,`rgn> mydecls = NULL;
    list_t<$(env_t<`rgn>,var_t,stmt_t)@`rgn,`rgn> mybodies = NULL;
    stmt_t test_tree = compile_decision_tree(rgn, nv, &mydecls, &mybodies, 
                                             dopt, lscs, v);
    // Note that at this point, test_tree contains all of the rhs's, but they
    // have not yet been translated.  That's because we need the compiler environment
    // for the fallthru case which is only generated after compiling the decision
    // tree.  So, now we step through each rhs and compile it.
    for (let lscs2 = lscs; lscs2 != NULL; lscs2 = lscs2->tl) {
      let &$(_,_,body_lab,body_sc) = lscs2->hd;
      stmt_t s = body_sc->body;
      // find the environment for this rhs.
      env_t<`rgn>* envp = find_case_env(mybodies,s);
      // skip over any case that is never called (i.e., has no envp), as it
      // must be dead code (not reachable in the decision tree.)
      if (envp == NULL) continue; 
      let env = *envp;
      // find the environment for the fallthru case if it's there.
      if (lscs2->tl != NULL) {
        let &$(_,_,fallthru_lab,next_sc) = lscs2->tl->hd;
	// FIX: all we use now is whether next_case_env exists, so this
	//      is a kludge
	let next_case_env = find_case_env(mybodies,next_sc->body);
        // if the next case is never called, then it must've been the default
        // case added for a try/catch in which case, we cannot have this case
        // fallthru to it.  So, we can treat this case as if it were the last
        // of the switch clauses.
        if (next_case_env == NULL) {
          stmt_to_c(last_switchclause_env(rgn,env,end_l),s);
        } else {
          // set up the environment with the fallthru information.
          list_t<vardecl_t> vs = NULL;
          if (next_sc->pat_vars != NULL) {
            vs = Tcutil::filter_nulls(List::split(next_sc->pat_vars->v)[0]);
            vs = List::imp_rev(vs);
          }
          stmt_to_c(non_last_switchclause_env(rgn, env, end_l, fallthru_lab,
                                              vs),s);
        }
      } else
        stmt_to_c(last_switchclause_env(rgn,env,end_l),s);
    }
    // almost done -- need to build the declarations, followed by the
    // test tree, followed by the end label.  We construct it backwards...
    stmt_t res = seq_stmt(test_tree,label_stmt(end_l,skip_stmt_dl(),DL),DL);
    // now add in declarations and alpha-convert
    for (; mydecls != NULL; mydecls = mydecls->tl) {
      let vd = mydecls->hd;
      vd->name = temp_var();
      vd->type = typ_to_c_array(vd->type);
      res = decl_stmt(new_decl(new Var_d(vd), DL), res, DL);
    }
    // overwrite original switch with new code.
    whole_s->r = declare_stmt(v,typ_to_c((type_t)e->topt),e,res,DL)->r;
    return;
  }
}

// forward declarations
static stmt_t letdecl_to_c(env_t nv, pat_t p, Tcpat::decision_opt_t, 
                           type_t t, exp_t e, stmt_t s);
static void local_decl_to_c(env_t nv,vardecl_t vd,stmt_t s);

///////////////////////////////////////////////////////////////
//              Translation of Statements                    //
///////////////////////////////////////////////////////////////
static void fndecl_to_c(env_t nv, fndecl_t f, bool cinclude);

stmt_t make_npop_handler(int n) {
  return exp_stmt(fncall_exp(_npop_handler_e,
			     new List(uint_exp(n-1,DL),NULL), DL), DL);
}
void do_npop_before(int n, stmt_t s) { // mutates s as necessary!
  if(n > 0)
    s->r = seq_stmt_r(make_npop_handler(n),new_stmt(s->r,DL));
}

static void stmt_to_c(env_t nv, stmt_t s) {
  // written to be self-tail recursive
  while (true) {
    switch (s->r) {
    case &Skip_s:
      return;
    case &Exp_s(e):
      exp_to_c(nv, e);
      return;
    case &Seq_s(s1,s2):
      stmt_to_c(nv,s1);
      s = s2;
      continue;
    case &Return_s(eopt):
      type_opt_t topt = NULL;
      if (eopt != NULL) {
	topt = typ_to_c((type_t)eopt->topt);
	exp_to_c(nv,(exp_t)eopt);
      }
      // reset handler **after** evaluating expression
      let npop = get_npop(s);
      if (npop > 0)
	if (topt != NULL) {
	  let x = temp_var();
	  let retn_stmt = return_stmt(var_exp(x,DL),DL);
	  s->r = declare_stmt(x,(type_t)topt, eopt,
			      seq_stmt(make_npop_handler(npop),
				       retn_stmt,DL),DL)->r;
	} else {
	  do_npop_before(npop,s);
	}
      return;
    case &IfThenElse_s(e,s1,s2):
      exp_to_c(nv,e);
      stmt_to_c(nv,s1);
      s = s2;
      continue;
    case &While_s($(e,_),s2):
      exp_to_c(nv,e);
      TOC_RGN(nv,temp) {
        stmt_to_c(loop_env(temp,nv),s2);
      }
      return;
    case &Break_s: 
      let &Env{.break_lab=b,...} = nv;
      if (b != NULL)
	s->r = goto_stmt_r(*b);
      // reset handler
      do_npop_before(get_npop(s),s);
      return;
    case &Continue_s:
      let &Env{.continue_lab=c,...} = nv;
      if (c != NULL)
	s->r = goto_stmt_r(*c);
      fallthru;
    case &Goto_s(_):
      // reset handler (note: earlier checks prevent jump into handler)
      do_npop_before(get_npop(s), s);
      return;
    case &For_s(e1,$(e2,_),$(e3,_),s2):
      // FIX:  should e3 be translated in nv?
      exp_to_c(nv,e1); exp_to_c(nv,e2); exp_to_c(nv,e3);
      TOC_RGN(nv, temp) {
        stmt_to_c(loop_env(temp,nv),s2);
      }
      return;
    case &Switch_s(e,scs,dec_tree_opt):
      xlate_switch(nv,s,e,scs,dec_tree_opt);
      return;
    case &Fallthru_s(es,dest_clause):
      let &Env{.fallthru_info = fi,...} = nv;
      if(fi == NULL)
	toc_impos("fallthru in unexpected place");
      let FallthruInfo{l,vs} = *fi;
      stmt_t s2 = goto_stmt(l, DL);
      // reset handler (after the es evaluation)
      do_npop_before(get_npop(s), s2);
      let vs2 = List::rev(vs);
      let es2 = List::rev(es);
      for(; vs2 != NULL; vs2 = vs2->tl, es2 = es2->tl) {
	exp_to_c(nv,es2->hd);
	s2 = seq_stmt(assign_stmt(varb_exp(new Pat_b(vs2->hd),DL), es2->hd,DL),
		      s2,DL);
      }
      s->r = s2->r;
      return;
    case &Decl_s(d,s1):
      // we have to treat Let_d and Var_d where we bind a comprehension
      // (not at the top-level) specially because these have to return
      // "statements".  See letdecl_to_c and decls_to_c below.
      switch (d->r) {
      case &Var_d(vd): local_decl_to_c(nv, vd, s1); break;
      case &Let_d(p,_,e,dec_tree):
        // Handle the special case where the pattern is a variable just like
	// a variable declaration, except variable's scope does NOT include e
	// DJG: just need to alpha-convert vd -- name resolution should
	//      have already decided scope, so we just have to rename
	//      because C's rules differ from ours.
        switch (p->r) {
        case &Var_p(vd, &Pat{.r = &Wild_p, ...}):
	  vd->name = temp_var();
          vd->initializer = e;
          d->r = new Var_d(vd);
	  local_decl_to_c(nv, vd, s1);
          break;
        default:
	  // we treat let declarations specially because they may need
	  // statements in addition to declarations, so we splice them in
	  // as a statement.  Other declarations only produce declarations.
	  s->r = letdecl_to_c(nv, p, dec_tree, (type_t)e->topt, e, s1)->r;
	  break;
        }
	break;
      case &Letv_d(vds):
        // Transform Letv_d into a sequence of Var_d, and call stmt_to_c on
        // the result.
        let rvds = List::rev(vds);
        if (rvds == NULL)
          impos("empty Letv_d");
        d->r = new Var_d(rvds->hd);
        rvds = rvds->tl;
        for (; rvds != NULL; rvds = rvds->tl) {
          let d2 = new_decl(new Var_d(rvds->hd),DL);
          s->r = decl_stmt(d2,new_stmt(s->r,DL),DL)->r;
        }
        stmt_to_c(nv,s);
        break;
      case &Fn_d(fd):
	fndecl_to_c(nv, fd, false);
	stmt_to_c(nv,s1);
        break;
      case &Region_d(tv, vd, open_exp_opt):
        let body = s1;
        // NOTE:  _npop_handler has to deal with regions as well as exceptions
        type_t rh_struct_typ     = strct(_RegionHandle_sp);
        type_t rh_struct_ptr_typ = cstar_typ(rh_struct_typ,mt_tq);
        qvar_t rh_var = temp_var();
        qvar_t x_var  = vd->name;
        exp_t  rh_exp = var_exp(rh_var,DL);
        exp_t  x_exp  = var_exp(x_var, DL);

	stmt_to_c(nv,body);
        if (no_regions) {
          s->r = declare_stmt(x_var, rh_struct_ptr_typ,
                              uint_exp(0,DL), body, DL)->r;
        } else if (open_exp_opt) { 
	  // { struct _REgionHandle *x = open_exp_opt -> h; body }
          exp_to_c(nv,open_exp_opt);
          exp_t arg = address_exp(aggrarrow_exp(open_exp_opt,new "h",DL),DL);
          s->r = declare_stmt(x_var,rh_struct_ptr_typ,arg,body,DL)->r;
        } else {
	  // { struct _RegionHandle rh = _new_region();
	  //   struct _RegionHandle *x = &rh;
	  //   _push_region(x);
	  //   body;
	  //   _pop_region(x);
	  // }
          s->r =
            declare_stmt(rh_var,rh_struct_typ,
                         fncall_exp(_new_region_e,
                                    new List(string_exp(qvar2string(x_var),DL),
                                             NULL),DL),
            declare_stmt(x_var, rh_struct_ptr_typ,address_exp(rh_exp,DL),
    	    seq_stmt(exp_stmt(fncall_exp(_push_region_e, list(x_exp), DL),DL),
            seq_stmt(body,
                     exp_stmt(fncall_exp(_pop_region_e,  list(x_exp), DL),DL),
                     DL),DL),DL),DL)->r;
        } 
        return;
      default: impos("bad nested declaration within function");
      }
      return;
    case &Label_s(lab,s1):
      s = s1; continue;
    case &Do_s(s2,$(e,_)):
      TOC_RGN(nv, temp) {
        stmt_to_c(loop_env(temp,nv),s2);
        exp_to_c(nv,e);
      }
      return;
    case &TryCatch_s(body,scs,dec_tree):
      // struct handler_cons h;
      // _push_handler(&h);
      // int was_thrown = 0;
      // if (setjmp(h.handler)) was_thrown = 1;
      // if (!was_thrown) {
      //   body
      //   _pop_handler();
      // } else {
      //   exn e = (exn)_exn_thrown;
      //   switch (e) scs
      // }
      // [Auxillary functions are defined in runtime_cyc.c]
      qvar_t h_var = temp_var();
      qvar_t e_var = temp_var();
      qvar_t was_thrown_var = temp_var();
      exp_t  h_exp = var_exp(h_var,DL);
      exp_t  e_exp = var_exp(e_var,DL);
      exp_t  was_thrown_exp = var_exp(was_thrown_var,DL);
      type_t h_typ = strct(_handler_cons_sp);
      type_t e_typ = typ_to_c(exn_typ());
      type_t was_thrown_typ = typ_to_c(sint_typ);
      // e_exp needs a typ because it'll go through exp_to_c;
      e_exp->topt = e_typ;
      TOC_RGN(nv, temp) {
        // translate the body
        stmt_to_c(nv,body);
        let tryandpop_stmt = seq_stmt(body,
                                      exp_stmt(fncall_exp(_pop_handler_e,
                                                          NULL,
                                                          DL), DL),DL);
        let handler_stmt = new_stmt(new Switch_s(e_exp,scs,dec_tree), DL);
        // translate the switches
        stmt_to_c(nv,handler_stmt);

        // wrap with the conditional, declarations, and setjmp
        let setjmp_call = // setjmp(h.handler)
          fncall_exp(setjmp_e,
                     new List(member_exp(h_exp,handler_sp,DL), NULL),
                     DL);
        let pushhandler_call = // _pushhandler(h);
          exp_stmt(fncall_exp(_push_handler_e,
                              new List(address_exp(h_exp,DL), NULL),
                              DL),DL);
        let zero_exp = int_exp(Signed,0,DL);
        let one_exp = int_exp(Signed,1,DL);
        s->r =
          declare_stmt(h_var, h_typ, NULL,
          seq_stmt(pushhandler_call,
          declare_stmt(was_thrown_var,was_thrown_typ,zero_exp,
          seq_stmt(ifthenelse_stmt(setjmp_call,
                                   assign_stmt(was_thrown_exp,one_exp,DL),
                                   skip_stmt_dl(),DL),
          ifthenelse_stmt(prim1_exp(Not, was_thrown_exp,DL),
                          tryandpop_stmt,
                          declare_stmt(e_var,e_typ,
                                       cast_it(e_typ,_exn_thrown_e),
                          handler_stmt,DL),DL),DL),DL),DL),DL)->r;
      }
      return;
    }
  }
}

///////////////////////////////////////////////////////////////
//              Translation of Declarations                  //
///////////////////////////////////////////////////////////////
// function declaration translation -- straightforward
static void stmttypes_to_c(stmt_t s);
static void fndecl_to_c(env_t nv, fndecl_t f, bool cinclude) {
  f->tvs      = NULL;
  f->effect   = NULL;
  f->rgn_po   = NULL;
  f->requires_clause = NULL;
  f->ensures_clause  = NULL;
  f->ret_type = typ_to_c(f->ret_type);
  region frgn; {
    let nv = share_env(frgn,nv);
    for (let args=f->args; args != NULL; args = args->tl) {
      let x = new $((nmspace_t)Loc_n,(*args->hd)[0]);
      (*args->hd)[2] = typ_to_c((*args->hd)[2]);
    }
    // for C code, we need to go through and convert all of the types
    // from Cyclone types to C, but otherwise leave the code alone.
    if (cinclude) {
      stmttypes_to_c(f->body);
      return;
    }
    fn_pop_table = new Hashtable::lookup(*gpop_tables,f);
    if (f->cyc_varargs && f->cyc_varargs->name != NULL) {
      let VarargInfo{n,tq,t,i} = *f->cyc_varargs;
      let t2 = typ_to_c(dyneither_typ(t,&HeapRgn_val,tq,false_conref));// region irrelevant
      let x2 = new $((nmspace_t)Loc_n,(var_t)n);
      f->args = List::append(f->args,new List(new $((var_t)n,tq,t2),NULL));
      f->cyc_varargs = NULL;
    }
    // Tovc would like to use param_vardecls:
    for(let arg_vds = f->param_vardecls->v; arg_vds!=NULL; arg_vds=arg_vds->tl) {
      arg_vds->hd->type = typ_to_c(arg_vds->hd->type);
    }
    stmt_to_c(clear_toplevel(frgn,nv),f->body);
  }
}

static scope_t scope_to_c(scope_t s) {
  switch (s) {
  case Abstract: return Public; // there's no abstract scope in C
  case ExternC : return Extern;
  default:       return s;
  }
}

// struct & union declarations -- straightforward except when we have
// a tagged union.  When we have:
//   @tagged union Foo { T1 m1; ... Tn mn; };
// this is translated to:
//   struct _union_Foo_m1 { int tag; T1 val; };
//   ...
//   struct _union_Foo_mn { int tag; Tn val; };
//   union Foo { struct _union_Foo_m1 m1; ... struct _union_Foo_mn mn; };

static int aggrdecl_to_c_body<`r2,`d,`r>(region_t<`d> d, 
                              $(struct TocState<`d>@`d, 
                                $(aggrdecl_t ad, bool add_to_decls)@`r2)@`r env) {
  let $(s, &$(ad, add_to_decls)) = *env;
  let n = ad->name;
  let TocState{.aggrs_so_far = aggrs_so_far, ...} = *s;
  bool seen_defn_before;
  let dopt = Dict::lookup_opt(*aggrs_so_far, n);
  if (dopt == NULL) {
    seen_defn_before = false;
    $(aggrdecl_t,type_t)@ v;
    if (ad->kind == StructA)
      v = rnew(d) $(ad,strctq(n));
    else
      v = rnew(d) $(ad,unionq_typ(n));
    *aggrs_so_far = Dict::insert(*aggrs_so_far,n,v);
  } else {
    let &$(ad2,t) = *dopt;
    if (ad2->impl == NULL) {
      *aggrs_so_far = Dict::insert(*aggrs_so_far,n,rnew(d) $(ad,t));
      seen_defn_before = false;
    } else
      seen_defn_before = true;
  }
  aggrdecl_t new_ad = new Aggrdecl {.kind = ad->kind,
                                    .sc = Public,
                                    .name = ad->name,
                                    .tvs = NULL,
                                    .impl = NULL,
                                    .expected_mem_kind = false,
                                    .attributes = ad->attributes};
  if(ad->impl != NULL && !seen_defn_before) {
    new_ad->impl = new AggrdeclImpl { .exist_vars = NULL,
                                      .rgn_po = NULL,
                                      .fields = NULL,
                                      .tagged = false };
    list_t<aggrfield_t> new_fields = NULL;
    for (let fields = ad->impl->fields; fields != NULL; fields = fields->tl){
      // JGM: I'm trying to get rid of warnings when we assign "const"
      // locations...
      let old_field = fields->hd;
      let old_type = old_field->type;
      let old_atts = old_field->attributes;
      if (kind_leq(&ak,typ_kind(old_type)) && 
          ((ad->kind == StructA && fields->tl == NULL) ||
           ad->kind == UnionA)) {
        // HACK ALERT:
        // If the last member is abstract we have to do more work:
        //  * if it's an array, we make it an array of size 0
        //  * otherwise as a HACK, we make it an array of void*'s of size 0,
        //    but add the __attribute__((aligned)) to force the thing
        //    to live on a suitable boundary.  This means that any
        //    instantiation has to also be aligned, but it gives us a
        //    way to portably get at the field.
        switch (compress(old_type)) {
        case &ArrayType(ArrayInfo{et,tq,_,zt,ztl}):
          // Note: type checker forces et to be non-abstract
          old_type = new ArrayType(ArrayInfo(et,tq,uint_exp(0,DL),zt,ztl));
          break;
        default: 
          old_atts = new List(new Aligned_att(NULL),old_atts);
          old_type = new ArrayType(ArrayInfo(void_star_typ(),
                                             empty_tqual(DL),
                                             uint_exp(0,DL),
                                             new_conref(false),DL));
        }
      }
      let new_field = new Aggrfield{.name = old_field->name,
                                    .tq = mt_tq,
                                    .type = typ_to_c(old_type),
                                    .width = old_field->width,
                                    .attributes = old_atts,
                                    .requires_clause = NULL};

      // If this is a tagged union, rewrite the member type from T
      // to struct _union_Foo_f {int tag; T val;} where Foo is the name
      // of the union, and f is the name of the member.
      if (ad->impl->tagged) {
        let T = new_field->type;
        let f = new_field->name;
        string_t s = aprintf("_union_%s_%s",*((*ad->name)[1]),*f);
        var_t str = new s;
        let value_field = new Aggrfield(val_sp,mt_tq,T,NULL,NULL,NULL);
        let tag_field = new Aggrfield(tag_sp,mt_tq,sint_typ,NULL,NULL,NULL);
        let fs = list(tag_field,value_field);
	let ad2 = make_c_struct_defn(str,fs);
        result_decls = new List(new_decl(new Aggr_d(ad2),DL),result_decls);
        new_field->type = strct(str);
      }
      new_fields = new List(new_field,new_fields);
    }
    new_ad->impl->fields = List::imp_rev(new_fields);
  }
  if (add_to_decls)
    result_decls = new List(new Decl(new Aggr_d(new_ad),DL),result_decls);
  return 0;
}

static void aggrdecl_to_c(aggrdecl_t ad, bool add_to_decls) {
  _ p = $(ad, add_to_decls);
  use_toc_state(&p, (aggrdecl_to_c_body@<`aggrdecl_to_c>)<>);
}

// datatype declarations -- tricky
// For "datatype foo {Bar,Blah,Baz(t1,t2,t3),Baf(t4,t5)}" we generate
//   typedef void *foo;
//   struct Baz_foo_struct {
//     int tag;  // always == 0
//     t1 f1;
//     t2 f2;
//     t3 f3;
//   };
//   struct Baf_foo_struct {
//     int tag;  // always == 1
//     t4 f1;
//     t5 f2;
//   };
// for xdatatype, we pull a really slimy trick: By using char arrays instead
// of ints, the uses get promoted to addresses just like we want.
// When the datatype is "extern" then we don't generate initializers
// for the tags (that should be done elsewhere.)
//
// NB: we allow any number of repeated declarations but we can only
//     declare and initialize global variables once.  So we keep track
//     of what we've seen so far.  And we make the globals static so that
//     extern and what not is only a link-checker thing.  Unfortunately,
//     the static trick doesn't work for xdatatype, which uses the addresses.
static int datatypedecl_to_c_body<`d,`r>(region_t<`d> d, 
                                         $(struct TocState<`d>@`d, 
                                           datatypedecl_t tud)@`r env) {
  let $(&TocState{.datatypes_so_far = datatypes_so_far, ...},tud) = *env;
  let n = tud->name;
  if(tud->fields == NULL || Set::member(*datatypes_so_far, n))
    return 0;
  *datatypes_so_far = Set::rinsert(d,*datatypes_so_far, n);
  for (let fields = tud->fields->v; fields != NULL; fields = fields->tl) {
    datatypefield_t f = fields->hd;
    // compute the fields for the struct, adding in a tag field
    let fs = NULL;
    int i  = 1;
    for (let ts = f->typs; ts != NULL; ts = ts->tl, i++) {
      let fname = fieldname(i);
      let f = new Aggrfield(fname,(*ts->hd)[0],
                            typ_to_c((*ts->hd)[1]),NULL,NULL,NULL);
      fs = new List(f,fs);
    }
    fs = new List(new Aggrfield(tag_sp,mt_tq,sint_typ,NULL,NULL,NULL),
                  List::imp_rev(fs));
    let ad = make_c_struct_defn(new "", fs);
    ad->name = collapse_qvars(f->name,tud->name);
    result_decls = new List(new_decl(new Aggr_d(ad),DL),result_decls);
  }
  return 0;
}

static void datatypedecl_to_c(datatypedecl_t tud) {
  use_toc_state(tud, datatypedecl_to_c_body<>);
}
// @extensible datatype declarations -- similar to datatype declarations
// For a declaration extending an existing xdatatype, e.g.,
//   "@extensible datatype foo {Bar,Baz(t1,t2)}"
// we generate
//   char Bar[] = "Bar";
//   struct Bar_foo_struct { char *tag; };
//   char Baz[] = "Baz";
//   struct Baz_foo_struct { char *tag; t1 f1; t2 f2; };
// When the xdatatype is extern, then we don't do initializers for the tags.
//
// Thus "Baz(e1,e2)" maps to
// ({struct _Baz_struct *t =
//     (struct _Baz_struct*)malloc(sizeof(struct _Baz_struct));
//   *t = (struct _Baz_struct){.tag=Baz, .f1 = e1, .f2 = e2};
//   t;})
//true if already seen & initialized, false if seen but non initialized (extern)
static int xdatatypedecl_to_c_body<`d,`r>(region_t<`d> d,
                                          $(struct TocState<`d>@`d,
                                            datatypedecl_t xd)@`r env) {
  let $(s,xd) = *env;
  if(xd->fields == NULL)
    return 0;
  let TocState{.xdatatypes_so_far = xdatatypes_so_far, ...} = *s;
  let n = xd->name;
  for (let fs = xd->fields->v; fs != NULL; fs = fs->tl) {
    datatypefield_t f  = fs->hd;
    stringptr_t fn = (*f->name)[1];
    let sz_exp  = uint_exp(numelts(*fn),DL);
    let tag_typ = array_typ(char_typ,mt_tq,sz_exp,false_conref,DL);
    // FIX: making bad alignment and pointer-size assumptions!
    switch (Dict::lookup_opt(*xdatatypes_so_far,f->name)) {
    case NULL:
      exp_opt_t initopt = NULL;
      if (f->sc != Extern) {
        initopt = string_exp(*fn,DL);
      }
      let tag_decl = new_vardecl(0,f->name, tag_typ, initopt);
      tag_decl->sc = f->sc;
      result_decls = new List(new_decl(new Var_d(tag_decl),DL),result_decls);
      *xdatatypes_so_far =
        Dict::insert(*xdatatypes_so_far, f->name, f->sc != Extern);
      list_t<aggrfield_t> fields = NULL;
      int i = 1;
      for (let tqts = f->typs; tqts != NULL; tqts = tqts->tl,i++) {
        let field_n = new ((string_t)aprintf("f%d",i));
        let newf = new Aggrfield(field_n,(*tqts->hd)[0],
                                 typ_to_c((*tqts->hd)[1]),NULL,NULL,NULL);
        fields = new List(newf,fields);
      }
      fields = new List(new Aggrfield(tag_sp,mt_tq,
                                      cstar_typ(char_typ,mt_tq),NULL,NULL,NULL),
                        List::imp_rev(fields));
      let strct_decl = make_c_struct_defn(new "",fields);
      strct_decl->name = collapse_qvars(f->name,xd->name);
      result_decls = new List(new_decl(new Aggr_d(strct_decl),DL),result_decls);
      break;
    case &false:
      if (f->sc != Extern) {
        let initopt = string_exp(*fn,DL);
        let tag_decl = new_vardecl(0,f->name, tag_typ, initopt);
        tag_decl->sc = f->sc;
        result_decls = new List(new_decl(new Var_d(tag_decl),DL),result_decls);
        *xdatatypes_so_far = Dict::insert(*xdatatypes_so_far, f->name, true);
      }
      break;
    default: break;
    }
  }
  return 0;
}

static void xdatatypedecl_to_c(datatypedecl_t xd) {
  use_toc_state(xd, xdatatypedecl_to_c_body<>);
}

static void enumdecl_to_c(enumdecl_t ed) {
  ed->sc = Public; // gcc warns if we have Extern or Static on an enum
  if(ed->fields != NULL)
    enumfields_to_c(ed->fields->v);
}

static void local_decl_to_c(env_t nv,vardecl_t vd,stmt_t s) {
  type_t old_typ = vd->type;
  vd->type = typ_to_c(old_typ);
  // Fat pointers can't be declared with "register" scope
  if (vd->sc == Register && is_tagged_pointer_typ(old_typ))
    vd->sc = Public;
  stmt_to_c(nv,s);
  if(vd->initializer != NULL) {
    exp_t init = (exp_t)vd->initializer;
    if (vd->sc == Static) {
      // static declarations have to be treated as if they're toplevel
      // w.r.t. the translation.  NB: Any other generated declarations
      // will also be left at top-level??
      TOC_RGN(nv, temp) {
	let nv2 = set_toplevel(temp,nv);
	exp_to_c(nv2, init);
      }
    } else
      exp_to_c(nv, init);
  } else {
    // must put in zero for zero-terminated arrays
    switch (compress(old_typ)) {
    case &ArrayType(ArrayInfo{et,_,num_elts_opt,zt,_}):
      if (conref_def(false,zt)) {
        if (num_elts_opt == NULL)
          toc_impos("can't initialize zero-terminated array -- size unknown");
        exp_t num_elts = (exp_t)num_elts_opt;
        let lhs = subscript_exp(var_exp(vd->name,DL),
                                add_exp(num_elts,signed_int_exp(-1,DL),DL),
                                DL);
        let rhs = signed_int_exp(0,DL);
        s->r = seq_stmt_r(exp_stmt(assign_exp(lhs,rhs,DL),DL),
                          new_stmt(s->r,DL));
      }
      break;
    default: break;
    }
  }
}

// Destructively rewrite the decision tree so that Failure nodes are 
// replaced with Success(fail) and Success(_) is replaced with Success(s)
static Tcpat::decision_t rewrite_decision(Tcpat::decision_t d,stmt_t success) {
  switch (d) {
  case &Tcpat::Failure(_): return d;
  case &Tcpat::Success(rhs): rhs->rhs = success; return d;
  case &Tcpat::SwitchDec(path, sws, *d2):
    *d2 = rewrite_decision(*d2, success);
    for (; sws != NULL; sws = sws->tl) {
      let &$(_,*d2) = sws->hd;
      *d2 = rewrite_decision(*d2, success);
    }
    return d;
  }
}

// let declarations -- tricky
// Unlike other declarations, lets need to execute statements and
// so return a statement.  (See stmt_to_c, case for Decl above.)
// We treat this similar to the compilation of a switch (see xlate_switch
// above) with one case, but where the failure throws Match_Exception.
// Lots of hacks to get this to work right and re-use the pattern
// match compiler.
static stmt_t letdecl_to_c(env_t nv, pat_t p, Tcpat::decision_opt_t dopt, 
                           type_t t, exp_t e, stmt_t s) {
  TOC_RGN(nv,rgn) {
    let nv = share_env(rgn,nv);
    let t = (type_t)e->topt;
    exp_to_c(nv,e);
    qvar_t v     = temp_var();
    exp_t  path  = var_exp(v,DL);
    var_t  end_l = fresh_label();
    // we us a bogus fail statement since it has to pass through translation.
    // we overwrite it with _throw_match() below.  For a success, we goto
    // th end label.
    let succ_stmt = skip_stmt_dl();
    if (dopt != NULL) {
      // rewrite the decision tree so that on failure we throw Match
      // and on success, continue with the body of the let.
      dopt = rewrite_decision(dopt, succ_stmt);
    }
    let c1 = new Switch_clause{p, NULL, NULL, succ_stmt, 0};
    let lscs = List::rmap_c(rgn,gen_labels,rgn,rlist(rgn,c1));
    // declarations and environments generated while compiling decision tree
    list_t<vardecl_t> mydecls = NULL;
    list_t<$(env_t<`rgn>,var_t,stmt_t)@`rgn,`rgn> mybodies = NULL;
    // compile the pattern -- this essentially generates
    // if e matches p then <skip> else _throw_match()
    stmt_t test_tree = compile_decision_tree(rgn, nv, &mydecls, &mybodies, 
                                             dopt, lscs, v);
    // get out the env to translate s
    env_t<`rgn> senv;
    for (; mybodies != NULL; mybodies = mybodies->tl) {
      let &$(env,_,st) = mybodies->hd;
      if (st == succ_stmt) { senv = env; goto FOUND_ENV; }
    }
    toc_impos("letdecl_to_c: couldn't find env!");
  FOUND_ENV:
    // translate the body of the let under the env we get out of match
    // compilation.
    stmt_to_c(senv,s);
    // put the tests in front
    stmt_t res = seq_stmt(test_tree,s,DL);
    // now add in declarations and alpha-convert
    for (; mydecls != NULL; mydecls = mydecls->tl) {
      let vd = mydecls->hd;
      vd->name = temp_var();
      vd->type = typ_to_c_array(vd->type);
      res = decl_stmt(new_decl(new Var_d(vd), DL), res, DL);
    }
    // finally declare the root variable v and initialize it with e
    res = declare_stmt(v,typ_to_c(t),e,res,DL);
    return res;
  }
}

// These next few functions clean up the types in C code, getting
// rid of stuff inserted by the parser (e.g., region evars).

static void exptypes_to_c(exp_t e) {
  switch (e->r) {
  case &Deref_e(e):          fallthru(e);
  case &AggrMember_e(e,...): fallthru(e);
  case &AggrArrow_e(e,...):  fallthru(e);
  case &Address_e(e):        fallthru(e);
  case &Throw_e(e,_):        fallthru(e);
  case &NoInstantiate_e(e):  fallthru(e);
  case &Sizeofexp_e(e):      fallthru(e);
  case &Increment_e(e1,_):   exptypes_to_c(e1); break;
  case &Primop_e(_,es):      List::iter(exptypes_to_c,es); break;
  case &And_e(e1,e2):        fallthru(e1,e2);
  case &Or_e(e1,e2):         fallthru(e1,e2);
  case &SeqExp_e(e1,e2):     fallthru(e1,e2);
  case &Subscript_e(e1,e2):  fallthru(e1,e2);
  case &Swap_e(e1,e2):       fallthru(e1,e2);
  case &AssignOp_e(e1,_,e2): exptypes_to_c(e1); exptypes_to_c(e2); break;
  case &Conditional_e(e1,e2,e3):
    exptypes_to_c(e1); exptypes_to_c(e2); exptypes_to_c(e3); break;
  case &FnCall_e(e,es,...):    
    exptypes_to_c(e); List::iter(exptypes_to_c,es); break;
  case &Cast_e(*t,e,_,_): *t = typ_to_c(*t); exptypes_to_c(e); break;
  case &CompoundLit_e(&$(_,_,*t),dles):
    *t = typ_to_c(*t);
    fallthru(dles);
  case &UnresolvedMem_e(_,dles): fallthru(dles);
  case &Array_e(dles):
    for (; dles != NULL; dles = dles->tl) {
      let $(_,e) = *dles->hd;
      exptypes_to_c(e);
    }
    break;
  case &Offsetof_e(*t,_): fallthru(t);
  case &Sizeoftyp_e(*t):  *t = typ_to_c(*t); break;
  case &StmtExp_e(s): stmttypes_to_c(s); break;
  case &Malloc_e(*m):
    if (m->elt_type != NULL)
      m->elt_type = new (typ_to_c(*m->elt_type));
    exptypes_to_c(m->num_elts);
    break;
  case &Const_e(_):     
  case &Var_e(_):       
  case &Enum_e(...):  
  case &Asm_e(...):     
  case &AnonEnum_e(...): break;

  case &Pragma_e(...): 
  case &AnonStruct_e(...): 
  case &Datatype_e(...):  
  case &Aggregate_e(...):
  case &Comprehension_e(...):
  case &ComprehensionNoinit_e(...):
  case &Tuple_e(...):         
  case &Instantiate_e(...): 
  case &New_e(...):         
  case &Valueof_e(...):       
  case &Tagcheck_e(...): terr(e->loc,"Cyclone expression within C code"); break;
  }
}

static void decltypes_to_c(decl_t d) {
  switch (d->r) {
  case &Var_d(vd):
    vd->type = typ_to_c(vd->type);
    if (vd->initializer != NULL) exptypes_to_c((exp_t)vd->initializer);
    break;
  case &Fn_d(fd):
    fd->ret_type = typ_to_c(fd->ret_type);
    for (let args=fd->args; args != NULL; args = args->tl) {
      (*args->hd)[2] = typ_to_c((*args->hd)[2]);
    }
    break;
  case &Aggr_d(ad): aggrdecl_to_c(ad,true); break;
  case &Enum_d(ed):
    if (ed->fields != NULL)
      for (let fs = ed->fields->v; fs != NULL; fs = fs->tl) {
        let f = fs->hd;
        if (f->tag != NULL) exptypes_to_c((exp_t)f->tag);
      }
    break;
  case &Typedef_d(td): td->defn = typ_to_c((type_t)td->defn); break;
  case &Let_d(...):
  case &Letv_d(_):
  case &Datatype_d(_):
  case &Namespace_d(_,_):
  case &Using_d(_,_):
  case &ExternC_d(_):
  case &ExternCinclude_d(_,_):
  case &Region_d(...): // DJG: impossible because of parser, no?
    terr(d->loc,"Cyclone declaration within C code");
    break;
  case &Porton_d:
  case &Portoff_d:
    break;
  }
}

static void stmttypes_to_c(stmt_t s) {
  switch (s->r) {
  case &Exp_s(e): exptypes_to_c(e); break;
  case &Seq_s(s1,s2): stmttypes_to_c(s1); stmttypes_to_c(s2); break;
  case &Return_s(eopt): if (eopt != NULL) exptypes_to_c((exp_t)eopt); break;
  case &IfThenElse_s(e,s1,s2):
    exptypes_to_c(e); stmttypes_to_c(s1); stmttypes_to_c(s2); break;
  case &While_s($(e,_),s):
    exptypes_to_c(e); stmttypes_to_c(s); break;
  case &For_s(e1,$(e2,_),$(e3,_),s):
    exptypes_to_c(e1); exptypes_to_c(e2); exptypes_to_c(e3);
    stmttypes_to_c(s); break;
  case &Switch_s(e,scs,dec_tree):
    exptypes_to_c(e);
    for (; scs != NULL; scs=scs->tl) stmttypes_to_c(scs->hd->body);
    break;
  case &Decl_s(d,s): decltypes_to_c(d); stmttypes_to_c(s); break;
  case &Do_s(s,$(e,_)): stmttypes_to_c(s); exptypes_to_c(e); break;
  case &Label_s(_,s): stmttypes_to_c(s); break;
  case &Skip_s:
  case &Break_s:
  case &Continue_s:
  case &Goto_s(...): 
    break;
  case &Fallthru_s(...): 
    // in C code, this is implicit, so we replace it with a skip
    s->r = new Skip_s;
    break;
  case &TryCatch_s(...):
    terr(s->loc,aprintf("Cyclone statement in C code: %s",stmt2string(s)));
    break;
  }
}

// Translate the given declarations, producing a new list of declarations
// and a new translation environment.  Top-level variable
// declarations are treated differently.
static env_t<`r> decls_to_c(region_t<`r> r, env_t<`r> nv, list_t<decl_t> ds, bool top, bool cinclude) {
  for (; ds != NULL; ds = ds->tl) {
    if (!is_toplevel(nv))
      impos("decls_to_c: not at toplevel!");
    fresh_label_counter = 0; // DJG: why not?
    decl_t d = ds->hd;
    switch (d->r) {
    case &Var_d(vd):
      let c_name = vd->name;
      // strip any namespace from an extern C declaration
      if (vd->sc == ExternC)
	c_name = new $(Abs_n(NULL,true),(*c_name)[1]);
      if (vd->initializer != NULL) {
        if (vd->sc == ExternC) vd->sc = Public;
        if (cinclude)
          exptypes_to_c((exp_t)vd->initializer);
        else
          exp_to_c(nv, (exp_t)vd->initializer);
      }
      vd->name = c_name;
      vd->sc   = scope_to_c(vd->sc);
      vd->type = typ_to_c(vd->type);
      result_decls = new List(d,result_decls);
      break;
    case &Fn_d(fd):
      let c_name = fd->name;
      // strip any namespace from an extern C declaration
      if (fd->sc == ExternC) {
	c_name = new $(Abs_n(NULL,true),(*c_name)[1]);
        fd->sc = Public; // function declarations can't be extern
      }
      fd->name = c_name;
      fndecl_to_c(nv, fd, cinclude);
      result_decls = new List(d,result_decls);
      break;
    case &Let_d(...):
    case &Letv_d(_):     toc_impos("letdecl at toplevel");
    case &Region_d(...): toc_impos("region decl at toplevel");
    case &Aggr_d(sd):
      aggrdecl_to_c(sd,true);
      break;
    case &Datatype_d(tud):
      if(tud->is_extensible)
	xdatatypedecl_to_c(tud);
      else
	datatypedecl_to_c(tud);
      break;
    case &Enum_d(ed):
      enumdecl_to_c(ed);
      result_decls = new List(d,result_decls);
      break;
    case &Typedef_d(td):
      td->tvs  = NULL;
      if (td->defn != NULL)
	td->defn = typ_to_c((type_t)td->defn);
      else {
	switch (td->kind->v->kind) {
	case BoxKind: td->defn = void_star_typ(); break;
	default: td->defn = &VoidType_val; break;
	}
      }
      // for non-anonymous-aggregates, this is wasteful b/c the printer
      // will skip any use of the typedef
      // DJG: anonymous aggregates are now hoisted
      if(noexpand_r)
	result_decls = new List(d,result_decls);
      break;
    case &Porton_d:
    case &Portoff_d: break;
    case &Namespace_d(_,ds2): fallthru(ds2);
    case &Using_d(_,ds2):     fallthru(ds2);
    case &ExternC_d(ds2): nv = decls_to_c(r,nv,ds2,top,cinclude); break;
    case &ExternCinclude_d(ds2,_): nv = decls_to_c(r,nv,ds2,top,true); break;
    }
  }
  return nv;
}

// initialize all globals
static void init() {
  let NewDynamicRegion{dyn} = new_rckey();
  let ts;
  {region h = open(dyn);
  ts = empty_toc_state(h);}
  toc_state = unew TocStateWrap{dyn, ts};
  result_decls = NULL;
  tuple_type_counter = 0;
  temp_var_counter = 0;
  fresh_label_counter = 0;
  total_bounds_checks = 0;
  bounds_checks_eliminated = 0;
  globals = new {
    &_throw_str,
    &setjmp_str,
    &_push_handler_str,
    &_pop_handler_str,
    &_exn_thrown_str,
    &_npop_handler_str,
    &_check_null_str,
    &_check_known_subscript_null_str,
    &_check_known_subscript_notnull_str,
    &_check_dyneither_subscript_str,
    &_dyneither_ptr_str,
    &_tag_dyneither_str,
    &_untag_dyneither_ptr_str,
    &_get_dyneither_size_str,
    &_get_zero_arr_size_str, // FIX: whole function set
    &_dyneither_ptr_plus_str,
    &_zero_arr_plus_str,     
    &_dyneither_ptr_inplace_plus_str,
    &_zero_arr_inplace_plus_str, // FIX: whole function set
    &_dyneither_ptr_inplace_plus_post_str,
    &_zero_arr_inplace_plus_post_str, // FIX: whole function set
    &_cycalloc_str,
    &_cyccalloc_str,
    &_cycalloc_atomic_str,
    &_cyccalloc_atomic_str,
    &_region_malloc_str,
    &_region_calloc_str,
    &_check_times_str,
    &_new_region_str,
    &_push_region_str,
    &_pop_region_str,
    &_throw_arraybounds_str,
    &_dyneither_ptr_decrease_size_str,
    &_throw_match_str,
    &_fast_region_malloc_str,
  };
}

void finish() { 
  toc_state_t ts = NULL;
  ts :=: toc_state;
  let TocStateWrap{dyn, s} = *ts;
  // reclaim space used by extensible array for the labels
  {region h = open(dyn);
  let TocState{.temp_labels = tls, ...} = *s;
  Xarray::reuse(tls);}

  Core::free_rckey(dyn);
  Core::ufree(ts);

  gpop_tables  = NULL;
  fn_pop_table = NULL;
}

// The entry point:  translate the list of Cyclone declarations to
// a list of C declarations.
list_t<decl_t> toc(table_t<fndecl_t,table_t<stmt_t,int>> pop_tables,
		   list_t<decl_t> ds) {
  gpop_tables = new pop_tables;
  init();
  { region start;
    decls_to_c(start,empty_env(start),ds,true,false);
  }
#ifdef BCE_DEBUG
  fprintf(stderr,"***eliminated %d out of %d bounds checks\n",
	  bounds_checks_eliminated, total_bounds_checks);
#endif
  return imp_rev(result_decls);
}
