/* Translate Cyclone abstract syntax to C abstract syntax.
   Copyright (C) 2001 Greg Morrisett, AT&T
   This file is part of the Cyclone compiler.

   The Cyclone compiler is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   The Cyclone compiler is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with the Cyclone compiler; see the file COPYING. If not,
   write to the Free Software Foundation, Inc., 59 Temple Place -
   Suite 330, Boston, MA 02111-1307, USA. */

// Translation of Cyclone abstract syntax to C abstract syntax.
// Assumes RemoveAggrs and Toseqc will be run subsequently (thoough
// the latter should be optional if we knew the underlying C compiler
// used left-to-right evaluation).  We use GCC-sepcific features (especially
// statement-expressions as convenient).

// The translation is mostly done in place in an imperative style
// (i.e., we overwrite AST nodes) so it's fairly crucial that we don't
// have sharing in the AST.  However, the type translation is functional.

//Look for "unimp" or comments that start with FIX for missing or broken pieces.

// FIX: we could probably use "const" in lots of places where we're not.

// unresolvedmem_exp should only be used (1) to build arrays; or (2) to build
// other things (structs etc.) at top level only; Tovc relies on this.

#include <string.h>
#include <set.h>
#include <dict.h>
#include <xarray.h>
#include "warn.h"
#include "flags.h"
#include "unify.h"
#include "tcutil.h"
#include "attributes.h"
#include "evexp.h"
#include "insert_checks.h"
#include "toc.h"
#include "tcpat.h"
using Core;
using List;
using Absyn;
using Tcutil;
namespace Toc;

// used for creation of all abstract syntax node locations created here
#define DL 0

// padding for variable-length array allocations
#define PAD_BYTES sizeof(double)

// for passing New_e destinations to RemoveAggrs
@extensible datatype Absyn::AbsynAnnot { 
  Dest(exp_t);
};

static `a unimp(string_t<`H> str) __attribute__((noreturn)) {
  Warn::impos2(str);
}
static `a toc_impos(string_t fmt, ... inject parg_t ap)
  __attribute__((format(printf,1,2), noreturn)) {
  Warn::vimpos(strconcat("Toc: ",fmt), ap);
}
static `a toc_impos2(...inject Warn::warg_t ap) __attribute__((noreturn)) {
  Warn::warg_t   toc  = new Warn::String("Toc: ");
  Warn::warg_t ? args = new {for i < (numelts(ap)+1) : (i==0 ? toc : ap[i-1])};
  Warn::vimpos2(args);
}

stringptr_t ?globals = NULL;

// should be folded into environment, but for now use globals
static table_t<fndecl_t,table_t<stmt_t,int>> * gpop_tables  = NULL;
static table_t<stmt_t,int>                   * fn_pop_table = NULL;
static int tuple_type_counter  = 0;
static int temp_var_counter    = 0;
static int fresh_label_counter = 0;

// we aren't re-entrant -- we build this list of output decls (in
// reverse order)  It's global b/c tuple types, tagged pointer types, and
// strange top-level initializers need to "splice in" toplevel decls and
// it's a pain to pass this list around everywhere
static list_t<decl_t> result_decls = NULL;

static int get_npop(stmt_t s) {
  return Hashtable::lookup(*fn_pop_table,s);
}

// for gensymming, etc.
struct TocState<`d> {
  // tuple types seen so far and the struct they map to
  list_t<$(type_t,list_t<type_t,`d>)@`d,`d> @`d tuple_types;
  // anonymous aggr types seen so far and the struct they map to (rare)
  // FIX: would be nice to share more code with tuple translation
  list_t<$(type_t,aggr_kind_t,list_t<aggrfield_t>)@`d,`d> @`d anon_aggr_types;
  // (non-tagged) aggregates seen so far, their declaration, and C type
  Dict::dict_t<qvar_t,$(aggrdecl_t,type_t)@`d,`d> @`d aggrs_so_far;
  //instantiations of abstract structs generated
  list_t<$(qvar_t,list_t<type_t>,type_t)@`d,`d> @`d abs_struct_types;
  // datatypes seen so far
  Set::set_t<qvar_t,`d> @`d                    datatypes_so_far;
  // xdatatypes seen so far -- bool is false if seen but not initialized (extern)
  Dict::dict_t<qvar_t,bool,`d> @`d             xdatatypes_so_far;
  // generated identifiers from combining other identifiers -- used when
  // collapsing datatype members with the datatype itself.  
  Dict::dict_t<$(qvar_t,qvar_t)@`d,qvar_t,`d>@`d qvar_tags;
  // generated labels -- get re-used across functions
  Xarray::xarray_t<var_t,`d>                    temp_labels;
};

static int qvar_tag_cmp($(qvar_t,qvar_t)@ x, $(qvar_t,qvar_t)@ y) {
  int i = qvar_cmp((*x)[0],(*y)[0]);
  if (i != 0) return i;
  return qvar_cmp((*x)[1],(*y)[1]);
}

// create a fresh TocState given the region
static struct TocState<`d>@`d empty_toc_state(region_t<`d> d) {
  return rnew(d) 
    TocState{.tuple_types       = rnew(d) NULL,
	     .anon_aggr_types   = rnew(d) NULL,
             .aggrs_so_far      = rnew(d) Dict::rempty(d,qvar_cmp),
             .abs_struct_types  = rnew(d) NULL,
             .datatypes_so_far  = rnew(d) Set::rempty(d,qvar_cmp),
             .xdatatypes_so_far = rnew(d) Dict::rempty(d,qvar_cmp),
             .qvar_tags         = rnew(d) Dict::rempty(d,qvar_tag_cmp),
             .temp_labels       = Xarray::rcreate_empty(d)
            };
}

struct TocStateWrap {
  <`d::R>
  Core::rcregion_key_t<`d> dyn;
  struct TocState<`d>@`d state;
};
typedef struct TocStateWrap*`U toc_state_t;
static toc_state_t toc_state = NULL;

// a generic function for using the toc state:  we pass in an
// argument arg and function f and end up passing f the current
// toc_state component after opening the toc_state's wrapped
// dynamic region.  
static `res use_toc_state(`a arg,
                          `res f<`d,`r>(region_t<`d>, 
                                        $(struct TocState<`d>@`d,`a)@`r)) {
  toc_state_t ts = NULL;
  ts :=: toc_state;
  let TocStateWrap{<`dyn> dyn, s} = *ts;
  let dyn2 = alias_refptr(dyn); 
  *ts = TocStateWrap{dyn,s};
  ts :=: toc_state;
  let res;
  {region h = open(dyn2); 
  let env = $(s, arg);
  res = f(h,&env);}
  free_rckey(dyn2); // should be equivalent to drop_refptr
  return res;
}

static type_t aggrdecl_type_body<`r2,`d,`r>(region_t<`d> d, 
                                 $(struct TocState<`d>@`d, 
                                 $(qvar_t q,type_t (@`H)(qvar_t))@`r2)@`r env) {
  let $(s, &$(q, type_maker)) = *env;
  $(aggrdecl_t,type_t)@`d*`d v = Dict::lookup_opt(*s->aggrs_so_far,q);
  return v==NULL ? type_maker(q) : (**v)[1];
}

static type_t aggrdecl_type(qvar_t q, type_t (@`H type_maker)(qvar_t)) {
  _ env = $(q, type_maker);
  return use_toc_state(&env, (aggrdecl_type_body@<`aggrdecl_type>)<>);
}

/////////////////////////// Pre-Allocated Stuff /////////////////////////////
// Don't use any of these things if they might get mutated!!!

// some pre-allocated boxed strings -- use foo_sp for char ?* w/ contents "foo"
#define MAKE_STRING(str)\
  static string_t    str##_string = #str; \
  static stringptr_t str##_sp     = &str##_string

MAKE_STRING(curr);
MAKE_STRING(tag);
MAKE_STRING(val);
MAKE_STRING(_handler_cons);
MAKE_STRING(handler);
MAKE_STRING(_RegionHandle);

/* Some pre-allocated qvars -- use foo_e for exp that is var "foo".
   NB we must record all of these so that tovc knows about them;
   this is done by initializing the external variable globals in the
   function init(), below. */
#define MAKE_VAR(str)\
  static string_t            str##_str = #str;\
  static $(nmspace_t, var_t) str##_pr  = $(Nmspace{.Loc_n=0},&str##_str);\
  static datatype Binding.Unresolved_b str##_bnd = Unresolved_b(&str##_pr);\
  static datatype Raw_exp.Var_e        str##_re  = Var_e(&str##_bnd);\
  static struct Exp          str##_ev  = Exp{NULL,&str##_re,0,&EmptyAnnot_val};\
  static exp_t               str##_e   = &str##_ev

MAKE_VAR(_throw);
MAKE_VAR(setjmp);
MAKE_VAR(_push_handler);
MAKE_VAR(_pop_handler);
MAKE_VAR(_exn_thrown);
MAKE_VAR(_npop_handler);
MAKE_VAR(_check_null);
MAKE_VAR(_check_known_subscript_null);
MAKE_VAR(_check_known_subscript_notnull);
MAKE_VAR(_check_fat_subscript);
MAKE_VAR(_fat_ptr);
MAKE_VAR(_tag_fat);
MAKE_VAR(_untag_fat_ptr);
MAKE_VAR(_get_fat_size);
MAKE_VAR(_get_zero_arr_size); // NOT SURE WHETHER WE NEED BOTH?
MAKE_VAR(_get_zero_arr_size_char);
MAKE_VAR(_get_zero_arr_size_short);
MAKE_VAR(_get_zero_arr_size_int);
MAKE_VAR(_get_zero_arr_size_float);
MAKE_VAR(_get_zero_arr_size_double);
MAKE_VAR(_get_zero_arr_size_longdouble);
MAKE_VAR(_get_zero_arr_size_voidstar);
MAKE_VAR(_fat_ptr_plus);
MAKE_VAR(_zero_arr_plus);     // NOT SURE WHETHER WE NEED BOTH?
MAKE_VAR(_zero_arr_plus_char);
MAKE_VAR(_zero_arr_plus_short);
MAKE_VAR(_zero_arr_plus_int);
MAKE_VAR(_zero_arr_plus_float);
MAKE_VAR(_zero_arr_plus_double);
MAKE_VAR(_zero_arr_plus_longdouble);
MAKE_VAR(_zero_arr_plus_voidstar);
MAKE_VAR(_fat_ptr_inplace_plus);
MAKE_VAR(_zero_arr_inplace_plus); // NOT SURE WHETHER WE NEED BOTH?
MAKE_VAR(_zero_arr_inplace_plus_char);
MAKE_VAR(_zero_arr_inplace_plus_short);
MAKE_VAR(_zero_arr_inplace_plus_int);
MAKE_VAR(_zero_arr_inplace_plus_float);
MAKE_VAR(_zero_arr_inplace_plus_double);
MAKE_VAR(_zero_arr_inplace_plus_longdouble);
MAKE_VAR(_zero_arr_inplace_plus_voidstar);
MAKE_VAR(_fat_ptr_inplace_plus_post);
MAKE_VAR(_zero_arr_inplace_plus_post); // NOT SURE WHETHER WE NEED BOTH?
MAKE_VAR(_zero_arr_inplace_plus_post_char);
MAKE_VAR(_zero_arr_inplace_plus_post_short);
MAKE_VAR(_zero_arr_inplace_plus_post_int);
MAKE_VAR(_zero_arr_inplace_plus_post_float);
MAKE_VAR(_zero_arr_inplace_plus_post_double);
MAKE_VAR(_zero_arr_inplace_plus_post_longdouble);
MAKE_VAR(_zero_arr_inplace_plus_post_voidstar);
MAKE_VAR(_cycalloc);
MAKE_VAR(_cyccalloc);
MAKE_VAR(_cycalloc_atomic);
MAKE_VAR(_cyccalloc_atomic);
MAKE_VAR(_region_malloc);
MAKE_VAR(_region_calloc);
MAKE_VAR(_check_times);
MAKE_VAR(_new_region);
MAKE_VAR(_push_region);
MAKE_VAR(_pop_region);
MAKE_VAR(_throw_arraybounds);
MAKE_VAR(_fat_ptr_decrease_size);
MAKE_VAR(_throw_match);
MAKE_VAR(_rethrow);
MAKE_VAR(_fast_region_malloc);

#undef MAKE_STRING
#undef MAKE_VAR

exp_t get_exn_thrown_expression() {
  static exp_opt_t _get_exn_thrown_e = NULL;
  //  $(nmspace_t, var_t)
  if(_get_exn_thrown_e)
    return (exp_t)_get_exn_thrown_e;
  qvar_t qv = new $(Nmspace{.Abs_n=list(new "Core")}, new "get_exn_thrown");
  binding_t bnd = new Unresolved_b(qv); 
  exp_t fnname = new Exp(NULL, new Var_e(bnd), 0, &EmptyAnnot_val);
  raw_exp_t fncall_re = new FnCall_e(fnname,NULL,NULL,false);
  _get_exn_thrown_e = new Exp(NULL,fncall_re,0,&EmptyAnnot_val);
  return (exp_t)_get_exn_thrown_e;
}

static tqual_t mt_tq = Tqual(false,false,false,false,0);

type_t void_star_type() {
  static type_opt_t t = NULL;
  if (t == NULL)
    t = star_type(void_type,heap_rgn_type, empty_tqual(0), false_type);
  return (type_t)t;
}
static type_t fat_ptr_type() {
  static type_opt_t t = NULL;
  if (t == NULL)
    t = aggr_type(UnknownAggr(StructA,&_fat_ptr_pr,NULL),NULL);
  return (type_t)t;
}
static type_t rgn_type() {
  static type_opt_t r = NULL;
  if (r == NULL)
    r = cstar_type(strct(_RegionHandle_sp),mt_tq);
  return (type_t)r;
}

static stmt_t skip_stmt_dl() {
  return skip_stmt(DL);
}

static $(list_t<designator_t>,exp_t)@ make_field(var_t name,exp_t e) {
  return new $(new List(new FieldName(name),NULL), e);
}

static exp_t fncall_exp_dl(exp_t f, ... exp_t args) {
  return fncall_exp(f,List::from_array(args),DL);
}
static exp_t cast_it(type_t t, exp_t e) { // DJG: sound for numeric casts?
  switch (e->r) {
  case &Cast_e(_,e,_,No_coercion): return cast_it(t,e);
  default: return cast_exp(t,e,false,No_coercion,DL);
  }
}
// These constructors are useful when we want to just update the
// raw part of an expression or statement.
static raw_exp_t cast_it_r(type_t t, exp_t e) {
  return new Cast_e(t,e,false,No_coercion);
}
static raw_exp_t deref_exp_r(exp_t e) {
  return new Deref_e(e);
}
static raw_exp_t subscript_exp_r(exp_t e1, exp_t e2) {
  return new Subscript_e(e1,e2);
}
static raw_exp_t stmt_exp_r(stmt_t s) {
  return new StmtExp_e(s);
}
static raw_exp_t sizeoftype_exp_r(type_t t) {
  return new Sizeoftype_e(t);
}
static raw_exp_t fncall_exp_r(exp_t e, ... exp_t es) {
  return new FnCall_e(e,List::from_array(es),NULL,true);
}
static raw_stmt_t seq_stmt_r(stmt_t s1, stmt_t s2) {
  return new Seq_s(s1,s2);
}
static raw_exp_t conditional_exp_r(exp_t e1, exp_t e2, exp_t e3) {
  return new Conditional_e(e1,e2,e3);
}
static raw_exp_t aggrmember_exp_r(exp_t e, field_name_t n) {
  return new AggrMember_e(e,n,false,false);
}
static raw_exp_t unresolvedmem_exp_r(opt_t<typedef_name_t,`H> tdopt,
                                     list_t<$(list_t<designator_t,`H>,exp_t)@`H,`H> ds)
{
  return new UnresolvedMem_e(tdopt,ds);
}
static raw_stmt_t goto_stmt_r(var_t v) {
  return new Goto_s(v);
}

static datatype Raw_exp.Const_e zero_exp = Const_e(Cnst{.Int_c= $(Signed,0)});

// same as aggrmember_e(e,f,DL) but when e is a deref_e(e1), replaces with
// aggrarrow_e(e1,f,DL)
static exp_t member_exp(exp_t e, field_name_t f, seg_t loc) {
  switch (e->r) {
  case &Deref_e(e1): return aggrarrow_exp(e1,f,loc);
  default: return aggrmember_exp(e,f,loc);
  }
}

// functionSets are used to call the appropriate function from
// cyc_include.h by casing on the type of the arguments
struct functionSet {
  exp_t fchar; 
  exp_t fshort;
  exp_t fint; 
  exp_t ffloat;
  exp_t fdouble; 
  exp_t flongdouble;
  exp_t fvoidstar;
};
#define MAKE_FUNCTION_SET(op)\
struct functionSet op ## _functionSet = functionSet {\
  .fchar       = & op ## _char_ev,\
  .fshort      = & op ## _short_ev,\
  .fint        = & op ## _int_ev,\
  .ffloat      = & op ## _float_ev,\
  .fdouble     = & op ## _double_ev,\
  .flongdouble = & op ## _longdouble_ev,\
  .fvoidstar   = & op ## _voidstar_ev\
}
MAKE_FUNCTION_SET(_zero_arr_plus);
MAKE_FUNCTION_SET(_zero_arr_inplace_plus);
MAKE_FUNCTION_SET(_zero_arr_inplace_plus_post);
MAKE_FUNCTION_SET(_get_zero_arr_size);

// choose which function to call based on argument type
static exp_t getFunctionType(struct functionSet @fS, type_t t) {
  switch(compress(t)) {
  case &AppType(&IntCon(_,Char_sz),_):  return fS->fchar;
  case &AppType(&IntCon(_,Short_sz),_): return fS->fshort;
  case &AppType(&IntCon(_,Int_sz),_):   return fS->fint;
  case &AppType(&FloatCon(0),_):        return fS->ffloat;
  case &AppType(&FloatCon(1),_):        return fS->fdouble;
  case &AppType(&FloatCon(_),_):        return fS->flongdouble;
  case &PointerType(_):                 return fS->fvoidstar;
  default: 
    toc_impos2("expression type ", t, " (not int, float, double, or pointer)");
  }
}
static exp_t getFunctionRemovePointer(struct functionSet @fS, exp_t arr) {
  switch (compress((type_t)arr->topt)) {
  case &PointerType(PtrInfo{.elt_type = et,...}): return getFunctionType(fS,et);
  default: toc_impos2("impossible type (not pointer)");
  }
}

///////////////////////////// Various Utilities /////////////////////////////

// FIX: this is duplicated in tcutil; but the functions are slightly different
static bool is_zero(exp_t e) {
  switch (e->r) {
  case &Const_e({.Char_c = $(_,c)}): return c == '\0';
  case &Const_e({.Wchar_c = s}):
    let l = strlen(s);
    int i = 0;
    if (l>=2 && s[0] == '\\') {
      if (s[1] == '0') i = 2; // octal
      else if (s[1] == 'x' && l>=3 && s[2] == '0') i = 3; // hex
      else return false;
      for (; i<l; i++) // remaining chars must be '0'
        if (s[i] != '0') return false;
      return true;
    }
    else return false;
  case &Const_e({.Short_c = $(_,i)}):    return i == 0;
  case &Const_e({.Int_c = $(_,i)}):      return i == 0;
  case &Const_e({.LongLong_c = $(_,i)}): return i == 0;
  case &Pragma_e(...):
  case &Const_e({.Null_c = _}):  return true;
  case &Cast_e(_,e1,_,_):        return is_zero(e1);
  case &Tuple_e(es):             return List::forall(is_zero,es);
  case &Array_e(dles):           fallthru(dles);
  case &Aggregate_e(_,_,dles,_): fallthru(dles);
  case &CompoundLit_e(_,dles):   fallthru(dles);
  case &UnresolvedMem_e(_,dles):
    for (; dles != NULL; dles = dles->tl)
      if (!is_zero((*dles->hd)[1])) return false;
    return true;
  default: return false;
  }
}

// If x = X1::X2::...::Xn::v, generate s_X1_X2_..._Xn_v_struct
static string_t collapse_qvar(stringptr_t s, qvar_t x) {
  let &$(ns,v) = x;
  switch (ns) {
  case {.Loc_n = _}:  fallthru(NULL);
  case {.Rel_n = vs}: fallthru(vs);
  case {.Abs_n = vs}: fallthru(vs); 
  case {.C_n = vs}: 
    // special-case trims out an '_' which isn't necessary, but we do it
    // (affects the struct name for exception variants)
    if(vs==NULL)
      return aprintf("%s_%s_struct",*s,*v);
    region r;
    return aprintf("%s_%s_%s_struct",*s,rstr_sepstr(r,vs,"_"),*v);
  }
}

// Used when generating the struct name for a datatype field.  
// If fieldname = N1::N2::...::Nn::f and the datatype name is
// M1::M2::...::Mm::d, then we generate the qvar that looks
// like N1::N2::....::Nn::f_M1_M2_..._Mm_d_struct.  
// FIX: this could conflict with a user-defined struct which
// can cause errors at C-compile time. 
static qvar_t collapse_qvars_body<`r2,`d,`r>(region_t<`d> d, 
                                             $(struct TocState<`d>@`d,
                                               $(qvar_t,qvar_t)@`r2)@`r env) {
  let $(&TocState{.qvar_tags = qvs,...}, pair) = *env;
  let $(fieldname,dtname) = *pair;
  try return Dict::lookup_other(*qvs,qvar_tag_cmp,pair);
  catch { case &Dict::Absent:
    let new_pair = new $(fieldname,dtname);
    let &$(nmspace,fieldvar) = fieldname;
    string_t newvar = collapse_qvar(fieldvar,dtname);
    qvar_t res = new $(nmspace, new newvar);
    *qvs = Dict::insert(*qvs,new_pair,res);
    return res;
  }
}
static qvar_t collapse_qvars(qvar_t fieldname,qvar_t dtname) {
  _ env = $(fieldname, dtname);
  return use_toc_state(&env, (collapse_qvars_body@<`collapse_qvars>)<>);
}

// there are several places we generate C struct types
// FIX? by using Rel_n instead of Abs_n, we do not prepend Cyc_
static aggrdecl_t make_c_struct_defn(var_t name, list_t<aggrfield_t,`H> fs) {
  return new Aggrdecl{.kind=StructA, .sc=Public, .tvs=NULL,
		      .attributes=NULL, .expected_mem_kind=false,
		      .name= new $(Rel_n(NULL),name),
		      .impl= new AggrdeclImpl{NULL,NULL,fs,false}};
}

// used to generate struct definitions for tuple types
// we share the struct definitions where possible (need to for C compiler!)
static type_t add_tuple_type_body(region_t<`d> d, 
				  $(struct TocState<`d>@`d, 
				    list_t<$(tqual_t,type_t)@`H,`H>)@`r env) {
  let $(&TocState{.tuple_types = tuple_types, ...},tqs0) = *env;
  // look for the same tuple-type already declared
  for (let tts = *tuple_types; tts != NULL; tts = tts->tl) {
    let &$(x,ts) = tts->hd;
    let tqs = tqs0;
    for (; tqs != NULL && ts != NULL; tqs = tqs->tl, ts = ts->tl)
      if (!Unify::unify((*tqs->hd)[1],ts->hd))
        break;
    if(tqs == NULL && ts == NULL)
      return x;
  }
  // haven't seen this one before, add a declaration
  // need to set up a real struct declaration for get_varsizeexp and RemoveAggrs
  stringptr_t xname = new (string_t)aprintf("_tuple%d",tuple_type_counter++);
  let fs = NULL;
  let ts = NULL;
  for (int i=1; tqs0 != NULL; tqs0 = tqs0->tl, i++) {
    type_t t = (*tqs0->hd)[1];
    fs = new List(new Aggrfield(fieldname(i),mt_tq,t,NULL,NULL,NULL),fs);
    ts = rnew(d) List(t,ts);
  }
  fs = imp_rev(fs);
  ts = imp_rev(ts);
  let sd  = make_c_struct_defn(xname,fs);
  let ans = aggr_type(KnownAggr(new sd),NULL);
  result_decls = new List(new_decl(new Aggr_d(sd),DL),result_decls);
  *tuple_types = rnew(d) List(rnew(d) $(ans,ts),*tuple_types);
  return ans;
}
static type_t add_tuple_type(list_t<$(tqual_t,type_t)@`H,`H> tqs0) {
  return use_toc_state(tqs0, add_tuple_type_body<>);
}

// similar to add_tuple_type, but for anonymous aggregates (should try to share)
static type_t add_anon_aggr_type_body(region_t<`d> d,
				      $(struct TocState<`d>@`d,
					$(aggr_kind_t,list_t<aggrfield_t,`H>)@`H)@`r env) {
  let &$(&TocState{.anon_aggr_types = anon_aggr_types,...},&$(ak,fs)) = env;
  // look for the same type already declared
  for(let ts = *anon_aggr_types; ts != NULL; ts=ts->tl) {
    let &$(x,ak2,fs2) = ts->hd;
    if(ak!=ak2)
      continue;
    if(!list_cmp(Tcutil::aggrfield_cmp,fs2,fs))
      return x;
  }
  // haven't seen this one before, add a declaration
  // need to set up a real struct declaration for get_varsizeexp and RemoveAggrs
  stringptr_t xname = new (string_t)aprintf("_tuple%d",tuple_type_counter++);
  let sd = make_c_struct_defn(xname,fs);
  sd->kind = ak; // might be a union
  let ans = aggr_type(KnownAggr(new sd),NULL);
  result_decls = new List(new_decl(new Aggr_d(sd),DL),result_decls);
  *anon_aggr_types = rnew(d) List(rnew(d) $(ans,ak,fs),*anon_aggr_types);
  return ans;
}
static type_t add_anon_aggr_type(aggr_kind_t ak, list_t<aggrfield_t,`H> fs) {
  return use_toc_state(new $(ak,fs), add_anon_aggr_type_body<>);
}

// similar to the above, except that we're working with an instantiated
// abstract struct.  The fieldnames are thus drawn from the actual
// struct fields and in addition, we have to worry about the instantiation.
// It's very important that we share as many instantiations as possible
// to get the translation right.  
static type_t 
add_struct_type_body<`r2,`r3,`d,`r>(region_t<`d> d,
				    $(struct TocState<`d>@`d s,
				      $(qvar_t struct_name,
					list_t<tvar_t,`H> type_vars,
					list_t<type_t,`H> type_args,
					list_t<aggrfield_t,`r2> fields)@`r3)@`r env) {
  // first, filter out the type_vars and type_args that are not of
  // type or integer kind.
  let $(&TocState{.abs_struct_types = abs_struct_types, ...},
        &$(struct_name, type_vars, type_args, fields)) = *env;
                                      
  // look for the same instantiation of abstract-struct-type already declared
  for (let tts = *abs_struct_types; tts != NULL; tts = tts->tl) {
    let &$(x,ts2,t) = tts->hd;
    if (qvar_cmp(x,struct_name) == 0 &&
        List::length(type_args) == List::length(ts2)) {
      bool okay = true;
      for (let ts = type_args; ts != NULL; ts=ts->tl, ts2=ts2->tl) {
        let t = ts->hd;
        let t2 = ts2->hd;
        switch (type_kind(t)) {
        case &Kind{.kind = EffKind, _}://Effects/regions won't appear in C types
        case &Kind{.kind = RgnKind, _}: continue;
        default:
          // Check if they're the same before translating them to C
          if (Unify::unify(t,t2) || Unify::unify(typ_to_c(t),typ_to_c(t2)))
            continue;
          okay = false; 
          break;
        }
        break;
      }
      if (okay) // found pre-existing type
        return t;
    }
  }
  //fprintf(stderr,"didn't find pre-existing type\n");
  // haven't seen this one before, add a declaration
  // we're calling it a "tuple" so we don't have to worry about name clashes.
  stringptr_t xname = new (string_t)aprintf("_tuple%d",tuple_type_counter++);
  type_t x = strct(xname);
  let fs = NULL;
  // go ahead and add this to the struct types
  *abs_struct_types  = rnew(d) List{rnew(d) $(struct_name,type_args,x),
                                    *abs_struct_types};
  // copy the fields over
  region r;
  let inst = List::rzip(r,r,type_vars,type_args);
  for (; fields != NULL; fields = fields->tl) {
    let f = fields->hd;
    type_t t = f->type;
    attributes_t atts = f->attributes;
    // if the original type was abstract, then we must force the field
    // to be aligned.
    //DJG: FIX I think this is broken for an array with element-type
    //     of abstract mem kind
    if (fields->tl == NULL 
	&& kind_leq(&ak,type_kind(t))
	&& !is_array_type(t))
      atts = new List(new Aligned_att(NULL),atts);
    t = typ_to_c(rsubstitute(r,inst,t));
    // still could be abstract and end up void -- if so, make it
    // a zero-sized array of void*'s and force it to be aligned.
    if (Unify::unify(t,void_type)) {
      t = new ArrayType(ArrayInfo(void_star_type(), empty_tqual(DL),
                                  uint_exp(0,DL), false_type, DL));
    }
    fs = new List(new Aggrfield{f->name,mt_tq,t,f->width,atts,NULL},fs);
  }
  fs = List::imp_rev(fs);
  let sd = make_c_struct_defn(xname,fs);
  result_decls = new List(new_decl(new Aggr_d(sd),DL),result_decls);
  return x;
}

static type_t add_struct_type(qvar_t struct_name,
                              list_t<tvar_t,`H> type_vars,
                              list_t<type_t,`H> type_args,
                              list_t<aggrfield_t,`r> fields) {
  _ env = $(struct_name, type_vars, type_args, fields);
  return use_toc_state(&env, (add_struct_type_body@<`r,`add_struct_type>)<>);
}


// generate a temporary variable
// FIX: need to guarantee these can't conflict
// FIX: we share labels but not variables (why?)
qvar_t temp_var() {
  return new $(Loc_n,new (string_t)aprintf("_tmp%X",temp_var_counter++));
}
$(qvar_t,exp_t) temp_var_and_exp() {
  qvar_t v = temp_var();
  return $(v,var_exp(v,DL));
}

// generate a fresh label
// FIX: need to guarantee these can't conflict
static var_t fresh_label_body<`d,`r>(region_t<`d> d, $(struct TocState<`d>@`d,int)@`r env) {
  let $(&TocState{.temp_labels = temp_labels, ...},_) = *env;
  let i = fresh_label_counter++;
  if (i < Xarray::length(temp_labels))
    return Xarray::get(temp_labels,i);
  var_t res = new (string_t)aprintf("_LL%X",i);
  if (Xarray::add_ind(temp_labels,res) != i)
    toc_impos2("fresh_label: add_ind returned bad index...");
  return res;
}
static var_t fresh_label() {
  return use_toc_state(0, fresh_label_body<>);
}

// This should never be used for xdatatypes. Should memoize?
// The former used to use static const int variables, but couldn't at top-level.
static exp_t datatype_tag(datatypedecl_t td, qvar_t name) {
  int ans = 0;
  let fs  = td->fields->v;
  while(qvar_cmp(name,fs->hd->name)!=0) {
    ++ans;
    fs = fs->tl;
  }
  return uint_exp(ans,DL);
}

///////////////////////////////////////////////////////////////
//         Convert a Cyclone type to a C type                //
///////////////////////////////////////////////////////////////
static void enumdecl_to_c(enumdecl_t ed);
static void aggrdecl_to_c(aggrdecl_t ad);
static void datatypedecl_to_c(datatypedecl_t tud);
static $(var_opt_t,tqual_t,type_t)@ arg_to_c($(var_opt_t,tqual_t,type_t)@ a) {
  return new $((*a)[0],(*a)[1],typ_to_c((*a)[2]));
}

// Sometimes we translate arrays t[] and t[N] to t*, and sometimes
// we leave them alone.  We must leave them alone in the following
// circumstances:
// 1. as the argument of sizeof
// 2. in typedef
// 3. in declarations
// 4. as the element type of an array
// 5. as the type part of a C9X compound literal
// 6. as the type of a struct field
// We must change them to pointers in the following circumstances:
// 1. as the argument of cast
// We can do either in the following circumstances:
// 1. as the parameter of a function
// The function typ_to_c_array changes them, while typ_to_c
// changes them to pointers.
static type_t typ_to_c_array(type_t t) {
  switch(compress(t)) { // FIX: do we handle tq correctly?
  case &ArrayType(ai): return cstar_type(typ_to_c_array(ai.elt_type),ai.tq);
  default: return typ_to_c(t);
  }
}

static aggrfield_t aggrfield_to_c(aggrfield_t f, type_t new_type) {
  // JGM: I'm making the qualifiers non-const here to allow initialization
  let ans = new *f;
  ans->type = new_type;
  ans->requires_clause = NULL;
  ans->tq = mt_tq;
  return ans;
}

static void enumfields_to_c(list_t<enumfield_t> fs) {
  // FIX: assumes all constant expressions are fine as C expressions
  return;
}

static bool is_boxed_tvar(type_t t) {
  switch (compress(t)) {
  case &VarType(tv): return kind_leq(type_kind(t),&tbk);
  default: return false;
  }
}
static bool is_abstract_type(type_t t) {
  switch (type_kind(t)) {
  case &Kind{.kind = AnyKind, ...}: return true;
  default: return false;
  }
}
static bool is_void_star(type_t t) {
  switch (compress(t)) {
  case &PointerType(PtrInfo{t2,_,_}): return is_void_type(t2);
  default: return false;
  }
}
static bool is_void_star_or_boxed_tvar(type_t t) {
  return is_void_star(t) || is_boxed_tvar(t);
}
static bool is_pointer_or_boxed_tvar(type_t t) {
  return is_pointer_type(t) || is_boxed_tvar(t);
}

static void exptypes_to_c(exp_t e); // forward declaration

type_t typ_to_c(type_t t) {
  switch (t) {
  case &AppType(&VoidCon,_): return t;
  case &Evar(_,*t2,_,_): 
    if (*t2 == NULL) {
      *t2 = sint_type;
      return sint_type;
    }
    return typ_to_c((type_t)(*t2));
  case &VarType(tv):
    if (tvar_kind(tv,&bk)->kind == AnyKind)
      return void_type;
    else return void_star_type(); // map `a to void *
  case &AppType(&DatatypeCon(_),_): return void_type;
  case &AppType(&DatatypeFieldCon({.KnownDatatypefield=$(tud,tuf)}),_):
    return strctq(collapse_qvars(tuf->name,tud->name));
  case &AppType(&DatatypeFieldCon(_),_): 
    toc_impos2("unresolved DatatypeFieldType");
  case &PointerType(PtrInfo(t2,tq,PtrAtts(_,_,bnds,_,_))):
    // t2? maps to struct fat_ptr.
    // t2* and t2@ map to t2*.  Regions and zero-term are irrelevant.
    t2 = typ_to_c(t2);
    if (get_bounds_exp(fat_bound_type,bnds) == NULL)
      return fat_ptr_type();
    else 
      return star_type(t2,heap_rgn_type,tq,false_type);
  case &AppType(&IntCon(_,_),_):
  case &AppType(&FloatCon(_),_): return t;
  case &ArrayType(ArrayInfo{t2,tq,e,_,ztl}):
    return array_type(typ_to_c(t2),tq,e,false_type,ztl);
  case &FnType(FnInfo{_,_,tq2,t2,args,c_vararg,cyc_vararg,_,atts,...}):
    // just drop the type arguments & effect and translate the nested types
    // also, drop any format descriptors
    let new_atts = Atts::atts2c(atts);
    let new_args = List::map(arg_to_c,args);
    if (cyc_vararg != NULL) {
      // region for array type irrelevant
      let t =typ_to_c(fatptr_type(cyc_vararg->type,heap_rgn_type,mt_tq,false_type));
      let vararg = new $(cyc_vararg->name,cyc_vararg->tq,t);
      new_args = List::imp_append(new_args,new List(vararg,NULL));
    }
    return new FnType(FnInfo{NULL,NULL,tq2,typ_to_c(t2),new_args,
                               c_vararg,NULL,NULL,new_atts,NULL,NULL,NULL,NULL,NULL});
  case &TupleType(tqs):
    // $(t1,...,tn) maps to struct tuple_type_n where we define
    // struct tuple_type_n { t1 f1; ...; tn fn; };
    let tqs2 = NULL;
    for(; tqs != NULL; tqs=tqs->tl)
      tqs2 = new List(new $((*tqs->hd)[0],typ_to_c((*tqs->hd)[1])),tqs2);
    return add_tuple_type(imp_rev(tqs2));
  // FIX: we may have to actually declare these things and use them
  // consistently to make GCC happy.
  case &AnonAggrType(k,fs):
    // similar to tuple translation (introduce sharing to appease C)
    // but we have full aggrfields to deal with
    let fs2 = NULL;
    for(; fs!=NULL; fs=fs->tl) 
      fs2 = new List(aggrfield_to_c(fs->hd,typ_to_c(fs->hd->type)), fs2);
    return add_anon_aggr_type(k,imp_rev(fs2));
  case &AppType(c as &AggrCon(info),ts):
    // If we are in C code, the implementation may not be set here.
    switch (info) {
    case {.UnknownAggr = _}:
      if (ts == NULL) return t;
      else return new AppType(c,NULL); // drop any type args
    default: break;
    }
    let ad = get_known_aggrdecl(info);
    if (ad->expected_mem_kind) {
      // check that it turned out to be a mem!
      if (ad->impl == NULL) 
        Warn::warn2(0, ad, " was never defined.");
    }
    // Have to watch out for flaky gcc ...
    if(ad->kind==UnionA)
      return aggrdecl_type(ad->name,unionq_type);
    let fs = (ad->impl == NULL) ? NULL : ad->impl->fields;
    if (fs == NULL) return aggrdecl_type(ad->name,strctq);
    for (; fs->tl != NULL; fs = fs->tl);
    let last_type = fs->hd->type;
    if (kind_leq(&ak,type_kind(last_type))) {
      if (ad->expected_mem_kind)
        Warn::warn2(0, ad, " ended up being abstract.");
      // To avoid looping, make sure the instantiation of the last
      // type is not still abstract.  If it is, we can just return
      // the struct type.
      region r;
      let inst = rzip(r,r,ad->tvs,ts);
      let t = rsubstitute(r,inst,last_type);
      if (is_abstract_type(t)) return aggrdecl_type(ad->name,strctq);
      return add_struct_type(ad->name,ad->tvs,ts,ad->impl->fields);
    }
    return aggrdecl_type(ad->name,strctq);
  case &AppType(&EnumCon(tdn,_),_): return t;
  case &AppType(&AnonEnumCon(fs),_): enumfields_to_c(fs); return t;
  case &TypedefType(tdn,ts,td,topt):
    // just drop the type arguments and translate the nested types
    // typedef expansion is done in Absynpp::to_tms.
    if (topt == NULL) {
      if (ts != NULL)
        return new TypedefType(tdn,NULL,td,NULL);
      else return t;
    } else 
      return new TypedefType(tdn,NULL,td,typ_to_c((type_t)topt));
  case &AppType(&TagCon,_):          return uint_type; // must be unsigned!
  case &AppType(&RgnHandleCon,_):    return rgn_type();
  case &AppType(&BuiltinCon(...),_): return t;
  // these types get translated when we instantiate aggregates with
  // abstract members -- we just translate them to void* to save pain.
  case &AppType(_,_): return void_star_type();
    // FIX: when we instantiate a struct parameterized by `i::I with
    // valueof_t(42), then we want the 42 to get propagated to any arrays
    // that might occur within.  So, for now, we don't do any translation.
    // This will bite me somewhere else...
  case &ValueofType(e): return t;
  case &TypeofType(e): 
    // JGM: we have to eliminate typeof(e)'s since these might
    // occur within a type declaration and we will pull the
    // type-declaration out of scope and put it to the top-level.
    exptypes_to_c(e);
    if (e->topt != NULL) 
      return typ_to_c((type_t)e->topt);
    return t;
  case &TypeDeclType(&{.r = &Aggr_td(ad),...},_):
    aggrdecl_to_c(ad);
    if (ad->kind==UnionA)
      return aggrdecl_type(ad->name,unionq_type);
    return aggrdecl_type(ad->name,strctq);
  case &TypeDeclType(&{.r = &Enum_td(ed),...},_):
    enumdecl_to_c(ed);
    return t;
  case &TypeDeclType(&{.r = &Datatype_td(dd),...},t):
    datatypedecl_to_c(dd);
    return typ_to_c(*t);
  }
}

static exp_t array_to_ptr_cast(type_t t,exp_t e,seg_t l) {
  switch (t) {
  case &ArrayType(ArrayInfo{t2,tq,_,_,_}):
    return cast_it(star_type(t2,heap_rgn_type,tq,false_type),e);
  default: return cast_it(t,e);
  }
}

// returns true when the type contains no pointers. Is conservative
// (does not look at instantiations)
static bool atomic_type(type_t t) {
  switch (compress(t)) {
  case &VarType(_):    return false;
  case &AppType(c,ts):
    switch (c) {
    case &VoidCon: case &IntCon(_,_): case &FloatCon(_):
    case &TagCon: case &EnumCon(...): case &AnonEnumCon(...): return true;
    case &DatatypeCon(_):
    case &RgnHandleCon:
    case &BuiltinCon(...):   return false;
    case &AggrCon(info):
      switch(info) {
      case {.UnknownAggr = _}: return false; // see above!
      default: break;
      }
      let ad = get_known_aggrdecl(info);
      if(ad->impl == NULL)
        return false;
      for(let fs = ad->impl->fields; fs != NULL; fs = fs->tl)
        if (!atomic_type(fs->hd->type)) return false;
      return true;
    case &DatatypeFieldCon({.KnownDatatypefield=$(tud,tuf)}):
      for (let tqs = tuf->typs; tqs != NULL; tqs = tqs->tl)
        if (!atomic_type((*tqs->hd)[1])) return false;
      return true;
    default: toc_impos2("atomic_typ: bad type ",t);
    }
  case &FnType(_): return true;
  case &ArrayType(ArrayInfo{t,...}): return atomic_type(t);
    // FIX: really should compute in terms of the instantiation
    // to be as aggressive as possible.
    // note even without this we'll allocate Position::seg_t with atomic.
    // NOTE: cannot call get_known_aggrdecl b/c we sometimes call this
    // post-translation (with unchecked C types)?? (We shouldn't)
  case &AnonAggrType(_,fs):
    for (; fs != NULL; fs = fs->tl)
      if (!atomic_type(fs->hd->type)) return false;
    return true;
  case &TupleType(tqs):
    for (; tqs != NULL; tqs = tqs->tl)
      if (!atomic_type((*tqs->hd)[1])) return false;
    return true;
    // FIX: can do better if all variants are fieldless (but then they could
    //      have used an enum)
  case &PointerType(_): return false;
  default: toc_impos2("atomic_typ:  bad type ",t);
  }
}

// returns true when field f of the struct/union t has type void*.
static bool is_poly_field(type_t t, field_name_t f) {
  switch (compress(t)) {
  case &AppType(&AggrCon(info),_):
    let ad = get_known_aggrdecl(info);
    if (ad->impl == NULL)
      toc_impos2("is_poly_field: type missing fields");
    fallthru(ad->impl->fields);
  case &AnonAggrType(_,fs):
    let field = lookup_field(fs,f);
    if (field == NULL)
      toc_impos2("is_poly_field: bad field ",*f);
    return is_void_star_or_boxed_tvar(field->type);
  default: toc_impos2("is_poly_field: bad type ",t);
  }
}

// returns true when e is projection of a field in a struct that has a
// variable type before instantiation.  For instance, the field hd has
// type `a before instantiation in struct List.
static bool is_poly_project(exp_t e) {
  switch (e->r) {
  case &AggrMember_e(e1,f,_,_): 
    return is_poly_field((type_t)e1->topt,f) && 
      !is_void_star_or_boxed_tvar((type_t)e->topt);
  case &AggrArrow_e(e1,f,_,_):
    switch (compress((type_t)e1->topt)) {
    case &PointerType(PtrInfo{t,_,_}): 
      return is_poly_field(t,f) && !is_void_star_or_boxed_tvar((type_t)e->topt);
    default: toc_impos2("is_poly_project: bad type ",(type_t)e1->topt);
    }
  default: return false;
  }
}

// malloc something -- choose malloc routine according to the (Cyclone) type
static exp_t malloc_exp(type_t t,exp_t s) {
  exp_t fn_e = atomic_type(t) ? _cycalloc_atomic_e : _cycalloc_e;
  return fncall_exp_dl(fn_e,s);
}
// calloc something -- choose calloc routine according to the (Cyclone) type
static exp_t calloc_exp(type_t elt_type, exp_t s, exp_t n) {
  exp_t fn_e = atomic_type(elt_type) ? _cyccalloc_atomic_e : _cyccalloc_e;
  return fncall_exp_dl(fn_e,s,n);
}
// region malloc something
static exp_t rmalloc_exp(exp_t rgn, exp_t s) {
  return fncall_exp_dl(_region_malloc_e,rgn,s);
}
// region malloc (inlined) something
static exp_t rmalloc_inline_exp(exp_t rgn, exp_t s) {
  return fncall_exp_dl(_fast_region_malloc_e,rgn,s);
}
// rcalloc something
static exp_t rcalloc_exp(exp_t rgn, exp_t s, exp_t n) {
  return fncall_exp_dl(_region_calloc_e,rgn,s,n);
}
// throw a match exception
static stmt_t throw_match_stmt() {
  return exp_stmt(fncall_exp_dl(_throw_match_e),DL);
}

// t*{sz} -> t? at top-level
static exp_t make_toplevel_dyn_arr(type_t t, exp_t sz, exp_t e) {
  // Note e must be either (a) a string or else (b) a [possibly cast]
  // identifier that is an array.
  // For case a, we generate
  //   t x[sz] = e;
  //   {x,x,x+sz};
  // For case b, we generate
  //   {e,e,e+sz};
  exp_t xexp;
  exp_t xplussz;
  switch (e->r) {
  case &Const_e({.String_c  = _}): 
  case &Const_e({.Wstring_c = _}):
    qvar_t    x      = temp_var();
    type_t    vd_typ = array_type(char_type,mt_tq,sz,false_type,DL);
    vardecl_t vd     = static_vardecl(x,vd_typ,e);
    result_decls = new List(new_decl(new Var_d(vd),DL),result_decls);
    xexp = var_exp(x,DL);
    xplussz = add_exp(xexp,sz,DL);
    break;
  default: 
    xexp = cast_it(void_star_type(),e);
    // Note: If e is NULL, element size of 0 is fine!
    xplussz = cast_it(void_star_type(),add_exp(e,sz,DL));
    break;
  }
  return unresolvedmem_exp(NULL,list(new $(NULL,xexp),
				     new $(NULL,xexp),
				     new $(NULL,xplussz)),DL);
}

///////////////////////////////////////////////////////////////
//              Translation Environments                     //
///////////////////////////////////////////////////////////////
// When break_lab is NULL, translate break to break.  Otherwise,
// translate break to goto of the given label.  Similarly for
// continue.  This is used in the translation of switches and
// exception handlers to get the right control-flow.
//
// Translation of fallthru(e1,...,en) is
// v1 = trans(e1); ... vn = trans(en);
// goto fallthru_info->v[0]
// where the ith element of fallthru_info->v[1] is vi
//
// We can alpha-convert just by mutating a vd->name.  When we hoist
// a declaration (in pattern-compilation), we must alpha-convert.
static struct FallthruInfo<`r::R> {
  var_t label;
  list_t<vardecl_t> binders;
};
static struct Env<`r::R> {
  <`r2::R> : {`r2} > `r
  var_t *`r break_lab;
  var_t *`r continue_lab;
  struct FallthruInfo<`r2> *`r2 fallthru_info;
  bool toplevel;
  bool @`r2 in_lhs;
  region_t<`r> rgn;
};
typedef struct Env<`r> @`r env_t<`r>;

static env_t<`r> empty_env(region_t<`r> r) {
  return rnew(r) Env(NULL,NULL,NULL,true,rnew(r) false,r);
}

static bool is_toplevel(env_t nv) {
  let &Env{.toplevel=t,...} = nv;
  return t;
}
static env_t<`r> clear_toplevel(region_t<`r> r, env_t<`r2> e : {`r2} > `r) {
  let &Env{b,c,f,t,lhs,_} = e;
  return rnew(r) Env{b,c,f,false,lhs,r};
}
static env_t<`r> set_toplevel(region_t<`r> r, env_t<`r2> e : {`r2} > `r) {
  let &Env{b,c,f,t,lhs,_} = e;
  return rnew(r) Env{b,c,f,true,lhs,r};
}
static bool in_lhs(env_t nv) {
  let &Env{.in_lhs=b,...} = nv;
  return *b;
}
static void set_lhs(env_t<`r> e, bool b) {
  let &Env{.in_lhs = lhs,...} = e;
  *lhs = b;
}

static env_t<`r> share_env(region_t<`r> r, env_t<`r2> e : {`r2} > `r) {
  let &Env{b,c,f,t,lhs,_} = e;
  return rnew(r) Env{b,c,f,t,lhs,r};
}

// env for loop body: break and continue labels are set to null,
// exception handler pop counters for break and continue are zeroed
static env_t<`r> loop_env(region_t<`r> r, env_t<`r2> e : {`r2} > `r) {
  let &Env{b,c,f,t,lhs,_} = e;
  return rnew(r) Env{NULL,NULL,f,t,lhs,r};
}

// env for a switch clause: give new label for break, and zero its pop counter
static env_t<`r>
non_last_switchclause_env(region_t<`r> r, env_t<`r2> e, 
			  var_t break_l, var_t fallthru_l,
                          list_t<vardecl_t,`H> fallthru_binders : {`r2} > `r) {
  let &Env{b,c,f,t,lhs,_} = e;
  struct FallthruInfo<`r>*`r fi =
    rnew(r) FallthruInfo{fallthru_l,fallthru_binders};
  return rnew(r) Env{rnew(r) break_l, c, fi, t,lhs,r};
}
static env_t<`r>
last_switchclause_env(region_t<`r> r, env_t<`r2> e, var_t break_l :{`r2} > `r) {
  let &Env{b,c,f,t,lhs,_} = e;
  return rnew(r) Env{rnew(r) break_l, c,NULL,t,lhs,r};
}

// must have no pattern vars and type is int, char, or datatype of a type
// with no value constructors. (If it weren't for allowing fallthru
// anywhere, we wouldn't need the next_l.)
static env_t<`r>
switch_as_switch_env(region_t<`r> r, env_t<`r2> e, var_t next_l : {`r2} > `r) {
  let &Env{b,c,f,t,lhs,_} = e;
  return rnew(r) Env{NULL,c, rnew(r) FallthruInfo{next_l,NULL}, t,lhs,r};
}

#ifdef COARSE_REGIONS
#define TOC_RGN(env,r) let &Env{.rgn = r, ...} = (env);
#else
#define TOC_RGN(env,r) region r;
#endif

///////////////////////////////////////////////////////////////
//              Translation of Expressions                   //
///////////////////////////////////////////////////////////////
static void exp_to_c(env_t nv, exp_t e); // forward declaration
static void stmt_to_c(env_t nv, stmt_t s); // forward declaration

static void asm_iolist_types_toc(list_t<$(string_t, exp_t)@> l) {
  while(l) {
    let &$(_,e) = l->hd;
    exptypes_to_c(e);
    l = l->tl;
  }
}

static void asm_iolist_toc(env_t nv, list_t<$(string_t, exp_t)@> l) {
  while(l) {
    let &$(_,e) = l->hd;
    exp_to_c(nv, e);
    l = l->tl;
  }
}

static bool do_null_check(exp_t e) { 
  switch(e->annot) {
  case &InsertChecks::NoCheck: return false;
  case &InsertChecks::NullOnly:
  case &InsertChecks::NullAndFatBound: 
  case &InsertChecks::NullAndThinBound(_): return true;
  case &InsertChecks::FatBound:
  case &InsertChecks::ThinBound(_): return false;
  default: Warn::impos_loc2(e->loc,"Toc: do_null_check");
  }
}
// shared by exp_to_c cases for Subscript_e, AggrArrow_e, and Deref_e
// translates and mutates ptr by adding necessary checks
// input: no index means 0 (usually leads to smaller code than actually using 0)
// result: true means the index has **already been calculated in mutated ptr**
//         (result is irrelevant to caller when index is NULL)
static bool ptr_use_to_c(env_t nv, exp_t ptr, absyn_annot_t annot,
			 exp_opt_t index) {
  bool  ans;
  let   old_lhs = in_lhs(nv);
  let   old_typ = compress((type_t)ptr->topt);
  let   new_typ = typ_to_c(old_typ);
  exp_t fn_e    = _check_known_subscript_notnull_e; // see last two cases
  set_lhs(nv,false);
  exp_to_c(nv, ptr);
  if(index != NULL)
    exp_to_c(nv,index);
  switch(old_typ) {
  case &PointerType(PtrInfo{ta,tq,PtrAtts(_,_,b,zt,_)}):
    switch(annot) {
    case &InsertChecks::NoCheck: 
      if(!get_bounds_exp(bounds_one(),b)) {
        // must make sure to update the type on any modified expression
        // so that toseq knows how to deal with it.
        let newt = cstar_type(typ_to_c(ta),tq);
	ptr->r = cast_it_r(newt,member_exp(new_exp(ptr->r,DL),curr_sp,DL));
        ptr->topt = newt;
      }
      ans = false; 
      break;
    case &InsertChecks::NullOnly:
      if(!get_bounds_exp(bounds_one(),b)) {
        // rewrite e to be e.curr
        let newt = cstar_type(typ_to_c(ta),tq);
	ptr->r = cast_it_r(newt,member_exp(new_exp(ptr->r,DL),curr_sp,DL));
        ptr->topt = newt;
        // if we have x[e] where x is a fat pointer and have proven that
        // no bounds check is needed, then it must be that e is unsigned-< 
        // numelts(x).  In turn, this implies that numelts(x) >= 0 which
        // implies x is not NULL.  (See insert_checks.)  
        if (index != NULL)
          toc_impos2("subscript of ? with no bounds check but need null check");
      }
      // ((t *)_check_null(e))
      ptr->r=cast_it_r(new_typ,fncall_exp_dl(_check_null_e,new_exp(ptr->r,0)));
      ans = false;
      break;
    case &InsertChecks::NullAndFatBound: fallthru; // null check comes for free
    case &InsertChecks::FatBound:
      // ((ta1 *)_check_fat_subscript(e1, sizeof(ta1), ind))
      type_t ta1 = typ_to_c(ta);
      type_t newt = cstar_type(ta1,tq);
      exp_t  ind = index ? index : uint_exp(0,DL);
      ptr->r = cast_it_r(newt, fncall_exp_dl(_check_fat_subscript_e,
					     new_exp(ptr->r,DL),
					     sizeoftype_exp(ta1,DL),
					     ind));
      ptr->topt = newt;
      ans = true;
      break;
    case &InsertChecks::NullAndThinBound(bd): 
      fn_e = _check_known_subscript_null_e;
      fallthru(bd);
    case &InsertChecks::ThinBound(bd):
      type_t ta1 = typ_to_c(ta);
      exp_t  ind = index ? index : uint_exp(0,DL);

      // requiring the bound to be 1 is a hack, but avoids strange
      // performance degradation (surprising searches for 0)
      let $(i,valid) = Evexp::eval_const_uint_exp(bd);
      if(!valid || i != 1 || !is_zeroterm_pointer_type((type_t)ptr->topt)) {
	// ((ta1*)_fn_e(e1, esz, sizeof(ta1), ind)
	ptr->r = cast_it_r(cstar_type(ta1,tq), 
			   fncall_exp_dl(fn_e, new_exp(ptr->r,DL),
					 bd, sizeoftype_exp(ta1,DL), ind));
	ans = true;
      } else {
	// special case: null-check suffices when ind is zero
	if(is_zero(bd)) {
	  if(fn_e == _check_known_subscript_null_e)
	    // ((t *)_check_null(e))
	    ptr->r = cast_it_r(new_typ,
			       fncall_exp_dl(_check_null_e, new_exp(ptr->r,0)));
	  ans = false;
	} else {
	  // get the right run-time function (always does a null-check)
	  // *((ta2)_zero_arr_plus(e1, esz, e2)
          fn_e = getFunctionRemovePointer(&_zero_arr_plus_functionSet,ptr);
          ptr->r = cast_it_r(cstar_type(ta1,tq), 
			     fncall_exp_dl(fn_e,new_exp(ptr->r,0),bd,ind));
	  ans = true;
	}
      }
      break;
    default: Warn::impos2("FIX: ptr_use_to_c, bad annotation");
    }
    set_lhs(nv,old_lhs);
    return ans;
  default: Warn::impos2("ptr_use_to_c: non-pointer-type");
  }
}

static type_t get_cyc_type(exp_t e) {
  if (e->topt == NULL) toc_impos2("Missing type in primop ");
  return (type_t)e->topt;
}
static $(tqual_t, type_t)@ tup_to_c(exp_t e) {
  return new $(mt_tq, typ_to_c((type_t)e->topt));
}

// adds one for zeroterm.  does not multiply by element size
static exp_opt_t array_length_exp(exp_t e) {
  switch(e->r) {
  case &Array_e(dles):
    for(let dles2=dles; dles2 != NULL; dles2 = dles2->tl)
      if((*dles2->hd)[0] != NULL) // sanity check
	unimp("array designators for abstract-field initialization");
    fallthru(signed_int_exp(length(dles),DL),false);
  case &Comprehension_e(_,bd,_,zt): fallthru(bd,zt);
  case &ComprehensionNoinit_e(bd,_,zt): 
    bd = copy_exp(bd);
    return zt ? add_exp(bd,uint_exp(1,DL),DL) : bd;
  default: return NULL;
  }
}
// when using a struct-hack, find what we need to add to a malloc-argument.
// while tempting to say "keep track of this when you translate the expression"
// in all we are seeing if it is simpler not to keep track of when we are
// "directly under a new" (see New_e case of exp_to_c)
static exp_opt_t get_varsizeexp(exp_t e) {
  // * we just need to detect struct-hacks, where we have a zero-length array
  //   because the initializer has unknown length
  // * few cases because we have already translated e to C and we are
  //   concerned only with a (nested) array initializer
  // * watch out for casts?? (make sure translation to C doesn't put them in
  // * also make sure the aggr is "known"
  // * FIX? can unions still be around here?
  let dles;
  let field_types;
  switch(e->r) {
  case &Aggregate_e(_,_,dles2,_): dles=dles2; break;
  default: return NULL; // if not a struct, then no struct hack possible
  }
  switch(compress((type_t)e->topt)) {
  case &AppType(&AggrCon({.KnownAggr = &ad}),_):
    if(ad->impl==NULL)
      return NULL;
    if(ad->kind == UnionA)
      return NULL; // correct and otherwise will not find "last field"
    field_types = ad->impl->fields;
    break;
    // else silently return because something translated to an aggregate
    // may not have set the topt field
  default: return NULL;
  }
  if(field_types==NULL) // weird case: struct with no fields (possible?)
    return NULL; 
  for(; field_types->tl != NULL; field_types = field_types->tl)
    ;
  let last_type_field = field_types->hd;
  for(; dles != NULL; dles=dles->tl) {
    let &$(ds,e2) = dles->hd;
    let f = designatorlist_to_fieldname(ds);
    if(!strptrcmp(f,last_type_field->name)) {
      let nested_ans = get_varsizeexp(e2);
      if(nested_ans != NULL)
	return nested_ans;
      switch(compress(last_type_field->type)) {
      case &ArrayType(ArrayInfo{.elt_type=elt_type,.num_elts=type_bd,...}):
	// key invariant: zero-length array means struct hack
	if(type_bd == NULL || !is_zero(type_bd))
	  return NULL;
	// DJG: not sure these pad bytes are necessary, but the old 
	//      version had them
	// FIX: as was try before, we execute the bound twice, and once
	//      in a position where the flow analysis does not expect
	return add_exp(fncall_exp_dl(_check_times_e,
				     (exp_t)array_length_exp(e2),
				     sizeoftype_exp(elt_type,DL)),
		       signed_int_exp(PAD_BYTES,DL),DL);
      default: return NULL;
      }
    }
  }
  toc_impos2("get_varsizeexp: did not find last struct field");
}

static int get_member_offset(aggrdecl_t ad, field_name_t f) {
  int i = 1;
  for (let fields = ad->impl->fields; fields != NULL; fields = fields->tl) {
    let field = fields->hd;
    if (strcmp(*field->name,*f) == 0) return i;
    ++i;
  }
  toc_impos2("get_member_offset ", *f, " failed");
}

// functions for passing to lvalue_assign (see below)
static exp_t assignop_lvalue(exp_t el, $(opt_t<primop_t,`H>,exp_t)@ pr) {
  return assignop_exp(el,(*pr)[0],(*pr)[1],DL);
}
static exp_t address_lvalue(exp_t e1, bool ignore) {
  return address_exp(e1,DL);
}
static exp_t incr_lvalue(exp_t e1, incrementor_t incr) {
  return new_exp(new Increment_e(e1,incr),DL);
}

static void lvalue_assign_stmt(stmt_t s,list_t<field_name_t> fs,
			       exp_t f(exp_t,`a), `a f_env);

// e1 is the result of translating an lvalue.  fs is the path of struct
// fields that we're assigning to on e1 (if any).  The translation
//  may have inserted NULL checks, etc., but buried within e1 is an lvalue.
// We find the underlying lvalue, call it el.
// We replace el in e1 with f(el,env)
// We assume that variables in f(el,env) will not be captured by any
static void lvalue_assign(exp_t e1, list_t<field_name_t> fs,
			  exp_t f(exp_t,`a), `a f_env){
  switch (e1->r) {
  case &StmtExp_e(s): lvalue_assign_stmt(s,fs,f,f_env); break;
  case &Cast_e(t,e,_,_):  lvalue_assign(e,fs,f,f_env); break;
  case &AggrMember_e(e,fld,is_tagged,is_read):
    // Hack: strip off the struct member -- the base case adds it back in.
    e1->r = e->r;
    lvalue_assign(e1,new List(fld,fs),f,f_env);
    break;
  default:
    // Note: this may not be an lvalue b/c of &arr where arr has an array type.
    // WARNING: If the translation of lvalues changes, we may need to change
    //          how we find the "inner lvalue".
    // make a copy so we don't create a loop
    exp_t e1_copy = copy_exp(e1);
    // add the path back on to the expression
    for (; fs != NULL; fs = fs->tl)
      e1_copy = member_exp(e1_copy,fs->hd,e1_copy->loc);
    e1->r = f(e1_copy, f_env)->r;
    break;
  }
}
static void lvalue_assign_stmt(stmt_t s,list_t<field_name_t> fs,
			       exp_t f(exp_t,`a), `a f_env) {
  switch (s->r) {
  case &Exp_s(e1):    lvalue_assign(e1,fs,f,f_env);      break;
    // we assume free vars of e2 are not captured by d
  case &Decl_s(d,s2): lvalue_assign_stmt(s2,fs,f,f_env); break;
  case &Seq_s(_,s2):  lvalue_assign_stmt(s2,fs,f,f_env); break;
  default: toc_impos2("lvalue_assign_stmt: ",s);
  }
}

static void push_address_stmt(stmt_t s);

// we want to take the address of e but it may no longer be a valid
// lhs, due to a cast or null-check or whatever.
static exp_t push_address_exp(exp_t e) {
  switch (e->r) {
  case &Cast_e(*t,*e1,_,_):
    *e1 = push_address_exp(*e1);
    *t = cstar_type(*t,mt_tq);
    return e;
  case &Deref_e(e1):
    return e1;
  case &StmtExp_e(s):
    // we only have this case because of assignments to
    // tagged union members -- see tagged_union_assignop
    push_address_stmt(s);
    return e;
  default:
    if (is_lvalue(e)) return address_exp(e,DL);
    toc_impos2("can't take & of exp ",e);
  }
}
static void push_address_stmt(stmt_t s) {
  switch (s->r) {
  case &Seq_s(_,s2): fallthru(s2);
  case &Decl_s(_,s2): push_address_stmt(s2); break;
  case &Exp_s(*e): *e = push_address_exp(*e); break;
  default: toc_impos2("can't take & of stmt ",s);
  }
}

// We're translating e which is of the form e_1 op= e_2 where e_1
// involves a zero-terminated pointer and is of the form *ea or
// ea[eb].  We need to prevent overwriting the last zero in the array.  
static void zero_ptr_assign_to_c(env_t nv, exp_t e,
                                 exp_t e1, opt_t<primop_t> popt, exp_t e2,
                                 type_t ptr_type,
                                 bool is_fat,
                                 type_t elt_type) {
  // To simplify the translation, we always use a fat pointer and generate:
  //  ({ fat_ptr_type x = ((fat_ptr_type)ea) + eb;
  //     elt_type y = *x; // check here that x is not null and in bounds
  //     elt_type z = y op e2;
  //     if (numelts(x) == 1 && y == zero && z != zero) _throw_arraybounds();
  //     *x.curr = z; })
  // This is generated and *then* translated to ensure the proper constraints.
  type_t fat_ptr_type = fatptr_type(elt_type, heap_rgn_type, mt_tq, true_type);
  let c_elt_type = typ_to_c(elt_type);
  let c_fat_ptr_type = typ_to_c(fat_ptr_type);
  let c_ptr_type = cstar_type(c_elt_type, mt_tq);
  let c_ptr_type_opt = new Opt(c_ptr_type);
  exp_t xinit;
  switch (e1->r) {
  case &Deref_e(ea):
    if (!is_fat) {
      ea = cast_exp(fat_ptr_type,ea,false,Other_coercion,DL);
      ea->topt = fat_ptr_type;
      ea->annot = &InsertChecks::NoCheck_val;
    }
    exp_to_c(nv,ea); xinit = ea; break;
  case &Subscript_e(ea,eb):
    if (!is_fat) {
      ea = cast_exp(fat_ptr_type,ea,false,Other_coercion,DL);
      ea->topt = fat_ptr_type;
      ea->annot = &InsertChecks::NoCheck_val;
    }
    exp_to_c(nv,ea); exp_to_c(nv,eb);
    xinit = fncall_exp_dl(_fat_ptr_plus_e,
			  ea,sizeoftype_exp(typ_to_c(elt_type),DL),eb);
    break;
  default: toc_impos2("found bad lhs for zero-terminated pointer assignment");
  }
  let x = temp_var();                // build ptr_type x = ea + eb;
  TOC_RGN(nv, rgn2) {
    let x_vd = new Vardecl {Public,x,0,mt_tq,c_fat_ptr_type,xinit,NULL,NULL,false,false};
    let x_bnd = new Local_b(x_vd);     // build *x -- need to translate here
    let x_exp = varb_exp(x_bnd,DL);  // to check the bound and for NULL
    x_exp->topt = fat_ptr_type;
    let deref_x = deref_exp(x_exp,DL);
    deref_x->topt = elt_type;
    deref_x->annot = &InsertChecks::NullAndFatBound_val; //check bound and NULL
    exp_to_c(nv,deref_x);
    let y = temp_var();                // build elt_type y = *x;
    let y_vd = new Vardecl {Public,y,0,mt_tq,c_elt_type,deref_x,NULL,NULL,false,false};
    let y_bnd = new Local_b(y_vd);
    exp_t z_init = e2;                 // build y op e2 and translate
    if (popt != NULL) {
      let y_exp = varb_exp(y_bnd,DL);
      y_exp->topt = deref_x->topt;
      z_init = prim2_exp(popt->v,y_exp,copy_exp(e2),DL);
      z_init->topt = y_exp->topt;
      z_init->annot = &InsertChecks::NoCheck_val;
    }
    exp_to_c(nv,z_init);
    let z = temp_var();                // build z = y op e2;
    let z_vd = new Vardecl {Public,z,0,mt_tq,c_elt_type,z_init,NULL,NULL,false,false};
    let z_bnd = new Local_b(z_vd);
    // build y == zero and translate -- here, we need to know what
    // the element type is to generate the right zero.
    let y2_exp = varb_exp(y_bnd,DL); y2_exp->topt = deref_x->topt;
    let zero1_exp = signed_int_exp(0,DL);
    let comp1_exp = prim2_exp(Eq,y2_exp,zero1_exp,DL);
    zero1_exp->topt = sint_type;
    comp1_exp->topt = sint_type;
    exp_to_c(nv,comp1_exp);
    // build z != zero and translate
    let z_exp = varb_exp(z_bnd,DL); z_exp->topt = deref_x->topt;
    let zero2_exp = signed_int_exp(0,DL);
    let comp2_exp = prim2_exp(Neq,z_exp,zero2_exp,DL);
    zero2_exp->topt = sint_type;
    comp2_exp->topt = sint_type;
    exp_to_c(nv,comp2_exp);
    // build numelts(x) == 1 directly (no translation)
    let xsizeargs = list(varb_exp(x_bnd,DL),
                         sizeoftype_exp(typ_to_c(elt_type),DL));
    let oneexp = uint_exp(1,DL);
    exp_t xsize;
    xsize = prim2_exp(Eq,fncall_exp(_get_fat_size_e,xsizeargs,DL),
                      oneexp,DL);
    // start assembling the statement
    let comp_exp = and_exp(xsize,and_exp(comp1_exp,comp2_exp,DL),DL);
    let thr_stmt = exp_stmt(fncall_exp_dl(_throw_arraybounds_e),DL);
    let xcurr = member_exp(varb_exp(x_bnd,DL),curr_sp,DL);
    xcurr = cast_it(c_ptr_type,xcurr);
    let deref_xcurr = deref_exp(xcurr,DL);
    let asn_exp = assign_exp(deref_xcurr,var_exp(z,DL),DL);
    let s = exp_stmt(asn_exp,DL);
    s = seq_stmt(ifthenelse_stmt(comp_exp,thr_stmt,skip_stmt(DL),DL),s,DL);
    s = decl_stmt(new Decl(new Var_d(z_vd),DL),s,DL);
    s = decl_stmt(new Decl(new Var_d(y_vd),DL),s,DL);
    s = decl_stmt(new Decl(new Var_d(x_vd),DL),s,DL);
    e->r = stmt_exp_r(s);
  }
}

// we have a read of e1.f or e1->f where e1 does any needed null checks,
// but we now have to do a tag-check.  We translate this to:
//  ({ temp = e1;
//     if (temp->f.tag != f_tag) throw_match();
//     temp->f.val;
//  })
// unless we are in a left-hand-side context, in which case we translate to
//  ({ temp = &e1->f; // okay because e1->f is a legal lhs
//     if (temp->tag != f_tag) throw_match();
//     &temp->val; // DJG: why shouldn't this be temp->val??
//  })
static raw_exp_t check_tagged_union(exp_t e1,type_t e1_c_type,
                                    type_t aggrtype,field_name_t f,
                                    bool in_lhs,
                                    exp_t aggrproj(exp_t,field_name_t,seg_t)) {
  aggrdecl_t ad;
  switch (compress(aggrtype)) {
  case &AppType(&AggrCon(info),_): ad = get_known_aggrdecl(info); break;
  default: Warn::impos2("expecting union but found ", aggrtype, 
			" in check_tagged_union");
  }
  let $(temp,temp_exp) = temp_var_and_exp();
  let f_tag = signed_int_exp(get_member_offset(ad,f),DL);
  if (in_lhs) {
    let temp_f_tag = aggrarrow_exp(temp_exp,tag_sp,DL);
    let test_exp = neq_exp(temp_f_tag,f_tag,DL);
    let temp_f_val = aggrarrow_exp(temp_exp,val_sp,DL);
    let sres = exp_stmt(address_exp(temp_f_val,DL),DL);
    let ifs = ifthenelse_stmt(test_exp,throw_match_stmt(),skip_stmt_dl(),DL);
    let e1_p_type = cstar_type(e1_c_type,mt_tq);
    let e1_f = address_exp(aggrproj(e1,f,DL),DL);
    let s = declare_stmt(temp,e1_p_type,e1_f,seq_stmt(ifs,sres,DL),DL);
    return stmt_exp_r(s);
  } else {
    let temp_f_tag = member_exp(aggrproj(temp_exp,f,DL),tag_sp,DL);
    let test_exp = neq_exp(temp_f_tag,f_tag,DL);
    let temp_f_val = member_exp(aggrproj(temp_exp,f,DL),val_sp,DL);
    let sres = exp_stmt(temp_f_val,DL);
    let ifs = ifthenelse_stmt(test_exp,throw_match_stmt(),skip_stmt_dl(),DL);
    let s = declare_stmt(temp,e1_c_type,e1,seq_stmt(ifs,sres,DL),DL);
    return stmt_exp_r(s);
  }
}

static bool is_tagged_union_project_impl(type_t t, field_name_t f,
					 int @f_tag, type_t @ tagged_member_type,
					 bool clear_read, bool *is_read) {
  switch (compress(t)) {
  case &AppType(&AggrCon(info),_):
    let ad = get_known_aggrdecl(info);
    *f_tag = get_member_offset(ad,f);
    // FIX: we need to get unique names for these damned structs...
    string_t str = aprintf("_union_%s_%s",*((*ad->name)[1]),*f);
    *tagged_member_type = strct(new str);
    if (clear_read) *is_read = false;
    return ad->impl->tagged;
  default: return false;
  }
}

// return true if e is e1.f or e1->f where e1 is a (pointer to a)
// tagged union.  While we're at it, calculate the tag for the
// corresponding member f_tag.
static bool is_tagged_union_project(exp_t e, int @f_tag,
                                    type_t @ tagged_member_type,
                                    bool clear_read) {
  switch (e->r) {
  case &Cast_e(_,e1,_,_): toc_impos2("cast on lhs!");
  case &AggrMember_e(e1,f,_,*is_read):
    return is_tagged_union_project_impl((type_t)e1->topt,f,f_tag,
					tagged_member_type,clear_read,is_read);
  case &AggrArrow_e(e1,f,_,*is_read):
    switch (compress((type_t)e1->topt)) {
    case &PointerType(PtrInfo{.elt_type = et,...}):
      return is_tagged_union_project_impl(et,f,f_tag,
					  tagged_member_type,clear_read,is_read);
    default: return false;
    }
  default: return false;
  }
}

// special case for assignment to a tagged union member (either e1.f
// or e1->f.  In particular, when we have e1->f = e2, we rewrite to:
// ({ temp = &e1->f;
//    temp->tag = f_tag;
//    temp->val = e2; })
// and if we have e1->f op= e2 we rewrite to:
// ({ temp = &e1->f;
//    if (temp->tag != f_tag) throw_match();
//    temp->val op= e2; })
static raw_exp_t tagged_union_assignop(exp_t e1, type_t e1_cyc_type,
                                       opt_t<primop_t,`H> popt,
                                       exp_t e2, type_t e2_cyc_type,
                                       int tag_num, type_t member_type) {
  let $(temp,temp_exp) = temp_var_and_exp();
  exp_t temp_val = aggrarrow_exp(temp_exp,val_sp,DL);
  exp_t temp_tag = aggrarrow_exp(temp_exp,tag_sp,DL);
  exp_t f_tag = signed_int_exp(tag_num,DL);
  stmt_t s3 = exp_stmt(assignop_exp(temp_val,popt,e2,DL),DL);
  stmt_t s2;
  if (popt == NULL)
    s2 = exp_stmt(assign_exp(temp_tag,f_tag,DL),DL);
  else {
    let test_exp = neq_exp(temp_tag,f_tag,DL);
    s2 = ifthenelse_stmt(test_exp,throw_match_stmt(),skip_stmt_dl(),DL);
  }
  stmt_t s1 = declare_stmt(temp,cstar_type(member_type,mt_tq),
                           push_address_exp(e1),
                           seq_stmt(s2,s3,DL),DL);
  return stmt_exp_r(s1);
}


static void exp_to_c(env_t nv, exp_t e) {
  if(e->topt == NULL)
    Warn::impos_loc2(e->loc,"exp_to_c: no type for ",e);
  type_t old_typ = (type_t)e->topt;
  // cases where we think to do checks, set this bool as a sanity check
  bool did_inserted_checks = false;
  switch(e->annot) {
  case &EmptyAnnot: // for Cyclone code generated in Toc that needs no checks
  case &InsertChecks::NoCheck: did_inserted_checks = true; break;
  default: break;
  }
  switch (e->r) {
  case &Pragma_e(...):
    e->r = (raw_exp_t)(&zero_exp);
    break;
  case &Const_e({.Null_c = _}):
    // NULL translate to 0 unless a fat pointer, then {0,0,0}, via runtime
    // call unless at top-level
    // note: we don't need the element type b/c the length is 0 (so we lie)
    // note: should share all these uint_exp(0,DL) things
    let zero = signed_int_exp(0,DL);
    if(is_fat_pointer_type(old_typ)) {
      if(is_toplevel(nv))
	e->r = make_toplevel_dyn_arr(old_typ, zero, zero)->r;
      else
	e->r = fncall_exp_r(_tag_fat_e,zero,zero,zero);
    } else {
      e->r = (raw_exp_t)(&zero_exp);
    }
    break;
  case &Const_e(_): break;
  case &Var_e(_):   break;
  case &Assert_e(_): e->r = int_exp(Signed,1,DL)->r; break;
  case &Extension_e(e1): exp_to_c(nv,e1); break;
  case &Primop_e(p,es):
    // Save Cyclone types -- needed for pointer arith stuff
    let old_types = List::map(get_cyc_type,es);
    // Translate args
    List::iter_c(exp_to_c,nv,es);
    switch (p) {
    case Numelts:
      exp_t arg = es->hd;
      switch (compress((type_t)arg->topt)) {
      case &PointerType(PtrInfo(elt_type,_,PtrAtts(_,nbl,bound,zt,_))):
        let eopt = get_bounds_exp(bounds_one(),bound);
        if (eopt == NULL) {
          // retrieve (last_plus_one - curr) via runtime call
	  e->r = fncall_exp_r(_get_fat_size_e,
			      es->hd,sizeoftype_exp(typ_to_c(elt_type),DL));
        } else {
          let e2 = eopt;
          // when zero-terminated, we have to call "strlen"
          if (force_type2bool(false,zt)) {
            exp_t function_e =
	      getFunctionRemovePointer(&_get_zero_arr_size_functionSet,
				       es->hd);
            e->r = fncall_exp_r(function_e,es->hd,e2);
          } else if (force_type2bool(false,nbl)) {
            if (!Evexp::c_can_eval(e2))
              terr(e->loc,"can't calculate numelts");
            // careful! when this is a nullable pointer, the size might be 0
            e->r = conditional_exp_r(arg,e2,uint_exp(0,DL));
          } else {
            e->r = e2->r; break; // compile-time evaluation
          }
	}
	break;
      default: toc_impos2("numelts primop applied to non-pointer ",
			  ((type_t)arg->topt));
      }
      break;
    case Plus:
      // only translation is for ? pointers or zero-terminated arrays
      //   _dynxxx_ptr_plus(e1,sizeof(elt_type),e2)
      // FIX: allow arithmetic on t ? types at top-level!
      if(is_toplevel(nv))
	unimp("can't do pointer arithmetic at top-level");
      switch (compress(old_types->hd)) {
      case &PointerType(PtrInfo(elt_type,_,PtrAtts(_,_,b,zt,_))):
        let eopt = get_bounds_exp(bounds_one(),b);
	exp_t e1 = es->hd;
	exp_t e2 = es->tl->hd;
        if (eopt == NULL)
          e->r = fncall_exp_r(_fat_ptr_plus_e,
			     e1,sizeoftype_exp(typ_to_c(elt_type),DL),e2);
        else if (force_type2bool(false,zt))
	  e->r = fncall_exp_r(getFunctionRemovePointer(&_zero_arr_plus_functionSet,e1),e1,eopt,e2);
        break;
      default: break;
      }
      break;
    case Minus:
      // only translation is for ? pointers.
      // if e2 is not a fat array, do just like plus of negation,
      // else result type is unsigned int, so subtract curr fields
      type_t elt_type = void_type;
      if(is_fat_pointer_type_elt(old_types->hd,&elt_type)) {
	exp_t e1 = es->hd;
	exp_t e2 = es->tl->hd;
	if(is_fat_pointer_type(old_types->tl->hd)) {
	  e1->r = aggrmember_exp_r(new_exp(e1->r,DL),curr_sp);
	  e2->r = aggrmember_exp_r(new_exp(e2->r,DL),curr_sp);
	  e1->topt = e2->topt = cstar_type(uchar_type,mt_tq);
	  e->r  = divide_exp(copy_exp(e),
			     sizeoftype_exp(typ_to_c(elt_type),DL),DL)->r;
	} else
	  e->r = fncall_exp_r(_fat_ptr_plus_e,
			      e1,sizeoftype_exp(typ_to_c(elt_type),DL),
			      prim1_exp(Minus,e2,DL));
      }
      break;
    case Eq: case Neq: case Gt: case Gte: case Lt: case Lte:
      // need to extract .curr field of fat arrays for comparisons
      exp_t e1 = es->hd;
      exp_t e2 = es->tl->hd;
      type_t t1 = old_types->hd;
      type_t t2 = old_types->tl->hd;
      type_t elt_type = void_type; // set in next call
      if (is_fat_pointer_type_elt(t1,&elt_type)) {
	let t = cstar_type(typ_to_c(elt_type),mt_tq);
	e1->r = cast_it_r(t,member_exp(new_exp(e1->r,DL),curr_sp,DL));
	e1->topt = t;
      }
      if (is_fat_pointer_type(t2)) {
	let t = cstar_type(typ_to_c(elt_type),mt_tq);
	e2->r = cast_it_r(t,member_exp(new_exp(e2->r,DL),curr_sp,DL));
	e2->topt = t;
      }
      break;
    default: break; //skip
    }
    break;
  case &Increment_e(e2,incr):
    type_t e2_cyc_typ = (type_t)e2->topt;
    // we need to worry about the case where e2 is of the form
    // *ea or ea[eb] and ea is a zero-terminated pointer, for
    // then we need to know that the inc/dec doesn't destroy the
    // trailing 0.  See the special code in the AssignOp_e case.
    // To combat this, I'm simply disallowing it.
    //
    // Similarly, we need to worry about the case where e2 is a
    // tagged union projection.
    type_t   ignore_typ  = void_type;
    bool     ignore_bool = false;
    int      ignore_int  = 0;
    string_t incr_str    = "increment";
    if (incr == PreDec || incr == PostDec) incr_str = "decrement";
    if (is_zero_ptr_deref(e2,&ignore_typ,&ignore_bool,&ignore_typ))
      Warn::impos_loc2(e->loc,"in-place ", incr_str, " is not supported when ",
		       "dereferencing a zero-terminated pointer");
    if (is_tagged_union_project(e2,&ignore_int,&ignore_typ,true)) {
      exp_t    one = signed_int_exp(1,DL);
      primop_t op;
      one->topt = sint_type;
      switch (incr) {
      case PreInc: op = Plus;  break;
      case PreDec: op = Minus; break;
      default: Warn::impos_loc2(e->loc,"in-place post", incr_str, 
				" is not supported on @tagged union members");
      }
      e->r = new AssignOp_e(e2,new Opt(op),one);
      exp_to_c(nv,e);
      return; // recursive call should check for inserted checks
    }
    set_lhs(nv,true);
    exp_to_c(nv,e2);
    set_lhs(nv,false);
    // only t ? or zero-terminated types are translated funny,
    // note that e2 is an lvalue!
    type_t elt_typ = void_type;
    if(is_fat_pointer_type_elt(old_typ,&elt_typ)) {
      _ fn_e;
      int change = 1;
      fn_e = (incr==PostInc || incr==PostDec) ?
        _fat_ptr_inplace_plus_post_e : _fat_ptr_inplace_plus_e;
      if (incr == PreDec || incr == PostDec)
        change = -1;
      e->r = fncall_exp_r(fn_e, push_address_exp(e2),
			  sizeoftype_exp(typ_to_c(elt_typ),DL),
			  signed_int_exp(change,DL));
    } else if (is_zero_pointer_type_elt(old_typ,&elt_typ)) {
      // we treat ++x specially -- this becomes
      //   if (x != 0 && *x != 0) ++x; else _throw_arraybounds()
      // or even
      //   if (*x != 0) ++x; else _throw_arraybounds()
      // if we can show x is not null.
      did_inserted_checks = true;
      if (incr != PostInc) {
        let x = temp_var();
        let t = cstar_type(typ_to_c(old_typ),mt_tq);
        let xexp = push_address_exp(e2);
        let testexp = neq_exp(deref_exp(deref_exp(var_exp(x,DL),DL),DL),
                              int_exp(None,0,DL),DL);
        if (do_null_check(e))
          testexp = and_exp(neq_exp(deref_exp(var_exp(x,DL),DL),
                                    int_exp(None,0,DL),DL),testexp,DL);
        let s = ifthenelse_stmt(testexp,
              exp_stmt(increment_exp(deref_exp(var_exp(x,DL),DL),PreInc,DL),DL),
	      exp_stmt(fncall_exp_dl(_throw_arraybounds_e),DL),DL);
        s = seq_stmt(s,exp_stmt(deref_exp(var_exp(x,DL),DL),DL),DL);
        e->r = stmt_exp(declare_stmt(x,t,xexp,s,DL),DL)->r;
      } else {
        // e.g, x++ becomes _zero_arr_inplace_plus_post(x,1) (does null check)
        let fnSet = &_zero_arr_inplace_plus_post_functionSet;
        exp_t fn_e = getFunctionRemovePointer(fnSet, e2);
        e->r = fncall_exp_r(fn_e, push_address_exp(e2), signed_int_exp(1,DL));
      }
    } else if(elt_typ == void_type && !is_lvalue(e2)) {
      lvalue_assign(e2,NULL,incr_lvalue,incr);
      e->r = e2->r;
    }
    break;
  case &AssignOp_e(e1,popt,e2):
    // FIX: not sure all these special-cases work right *together*...
    //
    // We need to know whether or not the expression is of the form
    // *ea op= e2 or ea[eb] op= e2 where ea is a zero-terminated pointer.
    // The reason is that we need to ensure not only that the pointer
    // is in bounds, but also, if it's pointing to the last element
    // (i.e., the zero) then the value written in should continue to
    // be zero.  So, for instance, if we have *ea = e2, then either ea
    // can't point to the last element or e2 must be 0.  If we have
    // *ea op= e2 then we need to know that either ea can't point to
    // the last element or (0 op= e2) is 0.
    //
    // Similarly, when e1 is a tagged union member, then we need to
    // update its tag as well as the value.  This is problematic when
    // we have something like e.x += 1 which is both a read and a write
    // of the member.
    // See if e1 is a projection on a tagged union member.
    type_t  e1_old_typ = (type_t)e1->topt;
    type_t  e2_old_typ = (type_t)e2->topt;
    int f_tag = 0; // bogus unless e1_tagged_proj
    type_t tagged_member_struct_type = void_type; // bogus unless e1_tagged_proj
    if (is_tagged_union_project(e1,&f_tag,&tagged_member_struct_type,true)) {
      set_lhs(nv,true);
      exp_to_c(nv,e1);
      set_lhs(nv,false);
      exp_to_c(nv,e2);
      e->r = tagged_union_assignop(e1,e1_old_typ,popt,e2,e2_old_typ,f_tag,
                                   tagged_member_struct_type);
      break;
    }
    type_t ptr_type = void_type;
    type_t elt_type = void_type;
    bool is_fat = false;
    if (is_zero_ptr_deref(e1,&ptr_type,&is_fat,&elt_type)) {
      zero_ptr_assign_to_c(nv, e, e1, popt, e2, ptr_type,
                           is_fat, elt_type);
      return; //trust that call to zero_ptr_assign_to_c does any inserted checks
    }
    // See if e1 is a polymorphic field (i.e., is an instantiated type
    // variable) -- if so, coerce e2 to void*.
    bool e1_poly = is_poly_project(e1);
    set_lhs(nv,true);
    exp_to_c(nv,e1);
    set_lhs(nv,false);
    exp_to_c(nv,e2);
    // special case for pointer arithmetic of t ? or zero-terminated types
    bool done = false;
    if(popt != NULL) {
      type_t elt_typ = void_type;
      if(is_fat_pointer_type_elt(old_typ,&elt_typ)) {
        _ change;
        switch(popt->v) {
        case Plus:  change = e2; break;
        case Minus: change = prim1_exp(Minus,e2,DL); break;
        default:    toc_impos2("bad t ? pointer arithmetic");
        }
        done = true;
        // FIX: Is e1 definitely still an lvalue? Probably not!!
        let fn_e = _fat_ptr_inplace_plus_e;
        e->r = fncall_exp_r(fn_e,push_address_exp(e1),
			    sizeoftype_exp(typ_to_c(elt_typ),DL),
			    change);
      } else if (is_zero_pointer_type_elt(old_typ,&elt_typ)) {
        // We're doing x += e where x is a zero-terminated pointer.
        // Make sure we don't run off the end.
        switch (popt->v) {
        case Plus:
          done = true;
          e->r = fncall_exp_r(getFunctionRemovePointer(&_zero_arr_inplace_plus_functionSet,e1),e1,e2);
          break;
        default: toc_impos2("bad zero-terminated pointer arithmetic");
        }
      }
    }
    if(!done) {
      // this cast is necessary to avoid gcc warnings
      if (e1_poly)
        e2->r = cast_it_r(void_star_type(), new_exp(e2->r,DL));
      // The typechecker guarantees that e1 starts out as an lvalue, but
      // the translation might have to insert casts, NULL checks,
      // declarations of temps, bound checks, etc.  If so we look into e1,
      // find the lvalue, and put the assignment there.
      if (!is_lvalue(e1)) {
        lvalue_assign(e1,NULL,assignop_lvalue,new $(popt,e2));
        e->r = e1->r;
      }
    }
    break;
  case &Conditional_e(e1,e2,e3):
    exp_to_c(nv,e1);
    exp_to_c(nv,e2);
    exp_to_c(nv,e3);
    break;
  case &And_e(e1,e2): fallthru(e1,e2);
  case &Or_e(e1,e2):  fallthru(e1,e2);
  case &SeqExp_e(e1,e2):
    exp_to_c(nv,e1);
    exp_to_c(nv,e2);
    break;
  case &FnCall_e(e1,es,NULL,_):
    type_t e1_typ = (type_t)e1->topt;
    exp_to_c(nv,e1);
    did_inserted_checks = true;
    if(do_null_check(e))
      //*((t *)_check_null(e)) (cast necessary b/c void* not a function type)
      e1->r = cast_it_r(typ_to_c(e1_typ),
			fncall_exp_dl(_check_null_e,copy_exp(e1)));
    List::iter_c(exp_to_c,nv,es);
    break;
  case &FnCall_e(e1,es,&VarargCallInfo{num_varargs,injectors,vai},_):
    // if vai->inject:
    //    t vn = injector[n](es[n])
    //    ...
    //    t v0 = injector[0](es[n-num_varargs+1])
    //    t argv[num_varargs] = {&v0, ..., &vn};
    // else
    //    t argv[num_varargs] = {es[n-num_varargs+1], ..., es[n]};
    // e1(es[0], ..., es[n-num_varargs], tag_fat(argv, sizeof(t), num_varargs));
    TOC_RGN(nv,r) {
      let $(argv,argvexp) = temp_var_and_exp();
      exp_t  num_varargs_exp = uint_exp(num_varargs,DL);
      type_t cva_type = typ_to_c(vai->type);
      type_t arr_type = array_type(cva_type,mt_tq,num_varargs_exp,false_type,
                                  DL);

      int num_args     = List::length(es);
      int num_normargs = num_args - num_varargs;

      // build argument list and set es to the varargs portion
      list_t<exp_t> new_args = NULL;
      for(int i=0; i < num_normargs; ++i, es=es->tl) {
	exp_to_c(nv,es->hd);
	new_args = new List(es->hd, new_args);
      }
      new_args = new List(fncall_exp_dl(_tag_fat_e,
					argvexp,
					sizeoftype_exp(cva_type,DL),
					num_varargs_exp),
			  new_args);
      new_args = imp_rev(new_args);
      // make the function call
      type_t e1_typ = (type_t)e1->topt;
      exp_to_c(nv,e1);
      did_inserted_checks = true;
      if(do_null_check(e))
	// ((t *)_check_null(e1))
	e1->r = cast_it_r(typ_to_c(e1_typ),
			  fncall_exp_dl(_check_null_e,copy_exp(e1)));
      stmt_t s = exp_stmt(fncall_exp(e1,new_args,DL),DL);

      // make the declarations and prepend them
      if(vai->inject) {
	datatypedecl_t tud;
	switch(compress(pointer_elt_type(vai->type))) {
	case &AppType(&DatatypeCon({.KnownDatatype=&x}),_): tud = x; break;
	default: toc_impos2("unknown datatype in vararg with inject");
	}
	qvar_t ? vs = rnew(r) {for i < num_varargs : temp_var()};

        if (num_varargs != 0) {
          // declare argv = {&v1,&v2,...,&vnum_varargs}
	  // we now make it an Array_e, which RemoveAggrs converts to a 
	  // sequence of assignments
          let array_args = NULL;
          for(int i=num_varargs-1; i >= 0; --i)
            array_args = new List(address_exp(var_exp(vs[i],DL),DL),array_args);
          s = declare_stmt(argv, arr_type, array_exp(array_args,DL), s, DL);
          // evaluate varargs (reverse to get left-to-right)
	  es = imp_rev(es);
	  injectors = imp_rev(injectors);
	  int i = length(es)-1;
          for (; es != NULL; es=es->tl, injectors=injectors->tl, --i) {
            exp_t  arg      = es->hd;
            type_t arg_type = (type_t)arg->topt;
            qvar_t var      = vs[i];
            exp_t  varexp   = var_exp(var,DL);
            let &Datatypefield{qv,tqts,_,_} = injectors->hd;
            type_t field_typ = typ_to_c((*tqts->hd)[1]);
            exp_to_c(nv,arg);
            if (is_void_star_or_boxed_tvar(field_typ))
              arg = cast_it(field_typ,arg);
	    // just make an Aggregate_e and pass the buck to RemoveAggrs
	    let tdn = collapse_qvars(qv,tud->name);
	    let dles = list(make_field(tag_sp,datatype_tag(tud,qv)),
			    make_field(fieldname(1),arg));
	    s = declare_stmt(var, strctq(tdn),
			     new_exp(new Aggregate_e(tdn,NULL,dles,NULL),DL), 
			     s, DL);
          }
        } else {
	  // if there are no var args, then set argv to the empty fat pointer
	  // (thin pointer here, function-argument calls _tag_fat)
	  // instead of an array of 0 elements to keep ansi c compilers happy
          s = declare_stmt(argv,void_star_type(),uint_exp(0,DL), s,DL);
        }
      } else {
	// now just make an Array_e and pass the buck to RemoveAggrs to
	// expand it out to avoid the GCC bug
	if(num_varargs != 0) {
	  list_t<exp_t> array_args = NULL;
	  for(; es != NULL; es = es->tl) {
	    exp_to_c(nv, es->hd);
	    array_args = new List(es->hd, array_args);
	  }
	  let init = array_exp(imp_rev(array_args),DL);
	  s = declare_stmt(argv, arr_type, init, s,DL);
	} else
          s = declare_stmt(argv,void_star_type(),uint_exp(0,DL), s,DL);
      }

      e->r = stmt_exp_r(s);
    }
    break;
  case &Throw_e(e1,b):
    // throw e -> (t)(throw(e)), the latter being a function call to throw
    exp_to_c(nv,e1);
    exp_t fn_e = b ? _rethrow_e : _throw_e;
    e->r = array_to_ptr_cast(typ_to_c(old_typ),fncall_exp_dl(fn_e,e1),DL)->r;
    break;
  case &NoInstantiate_e(e1): exp_to_c(nv,e1); break;
  case &Instantiate_e(e1,ts):
    exp_to_c(nv,e1);
    // only cast when the instantiation has type variables,
    // you can cast other times, but you'll spit out much more C code.
    // Note: we don't bother to cast if type is void * anyway (b/c that's
    //       what type variables get translated to)
    // Note: we could be even more aggressive -- often the instantiated types
    //  don't show up in the translated type.  Moreover, we probably don't
    //  get warnings when the only use of the tyvar is as a parameter b/c
    //  it's just an implicit cast to void * (so long as inst type isn't int)
    for(; ts != NULL; ts = ts->tl) {
      let k = type_kind(ts->hd)->kind;
      if(k != EffKind && k != RgnKind) {
	switch(compress(ts->hd)) {
	case &VarType(_):
	case &AppType(&DatatypeCon(_),_): continue;
	default:
	  e->r = array_to_ptr_cast(typ_to_c((type_t)e->topt),e1,DL)->r;
	  break;
	}
	break;
      }
    }
    break;
  case &Cast_e(*t,e1,user_inserted,coercion):
    type_t old_t2  = (type_t)e1->topt;
    type_t old_t2_c = typ_to_c(old_t2);
    type_t new_typ = *t;
    type_t new_typ_c = typ_to_c(new_typ);
    *t = new_typ_c;
    exp_to_c(nv, e1);
    // a few Cyclone casts are translated into C effects other than casts:
    switch ($(compress(old_t2),compress(new_typ))) {
    case $(&PointerType(p1),&PointerType(p2)):
      let b1  = get_bounds_exp(bounds_one(),p1.ptr_atts.bounds);
      let b2  = get_bounds_exp(bounds_one(),p2.ptr_atts.bounds);
      let zt1 = force_type2bool(false,p1.ptr_atts.zero_term);
      let zt2 = force_type2bool(false,p2.ptr_atts.zero_term);
      switch($(b1,b2)) {
      case $(&_, &_):
	// neither fat -- bound guaranteed in type-checker, so just check NULL
	did_inserted_checks = true;
	if(do_null_check(e))
	  e->r = cast_it_r(*t,fncall_exp_dl(_check_null_e,e1));
	else if (Unify::unify(old_t2_c,new_typ_c))
	  e->r = e1->r;
        // FIX: the type-checker doesn't currently allow the case
        // where b1 > b2, but this can be allowed for zero-terminated
        // arrays (since the true length isn't known.)  Of course,
        // this obligates a run-time check.
	break;
      case $(&_, NULL): // InsertChecks ensures bound is known
        let e2 = (exp_t)b1;
        let $(i,valid) = Evexp::eval_const_uint_exp(e2);
	if(is_toplevel(nv)) {
	  // can't use a function at top-level and don't want macros
	  // If p2 is not zero-terminated and not const, then we subtract
	  // one from the size so that no one can write the last location.
          if (zt1 && !p2.elt_tq.real_const && !zt2)
            e2 = prim2_exp(Minus,e2,uint_exp(1,DL),DL);
	  e->r = make_toplevel_dyn_arr(old_t2,e2,e1)->r;
	} else {
	  // cast from t*{n} or t@{n} to t? or t?
          if (zt1) {
            // if p1 is zero-terminated then calculate the size dynamically:
            //   ({ t *x = e1;
            //      _dynxxx_ptr_arr(x, sizeof(t), _get_zero_arr_size(x,n));
            //   })
	    let $(x,x_exp) = temp_var_and_exp();
            exp_t arg3;
            // if what we're casting is a string constant or an array
            // variable, we can avoid computing the "size" at run-time.
            switch (e1->r) {
            case &Const_e({.String_c = _}):  arg3 = e2; break;
            case &Const_e({.Wstring_c = _}): arg3 = e2; break;
            case &Var_e(&Global_b(vd)): fallthru(vd);
            case &Var_e(&Local_b(vd)):
              if (!Tcutil::is_array_type(vd->type)) 
		fallthru;
              arg3 = e2;
              break;
            default:
              // if what we're casting has a known size > 1 then
              // we use it instead of calculating the size at run-time
              if (valid && i != 1) 
                arg3 = e2;
              else 
                arg3 = fncall_exp_dl(getFunctionRemovePointer(&_get_zero_arr_size_functionSet,e1),
				     cast_it(void_star_type(),x_exp),e2);
              break;
            }
            if (!zt2 && !p2.elt_tq.real_const) {
              // If p2 is not zero-terminated and not const, then we subtract
              // one from the size so that no one can write the last location.
              arg3 = prim2_exp(Minus,arg3,uint_exp(1,DL),DL);
            }
            let arg2 = sizeoftype_exp(typ_to_c(p2.elt_type),DL);
            let tg_exp = fncall_exp_dl(_tag_fat_e,x_exp,arg2,arg3);
            let s = exp_stmt(tg_exp,DL);
            s = declare_stmt(x,typ_to_c(old_t2),e1,s,DL);
            e->r = stmt_exp_r(s);
          } else
            // build the t ? struct
            e->r = fncall_exp_r(_tag_fat_e, 
				e1,
				sizeoftype_exp(typ_to_c(p2.elt_type),DL),
				e2);
        }
	break;
      case $(NULL, &_): //InsertChecks ensures not-at-toplevel and b2 is known
        // When we have t?ZEROTERM and are casting to
        // t*{e2} or t@{e2} *without* the ZEROTERM, then we
        // can't allow e2 to be the actual size of the array --
        // it needs to be one less to ensure that you can't
        // overwrite the trailing 0.  We achieve this by
        // incrementing e2 by one.  That is if x has type t?Z,
        // and we're casting it to t@{2}, then we'd better check
        // that the size is at least 2+1=3.
        let new_e2 = (exp_t)b2;
        if (zt1 && !zt2)
          new_e2 = add_exp(b2,uint_exp(1,DL),DL);
	// FIX: allow bounds check to be elided
	// cast from t ? to t* or t@ -- run-time check:
	// for t*: (t *)_untag_arr(e1, sizeof(t), new_e2)
	// for t@: (t *)_check_null(_untag_arr(e1, sizeof(t), new_e2))
	let ptr_exp = fncall_exp_dl(_untag_fat_ptr_e,
				    e1,
				    sizeoftype_exp(typ_to_c(p1.elt_type),DL),
				    new_e2);
	did_inserted_checks = true;
	if(do_null_check(e)) // DJG: redundant unless bound is 0?
	  ptr_exp->r = fncall_exp_r(_check_null_e, copy_exp(ptr_exp));
	e->r = cast_it_r(*t, ptr_exp);
	break;
      // If p1 is zero-terminated and p2 is not, then p2 had better
      // be const or else we have to decrement its size by 1.
      case $(NULL, NULL):
        if (zt1 && !zt2 && !p2.elt_tq.real_const) {
          if (is_toplevel(nv)) // FIX: move to InsertChecks
            unimp("can't coerce a ZEROTERM to a non-const NOZEROTERM pointer at toplevel");
          e->r = fncall_exp_r(_fat_ptr_decrease_size_e,
                              e1,sizeoftype_exp(typ_to_c(p1.elt_type),DL),
			      uint_exp(1,DL));
        }
	break;
      }
      break;
    case $(&PointerType(p1), &AppType(&IntCon(_,_),_)):
      switch(get_bounds_exp(bounds_one(),p1.ptr_atts.bounds)) {
      case NULL: // cast t? to int -- cast curr field to int
	e1->r = aggrmember_exp_r(new_exp(e1->r,e1->loc),curr_sp);
	e1->topt = new_typ_c;
	break;
      default: break;
      }
      break;
    default: 
      if (Unify::unify(old_t2_c,new_typ_c))
        e->r = e1->r;
      break;
    }
    break;

  case &Address_e(e1): // FIX: support & e as malloc-and-initialize?
    set_lhs(nv,true);
    exp_to_c(nv,e1);
    set_lhs(nv,false);
    if(!is_lvalue(e1)) {
      lvalue_assign(e1,NULL,address_lvalue,true);
      // the wrong cast got pushed out, so as a kludge, just re-cast
      e->r = cast_it_r(typ_to_c((type_t)e->topt),e1);
    } else if (kind_leq(&ak,type_kind((type_t)e1->topt))) {
      // we could be taking the address of an abstract member, so
      // insert a cast here.
      e->r = cast_it_r(typ_to_c((type_t)e->topt),e1);
    }
    break;

  case &New_e(rgnopt,e1):
    // we share the work with RemoveAggrs:
    // * we do the malloc and the result expression
    // * we pass the destination for the initializer, which RemoveAggrs
    //   then gets rid of
    exp_to_c(nv,e1);
    // determine elt_typ after translating e1 due to the struct hack
    type_t elt_typ = typ_to_c((type_t)e1->topt); 
    let $(x,xexp) = temp_var_and_exp();
    exp_t lhs;
    switch(compress(elt_typ)) {
    case &ArrayType(ArrayInfo(t2,...)): 
      elt_typ = typ_to_c(t2); 
      lhs = copy_exp(xexp);
      break;
    default: 
      lhs = deref_exp(copy_exp(xexp),DL); 
      break;
    }
    exp_opt_t array_len = array_length_exp(e1);
    let lenvar = array_len ? (qvar_opt_t)temp_var() : NULL;
    let lenexp = array_len ? (exp_opt_t)var_exp((qvar_t)lenvar,DL) : NULL;
    exp_t mexp;
    if(lenexp)
      mexp = fncall_exp_dl(_check_times_e,lenexp,sizeoftype_exp(elt_typ,DL));
    else
      mexp = sizeofexp_exp(deref_exp(xexp,DL),DL);
    // deal with the struct hack (executing the bound twice and suffering
    // an unnecessary copy of the data)
    let vse = get_varsizeexp(e1);
    if(vse != NULL)
      mexp = add_exp(mexp,vse,DL);
    
    if(rgnopt == NULL || Flags::no_regions)
      mexp = malloc_exp(elt_typ,mexp);
    else {
      exp_to_c(nv,rgnopt);
      mexp = rmalloc_exp(rgnopt,mexp);
    }
    exp_t answer;
    if(is_fat_ptr(old_typ))
      answer = fncall_exp_dl(_tag_fat_e, 
			     copy_exp(xexp),
			     sizeoftype_exp(elt_typ,DL),
			     (lenexp ? lenexp : uint_exp(1,DL)));
    else
      answer = copy_exp(xexp);
    e->annot = new Dest(xexp); // RemoveAggrs puts in the assignments
    let s = declare_stmt(x,cstar_type(elt_typ,mt_tq),mexp,
			 seq_stmt(exp_stmt(copy_exp(e),DL),
				  exp_stmt(answer,DL),DL),DL);
      
    if(array_len)
      s = declare_stmt((qvar_t)lenvar,uint_type,(exp_t)array_len,s,DL);
    e->r = stmt_exp_r(s);
    if(vse != NULL) // in case of the struct hack, types do not line up
      e->r = cast_it_r(typ_to_c(old_typ),copy_exp(e));
    break;

    // InsertChecks ensures we don't do checks under a sizeof
  case &Sizeofexp_e(e1):  exp_to_c(nv,e1); break;
  case &Sizeoftype_e(t):  e->r = new Sizeoftype_e(typ_to_c(t));  break;
  case &Offsetof_e(t,fs):
    let t2 = t;
    let l = fs;
    for (; l != NULL; l=l->tl) {
      switch (l->hd) {
      case &StructField(n): break;
      case &TupleIndex(n):
	switch(compress(t2)) {
	case &AppType(&AggrCon(info),_):
	  let ad = get_known_aggrdecl(info);
	  if(ad->impl==NULL)
	    toc_impos2("struct fields must be known");
	  fallthru(ad->impl->fields);
	case &AnonAggrType(_,fields):
	  let nth_field = List::nth(fields,n);
	  l->hd = new StructField(nth_field->name);
	  t2 = nth_field->type;
	  break;
	case &TupleType(ts):
	  l->hd = new StructField(fieldname(n+1));
	  t2 = (*List::nth(ts,n))[1];
	  break;
	case &AppType(&DatatypeFieldCon({.KnownDatatypefield=$(_,tuf)}),_):
	  if(n == 0)
	    l->hd = new StructField(tag_sp);
	  else {
	    t2 = (*List::nth(tuf->typs,n-1))[1];
	    l->hd = new StructField(fieldname(n));
	  }
	  break;
	default: toc_impos2("impossible type for offsetof tuple index");
	}
	break;
      }
    }
    e->r = new Offsetof_e(typ_to_c(t),fs);
    break;
  case &AggrMember_e(e1,f,is_tagged,is_read):
    bool   is_poly     = is_poly_project(e);
    type_t e1_cyc_type = (type_t)e1->topt;
    exp_to_c(nv, e1);
    if (is_tagged && is_read)
      e->r = check_tagged_union(e1,typ_to_c(e1_cyc_type),e1_cyc_type,f,
				in_lhs(nv), member_exp);
    if(is_poly) // DJG: why not && is_read as in next case?
      e->r=array_to_ptr_cast(typ_to_c((type_t)e->topt),new_exp(e->r,DL),DL)->r;
    break;
  case &AggrArrow_e(e1,f,is_tagged,is_read):
    bool   is_poly = is_poly_project(e); // decide before mutating e
    type_t e1typ   = (type_t)e1->topt;
    type_t ta;
    switch(compress(e1typ)) {
    case &PointerType(p): ta = p.elt_type; break;
    default: toc_impos2("get_ptr_typ: not a pointer!");
    }
    did_inserted_checks = true;
    ptr_use_to_c(nv,e1,e->annot,NULL);
    if (is_tagged && is_read)
      e->r=check_tagged_union(e1,typ_to_c(e1typ),ta,f,in_lhs(nv),aggrarrow_exp);
    if(is_poly && is_read)
      e->r=array_to_ptr_cast(typ_to_c((type_t)e->topt),new_exp(e->r,DL),DL)->r;
    break;
  case &Deref_e(e1):
    did_inserted_checks = true;
    ptr_use_to_c(nv,e1,e->annot,NULL);
    break;
  case &Subscript_e(e1,e2):
    switch (compress((type_t)e1->topt)) {
    case &TupleType(ts): // e1.fi  where i = e2+1
      exp_to_c(nv, e1); // DJG: I think this is a lhs if e is
      let old_lhs = in_lhs(nv);
      set_lhs(nv,false); 
      exp_to_c(nv, e2);
      let $(i,known) = Evexp::eval_const_uint_exp(e2);
      if(!known)
	Warn::impos2("unknown tuple subscript in translation to C");
      e->r = aggrmember_exp_r(e1,fieldname(i+1));
      break;
    default:
      did_inserted_checks = true;
      bool index_used = ptr_use_to_c(nv,e1,e->annot,e2);
      if(index_used)
	e->r = deref_exp_r(e1);
      break;
    }
    break;
  case &Tuple_e(es): 
    if(!is_toplevel(nv)) {
      // convert to a struct and rely on RemoveAggrs
      let strct_typ = add_tuple_type(List::map(tup_to_c,es));
      switch(strct_typ) {
      case &AppType(&AggrCon(aggrinfo),NULL): 
	list_t<$(list_t<designator_t>,exp_t)@> dles = NULL;
	aggrdecl_t sd = get_known_aggrdecl(aggrinfo);
	for(int i=1; es != NULL; es = es->tl, ++i) {
	  exp_to_c(nv,es->hd);
	  dles = new List(make_field(fieldname(i),es->hd), dles);
	}
	e->r    = new Aggregate_e(sd->name,NULL,imp_rev(dles),sd);
	e->topt = strct_typ;
	break;
      default: toc_impos2("tuple type not an aggregate");
      }
      break;
    } else {
      // At top-level use an initializer
      // $(e1,...,en) -> {e1,...,en}
      list_t<$(list_t<designator_t,`H>,exp_t)@`H,`H> dles = NULL;
      for (; es != NULL; es = es->tl) {
	exp_to_c(nv,es->hd);
	dles = new List(new $(NULL,es->hd),dles);
      }
      e->r = unresolvedmem_exp_r(NULL,imp_rev(dles));
    }
    break;
  case &Array_e(dles0):
    // We now leave this to RemoveAggrs, which converts this to assignments
    // (it can only occur as an initializer)
    // but toplevel arrays must be converted to unresolvedMem to appease
    // passes downstream
    for (let dles = dles0; dles != NULL; dles = dles->tl)
      exp_to_c(nv,(*dles->hd)[1]);
    if(is_toplevel(nv))
      e->r = unresolvedmem_exp_r(NULL,dles0);
    break;
  case &Comprehension_e(vd,e1,e2,iszeroterm):
    // at top-level e1 and e2 must be constant and we make an unresolvedmem_exp.
    // inside a function, we now pass the buck to RemoveAggrs
    exp_to_c(nv,e1);
    exp_to_c(nv,e2);
    if(is_toplevel(nv)) {
      let $(sz,known) = Evexp::eval_const_uint_exp(e1);
      let elt_typ = typ_to_c((type_t)e2->topt);
      list_t<$(list_t<designator_t>,exp_t)@> es = NULL;
      // if e2 is 0, generate an "empty" array intializer to avoid giant arrays
      if (!is_zero(e2)) {
	if(!known) // FIX: type-checker should do the same test
	  terr(e1->loc, "cannot determine value of constant");
	for (unsigned int i = 0; i < sz; i++)
	  es = new List(new $(NULL,e2),es);
	// for a zero-terminated comprehension, add in an implicit 0 to the end
	if (iszeroterm) {
	  let ezero = cast_it(elt_typ,uint_exp(0,DL));
	  es = List::imp_append(es,new List{new $(NULL,ezero), NULL});
	}
      }
      e->r = unresolvedmem_exp_r(NULL,es);
    }
    break;
  case &ComprehensionNoinit_e(e1,t1,iszeroterm):
    // at toplevel, we can just make an empty array and rely on the
    // expression's type to build an array of the right size
    // inside a function, we now pass the buck to RemoveAggrs
    // FIX?: not sure if zeroterm should be allowed here since we do not
    //       initialize?
    if(is_toplevel(nv))
      e->r = unresolvedmem_exp_r(NULL,NULL);
    else
      exp_to_c(nv,e1);
    break;

  case &AnonStruct_e(st,dles): // note: no support for struck hacks
    for(let dles2=dles; dles2!=NULL; dles2=dles2->tl)
      exp_to_c(nv,(*dles2->hd)[1]);
    let strct_typ = typ_to_c((type_t)e->topt);
    e->topt = strct_typ;
    if(!is_toplevel(nv)) {
      switch(compress(strct_typ)) {
      case &AppType(&AggrCon(aggrinfo),NULL): 
	aggrdecl_t sd = get_known_aggrdecl(aggrinfo);
	e->r    = new Aggregate_e(sd->name,NULL,dles,sd);
	e->topt = strct_typ;
	break;
      default: toc_impos2("anonStruct type not an aggregate");
      }
    } else
      e->r = unresolvedmem_exp_r(NULL,dles);
    break;

  case &Aggregate_e(*tdn,exist_ts,dles,sd):
    // now relegate rewriting to RemoveAggrs, but we still may need to 
    // generate struct definitions and other nasty stuff
    if(sd==NULL || sd->impl==NULL)
      toc_impos2("exp_to_c, Aggregate_e: missing aggrdecl pointer or fields");
    let new_typ = typ_to_c(old_typ);
    switch(compress(new_typ)) { // typ_to_c may change the struct name!
    case &AppType(&AggrCon(info),_): *tdn = aggr_kinded_name(info)[1]; break;
    default: toc_impos2("exp_to_c, Aggregate_e: bad type translation");
    }
    // to handle struct kludges for the last field of the type
    // definition, we grab the last field
    // FIX?: should probably support these kludges for tuples and datatypes
    // too, which suggests doing it after translating more things to aggregates
    let typ_fields = sd->impl->fields;
    if(typ_fields==NULL) break; // no fields (maybe possible)
    for(; typ_fields->tl != NULL; typ_fields = typ_fields->tl)
      ;
    let last_typ_field = typ_fields->hd;
    let fields = resolve_aggregate_designators(heap_region, e->loc, dles,
					       sd->kind, sd->impl->fields);
    if(!is_toplevel(nv)) {
      switch(compress(old_typ)) {
      case &AppType(&AggrCon(_),param_ts):
	// now translate the fields, with special cases noted as they occur
	for(let fields2=fields; fields2!=NULL; fields2=fields2->tl) {
	  let &$(aggrfield,fieldexp) = fields2->hd;
	  let old_field_typ = fieldexp->topt; // for kludge below
	  exp_to_c(nv,fieldexp);
	  // warning avoidance
	  if (is_void_star_or_boxed_tvar(aggrfield->type) && 
	      !is_pointer_or_boxed_tvar((type_t)fieldexp->topt))
	    fieldexp->r = cast_it(typ_to_c(aggrfield->type),
				  copy_exp(fieldexp))->r;
	  // tagged unions: have to add the tag field
	  if(sd->impl->tagged) {
	    let n = aggrfield->name;
	    let tag_exp = uint_exp(get_member_offset(sd,n),DL);
	    let tag_dle = make_field(tag_sp,tag_exp);
	    let val_dle = make_field(val_sp,fieldexp);
	    qvar_t s = new $(Abs_n(NULL,true),
			     new (string_t)aprintf("_union_%s_%s",
						   *(*sd->name)[1],*n));
	    let u_dle = 
	      make_field(n,new_exp(new Aggregate_e(s,NULL,list(tag_dle,val_dle),
						   NULL),DL));
	    e->r = new Aggregate_e(*tdn,NULL,list(u_dle),sd);
	  }
	  // if the last field has abstract mem-kind (after instantiating
	  // the type-parameters), we have to generate a type here.
	  // (If the instantiation is concrete, typ_to_c handles it)
	  // Note: unions cannot have abstract mem-kind fields
	  if(is_abstract_type(old_typ) && last_typ_field==aggrfield) {
	    let inst = append(zip(sd->impl->exist_vars,exist_ts),
			      zip(sd->tvs,param_ts));
	    list_t<aggrfield_t> new_fields = NULL;
	    for(let fs = sd->impl->fields; fs!=NULL; fs=fs->tl) {
	      let old_f = fs->hd;
	      let old_ftyp = substitute(inst,old_f->type);
	      let new_f = aggrfield_to_c(old_f,
					 typ_to_c(substitute(inst,old_ftyp)));
	      new_fields = new List(new_f,new_fields);
	      // if we do not know the last field's size, we must
	      // use a struct hack (in coordination with the New_e case,
	      // which uses get_varsizeexp
	      // KLUDGE: we must set the topt of the field in case we are 
	      //  a nested aggregate, so the outer one uses the right type
	      if(fs->tl==NULL) {
		switch(compress(new_f->type)) {
		case &ArrayType(ai):
		  if(!Evexp::c_can_eval((exp_t)(ai.num_elts))) {
		    let ai2 = ai;
		    ai2.num_elts = uint_exp(0,DL); // zero-length array type
		    new_f->type = new ArrayType(ai2);
		  }
		  break;
		default: 
		  // see kludge above: we may be the outer aggregate, so we
		  // we have to get the new inner-aggregate's type
		  if(fieldexp->topt==NULL)
		    break;
		  switch(compress((type_t)fieldexp->topt)) {
		  case &AppType(&AggrCon(_),_): 
		    new_f->type = (type_t)fieldexp->topt; break;
		  default: break;
		  }
		  break;
		}
		//DJG: FIX I think this is broken for an array with element-type
		//     of abstract mem kind
		if(!is_array_type(old_f->type) &&
		   kind_leq(&ak,type_kind(old_f->type)))
		  new_f->attributes = new List(new Aligned_att(NULL),
					       new_f->attributes);
	      }
	    }
	    sd = make_c_struct_defn(new (string_t)aprintf("_genStruct%d",
						  tuple_type_counter++),
				    imp_rev(new_fields));
	    *tdn = sd->name;
	    aggrdecl_to_c(sd); // to add the decl
	    // see kludge above: must set topt in case we are an inner aggregate
	    e->topt = aggr_type(KnownAggr(new(aggrdecl_t)sd),NULL);
	  }
	}
	break;
      default: toc_impos2("exp_to_c, Aggregate_e: bad struct type");
      }
    } else {
      // At top-level must create an initializer.  For MSVC, sort fields
      // and drop initializers (sorting okay b/c we're at top-level)
      //
      // JGM: unfortunately, doesn't work for tagged unions -- we need
      // the designators to distinguish the various cases.
      if (sd->impl->tagged) {
        // should only be one field
        let &$(field,fieldexp) = fields->hd;
        let fieldexp_type = (type_t)fieldexp->topt;
        let fieldtyp = field->type;
        exp_to_c(nv,fieldexp);
        if (is_void_star_or_boxed_tvar(fieldtyp) &&
            !is_void_star_or_boxed_tvar(fieldexp_type))
          fieldexp->r =
            cast_it_r(void_star_type(),new_exp(fieldexp->r,DL));
        // for tagged unions, must insert tag here
        int i = get_member_offset(sd,field->name);
        exp_t field_tag_exp = signed_int_exp(i,0);
        let newdles = list(new $(NULL,field_tag_exp), new $(NULL,fieldexp));
        exp_t umem = unresolvedmem_exp(NULL,newdles,0);
        e->r = unresolvedmem_exp_r(NULL,list(make_field(field->name,umem)));
      } else { // not tagged
        // here is where we now sort
        let newdles = NULL;
        let sdfields = sd->impl->fields;
        for(; sdfields!=NULL; sdfields=sdfields->tl)
          for (let fields2 = fields; fields2 != NULL; fields2 = fields2->tl) {
            if((*fields2->hd)[0] == sdfields->hd) {
              let &$(field,fieldexp) = fields2->hd;
              let fieldtyp = typ_to_c(field->type);
              let fieldexp_typ = typ_to_c((type_t)fieldexp->topt);
              exp_to_c(nv,fieldexp);
              // must cast when the types don't match up 
              if (!Unify::unify(fieldtyp, fieldexp_typ)) 
                // unless they are both arithmetic types -- C can handle this.
                if (!is_arithmetic_type(fieldtyp) ||
                    !is_arithmetic_type(fieldexp_typ))
                fieldexp = cast_it(fieldtyp, copy_exp(fieldexp));
              newdles = new List(new $(NULL,fieldexp), newdles);
              break;
            }
          }
        e->r = unresolvedmem_exp_r(NULL,imp_rev(newdles));
      }
    }
    break;

  case &Datatype_e(es,tud,tuf):
    // convert the es, inserting casts to avoid GCC warnings
    let tqts = tuf->typs;
    for(let es2 = es; es2!=NULL; es2=es2->tl, tqts=tqts->tl) {
      exp_t  cur_e     = es2->hd;
      let    cur_e_typ = (type_t)cur_e->topt;
      type_t field_typ = typ_to_c((*tqts->hd)[1]);
      exp_to_c(nv,cur_e);
      if (is_void_star_or_boxed_tvar(field_typ) && 
	  !is_pointer_or_boxed_tvar(cur_e_typ))
	  cur_e->r = cast_it(field_typ,copy_exp(cur_e))->r;
    }
    // create the tag initializer
    let tag_exp = 
      tud->is_extensible ? var_exp(tuf->name,DL) : datatype_tag(tud,tuf->name);
    // convert to a struct
    if(!is_toplevel(nv)) {
      // make an Aggregate_e and rely on RemoveAggrs (similar to tuple case)
      list_t<$(list_t<designator_t>,_)@> dles = NULL;
      for(int i=1; es!=NULL; es=es->tl, ++i)
	dles = new List(make_field(fieldname(i),es->hd), dles);
      // FIX? leaves the last field NULL (TocState does not have what we want)
      // RemoveAggrs does not currently use the field, but for computing
      // the malloc-exp, we will assume the last field is not an abstract-mem
      let tag_dle = make_field(tag_sp,tag_exp);
      e->r = new Aggregate_e(collapse_qvars(tuf->name,tud->name), NULL,
			     new List(tag_dle, imp_rev(dles)), NULL);
    } else {
      // At top-level use an initializer (identical code in tuple case;
      // should share in RemoveAggrs)
      let dles = NULL;
      for(; es!=NULL; es=es->tl)
	dles = new List(new $(NULL,es->hd), dles);
      e->r = unresolvedmem_exp_r(NULL,new List(new $(NULL,tag_exp),
					       imp_rev(dles)));
    }
    break;

  case &Enum_e(...):
  case &AnonEnum_e(...): break;

  case &Malloc_e(MallocInfo{is_calloc,rgnopt,topt,num_elts,is_fat,inline_call}):
    type_t t_c = typ_to_c(*topt);
    exp_to_c(nv,num_elts);
    qvar_opt_t x = NULL;
    exp_t pexp;
    exp_t num_elts2 = num_elts;
    if (is_fat) { // necessary to avoid evaluating num_elts twice!
      x = temp_var(); 
      num_elts2 = var_exp(x,DL);
    }
    if (is_calloc) {
      if (rgnopt != NULL && !Flags::no_regions) {
	exp_to_c(nv,rgnopt);
	pexp = fncall_exp_dl(_region_calloc_e, 
			     rgnopt, sizeoftype_exp(t_c,DL), num_elts2);
      } else
	pexp = calloc_exp(*topt,sizeoftype_exp(t_c,DL), num_elts2);
    } else {
      if (rgnopt != NULL && !Flags::no_regions) {
	exp_to_c(nv,rgnopt);
	if (inline_call)
	  pexp = rmalloc_inline_exp(rgnopt, num_elts2);
	else
	  pexp = rmalloc_exp(rgnopt, num_elts2);
      } else
          pexp = malloc_exp(*topt, num_elts2);
    }
    if (is_fat) {
      exp_t  elt_sz = is_calloc ? sizeoftype_exp(t_c,DL) : uint_exp(1,DL);
      exp_t  rexp   = fncall_exp_dl(_tag_fat_e,pexp,elt_sz,num_elts2);
      stmt_t s      = declare_stmt((qvar_t)x, uint_type, num_elts, 
				   exp_stmt(rexp,DL),DL);
      e->r = stmt_exp_r(s);
    } else
      e->r = pexp->r;
    break;

  case &Swap_e(e1,e2):
    // e1 :=: e2 becomes ({ typeof(e1) tmp = e1; typeof(e2) tmp2 = e2;
    //                      e1 = tmp2; e2 = tmp; })
    // This assumes that e1 and e2 are effect-free lvalues.  We implement
    // this by replacing e with a Cyclone expression implementing the swap,
    // and then reuse the existing code generator to get everything to work out,
    // e.g. to handle tagged unions.
    type_t e1_old_typ = (type_t)e1->topt;
    type_t e2_old_typ = (type_t)e2->topt;
    if (!is_boxed(e1_old_typ) && !is_pointer_type(e1_old_typ))
      toc_impos2("Swap_e: is_pointer_or_boxed: not a pointer or boxed type");

    // create the Cyclone expression for the swap.  Need to deep copy the
    // expressions since the translation to C is by side-effect, and the rhs
    // and lhs of tagged unions are translated differently.
    let loc = e->loc;  
    let v1 = temp_var();
    let v1e = var_exp(v1,loc); v1e->topt = e1_old_typ;
    let v2 = temp_var();
    let v2e = var_exp(v2,loc); v2e->topt = e2_old_typ;

    let s1e = assign_exp(deep_copy_exp(true,e1),v2e,loc); s1e->topt = e1_old_typ;
    let s1 = exp_stmt(s1e,loc); // e1 = v2
    let s2e = assign_exp(deep_copy_exp(true,e2),v1e,loc); s2e->topt = e2_old_typ;
    let s2 = exp_stmt(s2e,loc); // e2 = v1

    let s = declare_stmt(v1,e1_old_typ,e1, // typeof(e1) v1 = e1
	    declare_stmt(v2,e2_old_typ,e2, // typeof(e2) v2 = e2
			 seq_stmt(s1,s2,loc),loc),loc); // above asgns
    stmt_to_c(nv,s);
    e->r = stmt_exp_r(s);
    break;
  case &Tagcheck_e(e1,f):
    // e1.f.tag == f_tag
    let e1_typ = compress((type_t)e1->topt);
    exp_to_c(nv,e1);
    switch (e1_typ) {
    case &AppType(&AggrCon({.KnownAggr = &ad}), _):
      let f_tag = signed_int_exp(get_member_offset(ad,f),DL);
      let e1_f = member_exp(e1,f,DL);
      let e1_f_tag = member_exp(e1_f,tag_sp,DL);
      e->r = eq_exp(e1_f_tag,f_tag,DL)->r;
      break;
    default: toc_impos2("non-aggregate type in tagcheck");
    }
    break;
  case &StmtExp_e(s): stmt_to_c(nv,s);  break;
  case &UnresolvedMem_e(_,_): toc_impos2("UnresolvedMem");
  case &CompoundLit_e(_,_):   toc_impos2("compoundlit");
  case &Valueof_e(_):         toc_impos2("valueof(-)");
  case &Asm_e(_,_,o,i,_): 
    asm_iolist_types_toc(o);
    asm_iolist_types_toc(i);
    break;
  }
  if(!did_inserted_checks)
    Warn::impos_loc2(e->loc,"Toc did not examine an inserted check: ", e);
}


///////////////////////////////////////////////////////////////
//              Translation of Switch Statements             //
///////////////////////////////////////////////////////////////
// We use the decision tree built by tcpat to compile switch/catch
// statements.  This is somewhat complicated by fallthru and
// where clauses as noted.  We use a switch statement if the
// pattern tests admit it and there's more than 1 alternative.
// Otherwise, we use if-then-else's.  The basic idea is to take
// the decision tree and compile it so that each right-hand-side (rhs)
// has two entry points:  One entry point, called init, extracts all of the values
// for the variables in the pattern and initializes the associated
// compiler temporary variables with those values.  The other entry
// point, called body, has the actual statement for the switch clause.
// For a fallthru, we jump to the next clauses's body.  If a statement
// shows up multiple times in the decision tree, we only generate
// the body once, and goto the body the other times.  


// generates a bool and two labels to be associated with the right-hand-side
// of a switch clause.  The bool records whether we've already emitted the
// code for this clause.  The first label is used for the code that extracts
// and initializes the variables of the pattern.  The second label is the
// entry point for the right-hand-side and is used for fallthru of previous
// switch cases.
static $(bool used,var_t,var_t,switch_clause_t)@`r gen_labels(region_t<`r> r,
                                                              switch_clause_t sc) {
  return rnew(r) $(false,fresh_label(),fresh_label(),sc);
}

using Tcpat {
// given a path from the match compiler and a root expression v,
// generate code for extracting the value.
static exp_t compile_path(path_t ps, exp_t v) {
  for (; ps != NULL; ps = ps->tl) {
    let p = ps->hd;
    // we cast the expression at each stage to avoid having to deal
    // with polymorphism and the like.  This generates bigger code
    // but it's a lot more uniform.
    if (tagcheck(p->orig_pat.pattern)) {
      type_t t = (type_t)p->orig_pat.pattern->topt; 
      let t2 = compress(typ_to_c_array(t));
      switch (t2) {
        // avoid casts that C will not like.
      case &AppType(&VoidCon,_): 
      case &AppType(&AggrCon(...),_):
      case &AnonAggrType(...): break;
      default:  v = cast_it(typ_to_c_array(t),v); break;
      }
    }
    switch (p->access) {
    case &Dummy: 
      // dummy accesses correspond to the extra tuple inserted to deal
      // with && clauses in patterns.  We handle those somewhat separately.
      break;
    case &Deref: 
      // if the next access is a datatypefield, then we want to
      // make sure that we cast the pointer to the appropriate
      // struct pointer before dereferencing.  
      if (ps->tl != NULL) {
        switch (ps->tl->hd->access) {
        case &DatatypeField(tud, tuf, i):
          ps = ps->tl;
          v = cast_it(cstar_type(strctq(collapse_qvars(tuf->name, tud->name)),mt_tq),v);
          v = aggrarrow_exp(v, fieldname(i+1), DL);
          continue;
        default: break;
        }
      }
      v = deref_exp(v,DL);
      break;
    case &DatatypeField(_,_,i): fallthru(i);
    case &TupleField(i): v = member_exp(v,fieldname(i+1),DL); break;
    case &AggrField(tagged, f): 
      v = member_exp(v,f,DL); 
      if (tagged)  // tagged unions require getting the .val member
        v = member_exp(v,val_sp,DL);
      break;
    }
  }
  return v;
}

// given a root expression v and a pattern test, generate an
// expression suitable for an if-then-else.
static exp_t compile_pat_test(exp_t v, pat_test_t t) {
  switch (t) {
  case &WhereTest(e): return (e==NULL) ? v : e; // FIX: e shouldn't be NULL?
  case &EqNull:           return eq_exp(v, signed_int_exp(0,DL),DL);
  case &NeqNull:          return neq_exp(v, signed_int_exp(0,DL),DL);
  case &EqEnum(ed, ef):   return eq_exp(v, new_exp(new Enum_e(ed, ef),DL),DL);
  case &EqAnonEnum(t,ef): return eq_exp(v, new_exp(new AnonEnum_e(t,ef),DL),DL);
  case &EqFloat(s,i):     return eq_exp(v, float_exp(s,i,DL), DL);
  case &EqConst(i):       return eq_exp(v, signed_int_exp(i,DL), DL);
  case &EqDatatypeTag(i,tud,tuf):
    // The compilation of the path has already done a dereference, so
    // get rid of any dereference in the path (peeking under casts.)
  LOOP1:
    switch (v->r) {
    case &Cast_e(_,e,...): v = e; goto LOOP1;
    case &Deref_e(e):      v = e; break;
    default: break;
    }
    // cast v to a pointer to the datatype field
    v = cast_it(cstar_type(strctq(collapse_qvars(tuf->name,tud->name)),mt_tq),v);    return eq_exp(aggrarrow_exp(v,tag_sp,DL), uint_exp(i,DL),DL);
    //v = cast_it(cstar_type(sint_type,mt_tq),v); // FIX: share type
    //return eq_exp(deref_exp(v,DL), signed_int_exp(i,DL),DL);
  case &EqTaggedUnion(f,i):
    return eq_exp(member_exp(member_exp(v,f,DL),tag_sp,DL),
		  signed_int_exp(i,DL),DL);
  case &EqExtensibleDatatype(tud,tuf): 
    // Same as with datatypes, so get rid of any dereference in the path.
  LOOP2:
    switch (v->r) {
    case &Cast_e(_,e,...): v = e; goto LOOP2;
    case &Deref_e(e): v = e; break;
    default: break;
    }
    // cast v to a pointer to the datatype field
    v = cast_it(cstar_type(strctq(collapse_qvars(tuf->name, tud->name)), mt_tq),v);
    return eq_exp(aggrarrow_exp(v,tag_sp,DL), var_exp(tuf->name,DL), DL);
  }
}

// used to determine what kind of code to emit for the test of the switch
datatype TestKind { 
  OtherTest; 
  DatatypeTagTest;
  WhereTest(exp_t);
  TaggedUnionTest(field_name_t);
};
datatype TestKind.OtherTest OtherTest_val = OtherTest;
datatype TestKind.DatatypeTagTest DatatypeTagTest_val = DatatypeTagTest;

// returns the number of pattern tests that admit a switch, and whether
// the pattern test is a datatype test, a tagged union test, a where-clause
// test, or something else. If any pattern test does not support a switch, 
// then we return 0.
static $(int,datatype TestKind@) 
admits_switch(list_t<$(pat_test_t,decision_t)@> ss) {
  int c = 0;
  datatype TestKind @ k = &OtherTest_val;
  for (; ss != NULL; ss = ss->tl, c = c+1) {
    let $(ptest,_) = *ss->hd;
    switch (ptest) {
      // these can all be put in switches
    case &EqEnum(_,_): 
    case &EqAnonEnum(_,_): 
    case &EqConst(_): continue;
    case &EqTaggedUnion(f,_): 
      if (k == &OtherTest_val)
        k = new TaggedUnionTest(f);
      continue;
    case &EqDatatypeTag(_,_,_): k = &DatatypeTagTest_val; continue;
      // the rest cannot be in a switch.
    case &Tcpat::WhereTest(e) && e!=NULL: k = new WhereTest(e); return $(0, k);
    case &Tcpat::WhereTest(_):
    case &EqNull:
    case &NeqNull:
    case &EqFloat(_,_):
    case &EqExtensibleDatatype(_,_): return $(0,k);
    }
  }
  return $(c,k);
}

// given a pattern test to be used in a generated switch statement,
// extract the appropriate C-pattern (i.e., an integer).
static pat_t compile_pat_test_as_case(Tcpat::pat_test_t p) {
  exp_t e;
  switch (p) {
  case &EqEnum(ed,ef):        e = new_exp(new Enum_e(ed, ef),    DL); break;
  case &EqAnonEnum(t, ef):    e = new_exp(new AnonEnum_e(t, ef), DL); break;
  case &EqConst(i):           fallthru(i);
  case &EqDatatypeTag(i,_,_): fallthru(i);
  case &EqTaggedUnion(_,i):   e = uint_exp(i,DL); break;
  default: toc_impos2("compile_pat_test_as_case!");
  }
  return new_pat(new Exp_p(e), DL);
}
}
// sequence two optional statements.
static stmt_opt_t seq_stmt_opt(stmt_opt_t s1, stmt_opt_t s2) {
  if (s1 == NULL) return s2;
  if (s2 == NULL) return s1;
  return seq_stmt(s1,s2,DL);
}

typedef list_t<$(vardecl_t oldv,vardecl_t newv)@`r,`r> patdecls_t<`r>;

// given a pattern, produce code and environment to initialize the pattern
// variables with the appropriate values.  Updates the environment and
// decls which are passed in by reference.
static stmt_opt_t 
extract_pattern_vars(region_t<`rgn> rgn, env_t<`rgn> @nv,
                     patdecls_t<`rgn> @ decls,
                     exp_t path, pat_t p) {
  type_t t = (type_t)p->topt;
  switch (p->r) {
  case &AliasVar_p(_,vd):
    let p2 = new_pat(&Wild_p_val,0);
    p2->topt = p->topt;
    fallthru(vd,p2);
  case &Var_p(vd,p2):
    // v = r (hoisted and renamed later) and continue matching p2 against r
    let new_vd = new_vardecl(DL, temp_var(), typ_to_c_array(vd->type), NULL);
    *decls = rnew(rgn) List{rnew(rgn) $(vd,new_vd),*decls};
    let s = assign_stmt(varb_exp(new Local_b(new_vd),DL),copy_exp(path),DL);
    return seq_stmt_opt(s,extract_pattern_vars(rgn,nv,decls,path,p2));
  case &TagInt_p(_,vd): // type translation erases tvar
    // v = r  (hoisted and renamed later)
    let new_vd = new_vardecl(DL, temp_var(), typ_to_c_array(vd->type), NULL);
    *decls = rnew(rgn) List{rnew(rgn) $(vd,new_vd),*decls};
    return assign_stmt(varb_exp(new Local_b(new_vd),DL),copy_exp(path),DL);
  case &Wild_p: return NULL;
  case &Reference_p(vd,p2):
    // v = &path
    vd->type = cstar_type(t,mt_tq); //DJG: apparently necessary -- bug in tcPat?
    let new_vd = new_vardecl(DL, temp_var(), typ_to_c_array(vd->type), NULL);
    *decls = rnew(rgn) List{rnew(rgn) $(vd,new_vd),*decls};
    // cast is needed to avoid a C warning when pointing to a polymorphic field
    let s = assign_stmt(varb_exp(new Local_b(new_vd),DL),
			cast_it(cstar_type(typ_to_c_array(t),mt_tq),
                                push_address_exp(copy_exp(path))),DL);
    return seq_stmt_opt(s, extract_pattern_vars(rgn,nv,decls,path,p2));
  // for these cases, no initialization.
  case &Null_p:      
  case &Int_p(...):  
  case &Char_p(_):   
  case &Float_p(...):
  case &Enum_p(...): 
  case &AnonEnum_p(...): return NULL;

    // special case for pointer to datatype
  case &Pointer_p(&Pat{&Datatype_p(tud,tuf,ps,_),_,_}):
    if (ps == NULL) return NULL;
    qvar_t tufstrct = collapse_qvars(tuf->name,tud->name);
    let field_ptr_typ = cstar_type(strctq(tufstrct),mt_tq);
    path = cast_it(field_ptr_typ,path);
    int cnt      = 1;
    let tuf_tqts = tuf->typs;
    stmt_opt_t s = NULL;
    for(; ps != NULL; ps = ps->tl, tuf_tqts = tuf_tqts->tl, ++cnt) {
      let p2  = ps->hd;
      if(p2->r == &Wild_p_val) continue;
      let tuf_typ = (*tuf_tqts->hd)[1];
      let t2  = (type_t)p2->topt;
      let t2c = typ_to_c_array(t2);
      let arrow_exp = aggrarrow_exp(path, fieldname(cnt), DL);
      if(is_void_star_or_boxed_tvar(typ_to_c(tuf_typ)))
	arrow_exp = cast_it(t2c, arrow_exp);
      s = seq_stmt_opt(s,extract_pattern_vars(rgn,nv,decls,arrow_exp,p2));
    }
    return s;

  case &Datatype_p(_,_,ps,_): fallthru(ps);
  case &Tuple_p(ps,_):
    stmt_opt_t s = NULL;
    int cnt = 1;
    for(; ps != NULL; ps = ps->tl, ++cnt) {
      let p2  = ps->hd;
      if(p2->r == &Wild_p_val)
	continue;
      let t2  = (type_t)p2->topt;
      let f = fieldname(cnt);
      s = seq_stmt_opt(s, extract_pattern_vars(rgn,nv,decls,member_exp(path,f,DL),p2));
    }
    return s;
  case &Aggr_p(NULL,...): toc_impos2("unresolved aggregate pattern!");
  case &Aggr_p(&info,_,dlps,_):
    // similar to translation of tuple pattern, but must account for designators.
    let ad = get_known_aggrdecl(info);
    stmt_opt_t s = NULL;
    for (; dlps != NULL; dlps = dlps->tl) {
      let tup = dlps->hd;
      let p2  = (*tup)[1];
      if(p2->r == &Wild_p_val)
        continue;
      let f = designatorlist_to_fieldname((*tup)[0]);
      let t2 = (type_t)p2->topt;
      let t2c = typ_to_c_array(t2);
      let memexp = member_exp(path,f,DL);
      // tagged unions require an extra .val
      if (ad->impl->tagged) memexp = member_exp(memexp,val_sp,DL);
      let ftype = lookup_field(ad->impl->fields,f)->type;
      if (is_void_star_or_boxed_tvar(ftype))
        memexp = cast_it(t2c, memexp);
      else if (!is_array_type(ftype) && kind_leq(&ak,type_kind(ftype))) {
        // for abstract members, we have to convert to the right
        // pointer type...
        memexp = deref_exp(cast_it(cstar_type(t2c,mt_tq), 
                                   address_exp(memexp,DL)),DL);
      }
      s = seq_stmt_opt(s, extract_pattern_vars(rgn,nv,decls,memexp,p2));
    }
    return s;

  case &Pointer_p(p2): 
    return extract_pattern_vars(rgn,nv,decls,deref_exp(path,DL),p2);

  case &UnknownId_p(_):       toc_impos2("unknownid pat");
  case &UnknownCall_p(_,_,_): toc_impos2("unknowncall pat");
  case &Exp_p(_):             toc_impos2("exp pat");
  }
}

static vardecl_t find_new_var(patdecls_t vs, vardecl_t v) {
  for (; vs != NULL; vs = vs->tl) {
    let $(oldv,newv) = *vs->hd;
    if (oldv == newv) return newv;
  }
  toc_impos("find_new_var");
}

// we have to substitute the associated temps for the
// pattern vars that occur in a where-clause.  This is
// limited to noassign_exp's (see tcstmt.cyc).
static void subst_pattern_vars(patdecls_t env, exp_t e) {
  switch (e->r) {
  case &Var_e(&Pat_b(vd)):  fallthru(vd);
  case &Var_e(&Local_b(vd)):
    try {
      e->r = new Var_e(new Local_b(assoc(env,vd)));
    } catch {
    case &Core::Not_found: break;
    }
    break;
  case &Conditional_e(e1,e2,e3):
    subst_pattern_vars(env,e1); fallthru(e2,e3);
  case &Comprehension_e(_,e1,e2,_): fallthru(e1,e2);
  case &And_e(e1,e2): fallthru(e1,e2);
  case &Or_e(e1,e2): fallthru(e1,e2);
  case &Subscript_e(e1,e2): fallthru(e1,e2);
  case &SeqExp_e(e1,e2): 
    subst_pattern_vars(env,e1); fallthru(e2);
  case &Extension_e(e): fallthru(e);
  case &Tagcheck_e(e,_): fallthru(e);
  case &Throw_e(e,...): fallthru(e);
  case &NoInstantiate_e(e): fallthru(e);
  case &Instantiate_e(e,...): fallthru(e);
  case &Cast_e(_,e,...): fallthru(e);
  case &Sizeofexp_e(e): fallthru(e);
  case &Deref_e(e): fallthru(e);
  case &AggrMember_e(e,...): fallthru(e);
  case &AggrArrow_e(e,...): fallthru(e);
  case &ComprehensionNoinit_e(e,...): fallthru(e);
  case &Address_e(e): subst_pattern_vars(env,e); break;
  case &Malloc_e(MallocInfo{_,eopt,_,e,...}): fallthru(eopt,e);
  case &New_e(eopt,e):
    if (eopt != NULL) subst_pattern_vars(env,(exp_t)eopt);
    subst_pattern_vars(env,e); break;
  case &Primop_e(_,es): fallthru(es);
  case &Datatype_e(es,...): fallthru(es);
  case &Tuple_e(es): List::iter_c(subst_pattern_vars,env,es); break;
  case &UnresolvedMem_e(_,dles): fallthru(dles);
  case &Aggregate_e(_,_,dles,_): fallthru(dles);
  case &AnonStruct_e(_,dles)   : fallthru(dles);
  case &Array_e(dles)          : fallthru(dles);
  case &CompoundLit_e(_,dles)  :
    for (; dles != NULL; dles = dles->tl) {
      let &$(_,e) = dles->hd;
      subst_pattern_vars(env,e);
    }
    break;
  default: break;
  }
}

// compiles a decision tree that was generated from the match compiler
// into a set of tests, switches, goto's, etc.  dopt is the decision tree
// and lscs is the original list of switch clauses, together with the labels
// we generated to jump to.  The variable v is used as the root value that
// we're matching on.
static stmt_t 
compile_decision_tree(region_t<`rgn> rgn, 
		      env_t<`rgn> nv,
		      patdecls_t<`rgn> @ decls,
		      list_t<$(env_t<`rgn>,var_t,stmt_t)@`rgn,`rgn>@ bodies,
		      Tcpat::decision_opt_t dopt,
		      list_t<$(bool,var_t,var_t,switch_clause_t)@> lscs,
		      qvar_t v) {
  switch (dopt) {
  // these two cases shouldn't occur -- we let them through silently.
  case NULL: return skip_stmt(0);
  case &Tcpat::Failure(_): return throw_match_stmt();
  case &Tcpat::Success(rhs):
    // find the corresponding rhs in lscs
    for (; lscs != NULL; lscs = lscs->tl) {
      let &$(*already_emitted,init_lab,code_lab,sc) = lscs->hd;
      let body = sc->body;
      if (body == rhs->rhs) {
        // if we've already emitted this rhs, then just goto it.
        if (*already_emitted) 
          return goto_stmt(init_lab,DL);
        *already_emitted = true;
        patdecls_t<`rgn> newdecls = NULL;
        // extract all of the pattern variables for this case
        stmt_opt_t init_opt = extract_pattern_vars(rgn,&nv,&newdecls,
                                                   var_exp(v,DL),sc->pattern);
        // generate init_lab: <code to extract vars to temps>; 
        //          code_lab: <copy-temps-to-declared-patvars>; <rhs>
        stmt_t res = sc->body;
        for (let ds = newdecls; ds != NULL; ds = ds->tl) {
          let $(oldv,newv) = *ds->hd;
          *decls = rnew(rgn) List{rnew(rgn) $(oldv,newv),*decls};
          oldv->initializer = varb_exp(new Local_b(newv), DL);
          oldv->initializer->topt = newv->type;
          oldv->type = newv->type;
          res = decl_stmt(new Decl{new Var_d(oldv),DL}, res, DL);
        }
        res = label_stmt(code_lab,res,DL);
        if (init_opt != NULL)
          res = seq_stmt(init_opt, res, DL);
        res = label_stmt(init_lab, res, DL);
        *bodies = rnew(rgn) List{rnew(rgn) $(nv,code_lab,body), *bodies};
        return res;
      }
    }
    toc_impos2("couldn't find rhs!");
  case &Tcpat::SwitchDec(symbolic_path, switches, other_decision):
    // start by compiling the default
    stmt_t res = compile_decision_tree(rgn,nv,decls,bodies,other_decision,lscs,v);
    // now we compile the path to the thing we're testing
    let p = compile_path(List::rev(symbolic_path), var_exp(v,DL));
    let ss = List::rev(switches);
    // see if we can/should translate this to a switch or a sequence of if's
    let $(allows_switch, test_kind) = admits_switch(ss);
    if (allows_switch > 1) {
      // we'll generate a switch statement here
      // start with the default clause at the end.
      list_t<switch_clause_t> new_lscs = 
        new List{new Switch_clause{new_pat(&Wild_p_val,DL),NULL,NULL,res,DL},NULL};
      // add in each switch clause
      for (; ss != NULL; ss = ss->tl) {
        let $(pat_test, dec_tree) = *ss->hd;
        // compile the pattern test for this clause as a case expression
        let case_exp = compile_pat_test_as_case(pat_test);
        // compile the decision tree for this case
        let s = compile_decision_tree(rgn,nv,decls,bodies,dec_tree,lscs,v);
        // add in the new switch clause
        new_lscs = new List(new Switch_clause{case_exp,NULL,NULL,s,DL},new_lscs);
      }
      switch (test_kind) {
      case &DatatypeTagTest:
      LOOP1: // get rid of any extra dereference for datatypes
        switch (p->r) {
        case &Cast_e(_,e,...): p = e; goto LOOP1;
        case &Deref_e(e):      p = e; break;
        default: break;
        }
        p = deref_exp(cast_it(cstar_type(sint_type,mt_tq),p),DL); break;
      case &TaggedUnionTest(f): // add an extra .tag for tagged unions
        p = member_exp(member_exp(p,f,DL),tag_sp,DL); break;
      case &WhereTest(_): // where shouldn't really happen here.
      case &OtherTest: break;
      }
      res = new_stmt(new Switch_s(p,new_lscs,NULL),DL);
    } else {
      // We're going to have to compile the test as an if-then-else
      // We could be down to a where clause
      switch (test_kind) {
      case &WhereTest(e):
        switch (ss) {
          // where-clauses should only occur in a switch with a single case
          // other than the default.
        case &List{&$(pat_test, &Tcpat::Success(rhs)),NULL}:
          // find the corresponding rhs -- this is quite similar to the 
          // rhs code above for Success.
          for (; lscs != NULL; lscs = lscs->tl) {
            let &$(*already_emitted,init_lab,code_lab,sc) = lscs->hd;
            let body = sc->body;
            if (body == rhs->rhs) {
              // if we've already emitted code for this case, then goto it.
              if (*already_emitted) 
                return goto_stmt(init_lab,DL);
              *already_emitted = true;
              patdecls_t<`rgn> newdecls = NULL;
              // extract all of the pattern variables for this case
              stmt_opt_t init_opt = extract_pattern_vars(rgn,&nv,&newdecls,var_exp(v,DL),
                                                         sc->pattern);
              // generate init_lab: <code to extract vars>; 
              //          if (e) { code_lab: <rhs> } else <default>
              stmt_t r = sc->body;
              for (let ds = newdecls; ds != NULL; ds = ds->tl) {
                let $(oldv,newv) = *ds->hd;
                *decls = rnew(rgn) List{rnew(rgn) $(oldv,newv),*decls};
                oldv->initializer = varb_exp(new Local_b(newv), DL);
                oldv->initializer->topt = newv->type;
                oldv->type = newv->type;
                r = decl_stmt(new Decl{new Var_d(oldv),DL}, r, DL);
              }
              r = label_stmt(code_lab,r,DL);
              // compile the where-clause
              // PROBLEM: we have to map the pattern variables in the
              // where clause to the associated temps.  
              subst_pattern_vars(*decls,e);
              exp_to_c(nv,e);
              r = ifthenelse_stmt(e,r,res,DL);
              if (init_opt != NULL)
                r = seq_stmt(init_opt, r, DL);
              r = label_stmt(init_lab, r, DL);
              *bodies = rnew(rgn) List{rnew(rgn) $(nv,code_lab,body), *bodies};
              return r;
            }
          }
          toc_impos2("couldn't find rhs!");
        default: toc_impos2("bad where clause in match compiler");
        }
      default:
        // generate a sequence of nested ifs
        for (; ss != NULL; ss = ss->tl) {
          let $(pat_test, dec_tree) = *ss->hd;
          let test_exp = compile_pat_test(p, pat_test);
          let s = compile_decision_tree(rgn,nv,decls,bodies,dec_tree,lscs,v);
          res = ifthenelse_stmt(test_exp,s,res,DL);
        }
      }
    }
    return res;
  }
}

// We record the compiler environment that gets generated for each rhs of
// the case.  This allows us to look it up so that we can use it for fallthru's.
// The only rhs's that will not have an associated env are those that never
// show up in the decision tree.  That should only happen for a catch where
// we added in a default clause that was unnecessary.  The good news is that
// we discover this during switch-compilation and just skip over that clause.
static env_t<`rgn>*`rgn 
find_case_env(list_t<$(env_t<`rgn>,var_t,stmt_t)@`rgn,`rgn> bodies, stmt_t s) {
  for (; bodies != NULL; bodies = bodies->tl) {
    let &$(*nv,_,s2) = bodies->hd;
    if (s2 == s) return nv;
  }
  // if we got this far, then we're dealing with a try/catch's default
  // which is never called.
  return NULL;
}

// translate a switch according to the given decision tree.
static void xlate_switch(env_t nv, stmt_t whole_s,
			 exp_t e, list_t<switch_clause_t> scs,
                         Tcpat::decision_opt_t dopt) {
  let t = (type_t)e->topt;
  exp_to_c(nv,e);

  let $(v,path) = temp_var_and_exp();
  var_t end_l = fresh_label();
  TOC_RGN(nv,rgn) {
    let nv = share_env(rgn,nv);
    // for each clause, generate a test label and an entry label, and flag indicating
    // whether we've already emitted code for the rhs of the clause.
    list_t<$(bool,var_t,var_t,switch_clause_t)@> lscs =
      List::rmap_c(rgn,gen_labels,rgn,scs);
    // compile the decision tree -- generates a list of declarations and
    // a list of case bodies with associated labels and environments, as
    // well as a big test statement.  
    patdecls_t<`rgn> mydecls = NULL;
    list_t<$(env_t<`rgn>,var_t,stmt_t)@`rgn,`rgn> mybodies = NULL;
    stmt_t test_tree = compile_decision_tree(rgn, nv, &mydecls, &mybodies, 
                                             dopt, lscs, v);
    // Note that at this point, test_tree contains all of the rhs's, but they
    // have not yet been translated.  That's because we need the compiler environment
    // for the fallthru case which is only generated after compiling the decision
    // tree.  So, now we step through each rhs and compile it.
    for (let lscs2 = lscs; lscs2 != NULL; lscs2 = lscs2->tl) {
      let &$(_,_,body_lab,body_sc) = lscs2->hd;
      stmt_t s = body_sc->body;
      // find the environment for this rhs.
      env_t<`rgn>* envp = find_case_env(mybodies,s);
      // skip over any case that is never called (i.e., has no envp), as it
      // must be dead code (not reachable in the decision tree).
      if (envp == NULL) continue; 
      let env = *envp;
      // find the environment for the fallthru case if it's there.
      if (lscs2->tl != NULL) {
        let &$(_,_,fallthru_lab,next_sc) = lscs2->tl->hd;
	// FIX: all we use now is whether next_case_env exists, so this
	//      is a kludge
	let next_case_env = find_case_env(mybodies,next_sc->body);
        // if the next case is never called, then it must've been the default
        // case added for a try/catch in which case, we cannot have this case
        // fallthru to it.  So, we can treat this case as if it were the last
        // of the switch clauses.
        if (next_case_env == NULL) {
          stmt_to_c(last_switchclause_env(rgn,env,end_l),s);
        } else {
          // set up the environment with the fallthru information.
          list_t<vardecl_t> vs = NULL;
          if (next_sc->pat_vars != NULL) {
            vs = Tcutil::filter_nulls(List::split(next_sc->pat_vars->v)[0]);
            vs = map_c(assoc,mydecls,List::imp_rev(vs));
          }
          stmt_to_c(non_last_switchclause_env(rgn, env, end_l, fallthru_lab,
                                              vs),s);
        }
      } else
        stmt_to_c(last_switchclause_env(rgn,env,end_l),s);
    }
    // almost done -- need to build the declarations, followed by the
    // test tree, followed by the end label.  We construct it backwards...
    stmt_t res = seq_stmt(test_tree,label_stmt(end_l,skip_stmt_dl(),DL),DL);
    // now add in declarations and alpha-convert
    for (; mydecls != NULL; mydecls = mydecls->tl) {
      let $(_,vd) = *mydecls->hd;
      res = decl_stmt(new_decl(new Var_d(vd), DL), res, DL);
    }
    // overwrite original switch with new code.
    whole_s->r = declare_stmt(v,typ_to_c((type_t)e->topt),e,res,DL)->r;
    return;
  }
}

// forward declarations
static stmt_t letdecl_to_c(env_t nv, pat_t p, Tcpat::decision_opt_t, 
                           type_t t, exp_t e, stmt_t s);
static void local_decl_to_c(env_t nv,vardecl_t vd,stmt_t s);

///////////////////////////////////////////////////////////////
//              Translation of Statements                    //
///////////////////////////////////////////////////////////////
static void fndecl_to_c(env_t nv, fndecl_t f, bool cinclude);

stmt_t make_npop_handler(int n) {
  return exp_stmt(fncall_exp_dl(_npop_handler_e,uint_exp(n-1,DL)),DL);
}
void do_npop_before(int n, stmt_t s) { // mutates s as necessary!
  if(n > 0)
    s->r = seq_stmt_r(make_npop_handler(n),new_stmt(s->r,DL));
}

static void stmt_to_c(env_t nv, stmt_t s) {
  // written to be self-tail recursive
  while (true) {
    switch (s->r) {
    case &Skip_s:         return;
    case &Exp_s(e):       exp_to_c(nv, e); return;
    case &Return_s(NULL): do_npop_before(get_npop(s),s); return;
    case &Return_s(e):
      // pop **after** evaluating expression
      type_t t = typ_to_c((type_t)e->topt);
      exp_to_c(nv,e);
      int npop = get_npop(s);
      if(npop > 0) {
	let x = temp_var();
	let retn_stmt = return_stmt(var_exp(x,DL),DL);
	do_npop_before(npop,retn_stmt);
	s->r = declare_stmt(x, t, e, retn_stmt, DL)->r;
      }
      return;
    case &Seq_s(s1,s2):
      stmt_to_c(nv,s1);
      s = s2;
      continue;
    case &IfThenElse_s(e,s1,s2):
      exp_to_c(nv,e);
      stmt_to_c(nv,s1);
      s = s2;
      continue;
    case &For_s(e1,$(e2,_),$(e3,_),s2):
      exp_to_c(nv,e1); 
      exp_to_c(nv,e2); 
      fallthru(s2,e3);
    case &Do_s(s2,$(e,_)): fallthru(e,s2);
    case &While_s($(e,_),s2):
      exp_to_c(nv,e);
      TOC_RGN(nv,temp) { stmt_to_c(loop_env(temp,nv),s2); }
      return;
    case &Break_s: 
      let &Env{.break_lab=b,...} = nv;
      if (b != NULL)
	s->r = goto_stmt_r(*b);
      // reset handler
      do_npop_before(get_npop(s),s);
      return;
    case &Continue_s:
      let &Env{.continue_lab=c,...} = nv;
      if (c != NULL)
	s->r = goto_stmt_r(*c);
      fallthru;
    case &Goto_s(_): // reset handler (earlier checks prevent jump into handler)
      do_npop_before(get_npop(s), s);
      return;
    case &Label_s(lab,s1): s = s1; continue;
    case &Switch_s(e,scs,dec_tree_opt):
      xlate_switch(nv,s,e,scs,dec_tree_opt);
      return;
    case &Fallthru_s(es,dest_clause):
      let &Env{.fallthru_info = fi,...} = nv;
      if(fi == NULL)
	toc_impos2("fallthru in unexpected place");
      let FallthruInfo{l,vs} = *fi;
      stmt_t s2 = goto_stmt(l, DL);
      // reset handler (after the es evaluation)
      do_npop_before(get_npop(s), s2);
      let vs2 = List::rev(vs);
      let es2 = List::rev(es);
      for(; vs2 != NULL; vs2 = vs2->tl, es2 = es2->tl) {
	exp_to_c(nv,es2->hd);
	s2 = seq_stmt(assign_stmt(varb_exp(new Pat_b(vs2->hd),DL), es2->hd,DL),
		      s2,DL);
      }
      s->r = s2->r;
      return;
    case &Decl_s(d,s1):
      // we have to treat Let_d and Var_d where we bind a comprehension
      // (not at the top-level) specially because these have to return
      // "statements".  See letdecl_to_c and decls_to_c below.
      switch (d->r) {
      case &Var_d(vd): local_decl_to_c(nv, vd, s1); break;
      case &Let_d(p,_,e,dec_tree):
        // Handle the special case where the pattern is a variable just like
	// a variable declaration, except variable's scope does NOT include e
	// DJG: just need to alpha-convert vd -- name resolution should
	//      have already decided scope, so we just have to rename
	//      because C's rules differ from ours.
        switch (p->r) {
        case &Var_p(vd, &Pat{.r = &Wild_p, ...}):
          let new_vd = new_vardecl(DL, temp_var(), vd->type, e);
          vd->initializer = varb_exp(new Local_b(new_vd),DL);
          vd->initializer->topt = new_vd->type;
          s->r = decl_stmt(new_decl(new Var_d(new_vd),s->loc),
                           decl_stmt(new_decl(new Var_d(vd),s->loc),
                                     s1,s->loc),s->loc)->r;
          stmt_to_c(nv, s);
          break;
        default:
	  // we treat let declarations specially because they may need
	  // statements in addition to declarations, so we splice them in
	  // as a statement.  Other declarations only produce declarations.
	  s->r = letdecl_to_c(nv, p, dec_tree, (type_t)e->topt, e, s1)->r;
	  break;
        }
	break;
      case &Letv_d(vds):
        // Transform Letv_d into a sequence of Var_d, and call stmt_to_c on
        // the result.
        let rvds = List::rev(vds);
        if (rvds == NULL)
          Warn::impos2("empty Letv_d");
        d->r = new Var_d(rvds->hd);
        rvds = rvds->tl;
        for (; rvds != NULL; rvds = rvds->tl) {
          let d2 = new_decl(new Var_d(rvds->hd),DL);
          s->r = decl_stmt(d2,new_stmt(s->r,DL),DL)->r;
        }
        stmt_to_c(nv,s);
        break;
      case &Fn_d(fd):
	fndecl_to_c(nv, fd, false);
	stmt_to_c(nv,s1);
        break;
      case &Region_d(tv, vd, open_exp_opt):
        let body = s1;
        // NOTE:  _npop_handler has to deal with regions as well as exceptions
        type_t rh_struct_typ     = strct(_RegionHandle_sp);
        type_t rh_struct_ptr_typ = cstar_type(rh_struct_typ,mt_tq);
	let $(rh_var,rh_exp) = temp_var_and_exp();
        qvar_t x_var  = vd->name;
        exp_t  x_exp  = var_exp(x_var, DL);

	stmt_to_c(nv,body);
        if (Flags::no_regions) {
          s->r = declare_stmt(x_var, rh_struct_ptr_typ,
                              uint_exp(0,DL), body, DL)->r;
        } else if (open_exp_opt) { 
	  // { struct _RegionHandle *x = open_exp_opt -> h; body }
          exp_to_c(nv,open_exp_opt);
          exp_t arg = address_exp(aggrarrow_exp(open_exp_opt,new "h",DL),DL);
          s->r = declare_stmt(x_var,rh_struct_ptr_typ,arg,body,DL)->r;
        } else {
	  // struct _RegionHandle rh = _new_region();
	  // struct _RegionHandle *x = &rh;
	  // _push_region(x);
	  // body;
	  // _pop_region(x);
          s->r = declare_stmt(rh_var,rh_struct_typ,
		   fncall_exp_dl(_new_region_e, string_exp(*(*x_var)[1],DL)),
                 declare_stmt(x_var, rh_struct_ptr_typ,address_exp(rh_exp,DL),
		 seq_stmt(exp_stmt(fncall_exp_dl(_push_region_e, x_exp),DL),
                 seq_stmt(body, 
			  exp_stmt(fncall_exp_dl(_pop_region_e),
				   DL),DL),DL),DL),DL)->r;
        } 
        return;
      default: Warn::impos2("bad nested declaration within function");
      }
      return;
    case &TryCatch_s(body,scs,dec_tree):
      // struct handler_cons h;
      // _push_handler(&h);
      // int was_thrown = 0;
      // if (setjmp(h.handler)) was_thrown = 1;
      // if (!was_thrown) {
      //   body
      //   _pop_handler();
      // } else {
      //   exn e = (exn)_exn_thrown;
      //   switch (e) scs
      // }
      // [Auxillary functions are defined in runtime_cyc.c]
      let $(h_var,h_exp) = temp_var_and_exp();
      let $(e_var,e_exp) = temp_var_and_exp();
      let $(was_thrown_var,was_thrown_exp) = temp_var_and_exp();      
      type_t h_typ = strct(_handler_cons_sp);
      type_t e_typ = typ_to_c(exn_type());
      type_t was_thrown_typ = typ_to_c(sint_type);
      // e_exp needs a typ because it'll go through exp_to_c;
      e_exp->topt = e_typ;
      TOC_RGN(nv, temp) {
        // translate the body
        stmt_to_c(nv,body);
        let tryandpop_stmt = seq_stmt(body,
				      exp_stmt(fncall_exp_dl(_pop_handler_e),
					       DL),DL);
        let handler_stmt = new_stmt(new Switch_s(e_exp,scs,dec_tree), DL);
        // translate the switches
        stmt_to_c(nv,handler_stmt);

        // wrap with the conditional, declarations, and setjmp
        let setjmp_call = // setjmp(h.handler)
          fncall_exp_dl(setjmp_e, member_exp(h_exp,handler_sp,DL));
        let pushhandler_call = // _pushhandler(h);
          exp_stmt(fncall_exp_dl(_push_handler_e,address_exp(h_exp,DL)),DL);
        let zero_exp = int_exp(Signed,0,DL);
        let one_exp  = int_exp(Signed,1,DL);
        s->r =
          declare_stmt(h_var, h_typ, NULL,
          seq_stmt(pushhandler_call,
          declare_stmt(was_thrown_var,was_thrown_typ,zero_exp,
          seq_stmt(ifthenelse_stmt(setjmp_call,
                                   assign_stmt(was_thrown_exp,one_exp,DL),
                                   skip_stmt_dl(),DL),
          ifthenelse_stmt(prim1_exp(Not, was_thrown_exp,DL),
                          tryandpop_stmt,
                          declare_stmt(e_var,e_typ,
                                       cast_it(e_typ,get_exn_thrown_expression()), //<--- change _exn_thrown_e to be a call to TLS _exn_thrown
				       handler_stmt,DL),DL),DL),DL),DL),DL)->r;
      }
      return;
    }
  }
}

///////////////////////////////////////////////////////////////
//              Translation of Declarations                  //
///////////////////////////////////////////////////////////////
// function declaration translation -- straightforward
static void stmttypes_to_c(stmt_t s);
static void fndecl_to_c(env_t nv, fndecl_t f, bool cinclude) {
  f->i.tvars  = NULL;
  f->i.effect = NULL;
  f->i.rgn_po = NULL;
  f->i.requires_clause = NULL;
  f->i.ensures_clause  = NULL;
  f->i.ret_type  = typ_to_c(f->i.ret_type);
  f->cached_type = typ_to_c((type_t)f->cached_type);
  region frgn;
  let nv = share_env(frgn,nv);
  for (let args=f->i.args; args != NULL; args = args->tl) {
    let x = new $((nmspace_t)Loc_n,(*args->hd)[0]);
    (*args->hd)[2] = typ_to_c((*args->hd)[2]);
  }
  // for C code, we need to go through and convert all of the types
  // from Cyclone types to C, but otherwise leave the code alone.
  if (cinclude) {
    stmttypes_to_c(f->body);
    return;
  }
  fn_pop_table = new Hashtable::lookup(*gpop_tables,f);
  if (f->i.cyc_varargs && f->i.cyc_varargs->name != NULL) {
    let VarargInfo{n,tq,t,i} = *f->i.cyc_varargs;
    let t2 = typ_to_c(fatptr_type(t,heap_rgn_type,tq,false_type));// region irrelevant
    let x2 = new $((nmspace_t)Loc_n,(var_t)n);
    f->i.args = append(f->i.args,new List(new $((var_t)n,tq,t2),NULL));
    f->i.cyc_varargs = NULL;
  }
  // Tovc would like to use param_vardecls:
  for(let arg_vds = f->param_vardecls->v; arg_vds!=NULL; arg_vds=arg_vds->tl)
    arg_vds->hd->type = typ_to_c(arg_vds->hd->type);
  stmt_to_c(clear_toplevel(frgn,nv),f->body);
}

static scope_t scope_to_c(scope_t s) {
  switch (s) {
  case Abstract: return Public; // there's no abstract scope in C
  case ExternC : return Extern;
  default:       return s;
  }
}

// struct & union declarations -- straightforward except when we have
// a tagged union.  When we have:
//   @tagged union Foo { T1 m1; ... Tn mn; };
// this is translated to:
//   struct _union_Foo_m1 { int tag; T1 val; };
//   ...
//   struct _union_Foo_mn { int tag; Tn val; };
//   union Foo { struct _union_Foo_m1 m1; ... struct _union_Foo_mn mn; };
static int aggrdecl_to_c_body<`r2,`d,`r>(region_t<`d> d, 
                              $(struct TocState<`d>@`d,aggrdecl_t@`r2)@`r env) {
  let $(s, &ad) = *env;
  let n = ad->name;
  let TocState{.aggrs_so_far = aggrs_so_far, ...} = *s;
  bool seen_defn_before;
  let dopt = Dict::lookup_opt(*aggrs_so_far, n);
  if (dopt == NULL) {
    seen_defn_before = false;
    $(aggrdecl_t,type_t)@ v;
    if (ad->kind == StructA)
      v = rnew(d) $(ad,strctq(n));
    else
      v = rnew(d) $(ad,unionq_type(n));
    *aggrs_so_far = Dict::insert(*aggrs_so_far,n,v);
  } else {
    let &$(ad2,t) = *dopt;
    if (ad2->impl == NULL) {
      *aggrs_so_far = Dict::insert(*aggrs_so_far,n,rnew(d) $(ad,t));
      seen_defn_before = false;
    } else
      seen_defn_before = true;
  }
  aggrdecl_t new_ad = new Aggrdecl {.kind = ad->kind,
                                    .sc = Public,
                                    .name = ad->name,
                                    .tvs = NULL,
                                    .impl = NULL,
                                    .expected_mem_kind = false,
                                    .attributes = ad->attributes};
  if(ad->impl != NULL && !seen_defn_before) {
    new_ad->impl = new AggrdeclImpl { .exist_vars = NULL,
                                      .rgn_po = NULL,
                                      .fields = NULL,
                                      .tagged = false };
    list_t<aggrfield_t> new_fields = NULL;
    for (let fields = ad->impl->fields; fields != NULL; fields = fields->tl){
      // JGM: I'm trying to get rid of warnings when we assign "const"
      // locations...
      let old_field = fields->hd;
      let old_type = old_field->type;
      let old_atts = old_field->attributes;
      if (kind_leq(&ak,type_kind(old_type)) && 
          ((ad->kind == StructA && fields->tl == NULL) ||
           ad->kind == UnionA)) {
        // HACK ALERT:
        // If the last member is abstract we have to do more work:
        //  * if it's an array, we make it an array of size 0
        //  * otherwise as a HACK, we make it an array of void*'s of size 0,
        //    but add the __attribute__((aligned)) to force the thing
        //    to live on a suitable boundary.  This means that any
        //    instantiation has to also be aligned, but it gives us a
        //    way to portably get at the field.
        switch (compress(old_type)) {
        case &ArrayType(ArrayInfo{et,tq,_,zt,ztl}):
          // Note: type checker forces et to be non-abstract
          old_type = new ArrayType(ArrayInfo(et,tq,uint_exp(0,DL),zt,ztl));
          break;
        default: 
          old_atts = new List(new Aligned_att(NULL),old_atts);
          old_type = new ArrayType(ArrayInfo(void_star_type(),
                                             empty_tqual(DL),
                                             uint_exp(0,DL),
                                             false_type,DL));
        }
      }
      let new_field = new Aggrfield{.name = old_field->name,
                                    .tq = mt_tq,
                                    .type = typ_to_c(old_type),
                                    .width = old_field->width,
                                    .attributes = old_atts,
                                    .requires_clause = NULL};

      // If this is a tagged union, rewrite the member type from T
      // to struct _union_Foo_f {int tag; T val;} where Foo is the name
      // of the union, and f is the name of the member.
      if (ad->impl->tagged) {
        let T = new_field->type;
        let f = new_field->name;
        string_t s = aprintf("_union_%s_%s",*((*ad->name)[1]),*f);
        var_t str = new s;
        let value_field = new Aggrfield(val_sp,mt_tq,T,        NULL,NULL,NULL);
        let tag_field   = new Aggrfield(tag_sp,mt_tq,sint_type,NULL,NULL,NULL);
	let ad2 = make_c_struct_defn(str,list(tag_field,value_field));
        result_decls = new List(new_decl(new Aggr_d(ad2),DL),result_decls);
        new_field->type = strct(str);
      }
      new_fields = new List(new_field,new_fields);
    }
    new_ad->impl->fields = List::imp_rev(new_fields);
  }
  // DJG: !seen_defn_before a hack because of TypedefType
  if (!seen_defn_before)
    result_decls = new List(new Decl(new Aggr_d(new_ad),DL),result_decls);
  return 0;
}
static void aggrdecl_to_c(aggrdecl_t ad) {
  use_toc_state(&ad, (aggrdecl_to_c_body@<`aggrdecl_to_c>)<>);
}

// datatype declarations -- tricky
// For "datatype foo {Bar,Blah,Baz(t1,t2,t3),Baf(t4,t5)}" we generate
//   typedef void *foo;
//   struct Baz_foo_struct {
//     int tag;  // always == 0
//     t1 f1;
//     t2 f2;
//     t3 f3;
//   };
//   struct Baf_foo_struct {
//     int tag;  // always == 1
//     t4 f1;
//     t5 f2;
//   };
// for xdatatype, we pull a really slimy trick: By using char arrays instead
// of ints, the uses get promoted to addresses just like we want.
// When the datatype is "extern" then we don't generate initializers
// for the tags (that should be done elsewhere.)
//
// NB: we allow any number of repeated declarations but we can only
//     declare and initialize global variables once.  So we keep track
//     of what we've seen so far.  And we make the globals static so that
//     extern and what not is only a link-checker thing.  Unfortunately,
//     the static trick doesn't work for xdatatype, which uses the addresses.
static int datatypedecl_to_c_body<`d,`r>(region_t<`d> d, 
                                         $(struct TocState<`d>@`d, 
                                           datatypedecl_t tud)@`r env) {
  let $(&TocState{.datatypes_so_far = datatypes_so_far, ...},tud) = *env;
  let n = tud->name;
  if(tud->fields == NULL || Set::member(*datatypes_so_far, n))
    return 0;
  *datatypes_so_far = Set::rinsert(d,*datatypes_so_far, n);
  for (let fields = tud->fields->v; fields != NULL; fields = fields->tl) {
    datatypefield_t f = fields->hd;
    // compute the fields for the struct, adding in a tag field
    let fs = NULL;
    int i  = 1;
    for (let ts = f->typs; ts != NULL; ts = ts->tl, i++) {
      let fname = fieldname(i);
      let f = new Aggrfield(fname,(*ts->hd)[0],
                            typ_to_c((*ts->hd)[1]),NULL,NULL,NULL);
      fs = new List(f,fs);
    }
    fs = new List(new Aggrfield(tag_sp,mt_tq,sint_type,NULL,NULL,NULL),
                  List::imp_rev(fs));
    let ad = make_c_struct_defn(new "", fs);
    ad->name = collapse_qvars(f->name,tud->name);
    result_decls = new List(new_decl(new Aggr_d(ad),DL),result_decls);
  }
  return 0;
}

static void datatypedecl_to_c(datatypedecl_t tud) {
  use_toc_state(tud, datatypedecl_to_c_body<>);
}
// @extensible datatype declarations -- similar to datatype declarations
// For a declaration extending an existing xdatatype, e.g.,
//   "@extensible datatype foo {Bar,Baz(t1,t2)}"
// we generate
//   char Bar[] = "Bar";
//   struct Bar_foo_struct { char *tag; };
//   char Baz[] = "Baz";
//   struct Baz_foo_struct { char *tag; t1 f1; t2 f2; };
// When the xdatatype is extern, then we don't do initializers for the tags.
//
// Thus "Baz(e1,e2)" maps to
// ({struct _Baz_struct *t =
//     (struct _Baz_struct*)malloc(sizeof(struct _Baz_struct));
//   *t = (struct _Baz_struct){.tag=Baz, .f1 = e1, .f2 = e2};
//   t;})
//true if already seen & initialized, false if seen but non initialized (extern)
static int xdatatypedecl_to_c_body<`d,`r>(region_t<`d> d,
                                          $(struct TocState<`d>@`d,
                                            datatypedecl_t xd)@`r env) {
  let $(s,xd) = *env;
  if(xd->fields == NULL)
    return 0;
  let TocState{.xdatatypes_so_far = xdatatypes_so_far, ...} = *s;
  let n = xd->name;
  for (let fs = xd->fields->v; fs != NULL; fs = fs->tl) {
    datatypefield_t f  = fs->hd;
    stringptr_t fn = (*f->name)[1];
    let sz_exp  = uint_exp(numelts(*fn),DL);
    let tag_typ = array_type(char_type,mt_tq,sz_exp,false_type,DL);
    // FIX: making bad alignment and pointer-size assumptions!
    switch (Dict::lookup_opt(*xdatatypes_so_far,f->name)) {
    case NULL:
      exp_opt_t initopt = NULL;
      if (f->sc != Extern) {
        initopt = string_exp(*fn,DL);
      }
      let tag_decl = new_vardecl(0,f->name, tag_typ, initopt);
      tag_decl->sc = f->sc;
      result_decls = new List(new_decl(new Var_d(tag_decl),DL),result_decls);
      *xdatatypes_so_far =
        Dict::insert(*xdatatypes_so_far, f->name, f->sc != Extern);
      list_t<aggrfield_t> fields = NULL;
      int i = 1;
      for (let tqts = f->typs; tqts != NULL; tqts = tqts->tl,i++) {
        let field_n = new ((string_t)aprintf("f%d",i));
        let newf = new Aggrfield(field_n,(*tqts->hd)[0],
                                 typ_to_c((*tqts->hd)[1]),NULL,NULL,NULL);
        fields = new List(newf,fields);
      }
      fields = new List(new Aggrfield(tag_sp,mt_tq,
                                      cstar_type(char_type,mt_tq),NULL,NULL,NULL),
                        List::imp_rev(fields));
      let strct_decl = make_c_struct_defn(new "",fields);
      strct_decl->name = collapse_qvars(f->name,xd->name);
      result_decls = new List(new_decl(new Aggr_d(strct_decl),DL),result_decls);
      break;
    case &false:
      if (f->sc != Extern) {
        let initopt = string_exp(*fn,DL);
        let tag_decl = new_vardecl(0,f->name, tag_typ, initopt);
        tag_decl->sc = f->sc;
        result_decls = new List(new_decl(new Var_d(tag_decl),DL),result_decls);
        *xdatatypes_so_far = Dict::insert(*xdatatypes_so_far, f->name, true);
      }
      break;
    default: break;
    }
  }
  return 0;
}

static void xdatatypedecl_to_c(datatypedecl_t xd) {
  use_toc_state(xd, xdatatypedecl_to_c_body<>);
}

static void enumdecl_to_c(enumdecl_t ed) {
  ed->sc = Public; // gcc warns if we have Extern or Static on an enum
  if(ed->fields != NULL)
    enumfields_to_c(ed->fields->v);
}

static void local_decl_to_c(env_t nv,vardecl_t vd,stmt_t s) {
  type_t old_typ = vd->type;
  vd->type = typ_to_c(old_typ);
  // Fat pointers can't be declared with "register" scope
  if (vd->sc == Register && is_fat_pointer_type(old_typ))
    vd->sc = Public;
  stmt_to_c(nv,s);
  if(vd->initializer != NULL) {
    exp_t init = (exp_t)vd->initializer;
    if (vd->sc == Static) {
      // static declarations have to be treated as if they're toplevel
      // w.r.t. the translation.  NB: Any other generated declarations
      // will also be left at top-level??
      TOC_RGN(nv, temp) {
	let nv2 = set_toplevel(temp,nv);
	exp_to_c(nv2, init);
      }
    } else
      exp_to_c(nv, init);
  } else {
    // must put in zero for zero-terminated arrays
    switch (compress(old_typ)) {
    case &ArrayType(ArrayInfo{et,_,num_elts_opt,zt,_}):
      if (force_type2bool(false,zt)) {
        if (num_elts_opt == NULL)
          toc_impos2("can't initialize zero-terminated array -- size unknown");
        exp_t num_elts = (exp_t)num_elts_opt;
        let lhs = subscript_exp(var_exp(vd->name,DL),
                                add_exp(num_elts,signed_int_exp(-1,DL),DL),
                                DL);
        let rhs = signed_int_exp(0,DL);
        s->r = seq_stmt_r(exp_stmt(assign_exp(lhs,rhs,DL),DL),
                          new_stmt(s->r,DL));
      }
      break;
    default: break;
    }
  }
}

// Destructively rewrite the decision tree so that Failure nodes are 
// replaced with Success(fail) and Success(_) is replaced with Success(s)
static Tcpat::decision_t rewrite_decision(Tcpat::decision_t d,stmt_t success) {
  switch (d) {
  case &Tcpat::Failure(_):   return d;
  case &Tcpat::Success(rhs): rhs->rhs = success; return d;
  case &Tcpat::SwitchDec(path, sws, *d2):
    *d2 = rewrite_decision(*d2, success);
    for (; sws != NULL; sws = sws->tl) {
      let &$(_,*d2) = sws->hd;
      *d2 = rewrite_decision(*d2, success);
    }
    return d;
  }
}

// let declarations -- tricky
// Unlike other declarations, lets need to execute statements and
// so return a statement.  (See stmt_to_c, case for Decl above.)
// We treat this similar to the compilation of a switch (see xlate_switch
// above) with one case, but where the failure throws Match_Exception.
// Lots of hacks to get this to work right and re-use the pattern
// match compiler.
static stmt_t letdecl_to_c(env_t nv, pat_t p, Tcpat::decision_opt_t dopt, 
                           type_t t, exp_t e, stmt_t s) {
  TOC_RGN(nv,rgn) {
    let nv = share_env(rgn,nv);
    let t = (type_t)e->topt;
    exp_to_c(nv,e);
    qvar_t v     = temp_var();
    exp_t  path  = var_exp(v,DL);
    var_t  end_l = fresh_label();
    // we us a bogus fail statement since it has to pass through translation.
    // we overwrite it with _throw_match() below.  For a success, we goto
    // th end label.
    let succ_stmt = s;
    if (dopt != NULL)
      // rewrite the decision tree so that on failure we throw Match
      // and on success, continue with the body of the let.
      dopt = rewrite_decision(dopt, succ_stmt);

    let c1 = new Switch_clause{p, NULL, NULL, succ_stmt, 0};
    let lscs = List::rmap_c(rgn,gen_labels,rgn,rlist(rgn,c1));
    // declarations and environments generated while compiling decision tree
    patdecls_t<`rgn> mydecls = NULL;
    list_t<$(env_t<`rgn>,var_t,stmt_t)@`rgn,`rgn> mybodies = NULL;
    // compile the pattern -- this essentially generates
    // if e matches p then <skip> else _throw_match()
    stmt_t test_tree = compile_decision_tree(rgn, nv, &mydecls, &mybodies, 
                                             dopt, lscs, v);
    // get out the env to translate s
    env_t<`rgn> senv;
    for (; mybodies != NULL; mybodies = mybodies->tl) {
      let &$(env,_,st) = mybodies->hd;
      if (st == succ_stmt) { senv = env; goto FOUND_ENV; }
    }
    toc_impos2("letdecl_to_c: couldn't find env!");
  FOUND_ENV:
    // translate the body of the let under the env we get out of match
    // compilation.
    stmt_to_c(senv,s);
    // put the tests in front
    stmt_t res = test_tree;
    // now add in declarations of temps generated for pattern matching
    for (; mydecls != NULL; mydecls = mydecls->tl) {
      let $(_,vd) = *mydecls->hd;
      res = decl_stmt(new_decl(new Var_d(vd), DL), res, DL);
    }
    // finally declare the root variable v and initialize it with e
    res = declare_stmt(v,typ_to_c(t),e,res,DL);
    return res;
  }
}


// These next few functions clean up the types in C code, getting
// rid of stuff inserted by the parser (e.g., region evars).

static void exptypes_to_c(exp_t e) {
  switch (e->r) {
  case &Extension_e(e):      fallthru(e);
  case &Deref_e(e):          fallthru(e);
  case &AggrMember_e(e,...): fallthru(e);
  case &AggrArrow_e(e,...):  fallthru(e);
  case &Address_e(e):        fallthru(e);
  case &Throw_e(e,_):        fallthru(e);
  case &NoInstantiate_e(e):  fallthru(e);
  case &Sizeofexp_e(e):      fallthru(e);
  case &Increment_e(e1,_):   exptypes_to_c(e1); break;
  case &Primop_e(_,es):      List::iter(exptypes_to_c,es); break;
  case &And_e(e1,e2):        fallthru(e1,e2);
  case &Or_e(e1,e2):         fallthru(e1,e2);
  case &SeqExp_e(e1,e2):     fallthru(e1,e2);
  case &Subscript_e(e1,e2):  fallthru(e1,e2);
  case &Swap_e(e1,e2):       fallthru(e1,e2);
  case &AssignOp_e(e1,_,e2): exptypes_to_c(e1); exptypes_to_c(e2); break;
  case &Conditional_e(e1,e2,e3):
    exptypes_to_c(e1); exptypes_to_c(e2); exptypes_to_c(e3); break;
  case &FnCall_e(e,es,...):    
    exptypes_to_c(e); List::iter(exptypes_to_c,es); break;
  case &Cast_e(*t,e,_,_): *t = typ_to_c(*t); exptypes_to_c(e); break;
  case &CompoundLit_e(&$(_,_,*t),dles):
    *t = typ_to_c(*t);
    fallthru(dles);
  case &UnresolvedMem_e(_,dles): fallthru(dles);
  case &Array_e(dles):
    for (; dles != NULL; dles = dles->tl)
      exptypes_to_c((*dles->hd)[1]);
    break;
  case &Offsetof_e(*t,_): fallthru(t);
  case &Sizeoftype_e(*t): *t = typ_to_c(*t); break;
  case &StmtExp_e(s):     stmttypes_to_c(s); break;
  case &Malloc_e(*m):
    if (m->elt_type != NULL)
      m->elt_type = new (typ_to_c(*m->elt_type));
    exptypes_to_c(m->num_elts);
    break;
  case &Asm_e(_,_,o,i,_):     
    asm_iolist_types_toc(o);
    asm_iolist_types_toc(i);
    break;
  case &Const_e(_):     
  case &Var_e(_):       
  case &Enum_e(...):  
  case &AnonEnum_e(...): break;

  case &Assert_e(...):
  case &Pragma_e(...): 
  case &AnonStruct_e(...): 
  case &Datatype_e(...):  
  case &Aggregate_e(...):
  case &Comprehension_e(...):
  case &ComprehensionNoinit_e(...):
  case &Tuple_e(...):         
  case &Instantiate_e(...): 
  case &New_e(...):         
  case &Valueof_e(...):       
  case &Tagcheck_e(...): Warn::impos_loc(e->loc,"Cyclone expression in C code");
  }
}

static void decltypes_to_c(decl_t d) {
  switch (d->r) {
  case &Var_d(vd):
    vd->type = typ_to_c(vd->type);
    if (vd->initializer != NULL) exptypes_to_c((exp_t)vd->initializer);
    break;
  case &Fn_d(fd):
    fd->i.ret_type = typ_to_c(fd->i.ret_type);
    for (let args=fd->i.args; args != NULL; args = args->tl)
      (*args->hd)[2] = typ_to_c((*args->hd)[2]);
    break;
  case &Aggr_d(ad): aggrdecl_to_c(ad); break;
  case &Enum_d(ed):
    if (ed->fields != NULL)
      for (let fs = ed->fields->v; fs != NULL; fs = fs->tl) {
        let f = fs->hd;
        if (f->tag != NULL) exptypes_to_c((exp_t)f->tag);
      }
    break;
  case &Typedef_d(td): td->defn = typ_to_c((type_t)td->defn); break;
  case &Let_d(...):
  case &Letv_d(_):
  case &Datatype_d(_):
  case &Namespace_d(_,_):
  case &Using_d(_,_):
  case &ExternC_d(...):
  case &ExternCinclude_d(...):
  case &Region_d(...): // DJG: impossible because of parser?
    Warn::impos_loc(d->loc,"Cyclone declaration in C code");
  case &Porton_d:
  case &Portoff_d: 
  case &Tempeston_d:
  case &Tempestoff_d: break;
  }
}

static void stmttypes_to_c(stmt_t s) {
  switch (s->r) {
  case &Exp_s(e):       exptypes_to_c(e); break;
  case &Seq_s(s1,s2):   stmttypes_to_c(s1); stmttypes_to_c(s2); break;
  case &Return_s(eopt): if (eopt != NULL) exptypes_to_c(eopt); break;
  case &IfThenElse_s(e,s1,s2):
    exptypes_to_c(e); stmttypes_to_c(s1); stmttypes_to_c(s2); break;
  case &While_s($(e,_),s):
    exptypes_to_c(e); stmttypes_to_c(s); break;
  case &For_s(e1,$(e2,_),$(e3,_),s):
    exptypes_to_c(e1); exptypes_to_c(e2); exptypes_to_c(e3);
    stmttypes_to_c(s); break;
  case &Switch_s(e,scs,dec_tree):
    exptypes_to_c(e);
    for (; scs != NULL; scs=scs->tl) stmttypes_to_c(scs->hd->body);
    break;
  case &Decl_s(d,s):    decltypes_to_c(d); stmttypes_to_c(s); break;
  case &Do_s(s,$(e,_)): stmttypes_to_c(s); exptypes_to_c(e);  break;
  case &Label_s(_,s):   stmttypes_to_c(s); break;
  case &Skip_s:
  case &Break_s:
  case &Continue_s:
  case &Goto_s(...): break;
  case &Fallthru_s(...): 
    // in C code, this is implicit, so we replace it with a skip
    s->r = new Skip_s; break;
  case &TryCatch_s(...): Warn::impos_loc(s->loc,"Cyclone statement in C code");
  }
}

// Translate the given declarations, producing a new list of declarations
// and a new translation environment.  Top-level variable
// declarations are treated differently.
static env_t<`r> decls_to_c(region_t<`r> r, env_t<`r> nv, list_t<decl_t> ds, 
			    bool cinclude) {
  for (; ds != NULL; ds = ds->tl) {
    if (!is_toplevel(nv))
      Warn::impos2("decls_to_c: not at toplevel!");
    fresh_label_counter = 0; // DJG: why not?
    decl_t d = ds->hd;
    switch (d->r) {
    case &Var_d(vd):
      let c_name = vd->name;
      // strip any namespace from an extern C declaration
      if (vd->sc == ExternC)
	c_name = new $(Abs_n(NULL,true),(*c_name)[1]);
      if (vd->initializer != NULL) {
        if (vd->sc == ExternC) vd->sc = Public;
        if (cinclude)
          exptypes_to_c((exp_t)vd->initializer);
        else
          exp_to_c(nv, (exp_t)vd->initializer);
      }
      vd->name = c_name;
      vd->sc   = scope_to_c(vd->sc);
      vd->type = typ_to_c(vd->type);
      result_decls = new List(d,result_decls);
      break;
    case &Fn_d(fd):
      // strip any namespace from an extern C declaration
      if (fd->sc == ExternC) { //but subsequent phases should ignore the body
	fd->name = new $(Abs_n(NULL,true),(*fd->name)[1]);
        fd->sc = Public; // function declarations can't be extern
      }
      fndecl_to_c(nv, fd, cinclude);
      result_decls = new List(d,result_decls);
      break;
    case &Let_d(...):
    case &Letv_d(_):     toc_impos2("letdecl at toplevel");
    case &Region_d(...): toc_impos2("region decl at toplevel");
    case &Aggr_d(sd): aggrdecl_to_c(sd); break;
    case &Datatype_d(tud): 
      tud->is_extensible ? xdatatypedecl_to_c(tud) : datatypedecl_to_c(tud);
      break;
    case &Enum_d(ed):
      enumdecl_to_c(ed);
      result_decls = new List(d,result_decls);
      break;
    case &Typedef_d(td):
      td->tvs  = NULL;
      if (td->defn != NULL) {
	td->defn = typ_to_c((type_t)td->defn);
        // JGM: when we're expanding typedef's, we need to add back as
        // a declaration any enum's since they are dropped otherwise.
	let ed;
	switch(td->defn) {
	case &TypeDeclType(&{.r = &Enum_td(ed2),.loc = loc},_): 
	  ed = new Decl{.r = new Enum_d(ed2), .loc = loc}; break;
	default: ed = NULL;
	}
        if (ed != NULL) {
          result_decls = new List(ed, result_decls);
	  switch(ed->r) {
	  case &Enum_d(ed): 
	    td->defn = new AppType(new EnumCon(ed->name,ed),NULL); break;
	  default: Warn::impos2("Toc: enumdecl to name");
	  }
	}
      } else {
	switch (td->kind->v->kind) {
	case BoxKind: td->defn = void_star_type(); break;
	default:      td->defn = void_type;        break;
	}
      }
      // for non-anonymous-aggregates, this is wasteful b/c the printer
      // will skip any use of the typedef
      // DJG: anonymous aggregates are now hoisted
      if(Flags::noexpand_r)
	result_decls = new List(d,result_decls);
      break;
    case &Porton_d:
    case &Portoff_d: 
    case &Tempeston_d:
    case &Tempestoff_d:       break;
    case &Namespace_d(_,ds2): fallthru(ds2);
    case &Using_d(_,ds2):     fallthru(ds2);
    case &ExternC_d(ds2):            nv = decls_to_c(r,nv,ds2,cinclude); break;
    case &ExternCinclude_d(ds2,...): nv = decls_to_c(r,nv,ds2,true);     break;
    }
  }
  return nv;
}

// initialize all globals
//static 
void init() {
  let NewDynamicRegion{dyn} = new_rckey();
  let ts;
  {region h = open(dyn);
  ts = empty_toc_state(h);}
  toc_state = unew TocStateWrap{dyn, ts};
  result_decls = NULL;
  tuple_type_counter = 0;
  temp_var_counter = 0;
  fresh_label_counter = 0;
  globals = new {
    &_throw_str,
    &setjmp_str,
    &_push_handler_str,
    &_pop_handler_str,
    &_exn_thrown_str,
    &_npop_handler_str,
    &_check_null_str,
    &_check_known_subscript_null_str,
    &_check_known_subscript_notnull_str,
    &_check_fat_subscript_str,
    &_tag_fat_str,
    &_untag_fat_ptr_str,
    &_get_fat_size_str,
    &_get_zero_arr_size_str, // FIX: whole function set
    &_fat_ptr_plus_str,
    &_zero_arr_plus_str,     
    &_fat_ptr_inplace_plus_str,
    &_zero_arr_inplace_plus_str, // FIX: whole function set
    &_fat_ptr_inplace_plus_post_str,
    &_zero_arr_inplace_plus_post_str, // FIX: whole function set
    &_cycalloc_str,
    &_cyccalloc_str,
    &_cycalloc_atomic_str,
    &_cyccalloc_atomic_str,
    &_region_malloc_str,
    &_region_calloc_str,
    &_check_times_str,
    &_new_region_str,
    &_push_region_str,
    &_pop_region_str,
    &_throw_arraybounds_str,
    &_fat_ptr_decrease_size_str,
    &_throw_match_str,
    &_fast_region_malloc_str,
  };
}

void finish() { 
  toc_state_t ts = NULL;
  ts :=: toc_state;
  let TocStateWrap{dyn, s} = *ts;
  // reclaim space used by extensible array for the labels
  {region h = open(dyn);
  let TocState{.temp_labels = tls, ...} = *s;
  Xarray::reuse(tls);}

  Core::free_rckey(dyn);
  Core::ufree(ts);

  gpop_tables  = NULL;
  fn_pop_table = NULL;
}

// The entry point:  translate the list of Cyclone declarations to
// a list of C declarations.
list_t<decl_t> toc(table_t<fndecl_t,table_t<stmt_t,int>> pop_tables,
		   list_t<decl_t> ds) {
  gpop_tables = new pop_tables;
  init();
  region start;
  decls_to_c(start,empty_env(start),ds,false);
  return imp_rev(result_decls);
}
