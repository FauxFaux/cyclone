/* Translate Cyclone abstract syntax to C abstract syntax.
   Copyright (C) 2001 Greg Morrisett, AT&T
   This file is part of the Cyclone compiler.

   The Cyclone compiler is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   The Cyclone compiler is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with the Cyclone compiler; see the file COPYING. If not,
   write to the Free Software Foundation, Inc., 59 Temple Place -
   Suite 330, Boston, MA 02111-1307, USA. */

// Translation of Cyclone abstract syntax to C abstract syntax.
// Assumes that the type-checker has been successfully run on the
// Cyclone AST.  Uses lots of GCC-specific features (that should be in
// C-9X) to simplify the translation -- in particular, we use struct
// expressions "(struct foo){.f1=e1,.f2=e2,...,.fn=en}" and statement
// expressions "({int temp = e; temp++})".  The latter is used for
// declaring temps needed in the translation of expressions.

// The translation is mostly done in place in an imperative style
// (i.e., we overwrite AST nodes) so it's fairly crucial that we don't
// have sharing in the AST.  The one exception is that the type
// translation is functional.

// Look for "unimp" or comments that start with FIX: for missing
// or broken pieces.

// FIX: we could probably use "const" in lots of places where we're not.

// Note: unresolvedmem_exp should only be used (1) to build arrays; or
// (2) to build other things (structs etc.) at top level only; Tovc relies on this.


#include <core.h>
#include <stdio.h>
#include <list.h>
#include <string.h>
#include <set.h>
#include <dict.h>
#include <position.h>
#include <xarray.h>
#include "absyn.h"
#include "absynpp.h"
#include "tcutil.h"
#include "evexp.h"
#include "cf_flowinfo.h"
#include "toc.h"
using Core;
using List;
using Set;
using Position;
using Absyn;
using Absynpp;
using Tcutil;

// in Cyclone.cyc:  controls whether or not we expand typedefs
extern bool noexpand_r;

namespace Toc;

// used for creation of all abstract syntax node locations created here
#define DL NULL

//#define BCE_DEBUG
bool warn_bounds_checks = false;
bool warn_all_null_deref = false;
unsigned total_bounds_checks = 0;
unsigned bounds_checks_eliminated = 0;

// we aren't re-entrant -- we build this list of output decls (in
// reverse order)  It's global b/c tuple types, tagged pointer types, and
// strange top-level initializers need to "splice in" toplevel decls and
// it's a pain to pass this list around everywhere
static list_t<decl_t> result_decls = NULL;
// for gensymming, etc.
struct TocState {
  <`d::R>
  dynregion_t<`d> dyn;
  // tuple types seen so far and the struct they map to
  list_t<$(type_t,list_t<type_t,`d>)@`d,`d> @`d tuple_types;
  // aggregates seen so far, their declaration, and C type
  Dict::dict_t<qvar_t,$(aggrdecl_t,type_t)@`d,`d> @`d aggrs_so_far;
  // tunions seen so far
  Set::set_t<qvar_t,`d> @`d                    tunions_so_far;
  // xtunions seen so far -- bool is false if seen but not initialized (extern)
  Dict::dict_t<qvar_t,bool,`d> @`d             xtunions_so_far;
  // generated identifiers from other identifiers (e.g., Foo_struct)
  Dict::dict_t<$(qvar_t,string_t)@`d,qvar_t,`d>@`d qvar_tags;
  // generated labels -- get re-used across functions
  Xarray::xarray_t<var_t,`d>                    temp_labels;
};
static struct TocState *toc_state = NULL;

int qvar_tag_cmp($(qvar_t,string_t)@ x, $(qvar_t,string_t)@ y) {
  let $(qx,sx) = *x;
  let $(qy,sy) = *y;
  int i = qvar_cmp(qx,qy);
  if (i != 0) return i;
  return strcmp(sx,sy);
}

type_t aggrdecl_type(qvar_t q, type_t type_maker(qvar_t)) {
  let TocState{<`d> .dyn = dyn, .aggrs_so_far = aggs, ...} = *toc_state;
  region d = open(dyn) {
    $(aggrdecl_t,type_t)@`d*`d v = Dict::lookup_opt(*aggs,q);
    if (v == NULL) {
      return type_maker(q);
    } else {
      let &$(_,t) = *v;
      return t;
    }
  }
}

static int tuple_type_counter = 0;
static int temp_var_counter = 0;
static int fresh_label_counter = 0;

// errors and reporting
xtunion exn {Toc_Unimplemented};
xtunion exn {Toc_Impossible};
static `a unimp(string_t fmt, ... inject parg_t<`r2> ap) 
  __attribute__((format(printf,1,2), noreturn))
{
  vfprintf(stderr,fmt,ap);
  fprintf(stderr,"\n");
  fflush(stderr);
  throw Toc_Unimplemented;
}
static `a toc_impos(string_t fmt, ... inject parg_t<`r2> ap) 
  __attribute__((format(printf,1,2), noreturn))
{
  vfprintf(stderr,fmt,ap);
  fprintf(stderr,"\n");
  fflush(stderr);
  throw Toc_Impossible;
}
xtunion exn {Match_error};

/////////////////////////// Pre-Allocated Stuff /////////////////////////////
// Don't use any of these things if they might get mutated!!!

// some pre-allocated boxed strings -- use foo_sp for char ?* w/ contents "foo"
#define MAKE_STRING(str)\
  static string_t    str##_string = #str; \
  static stringptr_t str##_sp     = &str##_string

MAKE_STRING(curr);
MAKE_STRING(tag);
MAKE_STRING(val);
MAKE_STRING(_handler_cons);
MAKE_STRING(handler);
MAKE_STRING(_RegionHandle);
MAKE_STRING(_DynRegionHandle);
MAKE_STRING(_DynRegionFrame);

/* Some pre-allocated qvars -- use foo_e for exp that is var "foo".
   NB we must record all of these so that tovc knows about them;
   this is done by initializing the external variable globals in the
   function init(), below. */
stringptr_t ?globals = NULL;
#define MAKE_VAR(str)\
  static string_t              str##_str = #str;\
  static $(nmspace_t, var_t)   str##_pr  = $(Loc_n,&str##_str);\
  static tunion Raw_exp.Var_e  str##_re  = Var_e(&str##_pr,Unresolved_b);\
  static struct Exp            str##_ev  = Exp{NULL,&str##_re,NULL,EmptyAnnot};\
  static exp_t                 str##_e   = &str##_ev


MAKE_VAR(_throw);
MAKE_VAR(setjmp);
MAKE_VAR(_push_handler);
MAKE_VAR(_pop_handler);
MAKE_VAR(_exn_thrown);
MAKE_VAR(_npop_handler);
MAKE_VAR(_check_null); 
MAKE_VAR(_check_known_subscript_null);
MAKE_VAR(_check_known_subscript_notnull);
// MAKE_VAR(_check_unknown_subscript);
MAKE_VAR(_check_dynforward_subscript);
MAKE_VAR(_check_dyneither_subscript);
// MAKE_VAR(_tagged_arr);
MAKE_VAR(_dynforward_ptr);
MAKE_VAR(_dyneither_ptr);
// MAKE_VAR(_tag_arr);
MAKE_VAR(_tag_dynforward);
MAKE_VAR(_tag_dyneither);
// MAKE_VAR(_init_tag_arr);
MAKE_VAR(_init_dynforward_ptr);
MAKE_VAR(_init_dyneither_ptr);
// MAKE_VAR(_untag_arr);
MAKE_VAR(_untag_dynforward_ptr);
MAKE_VAR(_untag_dyneither_ptr);
// MAKE_VAR(_get_arr_size);
MAKE_VAR(_get_dynforward_size);
MAKE_VAR(_get_dyneither_size);
MAKE_VAR(_get_zero_arr_size); // NOT SURE WHETHER WE NEED BOTH?
// MAKE_VAR(_tagged_arr_plus);
MAKE_VAR(_dynforward_ptr_plus);
MAKE_VAR(_dyneither_ptr_plus);
MAKE_VAR(_zero_arr_plus);     // NOT SURE WHETHER WE NEED BOTH?
// MAKE_VAR(_tagged_arr_inplace_plus);
MAKE_VAR(_dynforward_ptr_inplace_plus);
MAKE_VAR(_dyneither_ptr_inplace_plus);
MAKE_VAR(_zero_arr_inplace_plus); // NOT SURE WHETHER WE NEED BOTH?
// MAKE_VAR(_tagged_arr_inplace_plus_post);
MAKE_VAR(_dynforward_ptr_inplace_plus_post);
MAKE_VAR(_dyneither_ptr_inplace_plus_post);
MAKE_VAR(_dynforward_to_dyneither);
MAKE_VAR(_dyneither_to_dynforward);
MAKE_VAR(_zero_arr_inplace_plus_post); // NOT SURE WHETHER WE NEED BOTH?
MAKE_VAR(_cycalloc);
MAKE_VAR(_cyccalloc);
MAKE_VAR(_cycalloc_atomic);
MAKE_VAR(_cyccalloc_atomic);
MAKE_VAR(_region_malloc);
MAKE_VAR(_region_calloc);
MAKE_VAR(_check_times);
MAKE_VAR(_new_region);
MAKE_VAR(_push_region);
MAKE_VAR(_pop_region);
MAKE_VAR(_open_dynregion);
MAKE_VAR(_push_dynregion);
MAKE_VAR(_pop_dynregion);
MAKE_VAR(_reset_region);
MAKE_VAR(_throw_arraybounds);
// MAKE_VAR(_tagged_ptr_decrease_size);
MAKE_VAR(_dynforward_ptr_decrease_size);
MAKE_VAR(_dyneither_ptr_decrease_size);
MAKE_VAR(_swap_word);
MAKE_VAR(_swap_dynforward);
MAKE_VAR(_swap_dyneither);

#undef MAKE_STRING
#undef MAKE_VAR

static tunion Type.AggrType dynforward_ptr_typ_v =
AggrType(AggrInfo(UnknownAggr(StructA,&_dynforward_ptr_pr),
                  NULL));
static tunion Type dynforward_ptr_typ = &dynforward_ptr_typ_v;

static tunion Type.AggrType dyneither_ptr_typ_v =
                           AggrType(AggrInfo(UnknownAggr(StructA,
                                                         &_dyneither_ptr_pr),
                                             NULL));
static tunion Type dyneither_ptr_typ = &dyneither_ptr_typ_v;

static tqual_t mt_tq = Tqual(false,false,false,false,NULL);

static stmt_t skip_stmt_dl() {
  static stmt_t * skip_stmt_opt = NULL;
  if(skip_stmt_opt == NULL)
    skip_stmt_opt = new skip_stmt(DL);
  return *skip_stmt_opt;
}
// These constructors are useful when we want to just update the
// raw part of an expression or statement.
static exp_t cast_it(type_t t, exp_t e) {
  return cast_exp(t,e,false,No_coercion,DL);
}
static raw_exp_t cast_it_r(type_t t, exp_t e) {
  return new Cast_e(t,e,false,No_coercion);
}
static raw_exp_t deref_exp_r(exp_t e) {
  return new Deref_e(e);
}
static raw_exp_t subscript_exp_r(exp_t e1, exp_t e2) {
  return new Subscript_e(e1,e2);
}
static raw_exp_t stmt_exp_r(stmt_t s) {
  return new StmtExp_e(s);
}
static raw_exp_t sizeoftyp_exp_r(type_t t) {
  return new Sizeoftyp_e(t);
}
static raw_exp_t fncall_exp_r(exp_t e, list_t<exp_t,`H> es) {
  return new FnCall_e(e,es,NULL);
}
static raw_stmt_t exp_stmt_r(exp_t e) {
  return new Exp_s(e);
}
static raw_stmt_t seq_stmt_r(stmt_t s1, stmt_t s2) {
  return new Seq_s(s1,s2);
}
static raw_exp_t conditional_exp_r(exp_t e1, exp_t e2, exp_t e3) {
  return new Conditional_e(e1,e2,e3);
}
static raw_exp_t aggrmember_exp_r(exp_t e, field_name_t n) {
  return new AggrMember_e(e,n);
}
static raw_exp_t aggrarrow_exp_r(exp_t e, field_name_t n) {
  return new AggrArrow_e(e,n);
}
static raw_exp_t unresolvedmem_exp_r(opt_t<typedef_name_t,`H> tdopt,
                                     list_t<$(list_t<designator_t,`H>,exp_t)@`H,`H> ds)
{
  return new UnresolvedMem_e(tdopt,ds);
}
static raw_stmt_t goto_stmt_r(var_t v, stmt_opt_t s) {
  return new Goto_s(v,s);
}
static tunion Raw_exp.Const_e zero_exp = Const_e(Int_c(Signed,0));

///////////////////////////// Various Utilities /////////////////////////////

static bool is_zero(exp_t e) {
  switch (e->r) {
  case &Const_e(Char_c(_,c)):     return c == '\0';
  case &Const_e(Short_c(_,i)):    return i == 0;
  case &Const_e(Int_c(_,i)):      return i == 0;
  case &Const_e(LongLong_c(_,i)): return i == 0;
  case &Const_e(Null_c): return true;
  case &Cast_e(_,e1,_,_): return is_zero(e1);
  case &Tuple_e(es): return List::forall(is_zero,es);
  case &Array_e(dles):         fallthru(dles);
  case &Struct_e(_,_,dles,_):  fallthru(dles);
  case &CompoundLit_e(_,dles): fallthru(dles);
  case &UnresolvedMem_e(_,dles):
    for (; dles != NULL; dles = dles->tl) 
      if (!is_zero((*dles->hd)[1])) return false;
    return true;
  default: return false;
  }
}

// return true if t is a nullable pointer type i.e., *
static bool is_nullable(type_t t) {
  switch (compress(t)) {
  case &PointerType(PtrInfo(_,_,PtrAtts(_,n,_,_,_))): 
    return conref_def(false,n);
  default: toc_impos("is_nullable");
  }
}

// FIX: Share the results to save compile-time space and time.
//      Alternately, put struct names for tunion variants in the environment.
static qvar_t collapse_qvar_tag(qvar_t x,string_t<`H> tag) {
  let TocState{.dyn = dyn, .qvar_tags = qvs, ...} = *toc_state;
  static string_t bogus_string = "*bogus*";
  static $(nmspace_t,var_t) bogus_qvar = $(Loc_n,&bogus_string);
  static $(qvar_t,string_t) pair = $(&bogus_qvar,"");
  pair = $(x,tag);
  region d = open(dyn) {
    let qptr = Dict::lookup_opt(*qvs,&pair);
    if (qptr != NULL) return *qptr;
    let new_pair = new $(x,tag);
    qvar_t res = new $((*x)[0], new (string_t)strconcat(*((*x)[1]),tag));
    *qvs = Dict::insert(*qvs,new_pair,res);
    return res;
  }
}

// used to generate struct definitions for tuple types
// we share the struct definitions where possible.  
static type_t add_tuple_type(list_t<$(tqual_t,type_t)@,`r> tqs0) {
  let TocState{.dyn = dyn, .tuple_types = tuple_types, ...} = *toc_state;
  region d = open(dyn) {
    // look for the same tuple-type already declared
    for (let tts = *tuple_types; tts != NULL; tts = tts->tl) {
      let &$(x,ts) = tts->hd;
      let tqs = tqs0;
      for (; tqs != NULL && ts != NULL; tqs = tqs->tl, ts = ts->tl)
        if (!unify((*tqs->hd)[1],ts->hd))
          break;
      if(tqs == NULL && ts == NULL)
        return x;
    }
    // haven't seen this one before, add a declaration
    stringptr_t xname = new (string_t)aprintf("_tuple%d",tuple_type_counter++);
    type_t x = strct(xname);
    list_t<type_t> ts = List::rmap(d,snd_tqt,tqs0);
    let fs = NULL;
    list_t<type_t> ts2 = ts;
    for (int i=1; ts2 != NULL; ts2 = ts2->tl, i++)
      fs = new List(new Aggrfield(fieldname(i),mt_tq,ts2->hd,NULL,NULL),fs);
    fs = List::imp_rev(fs);
    let sd = new Aggrdecl{.kind=StructA, .sc = Public, 
                          .name = new $(Rel_n(NULL),xname), .tvs = NULL, 
                          .impl = new AggrdeclImpl{.exist_vars = NULL, 
                                                   .rgn_po = NULL,
                                                   .fields = fs},
                          .attributes = NULL};
    result_decls = new List(new_decl(new Aggr_d(sd),DL),result_decls);
    *tuple_types  = rnew(d) List(rnew(d) $(x,ts),*tuple_types);
    return x;
  }
}

// generate a temporary variable
// FIX: need to guarantee these can't conflict
qvar_t temp_var() {
  let i = temp_var_counter++;
  qvar_t res = new $(Loc_n,new (string_t)aprintf("_tmp%X",i));
  return res;
}

// generate a fresh label
// FIX: need to guarantee these can't conflict
static var_t fresh_label() {
  let TocState{.dyn = dyn, .temp_labels = temp_labels, ...} = *toc_state;
  region d = open(dyn) {
    let i = fresh_label_counter++;
    if (i < Xarray::length(temp_labels))
    return Xarray::get(temp_labels,i);
    var_t res = new (string_t)aprintf("_LL%X",i);
    if (Xarray::add_ind(temp_labels,res) != i)
      toc_impos("fresh_label: add_ind returned bad index...");
    return res;
  }
}

// These two functions should never be used for xtunions. Should memoize?
// Note the former used to use static const int variables, but couldn't
// at top-level.
static exp_t tunion_tag(tuniondecl_t td, qvar_t name, bool carries_value) {
  int ans = 0;
  let fs  = td->fields->v;
  while(qvar_cmp(name,fs->hd->name)!=0) {
    if(td->is_flat || 
       (carries_value && fs->hd->typs != NULL)
       || (!carries_value && fs->hd->typs == NULL))
      ++ans;
    fs = fs->tl;
  }
  return uint_exp(ans,DL);    
}
static int num_void_tags(tuniondecl_t td) {
  int ans = 0;
  for(let fs = td->fields->v; fs != NULL; fs = fs->tl)
    if(fs->hd->typs == NULL)
      ++ans;
  return ans;    
}

///////////////////////////////////////////////////////////////
//         Convert a Cyclone type to a C type                //
///////////////////////////////////////////////////////////////
static type_t typ_to_c(type_t t); // forward declaration

static $(opt_t<var_t,`r>,tqual_t,type_t)@ 
arg_to_c($(opt_t<var_t,`r>,tqual_t,type_t)@ a) {
  let $(x,y,z) = *a;
  return new $(x,y,typ_to_c(z));
}
static $(tqual_t,type_t)@ typ_to_c_f($(tqual_t,type_t)@ x) {
  let $(a,b) = *x;
  return new $(a,typ_to_c(b));
}
// Sometimes we translate arrays t[] and t[N] to t*, and sometimes
// we leave them alone.  We must leave them alone in the following
// circumstances:
// 1. as the argument of sizeof
// 2. in typedef
// 3. in declarations
// 4. as the element type of an array
// 5. as the type part of a C9X compound literal
// 6. as the type of a struct field
// We must change them to pointers in the following circumstances:
// 1. as the argument of cast
// We can do either in the following circumstances:
// 1. as the parameter of a function
// The function typ_to_c_array leaves them alone, while typ_to_c
// changes them to pointers.
static type_t typ_to_c_array(type_t t) {
  switch(compress(t)) {
  case &ArrayType(ArrayInfo{t2,tq,x,zt,ztl}): // FIX: do we handle tq correctly?
    return array_typ(typ_to_c_array(t2),tq,x,false_conref,ztl);
  case &Evar(_,&Opt{.v=t2},_,_): return typ_to_c_array(t2);
  default: return typ_to_c(t);
  }
}

static aggrfield_t aggrfield_to_c(aggrfield_t f) {
  // JGM: I'm making the qualifiers non-const here to allow initialization
  return new Aggrfield{.name=f->name, 
                          .tq=mt_tq, // .tq=f->tq, 
                          .type = typ_to_c(f->type),
                       .width=f->width, .attributes=f->attributes};
}

static void enumfields_to_c(list_t<enumfield_t> fs) {
  // warning: assumes all constant expressions are fine as C expressions
  return;
}

static type_t char_star_typ() {
  static type_t* cs = NULL;
  if (cs == NULL) {
    cs = new star_typ(char_typ,HeapRgn,mt_tq,false_conref);
  }
  return *cs;
}
static type_t rgn_typ() {
  static type_t* r = NULL;
  if (r == NULL) {
    r = new cstar_typ(strct(_RegionHandle_sp),mt_tq);
  }
  return *r;
}
static type_t dyn_rgn_typ() {
  static type_t* r = NULL;
  if (r == NULL) {
    r = new cstar_typ(strct(_DynRegionHandle_sp),mt_tq);
  }
  return *r;
}

static type_t typ_to_c(type_t t) {
  switch (t) {
  case VoidType: return t;
  case &Evar(_,NULL,_,_): return sint_typ; // pick something widely useful
  case &Evar(_,&Opt{.v=t2},_,_): return typ_to_c(t2); 
  case &VarType(tv): 
    if (tvar_kind(tv) == AnyKind) return VoidType;
    else return void_star_typ(); // map `a to void *
  case &TunionType(TunionInfo{KnownTunion(&tud),_,_}): 
    if (tud->is_flat)
      return unionq_typ(collapse_qvar_tag(tud->name,"_union"));
    else return void_star_typ();
  case &TunionType(_): toc_impos("unresolved TunionType");
  case &TunionFieldType(TunionFieldInfo{KnownTunionfield(tud,tuf),_}):
    // for flat tunion fields, it's the same as the tunion type.
    // for tunion fields that carry no arguments, it's an unsigned int
    // for xtunion fields that carry no argument, it's a char *.
    // for fields that carry arguments, it's a struct _Field_struct;
    if (tud->is_flat) 
      return unionq_typ(collapse_qvar_tag(tud->name,"_union"));
    if (tuf->typs == NULL) 
      if(tud->is_xtunion) 
        return char_star_typ();
      else return uint_typ;
    else return strctq(collapse_qvar_tag(tuf->name,"_struct"));
  case &TunionFieldType(_): toc_impos("unresolved TunionFieldType");
  case &PointerType(PtrInfo(t2,tq,PtrAtts(_,_,bnds,_,_))):
    // t2? maps to struct dynforward_ptr.
    // t2?+- maps to struct dyneither_ptr.
    // t2* and t2@ map to t2*.  Regions and zero-term are irrelevant.
    t2 = typ_to_c_array(t2);
    switch (compress_conref(bnds)->v) {
    case No_constr:
    case Eq_constr(DynForward_b): return dynforward_ptr_typ;
    case Eq_constr(DynEither_b): return dyneither_ptr_typ;
    default: return star_typ(t2,HeapRgn,tq,false_conref);
    }
  case &IntType(_,_): 
  case FloatType:     
  case &DoubleType(_): return t;
  case &ArrayType(ArrayInfo{t2,tq,e,_,ztl}): 
    return array_typ(typ_to_c_array(t2),tq,e,false_conref,ztl);
  case &FnType(FnInfo{_,_,t2,args,c_vararg,cyc_vararg,_,atts}):
    // just drop the type arguments & effect and translate the nested types
    // also, drop any format descriptors 
    // FIX:  problem with higher-order functions?  Again C's rules are strange.
    // FIX:  dropping noreturn and const attributes b/c C is complaining.
    let new_atts = NULL;
    for (; atts != NULL; atts = atts->tl)
      switch (atts->hd) {
      case Noreturn_att: 
      case Const_att   : 
      case &Format_att(_,_,_): continue;
      case &Initializes_att(_): continue; // correct: a Cyclone addition
      default: new_atts = new List(atts->hd,new_atts); break;
      }
    let new_args = List::map(arg_to_c,args);
    if (cyc_vararg != NULL) {
      // region for array type irrelevant
      let t =typ_to_c(dynforward_typ(cyc_vararg->type,HeapRgn,mt_tq,false_conref));
      let vararg = new $(cyc_vararg->name,cyc_vararg->tq,t);
      new_args = List::imp_append(new_args,new List(vararg,NULL));
    }
    return new FnType(FnInfo{NULL,NULL,typ_to_c(t2),new_args,
                               c_vararg,NULL,NULL,new_atts});
  case &TupleType(tqs):
    // $(t1,...,tn) maps to struct tuple_type_n where we define
    // struct tuple_type_n { t1 f1; ...; tn fn; };
    tqs = List::map(typ_to_c_f,tqs);
    return add_tuple_type(tqs);
  // FIX: we may have to actually declare these things and use them
  // consistently to make GCC happy.
  case &AnonAggrType(k,fs): 
    return new AnonAggrType(k,List::map(aggrfield_to_c,fs));
  case &AggrType(AggrInfo(info,ts)):
    let ad = get_known_aggrdecl(info);
    if(ad->kind==UnionA)
      return aggrdecl_type(ad->name,unionq_typ);
    else return aggrdecl_type(ad->name,strctq);
  case &EnumType(tdn,_): return t;
  case &AnonEnumType(fs): enumfields_to_c(fs); return t;
  case &TypedefType(tdn,ts,td,topt):
    if (topt == NULL || noexpand_r) 
      if (ts != NULL) 
        return new TypedefType(tdn,NULL,td,NULL);
      else return t;
    // just drop the type arguments and translate the nested types
    else return new TypedefType(tdn,NULL,td,new typ_to_c_array(*topt));
  case &SizeofType(_):
  case &TagType(_): return uint_typ; // must be unsigned!
  case &RgnHandleType(t): return rgn_typ();
  case &DynRgnType(_,_): return dyn_rgn_typ();
  case &TypeInt(_): 
    toc_impos("Toc::typ_to_c: type translation passed a type integer");
  case HeapRgn:
    toc_impos("Toc::typ_to_c: type translation passed the heap region");
  case UniqueRgn:
    toc_impos("Toc::typ_to_c: type translation passed the unique region");
  case &AccessEff(_):
  case &JoinEff(_):
  case &RgnsEff(_):
    toc_impos("Toc::typ_to_c: type translation passed an effect");
  }
}

static exp_t array_to_ptr_cast(type_t t,exp_t e,seg_t l) {
  switch (t) {
  case &ArrayType(ArrayInfo{t2,tq,_,_,_}): 
    return cast_it(star_typ(t2,HeapRgn,tq,false_conref),e);
  default: return cast_it(t,e);
  }
}

// returns true when the type contains no pointers. Is conservative
// (does not look at instantiations)
static bool atomic_typ(type_t t) {
  switch (compress(t)) {
  case VoidType:       return true;
  case &VarType(_):    return false;
  case &IntType(_,_):  
  case &EnumType(_,_): 
  case &AnonEnumType(_): 
  case FloatType:      
  case &DoubleType(_): 
  case &FnType(_):     
  case &TagType(_):
  case &SizeofType(_): return true;
  case &ArrayType(ArrayInfo{t,_,_,_,_}): return atomic_typ(t);
    // FIX: really should compute in terms of the instantiation
    // to be as aggressive as possible.
    // note even without this we'll allocate Position::seg_t with atomic.
    // NOTE: cannot call get_known_aggrdecl b/c we sometimes call this
    // post-translation (with unchecked C types)?? (We shouldn't)
  case &AggrType(AggrInfo(info,_)):
    switch(info) {
    case UnknownAggr(_,_): return false; // see above!
    default: break;
    }
    let ad = get_known_aggrdecl(info);
    if(ad->impl == NULL)
      return false;
    for(let fs = ad->impl->fields; fs != NULL; fs = fs->tl)
      if (!atomic_typ(fs->hd->type)) return false;
    return true;
  case &AnonAggrType(_,fs):
    for (; fs != NULL; fs = fs->tl)
      if (!atomic_typ(fs->hd->type)) return false;
    return true;
  case &TunionFieldType(TunionFieldInfo{KnownTunionfield(tud,tuf),_}):
    fallthru(tuf->typs);
  case &TupleType(tqs):
    for (; tqs != NULL; tqs = tqs->tl)
      if (!atomic_typ((*tqs->hd)[1])) return false;
    return true;
    // FIX: can do better if all variants are fieldless (but then they could
    //      have used an enum)
  case &TunionType(_):    
  case &PointerType(_):   
  case &RgnHandleType(_): return false;
  default: toc_impos("atomic_typ:  bad type %s",typ2string(t));
  }
}

static bool is_void_star(type_t t) {
  switch (compress(t)) {
  case &PointerType(PtrInfo{t2,_,_}):
    switch (compress(t2)) {
    case VoidType: return true;
    default:       return false;
    }
  default: return false;
  }
}

// returns true when field f of the struct/union t has type void*.
static bool is_poly_field(type_t t, field_name_t f) {
  switch (compress(t)) {
  case &AggrType(AggrInfo(info,_)):
    let ad = get_known_aggrdecl(info);
    if (ad->impl == NULL)
      toc_impos("is_poly_field: type missing fields");
    fallthru(ad->impl->fields);
  case &AnonAggrType(_,fs):
    let field = lookup_field(fs,f);
    if (field == NULL) 
      toc_impos("is_poly_field: bad field %s",*f);
    return is_void_star(field->type);
  default: toc_impos("is_poly_field: bad type %s",typ2string(t));
  }
}

// returns true when e is projection of a field in a struct that has a 
// variable type before instantiation.  For instance, the field hd has
// type `a before instantiation in struct cons.
static bool is_poly_project(exp_t e) {
  switch (e->r) {
  case &AggrMember_e(e1,f): return is_poly_field(e1->topt->v,f);
  case &AggrArrow_e(e1,f):
    switch (compress(e1->topt->v)) {
    case &PointerType(PtrInfo{t,_,_}): return is_poly_field(t,f);
    default: toc_impos("is_poly_project: bad type %s",typ2string(e1->topt->v));
    }
  default: return false;
  }
}

// possible pointer malloc
static exp_t malloc_ptr(exp_t s) {
  return fncall_exp(_cycalloc_e, new List(s,NULL),DL);
}
// no pointers possible malloc
static exp_t malloc_atomic(exp_t s) {
  return fncall_exp(_cycalloc_atomic_e, new List(s,NULL),DL);
}
// malloc something -- choose malloc routine according to the (Cyclone) type
static exp_t malloc_exp(type_t t,exp_t s) {
  if (atomic_typ(t))
    return malloc_atomic(s);
  return malloc_ptr(s);
}
// region malloc something
static exp_t rmalloc_exp(exp_t rgn, exp_t s) {
  return fncall_exp(_region_malloc_e, list(rgn,s), DL);
}
// calloc something
static exp_t calloc_exp(type_t elt_type, exp_t s, exp_t n) {
  if (atomic_typ(elt_type))
    return fncall_exp(_cyccalloc_atomic_e, list(s,n), DL);
  else 
    return fncall_exp(_cyccalloc_e, list(s,n), DL);
}
// rcalloc something
static exp_t rcalloc_exp(exp_t rgn, exp_t s, exp_t n) {
  return fncall_exp(_region_calloc_e, list(rgn,s,n), DL);
}

// throw an exception -- this is turned into a function call
static exp_t newthrow_exp(exp_t e) {
  return fncall_exp(_throw_e, new List(e,NULL), DL);
}

// t*{sz} -> t? or t?+- at top-level
static exp_t make_toplevel_dyn_arr(type_t t, exp_t sz, exp_t e, 
                                   bool forward_only) {
  // Note e must be either (a) a string or else (b) a [possibly cast] 
  // identifier that is an array.
  // For case a, we generate
  //   t x[sz] = e;
  //   {x,x,x+sz};
  // For case b, we generate
  //   {e,e,e+sz};
  bool is_string = false;
  switch (e->r) {
  case &Const_e(String_c(_)): is_string = true; break;
  default: break;
  }
  exp_t xexp;
  exp_t xplussz;
  if (is_string) {
    qvar_t    x      = temp_var();
    type_t    vd_typ = array_typ(char_typ,mt_tq,sz,false_conref,DL);
    vardecl_t vd     = static_vardecl(x,vd_typ,e);
    result_decls = new List(new_decl(new Var_d(vd),DL),result_decls);
    xexp = var_exp(x,DL);
    xplussz = add_exp(xexp,sz,DL);
  } else {
    xexp = cast_it(void_star_typ(),e);
    // Note: If e is NULL, element size of 0 is fine!
    xplussz = cast_it(void_star_typ(),add_exp(e,sz,DL));
  }
  exp_t urm_exp;
  if (!forward_only)
    urm_exp = unresolvedmem_exp(NULL,list(new $(NULL,xexp),
                                          new $(NULL,xexp),
                                          new $(NULL,xplussz)),DL);
  else 
    urm_exp = unresolvedmem_exp(NULL,list(new $(NULL,xexp),
                                          new $(NULL,xplussz)),DL);
  return urm_exp;
}

///////////////////////////////////////////////////////////////
//              Translation Environments                     //
///////////////////////////////////////////////////////////////
// When break_lab is NULL, translate break to break.  Otherwise,
// translate break to goto of the given label.  Similarly for
// continue.  This is used in the translation of switches and
// exception handlers to get the right control-flow.
//
// The varmap is used to map source identifiers to certain expressions.
// This is primarily used in the pattern match compilation.
//
// Translation of fallthru(e1,...,en) is
// varmap'(qv1) = trans(e1); ... varmap'(qvn) = trans(en);
// goto fallthru_info->v[0]
// where the ith element of fallthru_info->v[1] is qvi
// and varmap' is fallthru_info->v[2]
// (We also have to pop handlers as explained above.)
static struct FallthruInfo<`r::R> {
  var_t label;
  list_t<qvar_t,`r> binders;
  Dict::dict_t<qvar_t,exp_t,`r> next_case_env;
};

static struct Env<`r::R> {
  <`r2::R> : {`r2} > `r
  var_t *`r       break_lab;
  var_t *`r       continue_lab;
  struct FallthruInfo<`r2> *`r2 fallthru_info;
  Dict::dict_t<qvar_t,exp_t,`r> varmap;
  bool toplevel;
};
typedef struct Env<`r> @`r env_t<`r>;

static bool is_toplevel(env_t nv) {
  let &Env{.toplevel=t,...} = nv;
  return t;
}

static exp_t lookup_varmap(env_t nv, qvar_t x) {
  let &Env{.varmap=v,...} = nv;
  return Dict::lookup(v,x);
}

// the empty environment
static env_t<`r> empty_env(region_t<`r> r) {
  return rnew(r) Env{.break_lab     = NULL,
                     .continue_lab  = NULL,
                     .fallthru_info = NULL,
                     .varmap        = Dict::rempty(r,qvar_cmp),
                     .toplevel      = true};
}

static env_t<`r> share_env(region_t<`r> r, env_t<`r2> e : {`r2} > `r) {
  let &Env{b,c,f,v,t} = e;
  return rnew(r) Env{b,c,f,Dict::rshare(r,v),t};
}

static env_t<`r> clear_toplevel(region_t<`r> r, env_t<`r2> e : {`r2} > `r) {
  let &Env{b,c,f,v,t} = e;
  return rnew(r) Env{b,c,f,Dict::rshare(r,v),false};
}
static env_t<`r> set_toplevel(region_t<`r> r, env_t<`r2> e : {`r2} > `r) {
  let &Env{b,c,f,v,t} = e;
  return rnew(r) Env{b,c,f,Dict::rshare(r,v),true};
}

// add x->y to variable map in environment
// The type allows y to be a general exp, but in practice it is always a var_exp
static env_t<`r> add_varmap(region_t<`r> r, env_t<`r2> e, qvar_t x, exp_t y : {`r2} > `r) {
  switch ((*x)[0]) {
  case Rel_n(_): toc_impos("Toc::add_varmap on Rel_n: %s\n", qvar2string(x));
  default: break;
  }
  let &Env{b,c,f,v,t} = e;
  let new_v = Dict::insert(Dict::rshare(r,v), x, y);
  return rnew(r) Env{b,c,f,new_v,t};
}

// env for loop body: break and continue labels are set to null,
// exception handler pop counters for break and continue are zeroed
static env_t<`r> loop_env(region_t<`r> r, env_t<`r2> e : {`r2} > `r) {
  let &Env{b,c,f,v,t} = e;
  return rnew(r) Env{NULL,NULL,f,Dict::rshare(r,v),t};
}

// env for a switch clause: give new label for break, and zero its pop counter
static env_t<`r>
non_last_switchclause_env(region_t<`r> r,
                          env_t<`r2> e, var_t break_l, var_t fallthru_l,
                          list_t<vardecl_t> fallthru_binders,
                          env_t<`r3> next_case_env : {`r2} > `r, {`r3} > `r) {
  list_t<qvar_t,`r> fallthru_vars = NULL;
  for(; fallthru_binders != NULL; fallthru_binders = fallthru_binders->tl)
    fallthru_vars = rnew(r) List(fallthru_binders->hd->name, fallthru_vars);
  fallthru_vars = List::imp_rev(fallthru_vars);
  let &Env{b,c,f,v,t} = e;
  let &Env{_,_,_,next_case_varmap,_} = next_case_env;
  struct FallthruInfo<`r>*`r fi = 
    rnew(r) FallthruInfo{fallthru_l,fallthru_vars,
                           Dict::rshare(r,next_case_varmap)};
  return rnew(r) Env{rnew(r) break_l, c, fi, Dict::rshare(r,v),t};
}

static env_t<`r> 
last_switchclause_env(region_t<`r> r, env_t<`r2> e, var_t break_l : 
                      {`r2} > `r) {
  let &Env{b,c,f,v,t} = e;
  return rnew(r) Env{rnew(r) break_l, c, NULL, Dict::rshare(r,v), t};
}

// must have no pattern vars and type is int, char, or tunion of a type
// with no value constructors. (If it weren't for allowing fallthru
// anywhere, we wouldn't need the next_l.)
static env_t<`r> 
switch_as_switch_env(region_t<`r> r, env_t<`r2> e, var_t next_l :
                     {`r2} > `r) {
  let &Env{b,c,f,v,t} = e;
  return rnew(r) Env{NULL,c,rnew(r) FallthruInfo{next_l,NULL,
                                                   Dict::rempty(r,qvar_cmp)},
                       Dict::rshare(r,v), t};
}

///////////////////////////////////////////////////////////////
//              Translation of Expressions                   //
///////////////////////////////////////////////////////////////
static void exp_to_c(env_t nv, exp_t e); // forward declaration
static void stmt_to_c(env_t nv, stmt_t s); // forward declaration

static bool need_null_check(exp_t e) { // e must be pre-translation!
  switch(e->annot) {
  case &CfFlowInfo::UnknownZ(_): return is_nullable(e->topt->v);
  case &CfFlowInfo::NotZero(_):  return false;
  case CfFlowInfo::IsZero: 
    Tcutil::terr(e->loc,"dereference of NULL pointer"); 
    return false;
  case EmptyAnnot:
    // warning is unfounded under sizeof as in memcpy
    // Tcutil::warn(e->loc,"unreachable dereference");
    return false;
  case &CfFlowInfo::HasTagCmps(_):
    Tcutil::warn(e->loc,"compiler oddity: pointer compared to tag type");
    return is_nullable(e->topt->v);
  default: toc_impos("need_null_check");
  }
}

static CfFlowInfo::relns_t get_relns(exp_t e) { // e must be pre-translation!
  switch (e->annot) {
  case &CfFlowInfo::UnknownZ(r): return r;
  case &CfFlowInfo::NotZero(r):  return r;
  case CfFlowInfo::IsZero: 
    Tcutil::terr(e->loc,"dereference of NULL pointer"); 
    return NULL;
  case &CfFlowInfo::HasTagCmps(_):
  case EmptyAnnot: return NULL;
  default: toc_impos("get_relns");
  }
}

// returns true when i is <= the number of elements in t
static bool check_const_array(unsigned i, type_t t) {
  //fprintf(stderr,"checking const array %d and %s\n",i,typ2string(t));
  switch (compress(t)) {
  case &PointerType(PtrInfo(_,_,PtrAtts(_,_,b,zt,_))):
    switch (conref_def(bounds_one,b)) {
    case DynForward_b: return false;
    case DynEither_b: return false;
    case &Upper_b(e):
      let $(j,known) = Evexp::eval_const_uint_exp(e);
      return known && i <= j;
    case &AbsUpper_b(_): unimp("check_const_array: AbsUpper_b");
    }
  case &ArrayType(ArrayInfo{_,_,e,_,_}):
    if (e == NULL) return false;
    let $(j,known) = Evexp::eval_const_uint_exp((exp_t)e);
    return known && i <= j;
  default: return false;
  }
}

// see if y is <= v.size
static bool check_leq_size_var(CfFlowInfo::relns_t relns, vardecl_t v, 
                               vardecl_t y) {
  for (; relns != NULL; relns = relns->tl) {
    let r = relns->hd;
    if (r->vd != y) continue;
    switch (r->rop) {
    case CfFlowInfo::LessSize(z) : fallthru(z);
    case CfFlowInfo::LessEqSize(z): if (z == v) return true; else break; 
    default: continue;
    }
  }
  return false;
}

// see if e is <= v.size
static bool check_leq_size(CfFlowInfo::relns_t relns, vardecl_t v, exp_t e) {
  switch (e->r) {
  case &Var_e(_,&Pat_b(y)): fallthru(y);
  case &Var_e(_,&Local_b(y)): fallthru(y);
  case &Var_e(_,&Global_b(y)): fallthru(y);
  case &Var_e(_,&Param_b(y)):
    if (y->escapes) return false;
    // see if y <= v.size
    if (check_leq_size_var(relns,v,y)) return true;
    break;
  case &Primop_e(Size,&List(e2,_)):
    // see if e2 is v
    switch (e2->r) {
    case &Var_e(_,&Pat_b(y)): fallthru(y);
    case &Var_e(_,&Local_b(y)): fallthru(y);
    case &Var_e(_,&Global_b(y)): fallthru(y);
    case &Var_e(_,&Param_b(y)):
      return y == v;
    default: break;
    }
    break;
  default: break;
  }
  return false;
}

// return true if we can prove from relns that i < a.size
//  FIX: doesn't deal with the case where i is a constant and a's size
//  can be found.
static bool check_bounds(CfFlowInfo::relns_t relns, exp_t a, exp_t i) {
#ifdef BCE_DEBUG
  fprintf(stderr,"bounds check on %s and %s\n",exp2string(a),exp2string(i));
  fprintf(stderr,"relns: ["); CfFlowInfo::print_relns(relns); 
  fprintf(stderr,"]\n");
#endif
  switch (a->r) {
  case &Var_e(_,&Pat_b(x)):    fallthru(x);
  case &Var_e(_,&Local_b(x)):  fallthru(x);
  case &Var_e(_,&Global_b(x)): fallthru(x);
  case &Var_e(_,&Param_b(x)):
    if (x->escapes) return false; // no point in looking for escaping vars

  inner_loop:
    switch (i->r) {
    case &Cast_e(t,e2,_,_): i = e2; goto inner_loop;
    case &Const_e(Int_c(None,i)): fallthru(i);
    case &Const_e(Int_c(Signed,i)): 
      return ((i >= 0) && check_const_array(i+1,x->type));
    case &Const_e(Int_c(Unsigned,i)): 
      return check_const_array(i+1,x->type);
    case &Primop_e(Mod,&List(e1,&List(e2,_))):
      // we have x[e1 % e2]
      // if e2 is x.size or z such that z <= x.size then it's okay
      return check_leq_size(relns, x, e2);
    case &Var_e(_,&Pat_b(y)):    fallthru(y);
    case &Var_e(_,&Local_b(y)):  fallthru(y);
    case &Var_e(_,&Global_b(y)): fallthru(y);
    case &Var_e(_,&Param_b(y)):
      if (y->escapes) return false;
      // the expression we're checking is x[y].
      // find something such that y < something
      for (let rs = relns; rs != NULL; rs = rs->tl) {
        let r = rs->hd;
        if (r->vd == y) {
          switch (r->rop) {
            // y < x.size
          case CfFlowInfo::LessSize(z): if (x == z) return true; else break;
          case CfFlowInfo::LessVar(z):
            // y < z -- try to find z == x.size or z <= x.size
            for (let rs = relns; rs != NULL; rs = rs->tl) {
              let r = rs->hd;
              if (r->vd == z) 
                switch (r->rop) {
                case CfFlowInfo::LessEqSize(w): fallthru(w);
                case CfFlowInfo::LessSize(w):
                  if (x == w) return true; 
		  break;
                case CfFlowInfo::EqualConst(c): 
                  return check_const_array(c,x->type);
                case CfFlowInfo::LessVar(w):
                  if (check_leq_size_var(relns, x, w)) return true; 
		  break;
                default: break;
                }
            }
            break;
          case CfFlowInfo::LessConst(c):
            // y < c -- see if c <= x.size 
            return check_const_array(c,x->type);
          default: break;
          }
        }
      }
      break;
    default: break;
    }
    break;
  default: break;
  }
  return false;
}

static type_t get_c_typ(exp_t e) {
  if (e->topt == NULL) toc_impos("Missing type in primop ");
  return typ_to_c(e->topt->v);
}
static type_t get_cyc_typ(exp_t e) {
  if (e->topt == NULL) toc_impos("Missing type in primop ");
  return e->topt->v;
}
static $(tqual_t, type_t)@ tup_to_c(exp_t e) {
  return new $(mt_tq, typ_to_c(e->topt->v));
}
static $(list_t<designator_t>,exp_t)@ add_designator(env_t nv, exp_t e) {
  exp_to_c(nv,e);
  return new $(NULL,e);
}

static exp_t make_struct(env_t nv, qvar_t x, type_t struct_typ, stmt_t s,
                         bool pointer, exp_opt_t rgnopt, bool is_atomic) {
  exp_opt_t eo;
  type_t    t;
  if (pointer) {
    t  = cstar_typ(struct_typ, mt_tq);
    let se = sizeofexp_exp(deref_exp(var_exp(x,DL),DL),DL);
    if (rgnopt == NULL || no_regions)
      eo = is_atomic ? malloc_atomic(se) : malloc_ptr(se);
    else {
      exp_t r = (exp_t)rgnopt;
      exp_to_c(nv, r);
      eo = rmalloc_exp(r,se);
    }
  } else {
    t  = struct_typ;
    eo = NULL;
  }
  return stmt_exp(declare_stmt(x,t,eo,s,DL),DL);
}

static stmt_t init_comprehension(env_t nv, exp_t lhs, vardecl_t vd, 
                                 exp_t e1, exp_t e2, bool zero_term, stmt_t s, 
                                 bool e1_already_translated);

static stmt_t init_anon_struct(env_t nv, exp_t lhs, type_t struct_type,
                               list_t<$(list_t<designator_t>,exp_t)@> dles,
                               stmt_t s);

// code to initialize an array
static stmt_t init_array(env_t nv, exp_t lhs, 
                         list_t<$(list_t<designator_t>,exp_t)@> dles0,
                         stmt_t s) {
  int count = List::length(dles0)-1;
  for (let dles = List::rev(dles0); dles != NULL; dles = dles->tl) {
    // add lhs[e_index] = e to sequence of assignments
    let &$(dl,e1) = dles->hd;
    // calculate the index expression -- the front end checks that
    // the designators are in ascending order...
    // FIX:  real designator lists
    exp_t e_index;
    if (dl == NULL)
      e_index = signed_int_exp(count--,DL);
    else {
      if (dl->tl != NULL) unimp("multiple designators in array");
      let d = dl->hd;
      switch (d) {
      case &ArrayElement(e3):
        exp_to_c(nv,e3);
        e_index = e3;
        break;
      case &FieldName(_): unimp("field name designators in array");
      }
    }
    exp_t lval = subscript_exp(lhs,e_index,DL);
    switch (e1->r) {
    case &Array_e(dles0):
      s = init_array(nv, lval, dles0, s);
      break;
    case &Comprehension_e(vd,g1,g2,zt):
      s = init_comprehension(nv, lval, vd, g1, g2, zt, s, false);
      break;
    case &AnonStruct_e(st,dles):
      s = init_anon_struct(nv, lval, st, dles, s);
      break;
    default:
      exp_to_c(nv,e1);
      s = seq_stmt(assign_stmt(subscript_exp(lhs,e_index,DL),e1,DL),s,DL);
      break;
    }
  }
  return s;
}

// code to initialize a comprehension
// WARNING: Changing the translation here will break Tovc.
static stmt_t init_comprehension(env_t nv, exp_t lhs, vardecl_t vd, 
                                 exp_t e1, exp_t e2, bool zero_term,
                                 stmt_t s, bool e1_already_translated) {
  let x1 = vd->name;
  let elt_typ = typ_to_c(e2->topt->v);
  if (!e1_already_translated)
    exp_to_c(nv,e1);
  region r2 {
    env_t nv2 = add_varmap(r2,nv,x1,varb_exp(x1,new Local_b(vd),DL));
    qvar_t max = temp_var();
    exp_t ea = assign_exp(var_exp(x1,DL),signed_int_exp(0,DL),DL);
    exp_t eb = lt_exp(var_exp(x1,DL),var_exp(max,DL),DL);
    exp_t ec = post_inc_exp(var_exp(x1,DL),DL);
    // FIX: lval may be "const" -- we need to use pointer arithmetic
    // here and cast it to be a non-const pointer to the element type.
    exp_t lval = subscript_exp(lhs,var_exp(x1,DL),DL);
    stmt_t body;
    // since we don't yet allow arrays or comprehensions within comprehensions
    // these two cases shouldn't arise -- but we ought to support this.
    switch (e2->r) {
    case &Array_e(dles):
      body = init_array(nv2, lval, dles, skip_stmt_dl());
      break;
    case &Comprehension_e(vd2,g1,g2,zt):
      body = init_comprehension(nv2, lval, vd2, g1,g2,zt,skip_stmt_dl(), false);
      break;
    case &AnonStruct_e(st,dles):
      body = init_anon_struct(nv, lval, st, dles, skip_stmt_dl());
      break;
    default:
      exp_to_c(nv2,e2);
      body = assign_stmt(lval,e2,DL);
      break;
    }
    stmt_t s2 = for_stmt(ea,eb,ec,body,DL);
    // for zero-terminated comprehensions, we must initialize the last elt to 0
    if (zero_term) {
      // FIX: lhs[max] may be "const" -- we need to use pointer arithmetic
      // here and cast it to be a non-const pointer to the element type.
      // NB: we use new_exp here for the lhs to avoid sharing with the
      // occurrence of lhs above.
      exp_t ex = assign_exp(subscript_exp(new_exp(lhs->r,DL),var_exp(max,DL),DL),
                            cast_it(elt_typ,uint_exp(0,DL)),DL);
      s2 = seq_stmt(s2,exp_stmt(ex,DL),DL);
    }
    // note that we get rid of the const on the index variable x1 here
    return seq_stmt(declare_stmt(max,uint_typ,e1,
                                 declare_stmt(x1,uint_typ,NULL,s2,DL),DL),s,DL);
  }
}

static stmt_t init_anon_struct(env_t nv, exp_t lhs, type_t struct_type,
                               list_t<$(list_t<designator_t>,exp_t)@> dles,
                               stmt_t s) {
  for(let es = List::rev(dles); es != NULL; es = es->tl) {
    let &$(ds,e) = es->hd;
    if(ds == NULL)
      toc_impos("empty designator list");
    if(ds->tl != NULL) 
      toc_impos("too many designators in anonymous struct");
    switch (ds->hd) {
    case &FieldName(f):
      exp_t lval = aggrmember_exp(lhs,f,DL);
      switch (e->r) {
      case &Array_e(dles):
        s = init_array(nv, lval, dles, s); break;
      case &Comprehension_e(vd,e1,e2,zt):
        s = init_comprehension(nv, lval, vd, e1, e2, zt, s, false); break;
      case &AnonStruct_e(st2,dles):
        s = init_anon_struct(nv, lval, st2, dles, s); break;
      default:
        exp_to_c(nv,e);
        // cast to void* if necessary
        if (is_poly_field(struct_type,f))
          e = cast_it(void_star_typ(),e);
        // FIX: deal with nested arrays and comprehensions
        s = seq_stmt(exp_stmt(assign_exp(lval, e, DL), DL), s, DL);
        break;
      }
      break;
    default: toc_impos("array designator in struct");
    }
  }
  return s;
}

// Would be nice to share more code with init_struct
// but the designators get in the way.
static exp_t init_tuple(env_t nv, bool pointer, 
                        exp_opt_t rgnopt, list_t<exp_t> es) {
  // $(e1,...,en)  -> ({ t x;   x.f1 = e1; ... x.fn = en; x})
  // &$(e1,...,en) -> ({ t * x=malloc(sizeof(t); x->f1 = e1; ... x->fn = en; x})
  region r {
    let tqs = List::rmap(r,tup_to_c,es);
    let n   = add_tuple_type(tqs);
    
    let x    = temp_var();
    let xexp = var_exp(x,DL);
    let s    = exp_stmt(xexp,DL);

    let lval_f = pointer ? aggrarrow_exp : aggrmember_exp;

    bool is_atomic = true;
    let es = List::rrev(r,es);
    for (int i = length(es); es != NULL; es = es->tl, --i) {
      exp_t e = es->hd;
      exp_t lval = lval_f(xexp, fieldname(i), DL);
      is_atomic = is_atomic && atomic_typ(e->topt->v);
      switch (e->r) {
      case &Array_e(dles):
        s = init_array(nv, lval, dles, s);
        break;
      case &Comprehension_e(vd,e1,e2,zt):
        s = init_comprehension(nv, lval, vd, e1, e2, zt, s, false);
        break;
        // FIX: deal with comprehensions
      default:
        exp_to_c(nv,e);
        s = seq_stmt(exp_stmt(assign_exp(lval_f(xexp,fieldname(i),
                                                DL),e, DL), DL), s, DL);
        break;
      }
    }
    return make_struct(nv,x,n,s,pointer,rgnopt,is_atomic);
  }
}

static exp_t init_struct(env_t nv, type_t struct_type, bool has_exists,
                         bool pointer, exp_opt_t rgnopt, 
                         list_t<$(list_t<designator_t>,exp_t)@> dles, 
                         typedef_name_t tdn) {
  let x    = temp_var();
  let xexp = var_exp(x,DL);
  let s    = exp_stmt(xexp,DL);

  let lval_f = pointer ? aggrarrow_exp : aggrmember_exp;
  let aggr_typ = aggrdecl_type(tdn,strctq);
  
  bool is_atomic = true;
  aggrdecl_t ad;
  switch(compress(struct_type)) {
  case &AggrType(AggrInfo(info,_)): 
    ad = get_known_aggrdecl(info);
    break;
  default: toc_impos("init_struct: bad struct type");
  }
  region r {
    for(let es = List::rrev(r,dles); es != NULL; es = es->tl) {
      let &$(ds,e) = es->hd;
      is_atomic = is_atomic && atomic_typ(e->topt->v);
      if(ds == NULL)
        toc_impos("empty designator list");
      if(ds->tl != NULL) {
        // untested
        // JGM: I don't understand this code
        let y    = temp_var();
        let yexp = var_exp(y,DL);
        for(; ds != NULL; ds = ds->tl)
          switch (ds->hd) {
          case &FieldName(f):
            // cast to void* if necessary
            if (is_poly_field(struct_type,f))
              yexp = cast_it(void_star_typ(),yexp);
            s = seq_stmt(exp_stmt(assign_exp(lval_f(xexp,f,DL), yexp, DL), DL),
                         s, DL);
            break;
          default: toc_impos("array designator in struct");
          }
        // FIX:  need to deal with nested arrays, comprehensions, etc.
        exp_to_c(nv,e);
        s = seq_stmt(exp_stmt(assign_exp(yexp, e, DL), DL), s, DL);
      } else
        switch (ds->hd) {
        case &FieldName(f):
          exp_t lval = lval_f(xexp,f,DL);
          switch (e->r) {
          case &Array_e(dles):
            s = init_array(nv, lval, dles, s); break;
          case &Comprehension_e(vd,e1,e2,zt):
            s = init_comprehension(nv, lval, vd, e1, e2, zt, s, false); break;
          case &AnonStruct_e(st,dles):
            s = init_anon_struct(nv, lval, st, dles, s); break;
          default:
	    bool was_ptr_type = is_pointer_type(e->topt->v);
            exp_to_c(nv,e);
            let ad = lookup_decl_field(ad,f);
            // cast to void* to vaoid gcc warnings (does it more than needed)
	    if (is_poly_field(struct_type,f) && !was_ptr_type)
	      e = cast_it(void_star_typ(),e);
	    // more warning avoidance -- watch out if existentials are common
	    if(has_exists)
	      e = cast_it(ad->type,e);
            // FIX: deal with nested arrays and comprehensions
            s = seq_stmt(exp_stmt(assign_exp(lval, e, DL), DL), s, DL);
            break;
          }
          break;
        default: toc_impos("array designator in struct");
        }
    }
    return make_struct(nv, x, aggr_typ, s, pointer, rgnopt, is_atomic);
  }
}

// functions for passing to lvalue_assign (see below)
static exp_t assignop_lvalue(exp_t el, $(opt_t<primop_t,`H>,exp_t)@ pr) {
  return assignop_exp(el,(*pr)[0],(*pr)[1],DL);
}
static exp_t address_lvalue(exp_t e1, bool ignore) {
  return address_exp(e1,DL);
}
static exp_t incr_lvalue(exp_t e1, incrementor_t incr) {
  return new_exp(new Increment_e(e1,incr),DL);
}

static void lvalue_assign_stmt(stmt_t s,list_t<field_name_t> fs,
			       exp_t f(exp_t,`a), `a f_env);
// e1 is the result of translating an lvalue.  fs is the path of struct
// fields that we're assigning to on e1 (if any).  The translation
//  may have inserted NULL checks, etc., but buried within e1 is an lvalue.
// We find the underlying lvalue, call it el.
// We replace el in e1 with f(el,env)
// We assume that variables in f(el,env) will not be captured by any
static void lvalue_assign(exp_t e1, list_t<field_name_t> fs, 
			  exp_t f(exp_t,`a), `a f_env){
  switch (e1->r) {
  case &StmtExp_e(s): lvalue_assign_stmt(s,fs,f,f_env); break;
  case &Cast_e(t,e,_,_):  lvalue_assign(e,fs,f,f_env); break;
  case &AggrMember_e(e,fld):
    // Hack: strip off the struct member -- the base case adds it back in.
    e1->r = e->r;
    lvalue_assign(e1,new List(fld,fs),f,f_env);
    break;
  default:
    // Note: this may not be an lvalue b/c of &arr where arr has an array type.
    // WARNING: If the translation of lvalues changes, we may need to change
    //          how we find the "inner lvalue".
    // make a copy so we don't create a loop
    exp_t e1_copy = copy_exp(e1);
    // add the path back on to the expression
    for (; fs != NULL; fs = fs->tl)
      e1_copy = aggrmember_exp(e1_copy,fs->hd,e1_copy->loc);
    e1->r = f(e1_copy, f_env)->r;
    break;
  }
}
static void lvalue_assign_stmt(stmt_t s,list_t<field_name_t> fs, 
			       exp_t f(exp_t,`a), `a f_env) {
  switch (s->r) {
  case &Exp_s(e1):    lvalue_assign(e1,fs,f,f_env);      break;
    // we assume free vars of e2 are not captured by d
  case &Decl_s(d,s2): lvalue_assign_stmt(s2,fs,f,f_env); break;
  case &Seq_s(_,s2):  lvalue_assign_stmt(s2,fs,f,f_env); break;
  default: toc_impos("lvalue_assign_stmt: %s",stmt2string(s));
  }
}

// similar to map_c but flips order of arguments
static list_t<`b,`r2> rmap_2c(region_t<`r2> r2,`b f(`a,`c),`c env,
                               list_t<`a,`r1> x) {
  list_t<`b,`r2> result, prev;

  if (x == NULL) return NULL;
  result = rnew(r2) List(f(x->hd,env),NULL);
  prev = result;
  for (x=x->tl; x != NULL; x=x->tl) {
    prev->tl = rnew(r2) List(f(x->hd,env),NULL);
    prev = prev->tl;
  }
  return(result);
}
static list_t<`b> map_2c(`b f(`a,`c), `c env, list_t<`a,`r> x) {
  return rmap_2c(heap_region,f,env,x);
}

static $(list_t<designator_t>,exp_t)@ make_dle(exp_t e) {
  return new $(NULL,e);
}

static struct PtrInfo get_ptr_type(type_t t) {
  switch (compress(t)) {
  case &PointerType(p): return p;
  default: toc_impos("get_ptr_typ: not a pointer!");
  }
}

// given a type t that admits "zero", return an expression representing
// zero for that type.  For pointers, this is NULL.  For integral types,
// this is the appropriate integral 0.
static exp_t generate_zero(type_t t) {
  exp_t res;
  switch (compress(t)) {
  case &PointerType(_) : res = null_exp(DL); break;
  case &IntType(sn,Char_sz) : res = const_exp(Char_c(sn,0),DL); break;
  case &IntType(sn,Short_sz) : res = const_exp(Short_c(sn,0),DL); break;
  case &EnumType(_,_)  : fallthru;
  case &AnonEnumType(_): fallthru(Unsigned);
  case &IntType(sn,Int_sz) : fallthru(sn);
  case &IntType(sn,Long_sz) : 
    res = const_exp(Int_c(sn,0),DL); break;
  case &IntType(sn,LongLong_sz) : 
    res = const_exp(LongLong_c(sn,0),DL); break;
  case FloatType       : fallthru;
  case &DoubleType(_)  : res = const_exp(Float_c("0.0"),DL); break;
  default: 
    toc_impos("found non-zero type %s in generate_zero",typ2string(t));
  }
  res->topt = new Opt(t);
  return res;
}

// We're translating e which is of the form e_1 op= e_2 where e_1 
// involves a zero-terminated pointer and is of the form *ea or
// ea[eb].  We need to prevent overwriting the last zero in the array.  
static void zero_ptr_assign_to_c(env_t nv, exp_t e, 
                                 exp_t e1, opt_t<primop_t> popt, exp_t e2,
                                 type_t ptr_type, 
                                 bool is_dynforward, 
                                 bool is_dyneither,
                                 type_t elt_type) {
  // To simplify the translation, we always use a fat pointer and generate:
  //  ({ fat_ptr_type x = ((fat_ptr_type)ea) + eb; 
  //     elt_type y = *x; // check here that x is not null and in bounds
  //     elt_type z = y op e2;
  //     if (x.size == 1 && y == zero && z != zero) _throw_arraybounds();
  //     *x.curr = z; })
  // Note that this is generated and *then* translated to ensure the
  // proper constraints.  
  bool is_fat = (is_dynforward || is_dyneither);
  type_t fat_ptr_type;
  if (is_dynforward)
    fat_ptr_type = dynforward_typ(elt_type, HeapRgn, mt_tq, true_conref);
  else 
    fat_ptr_type = dyneither_typ(elt_type, HeapRgn, mt_tq, true_conref);
  let c_elt_type = typ_to_c(elt_type);
  let c_fat_ptr_type = typ_to_c(fat_ptr_type);
  let c_ptr_type = cstar_typ(c_elt_type, mt_tq);
  let c_ptr_type_opt = new Opt(c_ptr_type);
  exp_t xinit;
  switch (e1->r) {
  case &Deref_e(ea):
    if (!is_fat) {
      ea = cast_it(fat_ptr_type,ea); 
      ea->topt = new Opt(fat_ptr_type);
    }
    exp_to_c(nv,ea); xinit = ea; break;
  case &Subscript_e(ea,eb):
    if (!is_fat) {
      ea = cast_it(fat_ptr_type,ea); 
      ea->topt = new Opt(fat_ptr_type);
    }
    exp_to_c(nv,ea); exp_to_c(nv,eb);
    if (is_dynforward)
      xinit = fncall_exp(_dynforward_ptr_plus_e,
                         list(ea,sizeoftyp_exp(typ_to_c(elt_type),DL),eb),DL);
    else 
      xinit = fncall_exp(_dyneither_ptr_plus_e,
                         list(ea,sizeoftyp_exp(typ_to_c(elt_type),DL),eb),DL);
    break;
  default: toc_impos("found bad lhs for zero-terminated pointer assignment");
  }
  let x = temp_var();                // build ptr_type x = ea + eb;
  region rgn2 {
    let nv = add_varmap(rgn2, nv, x, var_exp(x,DL));  // add x to the varmap
    let x_vd = new Vardecl {Public,x,mt_tq,c_fat_ptr_type,xinit,NULL,NULL,false};
    let x_bnd = new Local_b(x_vd);     // build *x -- need to translate here
    let x_exp = varb_exp(x,x_bnd,DL);  // to check the bound and for NULL
    x_exp->topt = new Opt(fat_ptr_type);
    let deref_x = deref_exp(x_exp,DL);
    deref_x->topt = new Opt(elt_type);
    exp_to_c(nv,deref_x);
    let y = temp_var();                // build elt_type y = *x;
    nv = add_varmap(rgn2, nv, y, var_exp(y,DL));  // add y to the varmap
    let y_vd = new Vardecl {Public,y,mt_tq,c_elt_type,deref_x,NULL,NULL,false};
    let y_bnd = new Local_b(y_vd);
    exp_t z_init = e2;                 // build y op e2 and translate
    if (popt != NULL) {
      let y_exp = varb_exp(y,y_bnd,DL);
      y_exp->topt = deref_x->topt;
      z_init = prim2_exp(popt->v,y_exp,e2,DL);
      z_init->topt = y_exp->topt;
    }
    exp_to_c(nv,z_init);
    let z = temp_var();                // build z = y op e2;
    let z_vd = new Vardecl {Public,z,mt_tq,c_elt_type,z_init,NULL,NULL,false};
    let z_bnd = new Local_b(z_vd);
    nv = add_varmap(rgn2, nv, z, var_exp(z,DL));  // add z to the varmap
    // build y == zero and translate -- here, we need to know what
    // the element type is to generate the right zero.  
    let y2_exp = varb_exp(y,y_bnd,DL); y2_exp->topt = deref_x->topt;
    let zero1_exp = generate_zero(elt_type);
    let comp1_exp = prim2_exp(Eq,y2_exp,zero1_exp,DL);
    comp1_exp->topt = new Opt(sint_typ);
    exp_to_c(nv,comp1_exp);
    // build z != zero and translate
    let z_exp = varb_exp(z,z_bnd,DL); z_exp->topt = deref_x->topt;
    let zero2_exp = generate_zero(elt_type);
    let comp2_exp = prim2_exp(Neq,z_exp,zero2_exp,DL);
    comp2_exp->topt = new Opt(sint_typ);
    exp_to_c(nv,comp2_exp);
    // build x.size == 1 directly (no translation)
    let xsizeargs = list(varb_exp(x,x_bnd,DL),
                         sizeoftyp_exp(typ_to_c(elt_type),DL));
    let oneexp = uint_exp(1,DL);
    exp_t xsize;
    if (is_dynforward) 
      xsize = prim2_exp(Eq,fncall_exp(_get_dynforward_size_e,xsizeargs,DL),
                        oneexp,DL);
    else 
      xsize = prim2_exp(Eq,fncall_exp(_get_dyneither_size_e,xsizeargs,DL),
                        oneexp,DL);
    // start assembling the statement
    let comp_exp = and_exp(xsize,and_exp(comp1_exp,comp2_exp,DL),DL);
    let thr_stmt = exp_stmt(fncall_exp(_throw_arraybounds_e,NULL,DL),DL);
    let xcurr = aggrmember_exp(varb_exp(x,x_bnd,DL),curr_sp,DL);
    xcurr = cast_it(c_ptr_type,xcurr);
    let deref_xcurr = deref_exp(xcurr,DL);
    let asn_exp = assign_exp(deref_xcurr,var_exp(z,DL),DL);
    let s = exp_stmt(asn_exp,DL);
    s = seq_stmt(ifthenelse_stmt(comp_exp,thr_stmt,skip_stmt(DL),DL),s,DL);
    s = decl_stmt(new Decl(new Var_d(z_vd),DL),s,DL);
    s = decl_stmt(new Decl(new Var_d(y_vd),DL),s,DL);
    s = decl_stmt(new Decl(new Var_d(x_vd),DL),s,DL);
    e->r = stmt_exp_r(s);
  }
}

static void exp_to_c(env_t nv, exp_t e) {
  let r = e->r;
  if(e->topt == NULL)
    toc_impos("exp_to_c: no type for %s",exp2string(e));
  type_t old_typ = e->topt->v;
  switch (r) {
  case &Const_e(Null_c):
    // NULL translate to 0 unless a tagged array, then {0,0,0} (if either)
    // and {0,0} (if forward-only), via runtime call unless at top-level
    // note: we don't need the element type b/c the length is 0 (so we lie)
    // note: should share all these uint_exp(0,DL) things
    let zero = uint_exp(0,DL);
    bool forward_only = false;
    if(is_tagged_pointer_typ(old_typ,&forward_only)) {
      if(is_toplevel(nv))
	e->r = make_toplevel_dyn_arr(old_typ, zero, zero, forward_only)->r;
      else if (forward_only)
	e->r = fncall_exp_r(_tag_dynforward_e, list(zero,zero,zero));
      else 
	e->r = fncall_exp_r(_tag_dyneither_e, list(zero,zero,zero));
    }
    else
      e->r = (raw_exp_t)(&zero_exp);
    break;
  case &Const_e(_): break;
  case &Var_e(qv,b): 
    try e->r = lookup_varmap(nv,qv)->r;
    catch { case Dict::Absent:
       toc_impos("Can't find %s in exp_to_c, Var\n", qvar2string(qv));
    }
    break;
  case &UnknownId_e(qv): toc_impos("unknownid");
  case &Primop_e(p,es):
    // Save Cyclone types -- needed for pointer arith stuff
    let old_typs = List::map(get_cyc_typ,es);
    // Translate args
    List::iter_c(exp_to_c,nv,es);
    switch (p) {
    case Size:
      exp_t arg = es->hd;
      switch (compress(arg->topt->v)) {
      case &ArrayType(ArrayInfo{_,_,e2,_,_}): 
        // FIX: copy the expression e2 here.
        e->r = e2->r;  break;
      case &PointerType(PtrInfo(elt_typ,_,PtrAtts(_,nbl,bound,zt,_))):
	switch(conref_def(bounds_one,bound)) {
	case DynForward_b: // retrieve (last_plus_one - curr) via runtime call
	  e->r = fncall_exp_r(_get_dynforward_size_e,
                              list(es->hd, 
                                   sizeoftyp_exp(typ_to_c(elt_typ),DL)));
	  break;
        case DynEither_b: // same as above
	  e->r = fncall_exp_r(_get_dyneither_size_e,
                              list(es->hd, 
                                   sizeoftyp_exp(typ_to_c(elt_typ),DL)));
          break;
	case &Upper_b(e2): 
          // when zero-terminated, we have to call "strlen"
          if (conref_def(false,zt)) {
            e->r = fncall_exp_r(_get_zero_arr_size_e,list(es->hd,e2));
          } else if (conref_def(false,nbl)) {
            // careful! when this is a nullable pointer, the size might be 0
            e->r = conditional_exp_r(arg,e2,uint_exp(0,DL));
          } else {
            e->r = e2->r; break; // compile-time evaluation
          }
	  break;
	case &AbsUpper_b(_): unimp("toc: size of AbsUpper_b");
	}
	break;
      default: 
	toc_impos("size primop applied to non-array %s (%s)",
                  typ2string(arg->topt->v),typ2string(arg->topt->v)); 
      }
      break;
    case Plus:
      // only translation is for ? or ?+- pointers or zero-terminated arrays
      //   _dynxxx_ptr_plus(e1,sizeof(elt_typ),e2)
      // FIX: allow arithmetic on t ? types at top-level!
      switch (compress(old_typs->hd)) {
      case &PointerType(PtrInfo(elt_typ,_,PtrAtts(_,_,b,zt,_))):
        switch (conref_def(bounds_one,b)) {
        case DynForward_b:
          exp_t e1 = es->hd;
          exp_t e2 = es->tl->hd;
          e->r = fncall_exp_r(_dynforward_ptr_plus_e,
                              list(e1,sizeoftyp_exp(typ_to_c(elt_typ),DL),e2));
          break;
        case DynEither_b:
          exp_t e1 = es->hd;
          exp_t e2 = es->tl->hd;
          e->r = fncall_exp_r(_dyneither_ptr_plus_e,
                              list(e1,sizeoftyp_exp(typ_to_c(elt_typ),DL),e2));
          break;
        case &Upper_b(esz):
          if (conref_def(false,zt)) {
            exp_t e1 = es->hd;
            exp_t e2 = es->tl->hd;
            e->r = fncall_exp_r(_zero_arr_plus_e,list(e1,esz,e2));
          }
          break;
	case &AbsUpper_b(_): unimp("toc: plus on AbsUpper_b");
        }
        break;
      default:
        break;
      }
      break;
    case Minus:
      // only translation is for ? or ?- pointers.
      // if e2 is not a tagged array, do just like plus of negation,
      // else result type is unsigned int, so subtract curr fields
      type_t elt_typ = VoidType;
      bool forward_only = false;
      if(is_tagged_pointer_typ_elt(old_typs->hd,&elt_typ,&forward_only)) {
	exp_t e1 = es->hd;
	exp_t e2 = es->tl->hd;
        bool forward_only = false;
	if(is_tagged_pointer_typ(old_typs->tl->hd,&forward_only)) {
	  e1->r = aggrmember_exp_r(new_exp(e1->r,DL),curr_sp);
	  e2->r = aggrmember_exp_r(new_exp(e2->r,DL),curr_sp);
	  e->r  = divide_exp(copy_exp(e),
			     sizeoftyp_exp(typ_to_c(elt_typ),DL),DL)->r;
	} else {
          if (forward_only)
            terr(e->loc, "subtraction not allowed on forward-only ? pointer");
	  e->r = fncall_exp_r(_dyneither_ptr_plus_e,
                              list(e1,sizeoftyp_exp(typ_to_c(elt_typ),DL),
                                   prim1_exp(Minus,e2,DL)));
	}
      }
      break;
    case Eq: 
    case Neq: 
    case Gt: 
    case Gte: 
    case Lt: 
    case Lte: 
      // need to extract .curr field of tagged arrays for comparisons
      exp_t e1 = es->hd;
      exp_t e2 = es->tl->hd;
      type_t t1 = old_typs->hd;
      type_t t2 = old_typs->tl->hd;
      bool forward_only = false;
      if (is_tagged_pointer_typ(t1,&forward_only))
	e1->r = aggrmember_exp_r(new_exp(e1->r,DL),curr_sp);
      if (is_tagged_pointer_typ(t2,&forward_only))
	e2->r = aggrmember_exp_r(new_exp(e2->r,DL),curr_sp);
      break;
    default: break; //skip
    }
    break;
  case &Increment_e(e2,incr):
    type_t e2_cyc_typ = e2->topt->v;
    // we need to worry about the case where e2 is of the form
    // *ea or ea[eb] and ea is a zero-terminated pointer, for
    // then we need to know that the inc/dec doesn't destroy the
    // trailing 0.  See the special code in the AssignOp_e case.
    // To combat this, I'm simply disallowing it.  
    type_t ptr_type = VoidType;
    type_t elt_type = VoidType;
    bool is_dynforward = false;
    bool is_dyneither = false;
    string_t incr_str = "increment";
    if (incr == PreDec || incr == PostDec) incr_str = "decrement";
    if (is_zero_ptr_deref(e2,&ptr_type,&is_dynforward,&is_dyneither,
                          &elt_type)) {
      Tcutil::terr(e->loc,"in-place %s is not supported when dereferencing a zero-terminated pointer", incr_str);
      toc_impos("in-place inc on zero-term");
    }
    exp_to_c(nv,e2);
    // only t ? or zero-terminated types are translated funny, 
    // note that e2 is an lvalue!
    type_t elt_typ = VoidType;
    bool forward_only = false;
    if(is_tagged_pointer_typ_elt(old_typ,&elt_typ,&forward_only)) {
      _ fn_e;
      int change = 1;
      if (forward_only) {
        if (incr == PostDec || incr == PreDec)
          Tcutil::terr(e->loc,"decrement not allowed on forward ? pointer");
        fn_e = (incr == PostInc) ? _dynforward_ptr_inplace_plus_post_e
          : _dynforward_ptr_inplace_plus_e;
      } else {
        fn_e = (incr==PostInc || incr==PostDec) ? 
          _dyneither_ptr_inplace_plus_post_e : _dyneither_ptr_inplace_plus_e;
        if (incr == PreDec || incr == PostDec) 
          change = -1;
      }
      e->r = fncall_exp_r(fn_e, list(address_exp(e2,DL),
                                     sizeoftyp_exp(typ_to_c(elt_typ),DL),
                                     signed_int_exp(change,DL)));
    } else if (is_zero_pointer_typ_elt(old_typ,&elt_typ)) {
      // e.g, x++ becomes _zero_arr_inplace_plus_post(x,1)
      let fn_e = (incr == PostInc) ? _zero_arr_inplace_plus_post_e :
        _zero_arr_inplace_plus_e;
      e->r = fncall_exp_r(fn_e, list(e2,signed_int_exp(1,DL)));
    } else if(elt_typ == VoidType && !is_lvalue(e2)) {
      lvalue_assign(e2,NULL,incr_lvalue,incr);
      e->r = e2->r;
    }
    break;
  case &AssignOp_e(e1,popt,e2):
    // FIX: not sure all these special-cases work right *together*...
    // 
    // We need to know whether or not the expression is of the form
    // *ea op= e2 or ea[eb] op= e2 where ea is a zero-terminated pointer.
    // The reason is that we need to ensure not only that the pointer
    // is in bounds, but also, if it's pointing to the last element 
    // (i.e., the zero) then the value written in should continue to
    // be zero.  So, for instance, if we have *ea = e2, then either ea
    // can't point to the last element or e2 must be 0.  If we have
    // *ea op= e2 then we need to know that either ea can't point to
    // the last element or (0 op= e2) is 0.
    type_t ptr_type = VoidType;
    type_t elt_type = VoidType;
    bool is_dynforward = false;
    bool is_dyneither = false;
    if (is_zero_ptr_deref(e1,&ptr_type,&is_dynforward,&is_dyneither,
                          &elt_type)) {
      zero_ptr_assign_to_c(nv, e, e1, popt, e2, ptr_type, is_dynforward, 
                           is_dyneither, elt_type);
      return;
    } 
    // See if e1 is a polymorphic field (i.e., is an instantiated type
    // variable) -- if so, coerce e2 to void*.
    bool e1_poly    = is_poly_project(e1);
    type_t  e1_old_typ = e1->topt->v;
    type_t  e2_old_typ = e2->topt->v;
    exp_to_c(nv,e1); 
    exp_to_c(nv,e2);
    // special case for pointer arithmetic of t ? or zero-terminated types
    bool done = false;
    if(popt != NULL) {
      type_t elt_typ = VoidType;
      bool forward_only = false;
      if(is_tagged_pointer_typ_elt(old_typ,&elt_typ,&forward_only)) {
        _ change;
        switch(popt->v) {
        case Plus:  change = e2; break;
        case Minus: 
          if (forward_only)
            Tcutil::terr(e->loc,"subtraction not allowed on forward ? pointers");
          change = prim1_exp(Minus,e2,DL); break;
        default:    toc_impos("bad t ? pointer arithmetic");
        }
        done = true;
        // FIX: Is e1 definitely still an lvalue? Probably not!!
        let fn_e = forward_only ? _dynforward_ptr_inplace_plus_e :
          _dyneither_ptr_inplace_plus_e;
        e->r = fncall_exp_r(fn_e,list(address_exp(e1,DL),
                                      sizeoftyp_exp(typ_to_c(elt_typ),DL),
                                      change));
      } else if (is_zero_pointer_typ_elt(old_typ,&elt_typ)) {
        // We're doing x += e where x is a zero-terminated pointer.
        // Make sure we don't run off the end.
        switch (popt->v) {
        case Plus: 
          done = true;
          e->r = fncall_exp_r(_zero_arr_inplace_plus_e,list(e1,e2));
          break;
        default: toc_impos("bad zero-terminated pointer arithmetic");
        }
      }
    }
    if(!done) {
      // this cast is necessary to avoid gcc warnings
      if (e1_poly) 
        e2->r = cast_it_r(void_star_typ(), new_exp(e2->r,DL));
      // The typechecker guarantees that e1 starts out as an lvalue, but
      // the translation might have to insert casts, NULL checks,
      // declarations of temps, bound checks, etc.  If so we look into e1,
      // find the lvalue, and put the assignment there.
      if (!is_lvalue(e1)) {
        lvalue_assign(e1,NULL,assignop_lvalue,new{$(popt,e2)});
        e->r = e1->r;
      }
    }
    break;
  case &Conditional_e(e1,e2,e3):
    exp_to_c(nv,e1);
    exp_to_c(nv,e2);
    exp_to_c(nv,e3);
    break;
  case &And_e(e1,e2):
    exp_to_c(nv,e1);
    exp_to_c(nv,e2);
    break;
  case &Or_e(e1,e2):
    exp_to_c(nv,e1);
    exp_to_c(nv,e2);
    break;
  case &SeqExp_e(e1,e2):
    exp_to_c(nv,e1);
    exp_to_c(nv,e2);
    break;
  case &UnknownCall_e(e1,es): fallthru(e1,es);
  case &FnCall_e(e1,es,NULL):
    exp_to_c(nv,e1);
    List::iter_c(exp_to_c,nv,es);
    break;
  case &FnCall_e(e1,es,&VarargCallInfo{num_varargs,injectors,vai}):
    // if vai->inject:
    //    t vn = injector[n](es[n])
    //    ...
    //    t v0 = injector[0](es[n-num_varargs+1])
    //    t argv[num_varargs] = {&v0, ..., &vn};
    // else
    //    t argv[num_varargs] = {es[n-num_varargs+1], ..., es[n]};
    // e1(es[0], ..., es[n-num_varargs], tag_dynforward(argv, sizeof(t), num_varargs));
    region r {
      qvar_t argv     = temp_var();
      exp_t  argvexp  = var_exp(argv,DL);
      exp_t  num_varargs_exp = uint_exp(num_varargs,DL);
      type_t cva_type = typ_to_c(vai->type);
      type_t arr_type = array_typ(cva_type,mt_tq,num_varargs_exp,false_conref,
                                  NULL);

      int num_args     = List::length(es);
      int num_normargs = num_args - num_varargs;

      // build argument list and set es to the varargs portion
      list_t<exp_t> new_args = NULL;
      for(int i=0; i < num_normargs; ++i, es=es->tl) {
	exp_to_c(nv,es->hd);
	new_args = new List(es->hd, new_args);
      }
      new_args = new List(fncall_exp(_tag_dynforward_e,
				     list(argvexp, 
					  sizeoftyp_exp(cva_type,DL), 
					  num_varargs_exp), DL),
			  new_args);
      new_args = imp_rev(new_args);
      // make the function call
      exp_to_c(nv,e1);
      stmt_t s = exp_stmt(fncall_exp(e1,new_args,DL),DL);
     
      // make the declarations and prepend them
      if(vai->inject) {
	tuniondecl_t tud;
	switch(compress(vai->type)) {
	case &TunionType(TunionInfo(KnownTunion(&x),_,_)): tud = x; break;
	default: toc_impos("toc: unknown tunion in vararg with inject");
	}
	qvar_t ? vs = rnew(r) {for i < num_varargs : temp_var()};
	// declare argv = {&v1,&v2,...,&vnum_varargs}
	let array_args = NULL;
	for(int i=num_varargs-1; i >= 0; --i)
	  array_args = new List(make_dle(address_exp(var_exp(vs[i],DL),DL)),
				array_args);
	s = declare_stmt(argv, arr_type, unresolvedmem_exp(NULL,array_args,DL),
			 s,DL);
	// evaluate varargs (notice we're using a screwy evaluation order now)
	for (int i=0; es != NULL; es = es->tl, injectors = injectors->tl, ++i) {
	  exp_t  arg      = es->hd;
	  type_t arg_type = arg->topt->v;
	  qvar_t var      = vs[i];
	  exp_t  varexp   = var_exp(var,DL);
          let &Tunionfield{qv,tqts,_,_} = injectors->hd;
          type_t field_typ = typ_to_c((*tqts->hd)[1]);
	  exp_to_c(nv,arg);
          if (is_void_star(field_typ))
            arg = cast_it(field_typ,arg);
	  // DAN: We don't use an initializer b/c we're afraid of the GCC bug,
	  //   but I doubt it would happen and it causes a lot of gunk. :-(
          // struct qv_tag temp x;
          // x.tag = i; 
	  // x.f1  = arg;
          s = seq_stmt(assign_stmt(aggrmember_exp(varexp,fieldname(1),DL),
				   arg,DL),
		       s,DL);
          s = seq_stmt(assign_stmt(aggrmember_exp(varexp,tag_sp,DL),
				   tunion_tag(tud,qv,true),DL),
		       s,DL);
          s = declare_stmt(var,strctq(collapse_qvar_tag(qv,"_struct")), NULL,
			   s,DL);
        }
      } else {
	// we'd like: argv = { e1, ..., en} where ei is the ith vararg, but
	// alas I hit the GCC BUG when I did that (in one place in the 
	// pretty printer -- everything else went through fine).  So we do:
	// t argv[n];
	// argv[0] = e1; ... argv[n-1] = en;
	// Sigh.
	for(int i=0; es != NULL; es = es->tl, ++i) {
	  exp_to_c(nv, es->hd);
	  s = seq_stmt(assign_stmt(subscript_exp(argvexp,uint_exp(i,DL),DL),
				   es->hd, DL),
		       s, DL);
	}
	s = declare_stmt(argv, arr_type, NULL, s, DL);
	/*	list_t<exp_t,`r> array_args = NULL;
	for(; es != NULL; es = es->tl) {
	  exp_to_c(nv, es->hd);
	  array_args = rnew(r) List(es->hd, array_args);
	}
	array_args = List::imp_rev(array_args);
	let init = unresolvedmem_exp(NULL,List::map(make_dle,array_args),DL);
	s = declare_stmt(argv, arr_type, init,
			 s,DL);
	*/
      }
      
      e->r = stmt_exp_r(s);
    }
    break; 
  case &Throw_e(e1):
    // throw e -> (t)(throw(e)), the latter being a function call to throw
    exp_to_c(nv,e1);
    e->r = array_to_ptr_cast(typ_to_c(old_typ),newthrow_exp(e1),DL)->r;
    break;
  case &NoInstantiate_e(e1): exp_to_c(nv,e1); break;
  case &Instantiate_e(e1,ts):
    exp_to_c(nv,e1);
    // only cast when the instantiation has type variables,
    // you can cast other times, but you'll spit out much more C code.
    // Note: we don't bother to cast if type is void * anyway (b/c that's
    //       what type variables get translated to)
    // Note: we could be even more aggressive -- often the instantiated types
    //  don't show up in the translated type.  Moreover, we probably don't
    //  get warnings when the only use of the tyvar is as a parameter b/c
    //  it's just an implicit cast to void * (so long as inst type isn't int)
    for(; ts != NULL; ts = ts->tl) {
      kind_t k = typ_kind(ts->hd);
      if(k != EffKind && 
	 k != RgnKind && k != UniqueRgnKind && k != TopRgnKind) {
	switch(compress(ts->hd)) {
	case &VarType(_):    
	case &TunionType(_): continue;
	default: 
	  e->r = array_to_ptr_cast(typ_to_c(e->topt->v),e1,DL)->r;
	  break;
	}
	break;
      }
    }
    break;
  case &Cast_e(*t,e1,user_inserted,coercion):
    type_t old_t2  = e1->topt->v;
    type_t new_typ = *t;
    *t = typ_to_c(new_typ);
    exp_to_c(nv, e1);
    // a few Cyclone casts are translated into C effects other than casts:
    switch ($(compress(old_t2),compress(new_typ))) {
    case $(&PointerType(p1),&PointerType(p2)):
      let n1 = conref_def(false,p1.ptr_atts.nullable);
      let n2 = conref_def(false,p2.ptr_atts.nullable);
      let b1 = conref_def(bounds_one,p1.ptr_atts.bounds);
      let b2 = conref_def(bounds_one,p2.ptr_atts.bounds);
      let zt1 = conref_def(false,p1.ptr_atts.zero_term);
      let zt2 = conref_def(false,p2.ptr_atts.zero_term);
      bool p1_forward_only = false;
      bool p2_forward_only = false;
      switch($(b1,b2)) {
      case $(&Upper_b(b1), &Upper_b(b2)):
	if(n1 && !n2) {
	  if(is_toplevel(nv))
	    unimp("can't do NULL-check conversion at top-level");
	  // cast from t* to t@ -- run-time check: (t*)_check_null(e)
	  // flow analysis may not set annotation correctly here!
          // sanity checking:
          if (coercion != NonNull_to_Null) 
            impos("null-check conversion mis-classified: %s",exp2string(e));
          bool do_null_check = need_null_check(e1);
          if (do_null_check) {
            if (!user_inserted) 
              Tcutil::warn(e->loc,"inserted null check due to implicit "
                           "cast from * to @ type");
            e->r = cast_it_r(*t,fncall_exp(_check_null_e,
                                           new List(e1,NULL),DL));
          }
	}
        // FIX: the type-checker doesn't currently allow the case
        // where b1 > b2, but this can be allowed for zero-terminated
        // arrays (since the true length isn't known.)  Of course,
        // this obligates a run-time check.
	break;
      case $(&Upper_b(e2), DynForward_b): 
        p2_forward_only = true;
        fallthru(e2);
      case $(&Upper_b(e2), DynEither_b):
        // sanity checking
        if (coercion == NonNull_to_Null)
            impos("conversion mis-classified as null-check: %s",exp2string(e));
	if(is_toplevel(nv)) {
	  // can't use a function at top-level and don't want macros
          if (zt1 && !p2.elt_tq.real_const && !zt2) {
            // If p2 is not zero-terminated and not const, then we subtract
            // one from the size so that no one can write the last location.
            e2 = prim2_exp(Minus,e2,uint_exp(1,DL),DL);
          }
	  e->r = make_toplevel_dyn_arr(old_t2,e2,e1,p2_forward_only)->r;
	} else {
          let tag_e = p2_forward_only ? _tag_dynforward_e : _tag_dyneither_e;
	  // cast from t*{n} or t@{n} to t? or t?+-
          if (zt1) {
            // if p1 is zero-terminated then calculate the size dynamically:
            //   ({ t *x = e1;
            //      _dynxxx_ptr_arr(x, sizeof(t), _get_zero_arr_size(x,n));
            //   })
            let x = temp_var();
            let x_exp = var_exp(x,DL);
            let arg3 = fncall_exp(_get_zero_arr_size_e,list(x_exp,e2),DL);
            if (!zt2 && !p2.elt_tq.real_const) {
              // If p2 is not zero-terminated and not const, then we subtract
              // one from the size so that no one can write the last location.
              arg3 = prim2_exp(Minus,arg3,uint_exp(1,DL),DL);
            }
            let arg2 = sizeoftyp_exp(typ_to_c(p2.elt_typ),DL);
            let tg_exp = fncall_exp(tag_e,list(x_exp,arg2,arg3),DL);
            let s = exp_stmt(tg_exp,DL);
            s = declare_stmt(x,typ_to_c(old_t2),e1,s,DL);
            e->r = stmt_exp_r(s);
          } else {
            // build the t ? struct
            e->r = fncall_exp_r(tag_e,
                                list(e1, 
                                     sizeoftyp_exp(typ_to_c(p2.elt_typ),DL),
                                     e2));
          }
        }
	break;
      case $(DynForward_b, &Upper_b(e2)):
        p1_forward_only = true;
        fallthru(e2);
      case $(DynEither_b, &Upper_b(e2)):
	if(is_toplevel(nv))
	  unimp("can't coerce t? to t* or t@ at the top-level");
        // When we have t?ZEROTERM and are casting to 
        // t*{e2} or t@{e2} *without* the ZEROTERM, then we
        // can't allow e2 to be the actual size of the array -- 
        // it needs to be one less to ensure that you can't
        // overwrite the trailing 0.  We achieve this by 
        // incrementing e2 by one.  That is if x has type t?Z,
        // and we're casting it to t@{2}, then we'd better check
        // that the size is at least 2+1=3.
        let new_e2 = e2;
        if (zt1 && !zt2) {
          new_e2 = add_exp(e2,uint_exp(1,NULL),NULL);
        }
	// cast from t ? to t* or t@ -- run-time check: 
	// for t*: (t *)_untag_arr(e1, sizeof(t), new_e2)
	// for t@: (t *)_check_null(_untag_arr(e1, sizeof(t), new_e2))
        let untag_e = p1_forward_only ? _untag_dynforward_ptr_e : 
          _untag_dyneither_ptr_e;
	let ptr_exp = fncall_exp(untag_e,
				 list(e1,
                                      sizeoftyp_exp(typ_to_c(p1.elt_typ),DL),
				      new_e2), DL);
	if(n2) 
	  ptr_exp->r = fncall_exp_r(_check_null_e,
                                    new List(copy_exp(ptr_exp), NULL));
	e->r = cast_it_r(*t, ptr_exp);
	break;
      // If p1 is zero-terminated and p2 is not, then p2 had better
      // be const or else we have to decrement its size by 1.
      case $(DynForward_b, DynForward_b):
        p1_forward_only = true; 
        p2_forward_only = true;
        goto DynCast;
      case $(DynForward_b, DynEither_b):
        p1_forward_only = true;
        goto DynCast;
      case $(DynEither_b, DynForward_b):
        p2_forward_only = true;
        goto DynCast;
      case $(DynEither_b, DynEither_b):
DynCast:
        if (zt1 && !zt2 && !p2.elt_tq.real_const) {
          if (is_toplevel(nv))
            unimp("can't coerce a ZEROTERM to a non-const NOZEROTERM pointer at toplevel");
          let td_e = p1_forward_only ? _dynforward_ptr_decrease_size_e :
            _dyneither_ptr_decrease_size_e;
          e->r = fncall_exp_r(td_e,
                              list(e1,sizeoftyp_exp(typ_to_c(p1.elt_typ),DL),
                                   uint_exp(1,DL)));
          if (p1_forward_only != p2_forward_only) 
            if (p1_forward_only)
              e->r = fncall_exp_r(_dynforward_to_dyneither_e,
                                  list(copy_exp(e)));
            else 
              e->r = fncall_exp_r(_dyneither_to_dynforward_e,
                                  list(copy_exp(e)));
          
        } else if (p1_forward_only != p2_forward_only) {
          if (is_toplevel(nv))
            unimp("can't coerce between ? and ?+- at toplevel");
          if (p1_forward_only)
            e->r = fncall_exp_r(_dynforward_to_dyneither_e,list(e1));
          else 
            e->r = fncall_exp_r(_dyneither_to_dynforward_e,list(e1));
        }
	break;
      case $(&AbsUpper_b(t1),&AbsUpper_b(t2)): 
	if(n1 && !n2) {
	  if(is_toplevel(nv))
	    unimp("can't do NULL-check conversion at top-level");
	  // cast from t* to t@ -- run-time check: (t*)_check_null(e)
	  // flow analysis may not set annotation correctly here!
          // sanity checking:
          if (coercion != NonNull_to_Null) 
            impos("null-check conversion mis-classified: %s",exp2string(e));
          bool do_null_check = need_null_check(e1);
          if (do_null_check) {
            if (!user_inserted) 
              Tcutil::warn(e->loc,"inserted null check due to implicit "
                           "cast from * to @ type");
            e->r = cast_it_r(*t,fncall_exp(_check_null_e,
                                           new List(e1,NULL),DL));
          }
	}
	break;
      case $(&AbsUpper_b(_),_):
	unimp("%s: toc, cast from AbsUpper_b",Position::string_of_segment(e1->loc));
      case $(_,&AbsUpper_b(_)): break; // type-checker must have said okay
      }
      break;
    case $(&PointerType(p1), &IntType(_,_)):
      switch(conref_def(bounds_one,p1.ptr_atts.bounds)) {
      case DynForward_b: // cast t? to int -- cast curr field to int
      case DynEither_b: // cast t? to int -- cast curr field to int
	e1->r = aggrmember_exp_r(new_exp(e1->r,e1->loc),curr_sp); break;
      default: break;
      }
      break;
    default: break;
    }
    break;

  case &Address_e(e1):
    // When e1 is a struct or a tuple, this is really a "new".
    switch (e1->r) {
    case &Struct_e(tdn,ts,es,_):
      if (is_toplevel(nv))
	unimp("%s: & on non-identifiers at the top-level",
              Position::string_of_segment(e1->loc));
      e->r = init_struct(nv, e1->topt->v, ts != NULL, true, NULL, es, tdn)->r;
      break;
    case &Tuple_e(es):
      if (is_toplevel(nv))
	unimp("%s: & on non-identifiers at the top-level",
              Position::string_of_segment(e1->loc));
      e->r = init_tuple(nv, true, NULL, es)->r;
      break;
    default: // it's actually an address-of.
      exp_to_c(nv,e1);
      if(!is_lvalue(e1)) {
	lvalue_assign(e1,NULL,address_lvalue,true);
	// the wrong cast got pushed out, so as a kludge, just re-cast
	e->r = cast_it_r(typ_to_c(e->topt->v),e1);
      }
      break;
    }
    break;
  case &New_e(rgnopt,e1):
    // FIX: need to deal with zero-terminated arrays
    if (is_toplevel(nv))
      unimp("%s: new at top-level", Position::string_of_segment(e1->loc));
    switch (e1->r) {
    case &Array_e(dles0):
      // FIX: MAY BE SUSCEPTIBLE TO GCC BUG!
      // ({ t *x = (t*)(malloc(sizeof(t)*length(dles0)));
      //    x[d1] = e1; ... x[dn] = en; x; })
      let x = temp_var();
      let xexp = var_exp(x,DL);
      let s = init_array(nv, xexp, dles0, exp_stmt(xexp,DL));
      type_t old_elt_typ;
      switch (compress(old_typ)) {
      case &PointerType(PtrInfo{et,tq,PtrAtts(_,_,_,zt,_)}):
	old_elt_typ = et; break;
      default:
	old_elt_typ =
          toc_impos("exp_to_c:new array expression doesn't have ptr type");
      }
      type_t elt_typ=typ_to_c(old_elt_typ);
      let ptr_typ = cstar_typ(elt_typ,mt_tq);
      let e2 = times_exp(sizeoftyp_exp(elt_typ,DL),
                         signed_int_exp(List::length(dles0),DL),DL);
      exp_t e1;
      if (rgnopt == NULL || no_regions) {
        e1 = malloc_exp(old_elt_typ,e2);
      } else {
        exp_t r = (exp_t)rgnopt;
        exp_to_c(nv,r);
        e1 = rmalloc_exp(r,e2);
      }
      //      let e0 = cast_it(ptr_typ,e1);
      e->r = stmt_exp_r(declare_stmt(x,ptr_typ,e1,s,DL));
      break;

    case &Comprehension_e(vd,e1,e2,zero_term):
      // Drop the "tagged_ptr_t" struct stuff when type is a fixed-size array.
      // Slight twist for zero-terminated arrays -- must allocate one more
      // element and initialize the last element to 0.
      // ({ unsigned int max = e1;
      //    t *a = (t*)malloc(sizeof(t)*max);
      //    struct tagged_arr b = _tag_arr(a);
      //    unsigned int x ;
      //    for (x = 0; x < max; x++) a[x] = e2;
      //    b; })
      bool is_dynforward_ptr = false;
      bool is_dyneither_ptr = false;
      switch (compress(old_typ)) {
      case &PointerType(PtrInfo{et,tq,PtrAtts(_,_,b,zt,_)}):
        is_dynforward_ptr = (conref_def(bounds_one,b) == DynForward_b);
        is_dyneither_ptr = (conref_def(bounds_one,b) == DynEither_b);
        break;
      default: toc_impos("exp_to_c: comprehension not an array type");
      }
      qvar_t max = temp_var();
      qvar_t a = temp_var();
      type_t old_elt_typ = e2->topt->v;
      type_t elt_typ = typ_to_c(old_elt_typ);
      type_t ptr_typ = cstar_typ(elt_typ,mt_tq);
      exp_to_c(nv,e1);
      let malloc_size_exp = var_exp(max,DL);
      // add one to max for zero-terminated arrays
      if (zero_term) 
        malloc_size_exp = add_exp(malloc_size_exp,uint_exp(1,DL),DL);
      stmt_t s = init_comprehension(nv, var_exp(a,DL), vd, var_exp(max,DL), 
                                    e2, zero_term, skip_stmt_dl(), true);
      // FIX:  casts needed on exp_opts
      region r {
        list_t<$(qvar_t,type_t,exp_opt_t)@`r,`r> decls = 
          rnew(r) List(rnew(r) $(max,uint_typ,(exp_opt_t)e1),NULL);
        exp_t ai;
        if (rgnopt == NULL || no_regions)
          ai = malloc_exp(old_elt_typ,
			  fncall_exp(_check_times_e,
				     list(sizeoftyp_exp(elt_typ,DL),
					  malloc_size_exp), DL));
        else {
          exp_t r = (exp_t)rgnopt;
          exp_to_c(nv,r);
          ai = rmalloc_exp(r, fncall_exp(_check_times_e,
					 list(sizeoftyp_exp(elt_typ,DL),
					      malloc_size_exp), DL));

        }
        exp_t ainit = cast_it(ptr_typ,ai);
        decls = rnew(r) List(rnew(r) $(a,ptr_typ,(exp_opt_t)ainit),decls);
        if (is_dynforward_ptr || is_dyneither_ptr) {
          let b = temp_var();
          let t = typ_to_c(old_typ);
          let tag = is_dynforward_ptr ? _tag_dynforward_e : _tag_dyneither_e;
          let binit = 
	    fncall_exp(tag,
		       list(var_exp(a,DL), sizeoftyp_exp(elt_typ, DL), 
                            malloc_size_exp), DL);
          decls = rnew(r) List(rnew(r) $(b,t,(exp_opt_t)binit),decls);
          s = seq_stmt(s,exp_stmt(var_exp(b,DL),DL),DL);
        } else // not a tagged array -- just return a
          s = seq_stmt(s,exp_stmt(var_exp(a,DL),DL),DL);
        for (let ds = decls; ds != NULL; ds = ds->tl) {
          let $(d0,d1,d2) = *(ds->hd);
          s = declare_stmt(d0,d1,d2,s,DL);
        }
        e->r = stmt_exp_r(s);
      }
      break;
    case &Struct_e(tdn,ts,es,_):
      // try to avoid the GCC bug
      e->r = init_struct(nv, e1->topt->v, ts != NULL, true, rgnopt, es, tdn)->r;
      break;
    case &Tuple_e(es):
      // try to avoid the GCC bug
      e->r = init_tuple(nv, true, rgnopt, es)->r;
      break;
    default:
      // treated just like an array of size 1
      // FIX: MAY BE SUSCEPTIBLE TO GCC BUG!
      // ({ t *x = (t*)(malloc(sizeof(t)));
      //    x[0] = e1; x; })
      type_t old_elt_typ = e1->topt->v;
      type_t elt_typ = typ_to_c(old_elt_typ);
      // build up the malloc expression: (t *)(malloc(sizeof(t)))
      let x = temp_var();
      let xexp = var_exp(x,DL);
      exp_t mexp = sizeofexp_exp(deref_exp(xexp,DL),DL);
      exp_t inner_mexp = mexp;
      if (rgnopt == NULL || no_regions) 
        mexp = malloc_exp(old_elt_typ,mexp);
      else {
        exp_t r = (exp_t)rgnopt;
        exp_to_c(nv,r);
        mexp = rmalloc_exp(r,mexp);
      }
      //      mexp = cast_it(cstar_typ(elt_typ,mt_tq));
      // For tagged arrays, I have gotten burned by the GCC BUG 
      // (they're structs), so we special-case it right here
      // I HAVE NO IDEA IF I'M CATCHING ENOUGH CASES.
      bool done = false;
      bool forward_only = false;
      switch(e1->r) {
      case &Cast_e(t2,e2,_,_):
	switch($(compress(t2),compress(e2->topt->v))) {
	case $(&PointerType(PtrInfo{arr_typ,_,PtrAtts(_,_,bc,_,_)}),
	       &PointerType(PtrInfo{_,_,PtrAtts(_,_,be,_,_)})):
	  switch($(conref_def(bounds_one,bc),conref_def(bounds_one,be))) {
	  case $(DynForward_b,&Upper_b(arr_sz)):
            forward_only = true;
            fallthru(arr_sz);
	  case $(DynEither_b,&Upper_b(arr_sz)):
	    exp_to_c(nv,e2);
	    inner_mexp->r = sizeoftyp_exp_r(elt_typ);
	    done = true;
            let _init_f = forward_only ? 
              _init_dynforward_ptr_e : _init_dyneither_ptr_e;
	    e->r = fncall_exp_r(_init_f,
                                list(mexp, e2,
                                     sizeoftyp_exp(typ_to_c(arr_typ),DL),
                                     arr_sz));
	    break;
	  default: break;
	  }
	break;
	default: break;
	}
	break;
      default: break;
      }
      if(!done) {
	let s = exp_stmt(xexp,DL);
	let e_index = signed_int_exp(0,DL);
	exp_to_c(nv,e1);
	s = seq_stmt(assign_stmt(subscript_exp(xexp,e_index,DL),
				 e1,DL),s,DL);
	let ptr_typ = cstar_typ(elt_typ,mt_tq);
	e->r = stmt_exp_r(declare_stmt(x,ptr_typ,mexp,s,DL));
      }
      break;
    }
    break;
  case &Sizeofexp_e(e1): exp_to_c(nv,e1); break;
  case &Sizeoftyp_e(t):  e->r = new Sizeoftyp_e(typ_to_c_array(t));  break;
  case &Gentyp_e(_,_): toc_impos("__gen() in code generator"); 
  case &Offsetof_e(t,&StructField(n)): 
    e->r = new Offsetof_e(typ_to_c_array(t),new StructField(n)); break;
  case &Offsetof_e(t,&TupleIndex(n)): 
    switch(compress(t)) {
    case &AggrType(AggrInfo(info,_)):
      let ad = get_known_aggrdecl(info);
      if(ad->impl==NULL)
	toc_impos("struct fields must be known");
      fallthru(ad->impl->fields);
    case &AnonAggrType(_,fields):
      let nth_field = List::nth(fields,n);
      e->r = new Offsetof_e(typ_to_c_array(t),new StructField(nth_field->name));
      break;
    case &TupleType(_):
      e->r = new Offsetof_e(typ_to_c_array(t),new StructField(fieldname(n+1)));
      break;
    case &TunionFieldType(_):
      if(n == 0)
	e->r = new Offsetof_e(typ_to_c_array(t),new StructField(tag_sp));
      else
	e->r = new Offsetof_e(typ_to_c_array(t),new StructField(fieldname(n)));
      break;
    default: toc_impos("impossible type for offsetof tuple index");
    }
    break;
  case &Deref_e(e1):
    let e1_typ = compress(e1->topt->v);
    switch (e1_typ) {
    case &PointerType(PtrInfo{t2,tq,PtrAtts(rgn,cr,b,zt,_)}):
      switch (conref_def(bounds_one,b)) {
      case &Upper_b(_):
	bool do_null_check = need_null_check(e1);
	exp_to_c(nv,e1);
        if (do_null_check) {
          if (warn_all_null_deref)
            warn(e->loc, "inserted null check due to dereference");
	  // *((t *)_check_null(e))
          e1->r = cast_it_r(typ_to_c(e1_typ),
                            fncall_exp(_check_null_e,
                                       new List(copy_exp(e1),NULL),DL));
        }
        // Note that a null check is sufficient for zero-terminated arrays
        // too, because we guarantee that there's something to read here,
        // even if it's just a 0.  Note that writes are handled specially
        // by the AssignOp_e case.  
	break;
      case DynForward_b:
      case DynEither_b:
	// do it as e1[0], could share all the 0's but who cares
	let ind_e = uint_exp(0,DL);
	ind_e->topt = new Opt(uint_typ);
	e->r = subscript_exp_r(e1, ind_e);
	exp_to_c(nv,e);
	break;
      case &AbsUpper_b(_): unimp("exp_to_c: deref w/ AbsUpper_b");
      }
      break;
    default: toc_impos("exp_to_c: Deref: non-pointer");
    }
    break;
  case &AggrMember_e(e1,f):
    exp_to_c(nv, e1);
    if(is_poly_project(e))
      e->r = array_to_ptr_cast(typ_to_c(e->topt->v),new_exp(e->r,DL),DL)->r;
    break;
  case &AggrArrow_e(e1,f):
    type_t e1typ = compress(e1->topt->v);
    bool do_null_check = need_null_check(e1);
    exp_to_c(nv, e1);
    bool is_poly = is_poly_project(e); // decide before mutating e
    bool forward_only = false;
    let PtrInfo{ta,tq,PtrAtts(rgn,bcr,b,zt,_)} = get_ptr_type(e1typ);
    switch (conref_def(bounds_one,b)) {
    case &Upper_b(esz):
      // the type-checker should've ensured the size is at least 1
      // FIX: on unknown, dynamic bounds check!
      let $(j,known) = Evexp::eval_const_uint_exp(esz);
      if(known) {
	if (j < 1)
	  impos("exp_to_c:  AggrArrow_e on pointer of size 0");
	if (do_null_check) {
          if (warn_all_null_deref)
            warn(e->loc, "inserted null check due to dereference");
	  // ((t *)_check_null(e))->f
	  e->r = aggrarrow_exp_r(cast_it(typ_to_c(e1->topt->v),
                                         fncall_exp(_check_null_e,
                                                    new List(e1,NULL),DL)),f);
	}
      } else {
	// very strang case: they may have used sizeof or offsetof to make
	// a zero-size array.  Yeah, that'll happen never.
	e->r = aggrarrow_exp_r(cast_it(typ_to_c(e1->topt->v),
	      fncall_exp(_check_known_subscript_null_e,
                         list(e1,esz,sizeoftyp_exp(ta,DL),uint_exp(0,DL)),
                         DL)), f);
      }
      break;
    case DynForward_b:
      forward_only = true; fallthru;
    case DynEither_b:
      // ((ta1 *)_check_unknown_subscript(e1, sizeof(ta1), 0))->f
      let _check_f = forward_only ? 
        _check_dynforward_subscript_e : _check_dyneither_subscript_e;
      type_t ta1 = typ_to_c_array(ta);
      e1->r = cast_it_r(cstar_typ(ta1,tq),
                        fncall_exp(_check_f,
                                   list(copy_exp(e1),
                                        sizeoftyp_exp(ta1,DL),
                                        uint_exp(0,DL)),
                                   DL));
      break;
    case &AbsUpper_b(_): unimp("exp_to_c: AggrArrow w/ AbsUpper_b");
    }
    if(is_poly)
      e->r = array_to_ptr_cast(typ_to_c(e->topt->v),new_exp(e->r,DL),DL)->r;
    break;
  case &Subscript_e(e1,e2):
    let e1_typ = compress(e1->topt->v);
    //fprintf(stderr,"subscript %s:",exp2string(e));
    //CfFlowInfo::print_relns(relns); fprintf(stderr,"\n");
    // e1 could be a tuple or an array of various sorts
    switch (e1_typ) {
    case &TupleType(ts):
      // e1->fi  where i = e2+1
      exp_to_c(nv, e1);
      exp_to_c(nv, e2);
      let $(i,known) = Evexp::eval_const_uint_exp(e2);
      if(!known)
	impos("unknown tuple subscript in translation to C");
      e->r = aggrmember_exp_r(e1,fieldname(i+1));
      break;
    case &PointerType(PtrInfo{ta,tq,PtrAtts(rgn,bcr,b,zt,_)}):
      let relns = get_relns(e1);
      bool in_bnds = false;
      switch (conref_def(bounds_one,b)) {
      case &AbsUpper_b(_): break;
      default:
	in_bnds = check_bounds(relns,e1,e2);
	if(warn_bounds_checks && !in_bnds) 
	  Tcutil::warn(e->loc,"bounds check necessary for %s", exp2string(e));
#ifdef BCE_DEBUG
      fprintf(stderr,"check bounds returned %s\n", in_bnds ? "true " : "false");
#endif
      }
      exp_to_c(nv, e1);
      exp_to_c(nv, e2);
      total_bounds_checks++;
      bool forward_only = false;
      switch (conref_def(bounds_one,b)) {
      case &Upper_b(esz):
        bool possibly_null = conref_def(false,bcr);
	type_t ta1 = typ_to_c(ta);
	type_t ta2 = cstar_typ(ta1, tq);
        if (in_bnds)
	  bounds_checks_eliminated++;
        // check if zero terminated
        else if (conref_def(false,zt))
          // *((ta2)_zero_arr_plus(e1, esz, e2)
          e->r = deref_exp_r(cast_it(ta2,
                                     fncall_exp(_zero_arr_plus_e,
                                                list(e1,esz,e2),DL)));
	else if(possibly_null) {
          if (warn_all_null_deref)
            warn(e->loc, "inserted null check due to dereference");
	  // *((ta2)_check_known_subscript_null(e1, esz, sizeof(ta), e2)
	  e->r = deref_exp_r(cast_it(ta2,
                                     fncall_exp(_check_known_subscript_null_e,
                                                list(e1,esz,
                                                     sizeoftyp_exp(ta1,DL),
                                                     e2),DL)));
	} else
	  // e1[_check_known_subscript_notnull(esz,e2)]
	  e2->r = fncall_exp_r(_check_known_subscript_notnull_e,
                               list(esz,copy_exp(e2)));
	break;
      case DynForward_b:
        forward_only = true;
        fallthru;
      case DynEither_b:
	type_t ta1 = typ_to_c_array(ta);
        if (in_bnds) {
          // there's no need for a null-check here either because
          // a NULL ? pointer has size 0
          bounds_checks_eliminated++;
          e->r = subscript_exp_r(cast_it(cstar_typ(ta1,tq),
                                         aggrmember_exp(e1,curr_sp,DL)),e2);
        } else {
          // *((ta1 *) _check_unknown_subscript(e1, sizeof(ta1), e2))
          let _check_f = forward_only ? 
            _check_dynforward_subscript_e : _check_dyneither_subscript_e;
          e->r = deref_exp_r(cast_it(cstar_typ(ta1,tq),
                                     fncall_exp(_check_f,
                                                list(e1,sizeoftyp_exp(ta1,DL),
                                                     e2),DL)));
        }
	break;
      case &AbsUpper_b(t): 
	// FIX: does not yet compute transitive closure
	switch(e2->annot) {
	case &CfFlowInfo::HasTagCmps(cl):
	  for(; cl != NULL; cl = cl->tl)
	    if(cl->hd->cmp == Lt && typecmp(cl->hd->bd,t)==0) {
	      in_bnds = true;
	      break;
	    }
	  break;
	default: break;
	}
	if(!in_bnds)
	  Tcutil::terr(e->loc,"cannot determine that subscript is in bounds");
	break;
      }
      break;
    default: toc_impos("exp_to_c: Subscript on non-tuple/array/tuple ptr");
    }
    break;
  case &Tuple_e(es):
    if(!is_toplevel(nv))
      e->r = init_tuple(nv,false,NULL,es)->r;
    else {
      // At top-level use an initializer
      // $(e1,...,en) -> {e1,...,en}
      let tqs = List::map(tup_to_c,es);
      let n = add_tuple_type(tqs);
      list_t<$(list_t<designator_t,`H>,exp_t)@`H,`H> dles = NULL;
      for (int i = 1; es != NULL; es = es->tl, i++) {
	exp_to_c(nv,es->hd);
	dles = new List(new $(NULL,es->hd),dles);
      }
      dles = List::imp_rev(dles);
      e->r = unresolvedmem_exp_r(NULL,dles);
    }
    break;
  case &Array_e(dles0):
    // An array not under a "new" -- should only occur in initializer positions.
    // {e1,...,en}
    e->r = unresolvedmem_exp_r(NULL,dles0);
    for (let dles = dles0; dles != NULL; dles = dles->tl) {
      let &$(_,e) = dles->hd;
      exp_to_c(nv,e);
    }
    break;
  case &Comprehension_e(vd,e1,e2,iszeroterm):
    // a comprehension not under a "new" -- should only be the case
    // when e1 is constant.  For now, e2 must be too...
    let $(sz,known) = Evexp::eval_const_uint_exp(e1);
    let elt_typ = typ_to_c(e2->topt->v);
    exp_to_c(nv,e2);
    list_t<$(list_t<designator_t>,exp_t)@> es = NULL;
    // generate an "empty" array intializer to avoid giant arrays
    if (!is_zero(e2)) {
      if(!known)
	Tcutil::terr(e1->loc, "cannot determine value of constant");
      for (unsigned int i = 0; i < sz; i++)
        es = new List(new $(NULL,e2),es);
      // for a zero-terminated comprehension, add in an implicit 0 to the end
      if (iszeroterm) {
        let ezero = cast_it(elt_typ,uint_exp(0,DL));
        es = List::imp_append(es,new List{new $(NULL,ezero), NULL});
      }
    }
    e->r = unresolvedmem_exp_r(NULL,es);
    break;
  case &Struct_e(tdn,ts,dles,sd):
    // Due to a GCC bug w.r.t. to nested designators, we expand this out
    // to ({ t temp; t.f1 = e1, ..., t.fn = en; t}).
    if(!is_toplevel(nv))
      e->r = init_struct(nv,old_typ,ts != NULL,false,NULL,dles,tdn)->r;
    else {
      // At top-level must create an initializer.  For MSVC, sort fields
      // and drop initializers (sorting okay b/c we're at top-level)
      if(sd == NULL)
	toc_impos("Struct_e: missing aggrdecl pointer");
      aggrdecl_t sd2 = (aggrdecl_t)sd;
      region rgn {
      let fields = Tcutil::resolve_struct_designators(rgn, e->loc, dles, 
                                                      sd2->impl->fields);
      // here is where we now sort
      let newdles = NULL;
      let sdfields = sd2->impl->fields;
      for(; sdfields!=NULL; sdfields=sdfields->tl)
	for (let fields2 = fields; fields2 != NULL; fields2 = fields2->tl) {
	  if((*fields2->hd)[0] == sdfields->hd) {
	    let &$(field,fieldexp) = fields2->hd;
	    let fieldtyp = field->type;
	    exp_to_c(nv,fieldexp);
	    if (is_void_star(fieldtyp))
	      fieldexp->r = 
                cast_it_r(void_star_typ(),new_exp(fieldexp->r,DL));
	    newdles = new List(new $(NULL,fieldexp), newdles);
	    break;
	  }
	}
      e->r = unresolvedmem_exp_r(NULL,imp_rev(newdles));
      }
    }
    break;
  case &AnonStruct_e(st,dles):
    list_t<aggrfield_t> fs;
    switch (compress(st)) {
    case &AnonAggrType(_,afs): fs = afs; break;
    default: toc_impos("anon struct has type %s",typ2string(st));
    }
    region rgn {
      let fields = Tcutil::resolve_struct_designators(rgn, e->loc, dles, fs);
      for (; fields != NULL; fields = fields->tl) {
        let &$(field,fieldexp) = fields->hd;
        let fieldtyp = field->type;
        exp_to_c(nv,fieldexp);
        if (is_void_star(fieldtyp))
          fieldexp->r = cast_it_r(void_star_typ(),new_exp(fieldexp->r,DL));
      }
      //for (let es = dles; es != NULL; es = es->tl)
      //  exp_to_c(nv,es->hd[1]);
      //FIX: this has GCC bug written all over it.
      e->r = unresolvedmem_exp_r(NULL,dles);
    }
    break;
  
  case &Tunion_e(NULL,tud,tuf) && !tud->is_flat:
    qvar_t qv = tuf->name;
    // non-value-carrying constructor
    exp_t tag_exp = tud->is_xtunion ? var_exp(qv,DL) : tunion_tag(tud,qv,false);
    e->r = tag_exp->r;
    break;
  case &Tunion_e(es,tud,tuf):
    type_t tunion_ctype;
    exp_t tag_exp;
    let x = temp_var();
    let xexp = var_exp(x,DL);
    exp_t member_exp;
    if (tud->is_flat) {
      tunion_ctype = unionq_typ(collapse_qvar_tag(tud->name,"_union"));
      tag_exp = tunion_tag(tud,tuf->name,true);
      let &$(_,v) = tuf->name;
      member_exp = aggrmember_exp(xexp,v,DL);
    } else {
      tunion_ctype = strctq(collapse_qvar_tag(tuf->name,"_struct"));
      tag_exp = (tud->is_xtunion) ? var_exp(tuf->name,DL) : 
        tunion_tag(tud,tuf->name,true);
      member_exp = xexp;
    }
    let tqts = tuf->typs;
    // we have to do this differently for the toplevel
    if (is_toplevel(nv)) {
      // {i, e1, ... , en};
      list_t<$(list_t<designator_t,`H>,exp_t)@`H,`H> dles = NULL;
      for(; es != NULL; es = es->tl, tqts = tqts->tl) {
	exp_t cur_e = es->hd;
	type_t field_typ = typ_to_c((*tqts->hd)[1]);
	exp_to_c(nv,cur_e);
	if (is_void_star(field_typ))
	  cur_e = cast_it(field_typ,cur_e);
	dles = new List(new $(NULL,cur_e),dles);
      }
      dles = new List(new $(NULL,tag_exp),imp_rev(dles));
      e->r = unresolvedmem_exp_r(NULL,dles);
      if (tud->is_flat) {
        e->r = cast_it_r(strctq(collapse_qvar_tag(tuf->name,"_struct")),
                         copy_exp(e));
      }
    } else {
      // value-carrying, non-flat constructor
      // ({ struct F x; x.tag = i; x.f1 = e1; ...; x.fn = en; x; })
      // flat constructor
      // ({ union T x; x.F.tag = i; x.F.f1 = e1; ...; x.F.fn = en; x; })
      // Due to GCC bug we can't just use a struct expression
      let rev_assign =
	new List(assign_stmt(aggrmember_exp(member_exp,tag_sp,DL),tag_exp, DL),
                 NULL);
      for (int i = 1; es != NULL; es = es->tl, i++, tqts = tqts->tl) {
	exp_t cur_e = es->hd;
	type_t field_typ = typ_to_c((*tqts->hd)[1]);
	exp_to_c(nv,cur_e);
	if (is_void_star(field_typ))
	  cur_e = cast_it(field_typ,cur_e);
	let a = assign_stmt(aggrmember_exp(member_exp,fieldname(i), DL),
			    cur_e,DL);
	rev_assign = new List(a,rev_assign);
      }
      let final_stmt = exp_stmt(xexp,DL);
      let s2         = seq_stmts(imp_rev(new List(final_stmt,rev_assign)),DL);
      e->r = stmt_exp_r(declare_stmt(x,tunion_ctype,NULL,s2,DL));
    }
    break;

  case &Enum_e(_,_,_):
  case &AnonEnum_e(_,_,_): break;

  case &Malloc_e(MallocInfo{is_calloc,rgnopt,topt,num_elts,is_fat}): 
    type_t t_c = typ_to_c(*topt);
    exp_to_c(nv,num_elts);
    // FIX: we shouldn't be able to calloc a zero-terminated array of
    // size less than 1.  
    if (is_fat) {
      let x = temp_var();
      let p = temp_var();
      exp_t pexp, xexp, rexp;
      if (is_calloc) {
        xexp = num_elts;
        if (rgnopt != NULL && !no_regions) {
          exp_t rgn = (exp_t)rgnopt;
          exp_to_c(nv,rgn);
          pexp = rcalloc_exp(rgn, sizeoftyp_exp(t_c,DL), var_exp(x,DL));
        } else {
          pexp = calloc_exp(*topt,sizeoftyp_exp(t_c,DL), var_exp(x,DL));
        }
        // FIX: should support callocing a ?+- pointer
        rexp = fncall_exp(_tag_dynforward_e, 
                          list(var_exp(p,DL),sizeoftyp_exp(t_c,DL),
                               var_exp(x,DL)), DL);
      } else {
        xexp = times_exp(sizeoftyp_exp(t_c,DL),num_elts,DL);
        if (rgnopt != NULL && !no_regions) {
          exp_t rgn = (exp_t)rgnopt;
          exp_to_c(nv,rgn);
          pexp = rmalloc_exp(rgn, var_exp(x,DL));
        } else { 
          pexp = malloc_exp(*topt, var_exp(x,DL));
        }
        // FIX: should support mallocing a ?+- pointer
        rexp = fncall_exp(_tag_dynforward_e, list(var_exp(p,DL),uint_exp(1,DL),
                                                  var_exp(x,DL)), DL);
      }
      let s = declare_stmt(x, uint_typ, xexp,
                           declare_stmt(p,cstar_typ(t_c,mt_tq),pexp,
                                        exp_stmt(rexp,DL),DL),DL);
      e->r = stmt_exp_r(s);
    } else {
      if (rgnopt != NULL && !no_regions) {
        exp_t rgn = (exp_t)rgnopt;
        exp_to_c(nv,rgn);
        e->r = rmalloc_exp(rgn, sizeoftyp_exp(t_c,DL))->r;
      } else {
        e->r = malloc_exp(*topt, sizeoftyp_exp(t_c,DL))->r;
      }
    }
    break;

  case &Swap_e(e1,e2):
    // for pointer values, do
    //   swap(e1,e2) --> _swap_kw(&e1,&e2)
    // where _swap_kw is _swap_word for word-sized values, and something
    // different for the two kinds of fat pointers.  Assumes that we are
    // not swapping zero-terminated array elements so that we can avoid
    // adding dynamic checks.
    bool is_dynforward_ptr = false;
    bool is_dyneither_ptr = false;
    type_t e1_old_typ = e1->topt->v;
    type_t e2_old_typ = e2->topt->v;
    if (!is_pointer_or_boxed(e1_old_typ,&is_dynforward_ptr,
			     &is_dyneither_ptr))
      toc_impos("Swap_e: is_pointer_or_boxed: not a pointer or boxed type");

    // figure out which swap primitive to use
    exp_t swap_fn;
    if (is_dynforward_ptr)
      swap_fn = _swap_dynforward_e;
    else if (is_dyneither_ptr)
      swap_fn = _swap_dyneither_e;
    else
      swap_fn = _swap_word_e;

    // some sanity checks for now
    if (!is_lvalue(e1))
      toc_impos("Swap_e: %s is not an l-value\n",Absynpp::exp2string(e1));
    if (!is_lvalue(e2))
      toc_impos("Swap_e: %s is not an l-value\n",Absynpp::exp2string(e2));

    // turn each expression into a declaration + initializer
    // followed by a call to the swap primtive
//     type_t vtyp = at_typ(e1_old_typ,HeapRgn /* XXX */,
// 			 empty_tqual(NULL),false_conref);
//     qvar_t v1 = temp_var();
//     qvar_t v2 = temp_var();
//     exp_t fe = fncall_exp(swap_fn,list(var_exp(v1,e1->loc),
// 				       var_exp(v2,e2->loc)),e->loc);

    // take the address of each operand; the runtime system primitive
    // will dereference and swap the given lhs's.
    exp_to_c(nv,e1);
    exp_to_c(nv,e2);
    e->r = fncall_exp_r(swap_fn,list(address_exp(e1,DL),
				     address_exp(e2,DL)));
    break;

  case &StmtExp_e(s): stmt_to_c(nv,s);  break;
  case &UnresolvedMem_e(_,_): toc_impos("UnresolvedMem"); 
  case &CompoundLit_e(_,_):   unimp("compoundlit");
  }
}

// Translate a pattern generating tests which jump goes to fail_lab
// on unsuccessful match.
// Returns:
// * a new translation environment (mapping variables bound in the pattern
//   to temps generated)
// * a list of temps to be declared (along with their types.)
//   This list contains the decls parameter
// * The statement for actually doing the test.
//
// (The temps must be declared with a wide enough
// scope to cover the tests and any cases in a switch (hence the reason
// they're pulled out.  Also needed for translating fallthru.)
//
// xlate_pat(env,t,r,path,p,fail_lab)
//
//  r is the "root" variable that contains the value we're matching.
//  path is the address of this value -- used in the Reference pattern.
//  p is the pattern
//  we do nothing on successful match -- caller puts the right code next
//  fail_lab is where to go upon failure to match
//
// FIX: adapt the decision tree code in the type-checker so that we
// have much more efficient traversal of patterns.
//
// Note: Extra labels and gotos aren't a big deal b/c gcc -O collapses them.
//
// Warning: We end sharing the fail_exps -- they should be copied if they
//          might be mutated later!
static stmt_t if_neq_stmt(exp_t e1,exp_t e2,stmt_t fail_stmt) {
  return ifthenelse_stmt(neq_exp(e1,e2,DL),
			 fail_stmt,
			 skip_stmt_dl(),DL);
}
static $(env_t<`rgn>,list_t<$(qvar_t,type_t)@`rgn,`rgn>,stmt_t)
xlate_pat(env_t<`rgn> nv, 
          region_t<`rgn> rgn, type_t t, exp_t r, exp_t path, pat_t p,
	  stmt_t* tag_fail_stmt, stmt_t fail_stmt, 
          list_t<$(qvar_t,type_t)@`rgn,`rgn> decls) {
  stmt_t s; // the test statement
  switch (p->r) {
  case &Var_p(&Vardecl(_,x,_,_,_,_,_,_),p2): 
    // in essence, x = r; but achieved through the varmap
    return xlate_pat(add_varmap(rgn,nv,x,r),
                     rgn, t, r, path, p2, tag_fail_stmt, 
                     fail_stmt, decls);
  case &TagInt_p(_,&Vardecl(_,x,_,_,_,_,_,_)): // type translation erases tvar
    // in essence, x = r; but achieved through the varmap
    nv = add_varmap(rgn,nv,x,r);
    fallthru;
  case Wild_p: s = skip_stmt_dl(); break; // potentially wasteful
  case &Reference_p(vd,p2):
    // v = path
    let v = temp_var();
    decls = rnew(rgn) List(rnew(rgn) $(v,cstar_typ(typ_to_c(t),mt_tq)),decls);
    nv    = add_varmap(rgn,nv,vd->name,var_exp(v,DL));
    // cast is needed to avoid a C warning when pointing to a polymorphic field
    s     = assign_stmt(var_exp(v,DL),
			cast_it(cstar_typ(typ_to_c(t),mt_tq),
                                address_exp(path,DL)),DL);
    let result = xlate_pat(nv,rgn,t,r,path,p2,tag_fail_stmt,fail_stmt,decls);
    result[2] = seq_stmt(s,result[2],DL);
    return result;
  case Null_p:       s=if_neq_stmt(r,signed_int_exp(0,DL),fail_stmt); break;
  case &Int_p(sn,i): s=if_neq_stmt(r,int_exp(sn,i,DL),    fail_stmt); break;
  case &Char_p(c):   s=if_neq_stmt(r,char_exp(c,DL),      fail_stmt); break;
  case &Float_p(f):  s=if_neq_stmt(r,float_exp(f,DL),     fail_stmt); break;

  case &Enum_p(ed,ef): 
    s = if_neq_stmt(r,new_exp(new Enum_e(ef->name,ed,ef),NULL),fail_stmt); 
    break;
  case &AnonEnum_p(t2,ef):
    s = if_neq_stmt(r,new_exp(new AnonEnum_e(ef->name,t2,ef),NULL),fail_stmt); 
    break;

  case &Tunion_p(tud,tuf,NULL,_) && !tud->is_flat:
    // when ps == NULL:  if (r == tag) goto succ_lab else goto fail_lab;
    // Note: This should be correct for tunion and xtunion!
    exp_t cmp_exp;
    if(tud->is_xtunion)
      cmp_exp = var_exp(tuf->name,DL);
    else {
      cmp_exp = tunion_tag(tud,tuf->name,false);
      r = cast_it(sint_typ,r);
    }
    s = if_neq_stmt(r, cmp_exp, fail_stmt);
    break;

  case &Pointer_p(&Pat{&Tunion_p(tud,tuf,ps,_),_,_}) && ps != NULL && !tud->is_flat:
    // when ps is p1,...,pn:
    //   if ((unsigned int)r > max_tag && ((t)r)->tag == qv_tag)
    //      <similar to tuple and struct patterns>
    //   else goto fail_lab
    // (no max tag check on xtunions)
    // FIX: When type is TunionField, can avoid all checks
    // It's unfortunate that we have to always check that r > max_tag.
    // If we had the decision tree information, we could avoid doing so.
    s = skip_stmt_dl();
    int    cnt      = 1;
    qvar_t tufstrct = collapse_qvar_tag(tuf->name,"_struct");
    exp_t  rcast    = cast_it(cstar_typ(strctq(tufstrct),mt_tq),r);
    let tuf_tqts = tuf->typs;
    for(; ps != NULL; ps = ps->tl, tuf_tqts = tuf_tqts->tl, ++cnt) {
      let p2  = ps->hd;
      if(p2->r == Wild_p)
	continue;
      let tuf_typ = (*tuf_tqts->hd)[1];
      let v   = temp_var();
      let t2  = p2->topt->v;
      let t2c = typ_to_c(t2);
      let arrow_exp = aggrarrow_exp(rcast, fieldname(cnt), DL);
      if(is_void_star(typ_to_c(tuf_typ)))
	arrow_exp = cast_it(t2c, arrow_exp);
      decls = rnew(rgn) List(rnew (rgn) $(v,t2c),decls);
      let result = xlate_pat(nv,rgn,t2,var_exp(v,DL), arrow_exp,
			     p2,&fail_stmt,fail_stmt,decls);
      nv = result[0];
      decls = result[1];
      let s3 = result[2];
      let s1 = assign_stmt(var_exp(v,DL), arrow_exp, DL);
      s = seq_stmt(s, seq_stmt(s1,s3,DL), DL);
    }
    exp_t test_exp;
    if(tud->is_xtunion) {
      exp_t e2 = cast_it(cstar_typ(void_star_typ(),mt_tq), r);
      exp_t e1 = deref_exp(e2,DL);
      exp_t e  = var_exp(tuf->name,DL);
      test_exp = neq_exp(e1,e,DL);
      s = seq_stmt(ifthenelse_stmt(test_exp, fail_stmt, skip_stmt_dl(), DL),
                   s, DL);
    } else {
      exp_t e3 = cast_it(cstar_typ(sint_typ,mt_tq), r);
      exp_t e1 = deref_exp(e3,DL);
      exp_t e  = tunion_tag(tud,tuf->name,true);
      s = seq_stmt(ifthenelse_stmt(neq_exp(e1,e,DL),fail_stmt,skip_stmt_dl(),
                                   DL), s, DL);
      if (tag_fail_stmt != NULL) {
        int max_tag = num_void_tags(tud);
        if (max_tag != 0) {
          exp_t max_tag_exp = uint_exp(max_tag,DL);
          exp_t e5 = lte_exp(r, cast_it(void_star_typ(),max_tag_exp), DL);
          s = seq_stmt(ifthenelse_stmt(e5,*tag_fail_stmt,skip_stmt_dl(),DL),
                       s,DL);
        }
      }
    }
    break;

  case &Tunion_p(tud,tuf,ps,_) && tud->is_flat: 
    // check that the tag matches and then check the sub-patterns.
    let &$(_,field_name) = tuf->name;
    r = aggrmember_exp(r,field_name,DL);
    path = aggrmember_exp(path,field_name,DL);
    s = ifthenelse_stmt(neq_exp(aggrmember_exp(path,tag_sp,DL),
                                tunion_tag(tud,tuf->name,true),DL),
                        fail_stmt,skip_stmt_dl(),DL);
    int cnt = 1;
    for(; ps != NULL; ps = ps->tl, ++cnt) {
      let p2  = ps->hd;
      if(p2->r == Wild_p)
	continue;
      let v   = temp_var();
      let t2  = p2->topt->v;
      decls = rnew(rgn) List(rnew(rgn) $(v,typ_to_c(t2)),decls);
      let result = xlate_pat(nv,rgn,t2,var_exp(v,DL),
                             aggrmember_exp(path,fieldname(cnt),DL),
			     p2,&fail_stmt,fail_stmt,decls);
      nv = result[0];
      decls = result[1];
      let s2 = result[2];
      let s3 = assign_stmt(var_exp(v,DL),
			   aggrmember_exp(r,fieldname(cnt),DL),DL);
      s = seq_stmt(s,seq_stmt(s3,s2,DL),DL);
    }
    break;
  case &Tunion_p(_,_,ps,_): fallthru(ps); // okay for xtunion too
  case &Tuple_p(ps,_):
    // given the pattern $(p1,p2,...,pn)
    //    v1 = r->f1; if (matches(v1,p1)) goto L1 else goto fail_lab;
    // L1:v2 = r->f2; if (matches(v2,p2)) goto L2 else goto fail_lab;
    // L2:v3 = r->f3; if (matches(v3,p2)) goto L3 else goto fail_lab;
    //    ...
    // Ln-1:vn = r->fn; if (matches(vn,p2)) goto succ_lab else goto fail_lab;
    s = skip_stmt_dl(); // wasteful
    int cnt = 1;
    for(; ps != NULL; ps = ps->tl, ++cnt) {
      let p2  = ps->hd;
      if(p2->r == Wild_p)
	continue;
      let v   = temp_var();
      let t2  = p2->topt->v;
      decls = rnew(rgn) List(rnew(rgn) $(v,typ_to_c(t2)),decls);
      let result = xlate_pat(nv,rgn,t2,var_exp(v,DL),
                             aggrmember_exp(path,fieldname(cnt),DL),
			     p2,&fail_stmt,fail_stmt,decls);
      nv = result[0];
      decls = result[1];
      let s2 = result[2];
      let s3 = assign_stmt(var_exp(v,DL),
			   aggrmember_exp(r,fieldname(cnt),DL),DL);
      s = seq_stmt(s,seq_stmt(s3,s2,DL),DL);
    }
    break;
  case &Aggr_p(AggrInfo(info,_),_,dlps,_):
    let ad = get_known_aggrdecl(info);
    // similar to translation of tuple pattern
    s = skip_stmt_dl();
    for (; dlps != NULL; dlps = dlps->tl) {
      let tup = dlps->hd;
      let p2  = (*tup)[1];
      if(p2->r == Wild_p)
	continue;
      _ f;
      switch ((*tup)[0]->hd) {
      case &FieldName(f2): f=f2; break;
      default: throw Match_error; // FIX:  assumes one field name designator
      }
      let v   = temp_var();
      let t2  = p2->topt->v;
      let t2c = typ_to_c(t2);
      decls = rnew(rgn) List(rnew(rgn) $(v,t2c),decls);
      let result = xlate_pat(nv,rgn,t2,var_exp(v,DL),
                             aggrmember_exp(path,f,DL),p2,
                             &fail_stmt,fail_stmt,decls);
      nv = result[0];
      decls = result[1];
      let memexp = aggrmember_exp(r,f,DL);
      if(is_void_star(lookup_field(ad->impl->fields,f)->type))
	memexp = cast_it(t2c, memexp);
      let s2 = result[2];
      let s3 = assign_stmt(var_exp(v,DL), memexp, DL);
      s = seq_stmt(s, seq_stmt(s3,s2,DL), DL);
    }
    break;

  case &Pointer_p(p2):
    // if (r == 0) goto fail_lab; v = *r; match(v,p2);
    let v = temp_var();
    let t2 = p2->topt->v;
    decls = rnew(rgn) List(rnew(rgn) $(v,typ_to_c(t2)),decls);
    let result = xlate_pat(nv,rgn,t2,var_exp(v,DL),deref_exp(path,DL),p2,
			   &fail_stmt,fail_stmt,decls);
    nv = result[0];
    decls = result[1];
    let s2 = result[2];
    let s3 = seq_stmt(assign_stmt(var_exp(v,DL),deref_exp(r,DL),DL),s2,DL);
    if (is_nullable(t))
      s = seq_stmt(ifthenelse_stmt(eq_exp(r,signed_int_exp(0,DL),DL),
				   fail_stmt,
				   skip_stmt_dl(), DL),
		   s3,DL);
    else
      s = s3;
    break;
  case &UnknownId_p(_):     toc_impos("unknownid pat");
  case &UnknownCall_p(_,_,_): toc_impos("unknowncall pat");
  case &Exp_p(_):           toc_impos("exp pat");
  }
  return $(nv,decls,s);
}

///////////////////////////////////////////////////////////////
//              Translation of Switch Statements             //
///////////////////////////////////////////////////////////////
// FIX:  Should use decision tree stuff from tcpat.
//
// For performance, we try to leave switches as switches.  We do this when
// all of the following hold:
// * We are switching on a char or int type.
//   (Could also do tunion without value contructors, but we didn't pass in
//    access to the type definitions!)
// * No switch_clause has any variables. (reject switch(3) { case x: ... }
// The hitch is we could still have something like
//    switch(e) { case 0: if(b) fallthru; else return; }
// Therefore, we give each case body
// a fresh label so we can translate fallthru to goto.
// Then we just hope gcc cleans up the mess and can still use jump tables.
//
// For all other switches,
// switch (e) { case p1: s1 ... case pn:sn } turns into (roughly)
//
//  x = e;
//  <lots of temp declarations>
//    if !matches(p1,x) goto L2; L1: s1;
// L2:if !matches(p2,x) goto L4; L3: s2;
// L4:if !matches(p3,x) goto L4; L5: s3;
//     ...
// L2n: ; // destination of break within the original switch cases
// L2n-2:if matches(pn,x) goto L2n-1 else goto L2n;
// L1: s1;
// L3: s2;
// L5: s3;
// ...
// L2n-1: sn;
// L2n: ;
static $(var_t,var_t,switch_clause_t)@`r gen_label(region_t<`r> r,
                                                   switch_clause_t sc) {
  return rnew(r) $(fresh_label(),fresh_label(),sc);
}

static bool is_mixed_tunion(type_t t) {
  switch (compress(t)) {
  case &TunionType(TunionInfo{KnownTunion(&tud),...}) && !tud->is_flat:
    bool seen_novalue = false;
    bool seen_value = false;
    for (let fs = tud->fields->v; fs; fs = fs->tl) {
      if (fs->hd->typs == NULL)
        seen_value = true;
      else 
        seen_novalue = true;
      if (seen_value && seen_novalue) return true;
    }
    break;
  default: break;
  }
  return false;
}

static bool no_tag_test(pat_t p) {
  switch (p->r) {
  case &Var_p(_,p): return no_tag_test(p);
  case &Pointer_p(&Pat{&Tunion_p(tud,tuf,ps,_),_,_}) && ps != NULL && !tud->is_flat:
    return false;
  default: return true;
  }
}

static void xlate_switch(env_t nv, stmt_t whole_s, 
			 exp_t e, list_t<switch_clause_t> scs) {
  exp_to_c(nv,e);
  let t = e->topt->v;

  // decide if we can leave it as a switch
  // FIX: cannot have Float_p in any cases.
  bool leave_as_switch;
  switch (compress(t)) {
  case &IntType(_,_):  
  case &EnumType(_,_): leave_as_switch = true;  break;
  default:             leave_as_switch = false; break;
  }
  for(let scs1 = scs; scs1 != NULL; scs1 = scs1->tl)
    if(scs1->hd->pat_vars->v != NULL || scs1->hd->where_clause != NULL) {
      leave_as_switch = false;
      break;
    }
  if(leave_as_switch) {
    // note: fallthru in last case can't happen, else this is busted
    var_t next_l = fresh_label();
    for(let scs1 = scs; scs1 != NULL; scs1 = scs1->tl) {
      let s = scs1->hd->body;
      scs1->hd->body = label_stmt(next_l,s,DL);
      next_l = fresh_label();
      region rgn {
        stmt_to_c(switch_as_switch_env(rgn,nv,next_l),s);
      }
    }
    return;
  }
  // no dice, translate to a nest of gotos...
  qvar_t v     = temp_var();
  exp_t  r     = var_exp(v,DL);
  exp_t  path  = var_exp(v,DL);
  var_t  end_l = fresh_label();
  // for each case, generate a test label and an entry label
  region rgn {
    let nv = share_env(rgn,nv);
    list_t<$(var_t,var_t,switch_clause_t)@`rgn,`rgn> lscs = 
      List::rmap_c(rgn,gen_label,rgn,scs);
    list_t<stmt_t,`rgn>                test_stmts = NULL;
    list_t<env_t,`rgn>                 nvs        = NULL;
    list_t<$(qvar_t,type_t)@`rgn,`rgn> decls      = NULL;
    bool is_tunion = is_mixed_tunion(t);
    bool needs_tag_test = is_tunion;
    // generate the tests for each case, continuing to the case's
    // label on success and to the next test on false.
    // do tests first so as to get vars for fallthrus
    // the last case is different b/c there's no fallthru so fake it with end_l
    for (let lscs2 = lscs; lscs2 != NULL; lscs2 = lscs2->tl) {
      switch_clause_t sc = (*lscs2->hd)[2];
      var_t fail_lab = (lscs2->tl == NULL) ? end_l : (*lscs2->tl->hd)[0];
      stmt_t *`rgn tag_fail_stmt = NULL;
      // we're going to have to check if r <= max_tag.  On failure,
      // we jump to the next pattern that might satisfy this, skipping
      // over the tests that also require r <= max_tag.  We also record
      // that we've already done this test so that the subsequent tests
      // can be avoided.  
      if (needs_tag_test && !no_tag_test(sc->pattern)) {
        for (let xs = lscs2->tl; xs; xs = xs->tl) 
          if (no_tag_test((*xs->hd)[2]->pattern)) {
            tag_fail_stmt = rnew(rgn) (goto_stmt((*xs->hd)[0],DL));
            needs_tag_test = false;
            break;
          }
        if (tag_fail_stmt == NULL) 
          tag_fail_stmt = rnew(rgn) (goto_stmt(fail_lab,DL));
      }
      let $(nv2,decls2,test_stmt) = xlate_pat(nv,rgn,t,r,path,sc->pattern,
                                              tag_fail_stmt,
					      goto_stmt(fail_lab,DL),
                                              decls);
      if (is_tunion && no_tag_test(sc->pattern))
        needs_tag_test = true;
      if(sc->where_clause!=NULL) {
	let e = (exp_t)sc->where_clause;
	exp_to_c(nv2,e); // nv2 b/c pattern vars are in scope
	test_stmt = seq_stmt(test_stmt, ifthenelse_stmt(prim1_exp(Not,e,DL),
							goto_stmt(fail_lab,DL),
							skip_stmt_dl(), DL),DL);
      }
      decls = decls2;
      nvs = rnew(rgn) List(nv2,nvs);
      test_stmts = rnew(rgn) List(test_stmt,test_stmts);
    }
    nvs = List::imp_rev(nvs);
    test_stmts = List::imp_rev(test_stmts);
    list_t<stmt_t> stmts = NULL;
    // now generate all of the statements for the cases
    // note: first test_lab is unnecessary
    for (; lscs != NULL;
	 lscs = lscs->tl, nvs = nvs->tl, test_stmts = test_stmts->tl) {
      let &$(test_lab,body_lab,body_sc) = lscs->hd;
      let env = nvs->hd;
      stmt_t s = body_sc->body;
      region rgn2 {
        if(lscs->tl != NULL) {
          let &$(_,fallthru_lab,next_sc) = lscs->tl->hd;
          stmt_to_c(non_last_switchclause_env(rgn2, env, end_l, fallthru_lab,
                                              next_sc->pat_vars->v, 
                                              nvs->tl->hd),
                    s);
        } else
          stmt_to_c(last_switchclause_env(rgn2,env, end_l), s);
      }
      s = seq_stmt(label_stmt(test_lab,test_stmts->hd,DL),
		   label_stmt(body_lab,s,DL), DL);
      stmts = rnew(rgn) List(s, stmts);
    }
    stmt_t res = seq_stmt(seq_stmts(List::imp_rev(stmts),DL),
			  label_stmt(end_l, skip_stmt_dl(), DL), DL);
    // add in all of the variable declarations with a wide enough scope
    for (decls; decls != NULL; decls = decls->tl) {
      let &$(qv,t) = decls->hd;
      res = declare_stmt(qv, t, NULL, res, DL);
    }
    // add in the variable holding the test and clobber the abstract syntax
    whole_s->r = declare_stmt(v,typ_to_c(e->topt->v),e, res, DL)->r;
  }
}

// forward declarations
static stmt_t letdecl_to_c(env_t nv, pat_t p, type_t t, exp_t e, stmt_t s);
static void local_decl_to_c(env_t body_nv,env_t init_nv,vardecl_t vd,stmt_t s);

///////////////////////////////////////////////////////////////
//              Translation of Statements                    //
///////////////////////////////////////////////////////////////
static void fndecl_to_c(env_t nv, fndecl_t f, bool cinclude);

stmt_t make_npop_handler(int n) {
  return exp_stmt(fncall_exp(_npop_handler_e,
			     new List(uint_exp(n-1,DL),NULL), DL), DL);
}
void do_npop_before(int n, stmt_t s) { // mutates s as necessary!
  if(n > 0)
    s->r = seq_stmt_r(make_npop_handler(n),new_stmt(s->r,DL));
}

static void stmt_to_c(env_t nv, stmt_t s) {
  // written to be self-tail recursive
  while (true) {
    switch (s->r) {
    case Skip_s:
      return;
    case &Exp_s(e):
      exp_to_c(nv, e);
      return;
    case &Seq_s(s1,s2):
      stmt_to_c(nv,s1);
      s = s2;
      continue;
    case &Return_s(eopt):
      opt_t<type_t> topt = NULL;
      if (eopt != NULL) {
	topt = new Opt(typ_to_c(eopt->topt->v));
	exp_to_c(nv,(exp_t)eopt);
      }
      // reset handler **after** evaluating expression
      if (s->try_depth > 0) 
	if (topt != NULL) {
	  let x = temp_var();
	  let retn_stmt = return_stmt(var_exp(x,DL),DL);
	  s->r = declare_stmt(x,topt->v, eopt,
			      seq_stmt(make_npop_handler(s->try_depth),
				       retn_stmt,DL),DL)->r;
	} else {
	  do_npop_before(s->try_depth,s);
	}
      return;
    case &IfThenElse_s(e,s1,s2):
      exp_to_c(nv,e);
      stmt_to_c(nv,s1);
      s = s2;
      continue;
    case &While_s($(e,_),s2):
      exp_to_c(nv,e);
      region temp {
        stmt_to_c(loop_env(temp,nv),s2);
      }
      return;
    case &Break_s(dest_opt): // dest is NULL when break to end of void function
      let &Env{.break_lab=b,...} = nv;
      if (b != NULL)
	s->r = goto_stmt_r(*b,NULL);
      // reset handler
      int dest_depth = dest_opt == NULL ? 0 : dest_opt->try_depth;
      do_npop_before(s->try_depth - dest_depth, s);
      return;
    case &Continue_s(dest):
      let &Env{.continue_lab=c,...} = nv;
      if (c != NULL)
	s->r = goto_stmt_r(*c,NULL);
      fallthru(dest);
    case &Goto_s(_,dest): 
      // reset handler (note: earlier checks prevent jump into handler)
      do_npop_before(s->try_depth - dest->try_depth, s);
      return;
    case &For_s(e1,$(e2,_),$(e3,_),s2):
      // FIX:  should e3 be translated in nv?
      exp_to_c(nv,e1); exp_to_c(nv,e2); exp_to_c(nv,e3);
      region temp {
        stmt_to_c(loop_env(temp,nv),s2);
      }
      return;
    case &Switch_s(e,scs):
      xlate_switch(nv,s,e,scs);
      return;
    case &Fallthru_s(es,dest_clause):
      let &Env{.fallthru_info = fi,...} = nv;
      if(fi == NULL)
	toc_impos("fallthru in unexpected place"); 
      let FallthruInfo{l,vs,other_vmap} = *fi;
      stmt_t s2 = goto_stmt(l, DL);
      // reset handler (after the es evaluation)
      do_npop_before(s->try_depth - (*dest_clause)->body->try_depth, s2);
      let vs2 = List::rev(vs);
      let es2 = List::rev(es);
      for(; vs2 != NULL; vs2 = vs2->tl, es2 = es2->tl) {
	exp_to_c(nv,es2->hd);
	s2 = seq_stmt(assign_stmt(Dict::lookup(other_vmap,vs2->hd), es2->hd,DL),
		      s2,DL);
      }
      s->r = s2->r;
      return;
    case &Decl_s(d,s1):
      // we have to treat Let_d and Var_d where we bind a comprehension
      // (not at the top-level) specially because these have to return 
      // "statements".  See letdecl_to_c and decls_to_c below.
      switch (d->r) {
      case &Var_d(vd):
        region temp {
          let nv2 = add_varmap(temp,nv,vd->name,
                               varb_exp(vd->name,new Local_b(vd),DL));
          local_decl_to_c(nv2, nv2, vd, s1);
        }
	break;
      case &Let_d(p,_,e):
        // Handle the special case where the pattern is a variable just like
	// a variable declaration, except variable's scope does NOT include e
        switch (p->r) {
        case &Var_p(vd, &Pat{.r = Wild_p, ...}):
	  qvar_t old_name = vd->name;
	  qvar_t new_name = temp_var();
	  vd->name = new_name;
          vd->initializer = e;
          d->r = new Var_d(vd);
          region temp {
            let nv2 = 
              add_varmap(temp,nv,old_name,
                         varb_exp(new_name,new Local_b(vd),DL));
            local_decl_to_c(nv2, nv, vd, s1);
          }
          break;
        default: 
	  // we treat let declarations specially because they may need
	  // statements in addition to declarations, so we splice them in
	  // as a statement.  Other declarations only produce declarations.
	  s->r = letdecl_to_c(nv, p, e->topt->v, e, s1)->r;
	  break;
        }
	break;
      case &Letv_d(vds):
        //let nv2 = nv;
        //for (; vds != NULL; vds = vds->tl) {
        //  let vd = vds->hd;
        //  let c_name = vd->name;
        //  vd->type = typ_to_c_array(vd->type);
        //  nv2 = add_varmap(nv2,c_name,varb_exp(c_name,new Local_b(vd),DL));
        //}
        //stmt_to_c(nv2,s1);

        // Transform Letv_d into a sequence of Var_d, and call stmt_to_c on
        // the result.
        let rvds = List::rev(vds);
        if (rvds == NULL)
          impos("empty Letv_d");
        d->r = new Var_d(rvds->hd);
        rvds = rvds->tl;
        for (; rvds != NULL; rvds = rvds->tl) {
          let d2 = new_decl(new Var_d(rvds->hd),DL);
          s->r = decl_stmt(d2,new_stmt(s->r,DL),DL)->r;
        }
        stmt_to_c(nv,s);
        break;
      case &Fn_d(fd):
        let c_name = fd->name;
        region temp {
          let nv = add_varmap(temp,nv,fd->name,var_exp(c_name,DL));
          fndecl_to_c(nv, fd, false);
          stmt_to_c(nv,s1);
        }
        break;
      default: impos("bad nested declaration within function");
      }
      return;
    case &Label_s(lab,s1):
      s = s1; continue;
    case &Do_s(s2,$(e,_)):
      region temp {
        stmt_to_c(loop_env(temp,nv),s2);
        exp_to_c(nv,e);
      }
      return;
    case &TryCatch_s(body,scs):
      // NOTE: Because explicit fallthru is not allowed in the last case,
      //       appending a new last case can't change the meaning of any
      //       control flow.
      // struct handler_cons h;
      // _push_handler(&h);
      // int was_thrown = 0; 
      // if (setjmp(h.handler)) was_thrown = 1;
      // if (!was_thrown) {
      //   body
      //   _pop_handler();
      // } else {
      //   exn e = (exn)_exn_thrown;
      //   switch (e) scs
      // }
      // [Auxillary functions are defined in runtime_cyc.c]
      qvar_t h_var = temp_var();
      qvar_t e_var = temp_var();
      qvar_t was_thrown_var = temp_var();
      exp_t  h_exp = var_exp(h_var,DL);
      exp_t  e_exp = var_exp(e_var,DL);
      exp_t  was_thrown_exp = var_exp(was_thrown_var,DL);
      type_t h_typ = strct(_handler_cons_sp);
      type_t e_typ = typ_to_c(exn_typ);
      type_t was_thrown_typ = typ_to_c(sint_typ);
      // e_exp needs a typ because it'll go through exp_to_c;
      // as well, it must be in varmap
      e_exp->topt = new Opt(e_typ);
      region temp {
        let nv = add_varmap(temp,nv,e_var,e_exp);
        // translate the body
        stmt_to_c(nv,body);
        let tryandpop_stmt = seq_stmt(body,
                                      exp_stmt(fncall_exp(_pop_handler_e, 
                                                          NULL,
                                                          DL), DL),DL);
        // add a default case which re-throws the exception
        let x    = temp_var();
        let xexp = var_exp(x,DL);
        let x_vd = new_vardecl(x,exn_typ,NULL);
        xexp->topt = new Opt(exn_typ);
        let p = new Pat{.r=new Var_p(x_vd,new Pat{.r=Wild_p,.topt = new Opt(exn_typ), .loc = DL}), .topt=new Opt(exn_typ), .loc=DL};
        let te = throw_exp(xexp,DL);
        te->topt = new Opt(VoidType);
        let rs = exp_stmt(te,DL);
        let default_case =
          new Switch_clause{.pattern=p,.pat_vars=new Opt(new List(x_vd,NULL)),
                            .where_clause=NULL,.body=rs,.loc=DL};
        let handler_stmt = switch_stmt(e_exp,
                                       List::append(scs,
                                                    new List(default_case,NULL)),DL);
        // translate the switches
        stmt_to_c(nv,handler_stmt);

        // wrap with the conditional, declarations, and setjmp
        let setjmp_call = // setjmp(h.handler)
          fncall_exp(setjmp_e,
                     new List(aggrmember_exp(h_exp,handler_sp,DL), NULL),
                     DL);
        let pushhandler_call = // _pushhandler(h);
          exp_stmt(fncall_exp(_push_handler_e, 
                              new List(address_exp(h_exp,DL), NULL),
                              DL),DL);
        let zero_exp = int_exp(Signed,0,DL);
        let one_exp = int_exp(Signed,1,DL);
        s->r =
          declare_stmt(h_var, h_typ, NULL,
          seq_stmt(pushhandler_call,
          declare_stmt(was_thrown_var,was_thrown_typ,zero_exp,
          seq_stmt(ifthenelse_stmt(setjmp_call,
                                   assign_stmt(was_thrown_exp,one_exp,DL),
                                   skip_stmt_dl(),DL),
          ifthenelse_stmt(prim1_exp(Not, was_thrown_exp,DL),
                          tryandpop_stmt,
                          declare_stmt(e_var,e_typ,
                                       cast_it(e_typ,_exn_thrown_e),
                          handler_stmt,DL),DL),DL),DL),DL),DL)->r;
      }
      return;
    case &Region_s(tv, vd, resetable, open_exp_opt, body):
      // NOTE:  _npop_handler has to deal with regions as well as exceptions
      // When open_exp_opt is NULL:
      // { struct _RegionHandle rh = _new_region();
      //   struct _RegionHandle *x = &rh;
      //   _push_region(x);
      //   body; 
      //   _pop_region(x);
      // }
      // When open_exp_opt is not NULL:
      // { struct _DynRegionFrame f;
      //   struct _RegionHandle *x = _open_dynregion(&f,open_exp_opt);
      //   body;
      //   _pop_dynregion();
      // }
      // Note that _open_dynregion implicitly pushes the dynregion.
      type_t rh_struct_typ     = strct(_RegionHandle_sp);
      type_t rh_struct_ptr_typ = cstar_typ(rh_struct_typ,mt_tq);
      qvar_t rh_var = temp_var();
      qvar_t x_var  = vd->name;
      exp_t  rh_exp = var_exp(rh_var,DL);
      exp_t  x_exp  = var_exp(x_var, DL);

      region temp {
        stmt_to_c(add_varmap(temp,nv,x_var,x_exp),body);
      }
      if (no_regions) {
        s->r = declare_stmt(x_var, rh_struct_ptr_typ, 
                            uint_exp(0,DL), body, DL)->r;
      } else if (open_exp_opt == NULL) {
        s->r = 
	  declare_stmt(rh_var,rh_struct_typ, 
		       fncall_exp(_new_region_e,
			  	  new List(string_exp(qvar2string(x_var),DL),
					   NULL),DL),
  	  declare_stmt(x_var, rh_struct_ptr_typ,address_exp(rh_exp,DL),
  	  seq_stmt(exp_stmt(fncall_exp(_push_region_e, list(x_exp), DL),DL),
          seq_stmt(body,
		   exp_stmt(fncall_exp(_pop_region_e,  list(x_exp), DL),DL),
		   DL),DL),DL),DL)->r;
      } else {
        exp_to_c(nv, (exp_t)open_exp_opt);
        s->r = 
          declare_stmt(rh_var, strct(_DynRegionFrame_sp), NULL, 
	  declare_stmt(x_var, rh_struct_ptr_typ,
		       fncall_exp(_open_dynregion_e,
                                  list(address_exp(rh_exp,DL),
                                       (exp_t)open_exp_opt),
                                  DL),
          seq_stmt(body,
		   exp_stmt(fncall_exp(_pop_dynregion_e,  list(x_exp), DL),DL),
		   DL),DL),DL)->r;
      }
      return;
    case &ResetRegion_s(e):
      if (no_regions) {
        s->r = Skip_s;
      } else {
        exp_to_c(nv,e);
        s->r = exp_stmt_r(fncall_exp(_reset_region_e,new List(e,NULL),DL));
      }
      return;
    case &Alias_s(e,tv,vd,s1):
      // Handle this like a variable declaration 
      qvar_t old_name = vd->name;
      qvar_t new_name = temp_var();
      vd->name = new_name;
      vd->initializer = e;
      s->r = new Decl_s(new Decl(new Var_d(vd),DL),s1);
      region temp {
	let nv2 = 
	  add_varmap(temp,nv,old_name,
		     varb_exp(new_name,new Local_b(vd),DL));
	local_decl_to_c(nv2, nv, vd, s1);
      }
      return;
    }
  }
}

///////////////////////////////////////////////////////////////
//              Translation of Declarations                  //
///////////////////////////////////////////////////////////////
// function declaration translation -- straightforward
static void stmttypes_to_c(stmt_t s);
static void fndecl_to_c(env_t nv, fndecl_t f, bool cinclude) {
  f->tvs      = NULL;
  f->effect   = NULL;
  f->rgn_po   = NULL;
  f->ret_type = typ_to_c(f->ret_type);
  region frgn {
    let nv = share_env(frgn,nv);
    for (let args=f->args; args != NULL; args = args->tl) {
      let x = new $((nmspace_t)Loc_n,(*args->hd)[0]);
      (*args->hd)[2] = typ_to_c((*args->hd)[2]);
      nv = add_varmap(frgn,nv,x,var_exp(x,DL));
    }
    // for C code, we need to go through and convert all of the types 
    // from Cyclone types to C, but otherwise leave the code alone.
    if (cinclude) {
      stmttypes_to_c(f->body);
      return;
    }
    if (f->cyc_varargs && f->cyc_varargs->name != NULL) {
      let VarargInfo{n,tq,t,i} = *f->cyc_varargs;
      let t2 = typ_to_c(dynforward_typ(t,HeapRgn,tq,false_conref));// region irrelevant
      let x2 = new $((nmspace_t)Loc_n,n->v);
      f->args = List::append(f->args,new List(new $(n->v,tq,t2),NULL));
      nv = add_varmap(frgn,nv,x2,var_exp(x2,DL));
      f->cyc_varargs = NULL;
    }
    // Tovc would like to use param_vardecls:
    for(let arg_vds = f->param_vardecls->v; arg_vds!=NULL; arg_vds=arg_vds->tl) {
      arg_vds->hd->type = typ_to_c(arg_vds->hd->type);
    }
    stmt_to_c(clear_toplevel(frgn,nv),f->body);
  }
}

// there's no abstract scope in C
static scope_t scope_to_c(scope_t s) {
  switch (s) {
  case Abstract: return Public;
  case ExternC : return Extern;
  default:       return s;
  }
}

// struct declarations -- straightforward
static void aggrdecl_to_c(aggrdecl_t ad) {
  let n = ad->name;
  let TocState{.dyn = dyn, .aggrs_so_far = aggrs_so_far, ...} = *toc_state;
  region d = open(dyn) {
    bool seen_defn_before;
    let dopt = Dict::lookup_opt(*aggrs_so_far, n);
    if (dopt == NULL) {
      seen_defn_before = false;
      $(aggrdecl_t,type_t)@ v;
      if (ad->kind == StructA)
        v = rnew(d) $(ad,strctq(ad->name));
      else 
        v = rnew(d) $(ad,unionq_typ(ad->name));
      *aggrs_so_far = Dict::insert(*aggrs_so_far,n,v);
    } else {
      let &$(ad2,t) = *dopt;
      if (ad2->impl == NULL) {
        *aggrs_so_far = Dict::insert(*aggrs_so_far,n,rnew(d) $(ad,t));
        seen_defn_before = false;
      } else
      seen_defn_before = true;
    }
    ad->sc   = Public; // gcc warns if we have Extern or Static here
    ad->tvs  = NULL;
    if(ad->impl != NULL) {
      ad->impl->exist_vars = NULL;
      ad->impl->rgn_po     = NULL;
      if (seen_defn_before)
        ad->impl = NULL;
      else
        for (let fields = ad->impl->fields; fields != NULL; fields = fields->tl){
          // JGM: I'm trying to get rid of warnings when we assign "const"
          // locations...
          fields->hd->tq = mt_tq;
          fields->hd->type = typ_to_c_array(fields->hd->type);
        }
    }
  }
}

// tunion declarations -- tricky
// Non-flat case:
// For "tunion foo {Bar,Blah,Baz(t1,t2,t3),Baf(t4,t5)}" we generate
//   typedef void *foo;
//   struct Baz_struct {
//     int tag;  // always == 0
//     t1 f1;
//     t2 f2;
//     t3 f3;
//   };
//   struct Baf_struct {
//     int tag;  // always == 1
//     t4 f1;
//     t5 f2;
//   };
// for xtunion, we pull a really slimy trick: By using char arrays instead
// of ints, the uses get promoted to addresses just like we want.
// When the tunion is "extern" then we don't generate initializers
// for the tags (that should be done elsewhere.)
//
// NB: we allow any number of repeated declarations but we can only
//     declare and initialize global variables once.  So we keep track
//     of what we've seen so far.  And we make the globals static so that
//     extern and what not is only a link-checker thing.  Unfortunately,
//     the static trick doesn't work for xtunion, which uses the addresses.
// 
// For flat tunions, "tunion Foo {Bar, Blah, Baz(t1,t2,t3),Baf(t4,t5)}"
// we generate:
//    struct Bar { int tag; };
//    struct Blah { int tag; };
//    struct Baz { int tag; t1 f1; t2 f2; t3 f3; };
//    struct Baf { int tag; t4 f1; t5 f2; };
//    union Foo {
//      struct Bar Bar;
//      struct Blah Blah;
//      struct Baz  Baz;
//      struct Baf  Baf;
//    };
static void tuniondecl_to_c(tuniondecl_t tud) {
  let TocState{.dyn = dyn, .tunions_so_far = tunions_so_far, ...} = *toc_state;
  region d = open(dyn) {
    let n = tud->name;
    if(tud->fields == NULL || Set::member(*tunions_so_far, n))
      return;
    *tunions_so_far = Set::rinsert(d,*tunions_so_far, n);
  }
  // list of anonymous struct fields used for flattened tunions
  list_t<aggrfield_t> flat_structs = NULL;
  
  for (let fields = tud->fields->v; fields != NULL; fields = fields->tl) {
    tunionfield_t f = fields->hd;
    if (f->typs != NULL || tud->is_flat) {
      // compute the fields for the struct, adding in a tag field if this
      // isn't a flat tunion
      let fs = NULL;
      int i  = 1;
      for (let ts = f->typs; ts != NULL; ts = ts->tl, i++) {
	let fname = fieldname(i);
	let f = new Aggrfield(fname,(*ts->hd)[0],
			      typ_to_c_array((*ts->hd)[1]),NULL,NULL);
	fs = new List(f,fs);
      }
      fs = new List(new Aggrfield(tag_sp,mt_tq,sint_typ,NULL,NULL),
                    List::imp_rev(fs));
      let ad = 
        new Aggrdecl{.kind = StructA, .sc = Public,
                     .name = collapse_qvar_tag(f->name,"_struct"),
                     .tvs = NULL, 
                     .impl = new AggrdeclImpl(NULL,NULL,fs),
                     .attributes = NULL};
      result_decls = new List(new_decl(new Aggr_d(ad),DL),result_decls);
      if (tud->is_flat) {
        let field = new Aggrfield((*f->name)[1], mt_tq,
                                  new AggrType(AggrInfo(KnownAggr(new ad), NULL)),
                                  NULL,NULL);
        flat_structs = new List(field,flat_structs);
      }
    }
  }
  if (tud->is_flat) {
    // make an anonymous union out of the flat_structs
    flat_structs = List::imp_rev(flat_structs);
    let ad = 
      new Aggrdecl{.kind = UnionA, .sc = Public, 
                   .name = collapse_qvar_tag(tud->name,"_union"),
                   .tvs = NULL,
                   .impl = new AggrdeclImpl(NULL,NULL,flat_structs),
                   .attributes = NULL};
    result_decls = new List(new_decl(new Aggr_d(ad),DL),result_decls);
  }
}

// xtunion declarations -- similar to tunion declarations
// For a declaration extending an existing xtunion, e.g.,
//   "xtunion foo {Bar,Baz(t1,t2)}"
// we generate
//   char Bar[4] = "\0\0\0\0Bar";
//   struct Bar_struct { char *tag; };
//   char Baz[4] = "\0\0\0\0Baz";
//   struct Baz_struct { char *tag; t1 f1; t2 f2; };
// When the xtunion is extern, then we don't do initializers for the tags.
// The 0s are a crazy trick for letting void variants not have to be boxed
// (value variants can still follow the pointer and then their check fails)
//
// Thus "Baz(e1,e2)" maps to
// ({struct _Baz_struct *t =
//     (struct _Baz_struct*)malloc(sizeof(struct _Baz_struct));
//   *t = (struct _Baz_struct){.tag=Baz, .f1 = e1, .f2 = e2};
//   t;})
//true if already seen & initialized, false if seen but non initialized (extern)

static void xtuniondecl_to_c(tuniondecl_t xd) {
  if(xd->fields == NULL)
    return;
  let TocState{.dyn = dyn, .xtunions_so_far = xtunions_so_far, ...} = *toc_state;
  region d = open(dyn) {
    let n = xd->name;
    for (let fs = xd->fields->v; fs != NULL; fs = fs->tl) {
      tunionfield_t f  = fs->hd;
      stringptr_t fn = (*f->name)[1];
      let sz_exp  = uint_exp((*fn).size+4,DL);
      let tag_typ = array_typ(char_typ,mt_tq,sz_exp,false_conref,NULL);
      // FIX: making bad alignment and pointer-size assumptions!
      switch (Dict::lookup_opt(*xtunions_so_far,f->name)) {
      case NULL:
        exp_opt_t initopt = NULL;
        if (f->sc != Extern) {
          // JGMFIX: bug -- the printf functions fail miserably when we use
          // a 0 constants here because it thinks the 0 should be cast to a
          // NULL string.
          char zero = '\0';
          initopt = string_exp(aprintf("%c%c%c%c%s",zero,zero,zero,zero,*fn),DL);
        }
        let tag_decl = new_vardecl(f->name, tag_typ, initopt);
        tag_decl->sc = f->sc;
        result_decls = new List(new_decl(new Var_d(tag_decl),DL),result_decls);
        *xtunions_so_far = 
          Dict::insert(*xtunions_so_far, f->name, f->sc != Extern);
        if(f->typs != NULL) {
          list_t<aggrfield_t> fields = NULL;
          int i = 1;
          for (let tqts = f->typs; tqts != NULL; tqts = tqts->tl,i++) {
            let field_n = new ((string_t)aprintf("f%d",i));
            let newf = new Aggrfield(field_n,(*tqts->hd)[0],
                                     typ_to_c_array((*tqts->hd)[1]),NULL,NULL);
            fields = new List(newf,fields);
          }
          fields = new List(new Aggrfield(tag_sp,mt_tq,
                                          cstar_typ(char_typ,mt_tq),NULL,NULL),
                            List::imp_rev(fields));
          let strct_decl =
            new Aggrdecl{.kind = StructA, .sc = Public,
                         .name = collapse_qvar_tag(f->name,"_struct"),
                         .tvs  = NULL, 
                         .impl = new AggrdeclImpl(NULL,NULL,fields),
                         .attributes = NULL};
          result_decls = new List(new_decl(new Aggr_d(strct_decl),DL),
                                  result_decls);
        }
        break;
        
      case &false:
        if (f->sc != Extern) {
          // JGMFIX: bug -- the printf functions fail miserably when we use
          // a 0 constants here because it thinks the 0 should be cast to a
          // NULL string.
          char zero = '\0';
          let initopt = string_exp(aprintf("%c%c%c%c%s",zero,zero,zero,zero,*fn),
                                   DL);
          let tag_decl = new_vardecl(f->name, tag_typ, initopt);
          tag_decl->sc = f->sc;
          result_decls = new List(new_decl(new Var_d(tag_decl),DL),result_decls);
          *xtunions_so_far = Dict::insert(*xtunions_so_far, f->name, true);
        }
        break;
      default: break;
      }
    }
  }
}

static void enumdecl_to_c(env_t nv,enumdecl_t ed) {
  ed->sc = Public; // gcc warns if we have Extern or Static on an enum
  if(ed->fields != NULL)
    enumfields_to_c(ed->fields->v);
}

// we've decided let x = e and t x = e have different rules on e's
// environment, so we make the caller pass us an environment.
static void local_decl_to_c(env_t body_nv,env_t init_nv,vardecl_t vd,stmt_t s) {
  type_t old_typ = vd->type;
  vd->type = typ_to_c_array(old_typ);
  // Fat pointers can't be declared with "register" scope
  bool forward_only = false;
  if (vd->sc == Register && is_tagged_pointer_typ(old_typ,&forward_only)) 
    vd->sc = Public;
  stmt_to_c(body_nv,s);
  if(vd->initializer != NULL) {
    exp_t init = (exp_t)vd->initializer;
    switch(init->r) {
    case &Comprehension_e(vd2,e1,e2,zt):
      vd->initializer = NULL;
      s->r = init_comprehension(init_nv, var_exp(vd->name, DL), vd2, e1, e2,
                                zt, new_stmt(s->r,DL), false)->r;
      break;
    default:
      if (vd->sc == Static) {
        // static declarations have to be treated as if they're toplevel
        // w.r.t. the translation.  NB: Any other generated declarations
	// will also be left at top-level??
        region temp {
          let nv2 = set_toplevel(temp,init_nv);
          exp_to_c(nv2, init);
        }
      } else 
        exp_to_c(init_nv, init);
      break;
    }
  } else {
    // must put in zero for zero-terminated arrays
    switch (compress(old_typ)) {
    case &ArrayType(ArrayInfo{et,_,num_elts_opt,zt,_}) && conref_def(false,zt):
      if (num_elts_opt == NULL)
        toc_impos("can't initialize zero-terminated array -- size unknown");
      exp_t num_elts = (exp_t)num_elts_opt;
      let lhs = subscript_exp(var_exp(vd->name,DL),
                              add_exp(num_elts,signed_int_exp(-1,DL),DL),
                              DL);
      let rhs = signed_int_exp(0,DL);
      s->r = seq_stmt_r(exp_stmt(assign_exp(lhs,rhs,DL),DL),
                        new_stmt(s->r,DL));
      break;
    default: break;
    }
  }
}

static stmt_t* throw_match_stmt_opt = NULL;
static stmt_t throw_match_stmt() {
  if(throw_match_stmt_opt==NULL)
    throw_match_stmt_opt = new exp_stmt(newthrow_exp(match_exn_exp(DL)),DL);
  return *throw_match_stmt_opt;
}
// let declarations -- tricky
// Unlike other declarations, lets need to execute statements and
// so return a statement.  (See stmt_to_c, case for Decl above.)
// We treat this similar to the compilation of a switch (see xlate_switch
// above) with one case, but where the failure throws Match_Exception
static stmt_t letdecl_to_c(env_t nv, pat_t p, type_t t, exp_t e, stmt_t s) {
  exp_to_c(nv,e);
  qvar_t x = temp_var();
  region prgn {
    let fail = throw_match_stmt();
    let nv = share_env(prgn,nv);
    let $(nv,vars,test_stmt) =
      xlate_pat(nv, prgn, t, var_exp(x,DL), var_exp(x,DL), p, 
		&fail, throw_match_stmt(),NULL);
    stmt_to_c(nv,s);
    s = declare_stmt(x,typ_to_c(t),e,seq_stmt(test_stmt,s,DL),DL);
    for (; vars != NULL; vars = vars->tl) {
      let &$(qv,t2) = vars->hd;
      s = declare_stmt(qv,t2,NULL,s,DL);
    }
  }
  return s;
}

// These next few functions clean up the types in C code, getting
// rid of stuff inserted by the parser (e.g., region evars). 

static void exptypes_to_c(exp_t e) {
  switch (e->r) {
  case &Deref_e(e):          fallthru(e);
  case &AggrMember_e(e,_):   fallthru(e);
  case &AggrArrow_e(e,_):    fallthru(e);
  case &Address_e(e):        fallthru(e);
  case &Throw_e(e):          fallthru(e);
  case &NoInstantiate_e(e):  fallthru(e);
  case &Sizeofexp_e(e):      fallthru(e);
  case &Increment_e(e1,_):   exptypes_to_c(e1); break;
  case &Primop_e(_,es):      List::iter(exptypes_to_c,es); break;
  case &And_e(e1,e2):        fallthru(e1,e2);
  case &Or_e(e1,e2):         fallthru(e1,e2);
  case &SeqExp_e(e1,e2):     fallthru(e1,e2);
  case &Subscript_e(e1,e2):  fallthru(e1,e2);
  case &Swap_e(e1,e2):       fallthru(e1,e2);
  case &AssignOp_e(e1,_,e2): exptypes_to_c(e1); exptypes_to_c(e2); break;
  case &Conditional_e(e1,e2,e3): 
    exptypes_to_c(e1); exptypes_to_c(e2); exptypes_to_c(e3); break;
  case &FnCall_e(e,es,_):    fallthru(e,es);
  case &UnknownCall_e(e,es):
    exptypes_to_c(e); List::iter(exptypes_to_c,es); break;
  case &Cast_e(*t,e,_,_): *t = typ_to_c(*t); exptypes_to_c(e); break;
  case &CompoundLit_e(&$(_,_,*t),dles): 
    *t = typ_to_c(*t);
    fallthru(dles);
  case &UnresolvedMem_e(_,dles): fallthru(dles);
  case &Array_e(dles):
    for (; dles != NULL; dles = dles->tl) {
      let $(_,e) = *dles->hd;
      exptypes_to_c(e);
    }
    break;
  case &Offsetof_e(*t,_): fallthru(t);
  case &Sizeoftyp_e(*t):  *t = typ_to_c(*t); break;
  case &StmtExp_e(s): stmttypes_to_c(s); break;
  case &Malloc_e(*m):
    if (m->elt_type != NULL)
      m->elt_type = new (typ_to_c(*m->elt_type));
    exptypes_to_c(m->num_elts);
    break;
  case &Const_e(_):       fallthru;
  case &Var_e(_,_):       fallthru;
  case &UnknownId_e(_):   fallthru;
  case &Enum_e(_,_,_):    fallthru;
  case &AnonEnum_e(_,_,_):break;

  case &AnonStruct_e(_, _): fallthru;
  case &Tunion_e(_,_,_):    fallthru;
  case &Struct_e(_,_,_,_):  fallthru;
  case &Comprehension_e(_,_,_,_): fallthru;
  case &Tuple_e(_):         fallthru;
  case &Instantiate_e(_,_): fallthru;
  case &New_e(_,_):         fallthru;
  case &Gentyp_e(_,_):      
    Tcutil::terr(e->loc,"Cyclone expression within C code");
    break;
  }
}

static void decltypes_to_c(decl_t d) {
  switch (d->r) {
  case &Var_d(vd): 
    vd->type = typ_to_c(vd->type);
    if (vd->initializer != NULL) exptypes_to_c((exp_t)vd->initializer);
    break;
  case &Fn_d(fd):
    fd->ret_type = typ_to_c(fd->ret_type);
    for (let args=fd->args; args != NULL; args = args->tl) {
      (*args->hd)[2] = typ_to_c((*args->hd)[2]);
    }
    break;
  case &Aggr_d(ad): aggrdecl_to_c(ad); break;
  case &Enum_d(ed): 
    if (ed->fields != NULL) 
      for (let fs = ed->fields->v; fs != NULL; fs = fs->tl) {
        let f = fs->hd;
        if (f->tag != NULL) exptypes_to_c((exp_t)f->tag);
      }
    break;
  case &Typedef_d(td): td->defn = new Opt(typ_to_c_array(td->defn->v)); break;
  case &Let_d(_,_,_):
  case &Letv_d(_):
  case &Tunion_d(_):
  case &Namespace_d(_,_):
  case &Using_d(_,_):
  case &ExternC_d(_):
  case &ExternCinclude_d(_,_): 
    Tcutil::terr(d->loc,"Cyclone declaration within C code");
    break;
  case Porton_d:
  case Portoff_d: 
    break;
  }
}

static void stmttypes_to_c(stmt_t s) {
  switch (s->r) {
  case &Exp_s(e): exptypes_to_c(e); break;
  case &Seq_s(s1,s2): stmttypes_to_c(s1); stmttypes_to_c(s2); break;
  case &Return_s(eopt): if (eopt != NULL) exptypes_to_c((exp_t)eopt); break;
  case &IfThenElse_s(e,s1,s2):
    exptypes_to_c(e); stmttypes_to_c(s1); stmttypes_to_c(s2); break;
  case &While_s($(e,_),s): 
    exptypes_to_c(e); stmttypes_to_c(s); break;
  case &For_s(e1,$(e2,_),$(e3,_),s):
    exptypes_to_c(e1); exptypes_to_c(e2); exptypes_to_c(e3); 
    stmttypes_to_c(s); break;
  case &Switch_s(e,scs): 
    exptypes_to_c(e); 
    for (; scs != NULL; scs=scs->tl) stmttypes_to_c(scs->hd->body);
    break;
  case &Decl_s(d,s): decltypes_to_c(d); stmttypes_to_c(s); break;
  case &Do_s(s,$(e,_)): stmttypes_to_c(s); exptypes_to_c(e); break;
  case Skip_s: 
  case &Break_s(_):
  case &Continue_s(_):
  case &Goto_s(_,_): break;
  case &Fallthru_s(_,_):
  case &Label_s(_,_):
  case &TryCatch_s(_,_):
  case &Region_s(_,_,_,_,_):
  case &Alias_s(_,_,_,_):
  case &ResetRegion_s(_): Tcutil::terr(s->loc,"Cyclone statement in C code");
    break;
  }
}

// Translate the given declarations, producing a new list of declarations
// and a new translation environment.  All source-level variables should
// be entered in the varmap of the env.  Note that top-level variable
// declarations are treated differently.
static env_t<`r> decls_to_c(region_t<`r> r, env_t<`r> nv, list_t<decl_t> ds, bool top, bool cinclude) {
  for (; ds != NULL; ds = ds->tl) {
    if (!is_toplevel(nv))
      impos("decls_to_c: not at toplevel!");
    decl_t d = ds->hd;
    switch (d->r) {
    case &Var_d(vd):
      let c_name = vd->name;
      // strip any namespace from an extern C declaration
      if (vd->sc == ExternC) 
	c_name = new $(Rel_n(NULL),(*c_name)[1]);
      if (vd->initializer != NULL) {
        if (cinclude)
          exptypes_to_c((exp_t)vd->initializer);
        else 
          exp_to_c(nv, (exp_t)vd->initializer);
      }
      nv = add_varmap(r,nv,vd->name,varb_exp(c_name,new Global_b(vd),DL));
      vd->name = c_name;
      vd->sc   = scope_to_c(vd->sc);
      vd->type = typ_to_c_array(vd->type);
      result_decls = new List(d,result_decls);
      break;
    case &Fn_d(fd):
      let c_name = fd->name;
      // strip any namespace from an extern C declaration
      if (fd->sc == ExternC) {
	c_name = new $(Rel_n(NULL),(*c_name)[1]);
        fd->sc = Public; // function declarations can't be extern
      }
      nv = add_varmap(r,nv,fd->name,var_exp(c_name,DL));
      fd->name = c_name;
      fndecl_to_c(nv, fd, cinclude);
      result_decls = new List(d,result_decls);
      break;
    case &Let_d(_,_,_): 
    case &Letv_d(_):
      toc_impos("letdecl at toplevel");
    case &Aggr_d(sd):
      aggrdecl_to_c(sd);
      result_decls = new List(d,result_decls);
      break;
    case &Tunion_d(tud):
      if(tud->is_xtunion)
	xtuniondecl_to_c(tud);
      else
	tuniondecl_to_c(tud);
      break;
    case &Enum_d(ed):
      enumdecl_to_c(nv,ed);
      result_decls = new List(d,result_decls);
      break;
    case &Typedef_d(td):
      td->name = td->name;
      td->tvs  = NULL;
      if (td->defn != NULL) 
        td->defn = new Opt(typ_to_c_array(td->defn->v));
      else {
        switch (td->kind->v) {
        case BoxKind: td->defn = new Opt(void_star_typ()); break;
        default: td->defn = new Opt(VoidType); break;
        }
      }
      result_decls = new List(d,result_decls);
      break;
    case Porton_d:
    case Portoff_d:
      break;
    case &Namespace_d(_,ds2): fallthru(ds2);
    case &Using_d(_,ds2):     fallthru(ds2);
    case &ExternC_d(ds2): nv = decls_to_c(r,nv,ds2,top,cinclude); break;
    case &ExternCinclude_d(ds2,_): nv = decls_to_c(r,nv,ds2,top,true); break;
    }
  }
  return nv;
}

// initialize all globals
static void init() {
  let NewRegion{dyn} = Core::new_dynregion();
  region d = open(dyn) {
    toc_state = 
      new TocState{ .dyn = dyn,
                    .tuple_types = rnew(d) NULL,
                    .aggrs_so_far = rnew(d) Dict::rempty(d,qvar_cmp),
                    .tunions_so_far = rnew(d) Set::rempty(d,qvar_cmp),
                    .xtunions_so_far = rnew(d) Dict::rempty(d,qvar_cmp),
                    .qvar_tags = rnew(d) Dict::rempty(d,qvar_tag_cmp),
                    .temp_labels = Xarray::rcreate_empty(d)
      };
  }
  result_decls = NULL;
  tuple_type_counter = 0;
  temp_var_counter = 0;
  fresh_label_counter = 0;
  total_bounds_checks = 0;
  bounds_checks_eliminated = 0;
  globals = new {
    &_throw_str,
    &setjmp_str,
    &_push_handler_str,
    &_pop_handler_str,
    &_exn_thrown_str,
    &_npop_handler_str,
    &_check_null_str, 
    &_check_known_subscript_null_str,
    &_check_known_subscript_notnull_str,
    // &_check_unknown_subscript_str,
    &_check_dynforward_subscript_str,
    &_check_dyneither_subscript_str,
    // &_tagged_arr_str,
    &_dynforward_ptr_str,
    &_dyneither_ptr_str,
    // &_tag_arr_str,
    &_tag_dynforward_str,
    &_tag_dyneither_str,
    // &_init_tag_arr_str,
    &_init_dynforward_ptr_str,
    &_init_dyneither_ptr_str,
    // &_untag_arr_str,
    &_untag_dynforward_ptr_str,
    &_untag_dyneither_ptr_str,
    // &_get_arr_size_str,
    &_get_dynforward_size_str,
    &_get_dyneither_size_str,
    &_get_zero_arr_size_str, // NOT SURE WHETHER WE NEED BOTH?
    // &_tagged_arr_plus_str,
    &_dynforward_ptr_plus_str,
    &_dyneither_ptr_plus_str,
    &_zero_arr_plus_str,     // NOT SURE WHETHER WE NEED BOTH?
    // &_tagged_arr_inplace_plus_str,
    &_dynforward_ptr_inplace_plus_str,
    &_dyneither_ptr_inplace_plus_str,
    &_zero_arr_inplace_plus_str, // NOT SURE WHETHER WE NEED BOTH?
    // &_tagged_arr_inplace_plus_post_str,
    &_dynforward_ptr_inplace_plus_post_str,
    &_dyneither_ptr_inplace_plus_post_str,
    &_dynforward_to_dyneither_str,
    &_dyneither_to_dynforward_str,
    &_zero_arr_inplace_plus_post_str, // NOT SURE WHETHER WE NEED BOTH?
    &_cycalloc_str,
    &_cyccalloc_str,
    &_cycalloc_atomic_str,
    &_cyccalloc_atomic_str,
    &_region_malloc_str,
    &_region_calloc_str,
    &_check_times_str,
    &_new_region_str,
    &_push_region_str,
    &_pop_region_str,
    &_open_dynregion_str,
    &_push_dynregion_str,
    &_pop_dynregion_str,
    &_reset_region_str,
    &_throw_arraybounds_str,
    // &_tagged_ptr_decrease_size_str,
    &_dynforward_ptr_decrease_size_str,
    &_dyneither_ptr_decrease_size_str
  };
}

// The entry point:  translate the list of Cyclone declarations to
// a list of C declarations.
list_t<decl_t> toc(list_t<decl_t> ds) {
  init();
  region start {
    decls_to_c(start,empty_env(start),ds,true,false);
#ifdef BCE_DEBUG
    fprintf(stderr,"***eliminated %d out of %d bounds checks\n",
            bounds_checks_eliminated, total_bounds_checks);
#endif
    // free the state
    let TocState{.dyn = dyn,...} = *toc_state;
    Core::free_dynregion(dyn);
  }
  return imp_rev(result_decls);
}
