/* Translate Cyclone abstract syntax to C abstract syntax.
   Copyright (C) 2001 Greg Morrisett, AT&T
   This file is part of the Cyclone compiler.

   The Cyclone compiler is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   The Cyclone compiler is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with the Cyclone compiler; see the file COPYING. If not,
   write to the Free Software Foundation, Inc., 59 Temple Place -
   Suite 330, Boston, MA 02111-1307, USA. */

// Translation of Cyclone abstract syntax to C abstract syntax.
// Assumes that the type-checker has been successfully run on the
// Cyclone AST.  Uses lots of GCC-specific features (that should be in
// C-9X) to simplify the translation -- in particular, we use struct
// expressions "(struct foo){.f1=e1,.f2=e2,...,.fn=en}" and statement
// expressions "({int temp = e; temp++})".  The latter is used for
// declaring temps needed in the translation of expressions.

// The translation is mostly done in place in an imperative style
// (i.e., we overwrite AST nodes) so it's fairly crucial that we don't
// have sharing in the AST.  The one exception is that the type
// translation is functional.

// Look for "unimp" or comments that start with FIX: for missing
// or broken pieces.

// FIX: we could probably use "const" in lots of places where we're not.

// Note: unresolvedmem_exp should only be used (1) to build arrays; or
// (2) to build other things (structs etc.) at top level only; Tovc relies on this.


#include <core.h>
#include <cycboot.h>
#include <list.h>
#include <string.h>
#include <set.h>
#include <dict.h>
#include <position.h>
#include <xarray.h>
#include "absyn.h"
#include "absynpp.h"
#include "tcutil.h"
#include "evexp.h"
#include "relations.h"
#include "cf_flowinfo.h"
#include "toc.h"
using Core;
using List;
using Set;
using Position;
using Absyn;
using Absynpp;
using Tcutil;

// in Cyclone.cyc:  controls whether or not we expand typedefs
extern bool noexpand_r;

namespace Toc;

// used for creation of all abstract syntax node locations created here
#define DL 0

// padding for variable-length array allocations
#define PAD_BYTES sizeof(double)

// #define BCE_DEBUG
bool warn_bounds_checks = false;
bool warn_all_null_deref = false;
unsigned total_bounds_checks = 0;
unsigned bounds_checks_eliminated = 0;

// we aren't re-entrant -- we build this list of output decls (in
// reverse order)  It's global b/c tuple types, tagged pointer types, and
// strange top-level initializers need to "splice in" toplevel decls and
// it's a pain to pass this list around everywhere
static list_t<decl_t> result_decls = NULL;
// for gensymming, etc.
struct TocState<`d> {
  // tuple types seen so far and the struct they map to
  list_t<$(type_t,list_t<type_t,`d>)@`d,`d> @`d tuple_types;
  // (non-tagged) aggregates seen so far, their declaration, and C type
  Dict::dict_t<qvar_t,$(aggrdecl_t,type_t)@`d,`d> @`d aggrs_so_far;
  // instantiations of abstract structs generated as we go
  list_t<$(qvar_t,list_t<type_t>,type_t)@`d,`d> @`d abs_struct_types;
  // datatypes seen so far
  Set::set_t<qvar_t,`d> @`d                    datatypes_so_far;
  // xdatatypes seen so far -- bool is false if seen but not initialized (extern)
  Dict::dict_t<qvar_t,bool,`d> @`d             xdatatypes_so_far;
  // generated identifiers from combining other identifiers -- used when
  // collapsing datatype members with the datatype itself.  
  Dict::dict_t<$(qvar_t,qvar_t)@`d,qvar_t,`d>@`d qvar_tags;
  // generated labels -- get re-used across functions
  Xarray::xarray_t<var_t,`d>                    temp_labels;
};

int qvar_tag_cmp($(qvar_t,qvar_t)@ x, $(qvar_t,qvar_t)@ y) {
  let $(qx,sx) = *x;
  let $(qy,sy) = *y;
  int i = qvar_cmp(qx,qy);
  if (i != 0) return i;
  return qvar_cmp(sx,sy);
}

// create a fresh TocStaet given the region and an unused argument.
static struct TocState<`d>@`d empty_toc_state(region_t<`d> d, int unused) {
  return rnew(d) 
    TocState{.tuple_types = rnew(d) NULL,
             .aggrs_so_far = rnew(d) Dict::rempty(d,qvar_cmp),
             .abs_struct_types = rnew(d) NULL,
             .datatypes_so_far = rnew(d) Set::rempty(d,qvar_cmp),
             .xdatatypes_so_far = rnew(d) Dict::rempty(d,qvar_cmp),
             .qvar_tags = rnew(d) Dict::rempty(d,qvar_tag_cmp),
             .temp_labels = Xarray::rcreate_empty(d)
            };
}

struct TocStateWrap {
  <`d::R>
  Core::rcregion_key_t<`d> dyn;
  struct TocState<`d>@`d state;
};
typedef struct TocStateWrap*`U toc_state_t;
static toc_state_t toc_state = NULL;

// a generic function for using the toc state:  we pass in an
// argument arg and function f and end up passing f the current
// toc_state component after opening the toc_state's wrapped
// dynamic region.  
static `res use_toc_state(`a arg,
                          `res f<`d,`r>(region_t<`d>, 
                                        $(struct TocState<`d>@`d,`a)@`r)) {
  toc_state_t ts = NULL;
  ts :=: toc_state;
  let TocStateWrap{<`dyn> dyn, s} = *ts;
  let dyn2 = alias_refptr(dyn);
  *ts = TocStateWrap{dyn,s};
  ts :=: toc_state;
  let env = $(s, arg);
  let res = open_region(dyn2, &env, f);
  free_rckey(dyn2); // should be equivalent to drop_refptr
  return res;
}

static type_t aggrdecl_type_body<`r2,`d,`r>(region_t<`d> d, 
                                 $(struct TocState<`d>@`d, 
                                   $(qvar_t q,type_t (@`H)(qvar_t))@`r2)@`r env) {
  let $(s, &$(q, type_maker)) = *env;
  $(aggrdecl_t,type_t)@`d*`d v = Dict::lookup_opt(*s->aggrs_so_far,q);
  if (v == NULL) {
    return type_maker(q);
  } else {
    let &$(_,t) = *v;
    return t;
  }
}

type_t aggrdecl_type(qvar_t q, type_t (@`H type_maker)(qvar_t)) {
  _ env = $(q, type_maker);
  return use_toc_state(&env, (aggrdecl_type_body@<`aggrdecl_type>)<>);
}

static int tuple_type_counter = 0;
static int temp_var_counter = 0;
static int fresh_label_counter = 0;

// errors and reporting
datatype exn {Toc_Unimplemented};
datatype exn {Toc_Impossible};
static `a unimp(string_t fmt, ... inject parg_t<`r2> ap)
  __attribute__((format(printf,1,2), noreturn))
{
  vfprintf(stderr,fmt,ap);
  fprintf(stderr,"\n");
  fflush(stderr);
  throw new Toc_Unimplemented;
}
static `a toc_impos(string_t fmt, ... inject parg_t<`r2> ap)
  __attribute__((format(printf,1,2), noreturn))
{
  vfprintf(stderr,fmt,ap);
  fprintf(stderr,"\n");
  fflush(stderr);
  throw new Toc_Impossible;
}
datatype exn {Match_error};

/////////////////////////// Pre-Allocated Stuff /////////////////////////////
// Don't use any of these things if they might get mutated!!!

// some pre-allocated boxed strings -- use foo_sp for char ?* w/ contents "foo"
#define MAKE_STRING(str)\
  static string_t    str##_string = #str; \
  static stringptr_t str##_sp     = &str##_string

MAKE_STRING(curr);
MAKE_STRING(tag);
MAKE_STRING(val);
MAKE_STRING(_handler_cons);
MAKE_STRING(handler);
MAKE_STRING(_RegionHandle);
MAKE_STRING(_DynRegionHandle);
MAKE_STRING(_DynRegionFrame);

/* Some pre-allocated qvars -- use foo_e for exp that is var "foo".
   NB we must record all of these so that tovc knows about them;
   this is done by initializing the external variable globals in the
   function init(), below. */
stringptr_t ?globals = NULL;
#define MAKE_VAR(str)\
  static string_t              str##_str = #str;\
  static $(nmspace_t, var_t)   str##_pr  = $(Nmspace{.Loc_n=0},&str##_str);\
  static datatype Raw_exp.Var_e  str##_re  = Var_e(&str##_pr,&Unresolved_b_val);\
  static struct Exp            str##_ev  = Exp{NULL,&str##_re,0,&EmptyAnnot_val};\
  static exp_t                 str##_e   = &str##_ev


MAKE_VAR(_throw);
MAKE_VAR(setjmp);
MAKE_VAR(_push_handler);
MAKE_VAR(_pop_handler);
MAKE_VAR(_exn_thrown);
MAKE_VAR(_npop_handler);
MAKE_VAR(_check_null);
MAKE_VAR(_check_known_subscript_null);
MAKE_VAR(_check_known_subscript_notnull);
MAKE_VAR(_check_dyneither_subscript);
MAKE_VAR(_dyneither_ptr);
MAKE_VAR(_tag_dyneither);
MAKE_VAR(_init_dyneither_ptr);
MAKE_VAR(_untag_dyneither_ptr);
MAKE_VAR(_get_dyneither_size);
MAKE_VAR(_get_zero_arr_size); // NOT SURE WHETHER WE NEED BOTH?
MAKE_VAR(_get_zero_arr_size_char);
MAKE_VAR(_get_zero_arr_size_short);
MAKE_VAR(_get_zero_arr_size_int);
MAKE_VAR(_get_zero_arr_size_float);
MAKE_VAR(_get_zero_arr_size_double);
MAKE_VAR(_get_zero_arr_size_longdouble);
MAKE_VAR(_get_zero_arr_size_voidstar);
MAKE_VAR(_dyneither_ptr_plus);
MAKE_VAR(_zero_arr_plus);     // NOT SURE WHETHER WE NEED BOTH?
MAKE_VAR(_zero_arr_plus_char);
MAKE_VAR(_zero_arr_plus_short);
MAKE_VAR(_zero_arr_plus_int);
MAKE_VAR(_zero_arr_plus_float);
MAKE_VAR(_zero_arr_plus_double);
MAKE_VAR(_zero_arr_plus_longdouble);
MAKE_VAR(_zero_arr_plus_voidstar);
MAKE_VAR(_dyneither_ptr_inplace_plus);
MAKE_VAR(_zero_arr_inplace_plus); // NOT SURE WHETHER WE NEED BOTH?
MAKE_VAR(_zero_arr_inplace_plus_char);
MAKE_VAR(_zero_arr_inplace_plus_short);
MAKE_VAR(_zero_arr_inplace_plus_int);
MAKE_VAR(_zero_arr_inplace_plus_float);
MAKE_VAR(_zero_arr_inplace_plus_double);
MAKE_VAR(_zero_arr_inplace_plus_longdouble);
MAKE_VAR(_zero_arr_inplace_plus_voidstar);
MAKE_VAR(_dyneither_ptr_inplace_plus_post);
MAKE_VAR(_zero_arr_inplace_plus_post); // NOT SURE WHETHER WE NEED BOTH?
MAKE_VAR(_zero_arr_inplace_plus_post_char);
MAKE_VAR(_zero_arr_inplace_plus_post_short);
MAKE_VAR(_zero_arr_inplace_plus_post_int);
MAKE_VAR(_zero_arr_inplace_plus_post_float);
MAKE_VAR(_zero_arr_inplace_plus_post_double);
MAKE_VAR(_zero_arr_inplace_plus_post_longdouble);
MAKE_VAR(_zero_arr_inplace_plus_post_voidstar);
MAKE_VAR(_cycalloc);
MAKE_VAR(_cyccalloc);
MAKE_VAR(_cycalloc_atomic);
MAKE_VAR(_cyccalloc_atomic);
MAKE_VAR(_region_malloc);
MAKE_VAR(_region_calloc);
MAKE_VAR(_check_times);
MAKE_VAR(_new_region);
MAKE_VAR(_push_region);
MAKE_VAR(_pop_region);
MAKE_VAR(_open_dynregion);
MAKE_VAR(_push_dynregion);
MAKE_VAR(_pop_dynregion);
MAKE_VAR(_reset_region);
MAKE_VAR(_throw_arraybounds);
MAKE_VAR(_dyneither_ptr_decrease_size);
MAKE_VAR(_swap_word);
MAKE_VAR(_swap_dyneither);
MAKE_VAR(_throw_match);
MAKE_VAR(_rethrow);
MAKE_VAR(_fast_region_malloc);

#undef MAKE_STRING
#undef MAKE_VAR

static datatype Type.AggrType dyneither_ptr_typ_v =
    AggrType(AggrInfo(AggrInfoU{.UnknownAggr = $(StructA,&_dyneither_ptr_pr,NULL)},NULL));

static datatype Type @ dyneither_ptr_typ = &dyneither_ptr_typ_v;

static tqual_t mt_tq = Tqual(false,false,false,false,0);

static stmt_t skip_stmt_dl() {
  static stmt_t * skip_stmt_opt = NULL;
  if(skip_stmt_opt == NULL)
    skip_stmt_opt = new skip_stmt(DL);
  return *skip_stmt_opt;
}

// These constructors are useful when we want to just update the
// raw part of an expression or statement.
static exp_t cast_it(type_t t, exp_t e) {
  return cast_exp(t,e,false,No_coercion,DL);
}
static raw_exp_t cast_it_r(type_t t, exp_t e) {
  return new Cast_e(t,e,false,No_coercion);
}
static raw_exp_t deref_exp_r(exp_t e) {
  return new Deref_e(e);
}
static raw_exp_t subscript_exp_r(exp_t e1, exp_t e2) {
  return new Subscript_e(e1,e2);
}
static raw_exp_t stmt_exp_r(stmt_t s) {
  return new StmtExp_e(s);
}
static raw_exp_t sizeoftyp_exp_r(type_t t) {
  return new Sizeoftyp_e(t);
}
static raw_exp_t fncall_exp_r(exp_t e, list_t<exp_t,`H> es) {
  return new FnCall_e(e,es,NULL,true);
}
static raw_stmt_t exp_stmt_r(exp_t e) {
  return new Exp_s(e);
}
static raw_stmt_t seq_stmt_r(stmt_t s1, stmt_t s2) {
  return new Seq_s(s1,s2);
}
static raw_exp_t conditional_exp_r(exp_t e1, exp_t e2, exp_t e3) {
  return new Conditional_e(e1,e2,e3);
}
static raw_exp_t aggrmember_exp_r(exp_t e, field_name_t n) {
  return new AggrMember_e(e,n,false,false);
}
static raw_exp_t aggrarrow_exp_r(exp_t e, field_name_t n) {
  return new AggrArrow_e(e,n,false,false);
}
static raw_exp_t unresolvedmem_exp_r(opt_t<typedef_name_t,`H> tdopt,
                                     list_t<$(list_t<designator_t,`H>,exp_t)@`H,`H> ds)
{
  return new UnresolvedMem_e(tdopt,ds);
}
static raw_stmt_t goto_stmt_r(var_t v, stmt_opt_t s) {
  return new Goto_s(v,s);
}
static datatype Raw_exp.Const_e zero_exp = Const_e(Cnst{.Int_c= $(Signed,0)});

// same as aggrmember_e(e,f,DL) but when e is a deref_e(e1), replaces with
// aggrarrow_e(e1,f,DL)
static exp_t member_exp(exp_t e, field_name_t f, seg_t loc) {
  switch (e->r) {
  case &Deref_e(e1): return aggrarrow_exp(e1,f,loc);
  default: return aggrmember_exp(e,f,loc);
  }
}

/* functionSets are used to call the appropriate function from
 * cyc_include.h by casing on the type of the arguments
 */
struct functionSet {
  exp_t fchar; exp_t fshort;
  exp_t fint; exp_t ffloat;
  exp_t fdouble; exp_t flongdouble;
  exp_t fvoidstar;
};

struct functionSet _zero_arr_plus_functionSet = functionSet {
  .fchar = &_zero_arr_plus_char_ev,
  .fshort = &_zero_arr_plus_short_ev,
  .fint = &_zero_arr_plus_int_ev,
  .ffloat = &_zero_arr_plus_float_ev,
  .fdouble = &_zero_arr_plus_double_ev,
  .flongdouble = &_zero_arr_plus_longdouble_ev,
  .fvoidstar = &_zero_arr_plus_voidstar_ev
};
struct functionSet _get_zero_arr_size_functionSet = {
  .fchar = &_get_zero_arr_size_char_ev,
  .fshort = &_get_zero_arr_size_short_ev,
  .fint = &_get_zero_arr_size_int_ev,
  .ffloat = &_get_zero_arr_size_float_ev,
  .fdouble = &_get_zero_arr_size_double_ev,
  .flongdouble = &_get_zero_arr_size_longdouble_ev,
  .fvoidstar = &_get_zero_arr_size_voidstar_ev
};
struct functionSet _zero_arr_inplace_plus_functionSet = {
  .fchar = &_zero_arr_inplace_plus_char_ev,
  .fshort = &_zero_arr_inplace_plus_short_ev,
  .fint = &_zero_arr_inplace_plus_int_ev,
  .ffloat = &_zero_arr_inplace_plus_float_ev,
  .fdouble = &_zero_arr_inplace_plus_double_ev,
  .flongdouble = &_zero_arr_inplace_plus_longdouble_ev,
  .fvoidstar = &_zero_arr_inplace_plus_voidstar_ev
};
struct functionSet _zero_arr_inplace_plus_post_functionSet = {
  .fchar = &_zero_arr_inplace_plus_post_char_ev,
  .fshort = &_zero_arr_inplace_plus_post_short_ev,
  .fint = &_zero_arr_inplace_plus_post_int_ev,
  .ffloat = &_zero_arr_inplace_plus_post_float_ev,
  .fdouble = &_zero_arr_inplace_plus_post_double_ev,
  .flongdouble = &_zero_arr_inplace_plus_post_longdouble_ev,
  .fvoidstar = &_zero_arr_inplace_plus_post_voidstar_ev
};

// choose which function to call based on argument type
static exp_t getFunctionType(struct functionSet @fS, type_t t) {
  exp_t function;
  switch(Tcutil::compress(t)) {
  case &IntType(_,sz):
    switch(sz) {
    case Char_sz:  function = fS->fchar;  break;
    case Short_sz: function = fS->fshort; break;
    case Int_sz:   function = fS->fint;   break;
    default: throw new Impossible("impossible IntType (not char, short or int)");
    }
    break;
  case &FloatType(0):
    function = fS->ffloat;
    break;
  case &FloatType(1):
    function = fS->fdouble;
    break;
  case &FloatType(_):
    function = fS->flongdouble;
    break;
  case &PointerType(_):
    function = fS->fvoidstar;
    break;
  default:
    throw new Impossible(aprintf("impossible expression type %s (not int, float, double, or pointer)",typ2string(t)));
  }
  return function;
}
exp_t getFunction(struct functionSet @fS, exp_t arr) {
  return getFunctionType(fS, (type_t)arr->topt);
}
exp_t getFunctionRemovePointer(struct functionSet @fS, exp_t arr) {
  switch (compress((type_t)arr->topt)) {
  case &PointerType(PtrInfo{.elt_typ = et,...}):
      return getFunctionType(fS,et);
  default: throw new Impossible("impossible type (not pointer)");
  }
}

///////////////////////////// Various Utilities /////////////////////////////

/* FIX: this is duplicated in tcutil; but the functions are slightly different */
static bool is_zero(exp_t e) {
  switch (e->r) {
  case &Const_e({.Char_c = $(_,c)}):     return c == '\0';
  case &Const_e({.Wchar_c = s}):
    let l = strlen(s);
    int i = 0;
    if (l>=2 && s[0] == '\\') {
      if (s[1] == '0') i = 2; // octal
      else if (s[1] == 'x' && l>=3 && s[2] == '0') i = 3; // hex
      else return false;
      for (; i<l; i++) // remaining chars must be '0'
        if (s[i] != '0') return false;
      return true;
    }
    else return false;
  case &Const_e({.Short_c = $(_,i)}):    return i == 0;
  case &Const_e({.Int_c = $(_,i)}):      return i == 0;
  case &Const_e({.LongLong_c = $(_,i)}): return i == 0;
  case &Const_e({.Null_c = _}): return true;
  case &Cast_e(_,e1,_,_): return is_zero(e1);
  case &Tuple_e(es): return List::forall(is_zero,es);
  case &Array_e(dles):         fallthru(dles);
  case &Aggregate_e(_,_,dles,_):  fallthru(dles);
  case &CompoundLit_e(_,dles): fallthru(dles);
  case &UnresolvedMem_e(_,dles):
    for (; dles != NULL; dles = dles->tl)
      if (!is_zero((*dles->hd)[1])) return false;
    return true;
  default: return false;
  }
}

// return true if t is a nullable pointer type i.e., *
static bool is_nullable(type_t t) {
  switch (compress(t)) {
  case &PointerType(PtrInfo(_,_,PtrAtts(_,n,_,_,_))):
    return conref_def(false,n);
  default: toc_impos("is_nullable");
  }
}

// If x = X1::X2::...::Xn::v, generate s_X1_X2_..._Xn_v_struct
static string_t collapse_qvar(string_t s, qvar_t x) {
  unsigned slen = strlen(s);
  unsigned len = 9 + slen;  // s + "_struct" + "\0" plus slack
  let &$(namespce,&v) = x;
  unsigned vlen = strlen(v);
  len += 1 + vlen;          // "_" + v
  list_t<var_t> nms;
  switch (namespce) {
  case {.Loc_n = _}: nms = NULL; break;
  case {.Rel_n = vs}: nms = vs; break;
  case {.Abs_n = vs}: nms = vs; break;
  case {.C_n = vs}: nms = vs; break;
  }
  for (let names = nms; names != NULL; names = names->tl)
    len += 1 + strlen(*(names->hd)); // "_" + Xi
  char ? buf = calloc(len,sizeof(char));
  char ? p = buf;
  strcpy(p,s);  p += slen; // s
  for (; nms != NULL; nms = nms->tl) {
    let &X = nms->hd;
    *p = '_'; p++;                    // '_'
    strcpy(p,X);                      // X
    p += strlen(X);
  }
  *p = '_'; p++;                 // '_'
  strcpy(p,v); p += vlen;        // v
  strcpy(p,"_struct");
  return buf;
}

// Used when generating the struct name for a datatype field.  
// If fieldname = N1::N2::...::Nn::f and the datatype name is
// M1::M2::...::Mm::d, then we generate the qvar that looks
// like N1::N2::....::Nn::f_M1_M2_..._Mm_d_struct.  
// FIX: this could conflict with a user-defined struct which
// can cause errors at C-compile time. 
static qvar_t collapse_qvars_body<`r2,`d,`r>(region_t<`d> d, 
                                             $(struct TocState<`d>@`d,
                                               $(qvar_t,qvar_t)@`r2)@`r env) {
  static string_t bogus_string = "*bogus*";
  static $(nmspace_t,var_t) bogus_qvar = $(Nmspace{.Loc_n = 0},&bogus_string);
  static $(qvar_t,qvar_t) pair = $(&bogus_qvar,&bogus_qvar);

  let $(&TocState{.qvar_tags = qvs,...}, pair) = *env;
  let $(fieldname,dtname) = *pair;
  try {
    return Dict::lookup_other(*qvs,qvar_tag_cmp,pair);
  } catch {
  case &Dict::Absent:
    let new_pair = new $(fieldname,dtname);
    let &$(nmspace,&fieldvar) = fieldname;
    string_t newvar = collapse_qvar(fieldvar,dtname);
    qvar_t res = new $(nmspace, new newvar);
    *qvs = Dict::insert(*qvs,new_pair,res);
    return res;
  }
}

static qvar_t collapse_qvars(qvar_t fieldname,qvar_t dtname) {
  _ env = $(fieldname, dtname);
  return use_toc_state(&env, (collapse_qvars_body@<`collapse_qvars>)<>);
}

static type_t typ_to_c(type_t t); // forward declarations

// used to generate struct definitions for tuple types
// we share the struct definitions where possible.
static type_t add_tuple_type_body<`r2,`r3,`d,`r>(region_t<`d> d, 
                                                 $(struct TocState<`d>@`d, 
                                                   list_t<$(tqual_t,type_t)@`r2,`r3> tqs0)@`r env) {
  let $(&TocState{.tuple_types = tuple_types, ...},tqs0) = *env;
  // look for the same tuple-type already declared
  for (let tts = *tuple_types; tts != NULL; tts = tts->tl) {
    let &$(x,ts) = tts->hd;
    let tqs = tqs0;
    for (; tqs != NULL && ts != NULL; tqs = tqs->tl, ts = ts->tl)
      if (!unify((*tqs->hd)[1],ts->hd))
        break;
    if(tqs == NULL && ts == NULL)
      return x;
  }
  // haven't seen this one before, add a declaration
  stringptr_t xname = new (string_t)aprintf("_tuple%d",tuple_type_counter++);
  type_t x = strct(xname);
  list_t<type_t> ts = List::rmap(d,snd_tqt,tqs0);
  let fs = NULL;
  list_t<type_t> ts2 = ts;
  for (int i=1; ts2 != NULL; ts2 = ts2->tl, i++)
    fs = new List(new Aggrfield(fieldname(i),mt_tq,ts2->hd,NULL,NULL,NULL),fs);
  fs = List::imp_rev(fs);
  let sd = new Aggrdecl{.kind=StructA, .sc = Public,
                        .name = new $(Rel_n(NULL),xname), .tvs = NULL,
                        .impl = new AggrdeclImpl{.exist_vars = NULL,
                                                 .rgn_po = NULL,
                                                 .fields = fs,
                                                 .tagged=false},
                        .attributes = NULL, .expected_mem_kind = false};
  result_decls = new List(new_decl(new Aggr_d(sd),DL),result_decls);
  *tuple_types  = rnew(d) List(rnew(d) $(x,ts),*tuple_types);
  return x;
}

static type_t add_tuple_type(list_t<$(tqual_t,type_t)@`r,`r2> tqs0) {
  return use_toc_state(tqs0, (add_tuple_type_body@<`r,`r2>)<>);
}

// similar to the above, except that we're working with an instantiated
// abstract struct.  The fieldnames are thus drawn from the actual
// struct fields and in addition, we have to worry about the instantiation.
// It's very important that we share as many instantiations as possible
// to get the translation right.  
static type_t add_struct_type_body<`r2,`r3,`d,`r>(region_t<`d> d,
                                                  $(struct TocState<`d>@`d s,
                                                    $(qvar_t struct_name,
                                                      list_t<tvar_t,`H> type_vars,
                                                      list_t<type_t,`H> type_args,
                                                      list_t<aggrfield_t,`r2> fields)@`r3)@`r env) {
  // first, filter out the type_vars and type_args that are not of
  // type or integer kind.
  let $(&TocState{.abs_struct_types = abs_struct_types, ...},
        &$(struct_name, type_vars, type_args, fields)) = *env;
  //fprintf(stderr,"adding struct %s\n",typ2string(new AggrType(AggrInfo{AggrInfoU{.UnknownAggr = $(StructA,struct_name,NULL)},type_args})));
                                      
  // look for the same instantiation of abstract-struct-type already declared
  for (let tts = *abs_struct_types; tts != NULL; tts = tts->tl) {
    let &$(x,ts2,t) = tts->hd;
    //fprintf(stderr,"  comparing against struct %s\n",typ2string(new AggrType(AggrInfo{AggrInfoU{.UnknownAggr = $(StructA,x,NULL)},ts2})));
    if (qvar_cmp(x,struct_name) == 0 &&
        List::length(type_args) == List::length(ts2)) {
      bool okay = true;
      for (let ts = type_args; ts != NULL; ts=ts->tl, ts2=ts2->tl) {
        let t = ts->hd;
        let t2 = ts2->hd;
        //fprintf(stderr,"    comparing args %s and %s -- ",typ2string(t),typ2string(t2));
        switch (typ_kind(t)) {
        case &Kind{.kind = EffKind, _}: 
        case &Kind{.kind = RgnKind, _}: 
          // Effects and Regions won't show up in the toc types.
          //fprintf(stderr,"effect or region -- skipping\n");
          continue;
        default:
          // Check if they're the same before translating them to C
          if (unify(t,t2) || unify(typ_to_c(t),typ_to_c(t2))) {
            //fprintf(stderr," succeeded\n");
            continue;
          }
          //fprintf(stderr," failed\n");
          okay = false; 
          break;
        }
        break;
      }
      if (okay) {
        //fprintf(stderr,"found pre-existing type\n");
        return t;
      }
    }
  }
  //fprintf(stderr,"didn't find pre-existing type\n");
  // haven't seen this one before, add a declaration
  // we're calling it a "tuple" so we don't have to worry about name
  // clashes.
  stringptr_t xname = new (string_t)aprintf("_tuple%d",tuple_type_counter++);
  type_t x = strct(xname);
  let fs = NULL;
  // go ahead and add this to the struct types
  *abs_struct_types  = rnew(d) List{rnew(d) $(struct_name,type_args,x),
                                    *abs_struct_types};
  // copy the fields over
  region r;
  let inst = List::rzip(r,r,type_vars,type_args);
  for (; fields != NULL; fields = fields->tl) {
    let f = fields->hd;
    type_t t = f->type;
    attributes_t atts = f->attributes;
    // if the original type was abstract, then we must force the field
    // to be aligned.
    if (fields->tl == NULL && kind_leq(&ak,typ_kind(t))) {
      atts = new List(new Aligned_att(NULL),atts);
    }
    t = typ_to_c(rsubstitute(r,inst,t));
    // still could be abstract and end up void -- if so, make it
    // a zero-sized array of void*'s and force it to be aligned.
    if (unify(t,&VoidType_val)) {
      t = new ArrayType(ArrayInfo(void_star_typ(), empty_tqual(DL),
                                  uint_exp(0,DL), new_conref(false), DL));
    }
    fs = new List(new Aggrfield{f->name,mt_tq,t,f->width,atts,NULL},fs);
  }
  fs = List::imp_rev(fs);
  let sd = new Aggrdecl{.kind=StructA, .sc = Public,
                        .name = new $(Rel_n(NULL),xname), .tvs = NULL,
                        .impl = new AggrdeclImpl{.exist_vars = NULL,
                                                 .rgn_po = NULL,
                                                 .fields = fs,
                                                 .tagged=false},
                        .attributes = NULL, .expected_mem_kind = false};
  result_decls = new List(new_decl(new Aggr_d(sd),DL),result_decls);
  return x;
}

static type_t add_struct_type(qvar_t struct_name,
                              list_t<tvar_t,`H> type_vars,
                              list_t<type_t,`H> type_args,
                              list_t<aggrfield_t,`r> fields) {
  _ env = $(struct_name, type_vars, type_args, fields);
  return use_toc_state(&env, (add_struct_type_body@<`r,`add_struct_type>)<>);
}


// generate a temporary variable
// FIX: need to guarantee these can't conflict
qvar_t temp_var() {
  let i = temp_var_counter++;
  qvar_t res = new $(Loc_n,new (string_t)aprintf("_tmp%X",i));
  return res;
}

// generate a fresh label
// FIX: need to guarantee these can't conflict
static var_t fresh_label_body<`d,`r>(region_t<`d> d, $(struct TocState<`d>@`d,int)@`r env) {
  let $(&TocState{.temp_labels = temp_labels, ...},_) = *env;
  let i = fresh_label_counter++;
  if (i < Xarray::length(temp_labels))
    return Xarray::get(temp_labels,i);
  var_t res = new (string_t)aprintf("_LL%X",i);
  if (Xarray::add_ind(temp_labels,res) != i)
    toc_impos("fresh_label: add_ind returned bad index...");
  return res;
}

static var_t fresh_label() {
  return use_toc_state(0, fresh_label_body<>);
}

// These two functions should never be used for xdatatypes. Should memoize?
// Note the former used to use static const int variables, but couldn't
// at top-level.
static exp_t datatype_tag(datatypedecl_t td, qvar_t name) {
  int ans = 0;
  let fs  = td->fields->v;
  while(qvar_cmp(name,fs->hd->name)!=0) {
    ++ans;
    fs = fs->tl;
  }
  return uint_exp(ans,DL);
}

///////////////////////////////////////////////////////////////
//         Convert a Cyclone type to a C type                //
///////////////////////////////////////////////////////////////
static void enumdecl_to_c(enumdecl_t ed);
static void aggrdecl_to_c(aggrdecl_t ad, bool add_to_result_decls);
static void datatypedecl_to_c(datatypedecl_t tud);
static $(var_opt_t,tqual_t,type_t)@
arg_to_c($(var_opt_t,tqual_t,type_t)@ a) {
  let $(x,y,z) = *a;
  return new $(x,y,typ_to_c(z));
}
static $(tqual_t,type_t)@ typ_to_c_f($(tqual_t,type_t)@ x) {
  let $(a,b) = *x;
  return new $(a,typ_to_c(b));
}
// Sometimes we translate arrays t[] and t[N] to t*, and sometimes
// we leave them alone.  We must leave them alone in the following
// circumstances:
// 1. as the argument of sizeof
// 2. in typedef
// 3. in declarations
// 4. as the element type of an array
// 5. as the type part of a C9X compound literal
// 6. as the type of a struct field
// We must change them to pointers in the following circumstances:
// 1. as the argument of cast
// We can do either in the following circumstances:
// 1. as the parameter of a function
// The function typ_to_c_array changes them, while typ_to_c
// changes them to pointers.
static type_t typ_to_c_array(type_t t) {
  switch(compress(t)) {
  case &ArrayType(ArrayInfo{t2,tq,x,zt,ztl}): // FIX: do we handle tq correctly?
    return cstar_typ(typ_to_c_array(t2),tq);
  case &Evar(_,t2,_,_) && t2 != NULL: return typ_to_c_array((type_t)t2);
  default: return typ_to_c(t);
  }
}

static aggrfield_t aggrfield_to_c(aggrfield_t f) {
  // JGM: I'm making the qualifiers non-const here to allow initialization
  return new Aggrfield{.name=f->name,
                       .tq=mt_tq, // .tq=f->tq,
                       .type = typ_to_c(f->type),
                       .width=f->width, .attributes=f->attributes,
                       .requires_clause = NULL};
}

static void enumfields_to_c(list_t<enumfield_t> fs) {
  // warning: assumes all constant expressions are fine as C expressions
  return;
}

static type_t char_star_typ() {
  static type_t* cs = NULL;
  if (cs == NULL) {
    cs = new star_typ(char_typ,&HeapRgn_val,mt_tq,false_conref);
  }
  return *cs;
}
static type_t rgn_typ() {
  static type_t* r = NULL;
  if (r == NULL) {
    r = new cstar_typ(strct(_RegionHandle_sp),mt_tq);
  }
  return *r;
}
static type_t dyn_rgn_typ() {
  static type_t* r = NULL;
  if (r == NULL) {
    r = new cstar_typ(strct(_DynRegionHandle_sp),mt_tq);
  }
  return *r;
}
static bool is_boxed_tvar(type_t t) {
  switch (compress(t)) {
  case &VarType(tv):
    return kind_leq(typ_kind(t),&tbk);
  default: return false;
  }
}
static bool is_abstract_type(type_t t) {
  switch (typ_kind(t)) {
  case &Kind{.kind = AnyKind, ...}: return true;
  default: return false;
  }
}

static type_t typ_to_c(type_t t) {
  switch (t) {
  case &VoidType: return t;
  case &Evar(_,*t2,_,_): 
    if (*t2 == NULL) {
      *t2 = sint_typ;
      return sint_typ;
    }
    return typ_to_c((type_t)(*t2));
  case &VarType(tv):
    if (tvar_kind(tv,&bk)->kind == AnyKind) {
//       fprintf(stderr,"Mapping type var %s to void; has AnyKind\n",
// 	      *(tv->name));
      return &VoidType_val;
    }
    else return void_star_typ(); // map `a to void *
  case &DatatypeType(_):
    return &VoidType_val;
  case &DatatypeFieldType(DatatypeFieldInfo{{.KnownDatatypefield=$(tud,tuf)},_}):
    return strctq(collapse_qvars(tuf->name,tud->name));
  case &DatatypeFieldType(_): toc_impos("unresolved DatatypeFieldType");
  case &PointerType(PtrInfo(t2,tq,PtrAtts(_,_,bnds,_,_))):
    // t2? maps to struct dyneither_ptr.
    // t2* and t2@ map to t2*.  Regions and zero-term are irrelevant.
    t2 = typ_to_c(t2);
    switch (conref_def((bounds_t)&DynEither_b_val,bnds)) {
    case &DynEither_b: return dyneither_ptr_typ;
    default: return star_typ(t2,&HeapRgn_val,tq,false_conref);
    }
  case &IntType(_,_):
  case &FloatType(_): return t;
  case &ArrayType(ArrayInfo{t2,tq,e,_,ztl}):
    return array_typ(typ_to_c(t2),tq,e,false_conref,ztl);
  case &FnType(FnInfo{_,_,tq2,t2,args,c_vararg,cyc_vararg,_,atts,_,_,_,_}):
    // just drop the type arguments & effect and translate the nested types
    // also, drop any format descriptors
    // FIX:  problem with higher-order functions?  Again C's rules are strange.
    // FIX:  dropping noreturn and const attributes b/c C is complaining.
    let new_atts = NULL;
    for (; atts != NULL; atts = atts->tl)
      switch (atts->hd) {
      case &Noreturn_att:
      case &Const_att:
      case &Format_att(_,_,_): continue;
      case &Noconsume_att(_): continue; // correct: a Cyclone addition
      case &Noliveunique_att(_): continue; // correct: a Cyclone addition
      case &Initializes_att(_): continue; // correct: a Cyclone addition
      default: new_atts = new List(atts->hd,new_atts); break;
      }
    let new_args = List::map(arg_to_c,args);
    if (cyc_vararg != NULL) {
      // region for array type irrelevant
      let t =typ_to_c(dyneither_typ(cyc_vararg->type,&HeapRgn_val,mt_tq,false_conref));
      let vararg = new $(cyc_vararg->name,cyc_vararg->tq,t);
      new_args = List::imp_append(new_args,new List(vararg,NULL));
    }
    return new FnType(FnInfo{NULL,NULL,tq2,typ_to_c(t2),new_args,
                               c_vararg,NULL,NULL,new_atts,NULL,NULL,NULL,NULL});
  case &TupleType(tqs):
    // $(t1,...,tn) maps to struct tuple_type_n where we define
    // struct tuple_type_n { t1 f1; ...; tn fn; };
    tqs = List::map(typ_to_c_f,tqs);
    return add_tuple_type(tqs);
  // FIX: we may have to actually declare these things and use them
  // consistently to make GCC happy.
  case &AnonAggrType(k,fs):
    return new AnonAggrType(k,List::map(aggrfield_to_c,fs));
  case &AggrType(AggrInfo(info,ts)):
    // We may be in C code, in which case the implementation may not be set
    // here.
    switch (info) {
    case {.UnknownAggr = _}: return t;
    default: break;
    }
    let ad = get_known_aggrdecl(info);
    if (ad->expected_mem_kind) {
      // check that it turned out to be a mem!
      if (ad->impl == NULL) 
        Tcutil::warn(0, "%s %s was never defined.",
                     (ad->kind==UnionA) ? "union" : "struct",
                     qvar2string(ad->name));
    }
    // XXX I think this is where new instantiation types are
    // generated; want to adapt this for unions here.
    // Have to watch out for flaky gcc ...
    if(ad->kind==UnionA)
      return aggrdecl_type(ad->name,unionq_typ);
    let fs = (ad->impl == NULL) ? NULL : ad->impl->fields;
    if (fs == NULL) return aggrdecl_type(ad->name,strctq);
    for (; fs->tl != NULL; fs = fs->tl);
    let last_type = fs->hd->type;
    if (kind_leq(&ak,typ_kind(last_type))) {
      if (ad->expected_mem_kind) {
        Tcutil::warn(0, "struct %s ended up being abstract.",
                     qvar2string(ad->name));
      }                     
      // To avoid looping, make sure the instantiation of the last
      // type is not still abstract.  If it is, we can just return
      // the struct type.
      region r;
      let inst = rzip(r,r,ad->tvs,ts);
      let t = rsubstitute(r,inst,last_type);
      if (is_abstract_type(t)) return aggrdecl_type(ad->name,strctq);
      return add_struct_type(ad->name,ad->tvs,ts,ad->impl->fields);
    }
    return aggrdecl_type(ad->name,strctq);
  case &EnumType(tdn,_): return t;
  case &AnonEnumType(fs): enumfields_to_c(fs); return t;
  case &TypedefType(tdn,ts,td,topt):
    if (topt == NULL || noexpand_r)
      if (ts != NULL)
        return new TypedefType(tdn,NULL,td,NULL);
      else return t;
    // just drop the type arguments and translate the nested types
    else return new TypedefType(tdn,NULL,td,typ_to_c((type_t)topt));
  case &TagType(_): return uint_typ; // must be unsigned!
  case &RgnHandleType(t): return rgn_typ();
  case &DynRgnType(_,_): return dyn_rgn_typ();
  // these types get translated when we instantiate aggregates with
  // abstract members -- we just translate them to void* to save pain.
  case &HeapRgn:
  case &UniqueRgn:
  case &RefCntRgn:
  case &AccessEff(_):
  case &JoinEff(_):
  case &RgnsEff(_): return void_star_typ();
    // FIX: when we instantiate a struct parameterized by `i::I with
    // valueof_t(42), then we want the 42 to get propagated to any arrays
    // that might occur within.  So, for now, we don't do any translation.
    // This will bite me somewhere else...
  case &ValueofType(e): return t;
    // FIX: we really need to translate e!
  case &TypeofType(e): return t;
  case &BuiltinType(...): return t;
  case &TypeDeclType(&{.r = &Aggr_td(ad),...},_):
    aggrdecl_to_c(ad,true);
    if (ad->kind==UnionA)
      return aggrdecl_type(ad->name,unionq_typ);
    else return aggrdecl_type(ad->name,strctq);
  case &TypeDeclType(&{.r = &Enum_td(ed),...},_):
    enumdecl_to_c(ed);
    return t;
  case &TypeDeclType(&{.r = &Datatype_td(dd),...},t):
    datatypedecl_to_c(dd);
    return typ_to_c(*t);
  }
}

static exp_t array_to_ptr_cast(type_t t,exp_t e,seg_t l) {
  switch (t) {
  case &ArrayType(ArrayInfo{t2,tq,_,_,_}):
    return cast_it(star_typ(t2,&HeapRgn_val,tq,false_conref),e);
  default: return cast_it(t,e);
  }
}

// returns true when the type contains no pointers. Is conservative
// (does not look at instantiations)
static bool atomic_typ(type_t t) {
  switch (compress(t)) {
  case &VoidType:       return true;
  case &VarType(_):    return false;
  case &IntType(_,_):
  case &EnumType(_,_):
  case &AnonEnumType(_):
  case &FloatType(_):
  case &FnType(_):
  case &TagType(_): return true;
  case &ArrayType(ArrayInfo{t,_,_,_,_}): return atomic_typ(t);
    // FIX: really should compute in terms of the instantiation
    // to be as aggressive as possible.
    // note even without this we'll allocate Position::seg_t with atomic.
    // NOTE: cannot call get_known_aggrdecl b/c we sometimes call this
    // post-translation (with unchecked C types)?? (We shouldn't)
  case &AggrType(AggrInfo(info,_)):
    switch(info) {
    case {.UnknownAggr = _}: return false; // see above!
    default: break;
    }
    let ad = get_known_aggrdecl(info);
    if(ad->impl == NULL)
      return false;
    for(let fs = ad->impl->fields; fs != NULL; fs = fs->tl)
      if (!atomic_typ(fs->hd->type)) return false;
    return true;
  case &AnonAggrType(_,fs):
    for (; fs != NULL; fs = fs->tl)
      if (!atomic_typ(fs->hd->type)) return false;
    return true;
  case &DatatypeFieldType(DatatypeFieldInfo{{.KnownDatatypefield=$(tud,tuf)},_}):
    fallthru(tuf->typs);
  case &TupleType(tqs):
    for (; tqs != NULL; tqs = tqs->tl)
      if (!atomic_typ((*tqs->hd)[1])) return false;
    return true;
    // FIX: can do better if all variants are fieldless (but then they could
    //      have used an enum)
  case &DatatypeType(_):
  case &PointerType(_):
  case &DynRgnType(_,_):
  case &RgnHandleType(_): return false;
  default: toc_impos("atomic_typ:  bad type %s",typ2string(t));
  }
}

static bool is_void_star(type_t t) {
  switch (compress(t)) {
  case &PointerType(PtrInfo{t2,_,_}):
    switch (compress(t2)) {
    case &VoidType: return true;
    default:       return false;
    }
  default: return false;
  }
}

static bool is_void_star_or_boxed_tvar(type_t t) {
  return is_void_star(t) || is_boxed_tvar(t);
}

static bool is_pointer_or_boxed_tvar(type_t t) {
  return is_pointer_type(t) || is_boxed_tvar(t);
}

// returns true when field f of the struct/union t has type void*.
static bool is_poly_field(type_t t, field_name_t f) {
  switch (compress(t)) {
  case &AggrType(AggrInfo(info,_)):
    let ad = get_known_aggrdecl(info);
    if (ad->impl == NULL)
      toc_impos("is_poly_field: type missing fields");
    fallthru(ad->impl->fields);
  case &AnonAggrType(_,fs):
    let field = lookup_field(fs,f);
    if (field == NULL)
      toc_impos("is_poly_field: bad field %s",*f);
    return is_void_star_or_boxed_tvar(field->type);
  default: toc_impos("is_poly_field: bad type %s",typ2string(t));
  }
}

// returns true when e is projection of a field in a struct that has a
// variable type before instantiation.  For instance, the field hd has
// type `a before instantiation in struct List.
static bool is_poly_project(exp_t e) {
  switch (e->r) {
  case &AggrMember_e(e1,f,_,_): 
    return is_poly_field((type_t)e1->topt,f) && 
      !is_void_star_or_boxed_tvar((type_t)e->topt);
  case &AggrArrow_e(e1,f,_,_):
    switch (compress((type_t)e1->topt)) {
    case &PointerType(PtrInfo{t,_,_}): 
      return is_poly_field(t,f) && !is_void_star_or_boxed_tvar((type_t)e->topt);
    default: toc_impos("is_poly_project: bad type %s",typ2string((type_t)e1->topt));
    }
  default: return false;
  }
}

// possible pointer malloc
static exp_t malloc_ptr(exp_t s) {
  return fncall_exp(_cycalloc_e, new List(s,NULL),DL);
}
// no pointers possible malloc
static exp_t malloc_atomic(exp_t s) {
  return fncall_exp(_cycalloc_atomic_e, new List(s,NULL),DL);
}
// malloc something -- choose malloc routine according to the (Cyclone) type
static exp_t malloc_exp(type_t t,exp_t s) {
  if (atomic_typ(t))
    return malloc_atomic(s);
  return malloc_ptr(s);
}
// region malloc something
static exp_t rmalloc_exp(exp_t rgn, exp_t s) {
  return fncall_exp(_region_malloc_e, list(rgn,s), DL);
}
// region malloc (inlined) something
static exp_t rmalloc_inline_exp(exp_t rgn, exp_t s) {
  return fncall_exp(_fast_region_malloc_e, list(rgn,s), DL);
}
// calloc something
static exp_t calloc_exp(type_t elt_type, exp_t s, exp_t n) {
  if (atomic_typ(elt_type))
    return fncall_exp(_cyccalloc_atomic_e, list(s,n), DL);
  else
    return fncall_exp(_cyccalloc_e, list(s,n), DL);
}
// rcalloc something
static exp_t rcalloc_exp(exp_t rgn, exp_t s, exp_t n) {
  return fncall_exp(_region_calloc_e, list(rgn,s,n), DL);
}

// throw an exception -- this is turned into a function call
static exp_t newthrow_exp(exp_t e) {
  return fncall_exp(_throw_e, new List(e,NULL), DL);
}
static exp_t newrethrow_exp(exp_t e) {
  return fncall_exp(_rethrow_e, new List(e,NULL), DL);
}
// throw a match exception
static stmt_t throw_match_stmt() {
  return exp_stmt(fncall_exp(_throw_match_e,list(),DL),DL);
}


// t*{sz} -> t? at top-level
static exp_t make_toplevel_dyn_arr(type_t t, exp_t sz, exp_t e) {
  // Note e must be either (a) a string or else (b) a [possibly cast]
  // identifier that is an array.
  // For case a, we generate
  //   t x[sz] = e;
  //   {x,x,x+sz};
  // For case b, we generate
  //   {e,e,e+sz};
  bool is_string = false;
  switch (e->r) {
  case &Const_e({.String_c = _}): is_string = true; break;
  case &Const_e({.Wstring_c = _}): is_string = true; break;
  default: break;
  }
  exp_t xexp;
  exp_t xplussz;
  if (is_string) {
    qvar_t    x      = temp_var();
    type_t    vd_typ = array_typ(char_typ,mt_tq,sz,false_conref,DL);
    vardecl_t vd     = static_vardecl(x,vd_typ,e);
    result_decls = new List(new_decl(new Var_d(vd),DL),result_decls);
    xexp = var_exp(x,DL);
    xplussz = add_exp(xexp,sz,DL);
  } else {
    xexp = cast_it(void_star_typ(),e);
    // Note: If e is NULL, element size of 0 is fine!
    xplussz = cast_it(void_star_typ(),add_exp(e,sz,DL));
  }
  exp_t urm_exp;
  urm_exp = unresolvedmem_exp(NULL,list(new $(NULL,xexp),
                                        new $(NULL,xexp),
                                        new $(NULL,xplussz)),DL);
  return urm_exp;
}

///////////////////////////////////////////////////////////////
//              Translation Environments                     //
///////////////////////////////////////////////////////////////
// When break_lab is NULL, translate break to break.  Otherwise,
// translate break to goto of the given label.  Similarly for
// continue.  This is used in the translation of switches and
// exception handlers to get the right control-flow.
//
// The varmap is used to map source identifiers to certain expressions.
// This is primarily used in the pattern match compilation.
//
// Translation of fallthru(e1,...,en) is
// varmap'(qv1) = trans(e1); ... varmap'(qvn) = trans(en);
// goto fallthru_info->v[0]
// where the ith element of fallthru_info->v[1] is qvi
// and varmap' is fallthru_info->v[2]
// (We also have to pop handlers as explained above.)
static struct FallthruInfo<`r::R> {
  var_t label;
  list_t<qvar_t,`r> binders;
  Dict::dict_t<qvar_t,exp_t,`r> next_case_env;
};

static struct StructInfo {
  exp_opt_t @ varsizeexp; // size of comprehension for nested struct init
  exp_opt_t lhs_exp;        // lhs to which to (optionally) assign the curr exp
};

static struct Env<`r::R> {
  <`r2::R> : {`r2} > `r
  var_t *`r       break_lab;
  var_t *`r       continue_lab;
  struct FallthruInfo<`r2> *`r2 fallthru_info;
  Dict::dict_t<qvar_t,exp_t,`r> varmap;
  bool toplevel;
  bool @`r2 in_lhs;
  struct StructInfo struct_info;
  bool @`r2 in_sizeof;
  region_t<`r> rgn;
};
typedef struct Env<`r> @`r env_t<`r>;

static bool is_toplevel(env_t nv) {
  let &Env{.toplevel=t,...} = nv;
  return t;
}
static bool in_lhs(env_t nv) {
  let &Env{.in_lhs=b,...} = nv;
  return *b;
}

static exp_t lookup_varmap(env_t nv, qvar_t x) {
  let &Env{.varmap=v,...} = nv;
  return Dict::lookup(v,x);
}

// the empty environment
static env_t<`r> empty_env(region_t<`r> r) {
  return rnew(r) Env{.break_lab     = NULL,
                     .continue_lab  = NULL,
                     .fallthru_info = NULL,
                     .varmap        = Dict::rempty(r,qvar_cmp),
                     .toplevel      = true,
                     .in_lhs        = rnew(r) false,
		     .struct_info   = {new NULL,NULL},
                     .in_sizeof     = rnew(r) false,
                     .rgn           = r};
}

static env_t<`r> share_env(region_t<`r> r, env_t<`r2> e : {`r2} > `r) {
  let &Env{b,c,f,v,t,lhs,vs,sz,_} = e;
  return rnew(r) Env{b,c,f,Dict::rshare(r,v),t,lhs,vs,sz,r};
}

static env_t<`r> clear_toplevel(region_t<`r> r, env_t<`r2> e : {`r2} > `r) {
  let &Env{b,c,f,v,t,lhs,vs,sz,_} = e;
  return rnew(r) Env{b,c,f,Dict::rshare(r,v),false,lhs,vs,sz,r};
}
static env_t<`r> set_toplevel(region_t<`r> r, env_t<`r2> e : {`r2} > `r) {
  let &Env{b,c,f,v,t,lhs,vs,sz,_} = e;
  return rnew(r) Env{b,c,f,Dict::rshare(r,v),true,lhs,vs,sz,r};
}
static void set_lhs(env_t<`r> e, bool b) {
  let &Env{.in_lhs = lhs,...} = e;
  *lhs = b;
}
static bool set_in_sizeof(env_t<`r> e, bool b) {
  let &Env{.in_sizeof = sz,...} = e;
  let old_b = *sz;
  *sz = b;
  return old_b;
}
static bool in_sizeof(env_t<`r> e) {
  let &Env{.in_sizeof = sz,...} = e;
  return *sz;
}

static env_t<`r> set_lhs_exp(region_t<`r> r, exp_opt_t exp,
                             env_t<`r2> e : {`r2} > `r) {
  let &Env{b,c,f,v,t,lhs,{vexp,_},sz,_} = e;
  return rnew(r) Env{b,c,f,Dict::rshare(r,v),t,lhs,{vexp,exp},sz,r};
}

// add x->y to variable map in environment
// The type allows y to be a general exp, but in practice it is always a var_exp
static env_t<`r> add_varmap(region_t<`r> r, env_t<`r2> e, qvar_t x, exp_t y : {`r2} > `r) {
  switch ((*x)[0]) {
  case {.Rel_n = _}:
    toc_impos("Toc::add_varmap on Rel_n: %s\n", qvar2string(x));
  default: break;
  }
  let &Env{b,c,f,v,t,lhs,vs,sz,_} = e;
  let new_v = Dict::insert(Dict::rshare(r,v), x, y);
  return rnew(r) Env{b,c,f,new_v,t,lhs,vs,sz,r};
}

// env for loop body: break and continue labels are set to null,
// exception handler pop counters for break and continue are zeroed
static env_t<`r> loop_env(region_t<`r> r, env_t<`r2> e : {`r2} > `r) {
  let &Env{b,c,f,v,t,lhs,vs,sz,_} = e;
  return rnew(r) Env{NULL,NULL,f,Dict::rshare(r,v),t,lhs,vs,sz,r};
}

// env for a switch clause: give new label for break, and zero its pop counter
static env_t<`r>
non_last_switchclause_env(region_t<`r> r,
                          env_t<`r2> e, var_t break_l, var_t fallthru_l,
                          list_t<vardecl_t> fallthru_binders,
                          env_t<`r3> next_case_env : {`r2} > `r, {`r3} > `r) {
  list_t<qvar_t,`r> fallthru_vars = NULL;
  for(; fallthru_binders != NULL; fallthru_binders = fallthru_binders->tl)
    fallthru_vars = rnew(r) List(fallthru_binders->hd->name, fallthru_vars);
  fallthru_vars = List::imp_rev(fallthru_vars);
  let &Env{b,c,f,v,t,lhs,vs,sz,_} = e;
  let &Env{_,_,_,next_case_varmap,_,_,_,_,_} = next_case_env;
  struct FallthruInfo<`r>*`r fi =
    rnew(r) FallthruInfo{fallthru_l,fallthru_vars,
                           Dict::rshare(r,next_case_varmap)};
  return rnew(r) Env{rnew(r) break_l, c, fi, Dict::rshare(r,v),t,lhs,vs,sz,r};
}

static env_t<`r>
last_switchclause_env(region_t<`r> r, env_t<`r2> e, var_t break_l :
                      {`r2} > `r) {
  let &Env{b,c,f,v,t,lhs,vs,sz,_} = e;
  return rnew(r) Env{rnew(r) break_l,c,NULL,Dict::rshare(r,v),t,lhs,vs,sz,r};
}

// must have no pattern vars and type is int, char, or datatype of a type
// with no value constructors. (If it weren't for allowing fallthru
// anywhere, we wouldn't need the next_l.)
static env_t<`r>
switch_as_switch_env(region_t<`r> r, env_t<`r2> e, var_t next_l :
                     {`r2} > `r) {
  let &Env{b,c,f,v,t,lhs,vs,sz,_} = e;
  return rnew(r) Env{NULL,c,rnew(r) FallthruInfo{next_l,NULL,
                                                   Dict::rempty(r,qvar_cmp)},
                       Dict::rshare(r,v), t, lhs, vs, sz, r};
}

#ifdef COARSE_REGIONS
#define TOC_RGN(env,r) let &Env{.rgn = r, ...} = (env);
#else
#define TOC_RGN(env,r) region r;
#endif

///////////////////////////////////////////////////////////////
//              Translation of Expressions                   //
///////////////////////////////////////////////////////////////
static void exp_to_c(env_t nv, exp_t e); // forward declaration
static void stmt_to_c(env_t nv, stmt_t s); // forward declaration

static bool need_null_check(exp_t e) { // e must be pre-translation!
  //fprintf(stderr,"checking need_null_check on %s\n",exp2string(e));
  switch(e->annot) {
  case &CfFlowInfo::UnknownZ(_): 
    //fprintf(stderr,"annotation is unknown\n");
    return is_nullable((type_t)e->topt);
  case &CfFlowInfo::NotZero(_):  
    //fprintf(stderr,"annotation is notzero\n");
    return false;
  case &CfFlowInfo::IsZero:
    Tcutil::terr(e->loc,"dereference of NULL pointer");
    return false;
  case &EmptyAnnot:
    // warning is unfounded under sizeof as in memcpy
    // Tcutil::warn(e->loc,"unreachable dereference");
    //fprintf(stderr,"annotation is empty\n");
    return true;
  default: toc_impos("need_null_check");
  }
}

static Relations::relns_t get_relns(exp_t e) { // e must be pre-translation!
  switch (e->annot) {
  case &CfFlowInfo::UnknownZ(r): return r;
  case &CfFlowInfo::NotZero(r):  return r;
  case &CfFlowInfo::IsZero:
    Tcutil::terr(e->loc,"dereference of NULL pointer");
    return NULL;
  case &EmptyAnnot: return NULL;
  default: toc_impos("get_relns");
  }
}

// return true if we can prove from relns that i < numelts(a)
//  FIX: doesn't deal with the case where i is a constant and a's size
//  can be found.
static bool check_bounds(type_t a_typ, Relations::relns_t<`H> relns,
                         exp_t a, exp_t i) {
#ifdef BCE_DEBUG
  fprintf(stderr,"bounds check on %s:%s and %s\n",exp2string(a),
          typ2string(a_typ),exp2string(i));
  fprintf(stderr,"relns: ["); Relations::print_relns(stderr,relns);
  fprintf(stderr,"]\n");
#endif
  // if a has type T*{x} or T[x], then we can pretend like it's
  // a variable to get the rest of this code to work out.
  Relations::reln_op_t rop_i = Relations::RConst(0); // dummy value
  bool valid_rop_i = Relations::exp2relnop(i,&rop_i);

  vardecl_t x;
  switch (a->r) {
  case &Var_e(_,b):
    let x1 = Tcutil::nonesc_vardecl(b);
    if (x1 == NULL) fallthru;
    x = (vardecl_t)x1;
    break;
  default:
    // we're going to fake up a vardecl here
    static string_t bogus_string = "*bogus*";
    static $(nmspace_t,var_t) bogus_qvar =
      $(Nmspace{.Loc_n = 0},&bogus_string);
    static struct Vardecl bogus_vardecl =
    {.sc = Public, .name = &bogus_qvar,
     .tq = Tqual{false,false,false,false,0},
     .type = &VoidType_val, .initializer = NULL, .rgn = NULL,
     .attributes = NULL, .escapes = false};

    x = &bogus_vardecl;
    x->type = a_typ;
  }
  let xtype = a_typ;
  Relations::reln_op_t rop_a = Relations::RNumelts(x);

  // if x's type is T*{e}, T@{e}, or T[e] then we want to 
  // add a constraint of the form e <= numelts(x)
  exp_opt_t bound = Tcutil::get_type_bound(xtype);
  if (bound != NULL) {
    Relations::reln_op_t rop_bound = Relations::RConst(0); // bogus value
    if (Relations::exp2relnop(bound,&rop_bound))
      relns = Relations::add_relation(heap_region,rop_bound,
                                      Relations::Rlte,rop_a,relns);
  }

  // check to see if adding numelts(x) <= i to relns is inconsistent
  if (valid_rop_i) {
    let rlns = Relations::add_relation(heap_region,rop_a,
                                       Relations::Rlte,rop_i,relns);
#ifdef BCE_DEBUG
    fprintf(stderr,"checking consistency of: "); 
    Relations::print_relns(stderr,rlns);
    fprintf(stderr,"\n");
#endif
    if (!Relations::consistent_relations(rlns)) return true;
  }

inner_loop:
  switch (i->r) {
  case &Cast_e(t,e2,_,_): i = e2; goto inner_loop;
  case &Primop_e(Mod,&List(e1,&List(e2,_))):
    // we have x[e1 % e2]
    // if e2 is numelts(x) or z such that z <= numelts(x) then it's okay
    Relations::reln_op_t rop_z = Relations::RConst(0); // dummy
    if (Relations::exp2relnop(e2,&rop_z)) {
      // add numelts(x) < z and check to see if it's inconsistent
      let rlns = Relations::add_relation(heap_region,rop_a,
                                         Relations::Rlt,rop_z,relns);
      return !Relations::consistent_relations(rlns);
    }
    break;
  default: break;
  }
  return false;
}

static type_t get_c_typ(exp_t e) {
  if (e->topt == NULL) toc_impos("Missing type in primop ");
  return typ_to_c((type_t)e->topt);
}
static type_t get_cyc_typ(exp_t e) {
  if (e->topt == NULL) toc_impos("Missing type in primop ");
  return (type_t)e->topt;
}
static $(tqual_t, type_t)@ tup_to_c(exp_t e) {
  return new $(mt_tq, typ_to_c((type_t)e->topt));
}
static $(list_t<designator_t>,exp_t)@ add_designator(env_t nv, exp_t e) {
  exp_to_c(nv,e);
  return new $(NULL,e);
}

// we set the type of the returned expression to be struct_typ; this
// is assumed by recursive callers.
static exp_t make_struct(env_t nv, exp_t x, type_t struct_typ, stmt_t s,
			 bool pointer, exp_opt_t rgnopt, bool is_atomic,
			 bool do_declare) {
  exp_opt_t eo;
  type_t    t;
  if (pointer) {
    let se = sizeofexp_exp(deref_exp(x,DL),DL);
    if (*nv->struct_info.varsizeexp != NULL) {
      se = add_exp(se,(exp_t)*nv->struct_info.varsizeexp,DL);
      *nv->struct_info.varsizeexp = NULL;
    }
    t  = cstar_typ(struct_typ, mt_tq);
    if (rgnopt == NULL || no_regions)
      eo = is_atomic ? malloc_atomic(se) : malloc_ptr(se);
    else {
      exp_t r = (exp_t)rgnopt;
      exp_to_c(nv, r);
      eo = rmalloc_exp(r,se);
    }
  } else {
    t  = struct_typ;
    eo = NULL;
  }
  if (do_declare) {
    switch (x->r) {
    case &Var_e(x,_):
      return stmt_exp(declare_stmt(x,t,eo,s,DL),DL);
    default:
      toc_impos("bogus x to make_struct");
    }
  }
  else {
    if (eo != NULL)
      return stmt_exp(seq_stmt(exp_stmt(assign_exp(x,eo,DL),DL),s,DL),DL);
    else
      return stmt_exp(s,DL);
  }
}

static bool abstract_aggr(type_t typ) {
  switch (compress(typ)) {
  case &AggrType(AggrInfo(info,ts)):
    aggrdecl_t ad = get_known_aggrdecl(info);
    if (ad->impl == NULL) return false;
    list_t<aggrfield_t> aggrfields = ad->impl->fields;
    fallthru(aggrfields);
  case &AnonAggrType(_,aggrfields):
    if (aggrfields == NULL) return false;
    return true;
    // FIX: alternatively, I can check that this has at least two
    // fields, so that it won't become empty if the last one is
    // abstract
  default:
    return false;
  }
}

static type_t array_elt_type(type_t t) {
  switch (compress(t)) {
  case &ArrayType(ArrayInfo{elt_type,...}): return elt_type;
  default: toc_impos("array_elt_type called on %s",typ2string(t));
  }
}

static stmt_t init_comprehension(env_t nv, 
                                 type_t comprehension_type,
                                 exp_t lhs, vardecl_t vd,
                                 exp_t e1, exp_t e2, bool zero_term, stmt_t s,
                                 bool e1_already_translated);

static stmt_t init_anon_struct(env_t nv, exp_t lhs, type_t struct_type,
                               list_t<$(list_t<designator_t>,exp_t)@> dles,
                               stmt_t s);

// code to initialize an array
static stmt_t init_array(env_t nv, 
                         type_t array_type,
                         exp_t lhs,
                         list_t<$(list_t<designator_t>,exp_t)@> dles0,
                         stmt_t s) {
  type_t orig_elt_type = array_elt_type(array_type);
  int count = List::length(dles0)-1;
  for (let dles = List::rev(dles0); dles != NULL; dles = dles->tl) {
    // add lhs[e_index] = e to sequence of assignments
    let &$(dl,e1) = dles->hd;
    // calculate the index expression -- the front end checks that
    // the designators are in ascending order...
    // FIX:  real designator lists
    exp_t e_index;
    if (dl == NULL)
      e_index = signed_int_exp(count--,DL);
    else {
      if (dl->tl != NULL) unimp("multiple designators in array");
      let d = dl->hd;
      switch (d) {
      case &ArrayElement(e3):
        exp_to_c(nv,e3);
        e_index = e3;
        break;
      case &FieldName(_): unimp("field name designators in array");
      }
    }
    exp_t lval = subscript_exp(lhs,e_index,DL);
    switch (e1->r) {
    case &Array_e(dles0):
      s = init_array(nv, orig_elt_type, lval, dles0, s);
      break;
    case &Comprehension_e(vd,g1,g2,zt):
      s = init_comprehension(nv, orig_elt_type,
                             lval, vd, g1, g2, zt, s, false);
      break;
    case &AnonStruct_e(st,dles):
      s = init_anon_struct(nv, lval, st, dles, s);
      break;
    case &ComprehensionNoinit_e(...): // do nothing
      break;
    default:
      exp_to_c(nv,e1);
      s = seq_stmt(assign_stmt(subscript_exp(lhs,e_index,DL),
                               cast_it(typ_to_c(orig_elt_type),e1),DL),s,DL);
      break;
    }
  }
  return s;
}

// code to initialize a comprehension
// WARNING: Changing the translation here will break Tovc.
static stmt_t init_comprehension(env_t nv, 
                                 type_t comprehension_type,
                                 exp_t lhs, vardecl_t vd,
                                 exp_t e1, exp_t e2, bool zero_term,
                                 stmt_t s, bool e1_already_translated) {
  let x1 = vd->name;
  type_t expected_elt_type;
  switch (compress(comprehension_type)) {
  case &ArrayType(ArrayInfo{e,...}): 
    expected_elt_type = e; break;
  case &PointerType(PtrInfo{e,...}):
    expected_elt_type = e; break;
  default: toc_impos("init_comprehension passed a bad type!");
  }
  let elt_typ = typ_to_c((type_t)e2->topt);
  if (!e1_already_translated)
    exp_to_c(nv,e1);
  // if the body is a no-init comprehension, we don't have to do anything
  switch (e2->r) {
  case &ComprehensionNoinit_e(...): return skip_stmt(DL);
  default: break;
  }
  TOC_RGN(nv,r2) {
    env_t nv2 = add_varmap(r2,nv,x1,varb_exp(x1,new Local_b(vd),DL));
    qvar_t max = temp_var();
    exp_t ea = assign_exp(var_exp(x1,DL),signed_int_exp(0,DL),DL);
    exp_t eb = lt_exp(var_exp(x1,DL),var_exp(max,DL),DL);
    exp_t ec = post_inc_exp(var_exp(x1,DL),DL);
    // FIX: lval may be "const" -- we need to use pointer arithmetic
    // here and cast it to be a non-const pointer to the element type.
    exp_t lval = subscript_exp(lhs,var_exp(x1,DL),DL);
    stmt_t body;
    // since we don't yet allow arrays or comprehensions within comprehensions
    // these two cases shouldn't arise -- but we ought to support this.
    switch (e2->r) {
    case &Array_e(dles):
      body = init_array(nv2, expected_elt_type, lval, dles, skip_stmt_dl());
      break;
    case &Comprehension_e(vd2,g1,g2,zt):
      body = init_comprehension(nv2, expected_elt_type, lval, vd2, g1,g2,zt,skip_stmt_dl(), false);
      break;
    case &AnonStruct_e(st,dles):
      body = init_anon_struct(nv, lval, st, dles, skip_stmt_dl());
      break;
    default:
      exp_to_c(nv2,e2);
      body = assign_stmt(lval,cast_it(typ_to_c(expected_elt_type),e2),DL);
      break;
    }
    stmt_t s2 = for_stmt(ea,eb,ec,body,DL);
    // for zero-terminated comprehensions, we must initialize the last elt to 0
    if (zero_term) {
      // FIX: lhs[max] may be "const" -- we need to use pointer arithmetic
      // here and cast it to be a non-const pointer to the element type.
      // NB: we use new_exp here for the lhs to avoid sharing with the
      // occurrence of lhs above.
      exp_t ex = assign_exp(subscript_exp(new_exp(lhs->r,DL),var_exp(max,DL),DL),
                            cast_it(elt_typ,uint_exp(0,DL)),DL);
      s2 = seq_stmt(s2,exp_stmt(ex,DL),DL);
    }
    // note that we get rid of the const on the index variable x1 here
    return seq_stmt(declare_stmt(max,uint_typ,e1,
                                 declare_stmt(x1,uint_typ,NULL,s2,DL),DL),s,DL);
  }

}

static stmt_t init_anon_struct(env_t nv, exp_t lhs, type_t struct_type,
                               list_t<$(list_t<designator_t>,exp_t)@> dles,
                               stmt_t s) {
  for(let es = List::rev(dles); es != NULL; es = es->tl) {
    let &$(ds,e) = es->hd;
    if(ds == NULL)
      toc_impos("empty designator list");
    if(ds->tl != NULL)
      toc_impos("too many designators in anonymous struct");
    switch (ds->hd) {
    case &FieldName(f):
      exp_t lval = member_exp(lhs,f,DL);
      switch (e->r) {
      case &Array_e(dles):
        s = init_array(nv, (type_t)e->topt, lval, dles, s); break;
      case &Comprehension_e(vd,e1,e2,zt):
        s = init_comprehension(nv, (type_t)e->topt, 
                               lval, vd, e1, e2, zt, s, false); break;
      case &AnonStruct_e(st2,dles):
        s = init_anon_struct(nv, lval, st2, dles, s); break;
      case &ComprehensionNoinit_e(...): // do nothing
	break;
      default:
        exp_to_c(nv,e);
        // cast to void* if necessary
        if (is_poly_field(struct_type,f))
          e = cast_it(void_star_typ(),e);
        // FIX: deal with nested arrays and comprehensions
        s = seq_stmt(exp_stmt(assign_exp(lval, e, DL), DL), s, DL);
        break;
      }
      break;
    default: toc_impos("array designator in struct");
    }
  }
  return s;
}

// Would be nice to share more code with init_struct
// but the designators get in the way.
static exp_t init_tuple(env_t nv, bool pointer,
                        exp_opt_t rgnopt, list_t<exp_t> es) {
  // $(e1,...,en)  -> ({ t x;   x.f1 = e1; ... x.fn = en; x})
  // &$(e1,...,en) -> ({ t * x=malloc(sizeof(t); x->f1 = e1; ... x->fn = en; x})
  TOC_RGN(nv,r) {
    let tqs = List::rmap(r,tup_to_c,es);
    let n   = add_tuple_type(tqs);

    let x    = temp_var();
    let xexp = var_exp(x,DL);
    let s    = exp_stmt(xexp,DL);

    let lval_f = pointer ? aggrarrow_exp : member_exp;

    bool is_atomic = true;
    let es = List::rrev(r,es);
    for (int i = length(es); es != NULL; es = es->tl, --i) {
      exp_t e = es->hd;
      exp_t lval = lval_f(xexp, fieldname(i), DL);
      is_atomic = is_atomic && atomic_typ((type_t)e->topt);
      switch (e->r) {
      case &Array_e(dles):
        s = init_array(nv, (type_t)e->topt, lval, dles, s);
        break;
      case &Comprehension_e(vd,e1,e2,zt):
        s = init_comprehension(nv, (type_t)e->topt, 
                               lval, vd, e1, e2, zt, s, false);
        break;
      case &ComprehensionNoinit_e(...): // do nothing
	break;
        // FIX: deal with comprehensions
      default:
        exp_to_c(nv,e);
        s = seq_stmt(exp_stmt(assign_exp(lval_f(xexp,fieldname(i),
                                                DL),e, DL), DL), s, DL);
        break;
      }
    }
    return make_struct(nv,var_exp(x,DL),n,s,pointer,rgnopt,is_atomic,true);
  }
}

static int get_member_offset(aggrdecl_t ad, field_name_t f) {
  int i = 1;
  for (let fields = ad->impl->fields; fields != NULL; fields = fields->tl) {
    let field = fields->hd;
    if (strcmp(*field->name,*f) == 0) return i;
    ++i;
  }
  toc_impos(aprintf("get_member_offset %s failed",*f));
}

static bool init_variable_array(type_t @typ) {
  switch (compress(*typ)) {
  // if it's an array type and has valueof in it,
  // change it to an array of size 0
  case &ArrayType(ArrayInfo{elt_type,tq,e,zt,ztloc}):
    if (!Evexp::c_can_eval((exp_t)e)) {
      *typ = new ArrayType(ArrayInfo{elt_type,tq,uint_exp(0,DL),zt,ztloc});
      return true;
    }
    break;
  default: break;
  }
  return false;
}

static bool is_array_type(type_t t) {
  switch (compress(t)) {
  case &ArrayType(_): return true;
  default: return false;
  }
}

aggrdecl_t update_aggr_type(aggrdecl_t ad, field_name_t fn,
                            type_t new_field_type) {
  list_t<aggrfield_t> new_fields = NULL;
  list_t<aggrfield_t> fields;
  for (fields = ad->impl->fields; fields != NULL; 
       fields = fields->tl) {
    if (!strptrcmp(fields->hd->name,fn)) {
      let old_field = fields->hd;
      let old_atts = old_field->attributes;
      let old_type = old_field->type;
      if (!is_array_type(old_type), kind_leq(&ak,typ_kind(old_type)))
        old_atts = new List(new Aligned_att(NULL),old_atts);
      let new_field = new Aggrfield{.name= old_field->name,
				    .tq = mt_tq,
				    .type = new_field_type,
				    .width = old_field->width,
				    .attributes = old_atts,
                                    .requires_clause = NULL};
      new_fields = new List(new_field,new_fields);
    }
    else new_fields = new List(fields->hd,new_fields);
  }
  let aggrfields = List::rev(new_fields);
  stringptr_t name =
    new (string_t)aprintf("_genStruct%d",tuple_type_counter++);
  qvar_t qv = new $(Abs_n(NULL, true), name);
  let adi = new AggrdeclImpl {.exist_vars = ad->impl->exist_vars,
			      .rgn_po = ad->impl->rgn_po,
			      .fields = aggrfields,
			      .tagged = ad->impl->tagged};
  aggrdecl_t new_ad = new Aggrdecl {.kind = ad->kind,
				    .sc = ad->sc,
				    .name = qv,
				    .tvs = ad->tvs,
				    .impl = adi,
                                    .expected_mem_kind = false,
				    .attributes = ad->attributes};
  aggrdecl_to_c(new_ad, true);
  return new_ad;
}

static exp_t init_struct(env_t nv, type_t struct_type,
                         list_t<type_t> exist_types,
                         bool pointer, exp_opt_t rgnopt, 
                         list_t<$(list_t<designator_t>,exp_t)@> dles, 
                         typedef_name_t tdn) {
  // x is the variable that the result will be stored in
  bool do_declare = false;
  exp_t xexp;
  if (nv->struct_info.lhs_exp == NULL) {
    let x = temp_var();
    xexp  = var_exp(x,DL);
    do_declare = true;
  }
  else {
    xexp = (exp_t)nv->struct_info.lhs_exp;
    nv = set_lhs_exp(nv->rgn,NULL,nv);
  }
  let s   = exp_stmt(copy_exp(xexp),DL);

  // keep track of the final variable expression, in case we
  // need to insert a cast due to a changed type
  exp_t @varexp;
  switch (s->r) {
  case &Exp_s(*e): varexp = e; break;
  default: toc_impos("stmt not an expression!");
  }

  let lval_f = pointer ? aggrarrow_exp : member_exp;
  type_t aggr_typ = typ_to_c(struct_type); 
  type_t orig_typ = aggr_typ;

  bool is_atomic = true;
  list_t<type_t> forall_types;
  aggrdecl_t ad;
  list_t<aggrfield_t> aggrfields, orig_aggrfields;
  field_name_t *index = NULL;
  switch(compress(struct_type)) {
  case &AggrType(AggrInfo(info,ts)): 
    ad = get_known_aggrdecl(info);
    orig_aggrfields = aggrfields = ad->impl->fields;
    forall_types = ts;
    break;
  default: toc_impos("init_struct: bad struct type");
  }

  if (exist_types != NULL && ad->impl->fields != NULL) {
    let fields = ad->impl->fields;
    for (; fields->tl != NULL; fields = fields->tl);
    let last_field = fields->hd;
    TOC_RGN(nv,temp) {
      let inst1 = List::rzip(temp,temp,ad->tvs,forall_types);
      // we have an aggregate with existential types have to come up
      // with (potentially) a new struct type if the last member is of
      // abstract type.
      if (is_abstract_type(rsubstitute(temp,inst1,last_field->type))) {
	let inst2 = List::rzip(temp,temp,ad->impl->exist_vars,exist_types);
	let inst = List::rappend(temp,inst1,inst2);
	// now create a new aggregate according to the full instantiation
	list_t<aggrfield_t> new_fields = NULL;
	for (fields = ad->impl->fields; fields != NULL; fields = fields->tl) {
	  let old_field = fields->hd;
	  let new_field = new Aggrfield{.name= old_field->name,
					.tq = mt_tq,
					.type = rsubstitute(temp,inst,
							    old_field->type),
					.width = old_field->width,
					.attributes = old_field->attributes,
                                        .requires_clause = NULL};
	  // if the last field is an array type that includes a valueof(`i),
	  // make it a variable-length array instead (i.e. set bounds to 0)
	  // and keep track of the index needed to get to the array
	  if (fields->tl == NULL) {
	    if (init_variable_array(&new_field->type))
	      index = new new_field->name;
// 	    if (index != NULL) {
// 	      printf("found array type at index obj.%s\n",**index);
// 	    }
	  }
	  new_fields = new List(new_field,new_fields);
	}
	exist_types = NULL;
	aggrfields = List::rev(new_fields);
	stringptr_t name =
	  new (string_t)aprintf("_genStruct%d",tuple_type_counter++);
	qvar_t qv = new $(Abs_n(NULL, true), name);
	let adi = new AggrdeclImpl {.exist_vars = NULL,
				    .rgn_po = NULL,
				    .fields = aggrfields,
				    .tagged = false};
	aggrdecl_t new_ad = new Aggrdecl {.kind = StructA,
					  .sc = Public,
					  .name = qv,
					  .tvs = NULL,
                                          .expected_mem_kind = false,
					  .impl = adi,
					  .attributes = NULL};
	aggrdecl_to_c(new_ad, true);
	ad = new_ad;
	struct_type = new AggrType(AggrInfo{.aggr_info=KnownAggr(new new_ad),
					    .targs=NULL});
	aggr_typ = typ_to_c(struct_type);
      }
    }
  }
  bool is_tagged_union = ad->impl->tagged;
  TOC_RGN(nv,r) {
    for(let es = List::rrev(r,dles); es != NULL; es = es->tl) {
      let &$(ds,e) = es->hd;
      is_atomic = is_atomic && atomic_typ((type_t)e->topt);
      if(ds == NULL)
        toc_impos("empty designator list");
      if(ds->tl != NULL) {
        // untested
        // JGM: I don't understand this code
        let y    = temp_var();
        let yexp = var_exp(y,DL);
        for(; ds != NULL; ds = ds->tl)
          switch (ds->hd) {
          case &FieldName(f):
            // cast to void* if necessary
            if (is_poly_field(struct_type,f))
              yexp = cast_it(void_star_typ(),yexp);
            s = seq_stmt(exp_stmt(assign_exp(lval_f(xexp,f,DL), yexp, DL), DL),
                         s, DL);
            break;
          default: toc_impos("array designator in struct");
          }
        // FIX:  need to deal with nested arrays, comprehensions, etc.
        exp_to_c(nv,e);
        s = seq_stmt(exp_stmt(assign_exp(yexp, e, DL), DL), s, DL);
      } else
        switch (ds->hd) {
        case &FieldName(f):
          exp_t lval = lval_f(xexp,f,DL);
          if (is_tagged_union) {
            int i = get_member_offset(ad,f);
            exp_t f_tag_exp = signed_int_exp(i,DL);
            exp_t lhs = member_exp(lval,tag_sp,0);
            exp_t assn_exp = assign_exp(lhs,f_tag_exp,0);
            s = seq_stmt(exp_stmt(assn_exp,0),s,0);
            lval = member_exp(lval,val_sp,0);
          }
	  bool e1_translated = false;
          switch (e->r) {
          case &Array_e(dles):
            s = init_array(nv, lookup_field(aggrfields,f)->type, 
                           lval, dles, s); 
            break;
          case &Comprehension_e(vd,e1,e2,zt):
            s = init_comprehension(nv, 
                                   lookup_field((do_declare ? aggrfields :
                                                 orig_aggrfields),f)->type,
                                   lval, vd, e1, e2, zt, s, false);
	    e1_translated = true;
	    fallthru(e1,(type_t)e2->topt);
          case &ComprehensionNoinit_e(e1,t,...):
	    // if this is a dynamic comprehension, grab the bound
	    // for doing the malloc
	    if (index != NULL && !strptrcmp(*index,f)) {
	      if (!e1_translated) exp_to_c(nv,e1);
	      let t2 = typ_to_c(t);
	      *nv->struct_info.varsizeexp =
		add_exp(fncall_exp(_check_times_e,
				   list(e1,sizeoftyp_exp(t2,DL)),DL),
			const_exp(Cnst{.Int_c=$(Unsigned,PAD_BYTES)},DL),DL);
	    }
	    break;
          case &AnonStruct_e(st,dles):
            s = init_anon_struct(nv, lval, st, dles, s); break;
          default:
	    type_t old_e_typ = (type_t)e->topt;
	    bool was_ptr_type = is_pointer_or_boxed_tvar(old_e_typ);
            exp_to_c(set_lhs_exp(nv->rgn,lval,nv),e);
	    switch (old_e_typ) {
	    case &AggrType(...):
	      // generate a new aggregate type here based on the
	      // type change of the nested member
	      if (old_e_typ != e->topt && !unify(typ_to_c(old_e_typ),
						 (type_t)e->topt)){
		// replace the existing field in the implementation with
		// this type, and generate a new name
		ad = update_aggr_type(ad,f,(type_t)e->topt);
		struct_type = 
		  new AggrType(AggrInfo{.aggr_info=KnownAggr(new ad),
					.targs=NULL});
		aggr_typ = typ_to_c(struct_type);
	      }
	      break;
	    default: break;
	    }
            let adf = lookup_field(aggrfields,f);
            // cast to void* to avoid gcc warnings (does it more than needed)
	    if (is_poly_field(struct_type,f) && !was_ptr_type)
	      e = cast_it(void_star_typ(),e);
	    // more warning avoidance -- watch out if existentials are common
	    if(exist_types != NULL)
	      e = cast_it(typ_to_c(adf->type),e);
            // FIX: deal with nested arrays and comprehensions
            s = seq_stmt(exp_stmt(assign_exp(lval, e, DL), DL), s, DL);
            break;
          }
          break;
        default: toc_impos("array designator in struct");
        }
    }

    // if the type changed due to instantiations etc. we need to
    // insert a cast, but only if it's a pointer
    if (aggr_typ != orig_typ && pointer) {
      type_t cast_type = cstar_typ(orig_typ,mt_tq);
      *varexp = cast_it(cast_type,*varexp);
    }
    // now make the struct
    let res = make_struct(nv,xexp,aggr_typ,s,pointer,rgnopt,is_atomic,
			  do_declare);
    res->topt = struct_type;
    return res;
  }
}

// functions for passing to lvalue_assign (see below)
static exp_t assignop_lvalue(exp_t el, $(opt_t<primop_t,`H>,exp_t)@ pr) {
  return assignop_exp(el,(*pr)[0],(*pr)[1],DL);
}
static exp_t address_lvalue(exp_t e1, bool ignore) {
  return address_exp(e1,DL);
}
static exp_t incr_lvalue(exp_t e1, incrementor_t incr) {
  return new_exp(new Increment_e(e1,incr),DL);
}

static void lvalue_assign_stmt(stmt_t s,list_t<field_name_t> fs,
			       exp_t f(exp_t,`a), `a f_env);

// e1 is the result of translating an lvalue.  fs is the path of struct
// fields that we're assigning to on e1 (if any).  The translation
//  may have inserted NULL checks, etc., but buried within e1 is an lvalue.
// We find the underlying lvalue, call it el.
// We replace el in e1 with f(el,env)
// We assume that variables in f(el,env) will not be captured by any
static void lvalue_assign(exp_t e1, list_t<field_name_t> fs,
			  exp_t f(exp_t,`a), `a f_env){
  switch (e1->r) {
  case &StmtExp_e(s): lvalue_assign_stmt(s,fs,f,f_env); break;
  case &Cast_e(t,e,_,_):  lvalue_assign(e,fs,f,f_env); break;
  case &AggrMember_e(e,fld,is_tagged,is_read):
    // Hack: strip off the struct member -- the base case adds it back in.
    e1->r = e->r;
    lvalue_assign(e1,new List(fld,fs),f,f_env);
    break;
  default:
    // Note: this may not be an lvalue b/c of &arr where arr has an array type.
    // WARNING: If the translation of lvalues changes, we may need to change
    //          how we find the "inner lvalue".
    // make a copy so we don't create a loop
    exp_t e1_copy = copy_exp(e1);
    // add the path back on to the expression
    for (; fs != NULL; fs = fs->tl)
      e1_copy = member_exp(e1_copy,fs->hd,e1_copy->loc);
    e1->r = f(e1_copy, f_env)->r;
    break;
  }
}
static void lvalue_assign_stmt(stmt_t s,list_t<field_name_t> fs,
			       exp_t f(exp_t,`a), `a f_env) {
  switch (s->r) {
  case &Exp_s(e1):    lvalue_assign(e1,fs,f,f_env);      break;
    // we assume free vars of e2 are not captured by d
  case &Decl_s(d,s2): lvalue_assign_stmt(s2,fs,f,f_env); break;
  case &Seq_s(_,s2):  lvalue_assign_stmt(s2,fs,f,f_env); break;
  default: toc_impos("lvalue_assign_stmt: %s",stmt2string(s));
  }
}

static void push_address_stmt(stmt_t s);

// we want to take the address of e but it may no longer be a valid
// lhs, due to a cast or null-check or whatever.
static exp_t push_address_exp(exp_t e) {
  switch (e->r) {
  case &Cast_e(*t,*e1,_,_):
    *e1 = push_address_exp(*e1);
    *t = cstar_typ(*t,mt_tq);
    return e;
  case &Deref_e(e1):
    return e1;
  case &StmtExp_e(s):
    // we only have this case because of assignments to
    // tagged union members -- see tagged_union_assignop
    push_address_stmt(s);
    return e;
  default:
    if (is_lvalue(e)) return address_exp(e,DL);
    toc_impos("can't take & of exp %s",exp2string(e));
  }
}

static void push_address_stmt(stmt_t s) {
  switch (s->r) {
  case &Seq_s(_,s2): fallthru(s2);
  case &Decl_s(_,s2): push_address_stmt(s2); break;
  case &Exp_s(*e): *e = push_address_exp(*e); break;
  default:
    toc_impos("can't take & of stmt %s",stmt2string(s));
  }
}

// similar to map_c but flips order of arguments
static list_t<`b,`r2> rmap_2c(region_t<`r2> r2,`b f(`a,`c),`c env,
                               list_t<`a,`r1> x) {
  list_t<`b,`r2> result, prev;

  if (x == NULL) return NULL;
  result = rnew(r2) List(f(x->hd,env),NULL);
  prev = result;
  for (x=x->tl; x != NULL; x=x->tl) {
    prev->tl = rnew(r2) List(f(x->hd,env),NULL);
    prev = prev->tl;
  }
  return(result);
}
static list_t<`b> map_2c(`b f(`a,`c), `c env, list_t<`a,`r> x) {
  return rmap_2c(heap_region,f,env,x);
}

static $(list_t<designator_t>,exp_t)@ make_dle(exp_t e) {
  return new $(NULL,e);
}

static struct PtrInfo get_ptr_type(type_t t) {
  switch (compress(t)) {
  case &PointerType(p): return p;
  default: toc_impos("get_ptr_typ: not a pointer!");
  }
}

// given a type t that admits "zero", return an expression representing
// zero for that type.  For pointers, this is NULL.  For integral types,
// this is the appropriate integral 0.
static exp_t generate_zero(type_t t) {
  exp_t res;
  switch (compress(t)) {
  case &PointerType(_) : res = null_exp(DL); break;
  case &IntType(sn,Char_sz) : res = const_exp(Char_c(sn,0),DL); break;
  case &IntType(sn,Short_sz) : res = const_exp(Short_c(sn,0),DL); break;
  case &EnumType(_,_)  : fallthru;
  case &AnonEnumType(_): fallthru(Unsigned);
  case &IntType(sn,Int_sz) : fallthru(sn);
  case &IntType(sn,Long_sz) :
    res = const_exp(Int_c(sn,0),DL); break;
  case &IntType(sn,LongLong_sz) :
    res = const_exp(LongLong_c(sn,0),DL); break;
  case &FloatType(0): res = const_exp(Float_c("0.0F",0),DL); break;
  case &FloatType(1): res = const_exp(Float_c("0.0",1),DL); break;
  case &FloatType(i): res = const_exp(Float_c("0.0L",i),DL); break;
  default:
    toc_impos("found non-zero type %s in generate_zero",typ2string(t));
  }
  res->topt = t;
  return res;
}

// We're translating e which is of the form e_1 op= e_2 where e_1
// involves a zero-terminated pointer and is of the form *ea or
// ea[eb].  We need to prevent overwriting the last zero in the array.  unary & applied to non-lvalue
static void zero_ptr_assign_to_c(env_t nv, exp_t e,
                                 exp_t e1, opt_t<primop_t> popt, exp_t e2,
                                 type_t ptr_type,
                                 bool is_dyneither,
                                 type_t elt_type) {
  // To simplify the translation, we always use a fat pointer and generate:
  //  ({ fat_ptr_type x = ((fat_ptr_type)ea) + eb;
  //     elt_type y = *x; // check here that x is not null and in bounds
  //     elt_type z = y op e2;
  //     if (numelts(x) == 1 && y == zero && z != zero) _throw_arraybounds();
  //     *x.curr = z; })
  // Note that this is generated and *then* translated to ensure the
  // proper constraints.
  type_t fat_ptr_type = dyneither_typ(elt_type, &HeapRgn_val, mt_tq, true_conref);
  let c_elt_type = typ_to_c(elt_type);
  let c_fat_ptr_type = typ_to_c(fat_ptr_type);
  let c_ptr_type = cstar_typ(c_elt_type, mt_tq);
  let c_ptr_type_opt = new Opt(c_ptr_type);
  exp_t xinit;
  switch (e1->r) {
  case &Deref_e(ea):
    if (!is_dyneither) {
      ea = cast_exp(fat_ptr_type,ea,false,Other_coercion,DL);
      ea->topt = fat_ptr_type;
    }
    exp_to_c(nv,ea); xinit = ea; break;
  case &Subscript_e(ea,eb):
    if (!is_dyneither) {
      ea = cast_exp(fat_ptr_type,ea,false,Other_coercion,DL);
      ea->topt = fat_ptr_type;
    }
    exp_to_c(nv,ea); exp_to_c(nv,eb);
    xinit = fncall_exp(_dyneither_ptr_plus_e,
                       list(ea,sizeoftyp_exp(typ_to_c(elt_type),DL),eb),DL);
    break;
  default: toc_impos("found bad lhs for zero-terminated pointer assignment");
  }
  let x = temp_var();                // build ptr_type x = ea + eb;
  TOC_RGN(nv, rgn2) {
    let nv = add_varmap(rgn2, nv, x, var_exp(x,DL));  // add x to the varmap
    let x_vd = new Vardecl {Public,x,mt_tq,c_fat_ptr_type,xinit,NULL,NULL,false};
    let x_bnd = new Local_b(x_vd);     // build *x -- need to translate here
    let x_exp = varb_exp(x,x_bnd,DL);  // to check the bound and for NULL
    x_exp->topt = fat_ptr_type;
    let deref_x = deref_exp(x_exp,DL);
    deref_x->topt = elt_type;
    exp_to_c(nv,deref_x);
    let y = temp_var();                // build elt_type y = *x;
    nv = add_varmap(rgn2, nv, y, var_exp(y,DL));  // add y to the varmap
    let y_vd = new Vardecl {Public,y,mt_tq,c_elt_type,deref_x,NULL,NULL,false};
    let y_bnd = new Local_b(y_vd);
    exp_t z_init = e2;                 // build y op e2 and translate
    if (popt != NULL) {
      let y_exp = varb_exp(y,y_bnd,DL);
      y_exp->topt = deref_x->topt;
      z_init = prim2_exp(popt->v,y_exp,e2,DL);
      z_init->topt = y_exp->topt;
    }
    exp_to_c(nv,z_init);
    let z = temp_var();                // build z = y op e2;
    let z_vd = new Vardecl {Public,z,mt_tq,c_elt_type,z_init,NULL,NULL,false};
    let z_bnd = new Local_b(z_vd);
    nv = add_varmap(rgn2, nv, z, var_exp(z,DL));  // add z to the varmap
    // build y == zero and translate -- here, we need to know what
    // the element type is to generate the right zero.
    let y2_exp = varb_exp(y,y_bnd,DL); y2_exp->topt = deref_x->topt;
    let zero1_exp = generate_zero(elt_type);
    let comp1_exp = prim2_exp(Eq,y2_exp,zero1_exp,DL);
    comp1_exp->topt = sint_typ;
    exp_to_c(nv,comp1_exp);
    // build z != zero and translate
    let z_exp = varb_exp(z,z_bnd,DL); z_exp->topt = deref_x->topt;
    let zero2_exp = generate_zero(elt_type);
    let comp2_exp = prim2_exp(Neq,z_exp,zero2_exp,DL);
    comp2_exp->topt = sint_typ;
    exp_to_c(nv,comp2_exp);
    // build numelts(x) == 1 directly (no translation)
    let xsizeargs = list(varb_exp(x,x_bnd,DL),
                         sizeoftyp_exp(typ_to_c(elt_type),DL));
    let oneexp = uint_exp(1,DL);
    exp_t xsize;
    xsize = prim2_exp(Eq,fncall_exp(_get_dyneither_size_e,xsizeargs,DL),
                      oneexp,DL);
    // start assembling the statement
    let comp_exp = and_exp(xsize,and_exp(comp1_exp,comp2_exp,DL),DL);
    let thr_stmt = exp_stmt(fncall_exp(_throw_arraybounds_e,NULL,DL),DL);
    let xcurr = member_exp(varb_exp(x,x_bnd,DL),curr_sp,DL);
    xcurr = cast_it(c_ptr_type,xcurr);
    let deref_xcurr = deref_exp(xcurr,DL);
    let asn_exp = assign_exp(deref_xcurr,var_exp(z,DL),DL);
    let s = exp_stmt(asn_exp,DL);
    s = seq_stmt(ifthenelse_stmt(comp_exp,thr_stmt,skip_stmt(DL),DL),s,DL);
    s = decl_stmt(new Decl(new Var_d(z_vd),DL),s,DL);
    s = decl_stmt(new Decl(new Var_d(y_vd),DL),s,DL);
    s = decl_stmt(new Decl(new Var_d(x_vd),DL),s,DL);
    e->r = stmt_exp_r(s);
  }
}

// we have a read of e1.f or e1->f where e1 does any needed null checks,
// but we now have to do a tag-check.  We translate this to:
//  ({ temp = e1;
//     if (temp->f.tag != f_tag) throw_match();
//     temp->f.val;
//  })
// unless we are in a left-hand-side context, in which case we translate to
//  ({ temp = &e1->f; // okay because e1 must be a lhs
//     if (temp->tag != f_tag) throw_match();
//     &temp->val;
//  })
static raw_exp_t check_tagged_union(exp_t e1,type_t e1_c_type,
                                    type_t aggrtype,field_name_t f,
                                    bool in_lhs,
                                    exp_t aggrproj(exp_t,field_name_t,seg_t)) {
  aggrdecl_t ad;
  switch (compress(aggrtype)) {
  case &AggrType(AggrInfo(info,_)):
    ad = get_known_aggrdecl(info); break;
  default: impos(aprintf("expecting union but found %s in check_tagged_union",
                         typ2string(aggrtype)));
  }
  let temp = temp_var();
  let temp_exp = var_exp(temp,DL);
  let f_tag = signed_int_exp(get_member_offset(ad,f),DL);
  if (in_lhs) {
    let temp_f_tag = aggrarrow_exp(temp_exp,tag_sp,DL);
    let test_exp = neq_exp(temp_f_tag,f_tag,DL);
    let temp_f_val = aggrarrow_exp(temp_exp,val_sp,DL);
    let sres = exp_stmt(address_exp(temp_f_val,DL),DL);
    let ifs = ifthenelse_stmt(test_exp,throw_match_stmt(),skip_stmt_dl(),DL);
    let e1_p_type = cstar_typ(e1_c_type,mt_tq);
    let e1_f = address_exp(aggrproj(e1,f,DL),DL);
    let s = declare_stmt(temp,e1_p_type,e1_f,seq_stmt(ifs,sres,DL),DL);
    return stmt_exp_r(s);
  } else {
    let temp_f_tag = member_exp(aggrproj(temp_exp,f,DL),tag_sp,DL);
    let test_exp = neq_exp(temp_f_tag,f_tag,DL);
    let temp_f_val = member_exp(aggrproj(temp_exp,f,DL),val_sp,DL);
    let sres = exp_stmt(temp_f_val,DL);
    let ifs = ifthenelse_stmt(test_exp,throw_match_stmt(),skip_stmt_dl(),DL);
    let s = declare_stmt(temp,e1_c_type,e1,seq_stmt(ifs,sres,DL),DL);
    return stmt_exp_r(s);
  }
}

static bool is_tagged_union_project_impl(type_t t, field_name_t f,
					 int @f_tag, type_t @ tagged_member_type,
					 bool clear_read, bool *is_read) {
  switch (compress(t)) {
  case &AggrType(AggrInfo(info,...)):
    let ad = get_known_aggrdecl(info);
    *f_tag = get_member_offset(ad,f);
    // FIX: we need to get unique names for these damned structs...
    string_t str = aprintf("_union_%s_%s",*((*ad->name)[1]),*f);
    *tagged_member_type = strct(new str);
    if (clear_read) *is_read = false;
    return ad->impl->tagged;
  default: return false;
  }
}

// return true if e is e1.f or e1->f where e1 is a (pointer to a)
// tagged union.  While we're at it, calculate the tag for the
// corresponding member f_tag.
static bool is_tagged_union_project(exp_t e, int @f_tag,
                                    type_t @ tagged_member_type,
                                    bool clear_read) {
  switch (e->r) {
  case &Cast_e(_,e1,_,_): toc_impos("cast on lhs!");
  case &AggrMember_e(e1,f,_,*is_read):
    return is_tagged_union_project_impl((type_t)e1->topt,f,f_tag,
					tagged_member_type,clear_read,is_read);
  case &AggrArrow_e(e1,f,_,*is_read):
    switch (compress((type_t)e1->topt)) {
    case &PointerType(PtrInfo{.elt_typ = et,...}):
      return is_tagged_union_project_impl(et,f,f_tag,
					  tagged_member_type,clear_read,is_read);
    default: return false;
    }
  default: return false;
  }
}

// special case for when we're swapping a tagged union member.
// We have on input e.f or e->f and we want to swap the val
// field, so ultimately, we want to return &e.f.val or &e->f.val
// but we also need to check that e.f.tag or e->f.tag is the
// right one.  So, we mute e into:
// ({ temp = &e.f // or &e->f
//    if (temp->tag != f_tag) throw_match();
//    &temp->val; })
void add_tagged_union_check_for_swap(exp_t e, int tag, type_t mem_type) {
  let temp = temp_var();
  exp_t temp_exp = var_exp(temp,DL);
  exp_t temp_val = aggrarrow_exp(temp_exp,val_sp,DL);
  exp_t temp_tag = aggrarrow_exp(temp_exp,tag_sp,DL);
  exp_t f_tag = signed_int_exp(tag,DL);
  stmt_t s3 = exp_stmt(address_exp(temp_val,DL),DL);
  let test_exp = neq_exp(temp_tag,f_tag,DL);
  stmt_t s2 = ifthenelse_stmt(test_exp,throw_match_stmt(),skip_stmt_dl(),DL);
  stmt_t s1 = declare_stmt(temp,cstar_typ(mem_type,mt_tq),
                           push_address_exp(copy_exp(e)),
                           seq_stmt(s2,s3,DL),DL);
  e->r = stmt_exp_r(s1);
}

// special case for assignment to a tagged union member (either e1.f
// or e1->f.  In particular, when we have e1->f = e2, we rewrite to:
// ({ temp = &e1->f;
//    temp->tag = f_tag;
//    temp->val = e2; })
// and if we have e1->f op= e2 we rewrite to:
// ({ temp = &e1->f;
//    if (temp->tag != f_tag) throw_match();
//    temp->val op= e2; })
static raw_exp_t tagged_union_assignop(exp_t e1, type_t e1_cyc_type,
                                       opt_t<primop_t,`H> popt,
                                       exp_t e2, type_t e2_cyc_type,
                                       int tag_num, type_t member_type) {
  let temp = temp_var();
  exp_t temp_exp = var_exp(temp,DL);
  exp_t temp_val = aggrarrow_exp(temp_exp,val_sp,DL);
  exp_t temp_tag = aggrarrow_exp(temp_exp,tag_sp,DL);
  exp_t f_tag = signed_int_exp(tag_num,DL);
  stmt_t s3 = exp_stmt(assignop_exp(temp_val,popt,e2,DL),DL);
  stmt_t s2;
  if (popt == NULL)
    s2 = exp_stmt(assign_exp(temp_tag,f_tag,DL),DL);
  else {
    let test_exp = neq_exp(temp_tag,f_tag,DL);
    s2 = ifthenelse_stmt(test_exp,throw_match_stmt(),skip_stmt_dl(),DL);
  }
  stmt_t s1 = declare_stmt(temp,cstar_typ(member_type,mt_tq),
                           push_address_exp(e1),
                           seq_stmt(s2,s3,DL),DL);
  return stmt_exp_r(s1);
}

static void new_comprehension_to_c(env_t nv, exp_t e, type_t new_e_type,
				   exp_opt_t rgnopt, type_t old_typ,
				   exp_t e1, type_t t1,
				   bool zero_term, exp_opt_t init_exp,
				   vardecl_opt_t vd)
{		
  // Drop the "tagged_ptr_t" struct stuff when type is a fixed-size array.
  // Slight twist for zero-terminated arrays -- must allocate one more
  // element and initialize the last element to 0.
  // ({ unsigned int max = e1;
  //    t *a = (t*)malloc(sizeof(t)*max);
  //    struct tagged_arr b = _tag_arr(a);
  //    unsigned int x ;
  //    for (x = 0; x < max; x++) a[x] = e2;
  //    b; })      
  qvar_t max = temp_var();
  qvar_t a = temp_var();
  type_t old_elt_typ = t1;
  type_t elt_typ = typ_to_c(old_elt_typ);
  type_t ptr_typ = cstar_typ(elt_typ,mt_tq);
  exp_to_c(nv,e1);
  let malloc_size_exp = var_exp(max,DL);
  // add one to max for zero-terminated arrays
  stmt_t s;
  if (zero_term)
    malloc_size_exp = add_exp(malloc_size_exp,uint_exp(1,DL),DL);
  if (init_exp != NULL)
    s = init_comprehension(nv, new_e_type,
			   var_exp(a,DL), (vardecl_t)vd, var_exp(max,DL),
			   init_exp, zero_term, skip_stmt_dl(), true);
  else if (zero_term)
    s = exp_stmt(assign_exp(subscript_exp(var_exp(a,DL),var_exp(max,DL),DL),
			    cast_it(elt_typ,uint_exp(0,DL)),DL),DL);
  else
    s = skip_stmt(DL);
  // FIX:  casts needed on exp_opts
  TOC_RGN(nv,r) {
    list_t<$(qvar_t,type_t,exp_opt_t)@/*`r,`r*/> decls =
      rnew(r) List(rnew(r) $(max,uint_typ,(exp_opt_t)e1),NULL);
    exp_t ai;
    if (rgnopt == NULL || no_regions)
      ai = malloc_exp(old_elt_typ,
		      fncall_exp(_check_times_e,
				 list(sizeoftyp_exp(elt_typ,DL),
				      malloc_size_exp), DL));
    else {
      exp_t r = (exp_t)rgnopt;
      exp_to_c(nv,r);
      ai = rmalloc_exp(r, fncall_exp(_check_times_e,
				     list(sizeoftyp_exp(elt_typ,DL),
					  malloc_size_exp), DL));
    }
    exp_t ainit = cast_it(ptr_typ,ai);
    decls = rnew(r) List(rnew(r) $(a,ptr_typ,(exp_opt_t)ainit),decls);
    if (!is_pointer_type(old_typ))
      toc_impos("new_comprehension_to_c: comprehension is not an array type");
    if (is_dyneither_ptr(old_typ)) {
      let b = temp_var();
      let t = typ_to_c(old_typ);
      let tag = _tag_dyneither_e;
      let binit =
	fncall_exp(tag,
		   list(var_exp(a,DL), sizeoftyp_exp(elt_typ, DL),
			malloc_size_exp), DL);
      decls = rnew(r) List(rnew(r) $(b,t,(exp_opt_t)binit),decls);
      s = seq_stmt(s,exp_stmt(var_exp(b,DL),DL),DL);
    } else // not a tagged array -- just return a
      s = seq_stmt(s,exp_stmt(var_exp(a,DL),DL),DL);
    for (let ds = decls; ds != NULL; ds = ds->tl) {
      let $(d0,d1,d2) = *(ds->hd);
      s = declare_stmt(d0,d1,d2,s,DL);
    }
    e->r = stmt_exp_r(s);
  }
}

static void exp_to_c(env_t nv, exp_t e) {
  let r = e->r;
  if(e->topt == NULL)
    toc_impos("exp_to_c: no type for %s",exp2string(e));
  // if we're not about to convert an aggregate initializer,
  //   clear the lhs expression
  if (nv->struct_info.lhs_exp != NULL) {
    switch (r) {
    case &Aggregate_e(...): break;
    default: nv = set_lhs_exp(nv->rgn,NULL,nv);
    }
  }
  //if (in_lhs(nv))
  //  fprintf(stderr,"in_lhs for %s\n",exp2string(e));
  type_t old_typ = (type_t)e->topt;
  switch (r) {
  case &Const_e({.Null_c = _}):
    // NULL translate to 0 unless a tagged array, then {0,0,0}, via runtime
    // call unless at top-level
    // note: we don't need the element type b/c the length is 0 (so we lie)
    // note: should share all these uint_exp(0,DL) things
    let zero = uint_exp(0,DL);
    if(is_tagged_pointer_typ(old_typ)) {
      if(is_toplevel(nv))
	e->r = make_toplevel_dyn_arr(old_typ, zero, zero)->r;
      else
	e->r = fncall_exp_r(_tag_dyneither_e, list(zero,zero,zero));
    } else {
      e->r = (raw_exp_t)(&zero_exp);
    }
    break;
  case &Const_e(_): break;
  case &Var_e(qv,b):
    try e->r = lookup_varmap(nv,qv)->r;
    catch { case &Dict::Absent:
       toc_impos("Can't find %s in exp_to_c, Var\n", qvar2string(qv));
    }
    break;
  case &Primop_e(p,es):
    // Save Cyclone types -- needed for pointer arith stuff
    let old_typs = List::map(get_cyc_typ,es);
    // Translate args
    List::iter_c(exp_to_c,nv,es);
    switch (p) {
    case Numelts:
      exp_t arg = es->hd;
      switch (compress((type_t)arg->topt)) {
      case &ArrayType(ArrayInfo{_,_,e2,_,_}):
        // FIX: copy the expression e2 here.
        if (!Evexp::c_can_eval((exp_t)e2))
          terr(e->loc,"can't calculate numelts");
        e->r = e2->r;  break;
      case &PointerType(PtrInfo(elt_typ,_,PtrAtts(_,nbl,bound,zt,_))):
	switch(conref_def(bounds_one,bound)) {
        case &DynEither_b: // retrieve (last_plus_one - curr) via runtime call
	  e->r = fncall_exp_r(_get_dyneither_size_e,
                              list(es->hd,
                                   sizeoftyp_exp(typ_to_c(elt_typ),DL)));
          break;
	case &Upper_b(e2):
          // when zero-terminated, we have to call "strlen"
          if (conref_def(false,zt)) {
            exp_t function_e =
	      getFunctionRemovePointer(&_get_zero_arr_size_functionSet,
				       es->hd);
            e->r = fncall_exp_r(function_e,list(es->hd,e2));
          } else if (conref_def(false,nbl)) {
            if (!Evexp::c_can_eval(e2))
              terr(e->loc,"can't calculate numelts");
            // careful! when this is a nullable pointer, the size might be 0
            e->r = conditional_exp_r(arg,e2,uint_exp(0,DL));
          } else {
            e->r = e2->r; break; // compile-time evaluation
          }
	  break;
	}
	break;
      default:
	toc_impos("size primop applied to non-array %s (%s)",
                  typ2string((type_t)arg->topt),typ2string((type_t)arg->topt));
      }
      break;
    case Plus:
      // only translation is for ? pointers or zero-terminated arrays
      //   _dynxxx_ptr_plus(e1,sizeof(elt_typ),e2)
      // FIX: allow arithmetic on t ? types at top-level!
      switch (compress(old_typs->hd)) {
      case &PointerType(PtrInfo(elt_typ,_,PtrAtts(_,_,b,zt,_))):
        switch (conref_def(bounds_one,b)) {
        case &DynEither_b:
          exp_t e1 = es->hd;
          exp_t e2 = es->tl->hd;
          e->r = fncall_exp_r(_dyneither_ptr_plus_e,
                              list(e1,sizeoftyp_exp(typ_to_c(elt_typ),DL),e2));
          break;
        case &Upper_b(esz):
          if (conref_def(false,zt)) {
            exp_t e1 = es->hd;
            exp_t e2 = es->tl->hd;
            e->r = fncall_exp(getFunctionRemovePointer(&_zero_arr_plus_functionSet,e1),list(e1,esz,e2),DL)->r;
          }
          break;
        }
        break;
      default:
        break;
      }
      break;
    case Minus:
      // only translation is for ? pointers.
      // if e2 is not a tagged array, do just like plus of negation,
      // else result type is unsigned int, so subtract curr fields
      type_t elt_typ = &VoidType_val;
      if(is_tagged_pointer_typ_elt(old_typs->hd,&elt_typ)) {
	exp_t e1 = es->hd;
	exp_t e2 = es->tl->hd;
	if(is_tagged_pointer_typ(old_typs->tl->hd)) {
	  e1->r = aggrmember_exp_r(new_exp(e1->r,DL),curr_sp);
	  e2->r = aggrmember_exp_r(new_exp(e2->r,DL),curr_sp);
	  e->r  = divide_exp(copy_exp(e),
			     sizeoftyp_exp(typ_to_c(elt_typ),DL),DL)->r;
	} else {
	  e->r = fncall_exp_r(_dyneither_ptr_plus_e,
                              list(e1,sizeoftyp_exp(typ_to_c(elt_typ),DL),
                                   prim1_exp(Minus,e2,DL)));
	}
      }
      break;
    case Eq:
    case Neq:
    case Gt:
    case Gte:
    case Lt:
    case Lte:
      // need to extract .curr field of tagged arrays for comparisons
      exp_t e1 = es->hd;
      exp_t e2 = es->tl->hd;
      type_t t1 = old_typs->hd;
      type_t t2 = old_typs->tl->hd;
      type_t elt_typ = &VoidType_val; // bogus until next call
      if (is_tagged_pointer_typ_elt(t1,&elt_typ))
	e1->r = cast_it_r(cstar_typ(typ_to_c(elt_typ),mt_tq),member_exp(new_exp(e1->r,DL),curr_sp,DL));
      if (is_tagged_pointer_typ(t2))
	e2->r = cast_it_r(cstar_typ(typ_to_c(elt_typ),mt_tq),member_exp(new_exp(e2->r,DL),curr_sp,DL));
      break;
    default: break; //skip
    }
    break;
  case &Increment_e(e2,incr):
    type_t e2_cyc_typ = (type_t)e2->topt;
    // we need to worry about the case where e2 is of the form
    // *ea or ea[eb] and ea is a zero-terminated pointer, for
    // then we need to know that the inc/dec doesn't destroy the
    // trailing 0.  See the special code in the AssignOp_e case.
    // To combat this, I'm simply disallowing it.
    //
    // Similarly, we need to worry about the case where e2 is a
    // tagged union projection.
    type_t ptr_type = &VoidType_val;
    type_t elt_type = &VoidType_val;
    bool is_dyneither = false;
    string_t incr_str = "increment";
    if (incr == PreDec || incr == PostDec) incr_str = "decrement";
    if (is_zero_ptr_deref(e2,&ptr_type,&is_dyneither,&elt_type)) {
      Tcutil::terr(e->loc,"in-place %s is not supported when dereferencing a zero-terminated pointer", incr_str);
      toc_impos("in-place inc/dec on zero-term");
    }
    type_t tunion_member_type = &VoidType_val;
    int f_tag = 0;
    if (is_tagged_union_project(e2,&f_tag,&tunion_member_type,true)) {
      let one = signed_int_exp(1,DL);
      one->topt = sint_typ;
      switch (incr) {
      case PreInc:
        e->r = new AssignOp_e(e2,new Opt(Plus),one);
        exp_to_c(nv,e);
        return;
      case PreDec:
        e->r = new AssignOp_e(e2,new Opt(Minus),one);
        exp_to_c(nv,e);
        return;
      default:
        Tcutil::terr(e->loc,"in-place post-%s is not supported on @tagged "
                     "union members", incr_str);
        toc_impos("in-place inc/dec on @tagged union");
      }
    }
    set_lhs(nv,true);
    exp_to_c(nv,e2);
    set_lhs(nv,false);
    // only t ? or zero-terminated types are translated funny,
    // note that e2 is an lvalue!
    type_t elt_typ = &VoidType_val;
    if(is_tagged_pointer_typ_elt(old_typ,&elt_typ)) {
      _ fn_e;
      int change = 1;
      fn_e = (incr==PostInc || incr==PostDec) ?
        _dyneither_ptr_inplace_plus_post_e : _dyneither_ptr_inplace_plus_e;
      if (incr == PreDec || incr == PostDec)
        change = -1;
      e->r = fncall_exp_r(fn_e, list(push_address_exp(e2),
                                     sizeoftyp_exp(typ_to_c(elt_typ),DL),
                                     signed_int_exp(change,DL)));
    } else if (is_zero_pointer_typ_elt(old_typ,&elt_typ)) {
      // e.g, x++ becomes _zero_arr_inplace_plus_post(x,1)
      //let fn_e = (incr == PostInc) ? _zero_arr_inplace_plus_post_e :
      //  _zero_arr_inplace_plus_e;
      let fnSet = (incr!=PostInc) ? &_zero_arr_inplace_plus_functionSet
	                          : &_zero_arr_inplace_plus_post_functionSet;
      exp_t fn_e = getFunctionRemovePointer(fnSet, e2);
      e->r = fncall_exp_r(fn_e, list(push_address_exp(e2),
				     signed_int_exp(1,DL)));
    } else if(elt_typ == &VoidType_val && !is_lvalue(e2)) {
      lvalue_assign(e2,NULL,incr_lvalue,incr);
      e->r = e2->r;
    }
    break;
  case &AssignOp_e(e1,popt,e2):
    // FIX: not sure all these special-cases work right *together*...
    //
    // We need to know whether or not the expression is of the form
    // *ea op= e2 or ea[eb] op= e2 where ea is a zero-terminated pointer.
    // The reason is that we need to ensure not only that the pointer
    // is in bounds, but also, if it's pointing to the last element
    // (i.e., the zero) then the value written in should continue to
    // be zero.  So, for instance, if we have *ea = e2, then either ea
    // can't point to the last element or e2 must be 0.  If we have
    // *ea op= e2 then we need to know that either ea can't point to
    // the last element or (0 op= e2) is 0.
    //
    // Similarly, when e1 is a tagged union member, then we need to
    // update its tag as well as the value.  This is problematic when
    // we have something like e.x += 1 which is both a read and a write
    // of the member.
    // See if e1 is a projection on a tagged union member.
    type_t  e1_old_typ = (type_t)e1->topt;
    type_t  e2_old_typ = (type_t)e2->topt;
    int f_tag = 0; // bogus unless e1_tagged_proj
    type_t tagged_member_struct_type = &VoidType_val; // bogus unless e1_tagged_proj
    if (is_tagged_union_project(e1,&f_tag,&tagged_member_struct_type,true)) {
      set_lhs(nv,true);
      exp_to_c(nv,e1);
      set_lhs(nv,false);
      exp_to_c(nv,e2);
      e->r = tagged_union_assignop(e1,e1_old_typ,popt,e2,e2_old_typ,f_tag,
                                   tagged_member_struct_type);
      return;
    }
    type_t ptr_type = &VoidType_val;
    type_t elt_type = &VoidType_val;
    bool is_dyneither = false;
    if (is_zero_ptr_deref(e1,&ptr_type,&is_dyneither,&elt_type)) {
      zero_ptr_assign_to_c(nv, e, e1, popt, e2, ptr_type,
                           is_dyneither, elt_type);
      return;
    }
    // See if e1 is a polymorphic field (i.e., is an instantiated type
    // variable) -- if so, coerce e2 to void*.
    bool e1_poly    = is_poly_project(e1);
    set_lhs(nv,true);
    exp_to_c(nv,e1);
    set_lhs(nv,false);
    exp_to_c(nv,e2);
    // special case for pointer arithmetic of t ? or zero-terminated types
    bool done = false;
    if(popt != NULL) {
      type_t elt_typ = &VoidType_val;
      if(is_tagged_pointer_typ_elt(old_typ,&elt_typ)) {
        _ change;
        switch(popt->v) {
        case Plus:  change = e2; break;
        case Minus:
          change = prim1_exp(Minus,e2,DL); break;
        default:    toc_impos("bad t ? pointer arithmetic");
        }
        done = true;
        // FIX: Is e1 definitely still an lvalue? Probably not!!
        let fn_e = _dyneither_ptr_inplace_plus_e;
        e->r = fncall_exp_r(fn_e,list(push_address_exp(e1),
                                      sizeoftyp_exp(typ_to_c(elt_typ),DL),
                                      change));
      } else if (is_zero_pointer_typ_elt(old_typ,&elt_typ)) {
        // We're doing x += e where x is a zero-terminated pointer.
        // Make sure we don't run off the end.
        switch (popt->v) {
        case Plus:
          done = true;
          e->r = fncall_exp_r(getFunctionRemovePointer(&_zero_arr_inplace_plus_functionSet,e1),list(e1,e2));
          break;
        default: toc_impos("bad zero-terminated pointer arithmetic");
        }
      }
    }
    if(!done) {
      // this cast is necessary to avoid gcc warnings
      if (e1_poly)
        e2->r = cast_it_r(void_star_typ(), new_exp(e2->r,DL));
      // The typechecker guarantees that e1 starts out as an lvalue, but
      // the translation might have to insert casts, NULL checks,
      // declarations of temps, bound checks, etc.  If so we look into e1,
      // find the lvalue, and put the assignment there.
      if (!is_lvalue(e1)) {
        lvalue_assign(e1,NULL,assignop_lvalue,new{$(popt,e2)});
        e->r = e1->r;
      }
    }
    break;
  case &Conditional_e(e1,e2,e3):
    exp_to_c(nv,e1);
    exp_to_c(nv,e2);
    exp_to_c(nv,e3);
    break;
  case &And_e(e1,e2):
    exp_to_c(nv,e1);
    exp_to_c(nv,e2);
    break;
  case &Or_e(e1,e2):
    exp_to_c(nv,e1);
    exp_to_c(nv,e2);
    break;
  case &SeqExp_e(e1,e2):
    exp_to_c(nv,e1);
    exp_to_c(nv,e2);
    break;
  case &FnCall_e(e1,es,NULL,_):
    exp_to_c(nv,e1);
    List::iter_c(exp_to_c,nv,es);
    break;
  case &FnCall_e(e1,es,&VarargCallInfo{num_varargs,injectors,vai},_):
    // if vai->inject:
    //    t vn = injector[n](es[n])
    //    ...
    //    t v0 = injector[0](es[n-num_varargs+1])
    //    t argv[num_varargs] = {&v0, ..., &vn};
    // else
    //    t argv[num_varargs] = {es[n-num_varargs+1], ..., es[n]};
    // e1(es[0], ..., es[n-num_varargs], tag_dyneither(argv, sizeof(t), num_varargs));
    TOC_RGN(nv,r) {
      qvar_t argv = temp_var();
      exp_t argvexp = var_exp(argv,DL);
      exp_t  num_varargs_exp = uint_exp(num_varargs,DL);
      type_t cva_type = typ_to_c(vai->type);
      type_t arr_type = array_typ(cva_type,mt_tq,num_varargs_exp,false_conref,
                                  DL);

      int num_args     = List::length(es);
      int num_normargs = num_args - num_varargs;

      // build argument list and set es to the varargs portion
      list_t<exp_t> new_args = NULL;
      for(int i=0; i < num_normargs; ++i, es=es->tl) {
	exp_to_c(nv,es->hd);
	new_args = new List(es->hd, new_args);
      }
      new_args = new List(fncall_exp(_tag_dyneither_e,
				     list(argvexp,
					  sizeoftyp_exp(cva_type,DL),
					  num_varargs_exp), DL),
			  new_args);
      new_args = imp_rev(new_args);
      // make the function call
      exp_to_c(nv,e1);
      stmt_t s = exp_stmt(fncall_exp(e1,new_args,DL),DL);

      // make the declarations and prepend them
      if(vai->inject) {
	datatypedecl_t tud;
	switch(compress(pointer_elt_type(vai->type))) {
	case &DatatypeType(DatatypeInfo({.KnownDatatype=&x},_)): tud = x; break;
	default: toc_impos("toc: unknown datatype in vararg with inject");
	}
	qvar_t ? vs = rnew(r) {for i < num_varargs : temp_var()};

        if (num_varargs != 0) {
          // declare argv = {&v1,&v2,...,&vnum_varargs}
          let array_args = NULL;
          for(int i=num_varargs-1; i >= 0; --i)
            array_args = new List(make_dle(address_exp(var_exp(vs[i],DL),DL)),
                                  array_args);
          s = declare_stmt(argv, arr_type, unresolvedmem_exp(NULL,array_args,DL),
                           s,DL);
          // evaluate varargs (notice we're using a screwy evaluation order now)
          for (int i=0; es != NULL; es = es->tl, injectors = injectors->tl, ++i) {
            exp_t  arg      = es->hd;
            type_t arg_type = (type_t)arg->topt;
            qvar_t var      = vs[i];
            exp_t  varexp   = var_exp(var,DL);
            let &Datatypefield{qv,tqts,_,_} = injectors->hd;
            type_t field_typ = typ_to_c((*tqts->hd)[1]);
            exp_to_c(nv,arg);
            if (is_void_star_or_boxed_tvar(field_typ))
              arg = cast_it(field_typ,arg);
            // DAN: We don't use an initializer b/c we're afraid of the GCC bug,
            //   but I doubt it would happen and it causes a lot of gunk. :-(
            // struct qv_tag temp x;
            // x.tag = i;
            // x.f1  = arg;
            s = seq_stmt(assign_stmt(member_exp(varexp,fieldname(1),DL),
                                     arg,DL),
                         s,DL);
            s = seq_stmt(assign_stmt(member_exp(varexp,tag_sp,DL),
                                     datatype_tag(tud,qv),DL),
                         s,DL);
            s = declare_stmt(var,strctq(collapse_qvars(qv,tud->name)), NULL,
                             s,DL);
          }
        }
        // if there are no var args, then set argv to the empty fat pointer
        // instead of an array of 0 elements to keep ansi c compilers happy
        else {
          let array_args = list(make_dle(uint_exp(0,DL)),make_dle(uint_exp(0,DL)),
                                make_dle(uint_exp(0,DL)));
          s = declare_stmt(argv,void_star_typ(),uint_exp(0,DL),
                           s,DL);
        }
      } else {
	// we'd like: argv = { e1, ..., en} where ei is the ith vararg, but
	// alas I hit the GCC BUG when I did that (in one place in the
	// pretty printer -- everything else went through fine).  So we do:
	// t argv[n];
	// argv[0] = e1; ... argv[n-1] = en;
	// Sigh.
	for(int i=0; es != NULL; es = es->tl, ++i) {
	  exp_to_c(nv, es->hd);
	  s = seq_stmt(assign_stmt(subscript_exp(argvexp,uint_exp(i,DL),DL),
				   es->hd, DL),
		       s, DL);
	}
	s = declare_stmt(argv, arr_type, NULL, s, DL);
	/*	list_t<exp_t,`r> array_args = NULL;
	for(; es != NULL; es = es->tl) {
	  exp_to_c(nv, es->hd);
	  array_args = rnew(r) List(es->hd, array_args);
	}
	array_args = List::imp_rev(array_args);
	let init = unresolvedmem_exp(NULL,List::map(make_dle,array_args),DL);
	s = declare_stmt(argv, arr_type, init,
			 s,DL);
	*/
      }

      e->r = stmt_exp_r(s);
    }
    break;
  case &Throw_e(e1,b):
    // throw e -> (t)(throw(e)), the latter being a function call to throw
    exp_to_c(nv,e1);
    let nt = b ? newrethrow_exp(e1) : newthrow_exp(e1);
    e->r = array_to_ptr_cast(typ_to_c(old_typ),nt,DL)->r;
    break;
  case &NoInstantiate_e(e1): exp_to_c(nv,e1); break;
  case &Instantiate_e(e1,ts):
    exp_to_c(nv,e1);
    // only cast when the instantiation has type variables,
    // you can cast other times, but you'll spit out much more C code.
    // Note: we don't bother to cast if type is void * anyway (b/c that's
    //       what type variables get translated to)
    // Note: we could be even more aggressive -- often the instantiated types
    //  don't show up in the translated type.  Moreover, we probably don't
    //  get warnings when the only use of the tyvar is as a parameter b/c
    //  it's just an implicit cast to void * (so long as inst type isn't int)
    for(; ts != NULL; ts = ts->tl) {
      let k = typ_kind(ts->hd)->kind;
      if(k != EffKind && k != RgnKind) {
	switch(compress(ts->hd)) {
	case &VarType(_):
	case &DatatypeType(_): continue;
	default:
	  e->r = array_to_ptr_cast(typ_to_c((type_t)e->topt),e1,DL)->r;
	  break;
	}
	break;
      }
    }
    break;
  case &Cast_e(*t,e1,user_inserted,coercion):
    type_t old_t2  = (type_t)e1->topt;
    type_t old_t2_c = typ_to_c(old_t2);
    type_t new_typ = *t;
    type_t new_typ_c = typ_to_c(new_typ);
    *t = new_typ_c;
    exp_to_c(nv, e1);
    // a few Cyclone casts are translated into C effects other than casts:
    switch ($(compress(old_t2),compress(new_typ))) {
    case $(&PointerType(p1),&PointerType(p2)):
      let n1 = conref_def(false,p1.ptr_atts.nullable);
      let n2 = conref_def(false,p2.ptr_atts.nullable);
      let b1 = conref_def(bounds_one,p1.ptr_atts.bounds);
      let b2 = conref_def(bounds_one,p2.ptr_atts.bounds);
      let zt1 = conref_def(false,p1.ptr_atts.zero_term);
      let zt2 = conref_def(false,p2.ptr_atts.zero_term);
      switch($(b1,b2)) {
      case $(&Upper_b(b1), &Upper_b(b2)):
        if ((!Evexp::c_can_eval(b1) || !Evexp::c_can_eval(b2)) &&
            !Evexp::same_const_exp(b1,b2))
          terr(e->loc,"can't validate cast due to potential size differences");
	if(n1 && !n2) {
	  if(is_toplevel(nv))
	    unimp("can't do NULL-check conversion at top-level");
	  // cast from t* to t@ -- run-time check: (t*)_check_null(e)
	  // flow analysis may not set annotation correctly here!
          // sanity checking:
          if (coercion != NonNull_to_Null)
            impos("null-check conversion mis-classified: %s",exp2string(e));
          bool do_null_check = need_null_check(e1);
          if (do_null_check) {
            if (!user_inserted)
              Tcutil::warn(e->loc,"inserted null check due to implicit "
                           "cast from * to @ type");
            e->r = cast_it_r(*t,fncall_exp(_check_null_e,
                                           new List(e1,NULL),DL));
          } else {
	    // no check needed -- see if we can drop the cast all together
            if (unify(old_t2_c,new_typ_c))
              e->r = e1->r;
          }
	} else {
          // no check needed -- see if we can drop the cast all together
          if (unify(old_t2_c,new_typ_c))
            e->r = e1->r;
        }
        // FIX: the type-checker doesn't currently allow the case
        // where b1 > b2, but this can be allowed for zero-terminated
        // arrays (since the true length isn't known.)  Of course,
        // this obligates a run-time check.
	break;
      case $(&Upper_b(e2), &DynEither_b):
        if (!Evexp::c_can_eval(e2))
          terr(e->loc,"cannot perform coercion since numelts cannot be determined statically.");
        // sanity checking
        if (coercion == NonNull_to_Null)
            impos("conversion mis-classified as null-check: %s",exp2string(e));
	if(is_toplevel(nv)) {
	  // can't use a function at top-level and don't want macros
          if (zt1 && !p2.elt_tq.real_const && !zt2) {
            // If p2 is not zero-terminated and not const, then we subtract
            // one from the size so that no one can write the last location.
            e2 = prim2_exp(Minus,e2,uint_exp(1,DL),DL);
          }
	  e->r = make_toplevel_dyn_arr(old_t2,e2,e1)->r;
	} else {
          let tag_e = _tag_dyneither_e;
	  // cast from t*{n} or t@{n} to t? or t?+-
          if (zt1) {
            // if p1 is zero-terminated then calculate the size dynamically:
            //   ({ t *x = e1;
            //      _dynxxx_ptr_arr(x, sizeof(t), _get_zero_arr_size(x,n));
            //   })
            let x = temp_var();
            let x_exp = var_exp(x,DL);
            exp_t arg3;
            // if what we're casting is a string constant or an array
            // variable, we can avoid computing the "size" at run-time.
            switch (e1->r) {
            case &Const_e({.String_c = _}):
              arg3 = e2; break;
            case &Const_e({.Wstring_c = _}):
              arg3 = e2; break;
            default:
              arg3 = fncall_exp(getFunctionRemovePointer(
                                 &_get_zero_arr_size_functionSet,e1),
                                list(cast_it(void_star_typ(),x_exp),e2),DL);
              break;
            }
            if (!zt2 && !p2.elt_tq.real_const) {
              // If p2 is not zero-terminated and not const, then we subtract
              // one from the size so that no one can write the last location.
              arg3 = prim2_exp(Minus,arg3,uint_exp(1,DL),DL);
            }
            let arg2 = sizeoftyp_exp(typ_to_c(p2.elt_typ),DL);
            let tg_exp = fncall_exp(tag_e,list(x_exp,arg2,arg3),DL);
            let s = exp_stmt(tg_exp,DL);
            s = declare_stmt(x,typ_to_c(old_t2),e1,s,DL);
            e->r = stmt_exp_r(s);
          } else {
            // build the t ? struct
            e->r = fncall_exp_r(tag_e,
                                list(e1,
                                     sizeoftyp_exp(typ_to_c(p2.elt_typ),DL),
                                     e2));
          }
        }
	break;
      case $(&DynEither_b, &Upper_b(e2)):
        if (!Evexp::c_can_eval(e2))
          terr(e->loc,"cannot perform coercion since numelts cannot be determined statically.");
	if(is_toplevel(nv))
	  unimp("can't coerce t? to t* or t@ at the top-level");
        // When we have t?ZEROTERM and are casting to
        // t*{e2} or t@{e2} *without* the ZEROTERM, then we
        // can't allow e2 to be the actual size of the array --
        // it needs to be one less to ensure that you can't
        // overwrite the trailing 0.  We achieve this by
        // incrementing e2 by one.  That is if x has type t?Z,
        // and we're casting it to t@{2}, then we'd better check
        // that the size is at least 2+1=3.
        let new_e2 = e2;
        if (zt1 && !zt2) {
          new_e2 = add_exp(e2,uint_exp(1,DL),DL);
        }
	// cast from t ? to t* or t@ -- run-time check:
	// for t*: (t *)_untag_arr(e1, sizeof(t), new_e2)
	// for t@: (t *)_check_null(_untag_arr(e1, sizeof(t), new_e2))
        let untag_e = _untag_dyneither_ptr_e;
	let ptr_exp = fncall_exp(untag_e,
				 list(e1,
                                      sizeoftyp_exp(typ_to_c(p1.elt_typ),DL),
				      new_e2), DL);
	if(n2)
	  ptr_exp->r = fncall_exp_r(_check_null_e,
                                    new List(copy_exp(ptr_exp), NULL));
	e->r = cast_it_r(*t, ptr_exp);
	break;
      // If p1 is zero-terminated and p2 is not, then p2 had better
      // be const or else we have to decrement its size by 1.
      case $(&DynEither_b, &DynEither_b):
DynCast:
        if (zt1 && !zt2 && !p2.elt_tq.real_const) {
          if (is_toplevel(nv))
            unimp("can't coerce a ZEROTERM to a non-const NOZEROTERM pointer at toplevel");
          let td_e = _dyneither_ptr_decrease_size_e;
          e->r = fncall_exp_r(td_e,
                              list(e1,sizeoftyp_exp(typ_to_c(p1.elt_typ),DL),
                                   uint_exp(1,DL)));
        }
	break;
      }
      break;
    case $(&PointerType(p1), &IntType(_,_)):
      switch(conref_def(bounds_one,p1.ptr_atts.bounds)) {
      case &DynEither_b: // cast t? to int -- cast curr field to int
	e1->r = aggrmember_exp_r(new_exp(e1->r,e1->loc),curr_sp); break;
      default: break;
      }
      break;
    default: 
      if (unify(old_t2_c,new_typ_c)) 
        e->r = e1->r;
      break;
    }
    break;

  case &Address_e(e1):
    // When e1 is a struct or a tuple, this is really a "new".
    switch (e1->r) {
    case &Aggregate_e(tdn,ts,es,_):
      if (is_toplevel(nv))
	unimp("%s: & on non-identifiers at the top-level",
              Position::string_of_segment(e1->loc));
      let e2 = init_struct(nv, (type_t)e1->topt, ts, true, NULL, es, tdn);
      e->r = e2->r;
      e->topt = e2->topt;
      break;
    case &Tuple_e(es):
      if (is_toplevel(nv))
	unimp("%s: & on non-identifiers at the top-level",
              Position::string_of_segment(e1->loc));
      e->r = init_tuple(nv, true, NULL, es)->r;
      break;
    default: // it's actually an address-of.
      set_lhs(nv,true);
      exp_to_c(nv,e1);
      set_lhs(nv,false);
      if(!is_lvalue(e1)) {
	lvalue_assign(e1,NULL,address_lvalue,true);
	// the wrong cast got pushed out, so as a kludge, just re-cast
	e->r = cast_it_r(typ_to_c((type_t)e->topt),e1);
      } else if (kind_leq(&ak,typ_kind((type_t)e1->topt))) {
        // we could be taking the address of an abstract member, so
        // insert a cast here.
        e->r = cast_it_r(typ_to_c((type_t)e->topt),e1);
      }
      break;
    }
    break;
  case &New_e(rgnopt,e1):
    // FIX: need to deal with zero-terminated arrays
    if (is_toplevel(nv))
      unimp("%s: new at top-level", Position::string_of_segment(e1->loc));
    type_t new_e_type = (type_t)e1->topt;
    switch (e1->r) {
    case &Array_e(dles0):
      // FIX: MAY BE SUSCEPTIBLE TO GCC BUG!
      // ({ t *x = (t*)(malloc(sizeof(t)*length(dles0)));
      //    x[d1] = e1; ... x[dn] = en; x; })
      let x = temp_var();
      let xexp = var_exp(x,DL);
      let s = init_array(nv, new_e_type, xexp, dles0, exp_stmt(xexp,DL));
      type_t old_elt_typ;
      switch (compress(old_typ)) {
      case &PointerType(PtrInfo{et,tq,PtrAtts(_,_,_,zt,_)}):
	old_elt_typ = et; break;
      default:
	old_elt_typ =
          toc_impos("exp_to_c:new array expression doesn't have ptr type");
      }
      type_t elt_typ=typ_to_c(old_elt_typ);
      let ptr_typ = cstar_typ(elt_typ,mt_tq);
      let e2 = times_exp(sizeoftyp_exp(elt_typ,DL),
                         signed_int_exp(List::length(dles0),DL),DL);
      exp_t e1;
      if (rgnopt == NULL || no_regions) {
        e1 = malloc_exp(old_elt_typ,e2);
      } else {
        exp_t r = (exp_t)rgnopt;
        exp_to_c(nv,r);
        e1 = rmalloc_exp(r,e2);
      }
      //      let e0 = cast_it(ptr_typ,e1);
      e->r = stmt_exp_r(declare_stmt(x,ptr_typ,e1,s,DL));
      break;

    case &Comprehension_e(vd,e1,e2,zero_term):
      new_comprehension_to_c(nv,e,new_e_type,rgnopt,old_typ,e1,(type_t)e2->topt,zero_term,e2,vd);
      break;

    case &ComprehensionNoinit_e(e1,t1,zero_term):
      new_comprehension_to_c(nv,e,new_e_type,rgnopt,old_typ,e1,t1,zero_term,NULL,NULL);
      break;

    case &Aggregate_e(tdn,ts,es,ad):
      // try to avoid the GCC bug
      let e2 = init_struct(nv, (type_t)e1->topt, ts, true, rgnopt, es, tdn);
      e->r = e2->r;
      e->topt = e2->topt;
      break;
    case &Tuple_e(es):
      // try to avoid the GCC bug
      e->r = init_tuple(nv, true, rgnopt, es)->r;
      break;
    default:
      // treated just like an array of size 1
      // FIX: MAY BE SUSCEPTIBLE TO GCC BUG!
      // ({ t *x = (t*)(malloc(sizeof(t)));
      //    x[0] = e1; x; })
      type_t old_elt_typ = (type_t)e1->topt;
      type_t elt_typ = typ_to_c(old_elt_typ);
      // build up the malloc expression: (t *)(malloc(sizeof(t)))
      let x = temp_var();
      let xexp = var_exp(x,DL);
      exp_t mexp = sizeofexp_exp(deref_exp(xexp,DL),DL);
      exp_t inner_mexp = mexp;
      if (rgnopt == NULL || no_regions)
        mexp = malloc_exp(old_elt_typ,mexp);
      else {
        exp_t r = (exp_t)rgnopt;
        exp_to_c(nv,r);
        mexp = rmalloc_exp(r,mexp);
      }
      //      mexp = cast_it(cstar_typ(elt_typ,mt_tq));
      // For tagged arrays, I have gotten burned by the GCC BUG
      // (they're structs), so we special-case it right here
      // I HAVE NO IDEA IF I'M CATCHING ENOUGH CASES.
      bool done = false;
      switch(e1->r) {
      case &Cast_e(t2,e2,_,_):
	switch($(compress(t2),compress((type_t)e2->topt))) {
	case $(&PointerType(PtrInfo{arr_typ,_,PtrAtts(_,_,bc,_,_)}),
	       &PointerType(PtrInfo{_,_,PtrAtts(_,_,be,_,_)})):
	  switch($(conref_def(bounds_one,bc),conref_def(bounds_one,be))) {
	  case $(&DynEither_b,&Upper_b(arr_sz)):
	    exp_to_c(nv,e2);
	    inner_mexp->r = sizeoftyp_exp_r(elt_typ);
	    done = true;
            let _init_f = _init_dyneither_ptr_e;
	    e->r = fncall_exp_r(_init_f,
                                list(mexp, e2,
                                     sizeoftyp_exp(typ_to_c(arr_typ),DL),
                                     arr_sz));
	    break;
	  default: break;
	  }
	break;
	default: break;
	}
	break;
      default: break;
      }
      if(!done) {
	let s = exp_stmt(copy_exp(xexp),DL);
	let e_index = signed_int_exp(0,DL);
	exp_to_c(nv,e1);
	s = seq_stmt(assign_stmt(subscript_exp(xexp,e_index,DL),
				 e1,DL),s,DL);
	let ptr_typ = cstar_typ(elt_typ,mt_tq);
	e->r = stmt_exp_r(declare_stmt(x,ptr_typ,mexp,s,DL));
      }
      break;
    }
    break;
  case &Sizeofexp_e(e1): 
    // turn off array bounds checking in here...
    let old_in_sizeof = set_in_sizeof(nv,true);
    exp_to_c(nv,e1); 
    set_in_sizeof(nv,old_in_sizeof);
    break;
  case &Sizeoftyp_e(t):  e->r = new Sizeoftyp_e(typ_to_c(t));  break;
  case &Offsetof_e(t,fs):
    let t2 = t;
    let l = fs;
    for (; l != NULL; l=l->tl) {
      switch (l->hd) {
      case &StructField(n): break;
      case &TupleIndex(n):
	switch(compress(t2)) {
	case &AggrType(AggrInfo(info,_)):
	  let ad = get_known_aggrdecl(info);
	  if(ad->impl==NULL)
	    toc_impos("struct fields must be known");
	  fallthru(ad->impl->fields);
	case &AnonAggrType(_,fields):
	  let nth_field = List::nth(fields,n);
	  l->hd = new StructField(nth_field->name);
	  t2 = nth_field->type;
	  break;
	case &TupleType(ts):
	  l->hd = new StructField(fieldname(n+1));
	  t2 = (*List::nth(ts,n))[1];
	  break;
	case &DatatypeFieldType(DatatypeFieldInfo({.KnownDatatypefield=$(_,tuf)},_)):
	  if(n == 0)
	    l->hd = new StructField(tag_sp);
	  else {
	    t2 = (*List::nth(tuf->typs,n-1))[1];
	    l->hd = new StructField(fieldname(n));
	  }
	  break;
	default: toc_impos("impossible type for offsetof tuple index");
	  break;
	}
	break;
      }
    }
    e->r = new Offsetof_e(typ_to_c(t),fs);
    break;
  case &Deref_e(e1):
    let old_lhs = in_lhs(nv);
    set_lhs(nv,false);
    let e1_typ = compress((type_t)e1->topt);
    switch (e1_typ) {
    case &PointerType(PtrInfo{t2,tq,PtrAtts(rgn,cr,b,zt,_)}):
      switch (conref_def(bounds_one,b)) {
      case &Upper_b(nelts):
	bool do_null_check = !in_sizeof(nv) && need_null_check(e1);
	exp_to_c(nv,e1);
        if (do_null_check) {
          if (warn_all_null_deref)
            warn(e->loc, "inserted null check due to dereference");
	  // *((t *)_check_null(e))
          e1->r = cast_it_r(typ_to_c(e1_typ),
                            fncall_exp(_check_null_e,
                                       new List(copy_exp(e1),NULL),DL));
        }
        // Note that a null check is sufficient for zero-terminated arrays
        // too, because we guarantee that there's something to read here,
        // even if it's just a 0.  Note that writes are handled specially
        // by the AssignOp_e case.
        if (!in_sizeof(nv) && !conref_def(false,zt)) {
          let $(i,b) = Evexp::eval_const_uint_exp(nelts);
          // FIX:  should really do like below for the -> case
          // and check at run-time.  We'd still have to rule out
          // those bounds for which C cannot evaluate them (e.g.,
          // due to valueof.)
          if (!b || i <= 0)
            terr(e->loc,"cannot determine dereference is in bounds");
        }
	break;
      case &DynEither_b:
	// do it as e1[0], could share all the 0's but who cares
	let ind_e = uint_exp(0,DL);
	ind_e->topt = uint_typ;
	e->r = subscript_exp_r(e1, ind_e);
	exp_to_c(nv,e);
	break;
      }
      break;
    default: toc_impos("exp_to_c: Deref: non-pointer");
    }
    set_lhs(nv,old_lhs);
    break;
  case &AggrMember_e(e1,f,is_tagged,is_read):
    bool is_poly = is_poly_project(e);
    type_t e1_cyc_type = (type_t)e1->topt;
    exp_to_c(nv, e1);
    if (is_tagged && is_read) {
      e->r = check_tagged_union(e1,typ_to_c(e1_cyc_type),e1_cyc_type,f,
                                in_lhs(nv),
                                member_exp);
    }
    if(is_poly)
      e->r = array_to_ptr_cast(typ_to_c((type_t)e->topt),new_exp(e->r,DL),DL)->r;
    break;
  case &AggrArrow_e(e1,f,is_tagged,is_read):
    let old_lhs = in_lhs(nv);
    set_lhs(nv,false);
    type_t e1typ = compress((type_t)e1->topt);
    bool do_null_check = need_null_check(e1);
    exp_to_c(nv, e1);
    bool is_poly = is_poly_project(e); // decide before mutating e
    let PtrInfo{ta,tq,PtrAtts(rgn,bcr,b,zt,_)} = get_ptr_type(e1typ);
    switch (conref_def(bounds_one,b)) {
    case &Upper_b(esz):
      // the type-checker should've ensured the size is at least 1
      // FIX: on unknown, dynamic bounds check!
      let $(j,known) = Evexp::eval_const_uint_exp(esz);
      if(known) {
	if (j < 1)
	  impos("exp_to_c:  AggrArrow_e on pointer of size 0");
	if (do_null_check) {
          if (warn_all_null_deref)
            warn(e->loc, "inserted null check due to dereference");
	  // ((t *)_check_null(e))->f
	  e1->r = cast_it_r(typ_to_c(e1typ),
                            fncall_exp(_check_null_e,
                                       list(new_exp(e1->r,0)),DL));
	}
      } else {
        if (!Evexp::c_can_eval(esz))
          terr(e->loc,"cannot determine pointer dereference in bounds");
	// very strange case: they may have used sizeof or offsetof to make
	// a zero-size array.  Yeah, that'll happen never.
	e1->r = cast_it_r(typ_to_c(e1typ),
                          fncall_exp(_check_known_subscript_null_e,
                                     list(new_exp(e1->r,0),esz,
                                          sizeoftyp_exp(ta,DL),
                                          uint_exp(0,DL)),DL));
      }
      break;
    case &DynEither_b:
      // ((ta1 *)_check_unknown_subscript(e1, sizeof(ta1), 0))->f
      type_t ta1 = typ_to_c(ta);
      e1->r = cast_it_r(cstar_typ(ta1,tq),
                        fncall_exp(_check_dyneither_subscript_e,
                                   list(new_exp(e1->r,DL),
                                        sizeoftyp_exp(ta1,DL),
                                        uint_exp(0,DL)),DL));


      break;
    }
    if (is_tagged && is_read) {
      e->r = check_tagged_union(e1,typ_to_c(e1typ),ta,f,in_lhs(nv),aggrarrow_exp);
    }
    if(is_poly && is_read)
      e->r = array_to_ptr_cast(typ_to_c((type_t)e->topt),new_exp(e->r,DL),DL)->r;
    set_lhs(nv,old_lhs);
    break;
  case &Subscript_e(e1,e2):
    let old_lhs = in_lhs(nv);
    set_lhs(nv,false);
    let e1_typ = compress((type_t)e1->topt);
    // e1 could be a tuple or an array of various sorts
    switch (e1_typ) {
    case &TupleType(ts):
      // e1->fi  where i = e2+1
      exp_to_c(nv, e1);
      exp_to_c(nv, e2);
      let $(i,known) = Evexp::eval_const_uint_exp(e2);
      if(!known)
	impos("unknown tuple subscript in translation to C");
      e->r = aggrmember_exp_r(e1,fieldname(i+1));
      break;
    case &PointerType(PtrInfo{ta,tq,PtrAtts(rgn,bcr,b,zt,_)}):
      let relns = get_relns(e1);
      let need_nullchk = need_null_check(e1);
      let in_sz = in_sizeof(nv);
#ifdef BCE_DEBUG
      fprintf(stderr,"subscript %s, array has type %s: relns:",exp2string(e),
              typ2string((type_t)e1->topt));
      Relations::print_relns(stderr,relns); fprintf(stderr,"\n");
#endif
      bool in_bnds = in_sz;
      switch (conref_def(bounds_one,b)) {
      default:
	in_bnds = in_bnds || check_bounds(e1_typ,relns,e1,e2);
	if(warn_bounds_checks && !in_bnds)
	  Tcutil::warn(e->loc,"bounds check necessary for %s", exp2string(e));
#ifdef BCE_DEBUG
      fprintf(stderr,"check bounds returned %s\n", in_bnds ? "true " : "false");
#endif
      }
      exp_to_c(nv, e1);
      exp_to_c(nv, e2);
      total_bounds_checks++;
      switch (conref_def(bounds_one,b)) {
      case &Upper_b(esz):
        bool possibly_null = conref_def(false,bcr) && need_nullchk;
	type_t ta1 = typ_to_c(ta);
	type_t ta2 = cstar_typ(ta1, tq);
        if (in_bnds && !possibly_null)
	  bounds_checks_eliminated++;
        else if (in_bnds && possibly_null) {
          bounds_checks_eliminated++;
          if (warn_all_null_deref)
            warn(e->loc, "inserted null check due to dereference");
          e1->r = cast_it_r(ta2,fncall_exp(_check_null_e,
                                           list(copy_exp(e1)),DL));
        // check if zero terminated
        } else if (conref_def(false,zt)) {
          // *((ta2)_zero_arr_plus(e1, esz, e2)
          if (!Evexp::c_can_eval(esz))
            terr(e->loc,"cannot determine subscript is in bounds");
          exp_t function_e = getFunctionRemovePointer(&_zero_arr_plus_functionSet,e1);
          e->r = deref_exp_r(cast_it(ta2,
                                     fncall_exp(function_e,
                                                list(e1,esz,e2),DL)));
        } else if(possibly_null) {
          if (!Evexp::c_can_eval(esz))
            terr(e->loc,"cannot determine subscript is in bounds");
          if (warn_all_null_deref)
            warn(e->loc, "inserted null check due to dereference");
	  // *((ta2)_check_known_subscript_null(e1, esz, sizeof(ta), e2)
	  e->r = deref_exp_r(cast_it(ta2,
                                     fncall_exp(_check_known_subscript_null_e,
                                                list(e1,esz,
                                                     sizeoftyp_exp(ta1,DL),
                                                     e2),DL)));
	} else {
          if (!Evexp::c_can_eval(esz))
            terr(e->loc,"cannot determine subscript is in bounds");
	  // e1[_check_known_subscript_notnull(esz,e2)]
	  e2->r = fncall_exp_r(_check_known_subscript_notnull_e,
                               list(esz,copy_exp(e2)));
        }
	break;
      case &DynEither_b:
	type_t ta1 = typ_to_c(ta);
        if (in_bnds) {
          // there's no need for a null-check here either because
          // a NULL ? pointer has size 0
          bounds_checks_eliminated++;
          e->r = subscript_exp_r(cast_it(cstar_typ(ta1,tq),
                                         member_exp(e1,curr_sp,DL)),e2);
        } else {
          // *((ta1 *) _check_unknown_subscript(e1, sizeof(ta1), e2))
          let _check_f = _check_dyneither_subscript_e;
          e->r = deref_exp_r(cast_it(cstar_typ(ta1,tq),
                                     fncall_exp(_check_f,
                                                list(e1,sizeoftyp_exp(ta1,DL),
                                                     e2),DL)));
        }
	break;
      }
      break;
    default: toc_impos("exp_to_c: Subscript on non-tuple/array/tuple ptr");
    }
    set_lhs(nv,old_lhs);
    break;
  case &Tuple_e(es):
    if(!is_toplevel(nv))
      e->r = init_tuple(nv,false,NULL,es)->r;
    else {
      // At top-level use an initializer
      // $(e1,...,en) -> {e1,...,en}
      let tqs = List::map(tup_to_c,es);
      let n = add_tuple_type(tqs);
      list_t<$(list_t<designator_t,`H>,exp_t)@`H,`H> dles = NULL;
      for (int i = 1; es != NULL; es = es->tl, i++) {
	exp_to_c(nv,es->hd);
	dles = new List(new $(NULL,es->hd),dles);
      }
      dles = List::imp_rev(dles);
      e->r = unresolvedmem_exp_r(NULL,dles);
    }
    break;
  case &Array_e(dles0):
    // An array not under a "new" -- should only occur in initializer positions.
    // {e1,...,en}
    e->r = unresolvedmem_exp_r(NULL,dles0);
    for (let dles = dles0; dles != NULL; dles = dles->tl) {
      let &$(_,e) = dles->hd;
      exp_to_c(nv,e);
    }
    break;
  case &Comprehension_e(vd,e1,e2,iszeroterm):
    // a comprehension not under a "new" -- should only be the case
    // when e1 is constant.  For now, e2 must be too...
    let $(sz,known) = Evexp::eval_const_uint_exp(e1);
    let elt_typ = typ_to_c((type_t)e2->topt);
    exp_to_c(nv,e2);
    list_t<$(list_t<designator_t>,exp_t)@> es = NULL;
    // generate an "empty" array intializer to avoid giant arrays
    if (!is_zero(e2)) {
      if(!known)
	Tcutil::terr(e1->loc, "cannot determine value of constant");
      for (unsigned int i = 0; i < sz; i++)
        es = new List(new $(NULL,e2),es);
      // for a zero-terminated comprehension, add in an implicit 0 to the end
      if (iszeroterm) {
        let ezero = cast_it(elt_typ,uint_exp(0,DL));
        es = List::imp_append(es,new List{new $(NULL,ezero), NULL});
      }
    }
    e->r = unresolvedmem_exp_r(NULL,es);
    break;
  case &ComprehensionNoinit_e(e1,t1,iszeroterm):
    // we just inherit the size from the context by returning an
    // empty array
    e->r = unresolvedmem_exp_r(NULL,NULL);
    break;
  case &Aggregate_e(tdn,ts,dles,sd):
    // Due to a GCC bug w.r.t. to nested designators, we expand this out
    // to ({ t temp; t.f1 = e1, ..., t.fn = en; t}).
    if(!is_toplevel(nv)) {
      let e2 = init_struct(nv,old_typ,ts,false,NULL,dles,tdn);
      e->r = e2->r;
      e->topt = e2->topt;
    }
    else {
      // At top-level must create an initializer.  For MSVC, sort fields
      // and drop initializers (sorting okay b/c we're at top-level)
      //
      // JGM: unfortunately, doesn't work for tagged unions -- we need
      // the designators to distinguish the various cases.
      if(sd == NULL)
	toc_impos("Aggregate_e: missing aggrdecl pointer");
      aggrdecl_t sd2 = (aggrdecl_t)sd;

      TOC_RGN(nv,rgn) {
      let fields = Tcutil::resolve_aggregate_designators(rgn, e->loc, dles,
                                                         sd2->kind,
                                                         sd2->impl->fields);
      if (sd->impl->tagged) {
        // should only be one field
        let &$(field,fieldexp) = fields->hd;
        let fieldexp_type = (type_t)fieldexp->topt;
        let fieldtyp = field->type;
        exp_to_c(nv,fieldexp);
        if (is_void_star_or_boxed_tvar(fieldtyp) &&
            !is_void_star_or_boxed_tvar(fieldexp_type))
          fieldexp->r =
            cast_it_r(void_star_typ(),new_exp(fieldexp->r,DL));
        // for tagged unions, must insert tag here
        int i = get_member_offset(sd,field->name);
        exp_t field_tag_exp = signed_int_exp(i,0);
        let newdles = list(new $(NULL,field_tag_exp), new $(NULL,fieldexp));
        exp_t umem = unresolvedmem_exp(NULL,newdles,0);
        list_t<designator_t> ds = list(new FieldName(field->name));
        list_t<$(list_t<designator_t>,exp_t)@> dles = list(new $(ds,umem));
        e->r = unresolvedmem_exp_r(NULL,dles);
      } else { // not tagged
        // here is where we now sort
        let newdles = NULL;
        let sdfields = sd2->impl->fields;
        for(; sdfields!=NULL; sdfields=sdfields->tl)
          for (let fields2 = fields; fields2 != NULL; fields2 = fields2->tl) {
            if((*fields2->hd)[0] == sdfields->hd) {
              let &$(field,fieldexp) = fields2->hd;
              let fieldtyp = typ_to_c(field->type);
              let fieldexp_typ = typ_to_c((type_t)fieldexp->topt);
              exp_to_c(nv,fieldexp);
              // must cast when the types don't match up 
              if (!unify(fieldtyp, fieldexp_typ)) 
                // unless they are both arithmetic types -- C can handle this.
                if (!is_arithmetic_type(fieldtyp) ||
                    !is_arithmetic_type(fieldexp_typ))
                fieldexp = cast_it(fieldtyp, copy_exp(fieldexp));
              newdles = new List(new $(NULL,fieldexp), newdles);
              break;
            }
          }
        e->r = unresolvedmem_exp_r(NULL,imp_rev(newdles));
      }
      }
    }
    break;
  case &AnonStruct_e(st,dles):
    list_t<aggrfield_t> fs;
    switch (compress(st)) {
    case &AnonAggrType(_,afs): fs = afs; break;
    default: toc_impos("anon struct has type %s",typ2string(st));
    }
    TOC_RGN(nv,rgn) {
      let fields = Tcutil::resolve_aggregate_designators(rgn, e->loc, dles, StructA, fs);
      for (; fields != NULL; fields = fields->tl) {
        let &$(field,fieldexp) = fields->hd;
        let fieldexp_type = (type_t)fieldexp->topt;
        let fieldtyp = field->type;
        exp_to_c(nv,fieldexp);
        if (is_void_star_or_boxed_tvar(fieldtyp) &&
            !is_void_star_or_boxed_tvar(fieldexp_type))
          fieldexp->r = cast_it_r(void_star_typ(),new_exp(fieldexp->r,DL));
      }
      //for (let es = dles; es != NULL; es = es->tl)
      //  exp_to_c(nv,es->hd[1]);
      //FIX: this has GCC bug written all over it.
      e->r = unresolvedmem_exp_r(NULL,dles);
    }
    break;

  case &Datatype_e(es,tud,tuf):
    type_t datatype_ctype;
    exp_t tag_exp;
    let x = temp_var();
    let xexp = var_exp(x,DL);
    exp_t mem_exp;
    datatype_ctype = strctq(collapse_qvars(tuf->name,tud->name));
    tag_exp = (tud->is_extensible) ? var_exp(tuf->name,DL) :
      datatype_tag(tud,tuf->name);
    mem_exp = xexp;
    let tqts = tuf->typs;
    // we have to do this differently for the toplevel
    if (is_toplevel(nv)) {
      // {i, e1, ... , en};
      list_t<$(list_t<designator_t,`H>,exp_t)@`H,`H> dles = NULL;
      for(; es != NULL; es = es->tl, tqts = tqts->tl) {
	exp_t cur_e = es->hd;
        let cur_e_typ = (type_t)cur_e->topt;
	type_t field_typ = typ_to_c((*tqts->hd)[1]);
	exp_to_c(nv,cur_e);
	if (is_void_star_or_boxed_tvar(field_typ) && 
            !is_pointer_or_boxed_tvar(cur_e_typ))
	  cur_e = cast_it(field_typ,cur_e);
	dles = new List(new $(NULL,cur_e),dles);
      }
      dles = new List(new $(NULL,tag_exp),imp_rev(dles));
      e->r = unresolvedmem_exp_r(NULL,dles);
    } else {
      // Not at top-level:
      // ({ struct F x; x.tag = i; x.f1 = e1; ...; x.fn = en; x; })
      // Due to GCC bug we can't just use a struct expression
      let rev_assign =
	new List(assign_stmt(member_exp(mem_exp,tag_sp,DL),tag_exp, DL),
                 NULL);
      for (int i = 1; es != NULL; es = es->tl, i++, tqts = tqts->tl) {
	exp_t cur_e = es->hd;
        let cur_e_typ = (type_t)cur_e->topt;
	type_t field_typ = typ_to_c((*tqts->hd)[1]);
	exp_to_c(nv,cur_e);
	if (is_void_star_or_boxed_tvar(field_typ) && 
            !is_pointer_or_boxed_tvar(cur_e_typ))
	  cur_e = cast_it(field_typ,cur_e);
	let a = assign_stmt(member_exp(mem_exp,fieldname(i), DL),
			    cur_e,DL);
	rev_assign = new List(a,rev_assign);
      }
      let final_stmt = exp_stmt(xexp,DL);
      let s2         = seq_stmts(imp_rev(new List(final_stmt,rev_assign)),DL);
      e->r = stmt_exp_r(declare_stmt(x,datatype_ctype,NULL,s2,DL));
    }
    break;

  case &Enum_e(_,_,_):
  case &AnonEnum_e(_,_,_): break;

  case &Malloc_e(MallocInfo{is_calloc,rgnopt,topt,num_elts,is_fat,inline_call}):
    type_t t_c = typ_to_c(*topt);
    exp_to_c(nv,num_elts);
    // FIX: we shouldn't be able to calloc a zero-terminated array of
    // size less than 1.
    if (is_fat) {
      let x = temp_var();
      let p = temp_var();
      exp_t pexp, xexp, rexp;
      if (is_calloc) {
        xexp = num_elts;
        if (rgnopt != NULL && !no_regions) {
          exp_t rgn = (exp_t)rgnopt;
          exp_to_c(nv,rgn);
          pexp = rcalloc_exp(rgn, sizeoftyp_exp(t_c,DL), var_exp(x,DL));
        } else {
          pexp = calloc_exp(*topt,sizeoftyp_exp(t_c,DL), var_exp(x,DL));
        }
        rexp = fncall_exp(_tag_dyneither_e,
                          list(var_exp(p,DL),sizeoftyp_exp(t_c,DL),
                               var_exp(x,DL)), DL);
      } else {
        if (rgnopt != NULL && !no_regions) {
          exp_t rgn = (exp_t)rgnopt;
          exp_to_c(nv,rgn);
          if (inline_call)
            pexp = rmalloc_inline_exp(rgn, var_exp(x,DL));
          else
            pexp = rmalloc_exp(rgn, var_exp(x,DL));
        } else {
          pexp = malloc_exp(*topt, var_exp(x,DL));
        }
        rexp = fncall_exp(_tag_dyneither_e, list(var_exp(p,DL),uint_exp(1,DL),
                                                  var_exp(x,DL)), DL);
      }
      let s = declare_stmt(x, uint_typ, num_elts,
                           declare_stmt(p,cstar_typ(t_c,mt_tq),pexp,
                                        exp_stmt(rexp,DL),DL),DL);
      e->r = stmt_exp_r(s);
    } else {
      if (is_calloc) {
        if (rgnopt != NULL && !no_regions) {
          exp_t rgn = (exp_t)rgnopt;
          exp_to_c(nv,rgn);
          e->r = rcalloc_exp(rgn, sizeoftyp_exp(t_c,DL), num_elts)->r;
        } else {
          e->r = calloc_exp(*topt,sizeoftyp_exp(t_c,DL), num_elts)->r;
        }
      } else {
        if (rgnopt != NULL && !no_regions) {
          exp_t rgn = (exp_t)rgnopt;
          exp_to_c(nv,rgn);
          if (inline_call)
            e->r = rmalloc_inline_exp(rgn, num_elts)->r;
          else
            e->r = rmalloc_exp(rgn, num_elts)->r;
        } else {
          e->r = malloc_exp(*topt, num_elts)->r;
        }
      }
    }
    break;

  case &Swap_e(e1,e2):
    // for pointer values, do
    //   swap(e1,e2) --> _swap_kw(&e1,&e2)
    // where _swap_kw is _swap_word for word-sized values, and something
    // different for the two kinds of fat pointers.  Assumes that we are
    // not swapping zero-terminated array elements so that we can avoid
    // adding dynamic checks.
    type_t e1_old_typ = (type_t)e1->topt;
    type_t e2_old_typ = (type_t)e2->topt;
    if (!is_boxed(e1_old_typ) && !is_pointer_type(e1_old_typ))
      toc_impos("Swap_e: is_pointer_or_boxed: not a pointer or boxed type");

    // figure out which swap primitive to use
    exp_t swap_fn;
    if (is_dyneither_ptr(e1_old_typ))
      swap_fn = _swap_dyneither_e;
    else
      swap_fn = _swap_word_e;

    // figure out if these are tagged-union projections -- if so, then
    // we need to do some fix-up work after translating.
    int f1_tag = 0;
    type_t tagged_mem_type1 = &VoidType_val;
    bool e1_tmem = is_tagged_union_project(e1,&f1_tag,&tagged_mem_type1,true);
    int f2_tag = 0;
    type_t tagged_mem_type2 = &VoidType_val;
    bool e2_tmem = is_tagged_union_project(e2,&f2_tag,&tagged_mem_type2,true);

    set_lhs(nv,true);
    exp_to_c(nv,e1);
    exp_to_c(nv,e2);
    set_lhs(nv,false);

    // special case when e1 or e2 is a tagged union member (e.g., e.f or e->f)
    if (e1_tmem) {
      add_tagged_union_check_for_swap(e1,f1_tag,tagged_mem_type1);
    } else {
      // we may have to push the address operation in to get a valid lhs
      e1 = push_address_exp(e1);
    }
    if (e2_tmem) {
      add_tagged_union_check_for_swap(e2,f2_tag,tagged_mem_type2);
    } else {
      // we may have to push the address operation in to get a valid lhs
      e2 = push_address_exp(e2);
    }
    e->r = fncall_exp_r(swap_fn,list(e1,e2));

    break;
  case &Tagcheck_e(e1,f):
    // e1.f.tag == f_tag
    let e1_typ = compress((type_t)e1->topt);
    exp_to_c(nv,e1);
    switch (e1_typ) {
    case &AggrType(AggrInfo({.KnownAggr = &ad}, _)):
      let f_tag = signed_int_exp(get_member_offset(ad,f),DL);
      let e1_f = member_exp(e1,f,DL);
      let e1_f_tag = member_exp(e1_f,tag_sp,DL);
      e->r = eq_exp(e1_f_tag,f_tag,DL)->r;
      break;
    default: toc_impos("non-aggregate type in tagcheck");
    }
    break;
  case &StmtExp_e(s): stmt_to_c(nv,s);  break;
  case &UnresolvedMem_e(_,_): toc_impos("UnresolvedMem");
  case &CompoundLit_e(_,_):   unimp("compoundlit");
  case &Valueof_e(_): toc_impos("valueof(-)");
  case &Asm_e(...): toc_impos("__asm__");
  }
}

// Translate a pattern generating tests which jump goes to fail_lab
// on unsuccessful match.
// Returns:
// * a new translation environment (mapping variables bound in the pattern
//   to temps generated)
// * a list of temps to be declared (along with their types.)
//   This list contains the decls parameter
// * The statement for actually doing the test.
//
// (The temps must be declared with a wide enough
// scope to cover the tests and any cases in a switch (hence the reason
// they're pulled out.  Also needed for translating fallthru.)
//
// xlate_pat(env,t,r,path,p,fail_lab)
//
//  r is the "root" variable that contains the value we're matching.
//  path is the address of this value -- used in the Reference pattern.
//  p is the pattern
//  we do nothing on successful match -- caller puts the right code next
//  fail_lab is where to go upon failure to match
//
// FIX: adapt the decision tree code in the type-checker so that we
// have much more efficient traversal of patterns.
//
// Note: Extra labels and gotos aren't a big deal b/c gcc -O collapses them.
//
// Warning: We end sharing the fail_exps -- they should be copied if they
//          might be mutated later!
static stmt_t if_neq_stmt(exp_t e1,exp_t e2,stmt_t fail_stmt) {
  return ifthenelse_stmt(neq_exp(e1,e2,DL),
			 fail_stmt,
			 skip_stmt_dl(),DL);
}

static int path_length(exp_t e) {
  switch (e->r) {
  case &Cast_e(_,e1,_,_): return path_length(e1);
  case &Deref_e(e1): return 1 + path_length(e1);
  case &AggrMember_e(e1,...): return path_length(e1);
  default: return 0;
  }
}

static $(env_t<`rgn>,list_t<$(qvar_t,type_t)@`rgn,`rgn>,stmt_t)
xlate_pat(env_t<`rgn> nv,
          region_t<`rgn> rgn, type_t t, exp_t r, exp_t path, pat_t p,
	  stmt_t fail_stmt,
          list_t<$(qvar_t,type_t)@`rgn,`rgn> decls) {
  stmt_t s; // the test statement
  switch (p->r) {
  case &AliasVar_p(_,&Vardecl(_,x,_,_,_,_,_,_)):
    let p2 = new_pat(&Wild_p_val,0);
    p2->topt = p->topt;
    fallthru(x,p2);
  case &Var_p(&Vardecl(_,x,_,_,_,_,_,_),p2):
    // v = r (and substitute v for x) and continue matching p2 against r
    qvar_t v = temp_var();
    let t2 = (type_t)p2->topt;
    decls = rnew(rgn) List(rnew(rgn) $(v,typ_to_c_array(t2)), decls);
    let result = xlate_pat(add_varmap(rgn,nv,x,var_exp(v,DL)),
                           rgn,t2,var_exp(v,DL),path,p2,fail_stmt,decls);
    nv = result[0];
    decls = result[1];
    let s2 = result[2];
    let s3 = assign_stmt(var_exp(v,DL),r,DL);
    s = seq_stmt(s3,s2,DL);
    break;
  case &TagInt_p(_,&Vardecl(_,x,_,_,_,_,_,_)): // type translation erases tvar
    // v = r  (and substitute v for x)
    let v = temp_var();
    let t2 = (type_t)p->topt;
    decls = rnew(rgn) List(rnew(rgn) $(v,typ_to_c_array(t2)), decls);
    nv = add_varmap(rgn,nv,x,var_exp(v,DL));
    s = assign_stmt(var_exp(v,DL),r,DL);
    break;
  case &Wild_p: s = skip_stmt_dl(); break; 
  case &Reference_p(vd,p2):
    // v = &path
    let v = temp_var();
    decls = rnew(rgn) List(rnew(rgn) $(v,cstar_typ(typ_to_c_array(t),mt_tq)),decls);
    nv    = add_varmap(rgn,nv,vd->name,var_exp(v,DL));
    // cast is needed to avoid a C warning when pointing to a polymorphic field
    s     = assign_stmt(var_exp(v,DL),
			cast_it(cstar_typ(typ_to_c_array(t),mt_tq),
                                push_address_exp(path)),DL);
    let result = xlate_pat(nv,rgn,t,r,path,p2,fail_stmt,decls);
    result[2] = seq_stmt(s,result[2],DL);
    return result;
  // for these cases, if (r != value) goto fail_label.
  case &Null_p:       s=if_neq_stmt(r,signed_int_exp(0,DL),fail_stmt); break;
  case &Int_p(sn,i):  s=if_neq_stmt(r,int_exp(sn,i,DL),    fail_stmt); break;
  case &Char_p(c):    s=if_neq_stmt(r,char_exp(c,DL),      fail_stmt); break;
  case &Float_p(f,i): s=if_neq_stmt(r,float_exp(f,i,DL),   fail_stmt); break;
  case &Enum_p(ed,ef):
    s = if_neq_stmt(r,new_exp(new Enum_e(ef->name,ed,ef),DL),fail_stmt);
    break;
  case &AnonEnum_p(t2,ef):
    s = if_neq_stmt(r,new_exp(new AnonEnum_e(ef->name,t2,ef),DL),fail_stmt);
    break;

  case &Pointer_p(&Pat{&Datatype_p(tud,tuf,ps,_),_,_}):
    // when ps is p1,...,pn:
    //   struct C* temp = (struct C*)r;
    //   if (temp->tag == qv_tag)
    //      <similar to tuple and struct patterns>
    //   else goto fail_lab
    // FIX: When type is DatatypeField, can avoid all checks
    s = skip_stmt_dl();
    let temp        = temp_var();
    qvar_t tufstrct = collapse_qvars(tuf->name,tud->name);
    let field_ptr_typ = cstar_typ(strctq(tufstrct),mt_tq);
    int    cnt      = 1;
    exp_t  rcast    = cast_it(field_ptr_typ,r);
    let tuf_tqts = tuf->typs;
    for(; ps != NULL; ps = ps->tl, tuf_tqts = tuf_tqts->tl, ++cnt) {
      let p2  = ps->hd;
      if(p2->r == &Wild_p_val)
	continue;
      let tuf_typ = (*tuf_tqts->hd)[1];
      let t2  = (type_t)p2->topt;
      let t2c = typ_to_c_array(t2);
      let arrow_exp = aggrarrow_exp(var_exp(temp,DL), fieldname(cnt), DL);
      if(is_void_star_or_boxed_tvar(typ_to_c(tuf_typ)))
	arrow_exp = cast_it(t2c, arrow_exp);
      // FIX?  why aren't we using path->fi for the path?
      let result = xlate_pat(nv,rgn,t2,arrow_exp,arrow_exp,
			     p2,fail_stmt,decls);
      nv = result[0];
      decls = result[1];
      s = seq_stmt(s, result[2], DL);
    }
    exp_t temp_tag = aggrarrow_exp(var_exp(temp,DL), tag_sp, DL);
    exp_t tag_exp =
      tud->is_extensible ? var_exp(tuf->name,DL) : datatype_tag(tud,tuf->name);
    exp_t test_exp = neq_exp(temp_tag, tag_exp, DL);
    s = ifthenelse_stmt(test_exp,fail_stmt,s,DL);
    if (is_nullable((type_t)p->topt)) {
      // must check for null first -- note that the type-checker
      // prevents fat or zero-terminated pointers from showing up here.
      s = ifthenelse_stmt(eq_exp(var_exp(temp,DL),uint_exp(0,DL),DL),
                          fail_stmt, s, DL);
    }
    s = declare_stmt(temp,field_ptr_typ,rcast,s,DL);
    break;

  case &Datatype_p(_,_,ps,_): fallthru(ps);
  case &Tuple_p(ps,_):
    // given the pattern $(p1,p2,...,pn)
    //    v1 = r->f1; if (matches(v1,p1)) goto L1 else goto fail_lab;
    // L1:v2 = r->f2; if (matches(v2,p2)) goto L2 else goto fail_lab;
    // L2:v3 = r->f3; if (matches(v3,p2)) goto L3 else goto fail_lab;
    //    ...
    // Ln-1:vn = r->fn; if (matches(vn,p2)) goto succ_lab else goto fail_lab;
    s = skip_stmt_dl(); // wasteful
    int cnt = 1;
    for(; ps != NULL; ps = ps->tl, ++cnt) {
      let p2  = ps->hd;
      if(p2->r == &Wild_p_val)
	continue;
      let t2  = (type_t)p2->topt;
      let f = fieldname(cnt);
      let result = xlate_pat(nv,rgn,t2,member_exp(r,f,DL),
                             member_exp(path,f,DL),p2,fail_stmt,decls);
      nv = result[0];
      decls = result[1];
      s = seq_stmt(s,result[2],DL);
    }
    break;
  case &Aggr_p(NULL,...):
    toc_impos("unresolved aggregate pattern!");
  case &Aggr_p(&AggrInfo(info,_),_,dlps,_):
    let ad = get_known_aggrdecl(info);
    if (ad->impl->tagged) {
      // tagged union pattern:  Foo{.f = pat}
      // if (r.f.tag != f_tag) goto fail_lab;
      let &$(designators,pat) = dlps->hd;
      field_name_t f;
      switch (designators->hd) {
      case &FieldName(fn): f = fn; break;
      default: toc_impos("no field name in tagged union pattern");
      }
      //let v = temp_var();
      let t2 = (type_t)pat->topt;
      let t2c = typ_to_c_array(t2);
      //decls = rnew(rgn) List(rnew(rgn) $(v,t2c),decls);
      let pexp = aggrmember_exp(member_exp(path,f,DL),val_sp,DL);
      let memexp = aggrmember_exp(member_exp(r,f,DL),val_sp,DL);
      memexp = cast_it(t2c, memexp);
      pexp = cast_it(t2c,pexp);
      let result = xlate_pat(nv,rgn,t2,
                             memexp,
                             //var_exp(v,DL),
                             pexp,pat,fail_stmt,decls);
      nv = result[0];
      decls = result[1];
      let s2 = result[2];
      let s4 = if_neq_stmt(aggrmember_exp(member_exp(r,f,DL),tag_sp,DL),
                           signed_int_exp(get_member_offset(ad,f),DL),
                           fail_stmt);
      //let s3 = assign_stmt(var_exp(v,DL),memexp,DL);
      //s = seq_stmt(s4,seq_stmt(s3,s2,DL),DL);
      s = seq_stmt(s4,s2,DL);
    } else {
      // similar to translation of tuple pattern
      s = skip_stmt_dl();
      for (; dlps != NULL; dlps = dlps->tl) {
        let tup = dlps->hd;
        let p2  = (*tup)[1];
        if(p2->r == &Wild_p_val)
          continue;
        _ f;
        switch ((*tup)[0]->hd) {
        case &FieldName(f2): f=f2; break;
        default: throw new Match_error; // FIX:  assumes one field name designator
        }
        let t2 = (type_t)p2->topt;
        let t2c = typ_to_c_array(t2);
        let memexp = member_exp(r,f,DL);
        let ftype = lookup_field(ad->impl->fields,f)->type;
        let new_path = member_exp(path,f,DL);
        if (is_void_star_or_boxed_tvar(ftype))
          memexp = cast_it(t2c, memexp);
        else if (!is_array_type(ftype) && kind_leq(&ak,typ_kind(ftype))) {
          // for abstract members, we have to convert to the right
          // pointer type...
          memexp = deref_exp(cast_it(cstar_typ(t2c,mt_tq), 
                                     address_exp(memexp,DL)),DL);
          
          new_path = push_address_exp(new_path);
          new_path = cast_it(cstar_typ(t2c,mt_tq),new_path);
          new_path = deref_exp(new_path, DL);
        }
        let result = xlate_pat(nv,rgn,t2,memexp,new_path,p2,fail_stmt,decls);
        nv = result[0];
        decls = result[1];
        s = seq_stmt(s, result[2], DL);
      }
    }
    break;

  case &Pointer_p(p2):
    let t2 = (type_t)p2->topt;
    // if (path_length(r) > 2)
    // could insert a variable here but not a big deal.
    let result = xlate_pat(nv,rgn,t2,deref_exp(r,DL), deref_exp(path,DL),p2,
			   fail_stmt,decls);
    nv = result[0];
    decls = result[1];
    let s2 = result[2];
    if (is_nullable(t))
      s = seq_stmt(ifthenelse_stmt(eq_exp(r,signed_int_exp(0,DL),DL),
				   fail_stmt,
				   skip_stmt_dl(), DL), s2, DL);
    else
      s = s2;
    break;
  case &UnknownId_p(_):     toc_impos("unknownid pat");
  case &UnknownCall_p(_,_,_): toc_impos("unknowncall pat");
  case &Exp_p(_):           toc_impos("exp pat");
  }
  return $(nv,decls,s);
}

///////////////////////////////////////////////////////////////
//              Translation of Switch Statements             //
///////////////////////////////////////////////////////////////
// FIX:  Should use decision tree stuff from tcpat.
//
// For performance, we try to leave switches as switches.  We do this when
// all of the following hold:
// * We are switching on a char or int type.
//   (Could also do datatype without value contructors, but we didn't pass in
//    access to the type definitions!)
// * No switch_clause has any variables. (reject switch(3) { case x: ... }
// The hitch is we could still have something like
//    switch(e) { case 0: if(b) fallthru; else return; }
// Therefore, we give each case body
// a fresh label so we can translate fallthru to goto.
// Then we just hope gcc cleans up the mess and can still use jump tables.
//
// For all other switches,
// switch (e) { case p1: s1 ... case pn:sn } turns into (roughly)
//
//  x = e;
//  <lots of temp declarations>
//    if !matches(p1,x) goto L2; L1: s1;
// L2:if !matches(p2,x) goto L4; L3: s2;
// L4:if !matches(p3,x) goto L4; L5: s3;
//     ...
// L2n: ; // destination of break within the original switch cases
// L2n-2:if matches(pn,x) goto L2n-1 else goto L2n;
// L1: s1;
// L3: s2;
// L5: s3;
// ...
// L2n-1: sn;
// L2n: ;
static $(var_t,var_t,switch_clause_t)@`r gen_label(region_t<`r> r,
                                                   switch_clause_t sc) {
  return rnew(r) $(fresh_label(),fresh_label(),sc);
}

static void xlate_switch(env_t nv, stmt_t whole_s,
			 exp_t e, list_t<switch_clause_t> scs) {
  exp_to_c(nv,e);
  let t = (type_t)e->topt;

  // decide if we can leave it as a switch
  // FIX: cannot have Float_p in any cases.
  bool leave_as_switch;
  switch (compress(t)) {
  case &IntType(_,_):
  case &EnumType(_,_): leave_as_switch = true;  break;
  default:             leave_as_switch = false; break;
  }
  for(let scs1 = scs; scs1 != NULL; scs1 = scs1->tl)
    if(scs1->hd->pat_vars->v != NULL || scs1->hd->where_clause != NULL) {
      leave_as_switch = false;
      break;
    }
  if(leave_as_switch) {
    // note: fallthru in last case can't happen, else this is busted
    var_t next_l = fresh_label();
    for(let scs1 = scs; scs1 != NULL; scs1 = scs1->tl) {
      let s = scs1->hd->body;
      scs1->hd->body = label_stmt(next_l,s,DL);
      next_l = fresh_label();
      TOC_RGN(nv,rgn) {
        stmt_to_c(switch_as_switch_env(rgn,nv,next_l),s);
      }
    }
    return;
  }
  // no dice, translate to a nest of gotos...
  qvar_t v     = temp_var();
  exp_t  r     = var_exp(v,DL);
  exp_t  path  = var_exp(v,DL);
  var_t  end_l = fresh_label();
  // for each case, generate a test label and an entry label
  TOC_RGN(nv,rgn) {
    let nv = share_env(rgn,nv);
    list_t<$(var_t,var_t,switch_clause_t)@/*`rgn,`rgn*/> lscs =
      List::rmap_c(rgn,gen_label,rgn,scs);
    list_t<stmt_t/*,`rgn*/>                test_stmts = NULL;
    list_t<env_t/*,`rgn*/>                 nvs        = NULL;
    list_t<$(qvar_t,type_t)@/*`rgn,`rgn*/> decls      = NULL;
    // generate the tests for each case, continuing to the case's
    // label on success and to the next test on false.
    // do tests first so as to get vars for fallthrus
    // the last case is different b/c there's no fallthru so fake it with end_l
    for (let lscs2 = lscs; lscs2 != NULL; lscs2 = lscs2->tl) {
      switch_clause_t sc = (*lscs2->hd)[2];
      var_t fail_lab = (lscs2->tl == NULL) ? end_l : (*lscs2->tl->hd)[0];
      let $(nv2,decls2,test_stmt) = xlate_pat(nv,rgn,t,r,path,sc->pattern,
					      goto_stmt(fail_lab,DL),
                                              decls);
      if(sc->where_clause!=NULL) {
	let e = (exp_t)sc->where_clause;
	exp_to_c(nv2,e); // nv2 b/c pattern vars are in scope
	test_stmt = seq_stmt(test_stmt, ifthenelse_stmt(prim1_exp(Not,e,DL),
							goto_stmt(fail_lab,DL),
							skip_stmt_dl(), DL),DL);
      }
      decls = decls2;
      nvs = rnew(rgn) List(nv2,nvs);
      test_stmts = rnew(rgn) List(test_stmt,test_stmts);
    }
    nvs = List::imp_rev(nvs);
    test_stmts = List::imp_rev(test_stmts);
    list_t<stmt_t> stmts = NULL;
    // now generate all of the statements for the cases
    // note: first test_lab is unnecessary
    for (; lscs != NULL;
	 lscs = lscs->tl, nvs = nvs->tl, test_stmts = test_stmts->tl) {
      let &$(test_lab,body_lab,body_sc) = lscs->hd;
      let env = nvs->hd;
      stmt_t s = body_sc->body;
      TOC_RGN(nv, rgn2) {
        if(lscs->tl != NULL) {
          let &$(_,fallthru_lab,next_sc) = lscs->tl->hd;
	  let vs = Tcutil::filter_nulls(List::split(next_sc->pat_vars->v)[0]);
	  vs = List::imp_rev(vs);
          stmt_to_c(non_last_switchclause_env(rgn2, env, end_l, fallthru_lab,
                                              vs,
                                              nvs->tl->hd),
                    s);
        } else
          stmt_to_c(last_switchclause_env(rgn2,env, end_l), s);
      }
      s = seq_stmt(label_stmt(test_lab,test_stmts->hd,DL),
		   label_stmt(body_lab,s,DL), DL);
      stmts = rnew(rgn) List(s, stmts);
    }
    stmt_t res = seq_stmt(seq_stmts(List::imp_rev(stmts),DL),
			  label_stmt(end_l, skip_stmt_dl(), DL), DL);
    // add in all of the variable declarations with a wide enough scope
    for (decls; decls != NULL; decls = decls->tl) {
      let &$(qv,t) = decls->hd;
      res = declare_stmt(qv, t, NULL, res, DL);
    }
    // add in the variable holding the test and clobber the abstract syntax
    whole_s->r = declare_stmt(v,typ_to_c((type_t)e->topt),e, res, DL)->r;
  }
}

// forward declarations
static stmt_t letdecl_to_c(env_t nv, pat_t p, type_t t, exp_t e, stmt_t s);
static void local_decl_to_c(env_t body_nv,env_t init_nv,vardecl_t vd,stmt_t s);

///////////////////////////////////////////////////////////////
//              Translation of Statements                    //
///////////////////////////////////////////////////////////////
static void fndecl_to_c(env_t nv, fndecl_t f, bool cinclude);

stmt_t make_npop_handler(int n) {
  return exp_stmt(fncall_exp(_npop_handler_e,
			     new List(uint_exp(n-1,DL),NULL), DL), DL);
}
void do_npop_before(int n, stmt_t s) { // mutates s as necessary!
  if(n > 0)
    s->r = seq_stmt_r(make_npop_handler(n),new_stmt(s->r,DL));
}

static void stmt_to_c(env_t nv, stmt_t s) {
  // written to be self-tail recursive
  while (true) {
    switch (s->r) {
    case &Skip_s:
      return;
    case &Exp_s(e):
      exp_to_c(nv, e);
      return;
    case &Seq_s(s1,s2):
      stmt_to_c(nv,s1);
      s = s2;
      continue;
    case &Return_s(eopt):
      type_opt_t topt = NULL;
      if (eopt != NULL) {
	topt = typ_to_c((type_t)eopt->topt);
	exp_to_c(nv,(exp_t)eopt);
      }
      // reset handler **after** evaluating expression
      if (s->try_depth > 0)
	if (topt != NULL) {
	  let x = temp_var();
	  let retn_stmt = return_stmt(var_exp(x,DL),DL);
	  s->r = declare_stmt(x,(type_t)topt, eopt,
			      seq_stmt(make_npop_handler(s->try_depth),
				       retn_stmt,DL),DL)->r;
	} else {
	  do_npop_before(s->try_depth,s);
	}
      return;
    case &IfThenElse_s(e,s1,s2):
      exp_to_c(nv,e);
      stmt_to_c(nv,s1);
      s = s2;
      continue;
    case &While_s($(e,_),s2):
      exp_to_c(nv,e);
      TOC_RGN(nv,temp) {
        stmt_to_c(loop_env(temp,nv),s2);
      }
      return;
    case &Break_s(dest_opt): // dest is NULL when break to end of void function
      let &Env{.break_lab=b,...} = nv;
      if (b != NULL)
	s->r = goto_stmt_r(*b,NULL);
      // reset handler
      int dest_depth = dest_opt == NULL ? 0 : dest_opt->try_depth;
      do_npop_before(s->try_depth - dest_depth, s);
      return;
    case &Continue_s(dest):
      let &Env{.continue_lab=c,...} = nv;
      if (c != NULL)
	s->r = goto_stmt_r(*c,NULL);
      fallthru(dest);
    case &Goto_s(_,dest):
      // reset handler (note: earlier checks prevent jump into handler)
      do_npop_before(s->try_depth - dest->try_depth, s);
      return;
    case &For_s(e1,$(e2,_),$(e3,_),s2):
      // FIX:  should e3 be translated in nv?
      exp_to_c(nv,e1); exp_to_c(nv,e2); exp_to_c(nv,e3);
      TOC_RGN(nv, temp) {
        stmt_to_c(loop_env(temp,nv),s2);
      }
      return;
    case &Switch_s(e,scs):
      xlate_switch(nv,s,e,scs);
      return;
    case &Fallthru_s(es,dest_clause):
      let &Env{.fallthru_info = fi,...} = nv;
      if(fi == NULL)
	toc_impos("fallthru in unexpected place");
      let FallthruInfo{l,vs,other_vmap} = *fi;
      stmt_t s2 = goto_stmt(l, DL);
      // reset handler (after the es evaluation)
      do_npop_before(s->try_depth - (*dest_clause)->body->try_depth, s2);
      let vs2 = List::rev(vs);
      let es2 = List::rev(es);
      for(; vs2 != NULL; vs2 = vs2->tl, es2 = es2->tl) {
	exp_to_c(nv,es2->hd);
	s2 = seq_stmt(assign_stmt(Dict::lookup(other_vmap,vs2->hd), es2->hd,DL),
		      s2,DL);
      }
      s->r = s2->r;
      return;
    case &Decl_s(d,s1):
      // we have to treat Let_d and Var_d where we bind a comprehension
      // (not at the top-level) specially because these have to return
      // "statements".  See letdecl_to_c and decls_to_c below.
      switch (d->r) {
      case &Var_d(vd):
        TOC_RGN(nv, temp) {
          let nv2 = add_varmap(temp,nv,vd->name,
                               varb_exp(vd->name,new Local_b(vd),DL));
          local_decl_to_c(nv2, nv2, vd, s1);
        }
	break;
      case &Let_d(p,_,e):
        // Handle the special case where the pattern is a variable just like
	// a variable declaration, except variable's scope does NOT include e
        switch (p->r) {
        case &Var_p(vd, &Pat{.r = &Wild_p, ...}):
	  qvar_t old_name = vd->name;
	  qvar_t new_name = temp_var();
	  vd->name = new_name;
          vd->initializer = e;
          d->r = new Var_d(vd);
          TOC_RGN(nv, temp) {
            let nv2 =
              add_varmap(temp,nv,old_name,
                         varb_exp(new_name,new Local_b(vd),DL));
            local_decl_to_c(nv2, nv, vd, s1);
          }
          break;
        default:
	  // we treat let declarations specially because they may need
	  // statements in addition to declarations, so we splice them in
	  // as a statement.  Other declarations only produce declarations.
	  s->r = letdecl_to_c(nv, p, (type_t)e->topt, e, s1)->r;
	  break;
        }
	break;
      case &Letv_d(vds):
        //let nv2 = nv;
        //for (; vds != NULL; vds = vds->tl) {
        //  let vd = vds->hd;
        //  let c_name = vd->name;
        //  vd->type = typ_to_c(vd->type);
        //  nv2 = add_varmap(nv2,c_name,varb_exp(c_name,new Local_b(vd),DL));
        //}
        //stmt_to_c(nv2,s1);

        // Transform Letv_d into a sequence of Var_d, and call stmt_to_c on
        // the result.
        let rvds = List::rev(vds);
        if (rvds == NULL)
          impos("empty Letv_d");
        d->r = new Var_d(rvds->hd);
        rvds = rvds->tl;
        for (; rvds != NULL; rvds = rvds->tl) {
          let d2 = new_decl(new Var_d(rvds->hd),DL);
          s->r = decl_stmt(d2,new_stmt(s->r,DL),DL)->r;
        }
        stmt_to_c(nv,s);
        break;
      case &Fn_d(fd):
        let c_name = fd->name;
        TOC_RGN(nv, temp) {
          let nv = add_varmap(temp,nv,fd->name,var_exp(c_name,DL));
          fndecl_to_c(nv, fd, false);
          stmt_to_c(nv,s1);
        }
        break;
      case &Region_d(tv, vd, resetable, open_exp_opt):
        let body = s1;
        // NOTE:  _npop_handler has to deal with regions as well as exceptions
        // { struct _RegionHandle rh = _new_region(); (or *open_exp_opt)
        //   struct _RegionHandle *x = &rh;
        //   _push_region(x);
        //   body;
        //   _pop_region(x);
        // }
        type_t rh_struct_typ     = strct(_RegionHandle_sp);
        type_t rh_struct_ptr_typ = cstar_typ(rh_struct_typ,mt_tq);
        qvar_t rh_var = temp_var();
        qvar_t x_var  = vd->name;
        exp_t  rh_exp = var_exp(rh_var,DL);
        exp_t  x_exp  = var_exp(x_var, DL);

        TOC_RGN(nv, temp) {
          stmt_to_c(add_varmap(temp,nv,x_var,x_exp),body);
        }
        if (no_regions) {
          s->r = declare_stmt(x_var, rh_struct_ptr_typ,
                              uint_exp(0,DL), body, DL)->r;
        } else if (open_exp_opt) { 
          exp_to_c(nv,open_exp_opt);
          exp_t arg = address_exp(aggrarrow_exp(open_exp_opt,new "h",DL),DL);
          s->r = declare_stmt(x_var,rh_struct_ptr_typ,arg,body,DL)->r;
        } else {
          s->r =
            declare_stmt(rh_var,rh_struct_typ,
                         fncall_exp(_new_region_e,
                                    new List(string_exp(qvar2string(x_var),DL),
                                             NULL),DL),
            declare_stmt(x_var, rh_struct_ptr_typ,address_exp(rh_exp,DL),
    	    seq_stmt(exp_stmt(fncall_exp(_push_region_e, list(x_exp), DL),DL),
            seq_stmt(body,
                     exp_stmt(fncall_exp(_pop_region_e,  list(x_exp), DL),DL),
                     DL),DL),DL),DL)->r;
        } 
        return;
      default: impos("bad nested declaration within function");
      }
      return;
    case &Label_s(lab,s1):
      s = s1; continue;
    case &Do_s(s2,$(e,_)):
      TOC_RGN(nv, temp) {
        stmt_to_c(loop_env(temp,nv),s2);
        exp_to_c(nv,e);
      }
      return;
    case &TryCatch_s(body,scs):
      // NOTE: Because explicit fallthru is not allowed in the last case,
      //       appending a new last case can't change the meaning of any
      //       control flow.
      // struct handler_cons h;
      // _push_handler(&h);
      // int was_thrown = 0;
      // if (setjmp(h.handler)) was_thrown = 1;
      // if (!was_thrown) {
      //   body
      //   _pop_handler();
      // } else {
      //   exn e = (exn)_exn_thrown;
      //   switch (e) scs
      // }
      // [Auxillary functions are defined in runtime_cyc.c]
      qvar_t h_var = temp_var();
      qvar_t e_var = temp_var();
      qvar_t was_thrown_var = temp_var();
      exp_t  h_exp = var_exp(h_var,DL);
      exp_t  e_exp = var_exp(e_var,DL);
      exp_t  was_thrown_exp = var_exp(was_thrown_var,DL);
      type_t h_typ = strct(_handler_cons_sp);
      type_t e_typ = typ_to_c(exn_typ());
      type_t was_thrown_typ = typ_to_c(sint_typ);
      // e_exp needs a typ because it'll go through exp_to_c;
      // as well, it must be in varmap
      e_exp->topt = e_typ;
      TOC_RGN(nv, temp) {
        let nv = add_varmap(temp,nv,e_var,e_exp);
        // translate the body
        stmt_to_c(nv,body);
        let tryandpop_stmt = seq_stmt(body,
                                      exp_stmt(fncall_exp(_pop_handler_e,
                                                          NULL,
                                                          DL), DL),DL);
        // add a default case which re-throws the exception
        let x    = temp_var();
        let xexp = var_exp(x,DL);
        let x_vd = new_vardecl(x,exn_typ(),NULL);
        xexp->topt = exn_typ();
        let p = new Pat{.r=new Var_p(x_vd,new Pat{.r=&Wild_p_val,.topt = exn_typ(), .loc = DL}), .topt=exn_typ(), .loc=DL};
        let te = rethrow_exp(xexp,DL);
        te->topt = &VoidType_val;
        let rs = exp_stmt(te,DL);
        let default_case =
          new Switch_clause{.pattern=p,.pat_vars=new Opt(new List(new $(new x_vd,xexp),NULL)),
                            .where_clause=NULL,.body=rs,.loc=DL};
        let handler_stmt = switch_stmt(e_exp,
                                       List::append(scs,
                                                    new List(default_case,NULL)),DL);
        // translate the switches
        stmt_to_c(nv,handler_stmt);

        // wrap with the conditional, declarations, and setjmp
        let setjmp_call = // setjmp(h.handler)
          fncall_exp(setjmp_e,
                     new List(member_exp(h_exp,handler_sp,DL), NULL),
                     DL);
        let pushhandler_call = // _pushhandler(h);
          exp_stmt(fncall_exp(_push_handler_e,
                              new List(address_exp(h_exp,DL), NULL),
                              DL),DL);
        let zero_exp = int_exp(Signed,0,DL);
        let one_exp = int_exp(Signed,1,DL);
        s->r =
          declare_stmt(h_var, h_typ, NULL,
          seq_stmt(pushhandler_call,
          declare_stmt(was_thrown_var,was_thrown_typ,zero_exp,
          seq_stmt(ifthenelse_stmt(setjmp_call,
                                   assign_stmt(was_thrown_exp,one_exp,DL),
                                   skip_stmt_dl(),DL),
          ifthenelse_stmt(prim1_exp(Not, was_thrown_exp,DL),
                          tryandpop_stmt,
                          declare_stmt(e_var,e_typ,
                                       cast_it(e_typ,_exn_thrown_e),
                          handler_stmt,DL),DL),DL),DL),DL),DL)->r;
      }
      return;
    case &ResetRegion_s(e):
      if (no_regions) {
        s->r = &Skip_s_val;
      } else {
        exp_to_c(nv,e);
        s->r = exp_stmt_r(fncall_exp(_reset_region_e,new List(e,NULL),DL));
      }
      return;
    }
  }
}

///////////////////////////////////////////////////////////////
//              Translation of Declarations                  //
///////////////////////////////////////////////////////////////
// function declaration translation -- straightforward
static void stmttypes_to_c(stmt_t s);
static void fndecl_to_c(env_t nv, fndecl_t f, bool cinclude) {
  f->tvs      = NULL;
  f->effect   = NULL;
  f->rgn_po   = NULL;
  f->requires_clause = NULL;
  f->ensures_clause  = NULL;
  f->ret_type = typ_to_c(f->ret_type);
  region frgn; {
    let nv = share_env(frgn,nv);
    for (let args=f->args; args != NULL; args = args->tl) {
      let x = new $((nmspace_t)Loc_n,(*args->hd)[0]);
      (*args->hd)[2] = typ_to_c((*args->hd)[2]);
      nv = add_varmap(frgn,nv,x,var_exp(x,DL));
    }
    // for C code, we need to go through and convert all of the types
    // from Cyclone types to C, but otherwise leave the code alone.
    if (cinclude) {
      stmttypes_to_c(f->body);
      return;
    }
    if (f->cyc_varargs && f->cyc_varargs->name != NULL) {
      let VarargInfo{n,tq,t,i} = *f->cyc_varargs;
      let t2 = typ_to_c(dyneither_typ(t,&HeapRgn_val,tq,false_conref));// region irrelevant
      let x2 = new $((nmspace_t)Loc_n,(var_t)n);
      f->args = List::append(f->args,new List(new $((var_t)n,tq,t2),NULL));
      nv = add_varmap(frgn,nv,x2,var_exp(x2,DL));
      f->cyc_varargs = NULL;
    }
    // Tovc would like to use param_vardecls:
    for(let arg_vds = f->param_vardecls->v; arg_vds!=NULL; arg_vds=arg_vds->tl) {
      arg_vds->hd->type = typ_to_c(arg_vds->hd->type);
    }
    stmt_to_c(clear_toplevel(frgn,nv),f->body);
  }
}

// there's no abstract scope in C
static scope_t scope_to_c(scope_t s) {
  switch (s) {
  case Abstract: return Public;
  case ExternC : return Extern;
  default:       return s;
  }
}

// struct & union declarations -- straightforward except when we have
// a tagged union.  When we have:
//   @tagged union Foo { T1 m1; ... Tn mn; };
// this is translated to:
//   struct _union_Foo_m1 { int tag; T1 val; };
//   ...
//   struct _union_Foo_mn { int tag; Tn val; };
//   union Foo { struct _union_Foo_m1 m1; ... struct _union_Foo_mn mn; };

static int aggrdecl_to_c_body<`r2,`d,`r>(region_t<`d> d, 
                              $(struct TocState<`d>@`d, 
                                $(aggrdecl_t ad, bool add_to_decls)@`r2)@`r env) {
  let $(s, &$(ad, add_to_decls)) = *env;
  let n = ad->name;
  let TocState{.aggrs_so_far = aggrs_so_far, ...} = *s;
  bool seen_defn_before;
  let dopt = Dict::lookup_opt(*aggrs_so_far, n);
  if (dopt == NULL) {
    seen_defn_before = false;
    $(aggrdecl_t,type_t)@ v;
    if (ad->kind == StructA)
      v = rnew(d) $(ad,strctq(n));
    else
      v = rnew(d) $(ad,unionq_typ(n));
    *aggrs_so_far = Dict::insert(*aggrs_so_far,n,v);
  } else {
    let &$(ad2,t) = *dopt;
    if (ad2->impl == NULL) {
      *aggrs_so_far = Dict::insert(*aggrs_so_far,n,rnew(d) $(ad,t));
      seen_defn_before = false;
    } else
      seen_defn_before = true;
  }
  aggrdecl_t new_ad = new Aggrdecl {.kind = ad->kind,
                                    .sc = Public,
                                    .name = ad->name,
                                    .tvs = NULL,
                                    .impl = NULL,
                                    .expected_mem_kind = false,
                                    .attributes = ad->attributes};
  if(ad->impl != NULL && !seen_defn_before) {
    new_ad->impl = new AggrdeclImpl { .exist_vars = NULL,
                                      .rgn_po = NULL,
                                      .fields = NULL,
                                      .tagged = false };
    list_t<aggrfield_t> new_fields = NULL;
    for (let fields = ad->impl->fields; fields != NULL; fields = fields->tl){
      // JGM: I'm trying to get rid of warnings when we assign "const"
      // locations...
      let old_field = fields->hd;
      let old_type = old_field->type;
      let old_atts = old_field->attributes;
      if (kind_leq(&ak,typ_kind(old_type)) && 
          ((ad->kind == StructA && fields->tl == NULL) ||
           ad->kind == UnionA)) {
        // HACK ALERT:
        // If the last member is abstract we have to do more work:
        //  * if it's an array, we make it an array of size 0
        //  * otherwise as a HACK, we make it an array of void*'s of size 0,
        //    but add the __attribute__((aligned)) to force the thing
        //    to live on a suitable boundary.  This means that any
        //    instantiation has to also be aligned, but it gives us a
        //    way to portably get at the field.
        switch (compress(old_type)) {
        case &ArrayType(ArrayInfo{et,tq,_,zt,ztl}):
          // Note: type checker forces et to be non-abstract
          old_type = new ArrayType(ArrayInfo(et,tq,uint_exp(0,DL),zt,ztl));
          break;
        default: 
          old_atts = new List(new Aligned_att(NULL),old_atts);
          old_type = new ArrayType(ArrayInfo(void_star_typ(),
                                             empty_tqual(DL),
                                             uint_exp(0,DL),
                                             new_conref(false),DL));
        }
      }
      let new_field = new Aggrfield{.name = old_field->name,
                                    .tq = mt_tq,
                                    .type = typ_to_c(old_type),
                                    .width = old_field->width,
                                    .attributes = old_atts,
                                    .requires_clause = NULL};

      // If this is a tagged union, rewrite the member type from T
      // to struct _union_Foo_f {int tag; T value;} where Foo is the name
      // of the union, and f is the name of the member.
      if (ad->impl->tagged) {
        let T = new_field->type;
        let f = new_field->name;
        string_t s = aprintf("_union_%s_%s",*((*ad->name)[1]),*f);
        var_t str = new s;
        let value_field = new Aggrfield(val_sp,mt_tq,T,NULL,NULL,NULL);
        let tag_field = new Aggrfield(tag_sp,mt_tq,sint_typ,NULL,NULL,NULL);
        let fs = list(tag_field,value_field);
        let ad2 = new Aggrdecl{.kind = StructA, .sc = Public,
                               .name = new $(Loc_n,str), .tvs = NULL,
                               .impl = new AggrdeclImpl(NULL,NULL,fs,false),
                               .expected_mem_kind = false,
                               .attributes = NULL};
        result_decls = new List(new_decl(new Aggr_d(ad2),DL),result_decls);
        new_field->type = strct(str);
      }
      new_fields = new List(new_field,new_fields);
    }
    new_ad->impl->fields = List::imp_rev(new_fields);
  }
  if (add_to_decls)
    result_decls = new List(new Decl(new Aggr_d(new_ad),DL),result_decls);
  return 0;
}

static void aggrdecl_to_c(aggrdecl_t ad, bool add_to_decls) {
  _ p = $(ad, add_to_decls);
  use_toc_state(&p, (aggrdecl_to_c_body@<`aggrdecl_to_c>)<>);
}

// datatype declarations -- tricky
// For "datatype foo {Bar,Blah,Baz(t1,t2,t3),Baf(t4,t5)}" we generate
//   typedef void *foo;
//   struct Baz_foo_struct {
//     int tag;  // always == 0
//     t1 f1;
//     t2 f2;
//     t3 f3;
//   };
//   struct Baf_foo_struct {
//     int tag;  // always == 1
//     t4 f1;
//     t5 f2;
//   };
// for xdatatype, we pull a really slimy trick: By using char arrays instead
// of ints, the uses get promoted to addresses just like we want.
// When the datatype is "extern" then we don't generate initializers
// for the tags (that should be done elsewhere.)
//
// NB: we allow any number of repeated declarations but we can only
//     declare and initialize global variables once.  So we keep track
//     of what we've seen so far.  And we make the globals static so that
//     extern and what not is only a link-checker thing.  Unfortunately,
//     the static trick doesn't work for xdatatype, which uses the addresses.
static int datatypedecl_to_c_body<`d,`r>(region_t<`d> d, 
                                         $(struct TocState<`d>@`d, 
                                           datatypedecl_t tud)@`r env) {
  let $(&TocState{.datatypes_so_far = datatypes_so_far, ...},tud) = *env;
  let n = tud->name;
  if(tud->fields == NULL || Set::member(*datatypes_so_far, n))
    return 0;
  *datatypes_so_far = Set::rinsert(d,*datatypes_so_far, n);
  for (let fields = tud->fields->v; fields != NULL; fields = fields->tl) {
    datatypefield_t f = fields->hd;
    // compute the fields for the struct, adding in a tag field
    let fs = NULL;
    int i  = 1;
    for (let ts = f->typs; ts != NULL; ts = ts->tl, i++) {
      let fname = fieldname(i);
      let f = new Aggrfield(fname,(*ts->hd)[0],
                            typ_to_c((*ts->hd)[1]),NULL,NULL,NULL);
      fs = new List(f,fs);
    }
    fs = new List(new Aggrfield(tag_sp,mt_tq,sint_typ,NULL,NULL,NULL),
                  List::imp_rev(fs));
    let ad =
      new Aggrdecl{.kind = StructA, .sc = Public,
                   .name = collapse_qvars(f->name,tud->name),
                   .tvs = NULL, .expected_mem_kind = false,
                   .impl = new AggrdeclImpl(NULL,NULL,fs,false),
                   .attributes = NULL};
    result_decls = new List(new_decl(new Aggr_d(ad),DL),result_decls);
  }
  return 0;
}

static void datatypedecl_to_c(datatypedecl_t tud) {
  use_toc_state(tud, datatypedecl_to_c_body<>);
}
// @extensible datatype declarations -- similar to datatype declarations
// For a declaration extending an existing xdatatype, e.g.,
//   "@extensible datatype foo {Bar,Baz(t1,t2)}"
// we generate
//   char Bar[] = "Bar";
//   struct Bar_foo_struct { char *tag; };
//   char Baz[] = "Baz";
//   struct Baz_foo_struct { char *tag; t1 f1; t2 f2; };
// When the xdatatype is extern, then we don't do initializers for the tags.
//
// Thus "Baz(e1,e2)" maps to
// ({struct _Baz_struct *t =
//     (struct _Baz_struct*)malloc(sizeof(struct _Baz_struct));
//   *t = (struct _Baz_struct){.tag=Baz, .f1 = e1, .f2 = e2};
//   t;})
//true if already seen & initialized, false if seen but non initialized (extern)
static int xdatatypedecl_to_c_body<`d,`r>(region_t<`d> d,
                                          $(struct TocState<`d>@`d,
                                            datatypedecl_t xd)@`r env) {
  let $(s,xd) = *env;
  if(xd->fields == NULL)
    return 0;
  let TocState{.xdatatypes_so_far = xdatatypes_so_far, ...} = *s;
  let n = xd->name;
  for (let fs = xd->fields->v; fs != NULL; fs = fs->tl) {
    datatypefield_t f  = fs->hd;
    stringptr_t fn = (*f->name)[1];
    let sz_exp  = uint_exp(numelts(*fn),DL);
    let tag_typ = array_typ(char_typ,mt_tq,sz_exp,false_conref,DL);
    // FIX: making bad alignment and pointer-size assumptions!
    switch (Dict::lookup_opt(*xdatatypes_so_far,f->name)) {
    case NULL:
      exp_opt_t initopt = NULL;
      if (f->sc != Extern) {
        initopt = string_exp(*fn,DL);
      }
      let tag_decl = new_vardecl(f->name, tag_typ, initopt);
      tag_decl->sc = f->sc;
      result_decls = new List(new_decl(new Var_d(tag_decl),DL),result_decls);
      *xdatatypes_so_far =
        Dict::insert(*xdatatypes_so_far, f->name, f->sc != Extern);
      list_t<aggrfield_t> fields = NULL;
      int i = 1;
      for (let tqts = f->typs; tqts != NULL; tqts = tqts->tl,i++) {
        let field_n = new ((string_t)aprintf("f%d",i));
        let newf = new Aggrfield(field_n,(*tqts->hd)[0],
                                 typ_to_c((*tqts->hd)[1]),NULL,NULL,NULL);
        fields = new List(newf,fields);
      }
      fields = new List(new Aggrfield(tag_sp,mt_tq,
                                      cstar_typ(char_typ,mt_tq),NULL,NULL,NULL),
                        List::imp_rev(fields));
      let strct_decl =
        new Aggrdecl{.kind = StructA, .sc = Public,
                     .name = collapse_qvars(f->name,xd->name),
                     .tvs  = NULL, .expected_mem_kind = false,
                     .impl = new AggrdeclImpl(NULL,NULL,fields,false),
                     .attributes = NULL};
      result_decls = new List(new_decl(new Aggr_d(strct_decl),DL),
                              result_decls);
      break;
    case &false:
      if (f->sc != Extern) {
        let initopt = string_exp(*fn,DL);
        let tag_decl = new_vardecl(f->name, tag_typ, initopt);
        tag_decl->sc = f->sc;
        result_decls = new List(new_decl(new Var_d(tag_decl),DL),result_decls);
        *xdatatypes_so_far = Dict::insert(*xdatatypes_so_far, f->name, true);
      }
      break;
    default: break;
    }
  }
  return 0;
}

static void xdatatypedecl_to_c(datatypedecl_t xd) {
  use_toc_state(xd, xdatatypedecl_to_c_body<>);
}


static void enumdecl_to_c(enumdecl_t ed) {
  ed->sc = Public; // gcc warns if we have Extern or Static on an enum
  if(ed->fields != NULL)
    enumfields_to_c(ed->fields->v);
}

// we've decided let x = e and t x = e have different rules on e's
// environment, so we make the caller pass us an environment.
static void local_decl_to_c(env_t body_nv,env_t init_nv,vardecl_t vd,stmt_t s) {
  type_t old_typ = vd->type;
  vd->type = typ_to_c(old_typ);
  // Fat pointers can't be declared with "register" scope
  if (vd->sc == Register && is_tagged_pointer_typ(old_typ))
    vd->sc = Public;
  stmt_to_c(body_nv,s);
  if(vd->initializer != NULL) {
    exp_t init = (exp_t)vd->initializer;
    switch(init->r) {
    case &Comprehension_e(vd2,e1,e2,zt):
      vd->initializer = NULL;
      s->r = init_comprehension(init_nv, old_typ, var_exp(vd->name, DL), vd2, e1, e2,
                                zt, new_stmt(s->r,DL), false)->r;
      break;
    default:
      if (vd->sc == Static) {
        // static declarations have to be treated as if they're toplevel
        // w.r.t. the translation.  NB: Any other generated declarations
	// will also be left at top-level??
        TOC_RGN(init_nv, temp) {
          let nv2 = set_toplevel(temp,init_nv);
          exp_to_c(nv2, init);
        }
      } else
        exp_to_c(init_nv, init);
      break;
    }
  } else {
    // must put in zero for zero-terminated arrays
    switch (compress(old_typ)) {
    case &ArrayType(ArrayInfo{et,_,num_elts_opt,zt,_}) && conref_def(false,zt):
      if (num_elts_opt == NULL)
        toc_impos("can't initialize zero-terminated array -- size unknown");
      exp_t num_elts = (exp_t)num_elts_opt;
      let lhs = subscript_exp(var_exp(vd->name,DL),
                              add_exp(num_elts,signed_int_exp(-1,DL),DL),
                              DL);
      let rhs = signed_int_exp(0,DL);
      s->r = seq_stmt_r(exp_stmt(assign_exp(lhs,rhs,DL),DL),
                        new_stmt(s->r,DL));
      break;
    default: break;
    }
  }
}

// let declarations -- tricky
// Unlike other declarations, lets need to execute statements and
// so return a statement.  (See stmt_to_c, case for Decl above.)
// We treat this similar to the compilation of a switch (see xlate_switch
// above) with one case, but where the failure throws Match_Exception
static stmt_t letdecl_to_c(env_t nv, pat_t p, type_t t, exp_t e, stmt_t s) {
  exp_to_c(nv,e);
  qvar_t x = temp_var();
  TOC_RGN(nv, prgn) {
    let fail = throw_match_stmt();
    let nv = share_env(prgn,nv);
    let $(nv,vars,test_stmt) =
      xlate_pat(nv, prgn, t, var_exp(x,DL), var_exp(x,DL), p,
		throw_match_stmt(),NULL);
    stmt_to_c(nv,s);
    s = declare_stmt(x,typ_to_c(t),e,seq_stmt(test_stmt,s,DL),DL);
    for (; vars != NULL; vars = vars->tl) {
      let &$(qv,t2) = vars->hd;
      s = declare_stmt(qv,t2,NULL,s,DL);
    }
  }
  return s;
}

// These next few functions clean up the types in C code, getting
// rid of stuff inserted by the parser (e.g., region evars).

static void exptypes_to_c(exp_t e) {
  switch (e->r) {
  case &Deref_e(e):          fallthru(e);
  case &AggrMember_e(e,...):   fallthru(e);
  case &AggrArrow_e(e,...):    fallthru(e);
  case &Address_e(e):        fallthru(e);
  case &Throw_e(e,_):        fallthru(e);
  case &NoInstantiate_e(e):  fallthru(e);
  case &Sizeofexp_e(e):      fallthru(e);
  case &Increment_e(e1,_):   exptypes_to_c(e1); break;
  case &Primop_e(_,es):      List::iter(exptypes_to_c,es); break;
  case &And_e(e1,e2):        fallthru(e1,e2);
  case &Or_e(e1,e2):         fallthru(e1,e2);
  case &SeqExp_e(e1,e2):     fallthru(e1,e2);
  case &Subscript_e(e1,e2):  fallthru(e1,e2);
  case &Swap_e(e1,e2):       fallthru(e1,e2);
  case &AssignOp_e(e1,_,e2): exptypes_to_c(e1); exptypes_to_c(e2); break;
  case &Conditional_e(e1,e2,e3):
    exptypes_to_c(e1); exptypes_to_c(e2); exptypes_to_c(e3); break;
  case &FnCall_e(e,es,...):    
    exptypes_to_c(e); List::iter(exptypes_to_c,es); break;
  case &Cast_e(*t,e,_,_): *t = typ_to_c(*t); exptypes_to_c(e); break;
  case &CompoundLit_e(&$(_,_,*t),dles):
    *t = typ_to_c(*t);
    fallthru(dles);
  case &UnresolvedMem_e(_,dles): fallthru(dles);
  case &Array_e(dles):
    for (; dles != NULL; dles = dles->tl) {
      let $(_,e) = *dles->hd;
      exptypes_to_c(e);
    }
    break;
  case &Offsetof_e(*t,_): fallthru(t);
  case &Sizeoftyp_e(*t):  *t = typ_to_c(*t); break;
  case &StmtExp_e(s): stmttypes_to_c(s); break;
  case &Malloc_e(*m):
    if (m->elt_type != NULL)
      m->elt_type = new (typ_to_c(*m->elt_type));
    exptypes_to_c(m->num_elts);
    break;
  case &Const_e(_):       fallthru;
  case &Var_e(_,_):       fallthru;
  case &Enum_e(_,_,_):    fallthru;
  case &Asm_e(...):       fallthru;
  case &AnonEnum_e(_,_,_):break;

  case &AnonStruct_e(_, _): fallthru;
  case &Datatype_e(_,_,_):    fallthru;
  case &Aggregate_e(_,_,_,_):  fallthru;
  case &Comprehension_e(_,_,_,_): fallthru;
  case &ComprehensionNoinit_e(...): fallthru;
  case &Tuple_e(_):         fallthru;
  case &Instantiate_e(_,_): fallthru;
  case &New_e(_,_):         fallthru;
  case &Valueof_e(_):       fallthru;
  case &Tagcheck_e(...):
    Tcutil::terr(e->loc,"Cyclone expression within C code");
    break;
  }
}

static void decltypes_to_c(decl_t d) {
  switch (d->r) {
  case &Var_d(vd):
    vd->type = typ_to_c(vd->type);
    if (vd->initializer != NULL) exptypes_to_c((exp_t)vd->initializer);
    break;
  case &Fn_d(fd):
    fd->ret_type = typ_to_c(fd->ret_type);
    for (let args=fd->args; args != NULL; args = args->tl) {
      (*args->hd)[2] = typ_to_c((*args->hd)[2]);
    }
    break;
  case &Aggr_d(ad): aggrdecl_to_c(ad,true); break;
  case &Enum_d(ed):
    if (ed->fields != NULL)
      for (let fs = ed->fields->v; fs != NULL; fs = fs->tl) {
        let f = fs->hd;
        if (f->tag != NULL) exptypes_to_c((exp_t)f->tag);
      }
    break;
  case &Typedef_d(td): td->defn = typ_to_c((type_t)td->defn); break;
  case &Let_d(_,_,_):
  case &Letv_d(_):
  case &Datatype_d(_):
  case &Namespace_d(_,_):
  case &Using_d(_,_):
  case &ExternC_d(_):
  case &ExternCinclude_d(_,_):
  case &Region_d(...):
//   case &Alias_d(...):
    Tcutil::terr(d->loc,"Cyclone declaration within C code");
    break;
  case &Porton_d:
  case &Portoff_d:
    break;
  }
}

static void stmttypes_to_c(stmt_t s) {
  switch (s->r) {
  case &Exp_s(e): exptypes_to_c(e); break;
  case &Seq_s(s1,s2): stmttypes_to_c(s1); stmttypes_to_c(s2); break;
  case &Return_s(eopt): if (eopt != NULL) exptypes_to_c((exp_t)eopt); break;
  case &IfThenElse_s(e,s1,s2):
    exptypes_to_c(e); stmttypes_to_c(s1); stmttypes_to_c(s2); break;
  case &While_s($(e,_),s):
    exptypes_to_c(e); stmttypes_to_c(s); break;
  case &For_s(e1,$(e2,_),$(e3,_),s):
    exptypes_to_c(e1); exptypes_to_c(e2); exptypes_to_c(e3);
    stmttypes_to_c(s); break;
  case &Switch_s(e,scs):
    exptypes_to_c(e);
    for (; scs != NULL; scs=scs->tl) stmttypes_to_c(scs->hd->body);
    break;
  case &Decl_s(d,s): decltypes_to_c(d); stmttypes_to_c(s); break;
  case &Do_s(s,$(e,_)): stmttypes_to_c(s); exptypes_to_c(e); break;
  case &Label_s(_,s): stmttypes_to_c(s); break;
  case &Skip_s:
  case &Break_s(_):
  case &Continue_s(_):
  case &Goto_s(_,_): 
    break;
  case &Fallthru_s(_,_): 
    // in C code, this is implicit, so we replace it with a skip
    s->r = new Skip_s;
    break;
  case &TryCatch_s(_,_):
  case &ResetRegion_s(_): 
    Tcutil::terr(s->loc,aprintf("Cyclone statement in C code: %s",stmt2string(s)));
    break;
  }
}

// Translate the given declarations, producing a new list of declarations
// and a new translation environment.  All source-level variables should
// be entered in the varmap of the env.  Note that top-level variable
// declarations are treated differently.
static env_t<`r> decls_to_c(region_t<`r> r, env_t<`r> nv, list_t<decl_t> ds, bool top, bool cinclude) {
  for (; ds != NULL; ds = ds->tl) {
    if (!is_toplevel(nv))
      impos("decls_to_c: not at toplevel!");
    decl_t d = ds->hd;
    switch (d->r) {
    case &Var_d(vd):
      let c_name = vd->name;
      // strip any namespace from an extern C declaration
      if (vd->sc == ExternC)
	c_name = new $(Rel_n(NULL),(*c_name)[1]);
      if (vd->initializer != NULL) {
        if (vd->sc == ExternC) vd->sc = Public;
        if (cinclude)
          exptypes_to_c((exp_t)vd->initializer);
        else
          exp_to_c(nv, (exp_t)vd->initializer);
      }
      nv = add_varmap(r,nv,vd->name,varb_exp(c_name,new Global_b(vd),DL));
      vd->name = c_name;
      vd->sc   = scope_to_c(vd->sc);
      vd->type = typ_to_c(vd->type);
      result_decls = new List(d,result_decls);
      break;
    case &Fn_d(fd):
      let c_name = fd->name;
      // strip any namespace from an extern C declaration
      if (fd->sc == ExternC) {
	c_name = new $(Abs_n(NULL,true),(*c_name)[1]);
        fd->sc = Public; // function declarations can't be extern
      }
      nv = add_varmap(r,nv,fd->name,var_exp(c_name,DL));
      fd->name = c_name;
      fndecl_to_c(nv, fd, cinclude);
      result_decls = new List(d,result_decls);
      break;
    case &Let_d(_,_,_):
    case &Letv_d(_):
      toc_impos("letdecl at toplevel");
    case &Region_d(...):
      toc_impos("region decl at toplevel");
//     case &Alias_d(...):
//       toc_impos("alias decl at toplevel");
    case &Aggr_d(sd):
      aggrdecl_to_c(sd,true);
      break;
    case &Datatype_d(tud):
      if(tud->is_extensible)
	xdatatypedecl_to_c(tud);
      else
	datatypedecl_to_c(tud);
      break;
    case &Enum_d(ed):
      enumdecl_to_c(ed);
      result_decls = new List(d,result_decls);
      break;
    case &Typedef_d(td):
      td->tvs  = NULL;
      if (td->defn != NULL)
        td->defn = typ_to_c((type_t)td->defn);
      else {
        switch (td->kind->v->kind) {
        case BoxKind: td->defn = void_star_typ(); break;
        default: td->defn = &VoidType_val; break;
        }
      }
      result_decls = new List(d,result_decls);
      break;
    case &Porton_d:
    case &Portoff_d:
      break;
    case &Namespace_d(_,ds2): fallthru(ds2);
    case &Using_d(_,ds2):     fallthru(ds2);
    case &ExternC_d(ds2): nv = decls_to_c(r,nv,ds2,top,cinclude); break;
    case &ExternCinclude_d(ds2,_): nv = decls_to_c(r,nv,ds2,top,true); break;
    }
  }
  return nv;
}

// initialize all globals
static void init() {
  let NewDynamicRegion{dyn} = new_rckey();
  let ts = open_region(dyn, 0, empty_toc_state);
  toc_state = unew TocStateWrap{dyn, ts};
  result_decls = NULL;
  tuple_type_counter = 0;
  temp_var_counter = 0;
  fresh_label_counter = 0;
  total_bounds_checks = 0;
  bounds_checks_eliminated = 0;
  globals = new {
    &_throw_str,
    &setjmp_str,
    &_push_handler_str,
    &_pop_handler_str,
    &_exn_thrown_str,
    &_npop_handler_str,
    &_check_null_str,
    &_check_known_subscript_null_str,
    &_check_known_subscript_notnull_str,
    &_check_dyneither_subscript_str,
    &_dyneither_ptr_str,
    &_tag_dyneither_str,
    &_init_dyneither_ptr_str,
    &_untag_dyneither_ptr_str,
    &_get_dyneither_size_str,
    &_get_zero_arr_size_str, // NOT SURE WHETHER WE NEED BOTH?
    &_dyneither_ptr_plus_str,
    &_zero_arr_plus_str,     // NOT SURE WHETHER WE NEED BOTH?
    &_dyneither_ptr_inplace_plus_str,
    &_zero_arr_inplace_plus_str, // NOT SURE WHETHER WE NEED BOTH?
    &_dyneither_ptr_inplace_plus_post_str,
    &_zero_arr_inplace_plus_post_str, // NOT SURE WHETHER WE NEED BOTH?
    &_cycalloc_str,
    &_cyccalloc_str,
    &_cycalloc_atomic_str,
    &_cyccalloc_atomic_str,
    &_region_malloc_str,
    &_region_calloc_str,
    &_check_times_str,
    &_new_region_str,
    &_push_region_str,
    &_pop_region_str,
    &_open_dynregion_str,
    &_push_dynregion_str,
    &_pop_dynregion_str,
    &_reset_region_str,
    &_throw_arraybounds_str,
    &_dyneither_ptr_decrease_size_str,
    &_throw_match_str,
    &_swap_word_str,
    &_swap_dyneither_str,
    &_fast_region_malloc_str,
  };
}

// reclaim space used by extensible array for the labels
static int destroy_labels(region_t<`d> d, struct TocState<`d>@`d ts) {
  let TocState{.temp_labels = tls, ...} = *ts;
  Xarray::reuse(tls);
  return 0;
}

// The entry point:  translate the list of Cyclone declarations to
// a list of C declarations.
list_t<decl_t> toc(list_t<decl_t> ds) {
  init();
  region start; {
    decls_to_c(start,empty_env(start),ds,true,false);
#ifdef BCE_DEBUG
    fprintf(stderr,"***eliminated %d out of %d bounds checks\n",
            bounds_checks_eliminated, total_bounds_checks);
#endif
    // free the state
    toc_state_t ts = NULL;
    ts :=: toc_state;
    let TocStateWrap{dyn, s} = *ts;
    open_region(dyn, s, destroy_labels);
    Core::free_rckey(dyn);
    Core::ufree(ts);
  }
  return imp_rev(result_decls);
}
