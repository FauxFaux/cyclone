// Toc.pop:  copyright (c) 2000, Greg Morrisett and Trevor Jim
//
// Translation of Cyclone abstract syntax to C abstract syntax.
// Assumes that the type-checker has been successfully run on
// the Cyclone AST.  Uses lots of GCC-specific features (that should
// be in C-9X) to simplify the translation -- in particular, we use
// struct expressions "(struct foo){.f1=e1,.f2=e2,...,.fn=en}" and
// statement expressions "({int temp = e;  temp++})".  The
// latter is crucial for declaring temps needed in the translation
// of expressions.  It would be nice to avoid these and be able
// to generate ANSI C (so we can at least use VC++).

// The translation is mostly done in place in an imperative style
// (i.e., we overwrite AST nodes) so it's fairly crucial that we
// don't have sharing in the AST.  The one exception is that the
// type translation is functional.

// We need to figure out how to do the name mangling systematically,
// especially for namespaces.

// Look for "unimp" or comments that start with FIX: for missing
// or broken pieces.

// FIX: we could probably use "const" in lots of places where we're not.

// Note: Do NOT use unresolvedmem_exp except at top-level or you will break
//  the Tocv module

// Note: we generate lots of struct and tunion types that don't have pointers
//       back to the corresponding decls.  The printer doesn't follow these
//       pointers, else we need to set them.

#include "core.h"
#include "stdio.h"
#include "list.h"
#include "string.h"
#include "set.h"
#include "dict.h"
#include "position.h"
#include "absyn.h"
#include "absynpp.h"
#include "tcutil.h"
#include "evexp.h"
#include "formatstr.h"
#include "toc.h"
using Core;
using Stdio;
using List;
using Set;
using Position;
using Absyn;
using Absynpp;
using Tcutil;

namespace Toc;

bool use_runtimecheck_funs = true;

// we aren't re-entrant -- we build this list of output decls (in
// reverse order)  It's global b/c tuple types, tagged pointer types, and
// strange top-level initializers need to "splice in" toplevel decls and
// it's a pain to pass this list around everywhere
static list_t<decl_t> result_decls = null;

// used for creation of all abstract syntax nodes here
#define DL null
// don't use these if you're going to mutate the result! 
// (We're avoiding useless mallocs)
tunion Nmspace.Abs_n abs_ns_value = Abs_n(null);
tunion Nmspace abs_ns = &abs_ns_value;
tqual_t mt_tq = Tqual(false,false,false);

// errors and reporting
xtunion exn {Toc_Unimplemented};
xtunion exn {Toc_Impossible};
static `a unimp(string s) {
  fprintf(stderr,"%s\n",s);
  fflush(stderr);
  throw Toc_Unimplemented;
}
static `a toc_impos(string s) {
  fprintf(stderr,"%s\n",s);
  fflush(stderr);
  throw Toc_Impossible;
}
xtunion exn {Match_error};

// some pre-allocated boxed strings -- use foo_sp for char ?* w/ contents "foo"
#define MAKE_STRING(str)\
  static string    str##_string = #str; \
  static stringptr str##_sp     = &str##_string

MAKE_STRING(curr);
MAKE_STRING(last_plus_one);
MAKE_STRING(base);
MAKE_STRING(_tagged_string);
MAKE_STRING(xtunion); // not used as a keyword
MAKE_STRING(tag);
MAKE_STRING(_handler_cons);
MAKE_STRING(_push_region);
MAKE_STRING(_pop_region);
MAKE_STRING(handler);
MAKE_STRING(Match_Exception);
MAKE_STRING(Cyc_new_string);
MAKE_STRING(Cyc_rnew_string);
MAKE_STRING(_RegionHandle);
MAKE_STRING(_new_region);

// some pre-allocated qvars -- use foo_qv for qvar_t w/ contents "foo" 
// (top-level namespace)
// FIX: Next step is to make the exp_t, not just the qvar_t
#define MAKE_QVAR(str)\
  static string                  str##_string = #str;\
  static $(nmspace_t, stringptr) str##_pr     = $((nmspace_t)&abs_ns_value,\
						  &str##_string);\
  static qvar_t                  str##_qv     = &str##_pr

MAKE_QVAR(_throw);
MAKE_QVAR(setjmp);
MAKE_QVAR(_push_handler);
MAKE_QVAR(_pop_handler);
MAKE_QVAR(_exn_thrown);
MAKE_QVAR(_npop_handler);
MAKE_QVAR(_check_null);
MAKE_QVAR(_check_unknown_subscript);
MAKE_QVAR(_check_known_subscript_null);
MAKE_QVAR(_check_known_subscript_notnull);
MAKE_QVAR(GC_malloc);
MAKE_QVAR(GC_malloc_atomic);
MAKE_QVAR(_region_malloc);

#undef MAKE_STRING
#undef MAKE_QVAR

// FIX:  should really allow evaluating expressions too
static bool is_zero(exp_t e) {
  switch (e->r) {
  case &Const_e(&Char_c(_,c)): return c == '\0';
  case &Const_e(&Short_c(_,i)): return i == 0;
  case &Const_e(&Int_c(_,i)): return i == 0;
  case &Const_e(&LongLong_c(_,i)): return i == 0;
  case &Const_e(Null_c): return true;
  case &Cast_e(_,e1): return is_zero(e1);
  case &Tuple_e(es): return List::forall(is_zero,es);
  case &Array_e(dles): fallthru(dles);
  case &Struct_e(_,_,dles,_): fallthru(dles);
  case &CompoundLit_e(_,dles): fallthru(dles);
  case &UnresolvedMem_e(_,dles):
    for (; dles != null; dles = dles->tl) 
      if (!is_zero((*dles->hd)[1])) return false;
    return true;
  default: return false;
  }
}

// return true if t is a nullable pointer type i.e., *
static bool is_nullable(type_t t) {
  switch (compress(t)) {
  case &PointerType(PtrInfo{_,_,b,_,_}):
    switch (compress_conref(b)->v) {
    case &Eq_constr(b2): return b2;
    default:            return false;
    }
  default: toc_impos("is_nullable"); return false;
  }
}

static qvar_t collapse_qvar_tag(qvar_t x,string tag) {
  return new $((*x)[0], new {String::strconcat(*((*x)[1]),tag)});
}

static void add_tuple_decl(var_t x, list_t<type_t> ts) {
  let fs = null;
  for (int i=1; ts != null; ts = ts->tl, i++)
    fs = new List(new Structfield(new {xprintf("f%d",i)},mt_tq,ts->hd,null,null),fs);
  fs = List::imp_rev(fs);
  let sd = new Structdecl{.sc = Public, .name = new Opt(new $(abs_ns,x)),
                       .tvs = null, .fields = new Opt(fs), .attributes = null};
  result_decls = new List(new_decl(new Struct_d(sd),DL),result_decls);
}

static void add_tagged_ptr_decl(var_t x, type_t t) {
  type_t tptr = star_typ(t,HeapRgn,empty_tqual());
  let f1 = new Structfield(curr_sp,mt_tq,tptr,null,null);
  let f2 = new Structfield(base_sp,mt_tq,tptr,null,null);
  let f3 = new Structfield(last_plus_one_sp,mt_tq,tptr,null,null);
  let fs = new List(f1,new List(f2,new List(f3,null)));
  let sd = new Structdecl{.sc = Public,
                          .name = new Opt(new $(abs_ns,x)),
                          .tvs = null,
                          .fields = new Opt((list_t<structfield_t>)fs),
                          .attributes = null};
  result_decls = new List(new_decl(new Struct_d(sd),DL),result_decls);
}

// used to generate struct definitions for tuple types
// we share the struct definitions where possible.  
// FIX: should use an efficient map data structure.
static list_t<$(var_t,list_t<type_t>)@> tuple_types = null;
static int tuple_type_counter = 0;
static var_t add_tuple_type(list_t<$(tqual_t,type_t)@> tqs0) {
  for (let tts = tuple_types; tts != null; tts = tts->tl) {
    let &$(x,ts) = tts->hd;
    bool okay = true;
    let  tqs  = tqs0;
    for (; tqs != null && ts != null; tqs = tqs->tl, ts = ts->tl)
      if (!unify((*tqs->hd)[1],ts->hd)) {
	okay = false;
	break;
      }
    if (!okay || tqs != null || ts != null)
      continue;
    return x;
  }
  stringptr x = new {xprintf("_tuple%d",tuple_type_counter++)};
  list_t<type_t> ts = List::map(snd_tqt,tqs0);
  add_tuple_decl(x,ts);
  tuple_types = new List(new $(x,ts),tuple_types);
  return x;
}

// used to generate struct definitions for tagged pointer types (e.g., t?)
// we share the struct definitions where possible.
// FIX should use an efficient map data structure.
static list_t<$(var_t,type_t)@> tagged_ptr_types = null;
static int tagged_ptr_counter = 0;
static type_t tagged_string_type_v = VoidType; // constant initializer (unused)
static type_t tagged_string_type() {
  if(tagged_string_type_v == VoidType)
    tagged_string_type_v = strct(_tagged_string_sp);
  return tagged_string_type_v;
}
static type_t add_tagged_ptr_type(type_t t,tqual_t tq) {
  // Handle char[?] specially, its C implementation is in cyc_include.h
  switch (t) {
  case &IntType(Unsigned,B1): return tagged_string_type();
  default: break; //skip
  }
  for(_ tts = tagged_ptr_types; tts != null; tts = tts->tl) {
    let &$(x,t2) = tts->hd;
    if (!unify(t,t2)) continue;
    return strct(x);
  }
  stringptr x = new {xprintf("_tagged_ptr%d",tagged_ptr_counter++)};
  add_tagged_ptr_decl(x,t);
  tagged_ptr_types = new List(new $(x,t),tagged_ptr_types);
  return strct(x);
}

// generate a temporary variable
// FIX: need to guarantee these can't conflict
static int temp_var_counter = 0;
qvar_t temp_var() {
  return new $(Loc_n,new {xprintf("_temp%d",temp_var_counter++)});
}

// generate a fresh label
// FIX: need to guarantee these can't conflict
static int fresh_label_counter = 0;
static var_t fresh_label() {
  return new {xprintf("_LL%d",temp_var_counter++)};
}

///////////////////////////////////////////////////////////////
//         Convert a Cyclone type to a C type                //
///////////////////////////////////////////////////////////////
static type_t typ_to_c(type_t t); // forward declaration
static $(opt_t<var_t>,tqual_t,type_t)@ arg_to_c($(opt_t<var_t>,tqual_t,type_t)@ a) {
  let $(x,y,z) = *a;
  return new $(x,y,typ_to_c(z));
}
static $(tqual_t,type_t)@ typ_to_c_f($(tqual_t,type_t)@ x) {
  let $(a,b) = *x;
  return new $(a,typ_to_c(b));
}
// Sometimes we translate arrays t[] and t[N] to t*, and sometimes
// we leave them alone.  We must leave them alone in the following
// circumstances:
// 1. as the argument of sizeof
// 2. in typedef
// 3. in declarations
// 4. as the element type of an array
// 5. as the type part of a C9X compound literal
// 6. as the type of a struct field
// We must change them to pointers in the following circumstances:
// 1. as the argument of cast
// We can do either in the following circumstances:
// 1. as the parameter of a function
// The function typ_to_c_array leaves them alone, while typ_to_c
// changes them to pointers.
static type_t typ_to_c_array(type_t t) {
  switch(t) {
  case &ArrayType(t2,tq,x): // FIX: do we handle tq correctly?
    return new ArrayType(typ_to_c_array(t2),tq,x);
  case &Evar(_,&Opt{.v=t2},_): return typ_to_c_array(t2);
  default:
    return typ_to_c(t);
  }
}
static type_t typ_to_c(type_t t); 

static structfield_t structfield_to_c(structfield_t f) {
  // FIX: should the width be translated?  shouldn't it already be a constant?
  return new Structfield{.name=f->name, .tq=f->tq, .type = typ_to_c(f->type),
                            .width=f->width, .attributes=f->attributes};
}

static type_t typ_to_c(type_t t) {
  switch (t) {
  case VoidType:               return t;
      // FIX:  Typically this happens with throw, and void seems to be
      // the right thing to return.  But, I'm not sure.
  case &Evar(_,null,_):        return VoidType;
  case &Evar(_,&Opt{.v=t2},_): return typ_to_c(t2);
    // type variables (`a) are mapped to void*
  case &VarType(_):            return void_star_typ();
  case &TunionType(TunionInfo{&KnownTunion(tud),_,_}): return void_star_typ();
  case &TunionType(_): throw impos("unresolved TunionType");
  case &TunionFieldType(TunionFieldInfo{&KnownTunionfield(tud,tuf),_}):
    // for tunion fields that carry no arguments, it's an unsigned int
    // for xtunion fields that carry no argument, it's a char *.
    // for fields that carry arguments, it's a struct _Field_struct;
    if (tuf->typs == null) 
      if(tud->is_xtunion)
	return star_typ(uchar_t,HeapRgn,mt_tq);
      else
	return uint_t;
    else return strctq(collapse_qvar_tag(tuf->name,"_struct"));
  case &TunionFieldType(_): throw impos("unresolved TunionFieldType");
  case &PointerType(PtrInfo{t2,_,_,tq,bnds}):
    // t2? maps to struct tagged_ptr_t2, where we define
    // struct tagged_ptr_t2 { t2 *curr; t2 *base; t2 *last_plus_one; }
    // t2* and t2@ map to t2*.  Regions are irrelevant.
    t2 = typ_to_c_array(t2);
    switch (compress_conref(bnds)->v) {
    case &Eq_constr(Unknown_b): return add_tagged_ptr_type(t2,tq);
    default: return star_typ(t2,HeapRgn,tq);
    }
  case &IntType(_,_): return t;
  case FloatType:    return t;
  case DoubleType:   return t;
  case &ArrayType(t2,tq,e):   return new ArrayType(typ_to_c_array(t2),tq,e);
  case &FnType(FnInfo{_,_,t2,args,vararg,atts}):
    // just drop the type arguments & effect and translate the nested types
    // FIX:  problem with higher-order functions?  Again C's rules are strange.
    // FIX:  I'm dropping attributes like noreturn and const because C
    // complains otherwise.
    let new_atts = null;
    for (; atts != null; atts = atts->tl) {
      switch (atts->hd) {
      case Cdecl_att   : fallthru;
      case Noreturn_att: fallthru;
      case Const_att   : continue;
      default: new_atts = new List(atts->hd,new_atts); break;
      }
    }
    return new FnType(FnInfo{null,null,typ_to_c(t2),
                               List::map(arg_to_c,args),vararg,new_atts});
  case &TupleType(tqs):
    // $(t1,...,tn) maps to struct tuple_type_n where we define
    // struct tuple_type_n { t1 f1; ...; tn fn; };
    tqs = List::map(typ_to_c_f,tqs);
    let n = add_tuple_type(tqs);
    return strct(n);
  // FIX: we may have to actually declare these things and use them
  // consistently to make GCC happy.
  case &AnonStructType(fs): 
    return new AnonStructType(List::map(structfield_to_c,fs));
  case &AnonUnionType(fs):
    return new AnonUnionType(List::map(structfield_to_c,fs));
  case &UnionType(tdnopt,_,_): 
    if (tdnopt == null) unimp("anonymous union");
    // just drop the type arguments and translate the nested types
    return unionq_typ((typedef_name_t)tdnopt);
  case &StructType(tdnopt,_,_):
    if (tdnopt == null) unimp("anonymous struct");
    // just drop the type arguments and translate the nested types
    return strctq((typedef_name_t)tdnopt);
  case &EnumType(tdn,_): return t;
  case &TypedefType(tdn,ts,topt):
    if (topt == null) return toc_impos("Toc::typ_to_c: unresolved TypedefType");
    // just drop the type arguments and translate the nested types
    return new TypedefType(tdn,null, new Opt(typ_to_c_array(topt->v)));
  case &RgnHandleType(t):
    return cstar_typ(strct(_RegionHandle_sp),mt_tq);
  case HeapRgn:
    return toc_impos("Toc::typ_to_c: type translation passed the heap region");
  case &AccessEff(_):
    return toc_impos("Toc::typ_to_c: type translation passed the access eff");
  case &JoinEff(_):
    return toc_impos("Toc::typ_to_c: type translation passed the join eff");

  }
}

static exp_t array_to_ptr_cast(type_t t,exp_t e,seg_t l) {
  switch (t) {
  case &ArrayType(t2,tq,_): return cast_exp(star_typ(t2,HeapRgn,tq),e,l);
  default:                  return cast_exp(t,e,l);
  }
}

// returns true when the type contains no pointers
static bool atomic_typ(type_t t) {
  switch (compress(t)) {
  case VoidType    : return true;
  case &VarType(_)  : return false;
  case &IntType(_,_): return true;
  case FloatType   : return true;
  case DoubleType  : return false;
  case &ArrayType(t,_,_): return atomic_typ(t);
  case &FnType(_) : return true;
  case &TupleType(tqs):
    for (; tqs != null; tqs = tqs->tl)
      if (!atomic_typ((*tqs->hd)[1])) return false;
    return true;
    // FIX: really should compute in terms of the instantiation
    // to be as aggressive as possible.
    // note even without this we'll allocate Position::seg_t with atomic.
  case &StructType(_,_,_): return false;
  case &TunionType(_):     return false;
  case &AnonStructType(fs): fallthru(fs);
  case &AnonUnionType(fs):
    for (; fs != null; fs = fs->tl)
      if (!atomic_typ(fs->hd->type)) return false;
    return true;
  case &TunionFieldType(TunionFieldInfo{&KnownTunionfield(tud,tuf),_}):
    return tuf->typs == null;
    // FIX: could make this true now since we only allow bits in unions,
    // but it would be an evil bug to track down if we had to deal with this.
  case &UnionType(_,_,_):  return false; 
  case &PointerType(_): return false;
  case &RgnHandleType(_): return false;
  default:
    toc_impos(xprintf("atomic_typ:  bad type %s",typ2string(t)));
    return false;
  }
}

static bool is_void_star(type_t t) {
  switch (compress(t)) {
  case &PointerType(PtrInfo{t2,_,_,_,_}):
    switch (compress(t2)) {
    case VoidType: return true;
    default:       return false;
    }
  default: return false;
  }
}

// returns true when field f of the struct/union t has type void*.
static bool is_poly_field(type_t t, field_name_t f) {
  switch (compress(t)) {
  case &AnonUnionType(fs): fallthru(fs);
  case &AnonStructType(fs):
    let field = lookup_field(fs,f);
    if (field == null) 
      toc_impos(xprintf("is_poly_field: bad field %s",*field->name));
    return is_void_star(field->type);
  case &StructType(tdn,_,&sd):
    if(tdn == null)
      toc_impos("StructType name not properly set");
    if (sd->fields == null)
      toc_impos(xprintf("is_poly_field:  struct %s missing fields",
			qvar2string((qvar_t)tdn)));
    let fields = sd->fields->v;
    for (; fields != null; fields = fields->tl) {
      if (String::zstrptrcmp(f,fields->hd->name) == 0)
	return is_void_star(fields->hd->type);
    }
    toc_impos(xprintf("is_poly_field:  struct %s has no %s field",
		      qvar2string((qvar_t)tdn),*f));
    return false;
  case &StructType(tdn,_,null):
    if(tdn == null)
      toc_impos("StructType name not properly set");
    toc_impos(xprintf("is_poly_field:  struct %s missing structdecl",
		      qvar2string((qvar_t)tdn)));
    return false;
  case &UnionType(tdn,_,&ud):
    if (tdn == null)
      toc_impos("UnionType name not properly set");
    if (ud->fields == null)
      toc_impos(xprintf("is_poly_field:  union %s missing fields",
			qvar2string((qvar_t)tdn)));
    let fields = ud->fields->v;
    for (; fields != null; fields = fields->tl) {
      if (String::zstrptrcmp(f,fields->hd->name) == 0)
	return is_void_star(fields->hd->type);
    }
    toc_impos(xprintf("is_poly_field:  union %s has no %s field",
		      qvar2string((qvar_t)tdn),*f));
    return false;
  case &UnionType(tdn,_,null):
    if(tdn == null)
      toc_impos("UnionType name not properly set");
    toc_impos(xprintf("is_poly_field:  union %s missing structdecl",
		      qvar2string((qvar_t)tdn)));
    return false;
  default:
    toc_impos(xprintf("is_poly_field:  bad type %s",typ2string(t)));
    return false;
  }
}

// returns true when e is projection of a field in a struct that has a 
// variable type before instantiation.  For instance, the field hd has
// type `a before instantiation in struct cons.
static bool is_poly_project(exp_t e) {
  switch (e->r) {
  case &StructMember_e(e1,f): return is_poly_field(e1->topt->v,f);
  case &StructArrow_e(e1,f):
    switch (compress(e1->topt->v)) {
    case &PointerType(PtrInfo{t,_,_,_,_}): return is_poly_field(t,f);
    default: 
      toc_impos(xprintf("is_poly_project:  bad type %s",
			typ2string(e1->topt->v)));
      return false;
    }
  default: return false;
  }
}

// possible pointer malloc
static exp_t malloc_ptr(exp_t s) {
  return fncall_exp(var_exp(GC_malloc_qv,DL),new List(s,null),DL);
}

// no pointers possible malloc
static exp_t malloc_atomic(exp_t s) {
  return fncall_exp(var_exp(GC_malloc_atomic_qv,DL),new List(s,null),DL);
}

// malloc something -- choose malloc routine according to the (Cyclone) type
static exp_t malloc_exp(type_t t,exp_t s) {
  if (atomic_typ(t))
    return malloc_atomic(s);
  return malloc_ptr(s);
}

// region malloc something
static exp_t rmalloc_exp(exp_t rgn, exp_t s) {
  return fncall_exp(var_exp(_region_malloc_qv,DL),
		    new List(rgn, new List(s, null)),DL);
}

///////////////////////////////////////////////////////////////
//       Conversions for Expressions between Types           //
///////////////////////////////////////////////////////////////
// This section implements the various casts from one Cyclone
// type to another (e.g., boxing, unboxing, tagging, etc.)
static tunion Conv {
  NullCheck(type_t);           // t* -> t@
  UntagPtr(type_t,exp_t,bool); // t? -> t*{e}  bool is whether result is nullable
  TagPtr(type_t,exp_t);        // t*{e} -> t?
};
typedef tunion Conv conv;

// Calculate the conversions needed to map t1 to t2 -- the conversions
// should be applied in reverse order.
//
// FIX:  should deal with conversions to/from arithmetic types and
// bools and enums.  Should also make sure this is synchronized with
// the type checker -- the right way to do this is to compute the
// conversions within the type checker itself.
static list_t<conv> conversion(type_t t1, type_t t2) {
  t1 = compress(t1);
  t2 = compress(t2);
  switch ($(t1,t2)) {
  case $(&PointerType(p1), &PointerType(p2)):
    let n1 = conref_val(p1.nullable);
    let n2 = conref_val(p2.nullable);
    let b1 = conref_val(p1.bounds);
    let b2 = conref_val(p2.bounds);
    list_t<conv> convs = null;
    switch ($(b1,b2)) {
    case $(&Upper_b(_), &Upper_b(_)): 
      if (n1 && !n2) convs = new List(new NullCheck(t2),convs); break;
    case $(Unknown_b, Unknown_b): break;
    case $(&Upper_b(e1), Unknown_b):
      convs = new List(new TagPtr(typ_to_c(t1),e1),convs); break;
    case $(Unknown_b, &Upper_b(e2)):
      convs = new List(new UntagPtr(typ_to_c(t1),e2,n2),convs); break;
    }
    return convs;
  default: return null;
  }
}

// throw an exception -- this is turned into a function call
static exp_t newthrow_exp(exp_t e) {
  return fncall_exp(var_exp(_throw_qv,DL),new List(e,null),DL);
}

// t* -> t@
static exp_t null_check_conv(bool toplevel, type_t t, exp_t e) {
  type_t new_typ = typ_to_c(t);
  if (toplevel)
    unimp("can't do null-check conversion at top-level");
  if(use_runtimecheck_funs) {
    // (t *)_check_null(e)
    return cast_exp(new_typ,fncall_exp(var_exp(_check_null_qv,DL),
				       new List(e,null),DL),DL);
  } else {
    // ({ t* x = e; if (x == 0) throw(Null); x })
    qvar_t x = temp_var();
    stmt_t s = ifthenelse_stmt(eq_exp(var_exp(x,DL),signed_int_exp(0,DL),DL),
			       exp_stmt(newthrow_exp(null_pointer_exn_exp(DL)),DL),
			       skip_stmt(DL),DL);
    s = seq_stmt(s,exp_stmt(var_exp(x,DL),DL),DL);
    return stmt_exp(declare_stmt(x,new_typ,e,s,DL),DL);
  }
}
// t*{sz} -> t?
static exp_t tag_ptr_conv(bool toplevel, type_t t, exp_t sz, exp_t e) {
  qvar_t a = temp_var();
  qvar_t b = temp_var();
  int szvalue = Evexp::eval_const_uint_exp(sz);
  type_t strt_typ;
  type_t elt_typ;
  switch (compress(t)) {
  case &PointerType(PtrInfo{elt,_,_,_,_}):
    // FIX:  what about tqual ??
    elt_typ  = elt;
    strt_typ = add_tagged_ptr_type(elt,mt_tq);
    break;
  default:
    return toc_impos("tag_ptr_conv: not a pointer");
  }
  if (toplevel) {
    // Note e must be either (a) a string or else (b) a [possibly cast] 
    // identifier that is an array.
    // For case a, we generate
    // t x[sz] = e;
    // (struct tagged_ptr) {x,x,x+sz};
    // For case b, we generate
    // (struct tagged_ptr) {e,e,e+sz};
    bool is_string = false;
    switch (e->r) {
    case &Const_e(&String_c(_)): is_string = true; break;
    default: break;
    }
    exp_t xexp;
    if (is_string) {
      qvar_t x = temp_var();
      type_t vd_typ = new ArrayType(elt_typ,mt_tq,sz);
      vardecl_t vd = static_vardecl(x,vd_typ,e);
      result_decls = new List(new_decl(new Var_d(vd),DL),result_decls);
      xexp = var_exp(x,DL);
    } else {
      xexp = e;
    }
    exp_t xplussz = add_exp(xexp,sz,DL);
    exp_t urm_exp = 
      unresolvedmem_exp(null,new List(new $(null,xexp),
				   new List(new $(null,xexp),
                                            new List(new $(null,xplussz),
                                                     null))),DL);
    return urm_exp;
  } else {
    // ({ elt_typ *a = e;
    //    strt_typ b;
    //    b.curr = a;
    //    b.base = a;
    //    b.last_plus_one = a+szvalue;
    //    b; })
    stmt_t s = exp_stmt(var_exp(b,DL),DL);
    s = seq_stmt(assign_stmt(structmember_exp(var_exp(b,DL),
					      last_plus_one_sp,DL),
			     add_exp(var_exp(a,DL),
				     signed_int_exp(szvalue,DL),DL),
			     DL),s,DL);
    s = seq_stmt(assign_stmt(structmember_exp(var_exp(b,DL),base_sp,
					      DL),var_exp(a,DL),DL),s,DL);
    s = seq_stmt(assign_stmt(structmember_exp(var_exp(b,DL),curr_sp,
					      DL),var_exp(a,DL),DL),s,DL);
    s = declare_stmt(b,strt_typ,null,s,DL);
    s = declare_stmt(a,cstar_typ(elt_typ,mt_tq),
		     cast_exp(t,e,DL),s,DL);
    return stmt_exp(s,DL);
  }
}

// t? -> t*{sz}
static exp_t untag_ptr_conv(bool toplevel,type_t t1,exp_t sz,bool nullable,exp_t e) {
  if (toplevel)
    unimp("can't coerce t? to t* or t@ at the top-level");
  // ({ t1 x = e;
  //    if ((x.curr != 0) && // omit this when !nullable
  //        (x.curr < x.base || x.curr + sz > x.last_plus_one)) throw(Null); 
  //    x.curr; 
  //  })
  qvar_t x = temp_var();
  int szvalue = Evexp::eval_const_uint_exp(sz);
  exp_t xcurr = structmember_exp(var_exp(x,DL),curr_sp,DL);
  stmt_t s = exp_stmt(xcurr,DL);
  exp_t e1 = add_exp(xcurr,signed_int_exp(szvalue,DL),DL);
  exp_t e2 = structmember_exp(var_exp(x,DL),last_plus_one_sp,DL);
  exp_t e3 = gt_exp(e1,e2,DL);
  exp_t e4 = or_exp(lt_exp(xcurr,structmember_exp(var_exp(x,DL),base_sp,DL),DL),
		  e3,DL);
  exp_t e5 = (!nullable) ? e4 : and_exp(neq_exp(xcurr,uint_exp(0,DL),DL),e4,DL);
  s = seq_stmt(ifthenelse_stmt(e5,
			       exp_stmt(newthrow_exp(null_pointer_exn_exp(DL))
					,DL),skip_stmt(DL),DL),s,DL);
  s = declare_stmt(x,t1,e,s,DL);
  return stmt_exp(s,DL);
}

// convert e (which has source type t1) to have source type t2
// assumes e has already been compiled.
static exp_t convert_exp(bool toplevel, type_t t1, type_t t2, exp_t e) {
  for(list_t<conv> cs = conversion(t1,t2); cs != null; cs = cs->tl) {
    switch (cs->hd) {
    case &NullCheck(t): e = null_check_conv(toplevel,t,e); break;
    case &TagPtr(t,sz): e = tag_ptr_conv(toplevel,t,sz,e); break;
    case &UntagPtr(tagged_ptr_typ,sz,nullable): 
      e = untag_ptr_conv(toplevel,tagged_ptr_typ,sz,nullable,e); break;
    }
  }
  return e;
}

///////////////////////////////////////////////////////////////
//              Translation Environments                     //
///////////////////////////////////////////////////////////////
// When break_lab is null, translate break to break.  Otherwise,
// translate break to goto of the given label.  Similarly for
// continue.  This is used in the translation of switches and
// exception handlers to get the right control-flow.
//
// The varmap is used to map source identifiers to certain expressions.
// This is primarily used in the pattern match compilation.
//
// Translation of fallthru(e1,...,en) is
// varmap'(qv1) = trans(e1); ... varmap'(qvn) = trans(en);
// goto fallthru_info->v[0]
// where the ith element of fallthru_info->v[1] is qvi
// and varmap' is fallthru_info->v[2]
// (We also have to pop handlers as explained above.)
//
// Note that the varmap has to take into account the shadow number
// from bindings -- hence the domain of the map is qvar*int.
static struct Env {
  opt_t<var_t> break_lab;
  opt_t<var_t> continue_lab;
  opt_t<$(var_t,list_t<qvar_t>,Dict::dict_t<qvar_t,exp_t>)@> fallthru_info;
  Dict::dict_t<qvar_t,exp_t> varmap;
  bool toplevel;
};
typedef struct Env @env_t;

// the empty environment
static env_t empty_env() {
  return new Env{.break_lab       = null,
                    .continue_lab    = null,
                    .fallthru_info   = null,
                    .varmap          = Dict::empty(qvar_cmp),
                    .toplevel        = true};
}
static env_t copy_env(env_t e) {
  return new Env{.break_lab       = e->break_lab,
                    .continue_lab    = e->continue_lab,
                    .fallthru_info   = e->fallthru_info,
                    .varmap          = e->varmap,
                    .toplevel        = e->toplevel};
}

static env_t clear_toplevel(env_t e) {
  env_t ans = copy_env(e);
  ans->toplevel = false;
  return ans;
}

// add x->y to variable map in environment
// The type allows y to be a general exp, but in practice it is always a var_exp
static env_t add_varmap(env_t e, qvar_t x, exp_t y) {
  switch ((*x)[0]) {
  case &Rel_n(_):
    throw new Impossible(xprintf("Toc::add_varmap on Rel_n: %s\n", qvar2string(x)));
  default: break;
  }
  env_t ans = copy_env(e);
  ans->varmap = Dict::insert(ans->varmap, x, y);
  return ans;
}

// env for loop body: break and continue labels are set to null,
// exception handler pop counters for break and continue are zeroed
static env_t loop_env(env_t e) {
  env_t ans = copy_env(e);
  ans->break_lab    = null;
  ans->continue_lab = null;
  return ans;
}

// env for a switch clause: give new label for break, and zero its pop counter
static env_t non_last_switchclause_env(env_t e, var_t break_l, var_t fallthru_l,
				     list_t<vardecl_t> fallthru_binders,
				     env_t next_case_env) {
  let fallthru_vars = null;
  for(; fallthru_binders != null; fallthru_binders = fallthru_binders->tl)
    fallthru_vars = new List(fallthru_binders->hd->name, fallthru_vars);
  fallthru_vars = List::imp_rev(fallthru_vars);
    
  env_t ans = copy_env(e);
  ans->break_lab       = new Opt(break_l);
  ans->fallthru_info   = new Opt(new $(fallthru_l,
                                       fallthru_vars,
                                       next_case_env->varmap));
  return ans;
}

static env_t last_switchclause_env(env_t e, var_t break_l) {
  env_t ans = copy_env(e);
  ans->break_lab     = new Opt(break_l);
  ans->fallthru_info = null; // not allowed in last case
  return ans;
}

// must have no pattern vars and type is int, char, or tunion of a type
// with no value constructors. (If it weren't for allowing fallthru
// anywhere, we wouldn't need the next_l.)
static env_t switch_as_switch_env(env_t e, var_t next_l) {
  env_t ans = copy_env(e);
  ans->break_lab       = null;
  ans->fallthru_info   = new Opt(new $(next_l,null,Dict::empty(qvar_cmp)));
  return ans;
}

// printf_to_c(p,aopt,args,typs)
// Translate printf functions to C;
//   p is printf, fprintf, or xprintf
//   aopt is &Opt(e) if p is fprintf and e is its first arg
//   args are the remaining args, already translated
//   typs are the types of the translated args
//
// Most of the work has been done in the typechecker, which inserted
// casts on all the args.  The only remaining thing to do is handle
// %s.  The typechecker casts the corresponding arg to char[?].
// The C printf expects a char *.  So, we extract that from the char[?].
// Furthermore, we have to make sure that the C printf does not
// look past the end of the char[?].  So, we transform %s into %.*s,
// and, if the char[?] arg is x, we turn it into x,size(x).
//
// A final twist: the argument might not be a variable, so we have to
// introduce temporaries.  E.g.,
//   printf("%d%s%d\n",g(x),f(e),y)
// becomes
//   ({ int t1 = g(x);
//      string t2 = f(e);
//      int t3 = y;
//      printf("%d%.*s%d\n",t1,t2->sz,t2->contents,t3);
//   })
static exp_t printf_to_c(primop_t p, opt_t<exp_t> aopt,
			 list_t<exp_t> args, list_t<type_t> typs) {
  // All errors are Impossible because they should have been caught by
  // the typechecker
  if (args == null)
    return toc_impos("expecting a literal format string");

  string fmt_str;
  // get out the literal format string
  switch (args->hd->r) {
  case &Const_e(&String_c(s)): fmt_str = s; break;
  default: return toc_impos("expecting a literal format string");
  }
  // Check for the usual case: no %s.
  int len = fmt_str.size;
  int i   = 0;
  for (i=0; i<len; i++)
    if (fmt_str[i] == '%') {
      i++;
      if (i<len && fmt_str[i] == 's') break;
    }
  // If no %s, don't bother to process the args
  if (i == len) {
    if (aopt != null) args = new List(aopt->v,args);
    return primop_exp(p,args,DL);
  }

  // Otherwise we have %s and must process the args

  args = args->tl; // strip off fmt string
  typs = typs->tl; // and its type

  list_t<int>   rev_fmt    = null; // reversed fmt to return
  list_t<exp_t> rev_result = null; // reversed args to return, minus fmt
  list_t<$(qvar_t,type_t,exp_t)@> rev_temps = null; // reversed temps to return

  for (i=0; i<len; i++) {
    char c = fmt_str[i];
    rev_fmt = new List(c,rev_fmt);
    if (c != '%') continue;
    let x = Formatstr::parse_conversionspecification(fmt_str,i+1);
    if (x == null) toc_impos("bad format string");
    let &$(flags,width,precision,lenmod,c2,j) = x->v;
    i = j-1; // Subtract 1 because for-loop ends with i++
    if (c2 != 's') {
      // No change in this portion of format string; just copy conversion spec
      rev_fmt =
        List::revappend(List::flatten(new List(flags,
                                            new List(width,
                                                  new List(precision,
                                                        new List(lenmod,null))))),
                        rev_fmt);
      rev_fmt = new List(c2,rev_fmt);
      // * width or precision consumes an argument
      switch (width) {
      case &List(x,null) && x=='*':
        let temp = temp_var();
        rev_temps  = new List(new $(temp,typs->hd,args->hd),rev_temps);
        rev_result = new List(var_exp(temp,DL),rev_result);
        args = args->tl;
        typs = typs->tl;
        break;
      default: break;
      }
      switch (precision) {
      case &List(x,&List(y,null)) && x=='.' && y=='*':
        let temp = temp_var();
        rev_temps  = new List(new $(temp,typs->hd,args->hd),rev_temps);
        rev_result = new List(var_exp(temp,DL),rev_result);
        args = args->tl;
        typs = typs->tl;
        break;
      default: break;
      }
      if (c2 != '%') { // all but %% consume an arg and typ
        if (args == null || typs == null)
            toc_impos(xprintf("missing arg to %s", Absynpp::prim2string(p)));
        let temp = temp_var();
        rev_temps  = new List(new $(temp,typs->hd,args->hd),rev_temps);
        rev_result = new List(var_exp(temp,DL),rev_result);
        args = args->tl;
        typs = typs->tl;
      }
    } else {
      // %s case.  Note, tcexp currently prohibits flags, width, precision,
      // and length modifiers for %s, so we don't handle them here;
      // we just insert size into format and args.
      rev_fmt = new List('.',rev_fmt);
      rev_fmt = new List('*',rev_fmt);
      rev_fmt = new List('s',rev_fmt);
      let temp = temp_var();
      rev_temps = new List(new $(temp,typs->hd,args->hd),rev_temps);
      let size_exp = 
	subtract_exp(structmember_exp(var_exp(temp,DL),
				      last_plus_one_sp,DL),
		     structmember_exp(var_exp(temp,DL),curr_sp,DL),
		     DL);
      let cstring_exp = structmember_exp(var_exp(temp,DL),curr_sp,DL);
      rev_result = new List(size_exp,rev_result);
      rev_result = new List(cstring_exp,rev_result);
      args = args->tl;
      typs = typs->tl;
    }
  }
  let es = new List(string_exp(String::implode(List::imp_rev(rev_fmt)),DL),
		    List::imp_rev(rev_result));
  if (aopt != null) es = new List(aopt->v,es);
  let e = primop_exp(p,es,DL);
  let s = exp_stmt(e,DL);
  for (; rev_temps != null; rev_temps = rev_temps->tl) {
    let &$(qv,t,e) = rev_temps->hd;
    s = declare_stmt(qv, t, e, s, DL);
  }
  return stmt_exp(s,DL);
}

///////////////////////////////////////////////////////////////
//              Translation of Expressions                   //
///////////////////////////////////////////////////////////////
// Should really break this into smaller functions and factor
// out common code
static type_t get_c_typ(exp_t e) {
  if (e->topt == null) toc_impos("Missing type in primop ");
  return typ_to_c(e->topt->v);
}
static type_t get_cyc_typ(exp_t e) {
  if (e->topt == null) toc_impos("Missing type in primop ");
  return e->topt->v;
}
static $(tqual_t, type_t)@ tup_to_c(exp_t e) {
  return new $(mt_tq, typ_to_c(e->topt->v));
}
static void exp_to_c(env_t nv, exp_t e); // forward declaration
static $(list_t<designator_t>,exp_t)@ add_designator(env_t nv, exp_t e) {
  exp_to_c(nv,e);
  return new{$(null,e)};
}

static exp_t make_struct(env_t nv, qvar_t x, type_t struct_typ, stmt_t s,
                         bool pointer, exp_opt_t rgnopt, bool is_atomic) {
  exp_opt_t eo;
  type_t       t;
  if (pointer) {
    t  = cstar_typ(struct_typ, mt_tq);
    let se = sizeoftyp_exp(struct_typ,DL);
    if (rgnopt == null)
      eo = cast_exp(t, is_atomic ? malloc_atomic(se) : malloc_ptr(se), DL);
    else {
      exp_t r = (exp_t)rgnopt;
      exp_to_c(nv, r);
      eo = cast_exp(t, rmalloc_exp(r,se), DL);
    }
  } else {
    t  = struct_typ;
    eo = null;
  }
  return stmt_exp(declare_stmt(x,t,eo,s,DL),DL);
}

static stmt_t init_comprehension(env_t nv, exp_t lhs, vardecl_t vd, 
                                 exp_t e1, exp_t e2, stmt_t s, 
                                 bool e1_already_translated);

static stmt_t init_anon_struct(env_t nv, exp_t lhs, type_t struct_type,
                               list_t<$(list_t<designator_t>,exp_t)@> dles,
                               stmt_t s);

// code to initialize an array
static stmt_t init_array(env_t nv, exp_t lhs, 
                         list_t<$(list_t<designator_t>,exp_t)@> dles0,
                         stmt_t s) {
  int count = List::length(dles0)-1;
  for (let dles = List::rev(dles0); dles != null; dles = dles->tl) {
    // add lhs[e_index] = e to sequence of assignments
    let &$(dl,e1) = dles->hd;
    // calculate the index expression -- the front end checks that
    // the designators are in ascending order...
    // FIX:  real designator lists
    exp_t e_index;
    if (dl == null)
      e_index = signed_int_exp(count--,DL);
    else {
      if (dl->tl != null) unimp("multiple designators in array");
      let d = dl->hd;
      switch (d) {
      case &ArrayElement(e3):
        exp_to_c(nv,e3);
        e_index = e3;
        break;
      case &FieldName(_):
        e_index = unimp("field name designators in array");
        break;
      }
    }
    exp_t lval = subscript_exp(lhs,e_index,DL);
    switch (e1->r) {
    case &Array_e(dles0):
      s = init_array(nv, lval, dles0, s);
      break;
    case &Comprehension_e(vd,g1,g2):
      s = init_comprehension(nv, lval, vd, g1, g2, s, false);
      break;
    case &AnonStruct_e(st,dles):
      s = init_anon_struct(nv, lval, st, dles, s);
      break;
    default:
      exp_to_c(nv,e1);
      s = seq_stmt(assign_stmt(subscript_exp(lhs,e_index,DL),e1,DL),s,DL);
      break;
    }
  }
  return s;
}

// code to initialize a comprehension
// WARNING: Changing the translation here will break Tovc.
static stmt_t init_comprehension(env_t nv, exp_t lhs, vardecl_t vd, 
                                 exp_t e1, exp_t e2, stmt_t s, 
                                 bool e1_already_translated) {
  let x1 = vd->name;
  if (!e1_already_translated)
    exp_to_c(nv,e1);
  env_t nv2 = add_varmap(nv,x1,varb_exp(x1,new Local_b(vd),DL));
  qvar_t max = temp_var();
  exp_t ea = assign_exp(var_exp(x1,DL),signed_int_exp(0,DL),DL);
  exp_t eb = lt_exp(var_exp(x1,DL),var_exp(max,DL),DL);
  exp_t ec = post_inc_exp(var_exp(x1,DL),DL);
  exp_t lval = subscript_exp(lhs,var_exp(x1,DL),DL);
  stmt_t body;
  // since we don't yet allow arrays or comprehensions within comprehensions
  // these two cases shouldn't arise -- but we ought to support this.
  switch (e2->r) {
  case &Array_e(dles):
    body = init_array(nv2, lval, dles, skip_stmt(DL));
    break;
  case &Comprehension_e(vd2,g1,g2):
    body = init_comprehension(nv2, lval, vd2, g1,g2, skip_stmt(DL), false);
    break;
  case &AnonStruct_e(st,dles):
    body = init_anon_struct(nv, lval, st, dles, skip_stmt(DL));
    break;
  default:
    exp_to_c(nv2,e2);
    body = assign_stmt(lval,e2,DL);
    break;
  }
  stmt_t s2 = for_stmt(ea,eb,ec,body,DL);
  // note that we get rid of the const on the index variable x1 here
  s = seq_stmt(declare_stmt(max,uint_t,e1,
                            declare_stmt(x1,uint_t,null,s2,DL),DL),s,DL);
  return s;
}

static stmt_t init_anon_struct(env_t nv, exp_t lhs, type_t struct_type,
                               list_t<$(list_t<designator_t>,exp_t)@> dles,
                               stmt_t s) {

  for(let es = List::rev(dles); es != null; es = es->tl) {
    let &$(ds,e) = es->hd;
    if(ds == null)
      toc_impos("empty designator list");
    if(ds->tl != null) 
      toc_impos("too many designators in anonymous struct");
    switch (ds->hd) {
    case &FieldName(f):
      exp_t lval = structmember_exp(lhs,f,DL);
      switch (e->r) {
      case &Array_e(dles):
        s = init_array(nv, lval, dles, s);
        break;
      case &Comprehension_e(vd,e1,e2):
        s = init_comprehension(nv, lval, vd, e1, e2, s, false);
        break;
      case &AnonStruct_e(st2,dles):
        s = init_anon_struct(nv, lval, st2, dles, s);
        break;
      default:
        exp_to_c(nv,e);
        // cast to void* if necessary
        if (is_poly_field(struct_type,f))
          e = cast_exp(void_star_typ(),e,DL);
        // FIX: deal with nested arrays and comprehensions
        s = seq_stmt(exp_stmt(assign_exp(lval, e, DL), DL), s, DL);
        break;
      }
      break;
    default: throw toc_impos("array designator in struct");
    }
  }
  return s;
}

// Would be nice to share more code with init_struct
// but the designators get in the way.
static exp_t init_tuple(env_t nv, bool pointer, 
                        exp_opt_t rgnopt, list_t<exp_t> es) {
  // $(e1,...,en)  -> ({ t x;   x.f1 = e1; ... x.fn = en; x})
  // &$(e1,...,en) -> ({ t * x=malloc(sizeof(t); x->f1 = e1; ... x->fn = en; x})
  let tqs = List::map(tup_to_c,es);
  let n   = add_tuple_type(tqs);

  let x    = temp_var();
  let xexp = var_exp(x,DL);
  let s    = exp_stmt(xexp,DL);

  let lval_f = pointer ? structarrow_exp : structmember_exp;

  bool is_atomic = true;
  es = List::rev(es);
  for (int i = length(es); es != null; es = es->tl, --i) {
    exp_t e = es->hd;
    exp_t lval = lval_f(xexp, new {xprintf("f%d",i)}, DL);
    is_atomic = is_atomic && atomic_typ(e->topt->v);
    switch (e->r) {
    case &Array_e(dles):
      s = init_array(nv, lval, dles, s);
      break;
    case &Comprehension_e(vd,e1,e2):
      s = init_comprehension(nv, lval, vd, e1, e2, s, false);
      break;
    // FIX: deal with comprehensions
    default:
      exp_to_c(nv,e);
      s = seq_stmt(exp_stmt(assign_exp(lval_f(xexp,new {xprintf("f%d",i)},
                                              DL),e, DL), DL), s, DL);
      break;
    }
  }
  return make_struct(nv,x,strct(n),s,pointer,rgnopt,is_atomic);
}

static exp_t init_struct(env_t nv, type_t struct_type,
                         bool pointer, exp_opt_t rgnopt, 
                         list_t<$(list_t<designator_t>,exp_t)@> dles, 
                         typedef_name_t tdn) {
  let x    = temp_var();
  let xexp = var_exp(x,DL);
  let s    = exp_stmt(xexp,DL);

  let lval_f = pointer ? structarrow_exp : structmember_exp;

  bool is_atomic = true;

  for(let es = List::rev(dles); es != null; es = es->tl) {
    let &$(ds,e) = es->hd;
    is_atomic = is_atomic && atomic_typ(e->topt->v);
    if(ds == null)
      toc_impos("empty designator list");
    if(ds->tl != null) {
      // untested
      // JGM: I don't understand this code
      let y    = temp_var();
      let yexp = var_exp(y,DL);
      for(; ds != null; ds = ds->tl)
	switch (ds->hd) {
	case &FieldName(f):
          // cast to void* if necessary
          if (is_poly_field(struct_type,f))
            yexp = cast_exp(void_star_typ(),yexp,DL);
          s = seq_stmt(exp_stmt(assign_exp(lval_f(xexp,f,DL), yexp, DL), DL),
                       s, DL);
	  break;
	default: throw toc_impos("array designator in struct");
	}
      // FIX:  need to deal with nested arrays, comprehensions, etc.
      exp_to_c(nv,e);
      s = seq_stmt(exp_stmt(assign_exp(yexp, e, DL), DL), s, DL);
    } else{
      switch (ds->hd) {
      case &FieldName(f):
        exp_t lval = lval_f(xexp,f,DL);
        switch (e->r) {
        case &Array_e(dles):
          s = init_array(nv, lval, dles, s);
          break;
        case &Comprehension_e(vd,e1,e2):
          s = init_comprehension(nv, lval, vd, e1, e2, s, false);
          break;
        case &AnonStruct_e(st,dles):
          s = init_anon_struct(nv, lval, st, dles, s);
          break;
        default:
          exp_to_c(nv,e);
          // cast to void* if necessary
          if (is_poly_field(struct_type,f))
            e = cast_exp(void_star_typ(),e,DL);
          // FIX: deal with nested arrays and comprehensions
          s = seq_stmt(exp_stmt(assign_exp(lval, e, DL), DL), s, DL);
          break;
        }
        break;
      default: throw toc_impos("array designator in struct");
      }
    }
  }
  return make_struct(nv, x, strctq(tdn), s, pointer, rgnopt, is_atomic);
}



// functions for passing to lvalue_assign (see below)
static exp_t assignop_lvalue(exp_t el, $(opt_t<primop_t>,exp_t)@ pr) {
  return assignop_exp(el,(*pr)[0],(*pr)[1],DL);
}
static exp_t address_lvalue(exp_t e1, bool ignore) {
  return address_exp(e1,DL);
}
static exp_t incr_lvalue(exp_t e1, incrementor_t incr) {
  return new_exp(new Increment_e(e1,incr),DL);
}

static void lvalue_assign_stmt(stmt_t s,list_t<field_name_t> fs,
			       exp_t f(exp_t,`a), `a f_env);
// e1 is the result of translating an lvalue.  fs is the path of struct
// fields that we're assigning to on e1 (if any).  The translation
//  may have inserted null checks, etc., but buried within e1 is an lvalue.
// We find the underlying lvalue, call it el.
// We replace el in e1 with f(el,env)
// We assume that variables in f(el,env) will not be captured by any
static void lvalue_assign(exp_t e1, list_t<field_name_t> fs, 
			  exp_t f(exp_t,`a), `a f_env){
  switch (e1->r) {
  case &StmtExp_e(s): lvalue_assign_stmt(s,fs,f,f_env); break;
  case &Cast_e(t,e):  lvalue_assign(e,fs,f,f_env); break;
  case &StructMember_e(e,fld):
    // Hack: strip off the struct member -- the base case adds it back in.
    e1->r = e->r;
    lvalue_assign(e1,new List(fld,fs),f,f_env);
    break;
  default:
    // Sanity check: the translation of lvalues may change,
    // so we may need to adjust how we find the inner lvalue.
    if (!is_lvalue(e1))
      toc_impos(xprintf("lvalue_assign: could not find lvalue in `%s'",
			exp2string(e1)));
    // make a copy so we don't create a loop
    exp_t e1_copy = copy_exp(e1);
    // add the path back on to the expression
    for (; fs != null; fs = fs->tl)
      e1_copy = structmember_exp(e1_copy,fs->hd,e1_copy->loc);
    e1->r = f(e1_copy, f_env)->r;
    break;
  }
}
static void lvalue_assign_stmt(stmt_t s,list_t<field_name_t> fs, 
			       exp_t f(exp_t,`a), `a f_env) {
  switch (s->r) {
  case &Exp_s(e1):    lvalue_assign(e1,fs,f,f_env);      break;
    // we assume free vars of e2 are not captured by d
  case &Decl_s(d,s2): lvalue_assign_stmt(s2,fs,f,f_env); break;
  case &Seq_s(_,s2):  lvalue_assign_stmt(s2,fs,f,f_env); break;
  default: toc_impos(xprintf("lvalue_assign_stmt: %s",stmt2string(s))); break;
  }
}

static void stmt_to_c(env_t nv, stmt_t s); // forward declaration

static void exp_to_c(env_t nv, exp_t e) {
  let r = e->r;
  if(e->topt == null) {
    toc_impos(xprintf("exp_to_c: no type for %s",exp2string(e)));
    return;
  }
  type_t old_typ = e->topt->v;
  switch (r) {
  case &Const_e(Null_c):
    switch (compress(old_typ)) {
    case &PointerType(PtrInfo{elt,_,_,_,b}):
      
      if(b->v == No_constr) { // eg. int z = null;
	// null -> 0  -- this is okay according to C's rules!
	e->r = signed_int_exp(0,DL)->r;
	break;
      }
      switch (conref_val(b)) {
      case Unknown_b:
	let zero = new $(null,signed_int_exp(0,DL));
	let um = unresolvedmem_exp(null,
                                   new List(zero,new List(zero,
                                                          new List(zero,
                                                                   null))),DL);
	if (nv->toplevel) {
	  e->r = um->r;
	} else {
	  // null -> ({ struct tagged_ptr x = {0,0,0}; x })
	  let t = add_tagged_ptr_type(typ_to_c(elt),mt_tq);
	  let x = temp_var();
	  let xexp = var_exp(x,DL);
	  let s = declare_stmt(x,t,um,exp_stmt(xexp,DL),DL);
	  e->r = stmt_exp(s,DL)->r;
	}
	break;
      case &Upper_b(_): 
	// null -> 0  -- this is okay according to C's rules!
	e->r = signed_int_exp(0,DL)->r; 
	break;
      }
      break;
    default: toc_impos(xprintf("exp_to_c: null given type %s",
			       typ2string(old_typ)));
      break;
    }
    break;
  case &Const_e(_): break;
  case &Var_e(qv,b): 
    try e->r = Dict::lookup(nv->varmap,qv)->r;
    catch {
    case Dict::Absent:
       toc_impos(xprintf("Can't find %s in exp_to_c, Var\n", qvar2string(qv)));
       return;
    }
    break;
  case &UnknownId_e(qv): toc_impos("unknownid"); break;
  case &Primop_e(p,es):
    // Save Cyclone types -- needed for pointer arith stuff
    let old_typs = List::map(get_cyc_typ,es);
    // Save C types of args, needed for printf
    let typs = List::map(get_c_typ,es);
    // Translate args
    List::iter_c(exp_to_c,nv,es);
    // FIX:  look at these carefully and make sure this is okay
    switch (p) {
    case Size:
      exp_t arg = es->hd;
      switch (arg->topt->v) {
      case &ArrayType(_,_,e2): e->r = e2->r;  break;
      case &PointerType(PtrInfo{elt_typ,_,_,_,_}):
	// ({struct elt_typ_array temp = arg;
	//   ((unsigned int)(temp.last_plus_one - temp.curr);
	//  })
	let temp = temp_var();
	let temp_typ = typ_to_c(arg->topt->v);
	exp_t e2 = structmember_exp(var_exp(temp,DL),last_plus_one_sp,DL);
	exp_t e3 = structmember_exp(var_exp(temp,DL),curr_sp,DL);
	exp_t e4 = cast_exp(uint_t,subtract_exp(e2,e3,DL),DL);
	stmt_t result = exp_stmt(e4,DL);
	e->r = stmt_exp(declare_stmt(temp,temp_typ,arg,result,DL),DL)->r;
	break;
      default: 
	toc_impos(xprintf("size primop applied to non-array %s (%s)",
			  typ2string(typs->hd),typ2string(arg->topt->v))); 
	return;
      }
      break;
    case Printf:  e->r = printf_to_c(p,null,es,typs)->r; break;
    case Xprintf: e->r = printf_to_c(p,null,es,typs)->r; break;
    case Fprintf:
      if (es == null) toc_impos("fprintf without arguments");
      e->r = printf_to_c(p,new Opt(es->hd),es->tl,typs->tl)->r;
      break;
    case Sscanf:
      // INSECURE -- but useful for debugging.
      // The problem is that we can't guarantee that the input string
      // is null terminated -- sscanf could start reading past the end
      // of the string.  This could lead to a security breach.
      // Any sscanf expression should be rejected by the typechecker;
      // sometimes we disable this to help debug fscanf and scanf.
      if (es == null) toc_impos("sscanf without arguments");
      es->hd->r = structmember_exp(new_exp(es->hd->r,es->hd->loc),
				   curr_sp, DL)->r;
      break;
    case Plus:
      // Need to deal with pointer arithmetic
      // FIX: at top-level, we allow ((t ?)x)+1 where x is an array and
      // this should be translated appropriately..
      if (is_tagged_pointer_typ(old_typ)) {
	exp_t e1 = es->hd;
	exp_t e2 = es->tl->hd;
        // ({ struct tagged_ptr temp = e1;
        //    temp.curr += e2; temp; })
        let temp = temp_var();
        let temp_typ = typ_to_c(old_typ);
        let s = exp_stmt(var_exp(temp,DL),DL);
        let e3 = structmember_exp(var_exp(temp,DL),curr_sp,DL);
        let e4 = assignop_exp(e3,new Opt(Plus),e2,DL);
        s = seq_stmt(exp_stmt(e4,DL),s,DL);
        s = declare_stmt(temp,temp_typ,e1,s,DL);
        e->r = stmt_exp(s,DL)->r;
      }
      break;
    case Minus:
      if (is_tagged_pointer_typ(old_typs->hd)) {
        exp_t e1 = es->hd;
        exp_t e2 = es->tl->hd;
	type_t old_typ_e2 = old_typs->tl->hd; // cyclone type of e2
        // if they're both pointers, then just generate
        // e1.curr - e2.curr because the result is supposed to be an
        // unsigned int (really size_t).
	if (is_tagged_pointer_typ(old_typ_e2)) {
          e1->r = structmember_exp(new_exp(e1->r,DL),curr_sp,DL)->r;
	  e2->r = structmember_exp(new_exp(e2->r,DL),curr_sp,DL)->r;
        } else {
        // if e1 is a pointer but e2 is not, then generate:
	// ({ struct tagged_ptr temp = e1;
	//    temp.curr -= e2; temp; })  
	let temp = temp_var();
	let temp_typ = typ_to_c(old_typs->hd);
	let s = exp_stmt(var_exp(temp,DL),DL);
	let e3 = structmember_exp(var_exp(temp,DL),curr_sp,DL);
	let e4 = assignop_exp(e3,new Opt(Minus),e2,DL);
	s = seq_stmt(exp_stmt(e4,DL),s,DL);
	s = declare_stmt(temp,temp_typ,e1,s,DL);
	e->r = stmt_exp(s,DL)->r;
        }
      }
      break;
    case Eq : fallthru;
    case Neq: fallthru;
    case Gt : fallthru;
    case Gte: fallthru;
    case Lt : fallthru;
    case Lte: 
      // need to extract .curr field of tagged arrays for comparisons
      exp_t e1 = es->hd;
      exp_t e2 = es->tl->hd;
      type_t t1 = old_typs->hd;
      type_t t2 = old_typs->tl->hd;
      if (is_tagged_pointer_typ(t1))
	e1->r = structmember_exp(new_exp(e1->r,DL),curr_sp,DL)->r;
      if (is_tagged_pointer_typ(t2))
	e2->r = structmember_exp(new_exp(e2->r,DL),curr_sp,DL)->r;
      break;
    default: break; //skip
    }
    break;
  case &Increment_e(e2,incr):
    type_t e2_cyc_typ = e2->topt->v;
    exp_to_c(nv,e2);
    if (is_tagged_pointer_typ(e2_cyc_typ)) {
      if (incr == (incrementor_t)PreInc || incr == (incrementor_t)PreDec) {
        // When we have a pre-increment or decrement:
        // ({ struct tagged_ptr *temp = &e2;
        //    ++temp->curr; 
        //    *temp
        // })
        let temp = temp_var();
        let temp_typ = star_typ(typ_to_c(e2_cyc_typ),HeapRgn,empty_tqual());
        let s = exp_stmt(deref_exp(var_exp(temp,DL),DL),DL);
        let e3 = increment_exp(structarrow_exp(var_exp(temp,DL),curr_sp,DL),
                               incr,DL);
        s = seq_stmt(exp_stmt(e3,DL),s,DL);
        s = declare_stmt(temp,temp_typ,address_exp(e2,DL),s,DL);
        e->r = stmt_exp(s,DL)->r;
      } else {
        // When we have a post-increment or decrement:
        // ({ struct tagged_ptr *temp = &e2;
        //    struct tagged_ptr temp2 = *e2;
        //    temp->curr++;
        //    temp2;
        // })
        let temp = temp_var();
        let temp2 = temp_var();
        let temp2_typ = typ_to_c(e2_cyc_typ);
        let temp_typ = star_typ(typ_to_c(e2_cyc_typ),HeapRgn,empty_tqual());
        let s = exp_stmt(var_exp(temp2,DL),DL);
        let e3 = increment_exp(structarrow_exp(var_exp(temp,DL),curr_sp,DL),
                               incr,DL);
        s = seq_stmt(exp_stmt(e3,DL),s,DL);
        s = declare_stmt(temp2,temp2_typ,deref_exp(var_exp(temp,DL),DL),s,DL);
        s = declare_stmt(temp,temp_typ,address_exp(e2,DL),s,DL);
        e->r = stmt_exp(s,DL)->r;
      }
    } else if(!is_lvalue(e2)) {
      lvalue_assign(e2,null,incr_lvalue,incr);
      e->r = e2->r;
    }
    break;
  case &AssignOp_e(e1,popt,e2):
    // FIX:  tagged array types
    // See if e1 is a polymorphic field (i.e., is an instantiated type
    // variable) -- if so, coerce e2 to void*.
    bool e1_poly    = is_poly_project(e1);
    type_t  e1_old_typ = e1->topt->v;
    type_t  e2_old_typ = e2->topt->v;
    exp_to_c(nv,e1); 
    exp_to_c(nv,e2);
    if (popt != null && (popt->v == (primop_t)Plus || 
                         popt->v == (primop_t)Minus)) {
      // We could have e1+=e2 where e1 is a tagged array or
      // we could have e1-=e2 where e1 is a tagged array and e2 is either
      // an int or a tagged array
      if (is_tagged_pointer_typ(e1_old_typ))
	e1->r = structmember_exp(new_exp(e1->r,DL),curr_sp,DL)->r;
      if (is_tagged_pointer_typ(e2_old_typ))
    	e2->r = structmember_exp(new_exp(e2->r,DL),curr_sp,DL)->r;
    }
    // this cast is necessary to avoid gcc warnings
    if (e1_poly) 
      e2->r = cast_exp(void_star_typ(), new_exp(e2->r, DL), DL)->r;
    // The typechecker guarantees that e1 starts out as an lvalue, but
    // the translation might have to insert casts, null checks,
    // declarations of temps, bound checks, etc.  If so we look into e1,
    // find the lvalue, and put the assignment there.
    if (!is_lvalue(e1)) {
      lvalue_assign(e1,null,assignop_lvalue,new{$(popt,e2)});
      e->r = e1->r;
    }
    break;
  case &Conditional_e(e1,e2,e3):
    exp_to_c(nv,e1);
    exp_to_c(nv,e2);
    exp_to_c(nv,e3);
    break;
  case &SeqExp_e(e1,e2):
    exp_to_c(nv,e1);
    exp_to_c(nv,e2);
    break;
  case &UnknownCall_e(e1,es): fallthru(e1,es);
  case &FnCall_e(e1,es):
    exp_to_c(nv,e1);
    List::iter_c(exp_to_c,nv,es);
    break;
  case &Throw_e(e1):
    // throw e -> (t)(throw(e)), the latter being a function call to throw
    exp_to_c(nv,e1);
    e->r = array_to_ptr_cast(typ_to_c(old_typ),newthrow_exp(e1),DL)->r;
    break;
  case &NoInstantiate_e(e1): exp_to_c(nv,e1); break;
  case &Instantiate_e(e1,ts):
    exp_to_c(nv,e1);
    type_t t_inst = typ_to_c(e->topt->v);
    // only cast when the instantiation has type variables,
    // you can cast other times, but you'll spit out much more C code.
    for(; ts != null; ts = ts->tl) {
      kind_t k = typ_kind(ts->hd);
      if(k != (kind_t)EffKind && k != (kind_t)RgnKind) {
	e->r = array_to_ptr_cast(t_inst,e1,DL)->r;
	break;
      }
    }
    break;
  case &Cast_e(*t,*e1):
    type_t old_t2  = (*e1)->topt->v;
    type_t new_typ = *t;
    *t = typ_to_c(new_typ);
    exp_to_c(nv, *e1);
    *e1 = convert_exp(nv->toplevel, old_t2, new_typ, *e1);
    break;
  case &Address_e(e1):
    // When e1 is a struct or a tuple, this is really a "new".
    switch (e1->r) {
    case &Struct_e(tdn,_,es,_):
      if (nv->toplevel)
	unimp(xprintf("%s: & on non-identifiers at the top-level",
                      Position::string_of_segment(e1->loc)));
      e->r = init_struct(nv, e1->topt->v, true, null, es, tdn)->r;
      break;
    case &Tuple_e(es):
      if (nv->toplevel)
	unimp(xprintf("%s: & on non-identifiers at the top-level",
                      Position::string_of_segment(e1->loc)));
      e->r = init_tuple(nv, true, null, es)->r;
      break;
    default: // it's actually an address-of.
      exp_to_c(nv,e1);
      if(!is_lvalue(e1)) {
	lvalue_assign(e1,null,address_lvalue,true);
	// the wrong cast got pushed out, so as a kludge, just re-cast
	e->r = cast_exp(typ_to_c(e->topt->v),e1,DL)->r;
      }
      break;
    }
    break;
  case &New_e(rgnopt,e1):
    if (nv->toplevel)
      unimp(xprintf("%s: new at top-level", 
                    Position::string_of_segment(e1->loc)));
    switch (e1->r) {
    case &Array_e(dles0):
      // FIX: MAY BE SUSCEPTIBLE TO GCC BUG!
      // ({ t *x = (t*)(malloc(sizeof(t)*length(dles0)));
      //    x[d1] = e1; ... x[dn] = en; x; })
      let x = temp_var();
      let xexp = var_exp(x,DL);
      let s = init_array(nv, xexp, dles0, exp_stmt(xexp,DL));
      type_t old_elt_typ;
      switch (compress(old_typ)) {
      case &PointerType(PtrInfo{et,_,_,tq,_}):
	old_elt_typ = et; break;
      default:
	old_elt_typ =
          toc_impos("exp_to_c:new array expression doesn't have ptr type");
        break;
      }
      type_t elt_typ=typ_to_c(old_elt_typ);
      let ptr_typ = cstar_typ(elt_typ,mt_tq);
      let e2 = times_exp(sizeoftyp_exp(elt_typ,DL),
                         signed_int_exp(List::length(dles0),DL),DL);
      exp_t e1;
      if (rgnopt == null) {
        e1 = malloc_exp(old_elt_typ,e2);
      } else {
        exp_t r = (exp_t)rgnopt;
        exp_to_c(nv,r);
        e1 = rmalloc_exp(r,e2);
      }
      let e0 = cast_exp(ptr_typ,e1,DL);
      e->r = stmt_exp(declare_stmt(x,ptr_typ,e0,s,DL),DL)->r;
      break;
    case &Const_e(&String_c(s)):
      // Cyc_new_string(s) or Cyc_rnew_string(r,s)
      if (rgnopt == null) 
        e->r = fncall_exp(var_exp(new $(abs_ns,Cyc_new_string_sp),DL),
                          new List(new_exp(new Const_e(new String_c(s)),DL),
                                   null),DL)->r;
      else {
        exp_t r = (exp_t)rgnopt;
        exp_to_c(nv,r);
        e->r = fncall_exp(var_exp(new $(abs_ns,Cyc_rnew_string_sp),DL),
                          new List(new_exp(new Const_e(new String_c(s)),DL),
                                   null),DL)->r;
      }
      break;
    case &Comprehension_e(vd,e1,e2):
      // Drop the "tagged_ptr_t" struct stuff when type is a fixed-size array
      // ({ unsigned int max = e1;
      //    t *a = (t*)malloc(sizeof(t)*max);
      //    struct tagged_ptr_t b = {a, a, a+max};
      //    unsigned int x ;
      //    for (x = 0; x < max; x++) a[x] = e2;
      //    b; })
      bool is_tagged_ptr = false;
      switch (compress(old_typ)) {
      case &PointerType(PtrInfo{et,_,_,tq,b}):
        switch (compress_conref(b)->v) {
        case &Eq_constr(Unknown_b): is_tagged_ptr = true; break;
        default: break;
        }
        break;
      default:
        toc_impos("exp_to_c: comprehension not an array type");
        break;
      }
      qvar_t max = temp_var();
      qvar_t a = temp_var();
      type_t old_elt_typ = e2->topt->v;
      type_t elt_typ = typ_to_c(old_elt_typ);
      type_t ptr_typ = cstar_typ(elt_typ,mt_tq);
      exp_to_c(nv,e1);
      stmt_t s = init_comprehension(nv, var_exp(a,DL), vd, var_exp(max,DL), 
                                    e2, skip_stmt(DL), true);
      // FIX:  casts needed on exp_opts
      list_t<$(qvar_t,type_t,exp_opt_t)@> decls = 
        new List(new $(max,uint_t,(exp_opt_t)e1),null);
      exp_t ai;
      if (rgnopt == null)
        ai = malloc_exp(old_elt_typ,times_exp(sizeoftyp_exp(elt_typ,DL),
                                              var_exp(max,DL),DL));
      else {
        exp_t r = (exp_t)rgnopt;
        exp_to_c(nv,r);
        ai = rmalloc_exp(r,times_exp(sizeoftyp_exp(elt_typ,DL),
                                     var_exp(max,DL),DL));
      }
      exp_t ainit = cast_exp(ptr_typ,ai,DL);
      decls = new List(new $(a,ptr_typ,(exp_opt_t)ainit),decls);
      if (is_tagged_ptr) {
        let b = temp_var();
        let t = typ_to_c(old_typ);
        let binit = 
          unresolvedmem_exp(null,
                            new List{new $(null,var_exp(a,DL)),
			    new List{new $(null,var_exp(a,DL)),
			    new List{new $(null,add_exp(var_exp(a,DL),
							var_exp(max,DL),
							DL)),
				     null}}},DL);
        decls = new List(new $(b,t,(exp_opt_t)binit),decls);
        s = seq_stmt(s,exp_stmt(var_exp(b,DL),DL),DL);
      } else // not a tagged array -- just return a
        s = seq_stmt(s,exp_stmt(var_exp(a,DL),DL),DL);
      for (let ds = decls; ds != null; ds = ds->tl) {
        let $(d0,d1,d2) = *(ds->hd);
        s = declare_stmt(d0,d1,d2,s,DL);
      }
      e->r = stmt_exp(s,DL)->r;
      break;
    case &Struct_e(tdn,_,es,_):
      // try to avoid the GCC bug
      e->r = init_struct(nv, e1->topt->v, true, rgnopt, es, tdn)->r;
      break;
    case &Tuple_e(es):
      // try to avoid the GCC bug
      e->r = init_tuple(nv, true, rgnopt, es)->r;
      break;
    default:
      // treated just like an array of size 1
      // FIX: MAY BE SUSCEPTIBLE TO GCC BUG!
      // ({ t *x = (t*)(malloc(sizeof(t)));
      //    x[0] = e1; x; })
      let old_elt_typ = e1->topt->v;
      let x = temp_var();
      let s = exp_stmt(var_exp(x,DL),DL);
      let e_index = signed_int_exp(0,DL);
      exp_to_c(nv,e1);
      s = seq_stmt(assign_stmt(subscript_exp(var_exp(x,DL),e_index,DL),
                               e1,DL),s,DL);
      type_t elt_typ=typ_to_c(old_elt_typ);
      let ptr_typ = cstar_typ(elt_typ,mt_tq);
      let e2 = sizeoftyp_exp(elt_typ,DL);
      exp_t e1;
      if (rgnopt == null) 
        e1 = malloc_exp(old_elt_typ,e2);
      else {
        exp_t r = (exp_t)rgnopt;
        exp_to_c(nv,r);
        e1 = rmalloc_exp(r,e2);
      }
      let e0 = cast_exp(ptr_typ,e1,DL);
      e->r = stmt_exp(declare_stmt(x,ptr_typ,e0,s,DL),DL)->r;
      break;
    }
    break;
  case &Sizeoftyp_e(t): e->r = new Sizeoftyp_e(typ_to_c_array(t)); break;
  case &Sizeofexp_e(e1): exp_to_c(nv,e1); break;
  case &Deref_e(e1):
    type_t e1_typ = compress(e1->topt->v);
    exp_to_c(nv, e1);
    switch (e1_typ) {
    case &PointerType(PtrInfo{t2,rgn,cr,tq,b}):
      switch (conref_val(b)) {
      case Unknown_b:
	// ({ tagged_ptr x = e1;
	//    t2 *a = x.curr;
        //    if (x.base == 0 || a < x.base || a >= x.last_plus_one) 
        //      throw(ArrayIndex);
        //    *a; })
	qvar_t x = temp_var();
	qvar_t a = temp_var();
	let ta1 = typ_to_c_array(t2);
	type_t tx  = add_tagged_ptr_type(ta1,tq);
	type_t ta2 = cstar_typ(ta1,tq);
	exp_t test_exp = 
          or_exp(eq_exp(structmember_exp(var_exp(x,DL),base_sp,DL),
                        signed_int_exp(0,DL),DL),
	  or_exp(lt_exp(var_exp(a,DL),
			structmember_exp(var_exp(x,DL),base_sp,DL),DL),
		 gte_exp(var_exp(a,DL),
			 structmember_exp(var_exp(x,DL),last_plus_one_sp,DL),
			 DL),DL),DL);
	exp_t a_init = structmember_exp(var_exp(x,DL),curr_sp,DL);
	// FIX:  should throw array out of bounds exception
	stmt_t s5 = exp_stmt(deref_exp(var_exp(a,DL),DL),DL);
	stmt_t s4 = exp_stmt(newthrow_exp(null_pointer_exn_exp(DL)),DL);
	stmt_t s3 = ifthenelse_stmt(test_exp,s4,skip_stmt(DL),DL);
	stmt_t s2 = seq_stmt(s3,s5,DL);
	stmt_t s1 = declare_stmt(a,ta2,a_init,s2,DL);
	e->r = stmt_exp(declare_stmt(x,tx,e1,s1,DL),DL)->r;
        break;
      case &Upper_b(_):
	if (is_nullable(e1_typ)) {
	  if(use_runtimecheck_funs) {
	    // *((t *)_check_null(e))
	    e->r = deref_exp(cast_exp(typ_to_c(e1->topt->v),
				      fncall_exp(var_exp(_check_null_qv,DL),
						 new List(e1,null),DL),DL),
			     DL)->r;
	  } else {
	  // ({t x=e1; if (x == null) throw(NullPointer); *x;})
	  qvar_t x  = temp_var();
	  exp_t  e2 = eq_exp(var_exp(x,DL),signed_int_exp(0,DL),DL);
	  exp_t  e3 = newthrow_exp(null_pointer_exn_exp(DL));
	  stmt_t s1 = ifthenelse_stmt(e2,exp_stmt(e3,DL),skip_stmt(DL),DL);
	  stmt_t s2 = exp_stmt(deref_exp(var_exp(x,DL),DL),DL);
	  stmt_t s3 = seq_stmt(s1,s2,DL);
	  e->r = stmt_exp(declare_stmt(x,e1_typ,e1,s3,DL),DL)->r;
	  }
	}
	break;
      }
      break;
    default: toc_impos("exp_to_c: Deref: non-pointer"); break;
    }
    break;
  case &StructMember_e(e1,f):
    exp_to_c(nv, e1);
    if(is_poly_project(e))
      e->r = array_to_ptr_cast(typ_to_c(e->topt->v),new_exp(e->r,DL),DL)->r;
    break;
  case &StructArrow_e(e1,f):
    exp_to_c(nv, e1);
    bool is_poly = is_poly_project(e); // decide before mutating e
    if (is_nullable(e1->topt->v)) {
      if(use_runtimecheck_funs) {
	// ((t *)_check_null(e))->f
	e->r = structarrow_exp(cast_exp(typ_to_c(e1->topt->v),
					fncall_exp(var_exp(_check_null_qv,DL),
						   new List(e1,null),DL),DL),
			       f, DL)->r;
      } else {
	// {(t x=e1; if (x == null) throw(NullPointer); x->f;)}
	qvar_t x  = temp_var();
	type_t tx = typ_to_c(e1->topt->v);
	exp_t  e2 = eq_exp(var_exp(x,DL),signed_int_exp(0,DL),DL);
	exp_t  e3 = newthrow_exp(null_pointer_exn_exp(DL));
	stmt_t s1 = ifthenelse_stmt(e2,exp_stmt(e3,DL),skip_stmt(DL),DL);
	stmt_t s2 = exp_stmt(structarrow_exp(var_exp(x,DL),f,DL),DL);
	stmt_t s3 = seq_stmt(s1,s2,DL);
	e->r = stmt_exp(declare_stmt(x,tx,e1,s3,DL),DL)->r;
      }
    }
    if(is_poly)
      e->r = array_to_ptr_cast(typ_to_c(e->topt->v),new_exp(e->r,DL),DL)->r;
    break;
  case &Subscript_e(e1,e2):
    let e1_typ = compress(e1->topt->v);
    exp_to_c(nv, e1);
    exp_to_c(nv, e2);
    // e1 could be a tuple or an array of various sorts
    switch (e1_typ) {
    case &TupleType(ts):
      // e1->fi  where i = e2+1
      unsigned int i = Evexp::eval_const_uint_exp(e2)+1;
      e->r = structmember_exp(e1,new xprintf("f%d",i),DL)->r;
      break;
    case &PointerType(PtrInfo{ta,rgn,bcr,tq,b}):
      switch (conref_val(b)) {
      case &Upper_b(esz):
	// FIX: should avoid bounds-check when e2 is constant
	esz = uint_exp(Evexp::eval_const_uint_exp(esz),DL);
        bool possibly_null;
        switch (compress_conref(bcr)->v) {
        case &Eq_constr(b): possibly_null = b;     break;
        default:            possibly_null = false; break;
        }
	type_t ta1 = typ_to_c(ta);
	type_t ta2 = cstar_typ(ta1, tq);
	if(use_runtimecheck_funs) {
	  if(possibly_null) {
	    // *((ta2)_check_known_subscript_null(e1, esz, sizeof(ta), e2)
	    e->r = deref_exp(cast_exp(ta2,
		      fncall_exp(var_exp(_check_known_subscript_null_qv,DL),
				 new List(e1, 
				 new List(esz, 
				 new List(sizeoftyp_exp(ta1,DL), 
				 new List(e2, null)))), DL),DL), DL)->r;
	  } else {
	    // e1[_check_known_subscript_notnull(esz,e2)]
	    e2->r = fncall_exp(var_exp(_check_known_subscript_notnull_qv,DL),
			       new List(esz, new List(copy_exp(e2), null)), 
			       DL)->r;
	  }
	} else {
	  //({elt_typ *a=arr; uint i=ind; if (i >= sz) throw(ArrayIndex); a[i]})
	  // but if possibly_null replace test with (a == null || i >= sz)
	  // and if take_address is true, end with &a[i]
	  qvar_t a = temp_var();
	  qvar_t i = temp_var();
	  exp_t e3 = prim2_exp(Gte, var_exp(i,DL), esz, DL);
	  if (possibly_null)
	    e3 = or_exp(eq_exp(var_exp(a,DL), signed_int_exp(0,DL),DL),
			new_exp(e3->r,DL),DL);
	  // FIX:  should throw array out of bounds exception
	  exp_t  e4 = newthrow_exp(null_pointer_exn_exp(DL));
	  stmt_t s5 = exp_stmt(e4,DL);
	  stmt_t s4 = ifthenelse_stmt(e3,s5,skip_stmt(DL),DL);
	  exp_t  e5 = subscript_exp(var_exp(a,DL),var_exp(i,DL),DL);
	  stmt_t s6 = exp_stmt(e5,DL);
	  stmt_t s3 = seq_stmt(s4,s6,DL);
	  stmt_t s1 = declare_stmt(i,uint_t,e2,s3,DL);
	  e->r = stmt_exp(declare_stmt(a,ta2,e1,s1,DL),DL)->r;
	}
	break;
      case Unknown_b:
	type_t ta1 = typ_to_c_array(ta);
	type_t ta2 = cstar_typ(ta1,tq);
	if(use_runtimecheck_funs) {
	  // *(_check_unknown_subscript(e1, sizeof(ta), e2))
	  // where _check_unknown_subscript has been cast to take a tagged
	  // pointer of the correct type and return ta2
	  // NOTE: could avoid more allocation here
	  // NOTE: we could eagerly evalute the sizeof(ta) if Evexp::szof were
	  //   right.  Also, I was getting a an unset structdecl pointer
	  //   (presumably because some type was translated to C too early?)
	  let argtyps = 
	    new List(new $(null,mt_tq,typ_to_c(e1->topt->v)),
            new List(new $(null,mt_tq,uint_t),
	    new List(new $(null,mt_tq,uint_t), null)));
	  let fntyp = cstar_typ(new FnType(FnInfo(null,null,ta2, 
						  argtyps, false, null)),
				mt_tq);
	  exp_t fnexp = cast_exp(fntyp,
				 var_exp(_check_unknown_subscript_qv,DL),DL);
	  e->r = deref_exp(fncall_exp(fnexp,
				      new List(e1,
				      new List(sizeoftyp_exp(ta1,DL),
				      new List(e2, null))),DL),
			   DL)->r;
	} else {
	  // ({tagptr x=e1; 
	  //   ta *a = x.curr + e2;
	  //   if (x.base == 0 || a < x.base || a >= x.last_plus_one) 
	  //      throw(ArrayIndex);
	  //   *a;})
	  qvar_t x = temp_var();
	  qvar_t i = temp_var();
	  qvar_t a = temp_var();
	  type_t tx  = add_tagged_ptr_type(ta1,tq);
	  exp_t test_exp = 
	    or_exp(eq_exp(structmember_exp(var_exp(x,DL),base_sp,DL),
			  signed_int_exp(0,DL),DL),
		   or_exp(lt_exp(var_exp(a,DL),
				 structmember_exp(var_exp(x,DL),base_sp,DL),DL),
			  gte_exp(var_exp(a,DL),
				  structmember_exp(var_exp(x,DL),
						   last_plus_one_sp,DL),
				  DL),DL),DL);
	  exp_t a_init = add_exp(structmember_exp(var_exp(x,DL),curr_sp,DL),
				 e2,DL);
	  
	  // FIX:  should throw array out of bounds exception
	  stmt_t s5 = exp_stmt(deref_exp(var_exp(a,DL),DL),DL);
	  stmt_t s4 = exp_stmt(newthrow_exp(null_pointer_exn_exp(DL)),DL);
	  stmt_t s3 = ifthenelse_stmt(test_exp,s4,skip_stmt(DL),DL);
	  stmt_t s2 = seq_stmt(s3,s5,DL);
	  stmt_t s1 = declare_stmt(a,ta2,a_init,s2,DL);
	  e->r = stmt_exp(declare_stmt(x,tx,e1,s1,DL),DL)->r;
	}
	break;
      }
      break;
    default:
      toc_impos("exp_to_c: Subscript on non-tuple/array/tuple ptr");
      break;
    }
    break;
  case &Tuple_e(es):
    if(!nv->toplevel)
      e->r = init_tuple(nv,false,null,es)->r;
    else {
      // At top-level must use designators
      // $(e1,...,en) -> (struct _tuple_type_n){.f1=e1,...,.fn=en}
      let tqs = List::map(tup_to_c,es);
      let n = add_tuple_type(tqs);
      list_t<$(list_t<designator_t>,exp_t)@> dles = null;
      for (int i = 1; es != null; es = es->tl, i++) {
	exp_to_c(nv,es->hd);
	let des = new List((designator_t)(new FieldName(new xprintf("f%d",i))),
                           null);
	dles = new List(new $((list_t<designator_t>)des,es->hd),dles);
      }
      dles = List::imp_rev(dles);
      e->r = cast_exp(strct(n),unresolvedmem_exp(null,dles,DL),DL)->r;
    }
    break;
  case &CompoundLit_e(_,_):
    // the type-checker doesn't deal with these yet...
    unimp("compoundlit");
    break;
  case &Array_e(dles0):
    // An array not under a "new" -- it should only occur in initializer
    // positions.
    // {e1,...,en}
    e->r = unresolvedmem_exp(null,dles0,DL)->r;
    for (let dles = dles0; dles != null; dles = dles->tl) {
      let &$(_,e) = dles->hd;
      exp_to_c(nv,e);
    }
    break;
  case &Comprehension_e(vd,e1,e2):
    // a comprehension not under a "new" -- should only be the case
    // when e1 is constant.  For now, e2 must be too...
    let sz = Evexp::eval_const_uint_exp(e1);
    exp_to_c(nv,e2);
    list_t<$(list_t<designator_t>,exp_t)@> es = null;
    // generate an "empty" array intializer to avoid giant arrays
    if (!is_zero(e2)) {
      for (unsigned int i = 0; i < sz; i++)
        es = new List(new $(null,e2),es);
    }
    e->r = unresolvedmem_exp(null,es,DL)->r;
    break;
  case &Struct_e(tdn,ots,dles,sd):
    // Due to a GCC bug w.r.t. to nested designators, we expand this out
    // to ({ t temp; t.f1 = e1, ..., t.fn = en; t}).
    if(!nv->toplevel)
      e->r = init_struct(nv,old_typ,false,null,dles,tdn)->r;
    else {
      // At top-level must use designators
      let n = tdn;
      structdecl_t sd2 = 
	(structdecl_t)((sd == null) ? toc_impos(xprintf("no structdecl %s",qvar2string(tdn))) : sd);
      region rgn {
      let fields = Tcutil::resolve_struct_designators(rgn, e->loc, dles, 
                                                      ((structdecl_t)sd2)->fields->v);
      for (; fields != null; fields = fields->tl) {
	let &$(field,fieldexp) = fields->hd;
        let fieldtyp = field->type;
	exp_to_c(nv,fieldexp);
	if (is_void_star(fieldtyp))
	  fieldexp->r = cast_exp(void_star_typ(), 
				 new_exp(fieldexp->r,DL),DL)->r;
      }
      //for (let es = dles; es != null; es = es->tl)
      //  exp_to_c(nv,es->hd[1]);
      e->r = cast_exp(strctq(n), unresolvedmem_exp(null,dles,DL),DL)->r;
      }
    }
    break;
  case &AnonStruct_e(st,dles):
    list_t<structfield_t> fs;
    switch (compress(st)) {
    case &AnonStructType(afs): fs = afs; break;
    default: 
      fs = toc_impos(xprintf("anon struct has type %s",typ2string(st))); 
      break;
    }
    region rgn {
      let fields = Tcutil::resolve_struct_designators(rgn, e->loc, dles, fs);
      for (; fields != null; fields = fields->tl) {
        let &$(field,fieldexp) = fields->hd;
        let fieldtyp = field->type;
        exp_to_c(nv,fieldexp);
        if (is_void_star(fieldtyp))
          fieldexp->r = cast_exp(void_star_typ(), 
                                 new_exp(fieldexp->r,DL),DL)->r;
      }
      //for (let es = dles; es != null; es = es->tl)
      //  exp_to_c(nv,es->hd[1]);
      e->r = unresolvedmem_exp(null,dles,DL)->r;
    }
    break;
  
  case &Tunion_e(_,_,null,tud,tuf):
    qvar_t qv = tuf->name;
    // non-value-carrying constructor -- just use the constructor name
    // (see tuniondecl_to_c below)
    if (tud->is_xtunion || !nv->toplevel)
      e->r = var_exp(qv,DL)->r;
    else {
      // FIX: we should get the tag from a centralized place and we
      // might as well use it everywhere.
      // we can't use the variable name at toplevel
      int tag_count = 0;
      let fields = (tud->fields == null) ? null : tud->fields->v;
      while (qvar_cmp(qv,fields->hd->name) != 0) {
	if (fields->hd->typs == null) tag_count++;
	fields = fields->tl;
      }
      e->r = uint_exp(tag_count,DL)->r;
    }
    break;
  case &Tunion_e(_,_,es,tud,tuf):
    let qv   = tuf->name;
    let tqts = tuf->typs;

    let x = temp_var();
    let xexp = var_exp(x,DL);
    let strct_typ = strctq(collapse_qvar_tag(qv,"_struct"));
    // we have to do this differently for the toplevel
    if (nv->toplevel) {
      // {.tag = i, .f1 = e1, ... , .fn = en};
      exp_t tag_exp;
      if(tud->is_xtunion) {
	tag_exp = var_exp(qv,DL);
      } else {
	// FIX: we should get the tag from a centralized place and we
	// might as well use it everywhere.
	int tag_count = 0;
	let fields    = (tud->fields == null) ? null : tud->fields->v;
	while (qvar_cmp(qv,fields->hd->name) != 0) {
	  if (fields->hd->typs != null) tag_count++;
	  fields = fields->tl;
	}
	tag_exp = uint_exp(tag_count,DL);
      }
      let dles = null;
      for(; es != null; es = es->tl, tqts = tqts->tl) {
	exp_t cur_e = es->hd;
	type_t field_typ = typ_to_c((*tqts->hd)[1]);
	exp_to_c(nv,cur_e);
	if (is_void_star(field_typ))
	  cur_e = cast_exp(field_typ,cur_e,DL);
	dles = new{List(new{$(null,cur_e)},dles)};
      }
      dles = new{List(new{$(null,tag_exp)},imp_rev(dles))};
      e->r = unresolvedmem_exp(new Opt(collapse_qvar_tag(qv,"_struct")),
                               dles,DL)->r;
    } else {
      // value-carrying constructor
      // ({ struct qv_tag x; x.tag = i; x.f1 = e1; ...; x.fn = en; x; })
      // Due to GCC bug we can't just use a struct expression.
      let rev_assign =
	new List(assign_stmt(structmember_exp(xexp,tag_sp,DL),
                             var_exp(qv,DL),DL),
                 null);
      for (int i = 1; es != null; es = es->tl, i++, tqts = tqts->tl) {
	exp_t cur_e = es->hd;
	type_t field_typ = typ_to_c((*tqts->hd)[1]);
	exp_to_c(nv,cur_e);
	if (is_void_star(field_typ))
	  cur_e = cast_exp(field_typ,cur_e,DL);
	let a = assign_stmt(structmember_exp(xexp,new {xprintf("f%d",i)},
                                             DL),cur_e,DL);
	rev_assign = new List(a,rev_assign);
      }
      let final_stmt = exp_stmt(xexp,DL);
      let s2         = seq_stmts(imp_rev(new List(final_stmt,rev_assign)),DL);
      e->r = stmt_exp(declare_stmt(x,strct_typ,null,s2,DL),DL)->r;
    }
    break;

  case &Enum_e(_,_,_): break;

  case &Malloc_e(rgnopt,t): 
    type_t t_c = typ_to_c(t);
    if (rgnopt != null) {
      exp_t rgn = (exp_t)rgnopt;
      exp_to_c(nv,rgn);
      e->r = rmalloc_exp(rgn, sizeoftyp_exp(t_c,DL))->r;
    } else {
      e->r = malloc_exp(t, sizeoftyp_exp(t_c,DL))->r;
    }
    break;

  case &StmtExp_e(s): stmt_to_c(nv,s);  break;
  case &UnresolvedMem_e(_,_): toc_impos("UnresolvedMem"); break;
  case &Codegen_e(fd):        unimp("codegen");           break;
  case &Fill_e(_):            unimp("fill");              break;
  }
}

// Translate a pattern generating tests which jump to the succ_lab
// upon successful match and to the fail_lab othewise.  Returns:
// * a new translation environment (mapping variables bound in the pattern
//   to temps generated)
// * a list of temps to be declared (along with their types.)
//   This list contains the decls parameter
// * The statement for actually doing the test.
//
// (The temps must be declared with a wide enough
// scope to cover the tests and any cases in a switch (hence the reason
// they're pulled out.  Also needed for translating fallthru.)
//
// xlate_pat(env,t,r,path,p,succ_lab,fail_lab)
//
//  r is the "root" variable that contains the value we're matching.
//  path is the address of this value -- used in the Reference pattern.
//  p is the pattern
//  succ_lab is where to go upon successful match
//  fail_lab is where to go upon failure to match
//
// FIX: adapt the decision tree code in the type-checker so that we
// have much more efficient traversal of patterns.
// FIX: I think the Address pattern (*) code is too liberal -- lets
// you get pointers to a local variable if you do a switch on a
// local variable...
// DO NOT FIX:  though it looks like all of the goto's are bad and
// we could collapse a lot of if-then-else's and avoid some of the
// jumping around, GCC -O does this for us.  So the only reason to
// make that any better is to improve the readability of the code.
static stmt_t if_eq_goto_stmt(exp_t e1, exp_t e2, var_t succ_lab, var_t fail_lab) {
  return ifthenelse_stmt(eq_exp(e1,e2,DL),
			 goto_stmt(succ_lab,DL),
			 goto_stmt(fail_lab,DL), DL);
}
static $(env_t,list_t<$(qvar_t,type_t)@>,stmt_t)
xlate_pat(env_t nv, type_t t, exp_t r, exp_t path, pat_t p,
	  var_t succ_lab,var_t fail_lab, list_t<$(qvar_t,type_t)@> decls) {
  stmt_t s; // the test statement
  switch (p->r) {
  case &Var_p(&Vardecl(_,x,_,_,_,_,_)):
    // in essence, x = r; but achieved through the varmap
    nv = add_varmap(nv,x,r);
    fallthru;
  case Wild_p: 
    s  = goto_stmt(succ_lab,DL);
    break;
  case &Reference_p(vd):
    // v = path; goto succ_lab
    let v = temp_var();
    decls = new List(new $(v,cstar_typ(typ_to_c(t),mt_tq)),decls);
    nv    = add_varmap(nv,vd->name,var_exp(v,DL));
    s     = seq_stmt(assign_stmt(var_exp(v,DL),address_exp(path,DL),DL),
		     goto_stmt(succ_lab,DL),DL);
    break;

  case Null_p: 
    s = if_eq_goto_stmt(r, signed_int_exp(0,DL),succ_lab,fail_lab); break;
  case &Int_p(sn,i):
    s = if_eq_goto_stmt(r, int_exp(sn,i,DL),    succ_lab,fail_lab); break;
  case &Char_p(c):
    s = if_eq_goto_stmt(r, char_exp(c,DL),      succ_lab,fail_lab); break;
  case &Float_p(f):
    s = if_eq_goto_stmt(r, float_exp(f,DL),     succ_lab,fail_lab); break;

  case &Enum_p(ed,ef):
    s = if_eq_goto_stmt(r, new_exp(new Enum_e(ef->name,ed,ef),null), 
                        succ_lab, fail_lab); 
    break;

  case &Tunion_p(tud,tuf,ts,null):
    // when ps == null:  if (r == qv) goto succ_lab else goto fail_lab;
    // Note: This should be correct for tunion and xtunion!
    exp_t cmp_exp = var_exp(tuf->name,DL);
    if(!tud->is_xtunion)
      cmp_exp = cast_exp(void_star_typ(),cmp_exp,DL);
    s = if_eq_goto_stmt(r, cmp_exp, succ_lab, fail_lab);
    break;

  case &Pointer_p(&Pat{&Tunion_p(tud,tuf,ts,ps),_,_}) && ps != null:
    // when ps is p1,...,pn:
    //   if ((unsigned int)r > max_tag && ((t)r)->tag == qv_tag)
    //      <similar to tuple and struct patterns>
    //   else goto fail_lab
    // (no max tag check on xtunions)
    // FIX: When type is TunionField, can avoid all checks
    // It's unfortunate that we have to always check that r > max_tag.
    // If we had the decision tree information, we could avoid doing so.
    list_t<stmt_t> ss = null;
    int    cnt      = List::length(ps);
    qvar_t tufstrct = collapse_qvar_tag(tuf->name,"_struct");
    exp_t  rcast    = cast_exp(cstar_typ(strctq(tufstrct),mt_tq),r,DL);
    for(let rps = List::rev(ps); rps != null; rps = rps->tl, cnt--) {
      let p2  = rps->hd;
      let v   = temp_var();
      let t2  = p2->topt->v;
      let t2c = typ_to_c(t2);
      let lab = fresh_label();
      decls = new List(new $(v,t2c),decls);
      let result = xlate_pat(nv,t2,var_exp(v,DL),
                             structarrow_exp(rcast,new {xprintf("f%d",cnt)},
                                             DL),
                             p2,succ_lab,fail_lab,decls);
      nv = result[0];
      decls = result[1];
      let s3 = result[2];
      let s1 = assign_stmt(var_exp(v,DL),
                           cast_exp(t2c,
                                    structarrow_exp(rcast,
                                                    new {xprintf("f%d",cnt)},
                                                    DL),DL),DL);
      let s2 = seq_stmt(s1,s3,DL);
      ss = new List(label_stmt(lab,s2,DL),ss);
      succ_lab = lab;
    }
    exp_t test_exp;
    if(tud->is_xtunion) {
      exp_t e2 = cast_exp(cstar_typ(void_star_typ(),mt_tq), r,DL);
      exp_t e1 = deref_exp(e2,DL);
      exp_t e  = var_exp(tuf->name,DL);
      test_exp = eq_exp(e1,e,DL);
      s = ifthenelse_stmt(eq_exp(e1,e,DL),
			  seq_stmts(ss,DL),
			  goto_stmt(fail_lab,DL), DL);
    } else {
      unsigned int max_tag = 0;
      for (let fs = tud->fields->v; fs != null; fs = fs->tl) {
	let f = fs->hd;
	if (f->typs == null) {
	  max_tag++;
	}
      }
      exp_t max_tag_exp = uint_exp(max_tag,DL);
      exp_t e3 = cast_exp(cstar_typ(sint_t,mt_tq), r,DL);
      exp_t e1 = deref_exp(e3,DL);
      exp_t e5 = gt_exp(cast_exp(uint_t,r,DL), max_tag_exp, DL);
      exp_t e  = var_exp(tuf->name,DL);
      test_exp = (max_tag>0) ? and_exp(e5,eq_exp(e1,e,DL),DL) : eq_exp(e1,e,DL);
    }
    s = ifthenelse_stmt(test_exp,
			seq_stmts(ss,DL),
			goto_stmt(fail_lab,DL), DL);
    break;

  case &Tunion_p(_,_,_,ps): fallthru(ps); // okay for xtunion too
  case &Tuple_p(ps):
    // given the pattern $(p1,p2,...,pn)
    //    v1 = r->f1; if (matches(v1,p1)) goto L1 else goto fail_lab;
    // L1:v2 = r->f2; if (matches(v2,p2)) goto L2 else goto fail_lab;
    // L2:v3 = r->f3; if (matches(v3,p2)) goto L3 else goto fail_lab;
    //    ...
    // Ln-1:vn = r->fn; if (matches(vn,p2)) goto succ_lab else goto fail_lab;
    list_t<stmt_t> ss = null;
    int cnt = List::length(ps);
    for(let rps = List::rev(ps); rps != null; rps = rps->tl, cnt--) {
      let p2  = rps->hd;
      let v   = temp_var();
      let t2  = p2->topt->v;
      let lab = fresh_label();
      decls = new List(new $(v,typ_to_c(t2)),decls);
      let result = xlate_pat(nv,t2,var_exp(v,DL),
			   structmember_exp(path,new {xprintf("f%d",cnt)},
					   DL),p2,succ_lab,fail_lab,decls);
      nv = result[0];
      decls = result[1];
      let s2 = result[2];
      let s3 = seq_stmt(assign_stmt(var_exp(v,DL),
                                    structmember_exp(r,new {xprintf("f%d",cnt)},
                                                     DL),DL),
			s2,DL);
      ss = new List(label_stmt(lab,s3,DL),ss);
      succ_lab = lab;
    }
    s = seq_stmts(ss,DL);
    break;
  case &Struct_p(sd,ot,ts,dlps0):
    // similar to translation of tuple pattern
    list_t<stmt_t> ss = null;
    for (let dlps = List::rev(dlps0); dlps != null; dlps = dlps->tl) {
      let tup = dlps->hd;
      let p2  = (*tup)[1];
      _ f;
      switch ((*tup)[0]->hd) {
        case &FieldName(f2):
          f=f2;
          break;
        default:  // FIX:  assumes one field name designator
          throw Match_error;
      }
      let v   = temp_var();
      let t2  = p2->topt->v;
      let t2c = typ_to_c(t2);
      let lab = fresh_label();
      decls = new List(new $(v,t2c),decls);
      let result = xlate_pat(nv,t2,var_exp(v,DL),structmember_exp(path,f,DL),p2,
                             succ_lab,fail_lab,decls);
      nv = result[0];
      decls = result[1];
      let s2 = result[2];
      let s3 = seq_stmt(assign_stmt(var_exp(v,DL), 
                                    cast_exp(t2c,
                                             structmember_exp(r,f,DL),DL),DL),
                        s2, DL);
      ss = new List(label_stmt(lab,s3,DL),ss);
      succ_lab = lab;
    }
    s = seq_stmts(ss,DL);
    break;

  case &Pointer_p(p2):
    // if (r == 0) goto fail_lab; v = *r; match(v,p2);
    let v = temp_var();
    let t2 = p2->topt->v;
    decls = new List(new $(v,typ_to_c(t2)),decls);
    let result = xlate_pat(nv,t2,var_exp(v,DL),deref_exp(path,DL),p2,
			   succ_lab,fail_lab,decls);
    nv = result[0];
    decls = result[1];
    let s2 = result[2];
    let s3 = seq_stmt(assign_stmt(var_exp(v,DL),deref_exp(r,DL),DL),s2,DL);
    if (is_nullable(t))
      s = ifthenelse_stmt(eq_exp(r,signed_int_exp(0,DL),DL),
			  goto_stmt(fail_lab,DL),
			  s3,DL);
    else
      s = s3;
    break;
  case &UnknownId_p(_):         s = toc_impos("unknownid");     break;
  case &UnknownCall_p(_,_,_):   s = toc_impos("unknowncall");   break;
  case &UnknownFields_p(_,_,_): s = toc_impos("unknownfields"); break;
  }
  return $(nv,decls,s);
}

///////////////////////////////////////////////////////////////
//              Translation of Switch Statements             //
///////////////////////////////////////////////////////////////
// FIX:  Should use decision tree stuff from tcpat.
//
// For performance, we try to leave switches as switches.  We do this when
// all of the following hold:
// * We are switching on a char or int type.
//   (Could also do tunion without value contructors, but we didn't pass in
//    access to the type definitions!)
// * No switch_clause has any variables. (reject switch(3) { case x: ... }
// The hitch is we could still have something like
//    switch(e) { case 0: if(b) fallthru; else return; }
// Therefore, we give each case body
// a fresh label so we can translate fallthru to
// goto.  Then we just hope gcc cleans up the mess and can still use jump
// tables.
//
// For all other switches,
// switch (e) { case p1: s1 ... case pn:sn } turns into (roughly)
//
//  x = e;
//  <lots of temp declarations>
//    if matches(p1,x) goto L1 else goto L2;
// L2:if matches(p2,x) goto L3 else goto L4;
// L4:if matches(p3,x) goto L5 else goto L6;
//     ...
// L2n-2:if matches(pn,x) goto L2n-1 else goto L2n;
// L1: s1;
// L3: s2;
// L5: s3;
// ...
// L2n-1: sn;
// L2n: ;
//
// Note that within s1,...,sn, breaks are translated to "goto L2n".
static $(var_t,var_t,switch_clause_t)@ gen_label(switch_clause_t sc) {
  return new $(fresh_label(),fresh_label(),sc);
}
static void xlate_switch(env_t nv, stmt_t whole_s, exp_t e, list_t<switch_clause_t> scs) {
  exp_to_c(nv,e);
  let t = e->topt->v;

  // decide if we can leave it as a switch
  // FIX: cannot have Float_p in any cases.
  bool leave_as_switch;
  switch (compress(t)) {
  case &IntType(_,_): leave_as_switch = true;  break;
  default:           leave_as_switch = false; break;
  }
  for(let scs1 = scs; scs1 != null; scs1 = scs1->tl)
    if(scs1->hd->pat_vars->v != null || scs1->hd->where_clause != null) {
      leave_as_switch = false;
      break;
    }
  if(leave_as_switch) {
    // note: fallthru in last case can't happen, else this is busted
    var_t next_l = fresh_label();
    for(let scs1 = scs; scs1 != null; scs1 = scs1->tl) {
      let s = scs1->hd->body;
      scs1->hd->body = label_stmt(next_l,s,DL);
      next_l = fresh_label();
      stmt_to_c(switch_as_switch_env(nv,next_l),s);
    }
    return;
  }

  // no dice, translate to a nest of gotos...
  qvar_t v     = temp_var();
  exp_t  r     = var_exp(v,DL);
  exp_t  path  = var_exp(v,DL);
  var_t  end_l = fresh_label();
  // for each case, generate a test label and an entry label
  list_t<$(var_t,var_t,switch_clause_t)@> lscs = List::map(gen_label,scs);
  list_t<stmt_t>            test_stmts = null;
  list_t<env_t>             nvs        = null;
  list_t<$(qvar_t,type_t)@> decls      = null;
  // generate the tests for each case, branching to the case's
  // label on success and to the next test on false.
  // do tests backwards so as to get vars for fallthrus
  for (let lscs2 = lscs; lscs2 != null; lscs2 = lscs2->tl) {
    switch_clause_t sc = (*lscs2->hd)[2];
    var_t fail_lab = (lscs2->tl == null) ? end_l : (*lscs2->tl->hd)[0];
    var_t succ_lab = (*lscs2->hd)[1];
    if (sc->where_clause == null) {
      let res = xlate_pat(nv,t,r,path,sc->pattern,succ_lab,fail_lab,decls);
      nvs   = new List(res[0],nvs);
      decls = res[1];
      test_stmts = new List(label_stmt((*lscs2->hd)[0],res[2],DL),test_stmts);
    } else {
      let e = (exp_t)sc->where_clause;
      let intermed_lab = fresh_label();
      let res = xlate_pat(nv,t,r,path,sc->pattern,intermed_lab,fail_lab,decls);
      // Translate where clause with pattern vars in scope
      exp_to_c(res[0],e); 
      nvs   = new List(res[0],nvs);
      decls = res[1];
      stmt_t s2 = ifthenelse_stmt(e,goto_stmt(succ_lab,DL),
				  goto_stmt(fail_lab,DL),DL);
      stmt_t s3 = label_stmt(intermed_lab, s2, DL);
      test_stmts = new List(label_stmt((*lscs2->hd)[0],
				    seq_stmt(res[2], s3, DL),DL),
			 test_stmts);
    }
  }
  let test_stmt = seq_stmts(List::imp_rev(test_stmts),DL);
  nvs = List::imp_rev(nvs);
  // now generate all of the statements for the cases
  stmt_t clauses = skip_stmt(DL);
  if(lscs != null) {
    for (; lscs->tl != null; lscs = lscs->tl, nvs = nvs->tl) {
      let e = nvs->hd;
      stmt_t s = (*lscs->hd)[2]->body;
      stmt_to_c(non_last_switchclause_env(e,
					  end_l,
					  (*lscs->tl->hd)[1],
					  (*lscs->tl->hd)[2]->pat_vars->v,
					  nvs->tl->hd),
		s);
      clauses = seq_stmt(clauses, label_stmt((*lscs->hd)[1], s, DL), DL);
    }
    let e = nvs->hd;
    stmt_t s = (*lscs->hd)[2]->body;
    stmt_to_c(last_switchclause_env(e, end_l), s);
    clauses = seq_stmt(clauses, label_stmt((*lscs->hd)[1], s, DL), DL);
  }
  // glue the test statements, the case statements, and the end label together
  stmt_t res = seq_stmt(test_stmt,
		      seq_stmt(clauses,
			       label_stmt(end_l, skip_stmt(DL),DL),DL),DL);
  // add in all of the variable declarations with a wide enough scope
  for (decls; decls != null; decls = decls->tl) {
    let &$(qv,t) = decls->hd;
    res = declare_stmt(qv, t, null, res, DL);
  }
  // and finally add in the variable that holds the test and clobber
  // the abstract syntax
  whole_s->r = declare_stmt(v,typ_to_c(e->topt->v),e, res, DL)->r;
}

static stmt_t letdecl_to_c(env_t nv, pat_t p, opt_t<type_t> topt, exp_t e,
			 bool exhaust, stmt_t s); // forward declaration
static env_t decls_to_c(env_t nv, list_t<decl_t> ds, bool top);

///////////////////////////////////////////////////////////////
//              Translation of Statements                    //
///////////////////////////////////////////////////////////////
stmt_t make_npop_handler(int n) {
  return exp_stmt(fncall_exp(var_exp(_npop_handler_qv,DL),
			     new{List(uint_exp(n-1,DL),null)}, DL), DL);
}
void do_npop_before(int n, stmt_t s) { // mutates s as necessary!
  if(n > 0)
    s->r = seq_stmt(make_npop_handler(n),new_stmt(s->r,DL),DL)->r;
}

// This is surprisingly straightforward... a good sign.
static void stmt_to_c(env_t nv, stmt_t s) {
  // written to be self-tail recursive
  while (true) {
    switch (s->r) {
    case Skip_s:
      return;
    case &Exp_s(e):
      exp_to_c(nv, e);
      return;
    case &Seq_s(s1,s2):
      stmt_to_c(nv,s1);
      s = s2;
      continue;
    case &Return_s(eopt):
      opt_t<type_t> topt = null;
      if (eopt != null) {
	topt = new Opt(typ_to_c(eopt->topt->v));
	exp_to_c(nv,(exp_t)eopt);
      }
      // reset handler **after** evaluating expression
      // FIX:  share code between break, continue, return, fallthru
      if (s->try_depth > 0) 
	if (topt != null) {
	  let x = temp_var();
	  let retn_stmt = return_stmt(var_exp(x,DL),DL);
	  s->r = declare_stmt(x,topt->v, eopt,
			      seq_stmt(make_npop_handler(s->try_depth),
				       retn_stmt,DL),DL)->r;
	} else {
	  do_npop_before(s->try_depth,s);
	}
      return;
    case &IfThenElse_s(e,s1,s2):
      exp_to_c(nv,e);
      stmt_to_c(nv,s1);
      s = s2;
      continue;
    case &While_s($(e,_),s2):
      exp_to_c(nv,e);
      stmt_to_c(loop_env(nv),s2);
      return;
    case &Break_s(dest_opt): // dest is null when break to end of void function
      if (nv->break_lab != null)
	s->r = goto_stmt(nv->break_lab->v, DL)->r;
      // reset handler
      int dest_depth = dest_opt == null ? 0 : dest_opt->try_depth;
      do_npop_before(s->try_depth - dest_depth, s);
      return;
    case &Continue_s(dest):
      if (nv->continue_lab != null)
	s->r = goto_stmt(nv->continue_lab->v, DL)->r;
      // reset handler
      do_npop_before(s->try_depth - dest->try_depth, s);
      return;
    case &Goto_s(_,dest): 
      // reset handler (note: earlier checks prevent jump into handler)
      do_npop_before(s->try_depth - dest->try_depth, s);
      return;
    case &For_s(e1,$(e2,_),$(e3,_),s2):
      // FIX:  should e3 be translated in nv?
      exp_to_c(nv,e1); exp_to_c(nv,e2); exp_to_c(nv,e3);
      stmt_to_c(loop_env(nv),s2);
      return;
    case &Switch_s(e,scs):
      xlate_switch(nv,s,e,scs);
      return;
    case &Fallthru_s(es,dest_clause):
      if(nv->fallthru_info == null)
	throw toc_impos("fallthru in unexpected place"); 
      let &$(l,vs,other_vmap) = nv->fallthru_info->v;
      stmt_t s2 = goto_stmt(l, DL);
      // reset handler (after the es evaluation)
      do_npop_before(s->try_depth - (*dest_clause)->body->try_depth, s2);
      let vs2 = List::rev(vs);
      let es2 = List::rev(es);
      for(; vs2 != null; vs2 = vs2->tl, es2 = es2->tl) {
	exp_to_c(nv,es2->hd);
	s2 = seq_stmt(assign_stmt(Dict::lookup(other_vmap,vs2->hd),
				  es2->hd,DL),
		      s2,DL);
      }
      s->r = s2->r;
      return;
    case &Decl_s(d,s1):
      // we have to treat Let_d and Var_d where we bind a comprehension
      // (not at the top-level) specially because these have to return 
      // "statements".  See letdecl_to_c and decls_to_c below.
      switch (d->r) {
      case &Let_d(p,_,topt,e,exhaust):
        // Handle the special case where the pattern is a 
        // variable just like a variable declaration
	/* JGM: this isn't valid because of the following bad code:
	 *   int *i = new 3;
	 *   let i = i;
        let var_case = false;
        struct Vardecl *vdopt = null;
        switch (p->r) {
        case &Var_p(vd):
          var_case = true;
          vdopt = vd;
          vd->initializer = e;
          d->r = new Var_d(vd);
          break;
        default: break;
        }
        if (var_case) fallthru((vardecl_t)vdopt);
	*/
	// we treat let declarations specially because they may need
	// statements in addition to declarations, so we splice them in
	// as a statement.  Other declarations only produce declarations.
	s->r = letdecl_to_c(nv, p, topt, e, exhaust, s1)->r;
        break;
      case &Var_d(vd):
        let c_name = vd->name;
        vd->type = typ_to_c_array(vd->type);
        let nv2 = add_varmap(nv,c_name,varb_exp(c_name,new Local_b(vd),DL));
        stmt_to_c(nv2,s1);
        if (vd->initializer != null) {
          exp_t init = (exp_t)vd->initializer;
          switch (init->r) {
          case &Comprehension_e(vd2,e1,e2):
            vd->initializer = null;
            s1->r = init_comprehension(nv, var_exp(c_name, DL), vd2, e1, e2,
				      new_stmt(s1->r,DL), false)->r;
            break;
          default:
            exp_to_c(nv, init);
            break;
          }
        }
        break;
      default:
        impos("bad nested declaration within function");
        break;
      }
      return;
    case &Cut_s(_):    unimp("cut");    return;
    case &Splice_s(_): unimp("splice"); return;
    case &Label_s(lab,s1):
      s = s1; continue;
    case &Do_s(s2,$(e,_)):
      stmt_to_c(loop_env(nv),s2);
      exp_to_c(nv,e);
      return;
    case &TryCatch_s(body,scs):
      // NOTE: Because explicit fallthru is not allowed in the last case,
      //       appending a new last case can't change the meaning of any
      //       control flow.
      // struct handler_cons h;
      // _push_handler(&h);
      // int was_thrown = 0; 
      // if (setjmp(h.handler)) was_thrown = 1;
      // if (!was_thrown) {
      //   body
      //   _pop_handler();
      // } else {
      //   exn e = (exn)_exn_thrown;
      //   switch (e) scs
      // }
      //
      // [Auxillary functions are defined in cyc_runtime.c]
      qvar_t h_var = temp_var();
      qvar_t e_var = temp_var();
      qvar_t was_thrown_var = temp_var();
      exp_t  h_exp = var_exp(h_var,DL);
      exp_t  e_exp = var_exp(e_var,DL);
      exp_t  was_thrown_exp = var_exp(was_thrown_var,DL);
      type_t h_typ = strct(_handler_cons_sp);
      type_t e_typ = typ_to_c(exn_typ);
      type_t was_thrown_typ = typ_to_c(sint_t);
      exp_t  pushhandler_exp = var_exp(_push_handler_qv,DL);
      exp_t  setjmp_exp      = var_exp(setjmp_qv,       DL);
      exp_t  pophandler_exp  = var_exp(_pop_handler_qv, DL);
      exp_t  _exn_thrown_exp = var_exp(_exn_thrown_qv,  DL);
      // e_exp needs a typ because it'll go through exp_to_c;
      // as well, it must be in varmap
      e_exp->topt = new Opt(e_typ);
      nv = add_varmap(nv,e_var,e_exp);

      // translate the body
      stmt_to_c(nv,body);
      let tryandpop_stmt = seq_stmt(body,
                                    exp_stmt(fncall_exp(pophandler_exp, null,
                                                        DL), DL),DL);

      // add a default case which re-throws the exception
      let x    = temp_var();
      let xexp = var_exp(x,DL);
      let x_vd = new_vardecl(x,exn_typ,null);
      xexp->topt = new Opt(exn_typ);
      let p = new Pat{.r=new Var_p(x_vd),
                      .topt=new Opt(exn_typ),
                      .loc=DL};
      let te = throw_exp(xexp,DL);
      te->topt = new Opt(VoidType);
      let rs = exp_stmt(te,DL);
      let default_case =
        new Switch_clause{.pattern=p,.pat_vars=new Opt(new List(x_vd,null)),
                          .where_clause=null,.body=rs,.loc=DL};
      let handler_stmt = switch_stmt(e_exp,
                                     List::append(scs,
                                                  new List(default_case,null)),DL);
      // translate the switches
      stmt_to_c(nv,handler_stmt);

      // wrap with the conditional, declarations, and setjmp
      let setjmp_call = // setjmp(h.handler)
        fncall_exp(setjmp_exp,
                   new List(structmember_exp(h_exp,handler_sp,DL), null),
                   DL);
      let pushhandler_call = // _pushhandler(h);
        exp_stmt(fncall_exp(pushhandler_exp, 
                            new List(address_exp(h_exp,DL), null),
                            DL),
                 DL);
      let zero_exp = int_exp(Signed,0,DL);
      let one_exp = int_exp(Signed,1,DL);
      s->r =
        declare_stmt(h_var, h_typ, null,
        seq_stmt(pushhandler_call,
        declare_stmt(was_thrown_var,was_thrown_typ,zero_exp,
        seq_stmt(ifthenelse_stmt(setjmp_call,
                                 assign_stmt(was_thrown_exp,one_exp,DL),
                                 skip_stmt(DL),
                                 DL),
        ifthenelse_stmt(prim1_exp(Not, was_thrown_exp,DL),
                        tryandpop_stmt,
                        declare_stmt(e_var,e_typ,
                                     cast_exp(e_typ,_exn_thrown_exp,DL),
                        handler_stmt,DL),DL),DL),DL),DL),DL)->r;
      return;
    case &Region_s(tv, vd, body):
      // NOTE:  _npop_handler has to deal with regions as well as exceptions
      // { struct _RegionHandle rh = _new_region();
      //   struct _RegionHandle *x = &rh;
      //   _push_rgn(x);
      //   body; 
      //   _pop_region(&rh);
      // }
      type_t rh_struct_typ = strct(_RegionHandle_sp);
      type_t rh_struct_ptr_typ = cstar_typ(rh_struct_typ,mt_tq);
      type_t h_typ = strct(_handler_cons_sp);
      qvar_t rh_var = temp_var();
      qvar_t x_var = vd->name;
      exp_t  rh_exp = var_exp(rh_var,DL);
      exp_t  x_exp = varb_exp(x_var,new Local_b(vd),DL);
      exp_t pushregion_exp = var_exp(new $(abs_ns, _push_region_sp),DL);
      exp_t popregion_exp = var_exp(new $(abs_ns, _pop_region_sp),DL);
      exp_t newregion_exp = var_exp(new $(abs_ns, _new_region_sp),DL);
      exp_t addr_rh_exp = address_exp(rh_exp,DL);
      exp_t newregion_call = fncall_exp(newregion_exp, null, DL);
      exp_t popregion_call = fncall_exp(popregion_exp, 
                                        new List(addr_rh_exp,null),DL);
      exp_t pushregion_call = fncall_exp(pushregion_exp,
                                         new List(x_exp,null), DL);
      stmt_to_c(add_varmap(nv,x_var,x_exp),body);
      stmt_t s2 = seq_stmt(body,exp_stmt(popregion_call,DL),DL);
      s2 = seq_stmt(exp_stmt(pushregion_call,DL),s2,DL);
      s->r = 
        declare_stmt(rh_var, rh_struct_typ, newregion_call,
                     declare_stmt(x_var, rh_struct_ptr_typ, addr_rh_exp,
                                  s2,DL),DL)->r;
      return;
    }
  }
}

///////////////////////////////////////////////////////////////
//              Translation of Declarations                  //
///////////////////////////////////////////////////////////////
// function declaration translation -- straightforward
static void fndecl_to_c(env_t nv, fndecl_t f) {
  f->tvs      = null;
  f->effect   = null;
  f->ret_type = typ_to_c(f->ret_type);
  for (let args=f->args; args != null; args = args->tl) {
    (*args->hd)[2] = typ_to_c((*args->hd)[2]);
    let x = new $((nmspace_t)Loc_n,(*args->hd)[0]);
    nv = add_varmap(nv,x,var_exp(x,DL));
  }
  // Tovc would like to use param_vardecls:
  for(let arg_vds = f->param_vardecls->v; arg_vds!=null; arg_vds=arg_vds->tl) {
    arg_vds->hd->type = typ_to_c(arg_vds->hd->type);
  }
  stmt_to_c(clear_toplevel(nv),f->body);
}

// there's no abstract scope in C
static scope_t scope_to_c(scope_t s) {
  switch (s) {
  case Abstract: return Public;
  case ExternC : return Extern;
  default:       return s;
  }
}

// struct declarations -- straightforward
opt_t<Dict::dict_t<var_t,structdecl_t>> structs_so_far = null;
static void structdecl_to_c(structdecl_t s) {
  let n = s->name->v;
  if (structs_so_far == null) structs_so_far =
				new Opt(Dict::empty(String::zstrptrcmp));
  bool seen_defn_before;
  let dopt = Dict::lookup_opt(structs_so_far->v, (*n)[1]);
  if (dopt == null) {
    seen_defn_before = false;
    structs_so_far->v = Dict::insert(structs_so_far->v,(*n)[1],s);
  } else {
    if (dopt->v->fields == null) {
      structs_so_far->v = Dict::insert(structs_so_far->v,(*n)[1],s);
      seen_defn_before = false;
    } else
      seen_defn_before = true;
  }

  s->sc =
    // C does not like extern or static on struct declarations -- this avoids
    // a gcc warning
    (s->sc == Extern || s->sc == Static || s->sc == ExternC) ? Public 
    : scope_to_c(s->sc);
  s->tvs  = null;
  s->name = new Opt(n);
  if (s->fields != null)
    if (seen_defn_before)
      s->fields = null;
    else {
      for (let fields = s->fields->v; fields != null; fields = fields->tl)
        fields->hd->type = typ_to_c_array(fields->hd->type);
    }
}

// union declarations -- straightforward
opt_t<Dict::dict_t<var_t,uniondecl_t>> unions_so_far = null;
static void uniondecl_to_c(uniondecl_t u) {
  let n = u->name->v;
  if (unions_so_far == null) unions_so_far =
                               new Opt(Dict::empty(String::zstrptrcmp));
  bool seen_defn_before;
  let dopt = Dict::lookup_opt(unions_so_far->v, (*n)[1]);
  if (dopt == null) {
    seen_defn_before = false;
    unions_so_far->v = Dict::insert(unions_so_far->v,(*n)[1],u);
  } else {
    if (dopt->v->fields == null) {
      unions_so_far->v = Dict::insert(unions_so_far->v,(*n)[1],u);
      seen_defn_before = false;
    } else
      seen_defn_before = true;
  }

  u->sc =
    // C does not like extern or static on union declarations -- this avoids
    // a gcc warning
    (u->sc == Extern || u->sc == (scope_t)Static || u->sc == ExternC) ? 
    Public : scope_to_c(u->sc);
  u->tvs  = null;
  u->name = new Opt(n);
  if (u->fields != null)
    if (seen_defn_before)
      u->fields = null;
    else {
      for (let fields = u->fields->v; fields != null; fields = fields->tl)
        fields->hd->type = typ_to_c_array(fields->hd->type);
    }
}

// tunion declarations -- tricky
// for "tunion foo {Bar,Blah,Baz(t1,t2,t3),Baf(t4,t5)}" we generate
//   typedef void *foo;
//   static const int Bar  = 0;
//   static const int Blah = 1;
//   static const int Baz  = 0;
//   struct _Baz_struct {
//     int tag;  // always == Baz
//     t1 f1;
//     t2 f2;
//     t3 f3;
//   }
//   static const int Baf = 1;
//   struct _Baf_struct {
//     int tag;  // always == Baf
//     t4 f1;
//     t5 f2;
//   }
// for xtunion, we pull a really slimy trick: By using char arrays instead
// of ints, the uses get promoted to addresses just like we want.
// When the tunion is "extern" then we don't generate initializers
// for the tags (that should be done elsewhere.)
//
// NB: we allow any number of repeated declarations but we can only
//     declare and initialize global variables once.  So we keep track
//     of what we've seen so far.  And we make the globals static so that
//     extern and what not is only a link-checker thing.  Unfortunately,
//     the static trick doesn't work for xtunion, which uses the addresses.
static opt_t<Set::set_t<qvar_t>> tunions_so_far = null;
static void tuniondecl_to_c(tuniondecl_t tud) {
  if (tunions_so_far == null)
    tunions_so_far = new Opt(Set::empty(qvar_cmp));
  let n = tud->name;
  if(tud->fields == null)
    return;
  if(Set::member(tunions_so_far->v, n))
    return;
  tunions_so_far->v = Set::insert(tunions_so_far->v, n);

  // counters for the tags
  int tag_count = 0;
  int box_count = 0;
  for (let fields = tud->fields->v; fields != null; fields = fields->tl) {
    tunionfield_t f = fields->hd;
    if (f->typs == null) {
      // Declare an integer constant for the unboxed field
      exp_opt_t eopt = signed_int_exp(tag_count++,DL);
      vardecl_t vd   = static_vardecl(f->name, sint_t, eopt);
      vd->tq = Tqual{.q_const=true, .q_volatile=false, .q_restrict=false};
      result_decls = new List(new_decl(new Var_d(vd),DL),result_decls);
    } else {
      // Declare an integer constant for the tag and a struct for the field
      exp_opt_t eopt = signed_int_exp(box_count++,DL);
      vardecl_t vd   = static_vardecl(f->name, sint_t, eopt);
      vd->tq = Tqual{.q_const=true, .q_volatile=false, .q_restrict=false};
      result_decls = new List(new_decl(new Var_d(vd),DL),result_decls);
      // compute the fields for the struct, adding in a tag field
      let fs = null;
      int i  = 1;
      for (let ts = f->typs; ts != null; ts = ts->tl, i++) {
	let fname = (stringptr)(new xprintf("f%d",i));
	let f = new Structfield(fname,(*ts->hd)[0],
				typ_to_c_array((*ts->hd)[1]),null,null);
	fs = new List(f,fs);
      }
      fs = List::imp_rev(fs);
      fs = new List(new Structfield(tag_sp,mt_tq,sint_t,null,null),fs);
      let sd = 
	new Structdecl{.sc = Public,
		       .name = new Opt(collapse_qvar_tag(f->name,"_struct")),
		       .tvs = null, 
		       .fields = new Opt(fs), 
		       .attributes = null};
      result_decls = new List(new_decl(new Struct_d(sd),DL),result_decls);
    }
  }
}

// xtunion declarations -- similar to tunion declarations
// For a declaration extending an existing xtunion, e.g.,
//   "xtunion foo {Bar,Baz(t1,t2)}"
// we generate
//   char Bar[4] = "\0\0\0\0Bar";
//   struct Bar_struct { char *tag; };
//   char Baz[4] = "\0\0\0\0Baz";
//   struct Baz_struct { char *tag; t1 f1; t2 f2; };
// When the xtunion is extern, then we don't do initializers for the tags.
// The 0s are a crazy trick for letting void variants not have to be boxed
// (value variants can still follow the pointer and then their check fails)
//
// Thus "Baz(e1,e2)" maps to
// ({struct _Baz_struct *t =
//     (struct _Baz_struct*)malloc(sizeof(struct _Baz_struct));
//   *t = (struct _Baz_struct){.tag=Baz, .f1 = e1, .f2 = e2};
//   t;})
static opt_t<Dict::dict_t<qvar_t, bool>> xtunion_fields_so_far = null;
// true if already seen & initialized, false if already seen but non initialized (extern)

static void xtuniondecl_to_c(tuniondecl_t xd) {
  if (xtunion_fields_so_far == null)
    xtunion_fields_so_far = new Opt(Dict::empty(qvar_cmp));
  if(xd->fields == null)
    return;
  let n = xd->name;
  for (let fs = xd->fields->v; fs != null; fs = fs->tl) {
    tunionfield_t f  = fs->hd;
    stringptr     fn = (*f->name)[1];
    let       sz_exp  = uint_exp((*fn).size+4,DL);
    let       tag_typ = new ArrayType(uchar_t,mt_tq,sz_exp);
    // FIX: making bad alignment and pointer-size assumptions!
    switch (Dict::lookup_opt(xtunion_fields_so_far->v,f->name)) {
    case null:
      exp_opt_t initopt = null;
      if (f->sc != Extern) {
	initopt = string_exp(xprintf("%c%c%c%c%s",0,0,0,0,*fn),DL);
      }
      let tag_decl = new_vardecl(f->name, tag_typ, initopt);
      tag_decl->sc = f->sc;
      result_decls = new List(new_decl(new Var_d(tag_decl),DL),result_decls);
      xtunion_fields_so_far->v = Dict::insert(xtunion_fields_so_far->v, f->name, f->sc != Extern);
      if(f->typs != null) {
	list_t<structfield_t> fields = null;
	int i = 1;
	for (let tqts = f->typs; tqts != null; tqts = tqts->tl,i++) {
	  let field_n = (stringptr)(new {xprintf("f%d",i)});
	  let newf    = new Structfield(field_n,(*tqts->hd)[0],
					typ_to_c_array((*tqts->hd)[1]),null,null);
	  fields = new List(newf,fields);
	}
	fields = new List(new Structfield(tag_sp,mt_tq,
					  cstar_typ(uchar_t,mt_tq),null,null),
			  List::imp_rev(fields));
	let strct_decl =
	  new Structdecl{.sc = Public,
			 .name = new Opt(collapse_qvar_tag(f->name,"_struct")),
			 .tvs    = null,
			 .fields = new Opt(fields),
			 .attributes = null};
	result_decls = new List(new_decl(new Struct_d(strct_decl),DL),
				result_decls);
      }
      break;

    case &Opt(false):
      if (f->sc != Extern) {
	let initopt = string_exp(xprintf("%c%c%c%c%s",0,0,0,0,*fn),DL);
	let tag_decl = new_vardecl(f->name, tag_typ, initopt);
	tag_decl->sc = f->sc;
	result_decls = new List(new_decl(new Var_d(tag_decl),DL),result_decls);
	xtunion_fields_so_far->v = Dict::insert(xtunion_fields_so_far->v, f->name, true);
      }
      break;
    default: break;
    }
  }
}

static void enumdecl_to_c(env_t nv,enumdecl_t ed) {
  let n = ed->name;
  ed->sc = 
    // C does not like extern or static on struct declarations -- this avoids
    // a gcc warning
    (ed->sc == Extern || ed->sc == Static || 
     ed->sc == ExternC) ? Public : scope_to_c(ed->sc);
  for (let fs = ed->fields->v; fs != null; fs = fs->tl) {
    if (fs->hd->tag != null) {
      unsigned int i = Evexp::eval_const_uint_exp((exp_t)fs->hd->tag);
      fs->hd->tag = uint_exp(i,null);
    }
  }
}

// let declarations -- tricky
// Unlike other declarations, lets need to execute statements and
// so return a statement.  (See stmt_to_c, case for Decl above.)
// We treat this similar to the compilation of a switch (see xlate_switch
// above) with one case, but where the failure throws the exception
// Match_Exception
static stmt_t letdecl_to_c(env_t nv, pat_t p, opt_t<type_t> topt, exp_t e,
                           bool exhaust, stmt_t s) {
  type_t t = topt->v;
  exp_to_c(nv,e);
  qvar_t x = temp_var();
  var_t  succ_lab = fresh_label();
  var_t  fail_lab = exhaust ? succ_lab : fresh_label();
  let $(nv,vars,test_stmt) =
    xlate_pat(nv, t, var_exp(x,DL), var_exp(x,DL), p,
	      succ_lab, fail_lab, null);
  stmt_to_c(nv,s);
  let succ_stmt = label_stmt(succ_lab,s,DL);
  if(exhaust)
    s = declare_stmt(x,typ_to_c(t),e,seq_stmt(test_stmt,succ_stmt,DL),DL);
  else {
    let e3 = newthrow_exp(var_exp(new $(abs_ns,Match_Exception_sp),DL));
    let fail_stmt = label_stmt(fail_lab,exp_stmt(e3,DL),DL);
    s = declare_stmt(x,typ_to_c(t),e,
		     seq_stmt(test_stmt,
			      seq_stmt(fail_stmt,succ_stmt,DL),DL),DL);
  }
  for (; vars != null; vars = vars->tl) {
    let &$(qv,t2) = vars->hd;
    s = declare_stmt(qv,t2,null,s,DL);
  }
  return s;
}

// Translate the given declarations, producing a new list of declarations
// and a new translation environment.  All source-level variables should
// be entered in the varmap of the env.  Note that top-level variable
// declarations are treated differently.
//
// FIX:  the translation of top-level variable declarations needs to be
// fixed to make expressions "constant" initializers for C (e.g.,
// constructor expressions, new structs, etc.)
static env_t decls_to_c(env_t nv, list_t<decl_t> ds, bool top) {
  for (; ds != null; ds = ds->tl) {
    decl_t d = ds->hd;
    switch (d->r) {
    case &Var_d(vd):
      let c_name = vd->name;
      // strip any namespace from an extern C declaration
      if (vd->sc == ExternC) 
	c_name = new $(abs_ns,(*c_name)[1]);
      if (vd->initializer != null)
	exp_to_c(nv, (exp_t)vd->initializer);
      if (!nv->toplevel)
        impos("decls_to_c: not at toplevel!");
      nv = add_varmap(nv,vd->name,varb_exp(c_name,new Global_b(vd),DL));
      vd->name = c_name;
      vd->sc   = scope_to_c(vd->sc);
      vd->type = typ_to_c_array(vd->type);
      result_decls = new List(d,result_decls);
      break;
    case &Fn_d(fd):
      // extern C declarations are not placed in a namespace
      let c_name = fd->name;
      if (fd->sc == ExternC)
	c_name = new $(abs_ns,(*c_name)[1]);
      nv = add_varmap(nv,fd->name,var_exp(c_name,DL));
      fd->name = c_name;
      fndecl_to_c(nv, fd);
      result_decls = new List(d,result_decls);
      break;
    case &Let_d(_,_,_,_,_):
      // this is handled in stmt_to_c
      toc_impos("letdecl");
      break;
    case &Struct_d(sd):
      structdecl_to_c(sd);
      result_decls = new List(d,result_decls);
      break;
    case &Union_d(ud):
      uniondecl_to_c(ud);
      result_decls = new List(d,result_decls);
      break;
    case &Tunion_d(tud):
      if(tud->is_xtunion)
	xtuniondecl_to_c(tud);
      else
	tuniondecl_to_c(tud);
      break;
    case &Enum_d(ed):
      enumdecl_to_c(nv,ed);
      result_decls = new List(d,result_decls);
      break;
    case &Typedef_d(td):
      td->name = td->name;
      td->tvs  = null;
      td->defn = typ_to_c_array(td->defn);
      result_decls = new List(d,result_decls);
      break;
    case &Namespace_d(_,ds2): fallthru(ds2);
    case &Using_d(_,ds2):     fallthru(ds2);
    case &ExternC_d(ds2):
      nv = decls_to_c(nv,ds2,top);
      break;
    }
  }
  return nv;
}

// initialize all globals
static void init() {
  result_decls = null;
  tuple_types = null;
  tuple_type_counter = 0;
  tagged_ptr_types = null;
  tagged_ptr_counter = 0;
  temp_var_counter = 0;
  fresh_label_counter = 0;
  structs_so_far = null;
  tunions_so_far = null;
  xtunion_fields_so_far = null;
}

// The entry point:  translate the list of Cyclone declarations to
// a list of C declarations.
//
// FIX:  right now, any types that are generated for tuple types or
// tagged array types are added at the beginning of the declaration
// list.  It's not clear that this respects C's scope rules.  For
// instance, one of the tuple types might contain a forward reference
// to a struct type...  (I think this is okay, though.)
list_t<decl_t> toc(list_t<decl_t> ds) {
  init();
  decls_to_c(empty_env(),ds,true);
  // add the struct definitions for tuples and tagged arrays to the
  // beginning of the declarations.
  return imp_rev(result_decls);
}

