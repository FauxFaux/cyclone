// Type checking for patterns

#include "core.h"
#include "list.h"
#include "dict.h"
#include "set.h"
#include "string.h"
#include "position.h"
#include "absyn.h"
#include "absynpp.h"
#include "tcutil.h"
#include "tcenv.h"
#include "tcexp.h"
#include "tcpat.h"
#include "stdio.h"

namespace Tcpat;

using Core;
using List;
using Set;
using Position;
using Absyn;
using Absynpp;
using Tcutil;
using Tcenv;
using Tcexp;
using Stdio;

/////////////////////////////////////////////////////////////////////////
// type-check a pattern and return a list of the bound type variables,
// and a list of the bound value variables, their types, and any
// qualifiers (e.g., const).
/////////////////////////////////////////////////////////////////////////
static $(list_t<designator>,pat)@ null_designator(pat p) {
  return &$(null,p);
}
static var get_name(vardecl vd) {
  return (*vd->name)[1];
}
// FIX:  should pass in a topt and use it as we do with tcExp
$(list_t<tvar>, list_t<vardecl>)@ tcPat(tenv_t te,pat p, typ *`p region_opt) {
  typ t;
  list_t<tvar>    tv_result = null;
  list_t<vardecl> v_result  = null;

  // Figure out what t should be; assign to p->topt and return after switch
  switch (p->r) {
  case Wild_p:      t = new_evar(MemKind); break;
  case Int_p(s,i):  t = (s == Unsigned) ? uint_t : sint_t; break;
  case Char_p(c):   t = uchar_t; break;
  case Float_p(s):  t = float_t; break;
  case Null_p:
    t = PointerType(PtrInfo{new_evar(AnyKind),new_evar(RgnKind),
			    new_conref(true),empty_tqual(),empty_conref()}); 
    break;
  case Var_p(vd):
    t = new_evar(MemKind);
    vd->type   = t;
    vd->tq     = empty_tqual();
    vd->shadow = 0; // FIX?!?!?
    v_result = &List(vd,v_result);
    break;
  case Reference_p(vd):
    t = new_evar(MemKind);
    if(region_opt == null) {
      terr(p->loc, "* pattern would point into an unknown region");
      break;
    }
    vd->type   = PointerType(PtrInfo{t,*region_opt,new_conref(false),
				     empty_tqual(),empty_conref()});
    vd->tq     = empty_tqual();
    vd->shadow = 0; // FIX?!?!?
    v_result = &List(vd,v_result);
    break;

  case Pointer_p(p2):
    // we put in an unconstrained region.  Then the client calls
    // check_pat_regions after unifying against the type they're destructuring.
    typ ptr_rgn = new_evar(RgnKind);
    let &$(sub_tvs,sub_vs) = tcPat(te,p2,&ptr_rgn);
    tv_result = List::append(tv_result, sub_tvs);
    v_result  = List::append(v_result,  sub_vs);
    t = PointerType(PtrInfo{p2->topt->v, ptr_rgn, empty_conref(), 
			    empty_tqual(), empty_conref()});
    break;

  case Tuple_p(ps):
    list_t<$(tqual,typ)@> ts = null;
    for(; ps != null; ps=ps->tl) {
      let &$(sub_tvs,sub_vs) = tcPat(te,ps->hd,region_opt);
      tv_result = List::append(tv_result, sub_tvs);
      v_result  = List::append(v_result,  sub_vs);
      ts = &List(&$(empty_tqual(),ps->hd->topt->v),ts);
    }
    t = TupleType(List::imp_rev(ts));
    break;

  case Struct_p(sd, *topt_ref,tvs,dps): 
    if (tvs != null)
      return impos("tcPat: struct<...> not implemented");
    // type check the argument patterns
    for (_ dps0 = dps; dps0 != null; dps0 = dps0->tl) {
      let &$(sub_tvs,sub_vs) = tcPat(te,(*dps0->hd)[1],region_opt);
      tv_result = List::append(tv_result, sub_tvs);
      v_result  = List::append(v_result,  sub_vs);
    }
    // build up the instantiated pattern type
    _ all_inst = List::map(make_inst_var,sd->tvs);
    _ all_typs = List::map(snd,all_inst); 
    *topt_ref = &Opt(all_typs); // side effect
    t = StructType(sd->name->v,all_typs,(structdecl@)(&$(sd)));
    // unify with the struct type
    list_t<$($(field_name,tqual,typ)@,pat)@> fields = 
      resolve_struct_designators(p->loc,dps,sd);
    for(; fields != null; fields = fields->tl) {
      let &$(&$(n,tq,fieldtyp),p_arg) = fields->hd;
      _ inst_fieldtyp = substitute(all_inst,fieldtyp);
      if (!unify(p_arg->topt->v,inst_fieldtyp))
	terr(p->loc,
	     xprintf("field %s of struct pattern expects type %s != %s",
		     *n, typ2string(inst_fieldtyp), 
		     typ2string(p_arg->topt->v)));
    }
    break;

    // FIX: some day enums and xenums might not point into the heap.
  case Enum_p(q,_,tvs,ps,ed,ef): 
    typ heap = HeapRgn;
    tenv_t te2 = add_type_vars(p->loc,te,tvs);
    tv_result = List::append(tv_result, tvs);
    _ all_inst = List::map(make_inst_var,ed->tvs);
    _ all_typs = List::map(snd,all_inst); 
    t = EnumType(ed->name->v,all_typs,(enumdecl@)(&$(ed)));
    list_t<$(tqual,typ)@> tqts = ef->typs;
    for(; ps != null && tqts != null; ps = ps->tl, tqts = tqts->tl) {
      _ p2 = ps->hd;
      let &$(sub_tvs,sub_vs) = tcPat(te2,p2,&heap);
      tv_result = List::append(tv_result, sub_tvs);
      v_result  = List::append(v_result,  sub_vs);
      _ field_typ = substitute(all_inst,(*tqts->hd)[1]);
      if (!unify(p2->topt->v,field_typ))
        terr(p2->loc, xprintf("%s expects argument type %s, not %s",
			      qvar2string(q), 
			      typ2string(field_typ),
			      typ2string(p2->topt->v)));
    }
    if (ps != null)
      terr(p->loc,xprintf("too many arguments for enum constructor %s",
			  qvar2string(q)));
    if (tqts != null)
      terr(p->loc,xprintf("too few arguments for enum constructor %s",
			  qvar2string(q)));
    break;
  case Xenum_p(q,tvs,ps,xed,ef): 
    typ heap = HeapRgn;
    tenv_t te2 = add_type_vars(p->loc,te,tvs);
    tv_result = List::append(tv_result, tvs);
    t = XenumType(xed->name,(xenumdecl@)(&$(xed)));
    list_t<$(tqual,typ)@> tqts = ef->typs;
    for(; ps != null && tqts != null; ps = ps->tl, tqts = tqts->tl) {
      _ p2 = ps->hd;
      let &$(sub_tvs,sub_vs) = tcPat(te2,p2,&heap);
      tv_result = List::append(tv_result, sub_tvs);
      v_result  = List::append(v_result,  sub_vs);
      _ field_typ = (*tqts->hd)[1];
      if (!unify(p2->topt->v,field_typ))
        terr(p2->loc,
             xprintf("%s expects argument type %s, not %s",
                     qvar2string(q),typ2string(field_typ),
                     typ2string(p2->topt->v)));
    }
    if (ps != null)
      terr(p->loc,xprintf("too many arguments for xenum constructor %s",
			  qvar2string(q)));
    if (tqts != null)
      terr(p->loc,xprintf("too few arguments for xenum constructor %s",
			  qvar2string(q)));
    break;

  case UnknownId_p(q):
    try switch (lookup_ordinary(te,p->loc,q)) {
    case StructRes(_):
      terr(p->loc,"struct tag used without arguments in pattern");
      t = wildtyp();
      break;
    case EnumRes(ed,ef):
      p->r = Enum_p(ef->name,null,null,null,ed,ef);
      return tcPat(te,p,region_opt);
    case XenumRes(xed,ef):
      p->r = Xenum_p(ef->name,null,null,xed,ef);
      return tcPat(te,p,region_opt);
    case VarRes(_):
      // The pattern variable has already been declared
      switch ((*q)[0]) {
        // If the variable is not qualified, then we consider
        // this a declaration that shadows the outer declaration,
        // without warning.
      case Loc_n: fallthru;
      case Rel_n(null):
        (*q)[0] = Loc_n;        
        p->r = Var_p(new_vardecl(q,VoidType,null));
        return tcPat(te,p,region_opt); // sets the vardecl's fields correctly
      default:
        // Otherwise the variable is qualified and it has already
        // been declared.  We don't allow this.
        terr(p->loc,"qualified variable in pattern");
        break;
      }
      terr(p->loc,
           xprintf("unresolved identifier %s in pattern",qvar2string(q)));
      t = wildtyp();
      break;
    } catch {
    case Dict::Absent:
      // unbound variable in pattern
      switch ((*q)[0]) {
        // If the variable is unqualified, it declares a new variable
      case Loc_n: fallthru;
      case Rel_n(null):
        (*q)[0] = Loc_n;        
        p->r = Var_p(new_vardecl(q,VoidType,null));
        return tcPat(te,p,region_opt); // sets the vardecl's fields correctly
      default:
        // Otherwise it's an error
        terr(p->loc,
             xprintf("unbound identifier %s in pattern",qvar2string(q)));
        t = wildtyp();
        break;
      }
      break;
    }  
    break;
  case UnknownCall_p(q,tvs,ps):
    try switch (lookup_ordinary(te,p->loc,q)) {
    case StructRes(sd):
      let x = List::map(null_designator, ps);
      p->r = Struct_p(sd,null,tvs,x);
      return tcPat(te,p,region_opt);
    case EnumRes(ed,ef):
      p->r = Enum_p(ef->name,null,tvs,ps,ed,ef);
      return tcPat(te,p,region_opt);
    case XenumRes(xed,ef):
      p->r = Xenum_p(ef->name,tvs,ps,xed,ef);
      return tcPat(te,p,region_opt);
    case VarRes(_):
      break;
    } catch {case Dict::Absent: break;}
    terr(p->loc,
         xprintf("%s is not a constructor in pattern",qvar2string(q)));
    t = wildtyp();
    break;
  case UnknownFields_p(q,tvs,dps):
    try switch (lookup_ordinary(te,p->loc,q)) {
    case StructRes(sd):
      p->r = Struct_p(sd,null,tvs,dps);
      return tcPat(te,p,region_opt);
    case EnumRes(ed,ef):
      terr(p->loc,"enum with designators not implemented");
      t = wildtyp();
      break;
    case XenumRes(xed,ef):
      terr(p->loc,"xenum with designators not implemented");
      t = wildtyp();
      break;
    case VarRes(_):
      terr(p->loc,
           xprintf("unbound struct %s in pattern",qvar2string(q)));
      t = wildtyp();
      break;
    } catch {case Dict::Absent:
      terr(p->loc,
           xprintf("unbound struct %s in pattern",qvar2string(q)));
      t = wildtyp();
      break;
    }      
    break;
  }
  p->topt = &Opt(t);
  check_unique_vars(List::map(get_name, v_result), p->loc,
		    "pattern contains a repeated variable");
  return &$(tv_result,v_result);
}

void check_pat_regions(tenv_t te, pat p) {
  switch(p->r) {
  case Pointer_p(p2):
    check_pat_regions(te,p2);
    switch (p->topt->v) {
    case PointerType(PtrInfo{_,rt,_,_,_}):
      check_rgn_accessible(te,p->loc,rt);
      return;
    default: throw Core::Impossible("check_pat_regions: bad pointer type");
    }
  case Struct_p(_,_,_,dps):  fallthru(List::map(snd,dps));
  case Xenum_p(_,_,ps,_,_):  fallthru(ps);
  case Enum_p(_,_,_,ps,_,_): fallthru(ps);
  case Tuple_p(ps):
    for(; ps != null; ps = ps->tl)
      check_pat_regions(te,ps->hd);
    return;
  default: return;
  }
}

//static void print_pats(string s, list_t<pat> ps) {
//  fprintf(cyc_stderr,"---pat list: %s---\n",s);
//  for (; ps != null; ps = ps->tl)
//    fprintf(cyc_stderr,"%s\n",pat2string(ps->hd));
//  fprintf(cyc_stderr,"--------------------------------\n\n");
//}

// The rest of this is for match compilation -- this seems to be
// the easiest way to check for overlapping or inexhaustive patterns.
// These ideas are lifted from Peter Sestoft's paper "ML pattern
// match compilation and partial evaluation", which appeared in
// Dagstuhl Seminar on Partial Evaluation, LNCS, Springer-Verlag,
// March 1996.  See
// ftp://ftp.dina.kvl.dk/pub/Staff/Peter.Sestoft/papers/match.ps.gz

// FIX:  we need short, long, and double patterns.  In addition, we
// should really allow constant-expressions in patterns, and we should
// allow integral promotion on integral patterns.  Still need
// to deal with FALLTHRU's, etc.  We should probably also hash-cons
// as suggested by Sestoft to avoid a potential exponential space
// blow-up, and the traversal of the decision tree should be turned
// into a depth-first dag traversal to avoid an exponential time
// blow-up.  We should hang on to the decision tree so that the
// compiler can make effective use of it.  We should generalize the
// access to a "switch" (instead of just an "if").  We should
// look at the MacQueen paper to do a better job of ordering the tests.

// We compile down to simple patterns for exhaustive/overlap checks.
// Any's represent variables or wild-cards, whereas Con's represent
// everything else.
// The "name" of the con is an integer or string.
// The arity is the number of arguments the constructor has, and the
// span is the total number of constructors for the given type.
// Constant patterns (e.g., 1, true, 3[0]4) have 0 arity.  The span
// for bool is 2, for char is 256, and for integers, floats, and
// Xenums is infinite (i.e., null).
static enum Name_value { Name_v(string); Int_v(int); };
typedef enum Name_value name_value_t;
static struct Con_s {
  name_value_t name;
  int          arity;
  opt_t<int>   span;
};
typedef struct Con_s @con_t;
static enum Simple_pat { Any; Con(con_t,list_t<enum Simple_pat>); };
typedef enum Simple_pat simple_pat_t;

// used for creating sets of constructors
static int compare_con(con_t c1, con_t c2) {
  switch (c1->name) {
  case Name_v(n1):
    switch (c2->name) {
    case Name_v(n2): return String::zstrcmp(n1,n2);
    case Int_v(_):   return -1;
    }
  case Int_v(i1):
    switch (c2->name) {
    case Name_v(_): return 1;
    case Int_v(i2): return i1 - i2;
    }
  }
}

// build various cons
static Set::set_t<con_t> empty_con_set() { return Set::empty(compare_con); }

static struct Opt<int> one_opt = { 1 };
static struct Opt<int> two_opt = { 2 };
static opt_t<int> one_opt_ptr = &one_opt;

static name_value_t tuple_name = Name_v("tuple") ;

static struct Con_s null_con0     = { Name_v("null"),  0, &two_opt };
static struct Con_s null_ptr_con0 = { Name_v("ptr"),   1, &two_opt };
static struct Con_s ptr_con0      = { Name_v("ptr"),   1, &one_opt };

static con_t null_con     = &null_con0;
static con_t null_ptr_con = &null_ptr_con0;
static con_t ptr_con      = &ptr_con0;

static con_t int_con(int i)       { return &Con_s(Int_v(i),      0, null); }
static con_t char_con(char c)     { return &Con_s(Int_v((int)c), 0, &Opt(256));}
static con_t float_con(string f)  { return &Con_s(Name_v(f),  0, null); }
static con_t double_con(string d) { return &Con_s(Name_v(d),  0, null); }
static con_t tuple_con(int i)     { return &Con_s(tuple_name, i, one_opt_ptr); }

// build various simple patterns
static simple_pat_t null_pat()           { return Con(null_con,      null); }
static simple_pat_t int_pat(int i)       { return Con(int_con(i),    null); }
static simple_pat_t char_pat(char c)     { return Con(char_con(c),   null); }
static simple_pat_t float_pat(string f)  { return Con(float_con(f),  null); }
static simple_pat_t double_pat(string d) { return Con(double_con(d), null); }

static simple_pat_t null_ptr_pat(simple_pat_t p) {
  return Con(null_ptr_con,&List(p,null));
}
static simple_pat_t ptr_pat(simple_pat_t p) { 
  return Con(ptr_con,&List(p,null)); 
}
static simple_pat_t tuple_pat(list_t<simple_pat_t> ss) {
  return Con(tuple_con(List::length(ss)),ss);
}
static 
simple_pat_t con_pat(string con_name,opt_t<int> span,list_t<simple_pat_t> ps) {
  con_t c = &Con_s(Name_v(con_name), List::length(ps), span);
  return Con(c,ps);
}

// compile a Cyclone pattern to a simple pattern
static simple_pat_t compile_pat(pat p) {
  simple_pat_t s;
  switch (p->r) {
  case Wild_p:         s = Any; break;
  case Var_p(_):       s = Any; break;
  case Null_p:         s = null_pat(); break;
  case Int_p(sn,i):    s = int_pat(i); break;
  case Char_p(c):      s = char_pat(c); break;
  case Float_p(f):     s = float_pat(f); break;
  case Tuple_p(ps):    s = tuple_pat(List::map(compile_pat,ps)); break;
  case Reference_p(_): s = Any; break;
  case Pointer_p(pp):
    simple_pat_t ss = compile_pat(pp);
    switch (compress(p->topt->v)) {
    case PointerType(PtrInfo{_,_,n,_,_}):
      bool is_nullable = false;
      bool still_working = true;
      while (still_working) {
	switch (n->v) {
	case Forward_constr(y): 
	  n->v = y->v; 
	  continue;
	case No_constr:
          n->v = Eq_constr(false);
          is_nullable   = false;
          still_working = false;  // EXIT LOOP
          break;
	case Eq_constr(x):
          is_nullable   = (bool)x;
          still_working = false;  // EXIT LOOP
          break;
	}
      }
      if (is_nullable) 
	s = null_ptr_pat(ss);
      else 
	s = ptr_pat(ss);
      break;
    default: s = impos("pointer pattern does not have pointer type!"); break;
    }
    break;
  case Struct_p(sd,_,_,dlps):
    list_t<simple_pat_t> ps = null;
    for (_ fields = sd->fields->v; fields != null; fields = fields->tl) {
      bool found = false;
      for(_ dlps0 = dlps; !found && dlps0 != null; dlps0 = dlps0->tl) {
	let &$(dl,p) = dlps0->hd;
	switch (dl) {
	case &List{.hd=FieldName(f), .tl=null}: 
	  if(String::zstrptrcmp(f,(*fields->hd)[0]) == 0) {
	    ps = &List(compile_pat(p),ps);
	    found = true;
	  }
	  break;
	default: impos("bad designator(s)"); break;
	}
      }
      if(!found)
	impos("bad designator");
    }
    s = tuple_pat(ps);
    break;
  case Enum_p(_,_,_,ps,ed,ef):
    int span = List::length(ed->fields->v);
    s = con_pat(*((*ef->name)[1]),&Opt(span),List::map(compile_pat,ps)); 
    break;
  case Xenum_p(_,_,ps,xd,ef):
    s = con_pat(*((*ef->name)[1]),null,List::map(compile_pat,ps)); 
    break;
  case UnknownId_p(_):         s = impos("compile_pat: unknownid");     break;
  case UnknownCall_p(_,_,_):   s = impos("compile_pat: unknowncall");   break;
  case UnknownFields_p(_,_,_): s = impos("compile_pat: unknownfields"); break;
  }
  return s;
}

// A match is a list of patterns and their right-hand sides.  We
// parameterize over right-hand sides to make the code re-usable
// for compilation later on.  What we should really do is go ahead
// and compile to a decision tree and attach this to the abstract
// syntax...
#define match_t(rhs) list_t<$(simple_pat_t,rhs)@>
// A term descriptor describes a set of values using positive and/or
// negative information.  The descriptor Pos(c,[td1,...,tdn]) describes
// all values v of the form c(v1,...,vn), where vi is in the set
// described by tdi.  The descriptor Neg[c1,...,cn] describes all
// values v that are not of the form ci(v1,...,vm) (1 <= i <= n).
// Note that Neg[] denotes any possible value.
enum Term_desc {
  Pos(con_t,list_t<enum Term_desc>);
  Neg(Set::set_t<con_t>);
};
typedef enum Term_desc term_desc_t;

// Contexts represent a partial term-description matched thus far,
// from the root node of the object in a left-to-right fashion.
#define context_t list_t<$(con_t,list_t<term_desc_t>)@>
// A decision tree for compiling pattern-matches.  Failure denotes
// that an exception should be thrown.  Success triggers a right-hand-side.
// IfEq is a constructor test -- conceptually, the access path is a sequence
// of projections applied to the root object to get at the field being
// tested -- this will eventually have to change to have enough type
// information to really generate the right code.
static enum Access { Obj; Sel(int, enum Access); }; // just an int list really
typedef enum Access access_t;

static enum Decision<`rhs> {
  Failure;
  Success(`rhs);
  IfEq(access_t, con_t, enum Decision<`rhs>, enum Decision<`rhs>);
};
typedef enum Decision<`rhs> decision_t<`rhs>;

// A work_stack records what tests we have to continue to do.  An
// implicit invariant is that for each frame on the stack, the
// length of the pattern, access, and term_desc lists are the same.
#define work_stack_frame $(list_t<simple_pat_t>,list_t<access_t>,list_t<term_desc_t>)@
#define work_stack list_t<work_stack_frame>
// Used during primitive match compilation
static enum Answer { Yes, No, Maybe };
typedef enum Answer answer_t;

// Add c to a set of negative constructors for a term description.
// Assumes that td is a negative term description, that c is not
// already in the set, and that adding c does not cover all of the
// possible constructors.
static term_desc_t add_neg(term_desc_t td, con_t c) {
  switch (td) {
  case Neg(cs):
    if (Set::member(cs,c))
      impos("add_neg called when constructor already in set");
    if (c->span != null && (Set::cardinality(cs) + 1) >= c->span->v)
	impos("add_neg called when |cs U {c}| >= span(c)");
    return Neg(Set::insert(cs,c));
  case Pos(_,_): return impos("add_neg called when td is Positive");
  }
}

// Returns whether or not values that start with constructor c are in the set
// described by the term descriptor td.
static answer_t static_match(con_t c, term_desc_t td) {
  switch (td) {
  case Pos(c2,_):
    // td is the set of all values that start with c2
    if (compare_con(c,c2) == 0) return Yes;
    else return No;
  case Neg(cs):
    // td is the set of all values that do not start with any of the cons in cs
    if (Set::member(cs,c)) return No;
    // when there are n possible starting constructors, c is not in cs,
    // and |cs| = n-1, then we know that c has to be in the set described by td
    else if ((c->span != null) && (c->span->v == Set::cardinality(cs) + 1))
      return Yes;
    // otherwise, we can't be sure.
    else return Maybe;
  }
}

// Add dsc to the current node in the context -- note that this node
// is always at the beginning of the context.  Furthermore, the current
// node's sub-term-descriptors are in reverse order.  Thus, we just
// cons the dsc onto the first con's list of sub-term-desc's.
static context_t augment(context_t ctxt, term_desc_t dsc) {
  switch (ctxt) {
  case null: return null; // ???
  case &List{.hd=&$(c,args), .tl=rest}:
    return &List(&$(c,(list_t<term_desc_t>)&List(dsc, args)),rest);
  }
}

// When argument descriptions [dn,dn-1,...,d2,d1] have been found
// for all arguments of the local-most constructor c, we turn it
// into a positive descriptor Pos(c,[d1,d2,...,dn-1,dn]).
static context_t norm_context(context_t ctxt) {
  switch (ctxt) {
  case null: return impos("norm_context: empty context");
  case &List{.hd=&$(c,args), .tl=rest}: 
    return augment(rest, Pos(c, List::rev(args)));
  }
}

// When moving from one match rule to another, we must re-construct the
// object description from the context (describes the part of the object
// up to the left of the current subterm), the current subterm description,
// and the term descriptions on the work stack, which, when taken together,
// describe the object to the right of the current subterm.
static term_desc_t build_desc(context_t ctxt, term_desc_t dsc, work_stack work)
{
  switch ($(ctxt,work)) {
  case $(null,null): return dsc;
  case $(null,_):    return impos("build_desc: ctxt and work don't match");
  case $(_,   null): return impos("build_desc: ctxt and work don't match");
  case $(&List{.hd=&$(c,args), .tl=rest}, &List{.hd=&$(_,_,dargs), .tl=work2}):
    let td = Pos(c, List::append(List::rev(args), &List(dsc,dargs)));
    return build_desc(rest, td, work2);
  } 
}

static decision_t<`rhs> // forward declaration
match(simple_pat_t p, access_t obj, term_desc_t dsc, context_t ctx, 
      work_stack work, `rhs right_hand_side, match_t(`rhs) rules);

// Checks to see that the term (thus far described by dsc) matches one
// of the match_t rules.
static decision_t<`rhs> or_match(term_desc_t dsc, match_t(`rhs) allmrules)
{
  switch(allmrules) {
  case null: return Tcpat::Failure;
  case &List{.hd = &$(pat1, rhs1), .tl = rulerest}:
    return match(pat1, Obj, dsc, null, null, rhs1, rulerest);
  }
}

// Compiles a set of match rules to a decision tree.
static decision_t<`rhs> match_compile(match_t(`rhs) allmrules) {
  return or_match(Neg(empty_con_set()), allmrules);
}

// Succeeds returning the right-hand-side if every pattern matches the
// associated term-description in the work stack, or else the original
// object matches some rule from rules.
static decision_t<`rhs> and_match(context_t ctx, work_stack work,
				    `rhs right_hand_side, match_t(`rhs) rules) {
  switch (work) {
  case null: return Success(right_hand_side);
  case &List{.hd = &$(null,null,null), .tl = workr }:
    return and_match(norm_context(ctx), workr, right_hand_side, rules);
  case &List{.hd = &$(pats,objs,dscs), .tl = workr }:
    if (pats == null || objs == null || dscs == null)
      return impos("tcpat:and_match: malformed work frame");    
    let &List(pat1,patr) = (_@)(pats);
    let &List(obj1,objr) = (_@)(objs);
    let &List(dsc1,dscr) = (_@)(dscs);
    let wf = &$(patr, objr, dscr);
    return match(pat1,obj1,dsc1,ctx,&List(wf,workr),right_hand_side,rules);
  } 
}

// Get the term description arguments for a constructor term-description.
static list_t<term_desc_t> getdargs(con_t pcon, term_desc_t dsc) {
  switch (dsc) {
  case Neg(ncs):
    // We only know that the term is con which is never in the set ncs.
    // So return Neg{} for each argument, reflecting that no information
    // is known about the arguments.
    term_desc_t any = Neg(empty_con_set());
    let res = null;
    for (int i = 0; i < pcon->arity; ++i)
      res = &List(any,res);
    return res;
  case Pos(_, dargs): return dargs;
  }
}

// Compute the paths for each argument when disassembling a constructor.
static access_t getoarg(access_t obj, int i) {
  return Sel(i+1,obj);
}
static list_t<access_t> getoargs(con_t pcon, access_t obj) {
  return List::tabulate_c(pcon->arity, getoarg, obj);
}

// Succeeds returning the right-hand-side if the pattern matches the
// description and every pattern matches the associated description
// in the work stack, or if the original object matches one of the rules.
static decision_t<`rhs> 
match(simple_pat_t p, access_t obj, term_desc_t dsc,
      context_t ctx, work_stack work,
      `rhs right_hand_side, match_t(`rhs) rules) {
  switch (p) {
  case Any: return and_match(augment(ctx, dsc), work, right_hand_side, rules);
  case Con(pcon, pargs):
    switch (static_match(pcon, dsc)) {
    case Yes:
      let ctx2       = &List(&$(pcon,null), ctx);
      let work_frame = &$(pargs, getoargs(pcon, obj), getdargs(pcon, dsc));
      let work2      = &List(work_frame, work);
      return and_match(ctx2, work2, right_hand_side, rules);
    case No:
      return or_match(build_desc(ctx, dsc, work), rules);
    case Maybe:
      let ctx2       = &List(&$(pcon,null), ctx);
      let work_frame = &$(pargs, getoargs(pcon, obj), getdargs(pcon, dsc));
      let work2      = &List(work_frame, work);
      let s          = and_match(ctx2, work2, right_hand_side, rules);
      let f          = or_match(build_desc(ctx, add_neg(dsc,pcon), work), rules);
      return IfEq(obj, pcon, s, f);
    }
  }
}

// Given a decision tree, call not_exhaust for each Failure node
// and call rhs_appears for each Success node.  Note that Failure
// implies the patterns are not exhaustive.  Note also that if
// any rhs for a match does not show up in the decision tree, then
// the associated pattern was redundant.
static 
void check_exhaust_overlap(decision_t<`rhs> d,
                           void not_exhaust(`a),      `a env1,
                           void rhs_appears(`b,`rhs), `b env2) {
  switch (d) {
  case Tcpat::Failure: not_exhaust(env1);   break;
  case Success(r):     rhs_appears(env2,r); break;
  case IfEq(_,_,left,right):
    check_exhaust_overlap(left,  not_exhaust, env1, rhs_appears, env2);
    check_exhaust_overlap(right, not_exhaust, env1, rhs_appears, env2);
    break;
  }
}

// Builds the decision tree for the switches, then checks to see
// if there are any failure nodes (pattern is inexhaustive) or if
// any pattern doesn't show up in the tree (pattern is redundant.)
// Both are considered errors as far as the type-checker is concerned.
static 
$(simple_pat_t, $(bool,seg_t)@)@ get_match(int @ r, switch_clause swc) {
  simple_pat_t sp0 = compile_pat(swc->pattern);
  $(bool,seg_t)@ rhs = &$(false,swc->pattern->loc);
  simple_pat_t sp;
  if (swc->where_clause != null) {
    sp = tuple_pat(&List(sp0,&List(int_pat(*r),null)));
    *r = (*r) + 1;
  } else
    sp = tuple_pat(&List(sp0,&List(Any,null)));
  return &$(sp, rhs);
}
static void not_exhaust_err(seg_t loc) {
  terr(loc,"patterns may not be exhaustive");
}
static void rule_occurs(int dummy, $(bool,seg_t)@ rhs) {
  (*rhs)[0] = true;
}
void check_switch_exhaustive(seg_t loc, list_t<switch_clause> swcs) {
  // We represent "pat && e" as (simple_pat,i) where i is a unique integer.
  // We represent patterns without where clauses as (simple_pat,_).
  // This way, if we have the same pattern repeated, we get exhuastiveness
  // right as long as one of the copies does not have a where-clause.
  let match_rules = List::map_c(get_match,(int @)&$(0),swcs);
  let dec_tree    = match_compile(match_rules);
  check_exhaust_overlap(dec_tree, not_exhaust_err, loc, rule_occurs, 0);
  for (; match_rules != null; match_rules = match_rules->tl) {
    let &$(b,loc) = (*match_rules->hd)[1];
    if (!b)
      terr(loc,"redundant pattern");
  }
}

// Build the decision tree for the pattern.  If Failure occurs, then
// the pattern is not exhaustive (a warning).  There's no way to get
// something that's redundant (unless we add support for "or" patterns
// of some sort.)
static void not_exhaust_warn($(seg_t, bool) @ pr) {
  (*pr)[1] = false;
  warn((*pr)[0],"pattern not exhaustive");
}
static void dummy_fn(int i,int j) {
  return;
}
bool check_let_pat_exhaustive(seg_t loc,pat p) {
  let match_rules = &List(&$(compile_pat(p),0),null);
  let dec_tree    = match_compile(match_rules);
  let exhaust_env = &$(loc,true);
  check_exhaust_overlap(dec_tree, not_exhaust_warn, exhaust_env, dummy_fn, 0);
  return (*exhaust_env)[1];
}

// Check that the patterns in a catch switch are non-overlapping.
// There's an implicit "re-throw on wild" pattern here, so no need
// to check for exhaustiveness.
static $(simple_pat_t, $(bool,seg_t)@)@ get_match2(switch_clause swc) {
  simple_pat_t sp0 = compile_pat(swc->pattern);
  $(bool,seg_t)@ rhs = &$(false,swc->pattern->loc);
  return &$(sp0, rhs);
}
static void not_exhaust_err2(seg_t loc) {
  ; // skip
}
void check_catch_overlap(seg_t loc, list_t<switch_clause> swcs) {
  // We ignore where clauses here because catch's need not be exhaustive.
  let match_rules = List::map(get_match2,swcs);
  let dec_tree    = match_compile(match_rules);
  check_exhaust_overlap(dec_tree, not_exhaust_err2, loc, rule_occurs, 0);
  for (; match_rules != null; match_rules = match_rules->tl) {
    let pair = (*match_rules->hd)[1];
    if (!(*pair)[0])
      terr((*pair)[1],"redundant pattern");
  }
}
