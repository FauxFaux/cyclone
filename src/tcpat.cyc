// Type checking for patterns

#include "core.h"
#include "list.h"
#include "dict.h"
#include "set.h"
#include "string.h"
#include "position.h"
#include "absyn.h"
#include "absynpp.h"
#include "tcutil.h"
#include "tcenv.h"
#include "tcexp.h"
#include "tcpat.h"
#include "stdio.h"

namespace Tcpat;

using Core;
using List;
using Set;
using Position;
using Absyn;
using Absynpp;
using Tcutil;
using Tcenv;
using Tcexp;
using Stdio;

/////////////////////////////////////////////////////////////////////////
// type-check a pattern and return a list of the bound type variables,
// and a list of the bound value variables, their types, and any
// qualifiers (e.g., const).
/////////////////////////////////////////////////////////////////////////
static var_t get_name(vardecl_t vd) {
  return (*vd->name)[1];
}
static type_t any_type(type_t *`r topt) {
  if(topt != null)
    return *topt;
  return new_evar(MemKind);
}
static type_t num_type(type_t *`r topt, type_t numt) {
  // by setting to whatever topt is, unification will succeed.  Because
  // comparison between any two num types succeeds, this is fine (but kludgey)
  // FIX:? Allow *topt to be an Enum ?
  if(topt != null && coerceable(*topt))
    return *topt;
  return numt;
}
static void set_vd(vardecl_t vd, list_t<vardecl_t>@`r v_result_ptr, type_t t){
  vd->type = t;
  vd->tq   = empty_tqual();
  *v_result_ptr = new List(vd,*v_result_ptr);
}
$(list_t<tvar_t>, list_t<vardecl_t>) tcPatRec(tenv_t te,
					      pat_t  p,
					      type_t *`r1 topt,
					      type_t *`r2 region_opt) {
  type_t t;
  list_t<tvar_t>    tv_result = null;
  list_t<vardecl_t> v_result  = null;

  // Figure out what t should be; assign to p->topt and return after switch
  switch (p->r) {
  case &Int_p(Unsigned,_): t = num_type(topt, uint_t);  break;
  case &Int_p(Signed,_):   t = num_type(topt, sint_t);  break;
  case &Char_p(_):         t = num_type(topt, uchar_t); break;
  case &Float_p(_):        t = num_type(topt, float_t); break;
  case Null_p:
    if(topt != null)
      switch(compress(*topt)) {
      case &PointerType(_): t = *topt; goto tcpat_end;
      default: break;
      }
    t = new PointerType(PtrInfo(new_evar(AnyKind),new_evar(RgnKind),
				new_conref(true),empty_tqual(),empty_conref()));
    break;

  case Wild_p:       
    t = any_type(topt);
    break;
  case &Var_p(vd):
    t = any_type(topt);
    set_vd(vd, &v_result, t);
    break;
  case &Reference_p(vd):
    t = any_type(topt);
    if(region_opt == null) {
      terr(p->loc, "* pattern would point into an unknown region");
      break;
    }
    set_vd(vd, &v_result, 
	   new PointerType(PtrInfo(t,*region_opt,new_conref(false),
				     empty_tqual(),empty_conref())));
    break;

  case &Pointer_p(p2):
    type_t inner_typ  = VoidType;
    let    inner_topt = null;
    if(topt != null)
      switch(compress(*topt)) {
      case &PointerType(PtrInfo(elt_typ,_,_,_,_)): 
	inner_typ  = elt_typ; 
	inner_topt = &inner_typ;
	break;
      default: break;
      }
    
    // we put in an unconstrained region.  Then the client calls
    // check_pat_regions after unifying against the type they're destructuring.
    type_t ptr_rgn = new_evar(RgnKind);
    let $(sub_tvs,sub_vs) = tcPatRec(te,p2,inner_topt,&ptr_rgn);
    tv_result = List::append(tv_result, sub_tvs);
    v_result  = List::append(v_result,  sub_vs);
    // if p2's type is a tunion field or xtunion field type, then we cast
    // the type of p = &p2 to the appropriate tunion or xtunion type, unless
    // topt suggests we do otherwise.
    if(inner_topt == null) 
      switch (compress(p2->topt->v)) {
      case &TunionFieldType(TunionFieldInfo{n,tvs,fn,tud,tufd}):
	t = new TunionType(TunionInfo{n,tvs,ptr_rgn,tud});
	break;
      case &XTunionFieldType(XTunionFieldInfo{n,fn,xtud,xtufd}):
	t = new XTunionType(XTunionInfo{n,ptr_rgn,xtud});
	break;
      default:
	t = new PointerType(PtrInfo{p2->topt->v, ptr_rgn, empty_conref(), 
				    empty_tqual(), empty_conref()});
	break;
      }
    else 
      t = new PointerType(PtrInfo{p2->topt->v, ptr_rgn, empty_conref(), 
      empty_tqual(), empty_conref()});
    break;

  case &Tuple_p(ps):
    list_t<$(tqual_t,type_t)@> pat_ts  = null;
    list_t<$(tqual_t,type_t)@> topt_ts = null;
    if(topt != null)
      switch(compress(*topt)) {
      case &TupleType(tqts): topt_ts = tqts; break;
      default: break;
      }
    for(; ps != null; ps=ps->tl) {
      let inner_topt = null;
      if(topt_ts != null) {
	inner_topt = &(*topt_ts->hd)[1];
	topt_ts    = topt_ts->tl;
      }
      let $(sub_tvs,sub_vs) = tcPatRec(te,ps->hd,inner_topt,region_opt);
      tv_result = List::append(tv_result, sub_tvs);
      v_result  = List::append(v_result,  sub_vs);
      pat_ts = new List(new $(empty_tqual(),ps->hd->topt->v),pat_ts);
    }
    t = new TupleType(List::imp_rev(pat_ts));
    break;

  case &Struct_p(sd,*topt_ref,tvs,dps): 
    // FIX: USE TOPT!
    if (tvs != null)
      throw impos("tcPat: struct<...> not implemented");
    // type check the argument patterns
    for (_ dps0 = dps; dps0 != null; dps0 = dps0->tl) {
      let $(sub_tvs,sub_vs) = tcPatRec(te,(*dps0->hd)[1],null,region_opt);
      tv_result = List::append(tv_result, sub_tvs);
      v_result  = List::append(v_result,  sub_vs);
    }
    // build up the instantiated pattern type
    let all_inst = List::map(make_inst_var,sd->tvs);
    let all_typs = List::map(snd,all_inst); 
    *topt_ref = new Opt(all_typs); // side effect
    t = new StructType(sd->name->v, all_typs, new sd);
    // unify with the struct type
    list_t<$(structfield_t,pat_t)@> fields = 
      resolve_struct_designators(p->loc,dps,sd);
    for(; fields != null; fields = fields->tl) {
      let &$(field,p_arg) = fields->hd;
      let inst_fieldtyp = substitute(all_inst,field->type);
      if (!unify(p_arg->topt->v,inst_fieldtyp))
	terr(p->loc,
	     xprintf("field %s of struct pattern expects type %s != %s",
		     *field->name, typ2string(inst_fieldtyp), 
		     typ2string(p_arg->topt->v)));
    }
    break;

  case &Tunion_p(q,_,tvs,ps,tud,tuf): 
    // FIX: USE TOPT!
    // FIX: alpha-convert existential tyvars
    if(length(tvs) != length(tuf->tvs))
      terr(p->loc,"wrong number of existential type variables in pattern");

    // constrain the type variables to have box kind
    for (_ t = tvs; t != null; t = t->tl) {
      tvar_t tv = t->hd;
      compress_conref(tv->kind);
      switch (tv->kind->v) {
      case &Eq_constr(BoxKind): break;
      case &Eq_constr(k): 
	terr(p->loc,xprintf("tunion member %s abstracts type variable %s of kind %s != B",qvar2string(q),*tv->name,kind2string(k))); 
	break;
      case No_constr: 
	tv->kind->v = new Eq_constr(BoxKind); 
	break;
      case &Forward_constr(_): 
	throw impos("forward after compress in conref");
      }
    }
    // we put in an unconstrained region.  Then the client calls
    // check_pat_regions after unifying against the type they're destructuring.
    tv_result = List::append(tv_result, tvs);
    tenv_t te2      = add_type_vars(p->loc,te,tvs);
    let    all_inst = List::map(make_inst_var,tud->tvs);
    let    all_typs = List::map(snd,all_inst); 
    list_t<$(tqual_t,type_t)@> tqts = tuf->typs;
    // if the constructor has no arguments, then we go ahead and up-cast it
    // to the tunion type, otherwise, we leave it at the field type.  In
    // the latter case, the Pointer pattern does the upcast.
    if (tqts == null) 
      t = new TunionType(TunionInfo{tud->name->v,all_typs,
                                    new_evar(RgnKind),tud});
    else 
      t = new TunionFieldType(TunionFieldInfo{tud->name->v,all_typs,tuf->name,
                                              tud,tuf});
    for(; ps != null && tqts != null; ps = ps->tl, tqts = tqts->tl) {
      let p2 = ps->hd;
      // Note:  we don't pass in ptr_rgn here because for value-carrying
      // constructors, the pointer's region is passed down as region_opt.
      let $(sub_tvs,sub_vs) = tcPatRec(te2,p2,null,region_opt);
      tv_result = List::append(tv_result, sub_tvs);
      v_result  = List::append(v_result,  sub_vs);
      let field_typ = substitute(all_inst,(*tqts->hd)[1]);
      if (!unify(p2->topt->v,field_typ))
        terr(p2->loc, xprintf("%s expects argument type %s, not %s",
			      qvar2string(q), 
			      typ2string(field_typ),
			      typ2string(p2->topt->v)));
    }
    if (ps != null)
      terr(p->loc,xprintf("too many arguments for tunion constructor %s",
			  qvar2string(q)));
    if (tqts != null)
      terr(p->loc,xprintf("too few arguments for tunion constructor %s",
			  qvar2string(q)));
    break;

  case &XTunion_p(q,tvs,ps,xed,ef): 
    // FIX: USE TOPT!
    // FIX: alpha-convert existential tyvars
    if(length(tvs) != length(ef->tvs))
      terr(p->loc,"wrong number of existential type variables in pattern");

    // we put in an unconstrained region.  Then the client calls
    // check_pat_regions after unifying against the type they're destructuring.
    tenv_t te2 = add_type_vars(p->loc,te,tvs);
    tv_result = List::append(tv_result, tvs);
    list_t<$(tqual_t,type_t)@> tqts = ef->typs;
    // the Pointer pattern does the upcast from the field to the xtunion type.
    t = new XTunionFieldType(XTunionFieldInfo{xed->name,ef->name,xed,ef});
    for(; ps != null && tqts != null; ps = ps->tl, tqts = tqts->tl) {
      let p2 = ps->hd;
      // Note:  we don't pass in ptr_rgn here because for value-carrying
      // constructors, the pointer's region is passed down as region_opt.
      let $(sub_tvs,sub_vs) = tcPatRec(te2,p2,null,region_opt);
      tv_result = List::append(tv_result, sub_tvs);
      v_result  = List::append(v_result,  sub_vs);
      let field_typ = (*tqts->hd)[1];
      if (!unify(p2->topt->v,field_typ))
        terr(p2->loc,
             xprintf("%s expects argument type %s, not %s",
                     qvar2string(q),typ2string(field_typ),
                     typ2string(p2->topt->v)));
    }
    if (ps != null)
      terr(p->loc,xprintf("too many arguments for xtunion constructor %s",
			  qvar2string(q)));
    if (tqts != null)
      terr(p->loc,xprintf("too few arguments for xtunion constructor %s",
			  qvar2string(q)));
    break;

  case &Enum_p(q,ed,ef): // FIX? return numeric when topt is numeric??
    t = new EnumType(ed->name,ed);
    break;

  case &UnknownId_p(q):
    try switch (lookup_ordinary(te,p->loc,q)) {
    case &StructRes(_):
      terr(p->loc,"struct tag used without arguments in pattern");
      t = wildtyp();      
      goto tcpat_end;
    case &TunionRes(tud,tuf):
      p->r = new Tunion_p(tuf->name,null,null,null,tud,tuf);
      return tcPatRec(te,p,topt,region_opt);
    case &XTunionRes(xtud,xtuf):
      p->r = new XTunion_p(xtuf->name,null,null,xtud,xtuf);
      return tcPatRec(te,p,topt,region_opt);
    case &EnumRes(ed,ef):
      p->r = new Enum_p(ef->name,ed,ef);
      return tcPatRec(te,p,topt,region_opt);
    case &VarRes(_): // shadows an outer definition, but that's fine
      break;
    } catch { case &Dict::Absent: break; } // a new variable
    // Unqualified variable is a declaration, qualified is an error
    switch ((*q)[0]) {
    case Loc_n: fallthru;
    case &Rel_n(null):
      (*q)[0] = Loc_n;        
      p->r = new Var_p(new_vardecl(q,VoidType,null));
      return tcPatRec(te,p,topt,region_opt);//sets vardecl's fields correctly
    default:
      terr(p->loc,"qualified variable in pattern");
      t = wildtyp();
      break;
    }
    break;
  case &UnknownCall_p(q,tvs,ps):
    try switch (lookup_ordinary(te,p->loc,q)) {
    case &StructRes(sd):
      let new_ps = null;
      for(; ps != null; ps = ps->tl)
	new_ps = new List(new $(null,ps->hd), new_ps);
      p->r = new Struct_p(sd,null,tvs,List::imp_rev(new_ps));
      return tcPatRec(te,p,topt,region_opt);
    case &TunionRes(tud,tuf):
      p->r = new Tunion_p(tuf->name,null,tvs,ps,tud,tuf);
      return tcPatRec(te,p,topt,region_opt);
    case &XTunionRes(xtud,xtuf):
      p->r = new XTunion_p(xtuf->name,tvs,ps,xtud,xtuf);
      return tcPatRec(te,p,topt,region_opt);
    case &EnumRes(_,_):
      terr(p->loc,
           xprintf("bad enum constructor %s in pattern",qvar2string(q)));
      t = wildtyp();
      break;
    case &VarRes(_):
      break;
    } catch {case &Dict::Absent: break;}
    terr(p->loc,
         xprintf("%s is not a constructor in pattern",qvar2string(q)));
    t = wildtyp();
    break;
  case &UnknownFields_p(q,tvs,dps):
    try switch (lookup_ordinary(te,p->loc,q)) {
    case &StructRes(sd):
      p->r = new Struct_p(sd,null,tvs,dps);
      return tcPatRec(te,p,topt,region_opt);
    default: break;
    } catch {case &Dict::Absent: break; }
    terr(p->loc, xprintf("%s is not a struct name, but pattern has designators",
			 qvar2string(q)));
    t = wildtyp();
    break;
  }

 tcpat_end:
  p->topt = new Opt(t);
  return $(tv_result,v_result);
}

$(list_t<tvar_t>, list_t<vardecl_t>) tcPat(tenv_t te,
					   pat_t  p,
					   type_t *`r1 topt,
					   type_t *`r2 region_opt) {
  let ans = tcPatRec(te,p,topt,region_opt);
  // caller will check tvar uniqueness when adding to environment
  region r {
    check_unique_vars(List::rmap(r, get_name, ans[1]), p->loc,
		      "pattern contains a repeated variable");
  }
  return ans;
}

void check_pat_regions(tenv_t te, pat_t p) {
  switch(p->r) {
  case &Pointer_p(p2):
    check_pat_regions(te,p2);
    switch (p->topt->v) {
    case &PointerType(PtrInfo{_,rt,_,_,_}): fallthru(rt);
    case &TunionType(TunionInfo{_,_,rt,_}): fallthru(rt);
    case &XTunionType(XTunionInfo{_,rt,_}): 
      check_rgn_accessible(te,p->loc,rt);
      return;
    default: throw new Core::Impossible("check_pat_regions: bad pointer type");
    }
  case &Tunion_p(_,_,_,ps,_,_): 
    for(; ps != null; ps = ps->tl) check_pat_regions(te,ps->hd);
    switch (p->topt->v) {
    case &TunionType(TunionInfo{_,_,rt,_}):
      check_rgn_accessible(te,p->loc,rt);
      return;
    case &TunionFieldType(_):
      return;
    default: throw new Core::Impossible("check_pat_regions: bad tunion type");
    }
  case &XTunion_p(_,_,ps,_,_):
    for(; ps != null; ps = ps->tl) check_pat_regions(te,ps->hd);
    switch (p->topt->v) {
    case &XTunionType(XTunionInfo{_,rt,_}):
      check_rgn_accessible(te,p->loc,rt);
      return;
    case &XTunionFieldType(_):
      return;
    default: throw new Core::Impossible("check_pat_regions: bad xtunion type");
    }
  case &Struct_p(_,_,_,dps):  fallthru(List::map(snd,dps));
  case &Tuple_p(ps):
    for(; ps != null; ps = ps->tl)
      check_pat_regions(te,ps->hd);
    return;
  default: return;
  }
}

//static void print_pats(string s, list_t<pat_t> ps) {
//  fprintf(cyc_stderr,"---pat list: %s---\n",s);
//  for (; ps != null; ps = ps->tl)
//    fprintf(cyc_stderr,"%s\n",pat2string(ps->hd));
//  fprintf(cyc_stderr,"--------------------------------\n\n");
//}

// The rest of this is for match compilation -- this seems to be
// the easiest way to check for overlapping or inexhaustive patterns.
// These ideas are lifted from Peter Sestoft's paper "ML pattern
// match compilation and partial evaluation", which appeared in
// Dagstuhl Seminar on Partial Evaluation, LNCS, Springer-Verlag,
// March 1996.  See
// ftp://ftp.dina.kvl.dk/pub/Staff/Peter.Sestoft/papers/match.ps.gz

// FIX:  we need short, long, and double patterns.  In addition, we
// should really allow constant-expressions in patterns, and we should
// allow integral promotion on integral patterns.  Still need
// to deal with FALLTHRU's, etc.  We should probably also hash-cons
// as suggested by Sestoft to avoid a potential exponential space
// blow-up, and the traversal of the decision tree should be turned
// into a depth-first dag traversal to avoid an exponential time
// blow-up.  We should hang on to the decision tree so that the
// compiler can make effective use of it.  We should generalize the
// access to a "switch" (instead of just an "if").  We should
// look at the MacQueen paper to do a better job of ordering the tests.

// We compile down to simple patterns for exhaustive/overlap checks.
// Any's represent variables or wild-cards, whereas Con's represent
// everything else.
// The "name" of the con is an integer or string.
// The arity is the number of arguments the constructor has, and the
// span is the total number of constructors for the given type.
// Constant patterns (e.g., 1, true, 3[0]4) have 0 arity.  The span
// for bool is 2, for char is 256, and for integers, floats, and
// Xtunions is infinite (i.e., null).
static tunion Name_value { Name_v(string); Int_v(int); };
typedef tunion Name_value name_value_t;
static struct Con_s {
  name_value_t name;
  int          arity;
  opt_t<int>   span;
};
typedef struct Con_s @con_t;
static tunion Simple_pat { Any; Con(con_t,list_t<tunion Simple_pat>); };
typedef tunion Simple_pat simple_pat_t;

// used for creating sets of constructors
static int compare_con(con_t c1, con_t c2) {
  switch (c1->name) {
  case &Name_v(n1):
    switch (c2->name) {
    case &Name_v(n2): return String::zstrcmp(n1,n2);
    case &Int_v(_):   return -1;
    }
  case &Int_v(i1):
    switch (c2->name) {
    case &Name_v(_): return 1;
    case &Int_v(i2): return i1 - i2;
    }
  }
}

// build various cons
static Set::set_t<con_t> empty_con_set() { return Set::empty(compare_con); }

static struct Opt<int> one_opt = { 1 };
static struct Opt<int> two_opt = { 2 };
static opt_t<int> one_opt_ptr = &one_opt;

static tunion Name_value.Name_v null_name_value  = Name_v("null");
static tunion Name_value.Name_v ptr_name_value   = Name_v("ptr");
static tunion Name_value.Name_v tuple_name_value = Name_v("tuple");
static struct Con_s null_con0     = { &null_name_value,  0, &two_opt };
static struct Con_s null_ptr_con0 = { &ptr_name_value,   1, &two_opt };
static struct Con_s ptr_con0      = { &ptr_name_value,   1, &one_opt };

static con_t null_con     = &null_con0;
static con_t null_ptr_con = &null_ptr_con0;
static con_t ptr_con      = &ptr_con0;

static con_t int_con(int i)       { return new Con_s(new Int_v(i), 0, null); }
static con_t float_con(string f)  { return new Con_s(new Name_v(f), 0, null); }
static con_t char_con(char c) { 
  return new Con_s(new Int_v((int)c), 0,new Opt(256));
}
static con_t tuple_con(int i)     { 
  return new Con_s(&tuple_name_value, i, one_opt_ptr); 
}

// build various simple patterns
static simple_pat_t null_pat()           {return new Con(null_con,     null); }
static simple_pat_t int_pat(int i)       {return new Con(int_con(i),   null); }
static simple_pat_t char_pat(char c)     {return new Con(char_con(c),  null); }
static simple_pat_t float_pat(string f)  {return new Con(float_con(f), null); }
static simple_pat_t null_ptr_pat(simple_pat_t p) {
  return new Con(null_ptr_con,new List(p,null));
}
static simple_pat_t ptr_pat(simple_pat_t p) { 
  return new Con(ptr_con,new List(p,null)); 
}
static simple_pat_t tuple_pat(list_t<simple_pat_t> ss) {
  return new Con(tuple_con(List::length(ss)),ss);
}
static 
simple_pat_t con_pat(string con_name,opt_t<int> span,list_t<simple_pat_t> ps) {
  con_t c = new Con_s(new Name_v(con_name), List::length(ps), span);
  return new Con(c,ps);
}

// compile a Cyclone pattern to a simple pattern
static simple_pat_t compile_pat(pat_t p) {
  simple_pat_t s;
  switch (p->r) {
  case Wild_p:          s = Any; break;
  case &Var_p(_):       s = Any; break;
  case Null_p:          s = null_pat(); break;
  case &Int_p(sn,i):    s = int_pat(i); break;
  case &Char_p(c):      s = char_pat(c); break;
  case &Float_p(f):     s = float_pat(f); break;
  case &Tuple_p(ps):    s = tuple_pat(List::map(compile_pat,ps)); break;
  case &Reference_p(_): s = Any; break;
  case &Pointer_p(pp):
    simple_pat_t ss = compile_pat(pp);
    switch (compress(p->topt->v)) {
    case &PointerType(PtrInfo{_,_,n,_,_}):
      bool is_nullable = false;
      bool still_working = true;
      while (still_working) {
	switch (n->v) {
	case &Forward_constr(y): 
	  n->v = y->v; 
	  continue;
	case No_constr:
          n->v = new Eq_constr(false);
          is_nullable   = false;
          still_working = false;  // EXIT LOOP
          break;
	case &Eq_constr(x):
          is_nullable   = (bool)x;
          still_working = false;  // EXIT LOOP
          break;
	}
      }
      if (is_nullable) 
	s = null_ptr_pat(ss);
      else 
	s = ptr_pat(ss);
      break;
    // if the type of the & pattern is a Tunion or XTunion, then we just
    // leave all the compilation work to the sub-pattern.
    case &TunionType(_):
      s = ss; break;
    case &XTunionType(_):
      s = ss; break;
    default: s = impos("pointer pattern does not have pointer type!"); break;
    }
    break;
  case &Struct_p(sd,_,_,dlps):
    list_t<simple_pat_t> ps = null;
    for (_ fields = sd->fields->v; fields != null; fields = fields->tl) {
      // leave out bit fields without a name
      bool found = (String::strcmp(*fields->hd->name,"") == 0);
      for(_ dlps0 = dlps; !found && dlps0 != null; dlps0 = dlps0->tl) {
	let &$(dl,p) = dlps0->hd;
	switch (dl) {
	case &List{.hd=&FieldName(f), .tl=null}: 
	  if(String::zstrptrcmp(f,fields->hd->name) == 0) {
	    ps = new List(compile_pat(p),ps);
	    found = true;
	  }
	  break;
	default: impos("bad designator(s)"); break;
	}
      }
      if(!found)
	impos("bad designator");
    }
    s = tuple_pat(ps);
    break;
  case &Tunion_p(_,_,_,ps,ed,ef):
    int span = List::length(ed->fields->v);
    s = con_pat(*((*ef->name)[1]),new Opt(span),List::map(compile_pat,ps)); 
    break;
  case &XTunion_p(_,_,ps,xd,ef):
    s = con_pat(*((*ef->name)[1]),null,List::map(compile_pat,ps)); 
    break;
  case &Enum_p(q,ed,ef):
    // FIX: two different enum constructors can have the same value so we
    // might not get a duplicate warning when we should.
    int span = List::length(ed->fields);
    s = con_pat(*((*ef->name)[1]), new Opt(span), null);
    break;
  case &UnknownId_p(_):         s = impos("compile_pat: unknownid");     break;
  case &UnknownCall_p(_,_,_):   s = impos("compile_pat: unknowncall");   break;
  case &UnknownFields_p(_,_,_): s = impos("compile_pat: unknownfields"); break;
  }
  return s;
}

// A match is a list of patterns and their right-hand sides.  We
// parameterize over right-hand sides to make the code re-usable
// for compilation later on.  What we should really do is go ahead
// and compile to a decision tree and attach this to the abstract
// syntax...
#define match_t(rhs) list_t<$(simple_pat_t,rhs)@>
// A term descriptor describes a set of values using positive and/or
// negative information.  The descriptor Pos(c,[td1,...,tdn]) describes
// all values v of the form c(v1,...,vn), where vi is in the set
// described by tdi.  The descriptor Neg[c1,...,cn] describes all
// values v that are not of the form ci(v1,...,vm) (1 <= i <= n).
// Note that Neg[] denotes any possible value.
tunion Term_desc {
  Pos(con_t,list_t<tunion Term_desc>);
  Neg(Set::set_t<con_t>);
};
typedef tunion Term_desc term_desc_t;

// Contexts represent a partial term-description matched thus far,
// from the root node of the object in a left-to-right fashion.
typedef list_t<$(con_t,list_t<term_desc_t>)@> context_t;
// A decision tree for compiling pattern-matches.  Failure denotes
// that an exception should be thrown.  Success triggers a right-hand-side.
// IfEq is a constructor test -- conceptually, the access path is a sequence
// of projections applied to the root object to get at the field being
// tested -- this will eventually have to change to have enough type
// information to really generate the right code.
static tunion Access { Obj; Sel(int, tunion Access); }; // just an int list really
typedef tunion Access access_t;

static tunion Decision<`rhs> {
  Failure;
  Success(`rhs);
  IfEq(access_t, con_t, tunion Decision<`rhs>, tunion Decision<`rhs>);
};
typedef tunion Decision<`rhs> decision_t<`rhs>;

// A work_stack records what tests we have to continue to do.  An
// implicit invariant is that for each frame on the stack, the
// length of the pattern, access, and term_desc lists are the same.
typedef  $(list_t<simple_pat_t>,list_t<access_t>,list_t<term_desc_t>)@ work_stack_frame_t;
typedef list_t<work_stack_frame_t> work_stack_t;
// Used during primitive match compilation
static tunion Answer { Yes, No, Maybe };
typedef tunion Answer answer_t;

// Add c to a set of negative constructors for a term description.
// Assumes that td is a negative term description, that c is not
// already in the set, and that adding c does not cover all of the
// possible constructors.
static term_desc_t add_neg(term_desc_t td, con_t c) {
  switch (td) {
  case &Neg(cs):
    if (Set::member(cs,c))
      impos("add_neg called when constructor already in set");
    if (c->span != null && (Set::cardinality(cs) + 1) >= c->span->v)
	impos("add_neg called when |cs U {c}| >= span(c)");
    return new Neg(Set::insert(cs,c));
  case &Pos(_,_): return impos("add_neg called when td is Positive");
  }
}

// Returns whether or not values that start with constructor c are in the set
// described by the term descriptor td.
static answer_t static_match(con_t c, term_desc_t td) {
  switch (td) {
  case &Pos(c2,_):
    // td is the set of all values that start with c2
    if (compare_con(c,c2) == 0) return Yes;
    else return No;
  case &Neg(cs):
    // td is the set of all values that do not start with any of the cons in cs
    if (Set::member(cs,c)) return No;
    // when there are n possible starting constructors, c is not in cs,
    // and |cs| = n-1, then we know that c has to be in the set described by td
    else if ((c->span != null) && (c->span->v == Set::cardinality(cs) + 1))
      return Yes;
    // otherwise, we can't be sure.
    else return Maybe;
  }
}

// Add dsc to the current node in the context -- note that this node
// is always at the beginning of the context.  Furthermore, the current
// node's sub-term-descriptors are in reverse order.  Thus, we just
// cons the dsc onto the first con's list of sub-term-desc's.
static context_t augment(context_t ctxt, term_desc_t dsc) {
  switch (ctxt) {
  case null: return null; // ???
  case &List{.hd=&$(c,args), .tl=rest}:
    return new List(new $(c,(list_t<term_desc_t>)(new List(dsc, args))),rest);
  }
}

// When argument descriptions [dn,dn-1,...,d2,d1] have been found
// for all arguments of the local-most constructor c, we turn it
// into a positive descriptor Pos(c,[d1,d2,...,dn-1,dn]).
static context_t norm_context(context_t ctxt) {
  switch (ctxt) {
  case null: return impos("norm_context: empty context");
  case &List{.hd=&$(c,args), .tl=rest}: 
    return augment(rest, new Pos(c, List::rev(args)));
  }
}

// When moving from one match rule to another, we must re-construct the
// object description from the context (describes the part of the object
// up to the left of the current subterm), the current subterm description,
// and the term descriptions on the work stack, which, when taken together,
// describe the object to the right of the current subterm.
static term_desc_t build_desc(context_t ctxt,term_desc_t dsc,work_stack_t work)
{
  switch ($(ctxt,work)) {
  case $(null,null): return dsc;
  case $(null,_):    return impos("build_desc: ctxt and work don't match");
  case $(_,   null): return impos("build_desc: ctxt and work don't match");
  case $(&List{.hd=&$(c,args), .tl=rest}, &List{.hd=&$(_,_,dargs), .tl=work2}):
    let td = new Pos(c, List::append(List::rev(args), new List(dsc,dargs)));
    return build_desc(rest, td, work2);
  } 
}

static decision_t<`rhs> // forward declaration
match(simple_pat_t p, access_t obj, term_desc_t dsc, context_t ctx, 
      work_stack_t work, `rhs right_hand_side, match_t(`rhs) rules);

// Checks to see that the term (thus far described by dsc) matches one
// of the match_t rules.
static decision_t<`rhs> or_match(term_desc_t dsc, match_t(`rhs) allmrules)
{
  switch(allmrules) {
  case null: return Tcpat::Failure;
  case &List{.hd = &$(pat1, rhs1), .tl = rulerest}:
    return match(pat1, Obj, dsc, null, null, rhs1, rulerest);
  }
}

// Compiles a set of match rules to a decision tree.
static decision_t<`rhs> match_compile(match_t(`rhs) allmrules) {
  return or_match(new Neg(empty_con_set()), allmrules);
}

// Succeeds returning the right-hand-side if every pattern matches the
// associated term-description in the work stack, or else the original
// object matches some rule from rules.
static decision_t<`rhs> and_match(context_t ctx, work_stack_t work,
				    `rhs right_hand_side, match_t(`rhs) rules) {
  switch (work) {
  case null: return new Success(right_hand_side);
  case &List{.hd = &$(null,null,null), .tl = workr }:
    return and_match(norm_context(ctx), workr, right_hand_side, rules);
  case &List{.hd = &$(pats,objs,dscs), .tl = workr }:
    if (pats == null || objs == null || dscs == null)
      return impos("tcpat:and_match: malformed work frame");    
    let &List(pat1,patr) = (_@)(pats);
    let &List(obj1,objr) = (_@)(objs);
    let &List(dsc1,dscr) = (_@)(dscs);
    let wf = new $(patr, objr, dscr);
    return match(pat1,obj1,dsc1,ctx,new List(wf,workr),right_hand_side,rules);
  } 
}

// Get the term description arguments for a constructor term-description.
static list_t<term_desc_t> getdargs(con_t pcon, term_desc_t dsc) {
  switch (dsc) {
  case &Neg(ncs):
    // We only know that the term is con which is never in the set ncs.
    // So return Neg{} for each argument, reflecting that no information
    // is known about the arguments.
    term_desc_t any = new Neg(empty_con_set());
    let res = null;
    for (int i = 0; i < pcon->arity; ++i)
      res = new List(any,res);
    return res;
  case &Pos(_, dargs): return dargs;
  }
}

// Compute the paths for each argument when disassembling a constructor.
static access_t getoarg(access_t obj, int i) {
  return new Sel(i+1,obj);
}
static list_t<access_t> getoargs(con_t pcon, access_t obj) {
  return List::tabulate_c(pcon->arity, getoarg, obj);
}

// Succeeds returning the right-hand-side if the pattern matches the
// description and every pattern matches the associated description
// in the work stack, or if the original object matches one of the rules.
static decision_t<`rhs> 
match(simple_pat_t p, access_t obj, term_desc_t dsc,
      context_t ctx, work_stack_t work,
      `rhs right_hand_side, match_t(`rhs) rules) {
  switch (p) {
  case Any: return and_match(augment(ctx, dsc), work, right_hand_side, rules);
  case &Con(pcon, pargs):
    switch (static_match(pcon, dsc)) {
    case Yes:
      let ctx2       = new List(new $(pcon,null), ctx);
      let work_frame = new $(pargs, getoargs(pcon, obj), getdargs(pcon, dsc));
      let work2      = new List(work_frame, work);
      return and_match(ctx2, work2, right_hand_side, rules);
    case No:
      return or_match(build_desc(ctx, dsc, work), rules);
    case Maybe:
      let ctx2       = new List(new $(pcon,null), ctx);
      let work_frame = new $(pargs, getoargs(pcon, obj), getdargs(pcon, dsc));
      let work2      = new List(work_frame, work);
      let s          = and_match(ctx2, work2, right_hand_side, rules);
      let f          = or_match(build_desc(ctx, add_neg(dsc,pcon), work), rules);
      return new IfEq(obj, pcon, s, f);
    }
  }
}

// Given a decision tree, call not_exhaust for each Failure node
// and call rhs_appears for each Success node.  Note that Failure
// implies the patterns are not exhaustive.  Note also that if
// any rhs for a match does not show up in the decision tree, then
// the associated pattern was redundant.
static 
void check_exhaust_overlap(decision_t<`rhs> d,
                           void not_exhaust(`a),      `a env1,
                           void rhs_appears(`b,`rhs), `b env2) {
  switch (d) {
  case Tcpat::Failure:  not_exhaust(env1);   break;
  case &Success(r):     rhs_appears(env2,r); break;
  case &IfEq(_,_,left,right):
    check_exhaust_overlap(left,  not_exhaust, env1, rhs_appears, env2);
    check_exhaust_overlap(right, not_exhaust, env1, rhs_appears, env2);
    break;
  }
}

// Builds the decision tree for the switches, then checks to see
// if there are any failure nodes (pattern is inexhaustive) or if
// any pattern doesn't show up in the tree (pattern is redundant.)
// Both are considered errors as far as the type-checker is concerned.
static 
$(simple_pat_t, $(bool,seg_t)@)@ get_match(int @`r r, switch_clause_t swc) {
  simple_pat_t   sp0 = compile_pat(swc->pattern);
  $(bool,seg_t)@ rhs = new $(false,swc->pattern->loc);
  simple_pat_t sp;
  if (swc->where_clause != null) {
    sp = tuple_pat(new List(sp0,new List(int_pat(*r),null)));
    *r = (*r) + 1;
  } else
    sp = tuple_pat(new List(sp0,new List(Any,null)));
  return new $(sp, rhs);
}
static void not_exhaust_err(seg_t loc) {
  terr(loc,"patterns may not be exhaustive");
}
static void rule_occurs(int dummy, $(bool,seg_t)@ rhs) {
  (*rhs)[0] = true;
}
void check_switch_exhaustive(seg_t loc, list_t<switch_clause_t> swcs) {
  // We represent "pat && e" as (simple_pat,i) where i is a unique integer.
  // We represent patterns without where clauses as (simple_pat,_).
  // This way, if we have the same pattern repeated, we get exhuastiveness
  // right as long as one of the copies does not have a where-clause.
  let where_ctr   = 0;
  let match_rules = List::map_c(get_match,&where_ctr,swcs);
  let dec_tree    = match_compile(match_rules);
  check_exhaust_overlap(dec_tree, not_exhaust_err, loc, rule_occurs, 0);
  for (; match_rules != null; match_rules = match_rules->tl) {
    let &$(b,loc) = (*match_rules->hd)[1];
    if (!b)
      terr(loc,"redundant pattern");
  }
}

// Build the decision tree for the pattern.  If Failure occurs, then
// the pattern is not exhaustive (a warning).  There's no way to get
// something that's redundant (unless we add support for "or" patterns
// of some sort.)
static void not_exhaust_warn($(seg_t, bool) @ pr) {
  (*pr)[1] = false;
  warn((*pr)[0],"pattern not exhaustive");
}
static void dummy_fn(int i,int j) {
  return;
}
bool check_let_pat_exhaustive(seg_t loc,pat_t p) {
  let match_rules = new List(new $(compile_pat(p),0),null);
  let dec_tree    = match_compile(match_rules);
  let exhaust_env = new $(loc,true);
  check_exhaust_overlap(dec_tree, not_exhaust_warn, exhaust_env, dummy_fn, 0);
  return (*exhaust_env)[1];
}

// Check that the patterns in a catch switch are non-overlapping.
// There's an implicit "re-throw on wild" pattern here, so no need
// to check for exhaustiveness.
static $(simple_pat_t, $(bool,seg_t)@)@ get_match2(switch_clause_t swc) {
  simple_pat_t sp0 = compile_pat(swc->pattern);
  $(bool,seg_t)@ rhs = new $(false,swc->pattern->loc);
  return new $(sp0, rhs);
}
static void not_exhaust_err2(seg_t loc) {
  ; // skip
}
void check_catch_overlap(seg_t loc, list_t<switch_clause_t> swcs) {
  // We ignore where clauses here because catch's need not be exhaustive.
  let match_rules = List::map(get_match2,swcs);
  let dec_tree    = match_compile(match_rules);
  check_exhaust_overlap(dec_tree, not_exhaust_err2, loc, rule_occurs, 0);
  for (; match_rules != null; match_rules = match_rules->tl) {
    let pair = (*match_rules->hd)[1];
    if (!(*pair)[0])
      terr((*pair)[1],"redundant pattern");
  }
}
