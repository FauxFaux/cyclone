/* Type checking for patterns.
   Copyright (C) 2001 Greg Morrisett, AT&T
   This file is part of the Cyclone compiler.

   The Cyclone compiler is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   The Cyclone compiler is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with the Cyclone compiler; see the file COPYING. If not,
   write to the Free Software Foundation, Inc., 59 Temple Place -
   Suite 330, Boston, MA 02111-1307, USA. */

#include <core.h>
#include <list.h>
#include <dict.h>
#include <set.h>
#include <string.h>
#include <position.h>
#include "absyn.h"
#include "absynpp.h"
#include "tcutil.h"
#include "tcenv.h"
#include "tcexp.h"
#include "tcpat.h"
#include "evexp.h"
#include <stdio.h>

using Core;
using List;
using Set;
using Position;
using Absyn;
using Absynpp;
using Tcutil;
using Tcenv;
using Tcexp;
namespace Tcpat;

/////////////////////////////////////////////////////////////////////////
// type-check a pattern and return a list of the bound type variables,
// and a list of the bound value variables, their types, and any
// qualifiers (e.g., const).
/////////////////////////////////////////////////////////////////////////

static void resolve_pat(tenv_t te, pat_t p) {
  switch(p->r) {
  case &UnknownId_p(q):
    try {
      TEMP_RGN(te, r) {
        switch (lookup_ordinary(r,te,p->loc,q)) {
        case &AggrRes(_):
          p->r = Wild_p;
          terr(p->loc,"struct tag used without arguments in pattern");
          return;
        case &TunionRes(tud,tuf): 
          p->r = new Tunion_p(tud,tuf,NULL,false); return;
        case &EnumRes(ed,ef):     p->r = new Enum_p(ed,ef); return;
        case &AnonEnumRes(t,ef):  p->r = new AnonEnum_p(t,ef); return;
        case &VarRes(_): break; // shadows an outer definition, but that's fine
        }
      } 
    } catch { case Dict::Absent: break; } // a new variable
    // Unqualified variable is a declaration, qualified is an error
    switch ((*q)[0]) {
    case Loc_n: 
    case Rel_n(NULL):
      (*q)[0] = Loc_n;        
      p->r = new Var_p(new_vardecl(q,VoidType,NULL),// type set later
                       new_pat(Wild_p,NULL)); 
      return;
    default: terr(p->loc,"qualified variable in pattern"); return;
    }
  case &UnknownCall_p(q,ps,dots):
    try {
      TEMP_RGN(te, r) {
        switch (lookup_ordinary(r,te,p->loc,q)) {
        case &AggrRes(ad):
          if(ad->kind == UnionA) {
            p->r = Wild_p;
            terr(p->loc,"cannot pattern-match a union");
            return;
          }
          let new_ps = NULL;
          for(; ps != NULL; ps = ps->tl)
            new_ps = new List(new $(NULL,ps->hd), new_ps);
          p->r = new Aggr_p(AggrInfo(KnownAggr(new ad),NULL),
                            NULL,imp_rev(new_ps),dots);
          return;
        case &TunionRes(tud,tuf): p->r = new Tunion_p(tud,tuf,ps,dots); return;
        case &EnumRes(_,_):
        case &AnonEnumRes(_,_):
          terr(p->loc,"enum tag used with arguments in pattern");
          p->r = Wild_p;
          return;
        case &VarRes(_): break;
      }
    }} catch {case Dict::Absent: break;}
    terr(p->loc, "%s is not a constructor in pattern",qvar2string(q));
    p->r = Wild_p;
    return;

  case &Aggr_p(AggrInfo(UnknownAggr(k,n),targs), *exist_ts, dps, dots):
    try { 
      let adp = lookup_aggrdecl(te,p->loc,n);
      let ad = *adp;
      if(ad->kind == UnionA) {
	terr(p->loc,"cannot pattern-match a union");
        p->r = Wild_p;
	return;
      }
      if(ad->impl==NULL) {
	terr(p->loc, "can't destructure an abstract struct");
        p->r = Wild_p;
	return;
      }
      int more_exists = length(ad->impl->exist_vars) - length(*exist_ts);
      if(more_exists < 0) {
	terr(p->loc, "too many existentially bound type variables in pattern");
        let ts = exist_ts;
        for (int n = length(ad->impl->exist_vars); n != 0; n--)
          ts = &(*ts)->tl;
        *ts = NULL;
      } else if (more_exists > 0) {
        // add missing type variables for user here
        let new_ts = NULL;
        for (; more_exists != 0; more_exists--) 
          new_ts = new List(new_tvar(new Unknown_kb(NULL)),new_ts);
        *exist_ts = List::imp_append(*exist_ts,new_ts);
      }
      p->r = new Aggr_p(AggrInfo(KnownAggr(adp), targs), *exist_ts, dps,
                        dots);
    } catch { case Dict::Absent: 
      terr(p->loc, "Non-struct name has designator patterns"); 
      p->r = Wild_p;
      break;
    }
    return;
  case &Exp_p(e):
    Tcexp::tcExp(te,NULL,e);
    if (!is_const_exp(te,e)) {
      terr(p->loc,"non-constant expression in case pattern");
      p->r = Wild_p;
    }
    let $(i,known) = Evexp::eval_const_uint_exp(e);
    p->r = new Int_p(None,i);
    return;
  default: return;
  }
}

static var_t get_name(vardecl_t vd) {
  return (*vd->name)[1];
}
static type_t any_type(list_t<tvar_t,`H> s, type_t * topt) {
  if(topt != NULL)
    return *topt;
  return new_evar(&mk,new Opt(s));
}
static type_t num_type(type_t * topt, type_t numt) {
  // by setting to whatever topt is, unification will succeed.  Because
  // comparison between any two num types succeeds, this is fine (but kludgey)
  // FIX:? Allow *topt to be an Enum ?
  if(topt != NULL && coerceable(*topt))
    return *topt;
  // now allow enum to be cast up too
  switch(compress(numt)) {
  case &EnumType(_,_): if(topt != NULL) return *topt; break;
  default: break;
  }
  return numt;
}
static void set_vd(vardecl_t vd, list_t<vardecl_t>@ v_result_ptr, type_t t){
  vd->type = t;
  vd->tq   = empty_tqual(NULL);
  *v_result_ptr = new List(vd,*v_result_ptr);
}
static tcpat_result_t combine_results(tcpat_result_t res1, tcpat_result_t res2){
  // FIX: plenty of unnecessary allocation here
  let TcPatResult(p1,vs1) = res1;
  let TcPatResult(p2,vs2) = res2;
  if(p1 != NULL || p2 != NULL) {
    if(p1==NULL)
      p1 = new $(NULL,NULL);
    if(p2==NULL)
      p2 = new $(NULL,NULL);
    return TcPatResult(new $(append((*p1)[0],(*p2)[0]), 
			     append((*p1)[1],(*p2)[1])),
		       append(vs1,vs2));
  }
  return TcPatResult(NULL,append(vs1,vs2));
}

static pat_t wild_pat(seg_t loc) {
  return new Pat { .loc = loc, .topt = NULL, .r = Wild_p };
}

static tcpat_result_t tcPatRec(tenv_t te,pat_t  p,type_t *topt,type_t *rgn_opt){
  resolve_pat(te,p);
  type_t t;
  tcpat_result_t res = TcPatResult(NULL,NULL);

  // Figure out what t should be; assign to p->topt and return after switch
  switch (p->r) {

  case Wild_p:       
    t = any_type(lookup_type_vars(te),topt);
    break;
  case &Var_p(vd,p2):
    res = tcPatRec(te,p2,topt,rgn_opt);
    t = p2->topt->v;
    set_vd(vd, &res.patvars, t);
    break;
  case &Reference_p(vd,p2):
    res = tcPatRec(te,p2,topt,rgn_opt);
    t = p2->topt->v;
    if(rgn_opt == NULL) {
      terr(p->loc, "* pattern would point into an unknown/unallowed region");
      break;
    }
    else if (is_noalias_pointer(t))
      impos("* pattern cannot take the address of an alias-free path");
    set_vd(vd, &res.patvars, 
	   new PointerType(PtrInfo(t,empty_tqual(NULL),
				   PtrAtts(*rgn_opt,false_conref,
					   empty_conref(),empty_conref(),
                                           NULL))));
    break;

  case &TagInt_p(tv,vd): 
    // parser set the type b/c it's trivially known, but we need the var
    // in the result
    set_vd(vd, &res.patvars, vd->type);
    // gotta add the tvar in too; the parser set its kind correctly
    // the kind is IntKind, so no partial-order munging, etc.
    // this checks uniqueness of new tvars (kinda kludgy)
    TEMP_RGN(te, r2) {
      add_type_vars(r2,p->loc,te,list(tv));
    }
    if(res.tvars_and_bounds_opt==NULL)
      res.tvars_and_bounds_opt = new $(NULL,NULL);
    (*res.tvars_and_bounds_opt)[0] = 
      new List(tv,(*res.tvars_and_bounds_opt)[0]);
    t = uint_typ; // this is what we match against
    break;

  case &Int_p(Unsigned,_): t = num_type(topt, uint_typ);  break;
  case &Int_p(None,_):
  case &Int_p(Signed,_):   t = num_type(topt, sint_typ);  break;
  case &Char_p(_):         t = num_type(topt, char_typ);  break;
  case &Float_p(_):        t = num_type(topt, float_typ); break;
  case &Enum_p(ed,_):      t = num_type(topt, new EnumType(ed->name,ed)); break;
  case &AnonEnum_p(tenum,_): t = num_type(topt, tenum); break;
  case Null_p:
    if(topt != NULL)
      switch(compress(*topt)) {
      case &PointerType(_): t = *topt; goto tcpat_end;
      default: break;
      }
    let tenv_tvs = lookup_opt_type_vars(te);
    t = new PointerType(PtrInfo(new_evar(&ak,tenv_tvs),
                                empty_tqual(NULL),
				// MWH: don't allow switching on
				//   unique pointers for now
				PtrAtts(new_evar(&rk,tenv_tvs),
					true_conref,
					empty_conref(),empty_conref(),NULL)));
                                        
                                        
    break;

  case &Pointer_p(p2):
    // FIX: In the TunionField for p2 case, we should really pass-through
    // the type instantiation information in topt!!!

    type_t inner_typ  = VoidType;
    let    inner_topt = NULL;
    if(topt != NULL)
      switch(compress(*topt)) {
      case &PointerType(PtrInfo(elt_typ,_,_)): 
	inner_typ  = elt_typ; 
	inner_topt = &inner_typ;
	break;
      default: break;
      }
    
    // we put in an unconstrained region.  Then the client calls
    // check_pat_regions after unifying against the type they're destructuring.
    type_t ptr_rgn = new_evar(&trk,lookup_opt_type_vars(te));
    res = combine_results(res,tcPatRec(te,p2,inner_topt,&ptr_rgn));
    // if p2's type is a tunion field type, then we cast
    // the type of p = &p2 to the appropriate tunion type, unless
    // topt suggests we do otherwise.
    if(inner_topt == NULL) 
      switch (compress(p2->topt->v)) {
      case &TunionFieldType(TunionFieldInfo{KnownTunionfield(tud,tuf),targs}) && !tud->is_flat:
	t = new TunionType(TunionInfo{KnownTunion(new tud),targs,new Opt(ptr_rgn)});
	break;
      default:
	t = new PointerType(PtrInfo(p2->topt->v, empty_tqual(NULL),
				    PtrAtts(ptr_rgn, empty_conref(), 
					    empty_conref(), empty_conref(),
                                            NULL)));
	break;
      }
    else 
      t = new PointerType(PtrInfo(p2->topt->v, empty_tqual(NULL),
				  PtrAtts(ptr_rgn, empty_conref(), 
					  empty_conref(), empty_conref(),
                                          NULL)));
    break;

  case &Tuple_p(*ps_p,dots):
    let ps = *ps_p;
    list_t<$(tqual_t,type_t)@> pat_ts  = NULL;
    list_t<$(tqual_t,type_t)@> topt_ts = NULL;
    if(topt != NULL)
      switch(compress(*topt)) {
      case &TupleType(tqts): 
        topt_ts = tqts; 
        if (dots) {
          // fill in wild pattenrs for the missing fields
          let lps = List::length(ps);
          let lts = List::length(tqts);
          if (lps < lts) {
            list_t<pat_t> wild_ps = NULL;
            for (int i = 0; i < lts - lps; i++) 
              wild_ps = new List(wild_pat(p->loc), wild_ps);
            *ps_p = List::imp_append(ps,wild_ps);
            ps = *ps_p;
          } else if (List::length(ps) == List::length(tqts))
            warn(p->loc,"unnecessary ... in tuple pattern");
          // otherwise we'll get an error later on.
        }
        break;
        
      default: break;
      }
    else if (dots)
      terr(p->loc,"cannot determine missing fields for ... in tuple pattern");
    for(; ps != NULL; ps=ps->tl) {
      let inner_topt = NULL;
      if(topt_ts != NULL) {
	inner_topt = &(*topt_ts->hd)[1];
	topt_ts    = topt_ts->tl;
      }
      res = combine_results(res,tcPatRec(te,ps->hd,inner_topt,rgn_opt));
      pat_ts = new List(new $(empty_tqual(NULL),ps->hd->topt->v),pat_ts);
    }
    t = new TupleType(List::imp_rev(pat_ts));
    break;

  case &Aggr_p(AggrInfo(KnownAggr(&ad),*tsp),exist_ts,*dps_p,dots):
    let dps = *dps_p;
    if(ad->impl==NULL) {
      terr(p->loc,"can't destructure an abstract struct");
      t = wildtyp(lookup_opt_type_vars(te));
      break;
    }
    // don't allow reference patterns for existentials -- see Dan's ESOP paper
    if (exist_ts != NULL)
      rgn_opt = NULL;
    region<`rgn> rgn; {
      // constrain type variables to have at least the kind they were abstracted over
      let var_tvs = NULL;
      list_t<$(type_t,type_t)@> outlives_constraints = NULL;
      let u = ad->impl->exist_vars;
      for (_ t = exist_ts ; t != NULL; t = t->tl) {
	tvar_t tv = t->hd;
	tvar_t uv = u->hd;
	u = u->tl;
	let kb1 = compress_kb(tv->kind);
	let kb2 = compress_kb(uv->kind);
	bool error=false;
	kind_t k2;
	switch(kb2) {
	case &Less_kb(_,k): fallthru(k);
	case &Eq_kb(k): k2 = k; break;
	default: impos("unconstrained existential type variable in struct");
	}
	switch (kb1) {
	  // ensure that kind of quantified var <:: kind of pattern var
	case &Eq_kb(k1): 
	  if(!kind_leq(k2,k1)) 
	    error = true;
	  break;
	case &Less_kb(*f,k): fallthru(f);
	case &Unknown_kb(*f): *f = new Opt(kb2); break;
	}
	if(error) {
	  terr(p->loc,"type variable %s has kind %s "
	              "but must have at least kind %s",
	       *tv->name,
	       kindbound2string(kb1),kind2string(k2));
	}
	type_t vartype = new VarType(tv);
	var_tvs = rnew(rgn) List((type_t)(vartype),var_tvs);
	// if unpacking a region var, must add it to the po
	// FIX: allow adding existentials of TR kind?
	if(k2 == RgnKind) {
          outlives_constraints = new List(new $(empty_effect,vartype),outlives_constraints);
	}
	else if (k2 == UniqueRgnKind || k2 == TopRgnKind) {
	  Tcutil::impos("opened existential had unique or top region kind");
	}
      }

      var_tvs = imp_rev(var_tvs);

      TEMP_RGN(te, r2) {
        tenv_t te2 = add_type_vars(r2,p->loc,te,exist_ts);

        let tenv_tvs = lookup_type_vars(te2);
        let env = $(tenv_tvs,rgn);
        let all_inst   = List::rmap_c(rgn,r_make_inst_var,&env,ad->tvs);
        let exist_inst = List::rzip(rgn,rgn,ad->impl->exist_vars,var_tvs);
        let all_typs   = List::map(snd,all_inst);
        let exist_typs = List::map(snd,exist_inst);
        let inst       = List::rappend(rgn,all_inst,exist_inst);

        if(exist_ts != NULL || ad->impl->rgn_po != NULL) {
          if(res.tvars_and_bounds_opt==NULL)
            res.tvars_and_bounds_opt = new $(NULL,NULL);
          (*res.tvars_and_bounds_opt)[0] = 
            append((*res.tvars_and_bounds_opt)[0],exist_ts);
          (*res.tvars_and_bounds_opt)[1] = 
            append((*res.tvars_and_bounds_opt)[1],outlives_constraints);
          let rpo_inst = NULL;
          for(let rpo=ad->impl->rgn_po; rpo != NULL; rpo = rpo->tl)
            rpo_inst = new List(new $(rsubstitute(rgn,inst,(*rpo->hd)[0]),
                                      rsubstitute(rgn,inst,(*rpo->hd)[1])),
                                rpo_inst);
          rpo_inst = imp_rev(rpo_inst);
          (*res.tvars_and_bounds_opt)[1] = 
            append((*res.tvars_and_bounds_opt)[1],rpo_inst);
        }

        *tsp = all_typs;
        t = new AggrType(AggrInfo(KnownAggr(new ad),*tsp));
        if (dots) {
          // fill in wild patterns for the missing fields
          let ldps = List::length(dps);
          let lfields = List::length(ad->impl->fields);
          if (ldps < lfields) {
            list_t<$(list_t<designator_t>,pat_t)@> wild_dps = NULL;
            for (int i = 0; i < lfields - ldps; i++) 
              wild_dps = new List(new $(NULL,wild_pat(p->loc)), wild_dps);
            *dps_p = List::imp_append(dps,wild_dps);
            dps = *dps_p;
          } else if (ldps == lfields)
            warn(p->loc,"unnecessary ... in struct pattern");
        }
        list_t<$(aggrfield_t,pat_t)@`rgn,`rgn> fields =
          resolve_struct_designators(rgn,p->loc,dps,ad->impl->fields);
        for(; fields != NULL; fields = fields->tl) {
          let &$(field,pat)     = fields->hd;
          let inst_fieldtyp     = rsubstitute(rgn,inst,field->type);
          res = combine_results(res,tcPatRec(te2,pat,&inst_fieldtyp,rgn_opt));
          // must unify here or the type we gave pat won't ever get checked
          // against the exp we're matching against.  Even if we succeed now,
          // we could be constraining so as to catch an error later.
          if (!unify(pat->topt->v,inst_fieldtyp))
            terr(p->loc,"field %s of struct pattern expects type %s != %s",
                 *field->name, typ2string(inst_fieldtyp), 
                 typ2string(pat->topt->v));
        }
      }
    }
    break;

  case &Tunion_p(tud,tuf,*ps_p,dots): 
    let ps = *ps_p;
    // don't allow reference patterns in flat tunions -- these are like
    // existentials (see Dan's ESOP paper.)
    if (tud->is_flat) rgn_opt = NULL;
    TEMP_RGN(te, rgn) {
      list_t<$(tqual_t,type_t)@> tqts = tuf->typs;

      let tenv_tvs = lookup_type_vars(te);
      let env      = $(tenv_tvs,rgn);
      let inst     = List::rmap_c(rgn,r_make_inst_var,&env,tud->tvs);
      let all_typs = List::map(snd,inst);
      // unless topt says otherwise, guess we want Tunion when there are no args or we have a flat tunion
      if(tqts == NULL || tud->is_flat) {
        opt_t<type_t> ropt = NULL;
        if (!tud->is_flat) 
          ropt = new Opt(new_evar(&rk,new Opt(tenv_tvs)));
	t = new TunionType(TunionInfo{KnownTunion(new tud),all_typs,ropt});
      } else
	t = new TunionFieldType(TunionFieldInfo{KnownTunionfield(tud,tuf),
						all_typs});
      if(topt != NULL && (tqts == NULL || tud->is_flat))
	switch(compress(*topt)) {
	case &TunionFieldType(_): 
	  t = new TunionFieldType(TunionFieldInfo{KnownTunionfield(tud,tuf),
						  all_typs});
	  break;
	case &TunionType(TunionInfo{_,targs,_}):
	  // these unifies could make topt cause an error
	  let a = all_typs;
	  for (; a != NULL && targs != NULL; a=a->tl,targs=targs->tl)
	    unify(a->hd,targs->hd);
	  break;
	default: break;
	}
      if (dots) {
        // fill in wild patterns for the missing fields
        let lps = List::length(ps);
        let ltqts = List::length(tqts);
        if (lps < ltqts) {
          list_t<pat_t> wild_ps = NULL;
          for (int i = 0; i < ltqts - lps; i++) 
            wild_ps = new List(wild_pat(p->loc), wild_ps);
          *ps_p = List::imp_append(ps,wild_ps);
          ps = *ps_p;
        } else if (lps == ltqts)
          warn(p->loc,"unnecessary ... in tunion field %s",
               qvar2string(tud->name));
      }
      for(; ps != NULL && tqts != NULL; ps = ps->tl, tqts = tqts->tl) {
	let p2 = ps->hd;
	// Note:  we don't pass in ptr_rgn here because for value-carrying
	// constructors, the pointer's region is passed down as rgn_opt.
	let field_typ = rsubstitute(rgn, inst, (*tqts->hd)[1]);
	res = combine_results(res,tcPatRec(te,p2,&field_typ,rgn_opt));
	// must unify here or the type we gave pat won't ever get checked
	// against the exp we're matching against.  Even if we succeed now,
	// we could be constraining so as to catch an error later.
	if (!unify(p2->topt->v,field_typ))
	  terr(p2->loc, "%s expects argument type %s, not %s",
               qvar2string(tuf->name), typ2string(field_typ),
               typ2string(p2->topt->v));
      }
      if (ps != NULL)
	terr(p->loc,"too many arguments for tunion constructor %s",
             qvar2string(tuf->name));
      if (tqts != NULL)
	terr(p->loc,"too few arguments for tunion constructor %s",
	     qvar2string(tuf->name));
    }
    break;

  case &Aggr_p(AggrInfo(UnknownAggr(_,_),_),_,_,_):
  case &UnknownId_p(_):         
  case &Exp_p(_):
  case &UnknownCall_p(_,_,_): 
    t = wildtyp(lookup_opt_type_vars(te)); break;
  }
 tcpat_end:
  p->topt = new Opt(t);
  return res;
}

tcpat_result_t tcPat(tenv_t te, pat_t  p, type_t @ topt) {
  let ans = tcPatRec(te,p,topt,NULL);
  // caller will check tvar uniqueness when adding to environment
  TEMP_RGN(te, r) {
    check_unique_vars(List::rmap(r, get_name, ans.patvars), p->loc,
		      "pattern contains a repeated variable");
  }
  return ans;
}

void check_pat_regions(tenv_t te, pat_t p) {
  switch(p->r) {
  case &Pointer_p(p2):
    check_pat_regions(te,p2);
    // not allowed to dereference pointer to a unique type
    TEMP_RGN(te, temp) {
      if (is_noalias_pointer_or_aggr(temp,p2->topt->v)) {
        terr(p->loc,"Pattern dereferences to a non-aliased pointer; use swap");
        return;
      }
      // FIX: need to fold alias tracking via patterns into
      // flow analysis to remove this check
      if (is_noalias_pointer_or_aggr(temp,p->topt->v)) {
        terr(p->loc,"Pattern dereferences a non-aliased pointer; use swap");
        return;
      }
    }
    switch (p->topt->v) {
    case &PointerType(PtrInfo(_,_,PtrAtts(rt,_,_,_,_))): fallthru(rt);
    case &TunionType(TunionInfo{_,_,&Opt(rt)}):
      check_rgn_accessible(te,p->loc,rt);
      return;
    default: impos("check_pat_regions: bad pointer type");
    }
  case &Tunion_p(_,_,ps,_): 
    for(; ps != NULL; ps = ps->tl) check_pat_regions(te,ps->hd);
    switch (p->topt->v) {
    case &TunionType(TunionInfo{_,_,NULL}):
      return;
    case &TunionType(TunionInfo{_,_,&Opt(rt)}):
      check_rgn_accessible(te,p->loc,rt);
      return;
    case &TunionFieldType(_): return;
    default: impos("check_pat_regions: bad tunion type");
    }
  case &Aggr_p(_,_,dps,_): 
    for(; dps != NULL; dps = dps->tl)
      check_pat_regions(te,(*dps->hd)[1]);
    return;
  case &Tuple_p(ps,_):
    for(; ps != NULL; ps = ps->tl)
      check_pat_regions(te,ps->hd);
    return;
  default: return;
  }
}

//static void print_pats(string s, list_t<pat_t> ps) {
//  fprintf(cyc_stderr,"---pat list: %s---\n",s);
//  for (; ps != NULL; ps = ps->tl)
//    fprintf(cyc_stderr,"%s\n",pat2string(ps->hd));
//  fprintf(cyc_stderr,"--------------------------------\n\n");
//}

// The rest of this is for match compilation -- this seems to be
// the easiest way to check for overlapping or inexhaustive patterns.
// These ideas are lifted from Peter Sestoft's paper "ML pattern
// match compilation and partial evaluation", which appeared in
// Dagstuhl Seminar on Partial Evaluation, LNCS, Springer-Verlag,
// March 1996.  See
// ftp://ftp.dina.kvl.dk/pub/Staff/Peter.Sestoft/papers/match.ps.gz

// FIX:  we need short, long, and double patterns.  In addition, we
// should really allow constant-expressions in patterns, and we should
// allow integral promotion on integral patterns.  Still need
// to deal with FALLTHRU's, etc.  We should probably also hash-cons
// as suggested by Sestoft to avoid a potential exponential space
// blow-up, and the traversal of the decision tree should be turned
// into a depth-first dag traversal to avoid an exponential time
// blow-up.  We should hang on to the decision tree so that the
// compiler can make effective use of it.  We should generalize the
// access to a "switch" (instead of just an "if").  We should
// look at the MacQueen paper to do a better job of ordering the tests.

// We compile down to simple patterns for exhaustive/overlap checks.
// Any's represent variables or wild-cards, whereas Con's represent
// everything else.
// The "name" of the con is an integer or string.
// The arity is the number of arguments the constructor has, and the
// span is the total number of constructors for the given type.
// Constant patterns (e.g., 1, true, 3[0]4) have 0 arity.  The span
// for bool is 2, for char is 256, and for integers, floats, and
// Xtunions is infinite (i.e., NULL).
static __flat__ tunion Name_value { Name_v(string_t); Int_v(int); };
typedef tunion Name_value name_value_t;
static struct Con_s<`r::R> {
  name_value_t name;
  int          arity;
  int *`r const span;
  // pointer back to original pattern that generated it
  struct Pat  *`H orig_pat;  
};
typedef struct Con_s<`r> @`r con_t<`r>;
static tunion Simple_pat<`r::R> { 
  Any; 
  Con(con_t<`r>,list_t<tunion `r Simple_pat<`r>,`r>); 
};
typedef tunion `r Simple_pat<`r> simple_pat_t<`r>;

// used for creating sets of constructors
static int compare_con(con_t c1, con_t c2) {
  switch (c1->name) {
  case Name_v(n1):
    switch (c2->name) {
    case Name_v(n2): return strcmp(n1,n2);
    case Int_v(_):   return -1;
    }
  case Int_v(i1):
    switch (c2->name) {
    case Name_v(_): return 1;
    case Int_v(i2): return i1 - i2;
    }
  }
}

// build various cons
static Set::set_t<con_t<`r>,`r> empty_con_set(region_t<`r> r) { 
  return Set::rempty(r,compare_con); 
}

static int one_opt = 1;
static int two_opt = 2;
static int twofiftysix_opt = 256;

static con_t<`r> null_con(region_t<`r> r, pat_t p) { 
  return rnew(r) Con_s{Name_v("NULL"), 0, (int*`r)(&two_opt), p};
}
static con_t<`r> null_ptr_con(region_t<`r> r, pat_t p) { 
  return rnew(r) Con_s{Name_v("&"), 1, (int*`r)&two_opt, p};
}
static con_t<`r> ptr_con(region_t<`r> r, pat_t p) { 
  return rnew(r) Con_s{Name_v("&"), 1, (int*`r)&one_opt, p};
}
static con_t<`r> int_con(region_t<`r> r, int i,struct Pat *`H p) { 
  return rnew(r) Con_s(Int_v(i), 0, NULL, p); 
}
static con_t<`r> float_con(region_t<`r> r, string_t<`H> f, pat_t p) {
  return rnew(r) Con_s(Name_v(f),0,NULL,p);
}
static con_t<`r> char_con(region_t<`r> r, char c, pat_t p) {
  return rnew(r) Con_s(Int_v(c), 0,(int*`r)&twofiftysix_opt, p);
}
static con_t<`r> tuple_con(region_t<`r> r, int i, struct Pat *`H p)     { 
  return rnew(r) Con_s(Name_v("$"), i, &one_opt, p); 
}

// build various simple patterns
static simple_pat_t<`r> null_pat(region_t<`r> r, pat_t p) {
  return rnew(r) Con(null_con(r,p),     NULL); 
}
static simple_pat_t<`r> int_pat(region_t<`r> r, int i, struct Pat *`H p) {
  return rnew(r) Con(int_con(r,i,p),   NULL); 
}
static simple_pat_t<`r> char_pat(region_t<`r> r, char c, pat_t p) {
  return rnew(r) Con(char_con(r,c,p),  NULL); 
}
static simple_pat_t<`r> float_pat(region_t<`r> r, string_t<`H> f, pat_t p) {
  return rnew(r) Con(float_con(r,f,p),NULL);
}
static simple_pat_t<`r> null_ptr_pat(region_t<`r> r, simple_pat_t<`r> p, pat_t p0) {
  return rnew(r) Con(null_ptr_con(r,p0),rnew(r) List(p,NULL));
}
static simple_pat_t<`r> ptr_pat(region_t<`r> r, simple_pat_t<`r> p, pat_t p0) { 
  return rnew(r) Con(ptr_con(r,p0),rnew(r) List(p,NULL)); 
}
static simple_pat_t<`r> tuple_pat(region_t<`r> r, list_t<simple_pat_t<`r>,`r> ss, struct Pat *`H p) {
  return rnew(r) Con(tuple_con(r,List::length(ss),p),ss);
}
static simple_pat_t<`r> con_pat(region_t<`r> r, string_t<`H> con_name, int*`r span,
			    list_t<simple_pat_t<`r>,`r> ps, pat_t p) {
  con_t c = rnew(r) Con_s(Name_v(con_name), List::length(ps), span, p);
  return rnew(r) Con(c,ps);
}

// compile a Cyclone pattern to a simple pattern
static simple_pat_t<`r> compile_pat(region_t<`r> r, pat_t p) {
  simple_pat_t<`r> s;
  switch (p->r) {
  case Wild_p:          
  case &TagInt_p(_,_):  s = Any; break;
  case Null_p:          s = null_pat(r,p); break;
  case &Int_p(sn,i):    s = int_pat(r,i,p); break;
  case &Char_p(c):      s = char_pat(r,c,p); break;
  case &Float_p(f):     s = float_pat(r,f,p); break;
  case &Var_p(_,p2):    s = compile_pat(r,p2); break;
  case &Reference_p(_,p2): s = compile_pat(r,p2); break;
  case &Pointer_p(pp):
    switch (compress(p->topt->v)) {
    case &PointerType(PtrInfo(_,_,PtrAtts(_,n,_,_,_))):
      bool is_nullable = false;
      bool still_working = true;
      while (still_working) {
	switch (n->v) {
	case Forward_constr(y): 
	  n->v = y->v; 
	  continue;
	case No_constr:
          n->v = Eq_constr(false);
          is_nullable   = false;
          still_working = false;  // EXIT LOOP
          break;
	case Eq_constr(x):
          is_nullable   = (bool)x;
          still_working = false;  // EXIT LOOP
          break;
	}
      }
      simple_pat_t ss = compile_pat(r,pp);
      if (is_nullable) 
	s = null_ptr_pat(r,ss,p);
      else 
	s = ptr_pat(r,ss,p);
      break;
    case &TunionType(TunionInfo{_,_,&Opt(_)}):
      switch(pp->r) {
      case &Tunion_p(tud,tuf,ps,_):
	int*`r span;
	if(tud->is_xtunion)
	  span = NULL;
	else
	  span = rnew(r) (List::length(tud->fields->v));
	s = con_pat(r,*((*tuf->name)[1]),span,
                    List::rmap_c(r,compile_pat,r,ps),p); 
	break;
      default: impos("non-[x]tunion pattern has tunion type");
      }
      break;
    default: impos("pointer pattern does not have pointer type");
    }
    break;

  case &Tunion_p(tud,tuf,ps,_):
    int*`r span;
    switch(compress(p->topt->v)) {
    case &TunionType(_):     
      if(tud->is_xtunion)
	span = NULL;
      else
	span = rnew(r) (List::length(tud->fields->v)); 
      break;
    case &TunionFieldType(_): span = &one_opt; break;
    default: span = impos("void tunion pattern has bad type"); break;
    }
    s = con_pat(r,*((*tuf->name)[1]),span, List::rmap_c(r,compile_pat,r,ps),p);
    break;
    
    // case &Tunion_p(_,_,ps,_): fallthru(ps); // ps != NULL
  case &Tuple_p(ps,_): 
    s = tuple_pat(r,List::rmap_c(r,compile_pat,r,ps),p); break;

  case &Aggr_p(AggrInfo(KnownAggr(&ad),_),_,dlps,_):
    // FIX: doesn't look like multiple designators are right
    list_t<simple_pat_t<`r>,`r> ps = NULL;
    for (_ fields = ad->impl->fields; fields != NULL; fields = fields->tl) {
      // leave out bit fields without a name
      bool found = (strcmp(*fields->hd->name,"") == 0);
      for(_ dlps0 = dlps; !found && dlps0 != NULL; dlps0 = dlps0->tl) {
	let &$(dl,p) = dlps0->hd;
	switch (dl) {
	case &List{.hd=&FieldName(f), .tl=NULL}: 
	  if(strptrcmp(f,fields->hd->name) == 0) {
	    ps = rnew(r) List(compile_pat(r,p),ps);
	    found = true;
	  }
	  break;
	default: impos("bad designator(s)"); 
	}
      }
      if(!found)
	impos("bad designator");
    }
    s = tuple_pat(r,ps,p);
    break;
      
  case &Enum_p(ed,ef):
    // FIX: two different enum constructors can have the same value so we
    // might not get a duplicate warning when we should.
    int span = List::length(ed->fields->v);
    s = con_pat(r, *((*ef->name)[1]), rnew(r) span, NULL, p);
    break;
  case &AnonEnum_p(tenum,ef):
    // FIX: I had to put `H in here.  The problem must be that we type-check
    // the default first and try to unify impos's type (a type variable) with
    // the type of fields which was list_t<enumfield_t,#i>.  
    list_t<enumfield_t,`H> fields;
    switch (compress(tenum)) {
    case &AnonEnumType(fs): fields = fs; break;
    default: impos("bad type in AnonEnum_p");
    };
    // FIX: two different enum constructors can have the same value so we
    // might not get a duplicate warning when we should.
    int span = List::length(fields);
    s = con_pat(r,*((*ef->name)[1]), rnew(r) span, NULL, p);
    break;

  case &UnknownId_p(_):     
  case &UnknownCall_p(_,_,_): 
  case &Aggr_p(_,_,_,_):      
  case &Exp_p(_): s = Any;
  }
  return s;
}

// A match is a list of patterns and their right-hand sides.  We
// parameterize over right-hand sides to make the code re-usable
// for compilation later on.  What we should really do is go ahead
// and compile to a decision tree and attach this to the abstract
// syntax...
typedef list_t<$(simple_pat_t<`r>,`rhs)@`r,`r> match_t<`rhs,`r>;
// A term descriptor describes a set of values using positive and/or
// negative information.  The descriptor Pos(c,[td1,...,tdn]) describes
// all values v of the form c(v1,...,vn), where vi is in the set
// described by tdi.  The descriptor Neg[c1,...,cn] describes all
// values v that are not of the form ci(v1,...,vm) (1 <= i <= n).
// Note that Neg[] denotes any possible value.
static tunion Term_desc<`r::R> {
  Pos(con_t<`r>,list_t<tunion `r Term_desc<`r>,`r>);
  Neg(Set::set_t<con_t<`r>,`r>);
};
typedef tunion `r Term_desc<`r> term_desc_t<`r>;

// Contexts represent a partial term-description matched thus far,
// from the root node of the object in a left-to-right fashion.
typedef list_t<$(con_t<`r>,list_t<term_desc_t<`r>,`r>)@`r,`r> context_t<`r>;
// A decision tree for compiling pattern-matches.  Failure denotes
// that an exception should be thrown.  Success triggers a right-hand-side.
// IfEq is a constructor test -- conceptually, the access path is a sequence
// of projections applied to the root object to get at the field being
// tested -- this will eventually have to change to have enough type
// information to really generate the right code.
typedef list_t<int,`r> access_t<`r>;

static tunion Decision<`rhs,`r::R> {
  Failure(term_desc_t<`r>);
  Success(`rhs);
  IfEq(access_t<`r>, con_t<`r>, 
       tunion `r Decision<`rhs,`r>, 
       tunion `r Decision<`rhs,`r>);
};
typedef tunion `r Decision<`rhs,`r> decision_t<`rhs,`r>;

// A work_stack records what tests we have to continue to do.  An
// implicit invariant is that for each frame on the stack, the
// length of the pattern, access, and term_desc lists are the same.
typedef  $(list_t<simple_pat_t<`r>,`r>,
	   list_t<access_t<`r>,`r>,
	   list_t<term_desc_t<`r>,`r>)@`r work_stack_frame_t<`r>;
typedef list_t<work_stack_frame_t<`r>,`r> work_stack_t<`r>;
// Used during primitive match compilation
static tunion Answer { Yes, No, Maybe };
typedef tunion Answer answer_t;

// Add c to a set of negative constructors for a term description.
// Assumes that td is a negative term description, that c is not
// already in the set, and that adding c does not cover all of the
// possible constructors.
static term_desc_t<`r> add_neg(region_t<`r> r, term_desc_t<`r> td, con_t<`r> c) {
  switch (td) {
  case &Neg(cs):
    if (Set::member(cs,c))
      impos("add_neg called when constructor already in set");
    if (c->span != NULL && (Set::cardinality(cs) + 1) >= *c->span)
      impos("add_neg called when |cs U {c}| >= span(c)");
    return rnew(r) Neg(Set::rinsert(r,cs,c));
  case &Pos(_,_): impos("add_neg called when td is Positive");
  }
}

// Returns whether or not values that start with constructor c are in the set
// described by the term descriptor td.
static answer_t static_match(con_t<`r> c, term_desc_t<`r> td) {
  switch (td) {
  case &Pos(c2,_):
    // td is the set of all values that start with c2
    if (compare_con(c,c2) == 0) return Yes;
    else return No;
  case &Neg(cs):
    // td is the set of all values that do not start with any of the cons in cs
    if (Set::member(cs,c)) return No;
    // when there are n possible starting constructors, c is not in cs,
    // and |cs| = n-1, then we know that c has to be in the set described by td
    else if ((c->span != NULL) && (*c->span == Set::cardinality(cs) + 1))
      return Yes;
    // otherwise, we can't be sure.
    else return Maybe;
  }
}

// Add dsc to the current node in the context -- note that this node
// is always at the beginning of the context.  Furthermore, the current
// node's sub-term-descriptors are in reverse order.  Thus, we just
// cons the dsc onto the first con's list of sub-term-desc's.
static context_t<`r> augment(region_t<`r> r, 
			     context_t<`r> ctxt, term_desc_t<`r> dsc) {
  switch (ctxt) {
  case NULL: return NULL; // ???
  case &List{.hd=&$(c,args), .tl=rest}:
    return rnew(r) 
      List(rnew(r) $(c, (list_t<term_desc_t>)(rnew(r) List(dsc,args))),rest);
  }
}

// When argument descriptions [dn,dn-1,...,d2,d1] have been found
// for all arguments of the local-most constructor c, we turn it
// into a positive descriptor Pos(c,[d1,d2,...,dn-1,dn]).
static context_t<`r> norm_context(region_t<`r> r, context_t<`r> ctxt) {
  switch (ctxt) {
  case NULL: impos("norm_context: empty context");
  case &List{.hd=&$(c,args), .tl=rest}: 
    return augment(r, rest, rnew(r) Pos(c, List::rrev(r,args)));
  }
}

// When moving from one match rule to another, we must re-construct the
// object description from the context (describes the part of the object
// up to the left of the current subterm), the current subterm description,
// and the term descriptions on the work stack, which, when taken together,
// describe the object to the right of the current subterm.
static term_desc_t<`r> build_desc(region_t<`r> r, context_t<`r> ctxt,
				  term_desc_t<`r> dsc, work_stack_t<`r> work){
  switch ($(ctxt,work)) {
  case $(NULL,NULL): return dsc;
  case $(NULL,_):    
  case $(_,   NULL): impos("build_desc: ctxt and work don't match");
  case $(&List{.hd=&$(c,args), .tl=rest}, &List{.hd=&$(_,_,dargs), .tl=work2}):
    let td = rnew(r) Pos(c, List::rappend(r, List::rrev(r,args), 
					  rnew(r) List(dsc,dargs)));
    return build_desc(r, rest, td, work2);
  } 
}

static decision_t<`rhs,`r> 
match(region_t<`r> r,simple_pat_t<`r> p, access_t<`r> obj, term_desc_t<`r> dsc,
      context_t<`r> ctx, work_stack_t<`r> work,
      `rhs right_hand_side, match_t<`rhs,`r> rules);

// Checks to see that the term (thus far described by dsc) matches one
// of the match_t rules.
static decision_t<`rhs,`r> or_match(region_t<`r> r, term_desc_t<`r> dsc,
				    match_t<`rhs,`r> allmrules) {
  switch(allmrules) {
  case NULL: return new Tcpat::Failure(dsc);
  case &List{.hd = &$(pat1, rhs1), .tl = rulerest}:
    return match(r, pat1, NULL, dsc, NULL, NULL, rhs1, rulerest);
  }
}

// Compiles a set of match rules to a decision tree.
static decision_t<`rhs,`r> match_compile(region_t<`r> r,
					 match_t<`rhs,`r> allmrules) {
  return or_match(r, rnew(r) Neg(empty_con_set(r)), allmrules);
}

// Succeeds returning the right-hand-side if every pattern matches the
// associated term-description in the work stack, or else the original
// object matches some rule from rules.
static 
decision_t<`rhs,`r> and_match(region_t<`r> r, context_t<`r> ctx,
			      work_stack_t<`r> work, `rhs right_hand_side, 
			      match_t<`rhs,`r> rules) {
  switch (work) {
  case NULL: return rnew(r) Success(right_hand_side);
  case &List{.hd = &$(NULL,NULL,NULL), .tl = workr }:
    return and_match(r, norm_context(r,ctx), workr, right_hand_side, rules);
  case &List{.hd = &$(pats,objs,dscs), .tl = workr }:
    if (pats == NULL || objs == NULL || dscs == NULL)
      impos("tcpat:and_match: malformed work frame");    
    let &List(pat1,patr) = (_@)pats;
    let &List(obj1,objr) = (_@)objs;
    let &List(dsc1,dscr) = (_@)dscs;
    let wf = rnew(r) $(patr, objr, dscr);
    return match(r,pat1,obj1,dsc1,ctx, rnew(r) List(wf,workr),
		 right_hand_side,rules);
  } 
}

// Get the term description arguments for a constructor term-description.
static list_t<term_desc_t<`r>,`r> 
getdargs(region_t<`r> r,con_t<`r> pcon,term_desc_t<`r> dsc) {
  switch (dsc) {
  case &Neg(ncs):
    // We only know that the term is con which is never in the set ncs.
    // So return Neg{} for each argument, reflecting that no information
    // is known about the arguments.
    term_desc_t any = rnew(r) Neg(empty_con_set(r));
    let res = NULL;
    for (int i = 0; i < pcon->arity; ++i)
      res = rnew(r) List(any,res);
    return res;
  case &Pos(_, dargs): return dargs;
  }
}

// Compute the paths for each argument when disassembling a constructor.
static access_t<`r> getoarg($(region_t<`r>,access_t<`r>)@ env, int i) {
  let &$(r,obj) = env;
  return rnew(r) List(i+1,obj);
}
static 
list_t<access_t<`r>,`r> getoargs(region_t<`r> r, con_t<`r> pcon, access_t<`r> obj) {
  let env = $(r,obj);
  return List::rtabulate_c(r, pcon->arity, getoarg, &env);
}

// Succeeds returning the right-hand-side if the pattern matches the
// description and every pattern matches the associated description
// in the work stack, or if the original object matches one of the rules.
static decision_t<`rhs,`r> 
match(region_t<`r> r,simple_pat_t<`r> p, access_t<`r> obj, term_desc_t<`r> dsc,
      context_t<`r> ctx, work_stack_t<`r> work,
      `rhs right_hand_side, match_t<`rhs,`r> rules) {
  switch (p) {
  case Any: return and_match(r,augment(r,ctx, dsc),work,right_hand_side,rules);
  case &Con(pcon, pargs):
    switch (static_match(pcon, dsc)) {
    case Yes:
      context_t<`r> ctx2       = rnew(r) List(rnew(r) $(pcon,NULL), ctx);
      work_stack_frame_t<`r> work_frame = rnew(r) $(pargs,getoargs(r,pcon,obj),
                                                    getdargs(r,pcon,dsc));
      work_stack_t<`r> work2  = rnew(r) List(work_frame, work);
      return and_match(r,ctx2,work2,right_hand_side,rules);
    case No:
      return or_match(r,build_desc(r,ctx,dsc,work),rules);
    case Maybe:
      context_t<`r> ctx2       = rnew(r) List(rnew(r) $(pcon,NULL), ctx);
      work_stack_frame_t<`r> work_frame = rnew(r) $(pargs,getoargs(r,pcon,obj),
                                                    getdargs(r,pcon,dsc));
      work_stack_t<`r> work2   = rnew(r) List(work_frame, work);
      let s          = and_match(r, ctx2, work2, right_hand_side, rules);
      let f          = or_match(r,build_desc(r,ctx, add_neg(r,dsc,pcon), work),
				rules);
      return rnew(r) IfEq(obj, pcon, s, f);
    }
  }
}

// Given a decision tree, call not_exhaust for each Failure node
// and call rhs_appears for each Success node.  Note that Failure
// implies the patterns are not exhaustive.  Note also that if
// any rhs for a match does not show up in the decision tree, then
// the associated pattern was redundant.
static void check_exhaust_overlap(region_t<`r> r,
                                  decision_t<`rhs,`r> d,
				  void not_exhaust(region_t<`r>,`a,term_desc_t<`r>), 
                                  `a env1,
				  void rhs_appears(`b,`rhs), `b env2,
                                  bool @exhaust_done) {
  switch (d) {
  case &Tcpat::Failure(td): 
    if (!(*exhaust_done)) { not_exhaust(r,env1,td); *exhaust_done = true; }
    break;
  case &Success(r):    rhs_appears(env2,r); break;
  case &IfEq(_,_,left,right):
    check_exhaust_overlap(r,left,  not_exhaust, env1, rhs_appears, env2, 
                          exhaust_done);
    check_exhaust_overlap(r,right, not_exhaust, env1, rhs_appears, env2,
                          exhaust_done);
    break;
  }
}

// Builds the decision tree for the switches, then checks to see
// if there are any failure nodes (pattern is inexhaustive) or if
// any pattern doesn't show up in the tree (pattern is redundant.)
// Both are considered errors as far as the type-checker is concerned.
static 
$(simple_pat_t<`r>, $(bool,seg_t)@`r)@`r get_match($(region_t<`r>,int @)@ env, 
                                                   switch_clause_t swc) {
  let &$(r,ctr) = env;
  simple_pat_t   sp0 = compile_pat(r,swc->pattern);
  $(bool,seg_t)@ rhs = rnew(r) $(false,swc->pattern->loc);
  simple_pat_t sp;
  if (swc->where_clause != NULL) {
    sp = tuple_pat(r,rnew(r) 
                   List(sp0,rnew(r) List(int_pat(r,*ctr,NULL),NULL)),NULL);
    *ctr = (*ctr) + 1;
  } else
    sp = tuple_pat(r,rnew(r) List(sp0,rnew(r) List(Any,NULL)),NULL);
  return rnew(r) $(sp, rhs);
}

// Turn a descriptor into an example for reporting an inexhaustive match
xtunion exn { Desc2string };
static string_t descs2string(region_t<`r> r, list_t<term_desc_t<`r>,`r>);
static string_t desc2string(region_t<`r> r, term_desc_t<`r> d) {
  switch (d) {
  case &Pos(c,ds):
    let n = c->name;
    let p = c->orig_pat;
    if (p == NULL) {
      return desc2string(r,ds->hd);
    }
    switch (p->r) {
    case Wild_p: return "_";
    case &Var_p(vd,_): return qvar2string(vd->name);
    case &Reference_p(vd,_): return aprintf("*%s",qvar2string(vd->name));
    case &TagInt_p(tv,vd): return aprintf("%s<`%s>",qvar2string(vd->name),
                                          *tv->name);
    case &Tuple_p(_,_): return aprintf("$(%s)",descs2string(r,ds));
    case &Pointer_p(&Pat{&Tunion_p(_,tuf,_,_),_,_}): 
      return aprintf("&%s(%s)",qvar2string(tuf->name),descs2string(r,ds));
    case &Pointer_p(_):
      return aprintf("&%s",descs2string(r,ds));
    case &Aggr_p(AggrInfo(KnownAggr(&ad),_),_,_,_): 
      return aprintf("%s{%s}",qvar2string(ad->name),descs2string(r,ds));
    case &Tunion_p(_, tuf, _, _): 
      return aprintf("%s",qvar2string(tuf->name));
    case Null_p: return "NULL";
    case &Int_p(_,i): return aprintf("%d",i);
    case &Char_p(c): return aprintf("%d",c);
    case &Float_p(f): return f;
    case &Enum_p(_,ef): fallthru(ef);
    case &AnonEnum_p(_,ef): return qvar2string(ef->name);
    case &Exp_p(e): return exp2string(e);
    default: throw Desc2string;
    }
  case &Neg(s):
    if (Set::is_empty(s)) return "_";
    let c = Set::choose(s);
    let orig_pat = c->orig_pat;
    // we need to figure out what the type of the pattern is
    // orig_pat is NULL when we have an && clause on a pattern
    if (orig_pat == NULL) throw Desc2string;
    switch (compress(orig_pat->topt->v)) {
    case &IntType(_,Char_sz): 
      // find a character not in the constructor set
      for (int i = 0; i < 256; i++) {
        let c = char_con(r,(char)i,orig_pat);
        if (!Set::member(s,c)) 
          return aprintf("%d",i);
      }
      throw Desc2string;
    case &IntType(_,_):
      // find an integer not in the constructor set
      for (unsigned int i = 0; i < (0 - 1); i++) {
        let c = int_con(r,(int)i,orig_pat);
        if (!Set::member(s,c)) 
          return aprintf("%d",i);
      }
      throw Desc2string;
    case &PointerType(PtrInfo(_,_,patts)):
      let n = patts.nullable;
      bool is_nullable = conref_def(false,n);
      if (is_nullable) {
        if (!Set::member(s,null_con(r,orig_pat))) 
          return "NULL";
      }
      return "&_";
    case &TunionType(TunionInfo{KnownTunion(&tud),_,_}):
      if (tud->is_xtunion) throw Desc2string;
      let fields = tud->fields->v;
      int span = List::length(fields);
      for (; fields; fields = fields->tl) {
        string_t n = *((*fields->hd->name)[1]);
        let args = fields->hd->typs;
        if (!Set::member(s,new Con_s(Name_v(n), 0, NULL, orig_pat))) {
          if (List::length(args) == 0)
            return n;
          else if (tud->is_flat)
            return aprintf("%s(...)",n);
            else 
              return aprintf("&%s(...)",n);
        }
      }
      throw Desc2string;
    default: throw Desc2string;
    }
  }
}
static stringptr_t desc2stringptr(region_t<`r> r, term_desc_t<`r> d) {
  return new (desc2string(r,d));
}
static string_t descs2string(region_t<`r> r,list_t<term_desc_t<`r>,`r> ds) {
  let ss = List::rmap_c(r,desc2stringptr,r,ds);
  stringptr_t comma = new ",";
  for (let x = ss; x != NULL; x = x->tl) {
    if (x->tl != NULL) {
      x->tl = new List{comma,x->tl};
      x = x->tl;
    }
  }
  return strconcat_l(ss);
}

static void not_exhaust_err(region_t<`r> r, seg_t loc, term_desc_t<`r> desc) {
  try {
    let s = desc2string(r,desc);
    terr(loc,"patterns may not be exhaustive.\n\tmissing case for %s",s);
  } catch {
  case Desc2string: 
    terr(loc,"patterns may not be exhaustive.");
    break;
  }
}
static void rule_occurs(int dummy, $(bool,seg_t)@ rhs) {
  (*rhs)[0] = true;
}
void check_switch_exhaustive(seg_t loc, tenv_t te, list_t<switch_clause_t> swcs) {
  // We represent "pat && e" as (simple_pat,i) where i is a unique integer.
  // We represent patterns without where clauses as (simple_pat,_).
  // This way, if we have the same pattern repeated, we get exhuastiveness
  // right as long as one of the copies does not have a where-clause.
  TEMP_RGN(te, r) {
  let where_ctr   = 0;
  let env = $(r,&where_ctr);
  let match_rules = List::rmap_c(r,get_match,&env,swcs);
  let dec_tree    = match_compile(r,match_rules);
  let ex_done = false;
  check_exhaust_overlap(r, dec_tree, not_exhaust_err, loc, rule_occurs, 0, 
                        &ex_done);
  for (; match_rules != NULL; match_rules = match_rules->tl) {
    let &$(_,&$(b,loc2)) = match_rules->hd;
    if (!b)
      terr(loc2,"redundant pattern");
  }
  }
}

// Build the decision tree for the pattern.  If Failure occurs, then
// the pattern is not exhaustive (a warning).  There's no way to get
// something that's redundant (unless we add support for "or" patterns
// of some sort.)
static void not_exhaust_warn(region_t<`r> r, $(seg_t, bool) @ pr, term_desc_t<`r> desc) {
  (*pr)[1] = false;
  try {
    let s = desc2string(r, desc);
    warn((*pr)[0],"pattern not exhaustive.\n\tmissing case for %s",s);
  } catch {
  case Desc2string:
    warn((*pr)[0],"pattern not exhaustive.");
    break;
  }
}
static void dummy_fn(int i,int j) {
  return;
}
bool check_let_pat_exhaustive(seg_t loc,tenv_t te,pat_t p) {
  TEMP_RGN(te,r) {
  let match_rules = rnew(r) List(rnew(r) $(compile_pat(r,p),0),NULL);
  let dec_tree    = match_compile(r, match_rules);
  let exhaust_env = $(loc,true);
  let ex_done = false;
  check_exhaust_overlap(r, dec_tree, not_exhaust_warn, &exhaust_env, dummy_fn, 0,
                        &ex_done);
  return exhaust_env[1];
  }
}

// Check that the patterns in a catch switch are non-overlapping.
// There's an implicit "re-throw on wild" pattern here, so no need
// to check for exhaustiveness.
static $(simple_pat_t<`r>, $(bool,seg_t)@`r)@`r get_match2(region_t<`r> r,
                                                           switch_clause_t swc) {
  simple_pat_t<`r>   sp0 = compile_pat(r,swc->pattern);
  $(bool,seg_t)@`r rhs = rnew(r) $(false,swc->pattern->loc);
  return rnew(r) $(sp0, rhs);
}
static void not_exhaust_err2(region_t<`r> r, seg_t loc, term_desc_t d) {
  // skip
}
void check_catch_overlap(seg_t loc, tenv_t te, list_t<switch_clause_t> swcs) {
  // We ignore where clauses here because catch's need not be exhaustive.
  TEMP_RGN(te, r) {
    let match_rules = List::rmap_c(r,get_match2,r,swcs);
    let dec_tree    = match_compile(r,match_rules);
    let ex_done = false;
    check_exhaust_overlap(r, dec_tree, not_exhaust_err2, loc, rule_occurs, 0,
                          &ex_done);
    for (; match_rules != NULL; match_rules = match_rules->tl) {
      let &$(_,&$(b,loc2)) = match_rules->hd;
      if (!b)
        terr(loc2,"redundant pattern");
    }
  }
}
