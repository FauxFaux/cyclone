// Type checking for patterns

#include "core.h"
#include "list.h"
#include "dict.h"
#include "set.h"
#include "string.h"
#include "position.h"
#include "absyn.h"
#include "absynpp.h"
#include "tcutil.h"
#include "tcenv.h"
#include "tcexp.h"
#include "tcpat.h"

namespace Tcpat;

using Core;
using List;
using Set;
using Position;
using Absyn;
using Absynpp;
using Tcutil;
using Tcenv;
using Tcexp;

/////////////////////////////////////////////////////////////////////////
// type-check a pattern and return a list of the bound type variables,
// and a list of the bound value variables, their types, and any
// qualifiers (e.g., const).
/////////////////////////////////////////////////////////////////////////
static $(list<designator>,pat)@ null_designator(pat p) {
  return &$(null,p);
}
static var get_name(vardecl vd) {
  return vd->name[1];
}
$(list<tvar>, list<vardecl>)@ tcPat<`p>(tenv_t te,pat p,typ *`p region_opt) {
  typ t;
  list<tvar>    tv_result = null;
  list<vardecl> v_result  = null;

  // Figure out what t should be; assign to p->topt and return after switch
  switch (p->r) {
  case Wild_p:      t = wildtyp(); break;
  case Int_p(s,i):  t = (s == Unsigned) ? uint_t : sint_t; break;
  case Char_p(c):   t = uchar_t; break;
  case Float_p(s):  t = float_t; break;
  case Null_p:
    t = PointerType(wildtyp(),wildtyp(),new_conref(true),empty_tqual()); 
    break;
  case Var_p(vd):
    t = wildtyp();
    vd->type   = t;
    vd->tq     = empty_tqual();
    vd->shadow = 0; // FIX?!?!?
    v_result = &cons(vd,v_result);
    break;
  case Reference_p(vd):
    t = wildtyp();
    if(region_opt == null) {
      terr(p->loc, "* pattern would point into an unknown region");
      break;
    }
    vd->type   = PointerType(t,*region_opt,new_conref(false),empty_tqual());
    vd->tq     = empty_tqual();
    vd->shadow = 0; // FIX?!?!?
    v_result = &cons(vd,v_result);
    break;

  case Pointer_p(p2):
    // we put in an unconstrained region.  Then the client calls
    // check_pat_regions after unifying against the type they're destructuring.
    typ ptr_rgn = wildtyp();
    let &$(sub_tvs,sub_vs) = tcPat(te,p2,&ptr_rgn);
    tv_result = List::append(tv_result, sub_tvs);
    v_result  = List::append(v_result,  sub_vs);
    t = PointerType(p2->topt->v, ptr_rgn, empty_conref(), empty_tqual());
    break;

  case Tuple_p(ps):
    list<$(tqual,typ)@> ts = null;
    for(; ps != null; ps=ps->tl) {
      let &$(sub_tvs,sub_vs) = tcPat(te,ps->hd,region_opt);
      tv_result = List::append(tv_result, sub_tvs);
      v_result  = List::append(v_result,  sub_vs);
      ts = &cons(&$(empty_tqual(),ps->hd->topt->v),ts);
    }
    t = TupleType(List::imp_rev(ts));
    break;

  case Struct_p(sd, *topt_ref,tvs,dps): 
    if (tvs != null)
      return impos("tcPat: struct<...> not implemented");
    // type check the argument patterns
    for (_ dps0 = dps; dps0 != null; dps0 = dps0->tl) {
      let &$(sub_tvs,sub_vs) = tcPat(te,dps0->hd[1],region_opt);
      tv_result = List::append(tv_result, sub_tvs);
      v_result  = List::append(v_result,  sub_vs);
    }
    // build up the instantiated pattern type
    _ all_inst = List::map(make_inst_var,sd->tvs);
    _ all_typs = List::map(snd,all_inst); 
    *topt_ref = &Opt(all_typs); // side effect
    t = StructType(sd->name,all_typs,&$(sd));
    // unify with the struct type
    list<$($(field_name,tqual,typ)@,pat)@> fields = 
      resolve_struct_designators(p->loc,dps,sd);
    for(; fields != null; fields = fields->tl) {
      let &$(&$(n,tq,fieldtyp),p_arg) = fields->hd;
      _ inst_fieldtyp = substitute(all_inst,fieldtyp);
      if (!unify(p_arg->topt->v,inst_fieldtyp))
	terr(p->loc,
	     xprintf("field %s of struct pattern expects type %s != %s",
		     n, typ2string(inst_fieldtyp), typ2string(p_arg->topt->v)));
    }
    break;

    // FIX: some day enums and xenums might not point into the heap.
  case Enum_p(q,_,tvs,ps,ed,ef): 
    typ heap = HeapRgnType;
    tenv_t te2 = add_type_vars(p->loc,te,tvs);
    tv_result = List::append(tv_result, tvs);
    _ all_inst = List::map(make_inst_var,ed->tvs);
    _ all_typs = List::map(snd,all_inst); 
    t = EnumType(ed->name,all_typs,&$(ed));
    list<$(tqual,typ)@> tqts = ef->typs;
    for(; ps != null && tqts != null; ps = ps->tl, tqts = tqts->tl) {
      _ p2 = ps->hd;
      let &$(sub_tvs,sub_vs) = tcPat(te2,p2,&heap);
      tv_result = List::append(tv_result, sub_tvs);
      v_result  = List::append(v_result,  sub_vs);
      _ field_typ = substitute(all_inst,tqts->hd[1]);
      if (!unify(p2->topt->v,field_typ))
        terr(p2->loc, xprintf("%s expects argument type %s, not %s",
			      qvar2string(q), 
			      typ2string(field_typ),
			      typ2string(p2->topt->v)));
    }
    if (ps != null)
      terr(p->loc,xprintf("too many arguments for enum constructor %s",
			  qvar2string(q)));
    if (tqts != null)
      terr(p->loc,xprintf("too few arguments for enum constructor %s",
			  qvar2string(q)));
    break;
  case Xenum_p(q,tvs,ps,xed,ef): 
    typ heap = HeapRgnType;
    tenv_t te2 = add_type_vars(p->loc,te,tvs);
    tv_result = List::append(tv_result, tvs);
    t = XenumType(xed->name,&$(xed));
    list<$(tqual,typ)@> tqts = ef->typs;
    for(; ps != null && tqts != null; ps = ps->tl, tqts = tqts->tl) {
      _ p2 = ps->hd;
      let &$(sub_tvs,sub_vs) = tcPat(te2,p2,&heap);
      tv_result = List::append(tv_result, sub_tvs);
      v_result  = List::append(v_result,  sub_vs);
      _ field_typ = tqts->hd[1];
      if (!unify(p2->topt->v,field_typ))
        terr(p2->loc,
             xprintf("%s expects argument type %s, not %s",
                     qvar2string(q),typ2string(field_typ),
                     typ2string(p2->topt->v)));
    }
    if (ps != null)
      terr(p->loc,xprintf("too many arguments for xenum constructor %s",
			  qvar2string(q)));
    if (tqts != null)
      terr(p->loc,xprintf("too few arguments for xenum constructor %s",
			  qvar2string(q)));
    break;

  case UnknownId_p(q):
    switch (lookup_ordinary(te,p->loc,q)) {
    case StructRes(_):
      terr(p->loc,"struct tag used without arguments in pattern");
      t = wildtyp();
      break;
    case EnumRes(ed,ef):
      p->r = Enum_p(ef->name,null,null,null,ed,ef);
      return tcPat(te,p,region_opt);
    case XenumRes(xed,ef):
      p->r = Xenum_p(ef->name,null,null,xed,ef);
      return tcPat(te,p,region_opt);
    default: // LocalRes, GlobalRes, UnknownRes
      if (q[0] == null) {
        p->r = Var_p(new_vardecl(q,VoidType,null));
        return tcPat(te,p,region_opt); // sets the vardecl's fields correctly
      }
      terr(p->loc,
           xprintf("unresolved identifier %s in pattern",qvar2string(q)));
      t = wildtyp();
      break;
    }
    break;
  case UnknownCall_p(q,tvs,ps):
    switch (lookup_ordinary(te,p->loc,q)) {
    case StructRes(sd):
      _ x = List::map(null_designator, ps);
      p->r = Struct_p(sd,null,tvs,x);
      return tcPat(te,p,region_opt);
    case EnumRes(ed,ef):
      p->r = Enum_p(ef->name,null,tvs,ps,ed,ef);
      return tcPat(te,p,region_opt);
    case XenumRes(xed,ef):
      p->r = Xenum_p(ef->name,tvs,ps,xed,ef);
      return tcPat(te,p,region_opt);
    default: // LocalRes, GlobalRes, UnknownRes
      terr(p->loc,
           xprintf("unresolved identifier %s in pattern",qvar2string(q)));
      t = wildtyp();
      break;
    }
    break;
  case UnknownFields_p(q,tvs,dps):
    switch (lookup_ordinary(te,p->loc,q)) {
    case StructRes(sd):
      p->r = Struct_p(sd,null,tvs,dps);
      return tcPat(te,p,region_opt);
    case EnumRes(ed,ef):
      terr(p->loc,"enum with designators not implemented");
      t = wildtyp();
      break;
    case XenumRes(xed,ef):
      terr(p->loc,"xenum with designators not implemented");
      t = wildtyp();
      break;
    default: // LocalRes, GlobalRes, UnknownRes
      terr(p->loc,
           xprintf("unresolved identifier %s in pattern",qvar2string(q)));
      t = wildtyp();
      break;
    }
    break;
  }
  p->topt = &Opt(t);
  check_unique_vars(List::map(get_name, v_result), p->loc,
		    "pattern contains a repeated variable");
  return &$(tv_result,v_result);
}

void check_pat_regions(tenv_t te, pat p) {
  switch(p->r) {
  case Pointer_p(p2):
    check_pat_regions(te,p2);
    switch (p->topt->v) {
    case PointerType(_,rt,_,_):
      check_rgn_accessible(te,p->loc,rt);
      return;
    default: throw Core::Impossible("check_pat_regions: bad pointer type");
    }
  case Struct_p(_,_,_,dps):  fallthru(List::map(snd,dps));
  case Xenum_p(_,_,ps,_,_):  fallthru(ps);
  case Enum_p(_,_,_,ps,_,_): fallthru(ps);
  case Tuple_p(ps):
    for(; ps != null; ps = ps->tl)
      check_pat_regions(te,ps->hd);
    return;
  default: return;
  }
}

//static void print_pats(string s, list<pat> ps) {
//  fprintf(cyc_stderr,"---pat list: %s---\n",s);
//  for (; ps != null; ps = ps->tl)
//    fprintf(cyc_stderr,"%s\n",pat2string(ps->hd));
//  fprintf(cyc_stderr,"--------------------------------\n\n");
//}

// The rest of this is for match compilation -- this seems to be
// the easiest way to check for overlapping or inexhaustive patterns.
// These ideas are lifted from Peter Sestoft's paper "ML pattern
// match compilation and partial evaluation", which appeared in
// Dagstuhl Seminar on Partial Evaluation, LNCS, Springer-Verlag,
// March 1996.  See
// ftp://ftp.dina.kvl.dk/pub/Staff/Peter.Sestoft/papers/match.ps.gz

// FIX:  we need short, long, and double patterns.  In addition, we
// should really allow constant-expressions in patterns, and we should
// allow integral promotion on integral patterns.  Still need
// to deal with FALLTHRU's, etc.  We should probably also hash-cons
// as suggested by Sestoft to avoid a potential exponential space
// blow-up, and the traversal of the decision tree should be turned
// into a depth-first dag traversal to avoid an exponential time
// blow-up.  We should hang on to the decision tree so that the
// compiler can make effective use of it.  We should generalize the
// access to a "switch" (instead of just an "if").  We should
// look at the MacQueen paper to do a better job of ordering the tests.

// We compile down to simple patterns for exhaustive/overlap checks.
// Any's represent variables or wild-cards, whereas Con's represent
// everything else.
// The "name" of the con is an integer or string.
// The arity is the number of arguments the constructor has, and the
// span is the total number of constructors for the given type.
// Constant patterns (e.g., 1, true, 3[0]4) have 0 arity.  The span
// for bool is 2, for char is 256, and for integers, floats, and
// Xenums is infinite (i.e., null).
static enum Name_value { Name_v(string); Int_v(int); };
typedef enum Name_value name_value_t;
static struct Con_s {
  name_value_t name;
  int          arity;
  Opt_t<int>   span;
};
typedef struct Con_s @con_t;
static enum Simple_pat { Any; Con(con_t,list<enum Simple_pat>); };
typedef enum Simple_pat simple_pat_t;

// used for creating sets of constructors
static int compare_con(con_t c1, con_t c2) {
  switch (c1->name) {
  case Name_v(n1):
    switch (c2->name) {
    case Name_v(n2): return String::zstrcmp(n1,n2);
    case Int_v(_):   return -1;
    }
  case Int_v(i1):
    switch (c2->name) {
    case Name_v(_): return 1;
    case Int_v(i2): return i1 - i2;
    }
  }
}

// build various cons
static Set::Set<con_t> empty_con_set() { return Set::empty(compare_con); }

static struct Opt<int> one_opt = { 1 };
static struct Opt<int> two_opt = { 2 };
static Opt_t<int> one_opt_ptr = &one_opt;

static name_value_t tuple_name = Name_v("tuple") ;

static struct Con_s true_con0     = { Name_v("true"),  0, &two_opt };
static struct Con_s false_con0    = { Name_v("false"), 0, &two_opt };
static struct Con_s null_con0     = { Name_v("null"),  0, &two_opt };
static struct Con_s null_ptr_con0 = { Name_v("ptr"),   1, &two_opt };
static struct Con_s ptr_con0      = { Name_v("ptr"),   1, &one_opt };

static con_t true_con     = &true_con0;
static con_t false_con    = &false_con0;
static con_t null_con     = &null_con0;
static con_t null_ptr_con = &null_ptr_con0;
static con_t ptr_con      = &ptr_con0;

static con_t int_con(int i)       { return &Con_s(Int_v(i),      0, null); }
static con_t char_con(char c)     { return &Con_s(Int_v((int)c), 0, &Opt(256));}
static con_t float_con(string f)  { return &Con_s(Name_v(f),  0, null); }
static con_t double_con(string d) { return &Con_s(Name_v(d),  0, null); }
static con_t tuple_con(int i)     { return &Con_s(tuple_name, i, one_opt_ptr); }

// build various simple patterns
static simple_pat_t true_pat()           { return Con(true_con,      null); }
static simple_pat_t false_pat()          { return Con(false_con,     null); }
static simple_pat_t null_pat()           { return Con(null_con,      null); }
static simple_pat_t int_pat(int i)       { return Con(int_con(i),    null); }
static simple_pat_t char_pat(char c)     { return Con(char_con(c),   null); }
static simple_pat_t float_pat(string f)  { return Con(float_con(f),  null); }
static simple_pat_t double_pat(string d) { return Con(double_con(d), null); }

static simple_pat_t null_ptr_pat(simple_pat_t p) {
  return Con(null_ptr_con,&cons(p,null));
}
static simple_pat_t ptr_pat(simple_pat_t p) { 
  return Con(ptr_con,&cons(p,null)); 
}
static simple_pat_t tuple_pat(list<simple_pat_t> ss) {
  return Con(tuple_con(List::length(ss)),ss);
}
static 
simple_pat_t con_pat(string con_name,Opt_t<int> span,list<simple_pat_t> ps) {
  con_t c = &Con_s(Name_v(con_name), List::length(ps), span);
  return Con(c,ps);
}

// compile a Cyclone pattern to a simple pattern
static simple_pat_t compile_pat(pat p) {
  simple_pat_t s;
  switch (p->r) {
  case Wild_p:         s = Any; break;
  case Var_p(_):       s = Any; break;
  case Null_p:         s = null_pat(); break;
  case Int_p(sn,i):    s = int_pat(i); break;
  case Char_p(c):      s = char_pat(c); break;
  case Float_p(f):     s = float_pat(f); break;
  case Tuple_p(ps):    s = tuple_pat(List::map(compile_pat,ps)); break;
  case Reference_p(_): s = Any; break;
  case Pointer_p(pp):
    simple_pat_t ss = compile_pat(pp);
    switch (compress(p->topt->v)) {
    case PointerType(_,_,n,_):
      bool is_nullable = false;
      bool still_working = true;
      while (still_working) {
	switch (n->v) {
	case Forward_constr(y): 
	  n->v = y->v; 
	  continue;
	case No_constr:
          n->v = Eq_constr(false);
          is_nullable   = false;
          still_working = false;  // EXIT LOOP
          break;
	case Eq_constr(x):
          is_nullable   = (bool)x;
          still_working = false;  // EXIT LOOP
          break;
	}
      }
      if (is_nullable) 
	s = null_ptr_pat(ss);
      else 
	s = ptr_pat(ss);
      break;
    default: s = impos("pointer pattern does not have pointer type!"); break;
    }
    break;
  case Struct_p(sd,_,_,dlps):
    list<simple_pat_t> ps = null;
    for (_ fields = sd->fields->v; fields != null; fields = fields->tl) {
      bool found = false;
      for(_ dlps0 = dlps; !found && dlps0 != null; dlps0 = dlps0->tl) {
	let &$(dl,p) = dlps0->hd;
	switch (dl) {
	case &cons{.hd=FieldName(f), .tl=null}: 
	  if(String::zstrcmp(f,fields->hd[0]) == 0) {
	    ps = &cons(compile_pat(p),ps);
	    found = true;
	  }
	  break;
	default: impos("bad designator(s)"); break;
	}
      }
      if(!found)
	impos("bad designator");
    }
    s = tuple_pat(ps);
    break;
  case Enum_p(_,_,_,ps,ed,ef):
    int span = List::length(ed->fields->v);
    s = con_pat(ef->name[1],&Opt(span),List::map(compile_pat,ps)); break;
  case Xenum_p(_,_,ps,xd,ef):
    s = con_pat(ef->name[1],null,List::map(compile_pat,ps)); break;
  case UnknownId_p(_):         s = impos("compile_pat: unknownid");     break;
  case UnknownCall_p(_,_,_):   s = impos("compile_pat: unknowncall");   break;
  case UnknownFields_p(_,_,_): s = impos("compile_pat: unknownfields"); break;
  }
  return s;
}

// A match is a list of patterns and their right-hand sides.  We
// parameterize over right-hand sides to make the code re-usable
// for compilation later on.  What we should really do is go ahead
// and compile to a decision tree and attach this to the abstract
// syntax...
#define match_t(rhs) list<$(simple_pat_t,rhs)@>
// A term descriptor describes a set of values using positive and/or
// negative information.  The descriptor Pos(c,[td1,...,tdn]) describes
// all values v of the form c(v1,...,vn), where vi is in the set
// described by tdi.  The descriptor Neg[c1,...,cn] describes all
// values v that are not of the form ci(v1,...,vm) (1 <= i <= n).
// Note that Neg[] denotes any possible value.
enum Term_desc {
  Pos(con_t,list<enum Term_desc>);
  Neg(Set::Set<con_t>);
};
typedef enum Term_desc term_desc_t;

// Contexts represent a partial term-description matched thus far,
// from the root node of the object in a left-to-right fashion.
#define context_t list<$(con_t,list<term_desc_t>)@>
// A decision tree for compiling pattern-matches.  Failure denotes
// that an exception should be thrown.  Success triggers a right-hand-side.
// IfEq is a constructor test -- conceptually, the access path is a sequence
// of projections applied to the root object to get at the field being
// tested -- this will eventually have to change to have enough type
// information to really generate the right code.
static enum Access { Obj; Sel(int, enum Access); }; // just an int list really
typedef enum Access access_t;

static enum Decision<`rhs> {
  Failure;
  Success(`rhs);
  IfEq(access_t, con_t, enum Decision<`rhs>, enum Decision<`rhs>);
};
typedef enum Decision<`rhs> decision_t<`rhs>;

// A work_stack records what tests we have to continue to do.  An
// implicit invariant is that for each frame on the stack, the
// length of the pattern, access, and term_desc lists are the same.
#define work_stack_frame $(list<simple_pat_t>,list<access_t>,list<term_desc_t>)@
#define work_stack list<work_stack_frame>
// Used during primitive match compilation
static enum Answer { Yes, No, Maybe };
typedef enum Answer answer_t;

// Add c to a set of negative constructors for a term description.
// Assumes that td is a negative term description, that c is not
// already in the set, and that adding c does not cover all of the
// possible constructors.
static term_desc_t add_neg(term_desc_t td, con_t c) {
  switch (td) {
  case Neg(cs):
    if (Set::member(cs,c))
      impos("add_neg called when constructor already in set");
    if (c->span != null && (Set::cardinality(cs) + 1) >= c->span->v)
	impos("add_neg called when |cs U {c}| >= span(c)");
    return Neg(Set::insert(cs,c));
  case Pos(_,_): return impos("add_neg called when td is Positive");
  }
}

// Returns whether or not values that start with constructor c are in the set
// described by the term descriptor td.
static answer_t static_match(con_t c, term_desc_t td) {
  switch (td) {
  case Pos(c2,_):
    // td is the set of all values that start with c2
    if (compare_con(c,c2) == 0) return Yes;
    else return No;
  case Neg(cs):
    // td is the set of all values that do not start with any of the cons in cs
    if (Set::member(cs,c)) return No;
    // when there are n possible starting constructors, c is not in cs,
    // and |cs| = n-1, then we know that c has to be in the set described by td
    else if ((c->span != null) && (c->span->v == Set::cardinality(cs) + 1))
      return Yes;
    // otherwise, we can't be sure.
    else return Maybe;
  }
}

// Add dsc to the current node in the context -- note that this node
// is always at the beginning of the context.  Furthermore, the current
// node's sub-term-descriptors are in reverse order.  Thus, we just
// cons the dsc onto the first con's list of sub-term-desc's.
static context_t augment(context_t ctxt, term_desc_t dsc) {
  switch (ctxt) {
  case null: return null; // ???
  case &cons{.hd=&$(c,args), .tl=rest}:
    return &cons(&$(c,(list<term_desc_t>)&cons(dsc, args)),rest);
  }
}

// When argument descriptions [dn,dn-1,...,d2,d1] have been found
// for all arguments of the local-most constructor c, we turn it
// into a positive descriptor Pos(c,[d1,d2,...,dn-1,dn]).
static context_t norm_context(context_t ctxt) {
  switch (ctxt) {
  case null: return impos("norm_context: empty context");
  case &cons{.hd=&$(c,args), .tl=rest}: 
    return augment(rest, Pos(c, List::rev(args)));
  }
}

// When moving from one match rule to another, we must re-construct the
// object description from the context (describes the part of the object
// up to the left of the current subterm), the current subterm description,
// and the term descriptions on the work stack, which, when taken together,
// describe the object to the right of the current subterm.
static term_desc_t build_desc<`a,`b>(context_t ctxt, term_desc_t dsc, 
				     work_stack work) {
  switch ($(ctxt,work)) {
  case $(null,null): return dsc;
  case $(null,_):    return impos("build_desc: ctxt and work don't match");
  case $(_,   null): return impos("build_desc: ctxt and work don't match");
  case $(&cons{.hd=&$(c,args), .tl=rest}, &cons{.hd=&$(_,_,dargs), .tl=work2}):
    _ td = Pos(c, List::append(List::rev(args), &cons(dsc,dargs)));
    return build_desc(rest, td, work2);
  } 
}

static decision_t<`rhs> // forward declaration
match<`rhs>(simple_pat_t p, access_t obj, term_desc_t dsc, context_t ctx, 
	    work_stack work, `rhs right_hand_side, match_t(`rhs) rules);

// Checks to see that the term (thus far described by dsc) matches one
// of the match_t rules.
static decision_t<`rhs> or_match<`rhs>(term_desc_t dsc, match_t(`rhs) allmrules){
  switch(allmrules) {
  case null: return Tcpat::Failure;
  case &cons{.hd = &$(pat1, rhs1), .tl = rulerest}:
    return match(pat1, Obj, dsc, null, null, rhs1, rulerest);
  }
}

// Compiles a set of match rules to a decision tree.
static decision_t<`rhs> match_compile<`rhs>(match_t(`rhs) allmrules) {
  return or_match(Neg(empty_con_set()), allmrules);
}

// Succeeds returning the right-hand-side if every pattern matches the
// associated term-description in the work stack, or else the original
// object matches some rule from rules.
static decision_t<`rhs> and_match<`rhs>(context_t ctx, work_stack work,
				    `rhs right_hand_side, match_t(`rhs) rules) {
  switch (work) {
  case null: return Success(right_hand_side);
  case &cons{.hd = &$(null,null,null), .tl = workr }:
    return and_match(norm_context(ctx), workr, right_hand_side, rules);
  case &cons{.hd = &$(pats,objs,dscs), .tl = workr }:
    if (pats == null || objs == null || dscs == null)
      return impos("tcpat:and_match: malformed work frame");    
    let &cons(pat1,patr) = pats;
    let &cons(obj1,objr) = objs;
    let &cons(dsc1,dscr) = dscs;
    _ wf = &$(patr, objr, dscr);
    return match(pat1,obj1,dsc1,ctx,&cons(wf,workr),right_hand_side,rules);
  } 
}

// Get the term description arguments for a constructor term-description.
static list<term_desc_t> getdargs(con_t pcon, term_desc_t dsc) {
  switch (dsc) {
  case Neg(ncs):
    // We only know that the term is con which is never in the set ncs.
    // So return Neg{} for each argument, reflecting that no information
    // is known about the arguments.
    term_desc_t any = Neg(empty_con_set());
    _ res = null;
    for (int i = 0; i < pcon->arity; ++i)
      res = &cons(any,res);
    return res;
  case Pos(_, dargs): return dargs;
  }
}

// Compute the paths for each argument when disassembling a constructor.
static access_t getoarg(access_t obj, int i) {
  return Sel(i+1,obj);
}
static list<access_t> getoargs(con_t pcon, access_t obj) {
  return List::tabulate_c(pcon->arity, getoarg, obj);
}

// Succeeds returning the right-hand-side if the pattern matches the
// description and every pattern matches the associated description
// in the work stack, or if the original object matches one of the rules.
static decision_t<`rhs> 
match<`rhs>(simple_pat_t p, access_t obj, term_desc_t dsc,
	    context_t ctx, work_stack work,
	    `rhs right_hand_side, match_t(`rhs) rules) {
  switch (p) {
  case Any: return and_match(augment(ctx, dsc), work, right_hand_side, rules);
  case Con(pcon, pargs):
    switch (static_match(pcon, dsc)) {
    case Yes:
      _ ctx2       = &cons(&$(pcon,null), ctx);
      _ work_frame = &$(pargs, getoargs(pcon, obj), getdargs(pcon, dsc));
      _ work2      = &cons(work_frame, work);
      return and_match(ctx2, work2, right_hand_side, rules);
    case No:
      return or_match(build_desc(ctx, dsc, work), rules);
    case Maybe:
      _ ctx2       = &cons(&$(pcon,null), ctx);
      _ work_frame = &$(pargs, getoargs(pcon, obj), getdargs(pcon, dsc));
      _ work2      = &cons(work_frame, work);
      _ s          = and_match(ctx2, work2, right_hand_side, rules);
      _ f          = or_match(build_desc(ctx, add_neg(dsc,pcon), work), rules);
      return IfEq(obj, pcon, s, f);
    }
  }
}

// Given a decision tree, call not_exhaust for each Failure node
// and call rhs_appears for each Success node.  Note that Failure
// implies the patterns are not exhaustive.  Note also that if
// any rhs for a match does not show up in the decision tree, then
// the associated pattern was redundant.
static 
void check_exhaust_overlap<`rhs,`a,`b>(decision_t<`rhs> d,
				       void not_exhaust(`a),      `a env1,
				       void rhs_appears(`b,`rhs), `b env2) {
  switch (d) {
  case Tcpat::Failure: not_exhaust(env1);   break;
  case Success(r):     rhs_appears(env2,r); break;
  case IfEq(_,_,left,right):
    check_exhaust_overlap(left,  not_exhaust, env1, rhs_appears, env2);
    check_exhaust_overlap(right, not_exhaust, env1, rhs_appears, env2);
    break;
  }
}

// Builds the decision tree for the switches, then checks to see
// if there are any failure nodes (pattern is inexhaustive) or if
// any pattern doesn't show up in the tree (pattern is redundant.)
// Both are considered errors as far as the type-checker is concerned.
static 
$(simple_pat_t, $(bool,seg_t)@)@ get_match(int @ r, switch_clause swc) {
  simple_pat_t sp0 = compile_pat(swc->pattern);
  $(bool,seg_t)@ rhs = &$(false,swc->pattern->loc);
  simple_pat_t sp;
  if (swc->where_clause != null) {
    sp = tuple_pat(&cons(sp0,&cons(int_pat(*r),null)));
    *r = (*r) + 1;
  } else
    sp = tuple_pat(&cons(sp0,&cons(Any,null)));
  return &$(sp, rhs);
}
static void not_exhaust_err(seg_t loc) {
  terr(loc,"patterns may not be exhaustive");
}
static void rule_occurs(int dummy, $(bool,seg_t)@ rhs) {
  rhs[0] = true;
}
void check_switch_exhaustive(seg_t loc, list<switch_clause> swcs) {
  // We represent "pat && e" as (simple_pat,i) where i is a unique integer.
  // We represent patterns without where clauses as (simple_pat,_).
  // This way, if we have the same pattern repeated, we get exhuastiveness
  // right as long as one of the copies does not have a where-clause.
  _ match_rules = List::map_c(get_match,(int @)&$(0),swcs);
  _ dec_tree    = match_compile(match_rules);
  check_exhaust_overlap(dec_tree, not_exhaust_err, loc, rule_occurs, 0);
  for (; match_rules != null; match_rules = match_rules->tl) {
    let &$(b,loc) = match_rules->hd[1];
    if (!b)
      terr(loc,"redundant pattern");
  }
}

// Build the decision tree for the pattern.  If Failure occurs, then
// the pattern is not exhaustive (a warning).  There's no way to get
// something that's redundant (unless we add support for "or" patterns
// of some sort.)
static void not_exhaust_warn($(seg_t, bool) @ pr) {
  pr[1] = false;
  warn(pr[0],"pattern not exhaustive");
}
static void dummy_fn(int i,int j) {
  return;
}
bool check_let_pat_exhaustive(seg_t loc,pat p) {
  _ match_rules = &cons(&$(compile_pat(p),0),null);
  _ dec_tree    = match_compile(match_rules);
  _ exhaust_env = &$(loc,true);
  check_exhaust_overlap(dec_tree, not_exhaust_warn, exhaust_env, dummy_fn, 0);
  return exhaust_env[1];
}

// Check that the patterns in a catch switch are non-overlapping.
// There's an implicit "re-throw on wild" pattern here, so no need
// to check for exhaustiveness.
static $(simple_pat_t, $(bool,seg_t)@)@ get_match2(switch_clause swc) {
  simple_pat_t sp0 = compile_pat(swc->pattern);
  $(bool,seg_t)@ rhs = &$(false,swc->pattern->loc);
  return &$(sp0, rhs);
}
static void not_exhaust_err2(segment loc) {
  ; // skip
}
void check_catch_overlap(seg_t loc, list<switch_clause> swcs) {
  // We ignore where clauses here because catch's need not be exhaustive.
  _ match_rules = List::map(get_match2,swcs);
  _ dec_tree    = match_compile(match_rules);
  check_exhaust_overlap(dec_tree, not_exhaust_err2, loc, rule_occurs, 0);
  for (; match_rules != null; match_rules = match_rules->tl) {
    _ pair = match_rules->hd[1];
    if (!pair[0])
      terr(pair[1],"redundant pattern");
  }
}
