/* Type checking for patterns.
   Copyright (C) 2001 Greg Morrisett, AT&T
   This file is part of the Cyclone compiler.

   The Cyclone compiler is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   The Cyclone compiler is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with the Cyclone compiler; see the file COPYING. If not,
   write to the Free Software Foundation, Inc., 59 Temple Place -
   Suite 330, Boston, MA 02111-1307, USA. */

#include <core.h>
#include <list.h>
#include <dict.h>
#include <set.h>
#include <string.h>
#include <position.h>
#include "absyn.h"
#include "absynpp.h"
#include "tcutil.h"
#include "tcenv.h"
#include "tcexp.h"
#include "tcpat.h"
#include <stdio.h>

using Core;
using List;
using Set;
using Position;
using Absyn;
using Absynpp;
using Tcutil;
using Tcenv;
using Tcexp;
namespace Tcpat;

/////////////////////////////////////////////////////////////////////////
// type-check a pattern and return a list of the bound type variables,
// and a list of the bound value variables, their types, and any
// qualifiers (e.g., const).
/////////////////////////////////////////////////////////////////////////

static void resolve_pat(tenv_t te, pat_t p) {
  switch(p->r) {
  case &UnknownId_p(q):
    try switch (lookup_ordinary(te,p->loc,q)) {
    case &AggrRes(_):
      terr(p->loc,"struct tag used without arguments in pattern");
      return;
    case &TunionRes(tud,tuf): p->r = new Tunion_p(tud,tuf,NULL); return;
    case &EnumRes(ed,ef):     p->r = new Enum_p(ed,ef); return;
    case &AnonEnumRes(t,ef):  p->r = new AnonEnum_p(t,ef); return;
    case &VarRes(_): break; // shadows an outer definition, but that's fine
    } catch { case Dict::Absent: break; } // a new variable
    // Unqualified variable is a declaration, qualified is an error
    switch ((*q)[0]) {
    case Loc_n: 
    case &Rel_n(NULL):
      (*q)[0] = Loc_n;        
      p->r = new Var_p(new_vardecl(q,VoidType,NULL)); // type set later
      return;
    default: terr(p->loc,"qualified variable in pattern"); return;
    }
  case &UnknownCall_p(q,ps):
    try switch (lookup_ordinary(te,p->loc,q)) {
    case &AggrRes(ad):
      if(ad->kind == UnionA) {
	terr(p->loc,"cannot pattern-match a union");
	return;
      }
      let new_ps = NULL;
      for(; ps != NULL; ps = ps->tl)
	new_ps = new List(new $(NULL,ps->hd), new_ps);
      p->r = new Aggr_p(AggrInfo(new KnownAggr(new ad),NULL),
			NULL,imp_rev(new_ps));
      return;
    case &TunionRes(tud,tuf): p->r = new Tunion_p(tud,tuf,ps); return;
    case &EnumRes(_,_):
    case &AnonEnumRes(_,_):
      terr(p->loc,"enum tag used with arguments in pattern");
      return;
    case &VarRes(_): break;
    } catch {case Dict::Absent: break;}
    terr(p->loc, "%s is not a constructor in pattern",qvar2string(q));
    return;

  case &Aggr_p(AggrInfo(&UnknownAggr(k,n),targs), exist_ts, dps):
    try { 
      let adp = lookup_aggrdecl(te,p->loc,n);
      let ad = *adp;
      if(ad->kind == UnionA) {
	terr(p->loc,"cannot pattern-match a union");
	return;
      }
      if(ad->impl==NULL) {
	terr(p->loc, "can't destructure an abstract struct");
	return;
      }
      int more_exists = length(ad->impl->exist_vars) - length(exist_ts);
      if(more_exists != 0)
	terr(p->loc, "wrong number of existentially bound type variables");
      // FIX: add missing ones for the user here!
      p->r = new Aggr_p(AggrInfo(new KnownAggr(adp), targs), exist_ts, dps);
    } catch { case Dict::Absent: 
      terr(p->loc, "Non-struct name has designator patterns"); break;
    }
    return;
  default: return;
  }
}

static var_t get_name(vardecl_t vd) {
  return (*vd->name)[1];
}
static type_t any_type(list_t<tvar_t,`H> s, type_t *`r topt) {
  if(topt != NULL)
    return *topt;
  return new_evar(&mk,new Opt(s));
}
static type_t num_type(type_t *`r topt, type_t numt) {
  // by setting to whatever topt is, unification will succeed.  Because
  // comparison between any two num types succeeds, this is fine (but kludgey)
  // FIX:? Allow *topt to be an Enum ?
  if(topt != NULL && coerceable(*topt))
    return *topt;
  // now allow enum to be cast up too
  switch(compress(numt)) {
  case &EnumType(_,_): if(topt != NULL) return *topt; break;
  default: break;
  }
  return numt;
}
static void set_vd(vardecl_t vd, list_t<vardecl_t>@`r v_result_ptr, type_t t){
  vd->type = t;
  vd->tq   = empty_tqual();
  *v_result_ptr = new List(vd,*v_result_ptr);
}

$(list_t<tvar_t>, list_t<vardecl_t>) tcPatRec(tenv_t te,
					      pat_t  p,
					      type_t *`r1 topt,
					      type_t *`r2 region_opt) {
  resolve_pat(te,p);
  type_t t;
  list_t<tvar_t>    tv_result = NULL;
  list_t<vardecl_t> v_result  = NULL;

  // Figure out what t should be; assign to p->topt and return after switch
  switch (p->r) {

  case Wild_p:       
    t = any_type(lookup_type_vars(te),topt);
    break;
  case &Var_p(vd):
    t = any_type(lookup_type_vars(te),topt);
    set_vd(vd, &v_result, t);
    break;
  case &Reference_p(vd):
    t = any_type(lookup_type_vars(te),topt);
    if(region_opt == NULL) {
      terr(p->loc, "* pattern would point into an unknown/unallowed region");
      break;
    }
    set_vd(vd, &v_result, 
	   new PointerType(PtrInfo(t,*region_opt,new_conref(false),
				     empty_tqual(),empty_conref())));
    break;

  case &Int_p(Unsigned,_): t = num_type(topt, uint_typ);  break;
  case &Int_p(Signed,_):   t = num_type(topt, sint_typ);  break;
  case &Char_p(_):         t = num_type(topt, uchar_typ); break;
  case &Float_p(_):        t = num_type(topt, float_typ); break;
  case &Enum_p(ed,_):      t = num_type(topt, new EnumType(ed->name,ed)); break;
  case &AnonEnum_p(tenum,_): t = num_type(topt, tenum); break;
  case Null_p:
    if(topt != NULL)
      switch(compress(*topt)) {
      case &PointerType(_): t = *topt; goto tcpat_end;
      default: break;
      }
    let tenv_tvs = lookup_type_vars(te);
    t = new PointerType(PtrInfo(new_evar(&ak,new Opt(tenv_tvs)),
                                new_evar(&rk,new Opt(tenv_tvs)),
				new_conref(true),empty_tqual(),
                                empty_conref()));
    break;

  case &Pointer_p(p2):
    // FIX: In the TunionField for p2 case, we should really pass-through
    // the type instantiation information in topt!!!

    type_t inner_typ  = VoidType;
    let    inner_topt = NULL;
    if(topt != NULL)
      switch(compress(*topt)) {
      case &PointerType(PtrInfo(elt_typ,_,_,_,_)): 
	inner_typ  = elt_typ; 
	inner_topt = &inner_typ;
	break;
      default: break;
      }
    
    // we put in an unconstrained region.  Then the client calls
    // check_pat_regions after unifying against the type they're destructuring.
    type_t ptr_rgn = new_evar(&rk,new Opt(lookup_type_vars(te)));
    let $(sub_tvs,sub_vs) = tcPatRec(te,p2,inner_topt,&ptr_rgn);
    tv_result = List::append(tv_result, sub_tvs);
    v_result  = List::append(v_result,  sub_vs);
    // if p2's type is a tunion field type, then we cast
    // the type of p = &p2 to the appropriate tunion type, unless
    // topt suggests we do otherwise.
    if(inner_topt == NULL) 
      switch (compress(p2->topt->v)) {
      case &TunionFieldType(TunionFieldInfo{&KnownTunionfield(tud,tuf),targs}):
	t = new TunionType(TunionInfo{new KnownTunion(new tud),targs,ptr_rgn});
	break;
      default:
	t = new PointerType(PtrInfo{p2->topt->v, ptr_rgn, empty_conref(), 
				    empty_tqual(), empty_conref()});
	break;
      }
    else 
      t = new PointerType(PtrInfo(p2->topt->v, ptr_rgn, empty_conref(), 
				  empty_tqual(), empty_conref()));
    break;

  case &Tuple_p(ps):
    list_t<$(tqual_t,type_t)@> pat_ts  = NULL;
    list_t<$(tqual_t,type_t)@> topt_ts = NULL;
    if(topt != NULL)
      switch(compress(*topt)) {
      case &TupleType(tqts): topt_ts = tqts; break;
      default: break;
      }
    for(; ps != NULL; ps=ps->tl) {
      let inner_topt = NULL;
      if(topt_ts != NULL) {
	inner_topt = &(*topt_ts->hd)[1];
	topt_ts    = topt_ts->tl;
      }
      let $(sub_tvs,sub_vs) = tcPatRec(te,ps->hd,inner_topt,region_opt);
      tv_result = List::append(tv_result, sub_tvs);
      v_result  = List::append(v_result,  sub_vs);
      pat_ts = new List(new $(empty_tqual(),ps->hd->topt->v),pat_ts);
    }
    t = new TupleType(List::imp_rev(pat_ts));
    break;

  case &Aggr_p(AggrInfo(&KnownAggr(&ad),*tsp),exist_ts,dps):
    if(ad->impl==NULL) {
      terr(p->loc,"can't destructure an abstract struct");
      t = wildtyp(new Opt(lookup_type_vars(te)));
      break;
    }
    region rgn {
      // constrain the type variables to have box kind (still necessary?)
      // FIX: jcheney: this gets in my way, turning error into warning...
      let var_tvs = NULL;
      for (_ t = exist_ts; t != NULL; t = t->tl) {
	tvar_t tv = t->hd;
	switch (compress_kb(tv->kind)) {
	case &Eq_kb(BoxKind):      break;
        case &Unknown_kb(*f):      fallthru(f);
        case &Less_kb(*f,MemKind): fallthru(f);
        case &Less_kb(*f,AnyKind): *f = new Opt(new Eq_kb(BoxKind)); break;
	case &Eq_kb(k): fallthru(k);
        case &Less_kb(_,k): 
	  warn(p->loc,"struct %s abstracts type variable %s of kind %s != B",
               qvar2string(ad->name),*tv->name,kind2string(k)); 
	  break;
	}
	var_tvs = rnew(rgn) List((type_t)(new VarType(tv)),var_tvs);
      }
      var_tvs = imp_rev(var_tvs);

      tv_result = List::append(tv_result, exist_ts);
      tenv_t te2 = add_type_vars(p->loc,te,exist_ts);

      let tenv_tvs = lookup_type_vars(te2);
      let env = $(tenv_tvs,rgn);
      let all_inst   = List::rmap_c(rgn,r_make_inst_var,&env,ad->tvs);
      let exist_inst = List::rzip(rgn,rgn,ad->impl->exist_vars,var_tvs);
      let all_typs   = List::map(snd,all_inst);
      let exist_typs = List::map(snd,exist_inst);
      let inst       = List::rappend(rgn,all_inst,exist_inst);
      *tsp = all_typs;
      t = new AggrType(AggrInfo(new KnownAggr(new ad),*tsp));
      list_t<$(aggrfield_t,pat_t)@`rgn,`rgn> fields =
	resolve_struct_designators(rgn,p->loc,dps,ad->impl->fields);
      for(; fields != NULL; fields = fields->tl) {
	let &$(field,pat)     = fields->hd;
	let inst_fieldtyp     = rsubstitute(rgn,inst,field->type);
	let $(sub_tvs,sub_vs) = tcPatRec(te2,pat,&inst_fieldtyp,region_opt);
	tv_result = List::append(tv_result, sub_tvs);
	v_result  = List::append(v_result,  sub_vs);
	// must unify here or the type we gave pat won't ever get checked
	// against the exp we're matching against.  Even if we succeed now,
	// we could be constraining so as to catch an error later.
	if (!unify(pat->topt->v,inst_fieldtyp))
	  terr(p->loc,"field %s of struct pattern expects type %s != %s",
	       *field->name, typ2string(inst_fieldtyp), 
	       typ2string(pat->topt->v));
      }
    }
    break;

  case &Tunion_p(tud,tuf,ps): 
    region rgn {
      list_t<$(tqual_t,type_t)@> tqts = tuf->typs;

      let tenv_tvs = lookup_type_vars(te);
      let env = $(tenv_tvs,rgn);
      let inst    = List::rmap_c(rgn,r_make_inst_var,&env,tud->tvs);
      let all_typs = List::map(snd,inst);
      // unless topt says otherwise, guess we want Tunion when there are no args
      if(tqts == NULL)
	t = new TunionType(TunionInfo{new KnownTunion(new tud),
				      all_typs,
				      new_evar(&rk,new Opt(tenv_tvs))});
      else
	t = new TunionFieldType(TunionFieldInfo{new KnownTunionfield(tud,tuf),
						all_typs});
      if(topt != NULL && tqts == NULL)
	switch(compress(*topt)) {
	case &TunionFieldType(_): 
	  t = new TunionFieldType(TunionFieldInfo{new KnownTunionfield(tud,tuf),
						  all_typs});
	  break;
	case &TunionType(TunionInfo{_,targs,_}):
	  // these unifies could make topt cause an error
	  let a = all_typs;
	  for (; a != NULL && targs != NULL; a=a->tl,targs=targs->tl)
	    unify(a->hd,targs->hd);
	  break;
	default: break;
	}

      for(; ps != NULL && tqts != NULL; ps = ps->tl, tqts = tqts->tl) {
	let p2 = ps->hd;
	// Note:  we don't pass in ptr_rgn here because for value-carrying
	// constructors, the pointer's region is passed down as region_opt.
	let field_typ = rsubstitute(rgn, inst, (*tqts->hd)[1]);
	let $(sub_tvs,sub_vs) = tcPatRec(te,p2,&field_typ,region_opt);
	tv_result = List::append(tv_result, sub_tvs);
	v_result  = List::append(v_result,  sub_vs);
	// must unify here or the type we gave pat won't ever get checked
	// against the exp we're matching against.  Even if we succeed now,
	// we could be constraining so as to catch an error later.
	if (!unify(p2->topt->v,field_typ))
	  terr(p2->loc, "%s expects argument type %s, not %s",
               qvar2string(tud->name), typ2string(field_typ),
               typ2string(p2->topt->v));
      }
      if (ps != NULL)
	terr(p->loc,"too many arguments for tunion constructor %s",
             qvar2string(tud->name));
      if (tqts != NULL)
	terr(p->loc,"too few arguments for tunion constructor %s",
	     qvar2string(tud->name));
    }
    break;

  case &Aggr_p(AggrInfo(&UnknownAggr(_,_),_),_,_):
  case &UnknownId_p(_):         
  case &UnknownCall_p(_,_): t = wildtyp(new Opt(lookup_type_vars(te))); break;
  }
 tcpat_end:
  p->topt = new Opt(t);
  return $(tv_result,v_result);
}

$(list_t<tvar_t>, list_t<vardecl_t>) tcPat(tenv_t te,
					   pat_t  p,
					   type_t *`r1 topt,
					   type_t *`r2 region_opt) {
  let ans = tcPatRec(te,p,topt,region_opt);
  // caller will check tvar uniqueness when adding to environment
  region r {
    check_unique_vars(List::rmap(r, get_name, ans[1]), p->loc,
		      "pattern contains a repeated variable");
  }
  return ans;
}

void check_pat_regions(tenv_t te, pat_t p) {
  switch(p->r) {
  case &Pointer_p(p2):
    check_pat_regions(te,p2);
    switch (p->topt->v) {
    case &PointerType(PtrInfo{_,rt,_,_,_}): fallthru(rt);
    case &TunionType(TunionInfo{_,_,rt}):
      check_rgn_accessible(te,p->loc,rt);
      return;
    default: impos("check_pat_regions: bad pointer type");
    }
  case &Tunion_p(_,_,ps): 
    for(; ps != NULL; ps = ps->tl) check_pat_regions(te,ps->hd);
    switch (p->topt->v) {
    case &TunionType(TunionInfo{_,_,rt}):
      check_rgn_accessible(te,p->loc,rt);
      return;
    case &TunionFieldType(_): return;
    default: impos("check_pat_regions: bad tunion type");
    }
  case &Aggr_p(_,_,dps): 
    for(; dps != NULL; dps = dps->tl)
      check_pat_regions(te,(*dps->hd)[1]);
    return;
  case &Tuple_p(ps):
    for(; ps != NULL; ps = ps->tl)
      check_pat_regions(te,ps->hd);
    return;
  default: return;
  }
}

//static void print_pats(string s, list_t<pat_t> ps) {
//  fprintf(cyc_stderr,"---pat list: %s---\n",s);
//  for (; ps != NULL; ps = ps->tl)
//    fprintf(cyc_stderr,"%s\n",pat2string(ps->hd));
//  fprintf(cyc_stderr,"--------------------------------\n\n");
//}

// The rest of this is for match compilation -- this seems to be
// the easiest way to check for overlapping or inexhaustive patterns.
// These ideas are lifted from Peter Sestoft's paper "ML pattern
// match compilation and partial evaluation", which appeared in
// Dagstuhl Seminar on Partial Evaluation, LNCS, Springer-Verlag,
// March 1996.  See
// ftp://ftp.dina.kvl.dk/pub/Staff/Peter.Sestoft/papers/match.ps.gz

// FIX:  we need short, long, and double patterns.  In addition, we
// should really allow constant-expressions in patterns, and we should
// allow integral promotion on integral patterns.  Still need
// to deal with FALLTHRU's, etc.  We should probably also hash-cons
// as suggested by Sestoft to avoid a potential exponential space
// blow-up, and the traversal of the decision tree should be turned
// into a depth-first dag traversal to avoid an exponential time
// blow-up.  We should hang on to the decision tree so that the
// compiler can make effective use of it.  We should generalize the
// access to a "switch" (instead of just an "if").  We should
// look at the MacQueen paper to do a better job of ordering the tests.

// We compile down to simple patterns for exhaustive/overlap checks.
// Any's represent variables or wild-cards, whereas Con's represent
// everything else.
// The "name" of the con is an integer or string.
// The arity is the number of arguments the constructor has, and the
// span is the total number of constructors for the given type.
// Constant patterns (e.g., 1, true, 3[0]4) have 0 arity.  The span
// for bool is 2, for char is 256, and for integers, floats, and
// Xtunions is infinite (i.e., NULL).
static tunion Name_value { Name_v(string_t); Int_v(int); };
typedef tunion Name_value name_value_t;
static struct Con_s {
  name_value_t name;
  int          arity;
  opt_t<int>   span;
};
typedef struct Con_s @con_t;
static tunion Simple_pat { Any; Con(con_t,list_t<tunion Simple_pat>); };
typedef tunion Simple_pat simple_pat_t;

// used for creating sets of constructors
static int compare_con(con_t c1, con_t c2) {
  switch (c1->name) {
  case &Name_v(n1):
    switch (c2->name) {
    case &Name_v(n2): return zstrcmp(n1,n2);
    case &Int_v(_):   return -1;
    }
  case &Int_v(i1):
    switch (c2->name) {
    case &Name_v(_): return 1;
    case &Int_v(i2): return i1 - i2;
    }
  }
}

// build various cons
static Set::set_t<con_t,`r> empty_con_set(region_t<`r> r) { 
  return Set::rempty(r,compare_con); 
}

static struct Opt<int> one_opt = { 1 };
static struct Opt<int> two_opt = { 2 };
static opt_t<int> one_opt_ptr = &one_opt;

static tunion Name_value.Name_v null_name_value  = Name_v("NULL");
static tunion Name_value.Name_v ptr_name_value   = Name_v("ptr");
static tunion Name_value.Name_v tuple_name_value = Name_v("tuple");
static struct Con_s null_con0     = { &null_name_value,  0, &two_opt };
static struct Con_s null_ptr_con0 = { &ptr_name_value,   1, &two_opt };
static struct Con_s ptr_con0      = { &ptr_name_value,   1, &one_opt };

static con_t null_con     = &null_con0;
static con_t null_ptr_con = &null_ptr_con0;
static con_t ptr_con      = &ptr_con0;

static con_t int_con(int i)       { return new Con_s(new Int_v(i), 0, NULL); }
static con_t float_con(string_t<`H> f) {return new Con_s(new Name_v(f),0,NULL);}
static con_t char_con(char c) {return new Con_s(new Int_v(c), 0,new Opt(256));
}
static con_t tuple_con(int i)     { 
  return new Con_s(&tuple_name_value, i, one_opt_ptr); 
}

// build various simple patterns
static simple_pat_t null_pat()           {return new Con(null_con,     NULL); }
static simple_pat_t int_pat(int i)       {return new Con(int_con(i),   NULL); }
static simple_pat_t char_pat(char c)     {return new Con(char_con(c),  NULL); }
static simple_pat_t float_pat(string_t<`H> f){
  return new Con(float_con(f),NULL);
}
static simple_pat_t null_ptr_pat(simple_pat_t p) {
  return new Con(null_ptr_con,new List(p,NULL));
}
static simple_pat_t ptr_pat(simple_pat_t p) { 
  return new Con(ptr_con,new List(p,NULL)); 
}
static simple_pat_t tuple_pat(list_t<simple_pat_t,`H> ss) {
  return new Con(tuple_con(List::length(ss)),ss);
}
static simple_pat_t con_pat(string_t<`H> con_name, opt_t<int,`H> span,
			    list_t<simple_pat_t,`H> ps) {
  con_t c = new Con_s(new Name_v(con_name), List::length(ps), span);
  return new Con(c,ps);
}

// compile a Cyclone pattern to a simple pattern
static simple_pat_t compile_pat(pat_t p) {
  simple_pat_t s;
  switch (p->r) {
  case Wild_p:          s = Any; break;
  case &Var_p(_):       s = Any; break;
  case Null_p:          s = null_pat(); break;
  case &Int_p(sn,i):    s = int_pat(i); break;
  case &Char_p(c):      s = char_pat(c); break;
  case &Float_p(f):     s = float_pat(f); break;
  case &Reference_p(_): s = Any; break;
  case &Pointer_p(pp):
    switch (compress(p->topt->v)) {
    case &PointerType(PtrInfo{_,_,n,_,_}):
      bool is_nullable = false;
      bool still_working = true;
      while (still_working) {
	switch (n->v) {
	case &Forward_constr(y): 
	  n->v = y->v; 
	  continue;
	case No_constr:
          n->v = new Eq_constr(false);
          is_nullable   = false;
          still_working = false;  // EXIT LOOP
          break;
	case &Eq_constr(x):
          is_nullable   = (bool)x;
          still_working = false;  // EXIT LOOP
          break;
	}
      }
      simple_pat_t ss = compile_pat(pp);
      if (is_nullable) 
	s = null_ptr_pat(ss);
      else 
	s = ptr_pat(ss);
      break;
    case &TunionType(_):
      switch(pp->r) {
      case &Tunion_p(tud,tuf,ps):
	opt_t<int> span;
	if(tud->is_xtunion)
	  span = NULL;
	else
	  span = new Opt(List::length(tud->fields->v));
	s =con_pat(*((*tuf->name)[1]),span,List::map(compile_pat,ps)); 
	break;
      default: impos("non-[x]tunion pattern has tunion type");
      }
      break;
    default: impos("pointer pattern does not have pointer type");
    }
    break;

  case &Tunion_p(tud,tuf,NULL):
    opt_t<int,`H> span;
    switch(compress(p->topt->v)) {
    case &TunionType(_):     
      if(tud->is_xtunion)
	span = NULL;
      else
	span = new Opt(List::length(tud->fields->v)); 
      break;
    case &TunionFieldType(_): span = new Opt(1); break;
    default: span = impos("void tunion pattern has bad type"); break;
    }
    s = con_pat(*((*tuf->name)[1]),span, NULL); 
    break;
    
  case &Tunion_p(_,_,ps): fallthru(ps); // ps != NULL
  case &Tuple_p(ps): s = tuple_pat(List::map(compile_pat,ps)); break;

  case &Aggr_p(AggrInfo(&KnownAggr(&ad),_),_,dlps):
    // FIX: doesn't look like multiple designators are right
    list_t<simple_pat_t> ps = NULL;
    for (_ fields = ad->impl->fields; fields != NULL; fields = fields->tl) {
      // leave out bit fields without a name
      bool found = (strcmp(*fields->hd->name,"") == 0);
      for(_ dlps0 = dlps; !found && dlps0 != NULL; dlps0 = dlps0->tl) {
	let &$(dl,p) = dlps0->hd;
	switch (dl) {
	case &List{.hd=&FieldName(f), .tl=NULL}: 
	  if(zstrptrcmp(f,fields->hd->name) == 0) {
	    ps = new List(compile_pat(p),ps);
	    found = true;
	  }
	  break;
	default: impos("bad designator(s)"); 
	}
      }
      if(!found)
	impos("bad designator");
    }
    s = tuple_pat(ps);
    break;
      
  case &Enum_p(ed,ef):
    // FIX: two different enum constructors can have the same value so we
    // might not get a duplicate warning when we should.
    int span = List::length(ed->fields->v);
    s = con_pat(*((*ef->name)[1]), new Opt(span), NULL);
    break;
  case &AnonEnum_p(tenum,ef):
    // FIX: I had to put `H in here.  The problem must be that we type-check
    // the default first and try to unify impos's type (a type variable) with
    // the type of fields which was list_t<enumfield_t,#i>.  
    list_t<enumfield_t,`H> fields;
    switch (compress(tenum)) {
    case &AnonEnumType(fs): fields = fs; break;
    default: impos("bad type in AnonEnum_p");
    };
    // FIX: two different enum constructors can have the same value so we
    // might not get a duplicate warning when we should.
    int span = List::length(fields);
    s = con_pat(*((*ef->name)[1]), new Opt(span), NULL);
    break;

  case &UnknownId_p(_):     impos("compile_pat: unknownid");     
  case &UnknownCall_p(_,_): impos("compile_pat: unknowncall");   
  case &Aggr_p(_,_,_):      impos("compile_pat: bad aggr");
  }
  return s;
}

// A match is a list of patterns and their right-hand sides.  We
// parameterize over right-hand sides to make the code re-usable
// for compilation later on.  What we should really do is go ahead
// and compile to a decision tree and attach this to the abstract
// syntax...
typedef list_t<$(simple_pat_t,`rhs)@`r,`r> match_t<`rhs,`r>;
// A term descriptor describes a set of values using positive and/or
// negative information.  The descriptor Pos(c,[td1,...,tdn]) describes
// all values v of the form c(v1,...,vn), where vi is in the set
// described by tdi.  The descriptor Neg[c1,...,cn] describes all
// values v that are not of the form ci(v1,...,vm) (1 <= i <= n).
// Note that Neg[] denotes any possible value.
static tunion Term_desc<`r::R> {
  Pos(con_t,list_t<tunion `r Term_desc<`r>,`r>);
  Neg(Set::set_t<con_t,`r>);
};
typedef tunion `r Term_desc<`r> term_desc_t<`r>;

// Contexts represent a partial term-description matched thus far,
// from the root node of the object in a left-to-right fashion.
typedef list_t<$(con_t,list_t<term_desc_t<`r>,`r>)@`r,`r> context_t<`r>;
// A decision tree for compiling pattern-matches.  Failure denotes
// that an exception should be thrown.  Success triggers a right-hand-side.
// IfEq is a constructor test -- conceptually, the access path is a sequence
// of projections applied to the root object to get at the field being
// tested -- this will eventually have to change to have enough type
// information to really generate the right code.
typedef list_t<int,`r> access_t<`r>;

static tunion Decision<`rhs,`r::R> {
  Failure;
  Success(`rhs);
  IfEq(access_t<`r>, con_t, 
       tunion `r Decision<`rhs,`r>, 
       tunion `r Decision<`rhs,`r>);
};
typedef tunion `r Decision<`rhs,`r> decision_t<`rhs,`r>;

// A work_stack records what tests we have to continue to do.  An
// implicit invariant is that for each frame on the stack, the
// length of the pattern, access, and term_desc lists are the same.
typedef  $(list_t<simple_pat_t>,
	   list_t<access_t<`r>,`r>,
	   list_t<term_desc_t<`r>,`r>)@`r work_stack_frame_t<`r>;
typedef list_t<work_stack_frame_t<`r>,`r> work_stack_t<`r>;
// Used during primitive match compilation
static tunion Answer { Yes, No, Maybe };
typedef tunion Answer answer_t;

// Add c to a set of negative constructors for a term description.
// Assumes that td is a negative term description, that c is not
// already in the set, and that adding c does not cover all of the
// possible constructors.
static term_desc_t<`r> add_neg(region_t<`r> r, term_desc_t<`r> td, con_t c) {
  switch (td) {
  case &Neg(cs):
    if (Set::member(cs,c))
      impos("add_neg called when constructor already in set");
    if (c->span != NULL && (Set::cardinality(cs) + 1) >= c->span->v)
      impos("add_neg called when |cs U {c}| >= span(c)");
    return rnew(r) Neg(Set::rinsert(r,cs,c));
  case &Pos(_,_): impos("add_neg called when td is Positive");
  }
}

// Returns whether or not values that start with constructor c are in the set
// described by the term descriptor td.
static answer_t static_match(con_t c, term_desc_t td) {
  switch (td) {
  case &Pos(c2,_):
    // td is the set of all values that start with c2
    if (compare_con(c,c2) == 0) return Yes;
    else return No;
  case &Neg(cs):
    // td is the set of all values that do not start with any of the cons in cs
    if (Set::member(cs,c)) return No;
    // when there are n possible starting constructors, c is not in cs,
    // and |cs| = n-1, then we know that c has to be in the set described by td
    else if ((c->span != NULL) && (c->span->v == Set::cardinality(cs) + 1))
      return Yes;
    // otherwise, we can't be sure.
    else return Maybe;
  }
}

// Add dsc to the current node in the context -- note that this node
// is always at the beginning of the context.  Furthermore, the current
// node's sub-term-descriptors are in reverse order.  Thus, we just
// cons the dsc onto the first con's list of sub-term-desc's.
static context_t<`r> augment(region_t<`r> r, 
			     context_t<`r> ctxt, term_desc_t<`r> dsc) {
  switch (ctxt) {
  case NULL: return NULL; // ???
  case &List{.hd=&$(c,args), .tl=rest}:
    return rnew(r) 
      List(rnew(r) $(c, (list_t<term_desc_t>)(rnew(r) List(dsc,args))),rest);
  }
}

// When argument descriptions [dn,dn-1,...,d2,d1] have been found
// for all arguments of the local-most constructor c, we turn it
// into a positive descriptor Pos(c,[d1,d2,...,dn-1,dn]).
static context_t<`r> norm_context(region_t<`r> r, context_t<`r> ctxt) {
  switch (ctxt) {
  case NULL: impos("norm_context: empty context");
  case &List{.hd=&$(c,args), .tl=rest}: 
    return augment(r, rest, rnew(r) Pos(c, List::rrev(r,args)));
  }
}

// When moving from one match rule to another, we must re-construct the
// object description from the context (describes the part of the object
// up to the left of the current subterm), the current subterm description,
// and the term descriptions on the work stack, which, when taken together,
// describe the object to the right of the current subterm.
static term_desc_t<`r> build_desc(region_t<`r> r, context_t<`r> ctxt,
				  term_desc_t<`r> dsc, work_stack_t<`r> work){
  switch ($(ctxt,work)) {
  case $(NULL,NULL): return dsc;
  case $(NULL,_):    
  case $(_,   NULL): impos("build_desc: ctxt and work don't match");
  case $(&List{.hd=&$(c,args), .tl=rest}, &List{.hd=&$(_,_,dargs), .tl=work2}):
    let td = rnew(r) Pos(c, List::rappend(r, List::rrev(r,args), 
					  rnew(r) List(dsc,dargs)));
    return build_desc(r, rest, td, work2);
  } 
}

static decision_t<`rhs,`r> // forward declaration
match(region_t<`r>, simple_pat_t, access_t<`r>, term_desc_t<`r>, context_t<`r>, 
      work_stack_t<`r>, `rhs, match_t<`rhs,`r>);

// Checks to see that the term (thus far described by dsc) matches one
// of the match_t rules.
static decision_t<`rhs,`r> or_match(region_t<`r> r, term_desc_t<`r> dsc,
				    match_t<`rhs,`r> allmrules) {
  switch(allmrules) {
  case NULL: return Tcpat::Failure;
  case &List{.hd = &$(pat1, rhs1), .tl = rulerest}:
    return match(r, pat1, NULL, dsc, NULL, NULL, rhs1, rulerest);
  }
}

// Compiles a set of match rules to a decision tree.
static decision_t<`rhs,`r> match_compile(region_t<`r> r,
					 match_t<`rhs,`r> allmrules) {
  return or_match(r, rnew(r) Neg(empty_con_set(r)), allmrules);
}

// Succeeds returning the right-hand-side if every pattern matches the
// associated term-description in the work stack, or else the original
// object matches some rule from rules.
static 
decision_t<`rhs,`r> and_match(region_t<`r> r, context_t<`r> ctx,
			      work_stack_t<`r> work, `rhs right_hand_side, 
			      match_t<`rhs,`r> rules) {
  switch (work) {
  case NULL: return rnew(r) Success(right_hand_side);
  case &List{.hd = &$(NULL,NULL,NULL), .tl = workr }:
    return and_match(r, norm_context(r,ctx), workr, right_hand_side, rules);
  case &List{.hd = &$(pats,objs,dscs), .tl = workr }:
    if (pats == NULL || objs == NULL || dscs == NULL)
      impos("tcpat:and_match: malformed work frame");    
    let &List(pat1,patr) = (_@)pats;
    let &List(obj1,objr) = (_@)objs;
    let &List(dsc1,dscr) = (_@)dscs;
    let wf = rnew(r) $(patr, objr, dscr);
    return match(r,pat1,obj1,dsc1,ctx, rnew(r) List(wf,workr),
		 right_hand_side,rules);
  } 
}

// Get the term description arguments for a constructor term-description.
static list_t<term_desc_t<`r>,`r> 
getdargs(region_t<`r> r,con_t pcon,term_desc_t<`r> dsc) {
  switch (dsc) {
  case &Neg(ncs):
    // We only know that the term is con which is never in the set ncs.
    // So return Neg{} for each argument, reflecting that no information
    // is known about the arguments.
    term_desc_t any = rnew(r) Neg(empty_con_set(r));
    let res = NULL;
    for (int i = 0; i < pcon->arity; ++i)
      res = rnew(r) List(any,res);
    return res;
  case &Pos(_, dargs): return dargs;
  }
}

// Compute the paths for each argument when disassembling a constructor.
static access_t<`r> getoarg($(region_t<`r>,access_t<`r>)@ env, int i) {
  let &$(r,obj) = env;
  return rnew(r) List(i+1,obj);
}
static 
list_t<access_t<`r>,`r> getoargs(region_t<`r> r, con_t pcon, access_t<`r> obj) {
  let env = $(r,obj);
  return List::rtabulate_c(r, pcon->arity, getoarg, &env);
}

// Succeeds returning the right-hand-side if the pattern matches the
// description and every pattern matches the associated description
// in the work stack, or if the original object matches one of the rules.
static decision_t<`rhs,`r> 
match(region_t<`r> r,simple_pat_t p, access_t<`r> obj, term_desc_t<`r> dsc,
      context_t<`r> ctx, work_stack_t<`r> work,
      `rhs right_hand_side, match_t<`rhs,`r> rules) {
  switch (p) {
  case Any: return and_match(r,augment(r,ctx, dsc),work,right_hand_side,rules);
  case &Con(pcon, pargs):
    switch (static_match(pcon, dsc)) {
    case Yes:
      let ctx2       = rnew(r) List(rnew(r) $(pcon,NULL), ctx);
      let work_frame = rnew(r) $(pargs,getoargs(r,pcon,obj),
				 getdargs(r,pcon,dsc));
      let work2      = rnew(r) List(work_frame, work);
      return and_match(r,ctx2,work2,right_hand_side,rules);
    case No:
      return or_match(r,build_desc(r,ctx,dsc,work),rules);
    case Maybe:
      let ctx2       = rnew(r) List(rnew(r) $(pcon,NULL), ctx);
      let work_frame = rnew(r) $(pargs,getoargs(r,pcon,obj),
				 getdargs(r,pcon,dsc));
      let work2      = rnew(r) List(work_frame, work);
      let s          = and_match(r, ctx2, work2, right_hand_side, rules);
      let f          = or_match(r,build_desc(r,ctx, add_neg(r,dsc,pcon), work),
				rules);
      return rnew(r) IfEq(obj, pcon, s, f);
    }
  }
}

// Given a decision tree, call not_exhaust for each Failure node
// and call rhs_appears for each Success node.  Note that Failure
// implies the patterns are not exhaustive.  Note also that if
// any rhs for a match does not show up in the decision tree, then
// the associated pattern was redundant.
static void check_exhaust_overlap(decision_t<`rhs> d,
				  void not_exhaust(`a),      `a env1,
				  void rhs_appears(`b,`rhs), `b env2) {
  switch (d) {
  case Tcpat::Failure: not_exhaust(env1);   break;
  case &Success(r):    rhs_appears(env2,r); break;
  case &IfEq(_,_,left,right):
    check_exhaust_overlap(left,  not_exhaust, env1, rhs_appears, env2);
    check_exhaust_overlap(right, not_exhaust, env1, rhs_appears, env2);
    break;
  }
}

// Builds the decision tree for the switches, then checks to see
// if there are any failure nodes (pattern is inexhaustive) or if
// any pattern doesn't show up in the tree (pattern is redundant.)
// Both are considered errors as far as the type-checker is concerned.
static 
$(simple_pat_t, $(bool,seg_t)@`r)@`r get_match($(region_t<`r>,int @)@ env, 
					       switch_clause_t swc) {
  let &$(r,ctr) = env;
  simple_pat_t   sp0 = compile_pat(swc->pattern);
  $(bool,seg_t)@ rhs = rnew(r) $(false,swc->pattern->loc);
  simple_pat_t sp;
  if (swc->where_clause != NULL) {
    sp = tuple_pat(new List(sp0,new List(int_pat(*ctr),NULL)));
    *ctr = (*ctr) + 1;
  } else
    sp = tuple_pat(new List(sp0,new List(Any,NULL)));
  return rnew(r) $(sp, rhs);
}
static void not_exhaust_err(seg_t loc) {
  terr(loc,"patterns may not be exhaustive");
}
static void rule_occurs(int dummy, $(bool,seg_t)@ rhs) {
  (*rhs)[0] = true;
}
void check_switch_exhaustive(seg_t loc, list_t<switch_clause_t> swcs) {
  // We represent "pat && e" as (simple_pat,i) where i is a unique integer.
  // We represent patterns without where clauses as (simple_pat,_).
  // This way, if we have the same pattern repeated, we get exhuastiveness
  // right as long as one of the copies does not have a where-clause.
  region r {
  let where_ctr   = 0;
  let env = $(r,&where_ctr);
  let match_rules = List::rmap_c(r,get_match,&env,swcs);
  let dec_tree    = match_compile(r,match_rules);
  check_exhaust_overlap(dec_tree, not_exhaust_err, loc, rule_occurs, 0);
  for (; match_rules != NULL; match_rules = match_rules->tl) {
    let &$(_,&$(b,loc2)) = match_rules->hd;
    if (!b)
      terr(loc2,"redundant pattern");
  }
  }
}

// Build the decision tree for the pattern.  If Failure occurs, then
// the pattern is not exhaustive (a warning).  There's no way to get
// something that's redundant (unless we add support for "or" patterns
// of some sort.)
static void not_exhaust_warn($(seg_t, bool) @ pr) {
  (*pr)[1] = false;
  warn((*pr)[0],"pattern not exhaustive");
}
static void dummy_fn(int i,int j) {
  return;
}
bool check_let_pat_exhaustive(seg_t loc,pat_t p) {
  region r {
  let match_rules = rnew(r) List(rnew(r) $(compile_pat(p),0),NULL);
  let dec_tree    = match_compile(r, match_rules);
  let exhaust_env = $(loc,true);
  check_exhaust_overlap(dec_tree, not_exhaust_warn, &exhaust_env, dummy_fn, 0);
  return exhaust_env[1];
  }
}

// Check that the patterns in a catch switch are non-overlapping.
// There's an implicit "re-throw on wild" pattern here, so no need
// to check for exhaustiveness.
static $(simple_pat_t, $(bool,seg_t)@)@ get_match2(switch_clause_t swc) {
  simple_pat_t   sp0 = compile_pat(swc->pattern);
  $(bool,seg_t)@ rhs = new $(false,swc->pattern->loc);
  return new $(sp0, rhs);
}
static void not_exhaust_err2(seg_t loc) {
  // skip
}
void check_catch_overlap(seg_t loc, list_t<switch_clause_t> swcs) {
  // We ignore where clauses here because catch's need not be exhaustive.
  let match_rules = List::map(get_match2,swcs);
  let dec_tree    = match_compile(heap_region,match_rules);
  check_exhaust_overlap(dec_tree, not_exhaust_err2, loc, rule_occurs, 0);
  for (; match_rules != NULL; match_rules = match_rules->tl) {
    let &$(_,&$(b,loc2)) = match_rules->hd;
    if (!b)
      terr(loc2,"redundant pattern");
  }
}
