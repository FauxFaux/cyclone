{
/* Notes

   Many libraries incorrectly define macros for functions without also
   providing a function prototype.  The C standard says that function
   macros can be disabled by putting parens around the function name;
   e.g., (getc)(f) overrides the macro and calls the function
   directly.  Similarly you are supposed to be able to #undef macros
   and use the function.  We need to detect this situation and build a
   C stub automatically.

   It would be nice if buildlib did sanity checking, to make sure that
   the extern "C" function prototypes we code by hand match up with
   the actual C declarations.

   Cygwin sys/select.h defines a struct and then a typedef with the
   same name.  Our current scheme for halting repeated definitions
   does not separate typedefs and structs, so the typedef ends up
   undefined.  The current hack is to hand-define it in that special
   case.

   The #include <setjmp.h> in precore_c.h pollutes the namespace.
   Specifically, it defines some of the signal functions in Cygwin in
   a way that conflicts with the definitions I make in Cyclone.
   (precore_c.h is included in the output of the compiler for every
   Cyclone file.)  Maybe we can use buildlib to extract just the
   definitions we need from setjmp.h -- we need a flag in the parser
   that disables Cyclone keywords, so that we can parse more C code.

   Some C headers use sizeof(type) in constant expressions, which we
   don't currently allow in Cyclone.  The current hack is to
   precalculate the sizes using gcc, and do a textual replace of the
   sizeof expression with the actual size.  (The reason we don't allow
   it in Cyclone right now is that our compiler is not capable of
   calculating it at compile time, since it relies on gcc to lay out
   memory.)

   Cyclone does not currently handle long double complex, which is
   needed in <complex.h>.

   On some systems types aren't defined where they should be.  I
   added cpp for this case, but it would be better to do things
   automatically.

   Some systems don't define types at all -- e.g., socklen_t.  In
   such cases we might be able to derive the type from a function
   that uses it; we currently just take a guess.

   Some systems define typedefs with macros -- e.g., socklen_t in
   cygwin.

   OS X defines a struct with no members [/usr/include/net/if_var.h]
   and we don't parse it:
        struct tqdummy {
        };
 */

#include <core.h>
#include <lexing.h>
#include <set.h>
#include <string.h>
#include <list.h>
#include <hashtable.h>
#include <filename.h>
#include <position.h>
#include <arg.h>
#include <buffer.h>
#include "absyn.h"
#include "absynpp.h"
#include "parse.h"

#include <stdlib.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <ctype.h>

namespace Lex {
  extern void lex_init();
}

using Lexing;
using List;
using Core;
using Absyn;

extern "C" Cstring Ccomp; // The string to invoke gcc

FILE *log_file = NULL;
FILE *cstubs_file = NULL;
FILE *cycstubs_file = NULL;

int log(const char ?fmt, ... inject parg_t<`r2> ap) 
  __attribute__((format(printf,1,2)))
{
  if (log_file == NULL) {
    fprintf(stderr,"Internal error: log file is NULL\n");
    exit(1);
  }
  let x = vfprintf((FILE@)log_file,fmt,ap);
  fflush((FILE@)log_file);
  return x;
}

/* These will be filled in using gcc later */
int sizeof_unsignedlongint = -1;
int sizeof_unsignedshortint = -1;
int sizeof_shortint = -1;
int sizeof_int = -1;
int sizeof_short = -1;
int sizeof_fdmask = -1;
int sizeof___fdmask = -1;
int sizeof_uint32 = -1;
int sizeof_sockaddr = -1;
int sizeof_inport = -1;
int sizeof_inaddr = -1;

static string_t *current_source = NULL;
static list_t<stringptr_t> current_args = NULL;
static Set::set_t<stringptr_t> *current_targets = NULL;
static void add_target(stringptr_t<`H,`H> sptr) {
  current_targets = new Set::insert(*current_targets,sptr);
}

/* Forward declarations of lexing functions */
typedef $(stringptr_t,Set::set_t<stringptr_t>) *line_t;
extern line_t line(Lexbuf<`a>);
extern int macroname(Lexbuf<`a>);
extern int args(Lexbuf<`a>);
extern int token(Lexbuf<`a>);
extern int string(Lexbuf<`a>);

FILE *slurp_out = NULL;
extern int slurp(Lexbuf<`a>);
extern int slurp_string(Lexbuf<`a>);
extern int asm(Lexbuf<`a>);
extern int asm_string(Lexbuf<`a>);
extern int asm_comment(Lexbuf<`a>);

typedef $(string_t,stringptr_t) *suck_line_t;
extern suck_line_t suck_line(Lexbuf<`a>);
extern int suck_macroname(Lexbuf<`a>);
extern int suck_restofline(Lexbuf<`a>);
string_t current_line = NULL;

/* When $(A,B) is an ifdefined_t, B will be printed if A is NULL
   or A is a defined symbol */
typedef $(string_t<`H>,string_t<`H>) @ifdefined_t;

typedef $(string_t,list_t<stringptr_t>,list_t<stringptr_t>,
          list_t<ifdefined_t>,list_t<ifdefined_t>,
          list_t<ifdefined_t>,list_t<ifdefined_t>) *spec_t;
extern spec_t spec(Lexbuf<`a>);
extern int commands(Lexbuf<`a>);
extern int snarfsymbols(Lexbuf<`a>);
extern int block(Lexbuf<`a>);
extern int block_string(Lexbuf<`a>);
extern int block_comment(Lexbuf<`a>);
string_t current_header = NULL;
list_t<stringptr_t> snarfed_symbols = NULL;
list_t<stringptr_t> current_symbols = NULL;
list_t<ifdefined_t> current_cstubs = NULL;
list_t<ifdefined_t> current_cycstubs = NULL;
list_t<ifdefined_t> current_prologue = NULL;
list_t<ifdefined_t> current_epilogue = NULL;
list_t<stringptr_t> current_omit_symbols = NULL;
list_t<stringptr_t> current_cpp = NULL;
struct Buffer::t *specbuf = NULL;
int braces_to_match = 0;
int parens_to_match = 0;

int numdef = 0;
}

let newline = ('\n' | '\r' | "\r\n")
let idchar = ['A'-'Z''a'-'z''0'-'9''_']
let ws = [' ''\t''\n''\r']

/**********************************************************************/
/* Rules for finding dependencies of macros                           */
/**********************************************************************/
rule line "line_t" = parse
  "#define "
{ macroname(lexbuf);
  for (; current_args != NULL; current_args = current_args->tl) {
    current_targets = new Set::delete(*current_targets,current_args->hd);
  }
  /* The cast is needed so the return type matches */
  return new $((_ @)current_source,*current_targets);}
/* End of line */
| newline
{ return line(lexbuf); }
| eof
{ return NULL; }

and macroname = parse
  idchar+ '(' ')'
{ current_source = new (string_t)substring(lexeme(lexbuf), 0,
                                          lexeme_end(lexbuf)-lexeme_start(lexbuf)-2);
  current_args = NULL;
  current_targets = new Set::empty(strptrcmp);
  token(lexbuf);
  return 0;
}
| idchar+ '('
{ current_source = new (string_t)substring(lexeme(lexbuf), 0,
                                          lexeme_end(lexbuf)-lexeme_start(lexbuf)-1);
  current_args = NULL;
  current_targets = new Set::empty(strptrcmp);
  args(lexbuf);
  return 0;
}
| idchar+
{ current_source = new (string_t)lexeme(lexbuf);
  current_args = NULL;
  current_targets = new Set::empty(strptrcmp);
  token(lexbuf);
  return 0;
}

and args = parse
  idchar+ ',' ' '
{ let a = new (string_t)substring(lexeme(lexbuf), 0,
                                  lexeme_end(lexbuf)-lexeme_start(lexbuf)-2);
  current_args = new List(a,current_args);
  return args(lexbuf);
}
| idchar+ ')'
{ let a = new (string_t)substring(lexeme(lexbuf), 0,
                                  lexeme_end(lexbuf)-lexeme_start(lexbuf)-1);
  current_args = new List(a,current_args);
  return token(lexbuf);
}

and token = parse
/* Identifiers and keywords */
  ['A'-'Z''a'-'z''_']['A'-'Z''a'-'z''_''0'-'9']*
{ add_target(new (string_t)lexeme(lexbuf)); return token(lexbuf); }
/* End of file or line */
| (eof | ['\n' '\r'])
{ return 0; }
/* Other whitespace */
| [' ' '\t' '\v' '\f']+
{ return  token(lexbuf); }
/* string constants */
| "\""
{ string(lexbuf); return token(lexbuf);}
/* Integer constants */
| '0'['x''X']['0'-'9''a'-'f''A'-'F']+((['u''U']['l''L']?)|(['l''L']['u''U']?))?
{ return token(lexbuf); }
| '0'['0'-'7']*((['u''U']['l''L']?)|(['l''L']['u''U']?))?
{ return token(lexbuf); }
| '0'['0'-'9']+((['u''U']['l''L']?)|(['l''L']['u''U']?))?
{ return token(lexbuf); }
| ['1'-'9']['0'-'9']*((['u''U']['l''L']?)|(['l''L']['u''U']?))?
{ return token(lexbuf); }
/* Floating-point constants */
| ['0'-'9']+['e''E']['+''-']?['0'-'9']+['f''F''l''L']?
{ return token(lexbuf); }
| ((['0'-'9']+'.')|(['0'-'9']+'.'['0'-'9']+)|('.'['0'-'9']+))
  (['e''E']['+''-']?['0'-'9']+)?['f''F''l''L']?
{ return token(lexbuf); }
/* character constants */
| "'\\a'"
{ return token(lexbuf); }
| "'\\b'"
{ return token(lexbuf); }
| "'\\f'"
{ return token(lexbuf); }
| "'\\n'"
{ return token(lexbuf); }
| "'\\r'"
{ return token(lexbuf); }
| "'\\t'"
{ return token(lexbuf); }
| "'\\v'"
{ return token(lexbuf); }
| "'\\\\'"
{ return token(lexbuf); }
| "'\\''"
{ return token(lexbuf); }
| "'\\\"'"
{ return token(lexbuf); }
| "'\\?'"
{ return token(lexbuf); }
| "'\\" ['0'-'7']['0'-'7']?['0'-'7']? "'"
{ return token(lexbuf); }
| "'\\x" ['0'-'9''A'-'Z''a'-'z']+ "'"
{ return token(lexbuf); }
| "'" [^ '\\' '\'' '\n'] "'"
{ return token(lexbuf); }
/* Operators */
| "=="
{ return token(lexbuf); }
| "!="
{ return token(lexbuf); }
| "<="
{ return token(lexbuf); }
| ">="
{ return token(lexbuf); }
| "++"
{ return token(lexbuf); }
| "--"
{ return token(lexbuf); }
| "+="
{ return token(lexbuf); }
| "-="
{ return token(lexbuf); }
| "*="
{ return token(lexbuf); }
| "/="
{ return token(lexbuf); }
| "%="
{ return token(lexbuf); }
| "|="
{ return token(lexbuf); }
| "^="
{ return token(lexbuf); }
| "&="
{ return token(lexbuf); }
| "<<="
{ return token(lexbuf); }
| ">>="
{ return token(lexbuf); }
| "&&"
{ return token(lexbuf); }
| "||"
{ return token(lexbuf); }
| "<<"
{ return token(lexbuf); }
| ">>"
{ return token(lexbuf); }
| "<>"
{ return token(lexbuf); }
| "->"
{ return token(lexbuf); }
| "..."
{ return token(lexbuf); }
| "::"
{ return token(lexbuf); }
/* Default case */
| _
{ return token(lexbuf); }

and string = parse
    "\"" [' ''\n''\r''\t']* "\""
  /* concatenate adjacent strings */
                    { return string(lexbuf); }
  | "\""            { return 0; }
  | "\\" newline    { return string(lexbuf); }
  | "\\a"           { return string(lexbuf); }
  /* octal character escapes */
  | "\\" ['0'-'7']['0'-'7']?['0'-'7']?
                    { return string(lexbuf); }
  /* hex character escapes FIX? any length okay? */
  | "\\x" ['0'-'9''A'-'F''a'-'f']+
                    { return string(lexbuf);}
  | [^ '"''\\''\n']   /* NOT double quote, backslash, or newline */
                    { return string(lexbuf); }
  | newline         { return 0; }
  | eof             { return 0; }
  | _               { return string(lexbuf); }

/**********************************************************************/
/* Rules to ``fix up'' C code so that it will go through the Cyclone  */
/* parser.  E.g., eliminate/modify unsupported attributes, other      */
/* unsavory hacks.                                                    */
/**********************************************************************/
and slurp = parse /* returns 1 if more to do, 0 if all done */
  eof
{ return 0; }
| "\""
{ fputc('"',(FILE @)slurp_out);
  while (slurp_string(lexbuf)) /* skip */;
  return 1;
}
/* Currently Cyclone doesn't allow sizeofs as constant expressions.
   So we calculate the sizes in a previous phase and insert them
   here on a case-by-case basis. */
| "sizeof" ws* "(" ws* "fd_mask" ws* ")"
{ fprintf((FILE @)slurp_out," %d ",sizeof_fdmask);
  log("Warning: sizeof(fd_mask) inlined\n");
  return 1; }
| "sizeof" ws* "(" ws* "__fd_mask" ws* ")"
{ fprintf((FILE @)slurp_out," %d ",sizeof___fdmask);
  log("Warning: sizeof(__fd_mask) inlined\n");
  return 1; }
| "sizeof" ws* "(" ws* "__uint32_t" ws* ")"
{ fprintf((FILE @)slurp_out," %d ",sizeof_uint32);
  log("Warning: sizeof(__uint32_t) inlined\n");
  return 1; }
| "sizeof" ws* "(" ws* "in_port_t" ws* ")"
{ fprintf((FILE @)slurp_out," %d ",sizeof_inport);
  log("Warning: sizeof(__in_port_t) inlined\n");
  return 1; }
| "sizeof" ws* "(" ws* "int" ws* ")"
{ fprintf((FILE @)slurp_out," %d ",sizeof_int);
  log("Warning: sizeof(int) inlined\n");
  return 1; }
| "sizeof" ws* "(" ws* "short" ws* ")"
{ fprintf((FILE @)slurp_out," %d ",sizeof_short);
  log("Warning: sizeof(__short) inlined\n");
  return 1; }
| "sizeof" ws* "(" ws* "unsigned" ws+ "long" ws+ "int" ws* ")"
{ fprintf((FILE @)slurp_out," %d ",sizeof_unsignedlongint);
  log("Warning: sizeof(unsigned long int) inlined\n");
  return 1; }
| "sizeof" ws* "(" ws* "unsigned" ws+ "short" ws+ "int" ws* ")"
{ fprintf((FILE @)slurp_out," %d ",sizeof_unsignedshortint);
  log("Warning: sizeof(unsigned short int) inlined\n");
  return 1; }
| "sizeof" ws* "(" ws* "short" ws+ "int" ws* ")"
{ fprintf((FILE @)slurp_out," %d ",sizeof_shortint);
  log("Warning: sizeof(short int) inlined\n");
  return 1; }
| "sizeof" ws* "(" ws* "struct" ws+ "sockaddr" ws* ")"
{ fprintf((FILE @)slurp_out," %d ",sizeof_sockaddr);
  log("Warning: sizeof(struct sockaddr) inlined\n");
  return 1; }
| "sizeof" ws* "(" ws* "struct" ws+ "in_addr" ws* ")"
{ fprintf((FILE @)slurp_out," %d ",sizeof_inaddr);
  log("Warning: sizeof(struct inaddr) inlined\n");
  return 1; }
| "*" ws* "malloc" ws* "("
/* malloc is a Cyclone keyword so our parser can't handle a malloc
   declaration. */
{ fputs("*__IGNORE_FOR_CYCLONE_MALLOC(",(FILE @)slurp_out);
  log("Warning: declaration of malloc sidestepped\n");
  return 1; }
| ws+ "malloc" ws* "("
/* malloc is a Cyclone keyword so our parser can't handle a malloc
   declaration. */
{ fputs(" __IGNORE_FOR_CYCLONE_MALLOC(",(FILE @)slurp_out);
  log("Warning: declaration of malloc sidestepped\n");
  return 1; }
| "*" ws* "calloc" ws* "("
/* calloc is a Cyclone keyword so our parser can't handle a calloc
   declaration. */
{ fputs("*__IGNORE_FOR_CYCLONE_CALLOC(",(FILE @)slurp_out);
  log("Warning: declaration of calloc sidestepped\n");
  return 1; }
| ws+ "calloc" ws* "("
/* calloc is a Cyclone keyword so our parser can't handle a calloc
   declaration. */
{ fputs(" __IGNORE_FOR_CYCLONE_CALLOC(",(FILE @)slurp_out);
  log("Warning: declaration of calloc sidestepped\n");
  return 1; }
| "*region" /* Used in OS X in mach/vm_map.h, conflicts with our keyword */
{ fputs("__region",(FILE @)slurp_out);
  log("Warning: use of region sidestepped\n");
  return 1; }
| "__extension__" /* Used in cygwin in sys/reent.h */
{ return 1; }
| "__attribute__ ((__mode__ (__HI__)))" /* Used in linux in _G_config.h */
{ return 1; }
| "__attribute__ ((__mode__ (__SI__)))" /* Used in linux in _G_config.h */
{ return 1; }
| "__attribute__ ((__mode__ (__QI__)))" /* Used in linux in sys/types.h */
{ return 1; }
| "__attribute__ ((__mode__ (__DI__)))" /* Used in linux in sys/types.h */
{ return 1; }
| "__attribute__ ((__mode__ (__word__)))" /* Used in linux in sys/types.h */
{ return 1; }
| "__inline__" /* Used in cygwin in stdio.h */
{ fputs("inline",(FILE @)slurp_out); return 1; }
| "__inline" /* Used in OS X */
{ fputs("inline",(FILE @)slurp_out); return 1; }
| "__const__"
{ fputs("const",(FILE @)slurp_out); return 1; }
| "__const" /* Used in cygwin in unistd.h; an undocumented gcc extension?? */
{ fputs("const",(FILE @)slurp_out); return 1; }
| "__builtin_va_list"
/* Used in linux in /usr/lib/gcc-lib/i386-redhat-linux/2.96/include/stdarg.h;
   an undocumented gcc extension?  This is a HACK -- shouldn't matter since
   we don't use va_list */
{ fputs("int",(FILE @)slurp_out); return 1; }
| "__restrict" /* Used in linux in libio.h; an undocumented gcc extension?? */
{ return 1; }
| "__asm__" ws* '(' /* Used in cygwin in /usr/include/asm files for inline functions */
{ parens_to_match = 1;
  while (asm(lexbuf)) /* skip */;
  fputs("0",(FILE @)slurp_out); /* appears as expression followed by ';' typically */
  log("Warning: replacing use of __asm__ with 0\n");
  return 1; }
| [^ '"']
{ fputc(lexeme_char(lexbuf,0),(FILE @)slurp_out); return 1; }

and slurp_string = parse /* returns 1 if more to do, 0 if all done */
  eof
{ return 0; }
| "\""
{ fputc('"',(FILE @)slurp_out); return 0; }
| newline
{ log("Warning: unclosed string\n");
  fprintf((FILE @)slurp_out,"%s",lexeme(lexbuf)); return 1; }
| "\\" newline
{ fprintf((FILE @)slurp_out,"%s",lexeme(lexbuf)); return 1; }
| "\\a"
{ fprintf((FILE @)slurp_out,"%s",lexeme(lexbuf)); return 1; }
| "\\" ['0'-'7']['0'-'7']?['0'-'7']?
{ fprintf((FILE @)slurp_out,"%s",lexeme(lexbuf)); return 1; }
| "\\x" ['0'-'9''A'-'F''a'-'f']+
{ fprintf((FILE @)slurp_out,"%s",lexeme(lexbuf)); return 1; }
| [^ '"''\\''\n']
{ fprintf((FILE @)slurp_out,"%s",lexeme(lexbuf)); return 1; }
| _
{ fprintf((FILE @)slurp_out,"%s",lexeme(lexbuf)); return 1; }

and asm =
/* Expects to be entered just after a left paren, searches for the
   matching right paren, deletes everything in between.
   Parens in comments, strings, and character constants aren't counted.
   parens_to_match should be set to 1 before calling asm. */
 /* returns 1 if more to do, 0 if all done */
parse
  eof
{ return 0; }
| ')'
{ if (parens_to_match == 1) return 0;
  parens_to_match--;
  return 1; }
| '('
{ parens_to_match++;
  return 1; }
| '"'
{ while (asm_string(lexbuf)) /* skip */;
  return 1; }
| "/*"
{ while (asm_comment(lexbuf)) /* skip */;
  return 1; }
| "//" [^'\n''\r']*
{ return 1; }
| [^')']
{ return 1; }

and asm_string = parse /* returns 1 if more to do, 0 if all done */
  eof
{ log("Warning: unclosed string\n"); return 0; }
| "\""
{ return 0; }
| newline
{ log("Warning: unclosed string\n"); return 1; }
| "\\" newline
{ return 1; }
| "\\a"
{ return 1; }
| "\\" ['0'-'7']['0'-'7']?['0'-'7']?
{ return 1; }
| "\\x" ['0'-'9''A'-'F''a'-'f']+
{ return 1; }
| [^ '"''\\''\n']
{ return 1; }
| _
{ return 1; }

and asm_comment = parse /* returns 1 if more to do, 0 if all done */
  eof
{ log("Warning: unclosed comment\n"); return 0; }
| "*/"      /* Assumes that comments can't be nested */
{ return 0; }
| _
{ return 1; }

/**********************************************************************/
/* Rules to suck in a #define line and return it, along with the name */
/* of the macro                                                       */
/**********************************************************************/
and suck_line "suck_line_t" = parse
  "#define "
{ current_line = "#define ";
  suck_macroname(lexbuf);
  return new $(current_line,(stringptr_t)current_source); }
| ['\n' '\r']
{ return suck_line(lexbuf); }
| eof
{ return NULL; }

and suck_macroname = parse
  idchar+
{ current_source = new (string_t)lexeme(lexbuf);
  current_line = strconcat(current_line,*current_source);
  return suck_restofline(lexbuf);
}

and suck_restofline = parse
  [^'\n''\r']*
{ current_line = strconcat(current_line,lexeme(lexbuf)); return 0; }

/**********************************************************************/
/* Rules to read in header spec files                                 */
/**********************************************************************/
and spec "spec_t" = parse
  "//" [^'\n''\r']*
{ return spec(lexbuf); }
| ['A'-'Z''a'-'z''0'-'9''_''.''/']+ ':'
{ current_header =
  (string_t)substring(lexeme(lexbuf), 0,
                      lexeme_end(lexbuf)-lexeme_start(lexbuf)-1);
  current_symbols = NULL;
  current_omit_symbols = NULL;
  current_cstubs = NULL;
  current_cycstubs = NULL;
  current_prologue = NULL;
  current_epilogue = NULL;
  while (commands(lexbuf)) /* skip */;
  current_prologue = imp_rev(current_prologue);
  current_epilogue = imp_rev(current_epilogue);
  current_cstubs = imp_rev(current_cstubs);
  current_cycstubs = imp_rev(current_cycstubs);
  return new $(current_header,
               current_symbols,
               current_omit_symbols,
               current_prologue,
               current_epilogue,
               current_cstubs,
               current_cycstubs);
}
| ws+
{ return spec(lexbuf); }
| eof
{ return NULL; }
| _
{ fprintf(stderr,
          "Error in .cys file: expected header file name, found '%c' instead\n",
          lexeme_char(lexbuf,0));
  return NULL; }

and commands = parse /* returns 1 if more to do, 0 if all done */
  eof
{ return 0; }
| ';'
{ return 0; }
| "include" ws+ '{'
{ snarfed_symbols = NULL;
  while (snarfsymbols(lexbuf)) /* skip */;
  current_symbols = append(snarfed_symbols,current_symbols);
  return 1; }
| "omitvariables" ws+ '{'
{ snarfed_symbols = NULL;
  while (snarfsymbols(lexbuf)) /* skip */;
  current_omit_symbols = append(snarfed_symbols,current_omit_symbols);
  return 1; }
| "prologue" ws+ '{'
{ braces_to_match = 1;
  specbuf = Buffer::create(255);
  while (block(lexbuf)) /* skip */;
  ifdefined_t x = new $((string_t)NULL,
                        (string_t)Buffer::contents((Buffer::T)specbuf));
  current_prologue = new List(x,current_prologue);
  return 1; }
| "prologue" ws+ idchar+ ws+ '{'
{ let s = lexeme(lexbuf);
  s += strlen("prologue");
  while (isspace(*s)) s++;
  char ?t = s;
  while (!isspace(*t)) t++;
  let symbol = substring(s,0,t-s);
  braces_to_match = 1;
  specbuf = Buffer::create(255);
  while (block(lexbuf)) /* skip */;
  ifdefined_t x = new $((string_t)symbol,
                        (string_t)Buffer::contents((Buffer::T)specbuf));
  current_prologue = new List(x,current_prologue);
  return 1; }
| "epilogue" ws+ '{'
{ braces_to_match = 1;
  specbuf = Buffer::create(255);
  while (block(lexbuf)) /* skip */;
  ifdefined_t x = new $((string_t)NULL,
                        (string_t)Buffer::contents((Buffer::T)specbuf));
  current_epilogue = new List(x,current_epilogue);
  return 1; }
| "epilogue" ws+ idchar+ ws+ '{'
{ let s = lexeme(lexbuf);
  s += strlen("epilogue");
  while (isspace(*s)) s++;
  char ?t = s;
  while (!isspace(*t)) t++;
  let symbol = substring(s,0,t-s);
  braces_to_match = 1;
  specbuf = Buffer::create(255);
  while (block(lexbuf)) /* skip */;
  ifdefined_t x = new $((string_t)symbol,
                        (string_t)Buffer::contents((Buffer::T)specbuf));
  current_epilogue = new List(x,current_epilogue);
  return 1; }
| "cstub" ws+ '{'
{ braces_to_match = 1;
  specbuf = Buffer::create(255);
  while (block(lexbuf)) /* skip */;
  ifdefined_t x = new $((string_t)NULL,
                        (string_t)Buffer::contents((Buffer::T)specbuf));
  current_cstubs = new List(x,current_cstubs);
  return 1; }
| "cstub" ws+ idchar+ ws+ '{'
{ let s = lexeme(lexbuf);
  s += strlen("cstub");
  while (isspace(*s)) s++;
  char ?t = s;
  while (!isspace(*t)) t++;
  let symbol = substring(s,0,t-s);
  braces_to_match = 1;
  specbuf = Buffer::create(255);
  while (block(lexbuf)) /* skip */;
  ifdefined_t x = new $((string_t)symbol,
                        (string_t)Buffer::contents((Buffer::T)specbuf));
  current_cstubs = new List(x,current_cstubs);
  return 1; }
| "cycstub" ws+ '{'
{ braces_to_match = 1;
  specbuf = Buffer::create(255);
  while (block(lexbuf)) /* skip */;
  ifdefined_t x = new $((string_t)NULL,
                        (string_t)Buffer::contents((Buffer::T)specbuf));
  current_cycstubs = new List(x,current_cycstubs);
  return 1; }
| "cycstub" ws+ idchar+ ws+ '{'
{ let s = lexeme(lexbuf);
  s += strlen("cycstub");
  while (isspace(*s)) s++;
  char ?t = s;
  while (!isspace(*t)) t++;
  let symbol = substring(s,0,t-s);
  braces_to_match = 1;
  specbuf = Buffer::create(255);
  while (block(lexbuf)) /* skip */;
  ifdefined_t x = new $((string_t)symbol,
                        (string_t)Buffer::contents((Buffer::T)specbuf));
  current_cycstubs = new List(x,current_cycstubs);
  return 1; }
| "cpp" ws* '{'
{ braces_to_match = 1;
  specbuf = Buffer::create(255);
  while (block(lexbuf)) /* skip */;
  stringptr_t x = new (string_t)Buffer::contents((Buffer::T)specbuf);
  current_cpp = new List(x,current_cpp);
  return 1; }
| "//" [^'\n''\r']*
{ return 1; }
| ws+
{ return 1; }
| _
{ fprintf(stderr,
          "Error in .cys file: expected command, found '%c' instead\n",
          lexeme_char(lexbuf,0));
  return 0; }

and snarfsymbols =
/* Expects to be entered just after a left brace, searches for the
   a sequence of symbols and the matching right brace, stores the
   symbols in snarfed_symbols. */
/* returns 1 if more to do, 0 if all done */
parse
  idchar+
{ snarfed_symbols = new List(new (string_t)lexeme(lexbuf),snarfed_symbols);
  return 1; }
| ws+
{ return 1; }
| '}'
{ return 0; }
| eof
{ fprintf(stderr,
          "Error in .cys file: unexpected end-of-file\n");
  return 0; }
| _
{ fprintf(stderr,
          "Error in .cys file: expected symbol, found '%c' instead\n",
          lexeme_char(lexbuf,0));
  return 0; }

and block =
/* Expects to be entered just after a left brace, searches for the
   matching right brace, appends everything in between to specbuf.
   Braces in comments, strings, and character constants aren't counted.
   braces_to_match should be set to 1 before calling block. */
/* returns 1 if more to do, 0 if all done */
parse
  eof
{ log("Warning: unclosed brace\n"); return 0; }
| '}'
{ if (braces_to_match == 1) return 0;
  braces_to_match--;
  Buffer::add_char((Buffer::T)specbuf,'}');
  return 1; }
| '{'
{ braces_to_match++;
  Buffer::add_char((Buffer::T)specbuf,'{');
  return 1; }
| '"'
{ Buffer::add_char((Buffer::T)specbuf,'"');
  while (block_string(lexbuf)) /* skip */;
  return 1; }
| "/*"
{ Buffer::add_string((Buffer::T)specbuf,"/*");
  while (block_comment(lexbuf)) /* skip */;
  return 1; }
| "//" [^'\n''\r']*
{ Buffer::add_string((Buffer::T)specbuf,lexeme(lexbuf));
  return 1; }
| [^'}']
{ Buffer::add_char((Buffer::T)specbuf,lexeme_char(lexbuf,0));
  return 1; }

and block_string = parse /* returns 1 if more to do, 0 if all done */
  eof
{ log("Warning: unclosed string\n"); return 0; }
| "\""
{ Buffer::add_char((Buffer::T)specbuf,'"'); return 0; }
| newline
{ log("Warning: unclosed string\n");
  Buffer::add_string((Buffer::T)specbuf,lexeme(lexbuf));
  return 1; }
| "\\" newline
{ Buffer::add_string((Buffer::T)specbuf,lexeme(lexbuf));
  return 1; }
| "\\a"
{ Buffer::add_string((Buffer::T)specbuf,lexeme(lexbuf));
  return 1; }
| "\\" ['0'-'7']['0'-'7']?['0'-'7']?
{ Buffer::add_string((Buffer::T)specbuf,lexeme(lexbuf));
  return 1; }
| "\\x" ['0'-'9''A'-'F''a'-'f']+
{ Buffer::add_string((Buffer::T)specbuf,lexeme(lexbuf));
  return 1; }
| [^ '"''\\''\n']
{ Buffer::add_string((Buffer::T)specbuf,lexeme(lexbuf));
  return 1; }
| _
{ Buffer::add_string((Buffer::T)specbuf,lexeme(lexbuf));
  return 1; }

and block_comment = parse /* returns 1 if more to do, 0 if all done */
  eof
{ log("Warning: unclosed comment\n"); return 0; }
| "*/"      /* Assumes that comments can't be nested */
{ Buffer::add_string((Buffer::T)specbuf,"*/"); return 0; }
| _
{ Buffer::add_string((Buffer::T)specbuf,lexeme(lexbuf));
  return 1; }

{

//  static void pr(stringptr_t sptr) {
//    log(" %s\n",*sptr);
//  }

  extern void scan_type(type_t t);
  void scan_exp(exp_opt_t e) {
    switch (e->r) {
    case &Var_e(&$(_,v),_):
      // This case is actually impossible after only parse
      fallthru(v);
    case &UnknownId_e(&$(_,v)):
      add_target(v);
      return;
    case &Primop_e(_,x):
      for (; x != NULL; x = x->tl) {
        scan_exp(x->hd);
      }
      return;
    case &Subscript_e(e1,e2):
      fallthru(e1,e2);
    case &SeqExp_e(e1,e2):
      fallthru(e1,e2);
    case &AssignOp_e(e1,_,e2):
      scan_exp(e1);
      scan_exp(e2);
      return;
    case &Deref_e(e1):
      fallthru(e1);
    case &Sizeofexp_e(e1):
      fallthru(e1);
    case &Address_e(e1):
      fallthru(e1);
    case &Increment_e(e1,_):
      scan_exp(e1);
      return;
    case &Conditional_e(e1,e2,e3):
      scan_exp(e1);
      scan_exp(e2);
      scan_exp(e3);
      return;
    case &FnCall_e(e1,x,_):
      // This case is actually impossible after only parse
      fallthru(e1,x);
    case &UnknownCall_e(e1,x):
      scan_exp(e1);
      for (; x != NULL; x = x->tl) {
        scan_exp(x->hd);
      }
      return;
    case &Cast_e(t1,e1):
      scan_type(t1);
      scan_exp(e1);
      return;
    case &Malloc_e(MallocInfo{iscalloc,ropt,topt,e,_}):
      if (ropt != NULL) scan_exp((exp_t)ropt);
      if (topt != NULL) scan_type(*topt);
      scan_exp(e);
      return;
    case &Sizeoftyp_e(t1):
      scan_type(t1);
      return;
    case &AggrMember_e(e1,fn):
      fallthru(e1,fn);
    case &AggrArrow_e(e1,fn):
      scan_exp(e1);
      add_target(fn);
      return;
    case &Offsetof_e(t1,f):
      scan_type(t1);
      switch (f) {
      case &StructField(fn): add_target(fn); break;
      case &TupleIndex(_): break;
      }        
      return;
    case &Const_e(_):
      return;
    case &UnresolvedMem_e(_,x):
      for (; x != NULL; x = x->tl) {
        let &$(_,e1) = x->hd;
        scan_exp(e1);
      }
      return;
    case &StmtExp_e(_):
      fprintf(stderr,"Error: unexpected Stmt_e\n");
      exit(1); return;
    case &Throw_e(_):
      fprintf(stderr,"Error: unexpected Throw_e\n");
      exit(1); return;
    case &NoInstantiate_e(_):
      fprintf(stderr,"Error: unexpected NoInstantiate_e\n");
      exit(1); return;
    case &Instantiate_e(_,_):
      fprintf(stderr,"Error: unexpected Instantiate_e\n");
      exit(1); return;
    case &New_e(_,_):
      fprintf(stderr,"Error: unexpected New_e\n");
      exit(1); return;
    case &Gentyp_e(_,_):
      fprintf(stderr,"Error: unexpected Gentyp_e\n");
      exit(1); return;
    case &Tuple_e(_):
      fprintf(stderr,"Error: unexpected Tuple_e\n");
      exit(1); return;
    case &CompoundLit_e(_,_):
      fprintf(stderr,"Error: unexpected CompoundLit_e\n");
      exit(1); return;
    case &Array_e(_):
      fprintf(stderr,"Error: unexpected Array_e\n");
      exit(1); return;
    case &Comprehension_e(_,_,_):
      fprintf(stderr,"Error: unexpected Comprehension_e\n");
      exit(1); return;
    case &Struct_e(_,_,_,_):
      fprintf(stderr,"Error: unexpected Struct_e\n");
      exit(1); return;
    case &AnonStruct_e(_,_):
      fprintf(stderr,"Error: unexpected AnonStruct_e\n");
      exit(1); return;
    case &Tunion_e(_,_,_):
      fprintf(stderr,"Error: unexpected Tunion_e\n");
      exit(1); return;
    case &Enum_e(_,_,_):
      fprintf(stderr,"Error: unexpected Enum_e\n");
      exit(1); return;
    case &AnonEnum_e(_,_,_):
      fprintf(stderr,"Error: unexpected AnonEnum_e\n");
      exit(1); return;
    case &Codegen_e(_):
      fprintf(stderr,"Error: unexpected Codegen_e\n");
      exit(1); return;
    case &Fill_e(_):
      fprintf(stderr,"Error: unexpected Fill_e\n");
      exit(1); return;
    }
  }

  void scan_exp_opt(exp_opt_t eo) {
    if (eo) scan_exp(eo);
    return;
  }

  void scan_type(type_t t) {
    switch (t) {
    case VoidType:
    case &IntType(_,_):
    case FloatType:
    case &DoubleType(_):
      return;

    case &PointerType(x):
      scan_type(x.elt_typ);
      return;
    case &ArrayType(t,_,sz):
      scan_type(t);
      scan_exp_opt(sz);
      return;
    case &FnType(x):
      scan_type(x.ret_typ);
      for (let a = x.args; a != NULL; a = a->tl) {
        let &$(_,_,argt) = a->hd;
        scan_type(argt);
      }
      if (x.cyc_varargs != NULL)
        scan_type(x.cyc_varargs->type);
      return;
    case &AnonAggrType(_,sfs):
      for (; sfs != NULL; sfs = sfs->tl) {
        scan_type(sfs->hd->type);
        scan_exp_opt(sfs->hd->width);
      }
      return;
    case &AnonEnumType(_):
      return;
    case &AggrType(AggrInfo(info,_)):
      let $(_,&$(_,v)) = aggr_kinded_name(info);
      fallthru(v);
    case &EnumType(&$(_,v),_):
      fallthru(v);
    case &TypedefType(&$(_,v),_,_,_):
      add_target(v);
      return;

    case &Evar(_,_,_,_):
      fprintf(stderr,"Error: unexpected Evar\n");
      exit(1); return;
    case &VarType(_):
      fprintf(stderr,"Error: unexpected VarType\n");
      exit(1); return;
    case &TunionType(_):
      fprintf(stderr,"Error: unexpected TunionType\n");
      exit(1); return;
    case &TunionFieldType(_):
      fprintf(stderr,"Error: unexpected TunionFieldType\n");
      exit(1); return;
    case &TupleType(_):
      fprintf(stderr,"Error: unexpected TupleType\n");
      exit(1); return;
    case &RgnHandleType(_):
      fprintf(stderr,"Error: unexpected RgnHandleType\n");
      exit(1); return;
    case HeapRgn:
      fprintf(stderr,"Error: unexpected HeapRgn\n");
      exit(1); return;
    case &AccessEff(_):
      fprintf(stderr,"Error: unexpected AccessEff\n");
      exit(1); return;
    case &JoinEff(_):
      fprintf(stderr,"Error: unexpected JoinEff\n");
      exit(1); return;
    case &RgnsEff(_):
      fprintf(stderr,"Error: unexpected RgnsEff\n");
      exit(1); return;
    case &SizeofType(_):
      fprintf(stderr,"Error: unexpected sizeof_t\n");
      exit(1); return;
    case &TypeInt(_):
      fprintf(stderr,"Error: unexpected type integer\n");
      exit(1); return;
    case &TagType(_):
      fprintf(stderr,"Error: unexpected tag_t\n");
      exit(1); return;
    }
  }

  line_t scan_decl(decl_t d) {
    current_targets = new Set::empty(strptrcmp);
    switch (d->r) {
    case &Var_d(x):
      let &$(_,v) = x->name;
      current_source = v;
      scan_type(x->type);
      scan_exp_opt(x->initializer);
      break;
    case &Fn_d(x):
      let &$(_,v) = x->name;
      current_source = v;
      scan_type(x->ret_type);
      for (let a = x->args; a != NULL; a = a->tl) {
        let &$(_,_,t1) = a->hd;
        scan_type(t1);
      }
      if (x->cyc_varargs != NULL)
        scan_type(x->cyc_varargs->type);
      if (x->is_inline) {
        fprintf(stderr,"Warning: ignoring inline function\n");
      }
      break;
    case &Aggr_d(x):
      let &$(_,v) = x->name;
      current_source = v;
      if (x->impl) {
        for (let fs = x->impl->fields; fs != NULL; fs = fs->tl) {
          let f = fs->hd;
          scan_type(f->type);
          scan_exp_opt(f->width);
        }
        // That takes care of what the decl depends on.  Now must add
        // that each field depends on the decl.
        for (let fs = x->impl->fields; fs != NULL; fs = fs->tl) {
          // FIX!!
        }
      }
      break;
    case &Enum_d(x):
      let &$(_,v) = x->name;
      current_source = v;
      if (x->fields) {
        for (let fs = x->fields->v; fs != NULL; fs = fs->tl) {
          let f = fs->hd;
          scan_exp_opt(f->tag);
        }
        // That takes care of what the decl depends on.  Now must add
        // that each field depends on the decl.
        for (let fs = x->fields->v; fs != NULL; fs = fs->tl) {
          // FIX!!
        }
      }
      break;
    case &Typedef_d(x):
      let &$(_,v) = x->name;
      current_source = v;
      if (x->defn)
        scan_type(x->defn->v);
      break;

    case &Let_d(_,_,_):
      fprintf(stderr,"Error: unexpected let declaration\n");
      exit(1); return NULL;
    case &Tunion_d(_):
      fprintf(stderr,"Error: unexpected tunion declaration\n");
      exit(1); return NULL;
    case &Letv_d(_):
      fprintf(stderr,"Error: unexpected let declaration\n");
      exit(1); return NULL;
    case &Namespace_d(_,_):
      fprintf(stderr,"Error: unexpected namespace declaration\n");
      exit(1); return NULL;
    case &Using_d(_,_):
      fprintf(stderr,"Error: unexpected using declaration\n");
      exit(1); return NULL;
    case &ExternC_d(_):
      fprintf(stderr,"Error: unexpected extern \"C\" declaration\n");
      exit(1); return NULL;
    }

    /* The cast is needed so the return type matches */
    return new $((_ @)current_source,*current_targets);
  }

  /* Type for representing dependencies */
  typedef Hashtable::table_t<stringptr_t<`H,`H>,
                             Set::set_t<stringptr_t<`H,`H>,`H>> dep_t;

  dep_t new_deps() {
    return Hashtable::create(107,strptrcmp,Hashtable::hash_stringptr);
  }

  Set::set_t<stringptr_t<`H,`H>,`H> find(dep_t t, stringptr_t<`H,`H> x) {
    try return Hashtable::lookup(t,x);
    catch {
    case Not_found: return Set::empty(strptrcmp);
    }
  }

  Set::set_t<stringptr_t<`H,`H>,`H>
    reachable(list_t<stringptr_t<`H,`H>> init, dep_t t) {
    /* Maintain two sets, curr and delta: curr is the "current set"
       and delta is the subset of curr that was added in the previous
       step.  Initially curr = delta = the initial nodes.

       While delta is not empty,
         find a set, next, that consists of the nodes reachable
           from delta in a single step;
         set delta = next - curr, and curr = curr U delta.
    */
    Set::set_t<stringptr_t<`H,`H>,`H> emptyset = Set::empty(strptrcmp);
    Set::set_t<stringptr_t<`H,`H>,`H> curr;
    for (curr = emptyset; init != NULL; init = init->tl)
      curr = Set::insert(curr,init->hd);
    let delta = curr;

    let sptr = new "";
    while (Set::cardinality(delta) > 0) {
      let next = emptyset;
      let iter = Set::make_iter(Core::heap_region,delta);
      while(Iter::next(iter,&sptr))
        next = Set::union_two(next,find(t,sptr));
      delta = Set::diff(next,curr);
      curr = Set::union_two(curr,delta);
    }
    return curr;
  }

  tunion buildlib_mode { NORMAL, GATHER, GATHERSCRIPT, FINISH };
  static tunion buildlib_mode mode = NORMAL;
  static int gathering() {
    return (mode == GATHER) || (mode == GATHERSCRIPT) ;
  }

  static FILE *script_file = NULL;
  int prscript(const char ?fmt, ... inject parg_t<`r2> ap) 
    __attribute__((format(printf,1,2)))
  {
    if (script_file == NULL) {
      fprintf(stderr,"Internal error: script file is NULL\n");
      exit(1);
    }
    return vfprintf((FILE@)script_file,fmt,ap);
  }

  int force_directory(string_t d) {
    if (mode == GATHERSCRIPT) {
      prscript("if ! test -e %s; then mkdir %s; fi\n",d,d);
    }
    else {
      /* We could do this with stat, but stat is more
         platform dependent; this is more portable. */
      let fd = open(d,O_RDONLY);
      if (fd == -1) {
        if (mkdir(d,0700) == -1) {
          fprintf(stderr,"Error: could not create directory %s\n",d);
          return 1;
        }
      }
      else close(fd);
    }
    return 0;
  }

  int force_directory_prefixes(string_t file) {
    /* File is a string like "foo/bar/baz/xx.h", we want to make sure
       that the directories "foo", "foo/bar", "foo/bar/baz" all exist
       so we can create file. */
    let curr = strdup(file); // Make sure curr is on heap
    /* Compute all prefixes of file */
    let x = NULL;
    while (true) {
      curr = Filename::dirname(curr);
      if (curr.size == 0) break;
      x = new List(new (string_t)curr,x);
    }
    /* Make sure all prefixes exist */
    for (; x != NULL; x = x->tl) {
      if (force_directory(*x->hd)) return 1;
    }
    return 0;
  }

  /* Exception for handling error cases of process_file */
  xtunion exn { NO_SUPPORT };

  /* Returns 1 on a fatal error (can't create files, etc.) or 0 otherwise. */
  int process_file(string_t filename,
                   list_t<stringptr_t<`H,`H>,`H> start_symbols,
                   list_t<stringptr_t<`H,`H>,`H> omit_symbols,
                   list_t<ifdefined_t,`H> prologue,
                   list_t<ifdefined_t,`H> epilogue,
                   list_t<ifdefined_t,`H> cstubs,
                   list_t<ifdefined_t,`H> cycstubs) {
    FILE *maybe;
    FILE @in_file;
    FILE @out_file;
    int errorcode = 0;

    fprintf(stderr,
            "********************************* %s...\n",filename);

    if (!gathering()) log("\n%s:\n",filename);

    /* Calculate necessary file names.  For example:
       filename = sys/types.h
       basename = types.h
       dirname = sys
       choppedname = types
       cppinfile = types.iA
       macrosfile = sys/types.iB
       declsfile = sys/types.iC
       filtereddeclsfile = sys/types.iD
       cfilename = sys/ctypes.h
    */
    let basename = Filename::basename(filename);
    let dirname = Filename::dirname(filename);
    let choppedname = Filename::chop_extension(basename);
    let cppinfile = strconcat(choppedname, ".iA");
    let macrosfile =
      (dirname.size == 0)?
      (aprintf("%s.iB", choppedname)):
      (Filename::concat(dirname, aprintf("%s.iB", choppedname)));
    let declsfile =
      (dirname.size == 0)?
      (aprintf("%s.iC", choppedname)):
      (Filename::concat(dirname, aprintf("%s.iC", choppedname)));
    let filtereddeclsfile =
      (dirname.size == 0)?
      (aprintf("%s.iD", choppedname)):
      (Filename::concat(dirname, aprintf("%s.iD", choppedname)));
    let cfilename = 
      (dirname.size == 0)?
      (aprintf("c%s", basename)):
      (Filename::concat(dirname, aprintf("c%s", basename)));

    try {

    /* Make sure we'll be able to create files in the right directories */
    if (force_directory_prefixes(filename)) {
      return 1;
    }

    /* Create the file of macros and the file of declarations */
    if (mode != FINISH) {
      current_cpp = imp_rev(current_cpp);
      if (mode == GATHERSCRIPT) {
        prscript("cat >%s <<XXX\n",cppinfile);
        for (let l = current_cpp; l != NULL; l = l->tl)
          prscript("%s",*(l->hd));
        prscript("#include <%s>\n",filename);
        prscript("XXX\n");
        prscript("$GCC -E -dM -o %s -x c %s && \\\n",macrosfile,cppinfile);
        prscript("$GCC -E     -o %s -x c %s;\n",declsfile,cppinfile);
        prscript("rm %s\n",cppinfile);
      }
      else {
        maybe = fopen(cppinfile,"w");
        if (!maybe) {
          fprintf(stderr,"Error: could not create file %s\n",cppinfile);
          return 1;
        }
        out_file = (FILE@)maybe;
        for (let l = current_cpp; l != NULL; l = l->tl)
          fputs(*(l->hd),out_file);
        fprintf(out_file,"#include <%s>\n",filename);
        fclose(out_file);
        let GCC = Cstring_to_string(Ccomp);
        let cmd = aprintf("%s -E -dM -o %s -x c %s",
                          GCC,macrosfile,cppinfile);
        if (!system(cmd)) {
          /* No error in creating the file of macros, so go ahead and create
             the file of declarations */
          cmd = aprintf("%s -E -o %s -x c %s",
                        GCC,declsfile,cppinfile);
          system(cmd); // if err, no declsfile created, and we'll handle later
        }
        remove(cppinfile);
      }
    }
    if (gathering()) return 0;

    /* Put the macros in the table of dependencies */
    dep_t t = new_deps();
    maybe = fopen(macrosfile,"r");
    if (!maybe) throw NO_SUPPORT;

    in_file = (FILE@)maybe;
    let l = Lexing::from_file(in_file);
    let entry;
    while ( (entry = line(l)) != NULL) {
      let &$(name,uses) = (_ @)entry; // force NULL check to get rid of warning
      Hashtable::insert(t,name,uses);
      //      log("Macro %s uses:\n",*name);
      //      Set::iter(pr,uses);
    }
    fclose(in_file);

    /* Get the type declarations out of the file */
    maybe = fopen(declsfile,"r");
    if (!maybe) throw NO_SUPPORT;

    in_file = (FILE@)maybe;
    l = Lexing::from_file(in_file);
    slurp_out = fopen(filtereddeclsfile,"w");
    if (!slurp_out) return 1;
    while (slurp(l)) /* skip */;
    fclose(in_file);
    fclose((FILE @)slurp_out);
    if (mode != FINISH) remove(declsfile);

    maybe = fopen(filtereddeclsfile,"r");
    if (!maybe) return 1;
    in_file = (FILE@)maybe;
    Position::reset_position(filtereddeclsfile);
    Lex::lex_init(); // must forget typedefs, may as well flush symbols too
    let decls = Parse::parse_file(in_file);
    Lex::lex_init(); // garbage collect those big tries
    fclose(in_file);
    remove(filtereddeclsfile);

    for (let d = decls; d != NULL; d = d->tl) {
      let entry = scan_decl(d->hd);
      if (entry == NULL) continue;
      let &$(name,uses) = (_ @)entry; // force NULL check to get rid of warning
      /* Add the dependencies to the table.  Note that name might
         already have an entry in the table -- there can be more than
         one declaration for a name, e.g., struct stat and function
         stat in sys/stat.h. */
      let old;
      try
        old = Hashtable::lookup(t,name);
      catch {
      case Not_found: old = Set::empty(strptrcmp); break;
      }
      Hashtable::insert(t,name,Set::union_two(uses,old));
    }

    /* Compute reachable symbols */
    let reachable_set = reachable(start_symbols,t);

    /* Print reachable declarations */
    let reachable_decls = NULL;
    Set::set_t<stringptr_t<`H,`H>> defined_symbols = Set::empty(strptrcmp);
    for (let d = decls; d != NULL; d = d->tl) {
      let decl = d->hd;
      let name;
      switch (decl->r) {
        // This switch has just a bit more functionality than decl_name,
        // enough so that it doesn't make sense to combine them :-(
      case &Var_d(x):
        let &$(_,v) = x->name;
        defined_symbols = Set::insert(defined_symbols,v);
        if (mem(strptrcmp,omit_symbols,v)) name = NULL;
        else name = v;
        break;
      case &Fn_d(x):
        let &$(_,v) = x->name;
        defined_symbols = Set::insert(defined_symbols,v);
        if (mem(strptrcmp,omit_symbols,v)) name = NULL;
        else name = v;
        break;
      case &Aggr_d(x):
        let &$(_,v) = x->name;
        name = v;
        break;
      case &Enum_d(x):
        let &$(_,v) = x->name;
        name = v;

        // see if fields are reachable or name is reachable
        if (name != NULL && Set::member(reachable_set,(stringptr_t)name)) {
          reachable_decls = new List(decl,reachable_decls);
        }
        else if (x->fields) {
          for (let fs = x->fields->v; fs != NULL; fs = fs->tl) {
            let f = fs->hd;
            let &$(_,v) = f->name; 
            if (Set::member(reachable_set,v)) {
              reachable_decls = new List(decl,reachable_decls);
              break; // exit for-loop
            }
          }
        }
        name = NULL;
        break;
      case &Typedef_d(x):
        let &$(_,v) = x->name;
        name = v;
        break;

      case &Let_d(_,_,_):
      case &Tunion_d(_):
      case &Letv_d(_):
      case &Namespace_d(_,_):
      case &Using_d(_,_):
      case &ExternC_d(_):
        name = NULL;
        break;
      }
      if (name != NULL && Set::member(reachable_set,(stringptr_t)name))
        reachable_decls = new List(decl,reachable_decls);
    }
    reachable_decls = imp_rev(reachable_decls);
    maybe = fopen(filename,"w");
    if (!maybe) return 1;
    out_file = (FILE @)maybe;
    fprintf(out_file,"#include <%s>\nusing Std;\n",cfilename);
    fclose(out_file);
    maybe = fopen(cfilename, "w");
    if (!maybe) return 1;
    out_file = (FILE @)maybe;
    mstring_t ifdefmacro = aprintf("_%s_",filename);
    for (let j = 0; j < ifdefmacro.size; j++) {
      if (ifdefmacro[j] == '.' || ifdefmacro[j] == '/')
        ifdefmacro[j] = '_';
      else if (ifdefmacro[j] != '_' && ifdefmacro[j] != '/')
        ifdefmacro[j] = (char)toupper(ifdefmacro[j]);
    }
    fprintf(out_file,
            "#ifndef %s\n"
            "#define %s\n",
            ifdefmacro,
            ifdefmacro);

    if (prologue != NULL) {
      for (let x = prologue; x != NULL; x = x->tl) {
        let &$(symbol,text) = x->hd;
        if (text != NULL &&
            (symbol == NULL || Set::member(defined_symbols, new symbol)))
          // FIX: FPUTS DUMPS CORE ON LINUX IF FIRST ARG IS NULL!!
          fputs(text,out_file);
        else
          log("%s is not supported on this platform\n",symbol);
      }
    }

    fprintf(out_file,"\nnamespace Std {\n");

    for (let d = reachable_decls; d != NULL; d = d->tl) {
      let decl = d->hd;
      let anon_enum = false;
      let name;
      switch (decl->r) {
      case &Var_d(x):
        let &$(_,v) = x->name;
        name = v;
        break;
      case &Fn_d(x):
        let &$(_,v) = x->name;
        name = v;
        break;
      case &Aggr_d(x):
        let &$(_,v) = x->name;
        name = v;
        break;
      case &Enum_d(x):
        let &$(_,v) = x->name;
        name = v;
        break;
      case &Typedef_d(x):
        let &$(_,v) = x->name;
        name = v;
        break;

      case &Let_d(_,_,_):
      case &Tunion_d(_):
      case &Letv_d(_):
      case &Namespace_d(_,_):
      case &Using_d(_,_):
      case &ExternC_d(_):
        name = NULL;
        break;
      }
      if (!name && !anon_enum) continue;
      if (name) {
        ifdefmacro = aprintf("_%s_def_",*name);
        fprintf(out_file,"#ifndef %s\n",ifdefmacro);
        fprintf(out_file,"#define %s\n",ifdefmacro);
        // Because there's no decl2file and I'm lazy
        Absynpp::decllist2file(list(decl),out_file);
        fprintf(out_file,"#endif\n");
      }
      else {
        // Anonymous enum
        Absynpp::decllist2file(list(decl),out_file);
      }
    }

    /* Print reachable macros */
    maybe = fopen(macrosfile,"r");
    if (!maybe) throw NO_SUPPORT;
    in_file = (FILE@)maybe;
    l = Lexing::from_file(in_file);
    let entry2;
    while ( (entry2 = suck_line(l)) != NULL) {
      let &$(line,name) = (_ @)entry2; // force NULL check to get rid of warning
      if (Set::member(reachable_set,name)) {
        fprintf(out_file,"#ifndef %s\n",*name);
        fprintf(out_file,"%s\n",line);
        fprintf(out_file,"#endif\n");
      }
    }
    fclose(in_file);
    if (mode != FINISH) remove(macrosfile);

    if (epilogue != NULL) {
      for (let x = epilogue; x != NULL; x = x->tl) {
        let &$(symbol,text) = x->hd;
        if (text != NULL &&
            (symbol == NULL || Set::member(defined_symbols, new symbol)))
          // FIX: FPUTS DUMPS CORE ON LINUX IF FIRST ARG IS NULL!!
          fputs(text,out_file);
        else
          log("%s is not supported on this platform\n",symbol);
      }
    }
    fprintf(out_file,"}\n"); // close namespace Std
    fprintf(out_file,"#endif\n");
    fclose(out_file);

    /* Dump out the c stubs */
    if (cstubs != NULL) {
      out_file = (FILE @)cstubs_file;
      for (let x = cstubs; x != NULL; x = x->tl) {
        let &$(symbol,text) = x->hd;
        if (text != NULL &&
            (symbol == NULL || Set::member(defined_symbols, new symbol)))
          fputs(text,out_file);
      }
    }

    /* Dump out the cyclone stubs */
    out_file = (FILE @)cycstubs_file;
    /* Always include the header, to make sure it has no errors */
    fprintf(out_file, "#include <%s>\n\n", cfilename);
    if (cycstubs != NULL) {
      out_file = (FILE @)cycstubs_file;
      fprintf(out_file, "namespace Std {\n");
      for (let x = cycstubs; x != NULL; x = x->tl) {
        let &$(symbol,text) = x->hd;
        if (text != NULL &&
            (symbol == NULL || Set::member(defined_symbols, new symbol)))
          fputs(text,out_file);
      }
      fprintf(out_file, "}\n\n");
    }

    return 0;

    } catch {
    default:
      /* We could get here because of a throw NO_SUPPORT or because of
         a parse error or other error.  In either case, we create a
         default header and don't otherwise signal an error. */
      maybe = fopen(filename,"w");
      if (!maybe) {
        fprintf(stderr,"Error: could not create file %s\n",filename);
        return 1;
      }
      out_file = (FILE@)maybe;
      fprintf(out_file,
              "#error -- %s is not supported on this platform\n",
              filename);
      fclose(out_file);
      maybe = fopen(cfilename,"w");
      if (!maybe) {
        fprintf(stderr,"Error: could not create file %s\n",cfilename);
        return 1;
      }
      out_file = (FILE@)maybe;
      fprintf(out_file,
              "#error -- %s is not supported on this platform\n",
              cfilename);
      fclose(out_file);
      fprintf(stderr,"Warning: %s will not be supported on this platform\n",
              filename);
      log("Not supported on this platform\n");

      /* Delete intermediate files; some may not exist but we ignore that */
      remove(macrosfile);
      remove(declsfile);
      remove(filtereddeclsfile);

      return 0;
    }
  }

  /* Return 1 on fatal error, else 0 */
  int process_specfile(string_t file,string_t dir) {
    let maybe = fopen(file,"r");
    if (!maybe) {
      fprintf(stderr,"Error: could not open %s\n", file);
      return 1;
    }
    let in_file = (FILE@)maybe;

    /* Cd into dir, where the header files will be built.  Remember
       the current dir so we can cd back after we're done. */
    char ?buf = new {for i<1024: '\0'};
    let cwd = getcwd(buf,buf.size);
    if (mode != GATHERSCRIPT) {
      if (chdir(dir)) {
        fprintf(stderr,"Error: can't change directory to %s\n",dir);
        return 1;
      }
    }
    if (mode == GATHER) {
      /* This will be executed once for each specfile, but who cares */
      let GCC = Cstring_to_string(Ccomp);
      system(aprintf("echo | %s -E -dM - -o INITMACROS.h\n",GCC));
    }

    let l = Lexing::from_file(in_file);
    let entry;
    while ( (entry = spec(l)) != NULL) {
      let &$(headerfile,start_symbols,omit_symbols,
             prologue,epilogue,cstubs,cycstubs) = (_ @)entry;
      if (process_file(headerfile,start_symbols,omit_symbols, 
                       prologue,epilogue,cstubs,cycstubs))
        return 1; /* fatal error in process_file */
    }
    fclose(in_file);

    if (mode != GATHERSCRIPT) {
      if (chdir(cwd)) {
        fprintf(stderr,"Error: could not change directory to %s\n", cwd);
        return 1;
      }
    }
    return 0;
  }

  int getsize(const char ?dir, const char ?includes, const char ?type) {
    /* FIX: should get rid of dir argument and use std. temp file stuff */
    let getsizefilename = Filename::concat(dir,"getsize.c");
    let getsizeexec = Filename::concat(dir,"getsize");
    let getsizeout = Filename::concat(dir,"getsize.out");
    let getsizefile = fopen(getsizefilename,"w");
    if (!getsizefile) {
      fprintf(stderr,"Error: could not create %s\n",getsizefilename);
      log("Warning: could not find the size of %s\n",type);
      return -1;
    }
    /* We jump through some hoops here because the system function does not
       return the value returned by main (it does something more
       complicated and not very portable). */
    fprintf((FILE@)getsizefile,
            "%s\n"
            "#include <stdio.h>\n"
            "int main() {\n"
            "  FILE *f = fopen(\"%s\",\"w\");\n"
            "  fprintf(f,\"%%d\\n\",sizeof(%s));\n"
            "  fclose(f);\n"
            "  return (int)sizeof(%s);\n"
            "}\n",
            includes,
            getsizeout,
            type,
            type);
    fclose((FILE@)getsizefile);
    let GCC = Cstring_to_string(Ccomp);
    let gcccmd = aprintf("%s -o %s -x c %s",
                         GCC,
                         getsizeexec,
                         getsizefilename);
    if (system(gcccmd)) {
      fprintf(stderr,
              "Warning: could not find the size of %s; continuing anyway\n",
              type);
      log("Warning: could not find the size of %s\n",type);
      return -1;
    }
    let z = system(getsizeexec);
    //    log("size of %s returned by system is %d\n",type,z);
    let f = fopen(getsizeout,"r");
    int w = -1;
    if (fscanf((FILE@)f,"%d",&w) != 1) {
      log("Warning: could not find the size of %s\n",type);
      return -1;
    }
    log("size of %s read from file %s is %d\n",type,getsizeout,w);
    fclose((FILE@)f);
    remove(getsizeout);
    remove(getsizefilename);
    remove(getsizeexec);
    return w;
  }

  /* Helper functions for command line argument processing */
  static string_t output_dir = "BUILDLIB.OUT";
  static void set_output_dir(string_t<`H> s) {
    output_dir = s;
  }
  static list_t<stringptr_t> spec_files = NULL;
  static void add_spec_file(string_t<`H> s) {
    spec_files = new List(new s,spec_files);
  }
  static void set_GATHER() {
    mode = GATHER;
  }
  static void set_GATHERSCRIPT() {
    mode = GATHERSCRIPT;
  }
  static void set_FINISH() {
    mode = FINISH;
  }
  static bool badparse = false;
  static void unsupported_option(string_t<`H> s) {
    fprintf(stderr,"Unsupported option %s\n", s);
    badparse = true;
  }

  using Arg;

  /********************** Main *********************/
  extern "C" void GC_blacklist_warn_clear();
  int main(int argc, const char ?`H?`H argv) {
    GC_blacklist_warn_clear();

    Arg::speclist_t<`H,`H> options =
      list(new $("-d",false," <file>",
                 new String_spec(set_output_dir),
                 "Set the output directory to <file>"),
           new $("-gather",false,"",
                 new Unit_spec(set_GATHER),
                 "Gather C library info but don't produce Cyclone headers"),
           new $("-gatherscript",false,"",
                 new Unit_spec(set_GATHERSCRIPT),
                 "Produce a script to gather C library info"),
           new $("-finish",false,"",
                 new Unit_spec(set_FINISH),
                 "Produce Cyclone headers from pre-gathered C library info"),
           new $("-",true,"",
                 /* FIX: this is a crude way to see if there is an
                    invalid option on the command line, and halt if so.
                    We ought to change Arg::parse to make this
                    cleaner. */
                 new Flag_spec(unsupported_option),
                 "")
           );
    Arg::parse(options, add_spec_file, "Options:", argv);
    if (badparse) {
      Arg::usage(options,"Options:");
      return 1;
    }

    if (mode == GATHERSCRIPT) {
      script_file = fopen("BUILDLIB.sh","w");
      if (!script_file) {
        fprintf(stderr,"Could not create file BUILDLIB.sh\n");
        exit(1);
      }
      prscript("#!/bin/sh\n");
      prscript("GCC=\"gcc\"\n");
    }

    /* Make sure the directory where the output files will be placed exists */
    if (force_directory_prefixes(output_dir) || force_directory(output_dir)) {
      fprintf(stderr,"Error: could not create directory %s\n",output_dir);
      return 1;
    }

    if (mode == GATHERSCRIPT) {
      prscript("cd %s\n",output_dir);
      prscript("echo | $GCC -E -dM - -o INITMACROS.h\n");
    }

    if (!gathering()) {
      /* Create an empty log file -- most importantly, any previous log
         file will be truncated */
      log_file = fopen(Filename::concat(output_dir,"BUILDLIB.LOG"),"w");
      if (!log_file) {
        fprintf(stderr,"Error: could not create log file in directory %s\n",output_dir);
        return 1;
      }

      /* Create an empty cstubs.cyc file */
      cstubs_file = fopen(Filename::concat(output_dir,"cstubs.c"),"w");
      if (!cstubs_file) {
        fprintf(stderr,"Error: could not create cstubs.c in directory %s\n",output_dir);
        return 1;
      }

      /* Create a cycstubs.cyc file with the standard prologue */
      cycstubs_file = fopen(Filename::concat(output_dir,"cycstubs.cyc"),"w");
      if (!cycstubs_file) {
        fprintf(stderr,
                "Error: could not create cycstubs.c in directory %s\n",
                output_dir);
        return 1;
      }
      fprintf((FILE@)cycstubs_file,
              "#include <core.h>\n"
              "using Core;\n\n");

      /* Find the sizes of various types, for use in constant expressions */
      sizeof_unsignedlongint = getsize(output_dir,"","unsigned long int");
      sizeof_unsignedshortint = getsize(output_dir,"","unsigned short int");
      sizeof_shortint = getsize(output_dir,"","short int");
      sizeof_int = getsize(output_dir,"","int");
      sizeof_short = getsize(output_dir,"","short");
      /* sys/types is needed on OS X b/c it defines needed typedef u_int */
      sizeof_fdmask = getsize(output_dir,"#include <sys/types.h>\n#include <sys/select.h>","fd_mask");
      sizeof___fdmask = getsize(output_dir,"#include <sys/types.h>\n#include <sys/select.h>","__fd_mask");
      sizeof_uint32 = getsize(output_dir,"#include <sys/types.h>","__uint32_t");
      /* sys/types is needed on OS X b/c it defines needed typedef u_char */
      sizeof_sockaddr = getsize(output_dir,"#include <sys/types.h>\n#include <sys/socket.h>","struct sockaddr");
      sizeof_inport = getsize(output_dir,"#include <sys/types.h>\n#include <netinet/in.h>","in_port_t");
      sizeof_inaddr = getsize(output_dir,"#include <sys/types.h>\n#include <netinet/in.h>","struct in_addr");
    }
            
    /* Main loop -- process each spec file */
    for (; spec_files != NULL; spec_files = spec_files->tl) {
      if (process_specfile(*(spec_files->hd),output_dir)) {
        fprintf(stderr,"FATAL ERROR -- QUIT!\n");
        exit(1);
      }
    }

    if (mode == GATHERSCRIPT) {
      fclose((FILE@)script_file);
    }
    else if (!gathering()) {
      fclose((FILE@)log_file);
      fclose((FILE@)cstubs_file);
      fclose((FILE@)cycstubs_file);
    }

    return 0;
  }
}
