{
/* Notes

   Cygwin sys/select.h defines a struct and then a typedef with the
   same name.  Our current scheme for halting repeated definitions
   does not separate typedefs and structs, so the typedef ends up
   undefined.  The current hack is to hand-define it in that special
   case.

   The #include <setjmp.h> in precore_c.h pollutes the namespace.
   Specifically, it defines some of the signal functions in Cygwin in
   a way that conflicts with the definitions I make in Cyclone.
   (precore_c.h is included in the output of the compiler for every
   Cyclone file.)  Maybe we can use buildlib to extract just the
   definitions we need from setjmp.h.

   Some C headers use sizeof(type) in constant expressions, which we
   don't currently allow in Cyclone.  The current hack is to
   precalculate the sizes using gcc, and do a textual replace of the
   sizeof expression with the actual size.

   Cyclone does not currently handle long double complex, which is
   needed in <complex.h>.

   On some systems types aren't defined where they should be.  I
   added cpp for this case, but it would be better to do things
   automatically.

   Some systems don't define types at all -- e.g., socklen_t.  In
   such cases we might be able to derive the type from a function
   that uses it; we currently just take a guess.

 */

#include <core.h>
#include <lexing.h>
#include <set.h>
#include <string.h>
#include <list.h>
#include <hashtable.h>
#include <filename.h>
#include <position.h>
#include <stdlib.h>
#include <buffer.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <ctype.h>
#include "absyn.h"
#include "absynpp.h"
#include "parse.h"

namespace Lex {
  extern void lex_init();
}

using Lexing;
using List;
using Core;
using Absyn;

extern "C" Cstring Ccomp; // The string to invoke gcc

FILE *log_file = NULL;
FILE *cstubs_file = NULL;
FILE *cycstubs_file = NULL;

int log(const char ?fmt, ... inject parg_t<`r2> ap) 
  __attribute__((format(printf,1,2)))
{
  let x = vfprintf((FILE@)log_file,fmt,ap);
  fflush((FILE@)log_file);
  return x;
}

/* These will be filled in using gcc later */
int sizeof_unsignedlongint = -1;
int sizeof_unsignedshortint = -1;
int sizeof_shortint = -1;
int sizeof_int = -1;
int sizeof_short = -1;
int sizeof_fdmask = -1;
int sizeof___fdmask = -1;
int sizeof_uint32 = -1;
int sizeof_sockaddr = -1;
int sizeof_inport = -1;
int sizeof_inaddr = -1;

static string_t *current_source = NULL;
static list_t<stringptr_t> current_args = NULL;
static Set::set_t<stringptr_t> *current_targets = NULL;
static void add_target(stringptr_t<`H,`H> sptr) {
  current_targets = new Set::insert(*current_targets,sptr);
}

/* Forward declarations of lexing functions */
typedef $(stringptr_t,Set::set_t<stringptr_t>) *line_t;
extern line_t line(Lexbuf<`a>);
extern int macroname(Lexbuf<`a>);
extern int args(Lexbuf<`a>);
extern int token(Lexbuf<`a>);
extern int string(Lexbuf<`a>);

FILE *slurp_out = NULL;
extern int slurp(Lexbuf<`a>);
extern int slurp_string(Lexbuf<`a>);
extern int asm(Lexbuf<`a>);
extern int asm_string(Lexbuf<`a>);
extern int asm_comment(Lexbuf<`a>);

typedef $(string_t,stringptr_t) *suck_line_t;
extern suck_line_t suck_line(Lexbuf<`a>);
extern int suck_macroname(Lexbuf<`a>);
extern int suck_restofline(Lexbuf<`a>);
string_t current_line = NULL;

/* When $(A,B) is an ifdefined_t, B will be printed if A is NULL
   or A is a defined symbol */
typedef $(string_t<`H>,string_t<`H>) @ifdefined_t;

typedef $(string_t,list_t<stringptr_t>,list_t<stringptr_t>,
          list_t<ifdefined_t>,list_t<ifdefined_t>,
          list_t<ifdefined_t>,list_t<ifdefined_t>) *spec_t;
extern spec_t spec(Lexbuf<`a>);
extern int commands(Lexbuf<`a>);
extern int snarfsymbols(Lexbuf<`a>);
extern int block(Lexbuf<`a>);
extern int block_string(Lexbuf<`a>);
extern int block_comment(Lexbuf<`a>);
string_t current_header = NULL;
list_t<stringptr_t> snarfed_symbols = NULL;
list_t<stringptr_t> current_symbols = NULL;
list_t<ifdefined_t> current_cstubs = NULL;
list_t<ifdefined_t> current_cycstubs = NULL;
list_t<ifdefined_t> current_prologue = NULL;
list_t<ifdefined_t> current_epilogue = NULL;
list_t<stringptr_t> current_omit_symbols = NULL;
list_t<stringptr_t> current_cpp = NULL;
struct Buffer::t *specbuf = NULL;
int braces_to_match = 0;
int parens_to_match = 0;

int numdef = 0;
}

let newline = ('\n' | '\r' | "\r\n")
let idchar = ['A'-'Z''a'-'z''0'-'9''_']
let ws = [' ''\t''\n''\r']

/**********************************************************************/
/* Rules for finding dependencies of macros                           */
/**********************************************************************/
rule line "line_t" = parse
  "#define "
{ macroname(lexbuf);
  for (; current_args != NULL; current_args = current_args->tl) {
    current_targets = new Set::delete(*current_targets,current_args->hd);
  }
  /* The cast is needed so the return type matches */
  return new $((_ @)current_source,*current_targets);}
/* End of line */
| newline
{ return line(lexbuf); }
| eof
{ return NULL; }

and macroname = parse
  idchar+ '(' ')'
{ current_source = new (string_t)substring(lexeme(lexbuf), 0,
                                          lexeme_end(lexbuf)-lexeme_start(lexbuf)-2);
  current_args = NULL;
  current_targets = new Set::empty(strptrcmp);
  token(lexbuf);
  return 0;
}
| idchar+ '('
{ current_source = new (string_t)substring(lexeme(lexbuf), 0,
                                          lexeme_end(lexbuf)-lexeme_start(lexbuf)-1);
  current_args = NULL;
  current_targets = new Set::empty(strptrcmp);
  args(lexbuf);
  return 0;
}
| idchar+
{ current_source = new (string_t)lexeme(lexbuf);
  current_args = NULL;
  current_targets = new Set::empty(strptrcmp);
  token(lexbuf);
  return 0;
}

and args = parse
  idchar+ ',' ' '
{ let a = new (string_t)substring(lexeme(lexbuf), 0,
                                  lexeme_end(lexbuf)-lexeme_start(lexbuf)-2);
  current_args = new List(a,current_args);
  return args(lexbuf);
}
| idchar+ ')'
{ let a = new (string_t)substring(lexeme(lexbuf), 0,
                                  lexeme_end(lexbuf)-lexeme_start(lexbuf)-1);
  current_args = new List(a,current_args);
  return token(lexbuf);
}

and token = parse
/* Identifiers and keywords */
  ['A'-'Z''a'-'z''_']['A'-'Z''a'-'z''_''0'-'9']*
{ add_target(new (string_t)lexeme(lexbuf)); return token(lexbuf); }
/* End of file or line */
| (eof | ['\n' '\r'])
{ return 0; }
/* Other whitespace */
| [' ' '\t' '\v' '\f']+
{ return  token(lexbuf); }
/* string constants */
| "\""
{ string(lexbuf); return token(lexbuf);}
/* Integer constants */
| '0'['x''X']['0'-'9''a'-'f''A'-'F']+((['u''U']['l''L']?)|(['l''L']['u''U']?))?
{ return token(lexbuf); }
| '0'['0'-'7']*((['u''U']['l''L']?)|(['l''L']['u''U']?))?
{ return token(lexbuf); }
| '0'['0'-'9']+((['u''U']['l''L']?)|(['l''L']['u''U']?))?
{ return token(lexbuf); }
| ['1'-'9']['0'-'9']*((['u''U']['l''L']?)|(['l''L']['u''U']?))?
{ return token(lexbuf); }
/* Floating-point constants */
| ['0'-'9']+['e''E']['+''-']?['0'-'9']+['f''F''l''L']?
{ return token(lexbuf); }
| ((['0'-'9']+'.')|(['0'-'9']+'.'['0'-'9']+)|('.'['0'-'9']+))
  (['e''E']['+''-']?['0'-'9']+)?['f''F''l''L']?
{ return token(lexbuf); }
/* character constants */
| "'\\a'"
{ return token(lexbuf); }
| "'\\b'"
{ return token(lexbuf); }
| "'\\f'"
{ return token(lexbuf); }
| "'\\n'"
{ return token(lexbuf); }
| "'\\r'"
{ return token(lexbuf); }
| "'\\t'"
{ return token(lexbuf); }
| "'\\v'"
{ return token(lexbuf); }
| "'\\\\'"
{ return token(lexbuf); }
| "'\\''"
{ return token(lexbuf); }
| "'\\\"'"
{ return token(lexbuf); }
| "'\\?'"
{ return token(lexbuf); }
| "'\\" ['0'-'7']['0'-'7']?['0'-'7']? "'"
{ return token(lexbuf); }
| "'\\x" ['0'-'9''A'-'Z''a'-'z']+ "'"
{ return token(lexbuf); }
| "'" [^ '\\' '\'' '\n'] "'"
{ return token(lexbuf); }
/* Operators */
| "=="
{ return token(lexbuf); }
| "!="
{ return token(lexbuf); }
| "<="
{ return token(lexbuf); }
| ">="
{ return token(lexbuf); }
| "++"
{ return token(lexbuf); }
| "--"
{ return token(lexbuf); }
| "+="
{ return token(lexbuf); }
| "-="
{ return token(lexbuf); }
| "*="
{ return token(lexbuf); }
| "/="
{ return token(lexbuf); }
| "%="
{ return token(lexbuf); }
| "|="
{ return token(lexbuf); }
| "^="
{ return token(lexbuf); }
| "&="
{ return token(lexbuf); }
| "<<="
{ return token(lexbuf); }
| ">>="
{ return token(lexbuf); }
| "&&"
{ return token(lexbuf); }
| "||"
{ return token(lexbuf); }
| "<<"
{ return token(lexbuf); }
| ">>"
{ return token(lexbuf); }
| "<>"
{ return token(lexbuf); }
| "->"
{ return token(lexbuf); }
| "..."
{ return token(lexbuf); }
| "::"
{ return token(lexbuf); }
/* Default case */
| _
{ return token(lexbuf); }

and string = parse
    "\"" [' ''\n''\r''\t']* "\""
  /* concatenate adjacent strings */
                    { return string(lexbuf); }
  | "\""            { return 0; }
  | "\\" newline    { return string(lexbuf); }
  | "\\a"           { return string(lexbuf); }
  /* octal character escapes */
  | "\\" ['0'-'7']['0'-'7']?['0'-'7']?
                    { return string(lexbuf); }
  /* hex character escapes FIX? any length okay? */
  | "\\x" ['0'-'9''A'-'F''a'-'f']+
                    { return string(lexbuf);}
  | [^ '"''\\''\n']   /* NOT double quote, backslash, or newline */
                    { return string(lexbuf); }
  | newline         { return 0; }
  | eof             { return 0; }
  | _               { return string(lexbuf); }

/**********************************************************************/
/* Rules to ``fix up'' C code so that it will go through the Cyclone  */
/* parser.  E.g., eliminate/modify unsupported attributes, other      */
/* unsavory hacks.                                                    */
/**********************************************************************/
and slurp = parse
 "\""
{ fputc('"',(FILE @)slurp_out);
  if (slurp_string(lexbuf)) return 1; else return slurp(lexbuf);}
| eof
{ return 0; }
/* Currently Cyclone doesn't allow sizeofs as constant expressions.
   So we calculate the sizes in a previous phase and insert them
   here on a case-by-case basis. */
| "sizeof" ws* "(" ws* "fd_mask" ws* ")"
{ fprintf((FILE @)slurp_out," %d ",sizeof_fdmask);
  log("Warning: sizeof(fd_mask) inlined\n");
  return slurp(lexbuf); }
| "sizeof" ws* "(" ws* "__fd_mask" ws* ")"
{ fprintf((FILE @)slurp_out," %d ",sizeof___fdmask);
  log("Warning: sizeof(__fd_mask) inlined\n");
  return slurp(lexbuf); }
| "sizeof" ws* "(" ws* "__uint32_t" ws* ")"
{ fprintf((FILE @)slurp_out," %d ",sizeof_uint32);
  log("Warning: sizeof(__uint32_t) inlined\n");
  return slurp(lexbuf); }
| "sizeof" ws* "(" ws* "in_port_t" ws* ")"
{ fprintf((FILE @)slurp_out," %d ",sizeof_inport);
  log("Warning: sizeof(__in_port_t) inlined\n");
  return slurp(lexbuf); }
| "sizeof" ws* "(" ws* "int" ws* ")"
{ fprintf((FILE @)slurp_out," %d ",sizeof_int);
  log("Warning: sizeof(int) inlined\n");
  return slurp(lexbuf); }
| "sizeof" ws* "(" ws* "short" ws* ")"
{ fprintf((FILE @)slurp_out," %d ",sizeof_short);
  log("Warning: sizeof(__short) inlined\n");
  return slurp(lexbuf); }
| "sizeof" ws* "(" ws* "unsigned" ws+ "long" ws+ "int" ws* ")"
{ fprintf((FILE @)slurp_out," %d ",sizeof_unsignedlongint);
  log("Warning: sizeof(unsigned long int) inlined\n");
  return slurp(lexbuf); }
| "sizeof" ws* "(" ws* "unsigned" ws+ "short" ws+ "int" ws* ")"
{ fprintf((FILE @)slurp_out," %d ",sizeof_unsignedshortint);
  log("Warning: sizeof(unsigned short int) inlined\n");
  return slurp(lexbuf); }
| "sizeof" ws* "(" ws* "short" ws+ "int" ws* ")"
{ fprintf((FILE @)slurp_out," %d ",sizeof_shortint);
  log("Warning: sizeof(short int) inlined\n");
  return slurp(lexbuf); }
| "sizeof" ws* "(" ws* "struct" ws+ "sockaddr" ws* ")"
{ fprintf((FILE @)slurp_out," %d ",sizeof_sockaddr);
  log("Warning: sizeof(struct sockaddr) inlined\n");
  return slurp(lexbuf); }
| "sizeof" ws* "(" ws* "struct" ws+ "in_addr" ws* ")"
{ fprintf((FILE @)slurp_out," %d ",sizeof_inaddr);
  log("Warning: sizeof(struct inaddr) inlined\n");
  return slurp(lexbuf); }
| " malloc "
/* malloc is a Cyclone keyword so our parser can't handle a malloc
   declaration. */
{ fputs(" __IGNORE_FOR_CYCLONE_MALLOC ",(FILE @)slurp_out);
  log("Warning: declaration of malloc sidestepped\n");
  return slurp(lexbuf); }
| "*malloc "
/* malloc is a Cyclone keyword so our parser can't handle a malloc
   declaration. */
{ fputs("*__IGNORE_FOR_CYCLONE_MALLOC ",(FILE @)slurp_out);
  log("Warning: declaration of malloc sidestepped\n");
  return slurp(lexbuf); }
| " calloc "
/* calloc is a Cyclone keyword so our parser can't handle a calloc
   declaration. */
{ fputs(" __IGNORE_FOR_CYCLONE_CALLOC ",(FILE @)slurp_out);
  log("Warning: declaration of calloc sidestepped\n");
  return slurp(lexbuf); }
| "*calloc "
/* calloc is a Cyclone keyword so our parser can't handle a calloc
   declaration. */
{ fputs("*__IGNORE_FOR_CYCLONE_CALLOC ",(FILE @)slurp_out);
  log("Warning: declaration of calloc sidestepped\n");
  return slurp(lexbuf); }
| "*region" /* Used in OS X in mach/vm_map.h, conflicts with our keyword */
{ fputs("__region",(FILE @)slurp_out);
  log("Warning: use of region sidestepped\n");
  return slurp(lexbuf); }
| "__extension__" /* Used in cygwin in sys/reent.h */
{ return slurp(lexbuf); }
| "__attribute__ ((__mode__ (__HI__)))" /* Used in linux in _G_config.h */
{ return slurp(lexbuf); }
| "__attribute__ ((__mode__ (__SI__)))" /* Used in linux in _G_config.h */
{ return slurp(lexbuf); }
| "__attribute__ ((__mode__ (__QI__)))" /* Used in linux in sys/types.h */
{ return slurp(lexbuf); }
| "__attribute__ ((__mode__ (__DI__)))" /* Used in linux in sys/types.h */
{ return slurp(lexbuf); }
| "__attribute__ ((__mode__ (__word__)))" /* Used in linux in sys/types.h */
{ return slurp(lexbuf); }
| "__inline__" /* Used in cygwin in stdio.h */
{ fputs("inline",(FILE @)slurp_out); return slurp(lexbuf); }
| "__inline" /* Used in OS X */
{ fputs("inline",(FILE @)slurp_out); return slurp(lexbuf); }
| "__const__"
{ fputs("const",(FILE @)slurp_out); return slurp(lexbuf); }
| "__const" /* Used in cygwin in unistd.h; an undocumented gcc extension?? */
{ fputs("const",(FILE @)slurp_out); return slurp(lexbuf); }
| "__builtin_va_list"
/* Used in linux in /usr/lib/gcc-lib/i386-redhat-linux/2.96/include/stdarg.h;
   an undocumented gcc extension?  This is a HACK -- shouldn't matter since
   we don't use va_list */
{ fputs("int",(FILE @)slurp_out); return slurp(lexbuf); }
| "__restrict" /* Used in linux in libio.h; an undocumented gcc extension?? */
{ return slurp(lexbuf); }
| "__asm__" ws* '(' /* Used in cygwin in /usr/include/asm files for inline functions */
{ parens_to_match = 1;
  if (asm(lexbuf)) return 1;
  fputs("0",(FILE @)slurp_out); /* appears as expression followed by ';' typically */
  log("Warning: replacing use of __asm__ with 0\n");
  return slurp(lexbuf); }
| [^ '"']
{ fputc(lexeme_char(lexbuf,0),(FILE @)slurp_out); return slurp(lexbuf); }

and slurp_string = parse
  "\""
{ fputc('"',(FILE @)slurp_out); return 0; }
| eof     /* Unclosed string, error: return 1 instead of 0 */
{ return 1; }
| newline /* Unclosed string, error: return 1 instead of 0 */
{ return 1; }
| "\\" newline
{ fprintf((FILE @)slurp_out,"%s",lexeme(lexbuf)); return slurp_string(lexbuf); }
| "\\a"
{ fprintf((FILE @)slurp_out,"%s",lexeme(lexbuf)); return slurp_string(lexbuf); }
| "\\" ['0'-'7']['0'-'7']?['0'-'7']?
{ fprintf((FILE @)slurp_out,"%s",lexeme(lexbuf)); return slurp_string(lexbuf); }
| "\\x" ['0'-'9''A'-'F''a'-'f']+
{ fprintf((FILE @)slurp_out,"%s",lexeme(lexbuf)); return slurp_string(lexbuf); }
| [^ '"''\\''\n']
{ fprintf((FILE @)slurp_out,"%s",lexeme(lexbuf)); return slurp_string(lexbuf); }
| _
{ fprintf((FILE @)slurp_out,"%s",lexeme(lexbuf)); return slurp_string(lexbuf); }

and asm =
/* Expects to be entered just after a left paren, searches for the
   matching right paren, deletes everything in between.
   Parens in comments, strings, and character constants aren't counted.
   parens_to_match should be set to 1 before calling asm. */
parse
  ')'
{ if (parens_to_match == 1) return 0;
  parens_to_match--;
  return asm(lexbuf); }
| '('
{ parens_to_match++;
  return asm(lexbuf); }
| '"'
{ asm_string(lexbuf);
  return asm(lexbuf); }
| "/*"
{ asm_comment(lexbuf);
  return asm(lexbuf); }
| "//" [^'\n''\r']*
{ return asm(lexbuf); }
| eof
{ return 0; }
| [^')']
{ return asm(lexbuf); }

and asm_string = parse
  "\""
{ return 0; }
| eof     /* Unclosed string, error: return 1 instead of 0 */
{ return 1; }
| newline /* Unclosed string, error: return 1 instead of 0 */
{ return 1; }
| "\\" newline
{ return asm_string(lexbuf); }
| "\\a"
{ return asm_string(lexbuf); }
| "\\" ['0'-'7']['0'-'7']?['0'-'7']?
{ return asm_string(lexbuf); }
| "\\x" ['0'-'9''A'-'F''a'-'f']+
{ return asm_string(lexbuf); }
| [^ '"''\\''\n']
{ return asm_string(lexbuf); }
| _
{ return asm_string(lexbuf); }

and asm_comment = parse
/* Assumes that comments can't be nested */
  "*/"
{ return 0; }
| eof     /* Unclosed string, error: return 1 instead of 0 */
{ return 1; }
| _
{ return asm_comment(lexbuf); }

/**********************************************************************/
/* Rules to suck in a #define line and return it, along with the name */
/* of the macro                                                       */
/**********************************************************************/
and suck_line "suck_line_t" = parse
  "#define "
{ current_line = "#define ";
  suck_macroname(lexbuf);
  return new $(current_line,(stringptr_t)current_source); }
| ['\n' '\r']
{ return suck_line(lexbuf); }
| eof
{ return NULL; }

and suck_macroname = parse
  idchar+
{ current_source = new (string_t)lexeme(lexbuf);
  current_line = strconcat(current_line,*current_source);
  return suck_restofline(lexbuf);
}

and suck_restofline = parse
  [^'\n''\r']*
{ current_line = strconcat(current_line,lexeme(lexbuf)); return 0; }

/**********************************************************************/
/* Rules to read in header spec files                                 */
/**********************************************************************/
and spec "spec_t" = parse
  ['A'-'Z''a'-'z''0'-'9''_''.''/']+ ':'
{ current_header =
  (string_t)substring(lexeme(lexbuf), 0,
                      lexeme_end(lexbuf)-lexeme_start(lexbuf)-1);
  current_symbols = NULL;
  current_omit_symbols = NULL;
  current_cstubs = NULL;
  current_cycstubs = NULL;
  current_prologue = NULL;
  current_epilogue = NULL;
  if (commands(lexbuf)) return NULL;
  current_prologue = imp_rev(current_prologue);
  current_epilogue = imp_rev(current_epilogue);
  current_cstubs = imp_rev(current_cstubs);
  current_cycstubs = imp_rev(current_cycstubs);
  return new $(current_header,
               current_symbols,
               current_omit_symbols,
               current_prologue,
               current_epilogue,
               current_cstubs,
               current_cycstubs);
}
| "//" [^'\n''\r']*
{ return spec(lexbuf); }
| ws+
{ return spec(lexbuf); }
| eof
{ return NULL; }
| _
{ fprintf(stderr,
          "Error in .cys file: expected header file name, found '%c' instead\n",
          lexeme_char(lexbuf,0));
  return NULL; }

and commands = parse
  "include" ws+ '{'
{ snarfed_symbols = NULL;
  if (snarfsymbols(lexbuf)) return 1;
  current_symbols = append(snarfed_symbols,current_symbols);
  return commands(lexbuf); }
| "omitvariables" ws+ '{'
{ snarfed_symbols = NULL;
  if (snarfsymbols(lexbuf)) return 1;
  current_omit_symbols = append(snarfed_symbols,current_omit_symbols);
  return commands(lexbuf); }
| "prologue" ws+ '{'
{ braces_to_match = 1;
  specbuf = Buffer::create(255);
  if (block(lexbuf)) return 1;
  ifdefined_t x = new $((string_t)NULL,
                        (string_t)Buffer::contents((Buffer::T)specbuf));
  current_prologue = new List(x,current_prologue);
  return commands(lexbuf); }
| "prologue" ws+ idchar+ ws+ '{'
{ let s = lexeme(lexbuf);
  s += strlen("prologue");
  while (isspace(*s)) s++;
  char ?t = s;
  while (!isspace(*t)) t++;
  let symbol = substring(s,0,t-s);
  braces_to_match = 1;
  specbuf = Buffer::create(255);
  if (block(lexbuf)) return 1;
  ifdefined_t x = new $((string_t)symbol,
                        (string_t)Buffer::contents((Buffer::T)specbuf));
  current_prologue = new List(x,current_prologue);
  return commands(lexbuf); }
| "epilogue" ws+ '{'
{ braces_to_match = 1;
  specbuf = Buffer::create(255);
  if (block(lexbuf)) return 1;
  ifdefined_t x = new $((string_t)NULL,
                        (string_t)Buffer::contents((Buffer::T)specbuf));
  current_epilogue = new List(x,current_epilogue);
  return commands(lexbuf); }
| "epilogue" ws+ idchar+ ws+ '{'
{ let s = lexeme(lexbuf);
  s += strlen("epilogue");
  while (isspace(*s)) s++;
  char ?t = s;
  while (!isspace(*t)) t++;
  let symbol = substring(s,0,t-s);
  braces_to_match = 1;
  specbuf = Buffer::create(255);
  if (block(lexbuf)) return 1;
  ifdefined_t x = new $((string_t)symbol,
                        (string_t)Buffer::contents((Buffer::T)specbuf));
  current_epilogue = new List(x,current_epilogue);
  return commands(lexbuf); }
| "cstub" ws+ '{'
{ braces_to_match = 1;
  specbuf = Buffer::create(255);
  if (block(lexbuf)) return 1;
  ifdefined_t x = new $((string_t)NULL,
                        (string_t)Buffer::contents((Buffer::T)specbuf));
  current_cstubs = new List(x,current_cstubs);
  return commands(lexbuf); }
| "cstub" ws+ idchar+ ws+ '{'
{ let s = lexeme(lexbuf);
  s += strlen("cstub");
  while (isspace(*s)) s++;
  char ?t = s;
  while (!isspace(*t)) t++;
  let symbol = substring(s,0,t-s);
  braces_to_match = 1;
  specbuf = Buffer::create(255);
  if (block(lexbuf)) return 1;
  ifdefined_t x = new $((string_t)symbol,
                        (string_t)Buffer::contents((Buffer::T)specbuf));
  current_cstubs = new List(x,current_cstubs);
  return commands(lexbuf); }
| "cycstub" ws+ '{'
{ braces_to_match = 1;
  specbuf = Buffer::create(255);
  if (block(lexbuf)) return 1;
  ifdefined_t x = new $((string_t)NULL,
                        (string_t)Buffer::contents((Buffer::T)specbuf));
  current_cycstubs = new List(x,current_cycstubs);
  return commands(lexbuf); }
| "cycstub" ws+ idchar+ ws+ '{'
{ let s = lexeme(lexbuf);
  s += strlen("cycstub");
  while (isspace(*s)) s++;
  char ?t = s;
  while (!isspace(*t)) t++;
  let symbol = substring(s,0,t-s);
  braces_to_match = 1;
  specbuf = Buffer::create(255);
  if (block(lexbuf)) return 1;
  ifdefined_t x = new $((string_t)symbol,
                        (string_t)Buffer::contents((Buffer::T)specbuf));
  current_cycstubs = new List(x,current_cycstubs);
  return commands(lexbuf); }
| "cpp" ws* '{'
{ braces_to_match = 1;
  specbuf = Buffer::create(255);
  if (block(lexbuf)) return 1;
  stringptr_t x = new (string_t)Buffer::contents((Buffer::T)specbuf);
  current_cpp = new List(x,current_cpp);
  return commands(lexbuf); }
| "//" [^'\n''\r']*
{ return commands(lexbuf); }
| ws+
{ return commands(lexbuf); }
| eof
{ return 0; }
| ';'
{ return 0; }
| _
{ fprintf(stderr,
          "Error in .cys file: expected command, found '%c' instead\n",
          lexeme_char(lexbuf,0));
  return 1; }

and snarfsymbols =
/* Expects to be entered just after a left brace, searches for the
   a sequence of symbols and the matching right brace, stores the
   symbols in snarfed_symbols. */
parse
  idchar+
{ snarfed_symbols = new List(new (string_t)lexeme(lexbuf),snarfed_symbols);
  return snarfsymbols(lexbuf); }
| ws+
{ return snarfsymbols(lexbuf); }
| '}'
{ return 0; }
| eof
{ fprintf(stderr,
          "Error in .cys file: unexpected end-of-file\n");
  return 1; }
| _
{ fprintf(stderr,
          "Error in .cys file: expected symbol, found '%c' instead\n",
          lexeme_char(lexbuf,0));
  return 1; }

and block =
/* Expects to be entered just after a left brace, searches for the
   matching right brace, appends everything in between to specbuf.
   Braces in comments, strings, and character constants aren't counted.
   braces_to_match should be set to 1 before calling block. */
parse
  '}'
{ if (braces_to_match == 1) return 0;
  braces_to_match--;
  Buffer::add_char((Buffer::T)specbuf,'}');
  return block(lexbuf); }
| '{'
{ braces_to_match++;
  Buffer::add_char((Buffer::T)specbuf,'{');
  return block(lexbuf); }
| '"'
{ Buffer::add_char((Buffer::T)specbuf,'"');
  block_string(lexbuf);
  return block(lexbuf); }
| "/*"
{ Buffer::add_string((Buffer::T)specbuf,"/*");
  block_comment(lexbuf);
  return block(lexbuf); }
| "//" [^'\n''\r']*
{ Buffer::add_string((Buffer::T)specbuf,lexeme(lexbuf));
  return block(lexbuf); }
| eof
{ return 0; }
| [^'}']
{ Buffer::add_char((Buffer::T)specbuf,lexeme_char(lexbuf,0));
  return block(lexbuf); }

and block_string = parse
  "\""
{ Buffer::add_char((Buffer::T)specbuf,'"'); return 0; }
| eof     /* Unclosed string, error: return 1 instead of 0 */
{ return 1; }
| newline /* Unclosed string, error: return 1 instead of 0 */
{ return 1; }
| "\\" newline
{ Buffer::add_string((Buffer::T)specbuf,lexeme(lexbuf));
  return block_string(lexbuf); }
| "\\a"
{ Buffer::add_string((Buffer::T)specbuf,lexeme(lexbuf));
  return block_string(lexbuf); }
| "\\" ['0'-'7']['0'-'7']?['0'-'7']?
{ Buffer::add_string((Buffer::T)specbuf,lexeme(lexbuf));
  return block_string(lexbuf); }
| "\\x" ['0'-'9''A'-'F''a'-'f']+
{ Buffer::add_string((Buffer::T)specbuf,lexeme(lexbuf));
  return block_string(lexbuf); }
| [^ '"''\\''\n']
{ Buffer::add_string((Buffer::T)specbuf,lexeme(lexbuf));
  return block_string(lexbuf); }
| _
{ Buffer::add_string((Buffer::T)specbuf,lexeme(lexbuf));
  return block_string(lexbuf); }

and block_comment = parse
/* Assumes that comments can't be nested */
  "*/"
{ Buffer::add_string((Buffer::T)specbuf,"*/"); return 0; }
| eof     /* Unclosed string, error: return 1 instead of 0 */
{ return 1; }
| _
{ Buffer::add_string((Buffer::T)specbuf,lexeme(lexbuf));
  return block_comment(lexbuf); }

{

  static void pr(stringptr_t sptr) {
    printf(" %s\n",*sptr);
  }

  extern void scan_type(type_t t);
  void scan_exp(exp_opt_t e) {
    switch (e->r) {
    case &Var_e(&$(_,v),_):
      // This case is actually impossible after only parse
      fallthru(v);
    case &UnknownId_e(&$(_,v)):
      add_target(v);
      return;
    case &Primop_e(_,x):
      for (; x != NULL; x = x->tl) {
        scan_exp(x->hd);
      }
      return;
    case &Subscript_e(e1,e2):
      fallthru(e1,e2);
    case &SeqExp_e(e1,e2):
      fallthru(e1,e2);
    case &AssignOp_e(e1,_,e2):
      scan_exp(e1);
      scan_exp(e2);
      return;
    case &Deref_e(e1):
      fallthru(e1);
    case &Sizeofexp_e(e1):
      fallthru(e1);
    case &Address_e(e1):
      fallthru(e1);
    case &Increment_e(e1,_):
      scan_exp(e1);
      return;
    case &Conditional_e(e1,e2,e3):
      scan_exp(e1);
      scan_exp(e2);
      scan_exp(e3);
      return;
    case &FnCall_e(e1,x,_):
      // This case is actually impossible after only parse
      fallthru(e1,x);
    case &UnknownCall_e(e1,x):
      scan_exp(e1);
      for (; x != NULL; x = x->tl) {
        scan_exp(x->hd);
      }
      return;
    case &Cast_e(t1,e1):
      scan_type(t1);
      scan_exp(e1);
      return;
    case &Malloc_e(MallocInfo{iscalloc,ropt,topt,e,_}):
      if (ropt != NULL) scan_exp((exp_t)ropt);
      if (topt != NULL) scan_type(*topt);
      scan_exp(e);
      return;
    case &Sizeoftyp_e(t1):
      scan_type(t1);
      return;
    case &StructMember_e(e1,fn):
      fallthru(e1,fn);
    case &StructArrow_e(e1,fn):
      scan_exp(e1);
      add_target(fn);
      return;
    case &Offsetof_e(t1,f):
      scan_type(t1);
      switch (f) {
      case &StructField(fn): add_target(fn); break;
      case &TupleIndex(_): break;
      }        
      return;
    case &Const_e(_):
      return;
    case &UnresolvedMem_e(_,x):
      for (; x != NULL; x = x->tl) {
        let &$(_,e1) = x->hd;
        scan_exp(e1);
      }
      return;
    case &StmtExp_e(_):
      fprintf(stderr,"Error: unexpected Stmt_e\n");
      exit(1); return;
    case &Throw_e(_):
      fprintf(stderr,"Error: unexpected Throw_e\n");
      exit(1); return;
    case &NoInstantiate_e(_):
      fprintf(stderr,"Error: unexpected NoInstantiate_e\n");
      exit(1); return;
    case &Instantiate_e(_,_):
      fprintf(stderr,"Error: unexpected Instantiate_e\n");
      exit(1); return;
    case &New_e(_,_):
      fprintf(stderr,"Error: unexpected New_e\n");
      exit(1); return;
    case &Gentyp_e(_,_):
      fprintf(stderr,"Error: unexpected Gentyp_e\n");
      exit(1); return;
    case &Tuple_e(_):
      fprintf(stderr,"Error: unexpected Tuple_e\n");
      exit(1); return;
    case &CompoundLit_e(_,_):
      fprintf(stderr,"Error: unexpected CompoundLit_e\n");
      exit(1); return;
    case &Array_e(_):
      fprintf(stderr,"Error: unexpected Array_e\n");
      exit(1); return;
    case &Comprehension_e(_,_,_):
      fprintf(stderr,"Error: unexpected Comprehension_e\n");
      exit(1); return;
    case &Struct_e(_,_,_,_):
      fprintf(stderr,"Error: unexpected Struct_e\n");
      exit(1); return;
    case &AnonStruct_e(_,_):
      fprintf(stderr,"Error: unexpected AnonStruct_e\n");
      exit(1); return;
    case &Tunion_e(_,_,_,_,_):
      fprintf(stderr,"Error: unexpected Tunion_e\n");
      exit(1); return;
    case &Enum_e(_,_,_):
      fprintf(stderr,"Error: unexpected Enum_e\n");
      exit(1); return;
    case &AnonEnum_e(_,_,_):
      fprintf(stderr,"Error: unexpected AnonEnum_e\n");
      exit(1); return;
    case &Codegen_e(_):
      fprintf(stderr,"Error: unexpected Codegen_e\n");
      exit(1); return;
    case &Fill_e(_):
      fprintf(stderr,"Error: unexpected Fill_e\n");
      exit(1); return;
    }
  }

  void scan_exp_opt(exp_opt_t eo) {
    if (eo) scan_exp(eo);
    return;
  }

  void scan_type(type_t t) {
    switch (t) {
    case VoidType:
    case &IntType(_,_):
    case FloatType:
    case &DoubleType(_):
      return;

    case &PointerType(x):
      scan_type(x.elt_typ);
      return;
    case &ArrayType(t,_,sz):
      scan_type(t);
      scan_exp_opt(sz);
      return;
    case &FnType(x):
      scan_type(x.ret_typ);
      for (let a = x.args; a != NULL; a = a->tl) {
        let &$(_,_,argt) = a->hd;
        scan_type(argt);
      }
      if (x.cyc_varargs != NULL)
        scan_type(x.cyc_varargs->type);
      return;
    case &AnonStructType(sfs):
      fallthru(sfs);
    case &AnonUnionType(sfs):
      for (; sfs != NULL; sfs = sfs->tl) {
        scan_type(sfs->hd->type);
        scan_exp_opt(sfs->hd->width);
      }
      return;
    case &AnonEnumType(_):
      return;
    case &StructType(NULL,_,_):
      return;
    case &UnionType(NULL,_,_):
      return;
    case &StructType(&$(_,v),_,_):
      fallthru(v);
    case &UnionType(&$(_,v),_,_):
      fallthru(v);
    case &EnumType(&$(_,v),_):
      fallthru(v);
    case &TypedefType(&$(_,v),_,_):
      add_target(v);
      return;

    case &Evar(_,_,_,_):
      fprintf(stderr,"Error: unexpected Evar\n");
      exit(1); return;
    case &VarType(_):
      fprintf(stderr,"Error: unexpected VarType\n");
      exit(1); return;
    case &TunionType(_):
      fprintf(stderr,"Error: unexpected TunionType\n");
      exit(1); return;
    case &TunionFieldType(_):
      fprintf(stderr,"Error: unexpected TunionFieldType\n");
      exit(1); return;
    case &TupleType(_):
      fprintf(stderr,"Error: unexpected TupleType\n");
      exit(1); return;
    case &RgnHandleType(_):
      fprintf(stderr,"Error: unexpected RgnHandleType\n");
      exit(1); return;
    case HeapRgn:
      fprintf(stderr,"Error: unexpected HeapRgn\n");
      exit(1); return;
    case &AccessEff(_):
      fprintf(stderr,"Error: unexpected AccessEff\n");
      exit(1); return;
    case &JoinEff(_):
      fprintf(stderr,"Error: unexpected JoinEff\n");
      exit(1); return;
    case &RgnsEff(_):
      fprintf(stderr,"Error: unexpected RgnsEff\n");
      exit(1); return;
    case &SizeofType(_):
      fprintf(stderr,"Error: unexpected sizeof_t\n");
      exit(1); return;
    }
  }

  line_t scan_decl(decl_t d) {
    current_targets = new Set::empty(strptrcmp);
    switch (d->r) {
    case &Var_d(x):
      let &$(_,v) = x->name;
      current_source = v;
      scan_type(x->type);
      scan_exp_opt(x->initializer);
      break;
    case &Fn_d(x):
      let &$(_,v) = x->name;
      current_source = v;
      scan_type(x->ret_type);
      for (let a = x->args; a != NULL; a = a->tl) {
        let &$(_,_,t1) = a->hd;
        scan_type(t1);
      }
      if (x->cyc_varargs != NULL)
        scan_type(x->cyc_varargs->type);
      if (x->is_inline) {
        fprintf(stderr,"Warning: ignoring inline function\n");
      }
      break;
    case &Struct_d(x):
      if (!x->name) return NULL;
      let &$(_,v) = x->name->v;
      current_source = v;
      if (x->fields) {
        for (let fs = x->fields->v; fs != NULL; fs = fs->tl) {
          let f = fs->hd;
          scan_type(f->type);
          scan_exp_opt(f->width);
        }
        // That takes care of what the decl depends on.  Now must add
        // that each field depends on the decl.
        for (let fs = x->fields->v; fs != NULL; fs = fs->tl) {
          // FIX!!
        }
      }
      break;
    case &Union_d(x):
      // This case is identical to the last, but x has a different type
      // so we can't fallthru
      if (!x->name) return NULL;
      let &$(_,v) = x->name->v;
      current_source = v;
      if (x->fields) {
        for (let fs = x->fields->v; fs != NULL; fs = fs->tl) {
          let f = fs->hd;
          add_target(f->name);
          scan_type(f->type);
          scan_exp_opt(f->width);
        }
        // That takes care of what the decl depends on.  Now must add
        // that each field depends on the decl.
        for (let fs = x->fields->v; fs != NULL; fs = fs->tl) {
          // FIX!!
        }
      }
      break;
    case &Enum_d(x):
      let &$(_,v) = x->name;
      current_source = v;
      if (x->fields) {
        for (let fs = x->fields->v; fs != NULL; fs = fs->tl) {
          let f = fs->hd;
          scan_exp_opt(f->tag);
        }
        // That takes care of what the decl depends on.  Now must add
        // that each field depends on the decl.
        for (let fs = x->fields->v; fs != NULL; fs = fs->tl) {
          // FIX!!
        }
      }
      break;
    case &Typedef_d(x):
      let &$(_,v) = x->name;
      current_source = v;
      scan_type(x->defn);
      break;

    case &Let_d(_,_,_,_,_):
      fprintf(stderr,"Error: unexpected let declaration\n");
      exit(1); return NULL;
    case &Tunion_d(_):
      fprintf(stderr,"Error: unexpected tunion declaration\n");
      exit(1); return NULL;
    case &Letv_d(_):
      fprintf(stderr,"Error: unexpected let declaration\n");
      exit(1); return NULL;
    case &Namespace_d(_,_):
      fprintf(stderr,"Error: unexpected namespace declaration\n");
      exit(1); return NULL;
    case &Using_d(_,_):
      fprintf(stderr,"Error: unexpected using declaration\n");
      exit(1); return NULL;
    case &ExternC_d(_):
      fprintf(stderr,"Error: unexpected extern \"C\" declaration\n");
      exit(1); return NULL;
    }

    /* The cast is needed so the return type matches */
    return new $((_ @)current_source,*current_targets);
  }

  /* Type for representing dependencies */
  typedef Hashtable::table_t<stringptr_t<`H,`H>,
                             Set::set_t<stringptr_t<`H,`H>,`H>> dep_t;

  dep_t new_deps() {
    return Hashtable::create(107,strptrcmp,Hashtable::hash_stringptr);
  }

  Set::set_t<stringptr_t<`H,`H>,`H> find(dep_t t, stringptr_t<`H,`H> x) {
    try return Hashtable::lookup(t,x);
    catch {
    case Not_found: return Set::empty(strptrcmp);
    }
  }

  Set::set_t<stringptr_t<`H,`H>,`H>
    reachable(list_t<stringptr_t<`H,`H>> init, dep_t t) {
    /* Maintain two sets, curr and delta: curr is the "current set"
       and delta is the subset of curr that was added in the previous
       step.  Initially curr = delta = the initial nodes.

       While delta is not empty,
         find a set, next, that consists of the nodes reachable
           from delta in a single step;
         set delta = next - curr, and curr = curr U delta.
    */
    Set::set_t<stringptr_t<`H,`H>,`H> emptyset = Set::empty(strptrcmp);
    Set::set_t<stringptr_t<`H,`H>,`H> curr;
    for (curr = emptyset; init != NULL; init = init->tl)
      curr = Set::insert(curr,init->hd);
    let delta = curr;

    while (Set::cardinality(delta) > 0) {
      let next = emptyset;
      for (let z = Set::elements(delta); z != NULL; z = z->tl)
        next = Set::union_two(next,find(t,z->hd));
      delta = Set::diff(next,curr);
      curr = Set::union_two(curr,delta);
    }
    return curr;
  }

  int force_directory(string_t d) {
    /* We could do this with stat, but stat is more
       platform dependent; this is more portable. */
    let fd = open(d,O_RDONLY);
    if (fd == -1) {
      if (mkdir(d,0700) == -1) {
        fprintf(stderr,"Error: could not create directory %s\n",d);
        return 1;
      }
    }
    else close(fd);
    return 0;
  }

  int force_directory_prefixes(string_t file) {
    /* File is a string like "foo/bar/baz/xx.h", we want to make sure
       that the directories "foo", "foo/bar", "foo/bar/baz" all exist
       so we can create file. */
    let curr = strdup(file); // Make sure curr is on heap
    /* Compute all prefixes of file */
    let x = NULL;
    while (true) {
      curr = Filename::dirname(curr);
      if (curr.size == 0) break;
      x = new List(new (string_t)curr,x);
    }
    /* Make sure all prefixes exist */
    for (; x != NULL; x = x->tl) {
      if (force_directory(*x->hd)) return 1;
    }
    return 0;
  }

  int process_file(string_t filename,
                   string_t dir,
                   list_t<stringptr_t<`H,`H>,`H> start_symbols,
                   list_t<stringptr_t<`H,`H>,`H> omit_symbols,
                   list_t<ifdefined_t,`H> prologue,
                   list_t<ifdefined_t,`H> epilogue,
                   list_t<ifdefined_t,`H> cstubs,
                   list_t<ifdefined_t,`H> cycstubs) {
    FILE *maybe;
    FILE @in_file;
    FILE @out_file;

    fprintf(stderr,
            "********************************* %s...\n",filename);

    /* Cd into dir, where the header files will be built.  Remember
       the current dir so we can cd back after we're done. */
    char ?buf = new {for i<1024: '\0'};
    let cwd = getcwd(buf,buf.size);
    if (chdir(dir)) {
      fprintf(stderr,"Error: can't change directory to %s\n",dir);
      return 1;
    }

    log("\n%s:\n",filename);

    /* Calculate necessary file names.  For example:
       filename = sys/types.h
       basename = types.h
       choppedname = types
       cppinfile = types.iI
       preprocfile = types.i
       filteredfile = types.iX
       dirname = sys
       cfilename = sys/ctypes.h
    */
    let basename = Filename::basename(filename);
    let choppedname = Filename::chop_extension(basename);
    let cppinfile = strconcat(choppedname, ".iI");
    let preprocfile = strconcat(choppedname, ".i");
    let filteredfile = strconcat(choppedname, ".iX");
    let dirname = Filename::dirname(filename);
    let cfilename = 
      (dirname.size == 0)?
      (aprintf("c%s", basename)):
      (Filename::concat(dirname, aprintf("c%s", basename)));

    /* Make sure we'll be able to create files in the right directories */
    if (force_directory_prefixes(filename)) {
      return 1;
    }
    /* Table to hold the dependencies */
    dep_t t = new_deps();

    /* Get the macros out of the file */
    let GCC = Cstring_to_string(Ccomp);
    maybe = fopen(cppinfile,"w");
    if (!maybe) {
      fprintf(stderr,"Error: could not create file %s\n",cppinfile);
      return 1;
    }
    out_file = (FILE@)maybe;
    current_cpp = imp_rev(current_cpp);
    for (let l = current_cpp; l != NULL; l = l->tl)
      fputs(*(l->hd),out_file);
    fprintf(out_file,"#include <%s>\n",filename);
    fclose(out_file);
    let cmd = aprintf("%s -E -dM -o %s %s",
                      GCC,preprocfile,cppinfile);
    if (system(cmd) != 0) {
      remove(cppinfile);
      /* The header probably doesn't exist on this system;
         create a default header. */
      maybe = fopen(filename,"w");
      if (!maybe) {
        fprintf(stderr,"Error: could not create file %s\n",filename);
        return 1;
      }
      out_file = (FILE@)maybe;
      fprintf(out_file,
              "#error -- %s is not supported on this platform\n",
              filename);
      fclose(out_file);
      maybe = fopen(cfilename,"w");
      if (!maybe) {
        fprintf(stderr,"Error: could not create file %s\n",cfilename);
        return 1;
      }
      out_file = (FILE@)maybe;
      fprintf(out_file,
              "#error -- %s is not supported on this platform\n",
              cfilename);
      fclose(out_file);
      fprintf(stderr,"Warning: %s will not be supported on this platform\n",
              filename);

      log("Not supported on this platform\n");
      /* Return to original directory so that we're set up for
         the next file */
      if (chdir(cwd)) {
        fprintf(stderr,"Error: could not change directory to %s\n", cwd);
        return 1;
      }
      return 0;
    }
    maybe = fopen(preprocfile,"r");
    if (!maybe) {
      return 1;
    }
    in_file = (FILE@)maybe;
    let l = Lexing::from_file(in_file);
    let entry;
    while ( (entry = line(l)) != NULL) {
      let &$(name,uses) = (_ @)entry; // force NULL check to get rid of warning
      Hashtable::insert(t,name,uses);
      //      printf("Macro %s uses:\n",*name);
      //      Set::iter(pr,uses);
    }
    fclose(in_file);

    /* Get the type declarations out of the file */
    cmd = aprintf("%s -E -o %s %s",
                  GCC,preprocfile,cppinfile);
    if (system(cmd) != 0) {
      return 1;
    }
    maybe = fopen(preprocfile,"r");
    if (!maybe) {
      return 1;
    }
    in_file = (FILE@)maybe;
    l = Lexing::from_file(in_file);
    slurp_out = fopen(filteredfile,"w");
    if (!slurp_out) {
      return 1;
    }
    if (slurp(l)) {
      log("Error: Unclosed string in %s\n",filename);
      fprintf(stderr,"Error: Unclosed string in %s\n",filename);
      fclose(in_file);
      fclose((FILE @)slurp_out);
      remove(cppinfile);
      remove(preprocfile);
      remove(filteredfile);
      return 1;
    }
    fclose(in_file);
    fclose((FILE @)slurp_out);

    maybe = fopen(filteredfile,"r");
    if (!maybe) {
      return 1;
    }
    in_file = (FILE@)maybe;
    Position::reset_position(filteredfile);
    Lex::lex_init(); // must forget typedefs, may as well flush symbols too
    let decls = Parse::parse_file(in_file);
    Lex::lex_init(); // garbage collect those big tries
    fclose(in_file);
    remove(filteredfile);

    for (let d = decls; d != NULL; d = d->tl) {
      let entry = scan_decl(d->hd);
      if (entry == NULL) continue;
      let &$(name,uses) = (_ @)entry; // force NULL check to get rid of warning
      /* Add the dependencies to the table.  Note that name might
         already have an entry in the table -- there can be more than
         one declaration for a name, e.g., struct stat and function
         stat in sys/stat.h. */
      let old;
      try
        old = Hashtable::lookup(t,name);
      catch {
      case Not_found: old = Set::empty(strptrcmp); break;
      }
      Hashtable::insert(t,name,Set::union_two(uses,old));
    }

    /* Compute reachable symbols */
    let reachable_set = reachable(start_symbols,t);

    /* Print reachable declarations */
    let reachable_decls = NULL;
    Set::set_t<stringptr_t<`H,`H>> defined_symbols = Set::empty(strptrcmp);
    for (let d = decls; d != NULL; d = d->tl) {
      let decl = d->hd;
      let name;
      switch (decl->r) {
        // This switch has just a bit more functionality than decl_name,
        // enough so that it doesn't make sense to combine them :-(
      case &Var_d(x):
        let &$(_,v) = x->name;
        defined_symbols = Set::insert(defined_symbols,v);
        if (mem(strptrcmp,omit_symbols,v)) name = NULL;
        else name = v;
        break;
      case &Fn_d(x):
        let &$(_,v) = x->name;
        defined_symbols = Set::insert(defined_symbols,v);
        if (mem(strptrcmp,omit_symbols,v)) name = NULL;
        else name = v;
        break;
      case &Struct_d(x):
        if (!x->name) name = NULL;
        let &$(_,v) = x->name->v;
        name = v;
        break;
      case &Union_d(x):
        // This case is identical to the last, but x has a different type
        // so we can't fallthru
        if (!x->name) name = NULL;
        let &$(_,v) = x->name->v;
        name = v;
        break;
      case &Enum_d(x):
        let &$(_,v) = x->name;
        name = v;

        // see if fields are reachable or name is reachable
        if (name != NULL && Set::member(reachable_set,(stringptr_t)name)) {
          reachable_decls = new List(decl,reachable_decls);
        }
        else if (x->fields) {
          for (let fs = x->fields->v; fs != NULL; fs = fs->tl) {
            let f = fs->hd;
            let &$(_,v) = f->name; 
            if (Set::member(reachable_set,v)) {
              reachable_decls = new List(decl,reachable_decls);
              break; // exit for-loop
            }
          }
        }
        name = NULL;
        break;
      case &Typedef_d(x):
        let &$(_,v) = x->name;
        name = v;
        break;

      case &Let_d(_,_,_,_,_):
      case &Tunion_d(_):
      case &Letv_d(_):
      case &Namespace_d(_,_):
      case &Using_d(_,_):
      case &ExternC_d(_):
        name = NULL;
        break;
      }
      if (name != NULL && Set::member(reachable_set,(stringptr_t)name))
        reachable_decls = new List(decl,reachable_decls);
    }
    reachable_decls = imp_rev(reachable_decls);
    maybe = fopen(filename,"w");
    if (!maybe) {
      return 1;
    }
    out_file = (FILE @)maybe;
    fprintf(out_file,"#include <%s>\nusing Std;\n",cfilename);
    fclose(out_file);
    maybe = fopen(cfilename, "w");
    if (!maybe) {
      return 1;
    }
    out_file = (FILE @)maybe;
    mstring_t ifdefmacro = aprintf("_%s_",filename);
    for (let j = 0; j < ifdefmacro.size; j++) {
      if (ifdefmacro[j] == '.' || ifdefmacro[j] == '/')
        ifdefmacro[j] = '_';
      else if (ifdefmacro[j] != '_' && ifdefmacro[j] != '/')
        ifdefmacro[j] = (char)toupper(ifdefmacro[j]);
    }
    fprintf(out_file,
            "#ifndef %s\n"
            "#define %s\n",
            ifdefmacro,
            ifdefmacro);

    if (prologue != NULL) {
      for (let x = prologue; x != NULL; x = x->tl) {
        let &$(symbol,text) = x->hd;
        if (text != NULL &&
            (symbol == NULL || Set::member(defined_symbols, new symbol)))
          // FIX: FPUTS DUMPS CORE ON LINUX IF FIRST ARG IS NULL!!
          fputs(text,out_file);
        else
          log("%s is not supported on this platform\n",symbol);
      }
    }

    fprintf(out_file,"\nnamespace Std {\n");

    for (let d = reachable_decls; d != NULL; d = d->tl) {
      let decl = d->hd;
      let anon_enum = false;
      let name;
      switch (decl->r) {
      case &Var_d(x):
        let &$(_,v) = x->name;
        name = v;
        break;
      case &Fn_d(x):
        let &$(_,v) = x->name;
        name = v;
        break;
      case &Struct_d(x):
        if (!x->name) name = NULL;
        let &$(_,v) = x->name->v;
        name = v;
        break;
      case &Union_d(x):
        // This case is identical to the last, but x has a different type
        // so we can't fallthru
        if (!x->name) name = NULL;
        let &$(_,v) = x->name->v;
        name = v;
        break;
      case &Enum_d(x):
        let &$(_,v) = x->name;
        name = v;
        break;
      case &Typedef_d(x):
        let &$(_,v) = x->name;
        name = v;
        break;

      case &Let_d(_,_,_,_,_):
      case &Tunion_d(_):
      case &Letv_d(_):
      case &Namespace_d(_,_):
      case &Using_d(_,_):
      case &ExternC_d(_):
        name = NULL;
        break;
      }
      if (!name && !anon_enum) continue;
      if (name) {
        ifdefmacro = aprintf("_%s_def_",*name);
        fprintf(out_file,"#ifndef %s\n",ifdefmacro);
        fprintf(out_file,"#define %s\n",ifdefmacro);
        // Because there's no decl2file and I'm lazy
        Absynpp::decllist2file(list(decl),out_file);
        fprintf(out_file,"#endif\n");
      }
      else {
        // Anonymous enum
        Absynpp::decllist2file(list(decl),out_file);
      }
    }

    /* Print reachable macros */
    cmd = aprintf("%s -E -dM -o %s %s",
                  GCC,preprocfile,cppinfile);
    if (system(cmd) != 0) {
      return 1;
    }
    maybe = fopen(preprocfile,"r");
    if (!maybe) {
      return 1;
    }
    in_file = (FILE@)maybe;
    l = Lexing::from_file(in_file);
    let entry2;
    while ( (entry2 = suck_line(l)) != NULL) {
      let &$(line,name) = (_ @)entry2; // force NULL check to get rid of warning
      if (Set::member(reachable_set,name)) {
        fprintf(out_file,"#ifndef %s\n",*name);
        fprintf(out_file,"%s\n",line);
        fprintf(out_file,"#endif\n");
      }
    }
    fclose(in_file);
    remove(cppinfile);
    remove(preprocfile);

    if (epilogue != NULL) {
      for (let x = epilogue; x != NULL; x = x->tl) {
        let &$(symbol,text) = x->hd;
        if (text != NULL &&
            (symbol == NULL || Set::member(defined_symbols, new symbol)))
          // FIX: FPUTS DUMPS CORE ON LINUX IF FIRST ARG IS NULL!!
          fputs(text,out_file);
        else
          log("%s is not supported on this platform\n",symbol);
      }
    }
    fprintf(out_file,"}\n"); // close namespace Std
    fprintf(out_file,"#endif\n");
    fclose(out_file);

    /* Dump out the c stubs */
    if (cstubs != NULL) {
      out_file = (FILE @)cstubs_file;
      for (let x = cstubs; x != NULL; x = x->tl) {
        let &$(symbol,text) = x->hd;
        if (text != NULL &&
            (symbol == NULL || Set::member(defined_symbols, new symbol)))
          fputs(text,out_file);
      }
    }

    /* Dump out the cyclone stubs */
    out_file = (FILE @)cycstubs_file;
    /* Always include the header, to make sure it has no errors */
    fprintf(out_file, "#include <%s>\n\n", cfilename);
    if (cycstubs != NULL) {
      out_file = (FILE @)cycstubs_file;
      fprintf(out_file, "namespace Std {\n");
      for (let x = cycstubs; x != NULL; x = x->tl) {
        let &$(symbol,text) = x->hd;
        if (text != NULL &&
            (symbol == NULL || Set::member(defined_symbols, new symbol)))
          fputs(text,out_file);
      }
      fprintf(out_file, "}\n\n");
    }

    /* Return to original directory so that we're set up for
       the next file */
    if (chdir(cwd)) {
      fprintf(stderr,"Error: could not change directory to %s\n", cwd);
      return 1;
    }
    return 0;
  }

  int process_specfile(string_t file,string_t dir) {
    let maybe = fopen(file,"r");
    if (!maybe) return 1;
    let in_file = (FILE@)maybe;
    let l = Lexing::from_file(in_file);
    let entry;
    while ( (entry = spec(l)) != NULL) {
      let &$(headerfile,start_symbols,omit_symbols,
             prologue,epilogue,cstubs,cycstubs) = (_ @)entry;
      if (process_file(headerfile,dir,start_symbols,omit_symbols,
                       prologue,epilogue,cstubs,cycstubs)) {
        fclose(in_file);
        return 1;
      }
    }
    fclose(in_file);
    return 0;
  }

  int getsize(const char ?dir, const char ?includes, const char ?type) {
    let getsizefilename = Filename::concat(dir,"getsize.c");
    let getsizeexec = Filename::concat(dir,"getsize");
    let getsizeout = Filename::concat(dir,"getsize.out");
    let getsizefile = fopen(getsizefilename,"w");
    if (!getsizefile) {
      fprintf(stderr,"Error: could not create %s\n",getsizefilename);
      log("Warning: could not find the size of %s\n",type);
      return -1;
    }
    /* We have to jump through some hoops here because system is not
       returning the value returned by main, like it's supposed to. */
    fprintf((FILE@)getsizefile,
            "%s\n"
            "#include <stdio.h>\n"
            "int main() {\n"
            "  FILE *f = fopen(\"%s\",\"w\");\n"
            "  fprintf(f,\"%%d\\n\",sizeof(%s));\n"
            "  fclose(f);\n"
            "  return (int)sizeof(%s);\n"
            "}\n",
            includes,
            getsizeout,
            type,
            type);
    fclose((FILE@)getsizefile);
    let GCC = Cstring_to_string(Ccomp);
    let gcccmd = aprintf("%s -o %s %s",
                         GCC,
                         getsizeexec,
                         getsizefilename);
    if (system(gcccmd) != 0) {
      fprintf(stderr,"Warning: could not find the size of %s; continuing anyway\n",type);
      log("Warning: could not find the size of %s\n",type);
      return -1;
    }
    let z = system(getsizeexec);
    log("size of %s returned by system is %d\n",type,z);
    let f = fopen(getsizeout,"r");
    int w = -1;
    if (fscanf((FILE@)f,"%d",&w) != 1) {
      log("Warning: could not find the size of %s\n",type);
      return -1;
    }
    log("size of %s read from file %s is %d\n",type,getsizeout,w);
    fclose((FILE@)f);
    remove(getsizeout);
    remove(getsizefilename);
    remove(getsizeexec);
    return w;
  }

  extern "C" void GC_blacklist_warn_clear();
  int main(int argc, char ??argv) {
    GC_blacklist_warn_clear();
    if (argc < 3) {
      fprintf(stderr,
              "Usage: buildlib <dir> <spec>\n"
              " where <dir> the output directory"
              " and <spec> is a .cys specification file.\n");
      return 1;
    }
    let dir = argv[1];

    /* Make sure the directory where the output files will be placed exists */
    if (force_directory_prefixes(dir) || force_directory(dir)) {
      fprintf(stderr,"Error: could not create directory %s\n",dir);
      return 1;
    }

    /* Create an empty log file -- most importantly, any previous log
       file will be truncated */
    log_file = fopen(Filename::concat(dir,"BUILDLIB.LOG"),"w");
    if (!log_file) {
      fprintf(stderr,"Error: could not create log file in directory %s\n",dir);
      return 1;
    }

    /* Create an empty cstubs.cyc file */
    cstubs_file = fopen(Filename::concat(dir,"cstubs.c"),"w");
    if (!cstubs_file) {
      fprintf(stderr,"Error: could not create cstubs.c in directory %s\n",dir);
      return 1;
    }

    /* Create a cycstubs.cyc file with the standard prologue */
    cycstubs_file = fopen(Filename::concat(dir,"cycstubs.cyc"),"w");
    if (!cycstubs_file) {
      fprintf(stderr,
              "Error: could not create cycstubs.c in directory %s\n",
              dir);
      return 1;
    }
    fprintf((FILE@)cycstubs_file,
            "#include <core.h>\n"
            "using Core;\n\n");

    /* Find the sizes of various types, for use in constant expressions */
    sizeof_unsignedlongint = getsize(dir,"","unsigned long int");
    sizeof_unsignedshortint = getsize(dir,"","unsigned short int");
    sizeof_shortint = getsize(dir,"","short int");
    sizeof_int = getsize(dir,"","int");
    sizeof_short = getsize(dir,"","short");
    /* sys/types is needed on OS X b/c it defines needed typedef u_int */
    sizeof_fdmask = getsize(dir,"#include <sys/types.h>\n#include <sys/select.h>","fd_mask");
    sizeof___fdmask = getsize(dir,"#include <sys/types.h>\n#include <sys/select.h>","__fd_mask");
    sizeof_uint32 = getsize(dir,"#include <sys/types.h>","__uint32_t");
    /* sys/types is needed on OS X b/c it defines needed typedef u_char */
    sizeof_sockaddr = getsize(dir,"#include <sys/types.h>\n#include <sys/socket.h>","struct sockaddr");
    sizeof_inport = getsize(dir,"#include <sys/types.h>\n#include <netinet/in.h>","in_port_t");
    sizeof_inaddr = getsize(dir,"#include <sys/types.h>\n#include <netinet/in.h>","struct in_addr");
            
    for (int i = 2; i<argc; i++) {
      process_specfile(argv[i],dir);
    }

    fclose((FILE@)log_file);
    fclose((FILE@)cstubs_file);
    fclose((FILE@)cycstubs_file);

    return 0;
  }
}
