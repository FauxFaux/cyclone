/* Abstract expressions for control flow.
   Copyright (C) 2001 Dan Grossman, Greg Morrisett
   This file is part of the Cyclone compiler.

   The Cyclone compiler is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   The Cyclone compiler is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with the Cyclone compiler; see the file COPYING. If not,
   write to the Free Software Foundation, Inc., 59 Temple Place -
   Suite 330, Boston, MA 02111-1307, USA. */

// The creation and manipulation of "abstract expressions" for
// control-flow checking.  The primary reason to put this in its own
// module is that we wish to enforce the following grammar without a
// lot of nested enums for abstract operands that just have to get
// annoyingly traversed.  So the exported constructor functions do the
// necessary checks.
// By using this restricted grammar, we essentially normalize assignments
// in such a way that computing an expression's transfer is easy.
// (As opposed to having to deal with x = *&*&*&y; and crap.)  The abstraction
// of expressions has to deal with this.

// absexp ::= Skip | Use(rvalue) | Malloc(exp) | Assign(lvalue,rvalue)
//          | Group(absexpgroup,list_t<absexp>) | Stmt(stmt) | Bottom
// absexpgroup ::= Ordered | Unordered | Oneof
// rvalue ::= & addressable | lvalue
// lvalue ::= noaddress | Unknown 
//   (note: Include malloc b/c *(malloc(int)) = 7 is legit although stupid)
// addressable ::= x | malloc_op(exp) | noaddress.f
// noaddress ::= addressable | *noaddress

// Another invariant is that "top-level" absops cannot have struct or tuple
// types.  Instead, the constructors expand out any uses are assignments
// to the leaves.  That is, top-level absops must be "leaves" in the
// aggregate sense.  It is up to the translation to pass us the right type
// to make this happen.

// for debugging
#include <stdio.h>

#include <core.h>
#include <list.h>
#include <string.h>
#include <dict.h>
#include "tcutil.h"
#include "absyn.h"
#include "cf_flowinfo.h"
#include "new_control_flow.h"
#include "cf_absexp.h"
using Absyn;
using List;
using CfFlowInfo;
using NewControlFlow;
namespace CfAbsexp;

xtunion exn {BadAbsexp};

typedef Dict::dict_t<`a,`b> dict_t<`a,`b>;
typedef Position::seg_t     seg_t;

tunion Absexpgroup { 
  OrderedG;   // all get executed in left-to-right order
  UnorderedG; // could be any order
  OneofG;     // exactly one option gets executed
};

abstract tunion Absexp {
  BottomAE;
  SkipAE;
  UseAE(absop_t); 
  AssignAE(absop_t,absop_t); // first operand must be an lvalue
  MallocAE(local_root_t,int); // int is unique id (for debugging)
  StmtAE(stmt_t);
  GroupAE(absexpgroup_t,list_t<absexp_t>);
};
// Notice Unknown and Address can only occur at "toplevel"
// Notice you cannot take Address of Deref (But can do &((*x).f))
// Note: lvalues are anything except AddressOp and UnknownOp (for the latter
//       we have the special-case UseAE)
// Note: Malloc means "the memory" not "the pointer to the memory"
abstract tunion Absop {
  UnknownOp;           
  AddressOp(absop_t);        // op must be Local, Member, or Malloc
  DerefOp(absop_t);          // op must be Local, Member, or Deref
  MemberOp(absop_t,field_name_t); // op must be Local, Member, Malloc, or Deref
  LocalOp(vardecl_t);       
  MallocOp(exp_t,int); // int is unique id (for debugging)
};

// for enforcing the invariants stated above
// note: we know nothing about an op's type in this module, but the flow
//       analysis uses types to track the right fields.
static void ok_address_arg(absop_t ao) {
  switch(ao) {
  case &LocalOp(_):    
  case &MemberOp(_,_): 
  case &MallocOp(_,_): return;
  default: throw BadAbsexp;
  }
}
static void ok_member_arg(absop_t ao) {
  switch(ao) { 
  case &LocalOp(_):    
  case &MemberOp(_,_): 
  case &MallocOp(_,_): 
  case &DerefOp(_):    return;
  default: throw BadAbsexp;
  }
}
static void ok_deref_arg(absop_t ao) {
  switch (ao) {
  case &LocalOp(_):    
  case &MemberOp(_,_): 
  case &DerefOp(_):    return;
  default: throw BadAbsexp;
  }
}
static void ok_lvalue(absop_t ao) {
  switch(ao) {
  case UnknownOp:     // should use UseAE, not AssignAE(UnknownOp,_)
  case &AddressOp(_): throw BadAbsexp;
  default: return;
  }
}

// Note: exceessive to grow this dict for the file rather than for a function.
// FIX: use exp loc not, unique ints (good for error messages)
static int num_mallocpts = 0;
static dict_t<exp_t,int> * mallocpt_dict = NULL;
int mallocpt_int(exp_t e) {
  if(mallocpt_dict == NULL) {
    dict_t<exp_t,int> d = Dict::empty(Core::ptrcmp);
    mallocpt_dict = new{d};
  }
  int i = 0;
  if(!Dict::lookup_bool(*mallocpt_dict,e,&i))
    *mallocpt_dict = Dict::insert(*mallocpt_dict,e,i=++num_mallocpts);
  return i;
}

// These constructors must preserve the absop invariants, assuming their
// parameters obey the invariants.  (Ah, strong abstractions.)
absop_t mkUnknownOp() {
  return UnknownOp;
}
absop_t mkAddressOp(absop_t ao) {
  ok_address_arg(ao);
  return new AddressOp(ao);
}
absop_t mkLocalOp(vardecl_t vd) {
  return new LocalOp(vd);
}
absop_t mkMemberOp(absop_t ao, field_name_t f) {
  ok_member_arg(ao);
  return new MemberOp(ao,f);
}
absop_t mkMallocOp(exp_t e) {
  return new MallocOp(e,mallocpt_int(e));
}
absop_t mkDerefOp(absop_t ao) {
  ok_deref_arg(ao);
  return new DerefOp(ao);
}

absexp_t mkBottomAE() {
  return BottomAE;
}
absexp_t mkSkipAE() { 
  return SkipAE;
}
// Note: should not be called twice with the same e
absexp_t mkMallocAE(exp_t e) {
  return new MallocAE(new MallocPt(e),mallocpt_int(e));
}
absexp_t mkStmtAE(stmt_t s) {
  return new StmtAE(s);
}
absexp_t mkUseAE(absop_t ao) {
  switch(ao) {
  case UnknownOp: return SkipAE;
  default:        return new UseAE(ao);
  }
}
absexp_t mkAssignAE(absop_t l, absop_t r) {
  switch($(l,r)) {
  case $(UnknownOp,UnknownOp): return SkipAE;
  case $(UnknownOp,_):         return mkUseAE(r);
  default: 
    ok_lvalue(l);       
    return new AssignAE(l,r);
  }
}

// Note: All the cases are just unnecessary optimizations -- speeds up analysis
// Note: Here are more optimizations we could add:
// * When creating Unordered, can remove repeats (including from
//     nested Unordered)
// * When creating Ordered, can remove adjacent repeats (and swap
//     adjacent UseAE to get more adjacent repeats)
absexp_t mkGroupAE(absexpgroup_t g, absexp_t ae1, absexp_t ae2) { 
 switch ($(g,ae1,ae2)) {
  case $(_,_,SkipAE) && g != OneofG: return ae1;
  case $(_,SkipAE,_) && g != OneofG: return ae2;
  case $(OneofG,_,BottomAE):         return ae1;
  case $(OneofG,BottomAE,_):         return ae2;
  case $(OrderedG,BottomAE,_):       return BottomAE;
  case $(g,&GroupAE(g1,l1),&GroupAE(g2,l2)) && g == g1 && g == g2:
    return new GroupAE(g, List::append(l1,l2));
  case $(g,&GroupAE(g1,l1),_) && g == g1 && g != OrderedG:
    return new GroupAE(g, new{List::List(ae2,l1)});
  case $(OrderedG,&GroupAE(OrderedG,l1),_):
    return new GroupAE(OrderedG, List::append(l1, new List::List(ae2,NULL)));
  case $(g,_,&GroupAE(g2,l2)) && g == g2:
    return new GroupAE(g, new List::List(ae1,l2));
  default:
    return new GroupAE(g, new List::List(ae1, new List::List(ae2,NULL)));
  }
}
absexp_t mkGroupAE_l(absexpgroup_t g, list_t<absexp_t,`H> ael) {
  // Note: Maybe should optimize more here?
  if(ael == NULL) // g really shouldn't be OneofG in this case??
    return SkipAE;
  if(ael->tl == NULL)
    return ael->hd;
  return new GroupAE(g, ael);
}

bool isUnknownOp(absop_t ao) {
  return ao == UnknownOp;
}

///////////////////////// Printing and Debugging //////////////////////////////
string_t absop2string(absop_t ao) {
  switch(ao) {
  case UnknownOp:        return "Unknown";
  case &AddressOp(ao2):  return aprintf("& %s",absop2string(ao2));
  case &LocalOp(vd):     return *(*vd->name)[1];
  case &MemberOp(ao2,f): return aprintf("%s.%s",absop2string(ao2),*f);
  case &MallocOp(e,i):   return aprintf("<mpt%d>",i); 
  case &DerefOp(ao2):    return aprintf("(*%s)", absop2string(ao2));
  }
}
string_t absexp2string(absexp_t ae, int depth) {
  mstring_t ans = Core::new_string(depth);
  for(int i=0; i < ans.size; ++i)
    ans[i] = ' ';
  switch(ae) {
  case SkipAE:    ans = aprintf("%sskip",ans); break;
  case &UseAE(r): ans = aprintf("%suse %s",ans,absop2string(r)); break;
  case &MallocAE(&MallocPt(e),i): ans = aprintf("%smalloc %i",ans,i); break;
  case &AssignAE(l,r): ans = aprintf("%sassign %s %s",ans,
				     absop2string(l), absop2string(r)); break;
  case &GroupAE(g,l):
    switch(g) {
    case OrderedG:   ans = aprintf("%sordered",ans);   break;
    case UnorderedG: ans = aprintf("%sunordered",ans); break;
    case OneofG:     ans = aprintf("%soneof",ans);     break;
    }
    for(; l != NULL; l = l->tl)
      ans = aprintf("%s\n%s",ans,absexp2string(l->hd, depth+1));
    break;
    
  case &StmtAE(s): ans = aprintf("%s<<stmt>>",ans); break;
  case BottomAE:   ans = aprintf("%sbottom",  ans); break;
  default: throw BadAbsexp;
  }
  return ans;
}
// recurses rather than assume smaller ops and exps are okay
static void check_absop(absop_t ao) {
  switch(ao) {
  case UnknownOp:        return;
  case &AddressOp(ao2):  check_absop(ao2); ok_address_arg(ao2); return;
  case &DerefOp(ao2):    check_absop(ao2); ok_deref_arg(ao2);   return;
  case &MemberOp(ao2,_): check_absop(ao2); ok_member_arg(ao2);  return;
  case &LocalOp(_):      return;
  case &MallocOp(_,_):   return;
  }
}
void check_absexp(absexp_t ae) {
  switch(ae) {
  case BottomAE:
  case SkipAE:  return;
  case &MallocAE(&VarRoot(_),_): throw BadAbsexp;
  case &MallocAE(_,_):
  case &StmtAE(_): return;
  case &GroupAE(_,l):  
    for(; l != NULL; l = l->tl) 
      check_absexp(l->hd); 
    return;
  case &UseAE(ao): check_absop(ao); return;
  case &AssignAE(aol,aor):
    check_absop(aol);
    check_absop(aor);
    ok_lvalue(aol);
    return;
  }
}

/////////////////////////// Abstract Evaluation ///////////////////////////

// An Unknown means an assignment must be totally init (for alias reasons!)
// And for AddressOf, the result is AllIL if totally init, ThisIL otherwise.

// To do: avoid doing so much allocation.
// FIX: Cannot descend through uninitialized -- it's an error that must
//      be reported!
path_info_t eval_absop_r(pinfo_dict_t<local_root_t> pinfo_dict, absop_t ao);
init_state_t eval_absop_l(pinfo_dict_t<local_root_t> pinfo_dict, absop_t ao) {
  switch(ao) {
  case &LocalOp(vd):   
    return InitState(Unesc, new MustPointTo(new Place(new VarRoot(vd),NULL)));
  case &MallocOp(e,_): 
    return InitState(Unesc, new MustPointTo(new Place(new MallocPt(e),NULL)));
  case &MemberOp(ao2,n):
    let inner_state = eval_absop_l(pinfo_dict,ao2); 
    switch(inner_state) {
    case InitState(_,&MustPointTo(&Place(root,field_list))): 
      // too much allocation!!!
      field_list = append(field_list, new List(n,NULL));
      return InitState(Unesc, new MustPointTo(new Place(root, field_list)));
    case InitState(_,_): return inner_state;
    }
  case &DerefOp(ao2): 
    let inner_pinfo = eval_absop_r(pinfo_dict,ao2);
    switch(inner_pinfo) {
    case &LeafPI(x): return x;
    case &DictPI(_): throw BadAbsexp; // you cannot apply * to a record
    }
  case UnknownOp: 
  case &AddressOp(_): throw BadAbsexp;
  }
}
path_info_t eval_absop_r(pinfo_dict_t<local_root_t> pinfo_dict, absop_t ao) {
  switch(ao) {
  case &LocalOp(vd):   return Dict::lookup(pinfo_dict, new VarRoot(vd));
  case &MallocOp(e,_): return Dict::lookup(pinfo_dict, new MallocPt(e));
  case &MemberOp(ao2,fname):
    let inner_pinfo = eval_absop_r(pinfo_dict,ao2);
    switch(inner_pinfo) {
    case &LeafPI(_): return inner_pinfo; // eg. a function call
    case &DictPI(d): return Dict::lookup(d, fname);
    }
  case &DerefOp(ao2):
    let inner_pinfo = eval_absop_r(pinfo_dict,ao2);
    switch(inner_pinfo) {
    case &LeafPI(InitState(_,ThisIL)): return mkLeafPI(Esc,NoneIL);//Esc right?
    case &LeafPI(InitState(_,&MustPointTo(p))):
      return lookup_place(pinfo_dict,p);
    case &LeafPI(InitState(_,_)): return inner_pinfo;
    default: throw BadAbsexp;
    }
  case UnknownOp: return mkLeafPI(Esc,AllIL);
  case &AddressOp(ao2): return new LeafPI(eval_absop_l(pinfo_dict,ao2));
  }
}

path_info_t assign_escape(List::list_t<path_info_t,`H>@`r escaping_states,
			  path_info_t old_pinfo, path_info_t new_pinfo);

Dict::dict_t<`a,path_info_t> 
assign_escape_f(List::list_t<path_info_t,`H>@`r escaping_states, `a key,
		path_info_t b1, path_info_t b2, 
		Dict::dict_t<`a,path_info_t,`H> accum) {
  return Dict::insert(accum, key, assign_escape(escaping_states, b1, b2));
}

path_info_t assign_escape(List::list_t<path_info_t,`H>@`r escaping_states,
			  path_info_t old_pinfo, path_info_t new_pinfo) {
  switch ($(old_pinfo,new_pinfo)) {
  case $(&LeafPI(InitState(Unesc,_)), &LeafPI(InitState(_,level))):
    return mkLeafPI(Unesc,level);
  case $(&LeafPI(InitState(Esc,_)),   &LeafPI(_)):
    *escaping_states = new List(new_pinfo, *escaping_states);
    // may as well make All -- it will be an error if it's not
    return mkLeafPI(Esc,AllIL);
  case $(&DictPI(d1), &DictPI(d2)):
    return new DictPI(Dict::fold2_c(assign_escape_f, escaping_states, d1, d2,
				    Dict::empty(Std::zstrptrcmp)));
  default: throw new Core::Impossible("bad pinfos in assign_escape");
  }
}

// Note: It is CRUCIAL to get exn handling right that the Use and Assign
//       cases update tryflow.  Malloc needn't update only b/c tryflow
//       cannot possibly have the malloc op in its domain.
flow_info_t eval_absexp(analenv_t env, seg_t loc,
			absexp_t ae, flow_info_t in_flow) {
  //  printf("%s\n\n", absexp2string(ae,0));
  pinfo_dict_t<local_root_t> pinfo_dict;
  switch(in_flow) {
  case BottomFL:    return BottomFL;
  case &InitsFL(d): pinfo_dict = d; break;
  }
  switch(ae) {

    // To do: try to avoid unncessary allocation in AssignAE
  case &AssignAE(aol,aor):
    switch(eval_absop_l(pinfo_dict, aol)) {
    case InitState(_,&MustPointTo(place)):
      // WARNING: place better be in the dict (in scope)
      //   which is why we have kludges for Comprehension_e
      let old_pinfo = lookup_place(pinfo_dict, place);
      let r_pinfo   = eval_absop_r(pinfo_dict, aor);
      switch($(old_pinfo,r_pinfo)) {
      case $(&DictPI(_), &LeafPI(InitState(_,level))):
	switch(level) {
	case &MustPointTo(_): break; // possible???
	default: r_pinfo  = assign_unknown_dict(level, old_pinfo); break;
	}
	break;
      default: break;
      }
      if(env->all_changed != NULL) {
	//	printf("!");
	*env->all_changed = Set::insert(*env->all_changed, place);
      }
      let escaping_pinfos = NULL;
      let new_pinfo = assign_escape(&escaping_pinfos, old_pinfo, r_pinfo);
      for(; escaping_pinfos != NULL; escaping_pinfos = escaping_pinfos->tl) {
	let esc_pinfo = escaping_pinfos->hd;
	if(!isAllInit(pinfo_dict, esc_pinfo)) {
	  Tcutil::terr(loc,"uninitialized value assigned to escaped place");
	  return BottomFL; // attempt to avoid cascaded messages
	}
	pinfo_dict = escape_pointsto(esc_pinfo, pinfo_dict, env->all_changed);
      }
      pinfo_dict = insert_place(pinfo_dict, place, new_pinfo);
      let ans_flow = new InitsFL(pinfo_dict);
      update_tryflow(env,ans_flow);
      return ans_flow;
    default: break;
    }	
    fallthru(aor); // this should be correct for all Unknown variants (??)

  case &UseAE(ao): 
    let pinfo = eval_absop_r(pinfo_dict, ao);
    if(!isAllInit(pinfo_dict, pinfo))
      // only warn for bits (currently necessary for using unions), if only
      // warn, must not return BottomFL.
      // FIX: NOT good enough: we must warn when all reachable uninit things are
      //  bits_only
      switch (ao) {
      case &LocalOp(vd): 
	if(Tcutil::bits_only(vd->type)) {
	  Tcutil::warn(loc, "pointer-free %s may not be fully initialized", 
                       *(*vd->name)[1]);
	  break;
	}
	fallthru;
      default:
	Tcutil::terr(loc, "%s must be fully initialized to be used here", 
                     absop2string(ao));
	return BottomFL; // attempt to avoid cascaded messages
      }

    let out_dict = escape_pointsto(pinfo, pinfo_dict, env->all_changed);
    if(out_dict == pinfo_dict) return in_flow;
    let ans_flow = new InitsFL(pinfo_dict);
    update_tryflow(env,ans_flow);
    return ans_flow;

  case &MallocAE(root,_): 
    // Don't bother with the "already all uninit" since it's unlikely.
    // (Warning: if you disagree, be careful: root might not be in pinfo_dict!)
    // To do: avoid the repeated allocation.
    return new InitsFL(Dict::insert(pinfo_dict, root,
				    Dict::lookup(env->roots,root)));

  case BottomAE: return BottomFL;
  case SkipAE:   return in_flow;

  case &StmtAE(s): return cf_analyze_stmt(env,s,in_flow);

  case &GroupAE(OrderedG,ael):
    for(; ael != NULL; ael = ael->tl)
      in_flow = eval_absexp(env,loc,ael->hd,in_flow);
    return in_flow;
  case &GroupAE(OneofG,ael):
    flow_info_t out_flow = BottomFL; 
    for(; ael != NULL; ael = ael->tl)
      out_flow = join_flow(env->all_changed, out_flow, 
			   eval_absexp(env,loc,ael->hd,in_flow));
    return out_flow;
  case &GroupAE(UnorderedG,ael): 
    // FIX: cut down on allocations (reuse env->all_changed space)
    if(ael == NULL)
      return in_flow;
    let outer_all_changed = env->all_changed;
    place_set_t this_all_changed; // keep separate b/c we iterate
    flow_info_t old_in_flow;
    flow_info_t out_flow;
    do {
      //      printf(" ");
      this_all_changed = mt_place_set();
      // wouldn't need to peel off the head if we had a TopFL
      env->all_changed = new mt_place_set();
      out_flow = eval_absexp(env,loc,ael->hd,in_flow);
      this_all_changed = Set::union_two(this_all_changed, *env->all_changed);

      for(_ ael2 = ael->tl; ael2 != NULL; ael2 = ael2->tl) {
	env->all_changed = new mt_place_set();
	let next_flow = eval_absexp(env,loc,ael2->hd,in_flow);
	out_flow = after_flow(&this_all_changed,
			      out_flow, next_flow, 
			      this_all_changed, *env->all_changed);
	this_all_changed = Set::union_two(this_all_changed, *env->all_changed);
      }
      // need to check for less than after the join b/c of the approximation
      // else may not terminate.
      old_in_flow = in_flow;
      in_flow = join_flow(outer_all_changed,in_flow,out_flow);
    } while(!flow_lessthan_approx(in_flow,old_in_flow));
    if(outer_all_changed == NULL)
      env->all_changed = NULL;
    else
      env->all_changed = new Set::union_two(*outer_all_changed, 
					    this_all_changed);
    return out_flow;
  }
}
