
// The creation and manipulation of "abstract expressions" for
// control-flow checking.  The primary reason to put this in its own
// module is that we wish to enforce the following grammar without a
// lot of nested enums for abstract operands that just have to get
// annoyingly traversed.  So the exported constructor functions do the
// necessary checks.
// By using this restricted grammar, we essentially normalize assignments
// in such a way that computing an expression's transfer is easy.
// (As opposed to having to deal with x = *&*&*&y; and crap.)  The abstraction
// of expressions has to deal with this.

// absexp ::= Skip | Use(rvalue) | Malloc(exp) | Assign(lvalue,rvalue)
//          | Group(absexpgroup,list_t<absexp>) | Stmt(stmt) | Bottom
// absexpgroup ::= Ordered | Unordered | Oneof
// rvalue ::= & addressable | lvalue
// lvalue ::= noaddress | Unknown 
//   (note: Include malloc b/c *(malloc(int)) = 7 is legit although stupid)
// addressable ::= x | malloc_op(exp) | noaddress.f
// noaddress ::= addressable | *noaddress

// Another invariant is that "top-level" absops cannot have struct or tuple
// types.  Instead, the constructors expand out any uses are assignments
// to the leaves.  That is, top-level absops must be "leaves" in the
// aggregate sense.  It is up to the translation to pass us the right type
// to make this happen.

#include "core.h"
#include "list.h"
#include "dict.h"
#include "tcutil.h"
#include "absyn.h"
#include "cf_flowinfo.h"
#include "new_control_flow.h"
#include "cf_absexp.h"
using Absyn;
using List;
using CfFlowInfo;
using NewControlFlow;
namespace CfAbsexp;

xenum exn {BadAbsexp};

typedef vardecl             vardecl_t;
typedef Dict::dict_t<`a,`b> dict_t<`a,`b>;
typedef Position::seg_t     seg_t;

enum Absexpgroup { OrderedG; UnorderedG; OneofG };

abstract enum Absexp {
  BottomAE;
  SkipAE;
  UseAE(absop_t); 
  AssignAE(absop_t,absop_t); // first operand must be an lvalue
  MallocAE(exp,int); // int is unique id (for debugging)
  StmtAE(stmt);
  GroupAE(absexpgroup_t,list_t<absexp_t>);
};
// Notice Unknown and Address can only occur at "toplevel"
// Notice you cannot take Address of Deref (But can do &((*x).f))
// Note: lvalues are anything except AddressOp and UnknownOp (for the latter
//       we have the special-case UseAE)
// Note: Malloc means "the memory" not "the pointer to the memory"
abstract enum Absop {
  UnknownOp;           
  AddressOp(absop_t);        // op must be Local, Member, or Malloc
  DerefOp(absop_t);          // op must be Local, Member, or Deref
  MemberOp(absop_t,field_t); // op must be Local, Member, Malloc, or Deref
  LocalOp(vardecl_t);       
  MallocOp(exp,int); // int is unique id (for debugging)
};

// for enforcing the invariants stated above
// note: we know nothing about an op's type in this module, but the flow
//       analysis uses types to track the right fields.
static void ok_address_arg(absop_t ao) {
  switch(ao) {
  case LocalOp(_):    return;
  case MemberOp(_,_): return;
  case MallocOp(_,_): return;
  default: throw BadAbsexp;
  }
}
static void ok_member_arg(absop_t ao) {
  switch(ao) { 
  case LocalOp(_):    return;
  case MemberOp(_,_): return;
  case MallocOp(_,_): return;
  case DerefOp(_):    return;
  default: throw BadAbsexp;
  }
}
static void ok_deref_arg(absop_t ao) {
  switch (ao) {
  case LocalOp(_):    return;
  case MemberOp(_,_): return;
  case DerefOp(_):    return;
  default: throw BadAbsexp;
  }
}
static void ok_lvalue(absop_t ao) {
  switch(ao) {
  case UnknownOp:    fallthru; // should use UseAE, not AssignAE(UnknownOp,_)
  case AddressOp(_): throw BadAbsexp;
  default: return;
  }
}

// Note: exceessive to grow this dict for the file rather than for a function.
static int num_mallocpts = 0;
static dict_t<exp,int> * mallocpt_dict = null;
int mallocpt_int(exp e) {
  if(mallocpt_dict == null)
    mallocpt_dict = new{Dict::empty(Core::ptrcmp)};
  int i = 0;
  if(!Dict::lookup_bool(*mallocpt_dict,e,&i))
    *mallocpt_dict = Dict::insert(*mallocpt_dict,e,i=++num_mallocpts);
  return i;
}

// These constructors must preserve the absop invariants, assuming their
// parameters obey the invariants.  (Ah, strong abstractions.)
absop_t mkUnknownOp() {
  return UnknownOp;
}
absop_t mkAddressOp(absop_t ao) {
  ok_address_arg(ao);
  return AddressOp(ao);
}
absop_t mkLocalOp(vardecl_t vd) {
  return LocalOp(vd);
}
absop_t mkMemberOp(absop_t ao, field_t f) {
  ok_member_arg(ao);
  return MemberOp(ao,f);
}
absop_t mkMallocOp(exp e) {
  return MallocOp(e,mallocpt_int(e));
}
absop_t mkDerefOp(absop_t ao) {
  ok_deref_arg(ao);
  return DerefOp(ao);
}

absexp_t mkBottomAE() {
  return BottomAE;
}
absexp_t mkSkipAE() { 
  return SkipAE;
}
absexp_t mkMallocAE(exp e) {
  return MallocAE(e,mallocpt_int(e));
}
absexp_t mkStmtAE(stmt s) {
  return StmtAE(s);
}
absexp_t mkUseAE(absop_t ao) {
  switch(ao) {
  case UnknownOp: return SkipAE;
  default:        return UseAE(ao);
  }
}
absexp_t mkAssignAE(absop_t l, absop_t r) {
  switch($(l,r)) {
  case $(UnknownOp,UnknownOp): return SkipAE;
  case $(UnknownOp,_):         return mkUseAE(r);
  default: 
    ok_lvalue(l);       
    return AssignAE(l,r);
  }
}

// Note: All the cases are just unnecessary optimizations -- speeds up analysis
// Note: Here are more optimizations we could add:
// * When creating Unordered, can remove repeats (including from
//     nested Unordered)
// * When creating Ordered, can remove adjacent repeats (and swap
//     adjacent UseAE to get more adjacent repeats)
absexp_t mkGroupAE(absexpgroup_t g, absexp_t ae1, absexp_t ae2) { 
 switch ($(g,ae1,ae2)) {
  case $(_,_,SkipAE) && g != OneofG: return ae1;
  case $(_,SkipAE,_) && g != OneofG: return ae2;
  case $(OneofG,_,BottomAE):         return ae1;
  case $(OneofG,BottomAE,_):         return ae2;
  case $(OrderedG,BottomAE,_):       return BottomAE;
  case $(g,GroupAE(g1,l1),GroupAE(g2,l2)) && g == g1 && g == g2:
    return GroupAE(g, List::append(l1,l2));
  case $(g,GroupAE(g1,l1),_) && g == g1 && g != OrderedG:
    return GroupAE(g, new{List::List(ae2,l1)});
  case $(OrderedG,GroupAE(OrderedG,l1),_):
    return GroupAE(OrderedG, List::append(l1, new{List::List(ae2,null)}));
  case $(g,_,GroupAE(g2,l2)) && g == g2:
    return GroupAE(g, new {List::List(ae1,l2)});
  default:
    return GroupAE(g, new {List::List(ae1, new {List::List(ae2,null)})});
  }
}
absexp_t mkGroupAE_l(absexpgroup_t g, list_t<absexp_t> ael) {
  // Note: Maybe should optimize more here?
  if(ael == null) // g really shouldn't be OneofG in this case??
    return SkipAE;
  if(ael->tl == null)
    return ael->hd;
  return GroupAE(g, ael);
}

bool isUnknownOp(absop_t ao) {
  return ao == UnknownOp;
}

/////////////////////////// Abstract Evaluation ///////////////////////////
// Note: should have versions that takes state_dict b/c of recursive calls??
// Note: eval_absop_l never returns ThisInit or Uninit???????
// DO ME!!!!!!
init_state_t eval_absop_l(seg_t loc, absop_t ao, flow_info_t flow) {
  return Uninit;
}
init_state_t eval_absop_r(seg_t loc, absop_t ao, flow_info_t flow) {
  return Uninit;
}
// DO ME!!!!!!
flow_info_t eval_absexp(seg_t loc, absexp_t ae, flow_info_t in_flow) {
  switch(ae) {
  case UseAE(ao): 
    let state = eval_absop_r(loc,ao,in_flow);
    // must check for all init (detecting cycles -- do it in CfFlowInfo)
    // must "nuke downstream"
    return in_flow;
  case AssignAE(aol,aor): 
    // DO ME: if aol is not MustPointTo(p), must "nuke downstream"
    throw Core::Impossible("");
  case MallocAE(e,_):     
    // DO ME: need to do nuke anything that points to part of MallocPt(e)
    //   That's what the backward-pointer dictionary is for!
    // Then have to make all the fields Uninit.
    throw Core::Impossible("");

    // The rest of the cases are done but untested.
  case BottomAE:  return BottomFL;
  case SkipAE:    return in_flow;

  case StmtAE(s): return cf_analyze_stmt(s,in_flow);

  case GroupAE(OrderedG,ael):
    for(; ael != null; ael = ael->tl)
      in_flow = eval_absexp(loc,ael->hd,in_flow);
    return in_flow;

  case GroupAE(OneofG,ael):
    let out_flow = BottomFL; 
    for(; ael != null; ael = ael->tl)
      out_flow = join_flow(out_flow, eval_absexp(loc, ael->hd, in_flow));
    return out_flow;

  case GroupAE(UnorderedG,ael): // local iteration until we reach a fixpoint
    _ out_flow;
    do {
      out_flow = in_flow;
      for(; ael != null; ael = ael->tl)
	out_flow = join_flow(out_flow, eval_absexp(loc, ael->hd, out_flow));
    } while(out_flow != in_flow);
    return out_flow;
  }
}

///////////////////////// Printing and Debugging //////////////////////////////
string absop2string(absop_t ao) {
  switch(ao) {
  case UnknownOp:      return "Unknown";
  case AddressOp(ao2): return xprintf("& %s",absop2string(ao2));
  case LocalOp(vd):    return *(*vd->name)[1];
  case MemberOp(ao2,f):
    string fs;
    switch(f) {
    case StructF(field): fs = *field; break;
    case TupleF(i):      fs = xprintf("%d",i); break;
    }
    return xprintf("%s.%s",absop2string(ao2),fs);
  case MallocOp(e,i): return xprintf("<mpt%d>",i); 
  case DerefOp(ao2):  return xprintf("(*%s)", absop2string(ao2));
  }
}
string absexp2string(absexp_t ae, int depth) {
  string ans = Core::new_string(depth);
  for(int i=0; i < ans.size; ++i)
    ans[i] = ' ';
  switch(ae) {
  case SkipAE:        ans = xprintf("%sskip",ans); break;
  case UseAE(r):      ans = xprintf("%suse %s",ans,absop2string(r)); break;
  case MallocAE(e,i): ans = xprintf("%smalloc %i",ans,i); break;
  case AssignAE(l,r): ans = xprintf("%sassign %s %s",ans,
				    absop2string(l), absop2string(r)); break;
  case GroupAE(g,l):
    switch(g) {
    case OrderedG:   ans = xprintf("%sordered",ans);   break;
    case UnorderedG: ans = xprintf("%sunordered",ans); break;
    case OneofG:     ans = xprintf("%soneof",ans);     break;
    }
    for(; l != null; l = l->tl)
      ans = xprintf("%s\n%s",ans,absexp2string(l->hd, depth+1));
    break;
    
  case StmtAE(s): ans = xprintf("%s<<stmt>>",ans); break;
  case BottomAE:  ans = xprintf("%sbottom",  ans); break;
  }
  return ans;
}
// recurses rather than assume smaller ops and exps are okay
static void check_absop(absop_t ao) {
  switch(ao) {
  case UnknownOp:       return;
  case AddressOp(ao2):  check_absop(ao2); ok_address_arg(ao2); return;
  case DerefOp(ao2):    check_absop(ao2); ok_deref_arg(ao2);   return;
  case MemberOp(ao2,_): check_absop(ao2); ok_member_arg(ao2);  return;
  case LocalOp(_):      return;
  case MallocOp(_,_):   return;
  }
}
void check_absexp(absexp_t ae) {
  switch(ae) {
  case BottomAE:      return;
  case SkipAE:        return;
  case MallocAE(_,_): return;
  case StmtAE(s):     return;
  case GroupAE(_,l):  
    for(; l != null; l = l->tl) 
      check_absexp(l->hd); 
    return;
  case UseAE(ao):     check_absop(ao); return;
  case AssignAE(aol,aor):
    check_absop(aol);
    check_absop(aor);
    ok_lvalue(aol);
    return;
  }
}
