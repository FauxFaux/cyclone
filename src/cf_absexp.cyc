
// The creation and manipulation of "abstract expressions" for
// control-flow checking.  The primary reason to put this in its own
// module is that we wish to enforce the following grammar without a
// lot of nested enums for abstract operands that just have to get
// annoyingly traversed.  So the exported constructor functions do the
// necessary checks.
// By using this restricted grammar, we essentially normalize assignments
// in such a way that computing an expression's transfer is easy.
// (As opposed to having to deal with x = *&*&*&y; and crap.)  The abstraction
// of expressions has to deal with this.

// absexp ::= Skip | Use(rvalue) | Malloc(exp) | Assign(lvalue,rvalue)
//          | Group(absexpgroup,list_t<absexp>) | Stmt(stmt) | Bottom
// absexpgroup ::= Ordered | Unordered | Oneof
// rvalue ::= & addressable | lvalue
// lvalue ::= noaddress | Unknown 
//   (note: Include malloc b/c *(malloc(int)) = 7 is legit although stupid)
// addressable ::= x | malloc_op(exp) | noaddress.f
// noaddress ::= addressable | *noaddress

// Another invariant is that "top-level" absops cannot have struct or tuple
// types.  Instead, the constructors expand out any uses are assignments
// to the leaves.  That is, top-level absops must be "leaves" in the
// aggregate sense.  It is up to the translation to pass us the right type
// to make this happen.

// for debugging
#include <stdio.h>

#include <core.h>
#include <list.h>
#include <string.h>
#include <dict.h>
#include "tcutil.h"
#include "absyn.h"
#include "cf_flowinfo.h"
#include "new_control_flow.h"
#include "cf_absexp.h"
using Absyn;
using List;
using CfFlowInfo;
using NewControlFlow;
namespace CfAbsexp;

xtunion exn {BadAbsexp};

typedef Dict::dict_t<`a,`b> dict_t<`a,`b>;
typedef Position::seg_t     seg_t;

tunion Absexpgroup { 
  OrderedG;   //all get executed in left-to-right order
  UnorderedG; //could be any order, analysis more conservative than permutations
  OneofG;     //exactly one option gets executed
};

// see comments in .h file
absexpgroup_t mkAnyOrderG() {
  return OrderedG;
}

abstract tunion Absexp {
  BottomAE;
  SkipAE;
  UseAE(absop_t); 
  AssignAE(absop_t,absop_t); // first operand must be an lvalue
  MallocAE(local_root_t,int); // int is unique id (for debugging)
  StmtAE(stmt_t);
  GroupAE(absexpgroup_t,list_t<absexp_t>);
};
// Notice Unknown and Address can only occur at "toplevel"
// Notice you cannot take Address of Deref (But can do &((*x).f))
// Note: lvalues are anything except AddressOp and UnknownOp (for the latter
//       we have the special-case UseAE)
// Note: Malloc means "the memory" not "the pointer to the memory"
abstract tunion Absop {
  UnknownOp;           
  AddressOp(absop_t);        // op must be Local, Member, or Malloc
  DerefOp(absop_t);          // op must be Local, Member, or Deref
  MemberOp(absop_t,field_t); // op must be Local, Member, Malloc, or Deref
  LocalOp(vardecl_t);       
  MallocOp(exp_t,int); // int is unique id (for debugging)
};

// for enforcing the invariants stated above
// note: we know nothing about an op's type in this module, but the flow
//       analysis uses types to track the right fields.
static void ok_address_arg(absop_t ao) {
  switch(ao) {
  case &LocalOp(_):    return;
  case &MemberOp(_,_): return;
  case &MallocOp(_,_): return;
  default: throw BadAbsexp;
  }
}
static void ok_member_arg(absop_t ao) {
  switch(ao) { 
  case &LocalOp(_):    return;
  case &MemberOp(_,_): return;
  case &MallocOp(_,_): return;
  case &DerefOp(_):    return;
  default: throw BadAbsexp;
  }
}
static void ok_deref_arg(absop_t ao) {
  switch (ao) {
  case &LocalOp(_):    return;
  case &MemberOp(_,_): return;
  case &DerefOp(_):    return;
  default: throw BadAbsexp;
  }
}
static void ok_lvalue(absop_t ao) {
  switch(ao) {
  case UnknownOp:    fallthru; // should use UseAE, not AssignAE(UnknownOp,_)
  case &AddressOp(_): throw BadAbsexp;
  default: return;
  }
}

// Note: exceessive to grow this dict for the file rather than for a function.
// FIX: use exp loc not, unique ints (good for error messages)
static int num_mallocpts = 0;
static dict_t<exp_t,int> * mallocpt_dict = null;
int mallocpt_int(exp_t e) {
  if(mallocpt_dict == null) {
    dict_t<exp_t,int> d = Dict::empty(Core::ptrcmp);
    mallocpt_dict = new{d};
  }
  int i = 0;
  if(!Dict::lookup_bool(*mallocpt_dict,e,&i))
    *mallocpt_dict = Dict::insert(*mallocpt_dict,e,i=++num_mallocpts);
  return i;
}

// These constructors must preserve the absop invariants, assuming their
// parameters obey the invariants.  (Ah, strong abstractions.)
absop_t mkUnknownOp() {
  return UnknownOp;
}
absop_t mkAddressOp(absop_t ao) {
  ok_address_arg(ao);
  return new AddressOp(ao);
}
absop_t mkLocalOp(vardecl_t vd) {
  return new LocalOp(vd);
}
absop_t mkMemberOp(absop_t ao, field_t f) {
  ok_member_arg(ao);
  return new MemberOp(ao,f);
}
absop_t mkMallocOp(exp_t e) {
  return new MallocOp(e,mallocpt_int(e));
}
absop_t mkDerefOp(absop_t ao) {
  ok_deref_arg(ao);
  return new DerefOp(ao);
}

absexp_t mkBottomAE() {
  return BottomAE;
}
absexp_t mkSkipAE() { 
  return SkipAE;
}
// Note: should not be called twice with the same e
absexp_t mkMallocAE(exp_t e) {
  return new MallocAE(new MallocPt(e),mallocpt_int(e));
}
absexp_t mkStmtAE(stmt_t s) {
  return new StmtAE(s);
}
absexp_t mkUseAE(absop_t ao) {
  switch(ao) {
  case UnknownOp: return SkipAE;
  default:         return new UseAE(ao);
  }
}
absexp_t mkAssignAE(absop_t l, absop_t r) {
  switch($(l,r)) {
  case $(UnknownOp,UnknownOp): return SkipAE;
  case $(UnknownOp,_):         return mkUseAE(r);
  default: 
    ok_lvalue(l);       
    return new AssignAE(l,r);
  }
}

// Note: All the cases are just unnecessary optimizations -- speeds up analysis
// Note: Here are more optimizations we could add:
// * When creating Unordered, can remove repeats (including from
//     nested Unordered)
// * When creating Ordered, can remove adjacent repeats (and swap
//     adjacent UseAE to get more adjacent repeats)
absexp_t mkGroupAE(absexpgroup_t g, absexp_t ae1, absexp_t ae2) { 
 switch ($(g,ae1,ae2)) {
  case $(_,_,SkipAE) && g != (absexpgroup_t)OneofG: return ae1;
  case $(_,SkipAE,_) && g != (absexpgroup_t)OneofG: return ae2;
  case $(OneofG,_,BottomAE):         return ae1;
  case $(OneofG,BottomAE,_):         return ae2;
  case $(OrderedG,BottomAE,_):       return BottomAE;
  case $(g,&GroupAE(g1,l1),&GroupAE(g2,l2)) && g == g1 && g == g2:
    return new GroupAE(g, List::append(l1,l2));
  case $(g,&GroupAE(g1,l1),_) && g == g1 && g != (absexpgroup_t)OrderedG:
    return new GroupAE(g, new{List::List(ae2,l1)});
  case $(OrderedG,&GroupAE(OrderedG,l1),_):
    return new GroupAE(OrderedG, List::append(l1, new{List::List(ae2,null)}));
  case $(g,_,&GroupAE(g2,l2)) && g == g2:
    return new GroupAE(g, new {List::List(ae1,l2)});
  default:
    return new GroupAE(g, new {List::List(ae1, new {List::List(ae2,null)})});
  }
}
absexp_t mkGroupAE_l(absexpgroup_t g, list_t<absexp_t> ael) {
  // Note: Maybe should optimize more here?
  if(ael == null) // g really shouldn't be OneofG in this case??
    return SkipAE;
  if(ael->tl == null)
    return ael->hd;
  return new GroupAE(g, ael);
}

bool isUnknownOp(absop_t ao) {
  return ao == (absop_t)UnknownOp;
}

///////////////////////// Printing and Debugging //////////////////////////////
string_t absop2string(absop_t ao) {
  switch(ao) {
  case UnknownOp:      return "Unknown";
  case &AddressOp(ao2): return xprintf("& %s",absop2string(ao2));
  case &LocalOp(vd):    return *(*vd->name)[1];
  case &MemberOp(ao2,f):
    string_t fs;
    switch(f) {
    case &StructF(field): fs = *field; break;
    case &TupleF(i):      fs = xprintf("%d",i); break;
    }
    return xprintf("%s.%s",absop2string(ao2),fs);
  case &MallocOp(e,i): return xprintf("<mpt%d>",i); 
  case &DerefOp(ao2):  return xprintf("(*%s)", absop2string(ao2));
  }
}
string_t absexp2string(absexp_t ae, int depth) {
  mstring_t ans = Core::new_string(depth);
  for(int i=0; i < ans.size; ++i)
    ans[i] = ' ';
  switch(ae) {
  case SkipAE:        ans = xprintf("%sskip",ans); break;
  case &UseAE(r):      ans = xprintf("%suse %s",ans,absop2string(r)); break;
  case &MallocAE(&MallocPt(e),i): ans = xprintf("%smalloc %i",ans,i); break;
  case &AssignAE(l,r): ans = xprintf("%sassign %s %s",ans,
				    absop2string(l), absop2string(r)); break;
  case &GroupAE(g,l):
    switch(g) {
    case OrderedG:   ans = xprintf("%sordered",ans);   break;
    case UnorderedG: ans = xprintf("%sunordered",ans); break;
    case OneofG:     ans = xprintf("%soneof",ans);     break;
    }
    for(; l != null; l = l->tl)
      ans = xprintf("%s\n%s",ans,absexp2string(l->hd, depth+1));
    break;
    
  case &StmtAE(s): ans = xprintf("%s<<stmt>>",ans); break;
  case BottomAE:  ans = xprintf("%sbottom",  ans); break;
  default: throw BadAbsexp;
  }
  return ans;
}
// recurses rather than assume smaller ops and exps are okay
static void check_absop(absop_t ao) {
  switch(ao) {
  case UnknownOp:       return;
  case &AddressOp(ao2):  check_absop(ao2); ok_address_arg(ao2); return;
  case &DerefOp(ao2):    check_absop(ao2); ok_deref_arg(ao2);   return;
  case &MemberOp(ao2,_): check_absop(ao2); ok_member_arg(ao2);  return;
  case &LocalOp(_):      return;
  case &MallocOp(_,_):   return;
  }
}
void check_absexp(absexp_t ae) {
  switch(ae) {
  case BottomAE:      return;
  case SkipAE:        return;
  case &MallocAE(&VarRoot(_),_): throw BadAbsexp;
  case &MallocAE(_,_): return;
  case &StmtAE(s):     return;
  case &GroupAE(_,l):  
    for(; l != null; l = l->tl) 
      check_absexp(l->hd); 
    return;
  case &UseAE(ao):     check_absop(ao); return;
  case &AssignAE(aol,aor):
    check_absop(aol);
    check_absop(aor);
    ok_lvalue(aol);
    return;
  }
}

/////////////////////////// Abstract Evaluation ///////////////////////////

// An Unknown means an assignment must be totally init (for alias reasons!)
// And for AddressOf, the result is AllIL if totally init, ThisIL otherwise.

// To do: avoid doing so much allocation.
// FIX: Cannot descend through uninitialized -- it's an error that must
//      be reported!
path_info_t eval_absop_r(pinfo_dict_t<local_root_t> pinfo_dict, absop_t ao);
init_state_t eval_absop_l(pinfo_dict_t<local_root_t> pinfo_dict, absop_t ao) {
  switch(ao) {
  case &LocalOp(vd):   
    return new MustPointTo(new Place(new VarRoot(vd),null));
  case &MallocOp(e,_): 
    return new MustPointTo(new Place(new MallocPt(e),null));
  case &MemberOp(ao2,n):
    let inner_state = eval_absop_l(pinfo_dict,ao2); 
    switch(inner_state) {
    case &UnknownIS(_,_): return inner_state;
    case &MustPointTo(&Place(root,field_list)): // too much allocation!!!
      return new MustPointTo(new Place(root, 
				       append(field_list, new List(n,null))));
    }
  case &DerefOp(ao2): 
    let inner_pinfo = eval_absop_r(pinfo_dict,ao2);
    switch(inner_pinfo) {
    case &LeafPI(x):   return x;
    case &TuplePI(_):  fallthru;
    case &StructPI(_): throw BadAbsexp; // you cannot * a tuple or struct
    }
  case UnknownOp: fallthru;
  case &AddressOp(_): throw BadAbsexp;
  }
}
path_info_t eval_absop_r(pinfo_dict_t<local_root_t> pinfo_dict, absop_t ao) {
  switch(ao) {
  case &LocalOp(vd):   return Dict::lookup(pinfo_dict, new VarRoot(vd));
  case &MallocOp(e,_): return Dict::lookup(pinfo_dict, new MallocPt(e));
  case &MemberOp(ao2,f):
    let inner_pinfo = eval_absop_r(pinfo_dict,ao2);
    switch($(inner_pinfo,f)) {
    case $(&LeafPI(&UnknownIS(_,_)), _): return inner_pinfo;
    case $(&TuplePI(d),  &TupleF(i)):    return Dict::lookup(d, i);
    case $(&StructPI(d), &StructF(n)):   return Dict::lookup(d, n);
    default: throw BadAbsexp;
    }
  case &DerefOp(ao2):
    let inner_pinfo = eval_absop_r(pinfo_dict,ao2);
    switch(inner_pinfo) {
    case &LeafPI(&UnknownIS(esc,ThisIL)): return mkLeafPI(Esc,NoneIL);//Esc right?
    case &LeafPI(&UnknownIS(_,_)):     return inner_pinfo;
    case &LeafPI(&MustPointTo(place)): return lookup_place(pinfo_dict, place);
    default: throw BadAbsexp;
    }
  case UnknownOp:      return mkLeafPI(Esc,AllIL);
  case &AddressOp(ao2): return new LeafPI(eval_absop_l(pinfo_dict,ao2));
  }
}

path_info_t assign_escape(List::list_t<path_info_t>@`r escaping_states,
			  path_info_t old_pinfo, path_info_t new_pinfo);

Dict::dict_t<`a,path_info_t> 
assign_escape_f(List::list_t<path_info_t>@`r escaping_states, `a key,
		path_info_t b1, path_info_t b2, 
		Dict::dict_t<`a,path_info_t> accum) {
  return Dict::insert(accum, key, assign_escape(escaping_states, b1, b2));
}

path_info_t assign_escape(List::list_t<path_info_t>@`r escaping_states,
			  path_info_t old_pinfo, path_info_t new_pinfo) {
  switch ($(old_pinfo,new_pinfo)) {
  case $(&LeafPI(&MustPointTo(_)),     &LeafPI(&UnknownIS(_,level))): 
    fallthru(level);
  case $(&LeafPI(&UnknownIS(Unesc,_)), &LeafPI(&UnknownIS(_,level))):
    return mkLeafPI(Unesc,level);
  case $(&LeafPI(&MustPointTo(_)),     &LeafPI(_)):  fallthru;
  case $(&LeafPI(&UnknownIS(Unesc,_)), &LeafPI(_)): // must point to something
    return new_pinfo;
  case $(&LeafPI(&UnknownIS(Esc,_)),   &LeafPI(_)):
    *escaping_states = new List(new_pinfo, *escaping_states);
    // may as well make All -- it will be an error if it's not
    return mkLeafPI(Esc,AllIL);
  case $(&TuplePI(d1),  &TuplePI(d2)):
    return new TuplePI(Dict::fold2_c(assign_escape_f, escaping_states, d1, d2,
				     Dict::empty(Core::intcmp)));
  case $(&StructPI(d1), &StructPI(d2)):
    return new StructPI(Dict::fold2_c(assign_escape_f, escaping_states, d1, d2,
				      Dict::empty(String::zstrptrcmp)));
  default: throw new Core::Impossible("bad pinfos in assign_escape");
  }
}

bool is_ok_malloc_assign(absop_t lval, glist_t<exp_t,`r> ok_mallocs) {
  switch(lval) {
  case &MallocOp(e,_):   return List::memq(ok_mallocs,e);
  case &MemberOp(ao2,_): return is_ok_malloc_assign(ao2,ok_mallocs);
  default: return false;
  }
}

//This function is for the Unordered KLUDGE (see comments at end of eval_absexp)
//Note: descent through Unordered means O(n^2) overall.  Should be unnecessary??
static $(glist_t<absexp_t,`r>, glist_t<exp_t,`r>) 
unordered_mallocs(region_t<`r> rgn, absexp_t ae, glist_t<exp_t,`r> ok_mallocs) {
  let assigns = null;
  let mallocs = null;
  switch (ae) {
  case BottomAE:  break;
  case SkipAE:    break;
  case &UseAE(_):  break;
  case &AssignAE(ao1,ao2):
    if(is_ok_malloc_assign(ao1, ok_mallocs))
      assigns = rnew(rgn) List(ae, assigns);
    break;
  case &MallocAE(&MallocPt(e),_): 
    mallocs = rnew(rgn) List(e, mallocs);
    break;
  case &MallocAE(_,_): 
    throw new Core::Impossible("local variable in MallocAE");
  case &StmtAE(s): break; // conservative
  case &GroupAE(OrderedG, ael):
    for(; ael != null; ael = ael->tl) {
      let $(next_assigns, next_mallocs) =  
	unordered_mallocs(rgn, ael->hd, rappend(rgn, mallocs, ok_mallocs));
      assigns = rappend(rgn, next_assigns, assigns);
      mallocs = rappend(rgn, next_mallocs, mallocs);
    }
    break;
  case &GroupAE(OneofG, ael):
    // FIX: take intersection over mallocs and assigns in all ael
    //      what we have here is sound though
    break;
  case &GroupAE(UnorderedG, ael):
    for(; ael != null; ael = ael->tl) {
      let $(next_assigns, next_mallocs) = 
	unordered_mallocs(rgn, ael->hd, ok_mallocs);
      assigns = rappend(rgn, next_assigns, assigns);
      mallocs = rappend(rgn, next_mallocs, mallocs);
    }
    break;
  }
  return $(assigns,mallocs);
}

// Note: It is CRUCIAL to get exn handling right that the Use and Assign
//       cases update tryflow.  Malloc needn't update only b/c tryflow
//       cannot possibly have the malloc op in its domain.
flow_info_t eval_absexp(analenv_t env, seg_t loc, 
			absexp_t ae, flow_info_t in_flow) {
  //  fprintf(Stdio::stderr, "%s\n", absexp2string(ae,0));
  pinfo_dict_t<local_root_t> pinfo_dict;
  switch(in_flow) {
  case BottomFL:   return BottomFL;
  case &InitsFL(d): pinfo_dict = d; break;
  }
  switch(ae) {

    // To do: try to avoid unncessary allocation in AssignAE
  case &AssignAE(aol,aor):
    switch(eval_absop_l(pinfo_dict, aol)) {
    case &UnknownIS(_,_): break; 
    case &MustPointTo(place):
      // WARNING: place better be in the dict (in scope)
      //   which is why we have kludges for Comprehension_e
      let old_pinfo = lookup_place(pinfo_dict, place);
      let r_pinfo   = eval_absop_r(pinfo_dict, aor);
      switch($(old_pinfo,r_pinfo)) {
      case $(&TuplePI(_),  &LeafPI(&UnknownIS(_,level))): fallthru(level);
      case $(&StructPI(_), &LeafPI(&UnknownIS(_,level))):
	r_pinfo  = assign_unknown_dict(level, old_pinfo);
	break;
      default: break;
      }
      let escaping_pinfos = null;
      let new_pinfo = assign_escape(&escaping_pinfos, old_pinfo, r_pinfo);
      for(; escaping_pinfos != null; escaping_pinfos = escaping_pinfos->tl) {
	let esc_pinfo = escaping_pinfos->hd;
	if(!isAllInit(pinfo_dict, esc_pinfo)) {
	  Tcutil::terr(loc,"uninitialized value assigned to escaped place");
	  return BottomFL; // attempt to avoid cascaded messages
	}
	pinfo_dict = escape_pointsto(esc_pinfo, pinfo_dict);
      }
      pinfo_dict = insert_place(pinfo_dict, place, new_pinfo);
      let ans = new InitsFL(pinfo_dict);
      update_tryflow(env,ans);
      return ans;
    }	
    fallthru(aor); // this should be correct for all Unknown variants (??)

  case &UseAE(ao): 
    let pinfo = eval_absop_r(pinfo_dict, ao);
    if(!isAllInit(pinfo_dict, pinfo))
      // only warn for bits (currently necessary for using unions), if only
      // warn, must not return BottomFL.
      // NOT good enough: we must warn when all reachable uninit things are
      //  bits_only
      switch (ao) {
      case &LocalOp(vd): 
	if(Tcutil::bits_only(vd->type)) {
	  Tcutil::warn(loc, xprintf("pointer-free %s may not be fully "
				    "initialized", *(*vd->name)[1]));
	  break;
	}
	fallthru;
      default:
	Tcutil::terr(loc, xprintf("%s must be fully initialized "
				  "to be used here", absop2string(ao)));
	return BottomFL; // attempt to avoid cascaded messages
      }

    let out_dict = escape_pointsto(pinfo, pinfo_dict);
    if(out_dict == pinfo_dict) return in_flow;
    let ans = new InitsFL(pinfo_dict);

    update_tryflow(env,ans);
    return ans;

  case &MallocAE(root,_): 
    // Don't bother with the "already all uninit" since it's unlikely.
    // (Warning: if you disagree, be careful: root might not be in pinfo_dict!)
    // To do: avoid the repeated allocation.
    return new InitsFL(Dict::insert(pinfo_dict, root,
                                    Dict::lookup(env->roots,root)));

  case BottomAE:  return BottomFL;
  case SkipAE:    return in_flow;

  case &StmtAE(s): return cf_analyze_stmt(env,s,in_flow);

  case &GroupAE(OrderedG,ael):
    for(; ael != null; ael = ael->tl)
      in_flow = eval_absexp(env,loc,ael->hd,in_flow);
    return in_flow;
  case &GroupAE(OneofG,ael):
    flow_info_t out_flow = BottomFL; 
    for(; ael != null; ael = ael->tl)
      out_flow = join_flow(out_flow, eval_absexp(env,loc,ael->hd,in_flow));
    return out_flow;
  case &GroupAE(UnorderedG,ael): 
    _ out_flow = in_flow; 
    // local iteration until we reach a fixpoint
    // notice how we are extremely conservative.  Basically, the aes may
    // happen any number of times in any order.
    // That's too weak for nested malloc-and-init, so as a SOUND KLUDGE,
    // we go back through and notice any mallocs and assignment to malloc 
    // points that definitely occur.  The assignments must be after the 
    // mallocs though.  We don't check that every MallocAE is for a 
    // distinct exp, but this should be true!!
    do {
      in_flow  = out_flow;
      out_flow = in_flow;
      for(_ ael2 = ael; ael2 != null; ael2 = ael2->tl)
	out_flow = join_flow(out_flow, eval_absexp(env,loc,ael2->hd, out_flow));
    } while(!flow_lessthan_approx(out_flow,in_flow));
    pinfo_dict_t<local_root_t> pinfo_dict;
    switch(in_flow) {
    case BottomFL:   return BottomFL;
    case &InitsFL(d): pinfo_dict = d; break;
    }
    // UGLY, UGLY, UGLY
    region spine_rgn {
    let $(assigns,mallocs) = unordered_mallocs(spine_rgn,ae,null);
    for(; mallocs != null; mallocs = mallocs->tl) {
      let malloc_pt = new MallocPt(mallocs->hd); // avoid repeated allocation!
      pinfo_dict = Dict::insert(pinfo_dict, malloc_pt, 
				Dict::lookup(env->roots, malloc_pt));
    }
    out_flow = new InitsFL(pinfo_dict);
    // notice how we do these before the "outer" use/assigns -- good!
    for(; assigns != null; assigns = assigns->tl)
      out_flow = eval_absexp(env,loc,assigns->hd,out_flow);
    }
    return out_flow;
  }
}
