// Type checking for expressions 

/* TODO:
   codegen and fill
   compound literals
   generalized array and struct designators
   unresolvedmem
 */

#include "absyn.h"
#include "string.h"
#include "position.h"
#include "absynpp.h"
#include "tcenv.h"
#include "tcutil.h"
#include "evexp.h"
#include "tcstmt.h"
#include "tcexp.h"

namespace Tcexp;

using Core;
using List;
using Position;
using Absyn;
using Absynpp;
using Tcenv;
using Tcutil;
using Evexp;
using Tcstmt;

// shared error-generating function
static synth expr_err(tenv te,segment loc,string msg) {
  terr(loc,msg);
  return wild_synth(te);
}

extern synth tcExp      (tenv te, Opt_t<typ> topt, exp e);
extern synth tcExpNoInst(tenv te, Opt_t<typ> topt, exp e);

// The qualified identifier q could be a variable, an enum
// constructor, or an xenum constructor.  We resolve q and overwrite
// the expression e with the appropriate r. 
// Note: tcVar takes care of unknown error reporting and binding field updating.
static void resolve_unknown_id(tenv te, exp e, qvar q) {
  switch (lookup_ordinary(te,e->loc,q)) {
  case VarRes(b):        e->r = Var_e(q,b); break;
  case EnumRes(ed,ef):   e->r = Enum_e(ef->name,null,null,null,ed,ef); break;
  case XenumRes(xed,ef): e->r = Xenum_e(ef->name,null,null,xed,ef); break;
  case StructRes(_):
    terr(e->loc,xprintf("bad occurrence of struct name %s",qvar2string(q)));
    e->r = Var_e(q,Unresolved_b);
    break;
  }
}

static $(list<designator>,exp)@ make_struct_arg(exp e) {
  return &$(null,e);
}

// Resolve whether this is a function call or enum, xenum, or struct
// constructor -- let normal type-checking do the rest of the work. 
static void resolve_unknown_fn(tenv te, exp e, exp e1, list<exp> es) {
  switch (e1->r) {
  case UnknownId_e(q):
    switch (lookup_ordinary(te,e1->loc,q)) {
    case VarRes(b): 
      e->r = FnCall_e(e1,es); 
      break;
    case EnumRes(ed,ef):
      if (ed->name != null) {
        e->r = Enum_e(ef->name,null,null,es,ed,ef);
      } else {
        terr(e->loc,"missing enum name");
        e->r = Enum_e(q,null,null,es,ed,ef);
      }
      break;
    case XenumRes(xed,ef):
      e->r = Xenum_e(ef->name,null,es,xed,ef);
      break;
    case StructRes(sd):
      let des = List::map(make_struct_arg,es);
      if (sd->name != null)
        e->r = Struct_e(sd->name->v,null,des,&Opt(sd));
      else {
        terr(e->loc,"missing struct name");
        e->r = Struct_e(q,null,des,&Opt(sd));
      }
      break;
    }
    break;
  default:
    e->r = FnCall_e(e1,es);
    break;
  }
}

///////////////// UnresolvedMem //////////////////////////
static void resolve_unresolved_mem(tenv te, segment loc, Opt_t<typ> topt, exp e,
				   Opt_t<typedef_name> nopt,
				   list<$(list<designator>,exp)@> des) {
  // NOTE: must always bang e->r or caller will loop!
  if (topt == null) {
    terr(loc, "cannot resolve type of initializer");
    // guess it is an array
    e->r = Array_e(des);
    return; 
  }
  typ t = topt->v;
  switch (compress(t)) {
  case ArrayType(at,aq,ak):  e->r = Array_e(des); break;
  case StructType(tdopt,ts): e->r = Struct_e(tdopt->v,null,des,null); break;
  default:
    terr(loc, 
     xprintf("invalid initializer for type %s "
	     "-- expecting array or struct type", typ2string(t)));
    // guess it is an array
    e->r = Array_e(des);
    break;
  }
}

static void resolve_any_unknown_id(tenv te, exp e) {
  switch (e->r) {
  case UnknownId_e(q): resolve_unknown_id(te,e,q); break;
  default: break; // skip
  }
}


// Type check a list of expressions returning a sequentialized synth -- the
// type in the resulting synth is bogus, but the other information is valid.
static synth tcExpList(tenv te, list<exp> es) {
  synth s = skip_synth(te);
  while(es != null) {
    s  = seq_synth(s, tcExp(te,null,es->hd));
    te = layer_synth(te,s);
    es = es->tl;
  }
  return s;
}

// constants
static synth tcConst(tenv te, segment loc, Opt_t<typ> topt, cnst c) {
  typ t;
  switch (c) {
  case Char_c(sn,_):     t = (sn == Unsigned) ? uchar_t  : schar_t;  break;
  case Short_c(sn,_):    t = (sn == Unsigned) ? ushort_t : sshort_t; break;
    // FIX: take i into account
  case Int_c(sn,i):      t = (sn == Unsigned) ? uint_t   : sint_t;   break;
  case LongLong_c(sn,_): t = (sn == Unsigned) ? ulong_t  : slong_t;  break;
  case Bool_c(_)  : t = bool_t;  break;
  case Float_c(_) : t = float_t; break;
  case String_c(s):
    int len = size(s); // includes the trailing 0 character
    let r   = Const_e(Int_c(Unsigned,len));
    exp e   = new_exp(r,loc);
    e->topt = &Opt(uint_t);
    t = ArrayType(uchar_t,empty_tqual(),FixedArray(e));
    break;
  case Null_c:
    // FIX: take advantage of topt
    t = PointerType(wildtyp(), &Conref(Eq_constr((Bool)true)), empty_tqual());
    break;
  }
  return standard_synth(te,t);
}

// variables 
// FIX: lvalues must not be Funname_b (probably check somewhere else)
static synth tcVar(tenv te, segment loc, Opt_t<typ> topt, qvar q, exp e) {
  // FIX: update vd through e to have the correct binding
  switch (lookup_ordinary(te,loc,q)) {
  case VarRes(b):
    // great place to test out some fancy fallthrus later...
    switch(b) {
    case Unresolved_b:
      return expr_err(te,loc,xprintf("unbound identifier %s",qvar2string(q)));
    case Global_b(vd):
      q[0] = vd->name[0];
      return standard_synth(te,vd->type);
    case Funname_b(fd):
      q[0] = fd->name[0];
      return standard_synth(te,fndecl2typ(fd));
    case Param_b(&$(v,tq,t)):
      return standard_synth(te,t);
    case Local_b(vd):
      if (Set::member(get_unassigned(te),vd->name[1]))
	terr(loc,xprintf("identifier %s might not be initialized",q[1]));
      return standard_synth(te,vd->type);
    case Pat_b(vd):
      return standard_synth(te,vd->type);
    }
  case StructRes(_):  return impos("StructRes in tcVar");
  case EnumRes(_,_):  return impos("EnumRes in tcVar");
  case XenumRes(_,_): return impos("XenumRes in tcVar");
  }
}
static void check_format_args(tenv te, exp fmt, list<exp> args) {
  string fmt_str;
  list<typ> desc_types = null;
  int i = 0;

  // get out the literal format string
  switch (fmt->r) {
  case Const_e(String_c(s)): fmt_str = s; break;
  default: terr(fmt->loc, "expecting a literal format string"); return;
  }
  int len = String::strlen(fmt_str);
  // calculate the types
  while (i < len) {
    if (fmt_str[i] == '%') {
      ++i;
      if (i < len) {
	// FIX: should deal with real formatting
	switch (fmt_str[i]) {
	case 'c': desc_types = &cons(uchar_t,      desc_types); break;
	case 'd': desc_types = &cons(sint_t,       desc_types); break;
	case 'u': desc_types = &cons(uint_t,       desc_types); break;
	case 'x': desc_types = &cons(uint_t,       desc_types); break;
	case 'f': desc_types = &cons(float_t,      desc_types); break;
	case 's': desc_types = &cons(string_typ(), desc_types); break;
	case 'g': desc_types = &cons(double_t,     desc_types); break;
	case '%': break; // skip
	default: 
	  terr(fmt->loc, xprintf("bad format character %c",fmt_str[i]));
          break;
	}
	++i;
      }
    } else 
      ++i;
  }
  desc_types = List::imp_rev(desc_types);
  // now check that each desc_type matches the expression types
  for (; desc_types != null && args != null; desc_types = desc_types->tl, 
	                                     args = args->tl) {
    typ t = desc_types->hd;
    exp e = args->hd;
    if (!coerce_arg(te,e,t))
      terr(e->loc,xprintf("descriptor has type %s but argument has type %s",
			  typ2string(t), typ2string(e->topt->v)));
  }
  if (desc_types != null)
    terr(fmt->loc,xprintf("descriptor expects another value of type %s",
			  typ2string(desc_types->hd)));
  else if (args != null)
    terr(args->hd->loc,"too many arguments");
}


// Unary primops like -e, !e, etc. 
static typ tcUnPrimop(tenv te, segment loc, Opt_t<typ> topt, primop p, exp e) {
  typ t = compress(e->topt->v);
  switch (p) {
  case Plus:
    if (!arithmetic_promote(te,e)) 
      terr(loc,xprintf("expecting arithmetic type but found %s",typ2string(t)));
    return e->topt->v;
  case Minus:
    if (!arithmetic_promote(te,e)) 
      terr(loc,xprintf("expecting arithmetic type but found %s",typ2string(t)));
    return e->topt->v;
  case Not:
    if (!coerce_to_bool(te,e))
      terr(loc,xprintf("expecting bool but found %s",typ2string(t)));
    return bool_t;
  case Bitnot:
    if (!integral_promote(te,e))
      terr(loc,xprintf("expecting integral type but found %s",typ2string(t)));
    return e->topt->v;
  case Size:
    switch (t) {
    case ArrayType(_,_,UntaggedArray):
      terr(loc,"size not applicable to indeterminate arrays"); 
      break;
    case ArrayType(_,_,_): 
      break;
    default:
      terr(loc,xprintf("size requires array type, not %s",typ2string(t)));
      break;
    }
    return uint_t;
  default:
    return impos("Non-unary primop");
  }
}

static typ tcArithBinop(tenv te, segment loc, Opt_t<typ> topt, exp e1, exp e2) {
  if (!arithmetic_promote(te,e1)) {
    terr(e1->loc,xprintf("expecting arithmetic type but found %s",
			 typ2string(e1->topt->v)));
    return wildtyp();
  }
  if (!arithmetic_promote(te,e2)) {
    terr(e2->loc,xprintf("expecting arithmetic type but found %s",
			 typ2string(e2->topt->v)));
    return wildtyp();
  }
  typ t1  = compress(e1->topt->v);
  typ t2  = compress(e2->topt->v);
  typ res = max_arithmetic_type(t1,t2);
  // these casts should always succeed
  unchecked_cast(te,e1,res);
  unchecked_cast(te,e2,res);
  return res;
}

static 
typ tcIntegralBinop(tenv te, segment loc, Opt_t<typ> topt, exp e1, exp e2) {
  if (!integral_promote(te,e1)) {
    terr(e1->loc,xprintf("expecting integral type but found %s",
			 typ2string(e1->topt->v)));
    return wildtyp();
  }
  if (!integral_promote(te,e2)) {
    terr(e2->loc,xprintf("expecting integral type but found %s",
			 typ2string(e1->topt->v)));
    return wildtyp();
  }
  typ t1  = compress(e1->topt->v);
  typ t2  = compress(e2->topt->v);
  typ res = max_arithmetic_type(t1,t2);
  // these casts should always succeed
  unchecked_cast(te,e1,res);
  unchecked_cast(te,e2,res);
  return res;
}



static typ tcAnyBinop(tenv te, segment loc, Opt_t<typ> topt, exp e1, exp e2) {
  bool e1_is_unboxed_arith = comparison_promote(te,e1);
  bool e2_is_unboxed_arith = comparison_promote(te,e2);
  typ t1 = compress(e1->topt->v);
  typ t2 = compress(e2->topt->v);
  if (e1_is_unboxed_arith && e2_is_unboxed_arith) {
    typ res = max_arithmetic_type(t1,t2);
    unchecked_cast(te,e1,res);
    unchecked_cast(te,e2,res);
  } else if (!unify(t1,t2)) {
    terr(loc,xprintf("comparison not allowed between %s and %s",
		     typ2string(t1),typ2string(t2)));
    return wildtyp();
  }
  return bool_t;
}

// Binary primops like e1+e2, e1>>e2, etc. 
static typ tcBinPrimop(tenv te, segment loc, Opt_t<typ> topt, 
		       primop p, exp e1, exp e2) {
  typ t;
  switch (p) {
    // FIX:  Plus and Minus should allow arrays
  case Plus:       t = tcArithBinop(te,loc,topt,e1,e2); break;
  case Times:      t = tcArithBinop(te,loc,topt,e1,e2); break;
  case Minus:      t = tcArithBinop(te,loc,topt,e1,e2); break;
  case Div:        t = tcArithBinop(te,loc,topt,e1,e2); break;
  case Mod:        t = tcIntegralBinop(te,loc,topt,e1,e2); break;
  case Eq:         t = tcAnyBinop(te,loc,topt,e1,e2); break;
  case Neq:        t = tcAnyBinop(te,loc,topt,e1,e2); break;
  case Gt:         t = tcAnyBinop(te,loc,topt,e1,e2); break;
  case Lt:         t = tcAnyBinop(te,loc,topt,e1,e2); break;
  case Gte:        t = tcAnyBinop(te,loc,topt,e1,e2); break;
  case Lte:        t = tcAnyBinop(te,loc,topt,e1,e2); break;
  case Bitand:     t = tcIntegralBinop(te,loc,topt,e1,e2); break;
  case Bitor:      t = tcIntegralBinop(te,loc,topt,e1,e2); break;
  case Bitxor:     t = tcIntegralBinop(te,loc,topt,e1,e2); break;
  case Bitlshift:  t = tcIntegralBinop(te,loc,topt,e1,e2); break;
  case Bitlrshift: t = tcIntegralBinop(te,loc,topt,e1,e2); break;
  case Bitarshift: t = tcIntegralBinop(te,loc,topt,e1,e2); break;
  default: throw Failure("bad binary primop");
  }
  return t;
}

// Primops.
// Unlike Java, the only binops on bools are == and !=.  (The parser
// expands && and || into Conditionals and there's no ^ or | or & on
// booleans.) For == and != on booleans we do nothing special yet,
// unlike Java so for example, true == true will behave differently. 
static synth tcPrimop(tenv te, segment loc, Opt_t<typ> topt,
                      primop p, list<exp> es) {
  // FIX: sizeof(f) where f is a function (or expression of function type)
  // should not be allowed.  So for sizeof(e), we should not call tcExp on e,
  // because that will do pointer generation (convert a function to a pointer
  // to a function).  Instead we should call tcexpNoInst.
  let es_result = tcExpList(te,es);
  typ t;
  switch (p) {
  case Printf:
    if (es == null)
      return expr_err(te,loc,"missing format string in printf");
    check_format_args(te, es->hd, es->tl);
    t = VoidType;
    break;
  case Fprintf:
    if (es == null || es->tl == null)
      return
        expr_err(te,loc,"missing file descriptor or format string in fprintf");
    if (!unify(es->hd->topt->v, file_typ()))
      terr(es->hd->loc,xprintf("expecting FILE @ but found %s",
			       typ2string(es->hd->topt->v)));
    check_format_args(te, es->tl->hd, es->tl->tl);
    t = VoidType;
    break;
  case Xprintf:
    if (es == null)
      return expr_err(te,loc,"missing format string in xprintf");
    check_format_args(te, es->hd, es->tl);
    t = string_typ();
    break;
  default:
    switch (List::length(es)) {
    case 0:
      return expr_err(te,loc,"primitive operator applied to no arguments");
    case 1:
      t = tcUnPrimop(te,loc,topt,p,es->hd);
      break;
    case 2:
      t = tcBinPrimop(te,loc,topt,p,es->hd,es->tl->hd);
      break;
    default:
      return expr_err(te,loc,
		      xprintf("primitive operator %s has too many arguments",
			      prim2string(p)));
    }
    break;
  }
  return synth_set_typ(es_result,t);
}

static synth tcIncrement(tenv te, segment loc, Opt_t<typ> topt, 
			 exp e, incrementor i) {
  resolve_any_unknown_id(te,e);
  let esyn = tcExp(te, null, e);
  // FIX: this is probably not right -- for instance, it would allow
  // an enum variable to be "incremented"
  if (!arithmetic_promote(te,e)) {
    terr(e->loc,xprintf("expecting arithmetic type but found %s",
		       typ2string(e->topt->v)));
  }
  return synth_set_typ(esyn, e->topt->v);
}

// e1 ? e2 : e3
//  NB: some care is taken here to more accurately track initialization,
//  hence the complexity. 
static synth tcConditional(tenv te, segment loc, Opt_t<typ> topt, 
			   exp e1, exp e2, exp e3) {
  synth esyn1,esyn2,esyn3;
  esyn1 = tcExp(te,&Opt(bool_t),e1);
  if (!coerce_to_bool(te,e1))
    terr(e1->loc,xprintf("conditional argument has type %s instead of bool",
			 typ2string(e1->topt->v)));
  let $(true_te, false_te) = bool_layer_synth(te, esyn1);
  esyn2 = tcExp(true_te,  topt, e2);
  esyn3 = tcExp(false_te, topt, e3);
  typ t = wildtyp();
  if (!coerce_list(te,t,&cons(e2,&cons(e3,null)))) {
    expr_err(te,loc,
	     xprintf("clauses of conditional do not match type: %s != %s",
		     typ2string(e2->topt->v),typ2string(e3->topt->v)));
  }
  return join_synth(seq_synth(esyn1,esyn2), seq_synth(esyn1,esyn3));
}

// Assignments with optional operations, e.g., x = 3, x += 5
// Note that as in tcPrimop, we violate Java by not considering
// various boolean operators to have meaning.  Must check lhs before
// rhs, but if lhs is a Var, and there's no Op, then the Var is
// allowed to be undefined. 
static synth tcAssignOp(tenv te,segment loc, Opt_t<typ> topt, exp e0, exp e1,
			Opt_t<primop> po, exp e2) {
  tenv te_lhs;
  resolve_any_unknown_id(te,e1);
  resolve_any_unknown_id(te,e2);
  switch ($(e1->r, po)) {
  case $(Var_e(&$(null,v),b), null): 
    // assignment without an operator to a variable
    te_lhs = set_unassigned(te,Set::delete(get_unassigned(te),v)); break;
  default:
    te_lhs = te; break;
  }
  let esyn_lhs = tcExp(te_lhs, null, e1);
  let t1       = synth_typ(esyn_lhs);
  // Check to see if e1 is an lvalue after typechecking, so that
  // UnknownIds can be resolved.
  if (!is_lvalue(e1))
    return expr_err(te,loc,"assignment to non-lvalue");
  /*
  check_valid_lhs(te,e1);
  */
  tenv te_rhs;
  switch (e1->r) {
  case Var_e(_,_): te_rhs = te; break;
  default:         te_rhs = layer_synth(te,esyn_lhs); break;
  }
  let esyn_rhs    = tcExp(te_rhs, null, e2);
  let t2          = synth_typ(esyn_rhs);
  let synth_after = esyn_rhs;

  switch (e1->r) {
  case Var_e(v,*vd): // FIX: set vd!!
    synth_after = initialize_var_synth(seq_synth(esyn_lhs,esyn_rhs),v[1]);
    break;
  default:
    synth_after = seq_synth(esyn_lhs,esyn_rhs);
    break;
  }
  if (po == null) {
    if (!coerce_assign(te,e2,t1)) 
      return expr_err(te,loc,xprintf("type mismatch: %s != %s",
				     typ2string(t1), typ2string(t2)));
  } else {
    let p        = po->v;
    let t_result = tcBinPrimop(te,loc,null,p,e1,e2);
    if (!(unify(t_result,t1) || coerceable(t_result))) {
      return expr_err(te,loc,
		      "Cannot use this operator in front of an assignment");
    }
  }
  return synth_after;
}

// e1,e2 
static synth tcSeqExp(tenv te, segment loc, Opt_t<typ> topt, exp e1, exp e2) {
  let r = tcExpList(te,&cons(e1,&cons(e2,null)));
  return synth_set_typ(r,e2->topt->v);
}

// e(es) 
static 
synth tcFnCall(tenv te, segment loc, Opt_t<typ> topt, exp e, list<exp> es) {
  let list_result = tcExpList(te,&cons(e,es));
  typ t = compress(e->topt->v);
  // NB: we should really unify t with an unconstrained FnType with the
  // right arity but there may be coercions involved with the arguments
  // and the function might actually be a vararg.
  switch (t) {
  case PointerType(t1,x,tq):
    // FIX: insert null check if necessary
    switch (compress(t1)) {
    case FnType(tvars,res_t,args_info,is_vararg): //TODO: handle tvars
      if (is_vararg)
        terr(loc,"vararg functions (...) not supported yet");
      // for each argument -- check that it has the appropriate type, coercing
      // as necessary
      while ((es != null) && (args_info != null)) {
        exp e1 = es->hd;
        typ t2 = args_info->hd[2];
        typ t3 = e1->topt->v;
        if (!coerce_arg(te,e1,t2))
          terr(loc,
               xprintf("actual argument has type %s but formal has type %s",
                       typ2string(t3),typ2string(t2)));
        es = es->tl;
        args_info = args_info->tl;
      }
      if (es != null) 
        return expr_err(te,loc,"too many arguments for function");
      else if (args_info != null) 
        return expr_err(te,loc,"too few arguments for function");
      return synth_set_typ(list_result,res_t);
    default:
      return expr_err(te,loc,"expected pointer to function");
    }
  default:
    return expr_err(te,loc,"expected pointer to function");
  }
}

// throw e 
static synth tcThrow(tenv te, segment loc, Opt_t<typ> topt, exp e) {
  typ t = synth_typ(tcExp(te,&Opt(exn_t),e));
  if (!unify(t,exn_t)) 
    expr_err(te, loc,xprintf("expected xenum exn but found %s",typ2string(t)));
  return empty_synth(te);
}

// (implicit) instantiation 
// TODO: this is really untested, because the parser does not
// insert Instantiate expressions, only the typechecker does,
// and the output of the typechecker isn't passed through itself...
static synth tcInstantiate(tenv te, segment loc, Opt_t<typ> topt, 
                           exp e, Opt_t<list<typ>> @opt_ref) {
  Opt_t<list<typ>> topts = *opt_ref;
  synth esyn = tcExp(te,null,e);
  typ t0 = compress(synth_typ(esyn));
  switch (t0) {
  case PointerType(t,_,_):
    switch (t) {
    case FnType(tvars,rtyp,args,varargs):
      list<$(var,typ)@> instantiation;
      if (topts == null) {
        instantiation = List::map(make_inst_var,tvars);
        *opt_ref = &Opt(List::split(instantiation)[1]); // side-effect
      } else {
        try
          instantiation = List::zip(tvars,topts->v);
        catch {
        case List::List_mismatch:
          return expr_err(te,loc,"type instantiation mismatch");
        }
      }
      typ new_typ = substitute(instantiation,
                               FnType(null,rtyp,args,varargs));
      return synth_set_typ(esyn,new_typ);
    default:
      return expr_err(te,loc,xprintf("expecting polymorphic type but found %s",
                                     typ2string(t0)));
    }
  default:
    return expr_err(te,loc,xprintf("expecting polymorphic type but found %s",
                                   typ2string(t0)));
  }
}

// (t)e 
static synth tcCast(tenv te, segment loc, Opt_t<typ> topt, typ t, exp e) {
  check_valid_type(loc,te,lookup_type_vars(te),t);
  synth esyn = tcExp(te,null,e);
  typ t2 = synth_typ(esyn);
  if (!castable(te,loc,t2,t)) 
    return expr_err(te,loc,xprintf("cannot cast %s to %s",typ2string(t2),
				   typ2string(t)));
  return synth_set_typ(esyn,t);
}

// if e is a valid lhs, then return true if that lhs must be const,
// otherwise, return false.
static bool lhs_const(tenv te, exp e) {
  // in some situations, the pointer must actually be const
  switch (e->r) {
  case Var_e(q,_):
    switch (lookup_ordinary(te,e->loc,q)) {
    case VarRes(Unresolved_b): 
      terr(e->loc,"UnknownVar in lhs_const"); 
      return false;
    case VarRes(Global_b(vd)): return vd->tq->q_const;
    case VarRes(Local_b(vd)):  return vd->tq->q_const;
    case VarRes(Pat_b(vd)):    return vd->tq->q_const;
    case VarRes(Param_b(&$(_,tq,_))): return tq->q_const;
    case VarRes(Funname_b(_)): return true; // ???
    case StructRes(_):  throw impos("StructRes in lhs_const");
    case EnumRes(_,_):  throw impos("EnumRes in lhs_const");
    case XenumRes(_,_): throw impos("XenumRes in lhs_const");
    }
    // FIX??? Cannot Cast_e make something const ???
  case Cast_e(_,e2): return lhs_const(te,e2);
  case StructMember_e(e2,f):
    typ t = compress(e2->topt->v);
    switch (t) {
    case StructType(nopt,ts):
      let sd     = lookup_structdecl(te,e2->loc,nopt->v);
      let fields = sd->fields == null ? null : sd->fields->v;
      for(; fields != null; fields = fields->tl)
	if (String::zstrcmp(fields->hd[0],f) == 0)
	  return fields->hd[1]->q_const;
      terr(e2->loc,xprintf("bad field %s in struct %s",f,qvar2string(nopt->v)));
      return false;
    default:
      terr(e2->loc,"expression is not a struct");
      return false;
    }
  case Subscript_e(e1,e2):
    typ t = compress(e->topt->v);
    switch (t) {
    case ArrayType(_,tq,_): return tq->q_const;
    case TupleType(ts):
      for(unsigned int i = eval_const_uint_exp(e2); i != 0; --i)
	ts = ts->tl;
      return ts->hd[0]->q_const;
    default:
      terr(e->loc,xprintf("expression is not an array or tuple, it has type %s",
			  typ2string(t)));
      return false;
    }
  default: return false;
  }
}

// &e 
static synth tcAddress(tenv te, segment loc, Opt_t<typ> topt, exp e) {
  //  if (!is_lvalue(e))
  //    return expr_err(te,loc,"unary & applied to non-lvalue");
  // TESTING FUNCTION STUFF
  // Use tcExpNoInst here because if f is a function then
  // then &f is supposed to be a pointer to a function, not
  // a pointer to a pointer to a function
  // FIX: still busted...
  synth esyn = tcExpNoInst(te,topt,e);
  tqual tq = &Tqual{.q_const = lhs_const(te,e),
		    .q_volatile=false, .q_restrict=false};
  typ t = PointerType(synth_typ(esyn),
                      &Conref(Eq_constr((Bool)false)),tq);
  return synth_set_typ(esyn,t);
}



static void ok_sizeof(tenv te, segment loc, typ t) {
  switch (compress(t)) {
  case VoidType: terr(loc,"cannot apply sizeof to void type"); return;
  case Evar(_,_,_): impos("sizeof on evar!"); return;
  case VarType(_): return;
  case EnumType(_,_): return;
  case XenumType(_): return;
  case PointerType(_,_,_): return;
  case IntType(_,_,_): return;
  case BoolType(_): return;
  case FloatType(_): return;
  case DoubleType(_): return;
  case ArrayType(t2,tq,ak):
    switch (ak) {
    case UntaggedArray: 
      terr(loc,xprintf("cannot apply sizeof to untagged array type %s",
		       typ2string(t2)));
      return;
    case TaggedArray: return;
    case FixedArray(_): ok_sizeof(te,loc,t2); return;
    }
  case FnType(_,_,_,_): terr(loc,"sizeof applied to function type"); return;
  case TupleType(tqts):
    for (; tqts != null; tqts = tqts->tl)
      ok_sizeof(te,loc,tqts->hd[1]);
    return;
  case StructType(tdopt,ts):
    if (tdopt != null) {
      let td = tdopt->v;
      let sd = lookup_structdecl(te,loc,td);
      let inst = List::map(make_inst_var,sd->tvs);
      if (sd->fields == null) {
	terr(loc,xprintf("struct %s is abstract -- cannot apply sizeof",
			 qvar2string(td)));
	return;
      }
      for (let fs = sd->fields->v; fs != null; fs = fs->tl) 
	ok_sizeof(te,loc,substitute(inst,fs->hd[2]));
    }
    return;
  case UnionType: impos("ok_sizeof: uniontype"); return;
  case TypedefType(_,_,_): impos("ok_sizeof: typedeftype"); return;
  }
}

// sizeof t 
static synth tcSizeof(tenv te, segment loc, Opt_t<typ> topt, typ t) {
  check_valid_type(loc,te,lookup_type_vars(te),t);
  ok_sizeof(te,loc,t);
  return standard_synth(te,uint_t);
}

// *e 
static synth tcDeref(tenv te, segment loc, Opt_t<typ> topt, exp e) {
  synth esyn = tcExp(te,null,e);
  typ t = compress(e->topt->v);
  switch (t) {
  case PointerType(t2,_,_): return synth_set_typ(esyn,t2);
  default: return expr_err(te,loc,xprintf("expecting * or @ type but found %s",
					  typ2string(t)));
  }
}

// e->f 
static synth tcStructMember(tenv te, segment loc, Opt_t<typ> topt, 
			    exp e, field_name f) {
  synth esyn = tcExp(te,null,e);
  typ t = compress(e->topt->v);
  switch (t) {
  case StructType(nopt,ts):
    if (nopt == null)
      return expr_err(te,loc,"unresolved struct type (COMPILER ERROR)");
    let n = nopt->v; // FIX: is this guaranteed non-null?
    let sd = lookup_structdecl(te,loc,n);
    let finfo_opt = lookup_struct_field(sd,f);
    if (finfo_opt == null) 
      return expr_err(te,loc,xprintf("struct %s has no %s field",
				     qvar2string(n),f));
    let inst = List::zip(sd->tvs,ts);
    let t2 = substitute(inst,finfo_opt[1]);
    return synth_set_typ(esyn,t2);
  default:
    return expr_err(te,loc,xprintf("expecting struct, found %s",typ2string(t)));
  }
}

// e->f 
static synth tcStructArrow(tenv te, segment loc, Opt_t<typ> topt, 
			   exp e, field_name f) {
  synth esyn = tcExp(te,null,e);
  typ t = compress(e->topt->v);
  switch (t) {
  case PointerType(t2,_,_):
    switch (compress(t2)) {
    case StructType(nopt,ts):
      let n  = nopt->v; // FIX: is this guaranteed non-null?
      let sd = lookup_structdecl(te,loc,n);
      let finfo_opt = lookup_struct_field(sd,f);
      if (finfo_opt == null) {
	return expr_err(te,loc,xprintf("struct %s has no %s field",
				       qvar2string(n),f));
      }
      let inst = List::zip(sd->tvs,ts);
      let t3 = substitute(inst,finfo_opt[1]);
      return synth_set_typ(esyn,t3);
    default:
      return expr_err(te,loc, xprintf("expecting struct pointer, found %s", 
				      typ2string(t)));
    }
  default:
      return expr_err(te,loc,xprintf("expecting struct pointer, found %s",
				     typ2string(t)));
  }
}

// e1[e2] 
static synth tcSubscript(tenv te, segment loc, Opt_t<typ> topt, exp e1, exp e2){
  let list_result = tcExpList(te,&cons(e1,&cons(e2,null)));
  typ res;
  typ t1 = compress(e1->topt->v);
  typ t2 = compress(e2->topt->v);
  // NOTE: we use unsigned int here, unlike C, because we do not support
  // negative indexing on arrays.
  if (!coerce_uint_typ(te,e2)) {
    return expr_err(te,e2->loc,xprintf("expecting unsigned int, found %s",
                                       typ2string(t2)));
  }
  // the subscript could be on a tuple, a pointer to a tuple, or an array
  switch (t1) {
  case PointerType(t,_,tq):
    // FIX: see whether pointer is nullable? Consider tq?
    switch (t) {
    case TupleType(ts):
      unsigned int i = eval_const_uint_exp(e2);
      try {
        res = List::nth(ts,i)[1];
      } catch {
      case Nth:
        return expr_err(te,loc,
			xprintf("index is %d but tuple has only %d fields",
                                i, List::length(ts)));
      }
      break;
    default:
      return
        expr_err(te,loc,
                 xprintf("subscript applied to %s (array or tuple required)",
                         typ2string(t2)));
    }
    break; 
  case TupleType(ts):
    unsigned int i = eval_const_uint_exp(e2);
    try {
      res = List::nth(ts,i)[1];
    } catch {
    case Nth:
      return
        expr_err(te,loc,
                 xprintf("index is %d but tuple has only %d fields",
                         i,List::length(ts)));
    }
    break;
  case ArrayType(ta,q,ak):
    if (ak == UntaggedArray)
      expr_err(te,loc,xprintf("can't safely index into untagged array"));
    res = ta;
    break;
  default:
    return expr_err(te,loc,
		   xprintf("subscript applied to %s (array or tuple required)",
			   typ2string(t2)));
  }
  return synth_set_typ(list_result,res);
}

static typ exp_typ(exp e) {
  return e->topt->v;
}

// $(es) 
static $(tqual,typ)@ make_tuple_field(typ t) {
  return &$(&Tqual{.q_const = false,
                      .q_volatile = false, .q_restrict = false},t);
}
static synth tcTuple(tenv te, segment loc, Opt_t<typ> topt, list<exp> es) {
  let list_result = tcExpList(te,es);
  list<typ>           ts     = List::map(exp_typ,es);
  list<$(tqual,typ)@> fields = List::map(make_tuple_field,ts);
  return synth_set_typ(list_result,TupleType(fields));
}

// Compound literals, e.g., (struct foo){3,"abc"} 
static synth tcCompoundLit(tenv te, segment loc, Opt_t<typ> topt,
			   $(Opt_t<string>,tqual,typ)@ t,
			   list<$(list<designator>,exp)@> des) {
  return expr_err(te,loc,"tcCompoundLit");
}

///////////////////// Array ({e1,...,en}) /////////////////////////
// FIX:  only a very limited class of designators (basically, the proper
// index) is supported and all of the array elements must be present.
static synth tcArray(tenv te,segment loc,Opt_t<typ> topt, 
		     list<$(list<designator>,exp)@> des) {
  list<exp> es = List::map(snd,des); //@<list<designator>,exp>
  if (topt != null) {
    switch (compress(topt->v)) {
    case ArrayType(elt_t,_,_):
      // cast all of the elements to the element type
      for (let es1 = es; es1 != null; es1 = es1->tl) {
	exp e = es1->hd;
	e->r = cast_exp(elt_t,new_exp(e->r,e->loc),e->loc)->r;
      }
      break;
    default: 
      terr(loc,xprintf("initializer for %s is an array",typ2string(topt->v)));
      break;
    }
  }
  let list_result = tcExpList(te,es);
  typ res = wildtyp();
  if (!coerce_list(te,res,es))
    terr(es->hd->loc,
	 xprintf("elements of array do not all have the same type (%s)",
		 typ2string(res)));
  let sz_rexp = Const_e(Int_c(Unsigned,List::length(es)));
  exp sz_exp = new_exp(sz_rexp,loc);
  sz_exp->topt = &Opt(uint_t);
  typ res_t2 = ArrayType(res,empty_tqual(),FixedArray(sz_exp));
  // check that any designators make sense
  for(int offset = 0; des != null; offset++, des = des->tl) {
    list<designator> ds = des->hd[0];
    if (ds != null) {
      //   if (ds->hd->tl != null)
      //     terr(ds->hd[1]->loc,"only array index designators are supported");
      switch (ds->hd) {
      case FieldName(_):
	terr(loc,"only array index designators are supported");
        break;
      case ArrayElement(e):
	tcExp(te,null,e);
	unsigned int i = eval_const_uint_exp(e);
	if (i != offset)
	  terr(e->loc, xprintf("expecting index designator %d but found %d",
			       offset,i));
        break;
      }
    }
  }
  return synth_set_typ(list_result,res_t2);
}

// {for x < e1 : e2} 
static synth tcComprehension(tenv te,segment loc,Opt_t<typ> topt,
			     vardecl vd,exp bound,exp body) {
  let esyn_bound = tcExp(te,null,bound);
  if (!coerce_uint_typ(te,bound))
    terr(bound->loc,xprintf("expecting unsigned int, found %s",
			    typ2string(synth_typ(esyn_bound))));
  // add x to the environment with the type unsigned int, note it is inited
  tenv te2 = add_local_var(loc, te, vd);
  // if topt is present, cast the body to topt's element type
  if (topt != null) {
    switch (compress(topt->v)) {
    case ArrayType(elt_typ,_,_):
      body->r = cast_exp(elt_typ, new_exp(body->r,body->loc),body->loc)->r;
      break;
    default:
      terr(loc,xprintf("initializer for %s is an array",typ2string(topt->v)));
      break;
    }
  }
  // type-check the body in the new environment
  let esyn_body = tcExp(te2,null,body);
  array_kind k;
  if (is_const_exp(te2,bound)) 
    k = FixedArray(bound);
  else 
    k = TaggedArray;

  typ t = ArrayType(synth_typ(esyn_body), empty_tqual(), k);
  // the body may never be executed -- like a while or for loop
  return synth_set_typ(loop_synth(esyn_bound,esyn_body),t);
}

//////////////////// Struct (f{e1,...,en}) ///////////////////
// FIX:
// Right now, we only allow one field name designator on an argument.
// In addition, we assume any undesignated argument is associated with
// the first field that has not yet been explicitly mentioned.  So,
// for instance, if we have:
//  struct Foo {int a,b,c,d,e;}
//  Foo{.c=3,.d=4,1,2,5};
// then this is the same as Foo{->a=1,->b=2,->c=3,->d=4,->e=5};
// Later, we should support array designators and so forth.
static synth tcStruct(tenv te, segment loc, Opt_t<typ> topt,
		      typedef_name @tn,                    // arg[0]
		      Opt_t<list<typ>> @otyps,             // arg[1]
		      list<$(list<designator>,exp)@> args, // arg[2]
		      Opt_t<structdecl> sd_opt) {          // arg[3] 
  structdecl sd;
  if (sd_opt != null)
    sd = sd_opt->v;
  else {
    sd = lookup_structdecl(te,loc,*tn);
    if (sd->name != null)
      *tn = sd->name->v;
  }
  // calculate the instantiation and final type
  let inst = List::map(make_inst_var,sd->tvs);
  let typs = List::map(snd,inst); // @<tvar,typ>
  *otyps = &Opt(typs);
  let res_t = StructType(&Opt(*tn),typs);
  list<$(field_name,tqual,typ)@> fields;
  if (sd->fields == null) {
    fields = null;
    terr(loc,xprintf("struct %s is abstract",qvar2string(*tn)));
  } else
    // must make copy because we do imperative removes later on
    fields = List::copy(sd->fields->v);
  // type-check all of the argument expressions in order
  let list_result = tcExpList(te,List::map(snd,args)); //@<list<designator>,exp>
  // for each argument find its field and make sure its type matches
  while (args != null) {
    let &$(ds,e) = args->hd;
    $(field_name,tqual,typ)@ field;
    if (ds == null) {
      // no explicit designator -- take the first field
      if (fields == null) 
	return expr_err(te,e->loc,xprintf("extra argument to struct %s",
					  qvar2string(*tn)));
      field = fields->hd;
      args->hd[0] = &cons(FieldName(field[0]),null);
      fields = fields->tl;
    } else {
      // make sure the explicit designator is just a field name --
      // remove that field from the list of fields
      let d = ds->hd;
      if (ds->tl != null) terr(e->loc,"too many designators");
      switch (d) {
      case ArrayElement(e2):
	return expr_err(te,e2->loc,"array designators not supported here");
      case FieldName(f):
	try {
	  let p = remove_field(f,fields);
	  field = p[0];
	  fields = p[1];
	} catch {
	case MissingField:
	  return expr_err(te,e->loc,xprintf("bad field designator %s",f));
	}
	break;
      }
    }
    // field is now found -- check that the argument is the right type.
    let field_typ = substitute(inst,field[2]);
    if (!coerce_arg(te,e,field_typ))
      terr(e->loc,xprintf("field %s of struct %s expects type %s != %s",
			  field[0],qvar2string(*tn),typ2string(field_typ),
			  typ2string(e->topt->v)));
    args = args->tl;
  }
  if (fields != null)
    terr(loc,xprintf("struct %s is missing a value for field %s",
                     qvar2string(*tn),fields->hd[0]));
  return synth_set_typ(list_result,res_t);
}

// f(es)   where f is an enum 
static synth tcEnum(tenv te, segment loc, Opt_t<typ> topt,
		    qvar f,
		    Opt_t<list<typ>> @all_ref,
		    Opt_t<list<typ>> @exist_ref,
		    list<exp> es,
		    enumdecl  ed,
		    enumfield ef) {
  // FIX: the topt arg is not used ??
  let list_result = tcExpList(te,es);
  let all_inst    = List::map(make_inst_var,ed->tvs);
  let exist_inst  = List::map(make_inst_var,ef->tvs);
  let all_typs    = List::map(snd,all_inst);   // @<var,typ>
  let exist_typs  = List::map(snd,exist_inst); // @<var,typ>
  let inst = List::append(all_inst,exist_inst);
  *all_ref = &Opt(all_typs);
  *exist_ref = &Opt(exist_typs);
  typ res = EnumType(ed->name,all_typs);
  list<$(tqual,typ)@> ts = ef->typs;
  while (es != null && ts != null) {
    exp e = es->hd; es = es->tl;
    typ t = substitute(inst,ts->hd[1]); 
    ts = ts->tl;
    if (!coerce_arg(te,e,t))
      terr(e->loc,
           xprintf("enum constructor %s expects argument of type %s "
		   "but this argument has type %s",
		   qvar2string(f),typ2string(t),
		   (e->topt == null) ? (string)"?" : typ2string(e->topt->v)));
  }
  if (es != null) 
    return expr_err(te,es->hd->loc,
		    xprintf("too many arguments for enum constructor %s",
			    qvar2string(f)));
  else if (ts != null) 
    return expr_err(te,loc, xprintf("too few arguments for enum constructor %s",
				    qvar2string(f)));
  else
    return synth_set_typ(list_result,res);
}

// f(es)   where f is an xenum 
static synth tcXenum(tenv te, segment loc, Opt_t<typ> topt,
		     qvar f,
		     Opt_t<list<typ>> @exist_ref,
		     list<exp> es,
		     xenumdecl xd,
		     enumfield ef) {
  let list_result = tcExpList(te,es);
  let exist_inst  = List::map(make_inst_var,ef->tvs);
  let exist_typs  = List::map(snd,exist_inst); //@<var,typ>
  *exist_ref = &Opt(exist_typs);
  typ res = XenumType(xd->name);
  list<$(tqual,typ)@> ts = ef->typs;
  while (es != null && ts != null) {
    exp e = es->hd; es = es->tl;
    typ t = substitute(exist_inst,ts->hd[1]); 
    ts = ts->tl;
    if (!coerce_arg(te,e,t))
      terr(e->loc,xprintf("xenum constructor %s expects argument of type %s "
			  "but this argument has type %s",
			  qvar2string(f),typ2string(t),typ2string(e->topt->v)));
  }
  if (es != null)
    terr(es->hd->loc,xprintf("too many arguments for xenum constructor %s",
			     qvar2string(f)));
  else if (ts != null)
    terr(es->hd->loc,xprintf("too few arguments for xenum constructor %s",
			     qvar2string(f)));
  return synth_set_typ(list_result,res);

}

// ({ s }) 
static Opt_t<typ> find_stmt_typ(stmt s) {
  switch (s->r) {
  case Exp_s(e):     return e->topt;
  case Seq_s(s1,s2): return find_stmt_typ(s2);
  case Decl_s(d,s1): return find_stmt_typ(s1);
  default:           return null;
  }
}
static synth tcStmtExp(tenv te, segment loc, Opt_t<typ> topt, stmt s) {
  let ssyn  = tcStmt(te,s);
  let topt2 = find_stmt_typ(s);
  if (topt2 == null) 
    return expr_err(te,loc,"cannot determine type of statement expression");
  return synth_set_typ(ssyn,topt2->v);
}

// codegen(fd) 
static synth tcCodegen(tenv te, segment loc, Opt_t<typ> topt, fndecl fd) {
  return expr_err(te,loc,"tcCodegen");
  //  typ t = fndecl2typ(fd);
  /*
  check_fundecl_valid_type(te,loc,fd);
  tenv te2 = code_gen_tenv(fd,te);
  tcFn_d(te2,loc,fd);
  */
  //  return standard_synth(te,t);
}

static void tcFn_d(tenv te, segment loc, Opt_t<typ> topt, fndecl fd) {
  terr(loc,"tcFn_d");
  return;
}

// fill(e) 
static synth tcFill(tenv te, segment loc, Opt_t<typ> topt, exp e) {
  return expr_err(te,loc,"tcFill");
//  switch te->local {
//  case Frame(p):
//    // NB: assignments are not tracked in fills
//    return base_synth(te,tcExp(fill_te(te),e)->type);
//  case Hidden(_):
//    return terr(loc,"fill cannot be used while codegen is in cut");
//  case Outermost(_):
//    return terr(loc,"fill can only be used within codegen");
//  }
}

// FIX: there are other expressions we could allow, such as 
// &(x->y) or &(x[0]) that we do not support here...
extern bool is_const_exp(tenv te, exp e);
static bool cnst_exp(tenv te, bool var_okay, exp e) {
  switch (e->r) {
  case Const_e(_):
    return true;
  case Var_e(qv,_): 
    // NB: top-level function names are "constant" 
    // Fix: what about arrays?
    switch (lookup_ordinary(te, e->loc, qv)) {
    case VarRes(Funname_b(_)): return true;
    default: return var_okay;
    }
  case Primop_e(p,es):
    return (List::forall_c(is_const_exp,te,es));
  case Conditional_e(e1,e2,e3):
    return (cnst_exp(te,false,e1) && cnst_exp(te,false,e2) &&
	    cnst_exp(te,false,e3));
  case SeqExp_e(e1,e2):
    return (cnst_exp(te,false,e1) && cnst_exp(te,false,e2));
  case Instantiate_e(e2,_):
    return cnst_exp(te,var_okay,e2);
  case Cast_e(t,e2):
    // Fix:  not clear that we should allow boxing/unboxing conversions...
    return cnst_exp(te,var_okay,e2);
  case Address_e(e2):
    return cnst_exp(te,true,e2);
  case Sizeof_e(t):
    return true;
  case Tuple_e(es):
    for (; es != null; es = es->tl)
      if (!cnst_exp(te,false,es->hd)) return false;
    return true;
  case Array_e(des):
    for (; des != null; des = des->tl)
      if (!cnst_exp(te,false,des->hd[1])) return false;
    return true;
  case Struct_e(_,_,des,_):
    for (; des != null; des = des->tl)
      if (!cnst_exp(te,false,des->hd[1])) return false;
    return true;
  case Enum_e(_,_,_,es,_,_):
    for (; es != null; es = es->tl)
      if (!cnst_exp(te,false,es->hd)) return false;
    return true;
  case Xenum_e(_,_,es,_,_):
    for (; es != null; es = es->tl)
      if (!cnst_exp(te,false,es->hd)) return false;
    return true;
  default:
    return false;
  }
}
bool is_const_exp(tenv te, exp e) {
  return cnst_exp(te,false,e);
}

// Type check an expression e.  The value topt is an optional type
// that we expect e to have.  This is useful for propagating type
// information down (i.e., to resolve certain ambiguous expression
// forms) but isn't otherwise used -- one still needs to check that
// e has the expected type.  If e="e2<>" and e2 has a poly-type, 
// we do not instantiate the type quantifiers.  Otherwise if e has a
// poly-type, we instantiate the quantifiers. 
synth tcExp(tenv te, Opt_t<typ> topt, exp e) {
  synth esyn;
  switch (e->r) {
  case NoInstantiate_e(e2):
    // the user has asked not to implicitly instantiate any quantifiers
    esyn = tcExpNoInst(te,topt,e2);
    e->topt = e2->topt;
    break;
  default:
    // implicitly instantiate the expression if it has a polymorphic type
    esyn = tcExpNoInst(te,topt,e); // first, typecheck without instantiating
    // TESTING FUNCTION STUFF
    esyn = synth_set_typ(esyn,pointer_expand(compress(synth_typ(esyn))));
    e->topt = &Opt(synth_typ(esyn));
    switch (compress(synth_typ(esyn))) {
    case PointerType(t,x,tq):
      switch (compress(t)) {
      case FnType(tvs,rtyp,args,varargs):
        if (tvs != null) {   // then, instantiate if necessary
          list<$(var,typ)@> instantiation = List::map(make_inst_var,tvs);
          list<typ> ts = List::map(snd,instantiation); //@<var,typ>
          typ ftyp = substitute(instantiation,
                                FnType(null,rtyp,args,varargs));
          typ new_typ = PointerType(ftyp,x,tq);
	  exp inner = copy_exp(e);
          e->r = Instantiate_e(inner,&Opt(ts));
          e->topt = &Opt(new_typ);
          esyn = synth_set_typ(esyn,new_typ);
        }
        break;
      default:
        break; // skip
      }
      break;
    default:
      break; // skip
    }
    break;
  }
  return esyn;
}

// Type-check the expression -- don't do any implicit instantiation. 
static synth tcExpNoInst(tenv te, Opt_t<typ> topt, exp e) {
  segment loc = e->loc;
  synth esyn;

  switch (e->r) {
  case NoInstantiate_e(e2):
    // This would handle two NoInstantiates in a row; but note that
    // for now the parser does not produce this ( x<><> won't parse ).
    return tcExpNoInst(te,null,e2);
  case UnknownId_e(q):
    // resolve the identifier and then re-type-check the expression
    resolve_unknown_id(te,e,q);
    return tcExpNoInst(te,topt,e);
  case UnknownCall_e(e1,es):
    // resolve e1 as a function or struct, enum, or xenum constructor and
    // then re-type-check the expression
    resolve_unknown_fn(te,e,e1,es);
    return tcExpNoInst(te,topt,e);
  case UnresolvedMem_e(nopt,ds):
    // resolve as an array or struct and then re-type-check the expression
    resolve_unresolved_mem(te,loc,topt,e,nopt,ds);
    return tcExpNoInst(te,topt,e);
    // Dispatch the other cases 
  case Const_e(c)               : esyn=tcConst(te,loc,topt,c); break;
  case Var_e(q,vd)              : esyn=tcVar(te,loc,topt,q,e); break;
  case Primop_e(p,es)           : esyn=tcPrimop(te,loc,topt,p,es); break;
  case Increment_e(e1,i)        : esyn=tcIncrement(te,loc,topt,e1,i); break;
  case AssignOp_e(e1,popt,e2): esyn=tcAssignOp(te,loc,topt,e,e1,popt,e2); break;
  case Conditional_e(e1,e2,e3): esyn=tcConditional(te,loc,topt,e1,e2,e3); break;
  case SeqExp_e(e1,e2)          : esyn=tcSeqExp(te,loc,topt,e1,e2); break;
  case FnCall_e(e1,es)          : esyn=tcFnCall(te,loc,topt,e1,es); break;
  case Throw_e(e1)              : esyn=tcThrow(te,loc,topt,e1); break;
  case Instantiate_e(e2,*o)     : esyn=tcInstantiate(te,loc,topt,e2,o); break;
  case Cast_e(t,e1)             : esyn=tcCast(te,loc,topt,t,e1); break;
  case Address_e(e1)            : esyn=tcAddress(te,loc,topt,e1); break;
  case Sizeof_e(t)              : esyn=tcSizeof(te,loc,topt,t); break;
  case Deref_e(e1)              : esyn=tcDeref(te,loc,topt,e1); break;
  case StructMember_e(e1,f)     : esyn=tcStructMember(te,loc,topt,e1,f); break;
  case StructArrow_e(e1,f)      : esyn=tcStructArrow(te,loc,topt,e1,f); break;
  case Subscript_e(e1,e2)       : esyn=tcSubscript(te,loc,topt,e1,e2); break;
  case Tuple_e(es)              : esyn=tcTuple(te,loc,topt,es); break;
  case CompoundLit_e(t,des)     : esyn=tcCompoundLit(te,loc,topt,t,des); break;
  case Array_e(des)             : esyn=tcArray(te,loc,topt,des); break;
  case Comprehension_e(vd,e1,e2): esyn=tcComprehension(te,loc,topt,vd,e1,e2); 
                                  break;
  case Struct_e(*tn,*otyps,args,sd_opt): 
    esyn = tcStruct(te,loc,topt,tn,otyps,args,sd_opt); break;
  case Enum_e(f,*all_ref,*exist_ref,es,ed,ef): 
    esyn = tcEnum(te,loc,topt,f,all_ref,exist_ref,es,ed,ef); break;
  case Xenum_e(f,*exist_ref,es,xd,ef): 
    esyn = tcXenum(te,loc,topt,f,exist_ref,es,xd,ef); break;
  case StmtExp_e(s)             : esyn = tcStmtExp(te,loc,topt,s); break;
  case Codegen_e(fd)            : esyn = tcCodegen(te,loc,topt,fd); break;
  case Fill_e(e1)               : esyn = tcFill(te,loc,topt,e1); break;
  }
  e->topt = &Opt(synth_typ(esyn));
  return esyn;
}

