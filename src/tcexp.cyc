/* Type checking for expressions.
   Copyright (C) 2001 Greg Morrisett, AT&T
   This file is part of the Cyclone compiler.

   The Cyclone compiler is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   The Cyclone compiler is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with the Cyclone compiler; see the file COPYING. If not,
   write to the Free Software Foundation, Inc., 59 Temple Place -
   Suite 330, Boston, MA 02111-1307, USA. */


/* TODO:
   codegen and fill
   compound literals
   generalized array and struct designators
   JGMFIX: lousy error messages...
   EXPLAIN DELTA -- need to explain the difference in rich types
   other instances of typ2string should (outside of EXPLAIN DELTA)
     should be pretty-printed in a more user-friendly manner (i.e.,
     leave off effects, regions, etc. unless they're relevant.)
 */

#include "absyn.h"
#include <string.h>
#include <stdio.h>
#include <position.h>
#include "absynpp.h"
#include "tcenv.h"
#include "tcutil.h"
#include "evexp.h"
#include "tcstmt.h"
#include "formatstr.h"
#include "tcexp.h"
#include "new_control_flow.h"
using Core;
using List;
using Position;
using Absyn;
using Absynpp;
using Tcenv;
using Tcutil;

namespace Tcexp;

static type_t expr_err(tenv_t te,seg_t loc,string_t msg,
                       ... inject parg_t<`r2> ap) 
  __attribute__((format(printf,3,4)))
{
  terr(loc,vrprintf(heap_region,msg,ap));
  return wildtyp(new Opt(lookup_type_vars(te)));
}

//////////////////// Resolving References the Parser Cannot /////////////////

// The qualified identifier q could be a variable, a tunion
// constructor, or an xtunion constructor.  We resolve q and overwrite
// the expression e with the appropriate r.
// We must always overwrite e to prevent the compiler from diverging.
static void resolve_unknown_id(tenv_t te, exp_t e, qvar_t q) {
  try switch (lookup_ordinary(te,e->loc,q)) {
  case &VarRes(b):          e->r = new Var_e(q,b); break;
  case &EnumRes(ed,ef):     e->r = new Enum_e(q,ed,ef); break;
  case &AnonEnumRes(t,ef):  e->r = new AnonEnum_e(q,t,ef); break;
  case &TunionRes(tud,tuf): e->r = new Tunion_e(NULL,NULL,NULL,tud,tuf); break;
  case &StructRes(_):
    terr(e->loc,"bad occurrence of struct name %s",qvar2string(q));
    e->r = new Var_e(q,Unresolved_b);
    break;
  } catch { 
  case Dict::Absent:
    // This is an error, but the message will be printed elsewhere.
    // Here we just put the "I don't know" answer in e->r
    e->r = new Var_e(q,Unresolved_b);
    break;
  }
}

static $(list_t<designator_t>,exp_t)@ make_struct_arg(exp_t e) {
  return new $(NULL,e);
}
// Resolve whether this is a function call or tunion, xtunion, or struct
// constructor -- let normal type-checking do the rest of the work.
// NOTE: We assume q is a relative qvar.
static void resolve_unknown_fn(tenv_t te, exp_t e, exp_t e1, list_t<exp_t,`H> es) {
  switch (e1->r) {
  case &UnknownId_e(q):
    try {
      switch (lookup_ordinary(te,e1->loc,q)) {
      case &VarRes(b):        
	e->r = new FnCall_e(e1,es,NULL); 
	return;
      case &TunionRes(tud,tuf):
        if (tuf->typs == NULL)
          // Don't allow "foo()", require "foo"
          terr(e->loc,"%s is a constant, not a function",
               qvar2string(tuf->name));
        e->r = new Tunion_e(NULL,NULL,es,tud,tuf); 
	return;
	return;
      case &StructRes(sd):
	let des = List::map(make_struct_arg,es);
	if (sd->name != NULL)
	  e->r = new Struct_e(sd->name->v,NULL,des,sd);
	else {
	  terr(e->loc,"missing struct name");
	  e->r = new Struct_e(q,NULL,des,sd);
	}
	return;
      case &AnonEnumRes(_,_):
      case &EnumRes(_,_):
        terr(e->loc,"%s is an enum constructor, not a function",
             qvar2string(q));
        return;
      }
    } catch {
    case Dict::Absent:
      // print out error message later when type-checking the fn call
      // terr(e1->loc, "unbound identifier %s",qvar2string(q));
      e->r = new FnCall_e(e1,es,NULL);
      return;
    }
  default: 
    e->r = new FnCall_e(e1,es,NULL); 
    return;
  }
}

static 
void resolve_unresolved_mem(tenv_t te, seg_t loc, type_t *`r topt, exp_t e,
			    list_t<$(list_t<designator_t,`H>,exp_t)@`H,`H> des){
  // NOTE: must always bang e->r or caller will loop!
  if (topt == NULL) {
    // guess it is an array
    e->r = new Array_e(des);
    return;
  }
  type_t t = *topt;
  switch (compress(t)) {
  case &ArrayType(at,aq,_):
    e->r = new Array_e(des);
    break;
  case &StructType(tdnopt,ts,sdp):
    if(sdp==NULL || tdnopt == NULL)
      terr(loc,"Compiler bug: struct type not properly set");
    e->r = new Struct_e((typedef_name_t)tdnopt,NULL,des,*sdp);
    break;
  case &AnonStructType(_):
    e->r = new AnonStruct_e(t,des);
    break;
  default:
    // guess it is an array
    e->r = new Array_e(des);
    break;
  }
}

//////////////////////// Actual Type-checking //////////////////////////////

// forward reference just b/c of how things are organized at the moment
static void tcExpNoInst(tenv_t te, type_t *`r topt, exp_t e);
static type_t tcExpNoPromote(tenv_t te, type_t *`r topt, exp_t e);

// Type check a list of expressions
static void tcExpList(tenv_t te, list_t<exp_t> es) {
  for(; es != NULL; es = es->tl)
    tcExp(te,NULL,es->hd);
}

// Type check the if expressions, the loop guards, and the where clauses
void tcTest(tenv_t te, exp_t e, string_t msg_part) {
  check_contains_assign(e);
  tcExp(te,&sint_t,e);
  if (!coerce_to_bool(te,e))
    terr(e->loc,"test of %s has type %s instead of integral or * type",
         msg_part, typ2string(e->topt->v));
}

// constants
static type_t tcConst(tenv_t te, seg_t loc, type_t *`r topt, cnst_t c, exp_t e){
  type_t t;
  switch (c) {
  case &Char_c(sn,_):     
    t = (sn == (sign_t)Unsigned) ? uchar_t  : schar_t;  break;
  case &Short_c(sn,_):    
    t = (sn == (sign_t)Unsigned) ? ushort_t : sshort_t; break;
  case &LongLong_c(sn,_): 
    t = (sn == (sign_t)Unsigned) ? ulonglong_t  : slonglong_t;  break;
  case &Float_c(_) : t = float_t; break;
  case &Int_c(sn,i):
    if (topt == NULL)
      t = (sn == (sign_t)Unsigned) ? uint_t : sint_t;
    else
        // If *topt calls for a shorter int, we assume it's ok to
        // truncate without warning.
        // The typical case is in an array initializer, e.g.,
        // short x[1] = { 255 };
      switch (compress(*topt)) {
      case &IntType(sn,B1):
        t = (sn == (sign_t)Unsigned) ? uchar_t : schar_t;
        e->r = new Const_e(new Char_c(sn,(char)(i))); // i gets truncated here
        break;
      case &IntType(sn,B2):
	t = (sn == (sign_t)Unsigned) ? ushort_t : sshort_t;
        e->r = new Const_e(new Short_c(sn,(short)(i))); //i gets truncated here
        break;
      case &IntType(sn,_):
        t = (sn == (sign_t)Unsigned) ? uint_t : sint_t;
        break;
      case &PointerType(_) && (i == 0):
        // we're treating 0 as if it's NULL
        e->r = new Const_e(Null_c);
        let tenv_tvs = lookup_type_vars(te);
        t = new PointerType(PtrInfo(new_evar(&ak,new Opt(tenv_tvs)), 
                                    new_evar(&rk,new Opt(tenv_tvs)), 
                                    new_conref(true),
                                    empty_tqual(), empty_conref()));
        break;
      default: // topt isn't int; presumably an error to be caught elsewhere
        t = (sn == (sign_t)Unsigned) ? uint_t : sint_t;
        break;
    }
    break;
  case &String_c(s):
    int len  = s.size; // includes the trailing 0 character
    let r    = new Const_e(new Int_c(Unsigned,len));
    exp_t elen = new_exp(r,loc);
    elen->topt = new Opt(uint_t);
    // The default is to treat a string as if it's statically heap 
    // allocated and return a pointer to that string.  However, if the 
    // string is used as an initializer, then we should return an array type.
    t = atb_typ(uchar_t, HeapRgn, const_tqual(), new Upper_b(elen));
    if (topt != NULL) {
      switch (compress(*topt)) {
      case &ArrayType(telt,tq,e2):
        return new ArrayType(uchar_t, tq, elen);
      case &PointerType(PtrInfo(telt,trgn,nullable,tq,b)):
        if (!unify(*topt,t) && silent_castable(te,loc,t,*topt)) {
          e->topt = new Opt(t);
          unchecked_cast(te, e, *topt);
          t = *topt;
        } else {
          // maybe it's going in a different region
          t = atb_typ(uchar_t,new_evar(&rk,new Opt(lookup_type_vars(te))), 
                      const_tqual(), 
                      new Upper_b(elen));
          if (!unify(*topt,t) && silent_castable(te,loc,t,*topt)) {
            e->topt = new Opt(t);
            unchecked_cast(te, e, *topt);
            t = *topt;
          }
        }
        break;
      default: break;
      }
    }
    return t;
  case Null_c:
    let tenv_tvs = lookup_type_vars(te);
    // FIX: take advantage of topt
    t = new PointerType(PtrInfo(new_evar(&ak,new Opt(tenv_tvs)), 
                                new_evar(&rk,new Opt(tenv_tvs)), 
                                new_conref(true),
                                empty_tqual(), empty_conref()));
    break;
  }
  return t;
}

// variables
static type_t tcVar(tenv_t te, seg_t loc, qvar_t q, binding_t b) {
  switch(b) {
  case Unresolved_b:
    return expr_err(te,loc,"undeclared identifier: %s",qvar2string(q));
  case &Global_b(vd):
    q[0] = vd->name[0];
    return vd->type;
  case &Funname_b(fd):
    q[0] = fd->name[0];
    return fndecl2typ(fd);
  case &Pat_b(vd):   fallthru(vd);
  case &Local_b(vd): fallthru(vd);
  case &Param_b(vd):
    (*q)[0] = Loc_n;
    return vd->type;
  }
}

static void check_format_args(tenv_t te, exp_t fmt, 
                              opt_t<list_t<exp_t>> opt_args,
			      list_t<type_t> type_getter(tenv_t,string_t,seg_t)) {
  // check the format string and get the types it requires
  list_t<type_t> desc_types;
  switch (fmt->r) {
  case &Const_e(&String_c(s)): fallthru(s);
  case &Cast_e(_,&Exp(_,&Const_e(&String_c(s)),_,_)):
    desc_types = type_getter(te,s,fmt->loc); break;
  default: 
    // don't have a string literal argument, so we can't check the args
    return;
  }
  if (opt_args != NULL) {
    let args = opt_args->v;
    // check that each expression has the right type
    for (; desc_types != NULL && args != NULL; desc_types = desc_types->tl,
           args = args->tl) {
      type_t t = desc_types->hd;
      exp_t e = args->hd;
      if (!coerce_arg(te,e,t)) {
        terr(e->loc,"descriptor has type \n%s\n but argument has type \n%s",
             typ2string(t), typ2string(e->topt->v));
        explain_failure();
      }
    }
    // check arity
    if (desc_types != NULL)
      terr(fmt->loc,"too few arguments");
    if (args != NULL)
      terr(args->hd->loc,"too many arguments");
  }
}
static type_t tcUnPrimop(tenv_t te, seg_t loc, type_t *`r topt,
			 primop_t p,exp_t e){
  type_t t = compress(e->topt->v);
  switch (p) {
  case Plus: 
  case Minus:
    if (!is_numeric(e))
      terr(loc,"expecting arithmetic type but found %s",typ2string(t));
    return e->topt->v;
  case Not:
    check_contains_assign(e);
    if (!coerce_to_bool(te,e))
      terr(loc,"expecting integral or * type but found %s",typ2string(t));
    return sint_t;
  case Bitnot:
    if (!is_integral(e))
      terr(loc,"expecting integral type but found %s",typ2string(t));
    return e->topt->v;
  case Size:
    switch (t) {
    case &ArrayType(_,_,_):
      break;
    case &PointerType(PtrInfo(_,_,_,_,_)):
      break;
    default:
      terr(loc,"size requires pointer or array type, not %s",typ2string(t));
      break;
    }
    return uint_t;
  default:
    return impos("Non-unary primop");
  }
}

// Note: promoter must return false for any non-arithmetic type.
static type_t tcArithBinop(tenv_t te, exp_t e1, exp_t e2, 
			   bool checker(exp_t)) {
  // JGMFIX: lousy error messages...
  if (!checker(e1)) {
    terr(e1->loc,"type %s cannot be used here",typ2string(e1->topt->v));
    return wildtyp(new Opt(lookup_type_vars(te)));
  }
  if (!checker(e2)) {
    terr(e2->loc,"type %s cannot be used here",typ2string(e2->topt->v));
    return wildtyp(new Opt(lookup_type_vars(te)));
  }
  type_t t1 = compress(e1->topt->v);
  type_t t2 = compress(e2->topt->v);
  return max_arithmetic_type(t1,t2);
}
// Plus needs to support a pointer and an int
static type_t tcPlus(tenv_t te, exp_t e1, exp_t e2) {
  type_t t1 = compress(e1->topt->v);
  type_t t2 = compress(e2->topt->v);
  switch (t1) {
  case &PointerType(PtrInfo{et,r,n,tq,b}):
    if (!kind_leq(typ_kind(et),MemKind))
      terr(e1->loc,"can't perform arithmetic on abstract pointer type");
    if (!coerce_sint_typ(te, e2))
      terr(e2->loc,"expecting int but found %s",typ2string(t2));
    b = compress_conref(b);
    switch (b->v) {
    case &Eq_constr(Unknown_b): return t1;
    case &Eq_constr(&Upper_b(ub)):
      // we have to allow pointer arithmetic that might go out of bounds
      // here.  Consider:
      //   int buf[10] = {...};
      //   *((buf + 11) - 10)
      // This should not generate an exception.  So the best we can do
      // is coerce e1 to a ? type.
      let new_t1 = new PointerType(PtrInfo{et,r,new_conref(true),
                                           tq,new_conref(Unknown_b)});
      unchecked_cast(te, e1, new_t1);
      return new_t1;
    default:
      b->v = new Eq_constr(Unknown_b); return t1;
    }
  default:
    return tcArithBinop(te, e1, e2, is_numeric);
  }
}
// Minus needs to support a tagged array and an int, and two tagged arrays
static type_t tcMinus(tenv_t te, exp_t e1, exp_t e2) {
  type_t t1 = e1->topt->v;
  type_t t2 = e2->topt->v;
  type_t t1_elt = VoidType;
  type_t t2_elt = VoidType;
  if (is_tagged_pointer_typ_elt(t1,&t1_elt)) {
    if (is_tagged_pointer_typ(t2)) {
      if (!unify(t1, t2)) {
	terr(e1->loc,"pointer arithmetic on values of "
             "different types (%s != %s)",
             typ2string(e1->topt->v),typ2string(e2->topt->v));
        explain_failure();
      }
      return sint_t;
    } else {
      if (!kind_leq(typ_kind(t1_elt),MemKind))
        terr(e1->loc,"can't perform arithmetic on abstract pointer type");
      if (!coerce_sint_typ(te, e2)) {
	terr(e2->loc,"expecting either %s or int but found %s",
             typ2string(t1),typ2string(t2));
        explain_failure();
      }
      return t1;
    }
  } else return tcArithBinop(te, e1, e2, is_numeric);
}

static type_t tcAnyBinop(tenv_t te, seg_t loc, exp_t e1, exp_t e2) {
  bool e1_is_num = is_numeric(e1);
  bool e2_is_num = is_numeric(e2);
  type_t t1 = compress(e1->topt->v);
  type_t t2 = compress(e2->topt->v);
  if (e1_is_num && e2_is_num)
    return sint_t;
  // okay if same types and boxed
  else if (unify(t1,t2) && 
           unify(t1,new_evar(&bk,new Opt(lookup_type_vars(te))))) {
    return sint_t;
  // okay if t1 can be silently cast to t2 or vice versa 
  } else if (silent_castable(te,loc,t2,t1)) {
    unchecked_cast(te,e2,t1);
    return sint_t;
  } else if (silent_castable(te,loc,t1,t2)) {
    unchecked_cast(te,e1,t2);
    return sint_t;
  } else if (zero_to_null(te,t2,e1) || zero_to_null(te,t1,e2)) {
    return sint_t;
  // support comparisons on pointers
  } else {
    switch ($(compress(t1), compress(t2))) {
    case $(&PointerType(PtrInfo{t1a,_,_,_,_}),
	   &PointerType(PtrInfo{t2a,_,_,_,_})):
      if (unify(t1a,t2a)) return sint_t; break;
    default: break;
    }
  FAIL:
    terr(loc,"comparison not allowed between %s and %s",
         typ2string(t1),typ2string(t2));
    explain_failure();
    return wildtyp(new Opt(lookup_type_vars(te)));
  }
}

// Binary primops like e1+e2, e1>>e2, etc.
// Note: e1 and e2 must have already been type-checked.
static type_t tcBinPrimop(tenv_t te, seg_t loc, type_t *`r topt,
                          primop_t p, exp_t e1, exp_t e2) {
  switch (p) {
  case Plus:  return tcPlus(te,e1,e2);
  case Minus: return tcMinus(te,e1,e2);

  case Times:      
  case Div: return tcArithBinop(te,e1,e2,is_numeric);

  case Mod:        
  case Bitand:     
  case Bitor:      
  case Bitxor:     
  case Bitlshift:  
  case Bitlrshift: 
  case Bitarshift: return tcArithBinop(te,e1,e2,is_integral);

    // Note: comparing pointers relies on memory-manager properties
    //       (but darned useful for dictionaries)
  case Eq:         
  case Neq:        
  case Gt:         
  case Lt:         
  case Gte:        
  case Lte: return tcAnyBinop(te,loc,e1,e2);

  default: throw new Failure("bad binary primop");
  }
}

static type_t tcPrimop(tenv_t te, seg_t loc, type_t *`r topt,
                       primop_t p, list_t<exp_t> es) {
  // An ugly hack to push topt below unary minus.  This comes in
  // handy because it stops warnings from being printed on array
  // initializers generated by bison (where (short)4 looks like
  // we're losing precision).
  // HOWEVER it should be nuked when we re-write the type checker
  // to solve the general problem.
  if (p == (primop_t)Minus && List::length(es) == 1)
    return tcExp(te,topt,es->hd);
  tcExpList(te,es);
  type_t t;
  switch (List::length(es)) {
  case 0:  return expr_err(te,loc,"primitive operator has 0 arguments");
  case 1:  t = tcUnPrimop(te,loc,topt,p,es->hd); break;
  case 2:  t = tcBinPrimop(te,loc,topt,p,es->hd,es->tl->hd); break;
  default: return expr_err(te,loc,"primitive operator has > 2 arguments");
  }
  return t;
}

// check that e is not a const expression -- assumes e is already
// an lvalue and is type-checked
static void check_writable(tenv_t te, exp_t e) {
  
  switch (e->r) {
  case &Var_e(_,&Param_b(vd)): fallthru(vd);
  case &Var_e(_,&Local_b(vd)): fallthru(vd);
  case &Var_e(_,&Pat_b(vd)):   fallthru(vd);
  case &Var_e(_,&Global_b(vd)):
    if (!vd->tq.q_const) return;
    break;
  case &Subscript_e(e1,e2):
    switch (compress(e1->topt->v)) {
    case &PointerType(PtrInfo{_,_,_,tq,_}): fallthru(tq);
    case &ArrayType(_,tq,_): if (!tq.q_const) return; break;
    case &TupleType(ts):
      unsigned int i = Evexp::eval_const_uint_exp(e2);
      try {
        let &$(tq,_) = List::nth(ts,i);
        if (!tq.q_const) return;
      } catch { case Nth: return;
      }
      break;
    default: break;
    }
    break;
  case &StructMember_e(e1,f):
    switch (compress(e1->topt->v)) {
    case &StructType(_,_,sd):
      struct Structfield *sf = 
        (sd == NULL) ? NULL : lookup_struct_field((structdecl_t) *sd, f);
      if (sf == NULL || !sf->tq.q_const) return;
      break;
    case &AnonUnionType(fs): fallthru(fs);
    case &AnonStructType(fs):
      struct Structfield *sf = lookup_field(fs, f);
      if (sf == NULL || !sf->tq.q_const) return;
      break;
    case &UnionType(_,_,ud):
      struct Structfield *sf = 
        (ud == NULL) ? NULL : lookup_union_field((uniondecl_t) *ud, f);
      if (sf == NULL || !sf->tq.q_const) return;
      break;
    default: break;
    }
    break;
  case &StructArrow_e(e1,f):
    switch (compress(e1->topt->v)) {
    case &PointerType(PtrInfo{elt_typ,_,_,_,_}):
      switch (compress(elt_typ)) {
      case &StructType(_,_,sd):
        struct Structfield *sf = 
          (sd == NULL) ? NULL : lookup_struct_field((structdecl_t) *sd,f);
        if (sf == NULL || !sf->tq.q_const) return;
        break;
      case &UnionType(_,_,ud):
        struct Structfield *sf = 
          (ud == NULL) ? NULL : lookup_union_field((uniondecl_t) *ud,f);
        if (sf == NULL || !sf->tq.q_const) return;
        break;
      case &AnonStructType(fs): fallthru(fs);
      case &AnonUnionType(fs): 
        struct Structfield *sf = lookup_field(fs, f);
        if (sf == NULL || !sf->tq.q_const) return;
        break;
      default: break;
      }
      break;
    default: break;
    }
    break;
  case &Deref_e(e1):
    switch (compress(e1->topt->v)) {
    case &PointerType(PtrInfo{_,_,_,tq,_}): fallthru(tq);
    case &ArrayType(_,tq,_): if (!tq.q_const) return; break;
    default: break;
    }
    break;
  case &NoInstantiate_e(e1): fallthru(e1);
  case &Instantiate_e(e1,_): check_writable(te,e1); return;
  default: break;
  }
  terr(e->loc, "attempt to write a const location: %s", exp2string(e));
}

static type_t tcIncrement(tenv_t te, seg_t loc, type_t *`r topt,
                          exp_t e, incrementor_t i) {
  // Don't promote any arrays to pointers, as per K&R
  tcExpNoPromote(te,NULL,e);
  if(!is_lvalue(e))
    return expr_err(te,loc,"increment/decrement of non-lvalue");
  check_writable(te, e);
  type_t t = e->topt->v;
  // FIX: this is not right -- for instance, it allows incrementing an enum!!
  if (!is_numeric(e)) {
    type_t telt = VoidType;
    if (is_tagged_pointer_typ_elt(t,&telt)) {
      if (!kind_leq(typ_kind(telt),MemKind))
        terr(e->loc,"can't perform arithmetic on abstract pointer type");
    } else 
      terr(e->loc,"expecting arithmetic or ? type but found %s",
           typ2string(t));
  }
  return t;
}

// e1 ? e2 : e3
static type_t tcConditional(tenv_t te, seg_t loc, type_t *`r topt,
                            exp_t e1, exp_t e2, exp_t e3) {
  tcTest(te, e1, "conditional expression");
  tcExp(te,topt,e2);
  tcExp(te,topt,e3);
  type_t t = new_evar(&mk,new Opt(lookup_type_vars(te)));
  let l1 = new List(e3,NULL);
  let l2 = new List(e2,l1);
  if (!coerce_list(te,t,l2)) {
    terr(loc,"conditional clause types do not match: %s != %s",
         typ2string(e2->topt->v),typ2string(e3->topt->v));
    explain_failure();
  }
  return t;
}

// Assignments with optional operations, e.g., x = 3, x += 5
static type_t tcAssignOp(tenv_t te, seg_t loc, type_t *`r topt,
                         exp_t e1, opt_t<primop_t> po, exp_t e2) {
  // FIX: Not right b/c of funcions vs. function pointers???
  // As per K&R, don't promote any array types to pointer types in the lhs
  tcExpNoPromote(te,NULL,e1);
  tcExp(te,&e1->topt->v,e2);
  type_t t1 = e1->topt->v;
  type_t t2 = e2->topt->v;
  // Check to see that the type is not an array type
  switch (compress(t1)) {
  case &ArrayType(_,_,_): terr(loc,"cannot assign to an array"); break;
  default: break;
  }
  // check to see that the type is not an abstract type
  if (!kind_leq(typ_kind(t1),MemKind))
    terr(loc,"type is abstract (can't determine size).");
  // Check to see if e1 is an lvalue after typechecking, so that
  // UnknownIds have been resolved.
  if (!is_lvalue(e1))
    return expr_err(te,loc,"assignment to non-lvalue");
  check_writable(te, e1);
  if (po == NULL) {
    if (!coerce_assign(te,e2,t1)) {
      let result = expr_err(te,loc,"type mismatch: %s != %s",
                            typ2string(t1), typ2string(t2));
      unify(t1,t2); // needed to get right error message
      explain_failure();
      return result;
    }
  } else {
    let p        = po->v;
    let t_result = tcBinPrimop(te,loc,NULL,p,e1,e2);
    if (!(unify(t_result,t1) || coerceable(t_result) && coerceable(t1))) {
      let result = 
        expr_err(te,loc, "Cannot use this operator in an assignment when "
		      "the arguments have types %s and %s",typ2string(t1),
		      typ2string(t2));
      unify(t_result,t1); // needed to get right error message
      explain_failure();
      return result;
    }
    return t_result;
  }
  return t1;
}

// e1,e2
static type_t tcSeqExp(tenv_t te,seg_t loc,type_t *`r topt,exp_t e1,exp_t e2) {
  tcExp(te,NULL,e1);
  tcExp(te,topt,e2);
  return e2->topt->v;
}

static tunion Type.DoubleType dbl = DoubleType(false);
static type_t dbl_t = &dbl;

// try to find a field that e can be injected into
static struct Tunionfield *tcInjection(tenv_t te,exp_t e,type_t tu,
                                       region_t<`r> r,
                                       list_t<$(tvar_t,type_t)@`r,`r> inst, 
                                       list_t<tunionfield_t> fs) {
  list_t<tunionfield_t> fields;
  type_t t1 = e->topt->v;
  // must promote float to double, and char/short to int
  switch (compress(t1)) {
  case FloatType: unchecked_cast(te,e,dbl_t); t1 = dbl_t; break;
  case &IntType(_,B1): 
  case &IntType(_,B2): unchecked_cast(te,e,sint_t); t1 = sint_t; break;
  default: break;
  }
  // try to find an exact match first
  for (fields = fs; fields != NULL; fields = fields->tl) {
    let Tunionfield{n,tvs,typs,loc,sc} = *fields->hd;
    // should have exactly one argument and I don't want to deal with
    // existential types
    if (typs == NULL || typs->tl != NULL || tvs != NULL) continue;
    type_t t2 = rsubstitute(r,inst,(*typs->hd)[1]);
    // I hate doing this because it has side-effects, but oh well...
    if (unify(t1,t2)) {
      return fields->hd;
    }
  }
  // now try to find a match supported by silent conversions
  for (fields = fs; fields != NULL; fields = fields->tl) {
    let Tunionfield{n,tvs,typs,loc,sc} = *fields->hd;
    // should have exactly one argument and I don't want to deal with
    // existential types
    if (typs == NULL || typs->tl != NULL || tvs != NULL) continue;
    type_t t2 = rsubstitute(r,inst,(*typs->hd)[1]);
    // I hate doing this because it has side-effects, but oh well...
    if (coerce_arg(te,e,t2)) {
      return fields->hd;
    } 
  }
  terr(e->loc,"can't find a field in %s to inject a value of type %s",
       typ2string(tu), typ2string(t1));
  return NULL;
}

// e(es)
static type_t tcFnCall(tenv_t te,seg_t loc,type_t *`r topt,exp_t e,list_t<exp_t> args,vararg_call_info_t *@vararg_call_info){
  // if e is a vararg function then we need to declare a new local
  // region block -- we just do it always here.
  let es = args;
  te = new_block(loc,te); // needed for regions of params
  tcExp(te,NULL,e);
  type_t t = compress(e->topt->v);
  // NB: we should really unify t with an unconstrained FnType with the
  // right arity but there may be coercions involved with the arguments
  // and the function might actually be a vararg.
  switch (t) {
  case &PointerType(PtrInfo{t1,rgn,x,tq,b}):
    // Note: rgn is irrelevant -- all code is in the heap.
    // Nonetheless, perhaps we cast to another region, so check
    // the capability just for fun.
    check_rgn_accessible(te,loc,rgn);
    // Check that the bounds on the pointer aren't 0
    check_nonzero_bound(loc,b);
    switch (compress(t1)) {
    case &FnType(FnInfo{tvars,eff,res_typ,args_info,c_vararg,cyc_vararg,
                          rgn_po,atts}): 
      //FIX: handle tvars??
      // unify the result type with the expected type to get better
      // information while type-checking the arguments.
      if (topt != NULL) unify(res_typ,*topt);
      // check that each argument has the right type or can be coerced to it
      // FIX: need to deal with NULL!!!
      while ((es != NULL) && (args_info != NULL)) {
        exp_t e1 = es->hd;
        type_t t2 = (*args_info->hd)[2];
	tcExp(te, &t2, e1);
        if (!coerce_arg(te,e1,t2)) {
          terr(e1->loc,"actual argument has type \n%s\n but formal has type \n%s",
               typ2string(e1->topt->v),typ2string(t2));
          explain_failure();
        }
        es = es->tl;
        args_info = args_info->tl;
      }
      if (args_info != NULL) terr(loc,"too few arguments for function");
      // if we have left-over arguments, then check for varargs
      else if (es != NULL || c_vararg || cyc_vararg != NULL) {
	if(c_vararg)
	  for(; es != NULL; es = es->tl)
	    tcExp(te, NULL, es->hd);
	else if(cyc_vararg == NULL)
	  terr(loc, "too many arguments for function");
	else {
          let VarargInfo{_,_,vt,inject} = *cyc_vararg;
          let vci = new VarargCallInfo {.num_varargs = 0, 
                                        .injectors = NULL,
                                        .vai = (vararg_info_t @)cyc_vararg};
          *vararg_call_info = vci;

          if (!inject) {
            // all the rest of the arguments are the same type
            for (; es != NULL; es = es->tl) {
              exp_t e1 = es->hd;
              vci->num_varargs++;
              tcExp(te, &vt, e1);
              if (!coerce_arg(te,e1,vt)) {
                terr(loc,"vararg requires type %s but argument has type %s",
                     typ2string(vt),typ2string(e1->topt->v));
                explain_failure();
              }
            }
          } else {
            // this is trickier, we have to match up the type of the
            // actual argument with a constructor from the [x]tunion.
            switch (compress(vt)) {
            case &TunionType(TunionInfo{&KnownTunion(&td),targs,tur}):
              // unfortunately, td may not be the "latest" declaration of
              // an xtunion, so we re-look it up in the environment.
              let td = *lookup_tuniondecl(te,loc,td->name);
              list_t<tunionfield_t> fields = NULL;
              if (td->fields == NULL) 
                terr(loc,"can't inject into %s",typ2string(vt));
              else fields = td->fields->v;
	      if(!unify(tur,curr_rgn(te)))
		terr(loc,"bad region for injected varargs");
              region rgn {
                let inst = List::rzip(rgn,rgn,td->tvs,targs);
                for (; es != NULL; es = es->tl) {
                  vci->num_varargs++;
                  exp_t e1 = es->hd;
                  tcExp(te,NULL,e1);
                  let f = tcInjection(te,e1,vt,rgn,inst,fields);
                  if (f != NULL)
                    vci->injectors = 
                      List::append(vci->injectors,
                                   new List{(tunionfield_t)f,NULL});
                }
              }
              break;
            default: terr(loc,"bad inject vararg type"); break;
            }
          }
        }
      }
      // check for a format attribute
      for (_ a = atts; a != NULL; a = a->tl) {
        switch (a->hd) {
        case &Format_att(ft,fmt_arg_pos,arg_start_pos):
          try {
            // get the format descriptor string
            let fmt_arg = List::nth(args,fmt_arg_pos - 1);
            // get the varargs
            opt_t<list_t<exp_t>> fmt_args;
            if (arg_start_pos == 0)
              fmt_args = NULL;
            else
              fmt_args = new Opt(nth_tail(args,arg_start_pos - 1));
            switch (ft) {
            case Printf_ft:
              check_format_args(te,fmt_arg,fmt_args,Formatstr::get_format_typs);
              break;
            case Scanf_ft:
              check_format_args(te,fmt_arg,fmt_args,Formatstr::get_scanf_typs);
              break;
            }
          } catch {
          case Nth: terr(loc,"bad format arguments"); break;
          }
          break;
        default: break;
        }
      }
      // Check that the effect of the function is compatible with the current
      // capability.
      Tcenv::check_effect_accessible(te, loc, eff->v);
      // Check that the partial-order on region lifetimes required by the
      // function is compatible with the current region partial order
      Tcenv::check_rgn_partial_order(te, loc, rgn_po);
      return res_typ;
    default: return expr_err(te,loc,"expected pointer to function");
    }
  default: return expr_err(te,loc,"expected pointer to function");
  }
}

// throw e1
static type_t tcThrow(tenv_t te, seg_t loc, type_t *`r topt, exp_t e) {
  tcExp(te,&exn_typ,e); 
  if (!coerce_arg(te,e,exn_typ))
    terr(loc,"expected xtunion exn but found %s",typ2string(e->topt->v));
  return wildtyp(new Opt(lookup_type_vars(te)));
}

// explicit instantiation
static type_t tcInstantiate(tenv_t te, seg_t loc, type_t *`r topt,
                            exp_t e, list_t<type_t> ts) {
  tcExpNoInst(te,NULL,e);
  // turn any functions into function pointers
  e->topt->v = pointer_expand(e->topt->v);
  type_t t1 = compress(e->topt->v);
  switch (t1) {
  case &PointerType(PtrInfo{t0,rt,x,tq,b}):
    switch (compress(t0)) {
    case &FnType(FnInfo{tvars,eff,rtyp,args,c_varargs,cyc_varargs,rpo,atts}):
      list_t<$(tvar_t,type_t)@> instantiation = NULL;
      if (List::length(ts) != List::length(tvars))
	return expr_err(te,loc,"type instantiation mismatch");
      for (; ts != NULL; ts = ts->tl, tvars = tvars->tl) {
	kind_t k = tvar_kind(tvars->hd);
	check_type(loc,te,lookup_type_vars(te),k,true,ts->hd);
	instantiation = new List(new $(tvars->hd,ts->hd),instantiation);
      }
      type_t new_fn_typ = 
        substitute(instantiation,
                   new FnType(FnInfo{NULL,eff,rtyp,args,c_varargs,
                                     cyc_varargs,rpo,atts}));
      type_t new_typ = new PointerType(PtrInfo{new_fn_typ,rt,x,tq,b});
      return new_typ;
    default: break;
    }
    break;
  default: break;
  }
  return expr_err(te,loc,"expecting polymorphic type but found %s",
                  typ2string(t1));
}

// (t)e
static type_t tcCast(tenv_t te, seg_t loc, type_t *`r topt, type_t t, exp_t e) {
  check_type(loc,te,lookup_type_vars(te),MemKind,true,t);
  tcExp(te,NULL,e);
  type_t t2 = e->topt->v;
  if (!silent_castable(te,loc,t2,t) && 
      !castable(te,loc,t2,t) && !zero_to_null(te,t,e)) {
    // extra unify needed to get the right reason for the failure
    unify(t2,t);
    let result = expr_err(te,loc,"cannot cast %s to %s",
                          typ2string(t2), typ2string(t));
    explain_failure();
    return result;
  }
  return t;
}

// &e
static type_t tcAddress(tenv_t te, seg_t loc, exp_t e0, 
                        type_t *`r topt, exp_t e) {
  // This is really two things b/c we're still overloading
  // & throughout the compiler as address-of and malloc-and-initialize.
  let topt2 = NULL;
  let tq2 = empty_tqual();
  if (topt != NULL) {
    switch (compress(*topt)) {
    case &PointerType(PtrInfo{elttype,_,_,tq,_}):
      //FIX: this allocation is needed because *elttype is compiled incorrectly!
      topt2 = new elttype;
      tq2 = tq;
      break;
    default: break;
    }
  }
  // Use tcExpNoInst here because if f is a function then
  // then &f is supposed to be a pointer to a function, not
  // a pointer to a pointer to a function
  // Notice that this also bypasses the array-to-pointer promotion
  // as required (see p. 200, A7.1 of K&R.)
  tcExpNoInst(te,topt2,e);

  // first, dispense with the malloc-and-initialize cases or the
  // case where we have &e[i] and e is an array/pointer (i.e., not
  // a tuple.
  switch (e->r) {
  case &Struct_e(_,_,_,_): 
  case &Tuple_e(_):
    // Note: We're heap region b/c this is translated to an actual malloc
    warn(loc,"& used to allocate");
    // Avoid casts when we're passed down a nullable type
    let ptr_maker = at_typ;
    if(topt != NULL)
      switch (compress(*topt)) {
      case &PointerType(PtrInfo{_,_,n,_,_}): 
	if(conref_val(n))
	  ptr_maker = star_typ; 
	break;
      default: break;
      }
    return ptr_maker(e->topt->v,HeapRgn,tq2);
  case &Subscript_e(e1,e2):
    switch (compress(e1->topt->v)) {
    case &TupleType(_): break; // leave & for tuple types alone.
    default: 
      // we have &e[i] -- rewrite the whole expression as (e+i)
      // This ensures that we get the right size for an array or ?
      // pointer.
      e0->r = new Primop_e(Plus, new List(e1, new List(e2, NULL)));
      return tcPlus(te,e1,e2);
    }
    break;
  default: break;
  }

  // we've got an address-of
  let $(is_const,rgn) = addressof_props(te,e);
  tqual_t tq = empty_tqual();
  if(is_const)
    tq.q_const = true;
  // FIX: use topt to determine if we should return a tunion type
  type_t t = at_typ(e->topt->v, rgn, tq);
  return t;
}

 // sizeof t
static type_t tcSizeof(tenv_t te, seg_t loc, type_t *`r topt, type_t t) {
  check_type(loc,te,lookup_type_vars(te),MemKind,true,t);
  if(!Evexp::okay_szofarg(t))
    terr(loc, "sizeof applied to type %s, which has unknown size here",
         typ2string(t));
  if (topt != NULL) {
    switch (compress(*topt)) {
    // only return sizeof_t<t> when requested from context
    case &SizeofType(_): return new SizeofType(t);
    default: break;
    }
  }
  return uint_t; 
}

bool structfield_has_name(field_name_t n, structfield_t sf) {
  return (strcmp(*n,*sf->name) == 0);
}

// offsetof(t,n)
// FIX: check that n is actually a field of f (currently caught by gcc)
// FIX?: check if t is allowed to be a union type
static type_t tcOffsetof(tenv_t te, seg_t loc, type_t *`r topt, 
			 type_t t, offsetof_field_t n) {
  check_type(loc,te,lookup_type_vars(te),MemKind,true,t);
  switch(n) {
  case &StructField(n):
    bool bad_type = true;
    switch(compress(t)) {
    case &StructType(name,_,sdp):
      if(sdp == NULL)
	return Tcutil::impos("offsetof on unchecked StructType");
      if((*sdp)->fields == NULL)
	break;
      if(!exists_c(structfield_has_name,n,(*sdp)->fields->v))
	terr(loc,"no field of struct has name %s",*n);
      bad_type = false;
      break;
    case &AnonStructType(fields):
      if(!exists_c(structfield_has_name,n,fields))
	terr(loc,"no field of struct has name %s",*n);
      bad_type = false;
      break;
    case &UnionType(name,_,udp):
      if(udp == NULL)
	return Tcutil::impos("offsetof on unchecked UnionType");
      if((*udp)->fields == NULL)
	break;
      if(!exists_c(structfield_has_name,n,(*udp)->fields->v))
	terr(loc,"no field of union has name %s",*n);
      bad_type = false;
      break;
    case &AnonUnionType(fields):
      if(!exists_c(structfield_has_name,n,fields))
	terr(loc,"no field of anonymous union has name %s",*n);
      bad_type = false;
      break;
      
    default: break;
    }
    if(bad_type)
      terr(loc, "%s is not a known struct/union type", typ2string(t));
    break;
  case &TupleIndex(n):
    bool bad_type = true;
    switch(compress(t)) {
    case &StructType(_,_,sdp):
      if(sdp == NULL)
	return Tcutil::impos("offsetof on unchecked StructType");
      if((*sdp)->fields == NULL)
	break;
      if(List::length((*sdp)->fields->v) <= n) 
	terr(loc,"struct has too few components: %d <= %d",List::length((*sdp)->fields->v),n);
      bad_type = false;
      break;
    case &AnonStructType(fields):
      if(List::length(fields) <= n) 
	Tcutil::terr(loc,"struct has too few components: %d <= %d",List::length(fields),n);
      bad_type = false;
      break;
    case &UnionType(_,_,udp):
      if(udp == NULL)
	return Tcutil::impos("offsetof on unchecked UnionType");
      if((*udp)->fields == NULL)
	break;
      if(List::length((*udp)->fields->v) <= n) 
	terr(loc,"union has too few components: %d <= %d",List::length((*udp)->fields->v),n);
      bad_type = false;
      break;
    case &AnonUnionType(fields):
      if(List::length(fields) <= n) 
	Tcutil::terr(loc,"union has too few components: %d <= %d",List::length(fields),n);
      bad_type = false;
      break;

    case &TupleType(l):
      if(List::length(l) <= n)
	Tcutil::terr(loc,"tuple has too few components: %d <= %d",List::length(l),n);
      bad_type = false;
      break;
    case &TunionFieldType(TunionFieldInfo(&KnownTunionfield(tudecl,tuf),_)):
      //FIX: check that there are enough components in the field
      if(List::length(tuf->typs) < n)
	Tcutil::terr(loc,"tunionfield has too few components: %d < %d",List::length(tuf->typs),n);
      bad_type = false;
      break;
    default: break;
    }
    if(bad_type)
      terr(loc, "%s is not a known struct/union/tuple/tunion type", typ2string(t));
    break;
  }
  
  return uint_t;
}

 // *e
static type_t tcDeref(tenv_t te, seg_t loc, type_t *`r topt, exp_t e) {
  tcExp(te,NULL,e);
  type_t t = compress(e->topt->v);
  switch (t) {
  case &PointerType(PtrInfo{t2,rt,_,_,b}):
    check_rgn_accessible(te,loc,rt);
    check_nonzero_bound(loc, b);
    if (!kind_leq(typ_kind(t2),MemKind))
      terr(loc,"can't dereference abstract pointer type");
    return t2;
  default: 
    return expr_err(te,loc,"expecting * or @ type but found %s",typ2string(t));
  }
}

// e.f
static type_t tcStructMember(tenv_t te, seg_t loc, type_t *`r topt,
			     exp_t outer_e, exp_t e, field_name_t f) {
  // As per K&R, don't promote e from array to pointer type
  tcExpNoPromote(te,NULL,e);
  type_t t = compress(e->topt->v);
  switch (t) {
  case &StructType(tdnopt,ts,&sd):
    if (tdnopt == NULL)
      return expr_err(te,loc,"unresolved struct type (COMPILER ERROR)");
    let finfo = lookup_struct_field(sd,f);
    if (finfo == NULL)
      return expr_err(te,loc,"struct %s has no %s field",
                      qvar2string((qvar_t)tdnopt), *f);
    _ t2;
    region rgn {
      let inst = List::rzip(rgn,rgn,sd->tvs,ts);
      t2 = rsubstitute(rgn,inst,finfo->type);
    }
    return t2;
  case &AnonStructType(fs):
    let finfo = lookup_field(fs,f);
    if (finfo == NULL)
      return expr_err(te,loc,"struct has no %s field",*f);
    return finfo->type;
  case &AnonUnionType(fs):
    let finfo = lookup_field(fs,f);
    if (finfo == NULL)
      return expr_err(te,loc,"union has no %s field",*f);
    return finfo->type;
    
  case &UnionType(tdnopt,ts,&ud):
    if (tdnopt == NULL)
      return expr_err(te,loc,"unresolved union type (COMPILER ERROR)");
    let finfo = lookup_union_field(ud,f);
    if (finfo == NULL)
      return expr_err(te,loc,"union %s has no %s field",
                      qvar2string((qvar_t)tdnopt), *f);
    let inst = List::zip(ud->tvs,ts);
    let t2   = substitute(inst,finfo->type);
    return t2;
  case &ArrayType(_,_,_) && (zstrcmp(*f,"size") == 0):
    outer_e->r = new Primop_e(Size,new List(e,NULL));
    return uint_t;
  case &PointerType(_) && (zstrcmp(*f,"size") == 0):
    outer_e->r = new Primop_e(Size,new List(e,NULL));
    return uint_t;
  default:
    if (zstrcmp(*f,"size") == 0)
      return expr_err(te,loc,"expecting struct, union or array, found %s",
                      typ2string(t));
    else
       return expr_err(te,loc,"expecting struct or union, found %s",
                       typ2string(t));
  }
}

// e->f
static type_t tcStructArrow(tenv_t te, seg_t loc, type_t *`r topt, 
			    exp_t e, field_name_t f) {
  tcExp(te,NULL,e);
  type_t t = compress(e->topt->v);
  switch (t) {
  case &PointerType(PtrInfo{t2,rt,_,_,b}):
    check_nonzero_bound(loc, b);
    switch (compress(t2)) {
    case &StructType(tdnopt,ts,&sd):
      let finfo = lookup_struct_field(sd,f);
      if (finfo == NULL)
	return expr_err(te,loc,"struct %s has no %s field",
                        qvar2string((qvar_t)tdnopt),*f);
      _ t3;
      region rgn {
        let inst = List::rzip(rgn,rgn,sd->tvs,ts);
        t3 = rsubstitute(rgn,inst,finfo->type);
      }
      check_rgn_accessible(te,loc,rt);
      return t3;
    case &UnionType(tdnopt,ts,&ud):
      let finfo = lookup_union_field(ud,f);
      if (finfo == NULL)
	return expr_err(te,loc,"union %s has no %s field",
                        qvar2string((qvar_t)tdnopt),*f);
      let inst = List::zip(ud->tvs,ts);
      let t3   = substitute(inst,finfo->type);
      check_rgn_accessible(te,loc,rt);
      return t3;
    case &AnonStructType(fs):
      let finfo = lookup_field(fs,f);
      if (finfo == NULL)
	return expr_err(te,loc,"struct has no %s field",*f);
      return finfo->type;
    case &AnonUnionType(fs):
      let finfo = lookup_field(fs,f);
      if (finfo == NULL)
	return expr_err(te,loc,"union has no %s field",*f);
      return finfo->type;
    default:
      return expr_err(te,loc,"expecting struct pointer, found %s",
                      typ2string(t));
    }
  default:
    return expr_err(te,loc,"expecting struct pointer, found %s",
				   typ2string(t));
  }
}

// e1[e2]
static type_t ithTupleType(tenv_t te, seg_t loc,
			   list_t<$(tqual_t,type_t)@> ts, exp_t index) {
  unsigned int i = Evexp::eval_const_uint_exp(index);
  try
    return (*List::nth(ts,i))[1];
  catch { case Nth:
    return expr_err(te,loc,"index is %d but tuple has only %d fields",
                    i, List::length(ts));
  }
}
 // FIX: look at topt
static type_t tcSubscript(tenv_t te, seg_t loc, type_t *`r topt, 
			  exp_t e1, exp_t e2) {
  tcExp(te,NULL,e1);
  tcExp(te,NULL,e2);
  type_t t1 = compress(e1->topt->v);
  type_t t2 = compress(e2->topt->v);
  if (!coerce_sint_typ(te,e2))
    return expr_err(te,e2->loc,"expecting int subscript, found %s",
                    typ2string(t2));
  // the subscript could be on a tuple or a pointer -- any arrays
  // should've been coerced to pointers
  switch (t1) {
  case &PointerType(PtrInfo{t,rt,_,tq,b}):
    // FIX: Consider tq?
    if (is_const_exp(te, e2))
      check_bound(loc,Evexp::eval_const_uint_exp(e2),b);
    else {
      // an easy warning that helps when porting C code
      if(is_bound_one(b))
	warn(e1->loc,"subscript applied to pointer to one object");
      check_nonzero_bound(loc,b);
    }
    check_rgn_accessible(te,loc,rt);
    if (!kind_leq(typ_kind(t),MemKind))
      terr(e1->loc,"can't subscript an abstract pointer");
    return t;
  case &TupleType(ts): return ithTupleType(te,loc,ts,e2);
  default:
    return expr_err(te,loc,"subscript applied to %s",typ2string(t1));
  }
}

// $(es)
static type_t tcTuple(tenv_t te, seg_t loc, type_t *`r topt, list_t<exp_t> es) {
  bool done = false;
  list_t<$(tqual_t,type_t)@> fields = NULL;
  if(topt != NULL)
    switch (compress(*topt)) {
    case &TupleType(ts):
      if(length(ts) != length(es)) {
        // topt should never cause failure, just guides coercions.
	// terr(loc,"tuple expression has the wrong number of fields");
	break;
      }
      for(; es != NULL; es = es->tl, ts = ts->tl) {
	let topt2 = (*ts->hd)[1];
	tcExpInitializer(te,&topt2,es->hd);
	fields = new List(new $((*ts->hd)[0], es->hd->topt->v), fields);
      }
      done = true;
      break;
    default:
      break;
    }
  if(!done)
    for(; es != NULL; es = es->tl) {
      tcExpInitializer(te,NULL,es->hd);
      fields = new List(new $(empty_tqual(), es->hd->topt->v), fields);
    }
  return new TupleType(List::imp_rev(fields));
}

// Compound literals, e.g., (struct foo){3,"abc"}
static type_t tcCompoundLit(tenv_t te, seg_t loc, type_t *`r topt,
                             $(opt_t<stringptr_t>,tqual_t,type_t)@ t,
                             list_t<$(list_t<designator_t>,exp_t)@> des) {
  return expr_err(te,loc,"tcCompoundLit");
}

 ///////////////////// Array ({e1,...,en}) /////////////////////////
 // FIX:  only a very limited class of designators (basically, the proper
 // index) is supported and all of the array elements must be present.
 // 
 // Note that we pass in an optional element type, not the (optional)
 // expected type of the array.  See tcNew and the call to tcArray.
static type_t tcArray(tenv_t te,seg_t loc,type_t *`r elt_topt, 
                   list_t<$(list_t<designator_t>,exp_t)@> des) {
  list_t<exp_t> es      = List::map(snd,des);
  type_t        res     = new_evar(&mk,new Opt(lookup_type_vars(te)));
  let           sz_rexp = new Const_e(new Int_c(Unsigned,List::length(es)));
  exp_t         sz_exp  = new_exp(sz_rexp,loc);
  sz_exp->topt = new Opt(uint_t);
  type_t res_t2   = new ArrayType(res, empty_tqual(), sz_exp);

  for (_ es2 = es; es2 != NULL; es2 = es2->tl)
    tcExpInitializer(te,elt_topt,es2->hd);

  if (!coerce_list(te,res,es))
    // JGMFIX: lousy error messages...
    terr(es->hd->loc,"elements of array do not all have the same type (%s)",
         typ2string(res));
  // check that any designators make sense
  for(int offset = 0; des != NULL; offset++, des = des->tl) {
    list_t<designator_t> ds = (*des->hd)[0];
    if (ds != NULL)
      //   if (ds->hd->tl != NULL)
      //     terr(ds->hd[1]->loc,"only array index designators are supported");
      switch (ds->hd) {
      case &FieldName(_):
	terr(loc,"only array index designators are supported");
	break;
      case &ArrayElement(e):
	tcExpInitializer(te,NULL,e);
	unsigned int i = Evexp::eval_const_uint_exp(e);
	if (i != offset)
	  terr(e->loc, "expecting index designator %d but found %d",
               offset,i);
	break;
      }
  }
  
  //if (topt != NULL) {
  // if (!unify(*topt,res_t2) && silent_castable(te,loc,res_t2,*topt)) {
  //    e->topt = &Opt(res_t2);
  //    unchecked_cast(te, e, *topt);
  //    res_t2 = *topt;
  //}
  //}
  return res_t2;
}

 // {for [te] < [bound] : [body]}
static type_t tcComprehension(tenv_t te,seg_t loc,type_t *`r topt,
                              vardecl_t vd,exp_t bound,exp_t body) {
  tcExp(te,NULL,bound);
  if (!coerce_uint_typ(te,bound))
    terr(bound->loc,"expecting unsigned int, found %s",
         typ2string(bound->topt->v));
  // double-check that the index variable x is declared const
  if (!vd->tq.q_const)
    impos("comprehension index variable is not declared const!");
  // add x to the environment with the type unsigned int only if te->le
  // is not NULL.
  if (te->le != NULL) {
    te = Tcenv::new_block(loc,te);
    te = add_local_var(loc, te, vd);
  }
  _ pinfo;
  let topt2 = NULL;
  let tqopt = NULL;

  if (topt != NULL) {
    switch (compress(*topt)) {
    case &PointerType(x):
      pinfo = x;
      topt2 = &pinfo.elt_typ;
      tqopt = &pinfo.tq;
      break;
    case &ArrayType(*t,*tq,b):
      topt2 = t;
      tqopt = tq;
      break;
    default:
      break;
    }
   }
   // type-check the body in the new environment
   type_t t = tcExp(te,topt2,body);
   if (te->le == NULL) {
     // both the bound and the body must be constant expressions at the
     // top-level.  
     if (!is_const_exp(te,bound))
       terr(bound->loc,"bound is not constant");
     if (!is_const_exp(te,body))
       terr(bound->loc,"body is not constant");
   }
   return new ArrayType(t,(tqopt == NULL) ? empty_tqual() : *tqopt, bound);
}

 //////////////////// Struct (f{e1,...,en}) ///////////////////
 // FIX:
 // Right now, we only allow one field name designator on an argument.
 // In addition, we assume any undesignated argument is associated with
 // the first field that has not yet been explicitly mentioned.  So,
 // for instance, if we have:
 //  struct Foo {int a,b,c,d,e;}
 //  Foo{.c=3,.d=4,1,2,5};
 // then this is the same as Foo{.a=1,.b=2,.c=3,.d=4,.e=5};
 // Later, we should support array designators and so forth.
static type_t tcStruct(tenv_t te, seg_t loc, type_t *`r topt,
                       typedef_name_t @tn,
                       opt_t<list_t<type_t,`H>,`H> @otyps,
                       list_t<$(list_t<designator_t>,exp_t)@> args,
                       struct Structdecl *`H @`H sd_opt) {
  structdecl_t sd;
  if (*sd_opt != NULL)
    sd = (structdecl_t)(*sd_opt);
  else {
    try
      sd = *lookup_structdecl(te,loc,*tn);
    catch { 
    case Dict::Absent:
      terr(loc, "unbound struct name %s",qvar2string(*tn));
      return topt != NULL ? *topt : VoidType;
    }
    *sd_opt = sd;
    if (sd->name != NULL)
      *tn = sd->name->v;
  }
  region rgn {
  // calculate the instantiation and final type
  let env = $(lookup_type_vars(te),rgn);
  let inst    = List::rmap_c(rgn,r_make_inst_var,&env,sd->tvs);
  let typs    = List::map(snd,inst);
  let res_typ = new StructType(*tn,typs,new sd);
  // this will instantiate the struct if we have type information in topt
  // unfortunately, I think it allows topt to cause failure
  if (topt != NULL) unify(res_typ,*topt);
  *otyps = new Opt(typs);
  // make sure each argument has the right type
  if (sd->fields == NULL) {
    terr(loc,"can't build abstract struct");
    return res_typ;
  }
  list_t<$(structfield_t,exp_t)@`rgn,`rgn> fields =
    resolve_struct_designators(rgn,loc,args,sd->fields->v);
  for(; fields != NULL; fields = fields->tl) {
    let &$(field,field_exp) = fields->hd;
    let inst_fieldtyp = rsubstitute(rgn,inst,field->type);
    tcExpInitializer(te, &inst_fieldtyp, field_exp);
    if (!coerce_arg(te,field_exp,inst_fieldtyp)) {
      terr(field_exp->loc,"field %s of struct %s expects type %s != %s",
           *(field->name),qvar2string(*tn),typ2string(inst_fieldtyp),
           typ2string(field_exp->topt->v));
      explain_failure();
    }
  }
  return res_typ;
  }
}

static type_t tcAnonStruct(tenv_t te, seg_t loc, type_t ts, 
                           list_t<$(list_t<designator_t>,exp_t)@> args) {
  region rgn {
    switch (compress(ts)) {
    case &AnonStructType(fs):
      list_t<$(structfield_t,exp_t)@`rgn,`rgn> fields = 
        resolve_struct_designators(rgn,loc,args,fs);
      for (; fields != NULL; fields = fields->tl) {
        let &$(field,field_exp) = fields->hd;
        tcExpInitializer(te, &field->type, field_exp);
        if (!coerce_arg(te,field_exp,field->type)) {
          terr(field_exp->loc,"field %s of struct expects type %s != %s",
               *(field->name),typ2string(field->type),
               typ2string(field_exp->topt->v));
          explain_failure();
        }
      }
      break;
    default: impos("tcAnonStruct:  not an AnonStructType"); break;
    }
  }
  return ts;
}

// f(es)   where f is a tunion and is ef->name
static type_t tcTunion(tenv_t te, seg_t loc, type_t *`r topt,
                    exp_t e,
                    opt_t<list_t<type_t,`H>,`H> @all_ref,
                    opt_t<list_t<type_t,`H>,`H> @exist_ref,
                    list_t<exp_t> es,
                    tuniondecl_t tud,
                    tunionfield_t tuf) {
  region rgn {
  let env = $(lookup_type_vars(te),rgn);
  let all_inst   = List::rmap_c(rgn,r_make_inst_var,&env,tud->tvs);
  let exist_inst = List::rmap_c(rgn,r_make_inst_var,&env,tuf->tvs);
  let all_typs   = List::map(snd,all_inst);
  let exist_typs = List::map(snd,exist_inst);
  let inst       = List::rappend(rgn,all_inst,exist_inst);
  *all_ref   = new Opt(all_typs);
  *exist_ref = new Opt(exist_typs);
  type_t res = 
    new TunionFieldType(TunionFieldInfo{new KnownTunionfield(tud,tuf),
					all_typs});
  // this instantiates the type variables if we have top-down type info
  if (topt != NULL) {
    switch (compress(*topt)) {
    case &TunionFieldType(_): unify(*topt,res); break;
    case &TunionType(TunionInfo{_,targs,r}):
      for (_ a = all_typs; a != NULL && targs != NULL; a=a->tl,targs=targs->tl)
        unify(a->hd,targs->hd);
      // top-down, we're looking for a Tunion, not a Tunion field.
      // we can cast up here if there are no arguments to the constructor.
      if (tuf->typs == NULL && es == NULL) {
        e->topt = new Opt(res);
        res = new TunionType(TunionInfo{new KnownTunion(new tud),
					all_typs,r});
        unchecked_cast(te, e, res);
        return res;
      }
      break;
    default: break;
    }
  }
  list_t<$(tqual_t,type_t)@> ts = tuf->typs;
  for(; es != NULL && ts != NULL; es = es->tl, ts = ts->tl) {
    exp_t  e = es->hd;
    type_t t = rsubstitute(rgn,inst,(*ts->hd)[1]);
    tcExpInitializer(te, &t, e);
    if (!coerce_arg(te,e,t)) {
      terr(e->loc,"tunion constructor %s expects argument of type %s "
           "but this argument has type %s",
           qvar2string(tuf->name),typ2string(t),
           (e->topt == NULL) ? (string_t)"?" : typ2string(e->topt->v));
      explain_failure();
    }
  }
  if (es != NULL)
    return expr_err(te,es->hd->loc,
                    "too many arguments for tunion constructor %s",
                    qvar2string(tuf->name));
  if (ts != NULL)
    return expr_err(te,loc,"too few arguments for tunion constructor %s",
                    qvar2string(tuf->name));
  return res;
  }
}

static bool zeroable_type(type_t t) {
  switch (compress(t)) {
  case VoidType: return true;
  case &Evar(_,_,_,_):
  case &VarType(_): 
  case &TunionType(_):
  case &TunionFieldType(_): return false;
  case &PointerType(PtrInfo{_,_,n,_,_}):
    return (conref_def(true,n));
  case &IntType(_,_):
  case FloatType:
  case &DoubleType(_): return true;
  case &ArrayType(t,_,_): return zeroable_type(t);
  case &FnType(_): return false;
  case &TupleType(tqs):
    for (; tqs; tqs = tqs->tl) 
      if (!zeroable_type((*tqs->hd)[1])) return false;
    return true;
  case &StructType(_,ts,sdp):
    if (sdp == NULL) return false;
    let sd = *sdp;
    if (sd->fields == NULL) return false;
    region r {
      let inst = List::rzip(r,r,sd->tvs,ts);
      for (_ fs = sd->fields->v; fs != NULL; fs = fs->tl) 
        if (!zeroable_type(rsubstitute(r,inst,fs->hd->type))) return false;
      return true;
    }
  case &UnionType(_,_,_): return true; // bits only
  case &EnumType(_,_): return true;
  case &SizeofType(_): return true;
  case &AnonStructType(fs): 
    for (; fs != NULL; fs = fs->tl) 
      if (!zeroable_type(fs->hd->type)) return false;
    return true;
  case &AnonUnionType(_): return true; // bits only
  case &AnonEnumType(_): return true;  
  case &RgnHandleType(_): return false;

  case &TypedefType(_,_,_):
  case HeapRgn:
  case &AccessEff(_):
  case &JoinEff(_):
  case &RgnsEff(_): 
    return impos("bad type `%s' in zeroable type",typ2string(t));
  }
}

static void check_malloc_type(bool allow_zero, seg_t loc, 
                              type_t * topt, type_t t) {
  if (bits_only(t) || (allow_zero && zeroable_type(t))) return;
  // try unifying t with the topt info to get better results
  if (topt != NULL) {
    switch (compress(*topt)) {
    case &PointerType(PtrInfo{elt_typ,_,_,_,_}): 
      unify(elt_typ,t);
      if (bits_only(t) || (allow_zero && zeroable_type(t))) return;
      break;
    default: break;
    }
  }
  terr(loc,"%s cannot be used with type %s\n\t(type needs initialization)",
       allow_zero ? ((string_t)"calloc") : "malloc", typ2string(t));
}

static type_t tcMalloc(tenv_t te, seg_t loc, type_t *`r topt, exp_opt_t ropt, 
                       type_t *@t, exp_t @e, bool is_calloc,
                       bool @is_fat) {
  type_t rgn = HeapRgn;
  if (ropt != NULL) {
    // check that the region handle is still valid
    type_t expected_type = 
      new RgnHandleType(new_evar(&rk,new Opt(lookup_type_vars(te))));
    type_t handle_type = tcExp(te,&expected_type,(exp_t)ropt);
    switch (compress(handle_type)) {
    case &RgnHandleType(r): 
      rgn = r;
      check_rgn_accessible(te,loc,rgn);
      break;
    default:
      terr(ropt->loc,"expecting region_t type but found %s",
           typ2string(handle_type));
      break;
    }
  }
  tcExp(te,&uint_t,*e);
  // crawl over e and look for the following cases:
  //   sizeof(T):  result is T@ or T* depending upon topt
  //   sizeof(T)*n or n*sizeof(T):  result is T? 
  //     as long as T is bits-only or zero-able.
  //   otherwise it's char ?
  type_t elt_type; // the element type of the resulting pointer
  exp_t num_elts;  // the number of elements of the resulting pointer
  bool one_elt;
  if (is_calloc) {
    if (*t == NULL) impos("calloc with empty type");
    elt_type = **t;
    check_type(loc,te,lookup_type_vars(te),MemKind,true,elt_type);
    check_malloc_type(true,loc,topt,elt_type);
    num_elts = *e;
    one_elt = false;
  } else {
    switch ((*e)->r) {
    case &Sizeoftyp_e(t2):  
      elt_type = t2;
      *t = new elt_type;
      num_elts = uint_exp(1,NULL);
      tcExp(te,&uint_t,num_elts);
      one_elt = true;
      break;
    case &Primop_e(Times,&List(e1,&List(e2,NULL))):
      switch ($(e1->r, e2->r)) {
      case $(&Sizeoftyp_e(t1),_): 
        check_malloc_type(false,loc,topt,t1);
        elt_type = t1;
        *t = new elt_type;
        num_elts = e2;
        one_elt = false;
        break;
      case $(_,&Sizeoftyp_e(t2)):
        check_malloc_type(false,loc,topt,t2);
        elt_type = t2;
        *t = new elt_type;
        num_elts = e1;
        one_elt = false;
        break;
      default: goto No_sizeof;
      }
      break;
    default:
    No_sizeof:
      elt_type = uchar_t;
      *t = new elt_type;
      num_elts = *e;
      one_elt = false;
      break;
    }
  }
  *e = num_elts;
  *is_fat = !one_elt;
  // Don't yet support existential types (to do it, add to TunionFieldInfo
  // and here generate fresh evars).
  switch(elt_type) {
  case &TunionFieldType(TunionFieldInfo(&KnownTunionfield(_,tuf),_)):
    if(tuf->tvs != NULL)
      terr(loc,"malloc with existential types not yet implemented");
    break;
  default: break;
  }

  // Avoid casts when we're passed down a nullable type
  let ptr_maker = at_typ;
  if(topt != NULL)
    switch (compress(*topt)) {
    case &PointerType(PtrInfo{_,_,n,_,_}): 
      if(conref_val(n))
	ptr_maker = star_typ; 
      break;
    default: break;
    }
  if (!one_elt) ptr_maker = tagged_typ;
  return ptr_maker(elt_type,rgn,empty_tqual());
}
// ({ s })
static type_t tcStmtExp(tenv_t te, seg_t loc, type_t *`r topt, stmt_t s) {
  Tcstmt::tcStmt(set_encloser(te,s),s,true);
  // The encloser of s is not s, so reset it properly.
  NewControlFlow::set_encloser(s,get_encloser(te));
  // The type is the type of the expression that ends the statment.
  while(true)
    switch (s->r) {
    case &Exp_s(e):     return e->topt->v;
    case &Seq_s(s1,s2): s = s2; continue;
    case &Decl_s(d,s1): s = s1; continue;
    default:
      return expr_err(te,loc,"statement expression must end with expression");
    }
}

 // codegen(fd)
static type_t tcCodegen(tenv_t te, seg_t loc, type_t *`r topt, fndecl_t fd) {
  return expr_err(te,loc,"tcCodegen");
}
 // fill(e)
static type_t tcFill(tenv_t te, seg_t loc, type_t *`r topt, exp_t e) {
  return expr_err(te,loc,"tcFill");
}

// new e
static type_t tcNew(tenv_t te, seg_t loc, type_t *`r topt, 
                    exp_opt_t rgn_handle, exp_t e, exp_t e1) {
  type_t rgn = HeapRgn;
  if (rgn_handle != NULL) {
    // check that the region handle is still valid
    type_t expected_type = 
      new RgnHandleType(new_evar(&rk,new Opt(lookup_type_vars(te))));
    type_t handle_type = tcExp(te,&expected_type,(exp_t)rgn_handle);
    switch (compress(handle_type)) {
    case &RgnHandleType(r): 
      rgn = r;
      check_rgn_accessible(te,loc,rgn);
      break;
    default:
      terr(rgn_handle->loc,"expecting region_t type but found %s",
           typ2string(handle_type));
      break;
    }
  }

  switch (e1->r) {
  case &Comprehension_e(vd,ebound,egen):
    // Note: tcComprehension expects the pointer type, not an array type.
    let t_arr = tcExpNoPromote(te,topt,e1);
    switch (compress(t_arr)) {
    case &ArrayType(et_arr,tq_arr,_):
      bounds_t b = 
        is_const_exp(te,ebound) ? (bounds_t)(new Upper_b(ebound)) : Unknown_b;
      type_t res_typ = 
        new PointerType(PtrInfo{et_arr,rgn,empty_conref(),tq_arr,
                                new_conref(b)});
      if (topt != NULL) {
        if (!unify(*topt,res_typ) && silent_castable(te,loc,res_typ,*topt)) {
          e->topt = new Opt(res_typ);
          unchecked_cast(te, e, *topt);
          res_typ = *topt;
        }
      }
      return res_typ;
    default: return impos("tcNew: comprehension returned non-array type");
    }
  case &UnresolvedMem_e(nopt,des):
    e1->r = new Array_e(des);
    fallthru(des);
  case &Array_e(des):
    type_t *elt_typ_opt = NULL;
    if (topt != NULL) {
      switch (compress(*topt)) {
      case &PointerType(PtrInfo{*elt_typ,_,_,tq,_}):
        // tcArray only needs the element type, so the bound is bogus
        elt_typ_opt = elt_typ;
        break;
      default: break;
      }
    }
    let t_array = tcExpNoPromote(te, elt_typ_opt, e1);
    type_t res_typ;
    switch (compress(t_array)) {
    case &ArrayType(et,tq,sz): 
      res_typ = new PointerType(PtrInfo{et,rgn,empty_conref(),tq,
                                        new_conref(new Upper_b((exp_t)sz))});
      if (topt != NULL) {
        // try unifying res_typ and topt -- if that fails, then see if we
        // can cast res_typ to topt, and insert the cast so that the code
        // generator knows what to do.
        if (!unify(*topt,res_typ) && silent_castable(te,loc,res_typ,*topt)) {
          e->topt = new Opt(res_typ);
          unchecked_cast(te, e, *topt);
          res_typ = *topt;
        }
      }
      break;
    default: 
      return impos("tcExpNoPromote on Array_e returned non-array type");
    }
    return res_typ;
  case &Const_e(&String_c(s)):
    // here I'm going to guess that the user wants a char ?@ instead of
    // a char @{n}@.  They can get the char@{n}@ by using a cast.  This
    // is a total hack...
    let topt2 = atb_typ(uchar_t, rgn, const_tqual(), Unknown_b);
    let t = tcExp(te,&topt2,e1);
    return atb_typ(t, rgn, empty_tqual(), new Upper_b(uint_exp(1,NULL)));
  default:
    // code that's equivalent to "new {e1}" -- i.e., an array of size 1.
    // Note that we could simplify everything by rewriting the expression
    // to use an Array_e, but this would involve more allocation.
    type_t *topt2 = NULL;
    if (topt != NULL) {
      switch (compress(*topt)) {
      case &PointerType(PtrInfo{*elttype,_,tq,_,_}):
        topt2 = elttype; break;
      case &TunionType(_):
        // Note, we're lying here in the sense that we should pass down
        // a TunionFieldType -- but we don't know which field...
        topt2 = new (*topt);
        break;
      default: break;
      }
    }
    type_t telt = tcExp(te,topt2,e1);
    type_t res_typ =
      new PointerType(PtrInfo{telt,rgn,empty_conref(),
                              empty_tqual(),
                              new_conref(new Upper_b(uint_exp(1,NULL)))});
    if (topt != NULL) {
      if (!unify(*topt,res_typ) && silent_castable(te,loc,res_typ,*topt)) {
        e->topt = new Opt(res_typ);
        unchecked_cast(te,e,*topt);
        res_typ = *topt;
      }
    }
    return res_typ;
  }
}

// The default: type-check and promote any array types to pointer types
type_t tcExp(tenv_t te, type_t *`r topt, exp_t e) {
  type_t t = compress(tcExpNoPromote(te, topt, e));
  switch (t) {
  case &ArrayType(elt_typ,tq,e2):
    let $(_,rgn) = addressof_props(te,e);
    let b = (e2 == NULL) ? (bounds_t)Unknown_b : new Upper_b((exp_t)e2);
    t = atb_typ(elt_typ,rgn,tq,b);
    e->topt->v = t;
    return t;
  default:
    return t;
  }
}

// Type-check the expression -- if it's an Array_e, Comprehension_e, 
// or String_c expression, do not promote its type from array to pointer.  
// Otherwise, do so.
type_t tcExpInitializer(tenv_t te, type_t *`r topt, exp_t e) {
  type_t t = tcExpNoPromote(te, topt, e);
  switch (e->r) {
  case &Array_e(_): 
  case &Comprehension_e(_,_,_):
  case &Const_e(&String_c(_)): return t;
  default:
    t = compress(t);
    switch (t) {
    case &ArrayType(elt_typ,tq,e2):
      let $(_,rgn) = addressof_props(te,e);
      bounds_t b = (e2 == NULL) ? (bounds_t)Unknown_b : new Upper_b((exp_t)e2);
      t = atb_typ(elt_typ,rgn,tq,b);
      unchecked_cast(te,e,t);
      return t;
    default:
      return t;
    }
  }
}

// Type check an expression e.  The value topt is an optional type
// that we expect e to have.  This is useful for propagating type
// information down (i.e., to resolve certain ambiguous expression
// forms) but isn't otherwise used -- one still needs to check that
// e has the expected type.  If e="e2<>" and e2 has a poly-type,
// we do not instantiate the type quantifiers.  Otherwise if e has a
// poly-type, we instantiate the quantifiers.
static type_t tcExpNoPromote(tenv_t te, type_t *`r topt, exp_t e) {
  switch (e->r) {
  case &NoInstantiate_e(e2):
    // the user has asked not to implicitly instantiate any quantifiers
    tcExpNoInst(te,topt,e2);
    e2->topt->v = pointer_expand(e2->topt->v);
    e->topt = e2->topt;
    break;
  default:
    // first, typecheck without instantiating
    tcExpNoInst(te,topt,e);
    e->topt->v = pointer_expand(e->topt->v);
    // implicitly instantiate the expression if it has a polymorphic type
    switch (compress(e->topt->v)) {
    case &PointerType(PtrInfo{t,rt,x,tq,b}):
      switch (compress(t)) {
      case &FnType(FnInfo{tvs,eff,rtyp,args,c_varargs,cyc_varargs,rpo,atts}):
	if (tvs != NULL)    // then, instantiate if necessary
	  region rgn {
           let env = $(lookup_type_vars(te),rgn);
	   list_t<$(tvar_t,type_t)@`rgn,`rgn> inst = 
	     List::rmap_c(rgn,r_make_inst_var,&env,tvs);
	   list_t<type_t> ts = List::map(snd,inst);
	   type_t ftyp = rsubstitute(rgn, inst,
				     new FnType(FnInfo{NULL,eff,rtyp,args,
						       c_varargs,cyc_varargs,
                                                       rpo,atts}));
	   type_t new_typ = new PointerType(PtrInfo{ftyp,rt,x,tq,b});
	   exp_t  inner   = copy_exp(e);
	   e->r    = new Instantiate_e(inner,ts);
	   e->topt = new Opt(new_typ);
	  }
	break;
      default: break;
      }
      break;
    default: break;
    }
    break;
  }
  return e->topt->v;
}

 // Type-check the expression -- don't do any implicit instantiation.
static void tcExpNoInst(tenv_t te, type_t *`r topt, exp_t e) {
  seg_t loc = e->loc;
  type_t t;

  switch (e->r) {

  case &NoInstantiate_e(e2):
    // This would handle two NoInstantiates in a row; but note that
    // for now the parser does not produce this ( x<><> won't parse ).
    tcExpNoInst(te,NULL,e2);
    return;

  case &UnknownId_e(q):
    // resolve the identifier and then re-type-check the expression
    resolve_unknown_id(te,e,q);
    tcExpNoInst(te,topt,e);
    return;
  case &UnknownCall_e(e1,es):
    // resolve e1 as a function or struct, tunion, or xtunion constructor and
    // then re-type-check the expression
    resolve_unknown_fn(te,e,e1,es);
    tcExpNoInst(te,topt,e);
    return;
  case &UnresolvedMem_e(nopt,des):
    // resolve as an array or struct and then re-type-check the expression
    resolve_unresolved_mem(te,loc,topt,e,des);
    tcExpNoInst(te,topt,e);
    return;

  case &Const_e(c):
    t = tcConst(te,loc,topt,c,e); break;
  case &Var_e(q,b):
    t = tcVar(te,loc,q,b); break;
  case &Primop_e(p,es):
    t = tcPrimop(te,loc,topt,p,es); break;
  case &Increment_e(e1,i):
    t = tcIncrement(te,loc,topt,e1,i); break;
  case &AssignOp_e(e1,popt,e2):
    t = tcAssignOp(te,loc,topt,e1,popt,e2); break;
  case &Conditional_e(e1,e2,e3):
    t = tcConditional(te,loc,topt,e1,e2,e3); break;
  case &SeqExp_e(e1,e2):
    t = tcSeqExp(te,loc,topt,e1,e2); break;
  case &FnCall_e(e1,es,*vci):
    t = tcFnCall(te,loc,topt,e1,es,vci); break;
  case &Throw_e(e1):
    t = tcThrow(te,loc,topt,e1); break;
  case &Instantiate_e(e2,ts):
    t = tcInstantiate(te,loc,topt,e2,ts); break;
  case &Cast_e(t1,e1):
    t = tcCast(te,loc,topt,t1,e1); break;
  case &Address_e(e1):
    t = tcAddress(te,loc,e,topt,e1); break;
  case &New_e(rgn_handle,e1):
    t = tcNew(te,loc,topt,rgn_handle,e,e1); break;
  case &Sizeofexp_e(e1):
    let t1 = tcExpNoPromote(te, NULL, e1);
    t = tcSizeof(te,loc,topt,t1); break;
  case &Sizeoftyp_e(t1):
    t = tcSizeof(te,loc,topt,t1); break;
  case &Offsetof_e(t1,n):
    t = tcOffsetof(te,loc,topt,t1,n); break;
  case &Gentyp_e(_,_):
    terr(loc, "gen() not in top-level initializer");
    return;
  case &Deref_e(e1):
    t = tcDeref(te,loc,topt,e1); break;
  case &StructMember_e(e1,f):
    t = tcStructMember(te,loc,topt,e,e1,f); break;
  case &StructArrow_e(e1,f):
    t = tcStructArrow(te,loc,topt,e1,f); break;
  case &Subscript_e(e1,e2):
    t = tcSubscript(te,loc,topt,e1,e2); break;
  case &Tuple_e(es):
    t = tcTuple(te,loc,topt,es); break;
  case &CompoundLit_e(t1,des):
    t = tcCompoundLit(te,loc,topt,t1,des); break;
  case &Array_e(des):
    // tcArray expects us to pass in an optional element type, not
    // the array type.  See also tcNew.
    type_t *elt_topt = NULL;
    if (topt != NULL) {
      switch (compress(*topt)) {
      case &ArrayType(*et,_,_): elt_topt = et; break;
      default: break;
      }
    }
    t = tcArray(te,loc,elt_topt,des); break;
  case &StmtExp_e(s):
    t = tcStmtExp(te,loc,topt,s); break;
  case &Codegen_e(fd):
    t = tcCodegen(te,loc,topt,fd); break;
  case &Fill_e(e1):
    t = tcFill(te,loc,topt,e1); break;
  case &Comprehension_e(vd,e1,e2):
    t = tcComprehension(te,loc,topt,vd,e1,e2); break;
  case &Struct_e(*tn,*otyps,args,*sd_opt):
    t = tcStruct(te,loc,topt,tn,otyps,args,sd_opt); break;
  case &AnonStruct_e(ts,args):
    t = tcAnonStruct(te,loc,ts,args); break;
  case &Tunion_e(*all_ref,*exist_ref,es,tud,tuf):
    t = tcTunion(te,loc,topt,e,all_ref,exist_ref,es,tud,tuf); break;
  case &Enum_e(*q,ed,ef):
    *q = ef->name;
    t = new EnumType(ed->name,ed); break;
  case &AnonEnum_e(*v,t2,ef):
    *v = ef->name;
    t = t2; break;
  case &Malloc_e(MallocInfo{is_calloc,ropt,*t2,*e,*isfat}):
    t = tcMalloc(te,loc,topt,ropt,t2,e,is_calloc,isfat); break;
  }
  e->topt = new Opt(t);
}
