/* Type checking for expressions.
   Copyright (C) 2001 Greg Morrisett, AT&T
   This file is part of the Cyclone compiler.

   The Cyclone compiler is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   The Cyclone compiler is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with the Cyclone compiler; see the file COPYING. If not,
   write to the Free Software Foundation, Inc., 59 Temple Place -
   Suite 330, Boston, MA 02111-1307, USA. */

/* TODO:
   codegen and fill
   compound literals
   generalized array and struct designators
   JGMFIX: lousy error messages...
   EXPLAIN DELTA -- need to explain the difference in rich types
   other instances of typ2string should (outside of EXPLAIN DELTA)
     should be pretty-printed in a more user-friendly manner (i.e.,
     leave off effects, regions, etc. unless they're relevant.)
 */

#include "absyn.h"
#include <string.h>
#include <stdio.h>
#include <position.h>
#include "absynpp.h"
#include "tcenv.h"
#include "tcutil.h"
#include "evexp.h"
#include "tcstmt.h"
#include "formatstr.h"
#include "tcexp.h"
#include "new_control_flow.h"
using Core;
using List;
using Position;
using Absyn;
using Absynpp;
using Tcenv;
using Tcutil;

namespace Tcexp;

static type_t expr_err(tenv_t te,seg_t loc,type_t * topt, string_t msg,
                       ... inject parg_t ap) 
  __attribute__((format(printf,4,5)))
{
  terr(loc,vrprintf(heap_region,msg,ap));
  if (topt == NULL)
    return wildtyp(new Opt(lookup_type_vars(te)));
  else 
    return *topt;
}

#ifdef NO_PATHS
#define UNIQUE_ERR_MSG "Cannot consume paths; do swap instead %d"
#else
#define UNIQUE_ERR_MSG "Cannot consume non-unique paths; do swap instead"
#endif

//////////////////// Resolving References the Parser Cannot /////////////////

// The qualified identifier q could be a variable, a tunion
// constructor, or an xtunion constructor.  We resolve q and overwrite
// the expression e with the appropriate r.
// We must always overwrite e to prevent the compiler from diverging.
static void resolve_unknown_id(tenv_t te, exp_t e, qvar_t q) {
  try
    region r {
      switch (lookup_ordinary(r,te,e->loc,q)) {
      case &VarRes(b):          e->r = new Var_e(q,b); break;
      case &EnumRes(ed,ef):     e->r = new Enum_e(q,ed,ef); break;
      case &AnonEnumRes(t,ef):  e->r = new AnonEnum_e(q,t,ef); break;
      case &TunionRes(tud,tuf): e->r = new Tunion_e(NULL,tud,tuf); break;
      case &AggrRes(_):
        terr(e->loc,"bad occurrence of type name %s",qvar2string(q));
        e->r = new Var_e(q,Unresolved_b);
        break;
      }
    }
  catch { 
    case Dict::Absent:
      // This is an error, but the message will be printed elsewhere.
      // Here we just put the "I don't know" answer in e->r
      e->r = new Var_e(q,Unresolved_b);
      break;
    }
}

static $(list_t<designator_t>,exp_t)@ make_struct_arg(exp_t e) {
  return new $(NULL,e);
}
// Resolve whether this is a function call or tunion, xtunion, or struct
// constructor -- let normal type-checking do the rest of the work.
// NOTE: We assume q is a relative qvar.
static void resolve_unknown_fn(tenv_t te,exp_t e,exp_t e1,list_t<exp_t,`H> es) {
  switch (e1->r) {
  case &UnknownId_e(q):
    try {
      region r {
        switch (lookup_ordinary(r,te,e1->loc,q)) {
        case &VarRes(b):        
          e->r = new FnCall_e(e1,es,NULL); 
          return;
        case &TunionRes(tud,tuf):
          if (tuf->typs == NULL)
            // Don't allow "foo()", require "foo"
            terr(e->loc,"%s is a constant, not a function",
                 qvar2string(tuf->name));
          e->r = new Tunion_e(es,tud,tuf); 
          return;
        case &AggrRes(ad):
          let des = List::map(make_struct_arg,es);
          e->r = new Struct_e(ad->name,NULL,des,ad);
          return;
        case &AnonEnumRes(_,_):
        case &EnumRes(_,_):
          terr(e->loc,"%s is an enum constructor, not a function",qvar2string(q));
          return;
        }
      }
    } catch { case Dict::Absent:
      // print out error message later when type-checking the fn call
      // terr(e1->loc, "unbound identifier %s",qvar2string(q));
      e->r = new FnCall_e(e1,es,NULL);
      return;
    }
  default: 
    e->r = new FnCall_e(e1,es,NULL); 
    return;
  }
}

static 
void resolve_unresolved_mem(tenv_t te, seg_t loc, type_t * topt, exp_t e,
			    list_t<$(list_t<designator_t,`H>,exp_t)@`H,`H> des){
  // NOTE: must always bang e->r or caller will loop!
  if (topt == NULL) {
    // guess it is an array
    e->r = new Array_e(des);
    return;
  }
  type_t t = *topt;
  switch (compress(t)) {
  case &AggrType(AggrInfo(info,_)):
    switch(info) {
    case UnknownAggr(_,_): impos("struct type not properly set");
    case KnownAggr(&ad):   e->r = new Struct_e(ad->name,NULL,des,ad);
    }
    break;
  case &ArrayType(ArrayInfo{at,aq,_,_,_}): e->r = new Array_e(des); break;
  case &AnonAggrType(_,_):  e->r = new AnonStruct_e(t,des); break;
  default:                  e->r = new Array_e(des);        break;//do something
  }
}

//////////////////////// Actual Type-checking //////////////////////////////

// forward reference just b/c of how things are organized at the moment
static void tcExpNoInst(tenv_t te, type_t * topt, exp_t e);
static type_t tcExpNoPromote(tenv_t te, type_t * topt, exp_t e);

// Type check a list of expressions
static void tcExpList(tenv_t te, list_t<exp_t> es) {
  for(; es != NULL; es = es->tl)
    tcExp(te,NULL,es->hd);
}

// Type check the if expressions, the loop guards, and the where clauses
void tcTest(tenv_t te, exp_t e, string_t msg_part) {
  check_contains_assign(e);
  tcExp(te,&sint_typ,e);
  if (!coerce_to_bool(te,e))
    terr(e->loc,"test of %s has type %s instead of integral or * type",
         msg_part, typ2string(e->topt->v));
}

// constants
static type_t tcConst(tenv_t te, seg_t loc, type_t * topt, cnst_t *c, exp_t e){
  type_t t;
  switch (*c) {
  case Char_c(Signed,_):   t = schar_typ; break;
  case Char_c(Unsigned,_): t = uchar_typ; break;
  case Char_c(None,_):     t = char_typ;  break;
  case Short_c(sn,_):    
    t = (sn == Unsigned) ? ushort_typ : sshort_typ; break;
  case LongLong_c(sn,_): 
    t = (sn == Unsigned) ? ulonglong_typ  : slonglong_typ;  break;
  case Float_c(_) : t = float_typ; break;
  case Int_c(sn,i):
    if (topt == NULL)
      t = (sn == Unsigned) ? uint_typ : sint_typ;
    else
        // If *topt calls for a shorter int, we assume it's ok to
        // truncate without warning.
        // The typical case is in an array initializer, e.g.,
        // short x[1] = { 255 };
      switch (compress(*topt)) {
      case &IntType(sn,Char_sz):
        switch(sn) {
	case Unsigned: t = uchar_typ; break;
	case Signed: t = schar_typ; break;
	case None: t = char_typ; break;
	}
        *c = Char_c(sn,(char)(i)); // i gets truncated here
        break;
      case &IntType(sn,Short_sz):
	t = (sn == Unsigned) ? ushort_typ : sshort_typ;
        *c = Short_c(sn,(short)(i)); // i gets truncated here
        break;
      case &IntType(sn,Int_sz):
        t = (sn == Unsigned) ? uint_typ : sint_typ;
        break;
      case &IntType(sn,Long_sz):
        t = (sn == Unsigned) ? uint_typ : sint_typ;
        break;
      case &PointerType(_) && (i == 0):
        // we're treating 0 as if it's NULL
        e->r = new Const_e(Null_c);
        let tenv_tvs = lookup_type_vars(te);
        t = new PointerType(PtrInfo(new_evar(&ak,new Opt(tenv_tvs)), 
				    empty_tqual(NULL),
				    PtrAtts(new_evar(&trk,new Opt(tenv_tvs)), 
					    true_conref,
					    empty_conref(), empty_conref(),
                                            NULL)));
        break;
      case &TagType(t1): 
	let t2 = new TypeInt(i);
	if(!unify(t1,t2)) {
	  terr(loc, "expecting %s but found %s",typ2string(t1),typ2string(t2));
	  explain_failure();
	}
	t = new TagType(t2);
	break;
      default: // topt isn't int; presumably an error to be caught elsewhere
        t = (sn == Unsigned) ? uint_typ : sint_typ;
        break;
    }
    break;
  case String_c(s):
    int len = s.size; // includes the trailing 0 character
    exp_t elen = const_exp(Int_c(Unsigned, len), loc);
    elen->topt = new Opt(uint_typ);
    // The default is to treat a string as if it's statically heap 
    // allocated and return a pointer to that string.  However, if the 
    // string is used as an initializer, then we should return an array type.
    t = atb_typ(char_typ,HeapRgn,const_tqual(NULL),
                new Upper_b(elen),true_conref);
    if (topt != NULL) {
      switch (compress(*topt)) {
      case &ArrayType(ArrayInfo{_,tq,_,_,_}):
        // as an array initializer, a string literal can be either
        // treated as zero-terminated or not, hence the empty_conref.
        return array_typ(char_typ, tq, elen, empty_conref(),NULL);
      case &PointerType(_):
        if (!unify(*topt,t) && silent_castable(te,loc,t,*topt)) {
          e->topt = new Opt(t);
          unchecked_cast(te, e, *topt, Other_coercion);
          t = *topt;
        } else {
          // maybe it's going in a different region
          t = atb_typ(char_typ,new_evar(&rk,new Opt(lookup_type_vars(te))), 
                      const_tqual(NULL), 
                      new Upper_b(elen), true_conref);
          if (!unify(*topt,t) && silent_castable(te,loc,t,*topt)) {
            e->topt = new Opt(t);
            unchecked_cast(te, e, *topt, Other_coercion);
            t = *topt;
          }
        }
        break;
      default: break;
      }
    }
    return t;
  case Null_c:
    let tenv_tvs = lookup_type_vars(te);
    // FIX: take advantage of topt
    t = new PointerType(PtrInfo(new_evar(&ak,new Opt(tenv_tvs)), 
                                empty_tqual(NULL),
				PtrAtts(new_evar(&trk,new Opt(tenv_tvs)), 
					true_conref,
					empty_conref(),empty_conref(),NULL)));
                                       
    break;
  }
  return t;
}

// variables
static type_t tcVar(tenv_t te, seg_t loc, qvar_t q, binding_t b) {
  switch(b) {
  case Unresolved_b:
    return expr_err(te,loc,NULL,"undeclared identifier: %s",qvar2string(q));
  case &Global_b(vd):  *q = *vd->name; return vd->type;
  case &Funname_b(fd): *q = *fd->name; return fndecl2typ(fd);
  case &Pat_b(vd):     fallthru(vd);
  case &Local_b(vd):   fallthru(vd);
  case &Param_b(vd):   (*q)[0] = Loc_n; return vd->type;
  }
}

static 
void check_format_args(tenv_t<`g,`r> te, exp_t fmt, 
                       opt_t<list_t<exp_t>> opt_args,
		       list_t<type_t> 
                         type_getter(tenv_t<`g,`r>,string_t,seg_t)) {
  // check the format string and get the types it requires
  list_t<type_t> desc_types;
  switch (fmt->r) {
  case &Const_e(String_c(s)): fallthru(s);
  case &Cast_e(_,&Exp(_,&Const_e(String_c(s)),_,_),_,_):
    desc_types = type_getter(te,s,fmt->loc); break;
  default: 
    // without a string literal argument, we can't check the args against
    // the format string, but we still have to check they are type-correct.
    if (opt_args != NULL) {
      let args = opt_args->v;
      for (; args != NULL; args = args->tl) {
        tcExp(te,NULL,args->hd);
	if (is_unique_pointer(args->hd->topt->v) && !is_unique_path(args->hd))
	  terr(args->hd->loc, UNIQUE_ERR_MSG, __LINE__);
      }
    }
    return; 
  }
  if (opt_args != NULL) {
    let args = opt_args->v;
    // check that each expression has the right type
    for (; desc_types != NULL && args != NULL; 
	 desc_types = desc_types->tl, args = args->tl) {
      type_t t = desc_types->hd;
      exp_t  e = args->hd;
      tcExp(te,&t,e);
      if (!coerce_arg(te,e,t)) {
        terr(e->loc,"descriptor has type \n%s\n but argument has type \n%s",
             typ2string(t), typ2string(e->topt->v));
        explain_failure();
      }
      if (is_unique_pointer(t) && !is_unique_path(e))
	terr(args->hd->loc,UNIQUE_ERR_MSG, __LINE__);
    }
    // check arity
    if (desc_types != NULL)
      terr(fmt->loc,"too few arguments");
    if (args != NULL)
      terr(args->hd->loc,"too many arguments");
  }
}
static type_t tcUnPrimop(tenv_t te, seg_t loc, type_t * topt,
			 primop_t p,exp_t e){
  type_t t = compress(e->topt->v);
  switch (p) {
  case Plus: 
  case Minus:
    if (!is_numeric(e))
      terr(loc,"expecting arithmetic type but found %s",typ2string(t));
    return e->topt->v;
  case Not:
    check_contains_assign(e);
    if (!coerce_to_bool(te,e))
      terr(loc,"expecting integral or * type but found %s",typ2string(t));
    return sint_typ;
  case Bitnot:
    if (!is_integral(e))
      terr(loc,"expecting integral type but found %s",typ2string(t));
    return e->topt->v;
  case Size:
    switch (t) {
    case &ArrayType(_): break;
    case &PointerType(PtrInfo(_,_,PtrAtts(_,_,b,_,_))): 
      switch(compress_conref(b)->v) {
      case Eq_constr(DynForward_b):
      case Eq_constr(DynEither_b):
      case Eq_constr(&Upper_b(_)): break;
      default: terr(loc,"can't apply size to pointer/array of abstract length");
      }
      break;
    default:
      terr(loc,"size requires pointer or array type, not %s",typ2string(t));
    }
    return uint_typ;
  default: impos("Non-unary primop");
  }
}

// Note: promoter must return false for any non-arithmetic type.
static type_t tcArithBinop(tenv_t te, exp_t e1, exp_t e2, 
			   bool checker(exp_t)) {
  // JGMFIX: lousy error messages...
  if (!checker(e1)) {
    terr(e1->loc,"type %s cannot be used here",typ2string(e1->topt->v));
    return wildtyp(new Opt(lookup_type_vars(te)));
  }
  if (!checker(e2)) {
    terr(e2->loc,"type %s cannot be used here",typ2string(e2->topt->v));
    return wildtyp(new Opt(lookup_type_vars(te)));
  }
  type_t t1 = compress(e1->topt->v);
  type_t t2 = compress(e2->topt->v);
  return max_arithmetic_type(t1,t2);
}
// Plus needs to support a pointer and an int
static type_t tcPlus(tenv_t te, exp_t e1, exp_t e2) {
  type_t t1 = compress(e1->topt->v);
  type_t t2 = compress(e2->topt->v);
  switch (t1) {
  case &PointerType(PtrInfo(et,tq,PtrAtts(r,n,b,zt,_))):
    if (!kind_leq(typ_kind(et),MemKind))
      terr(e1->loc,"can't perform arithmetic on abstract pointer type");
    if (is_unique_pointer(t1))
      terr(e1->loc,"can't perform arithmetic on unique pointer type");
    if (!coerce_sint_typ(te, e2))
      terr(e2->loc,"expecting int but found %s",typ2string(t2));
    b = compress_conref(b);
    switch (b->v) {
    case Eq_constr(DynForward_b): 
      // FIX: warn if e2 is negative
      return t1;
    case Eq_constr(DynEither_b): return t1;
    case Eq_constr(&Upper_b(ub)):
      // if we have a zero-terminated array, warn that this could
      // be expensive, since coercing to a fat pointer involves a loop.  
      if (conref_def(false,zt)) 
        warn(e1->loc, "pointer arithmetic on thin, zero-terminated pointer may be expensive.");
      // we have to allow pointer arithmetic that might go out of bounds
      // here.  Consider:
      //   int buf[10] = {...};
      //   *((buf + 11) - 10)
      // This should not generate an exception.  So the best we can do
      // is coerce e1 to a ?- type.
      let new_t1 = new PointerType(PtrInfo(et,tq,
					   PtrAtts(r,true_conref,
						   bounds_dyneither_conref,zt,
                                                   NULL)));
      unchecked_cast(te, e1, new_t1, Other_coercion);
      return new_t1;
    case Eq_constr(&AbsUpper_b(_)):
      terr(e1->loc, "pointer arithmetic not allowed on pointers with "
	   "abstract bounds");
      return t1;
    default: b->v = Eq_constr(DynForward_b); return t1;
    }
  default: return tcArithBinop(te, e1, e2, is_numeric);
  }
}
// Minus needs to support a fat pointer and an int, and two pointers
// of any flavor.
static type_t tcMinus(tenv_t te, exp_t e1, exp_t e2) {
  type_t t1 = e1->topt->v;
  type_t t2 = e2->topt->v;
  type_t t1_elt = VoidType;
  bool forward_only1 = false;
  bool forward_only2 = false;
  if (is_tagged_pointer_typ_elt(t1,&t1_elt,&forward_only1)) {
    if (is_tagged_pointer_typ(t2,&forward_only2)) {
      if (!unify(t1, t2)) {
	terr(e1->loc,"pointer arithmetic on values of "
             "different types (%s != %s)",
             typ2string(e1->topt->v),typ2string(e2->topt->v));
        explain_failure();
      }
      return sint_typ;
    } else {
      if (forward_only1)
        terr(e1->loc,"can't subtract from forward-only ? pointer");
      if (!kind_leq(typ_kind(t1_elt),MemKind))
        terr(e1->loc,"can't perform arithmetic on abstract pointer type");
      if (is_unique_pointer(t1))
	terr(e1->loc,"can't perform arithmetic on unique pointer type");
      if (!coerce_sint_typ(te, e2)) {
	terr(e2->loc,"expecting either %s or int but found %s",
             typ2string(t1),typ2string(t2));
        explain_failure();
      }
      return t1;
    }
  } 
  // if we have pointers at this point, cast them to ints 
  if (is_pointer_type(t1)) 
    unchecked_cast(te, e1, sint_typ, Other_coercion);
  if (is_pointer_type(t2))
    unchecked_cast(te, e2, sint_typ, Other_coercion);
  return tcArithBinop(te, e1, e2, is_numeric);
}

static type_t tcAnyBinop(tenv_t te, seg_t loc, exp_t e1, exp_t e2) {
  bool e1_is_num = is_numeric(e1);
  bool e2_is_num = is_numeric(e2);
  type_t t1 = compress(e1->topt->v);
  type_t t2 = compress(e2->topt->v);
  if (e1_is_num && e2_is_num)
    return sint_typ;
  // okay if same types and boxed
  else if (unify(t1,t2) && 
           unify(t1,new_evar(&bk,new Opt(lookup_type_vars(te)))))
    return sint_typ;
  // okay if t1 can be silently cast to t2 or vice versa 
  else if (silent_castable(te,loc,t2,t1)) {
    unchecked_cast(te,e2,t1, Other_coercion);
    return sint_typ;
  } else if (silent_castable(te,loc,t1,t2)) {
    unchecked_cast(te,e1,t2, Other_coercion);
    return sint_typ;
  } else if (zero_to_null(te,t2,e1) || zero_to_null(te,t1,e2))
    return sint_typ;
  // support comparisons on pointers
  else {
    switch ($(compress(t1), compress(t2))) {
    case $(&PointerType(PtrInfo{t1a,_,_}),
	   &PointerType(PtrInfo{t2a,_,_})):
      if (unify(t1a,t2a)) return sint_typ; break;
    default: break;
    }
    terr(loc,"comparison not allowed between %s and %s",
         typ2string(t1),typ2string(t2));
    explain_failure();
    return wildtyp(new Opt(lookup_type_vars(te)));
  }
}

// Binary primops like e1+e2, e1>>e2, etc.
// Note: e1 and e2 must have already been type-checked.
static type_t tcBinPrimop(tenv_t te, seg_t loc, type_t * topt,
                          primop_t p, exp_t e1, exp_t e2) {
  switch (p) {
  case Plus:  return tcPlus(te,e1,e2);
  case Minus: return tcMinus(te,e1,e2);

  case Times:      
  case Div: return tcArithBinop(te,e1,e2,is_numeric);

  case Mod:        
  case Bitand:     
  case Bitor:      
  case Bitxor:     
  case Bitlshift:  
  case Bitlrshift: 
  case Bitarshift: return tcArithBinop(te,e1,e2,is_integral);

    // Note: comparing pointers relies on memory-manager properties
    //       (but darned useful for dictionaries)
  case Eq:         
  case Neq:        
  case Gt:         
  case Lt:         
  case Gte:        
  case Lte: return tcAnyBinop(te,loc,e1,e2);

  default: impos("bad binary primop");
  }
}

static type_t tcPrimop(tenv_t te, seg_t loc, type_t * topt,
                       primop_t p, list_t<exp_t> es) {
  // An ugly hack to push topt below unary minus.  This comes in
  // handy because it stops warnings from being printed on array
  // initializers generated by bison (where (short)4 looks like
  // we're losing precision).
  // HOWEVER it should be nuked when we re-write the type checker
  // to solve the general problem.
  if (p == Minus && List::length(es) == 1)
    return tcExp(te,topt,es->hd);
  tcExpList(te,es);
  type_t t;
  switch (List::length(es)) {
  case 0:  return expr_err(te,loc,topt,"primitive operator has 0 arguments");
  case 1:  t = tcUnPrimop(te,loc,topt,p,es->hd); break;
  case 2:  t = tcBinPrimop(te,loc,topt,p,es->hd,es->tl->hd); break;
  default: return expr_err(te,loc,topt,"primitive operator has > 2 arguments");
  }
  return t;
}

// check that e is not a const expression -- assumes e is already
// an lvalue and is type-checked
static void check_writable(tenv_t te, exp_t e) {
  switch (e->r) {
  case &Var_e(_,&Param_b(vd)): fallthru(vd);
  case &Var_e(_,&Local_b(vd)): fallthru(vd);
  case &Var_e(_,&Pat_b(vd)):   fallthru(vd);
  case &Var_e(_,&Global_b(vd)): if (!vd->tq.real_const) return; break;
  case &Subscript_e(e1,e2):
    switch (compress(e1->topt->v)) {
    case &PointerType(PtrInfo{_,tq,_}): fallthru(tq);
    case &ArrayType(ArrayInfo{_,tq,_,_,_}): if (!tq.real_const) return; break;
    case &TupleType(ts):
      let $(i,known) = Evexp::eval_const_uint_exp(e2);
      if(!known) {
	terr(e->loc, "tuple projection cannot use sizeof or offsetof");
	return;
      }
      try {
        let &$(tq,_) = List::nth(ts,i);
        if (!tq.real_const) return;
      } catch { case Nth: return; }
      break;
    default: break;
    }
    break;
  case &AggrMember_e(e1,f):
    switch (compress(e1->topt->v)) {
    case &AggrType(AggrInfo(KnownAggr(adp),_)):
      struct Aggrfield *sf = 
        (adp == NULL) ? NULL : lookup_decl_field(*adp, f);
      if (sf == NULL || !sf->tq.real_const) return;
      break;
    case &AnonAggrType(_,fs): 
      struct Aggrfield *sf = lookup_field(fs, f);
      if (sf == NULL || !sf->tq.real_const) return;
      break;
    default: break;
    }
    break;
  case &AggrArrow_e(e1,f):
    switch (compress(e1->topt->v)) {
    case &PointerType(PtrInfo{elt_typ,_,_}):
      switch (compress(elt_typ)) {
      case &AggrType(AggrInfo(KnownAggr(adp),_)):
	struct Aggrfield *sf = 
	  (adp == NULL) ? NULL : lookup_decl_field(*adp, f);
	if (sf == NULL || !sf->tq.real_const) return;
	break;
      case &AnonAggrType(_,fs): 
	struct Aggrfield *sf = lookup_field(fs, f);
	if (sf == NULL || !sf->tq.real_const) return;
	break;
      default: break;
      }
      break;
    default: break;
    }
    break;
  case &Deref_e(e1):
    switch (compress(e1->topt->v)) {
    case &PointerType(PtrInfo{_,tq,_}): fallthru(tq);
    case &ArrayType(ArrayInfo{_,tq,_,_,_}): if (!tq.real_const) return; break;
    default: break;
    }
    break;
  case &NoInstantiate_e(e1): fallthru(e1);
  case &Instantiate_e(e1,_): check_writable(te,e1); return;
  default: break;
  }
  terr(e->loc, "attempt to write a const location: %s", exp2string(e));
}

static type_t tcIncrement(tenv_t te, seg_t loc, type_t * topt,
                          exp_t e, incrementor_t i) {
  // Don't promote any arrays to pointers, as per K&R
  tcExpNoPromote(te,NULL,e);
  if(!is_lvalue(e))
    return expr_err(te,loc,topt,"increment/decrement of non-lvalue");
  check_writable(te, e);
  type_t t = e->topt->v;
  // FIX: this is not right -- for instance, it allows incrementing an enum!!
  if (!is_numeric(e)) {
    type_t telt = VoidType;
    bool forward_only = false;
    if (is_tagged_pointer_typ_elt(t,&telt,&forward_only) || 
        (is_zero_pointer_typ_elt(t,&telt) && (i == PreInc || i == PostInc))) {
      if (!kind_leq(typ_kind(telt),MemKind))
        terr(e->loc,"can't perform arithmetic on abstract pointer type");
      if (is_unique_pointer(t))
        terr(e->loc,"can't perform arithmetic on unique pointer type");
      if (forward_only && (i == PreDec || i == PostDec))
        terr(e->loc,"can't subtract from forward-only ? pointer");
    } else 
      terr(e->loc,"expecting arithmetic or ? type but found %s",typ2string(t));
  }
  return t;
}

// e1 ? e2 : e3
static type_t tcConditional(tenv_t te, seg_t loc, type_t * topt,
                            exp_t e1, exp_t e2, exp_t e3) {
  tcTest(te, e1, "conditional expression");
  tcExp(te,topt,e2);
  tcExp(te,topt,e3);
  type_t t = new_evar(&mk,new Opt(lookup_type_vars(te)));
  let l1 = List(e3,NULL);
  let l2 = List(e2,&l1);
  if (!coerce_list(te,t,&l2)) {
    terr(loc,"conditional clause types do not match: %s != %s",
         typ2string(e2->topt->v),typ2string(e3->topt->v));
    explain_failure();
  }
  return t;
}

// e1 && e2
static type_t tcAnd(tenv_t te, seg_t loc, exp_t e1, exp_t e2) {
  tcTest(te,e1,"logical-and expression");
  tcTest(te,e2,"logical-and expression");
  return sint_typ;
}

// e1 || e2
static type_t tcOr(tenv_t te, seg_t loc, exp_t e1, exp_t e2) {
  tcTest(te,e1,"logical-or expression");
  tcTest(te,e2,"logical-or expression");
  return sint_typ;
}

// Assignments with optional operations, e.g., x = 3, x += 5
static type_t tcAssignOp(tenv_t te, seg_t loc, type_t * topt,
                         exp_t e1, opt_t<primop_t> po, exp_t e2) {
  // FIX: Not right b/c of funcions vs. function pointers???
  //   JGM: this is okay because we shouldn't be able to assign to
  //   a function.  Since e2 cannot have a function type (any function
  //   types are promoted to function pointers) the types won't match.
  // As per K&R, don't promote any array types to pointer types in the lhs
  region r {
    tcExpNoPromote(enter_notreadctxt(r,te),NULL,e1);
  }
  tcExp(te,&e1->topt->v,e2);
  type_t t1 = e1->topt->v;
  type_t t2 = e2->topt->v;
  // Check to see that the type is not an array type
  switch (compress(t1)) {
  case &ArrayType(_): terr(loc,"cannot assign to an array"); break;
  default: break;
  }
  // check to see that the type is not an abstract type
  if (!kind_leq(typ_kind(t1),MemKind))
    terr(loc,"type is abstract (can't determine size).");
  // Check to see if e1 is an lvalue after typechecking, so that
  // UnknownIds have been resolved.
  if (!is_lvalue(e1))
    return expr_err(te,loc,topt,"assignment to non-lvalue");
  check_writable(te, e1);
  if (po == NULL) {
    if (is_unique_pointer(t2) && !is_unique_path(e2))
      terr(e2->loc,UNIQUE_ERR_MSG, __LINE__);
    if (!coerce_assign(te,e2,t1)) {
      let result = expr_err(te,loc,topt,"type mismatch: %s != %s",
                            typ2string(t1), typ2string(t2));
      unify(t1,t2); // needed to get right error message
      explain_failure();
      return result;
    }
  } else {
    let p        = po->v;
    let t_result = tcBinPrimop(te,loc,NULL,p,e1,e2);
    if (!(unify(t_result,t1) || coerceable(t_result) && coerceable(t1))) {
      let result = 
        expr_err(te,loc,topt, "Cannot use this operator in an assignment when "
		      "the arguments have types %s and %s",typ2string(t1),
		      typ2string(t2));
      unify(t_result,t1); // needed to get right error message
      explain_failure();
      return result;
    }
    return t_result;
  }
  return t1;
}

// e1,e2
static type_t tcSeqExp(tenv_t te,seg_t loc,type_t * topt,exp_t e1,exp_t e2) {
  tcExp(te,NULL,e1);
  tcExp(te,topt,e2);
  return e2->topt->v;
}

// try to find a field that e can be injected into
static struct Tunionfield *tcInjection(tenv_t te,exp_t e,type_t tu,
                                       region_t<`r> r,
                                       list_t<$(tvar_t,type_t)@`r,`r> inst, 
                                       list_t<tunionfield_t> fs) {
  static tunion Type.DoubleType dbl = DoubleType(false);
  static type_t dbl_typ = &dbl;

  list_t<tunionfield_t> fields;
  type_t t1 = e->topt->v;
  // must promote float to double, and char/short to int
  switch (compress(t1)) {
  case FloatType: unchecked_cast(te,e,dbl_typ,No_coercion);t1 = dbl_typ; break;
  case &IntType(_,Char_sz): 
  case &IntType(_,Short_sz): unchecked_cast(te,e,sint_typ,No_coercion);t1 = sint_typ; break;
  default: break;
  }
  // try to find an exact match first
  for (fields = fs; fields != NULL; fields = fields->tl) {
    let Tunionfield{n,typs,loc,sc} = *fields->hd;
    // should have exactly one argument
    if (typs == NULL || typs->tl != NULL) continue;
    type_t t2 = rsubstitute(r,inst,(*typs->hd)[1]);
    // I hate doing this because it has side-effects, but oh well...
    if (unify(t1,t2))
      return fields->hd;
  }
  // now try to find a match supported by silent conversions
  for (fields = fs; fields != NULL; fields = fields->tl) {
    let Tunionfield{n,typs,loc,sc} = *fields->hd;
    // should have exactly one argument 
    if (typs == NULL || typs->tl != NULL) continue;
    type_t t2 = rsubstitute(r,inst,(*typs->hd)[1]);
    // I hate doing this because it has side-effects, but oh well...
    if (coerce_arg(te,e,t2)) {
      return fields->hd;
    } 
  }
  terr(e->loc,"can't find a field in %s to inject a value of type %s",
       typ2string(tu), typ2string(t1));
  return NULL;
}

// e(es)
static type_t tcFnCall(tenv_t te_orig,seg_t loc,type_t * topt,exp_t e,
		       list_t<exp_t> args,
		       vararg_call_info_t *@vararg_call_info) {
  // if e is a vararg function then we need to declare a new local
  // region block -- we just do it always here.
  let es = args;
  region ter {
    let te = new_block(ter,loc,te_orig); // needed for regions of params
    tcExp(te,NULL,e);
    type_t t = compress(e->topt->v);
    // NB: we should really unify t with an unconstrained FnType with the
    // right arity but there may be coercions involved with the arguments
    // and the function might actually be a vararg.
    switch (t) {
    case &PointerType(PtrInfo(t1,tq,PtrAtts(rgn,x,b,zt,_))):
      // Note: rgn is irrelevant -- all code is in the heap.
      // Nonetheless, perhaps we cast to another region, so check
      // the capability just for fun.
      check_rgn_accessible(te,loc,rgn);
      // Check that the bounds on the pointer aren't 0
      check_nonzero_bound(loc,b);
      switch (compress(t1)) {
        case &FnType(FnInfo{tvars,eff,res_typ,args_info,c_vararg,cyc_vararg,
                              rgn_po,atts}): 
          //FIX: handle tvars??
          // unify the result type with the expected type to get better
          // information while type-checking the arguments.
          if (topt != NULL) unify(res_typ,*topt);
        // check that each argument has the right type or can be coerced to it
        while ((es != NULL) && (args_info != NULL)) {
          exp_t e1 = es->hd;
          type_t t2 = (*args_info->hd)[2];
          tcExp(te, &t2, e1);
          if (!coerce_arg(te,e1,t2)) {
            terr(e1->loc,
                 "actual argument has type \n\t%s\n but formal has type \n\t%s.",
                 typ2string(e1->topt->v),typ2string(t2));
            unify(e1->topt->v,t2);
            explain_failure();
          }
	  if (is_unique_pointer(t2) && !is_unique_path(e1))
	    terr(e1->loc,UNIQUE_ERR_MSG, __LINE__);
          es = es->tl;
          args_info = args_info->tl;
        }
        // Note -- we deal with too few or too many args below.  Here, we
        // check for a format attribute -- important to do this early on
        // so that we get the right types for things
        bool args_already_checked = false;
        for (_ a = atts; a != NULL; a = a->tl) {
          switch (a->hd) {
          case &Format_att(ft,fmt_arg_pos,arg_start_pos):
            try {
              // get the format descriptor string
              let fmt_arg = List::nth(args,fmt_arg_pos - 1);
              // get the varargs
              opt_t<list_t<exp_t>> fmt_args;
              if (arg_start_pos == 0)
                fmt_args = NULL;
              else
                fmt_args = new Opt(nth_tail(args,arg_start_pos - 1));
              args_already_checked = true;
              switch (ft) {
              case Printf_ft:
                check_format_args(te,fmt_arg,fmt_args,Formatstr::get_format_typs);
                break;
              case Scanf_ft:
                check_format_args(te,fmt_arg,fmt_args,Formatstr::get_scanf_typs);
                break;
              }
            } catch {
            case Nth: terr(loc,"bad format arguments"); break;
            }
            break;
          default: break;
          }
        }
        if (args_info != NULL) terr(loc,"too few arguments for function");
        // if we have left-over arguments, then check for varargs
        else if (es != NULL || c_vararg || cyc_vararg != NULL) {
          if(c_vararg)
            for(; es != NULL; es = es->tl)
              tcExp(te, NULL, es->hd);
          else if(cyc_vararg == NULL)
            terr(loc, "too many arguments for function");
          else {
            let VarargInfo{_,_,vt,inject} = *cyc_vararg;
            let vci = new VarargCallInfo {.num_varargs = 0, 
                                          .injectors = NULL,
                                          .vai = (vararg_info_t @)cyc_vararg};
            *vararg_call_info = vci;
            
            if (!inject) {
              // all the rest of the arguments are the same type
              for (; es != NULL; es = es->tl) {
                exp_t e1 = es->hd;
                vci->num_varargs++;
                tcExp(te, &vt, e1);
                if (!coerce_arg(te,e1,vt)) {
                  terr(loc,"vararg requires type %s but argument has type %s",
                       typ2string(vt),typ2string(e1->topt->v));
                  explain_failure();
                }
		if (is_unique_pointer(vt) && !is_unique_path(e1))
		  terr(e1->loc,UNIQUE_ERR_MSG, __LINE__);
              }
            } else {
              // this is trickier, we have to match up the type of the
              // actual argument with a constructor from the [x]tunion.
              switch (compress(vt)) {
              case &TunionType(TunionInfo{KnownTunion(&td),targs,tur}):
                // unfortunately, td may not be the "latest" declaration of
                // an xtunion, so we re-look it up in the environment.
                let td = *lookup_tuniondecl(te,loc,td->name);
                list_t<tunionfield_t> fields = NULL;
                if (td->fields == NULL) 
                  terr(loc,"can't inject into %s",typ2string(vt));
                else fields = td->fields->v;
                if(!unify(tur->v,curr_rgn(te)))
                  terr(loc,"bad region for injected varargs");
                region rgn {
                  let inst = List::rzip(rgn,rgn,td->tvs,targs);
                  for (; es != NULL; es = es->tl) {
                    vci->num_varargs++;
                    exp_t e1 = es->hd;
                    // must be careful not to type-check twice
                    if (!args_already_checked) {
                      tcExp(te,NULL,e1); 
		      if (is_unique_pointer(e1->topt->v) && 
			  !is_unique_path(e1))
			terr(e1->loc,UNIQUE_ERR_MSG, __LINE__);
		    }
                    let f = tcInjection(te,e1,vt,rgn,inst,fields);
                    if (f != NULL)
                      vci->injectors = 
                        List::append(vci->injectors,
                                     new List{(tunionfield_t)f,NULL});
                  }
                }
                break;
              default: terr(loc,"bad inject vararg type"); break;
              }
            }
          }
        }
        // Check that the effect of the function is compatible with the current
        // capability.  May be delayed.
        Tcenv::check_effect_accessible(te, loc, eff->v);
        // Check that the function's partial-order on region lifetimes 
        // is compatible with the current region partial order. May be delayed.
        Tcenv::check_rgn_partial_order(te, loc, rgn_po);
        return res_typ;
      default: return expr_err(te,loc,topt,"expected pointer to function");
      }
    default: return expr_err(te,loc,topt,"expected pointer to function");
    }
  }
}

// throw e1
static type_t tcThrow(tenv_t te, seg_t loc, type_t * topt, exp_t e) {
  tcExp(te,&exn_typ,e); 
  if (!coerce_arg(te,e,exn_typ))
    terr(loc,"expected xtunion exn but found %s",typ2string(e->topt->v));
  return wildtyp(new Opt(lookup_type_vars(te)));
}

// explicit instantiation
static type_t tcInstantiate(tenv_t te, seg_t loc, type_t * topt,
                            exp_t e, list_t<type_t> ts) {
  tcExpNoInst(te,NULL,e);
  // turn any functions into function pointers
  e->topt->v = pointer_expand(e->topt->v,false);
  type_t t1 = compress(e->topt->v);
  switch (t1) {
  case &PointerType(PtrInfo(t0,tq,PtrAtts(rt,x,b,zt,_))):
    switch (compress(t0)) {
    case &FnType(FnInfo{tvars,eff,rtyp,args,c_varargs,cyc_varargs,rpo,atts}):
      list_t<$(tvar_t,type_t)@> instantiation = NULL;
      // now allows partial instantiation
      for (; ts != NULL && tvars != NULL; ts = ts->tl, tvars = tvars->tl) {
	kind_t k = tvar_kind(tvars->hd);
	check_type(loc,te,lookup_type_vars(te),k,true,ts->hd);
	instantiation = new List(new $(tvars->hd,ts->hd),instantiation);
      }
      if(ts != NULL)
	return expr_err(te,loc,topt,"too many type variables in instantiation");
      type_t new_fn_typ = 
        substitute(instantiation,
                   new FnType(FnInfo{tvars,eff,rtyp,args,c_varargs,
                                     cyc_varargs,rpo,atts}));
      return new PointerType(PtrInfo(new_fn_typ,tq,PtrAtts(rt,x,b,zt,NULL)));
    default: break;
    }
    break;
  default: break;
  }
  return expr_err(te,loc,topt,"expecting polymorphic type but found %s",
                  typ2string(t1));
}

// (t)e
static type_t tcCast(tenv_t te, seg_t loc, type_t * topt, type_t t, exp_t e,
                     coercion_t *c) {
  check_type(loc,te,lookup_type_vars(te),MemKind,true,t);
  //  tcExp(te,NULL,e);
  tcExp(te,&t,e);
  type_t t2 = e->topt->v;
  if (silent_castable(te,loc,t2,t)) {
    *c = No_coercion;
  } else {
    coercion_t crc = castable(te,loc,t2,t);
    if (crc != Unknown_coercion) {
      *c = crc;
    } else if (zero_to_null(te,t,e)) {
      *c = No_coercion;
    } else {
      // extra unify needed to get the right reason for the failure
      unify(t2,t);
      let result = expr_err(te,loc,&t,"cannot cast %s to %s",
                            typ2string(t2), typ2string(t));
      explain_failure();
      return result;
    }
  }
  // special case -- if e is a m/calloc of size more than 1 and t is a * type
  // issue a warning -- this is a good sign that it's a legacy cast which will
  // lose information.
  switch ($(e->r, compress(t))) {
  case $(&Malloc_e(MallocInfo{_,_,_,_,fat_result}),
         &PointerType(PtrInfo{_,_,PtrAtts{_,nbl,bds,zt,_}})):
    // malloc must be fat and t must be a NOZEROTERM, *{1} type 
    if (fat_result && !conref_def(false,zt) && conref_def(false,nbl)) {
      switch (conref_def(bounds_one,bds)) {
      case &Upper_b(e2):
        if (Evexp::eval_const_uint_exp(e2)[0] == 1)
          warn(loc,"cast from ? pointer to * pointer will lose size information");
        break;
      default: break;
      }
    }
    break;
  default: break;
  }
  return t;
}

// e0 has the form &e, and optional type topt
static type_t tcAddress(tenv_t te, seg_t loc, exp_t e0, 
                        type_t * topt, exp_t e) {
  let topt2 = NULL;
  let tq2 = empty_tqual(NULL);
  if (topt != NULL) {
    switch (compress(*topt)) {
    case &PointerType(PtrInfo(elttype,tq,PtrAtts(_,_,_,zt,_))):
      //FIX: this allocation is needed because *elttype is compiled incorrectly!
      topt2 = new elttype;
      tq2 = tq;
      break;
    default: break;
    }
  }
  // Use tcExpNoInst here because if f is a function then
  // then &f is supposed to be a pointer to a function, not
  // a pointer to a pointer to a function
  // Notice that this also bypasses the array-to-pointer promotion
  // as required (see p. 200, A7.1 of K&R.)
  // We use clear_notreadctxt because the pointer might escape off
  // and later be read.
  region r {
    tcExpNoInst(clear_notreadctxt(r,te),topt2,e);
  }

  // first, dispense with the 
  // case where we have &e[i] and e is an array/pointer (i.e., not a tuple).
  switch (e->r) {
  case &Subscript_e(e1,e2):
    switch (compress(e1->topt->v)) {
    case &TupleType(_): break; // leave & for tuple types alone.
    default: 
      // we have &e[i] -- rewrite the whole expression as (e+i);
      // don't check for taking address of a unique pointer here,
      // since we aren't creating an alias.

      // This ensures that we get the right size for an array or ? pointer.
      e0->r = add_exp(e1,e2,NULL)->r; 
      return tcPlus(te,e1,e2);
    }
    break;
  default: break;
  }

  // we've got an address-of
  let $(is_const,rgn) = addressof_props(te,e);
  tqual_t tq = empty_tqual(NULL);
  if(is_const) {
    tq.print_const = true;
    tq.real_const = true;
  }
  // FIX: use topt to determine if we should return a tunion type
  type_t t = at_typ(e->topt->v, rgn, tq, false_conref);
  return t;
}

 // sizeof t
static type_t tcSizeof(tenv_t te, seg_t loc, type_t * topt, type_t t) {
  check_type(loc,te,lookup_type_vars(te),MemKind,true,t);
  if(!Evexp::okay_szofarg(t))
    terr(loc, "sizeof applied to type %s, which has unknown size here",
         typ2string(t));
  if (topt != NULL)
    switch (compress(*topt)) {
      // only return sizeof_t<t> when requested from context
    case &SizeofType(_): return new SizeofType(t);
    default: break;
    }
  return uint_typ; 
}

bool structfield_has_name(field_name_t n, aggrfield_t sf) {
  return (strcmp(*n,*sf->name) == 0);
}

// offsetof(t,n)
// FIX: check that n is actually a field of f (currently caught by gcc)
// FIX?: check if t is allowed to be a union type
static type_t tcOffsetof(tenv_t te, seg_t loc, type_t * topt, 
			 type_t t, offsetof_field_t n) {
  check_type(loc,te,lookup_type_vars(te),MemKind,true,t);
  switch(n) {
  case &StructField(n):
    bool bad_type = true;
    switch(compress(t)) {
    case &AggrType(AggrInfo(KnownAggr(adp),_)):
      if((*adp)->impl == NULL)
	break;
      if(!exists_c(structfield_has_name,n,(*adp)->impl->fields))
	terr(loc,"no field of struct/union has name %s",*n);
      bad_type = false;
      break;
    case &AnonAggrType(_,fields):
      if(!exists_c(structfield_has_name,n,fields))
	terr(loc,"no field of struct/union has name %s",*n);
      bad_type = false;
      break;
    default: break;
    }
    if(bad_type)
      terr(loc, "%s is not a known struct/union type", typ2string(t));
    break;
  case &TupleIndex(n):
    bool bad_type = true;
    switch(compress(t)) {
    case &AggrType(AggrInfo(KnownAggr(adp),_)):
      if((*adp)->impl == NULL)
	break;
      fallthru((*adp)->impl->fields);
    case &AnonAggrType(_,fields):
      if(List::length(fields) <= n) 
	Tcutil::terr(loc,"struct/union has too few components: %d <= %d",
		     List::length(fields),n);
      bad_type = false;
      break;
    case &TupleType(l):
      if(List::length(l) <= n)
	Tcutil::terr(loc,"tuple has too few components: %d <= %d",
		     List::length(l),n);
      bad_type = false;
      break;
    case &TunionFieldType(TunionFieldInfo(KnownTunionfield(_,tuf),_)):
      if(List::length(tuf->typs) < n)
	Tcutil::terr(loc,"tunionfield has too few components: %d < %d",
		     List::length(tuf->typs),n);
      bad_type = false;
      break;
    default: break;
    }
    if(bad_type)
      terr(loc, "%s is not a known type", typ2string(t));
    break;
  }
  return uint_typ;
}

 // *e
static type_t tcDeref(tenv_t te_orig, seg_t loc, type_t * topt, exp_t e) {
  region r { 
    let te = clear_notreadctxt(r,te_orig);
    tcExp(te,NULL,e);
    type_t t = compress(e->topt->v);
    switch (t) {
    case &PointerType(PtrInfo(t2,_,PtrAtts(rt,_,b,zt,_))):
      check_rgn_accessible(te,loc,rt);
      check_nonzero_bound(loc, b);
      if (!kind_leq(typ_kind(t2),MemKind))
        terr(loc,"can't dereference abstract pointer type");
      return t2;
    default: 
      return expr_err(te,loc,topt,"expecting * or @ type but found %s",typ2string(t));
    }
  }
}

// e.f
static type_t tcAggrMember(tenv_t te, seg_t loc, type_t * topt,
			   exp_t outer_e, exp_t e, field_name_t f) {
  // As per K&R, don't promote e from array to pointer type
  tcExpNoPromote(te,NULL,e);
  switch (compress(e->topt->v)) {
  case &AggrType(AggrInfo(KnownAggr(&ad),ts)):
    let finfo = lookup_decl_field(ad,f);
    if (finfo == NULL)
      return expr_err(te,loc,topt,"type %s has no %s field",
                      qvar2string(ad->name), *f);
    // must do after previous check else could dereference NULL
    if(ad->impl->exist_vars != NULL)
      return expr_err(te,loc,topt,"must use pattern-matching to access fields "
		      "of existential types");
    _ t2;
    region rgn {
      let inst = List::rzip(rgn,rgn,ad->tvs,ts);
      t2 = rsubstitute(rgn,inst,finfo->type);
      // prevent someone from reading a non-bits-only union member
      if (ad->kind == UnionA && !in_notreadctxt(te) && !bits_only(t2))
        return expr_err(te,loc,topt,"cannot read union member %s since it is not `bits-only'",*f);
    }
    return t2;
  case &AnonAggrType(k,fs):
    let finfo = lookup_field(fs,f);
    if (finfo == NULL)
      return expr_err(te,loc,topt,"type has no %s field",*f);
    if (k == UnionA && !in_notreadctxt(te) && !bits_only(finfo->type))
        return expr_err(te,loc,topt,"cannot read union member %s since it is not `bits-only'",*f);
    return finfo->type;
  case &ArrayType(_)   && (strcmp(*f,"size") == 0):
  case &PointerType(_) && (strcmp(*f,"size") == 0):
    outer_e->r = new Primop_e(Size,new List(e,NULL));
    return uint_typ;
  default:
    if (strcmp(*f,"size") == 0)
      return expr_err(te,loc,topt,
                      "expecting struct, union, or array, found %s",
                      typ2string(e->topt->v));
    else
      return expr_err(te,loc,topt,"expecting struct or union, found %s",
		      typ2string(e->topt->v));
  }
}

// e->f
static type_t tcAggrArrow(tenv_t te, seg_t loc, type_t * topt, 
			  exp_t e, field_name_t f) {
  region r {
    tcExp(clear_notreadctxt(r,te),NULL,e);
  }
  switch (compress(e->topt->v)) {
  case &PointerType(PtrInfo(t2,_,PtrAtts(rt,_,b,zt,_))):
    check_nonzero_bound(loc, b);
    switch (compress(t2)) {
    case &AggrType(AggrInfo(KnownAggr(&ad),ts)):
      let finfo = lookup_decl_field(ad,f);
      if (finfo == NULL)
	return expr_err(te,loc,topt,"type %s has no %s field",
			qvar2string(ad->name), *f);
      // must do after previous check else could dereference NULL
      if(ad->impl->exist_vars != NULL)
	return expr_err(te,loc,topt,
                        "must use pattern-matching to access fields "
			"of existential types");
      _ t3;
      region rgn {
	let inst = List::rzip(rgn,rgn,ad->tvs,ts);
	t3 = rsubstitute(rgn,inst,finfo->type);
      }
      if (ad->kind == UnionA && !in_notreadctxt(te) && !bits_only(t3))
        return expr_err(te,loc,topt,"cannot read union member %s since it is not `bits-only'",*f);
      return t3;
    case &AnonAggrType(k,fs):
      let finfo = lookup_field(fs,f);
      if (finfo == NULL)
	return expr_err(te,loc,topt,"type has no %s field",*f);
      if (k == UnionA && !in_notreadctxt(te) && !bits_only(finfo->type))
        return expr_err(te,loc,topt,"cannot read union member %s since it is not `bits-only'",*f);
      return finfo->type;
    default: break;
    }
    break;
  default: break;
  }
  return expr_err(te,loc,topt,"expecting struct or union pointer, found %s", 
		  typ2string(e->topt->v));
}

// e1[e2]
static type_t ithTupleType(tenv_t te, seg_t loc,
			   list_t<$(tqual_t,type_t)@> ts, exp_t index) {
  let $(i,known) = Evexp::eval_const_uint_exp(index);
  if(!known)
    return expr_err(te,loc,NULL,
                    "tuple projection cannot use sizeof or offsetof");
  try
    return (*List::nth(ts,i))[1];
  catch { case Nth:
    return expr_err(te,loc,NULL,"index is %d but tuple has only %d fields",
                    i, List::length(ts));
  }
}
 // FIX: look at topt
static type_t tcSubscript(tenv_t te_orig, seg_t loc, type_t * topt, 
			  exp_t e1, exp_t e2) {
  region r {
    let te = clear_notreadctxt(r,te_orig);
    tcExp(te,NULL,e1);
    tcExp(te,NULL,e2);
    type_t t1 = compress(e1->topt->v);
    type_t t2 = compress(e2->topt->v);
    if (!coerce_sint_typ(te,e2))
      return expr_err(te,e2->loc,topt,"expecting int subscript, found %s",
                      typ2string(t2));
    // the subscript could be on a tuple or a pointer -- any arrays
    // should've been coerced to pointers
    switch (t1) {
    case &PointerType(PtrInfo(t,tq,PtrAtts(rt,_,b,zt,_))):
      // for zero-terminated, thin pointers we warn when doing subscripting
      // to remind the user that this is an expensive operation.
      if (conref_def(false,zt)) {
        bool emit_warning = true;
        switch (compress_conref(b)->v) {
        case Eq_constr(&Upper_b(e3)):
          if (is_const_exp(te, e2)) {
            let $(i,known) = Evexp::eval_const_uint_exp(e2);
            if (known) {
              let $(j,knownj) = Evexp::eval_const_uint_exp(e3);
              if (knownj && j > i) emit_warning = false;
            }
          }
          break;
        case Eq_constr(DynForward_b): emit_warning = false; break;
        case Eq_constr(DynEither_b): emit_warning = false; break;
        default: break;
        }
        if (emit_warning) 
          warn(e2->loc, "subscript on thin, zero-terminated pointer could be expensive.");
      } else {
        // for nozero-terminated pointers
        if (is_const_exp(te, e2)) {
          let $(i,known) = Evexp::eval_const_uint_exp(e2);
          if (known)
            check_bound(loc,i,b);
        } else {
          // an easy warning that helps when porting C code
          if(is_bound_one(b) && !conref_def(false,zt))
            warn(e1->loc,"subscript applied to pointer to one object");
          check_nonzero_bound(loc,b);
        }
      }
      check_rgn_accessible(te,loc,rt);
      if (!kind_leq(typ_kind(t),MemKind))
        terr(e1->loc,"can't subscript an abstract pointer");
      return t;
    case &TupleType(ts): return ithTupleType(te,loc,ts,e2);
    default: return expr_err(te,loc,topt,"subscript applied to %s",typ2string(t1));
    }
  }
}

// $(es)
static type_t tcTuple(tenv_t te, seg_t loc, type_t * topt, list_t<exp_t> es) {
  bool done = false;
  list_t<$(tqual_t,type_t)@> fields = NULL;
  if(topt != NULL)
    switch (compress(*topt)) {
    case &TupleType(ts):
      if(length(ts) != length(es)) {
        // topt should never cause failure, just guides coercions.
	// terr(loc,"tuple expression has the wrong number of fields");
	break;
      }
      for(; es != NULL; es = es->tl, ts = ts->tl) {
	let topt2 = (*ts->hd)[1];
	tcExpInitializer(te,&topt2,es->hd);
        // try to coerce the argument to the result type
        coerce_arg(te,es->hd,(*ts->hd)[1]);
	fields = new List(new $((*ts->hd)[0], es->hd->topt->v), fields);
      }
      done = true;
      break;
    default: break;
    }
  if(!done)
    for(; es != NULL; es = es->tl) {
      tcExpInitializer(te,NULL,es->hd);
      fields = new List(new $(empty_tqual(NULL), es->hd->topt->v), fields);
    }
  return new TupleType(List::imp_rev(fields));
}

// Compound literals, e.g., (struct foo){3,"abc"}
static type_t tcCompoundLit(tenv_t te, seg_t loc, type_t * topt,
                             $(opt_t<stringptr_t>,tqual_t,type_t)@ t,
                             list_t<$(list_t<designator_t>,exp_t)@> des) {
  return expr_err(te,loc,topt,"tcCompoundLit");
}

 ///////////////////// Array ({e1,...,en}) /////////////////////////
 // FIX:  only a very limited class of designators (basically, the proper
 // index) is supported and all of the array elements must be present.
 // 
 // Note that we pass in an optional element type, not the (optional)
 // expected type of the array.  See tcNew and the call to tcArray.
 // We also pass in whether or not the array is to be zero terminated.
static type_t tcArray(tenv_t te,seg_t loc,type_t * elt_topt, bool zero_term,
                   list_t<$(list_t<designator_t>,exp_t)@> des) {
  type_t res_t2;
  region r {
    let           num_es  = List::length(des);
    list_t<exp_t,`r>  es  = List::rmap(r,snd,des);
    type_t        res     = new_evar(&mk,new Opt(lookup_type_vars(te)));
    let           sz_rexp = new Const_e(Int_c(Unsigned,num_es));
    exp_t         sz_exp  = new_exp(sz_rexp,loc);
    // if zero_term, check that last element in array is zero terminated.
    // Note that if we ever fix designators, then we need to fix this too.
    if (zero_term) {
      let e = List::nth(es, num_es - 1);
      if (!Tcutil::is_zero(e))
        terr(e->loc,"zero-terminated array doesn't end with zero.");
    }
    sz_exp->topt = new Opt(uint_typ);
    res_t2   = array_typ(res, empty_tqual(NULL), sz_exp, 
                         zero_term ? true_conref : false_conref,NULL);
    
    for (_ es2 = es; es2 != NULL; es2 = es2->tl)
      tcExpInitializer(te,elt_topt,es2->hd);

    if (!coerce_list(te,res,es))
    // JGMFIX: lousy error messages...
      terr(es->hd->loc,"elements of array do not all have the same type (%s)",
           typ2string(res));
  // check that any designators make sense
  }
  for(int offset = 0; des != NULL; offset++, des = des->tl) {
    list_t<designator_t> ds = (*des->hd)[0];
    if (ds != NULL)
      //   if (ds->hd->tl != NULL)
      //     terr(ds->hd[1]->loc,"only array index designators are supported");
      switch (ds->hd) {
      case &FieldName(_):
	terr(loc,"only array index designators are supported");
	break;
      case &ArrayElement(e):
	tcExpInitializer(te,NULL,e);
	let $(i,known) = Evexp::eval_const_uint_exp(e);
	if(!known)
	  terr(e->loc, "index designator cannot use sizeof or offsetof");
	else if (i != offset)
	  terr(e->loc, "expecting index designator %d but found %d",
               offset,i);
	break;
      }
  }
  
  return res_t2;
}

 // {for [te] < [bound] : [body]}
static type_t tcComprehension(tenv_t te, seg_t loc, type_t * topt,
                              vardecl_t vd, exp_t bound, exp_t body,
                              bool @is_zero_term) {
  tcExp(te,NULL,bound);
  switch(compress(bound->topt->v)) {
  case &TagType(_): break;
  default:
    if (!coerce_uint_typ(te,bound))
      terr(bound->loc,"expecting unsigned int, found %s",
	   typ2string(bound->topt->v));
  }
  // double-check that the index variable x is declared const
  if (!vd->tq.real_const)
    impos("comprehension index variable is not declared const!");
  // add x to the environment as an unsigned int only if te->le is not NULL
  region r {
    tenv_t<_,`r> te2 = copy_tenv(r,te);
    if (te2->le != NULL) {
      te2 = Tcenv::new_block(r,loc,te2);
      te2 = add_local_var(r, loc, te2, vd);
    }
    let te = te2;
    _ pinfo;
    let topt2 = NULL;
    let tqopt = NULL;
    let ztopt = NULL;
    
    if (topt != NULL)
      switch (compress(*topt)) {
      case &PointerType(x):
        pinfo = x;
        topt2 = &pinfo.elt_typ;
        tqopt = &pinfo.elt_tq;
        ztopt = &pinfo.ptr_atts.zero_term;
        break;
      case &ArrayType(ArrayInfo{*t,*tq,b,*zt,_}):
        topt2 = t;
        tqopt = tq;
        ztopt = zt;
        break;
      default:
        break;
      }
    // type-check the body in the new environment
    type_t t = tcExp(te,topt2,body);
    if (te->le == NULL) {
      // the bound and the body must both be constant expressions at top-level
      if (!is_const_exp(te,bound))
        terr(bound->loc,"bound is not constant");
      if (!is_const_exp(te,body))
        terr(bound->loc,"body is not constant");
    }
    if (ztopt != NULL && conref_def(false,*ztopt)) {
      // for zero-terminated arrays, the result is one larger due to the
      // implicit zero.
      let e1 = uint_exp(1,NULL); e1->topt = new Opt(uint_typ);
      bound = add_exp(bound,e1,NULL); bound->topt = new Opt(uint_typ);
      *is_zero_term = true;
    }
    // FIX:  bound may not be a constant here...
    return array_typ(t,(tqopt == NULL) ? empty_tqual(NULL) : *tqopt, bound, 
                     (ztopt == NULL) ? false_conref : *ztopt, NULL);
  }
}

 //////////////////// Struct (f{e1,...,en}) ///////////////////
 // FIX:
 // Right now, we only allow one field name designator on an argument.
 // In addition, we assume any undesignated argument is associated with
 // the first field that has not yet been explicitly mentioned.  So,
 // for instance, if we have:
 //  struct Foo {int a,b,c,d,e;}
 //  Foo{.c=3,.d=4,1,2,5};
 // then this is the same as Foo{.a=1,.b=2,.c=3,.d=4,.e=5};
 // Later, we should support array designators and so forth.
static type_t tcStruct(tenv_t te, seg_t loc, type_t * topt,
                       typedef_name_t @tn, list_t<type_t,`H> @ ts,
                       list_t<$(list_t<designator_t>,exp_t)@> args,
                       struct Aggrdecl *`H @`H ad_opt) {
  aggrdecl_t ad;
  if (*ad_opt != NULL)
    ad = (aggrdecl_t)(*ad_opt);
  else {
    try ad = *lookup_aggrdecl(te,loc,*tn);
    catch { case Dict::Absent:
      terr(loc, "unbound struct name %s",qvar2string(*tn));
      return topt != NULL ? *topt : VoidType;
    }
    *ad_opt = ad;
    *tn = ad->name;
  }
  if(ad->kind == UnionA)
    terr(loc, "expecting struct but found union");
  if (ad->impl == NULL) {
    terr(loc,"can't build abstract struct");
    return wildtyp(new Opt(lookup_type_vars(te)));
  }
  region rgn {
  // calculate the instantiation and final type
  let env = $(lookup_type_vars(te),rgn);
  let all_inst   = List::rmap_c(rgn,r_make_inst_var,&env,ad->tvs);
  let exist_inst = List::rmap_c(rgn,r_make_inst_var,&env,ad->impl->exist_vars);
  let all_typs   = List::map(snd,all_inst);
  let exist_typs = List::map(snd,exist_inst);
  let inst       = List::rappend(rgn,all_inst,exist_inst);
  let res_typ = new AggrType(AggrInfo(KnownAggr(new ad),all_typs));
  // integrate any witnesses the programmer wrote explicitly
  let user_ex_ts = *ts;
  let ex_ts = exist_typs;
  while(user_ex_ts != NULL && ex_ts != NULL) {
    // FIX: allow other kinds
    check_type(loc,te,lookup_type_vars(te),AnyKind,true,user_ex_ts->hd);
    unify(user_ex_ts->hd,ex_ts->hd);
    user_ex_ts = user_ex_ts->tl;
    ex_ts      = ex_ts->tl;
  }
  if(user_ex_ts != NULL)
    terr(loc, "too many explicit witness types");
    
  *ts = exist_typs;

  // this will instantiate the struct if we have type information in topt
  // unfortunately, I think it allows topt to cause failure.
  // It's important for region partial order stuff though (so user can pick
  // the region bound)
  if (topt != NULL) unify(res_typ,*topt);
  // make sure each argument has the right type
  list_t<$(aggrfield_t,exp_t)@`rgn,`rgn> fields =
    resolve_struct_designators(rgn,loc,args,ad->impl->fields);
  for(; fields != NULL; fields = fields->tl) {
    let &$(field,field_exp) = fields->hd;
    let inst_fieldtyp = rsubstitute(rgn,inst,field->type);
    tcExpInitializer(te, &inst_fieldtyp, field_exp);
    if (!coerce_arg(te,field_exp,inst_fieldtyp)) {
      terr(field_exp->loc,"field %s of struct %s expects type %s != %s",
           *(field->name),qvar2string(*tn),typ2string(inst_fieldtyp),
           typ2string(field_exp->topt->v));
      explain_failure();
    }
  }
  let rpo_inst = NULL;
  for(let rpo=ad->impl->rgn_po; rpo != NULL; rpo = rpo->tl)
    rpo_inst = new List(new $(rsubstitute(rgn,inst,(*rpo->hd)[0]),
			      rsubstitute(rgn,inst,(*rpo->hd)[1])),
			rpo_inst);
  rpo_inst = imp_rev(rpo_inst);
  Tcenv::check_rgn_partial_order(te,loc,rpo_inst);
  return res_typ;
  }
}

static type_t tcAnonStruct(tenv_t te, seg_t loc, type_t ts, 
                           list_t<$(list_t<designator_t>,exp_t)@> args) {
  region rgn {
    switch (compress(ts)) {
    case &AnonAggrType(k,fs):
      if(k==UnionA)
	terr(loc,"expecting struct but found union");
      list_t<$(aggrfield_t,exp_t)@`rgn,`rgn> fields = 
        resolve_struct_designators(rgn,loc,args,fs);
      for (; fields != NULL; fields = fields->tl) {
        let &$(field,field_exp) = fields->hd;
        tcExpInitializer(te, &field->type, field_exp);
        if (!coerce_arg(te,field_exp,field->type)) {
          terr(field_exp->loc,"field %s of struct expects type %s != %s",
               *(field->name),typ2string(field->type),
               typ2string(field_exp->topt->v));
          explain_failure();
        }
      }
      break;
    default: impos("tcAnonStruct: wrong type");
    }
  }
  return ts;
}

// f(es)   where f is a tunion and is tuf->name
static type_t tcTunion(tenv_t te, seg_t loc, type_t * topt, exp_t e,
		       list_t<exp_t> es, tuniondecl_t tud, tunionfield_t tuf) {
  region rgn {
  let env      = $(lookup_type_vars(te),rgn);
  let inst     = List::rmap_c(rgn,r_make_inst_var,&env,tud->tvs);
  let all_typs = List::map(snd,inst);
  type_t res =
    new TunionFieldType(TunionFieldInfo{KnownTunionfield(tud,tuf),
					all_typs});
  // this instantiates the type variables if we have top-down type info
  if (topt != NULL) {
    switch (compress(*topt)) {
    case &TunionFieldType(_): unify(*topt,res); break;
    case &TunionType(TunionInfo{_,targs,r}):
      for (_ a = all_typs; a != NULL && targs != NULL; a=a->tl,targs=targs->tl)
        unify(a->hd,targs->hd);
      // top-down, we're looking for a Tunion, not a Tunion field.
      // we can cast up here if there are no arguments to the constructor
      // or the tunion is flat.
      if (tud->is_flat || (tuf->typs == NULL && es == NULL)) {
        e->topt = new Opt(res);
        res = new TunionType(TunionInfo{KnownTunion(new tud),all_typs,r});
        unchecked_cast(te, e, res, No_coercion);
        // return res;
      }
      break;
    default: break;
    }
  }
  list_t<$(tqual_t,type_t)@> ts = tuf->typs;
  for(; es != NULL && ts != NULL; es = es->tl, ts = ts->tl) {
    exp_t  e = es->hd;
    type_t t = rsubstitute(rgn,inst,(*ts->hd)[1]);
    tcExpInitializer(te, &t, e);
    if (!coerce_arg(te,e,t)) {
      terr(e->loc,"tunion constructor %s expects argument of type %s "
           "but this argument has type %s",
           qvar2string(tuf->name),typ2string(t),
           (e->topt == NULL) ? (string_t)"?" : typ2string(e->topt->v));
      explain_failure();
    }
  }
  if (es != NULL)
    return expr_err(te,es->hd->loc,topt,
                    "too many arguments for tunion constructor %s",
                    qvar2string(tuf->name));
  if (ts != NULL)
    return expr_err(te,loc,topt,"too few arguments for tunion constructor %s",
                    qvar2string(tuf->name));
  return res;
  }
}

static bool zeroable_type(type_t t) {
  switch (compress(t)) {
  case VoidType: return true;
  case &Evar(_,_,_,_):
  case &VarType(_): 
  case &TunionType(_):
  case &TunionFieldType(_): return false;
  case &PointerType(PtrInfo(_,_,PtrAtts(_,n,_,_,_))):
    return (conref_def(true,n));
  case &IntType(_,_):
  case FloatType:
  case &DoubleType(_): return true;
  case &ArrayType(ArrayInfo{t,_,_,_,_}): return zeroable_type(t);
  case &FnType(_): return false;
  case &TupleType(tqs):
    for (; tqs; tqs = tqs->tl) 
      if (!zeroable_type((*tqs->hd)[1])) return false;
    return true;
  case &AggrType(AggrInfo(info,ts)):
    let ad = get_known_aggrdecl(info);
    if(ad->impl == NULL || ad->impl->exist_vars != NULL)
      return false;
    region r {
      let inst = List::rzip(r,r,ad->tvs,ts);
      for (_ fs = ad->impl->fields; fs != NULL; fs = fs->tl) 
        if (!zeroable_type(rsubstitute(r,inst,fs->hd->type))) return false;
      return true;
    }
  case &EnumType(_,_): return true; // FIX: explicit tags?
  case &SizeofType(_): return true;
  case &TagType(_): return true; // FIX: true iff 0? Is sizeof right?
  case &AnonAggrType(_,fs): 
    for (; fs != NULL; fs = fs->tl) 
      if (!zeroable_type(fs->hd->type)) return false;
    return true;
  case &AnonEnumType(_): return true; // FIX: explicit tags?
  case &TypedefType(_,_,_,_): return false;
  case &DynRgnType(_,_): return false;
  case &RgnHandleType(_): return false;

  case &TypeInt(_):
  case HeapRgn:
  case UniqueRgn:
  case &AccessEff(_):
  case &JoinEff(_):
  case &RgnsEff(_): impos("bad type `%s' in zeroable type",typ2string(t));
  }
}

static void check_malloc_type(bool allow_zero, seg_t loc, 
                              type_t * topt, type_t t) {
  if (bits_only(t) || (allow_zero && zeroable_type(t))) return;
  // try unifying t with the topt info to get better results
  if (topt != NULL) {
    switch (compress(*topt)) {
    case &PointerType(PtrInfo(elt_typ,_,_)): 
      unify(elt_typ,t);
      if (bits_only(t) || (allow_zero && zeroable_type(t))) return;
      break;
    default: break;
    }
  }
  terr(loc,"%s cannot be used with type %s\n\t(type needs initialization)",
       allow_zero ? ((string_t)"calloc") : (string_t)"malloc", typ2string(t));
}

static type_t tcMalloc(tenv_t te, seg_t loc, type_t * topt, exp_opt_t ropt, 
                       type_t *@t, exp_t @e, bool @is_calloc,
                       bool @is_fat) {
  // by default, we allocate heap pointers; this is for making inference
  // simpler.  If you want a unique pointer, do rnew (Core::unique_region)
  type_t rgn = HeapRgn; 
  if (ropt != NULL) {
    // check that the region handle is still valid
    type_t expected_type = 
      new RgnHandleType(new_evar(&trk,new Opt(lookup_type_vars(te))));
    type_t handle_type = tcExp(te,&expected_type,(exp_t)ropt);
    switch (compress(handle_type)) {
    case &RgnHandleType(r): 
      rgn = r;
      check_rgn_accessible(te,loc,rgn);
      break;
    default:
      terr(ropt->loc,"expecting region_t type but found %s",
           typ2string(handle_type));
      break;
    }
  }
  tcExp(te,&uint_typ,*e);
  // crawl over e and look for the following cases:
  //   sizeof(T):  result is T@ or T* depending upon topt
  //   sizeof(T)*n or n*sizeof(T):  result is T? 
  //     as long as T is bits-only or zero-able.
  //   otherwise it's char ?
  type_t elt_type; // the element type of the resulting pointer
  exp_t num_elts;  // the number of elements of the resulting pointer
  bool one_elt;
  if (*is_calloc) {
    if (*t == NULL) impos("calloc with empty type");
    elt_type = **t;
    check_type(loc,te,lookup_type_vars(te),MemKind,true,elt_type);
    check_malloc_type(true,loc,topt,elt_type);
    num_elts = *e;
    one_elt = false;
  } else {
    switch ((*e)->r) {
    case &Sizeoftyp_e(t2):  
      elt_type = t2;
      *t = new elt_type;
      num_elts = uint_exp(1,NULL);
      tcExp(te,&uint_typ,num_elts);
      one_elt = true;
      break;
    case &Primop_e(Times,&List(e1,&List(e2,NULL))):
      switch ($(e1->r, e2->r)) {
      case $(&Sizeoftyp_e(t1),_): 
        check_malloc_type(false,loc,topt,t1);
        elt_type = t1;
        *t = new elt_type;
        num_elts = e2;
        one_elt = false;
        break;
      case $(_,&Sizeoftyp_e(t2)):
        check_malloc_type(false,loc,topt,t2);
        elt_type = t2;
        *t = new elt_type;
        num_elts = e1;
        one_elt = false;
        break;
      default: goto No_sizeof;
      }
      break;
    default:
    No_sizeof:
      elt_type = char_typ;
      *t = new elt_type;
      num_elts = *e;
      one_elt = false;
      break;
    }
  }
  *e = num_elts;
  *is_fat = !one_elt;
  // Don't yet support existential types (to do it, add to TunionFieldInfo
  // and here generate fresh evars).
  switch(elt_type) {
  case &AggrType(AggrInfo(KnownAggr(&ad),_)):
    if(ad->impl != NULL && ad->impl->exist_vars != NULL)
      terr(loc,"malloc with existential types not yet implemented");
    break;
  default: break;
  }

  // Avoid casts when we're passed down a nullable type
  let ptr_maker = at_typ;
  let zero_term = false_conref;
  if(topt != NULL)
    switch (compress(*topt)) {
    case &PointerType(PtrInfo(_,_,PtrAtts(_,n,_,zt,_))): 
      zero_term = zt;
      if(conref_def(false,n))
	ptr_maker = star_typ; 
      // for zero-terminated arrays, rewrite malloc to calloc to ensure
      // we're actually zero-terminated.
      if (conref_def(false,zt) && !(*is_calloc)) {
        warn(loc,"converting malloc to calloc to ensure zero-termination");
        *is_calloc = true;
      }
      break;
    default: break;
    }
  if (!one_elt) ptr_maker = dynforward_typ;
  return ptr_maker(elt_type,rgn,empty_tqual(NULL),zero_term);
}

// swap(e1,e2)
static type_t tcSwap(tenv_t te, seg_t loc, type_t * topt,
		     exp_t e1, exp_t e2) {
  // MWH: is tcAssign, we do noPromote for the lhs, in a notreadctxt;
  //   I'm thinking we don't want to do this
  tcExp(te,NULL,e1);
  tcExp(te,&e1->topt->v,e2);
  type_t t1 = e1->topt->v;
  type_t t2 = e2->topt->v;
  // Check to see that the type is not an array type
  switch (compress(t1)) {
  case &ArrayType(_): terr(loc,"cannot assign to an array"); break;
  default: break;
  }
  // check to see that the type is word-sized or a pointer
  bool ign_1 = false;
  bool ign_2 = false;
  if (!is_pointer_or_boxed(t1,&ign_1,&ign_2))
    terr(loc,"Swap not allowed for non-pointer or non-word-sized types.");
  // Check to see if e1 is an lvalue after typechecking, so that
  // UnknownIds have been resolved.
  if (!is_lvalue(e1))
    return expr_err(te,e1->loc,topt,"swap non-lvalue");
  if (!is_lvalue(e2))
    return expr_err(te,e2->loc,topt,"swap non-lvalue");
  // Make sure we aren't swapping elements of a zero-terminated array
  type_t t_ign1 = VoidType, t_ign2 = VoidType;
  bool b_ign1 = false, b_ign2 = false;
  if (is_zero_ptr_deref(e1,&t_ign1,&b_ign1,&b_ign2,&t_ign2))
    return expr_err(te,e1->loc,topt,"swap value in zeroterm array");
  if (is_zero_ptr_deref(e2,&t_ign1,&b_ign1,&b_ign2,&t_ign2))
    return expr_err(te,e2->loc,topt,"swap value in zeroterm array");
  // Make sure the elements are writable
  check_writable(te, e1);
  check_writable(te, e2);
  if (!unify(t1,t2)) {
    let result = expr_err(te,loc,topt,"type mismatch: %s != %s",
			  typ2string(t1), typ2string(t2));
    return result;
  }
  return VoidType;
}

// ({ s })
static type_t tcStmtExp(tenv_t te, seg_t loc, type_t * topt, stmt_t s) {
  region r {
    Tcstmt::tcStmt(set_encloser(r,te,s),s,true);
  }
  // The encloser of s is not s, so reset it properly.
  NewControlFlow::set_encloser(s,get_encloser(te));
  // The type is the type of the expression that ends the statment.
  while(true)
    switch (s->r) {
    case &Exp_s(e):     return e->topt->v;
    case &Seq_s(s1,s2): s = s2; continue;
    case &Decl_s(d,s1): s = s1; continue;
    default:
      return expr_err(te,loc,topt,
                      "statement expression must end with expression");
    }
}

// e has the form new e1
static type_t tcNew(tenv_t te, seg_t loc, type_t * topt, 
                    exp_opt_t rgn_handle, exp_t e, exp_t e1) {
  // by default, we allocate heap pointers; this is for making inference
  // simpler.  If you want a unique pointer, do rnew (Core::unique_region)
  type_t rgn = HeapRgn; 
  if (rgn_handle != NULL) {
    // check that the region handle is still valid
    type_t expected_type = 
      new RgnHandleType(new_evar(&trk,new Opt(lookup_type_vars(te))));
    type_t handle_type = tcExp(te,&expected_type,(exp_t)rgn_handle);
    switch (compress(handle_type)) {
    case &RgnHandleType(r): 
      rgn = r;
      check_rgn_accessible(te,loc,rgn);
      break;
    default:
      terr(rgn_handle->loc,"expecting region_t type but found %s",
           typ2string(handle_type));
      break;
    }
  }

  switch (e1->r) {
  case &Comprehension_e(_,_,_,_):
    // Note: tcComprehension expects the pointer type, not an array type.
    let t_arr = tcExpNoPromote(te,topt,e1);
    switch (compress(t_arr)) {
    case &ArrayType(ArrayInfo{et_arr,tq_arr,bndopt,zt,_}):
      exp_t bnd = (exp_t)bndopt;
      bounds_t b;
      switch(compress(bnd->topt->v)) {
      case &TagType(t): b = new AbsUpper_b(t); break;
      default:
	if(is_const_exp(te,bnd))
	  b = new Upper_b(bnd);
	else
	  b = DynForward_b;
      }
      type_t res_typ = 
        new PointerType(PtrInfo(et_arr,tq_arr,
				PtrAtts(rgn,empty_conref(),new_conref(b),zt,
                                        NULL)));
      if (topt != NULL) {
        if (!unify(*topt,res_typ) && silent_castable(te,loc,res_typ,*topt)) {
          e->topt = new Opt(res_typ);
          unchecked_cast(te, e, *topt, Other_coercion);
          res_typ = *topt;
        }
      }
      return res_typ;
    default: impos("tcNew: comprehension returned non-array type");
    }
  case &UnresolvedMem_e(nopt,des):
    e1->r = new Array_e(des);
    fallthru(des);
  case &Array_e(des):
    type_t *elt_typ_opt = NULL;
    bool zero_term = false;
    if (topt != NULL) {
      switch (compress(*topt)) {
      case &PointerType(PtrInfo(*elt_typ,tq,PtrAtts(_,_,_,zt,_))):
        // tcArray only needs the element type, so the bound is bogus
        elt_typ_opt = elt_typ;
        zero_term = conref_def(false,zt);
        break;
      default: break;
      }
    }
    let t_array = tcArray(te,e1->loc,elt_typ_opt,zero_term,des);
    e1->topt = new Opt(t_array);
    type_t res_typ;
    switch (compress(t_array)) {
    case &ArrayType(ArrayInfo{et,tq,sz,zt,_}): 
      res_typ = 
	new PointerType(PtrInfo(et,tq,
				PtrAtts(rgn,empty_conref(),
					new_conref(new Upper_b((exp_t)sz)),
                                        zt,NULL)));
      if (topt != NULL) {
        // try unifying res_typ and topt -- if that fails, then see if we
        // can cast res_typ to topt, and insert the cast so that the code
        // generator knows what to do.
        if (!unify(*topt,res_typ) && silent_castable(te,loc,res_typ,*topt)) {
          e->topt = new Opt(res_typ);
          unchecked_cast(te, e, *topt, Other_coercion);
          res_typ = *topt;
        }
      }
      break;
    default: impos("tcExpNoPromote on Array_e returned non-array type");
    }
    return res_typ;
  case &Const_e(String_c(s)):
    // here I'm going to guess that the user wants a char *@ instead of
    // a char @{n}@.  They can get the char@{n}@ by using a cast.  This
    // is a total hack...
    let topt2 = atb_typ(char_typ, rgn, const_tqual(NULL), 
                        DynForward_b, true_conref);
    let t = tcExp(te,&topt2,e1);
    return atb_typ(t, rgn, empty_tqual(NULL), new Upper_b(uint_exp(1,NULL)), 
                   false_conref);
  default:
    // code that's equivalent to "new {e1}" -- i.e., an array of size 1.
    // Note that we could simplify everything by rewriting the expression
    // to use an Array_e, but this would involve more allocation.
    type_t *topt2 = NULL;
    if (topt != NULL) {
      switch (compress(*topt)) {
      case &PointerType(PtrInfo(*elttype,tq,_)):
        topt2 = elttype; break;
      case &TunionType(_):
        // Note, we're lying here in the sense that we should pass down
        // a TunionFieldType -- but we don't know which field...
        // FIX: not sure this is right for flat tunions
        topt2 = new (*topt);
        break;
      default: break;
      }
    }
    type_t telt = tcExp(te,topt2,e1);
    type_t res_typ =
      new PointerType(PtrInfo(telt,empty_tqual(NULL),
			      PtrAtts(rgn,empty_conref(),
				      bounds_one_conref,
				      false_conref,NULL)));
    if (topt != NULL) {
      if (!unify(*topt,res_typ) && silent_castable(te,loc,res_typ,*topt)) {
        e->topt = new Opt(res_typ);
        unchecked_cast(te,e,*topt,Other_coercion);
        res_typ = *topt;
      }
    }
    return res_typ;
  }
}

// The default: type-check and promote any array types to pointer types
type_t tcExp(tenv_t te, type_t * topt, exp_t e) {
  type_t t = compress(tcExpNoPromote(te, topt, e));
  switch (t) {
  case &ArrayType(ArrayInfo{elt_typ,tq,e2,zt,_}):
    let $(_,rgn) = addressof_props(te,e);
    let b = (e2 == NULL) ? (bounds_t)DynForward_b : new Upper_b((exp_t)e2);
    t = atb_typ(elt_typ,rgn,tq,b,zt);
    e->topt->v = t;
    return t;
  default:
    return t;
  }
}

// Type-check the expression -- if it's an Array_e, Comprehension_e, 
// or String_c expression, do not promote its type from array to pointer.  
// Otherwise, do so.
type_t tcExpInitializer(tenv_t te, type_t * topt, exp_t e) {
  type_t t = tcExpNoPromote(te, topt, e);
  // expression initializers are copied, and therefore consumed,
  // so check for uniqueness
  if (is_unique_pointer(t) && !is_unique_path(e)) {
    fprintf(stderr,"topt=%s, e->topt->v=%s, e=%s\n",
	    topt == NULL ? "NULL" : Absynpp::typ2string(*topt),
	    Absynpp::typ2string(e->topt->v),
	    Absynpp::exp2string(e));
    terr(e->loc,UNIQUE_ERR_MSG, __LINE__);
  }
  switch (e->r) {
  case &Array_e(_): 
  case &Comprehension_e(_,_,_,_):
  case &Const_e(String_c(_)): return t;
  default:
    t = compress(t);
    switch (t) {
    case &ArrayType(ArrayInfo{elt_typ,tq,e2,zt,_}):
      let $(_,rgn) = addressof_props(te,e);
      bounds_t b = (e2 == NULL) ? (bounds_t)DynForward_b : 
        new Upper_b((exp_t)e2);
      t = atb_typ(elt_typ,rgn,tq,b,zt);
      unchecked_cast(te,e,t,Other_coercion);
      return t;
    default:
      return t;
    }
  }
}

// Type check an expression e.  The value topt is an optional type
// that we expect e to have.  This is useful for propagating type
// information down (i.e., to resolve certain ambiguous expression
// forms) but isn't otherwise used -- one still needs to check that
// e has the expected type.  If e="e2<>" and e2 has a poly-type,
// we do not instantiate the type quantifiers.  Otherwise if e has a
// poly-type, we instantiate the quantifiers.
static type_t tcExpNoPromote(tenv_t te, type_t * topt, exp_t e) {
  switch (e->r) {
  case &NoInstantiate_e(e2):
    // the user has asked not to implicitly instantiate any quantifiers
    tcExpNoInst(te,topt,e2);
    e2->topt->v = pointer_expand(e2->topt->v,false);
    e->topt = e2->topt;
    break;
  default:
    // first, typecheck without instantiating
    tcExpNoInst(te,topt,e);
    e->topt->v = pointer_expand(e->topt->v,false);
    // implicitly instantiate the expression if it has a polymorphic type
    switch (compress(e->topt->v)) {
    case &PointerType(PtrInfo(t,tq,PtrAtts(rt,x,b,zt,_))):
      switch (compress(t)) {
      case &FnType(FnInfo{tvs,eff,rtyp,args,c_varargs,cyc_varargs,rpo,atts}):
	if (tvs != NULL)    // then, instantiate if necessary
	  region rgn {
           let env = $(lookup_type_vars(te),rgn);
	   list_t<$(tvar_t,type_t)@`rgn,`rgn> inst = 
	     List::rmap_c(rgn,r_make_inst_var,&env,tvs);
	   list_t<type_t> ts = List::map(snd,inst);
	   type_t ftyp = rsubstitute(rgn, inst,
				     new FnType(FnInfo{NULL,eff,rtyp,args,
						       c_varargs,cyc_varargs,
                                                       rpo,atts}));
	   let new_typ = new PointerType(PtrInfo(ftyp,tq,PtrAtts(rt,x,b,zt,NULL)));
	   let inner   = copy_exp(e);
	   e->r    = new Instantiate_e(inner,ts);
	   e->topt = new Opt(new_typ);
	  }
	break;
      default: break;
      }
      break;
    default: break;
    }
    break;
  }
  return e->topt->v;
}

 // Type-check the expression -- don't do any implicit instantiation.
static void tcExpNoInst(tenv_t te, type_t * topt, exp_t e) {
  seg_t loc = e->loc;
  type_t t;

  switch (e->r) {

  case &NoInstantiate_e(e2):
    // This would handle two NoInstantiates in a row; but note that
    // for now the parser does not produce this ( x<><> won't parse ).
    tcExpNoInst(te,NULL,e2);
    return;

  case &UnknownId_e(q):
    // resolve the identifier and then re-type-check the expression
    resolve_unknown_id(te,e,q);
    tcExpNoInst(te,topt,e);
    return;
  case &UnknownCall_e(e1,es):
    // resolve e1 as a function or struct, tunion, or xtunion constructor and
    // then re-type-check the expression
    resolve_unknown_fn(te,e,e1,es);
    tcExpNoInst(te,topt,e);
    return;
  case &UnresolvedMem_e(nopt,des):
    // resolve as an array or struct and then re-type-check the expression
    resolve_unresolved_mem(te,loc,topt,e,des);
    tcExpNoInst(te,topt,e);
    return;

  case &Const_e(*c):
    t = tcConst(te,loc,topt,c,e); break;
  case &Var_e(q,b):
    t = tcVar(te,loc,q,b); break;
  case &Primop_e(p,es):
    t = tcPrimop(te,loc,topt,p,es); break;
  case &Increment_e(e1,i):
    t = tcIncrement(te,loc,topt,e1,i); break;
  case &AssignOp_e(e1,popt,e2):
    t = tcAssignOp(te,loc,topt,e1,popt,e2); break;
  case &Conditional_e(e1,e2,e3):
    t = tcConditional(te,loc,topt,e1,e2,e3); break;
  case &And_e(e1,e2):
    t = tcAnd(te,loc,e1,e2); break;
  case &Or_e(e1,e2):
    t = tcOr(te,loc,e1,e2); break;
  case &SeqExp_e(e1,e2):
    t = tcSeqExp(te,loc,topt,e1,e2); break;
  case &FnCall_e(e1,es,*vci):
    t = tcFnCall(te,loc,topt,e1,es,vci); break;
  case &Throw_e(e1):
    t = tcThrow(te,loc,topt,e1); break;
  case &Instantiate_e(e2,ts):
    t = tcInstantiate(te,loc,topt,e2,ts); break;
  case &Cast_e(t1,e1,_,*c):
    t = tcCast(te,loc,topt,t1,e1,c); break;
  case &Address_e(e1):
    t = tcAddress(te,loc,e,topt,e1); break;
  case &New_e(rgn_handle,e1):
    t = tcNew(te,loc,topt,rgn_handle,e,e1); break;
  case &Sizeofexp_e(e1):
    let t1 = tcExpNoPromote(te, NULL, e1);
    t = tcSizeof(te,loc,topt,t1); break;
  case &Sizeoftyp_e(t1):
    t = tcSizeof(te,loc,topt,t1); break;
  case &Offsetof_e(t1,n):
    t = tcOffsetof(te,loc,topt,t1,n); break;
  case &Gentyp_e(_,_):
    terr(loc, "gen() not in top-level initializer");
    return;
  case &Deref_e(e1):
    t = tcDeref(te,loc,topt,e1); break;
  case &AggrMember_e(e1,f):
    t = tcAggrMember(te,loc,topt,e,e1,f); break;
  case &AggrArrow_e(e1,f):
    t = tcAggrArrow(te,loc,topt,e1,f); break;
  case &Subscript_e(e1,e2):
    t = tcSubscript(te,loc,topt,e1,e2); break;
  case &Tuple_e(es):
    t = tcTuple(te,loc,topt,es); break;
  case &CompoundLit_e(t1,des):
    t = tcCompoundLit(te,loc,topt,t1,des); break;
  case &Array_e(des):
    // tcArray expects us to pass in an optional element type, not
    // the array type.  See also tcNew.
    type_t *elt_topt = NULL;
    bool zero_term = false;
    if (topt != NULL) {
      switch (compress(*topt)) {
      case &ArrayType(ArrayInfo{*et,_,_,zt,_}): 
        elt_topt = et; 
        zero_term = conref_def(false,zt);
        break;
      default: break;
      }
    }
    t = tcArray(te,loc,elt_topt,zero_term,des); break;
  case &StmtExp_e(s):
    t = tcStmtExp(te,loc,topt,s); break;
  case &Comprehension_e(vd,e1,e2,*iszeroterm):
    t = tcComprehension(te,loc,topt,vd,e1,e2,iszeroterm); break;
  case &Struct_e(*tn,*ts,args,*sd_opt):
    t = tcStruct(te,loc,topt,tn,ts,args,sd_opt); break;
  case &AnonStruct_e(ts,args):
    t = tcAnonStruct(te,loc,ts,args); break;
  case &Tunion_e(es,tud,tuf):
    t = tcTunion(te,loc,topt,e,es,tud,tuf); break;
  case &Enum_e(*q,ed,ef):
    *q = ef->name;
    t = new EnumType(ed->name,ed); break;
  case &AnonEnum_e(*v,t2,ef):
    *v = ef->name;
    t = t2; break;
  case &Malloc_e(MallocInfo{*is_calloc,ropt,*t2,*e,*isfat}):
    t = tcMalloc(te,loc,topt,ropt,t2,e,is_calloc,isfat); break;
  case &Swap_e(e1,e2):
    t = tcSwap(te,loc,topt,e1,e2); break;
  }
  e->topt = new Opt(t);
}
