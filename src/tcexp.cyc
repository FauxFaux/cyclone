// Type checking for expressions 

/* TODO:
   codegen and fill
   compound literals
   generalized array and struct designators
 */

#include "absyn.h"
#include "string.h"
#include "character.h"
#include "position.h"
#include "absynpp.h"
#include "tcenv.h"
#include "tcutil.h"
#include "evexp.h"
#include "tcstmt.h"
#include "control_flow.h"
#include "formatstr.h"
#include "tcexp.h"
using Core;
using List;
using Position;
using Absyn;
using Absynpp;
using Tcenv;
using Tcutil;
using Stdio;

namespace Tcexp;

static synth expr_err(tenv te,segment loc,string msg) {
  terr(loc,msg);
  return wild_synth(te);
}

//////////////////// Resolving References the Parser Cannot /////////////////

// The qualified identifier q could be a variable, an enum
// constructor, or an xenum constructor.  We resolve q and overwrite
// the expression e with the appropriate r. 
static void resolve_unknown_id(tenv te, exp e, qvar q) {
  switch (lookup_ordinary(te,e->loc,q)) {
  case VarRes(b):        e->r = Var_e(q,b); break;
  case EnumRes(ed,ef):   e->r = Enum_e(null,null,null,ed,ef); break;
  case XenumRes(xed,ef): e->r = Xenum_e(null,null,xed,ef);    break;
  case StructRes(_):
    terr(e->loc,xprintf("bad occurrence of struct name %s",qvar2string(q)));
    e->r = Var_e(q,Unresolved_b);
    break;
  }
}

static $(list<designator>,exp)@ make_struct_arg(exp e) {
  return &$(null,e);
}
// Resolve whether this is a function call or enum, xenum, or struct
// constructor -- let normal type-checking do the rest of the work. 
// NOTE: We assume q is a relative qvar.
static void resolve_unknown_fn(tenv te, exp e, exp e1, list<exp> es) {
  switch (e1->r) {
  case UnknownId_e(q):
    try {
      switch (lookup_ordinary(te,e1->loc,q)) {
      case VarRes(b):        e->r = FnCall_e(e1,es);            return;
      case EnumRes(ed,ef):   e->r = Enum_e(null,null,es,ed,ef); return;
      case XenumRes(xed,ef): e->r = Xenum_e(null,es,xed,ef);    return;
      case StructRes(sd):
	_ des = List::map(make_struct_arg,es);
	if (sd->name != null)
	  e->r = Struct_e(sd->name->v,null,des,sd);
	else {
	  terr(e->loc,"missing struct name");
	  e->r = Struct_e(q,null,des,sd);
	}
	return;
      }
    } catch {
    case Dict::Absent:
      terr(e1->loc, xprintf("unbound identifier %s",qvar2string(q)));
      return;
    }
  default: e->r = FnCall_e(e1,es); return;
  }
}

static void 
resolve_unresolved_mem<`r>(tenv te, segment loc, typ *`r topt, exp e,
			   list<$(list<designator>,exp)@> des) {
  // NOTE: must always bang e->r or caller will loop!
  if (topt == null) {
    // guess it is an array
    e->r = Array_e(false,des);
    return; 
  }
  typ t = *topt;
  switch (compress(t)) {
  case ArrayType(at,aq,_):    
    e->r = Array_e(false,des); 
    break;
  case StructType(tdopt,ts,sdp): 
    if(sdp==null)
      terr(loc,"Compiler bug: struct type not properly set");
    e->r = Struct_e(tdopt->v,null,des,*sdp); 
    break;
  default:
    // guess it is an array
    e->r = Array_e(false,des);
    break;
  }
}

//////////////////////// Actual Type-checking //////////////////////////////

// forward reference just b/c of how things are organized at the moment
static void tcExpNoInst<`r>(tenv te, typ *`r topt, exp e);
static synth tcExpNoPromote<`r>(tenv te, typ *`r topt, exp e);

// Type check a list of expressions -- we no longer bother returning
// a sequentialized synth (we don't have left to right evaluation anyway) 
static void tcExpList(tenv te, list<exp> es) {
  for(; es != null; es = es->tl)
    tcExp(te,null,es->hd);
}

// type-check the if expressions, the loop guards, and the where clauses
void tcTest(tenv te, exp e, string msg_part) {
  check_contains_assign(e);
  tcExp(te,&sint_t,e); 
  if (!coerce_to_bool(te,e))
    terr(e->loc,xprintf("test of %s has type %s instead of integral or * type",
			msg_part, typ2string(e->topt->v)));
}

// constants
static synth tcConst<`r>(tenv te, segment loc, typ *`r topt, cnst_t c, exp e) {
  typ t;
  switch (c) {
  case Char_c(sn,_):     t = (sn == Unsigned) ? uchar_t  : schar_t;  break;
  case Short_c(sn,_):    t = (sn == Unsigned) ? ushort_t : sshort_t; break;
  case LongLong_c(sn,_): t = (sn == Unsigned) ? ulong_t  : slong_t;  break;
  case Float_c(_) :      t = float_t; break;
  case Int_c(sn,i):
    if (topt == null)
      t = (sn == Unsigned) ? uint_t : sint_t;
    else
        // If *topt calls for a shorter int, we assume it's ok to
        // truncate without warning.
        // The typical case is in an array initializer, e.g.,
        // short x[1] = { 255 };
      switch (*topt) {
      case IntType(sn,B1):
        t = (sn == Unsigned) ? uchar_t : schar_t;
        e->r = Const_e(Char_c(sn,(char)(i))); // i gets truncated here
        break;
      case IntType(sn,B2):
	t = (sn == Unsigned) ? ushort_t : sshort_t;
        e->r = Const_e(Short_c(sn,(short)(i))); // i gets truncated here
        break;
      case IntType(sn,_):
        t = (sn == Unsigned) ? uint_t : sint_t;
        break;
      default: // topt isn't int; presumably an error to be caught elsewhere
        t = (sn == Unsigned) ? uint_t : sint_t;
        break;
    }
    break;
  case String_c(heap_allocate,s):
    // FIX: deal with topt being pointer???
    int len = s.size; // includes the trailing 0 character
    _   r   = Const_e(Int_c(Unsigned,len));
    exp elen= new_exp(r,loc);
    elen->topt = &Opt(uint_t);
    // The default is to treat a string as if it's heap allocated
    // Note that such strings are shared...
    t = atb_typ(uchar_t, HeapRgnType, empty_tqual(), Upper_b(elen));
    if (topt != null) {
      switch (compress(*topt)) {
      case ArrayType(telt,tq,e2):
	if (heap_allocate)
	  terr(loc,"string is dynamically allocated -- returns char pointer");
	uint len2 = Evexp::eval_const_uint_exp(e2);
	if (!unify(telt,uchar_t))
	  terr(loc,xprintf("string constant cannot be used as %s array",
			   typ2string(telt)));
	if (len != len2)
	  terr(loc,xprintf("string has length %d instead of %d",len,len2));
	return standard_synth(te,*topt);
      case PointerType(PtrInfo{telt,trgn,nullable,tq,b}):
	if (!unify(telt,uchar_t))
	  terr(loc,xprintf("string cannot be used as %s pointer",
			   typ2string(telt)));
	if (!unify(trgn,HeapRgnType))
	  terr(loc,"this string literal is heap allocated");
	b = compress_conref(b);
	switch (b->v) {
	case Eq_constr(Upper_b(elen2)):
	  uint len2 = Evexp::eval_const_uint_exp(elen2);
	  if (len != len2)
	    terr(loc,xprintf("string has length %d instead of %d",len,len2));
	  break;
	case Eq_constr(Unknown_b):
	  // must cast e so that translation to C boxes the string
	  e->topt = &Opt(t);
	  unchecked_cast(te, e, *topt);
	  break;
	default: 
	  b->v = Eq_constr(Upper_b(elen)); 
	  break;
	}
	return standard_synth(te,*topt);
      default:
	break;
      }
    }
    break;
  case Null_c:
    // FIX: take advantage of topt
    t = PointerType(PtrInfo{wildtyp(), new_evar(RgnKind), new_conref(true), 
			    empty_tqual(), empty_conref()});
    break;
  }
  return standard_synth(te,t);
}

// variables 
static synth tcVar<`r>(tenv te, segment loc, typ *`r topt, qvar q, exp e) {
  switch (lookup_ordinary(te,loc,q)) {
  case VarRes(b):
    switch(b) {
    case Unresolved_b:
      return expr_err(te,loc,xprintf("unbound identifier %s",qvar2string(q)));
    case Global_b(vd):
      q[0] = vd->name[0];
      return standard_synth(te,vd->type);
    case Funname_b(fd):
      q[0] = fd->name[0];
      return standard_synth(te,fndecl2typ(fd));
    case Pat_b(vd): fallthru(vd);
    case Local_b(vd):
      typ t = vd->type;
      fallthru(t);
    case Param_b(&$(_,_,t)): return standard_synth(te,t);
    }
  case StructRes(_):  throw impos("StructRes in tcVar");
  case EnumRes(_,_):  throw impos("EnumRes in tcVar");
  case XenumRes(_,_): throw impos("XenumRes in tcVar");
  }
}

static void check_format_args(tenv te, exp fmt, list<exp> args,
			      list<typ> type_getter(string,segment)) {
  // check the format string and get the types it requires
  list<typ> desc_types;
  switch (fmt->r) {
  case Const_e(String_c(false,s)): desc_types = type_getter(s,fmt->loc); break;
  default: terr(fmt->loc, "expecting a literal format string"); return;
  }
  // check that each expression has the right type
  for (; desc_types != null && args != null; desc_types = desc_types->tl, 
	                                     args = args->tl) {
    typ t = desc_types->hd;
    exp e = args->hd;
    if (!coerce_arg(te,e,t))
      terr(e->loc,xprintf("descriptor has type %s but argument has type %s",
			  typ2string(t), typ2string(e->topt->v)));
  }
  // check arity
  if (desc_types != null)
    terr(fmt->loc,"too few arguments");
  if (args != null)
    terr(args->hd->loc,"too many arguments");
}
static typ tcUnPrimop<`r>(tenv te, segment loc, typ *`r topt, primop p, exp e){
  typ t = compress(e->topt->v);
  switch (p) {
  case Plus: fallthru;
  case Minus:
    if (!arithmetic_promote(te,e)) 
      terr(loc,xprintf("expecting arithmetic type but found %s",typ2string(t)));
    return e->topt->v;
  case Not:
    check_contains_assign(e);
    if (!coerce_to_bool(te,e)) 
      terr(loc,xprintf("expecting integral or * type but found %s",
		       typ2string(t)));
    return sint_t;
  case Bitnot:
    if (!integral_promote(te,e))
      terr(loc,xprintf("expecting integral type but found %s",typ2string(t)));
    return e->topt->v;
  case Size:
    switch (t) {
    case ArrayType(_,_,_): 
      break;
    case PointerType(PtrInfo{_,_,_,_,_}):
      break;
    default:
      terr(loc,xprintf("size requires pointer or array type, not %s",
		       typ2string(t)));
      break;
    }
    return uint_t;
  default:
    return impos("Non-unary primop");
  }
}

// Note: promoter must return false for any non-arithmetic type.
static typ tcArithBinop(tenv te, exp e1, exp e2, bool promoter(tenv,exp)) {
  if (!promoter(te,e1)) {
    terr(e1->loc,xprintf("type %s cannot be used here",
			 typ2string(e1->topt->v)));
    return wildtyp();
  }
  if (!promoter(te,e2)) {
    terr(e2->loc,xprintf("type %s cannot be used here",
			 typ2string(e2->topt->v)));
    return wildtyp();
  }
  typ t1  = compress(e1->topt->v);
  typ t2  = compress(e2->topt->v);
  typ res = max_arithmetic_type(t1,t2);
  unchecked_cast(te,e1,res);
  unchecked_cast(te,e2,res);
  return res;
}
// Plus needs to support a pointer and an int
static typ tcPlus(tenv te, exp e1, exp e2) {
  typ t1 = e1->topt->v;
  if (is_tagged_pointer_typ(t1)) {
    if (!coerce_sint_typ(te, e2))
      terr(e2->loc,xprintf("expecting int but found %s",
			   typ2string(e2->topt->v)));
    return t1;
  } else return tcArithBinop(te, e1, e2, arithmetic_promote);
}
// Minus needs to support a tagged array and an int, and two tagged arrays
static typ tcMinus(tenv te, exp e1, exp e2) {
  typ t1 = e1->topt->v;
  typ t2 = e2->topt->v;
  if (is_tagged_pointer_typ(t1)) {
    if (is_tagged_pointer_typ(t2)) {
      if (!unify(t1, t2))
	terr(e1->loc,xprintf("pointer arithmetic on values of "
			     "different types (%s != %s)", 
			     typ2string(e1->topt->v),typ2string(e2->topt->v)));
      return sint_t;
    } else {
      if (!coerce_sint_typ(te, e2)) 
	terr(e2->loc,xprintf("expecting either %s or int but found %s",
			     typ2string(t1),typ2string(t2)));
      return t1;
    }
  } else return tcArithBinop(te, e1, e2, arithmetic_promote);
}

static typ tcAnyBinop(tenv te, segment loc, exp e1, exp e2) {
  bool e1_is_unboxed_arith = comparison_promote(te,e1);
  bool e2_is_unboxed_arith = comparison_promote(te,e2);
  typ t1 = compress(e1->topt->v);
  typ t2 = compress(e2->topt->v);
  if (e1_is_unboxed_arith && e2_is_unboxed_arith) {
    typ res = max_arithmetic_type(t1,t2);
    unchecked_cast(te,e1,res);
    unchecked_cast(te,e2,res);
    return sint_t;
  } 
  // okay if same types and boxed
  else if (unify(t1,t2) && unify(t1,new_evar(BoxPKind))) {
    return sint_t;
  // support comparisons on pointers
  } else {
    typ t1 = e1->topt->v;
    typ t2 = e2->topt->v;
    switch ($(compress(t1), compress(t2))) {
    case $(PointerType(PtrInfo{t1a,_,_,_,_}),
	   PointerType(PtrInfo{t2a,_,_,_,_})):
      if (unify(t1a,t2a)) return sint_t; break;
    default:
      break;
    }
    terr(loc,xprintf("comparison not allowed between %s and %s",
		     typ2string(t1),typ2string(t2)));
    return wildtyp();
  }
}

// Binary primops like e1+e2, e1>>e2, etc. 
// Note: e1 and e2 must have already been type-checked.
static typ tcBinPrimop<`r>(tenv te, segment loc, typ *`r topt, 
		       primop p, exp e1, exp e2) {
  switch (p) {
  case Plus:       return tcPlus(te,e1,e2);
  case Minus:      return tcMinus(te,e1,e2);
  case Times:      fallthru;
  case Div:        return tcArithBinop(te,e1,e2,arithmetic_promote);

  case Mod:        fallthru;
  case Bitand:     fallthru;
  case Bitor:      fallthru;
  case Bitxor:     fallthru;
  case Bitlshift:  fallthru;
  case Bitlrshift: fallthru;
  case Bitarshift: return tcArithBinop(te,e1,e2,integral_promote);

    // Note: comparing pointers relies on memory-manager properties
    //       (but darned useful for dictionaries)
  case Eq:         fallthru;
  case Neq:        fallthru;
  case Gt:         fallthru;
  case Lt:         fallthru;
  case Gte:        fallthru;
  case Lte:        return tcAnyBinop(te,loc,e1,e2);

  default: throw Failure("bad binary primop");
  }
}

static synth tcPrimop<`r>(tenv te, segment loc, typ *`r topt,
			  primop p, list<exp> es) {
  // An ugly hack to push topt below unary minus.  This comes in
  // handy because it stops warnings from being printed on array
  // initializers generated by bison (where (short)4 looks like
  // we're losing precision).
  // HOWEVER it should be nuked when we re-write the type checker
  // to solve the general problem.
  if (p == Minus && List::length(es) == 1)
    return tcExp(te,topt,es->hd);
  // FIX: sizeof(f) where f is a function (or expression of function type)
  // should not be allowed.  So for sizeof(e), we should not call tcExp on e,
  // because that will do pointer generation (convert a function to a pointer
  // to a function).  Instead we should call tcexpNoInst.
  tcExpList(te,es);
  typ t;
  switch (p) {
  case Printf:
    if (es == null)
      return expr_err(te,loc,"missing format string in printf");
    check_format_args(te, es->hd, es->tl, Formatstr::get_format_typs);
    t = VoidType;
    break;
  case Fprintf:
    if (es == null || es->tl == null)
      return expr_err(te,loc,"too few arguments to fprintf");
    if (!unify(es->hd->topt->v, file_typ()))
      terr(es->hd->loc,xprintf("expecting FILE @ but found %s",
			       typ2string(es->hd->topt->v)));
    check_format_args(te, es->tl->hd, es->tl->tl, Formatstr::get_format_typs);
    t = VoidType;
    break;
  case Xprintf:
    if (es == null)
      return expr_err(te,loc,"missing format string in xprintf");
    check_format_args(te, es->hd, es->tl, Formatstr::get_format_typs);
    t = string_typ(new_evar(RgnKind));
    break;
  case Scanf:
    if (es == null)
      return expr_err(te,loc,"missing format string in scanf");
    check_format_args(te, es->hd, es->tl, Formatstr::get_scanf_typs);
    t = sint_t;
    break;
  case Fscanf:
    if (es == null || es->tl == null)
      return expr_err(te,loc,"too few arguments to fscanf");
    if (!unify(es->hd->topt->v, file_typ()))
      terr(es->hd->loc,xprintf("expecting FILE @ but found %s",
			       typ2string(es->hd->topt->v)));
    check_format_args(te, es->tl->hd, es->tl->tl, Formatstr::get_scanf_typs);
    t = sint_t;
    break;
  case Sscanf:
    // We don't support sscanf because we cannot guarantee that the
    // input string is null terminated.  The standard sscanf might
    // read past the end of the string -- a potential security breach.
    // Possible fixes: copy the string or re-implement sscanf from scratch.
    terr(loc,"sscanf is not supported");
    /* 
    // It's sometimes helpful to allow sscanf for debugging, but
    // usually this should be commented out.
    if (es == null || es->tl == null)
      return
        expr_err(te,loc,"missing input string or format string in sscanf");
    if (!coerce_arg(te,es->hd, string_typ()))
      terr(es->hd->loc,xprintf("expecting string found %s",
			       typ2string(es->hd->topt->v)));
    check_scanf_args(te, es->tl->hd, es->tl->tl, Formatstr::get_scanf_typs);
    */
    t = sint_t;
    break;
  default:
    switch (List::length(es)) {
    case 0:  return expr_err(te,loc,"primitive operator has 0 arguments");
    case 1:  t = tcUnPrimop(te,loc,topt,p,es->hd); break;
    case 2:  t = tcBinPrimop(te,loc,topt,p,es->hd,es->tl->hd); break;
    default: return expr_err(te,loc,"primitive operator has > 2 arguments");
    }
    break;
  }
  return standard_synth(te,t);
}

static synth tcIncrement<`r>(tenv te, segment loc, typ *`r topt, 
			     exp e, incrementor_t i) {
  // Don't promote any arrays to pointers, as per K&R
  tcExpNoPromote(te,null,e);
  typ t = e->topt->v;
  // FIX: this is not right -- for instance, it allows incrementing an enum!!
  if (!arithmetic_promote(te,e) && !is_tagged_pointer_typ(t))
    terr(e->loc,xprintf("expecting arithmetic or pointer type but found %s",
			typ2string(t)));
  return standard_synth(te,t);
}

// e1 ? e2 : e3
static synth tcConditional<`r>(tenv te, segment loc, typ *`r topt, 
			       exp e1, exp e2, exp e3) {
  tcTest(te, e1, "conditional expression");
  tcExp(te,topt,e2);
  tcExp(te,topt,e3);
  typ t = wildtyp();
  if (!coerce_list(te,t,&cons(e2,&cons(e3,null))))
    terr(loc,xprintf("conditional clause types do not match: %s != %s",
			    typ2string(e2->topt->v),typ2string(e3->topt->v)));
  return standard_synth(te,t);
}

// Assignments with optional operations, e.g., x = 3, x += 5
// FIX: reject assignment to unmodifiable (eg. const) lvalues.
static synth tcAssignOp<`r>(tenv te, segment loc, typ *`r topt, 
			    exp e1, Opt_t<primop> po, exp e2) {
  // FIX: Not right b/c of funcions vs. function pointers???
  // As per K&R, don't promote any array types to pointer types in the lhs
  tcExpNoPromote(te,null,e1); 
  tcExp(te,null,e2);
  typ t1 = e1->topt->v;
  typ t2 = e2->topt->v;
  // Check to see that the type is not an array type
  switch (compress(t1)) {
  case ArrayType(_,_,_):
    terr(loc,"cannot assign to an array"); break;
  default:  break;
  }
  // Check to see if e1 is an lvalue after typechecking, so that
  // UnknownIds have been resolved.
  if (!is_lvalue(e1))
    return expr_err(te,loc,"assignment to non-lvalue");
  if (po == null) {
    if (!coerce_assign(te,e2,t1)) 
      return expr_err(te,loc,xprintf("type mismatch: %s != %s",
				     typ2string(t1), typ2string(t2)));
  } else {
    _ p        = po->v;
    _ t_result = tcBinPrimop(te,loc,null,p,e1,e2);
    if (!(unify(t_result,t1) || coerceable(t_result)))
      return expr_err(te,loc, "Cannot use this operator in an assignment");
  }
  return standard_synth(te,t2);
}

// e1,e2 
static synth tcSeqExp<`r>(tenv te, segment loc, typ *`r topt, exp e1, exp e2) {
  tcExp(te,null,e1);
  tcExp(te,topt,e2);
  return standard_synth(te,e2->topt->v);
}

// e(es) 
static synth tcFnCall<`r>(tenv te,segment loc,typ *`r topt,exp e,list<exp> es){
  tcExp(te,null,e);
  typ t = compress(e->topt->v);
  // NB: we should really unify t with an unconstrained FnType with the
  // right arity but there may be coercions involved with the arguments
  // and the function might actually be a vararg.
  switch (t) {
  case PointerType(PtrInfo{t1,rgn,x,tq,b}):
    // Note: rgn is irrelevant -- all code is in the heap. 
    // Nonetheless, perhaps we cast to another region, so check
    // the capability just for fun.
    check_rgn_accessible(te,loc,rgn);
    // Check that the bounds on the pointer aren't 0
    check_nonzero_bound(loc,b);
    switch (compress(t1)) {
    case FnType(tvars,res_typ,args_info,is_vararg): //FIX: handle tvars
      if (is_vararg)
        terr(loc,"vararg functions (...) not supported yet");
      // unify the result type with the expected type to get better
      // information while type-checking the arguments.
      if (topt != null) unify(res_typ,*topt);
      // check that each argument has the right type or can be coerced to it
      // FIX: need to check that any arguments are accessible!
      while ((es != null) && (args_info != null)) {
        exp e1 = es->hd;
        typ t2 = (*args_info->hd)[2];
	tcExp(te, &t2, e1);
        if (!coerce_arg(te,e1,t2))
          terr(loc,
               xprintf("actual argument has type %s but formal has type %s",
                       typ2string(e1->topt->v),typ2string(t2)));
        es = es->tl;
        args_info = args_info->tl;
      }
      if (es != null) 
        terr(loc,"too many arguments for function");
      if (args_info != null) 
        terr(loc,"too few arguments for function");
      return standard_synth(te,res_typ);
    default: return expr_err(te,loc,"expected pointer to function");
    }
  default: return expr_err(te,loc,"expected pointer to function");
  }
}

// throw e 
static synth tcThrow<`r>(tenv te, segment loc, typ *`r topt, exp e) {
  tcExp(te,&exn_typ,e); // unnecessary allocation
  typ t = e->topt->v;
  if (!unify(t,exn_typ)) 
    terr(loc,xprintf("expected xenum exn but found %s",typ2string(t)));
  return wild_synth(te);
}

// (implicit) instantiation 
// FIX: this is really untested, because the parser does not
// insert Instantiate expressions, only the typechecker does,
// and the output of the typechecker isn't passed through itself...
static synth tcInstantiate<`r>(tenv te, segment loc, typ *`r topt, 
			       exp e, Opt_t<list<typ>> @opt_ref) {
  tcExp(te,null,e);
  Opt_t<list<typ>> topts = *opt_ref;
  typ              t0    = e->topt->v;
  switch (t0) {
  case PointerType(PtrInfo{FnType(tvars,rtyp,args,varargs),_,_,_,b}):
    list<$(tvar,typ)@> instantiation;
    check_nonzero_bound(loc, b);
    if (topts == null) {
      instantiation = List::map(make_inst_var,tvars);
      *opt_ref = &Opt(List::split(instantiation)[1]); // side-effect
    } else {
      try instantiation = List::zip(tvars,topts->v);
      catch { case List::List_mismatch:
	return expr_err(te,loc,"type instantiation mismatch");
      }
    }
    typ new_typ = substitute(instantiation, FnType(null,rtyp,args,varargs));
    return standard_synth(te,new_typ);
  default:
    return expr_err(te,loc,xprintf("expecting polymorphic type but found %s",
                                   typ2string(t0)));
  }
}

// (t)e 
static synth tcCast<`r>(tenv te, segment loc, typ *`r topt, typ t, exp e) {
  check_valid_type(loc,te,lookup_type_vars(te),t);
  tcExp(te,null,e);
  typ t2 = e->topt->v;
  if (!silent_castable(te,loc,t2,t) && !castable(te,loc,t2,t)) 
    return expr_err(te,loc,xprintf("cannot cast %s to %s",
				   typ2string(t2), typ2string(t)));
  return standard_synth(te,t);
}

 // &e 
static synth tcAddress<`r>(tenv te, segment loc, typ *`r topt, exp e) {
  // This is really two things b/c we're still overloading
  // & throughout the compiler as address-of and malloc-and-initialize.
  _ topt2 = null;
  _ tq2 = empty_tqual();
  if (topt != null) {
    switch (compress(*topt)) {
    case PointerType(PtrInfo{elttype,_,_,tq,_}): 
      // FIX:  this allocation is needed because *elttype doesn't compile
      // correctly.
      topt2 = (typ *)&$(elttype);
      tq2 = tq;
      break;
    default: break;
    }
  }
  // Use tcExpNoInst here because if f is a function then
  // then &f is supposed to be a pointer to a function, not
  // a pointer to a pointer to a function
  // Notice that this also bypasses the array-to-pointer promotion
  // as required (see p. 200, A7.1 of K&R.)
  tcExpNoInst(te,topt2,e);
  
  // first, dispense with the malloc-and-initialize cases
  // Note: We're heap region b/c this is translated to an actual malloc
  switch (e->r) {
  case Struct_e(_,_,_,_): fallthru;
  case Tuple_e(_):
    typ t = at_typ(e->topt->v,HeapRgnType,tq2);
    return standard_synth(te,t);
  default: break;
  }
  
  // we've got an address-of
  let $(is_const,rgn) = addressof_props(te,e);
  tqual tq = empty_tqual();
  if(is_const)
    tq->q_const = true;
  typ t = at_typ(e->topt->v, rgn, tq);
  return standard_synth(te,t);
}

 // sizeof t 
static synth tcSizeof<`r>(tenv te, segment loc, typ *`r topt, typ t) {
  check_valid_type(loc,te,lookup_type_vars(te),t);
  Evexp::szof(t,loc); // just ignore result -- posts error for bad type
  return standard_synth(te,uint_t);
}

 // *e 
 // FIX: check static region capability, also in arrow, subscript
static synth tcDeref<`r>(tenv te, segment loc, typ *`r topt, exp e) {
  tcExp(te,null,e);
  typ t = compress(e->topt->v);
  switch (t) {
  case PointerType(PtrInfo{t2,rt,_,_,b}): 
    check_rgn_accessible(te,loc,rt);
    check_nonzero_bound(loc, b);
    return standard_synth(te,t2);
  // FIX:  should support constant sized arrays (larger than 0) and 
  // tagged arrays.
  default: return expr_err(te,loc,xprintf("expecting * or @ type but found %s",
					  typ2string(t)));
  }
}

// e.f 
static synth tcStructMember<`r>(tenv te, segment loc, typ *`r topt, 
				exp outer_e, exp e, field_name f) {
  // As per K&R, don't promote e from array to pointer type
  tcExpNoPromote(te,null,e);
  typ t = compress(e->topt->v);
  switch (t) {
  case StructType(nopt,ts,&sd):
    if (nopt == null)
      return expr_err(te,loc,"unresolved struct type (COMPILER ERROR)");
    _ finfo = lookup_struct_field(sd,f);
    if (finfo == null) 
      return expr_err(te,loc,xprintf("struct %s has no %s field",
				     qvar2string(nopt->v), *f));
    _ inst = List::zip(sd->tvs,ts);
    _ t2   = substitute(inst,(*finfo)[2]);
    return standard_synth(te,t2);
  case ArrayType(_,_,_) && (String::zstrcmp(*f,"size") == 0): 
    outer_e->r = Primop_e(Size,&cons(e,null));
    return standard_synth(te,uint_t);
  case PointerType(_) && (String::zstrcmp(*f,"size") == 0): 
    outer_e->r = Primop_e(Size,&cons(e,null));
    return standard_synth(te,uint_t);
  default:
    if (String::zstrcmp(*f,"size") == 0)
      return expr_err(te,loc,xprintf("expecting struct or array, found %s",
				     typ2string(t)));
    else 
       return expr_err(te,loc,xprintf("expecting struct, found %s",
				      typ2string(t)));
  }
}

// e->f 
static synth tcStructArrow<`r>(tenv te, segment loc, typ *`r topt, 
			       exp e, field_name f) {
  tcExp(te,null,e);
  typ t = compress(e->topt->v);
  switch (t) {
  case PointerType(PtrInfo{t2,rt,_,_,b}):
    check_nonzero_bound(loc, b);
    switch (compress(t2)) {
    case StructType(nopt,ts,&sd):
      _ finfo = lookup_struct_field(sd,f);
      if (finfo == null)
	return expr_err(te,loc,xprintf("struct %s has no %s field",
				       qvar2string(nopt->v),*f));
      _ inst = List::zip(sd->tvs,ts);
      _ t3   = substitute(inst,(*finfo)[2]);
      check_rgn_accessible(te,loc,rt);
      return standard_synth(te,t3);
    default:
      return expr_err(te,loc, xprintf("expecting struct pointer, found %s", 
				      typ2string(t)));
    }
  default:
    return expr_err(te,loc,xprintf("expecting struct pointer, found %s",
				   typ2string(t)));
  }
}

// e1[e2] 
static synth ithTupleType(tenv te,segment loc,list<$(tqual,typ)@> ts,exp index){
  unsigned int i = Evexp::eval_const_uint_exp(index);
  try 
    return standard_synth(te,(*List::nth(ts,i))[1]);
  catch { case Nth:
    return expr_err(te,loc,xprintf("index is %d but tuple has only %d fields",
				   i, List::length(ts)));
  }
}
 // FIX: look at topt
static synth tcSubscript<`r>(tenv te, segment loc, typ *`r topt, 
			     exp e1, exp e2) {
  tcExp(te,null,e1);
  tcExp(te,null,e2);
  typ t1 = compress(e1->topt->v);
  typ t2 = compress(e2->topt->v);
  if (!coerce_sint_typ(te,e2))
    return expr_err(te,e2->loc,xprintf("expecting int subscript, found %s",
				       typ2string(t2)));
  // the subscript could be on a tuple or a pointer -- any arrays
  // should've been coerced to pointers
  switch (t1) {
  case PointerType(PtrInfo{t,rt,_,tq,b}):
    // FIX: Consider tq?
    if (is_const_exp(te, e2))
      check_bound(loc,Evexp::eval_const_uint_exp(e2),b);
    else 
      check_nonzero_bound(loc,b);
    check_rgn_accessible(te,loc,rt);
    return standard_synth(te,t);
  case TupleType(ts): return ithTupleType(te,loc,ts,e2);
  default:
    return expr_err(te,loc,xprintf("subscript applied to %s",typ2string(t1)));
  }
}

 // $(es) 
static synth tcTuple<`r>(tenv te, segment loc, typ *`r topt, list<exp> es) {
  bool done = false;
  list<$(tqual,typ)@> fields = null;
  if(topt != null) 
    switch (compress(*topt)) {
    case TupleType(ts):
      if(length(ts) != length(es)) {
	terr(loc,"tuple expression has the wrong number of fields");
	break;
      }
      _ topt2;
      for(; es != null; es = es->tl, ts = ts->tl) {
	topt2 = (*ts->hd)[1];
	tcExpInitializer(te,&topt2,es->hd);
	fields = &cons(&$((*ts->hd)[0], es->hd->topt->v), fields);
      } 
      done = true;
      break;
    default:
      terr(loc,xprintf("initializer for %s is a tuple",typ2string(*topt)));
      break;
    }
  if(!done)
    for(; es != null; es = es->tl) {
      tcExpInitializer(te,null,es->hd);
      fields = &cons(&$(empty_tqual(), es->hd->topt->v), fields);
    }
  return standard_synth(te,TupleType(List::imp_rev(fields)));
}

// Compound literals, e.g., (struct foo){3,"abc"} 
static synth tcCompoundLit<`r>(tenv te, segment loc, typ *`r topt,
			   $(Opt_t<stringptr>,tqual,typ)@ t,
			   list<$(list<designator>,exp)@> des) {
  return expr_err(te,loc,"tcCompoundLit");
}

 ///////////////////// Array ({e1,...,en}) /////////////////////////
 // FIX:  only a very limited class of designators (basically, the proper
 // index) is supported and all of the array elements must be present.
static synth tcArray<`r>(tenv te,segment loc,typ *`r topt, 
			 exp e, bool heap_allocated,
			 list<$(list<designator>,exp)@> des) {
  list<exp> es = List::map(snd,des); 
  typ res      = wildtyp();
  _   sz_rexp  = Const_e(Int_c(Unsigned,List::length(es)));
  exp sz_exp   = new_exp(sz_rexp,loc);
  sz_exp->topt = &Opt(uint_t);
  typ res_t2;
  if (heap_allocated)
    res_t2 = atb_typ(res,HeapRgnType,empty_tqual(),Upper_b(sz_exp));
  else 
    res_t2 = ArrayType(res, empty_tqual(), sz_exp);

  if (topt == null) {
    for (_ es2 = es; es2 != null; es2 = es2->tl) {
      tcExpInitializer(te,null,es2->hd);
    }
  } else {
    switch (compress(*topt)) {
    case PointerType(PtrInfo{elt_typ,_,_,_,_}):
      fallthru(elt_typ);
    case ArrayType(elt_typ,_,_):
      _ topt1 = elt_typ;
      for (_ es1 = es; es1 != null; es1 = es1->tl) {
	exp e = es1->hd;
	tcExpInitializer(te,&topt1,e);
	coerce_arg(te,e,elt_typ);
      }
      break;
    default: 
      terr(loc,xprintf("initializer for %s is an array",typ2string(*topt)));
      tcExpList(te,es);
      break;
    }
  }
  
  if (!coerce_list(te,res,es))
    terr(es->hd->loc,
	 xprintf("elements of array do not all have the same type (%s)",
		 typ2string(res)));
  // check that any designators make sense
  for(int offset = 0; des != null; offset++, des = des->tl) {
    list<designator> ds = (*des->hd)[0];
    if (ds != null)
      //   if (ds->hd->tl != null)
      //     terr(ds->hd[1]->loc,"only array index designators are supported");
      switch (ds->hd) {
      case FieldName(_):
	terr(loc,"only array index designators are supported");
	break;
      case ArrayElement(e):
	tcExpInitializer(te,null,e);
	unsigned int i = Evexp::eval_const_uint_exp(e);
	if (i != offset)
	  terr(e->loc, xprintf("expecting index designator %d but found %d",
			       offset,i));
	break;
      }
  }
  if (topt != null) {
    if (!unify(*topt,res_t2) && silent_castable(te,loc,res_t2,*topt)) {
      e->topt = &Opt(res_t2);
      unchecked_cast(te, e, *topt);
      res_t2 = *topt;
    }
  }
  return standard_synth(te,res_t2);
}

 // {for x < e1 : e2} 
static synth tcComprehension<`r>(tenv te,segment loc,typ *`r topt,
				 vardecl vd,exp bound,exp body) {
  tcExp(te,null,bound);
  if (!coerce_uint_typ(te,bound))
    terr(bound->loc,xprintf("expecting unsigned int, found %s",
			    typ2string(bound->topt->v)));
  // add x to the environment with the type unsigned int
  te = Tcenv::new_block(te);
  te = add_local_var(loc, te, vd);
  _ topt2 = null;
  _ nopt = null;
  _ tqopt = null;
  _ bopt = null;
  
  if (topt != null) {
    switch (compress(*topt)) {
    case PointerType(PtrInfo{elt_typ,_,n,tq,b}):
      // FIX:  bug in compiler prevents stack allocation...
      topt2 = (typ @)&$(elt_typ);
      nopt = (conref<bool> @)&$(n);
      tqopt = (tqual @)&$(tq);
      bopt = (conref<bounds_t> @)&$(b);
      break;
    default:
      terr(loc,xprintf("initializer for %s is an array",typ2string(*topt)));
      break;
    }
  }
  // type-check the body in the new environment
  tcExp(te,topt2,body);
  bounds_t b_result;
  bool bound_is_const = is_const_exp(te,bound);
  if (bopt != null) 
    switch (compress_conref(*bopt)->v) {
    case Eq_constr(Unknown_b): b_result = Unknown_b; break;
    case Eq_constr(Upper_b(e)):
      if (bound_is_const && 
	  (Evexp::eval_const_uint_exp(e)<=Evexp::eval_const_uint_exp(bound))) {
	b_result = Upper_b(e);
	break;
      } else fallthru;
    default: 
      b_result = bound_is_const ? Upper_b(bound) : Unknown_b;
      break;
    }
  else b_result = bound_is_const ? Upper_b(bound) : Unknown_b;
  tqual tq_result = (tqopt != null) ? *tqopt : empty_tqual();
  typ result = 
    (b_result == Unknown_b) ? 
    starb_typ(body->topt->v,HeapRgnType,tq_result,b_result) :
      atb_typ(body->topt->v,HeapRgnType,tq_result,b_result);
  return standard_synth(te,result);
}

 //////////////////// Struct (f{e1,...,en}) ///////////////////
 // FIX:
 // Right now, we only allow one field name designator on an argument.
 // In addition, we assume any undesignated argument is associated with
 // the first field that has not yet been explicitly mentioned.  So,
 // for instance, if we have:
 //  struct Foo {int a,b,c,d,e;}
 //  Foo{.c=3,.d=4,1,2,5};
 // then this is the same as Foo{.a=1,.b=2,.c=3,.d=4,.e=5};
 // Later, we should support array designators and so forth.
static synth tcStruct<`r>(tenv_t te, seg_t loc, typ *`r topt,
			  typedef_name_t @tn,                    
			  Opt_t<list<typ>> @otyps,             
			  list<$(list<designator>,exp)@> args, 
			  struct Structdecl *@ sd_opt) {
  structdecl sd;
  if (*sd_opt != null)
    sd = (structdecl)(*sd_opt);
  else {
    sd = *lookup_structdecl(te,loc,*tn);
    *sd_opt = sd;
    if (sd->name != null)
      *tn = sd->name->v;
  }
  // calculate the instantiation and final type
  _ inst    = List::map(make_inst_var,sd->tvs);
  _ typs    = List::map(snd,inst); 
  _ res_typ = StructType(&Opt(*tn),typs,(structdecl@)(&$(sd)));
  // this will instantiate the struct if we have type information in topt
  if (topt != null) unify(res_typ,*topt);
  *otyps = &Opt(typs);
  // make sure each argument has the right type
  list<$($(field_name,tqual,typ)@,exp)@> fields =
    resolve_struct_designators(loc,args,sd);
  for(; fields != null; fields = fields->tl) {
    let &$(&$(n,tq,fieldtyp),field_exp) = fields->hd;
    _ inst_fieldtyp = substitute(inst,fieldtyp);
    tcExpInitializer(te, &inst_fieldtyp, field_exp);
    if (!coerce_arg(te,field_exp,inst_fieldtyp))
      terr(field_exp->loc,
	   xprintf("field %s of struct %s expects type %s != %s",
		   *n,qvar2string(*tn),typ2string(inst_fieldtyp),
		   typ2string(field_exp->topt->v)));
  }
  return standard_synth(te,res_typ);
}

 // f(es)   where f is an enum and is ef->name
 static synth tcEnum<`r>(tenv te, segment loc, typ *`r topt,
			 Opt_t<list<typ>> @all_ref,
			 Opt_t<list<typ>> @exist_ref,
			 list<exp> es,
			 enumdecl ed,
			 enumfield ef) {
   _ all_inst   = List::map(make_inst_var,ed->tvs);
   _ exist_inst = List::map(make_inst_var,ef->tvs);
   _ all_typs   = List::map(snd,all_inst);   
   _ exist_typs = List::map(snd,exist_inst); 
   _ inst       = List::append(all_inst,exist_inst);
   *all_ref   = &Opt(all_typs);
   *exist_ref = &Opt(exist_typs);
   typ res = EnumType(ed->name,all_typs,(enumdecl*)(&$(ed)));
   // this instantiates the type variables if we have top-down type info
   if (topt != null) unify(*topt,res);
   list<$(tqual,typ)@> ts = ef->typs;
   while (es != null && ts != null) {
     exp e = es->hd; 
     typ t = substitute(inst,(*ts->hd)[1]); 
     tcExpInitializer(te, &t, e);
     es = es->tl;
     ts = ts->tl;
     if (!coerce_arg(te,e,t))
       terr(e->loc,
	    xprintf("enum constructor %s expects argument of type %s "
		    "but this argument has type %s",
		    qvar2string(ef->name),typ2string(t),
		    (e->topt == null) ? (string)"?" : typ2string(e->topt->v)));
   }
   if (es != null) 
     return expr_err(te,es->hd->loc,
		     xprintf("too many arguments for enum constructor %s",
			     qvar2string(ef->name)));
   if (ts != null) 
     return expr_err(te,
                     loc,
                     xprintf("too few arguments for enum constructor %s",
                             qvar2string(ef->name)));
   return standard_synth(te,res);
 }

 // f(es)   where f is an xenum and is ef->name
 static synth tcXenum<`r>(tenv te, segment loc, typ *`r topt,
			  Opt_t<list<typ>> @exist_ref,
			  list<exp> es,
			  xenumdecl xd,
			  enumfield ef) {
   _ exist_inst = List::map(make_inst_var,ef->tvs);
   _ exist_typs = List::map(snd,exist_inst); 
   _ res        = XenumType(xd->name,(xenumdecl*)(&$(xd)));
   _ ts         = ef->typs;
   *exist_ref = &Opt(exist_typs);
   while (es != null && ts != null) {
     exp e = es->hd; 
     typ t = substitute(exist_inst,(*ts->hd)[1]); 
     tcExpInitializer(te, &t, e);
     es = es->tl;
     ts = ts->tl;
     if (!coerce_arg(te,e,t))
       terr(e->loc,xprintf("xenum constructor %s expects argument of type %s "
			   "but this argument has type %s",
			   qvar2string(ef->name),
			   typ2string(t),typ2string(e->topt->v)));
   }
   if (es != null)
     terr(es->hd->loc,xprintf("too many arguments for xenum constructor %s",
			      qvar2string(ef->name)));
   else if (ts != null)
     terr(es->hd->loc,xprintf("too few arguments for xenum constructor %s",
			      qvar2string(ef->name)));
   return standard_synth(te,res);
 }

 // ({ s }) 
static synth tcStmtExp<`r>(tenv te, segment loc, typ *`r topt, stmt s) {
   Tcstmt::tcStmt(set_encloser(te,s),s,true);
   // The encloser of s is not s, so reset it properly.
   ControlFlow::set_encloser(s,get_encloser(te));
   // The type is the type of the expression that ends the statment.
   while(true) 
     switch (s->r) {
     case Exp_s(e):     return standard_synth(te,e->topt->v);
     case Seq_s(s1,s2): s = s2; continue;
     case Decl_s(d,s1): s = s1; continue;
     default: 
       return expr_err(te,loc,"statement expression must end with expression");
     }
 }

 // codegen(fd) 
static synth tcCodegen<`r>(tenv te, segment loc, typ *`r topt, fndecl fd) {
  return expr_err(te,loc,"tcCodegen");
}
 // fill(e) 
static synth tcFill<`r>(tenv te, segment loc, typ *`r topt, exp e) {
  return expr_err(te,loc,"tcFill");
}

 // FIX: there are other expressions we could allow, such as 
 // &(x->y) or &(x[0]) that we do not support here...
 static bool cnst_exp(tenv te, bool var_okay, exp e) {
   switch (e->r) {
   case Const_e(_):  return true;
   case Sizeof_e(t): return true;

   case Var_e(qv,_): 
     // NB: top-level function names and arrays are "constant" 
     switch (lookup_ordinary(te, e->loc, qv)) {
     case VarRes(Funname_b(_)): return true;
     case VarRes(Global_b(vd)):
       switch (compress(vd->type)) {
       case ArrayType(_,_,_): return true;
       default: return var_okay;
       }
     default: return var_okay;
     }

   case Conditional_e(e1,e2,e3):
     return (cnst_exp(te,false,e1) 
	     && cnst_exp(te,false,e2) 
	     && cnst_exp(te,false,e3));
   case SeqExp_e(e1,e2):
     return (cnst_exp(te,false,e1) && cnst_exp(te,false,e2));
   case Instantiate_e(e2,_):
     return cnst_exp(te,var_okay,e2);
   case Cast_e(_,e2):
     // FIX:  We cannot allow casts w/ run-time effect b/c C will complain!
     return cnst_exp(te,var_okay,e2);
   case Address_e(e2):
     return cnst_exp(te,true,e2);

   case Array_e(_,des): fallthru(des);
   case Struct_e(_,_,des,_):
     for (; des != null; des = des->tl)
       if (!cnst_exp(te,false,(*des->hd)[1])) 
	 return false;
     return true;

   case Primop_e(p,es):       fallthru(es);
   case Tuple_e(es):          fallthru(es);
   case Enum_e(_,_,es,_,_): fallthru(es);
   case Xenum_e(_,es,_,_):
     for (; es != null; es = es->tl)
       if (!cnst_exp(te,false,es->hd)) 
	 return false;
     return true;
   default:
     return false;
   }
 }
 bool is_const_exp(tenv te, exp e) {
   return cnst_exp(te,false,e);
 }

// The default:  type-check and promote any array types to pointer types
synth tcExp<`r>(tenv te, typ *`r topt, exp e) {
  synth s = tcExpNoPromote(te, topt, e);
  typ t = compress(synth_typ(s));
  switch (t) {
  case ArrayType(elt_typ,tq,e2):
    let $(_,rgn) = addressof_props(te,e);
    t = atb_typ(elt_typ,rgn,tq,Upper_b(e2));
    unchecked_cast(te,e,t);
    return standard_synth(te, t);
  default:
    return s;
  }
}

// Type-check the expression -- if it's an Array_e or String_c expression,
// do not promote its type from array to pointer.  Otherwise, do so.
synth tcExpInitializer<`r>(tenv te, typ *`r topt, exp e) {
  synth s = tcExpNoPromote(te, topt, e);
  switch (e->r) {
  case Array_e(_,_): return s;
  case Const_e(String_c(_,_)): return s;
  default:
    typ t = compress(synth_typ(s));
    switch (t) {
    case ArrayType(elt_typ,tq,e2):
      let $(_,rgn) = addressof_props(te,e);
      t = atb_typ(elt_typ,rgn,tq,Upper_b(e2));
      unchecked_cast(te,e,t);
      return standard_synth(te, t);
    default:
      return s;
    }
  }
}

// Type check an expression e.  The value topt is an optional type
// that we expect e to have.  This is useful for propagating type
// information down (i.e., to resolve certain ambiguous expression
// forms) but isn't otherwise used -- one still needs to check that
// e has the expected type.  If e="e2<>" and e2 has a poly-type, 
// we do not instantiate the type quantifiers.  Otherwise if e has a
// poly-type, we instantiate the quantifiers. 
static synth tcExpNoPromote<`r>(tenv te, typ *`r topt, exp e) {
  switch (e->r) {
  case NoInstantiate_e(e2):
    // the user has asked not to implicitly instantiate any quantifiers
    tcExpNoInst(te,topt,e2);
    e->topt = e2->topt;
    break;
  default:
    // implicitly instantiate the expression if it has a polymorphic type
    // first, typecheck without instantiating
    tcExpNoInst(te,topt,e);
    e->topt->v = pointer_expand(compress(e->topt->v));
    switch (compress(e->topt->v)) {
    case PointerType(PtrInfo{t,rt,x,tq,b}):
      switch (compress(t)) {
      case FnType(tvs,rtyp,args,varargs):
	if (tvs != null) {   // then, instantiate if necessary
	  list<$(tvar,typ)@> inst = List::map(make_inst_var,tvs);
	  list<typ>          ts   = List::map(snd,inst);
	  typ ftyp    = substitute(inst,FnType(null,rtyp,args,varargs));
	  typ new_typ = PointerType(PtrInfo{ftyp,rt,x,tq,b});
	  exp inner   = copy_exp(e);
	  e->r    = Instantiate_e(inner,&Opt(ts));
	  e->topt = &Opt(new_typ);
	}
	break;
      default: break;
      }
      break;
    default: break; 
    }
    break;
  }
  return standard_synth(te,e->topt->v);
}

 // Type-check the expression -- don't do any implicit instantiation. 
static void tcExpNoInst<`r>(tenv te, typ *`r topt, exp e) {
  segment loc = e->loc;
  synth   esyn;
  
  switch (e->r) {
    
  case NoInstantiate_e(e2):
    // This would handle two NoInstantiates in a row; but note that
    // for now the parser does not produce this ( x<><> won't parse ).
    tcExpNoInst(te,null,e2);
    return;

  case UnknownId_e(q):
    // resolve the identifier and then re-type-check the expression
    resolve_unknown_id(te,e,q);
    tcExpNoInst(te,topt,e);
    return;
  case UnknownCall_e(e1,es):
    // resolve e1 as a function or struct, enum, or xenum constructor and
    // then re-type-check the expression
    resolve_unknown_fn(te,e,e1,es);
    tcExpNoInst(te,topt,e);
    return;
  case UnresolvedMem_e(nopt,des):
    // resolve as an array or struct and then re-type-check the expression
    resolve_unresolved_mem(te,loc,topt,e,des);
    tcExpNoInst(te,topt,e);
    return;

  case Const_e(c):              
    esyn=tcConst(te,loc,topt,c,e);            
    break;
  case Var_e(q,vd):             
    esyn=tcVar(te,loc,topt,q,e);
    break;
  case Primop_e(p,es):          
    esyn=tcPrimop(te,loc,topt,p,es);          
    break;
  case Increment_e(e1,i):       
    esyn=tcIncrement(te,loc,topt,e1,i);       
    break;
  case AssignOp_e(e1,popt,e2):  
    esyn=tcAssignOp(te,loc,topt,e1,popt,e2);  
    break;
  case Conditional_e(e1,e2,e3): 
    esyn=tcConditional(te,loc,topt,e1,e2,e3); 
    break;
  case SeqExp_e(e1,e2):         
    esyn=tcSeqExp(te,loc,topt,e1,e2);         
    break;
  case FnCall_e(e1,es):         
    esyn=tcFnCall(te,loc,topt,e1,es);         
    break;
  case Throw_e(e1):             
    esyn=tcThrow(te,loc,topt,e1);             
    break;
  case Instantiate_e(e2,*o):    
    esyn=tcInstantiate(te,loc,topt,e2,o);     
    break;
  case Cast_e(t,e1):            
    esyn=tcCast(te,loc,topt,t,e1);            
    break;
  case Address_e(e1):           
    esyn=tcAddress(te,loc,topt,e1);           
    break;
  case Sizeof_e(t):             
    esyn=tcSizeof(te,loc,topt,t);             
    break;
  case Deref_e(e1):             
    esyn=tcDeref(te,loc,topt,e1);             
    break;
  case StructMember_e(e1,f):    
    esyn=tcStructMember(te,loc,topt,e,e1,f);  
    break;
  case StructArrow_e(e1,f):     
    esyn=tcStructArrow(te,loc,topt,e1,f);     
    break;
  case Subscript_e(e1,e2):      
    esyn=tcSubscript(te,loc,topt,e1,e2);      
    break;
  case Tuple_e(es):             
    esyn=tcTuple(te,loc,topt,es);             
    break;
  case CompoundLit_e(t,des):    
    esyn=tcCompoundLit(te,loc,topt,t,des);    
    break;
  case Array_e(b,des):          
    esyn=tcArray(te,loc,topt,e,b,des);        
    break;
  case StmtExp_e(s):            
    esyn=tcStmtExp(te,loc,topt,s);            
    break;
  case Codegen_e(fd):           
    esyn=tcCodegen(te,loc,topt,fd);           
    break;
  case Fill_e(e1):              
    esyn=tcFill(te,loc,topt,e1);             
    break;
  case Comprehension_e(vd,e1,e2): 
    esyn = tcComprehension(te,loc,topt,vd,e1,e2); break;
  case Struct_e(*tn,*otyps,args,*sd_opt): 
    esyn = tcStruct(te,loc,topt,tn,otyps,args,sd_opt); break;
  case Enum_e(*all_ref,*exist_ref,es,ed,ef): 
    esyn = tcEnum(te,loc,topt,all_ref,exist_ref,es,ed,ef); break;
  case Xenum_e(*exist_ref,es,xd,ef): 
    esyn = tcXenum(te,loc,topt,exist_ref,es,xd,ef); break;
  }
  typ t = synth_typ(esyn);
  e->topt = &Opt(t);
}
