/* Utility functions for type checking */

#include "core.h"
#include "stdio.h"
#include "absyn.h"
#include "absynpp.h"
#include "set.h"
#include "position.h"
#include "tcenv.h"
#include "string.h"
#include "evexp.h"
#include "tcutil.h"
using Core;
using Stdio;
using List;
using Set;
using Position;
using Absyn;
using Absynpp;
using Tcenv;

namespace Tcutil;

xenum exn {TypeErr};

extern void unify_it(typ t1, typ t2);

void terr(segment loc, string s) {
  Position::post_error(Position::mk_err_elab(loc,s));
}

`a impos<`a>(string msg) {
  fprintf(stderr,"Error: %s\n",msg);
  fflush(stderr);
  throw TypeErr;
}

static list<segment> warning_segs = null;
static list<stringptr>  warning_msgs = null;

// we batch warnings because we have to parse the file to determine
// line and column information.
void warn(segment sg, string msg) {
  warning_segs = &cons(sg, warning_segs);
  // FIX:  cast to stringptr is necessary here...
  warning_msgs = &cons((stringptr)new {msg},warning_msgs);
}
void flush_warnings() {
  if(warning_segs == null)
    return;
  fprintf(stderr,"***Warnings***\n");
  list<stringptr> seg_strs = strings_of_segments(warning_segs);
  warning_segs = null;
  warning_msgs = List::imp_rev(warning_msgs);
  while(warning_msgs != null) {
    fprintf(stderr,"%s: %s\n", *(seg_strs->hd), *(warning_msgs->hd));
    seg_strs     = seg_strs->tl;
    warning_msgs = warning_msgs->tl;
  }
  fprintf(stderr,"**************\n");
  fflush(stderr);
}

// set by by Tcenv::tc_init, used to reduce allocation and calls to Set::empty.
Opt_t<Set<var>> empty_var_set = null;

// compress out any evars or typedefs
typ compress(typ t) {
  switch (t) {
  case Evar(_,null,      _): 
    return t;
  case Evar(_,*t2opt_ref,_): // TRICKY
    typ t2 = compress((*t2opt_ref)->v);
    *t2opt_ref = &Opt(t2);
    return t2;
  case TypedefType(_,_,null): 
    return t;
  case TypedefType(_,_,*topt_ref):
    typ t2 = compress((*topt_ref)->v);
    *topt_ref = &Opt(t2);
    return t2;
  default:
    return t;
  }
}

// FIX: It's much faster to do this as a straight table lookup
//      instead of a procedural implementation of the lattice.
//      But since this kind system is still experimental, I've just
//      coded up the lattice quite literally:
//                          Unresolved
//                       /         |
//                   MemU         Rgn
//                    |   \
//                    |   MemP   
//                    |     |
//                   BoxU   |
//                       \  |
//                         BoxP               
static bool kind_leq(kind_t k1, kind_t k2) {
  if(k1 == k2)
    return true;
  switch (k2) {
  case UnresolvedKind: return true; // okay, so I snuck in 1 important fast-path
  case BoxPKind: return false;
  case BoxUKind: return kind_leq(k1,BoxPKind);
  case MemPKind: return kind_leq(k1,BoxPKind);
  case MemUKind: return kind_leq(k1,BoxUKind) || kind_leq(k1,MemPKind);
  case RgnKind:  return false;
  }
}

// return the "least" kind of a type, according to the lattice above
// FIX: The "enums, structs, and xenums are packable" rule
//      is currently enforced stringently in Tc and should change some day.
// FIX: I think the Evar case should be an error, but I'm not sure yet.
static bool is_packable(typ);
static kind_t typ_kind(typ t) {
  switch (compress(t)) {
    // FIX: this isn't the least kind -- what if it got constrained to
    // unpackable later?!?!?
    // But unify_it calls this with an evar, so let it go for now.
  case Evar(k,topt,_):    return k; 

  case VarType(&$(_,k)):  return k;
  case VoidType:          return MemPKind;
  case IntType(_,sz):     return (sz==B4) ? BoxPKind : MemPKind;
  case FloatType:         return MemPKind;
  case DoubleType:        return MemPKind;
  case FnType(_,_,_,_):   return MemPKind;
  case RgnHandleType(_):  return BoxUKind; // the whole point on packability
  case HeapRgnType:       return RgnKind;

  case EnumType(_,_,_):   return BoxPKind; // see FIX above
  case XenumType(_,_):    return BoxPKind; // see FIX above
  case StructType(_,_,_): return MemPKind; // see FIX above

  // For pointers, the rgntyp is irrelevant for packability because
  // an existential bound variable cannot have RgnKind, so it can't be hidden
  // FIX: That assumption will change if the ability to name ever doesn't
  // imply the capability to access.
  case PointerType(pinfo):
    return is_packable(pinfo.elt_typ) ? BoxPKind : BoxUKind;
  // Arrays are always of memkind
  case ArrayType(t,_,_): return is_packable(t) ? MemPKind : MemUKind;
  case TupleType(tqts):
    for(; tqts != null; tqts = tqts->tl)
      if(!is_packable((*tqts->hd)[1]))
	return MemUKind;
    return MemPKind;

  case TypedefType(_,_,topt): 
    return impos(xprintf("typ_kind: typedef found: %s", typ2string(t)));
  case UnionType: return impos("union type");
  }
}
static bool is_packable(typ t) {
  switch (compress(t)) {
  case Evar(_,_,_): return false; // conservative -- will it be a pain?
  default: 
    switch(typ_kind(t)) {
    case MemUKind: return false;
    case BoxUKind: return false;
    case MemPKind: return true;
    case BoxPKind: return true;
    case RgnKind:        throw Impossible("is_packable found RgnKind");
    case UnresolvedKind: throw Impossible("is_packable found UnresolvedKind");
    }
  }
}

xenum exn {Unify};

// unify types t1 and t2, returning true iff the unification succeeds 
bool unify(typ t1, typ t2) {
  try {
    unify_it(t1,t2);
    return true;
  } catch {
  case Unify: return false;
  }
}

// see if evar occurs within t
static void occurslist(typ evar, list<typ> ts); // mutually recursive fns
static void occurs(typ evar, typ t) {
  switch (compress(t)) {
  case Evar(_,r,_):
    if (t == evar) throw Unify;
    else if (r != null) occurs(evar,r->v);
    break;
  case PointerType(pinfo): 
    occurs(evar,pinfo.elt_typ); occurs(evar,pinfo.rgn_typ); break;
  case ArrayType(t2,_,_): occurs(evar,t2); break;
  case FnType(tvs,rt,args,varargs): // FIX: OK to ignore binding of type vars?
    occurs(evar,rt);
    for(; args != null; args = args->tl)
      occurs(evar,(*args->hd)[2]);
    break;
  case TupleType(args):
    for(; args != null; args = args->tl)
      occurs(evar,(*args->hd)[1]);
    break;
  case RgnHandleType(rt): occurs(evar,rt); break;
  case TypedefType(_,ts,topt): fallthru(ts);
  case EnumType(_,ts,_):       fallthru(ts);
  case StructType(_,ts,_):     occurslist(evar,ts); break;
  default: break;
  }
}
static void occurslist(typ evar, list<typ> ts) {
  for (; ts != null; ts = ts->tl)
    occurs(evar,ts->hd);
}

// unify two lists of types
static void unify_list(list<typ> t1, list<typ> t2) {
  try List::iter2(unify_it,t1,t2);
  catch {case List_mismatch: throw Unify;}
}

// unify two type qualifiers -- throws Unify unless they are the same
static void unify_tqual(tqual tq1, tqual tq2) {
  if ((tq1->q_const != tq2->q_const)    
      || (tq1->q_volatile != tq2->q_volatile) 
      || (tq1->q_restrict != tq2->q_restrict))
    throw Unify;
}

bool equal_tqual(tqual tq1, tqual tq2) {
  return ((tq1->q_const == tq2->q_const) 
	  && (tq1->q_volatile == tq2->q_volatile) 
	  && (tq1->q_restrict == tq2->q_restrict));
}

// compress a conref
conref<`a> compress_conref<`a>(conref<`a> x) {
  switch (x->v) {
  case No_constr:    return x;
  case Eq_constr(_): return x;
  case Forward_constr(y):
    let z = compress_conref(y);
    x->v = z->v;
    return z;
  }
}

`a conref_val<`a>(conref<`a> x) {
  switch (compress_conref(x)->v) {
  case Eq_constr(v): return v;
  default:           return impos("conref_val");
  }
}

// unify two constraint refs
static void unify_it_conrefs<`a>(int cmp(`a,`a), conref<`a> x, conref<`a> y) {
  x = compress_conref(x);
  y = compress_conref(y);
  if (x == y) return;
  switch (x->v) {
  case No_constr: x->v = Forward_constr(y); return;
  case Forward_constr(_): throw impos("unify_conref: forward after compress");
  case Eq_constr(xv):
    switch (y->v) {
    case No_constr: y->v = x->v; return;
    case Forward_constr(_):
      throw impos("unify_confref: forward after compress(2)");
    case Eq_constr(yv):
      if (cmp(xv,yv) != 0) throw Unify;
      return;
    }
  }
}

static bool unify_conrefs<`a>(int cmp(`a,`a), conref<`a> x, conref<`a> y) {
  try {
    unify_it_conrefs(cmp,x,y);
    return true;
  } catch { case Unify: return false; }
}

static int boundscmp(bounds_t b1, bounds_t b2) {
  switch ($(b1,b2)) {
  case $(Unknown_b,Unknown_b): return 0;
  case $(Unknown_b,_): return -1;
  case $(_,Unknown_b): return 1;
  case $(Upper_b(e1),Upper_b(e2)): 
    int i1 = Evexp::eval_const_uint_exp(e1);
    int i2 = Evexp::eval_const_uint_exp(e2);
    if (i1 == i2) return 0;
    if (i1 < i2) return -1;
    return 1;
  }
}

// the real work of unification
void unify_it(typ t1, typ t2) {
  t1 = compress(t1);
  t2 = compress(t2);
  if (t1 == t2) return;
  switch (t1) {
  case Evar(kind1,*ref1_ref,_):
    // this really shouldn't happen since we compressed t1
    if (*ref1_ref != null) {
      unify_it((*ref1_ref)->v,t2);
      return;
    }
    // check that the evar doesn't occur in t2
    occurs(t1,t2);
    _ kind2 = typ_kind(t2);
    // we can constrain the Evar to be equal to t2 only when the kind of the
    // evar is greater than or equal to the kind of t2 or t2 is an evar that
    // we can constrain to be equal to t1.
    if (kind_leq(kind2,kind1)) {
      *ref1_ref = &Opt(t2);
      return;
    } else {
      switch (t2) {
      case Evar(_,*ref2_ref,_): *ref2_ref = &Opt(t1); return;
      default: throw Unify;
      }
    }
  default: break; 
  }
  // t1 is not an evar

    // in what follows, we throw Unify unless we explicitly return.
  switch ($(t2,t1)) {

  case $(Evar(_,_,_),_): // t2 is an evar, t1 is not, swap and try again
    unify_it(t2,t1);
    return;

  case $(VoidType,VoidType): return;

  case $(VarType(&$(x2,k2)),VarType(&$(x1,k1))):
    // kinds should already be resolved, otherwise we could "unify"
    // UnresolvedKind with something else???
    if(k2 == k1 && String::zstrptrcmp(x2,x1) == 0) return;
    break;

  case $(StructType(nopt2,ts2,sd2), StructType(nopt1,ts1,sd1)): 
    // FIX: equivalent and more efficient to pointer-compare sds
    if ((nopt1 != null && nopt2 != null
	 && qvar_cmp((qvar)nopt1,(qvar)nopt2) == 0) 
	|| (nopt1 == null && nopt2 == null)) {
      unify_list(ts1,ts2);
      return;
    }
    break;

  case $(EnumType(nopt2,ts2,edp2), EnumType(nopt1,ts1,edp1)):
    if (*edp2 == *edp1) {
      unify_list(ts1,ts2);
      return;
    }
    break;

  case $(XenumType(n2,xedp2),XenumType(n1,xedp1)):
    if(*xedp2 == *xedp1)
      return;
    break;

  case $(PointerType(PtrInfo{.elt_typ=t2a,.rgn_typ=rgn2,
			     .nullable=null2a,.tq=tqual2a,.bounds=b2}),
	 PointerType(PtrInfo{.elt_typ=t1a,.rgn_typ=rgn1,
			     .nullable=null1a,.tq=tqual1a,.bounds=b1})):
    unify_it(t1a,t2a);
    unify_it(rgn2,rgn1); // the whole reason regions are "types"
    unify_tqual(tqual1a,tqual2a);
    unify_it_conrefs(boundscmp,b1,b2);
    // There's no need to force the nullable's to be the same when
    // the bounds are ?.
    switch (compress_conref(b1)->v) {
    case Eq_constr(Unknown_b): return;
    default: break;
    }
    unify_it_conrefs(intcmp,null1a,null2a);
    return;

  case $(IntType(sn2,sz2), IntType(sn1,sz1)):
    if ((sn1 == sn2) && (sz1 == sz2)) return;
    break;

  case $(FloatType,    FloatType):    return;
  case $(DoubleType,   DoubleType):   return;

  case $(ArrayType(t2a,tq2a,e1), ArrayType(t1a,tq1a,e2)):
    unify_it(t1a,t2a);
    unify_tqual(tq1a,tq2a);
    if (Evexp::eval_const_uint_exp(e1) == Evexp::eval_const_uint_exp(e2)) 
      return;
    break;

  case $(FnType(tvs2,rt2,args2,vararg2), FnType(tvs1,rt1,args1,vararg1)):
    list<$(tvar,typ)@> inst = null;
    while (tvs1 != null) {
      if (tvs2 == null) break;
      inst = &cons(&$(tvs2->hd,VarType(tvs1->hd)),inst);
      tvs1 = tvs1->tl;
      tvs2 = tvs2->tl;
    }
    if (tvs2 != null) break;
    if (inst != null) {
      unify_it(FnType(null,rt1,args1,vararg1),
	       substitute(inst,FnType(null,rt2,args2,vararg2)));
      return;
    } 
    unify_it(rt1,rt2);
    for (; args1!=null && args2!=null; args1 = args1->tl, args2 = args2->tl) {
      unify_tqual((*args1->hd)[1],(*args2->hd)[1]);
      unify_it((*args1->hd)[2],(*args2->hd)[2]);
    }
    if ((args1 != null) || (args2 != null)) break;
    if (vararg1 == vararg2) return;
    break;

  case $(TupleType(ts2), TupleType(ts1)):
    for (; ts1 != null && ts2 != null; ts1 = ts1->tl, ts2 = ts2->tl) {
      unify_tqual((*ts1->hd)[0],(*ts2->hd)[0]);
      unify_it((*ts1->hd)[1],(*ts2->hd)[1]);
    }
    if (ts1 == null && ts2 == null) return;
    break;

  case $(HeapRgnType, HeapRgnType): return;
  case $(RgnHandleType(rt1),RgnHandleType(rt2)):
    unify_it(rt1,rt2);
    return;

  default: break;
  }
  throw Unify;
}

bool is_arithmetic_type(typ t) {
  switch (compress(t)) {
  case IntType(_,_): return true;
  case FloatType:    return true;
  case DoubleType:   return true;
  default:           return false;
  }
}

// we're about to convert a value of type t1 to type t2 (both arithmetic types)
// return true if we will potentially loose precision
bool will_lose_precision(typ t1, typ t2) {
  t1 = compress(t1);
  t2 = compress(t2);
  switch ($(t1,t2)) {
  case $(DoubleType,   FloatType):       return true;
  case $(DoubleType,   IntType(_,_)):    return true;
  case $(FloatType,    IntType(_,_)):    return true;
  case $(IntType(_,B8), IntType(_,B8)):  return false;
  case $(IntType(_,B8), _):              return true; // see prev case
  case $(IntType(_,B4), FloatType):      return true;
  case $(IntType(_,B4), IntType(_,B2)):  return true;
  case $(IntType(_,B4), IntType(_,B1)):  return true;
  case $(IntType(_,B2), IntType(_,B1)):  return true;
  default: return false;
  }
}

// coerce the list e so that each element has type t -- used in arrays and
// conditionals 
bool coerce_list(tenv te, typ t, list<exp> es) {
  // find the biggest arithmetic type (if any) for the list and determine
  // if all of the elements are boxed.
  Opt_t<typ> max_arith_type = null;
  for (list<exp> el = es; el != null; el = el->tl) {
    typ t1 = compress(el->hd->topt->v);
    if (is_arithmetic_type(t1)) 
      if (max_arith_type == null || will_lose_precision(t1,max_arith_type->v))
	max_arith_type = &Opt(t1);
  }
  // unify the max arithmetic type with the result type t
  if (max_arith_type != null)
    if (!unify(t,max_arith_type->v))
      return false;
  // now coerce each expression to the type t as if by assignment
  for (list<exp> el = es; el != null; el = el->tl)
    if (!coerce_assign(te,el->hd,t)) {
      terr(el->hd->loc,xprintf("type mismatch: expecting %s but found %s",
			       typ2string(t),typ2string(el->hd->topt->v)));
      return false;
    }
  return true;
}

// coerce e to have type "bool" (int) -- used in conditionals 
bool coerce_to_bool(tenv te, exp e) {
  if (!coerce_sint_typ(te,e)) {
    switch (compress(e->topt->v)) {
    case PointerType(_): unchecked_cast(te,e,uint_t); break;
    default: return false;
    }
  }
  return true;
}

bool is_integral_type(typ t) {
  switch (compress(t)) {
  case IntType(_,_): return true;
  default: return false;
  }
}

// coerce e to have type unsigned int -- used in subscript
bool coerce_uint_typ(tenv te, exp e) {
  if (unify(e->topt->v,uint_t)) 
    return true;
  // try arithmetic conversions -- we only allow integral values
  if (is_integral_type(e->topt->v)) {
    if (will_lose_precision(e->topt->v,uint_t))
      warn(e->loc,"integral size mismatch; conversion supplied");
    unchecked_cast(te,e,uint_t);
    return true;
  }
  return false;
}

// coerce e to have type [signed] int -- used in coercions to "bool"
bool coerce_sint_typ(tenv te, exp e) {
  if (unify(e->topt->v,sint_t)) 
    return true;
  // try arithmetic conversions -- we only allow integral values
  if (is_integral_type(e->topt->v)) {
    if (will_lose_precision(e->topt->v,sint_t))
      warn(e->loc,"integral size mismatch; conversion supplied");
    unchecked_cast(te,e,sint_t);
    return true;
  }
  return false;
}

// Can t1 be (implicitly) cast to t2? Assumes types are well-formed 
bool silent_castable(tenv te, segment loc, typ t1, typ t2) {
  t1 = compress(t1);
  t2 = compress(t2);
  switch ($(t1,t2)) {
 
  case $(PointerType(pinfo_a), PointerType(pinfo_b)):
    bool okay = true;
    // can coerce @ to *
    if (!unify_conrefs(intcmp,pinfo_a.nullable,pinfo_b.nullable)) {
      switch(compress_conref(pinfo_a.nullable)->v) {
      case Eq_constr(b): okay = !b; break;
      default: throw impos("silent_castable conref not eq");
      }
    }
    // can coerce *{e} to ? and *{e1} to *{e2} when e2 <= e1
    if (!unify_conrefs(boundscmp,pinfo_a.bounds,pinfo_b.bounds)) {
      switch ($(compress_conref(pinfo_a.bounds)->v, 
		compress_conref(pinfo_b.bounds)->v)) {
      case $(Eq_constr(Upper_b(_)),Eq_constr(Unknown_b)): 
	// Can cast to ? regardless of nullable
	okay = true; break;
	// JGM:  the following would be legal, but perhaps we don't
	// want to allow it to make porting easier -- I'm afraid
	// that writing t *x = y, where y is an array will go through
	// too easily...
	//case $(Eq_constr(Upper_b(e1)),Eq_constr(Upper_b(e2))):
	//okay = okay && (Evexp::eval_const_uint_exp(e1) >= 
	//		Evexp::eval_const_uint_exp(e2)); 
	//break;
      case $(Eq_constr(Unknown_b),Eq_constr(Unknown_b)):
	// Can cast ? to ? regardless of nullable
	okay = true; break;
      default:
	okay = false; break;
      }
    }
    return (okay && unify(pinfo_a.elt_typ,pinfo_b.elt_typ) &&
	    unify(pinfo_a.rgn_typ,pinfo_b.rgn_typ) &&
	    (!pinfo_a.tq->q_const || pinfo_b.tq->q_const));

  case $(ArrayType(t1a,tq1a,e1),ArrayType(t2a,tq2a,e2)):
    bool okay;
    okay = (Evexp::eval_const_uint_exp(e1)>=Evexp::eval_const_uint_exp(e2));
    return (okay && unify(t1a,t2a) && (!tq1a->q_const || tq2a->q_const));

  default: return unify(t1,t2);
  }
}

// coerce e to have type t -- used in function call and explicit fallthru
bool coerce_arg(tenv te, exp e, typ t2) {
  typ t1 = compress(e->topt->v);
  // see if types immediately match
  if (unify(t1,t2)) return true;
  // try arithmetic conversions
  if (is_arithmetic_type(t1) && is_arithmetic_type(t2)) {
    // issue a warning if we lose precision
    if (will_lose_precision(t1,t2))
      warn(e->loc,"integral size mismatch; conversion supplied");
    unchecked_cast(te,e,t2);
    return true;
  } else if (silent_castable(te,e->loc,t1,t2)) {
    unchecked_cast(te,e,t2);
    return true;
  } else if (castable(te,e->loc,t1,t2)) {
    unchecked_cast(te,e,t2);
    warn(e->loc,xprintf("implicit cast from %s to %s",typ2string(t1),
			typ2string(t2)));
    return true;
  } else return false;
}

// coerce e to have type t -- used in assignment operations.  Neither
// gcc nor VC++ issue warnings for losing precision here, but I think
// it may be appropriate.
bool coerce_assign(tenv te, exp e, typ t) {
  return coerce_arg(te,e,t);
}

static bool any_promote(tenv te, exp e) {
  typ old_typ = compress(e->topt->v);
  typ t;
  switch (old_typ) {
  case IntType(sn,sz):
    switch (sz) {
    case B1: t = sint_t; break; // convert to unboxed, signed int
    case B2: t = sint_t; break; // convert to unboxed, signed int
    case B4: t = (sn == Unsigned) ? uint_t : sint_t; break;   // make unboxed
    case B8: t = (sn == Unsigned) ? ulong_t : slong_t; break; // make unboxed
    }
    break;
  case FloatType:  t = float_t;  break; // make unboxed
  case DoubleType: t = double_t; break; // make unboxed
  default: return false;
  }
  unchecked_cast(te,e,t);
  return true;
}

// Convert e so that it has type t, possibly by casting t.  This is
// used in routines like function call or assignment where we may have
// to promote an integral type.
// FIX: THIS IS NOT RIGHT.
// FIX: account for unpackable kinds?
bool coerce_use(tenv te, exp e, typ t2) {
  typ    t1 = compress(e->topt->v);
  kind_t k1 = typ_kind(t1);
  kind_t k2 = typ_kind(t2);
  if (unify(t1,t2)) 
    return true;
  // unification failed, try promoting
  any_promote(te,e);
  if (unify(e->topt->v,t2)) 
    return true;
  else if (silent_castable(te,e->loc,t1,t2)) {
    unchecked_cast(te,e,t2);
    return true;
  } else if (castable(te,e->loc,t1,t2)) {
    unchecked_cast(te,e,t2);
    warn(e->loc,xprintf("implicit cast from %s to %s",typ2string(t1),
		       typ2string(t2)));
    return true;
  } else 
    return false;
}

bool coerceable(typ t) {
  switch (compress(t)) {
  case IntType(_,_): return true;
  case FloatType:    return true;
  case DoubleType:   return true;
  default:           return false;
  }
}

// Flatten a type into a list of type qualifiers and types for
// use in subtype comparison.
// FIX:  we should recursively flatten tuple and struct types here,
// but doing so is tricky because we have to get the padding and
// alignment right.  This seems to be particularly weird on the
// x86 -- I need to find precise documentation on it before we 
// do this.
static $(tqual,typ)@ flatten_typ_f(list<$(tvar,typ)@> inst,
                                   $(field_name,tqual,typ)@ x) {
  return &$((*x)[1],substitute(inst,(*x)[2]));
}
static list<$(tqual,typ)@> flatten_typ(tenv te,typ t1) {
  t1 = compress(t1);
  switch (t1) {
  case VoidType:       return null;
  case TupleType(tqs): return tqs; // FIX: recursively flatten here
  case StructType(tdnopt,ts,sdp):
    _ sd   = *sdp;
    _ n    = *tdnopt;
    _ inst = List::zip(sd->tvs,ts);
    if (sd->fields == null) return &cons(&$(empty_tqual(),t1),null);
    // FIX: recursively flatten here
    return List::map_c(flatten_typ_f,inst,sd->fields->v);
  default: return &cons(&$(empty_tqual(),t1),null);
  }
}

// FIX: the plan is, once we have a context that lets us assume t1 <= t2
// for recursive types, then to do deep subtyping.  
static bool ptrsubtype(tenv te, list<$(typ,typ)@> assume, typ t1, typ t2);
static bool subtype(tenv te, list<$(typ,typ)@> assume, typ t1, typ t2) {
  if (unify(t1,t2)) return true;
  for (_ a = assume; a != null; a = a->tl)
    if (unify(t1,(*a->hd)[0]) && unify(t2,(*a->hd)[1])) 
      return true;
  t1 = compress(t1);
  t2 = compress(t2);
  switch ($(t1,t2)) {
    case $(PointerType(PtrInfo{t_a, rt_a, null_a, q_a, b_a}),
	   PointerType(PtrInfo{t_b, rt_b, null_b, q_b, b_b})):
    // if t1 is const then t2 must be const
    if (q_a->q_const && !q_b->q_const) 
      return false;
    // if t1 is * then t2 must be *
    if (!unify_conrefs(intcmp,null_a,null_b) 
	&& conref_val(null_a) && !conref_val(null_b)) 
      return false;
    // if rt_a is not the heap, then rt_b must be the same (can relax this
    // later to a more general "outlives" relationship)
    switch (rt_a) {
    case HeapRgnType: break;
    default: unify(rt_a,rt_b); break;
    }
    // need to check that the bounds match up
    if (!unify_conrefs(boundscmp,b_a,b_b)) {
      switch ($(conref_val(b_a),conref_val(b_b))) {
      case $(Upper_b(_), Unknown_b): break;
      case $(Upper_b(e1), Upper_b(e2)): 
	if (Evexp::eval_const_uint_exp(e1) < Evexp::eval_const_uint_exp(e2))
	  return false;
	break;
      default: return false;
      }
    }
    return ptrsubtype(te, &cons(&$(t1,t2),assume), t_a, t_b);
  default: return false;
  }
}

// is t1* <= t2*?
//   we flatten t1 and t2 into structurally equivalent tuple types 
//   (and thus ignore field names, associativity of nested tuples and
//   structs, etc.) and then check that t1 is a width extension of t2 
//   and for each field, either (a) both t1 and t2 have qualifier "const"
//   and the t1 field is a subtype of the t2 field, or (b) t1 = t2.
static bool ptrsubtype(tenv te, list<$(typ,typ)@> assume, typ t1, typ t2) {
  list<$(tqual,typ)@> tqs1 = flatten_typ(te,t1);
  list<$(tqual,typ)@> tqs2 = flatten_typ(te,t2);
  for (; tqs2 != null; tqs2 = tqs2->tl, tqs1 = tqs1->tl) {
    if (tqs1 == null) return false;
    let &$(tq1,t1a) = tqs1->hd;
    let &$(tq2,t2a) = tqs2->hd;
    if (tq2->q_const && subtype(te,assume,t1a,t2a)) continue;
    else if (unify(t1a,t2a)) continue;
    else return false;
  }
  return true;
}

// Can t1 be cast to t2?  Assumes that the types are well-formed.
bool castable(tenv te, segment loc, typ t1, typ t2) {
  t1 = compress(t1);
  t2 = compress(t2);
  if(unify(t1,t2))
    return true;
  switch (t1) {
  case EnumType(name_opt,ts,ed):
    // can cast an enum to an int -- extracts the tag
    // FIX:  when the enum carries a value?!?
    return (coerceable(t2));
    // FIX: look at regions!
  case PointerType(PtrInfo{t_a,rt_a,null_a,q_a,b_a}):
    // can cast t* to t@ and vice versa.  
    // can cast a non-const pointer to a const pointer.  
    // can cast a t heap pointer to a t[],t[1], or t[?]
    // can cast a pointer in the heap to a pointer to some other region
    switch (t2) {
    case PointerType(PtrInfo{t_b,rt_b,null_b,q_b,b_b}):
      _ assump = &cons(&$(t1,t2),null);
      _ ptrsub =
	ptrsubtype(te,assump,t_a,t_b) && (!q_a->q_const || q_b->q_const);
      bool bounds_ok = unify_conrefs(boundscmp,b_a,b_b);
      if (!bounds_ok) {
	switch ($(conref_val(b_a),conref_val(b_b))) {
	  // We allow casts of any form as long as we can't statically
	  // tell that the bounds will be violated.
	case $(Upper_b(e_a),Upper_b(e_b)): 
	  if (Evexp::eval_const_uint_exp(e_a) >= 
	      Evexp::eval_const_uint_exp(e_b)) 
	    bounds_ok = true;
	  break;
	default: bounds_ok = true; break;
	}
      }
      return bounds_ok && ptrsub && (rt_a == HeapRgnType || unify(rt_a,rt_b));
    default: return false;
    }
  case ArrayType(t1a,tq1a,e1):
    switch (t2) {
    case ArrayType(t2a,tq2a,e2):
      bool okay;
      okay=(Evexp::eval_const_uint_exp(e1) >= Evexp::eval_const_uint_exp(e2));
      return (okay && unify(t1a,t2a) && (!tq1a->q_const || tq2a->q_const));
    default: return false;
    }
  // can cast a numeric type or bool to any numeric type
  case IntType(_,_): fallthru;
  case FloatType :  fallthru;
  case DoubleType:  return coerceable(t2);
  default: return false;
  }
}

// Replace e by a cast of e to t.  The caller must ensure that the cast is safe.
void unchecked_cast(tenv te, exp e, typ t) {
  if (!unify(e->topt->v,t)) {
    _ inner = copy_exp(e);
    e->r    = Cast_e(t,inner);
    e->topt = &Opt(t);
  }
}

bool comparison_promote(tenv te, exp e) {
  typ t;
  switch (compress(e->topt->v)) {
  case IntType(sn,sz):
    switch (sz) {
    case B1: t = sint_t; break; // convert to unboxed, signed int
    case B2: t = sint_t; break; // convert to unboxed, signed int
    case B4: t = (sn == Unsigned) ? uint_t : sint_t; break; // make uboxed
    case B8: return true;
    }
    break;
  case FloatType: t = float_t; break; // make unboxed
  case DoubleType: return true;
  default: return false;
  }
  unchecked_cast(te,e,t);
  return true;
}

// check that the expression has an arithmetic type and, if it's 
// a size that is smaller than an int, then promote it up to int.
// Note that unsigned char or unsigned short will be promoted to
// signed int.  Otherwise, the sign is preserved.
bool arithmetic_promote(tenv te, exp e) {
  typ old_typ = compress(e->topt->v);
  typ t;
  switch (old_typ) {
  case IntType(sn,sz):
    switch (sz) {
    case B1:  t = sint_t; break; // convert to unboxed, signed int
    case B2:  t = sint_t; break; // convert to unboxed, signed int
    case B4: // make unboxed
      t = (sn == Unsigned) ? uint_t : sint_t;
      break;
    case B8: // make unboxed
      t = (sn == Unsigned) ? ulong_t : slong_t;
      break;
    }
    break;
  case FloatType:  t = float_t;  break; // make unboxed
  case DoubleType: t = double_t; break; // make unboxed
  case EnumType(_,_,_): t = sint_t;   break; // convert to unboxed, signed int
  case Evar(_,_,_):
    t = sint_t;
    if (!unify(old_typ,t))
      return false;
    break;
  default:
    return false;
  }
  unchecked_cast(te,e,t);
  return true;
}


// Make sure that e has integral type; if it's a size that is
// smaller than an int, then promote it up to int.  Note that unsigned
// char or unsigned short will be promoted to signed int.  Otherwise,
// the sign is preserved.
bool integral_promote(tenv te, exp e) {
  typ old_typ = compress(e->topt->v);
  typ t;
  switch (old_typ) {
  case IntType(sn,sz):
    switch (sz) {
    case B1: t = sint_t; break; // convert to unboxed, signed int
    case B2: t = sint_t; break; // convert to unboxed, signed int
    case B4: t = (sn == Unsigned) ? uint_t  : sint_t;  break; // make unboxed
    case B8: t = (sn == Unsigned) ? ulong_t : slong_t; break; // make unboxed
    }
    break;
  case EnumType(_,_,_):
    t = sint_t;
    break; // convert to unboxed, signed int
  case Evar(_,_,_):
    t = sint_t;
    if (!unify(old_typ,t))
      return false;
    break;
  default:
    return false;
  }
  unchecked_cast(te,e,t);
  return true;
}
typ max_arithmetic_type(typ t1, typ t2) {
  switch ($(t1,t2)) {
  case $(DoubleType,_): fallthru;
  case $(_,DoubleType): return DoubleType;
  case $(FloatType,_):  fallthru;
  case $(_,FloatType):  return FloatType;
  case $(IntType(Unsigned,B8),_): fallthru;
  case $(_,IntType(Unsigned,B8)): return IntType(Unsigned,B8);
  case $(IntType(Signed,B8),_):   fallthru;
  case $(_,IntType(Signed,B8)):   return IntType(Signed,B8);
  case $(IntType(Unsigned,B4),_): fallthru;
  case $(_,IntType(Unsigned,B4)): return IntType(Unsigned,B4);
  default: return IntType(Signed,B4);
  }
}

// used to warn when a while, for, if, or do test contains an assignment
void check_contains_assign(exp e) {
  switch (e->r) {
  case AssignOp_e(_,null,_): warn(e->loc,"assignment in test"); break;
  default: break;
  }
}

// Note: The kind inference in check_valid_type updates the kinds in the tyvars.
void check_fndecl_valid_type(segment loc,tenv te,fndecl fd) {
  check_unique_tvars(loc,fd->tvs);
  check_valid_type(loc,te,fd->tvs,fd->ret_type);
  for (_ x = fd->args; x != null; x = x->tl)
    check_valid_type(loc,te,fd->tvs,(*x->hd)[2]);
}

static $(Opt_t<var>,tqual,typ)@ fndecl2typ_f($(var,tqual,typ)@ x) {
  return &$((Opt_t<var>)&Opt((*x)[0]), (*x)[1], (*x)[2]);
}
typ fndecl2typ(fndecl fd) {
  return FnType(fd->tvs,
                fd->ret_type,
                List::map(fndecl2typ_f, fd->args),
                fd->varargs);
}

static $($(Opt_t<var>,tqual)@,typ)@ substitute_f1($(Opt_t<var>,tqual,typ)@ y) {
  return &$(&$((*y)[0],(*y)[1]),(*y)[2]);
}
static $(Opt_t<var>,tqual,typ)@ substitute_f2($($(Opt_t<var>,tqual)@,typ)@ w) {
  let $(p,t) = *w;
  let $(vopt,tq) = *p;
  return &$(vopt,tq,t);
}
static list<typ> substs(list<$(tvar,typ)@> inst, list<typ> ts);
typ substitute(list<$(tvar,typ)@> inst, typ t) {
  switch (compress(t)) {
  case VarType(v):
    // a tvar lookup, not a var lookup!
    try return List::assoc_cmp(tvar_cmp,inst,v);
    catch {case Not_found: return t;}
  case StructType(no,ts,sd):   return StructType(no,substs(inst,ts),sd);
  case EnumType(no,ts,ed):     return EnumType(no,substs(inst,ts),ed);
  case TypedefType(n,ts,topt): return TypedefType(n,substs(inst,ts),topt);
  case ArrayType(t1,tq,e):     return ArrayType(substitute(inst,t1),tq,e);
  case PointerType(PtrInfo{t1,r,n,tq,b}): 
    return PointerType(PtrInfo{substitute(inst,t1),substitute(inst,r),n,tq,b});
  case FnType(vs,rtyp,args,varargs):
    for (let p = vs; p != null; p = p->tl)
      inst = &cons(&$(p->hd,VarType(p->hd)),inst);
    let $(qs,ts) = List::split(List::map(substitute_f1, args));
    _   ts2      = substs(inst,ts);
    _   args2    = List::map(substitute_f2, List::zip(qs,ts2));
    return FnType(vs,substitute(inst,rtyp), args2, varargs);
  case TupleType(tqts):
    let $(tqs,ts) = List::split(tqts);
    _   ts2       = substs(inst,ts);
    _   tqts2     = List::zip(tqs,ts2);
    return TupleType(tqts2);
  case Evar(_,r,_):
    if (r != null) return(substitute(inst,r->v));
    else return t;
  case RgnHandleType(rt): return RgnHandleType(substitute(inst,rt)); 

  case VoidType:       return t;
  case XenumType(_,_): return t;
  case IntType(_,_):   return t;
  case FloatType:      return t;
  case DoubleType:     return t;
  case HeapRgnType:    return t;

  case UnionType:      return t;
  }
}
static list<typ> substs(list<$(tvar,typ)@> inst, list<typ> ts) {
  return List::map_c(substitute,inst,ts);
}

exp default_initializer(tenv te, typ t, segment loc) {
  exp e = new_exp(Const_e(Null_c),loc);

  switch (compress(t)) {
  case PointerType(_): break; // FIX: non-nullable is an error!
  case IntType(sg,B1):
    e->r = Const_e(Char_c(Signed,'\000'));
    break;
  case IntType(sg,sz):
    e->r = Const_e(Int_c(sg,0));
    if (sz != B4)
      e = new_exp(Cast_e(t,e),loc);
    break;
  case FloatType:
    e->r = Const_e(Float_c("0.0"));
    break;
  case DoubleType:
    e->r = Cast_e(t,new_exp(Const_e(Float_c("0.0")), loc));
    break;
/*
  case ArrayType*(t,eopt):
    if (eopt == null)
      e->r = ConstArray_e(null,&Opt(t));
    else {
      e->r =
	FnCall_e(&Exp(null,Var("new_array"),loc),null,
	&cons(eopt->v,&cons(default_initializer(te,t,loc),null)));
    }

  case StringType:  e->r = Const_e(String_c(""));
  case CharType:    e->r = Const_e(Char_c('\000'));
  case TupleType(ts):
    e->r = NewTuple_e(List::map_c(def_init,&$(te,loc),ts));
  case NamedType(p):
    let n  = p[0];
    let ts = p[1];
    // check for an opened type name
    if (!(Dict::member(te->structs,n)
	  || Dict::member(te->unions,n)
	  || Dict::member(te->abstracts,n))) {
      try {
	n = Dict::lookup(te->open_typs,n);
	p[0] = n;
      } catch {
      case Dict::Absent: terr2(loc,"unbound type name ",n);
      }
    }
    // if it's possibly null, we'e done otherwise...
    if (possibly_null(te,n)) return e;
    let sdopt = Dict::lookup_opt(te->structs,n);
    let udopt;
    if (sdopt != null) {
      // n is a struct -- return a struct of the default expressions for
      // each of the field types->
      let sd = sdopt->v[0];
      let inst = List::zip(sd->tvs,ts);
      let es =
	List::map_c(fun *(<field_name>Opt,exp)
		     f(*(*(tenv,segment),list<$(var,typ)@>) env,
		       *(field_name,capability,typ)               field){
		       return &$(null,def_init(env[0],subst(env[1],field[2])));
		    },
                   &$(&$(te,loc),inst),
		   sd->fields);
      e->r = NewStruct_e(n,&Opt(ts),es);
    } else if ((udopt = Dict::lookup_opt(te->unions,n)) != null) {
      // n is a union -- return the first field (and an expression of the
      // argument type if any->)
      let ud = udopt->v[0];
      if (ud->fields == null) {
	terr(loc,"Union has no fields!");
      } else {
	// get first field
	let field = ud->fields->hd[0];
	// get its type
	typ t = ud->fields->hd[1];
	// if it's void then the field doesn't carry a value
	if (t == VoidType)
	  e->r = NewUnion_e(n,&Opt(ts),field,null);
	else {
	  // otherwise construct a default value for that type
	  let inst = List::zip(ud->tvs,ts);
	  let e2 = &Opt(default_initializer(te,subst(inst,t),loc));
	  e->r = NewUnion_e(n,&Opt(ts),field,e2);
	}
      }
    } else
      terr(loc,"Abstract types require initializers->");
*/

  default:
    terr(loc, xprintf("declaration of type %s requires initializer",
		      typ2string(t)));
    break;
  }
  return e;
}

$(tvar,typ)@ make_inst_var(tvar tv) {
  return &$(tv, new_evar(UnresolvedKind));
}

// Check that the type is valid assuming that the free type variables
// are drawn from the given list.  Perform the following side-effects,
// which most of the compiler rightfully assumes have occurred:
// * expand typedefs
// * set pointers to declarations for StructType, EnumType, and XenumType
// * change relative type names to absolute type names
// * set the kind field of type variables.  We do just a tad of trivial 
//   inference: if the parse leaves the kind of a tyvar Unresolved, then
//   it's RgnKind if it appears in a region position, a BoxPKind if it appears
//   elsewhere, and a BoxPKind with a warning if it doesn't appear.
// Note: check_valid_type should only be called with types that should not have
//       RgnKind. Analogously, check_valid_rgn should only be called with types
//       that should have RgnKind.
// FIX: Right under a pointer, infer a type variable has kind MemPKind.
//      (Add a mutually recursive check_valid_mem_type.  This isn't too useful
//       until structdecls and enumdecls can have memkind type parameters.)
void check_valid_rgn(segment loc,tenv te,list<tvar> bound_vars, typ t){
  switch (compress(t)) {
  case HeapRgnType: return;
  case Evar(*k,null,i):
    switch(*k) {
    case UnresolvedKind: *k = RgnKind; return;
    case RgnKind: return;
    default: terr(loc,"This type should be a region."); return;
    }
  case VarType(pr):
    let &$(tv,k) = pr;
    for(; bound_vars != null; bound_vars = bound_vars->tl) 
      if(String::zstrptrcmp((*bound_vars->hd)[0],tv)==0) {
	_ bk = (*bound_vars->hd)[1];
	if((bk != RgnKind && bk != UnresolvedKind)
	   || (k != RgnKind && k != UnresolvedKind)) {
	  terr(loc, "Type variable used as region");
	  return;
	}
	(*pr)[1] = (*bound_vars->hd)[1] = RgnKind;
	return;
      }
    // it might be a local block region
    try {
      int i = String::to_int(*tv,null);
      if (valid_block(te,i)) return;
    } catch {
    case InvalidArg(_): break;
    }
    terr(loc,xprintf("unbound type variable %s",*tv));
    return;
    
  default: terr(loc,"This type should be a region."); return;
  }
}
void check_valid_type(segment loc, tenv te, list<tvar> bound_vars, typ t) {
  switch (compress(t)) {
  case VoidType: break;
  case Evar(RgnKind,topt,i): fallthru;
  case HeapRgnType: 
    terr(loc,"This type should not be a region.");
    return;
  case Evar(*k,topt,i):
    if(*k==UnresolvedKind)
      *k = MemUKind;
    break;
  case VarType(pr):
    let &$(tv,k) = pr;
    for(; bound_vars != null; bound_vars = bound_vars->tl)
      if(String::zstrptrcmp((*bound_vars->hd)[0],tv)==0)
	switch ($((*bound_vars->hd)[1],k)) {
	case $(_,RgnKind): fallthru;
	case $(RgnKind,_): terr(loc,"Region variable used as type"); return;
	case $(UnresolvedKind,BoxPKind): fallthru;
	case $(UnresolvedKind,UnresolvedKind):
	  (*pr)[1] = (*bound_vars->hd)[1] = BoxPKind;
	  return;
	case $(UnresolvedKind,_):
	  terr(loc,"Wrong kind for type variable");
	  return;
	case $(bk,_):
	  if(k==UnresolvedKind || bk==k)
	    (*pr)[1] = bk;
	  else
	    terr(loc,"Wrong kind for type variable");
	  return;
	}
    terr(loc,xprintf("unbound type variable %s",*tv));
    return;
  case EnumType(tdnopt,targs,*edp):
    if (tdnopt == null) {
      terr(loc,"missing enum name");
      return;
    }
    if(*edp == null) {
      try *edp = lookup_enumdecl(te,loc,(typedef_name_t)tdnopt);
      catch { case Dict::Absent: 
	terr(loc,xprintf("unbound type enum %s",qvar2string((qvar)tdnopt)));
      return;
      }
    } 
    enumdecl ed = **edp;
    // Make relative name absolute (or replace absolute name with itself)
    if (ed->name != null) // sanity check
      *tdnopt = ed->name->v[0];
    int lvs   = List::length(ed->tvs);
    int largs = List::length(targs);
    if (lvs != largs)
      terr(loc,xprintf("enum %s expects %d type arguments, not %d",
		       qvar2string((qvar)tdnopt),lvs,largs));
    // check that each of the type arguments is well-formed packable box type
    for (; targs != null; targs = targs->tl) {
      typ t1 = targs->hd;
      check_valid_type(loc,te,bound_vars,t1);
      if (typ_kind(t1) != BoxPKind) 
	terr(loc,xprintf("type %s is not a packable boxed type",
			 typ2string(t1)));
    }
    break;
  case XenumType(tdn,*xedp):
    if(*xedp == null) {
      try { 
	Opt_t<xenumdecl@> xed = lookup_xenumdecl(te,loc,tdn);
	if(xed == null) {
	  terr(loc,xprintf("unbound xenum %s",qvar2string(tdn)));
	  return;
	}
	*xedp = xed->v;
      } catch { case Dict::Absent:
	terr(loc,xprintf("unbound xenum %s",qvar2string(tdn)));
        return;
      }
    }
    xenumdecl xed = **xedp;
    // Make relative name absolute (or replace absolute name with itself)
    tdn[0] = xed->name[0];
    break;
  case PointerType(PtrInfo{.elt_typ=t1,.rgn_typ=rgn_typ,.nullable=nullable,
			      .tq=tq,.bounds=b}):
    // FIX: check that tqual is valid?
    check_valid_type(loc,te,bound_vars,t1);
    check_valid_rgn(loc,te,bound_vars,rgn_typ);
    // check that any bound is a constant expression
    switch (compress_conref(b)->v) {
    case Eq_constr(Upper_b(e)): Evexp::eval_const_uint_exp(e); break;
    default: break;
    }
    break;
  case RgnHandleType(rgn_typ):
    check_valid_rgn(loc,te,bound_vars,rgn_typ);
    break;
  case IntType(_,_): break; 
  case FloatType:    break; 
  case DoubleType:   break; 
  case ArrayType(t1,tq,e):
    // FIX: check that tqual is valid?
    check_valid_type(loc,te,bound_vars,t1);
    // FIX: should memoize the size so that we don't have to worry about
    // evaluating it during unification
    Evexp::eval_const_uint_exp(e); // check that e is of constant size
    break;
  case FnType(btvs,tr,args,vararg):
    // FIX:  make sure that `H is not a bound variable...
    check_unique_tvars(loc,btvs);
    list<tvar> new_bound_vars = List::append(btvs,bound_vars);
    check_valid_type(loc,te,new_bound_vars,tr);
    for (; args != null; args = args->tl) {
      // FIX: should check that variables are unique and that tquals are okay
      check_valid_type(loc,te,new_bound_vars,(*args->hd)[2]);
    }
    // if any kinds are still unresolved, warn and make them BoxPKind
    for(; btvs != null; btvs = btvs->tl)
      if((*btvs->hd)[1] == UnresolvedKind) {
	warn(loc,xprintf("Type variable %s unused, assuming boxed",
			 *((*btvs->hd)[0])));
	(*btvs->hd)[1] = BoxPKind;
      }
    break;
  case TupleType(tq_ts):
    // FIX: check the tquals
    for (; tq_ts != null; tq_ts = tq_ts->tl)
      check_valid_type(loc,te,bound_vars,(*tq_ts->hd)[1]);
    break;
  case StructType(tdnopt,targs,*sdp):
    if (tdnopt == null) {
      terr(loc,"missing struct name");
      return;
    }
    if(*sdp == null) {
      try *sdp = lookup_structdecl(te,loc,(qvar)tdnopt);
      catch { case Dict::Absent:
	terr(loc,xprintf("unbound type struct %s",qvar2string((qvar)tdnopt)));
        return;
      }
    }
    structdecl sd = **sdp;
    // Make relative name absolute (or replace absolute name with itself)
    if (sd->name != null) // sanity check
      *tdnopt = sd->name->v[0];
    int lvs   = List::length(sd->tvs);
    int largs = List::length(targs);
    if (lvs != largs) 
      terr(loc,xprintf("struct %s expects %d type arguments but was given %d",
		       qvar2string((qvar)tdnopt),lvs,largs));
    // check that each of the type arguments is a well-formed packable box type
    for (; targs != null; targs = targs->tl) {
      typ t1 = targs->hd;
      check_valid_type(loc,te,bound_vars,t1);
      if (typ_kind(t1) != BoxPKind)
	terr(loc,xprintf("type %s is not a packable boxed type",
			 typ2string(t1)));
    }
    break;
  case TypedefType(tdn,targs,*toptp):
    // NB: since we called compress *toptp == null
    typedefdecl td;
    try td = lookup_typedefdecl(te,loc,tdn);
    catch { case Dict::Absent:
      terr(loc,xprintf("unbound typedef name %s",qvar2string(tdn)));
      return;
    }
    // Make relative name absolute (or replace absolute name with itself)
    tdn[0] = td->name[0];
    
    // FIX: allow typedefs over other kinds???
    for (list<typ> ts = targs; ts != null; ts = ts->tl) {
      check_valid_type(loc,te,bound_vars,ts->hd);
      if (typ_kind(ts->hd) != BoxPKind)
	terr(loc,xprintf("type %s is not a packable boxed type",
			 typ2string(ts->hd)));
    }
    list<$(tvar,typ)@> inst;
    try inst = List::zip(td->tvs,targs);
    catch { case List::List_mismatch:
      terr(loc,xprintf("typedef %s expects a different number of arguments",
		       qvar2string(tdn)));
      return;
    }
    typ new_typ = substitute(inst,td->defn);
    *toptp = &Opt(new_typ);
    break;
  case UnionType:
    terr(loc,"union type unsupported");
    break;
  } 
}

// Note: we expect lists to be very short.  Otherwise, a hashtable would
// be a better choice.
static void check_unique_unsorted<`a>(int (@cmp)(`a,`a), list<`a> vs,
				      segment loc, string msg) {
  for(; vs != null; vs = vs->tl)
    for(_ vs2 = vs->tl; vs2 != null; vs2 = vs2->tl)
      if(cmp(vs->hd, vs2->hd)== 0)
	terr(loc, msg);
}

void check_unique_vars(list<var> vs, segment loc, string msg) {
  check_unique_unsorted(String::zstrptrcmp,vs,loc,msg);
}

void check_unique_tvars(segment loc, list<tvar> tvs) {
  check_unique_unsorted(tvar_cmp,tvs,loc,"duplicate type variable");
}

// take a list of $(list<designator>,`a) things corresponding to a struct.
// ensure the struct is not abstract.
//  * check that each list<designator> has exactly one element which is a 
//    FieldName or is empty
//  * match up the correct member of sd->fields with the `a.  If the list
//    is empty, take the first unused field. ?????
//    Bang in the corresponding designator in the des list element
//  * ensure that each field is used exactly once.
// (This functionality was repeated in tcPat and tcExp and was annoying me.)
// FIX: Pass in a flag to allow multiple field names ??
list<$($(field_name,tqual,typ)@,`a)@>
resolve_struct_designators<`a>(seg_t loc,
			       list<$(list<designator>,`a)@> des, 
			       structdecl sd) {
  if(sd->fields == null)
    terr(loc, "inappropriate use of abstract struct");

  // grab all the fields and mark them unused
  list<$($(field_name,tqual,typ)@,bool)@> fields = null;
  for(_ sd_fields = sd->fields->v; sd_fields != null; sd_fields = sd_fields->tl)
    fields = &cons(&$(sd_fields->hd,false), fields);
  fields = imp_rev(fields);

  // match up each element of des
  list<$($(field_name,tqual,typ)@,`a)@> ans = null;
  for(; des != null; des = des->tl) {
    let &$(dl,a) = des->hd;
    if(dl == null) {
      // grab first unused
      _ fields2 = fields;
      for(; fields2 != null; fields2 = fields2->tl)
	if(!(*fields2->hd)[1]) {
	  (*fields2->hd)[1] = true;
	  (*des->hd)[0] = &cons(FieldName((*(*fields2->hd)[0])[0]), null);
	  ans = &cons(&$((*fields2->hd)[0],a), ans);
	  break;
	}
      if(fields2 == null)
	terr(loc, "too many arguments to struct");
    } else if(dl->tl != null)
      // we don't support multiple designators
      terr(loc, "multiple designators are not supported");
    else
      // find the right field based on the designator
      switch (dl->hd) {
      case ArrayElement(_): 
	terr(loc, "array designator used in argument to struct");
	break;
      case FieldName(v):
	_ fields2 = fields;
	for(; fields2 != null; fields2 = fields2->tl)
	  if(String::zstrptrcmp(v,(*(*fields2->hd)[0])[0]) == 0) {
	    if((*fields2->hd)[1])
	      terr(loc, 
		   xprintf("field %s has already been used as an argument", 
			   *v));
	    (*fields2->hd)[1] = true;
	    ans = &cons(&$((*fields2->hd)[0],a), ans);
	    break;
	  }
	if(fields2 == null)
	  terr(loc, xprintf("bad field designator %s", *v));
	break;
      }
  }
  
  // make sure we used all the fields
  for(; fields != null; fields = fields->tl)
    if(!(*fields->hd)[1]) {
      terr(loc, "too few arguments to struct");
      break;
    }

  return imp_rev(ans);
}

bool is_tagged_pointer_typ(typ t) {
  switch (compress(t)) {
  case PointerType(PtrInfo{_,_,_,_,b}):
    _ b = compress_conref(b);
    switch (compress_conref(b)->v) {
    case Eq_constr(Unknown_b): return true;
    case No_constr: 
      b->v = Eq_constr(Unknown_b); return true;
    default: return false;
    }
  default: return false;
  }
}

// used by address of.  
// Ensure e is an lvalue or function designator.
// Return if &e is const (true for const) and what region e is in (via a type
//    of RgnKind).
// FIX: not sure const is sufficient to prevent assigning to a function
//      designator???
// Type errors should already have been reported, so we often silently return
//   a bogus answer to avoid duplicate errors.
// Note: regions might not be resolved (unification is order-dependent),
//   but that's okay because a later unification will ensure soundness.
// Note: As explained below, if e1 is a FixedArray, then &e1[e2] is only
//   legal if e1 is an lvalue.  This is not true in C, but I need it, at least
//   for now, and I doubt anyone minds.
$(bool,typ) addressof_props(tenv te, exp e) {
  // in some situations, the pointer must actually be const
  $(bool,typ) bogus_ans = $(false,HeapRgnType);
  switch (e->r) {
  case Var_e(q,x):
    // where oh where does my variable live?
    switch(x) {
    case Unresolved_b: return bogus_ans;
    case Funname_b(_): return $(true, HeapRgnType); 
    case Global_b(vd): 
      switch (compress(e->topt->v)) {
	// arrays cannot be modified
      case ArrayType(_,_,_): return $(true, HeapRgnType);
      default: return $(vd->tq->q_const, HeapRgnType);
      }
    case Local_b(vd):  
      switch (compress(e->topt->v)) {
      case ArrayType(_,_,_): return $(true, block_to_typ(te,vd->block));
      default: return $(vd->tq->q_const, block_to_typ(te,vd->block));
      }
    case Pat_b(vd):    
      return $(vd->tq->q_const, block_to_typ(te,vd->block));
      // KLUDGE: assumes parameters are block 0
    case Param_b(&$(_,tq,_)): return $(tq->q_const, block_to_typ(te,0));
    }
  case StructMember_e(e1,f):
    // we have an unboxed thing, so we inherit e2's region
    switch (compress(e1->topt->v)) {
    case StructType(_,_,&sd):
      _ finfo = lookup_struct_field(sd,f);
      if(finfo != null)
	return $((*finfo)[1]->q_const, addressof_props(te,e1)[1]);
      fallthru;
    default: return bogus_ans;
    }
  case StructArrow_e(e1,f): 
    // we have a boxed thing, so the region is in the pointer-type.
    switch (compress(e1->topt->v)) {
    case PointerType(PtrInfo{t1,r,_,_,_}): 
      switch (compress(t1)) {
      case StructType(_,_,&sd):
	_ finfo = lookup_struct_field(sd,f);
	if(finfo != null)
	  return $((*finfo)[1]->q_const, r);
	fallthru;
      default: return bogus_ans;
      }
    default: return bogus_ans;
    }
  case Deref_e(e1):
    // we have a boxed thing, so the region is in the pointer-type.
    switch (compress(e1->topt->v)) {
    case PointerType(PtrInfo{_,r,_,tq,_}): 
      return $(tq->q_const, r); // FIX: is tq set correctly?
    default: return bogus_ans;
    }

  case Subscript_e(e1,e2):
    // here we need to figure out whether we've got a boxed thing
    // or not because [] is overloaded for all array kinds, tuples, and
    // tuple pointers.
    // FIX: eventually a tagged array's elements may live in a region, for now, 
    // they always in the heap
    typ t = compress(e1->topt->v);
    switch (t) {
    case ArrayType(_,tq,_): 
      // NOTE: Unlike C, we cannot allow any e1 -- it must be an lvalue.
      // (C doesn't need to know the region and we do!)
      return $(tq->q_const, addressof_props(te,e1)[1]);
    case TupleType(ts):
      // We need an lvalue in this unboxed case whereas "C w/ tuples" wouldn't.
      _ finfo = lookup_tuple_field(ts,Evexp::eval_const_uint_exp(e2));
      if(finfo != null)
	return $((*finfo)[0]->q_const, addressof_props(te,e1)[1]);
      return bogus_ans;
    case PointerType(PtrInfo{t2,r,_,_,b}): 
      // boxed tuple case -- so the region is in the pointer type.
      switch(compress(t2)) {
      case TupleType(ts):
	_ finfo = lookup_tuple_field(ts,Evexp::eval_const_uint_exp(e2));
	if(finfo != null)
	  return $((*finfo)[0]->q_const, r);
	fallthru;
      default: return bogus_ans;
      }
    default: return bogus_ans;
    }
  default: 
    terr(e->loc,"invalid portion in left-hand-side"); 
    return bogus_ans;
  }
}

// Coerce an expression of array type to a pointer type.  In
// certain situations, we undo this coercion, notably when e is
// a string constant or Array_e expression occurring as follows:
//    t x[c] = e
//    {.... e ... }  where the {...} is an Array_e
//    Foo(.... e ....)  where Foo is a struct or enum with a corresponding 
//         field that has type t 

typ array_to_ptr(tenv te, typ e_typ, exp e) {
  switch (compress(e_typ)) {
  case ArrayType(t,tq,_):
    let $(_,rgn) = addressof_props(te,e);
    return atb_typ(t,rgn,tq,Upper_b(e));
  default: 
    return e_typ;
  }
}

// give an error when we can statically tell that the array bounds
// aren't large enough -- if the bounds are unconstrained, set them
// to i+1.
void check_bound(segment loc, unsigned int i, conref<bounds_t> b) {
  b = compress_conref(b);
  switch (b->v) {
  case Eq_constr(Unknown_b): return; // checked dynamically
  case Eq_constr(Upper_b(e)):
    if (Evexp::eval_const_uint_exp(e) <= i)
      terr(loc, "dereference is out of bounds");
    return;
  default:
    // constrain the bounds to be i+1
    b->v = Eq_constr(Upper_b(uint_exp(i+1,null)));
    return;
  }
}

void check_nonzero_bound(segment loc, conref<bounds_t> b) {
  check_bound(loc, 0, b);
}

