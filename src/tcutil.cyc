/* Utility functions for type checking.
   Copyright (C) 2001 Greg Morrisett, AT&T
   This file is part of the Cyclone compiler.

   The Cyclone compiler is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   The Cyclone compiler is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with the Cyclone compiler; see the file COPYING. If not,
   write to the Free Software Foundation, Inc., 59 Temple Place -
   Suite 330, Boston, MA 02111-1307, USA. */

#include <core.h>
#include <stdio.h>
#include "absyn.h"
#include "absynpp.h"
#include <set.h>
#include <position.h>
#include "tcenv.h"
#include <string.h>
#include "evexp.h"
#include "tcutil.h"
#include "tcexp.h"
#include "tc.h"
using Core;
using List;
using Set;
using Position;
using Absyn;
using Absynpp;
using Tcenv;

namespace Tcutil;

xtunion exn {Unify};

extern void unify_it(type_t t1, type_t t2);

// Variables set to indicate where a failure occurs
type_t t1_failure = VoidType;
type_t t2_failure = VoidType;
// why the unification failed
const char ? failure_reason = NULL;
// print out an explanation about where and why a type error
// occurred -- this augments the high-level information with
// low-level specific details.
void explain_failure() {
  if(Position::num_errors >= Position::max_errors) return;
  fflush(stderr);
  string_t s1 = typ2string(t1_failure);
  string_t s2 = typ2string(t2_failure);
  int pos = 8;
  fprintf(stderr,"\t%s and ",s1);
  pos += s1.size+5;
  if (pos >= 80) {
    fprintf(stderr,"\n\t");
    pos = 8;
  }
  fprintf(stderr,"%s ",s2);
  pos += s2.size+1;
  if (pos >= 80) {
    fprintf(stderr,"\n\t");
    pos = 8;
  }
  fprintf(stderr,"failed to unify. ");
  pos += 17;
  if (failure_reason != NULL) {
    if (pos >= 80) {
      fprintf(stderr,"\n\t");
      pos = 8;
    };
    fprintf(stderr,"%s",failure_reason);
  }
  fprintf(stderr,"\n");
  fflush(stderr);
}

void terr(seg_t loc, string_t fmt, ... inject parg_t ap) 
  __attribute__((format(printf,2,3)))
{
  Position::post_error(Position::mk_err_elab(loc,vrprintf(heap_region,fmt,ap)));
}

`a impos(string_t fmt, ... inject parg_t ap) 
  __attribute__((format(printf,1,2), noreturn))
{
  string_t msg = vrprintf(heap_region,fmt,ap);
  fprintf(stderr,"Compiler Error (Tcutil::impos): %s\n",msg);
  fflush(stderr);
  throw new Impossible(msg);
}

static string_t tvar2string(tvar_t tv) {
  return *tv->name;
}

void print_tvars(list_t<tvar_t> tvs) {
  for (; tvs != NULL; tvs = tvs->tl) 
    fprintf(stderr,"%s::%s ",
	    tvar2string(tvs->hd),kindbound2string(tvs->hd->kind));
  fprintf(stderr,"\n"); fflush(stderr);
}

static list_t<seg_t>       warning_segs = NULL;
static list_t<stringptr_t> warning_msgs = NULL;

// we batch warnings because we have to parse the file to determine
// line and column information.
void warn(seg_t sg, string_t fmt, ... inject parg_t<`r2> ap) 
  __attribute__((format(printf,2,3)))
{
  string_t msg = vrprintf(heap_region,fmt,ap);
  warning_segs = new List(sg,      warning_segs);
  warning_msgs = new List(new msg, warning_msgs);
}
void flush_warnings() {
  if(warning_segs == NULL)
    return;
  fprintf(stderr,"***Warnings***\n");
  let seg_strs = strings_of_segments(warning_segs);
  warning_segs = NULL;
  warning_msgs = List::imp_rev(warning_msgs);
  while(warning_msgs != NULL) {
    fprintf(stderr,"%s: %s\n", *(seg_strs->hd), *(warning_msgs->hd));
    seg_strs     = seg_strs->tl;
    warning_msgs = warning_msgs->tl;
  }
  fprintf(stderr,"**************\n");
  fflush(stderr);
}

// set by by Tcenv::tc_init, used to reduce allocation and calls to Set::empty.
opt_t<set_t<var_t>> empty_var_set = NULL;

// fast type-variable comparison -- can only be used when a tvar has
// an identity.
static int fast_tvar_cmp(tvar_t tv1, tvar_t tv2) {
  return (*tv1->identity - *tv2->identity);
}

// compress out any evars or typedefs
type_t compress(type_t t) {
  switch (t) {
  case &Evar(_,NULL,_,_): 
  case &TypedefType(_,_,_,NULL): return t;
  case &TypedefType(_,_,_,*topt_ref): fallthru(topt_ref);
  case &Evar(_,*t2opt_ref,_,_): // TRICKY
    type_t t2 = compress((*t2opt_ref)->v);
    // only modify if something changed to avoid allocation
    if (t2 != (*t2opt_ref)->v)
      *t2opt_ref = new Opt(t2);
    return t2;
  default: return t;
  }
}

// does a deep copy of a type to avoid sharing type variables.
// Note that any evars continue to be shared.  This should
// be run only before feeding the type to the well-formedness checker.
type_t copy_type(type_t t);
static list_t<type_t> copy_types(list_t<type_t> ts) {
  return List::map(copy_type, ts);
}
static conref_t<`a> copy_conref(conref_t<`a> c) {
  switch (c->v) {
  case No_constr: return empty_conref();
  case &Eq_constr(x): return new_conref(x);
  case &Forward_constr(cr): return copy_conref(cr);
  }
}
static kindbound_t copy_kindbound(kindbound_t kb) {
  switch (compress_kb(kb)) {
  case &Eq_kb(k): return new Eq_kb(k);
  case &Unknown_kb(_): return new Unknown_kb(NULL);
  case &Less_kb(_,k): return new Less_kb(NULL,k);
  }
}
static tvar_t copy_tvar(tvar_t tv) {
  // NB: loses sharing of identity here
  return new Tvar(tv->name,NULL,copy_kindbound(tv->kind));
}
static $(opt_t<var_t>,tqual_t,type_t)@ 
  copy_arg($(opt_t<var_t,`H>,tqual_t,type_t) @arg) {
  let &$(x,y,t) = arg;
  return new $(x,y,copy_type(t));
}
static $(tqual_t,type_t)@ copy_tqt($(tqual_t,type_t) @arg) {
  let &$(x,t) = arg;
  return new $(x,copy_type(t));
}
static aggrfield_t copy_field(aggrfield_t f) {
  return new Aggrfield{f->name,f->tq,copy_type(f->type),f->width,f->attributes};
}
static $(type_t,type_t)@ copy_rgncmp($(type_t,type_t)@ x) {
  let &$(r1,r2) = x;
  return new $(copy_type(r1),copy_type(r2));
}
static enumfield_t copy_enumfield(enumfield_t f) {
  return new Enumfield{f->name,f->tag,f->loc};
}
type_t copy_type(type_t t) {
  switch (compress(t)) {
  case VoidType:
  case &Evar(_,_,_,_): return t;
  case &VarType(tv): return new VarType(copy_tvar(tv));
  case &TunionType(TunionInfo{tui,targs,rgn}):
    return new TunionType(TunionInfo{tui,copy_types(targs),
                                       copy_type(rgn)});
  case &TunionFieldType(TunionFieldInfo{fi,targs}):
    return new TunionFieldType(TunionFieldInfo{fi,copy_types(targs)});
  case &PointerType(PtrInfo{elt,rgn,nbl,tq,bs,zt}):
    let elt2 = copy_type(elt);
    let rgn2 = copy_type(rgn);
    let nbl2 = copy_conref(nbl);
    let tq2 = tq;
    let bs2 = copy_conref(bs);
    let zt2 = copy_conref(zt);
    return new PointerType(PtrInfo{elt2,rgn2,nbl2,tq2,bs2,zt2});
  case &IntType(sn,sz): return new IntType(sn,sz); // copy necessary???
  case FloatType: return t;
  case &DoubleType(b): return new DoubleType(b); // copy necessarry???
  case &ArrayType(ArrayInfo{et,tq,eopt,zt}): 
    // FIX: should really copy eopt???
    return new ArrayType(ArrayInfo{copy_type(et),tq,eopt,copy_conref(zt)});
  case &FnType(FnInfo{tvs,effopt,rt,args,c_varargs,cyc_varargs,rgn_po,atts}):
    let tvs2 = List::map(copy_tvar,tvs);
    let effopt2 = (effopt == NULL) ? NULL : new Opt(copy_type(effopt->v));
    let rt2 = copy_type(rt);
    let args2 = List::map(copy_arg,args);
    let c_varargs2 = c_varargs;
    vararg_info_t * cyc_varargs2 = NULL;
    if (cyc_varargs != NULL) {
      vararg_info_t @cv = (vararg_info_t @)cyc_varargs;
      cyc_varargs2 = new VarargInfo{cv->name,cv->tq,copy_type(cv->type),
                                    cv->inject};
    }
    let rgn_po2 = List::map(copy_rgncmp,rgn_po);
    let atts2 = atts;
    return new FnType(FnInfo{tvs2,effopt2,rt2,args2,c_varargs2,
                               cyc_varargs2,rgn_po2,atts2});
  case &TupleType(tqts): return new TupleType(List::map(copy_tqt,tqts));
  case &AggrType(AggrInfo(&UnknownAggr(k,n),ts)):
    return new AggrType(AggrInfo(new UnknownAggr(k,n),copy_types(ts)));
  case &AggrType(AggrInfo(&KnownAggr(adp),ts)):
    return new AggrType(AggrInfo(new KnownAggr(adp),copy_types(ts)));
  case &AnonAggrType(k,fs): return new AnonAggrType(k,List::map(copy_field,fs));
  case &EnumType(tdn,fs): return new EnumType(tdn,fs);
  case &AnonEnumType(fs): return new AnonEnumType(List::map(copy_enumfield,fs));
  case &SizeofType(t): return new SizeofType(copy_type(t));
  case &TypeInt(n): return new TypeInt(n);
  case &TagType(t): return new TagType(copy_type(t));
  case &RgnHandleType(t): return new RgnHandleType(copy_type(t));
  case &TypedefType(tdn,ts,td,_): 
    return new TypedefType(tdn,copy_types(ts),td,NULL);
  case HeapRgn: return t;
  case &AccessEff(t): return new AccessEff(copy_type(t));
  case &JoinEff(ts): return new JoinEff(copy_types(ts));
  case &RgnsEff(t): return new RgnsEff(copy_type(t));
  }
}

// Our lattice looks like this:
//          AbsType   EffKind  RgnKind
//             V
//          MemType
//             V
//          BoxType
// Only used during unification -- we can constrain an Evar or VarType
// as long as we move down in the lattice.
bool kind_leq(kind_t k1, kind_t k2) {
  if (k1 == k2) return true;
  switch ($(k1,k2)) {
  case $(BoxKind, MemKind): 
  case $(BoxKind, AnyKind): 
  case $(MemKind, AnyKind): return true;
  default: return false;
  }
}

kind_t tvar_kind(tvar_t tv) {
  switch (compress_kb(tv->kind)) {
  case &Eq_kb(k): return k;
  case &Less_kb(_,k): return k;
  default: impos("kind not suitably constrained!");
  }
}

// Return the "least" kind of a type, according to the lattice above
// In some situations, we have to be conservative...
// Note that both Evars and VarTypes should have their kinds established
// by this point.
kind_t typ_kind(type_t t) {
  switch (compress(t)) {
  case &Evar(k,topt,_,_): return k->v; 
  case &VarType(tv):      return tvar_kind(tv);
  case VoidType:          return MemKind;
  case &IntType(_,sz):    return (sz==(size_of_t)B4) ? BoxKind : MemKind;
  case FloatType:         
  case &DoubleType(_):        
  case &FnType(_):        return MemKind;
  case &RgnHandleType(_): return BoxKind; 
  case HeapRgn:           return RgnKind;
  case &TunionType(_):    return BoxKind;
  case &TunionFieldType(TunionFieldInfo(&KnownTunionfield(_,tuf),_)):
    if(tuf->typs == NULL) return BoxKind;
    else return MemKind;
  case &TunionFieldType(TunionFieldInfo(&UnknownTunionfield(_),_)):
    impos("typ_kind: Unresolved TunionFieldType");
    // for structs, unions, or enums without definitions, we must be 
    // conservative and treat them as having AnyKind
  case &EnumType(_,NULL):     
  case &AggrType(AggrInfo(&UnknownAggr(_,_),_)): return AnyKind;
  case &AggrType(AggrInfo(&KnownAggr(& &Aggrdecl(_,_,_,_,i,_)),_)):    
    return (i==NULL ? AnyKind : MemKind);
  case &AnonAggrType(_,_):    
  case &AnonEnumType(_):   return MemKind;
  case &EnumType(_,ed): 
    if (ed->fields == NULL) return AnyKind; else return MemKind;
  case &PointerType(pinfo):
    switch (compress_conref(pinfo.bounds)->v) {
    case &Eq_constr(Unknown_b): return MemKind;
    case &Eq_constr(&Upper_b(_)): return BoxKind;
    case No_constr: return MemKind; 
      // be conservative -- this may later be constrained with an Unknown_b
    case &Forward_constr(_):
      impos("typ_kind: forward constraint in ptr bounds");
    }
  case &SizeofType(_): return BoxKind;
  case &TypeInt(_): return IntKind;
  case &TagType(_): return BoxKind;
  // Arrays are always of memkind
  case &ArrayType(_): 
  case &TupleType(_): return MemKind;
  case &TypedefType(_,_,td,_):
    if (td == NULL || td->kind == NULL)
      impos("typ_kind: typedef found: %s", typ2string(t));
    return td->kind->v;
  case &AccessEff(_):     
  case &JoinEff(_):       
  case &RgnsEff(_): return EffKind;
  }
}

// unify types t1 and t2, returning true iff the unification succeeds 
bool unify(type_t t1, type_t t2) {
  try {
    unify_it(t1,t2);
    return true;
  } catch { case Unify: return false; }
}

// see if evar occurs within t and also check that every free type
// variable in t occurs within the list env.
static void occurslist(type_t evar, region_t<`r> r, list_t<tvar_t,`r> env, list_t<type_t> ts); // mutually recursive fns
static void occurs(type_t evar,region_t<`r> r,list_t<tvar_t,`r> env,type_t t) {
  switch (compress(t)) {
  case &VarType(tv): 
    if (!List::mem(fast_tvar_cmp,env,tv)) { 
      failure_reason = "(type variable would escape scope)"; 
      throw Unify; 
    }
    break;
  case &Evar(_,rg,_,*sopt):
    if (t == evar) {
      failure_reason = "(occurs check)";
      throw Unify;
    }
    else if (rg != NULL) occurs(evar,r,env,rg->v);
    else {
      // check to see if sopt is a subset of env
      bool problem = false;
      for (_ s = (*sopt)->v; s != NULL; s = s->tl) {
        if (!List::mem(fast_tvar_cmp,env,s->hd)) {
          problem = true; break;
        }
      }
      // for sopt to be a subset of env
      if (problem) {
        let result = NULL;
        for (_ s = (*sopt)->v; s != NULL; s = s->tl) {
          if (List::mem(fast_tvar_cmp,env,s->hd)) 
            result = new List(s->hd,result);
        }
        *sopt = new Opt(result);
      }
    }
    break;
  case &PointerType(pinfo): 
    occurs(evar,r,env,pinfo.elt_typ); occurs(evar,r,env,pinfo.rgn_typ); break;
  case &ArrayType(ArrayInfo{t2,_,_,_}): occurs(evar,r,env,t2); break;
  case &FnType(FnInfo{tvs,eff,rt,args,c_varargs,cyc_varargs,rgn_po,atts}): 
    env = List::rappend(r,tvs,env);
    if (eff != NULL) occurs(evar,r,env,eff->v);
    occurs(evar,r,env,rt);
    for(; args != NULL; args = args->tl)
      occurs(evar,r,env,(*args->hd)[2]);
    if (cyc_varargs != NULL)
      occurs(evar,r,env,cyc_varargs->type);
    for (; rgn_po != NULL; rgn_po = rgn_po->tl) {
      let &$(r1,r2) = rgn_po->hd;
      occurs(evar,r,env,r1);
      occurs(evar,r,env,r2);
    }
    break;
  case &TupleType(args):
    for(; args != NULL; args = args->tl)
      occurs(evar,r,env,(*args->hd)[1]);
    break;
  case &TunionType(TunionInfo{_,ts,rg}):
    occurs(evar,r,env,rg); occurslist(evar,r,env,ts); break;
  case &TypedefType(_,ts,_,topt): fallthru(ts);
  case &TunionFieldType(TunionFieldInfo{_,ts}): fallthru(ts);
  case &AggrType(AggrInfo(_,ts)): occurslist(evar,r,env,ts); break;
  case &AnonAggrType(_,fs):
    for (; fs != NULL; fs = fs->tl)
      occurs(evar, r, env, fs->hd->type);
    break;
  case &RgnHandleType(rt): fallthru(rt);
  case &SizeofType(t0): fallthru(t0);
  case &AccessEff(t0): fallthru(t0);
  case &RgnsEff(t0): occurs(evar,r,env,t0); break;
  case &JoinEff(ts): occurslist(evar,r,env,ts); break;
  default: break;
  }
}
static void occurslist(type_t evar, region_t<`r> r, list_t<tvar_t,`r> env,
                       list_t<type_t> ts) {
  for (; ts != NULL; ts = ts->tl)
    occurs(evar,r,env,ts->hd);
}

// unify two lists of types
static void unify_list(list_t<type_t> t1, list_t<type_t> t2) {
  for (; t1 != NULL && t2 != NULL; t1 = t1->tl, t2 = t2->tl)
    unify_it(t1->hd,t2->hd);
  if (t1 != NULL || t2 != NULL)
    throw Unify;
}

// unify two type qualifiers -- throws Unify unless they are the same
static void unify_tqual(tqual_t tq1, tqual_t tq2) {
  if ((tq1.q_const != tq2.q_const)    
      || (tq1.q_volatile != tq2.q_volatile) 
      || (tq1.q_restrict != tq2.q_restrict)) {
    failure_reason = "(qualifiers don't match)";
    throw Unify;
  }
}

bool equal_tqual(tqual_t tq1, tqual_t tq2) {
  return ((tq1.q_const == tq2.q_const) 
	  && (tq1.q_volatile == tq2.q_volatile) 
	  && (tq1.q_restrict == tq2.q_restrict));
}

// unify two constraint refs
static void unify_it_conrefs(int cmp(`a,`a), conref_t<`a> x, conref_t<`a> y,
                             string_t<`H> reason) {
  x = compress_conref(x);
  y = compress_conref(y);
  if (x == y) return;
  switch (x->v) {
  case No_constr: x->v = new Forward_constr(y); return;
  case &Forward_constr(_): impos("unify_conref: forward after compress");
  case &Eq_constr(xv):
    switch (y->v) {
    case No_constr: y->v = x->v; return;
    case &Forward_constr(_): impos("unify_conref: forward after compress(2)");
    case &Eq_constr(yv):
      if (cmp(xv,yv) != 0) {
        failure_reason = reason;
        throw Unify;
      }
      return;
    }
  }
}

static bool unify_conrefs(int cmp(`a,`a), conref_t<`a> x, conref_t<`a> y) {
  try {
    unify_it_conrefs(cmp,x,y,NULL);
    return true;
  } catch { case Unify: return false; }
}

static int boundscmp(bounds_t b1, bounds_t b2) {
  switch ($(b1,b2)) {
  case $(Unknown_b,Unknown_b): return 0;
  case $(Unknown_b,_): return -1;
  case $(_,Unknown_b): return 1;
  case $(&Upper_b(e1),&Upper_b(e2)): return Evexp::const_exp_cmp(e1,e2);
  }
}

static int attribute_case_number(attribute_t att) {
  switch(att) {
  case &Regparm_att(_): return 0; 
  case Stdcall_att: return 1;      
  case Cdecl_att: return 2;        
  case Fastcall_att: return 3;
  case Noreturn_att: return 4;     
  case Const_att: return 5;
  case &Aligned_att(_): return 6;
  case Packed_att: return 7;
  case &Section_att(_): return 8;
  case Nocommon_att: return 9;
  case Shared_att: return 10;
  case Unused_att: return 11;
  case Weak_att: return 12;
  case Dllimport_att: return 13;
  case Dllexport_att: return 14;
  case No_instrument_function_att: return 15;
  case Constructor_att: return 16;
  case Destructor_att: return 17;
  case No_check_memory_usage_att: return 18;
  case &Format_att(_,_,_): return 19;
  case &Initializes_att(_): return 20;
  case Pure: return 21;
  }
}

static int attribute_cmp(attribute_t att1, attribute_t att2) {
  switch($(att1,att2)) {
  case $(&Regparm_att(i1),&Regparm_att(i2)): fallthru(i1,i2);
  case $(&Initializes_att(i1), &Initializes_att(i2)): fallthru(i1,i2);
  case $(&Aligned_att(i1),&Aligned_att(i2)): return intcmp(i1,i2);
  case $(&Section_att(s1),&Section_att(s2)): return strcmp(s1,s2);
  case $(&Format_att(ft1,i1,j1),&Format_att(ft2,i2,j2)):
    let ftc = intcmp((unsigned int)ft1, (unsigned int)ft2);
    if(ftc != 0) return ftc;
    let ic = intcmp(i1,i2);
    if(ic != 0) return ic;
    return intcmp(j1,j2);
  default:
    return intcmp(attribute_case_number(att1), attribute_case_number(att2));
  }
}

static bool equal_att(attribute_t a1, attribute_t a2) {
  return attribute_cmp(a1,a2)==0;
}

bool same_atts(attributes_t a1, attributes_t a2) {
  for (_ a = a1; a != NULL; a = a->tl) 
    if (!List::exists_c(equal_att,a->hd,a2)) return false;
  for (_ a = a2; a != NULL; a = a->tl)
    if (!List::exists_c(equal_att,a->hd,a1)) return false;
  return true;
}

// forward declarations
static type_t rgns_of(type_t t);

static type_t rgns_of_field(aggrfield_t af) {
  return rgns_of(af->type);
}

static $(tvar_t,type_t)@ region_free_subst(tvar_t tv) {
  type_t t; // FIX: IntKind
  switch (tvar_kind(tv)) {
  case RgnKind: t = HeapRgn;      break;
  case EffKind: t = empty_effect; break;
  default:      t = sint_typ;     break; // lives in every kind
  }
  return new $(tv,t);
}

// Calculate the regions of a type and return as an effect -- used
// in normalizing effects.
// NOTE: does a lot of unncecessary allocation (e.g. regions_t<`a> reallocates
//       every time!)
static type_t rgns_of(type_t t) {
  switch (compress(t)) {
  case VoidType: 
  case FloatType: 
  case &DoubleType(_): 
  case &EnumType(_,_):
  case &AnonEnumType(_):
  case &TypeInt(_):
  case &IntType(_,_): return empty_effect;
  case &Evar(_,_,_,_):
  case &VarType(_): 
    switch (typ_kind(t)) {
    case RgnKind: return new AccessEff(t);
    case EffKind: return t;
    case IntKind: return empty_effect;
    default: return new RgnsEff(t);
    }
  case &RgnHandleType(t): return new AccessEff(t);
  case &TunionType(TunionInfo{_,targs,r}):
    list_t<type_t> ts = new List(new AccessEff(r), map(rgns_of,targs));
    return normalize_effect(new JoinEff(ts));
  case &PointerType(PtrInfo{et,r,_,_,_,_}):
    return normalize_effect(new JoinEff(list(new AccessEff(r),rgns_of(et))));
  case &ArrayType(ArrayInfo{et,_,_,_}):
    return normalize_effect(rgns_of(et));
  case &TupleType(tqts):
    let ts = NULL;
    for (; tqts != NULL; tqts = tqts->tl)
      ts = new List((*tqts->hd)[1],ts);
    fallthru(ts);
  case &TunionFieldType(TunionFieldInfo{_,ts}): fallthru(ts);
  case &AggrType(AggrInfo(_,ts)): 
    return normalize_effect(new JoinEff(map(rgns_of,ts)));
  case &AnonAggrType(_,fs): 
    return normalize_effect(new JoinEff(map(rgns_of_field,fs)));
  case &SizeofType(t): return rgns_of(t);
  case &TagType(_): return rgns_of(t);
  case &FnType(FnInfo{tvs,eff,rt,args,_,cyc_varargs,rpo,_}):
    // NOTE:  we define RgnsEff(t) in this case to be the regions in the
    // effect.  So, if the effect is smaller than the argument or return
    // types, they won't show up.  This saves us from a lot of complication
    // with varargs, etc. and should result in a smaller effect.  But it
    // might bite us someday...
    // HACK:  we substitute region-free types for the bound type variables
    // and then compute the regions of that.
    let e = substitute(map(region_free_subst,tvs),eff->v);
    return normalize_effect(e);
  case HeapRgn: return empty_effect;
  case &AccessEff(_):
  case &JoinEff(_): return t;
  case &RgnsEff(t2): return rgns_of(t2);
  case &TypedefType(_,ts,_,_): 
    return normalize_effect(new JoinEff(map(rgns_of,ts)));
  }
}

// flattens out nested join effects when possible
// -- this has a side effect on the actual type when possible to
// memoize the computation.
type_t normalize_effect(type_t e) {
  e = compress(e);
  switch (e) {
  case &JoinEff(*es):
    bool redo_join = false; // Dan: changed from true
    for (_ effs = *es; effs != NULL; effs = effs->tl) {
      let eff = effs->hd;
      effs->hd = compress(normalize_effect(eff));
      switch (effs->hd) {
      case &JoinEff(_): 
      case &AccessEff(HeapRgn): redo_join = true; break;
      default: break;
      }
    }
    if (!redo_join) return e;
    list_t<type_t> effects = NULL;
    for (_ effs = *es; effs != NULL; effs = effs->tl) {
      switch (compress(effs->hd)) {
      case &JoinEff(nested_effs): 
        effects = List::revappend(nested_effs,effects);
        break;
      case &AccessEff(HeapRgn): break;
      case e: effects = new List(e,effects); break;
      }
    }
    *es = List::imp_rev(effects);
    return e;
  case &RgnsEff(t): // special cases to avoid allocation
    switch(compress(t)) {
    case &Evar(_,_,_,_):
    case &VarType(_): return e;
    default: return rgns_of(t);
    }
  default: return e;
  }
}

static struct Opt<kind_t> ek = {EffKind};

// Create a dummy type that includes the effect:  void (@`H)(;eff)
static type_t dummy_fntype(type_t eff) {
  let fntype = new FnType(FnInfo{.tvars=NULL,.effect=new Opt(eff),
                               .ret_typ=VoidType,.args=NULL,.c_varargs=false,
                               .cyc_varargs=NULL,.rgn_po=NULL,
                               .attributes = NULL});
  return atb_typ(fntype, HeapRgn, empty_tqual(), bounds_one, false_conref);
}

// Returns true if the region r is in the effect e or else r is the
// heap region.  If constrain is true, this might cause region or
// effect evars to become constrained.
bool region_in_effect(bool constrain, type_t r, type_t e) {
  r = compress(r);
  if (r == HeapRgn) return true;
  switch (compress(e)) {
  case &AccessEff(r2): 
    // note:  might constrain a region variable unnecessarily
    if (constrain) return unify(r,r2);
    r2 = compress(r2);
    if (r == r2) return true;
    switch ($(r, r2)) {
    case $(&VarType(tv1), &VarType(tv2)): return (tvar_cmp(tv1,tv2) == 0);
    default: return false;
    }
  case &JoinEff(es): 
    for (; es != NULL; es = es->tl) 
      if (region_in_effect(constrain, r, es->hd)) return true;
    return false;
  case &RgnsEff(t):
    switch (rgns_of(t)) {
    case &RgnsEff(t):
      if (!constrain) return false;
      switch (compress(t)) {
      case &Evar(k,*p,_,s):
        // we found regions(ev) -- constrain ev to a dummy function type
        // t such that regions(t) = ev2+{`r} where ev2 is a fresh effect evar
        let ev = new_evar(&ek,s);
        // this has the effect of checking that any free variables in r
        // are contained in s.
        occurs(ev,heap_region,s->v,r);
        let new_typ = dummy_fntype(new JoinEff(list(ev,new AccessEff(r))));
        *p = new Opt(new_typ);
        return true;
      default: return false;
      }
    case e2: return region_in_effect(constrain,r,e2);
    }
  case &Evar(k,*p,_,s): 
    if (k == NULL || k->v != EffKind) impos("effect evar has wrong kind");
    if (!constrain) return false;
    // we found a non-canonical evar -- we can grow it to include r
    // but this may cause problems later on with other constraints.
    let ev = new_evar(&ek,s);
    // this has the effect of checking that any free variables in r
    // are contained in s.
    occurs(ev,heap_region,s->v,r);
    let new_typ = new JoinEff(new List{ev,new List{new AccessEff(r),NULL}});
    *p = new Opt(new_typ);
    return true;
  default: return false;
  }
}

// Returns true if the type t is in the effect e t as RgnsEff(t).
// If constrain is true, this might cause evars to become constrained.
// Note that t must either be an evar or a tvar.
static bool type_in_effect(bool may_constrain_evars, type_t t, type_t e) {
  t = compress(t);
  switch (normalize_effect(compress(e))) {
  case &AccessEff(_): return false;
  case &JoinEff(es): 
    for (; es != NULL; es = es->tl) 
      if (type_in_effect(may_constrain_evars, t, es->hd)) 
	return true;
    return false;
  case &RgnsEff(t2):
    t2 = compress(t2);
    if (t == t2) return true;
    if (may_constrain_evars) return unify(t,t2);
    switch (rgns_of(t)) {
    case &RgnsEff(t3):
      switch ($(compress(t3),t2)) {
      case $(&VarType(tv1),&VarType(tv2)): return unify(t,t2); // ???
      default: return t3 == t2;
      }
    case e2: return type_in_effect(may_constrain_evars,t,e2);
    }
  case &Evar(k,*p,_,s): 
    if (k == NULL || k->v != EffKind) impos("effect evar has wrong kind");
    if (!may_constrain_evars) return false;
    // we found a non-canonical evar -- we can grow it to include t
    // but this may cause problems later on with other constraints.
    let ev = new_evar(&ek,s);
    // this has the effect of checking that any free variables in t
    // are contained in s.
    occurs(ev,heap_region,s->v,t);
    let new_typ = new JoinEff(new List{ev,new List{new RgnsEff(t),NULL}});
    *p = new Opt(new_typ);
    return true;
  default: return false;
  }
}


// Returns true if the effect type variable v is in the effect e.
// If constrain is true, this might cause effect evars to become constrained.
static bool variable_in_effect(bool may_constrain_evars, tvar_t v, type_t e) {
  e = compress(e);
  switch (e) {
  case &VarType(v2): return (tvar_cmp(v, v2) == 0);
  case &JoinEff(es):
    for (; es != NULL; es = es->tl) 
      if (variable_in_effect(may_constrain_evars, v, es->hd)) 
	return true;
    return false;
  case &RgnsEff(t):
    switch (rgns_of(t)) {
    case &RgnsEff(t2): 
      if (!may_constrain_evars) return false;
      switch (compress(t2)) {
      case &Evar(k,*p,_,s):
        // we found regions(ev) where ev is an evar -- set ev to
        // be a dummy type t such that regions(t) = ev2+`e where ev2
        // is a fresh evar.
        let ev = new_evar(&ek,s);
        // make sure v is in the allowed set of type variables in the evar
        if (!List::mem(fast_tvar_cmp,s->v,v)) return false;
        let new_typ = dummy_fntype(new JoinEff(list(ev,new VarType(v))));
        *p = new Opt(new_typ);
        return true;
      default: return false;
      }
    case e2: return variable_in_effect(may_constrain_evars,v,e2);
    }
  case &Evar(k,*p,_,s):
    if (k == NULL || k->v != EffKind) impos("effect evar has wrong kind");
    // we found a non-canonical evar -- we can grow it to include v
    // but this may cause problems later on with other constraints.
    let ev = new_evar(&ek,s);
    // make sure v is in the allowed set of type variables for the evar
    if (!List::mem(fast_tvar_cmp,s->v,v))
      return false;
    let new_typ = new JoinEff(new List{ev,new List{new VarType(v),NULL}});
    *p = new Opt(new_typ);
    return true;
  default: return false;
  }
}

// Returns true if the effect evar ev is in the effect e.
static bool evar_in_effect(type_t evar, type_t e) {
  e = compress(e);
  switch (e) {
  case &JoinEff(es):
    for (; es != NULL; es = es->tl) 
      if (evar_in_effect(evar, es->hd)) 
	return true;
    return false;
  case &RgnsEff(t):
    switch (rgns_of(t)) {
    case &RgnsEff(t2): return false;
    case e2: return evar_in_effect(evar, e2);
    }
  case &Evar(_,_,_,_): return (evar == e);
  default: return false;
  }
}

// Returns true when e1 is a sub-effect of e2 -- this isn't very
// efficient and can constrain both effect and region evars in
// unpredictable ways (though it tries hard not to).  
// When set_to_empty is true, evars in e1 that do not occur in (or
// cannot easily be made to occur in) e2 are constrained to the 
// empty effect (or HeapRgn for region evars).  This is the "right" 
// thing for when a function call needs to constrain the effect to 
// an upper bound.  When set_to_empty is false, we instantiate 
// unconstrained evars in e1 to be e2.
bool subset_effect(bool may_constrain_evars, type_t e1, type_t e2) {
  // if e2 is of the form JoinEff(ev::rest) where ev is an effect evar,
  // then we can instantiate ev to JoinEff(ev'::e1) where ev' is fresh
  switch (compress(e1)) {
  case &JoinEff(es): 
    for (; es != NULL; es = es->tl)
      if (!subset_effect(may_constrain_evars,es->hd,e2))
	return false;
    return true;
  case &AccessEff(r): 
    // Try checking if the region is in the effect without performing
    // any unification first and only if this fails do we actually
    // go in and try to unify something.  It's not clear whether it's
    // best to just pin the region to HeapRgn or try to unify it with
    // some region already in the effect e2.  We used to try the latter, then
    // the former.  Now we just pick the former.
    return (region_in_effect(false,r,e2) 
	    || (may_constrain_evars && unify(r,HeapRgn)));
  case &VarType(v): return variable_in_effect(may_constrain_evars,v,e2);
  case &RgnsEff(t):
    switch (rgns_of(t)) {
    case &RgnsEff(t2): 
      // similar to AccessEff(r) but we're grepping around for RgnsEff(t2)
      // within e2 -- if we don't find it, try unifying something, and 
      // failing that, just try to pin it down to something without regions.
      return (type_in_effect(may_constrain_evars,t2,e2) || 
	      (may_constrain_evars && unify(t2,sint_typ)));
    case e: return subset_effect(may_constrain_evars,e,e2);
    }
  case &Evar(_,*p,_,s): 
    if (!evar_in_effect(e1,e2)) 
      // We can set the evar to be any subset of e2. 
      // We set it to e2 basically.
      //      if (may_constrain_evars) {
	*p = new Opt(empty_effect);
	//	occurs(e1,heap_region,s->v,e2);
	//        *p = new Opt(e2);
    //      }
    return true;
  default: impos("subset_effect: bad effect: %s",typ2string(e1));
  }
}

// "unify" two effects
//    * We simply check that one
//      effect is a "subset" of the other.  If necessary, we instantiate
//      region or effect evars to force the subset relation.  This may 
//      cause region or effect evars to become pinned down in an undesirable 
//       way...  But the situation should be rare, and if it happens, users
//       should fall back on explicit typing.
//
// What we should really do:  generate some set equalities and hold
// on to them.  Then try to simplify and solve them later on after
// things have become more constrained.  
static bool unify_effect(type_t e1, type_t e2) {
  e1 = normalize_effect(e1);
  e2 = normalize_effect(e2);
  if(subset_effect(false, e1, e2) && subset_effect(false, e2, e1))
    return true;
  if(subset_effect(true, e1, e2) && subset_effect(true, e2, e1))
    return true;
  return false;
}

// returns true when rpo1 is a sub-partial order of rpo2.  By this
// we mean that every inequation in rpo1 is also in rpo2, or else
// the inequation in rpo is of the form `H <= t.  Note that
// this might constrain region variables.  Note also that we don't
// do any sort of transitive closure to figure out causalities.
// FIX:  this isn't complete or efficient by far...
static bool sub_rgnpo(list_t<$(type_t,type_t)@> rpo1, 
                      list_t<$(type_t,type_t)@> rpo2) {
  for (_ r1 = rpo1; r1 != NULL; r1 = r1->tl) {
    let &$(t1a,t1b) = r1->hd;
    bool found = (t1a == HeapRgn);
    for (_ r2 = rpo2; r2 != NULL && !found; r2 = r2->tl) {
      let &$(t2a,t2b) = r2->hd;
      if (unify(t1a,t2a) && unify(t1b,t2b)) {
        found = true;
        break;
      }
    }
    if (!found) return false;
  }
  return true;
}

// see if two region partial-orders are the same
static bool same_rgn_po(list_t<$(type_t,type_t)@> rpo1, 
                        list_t<$(type_t,type_t)@> rpo2) {
  return (sub_rgnpo(rpo1,rpo2) && sub_rgnpo(rpo2,rpo1));
}

// the real work of unification
void unify_it(type_t t1, type_t t2) {
  t1_failure = t1;
  t2_failure = t2;
  failure_reason = NULL;
  t1 = compress(t1);
  t2 = compress(t2);
  if (t1 == t2) return;
  switch (t1) {
  case &Evar(kind1,*ref1_ref,_,s1opt):
    // check that the evar doesn't occur in t2 and that any free variables
    // of t2 are contained in s1.
    occurs(t1,heap_region,s1opt->v,t2);
    let kind2 = typ_kind(t2);
    // we can constrain the Evar to be equal to t2 only when the kind of 
    // the evar is greater than or equal to the kind of t2 or t2 is an 
    // evar that we can constrain to be equal to t1.
    if (kind_leq(kind2,kind1->v)) {
      *ref1_ref = new Opt(t2);
      return;
    } else {
      switch (t2) {
      case &Evar(_,*ref2_ref,_,s2opt): 
        // check that s2 is a subset of s1
        let s1 = s1opt->v;
        for (_ s2 = s2opt->v; s2 != NULL; s2 = s2->tl) {
          if (!List::mem(fast_tvar_cmp,s1,s2->hd)) {
            failure_reason = "(type variable would escape scope)";
            throw Unify;
          }
        }
        if (kind_leq(kind1->v,kind2)) {
          *ref2_ref = new Opt(t1); return;
        }
        failure_reason = "(kinds are incompatible)";
        break;
        // this is a special hack to deal with the fact that a boxed evar
        // can't unify with a pointer type where we don't know whether or
        // not it's a ? pointer vs. a * or @ pointer.  
      case &PointerType(pinfo) && kind1->v == BoxKind:
        let c = compress_conref(pinfo.bounds);
        switch (c->v) {
        case No_constr:
          // set the pointer to be a * or @ to an array of size 1
          c->v = new Eq_constr((bounds_t)(new Upper_b(signed_int_exp(1,NULL))));
          *ref1_ref = new Opt(t2);
          return;
        default: break;
        }
        break;
      default: break;
      }
      failure_reason = "(kinds are incompatible)";
      throw Unify;
    }
  default: break; 
  }
  // t1 is not an evar

    // in what follows, we throw Unify unless we explicitly return.
  switch ($(t2,t1)) {

  case $(&Evar(_,_,_,_),_): // t2 is an evar, t1 is not, swap and try again
    unify_it(t2,t1);
    return;

  case $(VoidType,VoidType): return;

  case $(&VarType(tv2),&VarType(tv1)):
    let x2 = tv2->name;
    let x1 = tv1->name;
    // identities should be resolved
    let id2 = *tv2->identity;
    let id1 = *tv1->identity; 
    let k2 = tvar_kind(tv2);
    let k1 = tvar_kind(tv1);
    // kinds should already be resolved.  
    // FIX: shouldn't need the strptrcmp any more...
    if (id1 == id2 && strptrcmp(x2,x1) == 0) {
      // sanity check
      if (k2 != k1)
        impos("same type variable %s has kinds %s and %s",
              *x2,kind2string(k2),kind2string(k1));
      return;
    } 
    failure_reason = "(variable types are not the same)";
    break;

  case $(&AggrType(AggrInfo(info2,ts2)),&AggrType(AggrInfo(info1,ts1))):
    let $(k1,n1) = aggr_kinded_name(info1);
    let $(k2,n2) = aggr_kinded_name(info2);
    if(k1 != k2) { failure_reason = "(struct and union type)"; break; }
    if(qvar_cmp(n1,n2) != 0) { failure_reason = "(different type name)"; break;}
    unify_list(ts1,ts2);
    return;

    // don't use decl pointer -- it might not be set due to an earlier error
  case $(&EnumType(n1,_), &EnumType(n2,_)):
    if (qvar_cmp(n1,n2) == 0) return;
    failure_reason = "(different enum types)";
    break;

  case $(&AnonEnumType(fs1), &AnonEnumType(fs2)):
    bool bad = false;
    for (; fs1 != NULL && fs2 != NULL; fs1=fs1->tl, fs2=fs2->tl) {
      let f1 = fs1->hd;
      let f2 = fs2->hd;
      if (qvar_cmp(f1->name,f2->name) != 0) {
        failure_reason = "(different names for enum fields)";
        bad = true;
        break;
      }
      if (f1->tag == f2->tag) continue;
      if (f1->tag == NULL || f2->tag == NULL) {
        failure_reason = "(different tag values for enum fields)";
        bad = true; 
        break;
      }
      if(!Evexp::same_const_exp((exp_t)f1->tag, (exp_t)f2->tag)) {
        failure_reason = "(different tag values for enum fields)";
        bad = true;
        break;
      }
    }
    if (bad) break;
    if (fs1 == NULL && fs2 == NULL) return;
    failure_reason = "(different number of fields for enums)";
    break;

  case $(&TunionType(TunionInfo(&KnownTunion(&tud2),ts2,r2)),
	 &TunionType(TunionInfo(&KnownTunion(&tud1),ts1,r1))):
    if(tud2 == tud1 || qvar_cmp(tud2->name,tud1->name) == 0) {
      unify_it(r1,r2);
      unify_list(ts1,ts2);
      return;
    }
    failure_reason = "(different tunion types)";
    break;

  case $(&TunionFieldType(TunionFieldInfo(&KnownTunionfield(tud2,tuf2),ts2)),
	 &TunionFieldType(TunionFieldInfo(&KnownTunionfield(tud1,tuf1),ts1))):
    if((tud2 == tud1 || qvar_cmp(tud2->name,tud1->name)==0)
       && (tuf2 == tuf1 || qvar_cmp(tuf2->name, tuf1->name)==0)) {
      unify_list(ts1,ts2);
      return;
    }
    failure_reason = "(different tunion field types)";
    break;

  case $(&PointerType(PtrInfo{.elt_typ=t2a,.rgn_typ=rgn2,
                              .nullable=null2a,.tq=tqual2a,.bounds=b2,
                              .zero_term=zt2}),
	 &PointerType(PtrInfo{.elt_typ=t1a,.rgn_typ=rgn1,
                              .nullable=null1a,.tq=tqual1a,.bounds=b1,
                              .zero_term=zt1})):
    unify_it(t1a,t2a);
    unify_it(rgn2,rgn1); // the whole reason regions are "types"
    t1_failure = t1;
    t2_failure = t2;
    unify_tqual(tqual1a,tqual2a);
    unify_it_conrefs(boundscmp,b1,b2,"(different pointer bounds)");
    unify_it_conrefs(intcmp,zt1,zt2,"(not both zero terminated)");
    // There's no need to force the nullable's to be the same when
    // the bounds are ?.
    switch (compress_conref(b1)->v) {
    case &Eq_constr(Unknown_b): return;
    default: break;
    }
    unify_it_conrefs(intcmp,null1a,null2a,"(different pointer types)");
    return;

  case $(&IntType(sn2,sz2), &IntType(sn1,sz1)):
    if ((sn1 == sn2) && (sz1 == sz2)) return;
    failure_reason = "(different integral types)";
    break;

  case $(FloatType, FloatType):  return;
  case $(&DoubleType(b2), &DoubleType(b1)): 
    if (b2 == b1) return;
   break;

  case $(&SizeofType(t1), &SizeofType(t2)): unify_it(t1,t2); return;

  case $(&TypeInt(n),&TypeInt(m)): if(n==m) return;
    failure_reason = "(different type integers)";
    break;

  case $(&TagType(t1),&TagType(t2)): unify_it(t1,t2); return;

  case $(&ArrayType(ArrayInfo{t2a,tq2a,e1,zt1}), 
         &ArrayType(ArrayInfo{t1a,tq1a,e2,zt2})):
    unify_tqual(tq1a,tq2a);
    unify_it(t1a,t2a);
    unify_it_conrefs(intcmp,zt1,zt2,"(not both zero terminated)");
    if (e1 == e2) return;
    if (e1 == NULL || e2 == NULL) break;
    if (Evexp::same_const_exp((exp_t)e1, (exp_t)e2))
      return;
    failure_reason = "(different array sizes)";
    break;

  case $(&FnType(FnInfo{tvs2,eff2,rt2,args2,c_vararg2,cyc_vararg2,rpo2,atts2}), 
         &FnType(FnInfo{tvs1,eff1,rt1,args1,c_vararg1,cyc_vararg1,rpo1,atts1})):
    bool done = false;
    region rgn {
    list_t<$(tvar_t,type_t)@`rgn,`rgn> inst = NULL;
    while (tvs1 != NULL) {
      if (tvs2 == NULL) { 
        failure_reason = "(second function type has too few type variables)"; 
        throw Unify;
      }
      let k1 = tvar_kind(tvs1->hd);
      let k2 = tvar_kind(tvs2->hd);
      if (k1 != k2) {
        failure_reason = aprintf("(type var %s has different kinds %s and %s)",
                                 tvar2string(tvs1->hd), kind2string(k1),
                                 kind2string(k2));
        throw Unify;
      }
      inst = rnew(rgn) List(rnew(rgn) $(tvs2->hd,new VarType(tvs1->hd)),inst);
      tvs1 = tvs1->tl;
      tvs2 = tvs2->tl;
    }
    if (tvs2 != NULL) {
      failure_reason = "(second function type has too many type variables)";
      break;
    }
    if (inst != NULL) {
      unify_it(new FnType(FnInfo{NULL,eff1,rt1,args1,c_vararg1,cyc_vararg1,
                                   rpo1,atts1}),
	       rsubstitute(rgn, inst,
                           new FnType(FnInfo{NULL,eff2,rt2,args2,c_vararg2,
					       cyc_vararg2,rpo2,atts2})));
      done = true;
    } 
    }
    if(done) 
      return;
    unify_it(rt1,rt2);
    for (; args1!=NULL && args2!=NULL; args1 = args1->tl, args2 = args2->tl) {
      unify_tqual((*args1->hd)[1],(*args2->hd)[1]);
      unify_it((*args1->hd)[2],(*args2->hd)[2]);
    }
    t1_failure = t1; 
    t2_failure = t2;
    if ((args1 != NULL) || (args2 != NULL)) {
      failure_reason = "(function types have different number of arguments)";
      break;
    }
    if (c_vararg1 != c_vararg2) {
      failure_reason = "(only one function type takes C varargs)";
      break;
    }
    // unify any cyclone varargs
    bool bad_cyc_vararg = false;
    switch ($(cyc_vararg1, cyc_vararg2)) {
    case $(NULL,NULL): break;
    case $(NULL,_): 
    case $(_,NULL): 
      bad_cyc_vararg = true; 
      failure_reason = "(only one function type takes varargs)";
      break;
    case $(&VarargInfo{n1,tq1,tp1,i1}, &VarargInfo{n2,tq2,tp2,i2}):
      unify_tqual(tq1,tq2);
      unify_it(tp1,tp2);
      if (i1 != i2) { 
        bad_cyc_vararg = true;
        failure_reason = "(only one function type injects varargs)";
      }
      break;
    }
    if (bad_cyc_vararg) break;
    // It's important to unify the effects and po after the arguments and 
    // result so that the effects are pinned down as much as possible.
    bool bad_effect = false;
    switch($(eff1,eff2)) {
    case $(NULL,NULL): break;
    case $(NULL,_): 
    case $(_,NULL): bad_effect = true; break;
    default: bad_effect = !unify_effect(eff1->v,eff2->v); break;
    }
    t1_failure = t1; 
    t2_failure = t2;
    if(bad_effect) {
      failure_reason = "(function type effects do not unify)";
      break;
    }
    if (!same_atts(atts2,atts1)) {
      failure_reason = "(function types have different attributes)";
      break;
    }
    if (!same_rgn_po(rpo2,rpo1)) {
      failure_reason = "(function types have different region lifetime orderings)";
      break;
    }
    return;

  case $(&TupleType(ts2), &TupleType(ts1)):
    for (; ts1 != NULL && ts2 != NULL; ts1 = ts1->tl, ts2 = ts2->tl) {
      unify_tqual((*ts1->hd)[0],(*ts2->hd)[0]);
      unify_it((*ts1->hd)[1],(*ts2->hd)[1]);
    }
    if (ts1 == NULL && ts2 == NULL) return;
    t1_failure = t1; 
    t2_failure = t2;
    failure_reason = "(tuple types have different numbers of components)";
    break;

  case $(&AnonAggrType(k2,fs2), &AnonAggrType(k1,fs1)): 
    if(k1 != k2) { failure_reason = "(struct and union type)"; break; }
    for (; fs1 != NULL && fs2 != NULL; fs1 = fs1->tl, fs2 = fs2->tl) {
      let f1 = fs1->hd;
      let f2 = fs2->hd;
      if (strptrcmp(f1->name,f2->name) != 0) {
        failure_reason = "(different member names)";
        throw Unify;
      }
      unify_tqual(f1->tq, f2->tq);
      unify_it(f1->type, f2->type);
      if (!same_atts(f1->attributes,f2->attributes)) {
        t1_failure = t1; 
        t2_failure = t2;
        failure_reason = "(different attributes on member)";
        throw Unify;
      }
      if ((f1->width != NULL && f2->width == NULL) ||
          (f2->width != NULL && f1->width == NULL) ||
          (f1->width != NULL && f2->width != NULL &&
	   !Evexp::same_const_exp((exp_t)f1->width, (exp_t)f2->width))) {
        t1_failure = t1; 
        t2_failure = t2;
        failure_reason = "(different bitfield widths on member)";
        throw Unify;
      }
    }
    if (fs1 == NULL && fs2 == NULL) return;
    t1_failure = t1; 
    t2_failure = t2;
    failure_reason = "(different number of members)";
    break;
  case $(HeapRgn, HeapRgn): return;
  case $(&RgnHandleType(rt1),&RgnHandleType(rt2)):
    unify_it(rt1,rt2);
    return;
  case $(&JoinEff(_), _): 
  case $(_, &JoinEff(_)): 
  case $(&AccessEff(_), _): 
  case $(&RgnsEff(_), _): 
  case $(_, &RgnsEff(_)): 
  case $(_, &AccessEff(_)): 
    if (unify_effect(t1,t2)) return;
    failure_reason = "(effects don't unify)";
    break;
  default: break;
  }
  throw Unify;
}

int star_cmp<`a::A,`r::R>(int cmp(`a@`r,`a@`r),`a*`r a1, `a*`r a2) {
  if(a1 == a2) return 0;
  if(a1 == NULL && a2 != NULL) return -1;
  if(a1 != NULL && a2 == NULL) return 1;
  return cmp((_@)a1,(_@)a2);
}

static int tqual_cmp(tqual_t tq1, tqual_t tq2) {
  let i1 = tq1.q_const + (tq1.q_volatile << 1) + (tq1.q_restrict << 2);
  let i2 = tq2.q_const + (tq2.q_volatile << 1) + (tq2.q_restrict << 2);
  return intcmp(i1,i2);
}

// unify two constraint refs
static int conrefs_cmp(int cmp(`a,`a), conref_t<`a> x, conref_t<`a> y) {
  x = compress_conref(x);
  y = compress_conref(y);
  if (x == y) return 0;
  switch (x->v) {
  case No_constr: return -1;
  case &Eq_constr(xv):
    switch (y->v) {
    case No_constr: return 1;
    case &Eq_constr(yv): return cmp(xv,yv);
    case &Forward_constr(_): impos("unify_conref: forward after compress(2)");
    }
  case &Forward_constr(_): impos("unify_conref: forward after compress");
  }
}

static int tqual_type_cmp($(tqual_t,type_t)@ tqt1, $(tqual_t,type_t)@tqt2) {
  let &$(tq1,t1) = tqt1;
  let &$(tq2,t2) = tqt2;
  let tqc = tqual_cmp(tq1,tq2);
  if(tqc != 0) return tqc;
  return typecmp(t1,t2);
}

static int aggrfield_cmp(aggrfield_t f1, aggrfield_t f2) {
  let zsc = strptrcmp(f1->name,f2->name);
  if(zsc != 0) return zsc;
  let tqc = tqual_cmp(f1->tq, f2->tq);
  if(tqc != 0) return tqc;
  let tc = typecmp(f1->type, f2->type);
  if(tc != 0) return tc;
  let ac = list_cmp(attribute_cmp,f1->attributes, f2->attributes);
  if(ac != 0) return ac;
  return star_cmp(Evexp::const_exp_cmp,f1->width, f2->width);
}

static int enumfield_cmp(enumfield_t e1, enumfield_t e2) {
  let qc = qvar_cmp(e1->name,e2->name);
  if(qc != 0) return qc;
  return star_cmp(Evexp::const_exp_cmp,e1->tag,e2->tag);
}

static int type_case_number(type_t t) {
  switch(t) {
  case VoidType: return 0;
  case &Evar(_,_,_,_): return 1;
  case &VarType(_): return 2;
  case &TunionType(_): return 3;
  case &TunionFieldType(_): return 4;
  case &PointerType(_): return 5;
  case &IntType(_,_): return 6;
  case FloatType: return 7;
  case &DoubleType(_): return 8;
  case &ArrayType(_): return 9;
  case &FnType(_): return 10;
  case &TupleType(_): return 11;
  case &AggrType(_): return 12;
  case &AnonAggrType(_,_): return 14;
  case &EnumType(_,_): return 16;
  case &AnonEnumType(_): return 17;
  case &RgnHandleType(_): return 18;
  case &TypedefType(_,_,_,_): return 19;
  case HeapRgn: return 20;
  case &AccessEff(_): return 21;
  case &JoinEff(_): return 22;
  case &RgnsEff(_): return 23;
  case &SizeofType(_): return 24;
  case &TypeInt(_): return 25;
  case &TagType(_): return 26;
  }
}
// the real work of comparison
// returns -1 if t1 < t2, 0 if ==, 1 if t1 > t2
// error for type not to be closed (?? -- doesn't look like it's a problem)
int typecmp(type_t t1, type_t t2) {
  t1 = compress(t1);
  t2 = compress(t2);
  if (t1 == t2) return 0;
  let shallowcmp = intcmp(type_case_number(t1), type_case_number(t2));
  if(shallowcmp != 0) 
    return shallowcmp;

  // guaranteed that top cases are the same
  switch ($(t2,t1)) {
  case $(&Evar(_,_,_,_),&Evar(_,_,_,_)): 
    impos("typecmp: can only compare closed types");
    
  case $(VoidType,VoidType): return 0;

  case $(&VarType(tv2),&VarType(tv1)):
    // identities should be resolved
    return intcmp(*tv1->identity,*tv2->identity);

  case $(&AggrType(AggrInfo(info1,ts1)),&AggrType(AggrInfo(info2,ts2))):
    // shouldn't have union and struct w/ same name, so ignore the kinds
    let $(_,n1) = aggr_kinded_name(info1);
    let $(_,n2) = aggr_kinded_name(info2);
    let ncmp = qvar_cmp(n1,n2);
    if(ncmp != 0) return ncmp;
    else return list_cmp(typecmp,ts1,ts2);

    // decl irrelevant and may not be set; name is enough
  case $(&EnumType(n1,_), &EnumType(n2,_)): return qvar_cmp(n1,n2);

  case $(&AnonEnumType(efs1), &AnonEnumType(efs2)):
    return list_cmp(enumfield_cmp,efs1,efs2);
    
  case $(&TunionType(TunionInfo(&KnownTunion(&tud2),ts2,r2)),
	 &TunionType(TunionInfo(&KnownTunion(&tud1),ts1,r1))):
    if(tud1 == tud2) return 0;
    let qc = qvar_cmp(tud1->name,tud2->name);
    if(qc != 0) return qc;
    let rc = typecmp(r1,r2);
    if(rc != 0) return rc;
    return list_cmp(typecmp,ts1,ts2);

  case $(&TunionFieldType(TunionFieldInfo(&KnownTunionfield(tud2,tuf2),ts2)),
	 &TunionFieldType(TunionFieldInfo(&KnownTunionfield(tud1,tuf1),ts1))):
    if(tud1 == tud2) return 0;
    let qc1 =  qvar_cmp(tud2->name,tud1->name);
    if(qc1 != 0) return qc1;
    let qc2 = qvar_cmp(tuf2->name, tuf1->name);
    if(qc2 != 0) return qc2;
    return list_cmp(typecmp,ts1,ts2);


  case $(&PointerType(PtrInfo{.elt_typ=t2a,.rgn_typ=rgn2,
                              .nullable=null2a,.tq=tqual2a,.bounds=b2,
                              .zero_term=zt2}),
	 &PointerType(PtrInfo{.elt_typ=t1a,.rgn_typ=rgn1,
                              .nullable=null1a,.tq=tqual1a,.bounds=b1,
                              .zero_term=zt1})):
    let etc = typecmp(t1a,t2a);
    if(etc != 0) return etc;
    let rc = typecmp(rgn1,rgn2);
    if(rc != 0) return rc;
    let tqc = tqual_cmp(tqual1a,tqual2a);
    if(tqc != 0) return tqc;
    let cc = conrefs_cmp(boundscmp,b1,b2);
    if (cc != 0) return cc;
    let zc = conrefs_cmp(intcmp,zt1,zt2);
    if (zc != 0) return zc;
    switch (compress_conref(b1)->v) {
    case &Eq_constr(Unknown_b): return 0;
    default: break;
    }
    return conrefs_cmp(intcmp,null1a,null2a);

  case $(&IntType(sn2,sz2), &IntType(sn1,sz1)):
    if (sn1 != sn2) return intcmp((unsigned int)sn1,(unsigned int)sn2);
    if(sz1 != sz2) return intcmp((unsigned int)sz1,(unsigned int) sz2);
    return 0;

  case $(FloatType, FloatType):  return 0;
  case $(&DoubleType(b1), &DoubleType(b2)): 
    if (b1 == b2) return 0;
    else if (b1) return -1;
    else return 1;

  case $(&ArrayType(ArrayInfo{t2a,tq2a,e1,zt1}), 
         &ArrayType(ArrayInfo{t1a,tq1a,e2,zt2})):
    let tqc = tqual_cmp(tq1a,tq2a);
    if(tqc != 0) return tqc;
    let tc = typecmp(t1a,t2a);
    if(tc != 0) return tc;
    let ztc = conrefs_cmp(intcmp,zt1,zt2);
    if (ztc != 0) return ztc;
    if (e1 == e2) return 0;
    if (e1 == NULL || e2 == NULL) { 
      impos("missing expression in array index");
    }
    return star_cmp(Evexp::const_exp_cmp,e1,e2);
    
  case $(&FnType(FnInfo{tvs2,eff2,rt2,args2,c_vararg2,cyc_vararg2,rpo2,atts2}), 
	 &FnType(FnInfo{tvs1,eff1,rt1,args1,c_vararg1,cyc_vararg1,rpo1,atts1})):
	   impos("typecmp: function types not handled");
  
  case $(&TupleType(ts2), &TupleType(ts1)):
    return list_cmp(tqual_type_cmp,ts1,ts2);
    
  case $(&AnonAggrType(k2,fs2), &AnonAggrType(k1,fs1)): 
    if(k1 != k2)
      if(k1 == StructA) return -1;
      else return 1;
    return list_cmp(aggrfield_cmp,fs1,fs2);
  
  case $(HeapRgn, HeapRgn): return 0; 
  case $(&RgnHandleType(rt1),&RgnHandleType(rt2)):
    return typecmp(rt1,rt2);
  case $(&SizeofType(s1),&SizeofType(s2)): return typecmp(s1,s2);
  case $(&TagType(s1),&TagType(s2)): return typecmp(s1,s2);
  case $(&TypeInt(n),&TypeInt(m)): return intcmp(n,m);
  case $(&JoinEff(_), _)  : 
  case $(_, &JoinEff(_))  : 
  case $(&AccessEff(_), _): 
  case $(&RgnsEff(_), _)  : 
  case $(_, &RgnsEff(_))  : 
  case $(_, &AccessEff(_)): impos("typecmp: effects not handled");
  default: impos("Unmatched case in typecmp");
  }
}

bool is_arithmetic_type(type_t t) {
  switch (compress(t)) {
  case &IntType(_,_): 
  case FloatType:     
  case &DoubleType(_):    
  case &EnumType(_,_): 
  case &AnonEnumType(_): return true;
  default: return false;
  }
}

// we're about to convert a value of type t1 to type t2 (both arithmetic types)
// return true if we will potentially lose precision
bool will_lose_precision(type_t t1, type_t t2) {
  switch ($(compress(t1),compress(t2))) {
  case $(&DoubleType(b1), &DoubleType(b2)): return (!b2 && b1);
  case $(&DoubleType(_),  FloatType):       
  case $(&DoubleType(_),  &IntType(_,_)):   
  case $(&DoubleType(_),  &SizeofType(_)):   
  case $(FloatType,       &SizeofType(_)):
  case $(&DoubleType(_),  &TagType(_)):   
  case $(FloatType,       &TagType(_)):
  case $(FloatType,       &IntType(_,_)):  return true;
  case $(&IntType(_,B8),  &IntType(_,B8)): return false;
  case $(&IntType(_,B8),  _): // see prev case
  case $(&IntType(_,B4),  FloatType):       
  case $(&IntType(_,B4),  &IntType(_,B2)):  
  case $(&IntType(_,B4),  &IntType(_,B1)):  
  case $(&IntType(_,B2),  &IntType(_,B1)): 
  case $(&TagType(_),  &IntType(_,B2)):  
  case $(&TagType(_),  &IntType(_,B1)): 
  case $(&SizeofType(_),  &IntType(_,B2)):  
  case $(&SizeofType(_),  &IntType(_,B1)): return true;
  default: return false;
  }
}

// coerce the list e so that each element has type t -- used in arrays and
// conditionals 
bool coerce_list(tenv_t te, type_t t, list_t<exp_t> es) {
  // find the biggest arithmetic type (if any) for the list and determine
  // if all of the elements are boxed.
  opt_t<type_t> max_arith_type = NULL;
  for (list_t<exp_t> el = es; el != NULL; el = el->tl) {
    type_t t1 = compress(el->hd->topt->v);
    if (is_arithmetic_type(t1)) 
      if (max_arith_type == NULL || will_lose_precision(t1,max_arith_type->v))
	max_arith_type = new Opt(t1);
  }
  // unify the max arithmetic type with the result type t
  if (max_arith_type != NULL)
    if (!unify(t,max_arith_type->v))
      return false;
  // now coerce each expression to the type t as if by assignment
  for (list_t<exp_t> el = es; el != NULL; el = el->tl)
    if (!coerce_assign(te,el->hd,t)) {
      terr(el->hd->loc,"type mismatch: expecting %s but found %s",
           typ2string(t),typ2string(el->hd->topt->v));
      return false;
    }
  return true;
}

// coerce e to have type "bool" (int) -- used in conditionals 
// Note: explicit cast is needed only for fat pointers, I think.
bool coerce_to_bool(tenv_t te, exp_t e) {
  if (!coerce_sint_typ(te,e))
    switch (compress(e->topt->v)) {
    case &PointerType(_): unchecked_cast(te,e,uint_typ); break;
    default: return false;
    }
  return true;
}

bool is_integral_type(type_t t) {
  switch (compress(t)) {
  case &IntType(_,_): 
  case &SizeofType(_):
  case &TagType(_):
  case &EnumType(_,_): 
  case &AnonEnumType(_): return true;
  default: return false;
  }
}

// coerce e to have type unsigned int -- used in subscript
bool coerce_uint_typ(tenv_t te, exp_t e) {
  if (unify(e->topt->v,uint_typ)) 
    return true;
  // try arithmetic conversions -- we only allow integral values
  if (is_integral_type(e->topt->v)) {
    if (will_lose_precision(e->topt->v,uint_typ))
      warn(e->loc,"integral size mismatch; conversion supplied");
    unchecked_cast(te,e,uint_typ);
    return true;
  }
  return false;
}

// coerce e to have type [signed] int -- used in coercions to "bool"
bool coerce_sint_typ(tenv_t te, exp_t e) {
  if (unify(e->topt->v,sint_typ)) 
    return true;
  // try arithmetic conversions -- we only allow integral values
  if (is_integral_type(e->topt->v)) {
    if (will_lose_precision(e->topt->v,sint_typ))
      warn(e->loc,"integral size mismatch; conversion supplied");
    unchecked_cast(te,e,sint_typ);
    return true;
  }
  return false;
}

// Can t1 be (implicitly) cast to t2? Assumes types are well-formed 
bool silent_castable(tenv_t te, seg_t loc, type_t t1, type_t t2) {
  t1 = compress(t1);
  t2 = compress(t2);
  switch ($(t1,t2)) {
  case $(&PointerType(pinfo_a), &PointerType(pinfo_b)):
    bool okay = true;
    // can coerce @ to *
    if (!unify_conrefs(intcmp,pinfo_a.nullable,pinfo_b.nullable)) {
      switch(compress_conref(pinfo_a.nullable)->v) {
      case &Eq_constr(b): okay = !b; break;
      default: impos("silent_castable conref not eq");
      }
    }
    // can coerce *{e} to ? and *{e1} to *{e2} when e2 <= e1
    if (!unify_conrefs(boundscmp,pinfo_a.bounds,pinfo_b.bounds)) {
      switch ($(compress_conref(pinfo_a.bounds)->v, 
		compress_conref(pinfo_b.bounds)->v)) {
      case $(&Eq_constr(&Upper_b(_)),&Eq_constr(Unknown_b)): 
	// Can cast to ? regardless of nullable
	okay = true; break;
	// JGM:  the following would be legal, but perhaps we don't
	// want to allow it to make porting easier -- I'm afraid
	// that writing t *x = y, where y is an array will go through
	// too easily...
	// DAN: okay, so make it a warning...
      case $(&Eq_constr(&Upper_b(e1)),&Eq_constr(&Upper_b(e2))):
	okay = okay && Evexp::lte_const_exp(e2,e1);
        // no need to warn for zero-terminated arrays -- they can get back
        // again (usually).
        if (!conref_def(false,pinfo_b.zero_term))
          warn(loc, "implicit cast to shorter array");
	break;
      case $(&Eq_constr(Unknown_b), &Eq_constr(&Upper_b(_))):
        // when zero-terminated can cast from ? to */@
        if (!conref_def(false,pinfo_a.zero_term))
          okay = false;
        break;
      case $(&Eq_constr(Unknown_b),&Eq_constr(Unknown_b)):
	// Can cast ? to ? regardless of nullable
	okay = true; break;
      default:
	okay = false; break;
      }
    }
    // element types have to be compatible
    okay = okay && unify(pinfo_a.elt_typ,pinfo_b.elt_typ);
    // first region must outlive the second
    okay = okay && (unify(pinfo_a.rgn_typ,pinfo_b.rgn_typ) || 
                    region_outlives(te,pinfo_a.rgn_typ,pinfo_b.rgn_typ));
    // can only move from non-const to const or stay same
    okay = okay && (!pinfo_a.tq.q_const || pinfo_b.tq.q_const);
    // must preserve zero-termination
    okay = okay && unify_conrefs(intcmp,pinfo_a.zero_term,pinfo_b.zero_term);
    return okay;

  case $(&ArrayType(ArrayInfo{t1a,tq1a,e1,zt1}),
         &ArrayType(ArrayInfo{t2a,tq2a,e2,zt2})):
    bool okay;
    // we could allow e1 >= e2 but I think it's best to give an error
    okay = unify_conrefs(intcmp,zt1,zt2) && 
      (e1 != NULL && e2 != NULL && Evexp::same_const_exp((exp_t)e1,(exp_t)e2));
    return (okay && unify(t1a,t2a) && (!tq1a.q_const || tq2a.q_const));

  // can cast a TunionFieldType to a TunionType if the field doesn't 
  // carry values.
  case $(&TunionFieldType(TunionFieldInfo{&KnownTunionfield(tud1,tuf),ts1}),
         &TunionType(TunionInfo(&KnownTunion(&tud2),ts2,_))):
       if ((tud1 == tud2 || qvar_cmp(tud1->name,tud2->name) == 0) 
	   && tuf->typs == NULL) {
	 for (; ts1 != NULL && ts2 != NULL; ts1=ts1->tl, ts2=ts2->tl)
	   if (!unify(ts1->hd,ts2->hd))
	     break;
	 if (ts1 == NULL && ts2 == NULL) 
	   return true;
       }
       return false;

  // can cast a "tunion T.f<ts> @`r1" to a "tunion `r2 T<ts>" when 
  //   field f carries values and r1==r2 or r1 outlives r2
  case $(&PointerType(PtrInfo{t_a,rt_a,null_a,q_a,b_a,zt1}),
	 &TunionType(TunionInfo{&KnownTunion(&tud2),ts2,r2})):
	   //n2,ts2,r2,_})):
    switch (compress(t_a)) {
    case &TunionFieldType(TunionFieldInfo{&KnownTunionfield(tud1,tuf1),ts1}):
      //n1,ts1,f1,_,tufd}):
      // regions must unify or rt_a must outlive r2
      if (!unify(rt_a,r2) && !region_outlives(te,rt_a,r2))
        return false;
      // pointer must be non-NULL(@) -- note could allow * but would have
      // to insert a bounds check?
      if (!unify_conrefs(intcmp,null_a,false_conref)) return false;
      // pointer must point to one element -- note, could allow > 0
      if (!unify_conrefs(boundscmp,b_a,new_conref(bounds_one)))
        return false;
      // don't allow zero-terminated pointer
      if (!unify_conrefs(intcmp,zt1,false_conref)) return false;
      // field must carry values and tunion names must align
      if (qvar_cmp(tud2->name,tud1->name)==0 && tuf1->typs != NULL) {
        // check type arguments
        bool okay = true;
        for (; ts1 != NULL && ts2 != NULL; ts1=ts1->tl, ts2=ts2->tl) 
          if (!unify(ts1->hd,ts2->hd)) {
            okay = false; break;
          }
        if (!okay || ts1 != NULL || ts2 != NULL) return false;
        return true;
      }
      break;
    default: break;
    }
    return false;

  case $(&SizeofType(_),&IntType(_,B4)):
  case $(&TagType(_),&IntType(_,B4)): return true;

  default: return unify(t1,t2);
  }
}

bool is_pointer_type(type_t t) {
  switch (compress(t)) {
  case &PointerType(_): return true;
  default: return false;
  }
}

bool is_zero(exp_t e) {
  switch (e->r) {
  case &Const_e(&Int_c(_,0)): return true;
  case &Const_e(&Char_c(_,0)): return true;
  case &Const_e(&Short_c(_,0)): return true;
  case &Const_e(&LongLong_c(_,0)): return true;
  case &Cast_e(t,e2): return is_zero(e2) && admits_zero(t);
  default: return false;
  }
}

struct Opt<kind_t> rk = {RgnKind};
struct Opt<kind_t> ak = {AnyKind};
struct Opt<kind_t> bk = {BoxKind};
struct Opt<kind_t> mk = {MemKind};

// if e1 is zero, and t2 a pointer type, changes e1 to NULL and
// returns true if t2 is a nullable pointer type
bool zero_to_null(tenv_t te, type_t t2, exp_t e1) {
  if (is_pointer_type(t2) && is_zero(e1)) {
    e1->r = new Const_e(Null_c);
    let tenv_tvs = lookup_type_vars(te);
    let t1 = new PointerType(PtrInfo(new_evar(&ak,new Opt(tenv_tvs)), 
                                     new_evar(&rk,new Opt(tenv_tvs)), 
                                     true_conref,
                                     empty_tqual(), empty_conref(), 
                                     empty_conref()));
    e1->topt->v = t1;
    return (coerce_arg(te, e1, t2));
  }
  return false;
}

static bool is_sizeof_type(type_t t1) {
  switch (compress(t1)) {
  case &SizeofType(_): return true;
  default: return false;
  }
}
static bool is_tag_type(type_t t1) {
  switch (compress(t1)) {
  case &TagType(_): return true;
  default: return false;
  }
}
// coerce e to have type t -- used in function call and explicit fallthru
bool coerce_arg(tenv_t te, exp_t e, type_t t2) {
  type_t t1 = compress(e->topt->v);
  // see if types immediately match
  if (unify(t1,t2)) return true;
  // try arithmetic conversions
  if ((is_arithmetic_type(t1) && is_arithmetic_type(t2)) ||
      (is_sizeof_type(t1) && is_arithmetic_type(t2)) ||
      (is_tag_type(t1) && is_arithmetic_type(t2)) ) {
    // issue a warning if we lose precision
    if (will_lose_precision(t1,t2))
      warn(e->loc,"integral size mismatch; %s -> %s conversion supplied", 
	   typ2string(t1), typ2string(t2));
    unchecked_cast(te,e,t2);
    return true;
  } else if (silent_castable(te,e->loc,t1,t2)) {
    unchecked_cast(te,e,t2);
    return true;
  } else if (zero_to_null(te,t2,e)) { 
    return true;
  } else if (castable(te,e->loc,t1,t2)) {
    unchecked_cast(te,e,t2);
    warn(e->loc,"implicit cast from %s to %s",typ2string(t1),typ2string(t2));
    return true;
  } else return false;
}

// coerce e to have type t -- used in assignment operations.  Neither
// gcc nor VC++ issue warnings for losing precision here, but I think
// it may be appropriate.
bool coerce_assign(tenv_t te, exp_t e, type_t t) {
  return coerce_arg(te,e,t);
}

bool coerceable(type_t t) {
  switch (compress(t)) {
  case &IntType(_,_): 
  case FloatType:     
  case &DoubleType(_): return true;
  default: return false;
  }
}

// FIX:  all of the subtyping stuff needs to be re-examined in the light
// of packed/aligned attributes.  And we'd need to be careful to do this
// in an architecture-dependent way (based on alignement and so forth.)

// Flatten a type into a list of type qualifiers and types for
// use in subtype comparison.
// FIX:  we should recursively flatten tuple and struct types here,
// but doing so is tricky because we have to get the padding and
// alignment right.  This seems to be particularly weird on the
// x86 -- I need to find precise documentation on it before we do this.
static $(tqual_t,type_t)@ flatten_typ_f(list_t<$(tvar_t,type_t)@`H,`H> inst,
					aggrfield_t x) {
  return new $(x->tq,substitute(inst,x->type));
}
static list_t<$(tqual_t,type_t)@> flatten_typ(tenv_t te,type_t t1) {
  t1 = compress(t1);
  switch (t1) {
  case VoidType: return NULL;
  case &TupleType(tqs): return tqs; // FIX: recursively flatten here
  case &AggrType(AggrInfo(&KnownAggr(&ad),ts)):
    // FIX: to strict with existentials and constraints??
    if(ad->kind==UnionA || ad->impl==NULL 
       || ad->impl->exist_vars != NULL || ad->impl->rgn_po != NULL) 
      return new List(new $(empty_tqual(),t1),NULL);
    let inst = List::zip(ad->tvs,ts);
    // FIX: recursively flatten here (if alignment allows??)
    return List::map_c(flatten_typ_f,inst,ad->impl->fields);
  case &AnonAggrType(StructA,fs):
    // FIX: recursively flatten here (if alignment allows??)
    return List::map_c(flatten_typ_f,NULL,fs);
  default: return new List(new $(empty_tqual(),t1),NULL);
  }
}

// FIX: the plan is, once we have a context that lets us assume t1 <= t2
// for recursive types, then to do deep subtyping.  
// FIX: allow casting one function type to another -- especially, allow
// effects to grow...
static bool ptrsubtype(tenv_t te, list_t<$(type_t,type_t)@`H,`H> assume, 
		       type_t t1, type_t t2);
static bool subtype(tenv_t te, list_t<$(type_t,type_t)@`H,`H> assume, 
		    type_t t1, type_t t2) {
  if (unify(t1,t2)) return true;
  for (_ a = assume; a != NULL; a = a->tl) 
    if (unify(t1,(*a->hd)[0]) && unify(t2,(*a->hd)[1])) 
      return true;

  t1 = compress(t1);
  t2 = compress(t2);
  switch ($(t1,t2)) {
    // the following allows us to cast an unsigned int pointer to an int 
    // pointer and vice versa.  This is okay because the types are isomorphic.
    case $(&PointerType(PtrInfo{t_a, rt_a, null_a, q_a, b_a, zt_a}),
	   &PointerType(PtrInfo{t_b, rt_b, null_b, q_b, b_b, zt_b})):
    // if t1 is const then t2 must be const
    if (q_a.q_const && !q_b.q_const) 
      return false;
    // if t1 is * then t2 must be *
    if (!unify_conrefs(intcmp,null_a,null_b) 
	&& conref_val(null_a) && !conref_val(null_b)) 
      return false;
    // if t1 is not zero-terminated, then t2 must not be zero-terminated
    if (!unify_conrefs(intcmp,zt_a,zt_b)
        && !conref_val(zt_a) && conref_val(zt_b))
      return false;
    // rt_a must outlive rt_b
    if (!unify(rt_a,rt_b) && !region_outlives(te,rt_a,rt_b))
      return false;
    // need to check that the bounds match up
    if (!unify_conrefs(boundscmp,b_a,b_b)) {
      switch ($(conref_val(b_a),conref_val(b_b))) {
      case $(&Upper_b(_), Unknown_b): break;
      case $(&Upper_b(e1), &Upper_b(e2)): 
	if(!Evexp::lte_const_exp(e2,e1))
	  return false;
	break;
      default: return false;
      }
    }
    return ptrsubtype(te, new List(new $(t1,t2),assume), t_a, t_b);
  default: return false;
  }
}

static bool isomorphic(type_t t1, type_t t2) {
  switch ($(compress(t1),compress(t2))) {
  case $(&IntType(_,b1), &IntType(_, b2)): return b1 == b2;
  default: return false;
  }
}

// is t1* <= t2*?
//   we flatten t1 and t2 into structurally equivalent tuple types 
//   (and thus ignore field names, associativity of nested tuples and
//   structs, etc.) and then check that t1 is a width extension of t2 
//   and for each field, either (a) both t1 and t2 have qualifier "const"
//   and the t1 field is a subtype of the t2 field, or (b) t1 = t2.
static bool ptrsubtype(tenv_t te, list_t<$(type_t,type_t)@`H,`H> assume, type_t t1, type_t t2) {
  list_t<$(tqual_t,type_t)@> tqs1 = flatten_typ(te,t1);
  list_t<$(tqual_t,type_t)@> tqs2 = flatten_typ(te,t2);
  for (; tqs2 != NULL; tqs2 = tqs2->tl, tqs1 = tqs1->tl) {
    if (tqs1 == NULL) return false;
    let &$(tq1,t1a) = tqs1->hd;
    let &$(tq2,t2a) = tqs2->hd;
    if (tq2.q_const && subtype(te,assume,t1a,t2a)) continue;
    else if (unify(t1a,t2a)) continue;
    else if (isomorphic(t1a,t2a)) continue;
    else return false;
  }
  return true;
}

static bool is_char_type(type_t t) {
  switch (compress(t)) {
  case &IntType(_,B1): return true;
  default: return false;
  }
}

// Can t1 be cast to t2?  Assumes that the types are well-formed.
// FIX: add function types...
bool castable(tenv_t te, seg_t loc, type_t t1, type_t t2) {
  if(unify(t1,t2))
    return true;
  t1 = compress(t1);
  t2 = compress(t2);
  switch (t2) {
  // we can cast t1 to an int if t1 is a boxed type.
  case &IntType(_,B4):
    if (typ_kind(t1) == BoxKind) return true;
    break;
  default: break;
  }
  switch (t1) {
  case &PointerType(PtrInfo{t_a,rt_a,null_a,q_a,b_a,zt_a}):
    // can cast t* to t@ and vice versa.  
    // can cast a non-const pointer to a const pointer.  
    // can cast a pointer in region r1 to a pointer in region r2 as
    // long as r1 outlives r2.
    // can cast a "bits-only" pointer to a char pointer ?NOZEROTERM
    // can cast a zero-terminated pointer to a non-zero terminated pointer
    switch (t2) {
    case &PointerType(PtrInfo{t_b,rt_b,null_b,q_b,b_b,zt_b}):
      let assump = new List(new $(t1,t2),NULL);
      let ptrsub =
	ptrsubtype(te,assump,t_a,t_b) && (!q_a.q_const || q_b.q_const);
      bool zeroterm_ok = unify_conrefs(intcmp,zt_a,zt_b) || !conref_val(zt_b);
      let bitcase = ptrsub ? false : (bits_only(t_a) && is_char_type(t_b)
                                      && !conref_def(false,zt_b) 
                                      && (q_b.q_const || !q_a.q_const));
      bool bounds_ok = unify_conrefs(boundscmp,b_a,b_b);
      if (!bounds_ok && !bitcase) {
	switch ($(conref_val(b_a),conref_val(b_b))) {
	  // We allow casts of any form as long as we can't statically
	  // tell that the bounds will be violated.
	case $(&Upper_b(e_a),&Upper_b(e_b)): 
	  if(Evexp::lte_const_exp(e_b,e_a))
	    bounds_ok = true;
	  break;
	default: bounds_ok = true; break;
	}
      }
      return bounds_ok && zeroterm_ok && (ptrsub || bitcase) && 
        (unify(rt_a,rt_b) || region_outlives(te,rt_a,rt_b));
    case VoidType: return true;
    default: break;
    }
    return false;
  case &ArrayType(ArrayInfo{t1a,tq1a,e1,zt1}):
    switch (t2) {
    case &ArrayType(ArrayInfo{t2a,tq2a,e2,zt2}):
      bool okay;
      okay=
        (e1 != NULL && e2 != NULL && unify_conrefs(intcmp,zt1,zt2) &&
	 Evexp::lte_const_exp((exp_t)e2,(exp_t)e1));
      return (okay && unify(t1a,t2a) && (!tq1a.q_const || tq2a.q_const));
    default: return false;
    }
    return false;
  // can cast a numeric type or bool to any numeric type
  case &EnumType(_,ed1): 
    // can also cast an enum to a shorter enum
    switch(t2) {
    case &EnumType(_,ed2):
      if(ed1->fields != NULL && ed2->fields != NULL
	 && length(ed1->fields->v) >= length(ed2->fields->v))
	return true;
      break;
    default: break;
    }
    fallthru;
  case &IntType(_,_): 
  case FloatType :  
  case &DoubleType(_): return coerceable(t2) || t2 == VoidType;
  case VoidType:   return t2 == VoidType;
  default: return false;
  }
}

// Replace e by a cast of e to t.  The caller must ensure that the cast is safe.
void unchecked_cast(tenv_t te, exp_t e, type_t t) {
  if (!unify(e->topt->v,t)) {
    let inner = copy_exp(e);
    e->r    = new Cast_e(t,inner);
    e->topt = new Opt(t);
  }
}

bool is_integral(exp_t e) {
  switch (compress(e->topt->v)) {
  case &IntType(_,_): 
  case &EnumType(_,_):
  case &AnonEnumType(_):
  case &TagType(_):
  case &SizeofType(_): return true;
  case &Evar(_,_,_,_): return unify(e->topt->v,sint_typ);
  default: return false;
  }
}

bool is_numeric(exp_t e) {
  if(is_integral(e))
    return true;
  switch (compress(e->topt->v)) {
  case FloatType:  
  case &DoubleType(_): return true;
  default: return false;
  }
}

bool is_function_type(type_t t) {
  switch (compress(t)) {
  case &FnType(_): return true;
  default: return false;
  }
}

type_t max_arithmetic_type(type_t t1, type_t t2) {
  switch ($(t1,t2)) {
  case $(&DoubleType(b1),&DoubleType(b2)): 
    if (b1) return t1; 
    else return t2;
  case $(&DoubleType(_),_): return t1;
  case $(_,&DoubleType(_)): return t2;
  case $(FloatType,_):  
  case $(_,FloatType):  return FloatType;
  case $(&IntType(Unsigned,B8),_): 
  case $(_,&IntType(Unsigned,B8)): return ulonglong_typ;
  case $(&IntType(None,B8),_):   
  case $(_,&IntType(None,B8)):case $(&IntType(Signed,B8),_):   
  case $(_,&IntType(Signed,B8)):   return slonglong_typ;
  case $(&IntType(Unsigned,B4),_): 
  case $(_,&IntType(Unsigned,B4)): return uint_typ;
  default: return sint_typ;
  }
}

// used to warn when a while, for, if, or do test contains an assignment
void check_contains_assign(exp_t e) {
  switch (e->r) {
  case &AssignOp_e(_,NULL,_): warn(e->loc,"assignment in test"); break;
  default: break;
  }
}

/////////////////////////////////////////////////////////////////////
// Checking well-formedness of types
/////////////////////////////////////////////////////////////////////

// Given two kind constraint refs, merge them so that they will
// point to the most constrained kind -- if they're compatible
// return true, otherwise return false.
static bool constrain_kinds(kindbound_t c1, kindbound_t c2) {
  c1 = compress_kb(c1);
  c2 = compress_kb(c2);
  switch ($(c1,c2)) {
  case $(&Eq_kb(k1),&Eq_kb(k2)): return k1 == k2;
  case $(_,&Unknown_kb(*f)): *f = new Opt(c1); return true;
  case $(&Unknown_kb(*f),_): *f = new Opt(c2); return true;
  case $(&Less_kb(*f,k1),&Eq_kb(k2)): 
    if (kind_leq(k2,k1)) {
      *f = new Opt(c2); return true;
    } else return false;
  case $(&Eq_kb(k1),&Less_kb(*f,k2)):
    if (kind_leq(k1,k2)) {
      *f = new Opt(c1); return true;
    } else return false;
  case $(&Less_kb(*f1,k1),&Less_kb(*f2,k2)):
    if (kind_leq(k1,k2)) {
      *f2 = new Opt(c1); return true;
    } else if (kind_leq(k2,k1)) {
      *f1 = new Opt(c2); return true;
    } else return false;
  }
}

// generating fresh tvars and tvar identities
static int tvar_id_counter = 0;
int *new_tvar_id() {
  return new (tvar_id_counter++);
}

static int tvar_counter = 0;
tvar_t new_tvar(kindbound_t k) {
  int i = tvar_counter++;
  string_t s = aprintf("#%d",i);
  return new Tvar(new{s},NULL,k);
}

bool is_temp_tvar(tvar_t t) {
  let s = *(t->name);
  return (s[0]=='#');
}

void rewrite_temp_tvar(tvar_t t) { // change t->name from "#xxx" to "`txxx"
  printf("%s", *(t->name));
  if (! is_temp_tvar(t)) return;
  let s = strconcat("`", *(t -> name));
  s[1] = 't';
  t -> name = new{(string_t)s};
}

// Given a function declaration, return its type as a function type:
static $(opt_t<var_t>,tqual_t,type_t)@ 
  fndecl2typ_f($(var_t,tqual_t,type_t)@ x) {
  return new $((opt_t<var_t>)(new Opt((*x)[0])), (*x)[1], (*x)[2]);
}

type_t fndecl2typ(fndecl_t fd) {
  if (fd->cached_typ == NULL) {
    // We don't cache this type as we want to expand out the effect
    // and so forth...  The caching happens after we check that the
    // function declaration is valid (see below).
    // First, separate the function type attributes from the rest
    // of the attributes and update the function declaration appropriately.
    let fn_type_atts = NULL;
    for (_ atts = fd->attributes; atts != NULL; atts = atts->tl)
      if (fntype_att(atts->hd))
        fn_type_atts = new List(atts->hd,fn_type_atts); 
    return new FnType(FnInfo{fd->tvs, fd->effect, fd->ret_type,
                               List::map(fndecl2typ_f, fd->args),
                               fd->c_varargs, fd->cyc_varargs, 
                               fd->rgn_po, fn_type_atts});
  }
  return fd->cached_typ->v;
}

// Substitution stuff
static `a fst_fdarg($(`a,tqual_t,`c)@`r t) { return (*t)[0]; }
type_t snd_tqt($(tqual_t,type_t)@`r t) { return (*t)[1]; }
static $(tqual_t,type_t)@ map2_tq($(tqual_t,type_t)@`r1 pr, type_t t) {
  return new $((*pr)[0],t);
}
static $($(opt_t<var_t>,tqual_t)@`r,type_t)@`r
substitute_f1(region_t<`r> rgn, $(opt_t<var_t,`H>,tqual_t,type_t) @`r2 y) {
  return rnew(rgn) $(rnew(rgn) $((*y)[0],(*y)[1]),(*y)[2]);
}
static $(opt_t<var_t>,tqual_t,type_t)@ 
substitute_f2($($(opt_t<var_t,`H>,tqual_t)@`r2,type_t)@`r1 w) {
  let $(p,t) = *w;
  let $(vopt,tq) = *p;
  return new $(vopt,tq,t);
}
static type_t field_type(aggrfield_t f) {
  return f->type;
}
static aggrfield_t zip_field_type(aggrfield_t f, type_t t) {
  return new Aggrfield {.name = f->name, .tq = f->tq, .type = t,
                        .width = f->width, .attributes = f->attributes};
}

static list_t<type_t,`r2> substs(region_t<`r> rgn,
				  list_t<$(tvar_t,type_t)@`r,`r> inst, 
				  list_t<type_t,`r2> ts);

type_t rsubstitute(region_t<`r> rgn, 
		   list_t<$(tvar_t,type_t)@`r,`r> inst, 
		   type_t t) {
  switch (compress(t)) {
  case &VarType(v):
    // a tvar lookup, not a var lookup!
    try return List::assoc_cmp(tvar_cmp,inst,v);
    catch {case Not_found: return t;}
  case &AggrType(AggrInfo(info,ts)):   
    let new_ts = substs(rgn,inst,ts);
    return new_ts == ts ? t : new AggrType(AggrInfo(info,new_ts));
  case &TunionType(TunionInfo{info,ts,r}):     
    let new_ts = substs(rgn,inst,ts);
    let new_r  = rsubstitute(rgn,inst,r);
    return (new_ts == ts && new_r == r) ? t : 
      new TunionType(TunionInfo{info,new_ts,new_r});
  case &TunionFieldType(TunionFieldInfo{info,ts}):
    let new_ts = substs(rgn,inst,ts);
    return (new_ts == ts) ? t : 
      new TunionFieldType(TunionFieldInfo{info,new_ts});
  case &TypedefType(n,ts,td,topt): 
    let new_ts = substs(rgn,inst,ts);
    return new_ts == ts ? t : new TypedefType(n,new_ts,td,topt);
  case &ArrayType(ArrayInfo{t1,tq,e,zt}):     
    let new_t1 = rsubstitute(rgn,inst,t1);
    return new_t1 == t1 ? t : new ArrayType(ArrayInfo{new_t1,tq,e,zt});
  case &PointerType(PtrInfo{t1,r,n,tq,b,zt}): 
    let new_t1 = rsubstitute(rgn,inst,t1);
    let new_r  = rsubstitute(rgn,inst,r);
    if(new_t1 == t1 && new_r == r)
      return t;
    return new PointerType(PtrInfo(new_t1,new_r,n,tq,b,zt));
  case &FnType(FnInfo{vs,eff,rtyp,args,c_varargs,cyc_varargs,rgn_po,atts}):
    for (let p = vs; p != NULL; p = p->tl)
      inst = rnew(rgn) List(rnew(rgn) $(p->hd,new VarType(p->hd)),inst);
    let $(qs,ts) = List::rsplit(rgn,rgn, 
				List::rmap_c(rgn,substitute_f1,rgn,args));
    let ts2      = substs(rgn,inst,ts);
    let args2    = List::map(substitute_f2, List::rzip(rgn,rgn,qs,ts2));
    opt_t<type_t> eff2;
    if(eff == NULL)
      eff2 = NULL;
    else {
      let new_eff = rsubstitute(rgn,inst,eff->v);
      if(new_eff == eff->v)
	eff2 = eff;
      else
	eff2 = new Opt(new_eff);
    }
    vararg_info_t *cyc_varargs2;
    if (cyc_varargs == NULL) 
      cyc_varargs2 = NULL;
    else {
      let VarargInfo{n,tq,t,i} = *cyc_varargs;
      let t2 = rsubstitute(rgn,inst,t);
      if (t2 == t) cyc_varargs2 = cyc_varargs;
      else 
        cyc_varargs2 = new VarargInfo{n,tq,t2,i};
    }
    list_t<$(type_t,type_t)@> rgn_po2;
    let $(rpo1a,rpo1b) = List::rsplit(rgn,rgn,rgn_po);
    let rpo2a = substs(rgn,inst,rpo1a);
    let rpo2b = substs(rgn,inst,rpo1b);
    if (rpo2a == rpo1a && rpo2b == rpo1b) 
      rgn_po2 = rgn_po;
    else 
      rgn_po2 = List::zip(rpo2a,rpo2b);
    return 
      new FnType(FnInfo{vs,eff2,rsubstitute(rgn,inst,rtyp),args2,c_varargs,
                          cyc_varargs2,rgn_po2,atts});
  case &TupleType(tqts):
    let ts  = List::rmap(rgn,snd_tqt,tqts);
    let ts2 = substs(rgn,inst,ts);
    if(ts2 == ts)
      return t;
    let tqts2 = List::map2(map2_tq,tqts,ts2);
    return new TupleType(tqts2);
  case &AnonAggrType(k,fs):
    let ts = List::rmap(rgn,field_type,fs);
    let ts2 = substs(rgn,inst,ts);
    if (ts2 == ts)
      return t;
    let fs2 = List::map2(zip_field_type,fs,ts2);
    return new AnonAggrType(k,fs2);
  case &Evar(_,r,_,_):
    if (r != NULL) return rsubstitute(rgn,inst,r->v);
    else return t;
  case &RgnHandleType(rt): 
    let new_rt = rsubstitute(rgn,inst,rt);
    return new_rt == rt ? t : new RgnHandleType(new_rt);
  case &SizeofType(t2):
    let new_t2 = rsubstitute(rgn,inst,t2);
    return new_t2 == t2 ? t : new SizeofType(new_t2);
  case &TagType(t2):
    let new_t2 = rsubstitute(rgn,inst,t2);
    return new_t2 == t2 ? t : new TagType(new_t2);
  case &TypeInt(_):
  case &EnumType(_,_): 
  case &AnonEnumType(_):
  case VoidType:       
  case &IntType(_,_):  
  case FloatType:      
  case &DoubleType(_): 
  case HeapRgn:        return t;
  case &RgnsEff(t2):
    let new_t2 = rsubstitute(rgn,inst,t2);
    return new_t2 == t2 ? t : new RgnsEff(new_t2);
  case &AccessEff(r): 
    let new_r = rsubstitute(rgn,inst,r);
    return new_r == r ? t : new AccessEff(new_r);
  case &JoinEff(es):  
    let new_es = substs(rgn,inst,es);
    return new_es == es ? t : new JoinEff(new_es);
  }
}
// This is just a map beefed up to avoid unnecessary allocation.
static list_t<type_t,`r2> substs(region_t<`r> rgn,
				  list_t<$(tvar_t,type_t)@`r,`r> inst, 
				  list_t<type_t,`r2> ts) {
  if(ts == NULL)
    return NULL;
  let old_hd = ts->hd;
  let old_tl = ts->tl;
  let new_hd = rsubstitute(rgn, inst, old_hd);
  let new_tl = substs(rgn, inst, old_tl);
  if(old_hd == new_hd && old_tl == new_tl)
    return ts;
  return (list_t<type_t,`r2>)(new List(new_hd,new_tl));
}

extern type_t substitute(list_t<$(tvar_t,type_t)@`H,`H> inst, type_t t) {
  return rsubstitute(heap_region, inst, t);
}

// Generate an appropriate evar for an instantiation of a type var
$(tvar_t,type_t)@ make_inst_var(list_t<tvar_t,`H> s, tvar_t tv) {
  kind_t k = tvar_kind(tv);
  return new $(tv, new_evar(new Opt(k),new Opt(s)));
}

$(tvar_t,type_t)@`r r_make_inst_var($(list_t<tvar_t,`H>,region_t<`r>)@ env,
                                    tvar_t tv) {
  let &$(s,rgn) = env;
  kind_t k = tvar_kind(tv);
  return rnew(rgn) $(tv, new_evar(new Opt(k),new Opt(s)));
}

// Adds tv to the list of tvars unless it's already present.  If it's
// already present, makes sure the kinds are compatible by choosing the
// most constrained kind as the kind of the variable, and in fact
// physically share the kinds so that further constraints on it are
// propagated.  Also ensures that the tvars share the same identity.
static list_t<tvar_t> add_free_tvar(seg_t loc, list_t<tvar_t,`H> tvs, 
                                    tvar_t tv)
{
  for (_ tvs2 = tvs; tvs2 != NULL; tvs2 = tvs2->tl) {
    if (strptrcmp(tvs2->hd->name, tv->name) == 0) {
      kindbound_t k1 = tvs2->hd->kind;
      kindbound_t k2 = tv->kind;
      if (!constrain_kinds(k1,k2))
        terr(loc,"type variable %s is used with inconsistent kinds %s and %s",
             *tv->name, kindbound2string(k1), kindbound2string(k2));
      if (tv->identity == NULL)
        tv->identity = tvs2->hd->identity;
      else if (*tv->identity != *tvs2->hd->identity)
        impos("same type variable has different identity!");
      return tvs;
    }
  }
  tv->identity = new_tvar_id();
  return new List(tv,tvs);
}

// This assumes the identities and kinds are set, and simply adds
// the tvar if it's not already present.
static list_t<tvar_t> fast_add_free_tvar(list_t<tvar_t,`H> tvs, tvar_t tv) {
  // sanity
  if (tv->identity == NULL)
    impos("fast_add_free_tvar: bad identity in tv");
  for (_ tvs2 = tvs; tvs2 != NULL; tvs2 = tvs2->tl) {
    // sanity
    if (tvs2->hd->identity == NULL)
      impos("fast_add_free_tvar: bad identity in tvs2");
    if (*tvs2->hd->identity == *tv->identity)
      return tvs;
  }
  return new List{tv,tvs};
}

// will shadow other variables
static list_t<tvar_t> add_bound_tvar(list_t<tvar_t,`H> tvs, tvar_t tv) {
  // sanity
  if (tv->identity == NULL) 
    impos("bound tvar id for %s is NULL", tvar2string(tv));
  return new List(tv,tvs);
}

// assumes es is a list of evars, and e is an evar.  Adds in e only
// if not already present.
static list_t<type_t> add_free_evar(list_t<type_t,`H> es, type_t e) {
  switch (compress(e)) {
  case &Evar(_,_,i,_):
    for (_ es2 = es; es2 != NULL; es2 = es2->tl) {
      switch (compress(es2->hd)) {
      case &Evar(_,_,j,_): if (i == j) return es; break;
      default: break;
      }
    }
    return new List(e,es);
  default: return es;
  }
}  

static list_t<tvar_t> remove_bound_tvars(list_t<tvar_t> tvs,
					 list_t<tvar_t> btvs) {
  list_t<tvar_t> r = NULL;
  for (; tvs != NULL; tvs = tvs->tl) {
    bool present = false;
    for (_ b = btvs; b != NULL; b = b->tl) {
      if (*tvs->hd->identity == *b->hd->identity) {
        present = true;
        break;
      }
    }
    if (!present) r = new List(tvs->hd,r);
  }
  r = List::imp_rev(r);
  return r;
}

void check_bitfield(seg_t loc, tenv_t te, type_t field_typ, 
                    exp_opt_t width, stringptr_t fn) {
  if (width != NULL) {
    unsigned int w = 0;
    if (!is_const_exp(te,(exp_t)width))
      terr(loc,"bitfield %s does not have constant width",*fn);
    else {
      let $(i,known) = Evexp::eval_const_uint_exp((exp_t)width);
      if(!known)
	terr(loc,"bitfield width cannot use sizeof or offsetof");
      w = i;
    }
    switch (compress(field_typ)) {
    case &IntType(_,b):
      switch (b) {
      case B1: if (w > 8)  terr(loc,"bitfield larger than type"); break;
      case B2: if (w > 16) terr(loc,"bitfield larger than type"); break;
      case B4: if (w > 32) terr(loc,"bitfield larger than type"); break;
      case B8: if (w > 64) terr(loc,"bitfield larger than type"); break;
      }
      break;
    default:
      terr(loc,"bitfield %s must have integral type but has type %s",
           *fn,typ2string(field_typ));
      break;
    }
  }
}

static void check_field_atts(seg_t loc, stringptr_t fn, attributes_t atts) {
  for (; atts != NULL; atts = atts->tl)
    switch (atts->hd) {
    case Packed_att: continue;
    case &Aligned_att(_): continue;
    default: terr(loc,"bad attribute %s on member %s",
		  attribute2string(atts->hd), *fn);
    }
}

// Check-Valid-Type environments
static struct CVTEnv { 
  // passed down
  list_t<tvar_t> kind_env;  // used to get consistent id's and kinds for tvars
  // passed up 
  list_t<tvar_t> free_vars; // free tvars for this type
  list_t<type_t> free_evars;// free evars for this type
  // flag controlling whether to replace evars with fresh tvars
  bool generalize_evars; 
  // flag controlling whether we are in a function result or not
  bool fn_result;
};
typedef struct CVTEnv cvtenv_t;

// Checks that a type is well-formed and lives in kind expected_kind.  
// Takes as input a location (for error reporting), a type environment 
// (for looking up struct, enum, tunion, etc. decls), a check-valid-type
// environment (explained below), an expected kind, and the type itself t.
// It returns a check-valid-type-env as a result.
//
// In addition to checking that the type is valid, the routine needs
// to compute the set of free type variables and free evars in the
// type, and to constrain their kinds appropriately.  Normally, this
// would be coded by passing a kind_env down, and returning free_vars
// and free_evars as a result.  However, to cut down on allocation,
// we pass in the free variables of surrounding types and just add
// any new free variables to the result.  This way, we can calculate
// all of the free variables for a term in a store-passing style.
// The only situation where this breaks down is where we have binders
// as is the case for function types (see below).
//
// This also performs the following side-effects which most of the 
// rest of the compiler rightfully assumes have occurred:
// * expand typedefs
// * set pointers (or Known* variants) to declarations for 
//   StructType, UnionType, TunionType, TunionFieldType
// * change relative type names to absolute type names
// * set the kind field of type variables: we use the expected kind
//   initially, but if later constraints force a more constrained kind,
//   then we move to the more constrained kind.  This is why we propagate
//   around the set of 
// * add default effects for function types 
static cvtenv_t i_check_valid_type(seg_t loc, tenv_t te, cvtenv_t cvtenv, 
                                   kind_t expected_kind, type_t t) {
  switch (compress(t)) {
  case VoidType: break;
  case &Evar(*k,*ref,_,_): 
    if (*k == NULL) *k = new Opt(expected_kind); 
    if (cvtenv.fn_result && cvtenv.generalize_evars && 
        expected_kind == RgnKind) {
      *ref = new Opt(HeapRgn);
    } else if (cvtenv.generalize_evars) {
      let v = new_tvar(new Less_kb(NULL,expected_kind));
      *ref = new Opt(new VarType(v));
      fallthru(v);
    } else {
      cvtenv.free_evars = add_free_evar(cvtenv.free_evars,t);
    }
    break;
  case &VarType(v):
    switch (compress_kb(v->kind)) {
    case &Unknown_kb(*f): *f = new Opt(new Less_kb(NULL,expected_kind)); break;
    default: break;
    }
    // this constrains the variable's kind according to other occurrences
    // of that variable and makes sure they share the same tvar identity.
    cvtenv.kind_env = add_free_tvar(loc, cvtenv.kind_env, v);
    // no need to constrain things here, but want to add it only if
    // it hasn't already been added.
    cvtenv.free_vars = fast_add_free_tvar(cvtenv.free_vars, v);
    break;
  case &AnonEnumType(fs):
    // Note: this code is duplicated almost exactly in tc.cyc
    genv_t ge = Dict::lookup(te->ae,te->ns);
    region uprev_rgn {
      list_t<field_name_t, `uprev_rgn> prev_fields = NULL;
      unsigned int tag_count = 0;
      for (; fs != NULL; fs = fs->tl) {
        let f = fs->hd;
        if (List::mem(strptrcmp,prev_fields,(*f->name)[1]))
          terr(f->loc,"duplicate enum field name %s",*((*f->name)[1]));
        else
          prev_fields = rnew(uprev_rgn) List((*f->name)[1],prev_fields);
      
        if (f->tag == NULL)
          f->tag = uint_exp(tag_count, f->loc);
        else if (!Tcutil::is_const_exp(te,(exp_t)f->tag))
          terr(loc,"enum field %s: expression is not constant",*(*f->name)[1]);
        
        unsigned int t1 = Evexp::eval_const_uint_exp((exp_t)f->tag)[0];
        tag_count = t1+1;
        (*f->name)[0] = new Abs_n(te->ns);
        ge->ordinaries = Dict::insert(ge->ordinaries, (*f->name)[1],
                                      new $(new AnonEnumRes(t,f), true));
      }
    }
    break;
  case &EnumType(n,*edp):
    if (*edp == NULL || (*edp)->fields == NULL)
      try {
        enumdecl_t @ed = lookup_enumdecl(te,loc,n);
        *edp = *ed;
      } catch {
      case Dict::Absent:
        let ge = Dict::lookup(te->ae,te->ns);
        let ed_orig = new Enumdecl{Extern,n,NULL};
        Tc::tcEnumdecl(te,ge,loc,ed_orig);
        enumdecl_t @ed = lookup_enumdecl(te,loc,n);
        *edp = *ed;
        break;
        //terr(loc,"unbound type enum %s",qvar2string(n));
        //return cvtenv;
      }
    enumdecl_t ed = (enumdecl_t)*edp;
    // Make relative name absolute
    *n = (ed->name)[0];
    break;
  case &TunionType(TunionInfo(*info,*targsp,rgn)):
    let targs = *targsp;
    switch(*info) {
    case &UnknownTunion(UnknownTunionInfo(n,is_x)):
      tuniondecl_t@ tudp;
      try tudp = lookup_tuniondecl(te,loc,n);// FIX: lookup_xtuniondecl needed?
      catch { case Dict::Absent:
        // declare the tunion for the user
        let ge = Dict::lookup(te->ae,te->ns);
        let tud = new Tuniondecl{Extern, n, NULL, NULL, is_x};
        Tc::tcTuniondecl(te, ge, loc, tud);
        tudp = lookup_tuniondecl(te,loc,n);
        // give an error here if targs is non-empty
        if (targs != NULL) {
          terr(loc,"please declare parameterized %s %s before using",
               (is_x ? (const char ?)"xtunion" : "tunion"), qvar2string(n));
          return cvtenv;
        }        
        break;
        // terr(loc,"unbound type [x]tunion %s",qvar2string(n));
        // return cvtenv;
      }
      if((*tudp)->is_xtunion != is_x)
	terr(loc,"[x]tunion is different from type declaration %s",
			 qvar2string(n));
      *info = new KnownTunion(tudp);
      fallthru(*tudp);
    case &KnownTunion(&tud):
      // check the region is well-formed
      cvtenv = i_check_valid_type(loc,te,cvtenv,RgnKind,rgn);
      // check the type arguments are well-formed
      list_t<tvar_t> tvs = tud->tvs;
      for (; targs != NULL && tvs != NULL; targs = targs->tl, tvs = tvs->tl) {
	type_t t1 = targs->hd;
	kind_t k1 = tvar_kind(tvs->hd);
	cvtenv = i_check_valid_type(loc,te,cvtenv,k1,t1);
      }
      if (targs != NULL)
	terr(loc,"too many type arguments for tunion %s",
             qvar2string(tud->name));
      if (tvs != NULL) {
        // fill in missing parameters
        list_t<type_t> hidden_ts = NULL;
        for (; tvs != NULL; tvs = tvs->tl) {
          kind_t k1 = tvar_kind(tvs->hd);
          type_t e = new_evar(NULL,NULL);
          hidden_ts = new List(e,hidden_ts);
          cvtenv = i_check_valid_type(loc,te,cvtenv,k1,e);
        }
        *targsp = List::imp_append(*targsp,List::imp_rev(hidden_ts));
      }
      break;
    }
    break;

  case &TunionFieldType(TunionFieldInfo{*info,targs}):
    switch(*info) {
    case &UnknownTunionfield(UnknownTunionFieldInfo(tname,fname,is_x)):
      tuniondecl_t  tud;
      tunionfield_t tuf;
      try *lookup_tuniondecl(te,loc,tname);//FIX lookup_xtuniondecl needed?
      catch { case Dict::Absent:
        terr(loc,"unbound type tunion %s",qvar2string(tname));
      return cvtenv;
      }
      try 
	switch(lookup_ordinary(te,loc,fname)) {
	case &TunionRes(tud2,tuf2):
	  tuf = tuf2;
	  tud = tud2;
	  if(tud->is_xtunion != is_x)
	    terr(loc,"[x]tunion is different from type declaration %s",
                 qvar2string(tname));
	  break;
	default: terr(loc,"unbound field %s in type tunion %s",
                      qvar2string(fname), qvar2string(tname));
          return cvtenv;
        }
      catch {
      case Dict::Absent:
        terr(loc,"unbound field %s in type tunion %s",
             qvar2string(fname), qvar2string(tname));
        return cvtenv;
      }  
      *info = new KnownTunionfield(tud,tuf);
      fallthru(tud,tuf);
    case &KnownTunionfield(tud,tuf):
      // check the type arguments are well-formed
      list_t<tvar_t> tvs = tud->tvs;
      for (; targs != NULL && tvs != NULL; targs = targs->tl, tvs = tvs->tl) {
	type_t t1 = targs->hd;
	kind_t k1 = tvar_kind(tvs->hd);
	cvtenv = i_check_valid_type(loc,te,cvtenv,k1,t1);
      }
      if (targs != NULL)
	terr(loc,"too many type arguments for tunion %s.%s",
             qvar2string(tud->name),qvar2string(tuf->name));
      if (tvs != NULL) 
	terr(loc,"too few type arguments for tunion %s.%s",
             qvar2string(tud->name),qvar2string(tuf->name));
      break;
    }
    break;
  case &PointerType(PtrInfo{.elt_typ=t1,.rgn_typ=rgn_typ,
			    .nullable=nullable,.tq=tq,
                            .bounds=b,.zero_term=zt}):
    // FIX: check that tqual is valid?
    bool is_zero_terminated;
    // note that here, we allow AnyKind types under the pointer
    cvtenv = i_check_valid_type(loc,te,cvtenv,AnyKind,t1);
    cvtenv = i_check_valid_type(loc,te,cvtenv,RgnKind,rgn_typ);
    switch (compress_conref(zt)->v) {
    case No_constr:
      // if zero_term is unconstrained, then set it to false unless
      // we have [signed] char */@/? {n}.
      switch (compress(t1)) {
      case &IntType(_,B1): 
        unify_conrefs(intcmp,zt,true_conref);
        is_zero_terminated = true;
        break;
      default:
        unify_conrefs(intcmp,zt,false_conref);
        is_zero_terminated = false;
        break;
      }
      break;
    case &Eq_constr(true):
      // check that t1 admits zero as an element
      if (!admits_zero(t1))
        terr(loc,"cannot have a pointer to zero-terminated %s elements",
             typ2string(t1));
      is_zero_terminated = true;
      break;
    default:
      is_zero_terminated = false;
      break;
    }
    // check that any bound is a constant expression
    switch (compress_conref(b)->v) {
    case &Eq_constr(&Upper_b(e)): 
      Tcexp::tcExp(te,NULL,e);
      if (!coerce_uint_typ(te,e))
        terr(loc,"pointer bounds expression is not an unsigned int");
      let $(sz,known) = Evexp::eval_const_uint_exp(e); 
      if (is_zero_terminated && (!known || sz < 1))
        terr(loc,"zero-terminated pointer cannot point to empty sequence");
      break;
    default: break;
    }
    break;
  case &SizeofType(t1):
    cvtenv = i_check_valid_type(loc,te,cvtenv,AnyKind,t1);
    break;
  case &TagType(t1):
    cvtenv = i_check_valid_type(loc,te,cvtenv,IntKind,t1);
    break;
  case &TypeInt(_):
  case &IntType(_,_): 
  case FloatType:    
  case &DoubleType(_): break; 
  case &ArrayType(ArrayInfo{t1,tq,e,zt}):
    // FIX: check that tqual is valid?
    // we don't allow abstract mem types as the elt type of an array type
    cvtenv = i_check_valid_type(loc,te,cvtenv,MemKind,t1);
    bool is_zero_terminated;
    switch (compress_conref(zt)->v) {
    case No_constr:
      // if zero_term is unconstrained, then set it to false.
      unify_conrefs(intcmp,zt,false_conref);
      is_zero_terminated = false;
      /* This old code set it to true if we had char for the elt type
       * but this causes too many headaches, so I'm disabling it.
      switch (compress(t1)) {
      case &IntType(_,B1): 
        unify_conrefs(intcmp,zt,true_conref);
        is_zero_terminated = true;
        break;
      default:
        unify_conrefs(intcmp,zt,false_conref);
        is_zero_terminated = false;
        break;
      }
      */
      break;
    case &Eq_constr(true):
      // check that t1 supports 0 as an element
      if (!admits_zero(t1)) 
        terr(loc,"cannot have a zero-terminated array of %s elements",
             typ2string(t1));
      is_zero_terminated = true;
      break;
    default: 
      is_zero_terminated = false;
      break;
    }
    // FIX: should memoize the size so that we don't have to worry about
    // evaluating it during unification
    if(e==NULL)
      terr(loc,"an explicit array bound is required here");
    else {
      Tcexp::tcExp(te,NULL,(exp_t)e);
      if (!is_const_exp(te,(exp_t)e))
        terr(loc,"array bounds expression is not constant");
      if (!coerce_uint_typ(te,(exp_t)e))
        terr(loc,"array bounds expression is not an unsigned int");
      let $(sz,known) = Evexp::eval_const_uint_exp((exp_t)e); 
      // FIX: if we have an unknown size then it might not be zero-terminated!
      if (is_zero_terminated && known && sz < 1)
        warn(loc,"zero terminated array cannot have zero elements");
    }
    break;
  case &FnType(FnInfo{*btvs,*eff,tr,args,c_vararg,cyc_vararg,rgn_po,atts}):
    // This is an unusual and complicated case because (a) we may have to
    // bind type variables here, (b) we may have to calculate the effect.

    // attributes: check that the attributes are function type attributes
    // and that at most one of {stdcall, cdecl, fastcall} is there.
    int  num_convs = 0;
    bool seen_cdecl    = false;
    bool seen_stdcall  = false;
    bool seen_fastcall = false;
    bool seen_format   = false;
    tunion Format_Type ft = Printf_ft;
    int fmt_desc_arg = -1;
    int fmt_arg_start = -1;
    for (; atts != NULL; atts = atts->tl) {
      if (!fntype_att(atts->hd))
	terr(loc,"bad function type attribute %s",attribute2string(atts->hd));
      switch(atts->hd) {
      case Stdcall_att: 
	if(!seen_stdcall)  { seen_stdcall=true;  ++num_convs;} break;
      case Cdecl_att: 
	if(!seen_cdecl)    { seen_cdecl=true;    ++num_convs;} break;
      case Fastcall_att:
	if(!seen_fastcall) { seen_fastcall=true; ++num_convs;} break;
      case &Format_att(fmttype,i,j):
        if (!seen_format)  { 
          seen_format = true; 
	  ft = fmttype; 
          fmt_desc_arg = i; 
	  fmt_arg_start = j;
        } else 
          terr(loc,"function can't have multiple format attributes");
        break;
      default: break;
      }
    }
    if(num_convs > 1)
      terr(loc,"function can't have multiple calling conventions");

    // bound type variables (we may add more) -- 
    // check unique, disallow MemKind, and add to cvtenv.kind_env.
    check_unique_tvars(loc,*btvs);
    for (_ b = *btvs; b != NULL; b = b->tl) {
      b->hd->identity = new_tvar_id();
      cvtenv.kind_env = add_bound_tvar(cvtenv.kind_env,b->hd);
      switch (compress_kb(b->hd->kind)) {
      case &Eq_kb(MemKind):
	terr(loc,"function attempts to abstract Mem type variable %s",
	     *b->hd->name); break;
      default: break;
      }
    }

    // We use a fresh environment here so that we only track the free type
    // vars (and evars) of the function type in case we have to abstract them.
    let new_cvtenv = 
      CVTEnv{cvtenv.kind_env,NULL,NULL,cvtenv.generalize_evars,true};

    // results and arguments of functions cannot be abstract mem types
    // FIX?: should check that variables are unique and that tquals are ok
    new_cvtenv = i_check_valid_type(loc,te,new_cvtenv,MemKind,tr);
    new_cvtenv.fn_result = false;
    for (_ a = args; a != NULL; a = a->tl)
      new_cvtenv = i_check_valid_type(loc,te,new_cvtenv,MemKind,(*a->hd)[2]);

    // varargs
    if (cyc_vararg != NULL) {
      if (c_vararg) impos("both c_vararg and cyc_vararg"); // sanity
      let VarargInfo{_,_,vt,vi} = *cyc_vararg;
      new_cvtenv = i_check_valid_type(loc,te,new_cvtenv,MemKind,vt);
      // if inject, then check the type is an appropriate [x]tunion
      if (vi)
        switch (compress(vt)) {
        case &TunionType(TunionInfo{&KnownTunion(_),_,_}): break;
        default: terr(loc,"can't inject a non-[x]tunion type"); break;
        }
    }
    // check the format attribute is consistent
    if (seen_format) {
      let num_args = List::length(args);
      if (fmt_desc_arg < 0 || fmt_desc_arg > num_args || fmt_arg_start < 0 || 
          // when no varargs, fmt_arg_start should be 0
          (cyc_vararg == NULL && fmt_arg_start != 0) ||
          (cyc_vararg != NULL && fmt_arg_start != num_args + 1)) // wrong??
        terr(loc,"bad format descriptor");
      else {
        // check that fmt_desc_arg is a string in some region
        let $(_,_,t) = *List::nth(args, fmt_desc_arg - 1);
        //can't use unification because evars aren't properly nailed down yet...
        switch (compress(t)) {
        case &PointerType(PtrInfo{et,_,_,_,b,zt}):
          // FIX:  zero-termination?
          switch ($(compress(et), conref_def((bounds_t)Unknown_b,b))) {
          case $(&IntType(None,B1), Unknown_b): break;
          default: terr(loc,"format descriptor is not a char ? type"); break;
          }
          break;
        default: terr(loc,"format descriptor is not a char ? type"); break;
        }
        if (fmt_arg_start != 0) {
          // check the type of the varargs is either tunion PrintArg or 
          // tunion ScanfArg according to ft.
	  // FIX: shouldn't we just do this once when the declaration is made?
          bool problem;
          switch ($(ft,compress(cyc_vararg->type))) {
          case $(Printf_ft, &TunionType(TunionInfo(&KnownTunion(&tud),_,_))):
	    problem = (qvar_cmp(tud->name,tunion_print_arg_qvar) != 0); break;
	  case $(Scanf_ft,  &TunionType(TunionInfo(&KnownTunion(&tud),_,_))):  
	    problem = (qvar_cmp(tud->name,tunion_scanf_arg_qvar) != 0); break;
	  default: 
	    problem = true; break;
	  }  
          if (problem)
            terr(loc,"format attribute and vararg types don't match");
        }
      }
    }
    // check the region partial order
    // FIX:  we need to ensure there are no circular dependencies...
    //       actually, allow circularities, but forbid effect variables
    for (_ rpo = rgn_po; rpo != NULL; rpo = rpo->tl) {
      let &$(r1,r2) = rpo->hd;
      new_cvtenv = i_check_valid_type(loc,te,new_cvtenv,EffKind,r1);
      new_cvtenv = i_check_valid_type(loc,te,new_cvtenv,RgnKind,r2);
    }
    // finally, the effect -- usually inferred
    if (*eff != NULL)
      new_cvtenv = i_check_valid_type(loc,te,new_cvtenv,EffKind,(*eff)->v);
    else {
      list_t<type_t> effect = NULL;
      // Add in any free region or effect variables to the effect.
      // This is why we need a "new_cvtenv" above -- we only want the
      // type variables that actually occur in the function type 
      // as opposed to elsewhere.
      for (_ tvs = new_cvtenv.free_vars; tvs != NULL; tvs = tvs->tl)
        switch (compress_kb(tvs->hd->kind)) {
        case &Less_kb(*f,RgnKind):
          *f = new Opt(new Eq_kb(RgnKind)); fallthru;
        case &Eq_kb(RgnKind):
          effect = new List(new AccessEff(new VarType(tvs->hd)),effect); break;
        case &Less_kb(*f,EffKind):
          *f = new Opt(new Eq_kb(EffKind)); fallthru;
        case &Eq_kb(EffKind):
          effect = new List(new VarType(tvs->hd),effect); break;
        case &Unknown_kb(*f):
          *f = new Opt(new Less_kb(NULL,AnyKind)); fallthru;
        default:
          // add regions(`a) to the default effect for every type variable `a.
          effect = new List(new RgnsEff(new VarType(tvs->hd)), effect); break;
        }
      // Better add in any evars too:
      for (_ ts = new_cvtenv.free_evars; ts != NULL; ts = ts->tl)
        switch (typ_kind(ts->hd)) {
        case RgnKind: effect = new List(new AccessEff(ts->hd), effect); break;
        case EffKind: effect = new List(ts->hd,                effect); break;
        default:      effect = new List(new RgnsEff(ts->hd),   effect); break;
        }
      *eff = new Opt(new JoinEff(effect)); // used to reverse list (twice)
    }
    // Warn if afterwards any kind is still unconstrained and set it to 
    // BoxKind. In addition, drive any MemKind or AnyKind bounded type
    // variables to BoxKind to ensure that we don't abstract a MemKind variable.
    if (*btvs != NULL)
      for(list_t<tvar_t> bs = *btvs; bs != NULL; bs = bs->tl)
        switch (compress_kb(bs->hd->kind)) {
        case &Unknown_kb(*f): 
          warn(loc,"Type variable %s unconstrained, assuming boxed",
	       *bs->hd->name);
          fallthru(f);
        case &Less_kb(*f,MemKind): fallthru(f);
        case &Less_kb(*f,AnyKind): *f = new Opt(new Eq_kb(BoxKind)); break;
        case &Less_kb(*f,k):       *f = new Opt(new Eq_kb(k));       break;
        case &Eq_kb(MemKind):
	  terr(loc,"functions can't abstract M types"); break;
        default: break;
        }
    // remove the bound vars from the kind environment and the list of free vars
    cvtenv.kind_env = remove_bound_tvars(new_cvtenv.kind_env,*btvs);
    new_cvtenv.free_vars = remove_bound_tvars(new_cvtenv.free_vars,*btvs);
    // add the free vars in to the set of all free vars
    for (_ tvs = new_cvtenv.free_vars; tvs != NULL; tvs = tvs->tl)
      cvtenv.free_vars = fast_add_free_tvar(cvtenv.free_vars,tvs->hd);
    // add the free evars in to the set of all free evars
    for (_ evs = new_cvtenv.free_evars; evs != NULL; evs = evs->tl)
      cvtenv.free_evars = add_free_evar(cvtenv.free_evars,evs->hd);
    break;

  case &TupleType(tq_ts):
    // FIX: check the tquals
    for (; tq_ts != NULL; tq_ts = tq_ts->tl)
      cvtenv = i_check_valid_type(loc,te,cvtenv,MemKind,(*tq_ts->hd)[1]);
    break;

  case &AnonAggrType(k,fs):
    // FIX: this code is mostly duplicated in Tc::tcAggrdecl
    region aprev_rgn {
      list_t<field_name_t,`aprev_rgn> prev_fields = NULL;
      for (; fs != NULL; fs = fs->tl) {
        let &Aggrfield{fn,tq,t,width,atts} = fs->hd;
        if (List::mem(strptrcmp,prev_fields,fn))
          terr(loc,"duplicate field %s",*fn);
        if (strcmp(*fn,"") != 0)
          prev_fields = rnew(aprev_rgn) List(fn,prev_fields);
        cvtenv = i_check_valid_type(loc,te,cvtenv,MemKind,t);
	if(k==UnionA && !bits_only(t))
          // FIX: bad error message when t is a zero-terminated type
	  terr(loc,"union member %s has a non-integral type", *fn);
        check_bitfield(loc,te,t,width,fn);
        check_field_atts(loc,fn,atts);
      }      
    }
    break;

  case &AggrType(AggrInfo(*info,*targs)):
    switch(*info) {
    case &UnknownAggr(k,n):
      aggrdecl_t @ adp;
      try {
	adp = lookup_aggrdecl(te,loc,n);
	*info = new KnownAggr(adp);
      } catch { case Dict::Absent:
	// add as an abstract type declaration
	// FIX: use the correct namespace by examining the qvar_t n
	let ge = Dict::lookup(te->ae,te->ns);
	let ad = new Aggrdecl{k,Extern,n,NULL,NULL,NULL};
	Tc::tcAggrdecl(te,ge,loc,ad);
	adp = lookup_aggrdecl(te,loc,n);
	*info = new KnownAggr(adp);
        // give an error here if targs is non-empty:
        if (*targs != NULL) {
          terr(loc,"declare parameterized type %s before using",
	       qvar2string(n));
          return cvtenv;
        }
        break;
      }
      fallthru(*adp);
    case &KnownAggr(&ad):
      list_t<tvar_t> tvs = ad->tvs;
      list_t<type_t> ts = *targs;
      for (; ts != NULL && tvs != NULL; ts = ts->tl, tvs = tvs->tl) {
	kind_t k = tvar_kind(tvs->hd);
	cvtenv = i_check_valid_type(loc,te,cvtenv,k,ts->hd);
      }
      if (ts != NULL)
	terr(loc,"too many parameters for type %s", qvar2string(ad->name));
      if (tvs != NULL) {
	// add in hidden type parameters
	list_t<type_t> hidden_ts = NULL;
	for (; tvs != NULL; tvs = tvs->tl) {
	  kind_t k = tvar_kind(tvs->hd);
	  type_t e = new_evar(NULL,NULL);
	  hidden_ts = new List(e,hidden_ts);
	  cvtenv = i_check_valid_type(loc,te,cvtenv,k,e);
	}
	*targs = List::imp_append(*targs,List::imp_rev(hidden_ts));
      }
    }
    break;
	
  case &TypedefType(tdn,*targs_ref,*tdopt,*toptp):
    list_t<type_t> targs = *targs_ref;
    // NB: since we called compress *toptp == NULL
    typedefdecl_t td;
    try td = lookup_typedefdecl(te,loc,tdn);
    catch { case Dict::Absent:
      terr(loc,"unbound typedef name %s",qvar2string(tdn));
      return cvtenv;
    }
    *tdopt = td;
    // Make relative name absolute (or replace absolute name with itself)
    tdn[0] = td->name[0];
    list_t<tvar_t> tvs = td->tvs;
    list_t<type_t> ts = targs;
    list_t<$(tvar_t,type_t)@> inst = NULL;
    // check type arguments
    for (; ts != NULL && tvs != NULL; ts = ts->tl, tvs = tvs->tl) {
      kind_t k = tvar_kind(tvs->hd);
      cvtenv = i_check_valid_type(loc,te,cvtenv,k,ts->hd);
      inst = new List(new $(tvs->hd,ts->hd),inst);
    }
    if (ts != NULL)
      terr(loc,"too many parameters for typedef %s",qvar2string(tdn));
    if (tvs != NULL) {
      list_t<type_t> hidden_ts = NULL;
      // too few parameters -- plug them in for the user using evars
      for (; tvs != NULL; tvs = tvs->tl) {
        kind_t k = tvar_kind(tvs->hd);
        type_t e = new_evar(NULL,NULL);
        hidden_ts = new List(e,hidden_ts);
        cvtenv = i_check_valid_type(loc,te,cvtenv,k,e);
        inst = new List(new $(tvs->hd,e),inst);
      }
      // add the hidden type arguments back in so error messages are decent
      *targs_ref = List::imp_append(targs,List::imp_rev(hidden_ts));
    }
    if (td->defn != NULL) {
      type_t new_typ = substitute(inst,td->defn->v);
      *toptp = new Opt(new_typ);
    }
    break;
  case HeapRgn: break;
  case &RgnHandleType(t2): fallthru(t2);
  case &AccessEff(t2):
    cvtenv = i_check_valid_type(loc,te,cvtenv,RgnKind,t2); break;
  case &RgnsEff(t2):
    cvtenv = i_check_valid_type(loc,te,cvtenv,AnyKind,t2); break;
  case &JoinEff(ts):
    for (; ts != NULL; ts = ts->tl)
      cvtenv = i_check_valid_type(loc,te,cvtenv,EffKind,ts->hd);
    break;
  } 
  if (!kind_leq(typ_kind(t), expected_kind))
    terr(loc,"type %s has kind %s but as used here needs kind %s",
         typ2string(t), kind2string(typ_kind(t)), kind2string(expected_kind));
  return cvtenv;
}

static cvtenv_t check_valid_type(seg_t loc, tenv_t te, 
                                 list_t<tvar_t,`H> kind_env, 
                                 kind_t expected_kind, 
                                 bool generalize_evars,
                                 type_t t) {
  let cvt = 
    i_check_valid_type(loc,te,CVTEnv{kind_env,NULL,NULL,generalize_evars,false},
		       expected_kind,t);

  for (_ vs = cvt.free_vars; vs != NULL; vs = vs->tl)
    cvt.kind_env = fast_add_free_tvar(kind_env,vs->hd);

  // run through the evars and constrain them so that when unified,
  // the resulting type can only have type variables drawn from the
  // kind environment or the set of free type variables mentioned here.
  for (_ evs = cvt.free_evars; evs != NULL; evs = evs->tl)
    switch (compress(evs->hd)) {
    case &Evar(_,_,_,*s): 
      if (*s == NULL)
        *s = new Opt(kind_env); 
      else {
        // constrain to the intersection of the contexts
        let tvs = (*s)->v;
        let result = NULL;
        for (; tvs != NULL; tvs = tvs->tl)
          if (List::mem(fast_tvar_cmp,kind_env,tvs->hd))
            result = new List(tvs->hd,result);
        *s = new Opt(result);
      }
      break;
    default: break;
    }
  return cvt;
}

// Same as check_valid_type except that for function types, we check
// that either the bound type variables are empty (in which case we
// plug them in) or else the free type variables are contained in the
// list of the bound type variables and have the right kinds.
void check_valid_toplevel_type(seg_t loc, tenv_t te, type_t t) {
  bool generalize_evars = is_function_type(t);
  let cvt = check_valid_type(loc, te, NULL, MemKind, generalize_evars, t);
  let free_tvars = cvt.free_vars;
  let free_evars = cvt.free_evars;

  // resolve the kinds of type variables.  If there's a kind that must
  // be less than Mem or Any, make it boxed.  
  for (_ x = free_tvars; x != NULL; x = x->tl)
    switch (compress_kb(x->hd->kind)) {
    case &Unknown_kb(*f):      fallthru(f);
    case &Less_kb(*f,MemKind): fallthru(f);
    case &Less_kb(*f,AnyKind): *f = new Opt(new Eq_kb(BoxKind)); break;
    case &Less_kb(*f,k):       *f = new Opt(new Eq_kb(k));       break;
    case &Eq_kb(MemKind):
      terr(loc,"type variable %s cannot have kind M",tvar2string(x->hd));
      break;
    default: break;
    }

  if (free_tvars != NULL || free_evars != NULL) {
    switch (compress(t)) {
    case &FnType(FnInfo{*btvs,eff,tr,args,c_vararg,cyc_vararg,rgn_po,atts}):
      if (*btvs == NULL) {
        // abstract the free tvars
        *btvs = free_tvars;
        free_tvars = NULL;
      }
      break;
    default: break;
    }
    if (free_tvars != NULL) 
      terr(loc,"unbound type variable %s",*free_tvars->hd->name);
    // we can constrain the region evars to HeapRgn and the 
    // effect evars to the empty effect, but we're out of luck
    // for the type variables.
    if (free_evars != NULL) {
      for (; free_evars != NULL; free_evars = free_evars->tl) {
        type_t e = free_evars->hd;
        switch (typ_kind(e)) {
        case RgnKind: 
          if (!unify(e,HeapRgn)) impos("can't unify evar with heap!");
          break;
        case EffKind: 
          if (!unify(e,empty_effect)) impos("can't unify evar with {}!");
          break;
        default:
          terr(loc,"hidden type variable %s isn't abstracted in type %s",
               typ2string(e), typ2string(t));
          break;
        }
      }
    }
  }
}
    
// Check that the function declaration has a valid type:  all
// we do is build a FnType and then check that it is well-formed
// which has the side effect of giving us the effect and any
// bound type variables.
void check_fndecl_valid_type(seg_t loc,tenv_t te,fndecl_t fd) {
  type_t t = fndecl2typ(fd);
  // this fills in the missing bound type variables and effects
  check_valid_toplevel_type(loc,te,t);
  switch (compress(t)) {
  case &FnType(FnInfo{tvs,effect,_,_,_,_,_,_}):
    fd->tvs = tvs;
    fd->effect = effect;
    break;
  default: impos("check_fndecl_valid_type: not a FnType");
  }
  // check for repeated paramater names (not allowed in C and makes no sense)
  region r {
    check_unique_vars(rmap(r,fst_fdarg,fd->args), loc, 
		      "function declaration has repeated parameter");
  }
  // cache the type on the declaration so we don't have to recompute it
  fd->cached_typ = new Opt(t);
}

// Same as check_valid_type except that we ensure the free type variables
// are drawn from the given set of bound type variables.
void check_type(seg_t loc, tenv_t te, 
                list_t<tvar_t,`H> bound_tvars, 
                kind_t expected_kind, bool allow_evars, type_t t) {
  let cvt = check_valid_type(loc,te,bound_tvars,expected_kind,false,t);
  let free_tvars = remove_bound_tvars(cvt.free_vars, bound_tvars);
  let free_evars = cvt.free_evars;
  for (_ fs = free_tvars; fs != NULL; fs = fs->tl) {
    let ftvn = fs->hd->name;
    terr(loc,"unbound type variable %s in type %s",*ftvn,typ2string(t));
  }
  if (!allow_evars && free_evars != NULL) {
    for (; free_evars != NULL; free_evars = free_evars->tl) {
      type_t e = free_evars->hd;
      switch (typ_kind(e)) {
      case RgnKind: 
        if (!unify(e,HeapRgn)) impos("can't unify evar with heap!");
          break;
      case EffKind: 
        if (!unify(e,empty_effect)) impos("can't unify evar with {}!");
        break;
      default:
        terr(loc,"hidden type variable %s isn't abstracted in type %s",
             typ2string(e), typ2string(t));
        break;
      }
    }
  }
}

void add_tvar_identity(tvar_t tv) {
  if (tv->identity == NULL) 
    tv->identity = new_tvar_id();
}

void add_tvar_identities(list_t<tvar_t> tvs) {
  List::iter(add_tvar_identity,tvs);
}

// Note: we expect lists to be very short.  Otherwise, a hashtable would
// be a better choice.
static void check_unique_unsorted(int (@cmp)(`a,`a), list_t<`a> vs,
				  seg_t loc, 
				  string_t a2string(`a), string_t msg) {
  for(; vs != NULL; vs = vs->tl)
    for(_ vs2 = vs->tl; vs2 != NULL; vs2 = vs2->tl)
      if(cmp(vs->hd, vs2->hd)== 0)
	terr(loc, "%s: %s",msg,a2string(vs->hd));
}

static string_t<`r> strptr2string(string_t<`r> @s) {
  return *s;
}

void check_unique_vars(list_t<var_t,`r> vs, seg_t loc, string_t msg) {
  check_unique_unsorted(strptrcmp,vs,loc,strptr2string,msg);
}

void check_unique_tvars(seg_t loc, list_t<tvar_t> tvs) {
  check_unique_unsorted(tvar_cmp,tvs,loc,tvar2string,"duplicate type variable");
}

// take a list of $(list_t<designator>,`a) things corresponding to a struct.
// ensure the struct is not abstract.
//  * check that each list_t<designator> has exactly one element which is a 
//    FieldName or is empty
//  * match up the correct member of sd->fields with the `a.  If the list
//    is empty, take the first unused field. ?????
//    Bang in the corresponding designator in the des list element
//  * ensure that each field is used exactly once.
// FIX: Pass in a flag to allow multiple field names ??
list_t<$(aggrfield_t,`a)@`r,`r>
resolve_struct_designators(region_t<`r> rgn, seg_t loc,
                           list_t<$(list_t<designator_t>,`a)@> des, 
                           list_t<aggrfield_t> sdfields) {

  // grab all the fields and mark them unused unless the field has an
  // empty name -- these are bitfields for padding and shouldn't be
  // initialized or projected.
  list_t<$(aggrfield_t,bool)@> fields = NULL;
  for(_ sd_fields = sdfields; sd_fields != NULL; sd_fields = sd_fields->tl) {
    if (strcmp(*sd_fields->hd->name,"") != 0)
      fields = new List(new $(sd_fields->hd,false), fields);
  }
  fields = imp_rev(fields);

  // match up each element of des
  list_t<$(aggrfield_t,`a)@`r,`r> ans = NULL;
  for(; des != NULL; des = des->tl) {
    let &$(dl,a) = des->hd;
    if(dl == NULL) {
      // grab first unused
      let fields2 = fields;
      for(; fields2 != NULL; fields2 = fields2->tl)
	if(!(*fields2->hd)[1]) {
	  (*fields2->hd)[1] = true;
	  (*des->hd)[0] = new List(new FieldName((*fields2->hd)[0]->name),NULL);
	  ans = rnew(rgn) List(rnew(rgn) $((*fields2->hd)[0],a), ans);
	  break;
	}
      if(fields2 == NULL)
	terr(loc, "too many arguments to struct");
    } else if(dl->tl != NULL)
      // we don't support multiple designators
      terr(loc, "multiple designators are not supported");
    else
      // find the right field based on the designator
      switch (dl->hd) {
      case &ArrayElement(_): 
	terr(loc, "array designator used in argument to struct");
	break;
      case &FieldName(v):
	let fields2 = fields;
	for(; fields2 != NULL; fields2 = fields2->tl)
	  if(strptrcmp(v,((*fields2->hd)[0])->name) == 0) {
	    if((*fields2->hd)[1])
	      terr(loc, "field %s has already been used as an argument", *v);
	    (*fields2->hd)[1] = true;
	    ans = rnew(rgn) List(rnew(rgn) $((*fields2->hd)[0],a), ans);
	    break;
	  }
	if(fields2 == NULL)
	  terr(loc, "bad field designator %s", *v);
	break;
      }
  }
  
  // make sure we used all the fields
  for(; fields != NULL; fields = fields->tl)
    if(!(*fields->hd)[1]) {
      terr(loc, "too few arguments to struct");
      break;
    }

  return imp_rev(ans);
}

bool is_tagged_pointer_typ_elt(type_t t, type_t@ elt_typ_dest) {
  switch (compress(t)) {
  case &PointerType(PtrInfo{elt_typ,_,_,_,b,_}):
    let b = compress_conref(b);
    switch (compress_conref(b)->v) {
    case &Eq_constr(Unknown_b): 
      *elt_typ_dest = elt_typ; 
      return true;
    case No_constr: 
      b->v = new Eq_constr(Unknown_b); 
      *elt_typ_dest = elt_typ; 
      return true;
    default: return false;
    }
  default: return false;
  }
}

bool is_zero_pointer_typ_elt(type_t t, type_t@ elt_typ_dest) {
  switch (compress(t)) {
  case &PointerType(PtrInfo{elt_typ,_,_,_,_,zt}):
    *elt_typ_dest = elt_typ;
    return conref_def(false,zt);
  default: return false;
  }
}

bool is_tagged_pointer_typ(type_t t) {
  type_t ignore = VoidType;
  return is_tagged_pointer_typ_elt(t, &ignore);
}

// used by address of.  
// Ensure e is an lvalue or function designator.
// Return if &e is const (true for const) and what region e is in (via a type
//    of RgnKind).
// FIX: not sure const is sufficient to prevent assigning to a function
//      designator???
// Type errors should already have been reported, so we often silently return
//   a bogus answer to avoid duplicate errors.
// Note: regions might not be resolved (unification is order-dependent),
//   but that's okay because a later unification will ensure soundness.
// Note: As explained below, if e1 is a FixedArray, then &e1[e2] is only
//   legal if e1 is an lvalue.  This is not true in C, but I need it, at least
//   for now, and I doubt anyone minds.
$(bool,type_t) addressof_props(tenv_t te, exp_t e) {
  // in some situations, the pointer must actually be const
  $(bool,type_t) bogus_ans = $(false, HeapRgn);
  switch (e->r) {
  case &Var_e(q,x):
    // where oh where does my variable live?
    switch(x) {
    case Unresolved_b: 
    case &Funname_b(_): return bogus_ans;
    case &Global_b(vd): 
      switch (compress(e->topt->v)) {
	// arrays cannot be modified
      case &ArrayType(_): return $(true, HeapRgn);
      default: return $(vd->tq.q_const,HeapRgn);
      }
    case &Local_b(vd):  
      switch (compress(e->topt->v)) {
      case &ArrayType(_): return $(true, vd->rgn->v);
      default: 
        vd->escapes = true;
        return $(vd->tq.q_const, vd->rgn->v);
      }
    case &Pat_b(vd):   fallthru(vd);
    case &Param_b(vd): 
      vd->escapes = true;
      return $(vd->tq.q_const, vd->rgn->v);
    }
  case &AggrMember_e(e1,f):
    // we have an unboxed thing, so we inherit e2's region
    // must check that f isn't a bitfield.
    switch (compress(e1->topt->v)) {
    case &AnonAggrType(_,fs):
      let finfo = lookup_field(fs,f);
      if(finfo != NULL && finfo->width != NULL)
	return $(finfo->tq.q_const, addressof_props(te,e1)[1]);
      return bogus_ans;
    case &AggrType(AggrInfo(&KnownAggr(&ad),_)):
      let finfo = lookup_decl_field(ad,f);
      if(finfo != NULL && finfo->width != NULL)
	return $(finfo->tq.q_const, addressof_props(te,e1)[1]);
      return bogus_ans;
    default: return bogus_ans;
    }
  case &AggrArrow_e(e1,f): 
    // we have a boxed thing, so the region is in the pointer-type.
    // must check that f isn't a bitfield. DAN: why?  JGM: because
    // you can't get a pointer to a bitfield in C.
    switch (compress(e1->topt->v)) {
    case &PointerType(PtrInfo{t1,r,_,_,_,_}): 
      struct Aggrfield * finfo;
      switch (compress(t1)) {
      case &AnonAggrType(_,fs): 
	finfo = lookup_field(fs,f); break;
      case &AggrType(AggrInfo(&KnownAggr(&ad),_)):
	finfo = lookup_decl_field(ad,f); break;
      default: return bogus_ans;
      }
      if(finfo != NULL && finfo->width != NULL)
	return $(finfo->tq.q_const, r);
      return bogus_ans;
    default: return bogus_ans;
    }
  case &Deref_e(e1):
    // we have a boxed thing, so the region is in the pointer-type.
    switch (compress(e1->topt->v)) {
    case &PointerType(PtrInfo{_,r,_,tq,_,_}): 
      return $(tq.q_const, r); // FIX: is tq set correctly?
    default: return bogus_ans;
    }

  case &Subscript_e(e1,e2):
    // here we need to figure out whether we've got a boxed thing
    // or not because [] is overloaded for all array kinds, and tuples
    type_t t = compress(e1->topt->v);
    switch (t) {
    case &TupleType(ts):
      // We need an lvalue in this unboxed case whereas "C w/ tuples" wouldn't.
      let $(i,known) = Evexp::eval_const_uint_exp(e2);
      if(!known)
	return bogus_ans;
      let finfo = lookup_tuple_field(ts,i);
      if(finfo != NULL)
	return $((*finfo)[0].q_const, addressof_props(te,e1)[1]);
      return bogus_ans;
    case &PointerType(PtrInfo{t2,r,_,tq,b,_}): 
      return $(tq.q_const,r);
    case &ArrayType(ArrayInfo{_,tq,_,_}): 
      // Actually, this should be impossible since we've surely
      // promoted e1 to a pointer.
      // NOTE: Unlike C, we cannot allow any e1 -- it must be an lvalue.
      // (C doesn't need to know the region and we do!)
      return $(tq.q_const, addressof_props(te,e1)[1]);
    default: return bogus_ans;
    }
  default: 
    terr(e->loc,"unary & applied to non-lvalue");
    return bogus_ans;
  }
}

// Coerce an expression of array type to a pointer type.  In
// certain situations, we undo this coercion, notably when e is
// a string constant or Array_e expression occurring as follows:
//    t x[c] = e
//    {.... e ... }  where the {...} is an Array_e
//    Foo(.... e ....)  where Foo is a struct or [x]tunion with a 
//     corresponding field that has type t 
type_t array_to_ptr(tenv_t te, type_t e_typ, exp_t e) {
  switch (compress(e_typ)) {
  case &ArrayType(ArrayInfo{t,tq,_,zt}):
    let $(_,rgn) = addressof_props(te,e);
    return atb_typ(t,rgn,tq,new Upper_b(e),zt);
  default: 
    return e_typ;
  }
}

// give an error when we can statically tell that the array bounds arent'
// large enough -- if the bounds are unconstrained, set them to i+1.
void check_bound(seg_t loc, unsigned int i, conref_t<bounds_t> b) {
  b = compress_conref(b);
  switch (b->v) {
  case &Eq_constr(Unknown_b): return; // checked dynamically
  case &Eq_constr(&Upper_b(e)):
    let $(j,known) = Evexp::eval_const_uint_exp(e);
    if(known && j <= i)
      terr(loc, "dereference is out of bounds: %d <= %d", j, i);
    return;
  default:
    // constrain the bounds to be i+1
    b->v = new Eq_constr((bounds_t)(new Upper_b(uint_exp(i+1,NULL))));
    return;
  }
}

void check_nonzero_bound(seg_t loc, conref_t<bounds_t> b) {
  check_bound(loc, 0, b);
}

bool is_bound_one(conref_t<bounds_t> b) {
  switch(compress_conref(b)->v) {
  case &Eq_constr(&Upper_b(e)): 
    let $(i,known) = Evexp::eval_const_uint_exp(e);
    return known && i==1;
  default: return false;
  }
}

bool bits_only(type_t t) {
  switch (compress(t)) {
  case VoidType: 
  case &IntType(_,_): 
  case FloatType: 
  case &DoubleType(_): return true;
  case &EnumType(_,_): 
  case &AnonEnumType(_): return false; //could be true but for pattern exhaustion!
  case &ArrayType(ArrayInfo{t,_,_,zero_term}): 
    // can't allow a zero-terminated array to be treated as bits only
    // for initialization purposes
    // FIX: for now, I'm allowing this because otherwise we can't
    // operate with buildlib properly.
    return /*(!conref_def(false,zero_term)) &&*/ bits_only(t);
  case &TupleType(tqs):
    for (; tqs != NULL; tqs = tqs->tl) 
      if (!bits_only((*tqs->hd)[1])) return false;
    return true;
  case &AggrType(AggrInfo(&UnknownAggr(UnionA,_),_)): return true;
  case &AggrType(AggrInfo(&UnknownAggr(StructA,_),_)): return false;
  case &AggrType(AggrInfo(&KnownAggr(&ad),ts)):
    if(ad->kind == UnionA)
      return true;
    if(ad->impl==NULL)
      return false;
    region rgn {
      let inst = List::rzip(rgn,rgn,ad->tvs,ts);
      for (_ fs = ad->impl->fields; fs != NULL; fs = fs->tl)
	if (!bits_only(rsubstitute(rgn,inst,fs->hd->type))) return false;
      return true;
    }
  case &AnonAggrType(_,fs): 
    for (; fs != NULL; fs = fs->tl)
      if (!bits_only(fs->hd->type)) return false;
    return true;
  default: return false;
  }
}

// FIX: there are other expressions we could allow, such as
// &(x->y) or &(x[0]) that we do not support here...
// RENAME
// Actually need to distinguish two kinds of constant expressions, as in ANSI C
// This is now sort of for top-level expressions
static bool cnst_exp(tenv_t te, bool var_okay, exp_t e) {
  switch (e->r) {
  case &Const_e(_):     
  case &Sizeoftyp_e(_): 
  case &Sizeofexp_e(_): 
  case &Offsetof_e(_,_):
  case &Gentyp_e(_,_):  
  case &Enum_e(_,_,_):  
  case &AnonEnum_e(_,_,_): return true;
  case &Var_e(qv,b):
    // NB: top-level function names and arrays are "constant"
    // Ignore unbound variables b/c should be reported elsewhere
    switch (b) {
    case &Funname_b(_): return true;
    case &Global_b(vd):
      switch (compress(vd->type)) {
      case &ArrayType(_): 
      case &FnType(_): return true;
      default: return var_okay;
      }
    case Unresolved_b: return false;
    default: return var_okay;
    }

  case &Conditional_e(e1,e2,e3):
    return (cnst_exp(te,false,e1)
            && cnst_exp(te,false,e2)
            && cnst_exp(te,false,e3));
  case &SeqExp_e(e1,e2):
    return (cnst_exp(te,false,e1) && cnst_exp(te,false,e2));
  case &NoInstantiate_e(e2): fallthru(e2);
  case &Instantiate_e(e2,_):
    return cnst_exp(te,var_okay,e2);
  case &Cast_e(t,e2):
    // FIX:  We cannot allow casts w/ run-time effect b/c C will complain!
    return cnst_exp(te,var_okay,e2);
  case &Address_e(e2): 
    return cnst_exp(te,true,e2);
  case &Comprehension_e(_,e1,e2,_):
    return cnst_exp(te,false,e1) && cnst_exp(te,false,e2);
  case &Array_e(des): fallthru(des);
  case &AnonStruct_e(_,des): fallthru(des);
  case &Struct_e(_,_,des,_):
    for (; des != NULL; des = des->tl)
      if (!cnst_exp(te,false,(*des->hd)[1]))
        return false;
    return true;

  case &Primop_e(p,es): fallthru(es);
  case &Tuple_e(es):    fallthru(es);
  case &Tunion_e(es,_,_):
    for (; es != NULL; es = es->tl)
      if (!cnst_exp(te,false,es->hd))
        return false;
    return true;
  default: return false;
  }
}

bool is_const_exp(tenv_t te, exp_t e) {
  return cnst_exp(te,false,e);
}

static bool fields_support_default(list_t<tvar_t> tvs, list_t<type_t> ts, 
                                   list_t<aggrfield_t> fs);
bool supports_default(type_t t) {
  switch (compress(t)) {
  case VoidType: 
  case &IntType(_,_): 
  case FloatType: 
  case &DoubleType(_): return true;

  case &PointerType(PtrInfo{_,_,nullable,_,bounds,_}):
    switch (compress_conref(bounds)->v) {
    case &Eq_constr(Unknown_b): return true;
    case &Eq_constr(&Upper_b(_)):
      switch (compress_conref(nullable)->v) {
      case &Eq_constr(b): return b;
      default: return false;
      }
    default: return false;
    }

  case &ArrayType(ArrayInfo{t,_,_,_}): return supports_default(t);
  case &TupleType(tqs):
    for (; tqs != NULL; tqs = tqs->tl)
      if (!supports_default((*tqs->hd)[1])) return false;
    return true;
  case &AggrType(AggrInfo(info,ts)):
    let ad = get_known_aggrdecl(info);
    if(ad->impl == NULL) return false;
    if(ad->impl->exist_vars != NULL) return false; // FIX?
    return fields_support_default(ad->tvs, ts, ad->impl->fields);
  case &AnonAggrType(_,fs): return fields_support_default(NULL,NULL,fs);

  case &AnonEnumType(_):
  case &EnumType(_,_): return true; // FIX: may not include 0!

  default: return false;
  }
}

static bool fields_support_default(list_t<tvar_t> tvs, list_t<type_t> ts, 
                                   list_t<aggrfield_t> fs) {
  region rgn {
    let inst = List::rzip(rgn,rgn,tvs,ts);
    for (; fs != NULL; fs = fs->tl) {
      type_t t = rsubstitute(rgn,inst,fs->hd->type);
      if (!supports_default(t)) return false;
    }
  }
  return true;
}

// returns true if "0" is a value in the type.  Used for checking
// the well-formedness of zero-terminated array and pointer types.
// Currently, only integral types and thin pointers support this.
bool admits_zero(type_t t) {
  switch (compress(t)) {
  case &IntType(_,_): 
  case FloatType: 
  case &DoubleType(_): return true;
  case &PointerType(PtrInfo{_,_,nullable,_,bounds,_}):
    switch (compress_conref(bounds)->v) {
      // for now, we're not allowing fat pointers to be in zero-terminated
      // arrays.  They cause way too many problems in the translation and
      // are of dubious use (I hope.)
    case &Eq_constr(Unknown_b): return false; 
    case &Eq_constr(&Upper_b(_)):
      switch (compress_conref(nullable)->v) {
      case &Eq_constr(b): return b;
      default: return false;
      }
    default: return false;
    }
  default: return false;
  }
}

bool is_noreturn(type_t t) {
  switch (compress(t)) {
  case &PointerType(PtrInfo{elt,_,_,_,_,_}): return is_noreturn(elt);
  case &FnType(FnInfo{_,_,_,_,_,_,_,atts}):
    for (; atts != NULL; atts = atts->tl)
      switch (atts->hd) {
      case Noreturn_att: return true;
      default: continue;
      }
    break;
  default: break;
  }
  return false;
}
