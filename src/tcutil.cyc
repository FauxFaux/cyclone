/* Utility functions for type checking.
   Copyright (C) 2001 Greg Morrisett, AT&T
   This file is part of the Cyclone compiler.

   The Cyclone compiler is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   The Cyclone compiler is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with the Cyclone compiler; see the file COPYING. If not,
   write to the Free Software Foundation, Inc., 59 Temple Place -
   Suite 330, Boston, MA 02111-1307, USA. */

#include <string.h>
#include "absynpp.h"
#include "kinds.h"
#include "warn.h"
#include "flags.h"
#include "evexp.h"
#include "unify.h"
#include "relations-ap.h"
#include "tcutil.h"
#include "attributes.h"
#include "assndef.h"
#include "vcgen.h"
#include "pratt_prover.h"
using Core;
using List;
using Absyn;
using Unify;
namespace Tcutil;

//////////////////////// predicates on types ////////////////////////

// these next few functions are obvious and have no side effects
bool is_void_type(type_t t) {
  switch (compress(t)) {
  case &AppType(&VoidCon,_): return true;
  default: return false;
  }
}
bool is_array_type(type_t t) {
  switch(compress(t)) {
  case &ArrayType(_): return true;
  default: return false;
  }
}
bool is_heap_rgn_type(type_t t) {
  switch (compress(t)) {
  case &AppType(&HeapCon,_): return true;
  default: return false;
  }
}
bool is_pointer_type(type_t t) {
  switch (compress(t)) {
  case &PointerType(_): return true;
  default: return false;
  }
}
// true for any char [signed | unsigned | none]
bool is_char_type(type_t t) {
  switch (compress(t)) {
  case &AppType(&IntCon(_,Char_sz),_): return true;
  default: return false;
  }
}
// true for [signed | unsigned | none] [char | short | int | long | long long]
bool is_any_int_type(type_t t) {
  switch (compress(t)) {
  case &AppType(&IntCon(_,_),_): return true;
  default: return false;
  }
}
// true for [float | double | long double]
bool is_any_float_type(type_t t) {
  switch (compress(t)) {
  case &AppType(&FloatCon(_),_): return true;
  default: return false;
  }
}
// is_any_int_type or tag_t<...> or enum
bool is_integral_type(type_t t) {
  switch (compress(t)) {
  case &AppType(c,_):
    switch (c) {
    case &IntCon(_,_):
    case &TagCon:
    case &EnumCon(_,_):
    case &AnonEnumCon(_): return true;
    default: return false;
    }
  default: return false;
  }
}
bool is_signed_type(type_t t) {
  switch (compress(t)) {
  case &AppType(&IntCon(Signed,_),_): return true;
  case &AppType(&FloatCon(_),_): return true;
  default: return false;
  }
}
bool is_arithmetic_type(type_t t) {
  return is_integral_type(t) || is_any_float_type(t);
}
bool is_strict_arithmetic_type(type_t t) {
  return is_any_int_type(t) || is_any_float_type(t);
}
bool is_tag_type(type_t t) {
  switch (compress(t)) {
  case &AppType(&TagCon,_): return true;
  default: return false;
  }
}
bool is_function_type(type_t t) {
  switch (compress(t)) {
  case &FnType(_): return true;
  default: return false;
  }
}
bool is_typedef_type(type_t t) {
  switch (compress(t)) {
  case &TypedefType(...): return true;
  default: return false;
  }
}
bool is_boxed(type_t t) {
  return type_kind(t)->kind == BoxKind;
}

/////////////////////////////////////////////////////////////
// The following predicates may constrain things as indicated

// side effect: constrains an evar to signed int
bool is_integral(exp_t e) {
  switch (compress((type_t)e->topt)) {
  case &Evar(...): return unify((type_t)e->topt,sint_type);
  case t: return is_integral_type(t);
  }
}

// no side effect here -- not sure why
bool is_numeric(exp_t e) {
  if(is_integral(e))
    return true;
  switch (compress((type_t)e->topt)) {
  case &AppType(&FloatCon(_),_): return true;
  default: return false;
  }
}

// side effect: possibly constrains zero-termination
bool is_zeroterm_pointer_type(type_t t) {
  switch (compress(t)) {
  case &PointerType(PtrInfo{.ptr_atts = PtrAtts{.zero_term = ztl,...},...}):
    return force_type2bool(false, ztl);
  default: return false;
  }
}

// side effect: possibly constrains nullable
bool is_nullable_pointer_type(type_t t, bool def) {
  switch (compress(t)) {
  case &PointerType(PtrInfo{.ptr_atts = PtrAtts{.nullable = nbl,...},...}):
    return force_type2bool(def, nbl);
  default: return false;
  }
}

// side effect: possibly constrains pointer bounds
bool is_fat_ptr(type_t t) {
  switch (compress(t)) {
  case &PointerType(PtrInfo{_,_,PtrAtts(_,_,b,...)}):
    return unify(fat_bound_type, b);
  default: return false;
  }
}

// side effect: possibly constrains bounds to fat.  
// If true, returns element type in elt_type_dest
bool is_fat_pointer_type_elt(type_t t, type_t@ elt_type_dest) {
  switch (compress(t)) {
  case &PointerType(PtrInfo(elt_type,_,PtrAtts(_,_,b,...))):
    if (!unify(b,fat_bound_type)) 
      return false;
    *elt_type_dest = elt_type;
    return true;
  default: return false;
  }
}

// side effect: possibly constrains zeroterm.  
// If true, returns element type in elt_type_dest
bool is_zero_pointer_type_elt(type_t t, type_t@ elt_type_dest) {
  switch (compress(t)) {
  case &PointerType(PtrInfo(elt_type,_,PtrAtts(_,_,_,zt,...))):
    *elt_type_dest = elt_type;
    return type2bool(false,zt);
  default: return false;
  }
}

// side effect: possibly constrains zeroterm
// Return true if t is a zero-terminated pointer or array type and set the
// elt_type and ptr_type as appropriate.
bool is_zero_ptr_type(type_t t, type_t @ptr_type,
		      bool @is_fat, type_t @elt_type) {
  switch (compress(t)) {
  case &PointerType(PtrInfo{elt,_,PtrAtts(_,_,bnds,zt,_,_,_)}):
    if (!type2bool(false,zt))
      return false;
    *ptr_type = t;
    *elt_type = elt;
    switch (compress(bnds)) {
    case &AppType(&FatCon,_): *is_fat = true; break;
    default: *is_fat = false; break;
    }
    return true;
  case &ArrayType(ArrayInfo{elt,tq,n,zt,_}):
    if (!type2bool(false,zt))
      return false;
    *elt_type = elt;
    *is_fat = false;      
    *ptr_type = promote_array(t,heap_rgn_type,al_qual_type,false);
    return true;
  default: return false;
  }
}

// true for fat pointers -- since it calls is_fat_pointer_type_elt
// can end up constraining zeroterm.  I suppose this should only be
// called from toc.cyc where things are fully resolved?
bool is_fat_pointer_type(type_t t) {
  type_t ignore = void_type;
  return is_fat_pointer_type_elt(t, &ignore);
}

// side effect: possibly constrains bounds
bool is_bound_one(ptrbound_t  b) {
  let eopt = get_bounds_exp(bounds_one(),b);
  if (eopt == NULL) return false;
  let $(i,known) = Evexp::eval_const_uint_exp(eopt);
  return known && i==1;
}

// side effect: possibly constrains zero-termination on pointers
bool is_bits_only_type(type_t t) {
  switch (compress(t)) {
  case &AppType(c,ts):
    switch (c) {
    case &VoidCon:
    case &IntCon(_,_):
    case &FloatCon(_):
    case &ComplexCon:
    case &AnonEnumCon(_): 
    case &EnumCon(_,_): return true;//okay b/c enums now don't exhaust patterns

    case &AggrCon({.UnknownAggr = _}): return false;
    case &AggrCon({.KnownAggr = &ad}):
      if(ad->impl==NULL)
	return false;
      region rgn; 
      let inst = List::rzip(rgn,rgn,ad->tvs,ts);
      for (_ fs = ad->impl->fields; fs != NULL; fs = fs->tl)
	if (!is_bits_only_type(rsubstitute(rgn,inst,fs->hd->type))) 
	  return false;
      return true;
    default: return false;
    }
  case &ArrayType(ArrayInfo{t,_,_,zero_term,_}):
    // can't allow a zero-terminated array to be treated as bits only
    // for initialization purposes
    return (!type2bool(false,zero_term)) && is_bits_only_type(t);
  case &AnonAggrType(_,_,fs):
    for (; fs != NULL; fs = fs->tl)
      if (!is_bits_only_type(fs->hd->type)) 
	return false;
    return true;
  default: return false;
  }
}

//fast type-variable comparison -- can only be used when a tvar has an identity.
int fast_tvar_cmp(tvar_t tv1, tvar_t tv2) {
  return (tv1->identity - tv2->identity);
}

static tvar_t copy_tvar(tvar_t tv) {  // NB: loses sharing of identity here!
  return new Tvar(tv->name,-1,Kinds::copy_kindbound(tv->kind),tv->aquals_bound);
}
static $(var_opt_t,tqual_t,type_t)@ copy_arg($(var_opt_t,tqual_t,type_t) @arg) {
  let &$(x,y,t) = arg;
  return new $(x,y,copy_type(t));
}
static $(tqual_t,type_t)@ copy_tqt($(tqual_t,type_t) @arg) {
  return new $((*arg)[0],copy_type((*arg)[1]));
}
static exp_opt_t deep_copy_exp_opt(bool preserve_types, exp_opt_t e) {
  return (e==NULL) ? NULL : deep_copy_exp(preserve_types, e);
}
static aggrfield_t copy_field(aggrfield_t f) {
  return new Aggrfield{f->name,f->tq,copy_type(f->type),f->width,f->attributes,
                       deep_copy_exp_opt(true,f->requires_clause)};
}
static $(type_t,type_t)@ copy_type_pair($(type_t,type_t)@ x) {
  let &$(r1,r2) = x;
  return new $(copy_type(r1),copy_type(r2));
}
static effconstr_t copy_effconstr(effconstr_t fc) {
  switch(fc) {
  case &SingleConstraint(e):
    return new SingleConstraint(copy_type(e));
  case &DisjointConstraint(e1, e2):
    return new DisjointConstraint(copy_type(e1), copy_type(e2)); 
  case &SubsetConstraint(e1, e2):
    return new SubsetConstraint(copy_type(e1), copy_type(e2)); 
  }
}
static type_t tvar2type(tvar_t t) {
  return var_type(copy_tvar(t));
}
static vardecl_opt_t copy_vardecl_opt(vardecl_opt_t vdopt) {
  if (vdopt == NULL) return NULL;
  vardecl_t vd = new *vdopt;
  vd->type = copy_type(vd->type);
  vd->initializer = deep_copy_exp_opt(true,vd->initializer);
  if (vd->rgn != NULL) 
    vd->rgn = copy_type((type_t)vd->rgn);
  return vd;
}

type_t copy_type(type_t t) {
  switch (compress(t)) {
  case &AppType(c,NULL): return t;  // nullary constructors can be shared
  case &AppType(c,ts):   return new AppType(c,map(copy_type,ts));
  case &Evar(...):       return t; //FIX?: introduces constraints -- should it??
  case &VarType(tv):     return var_type(copy_tvar(tv));
  case &PointerType(PtrInfo(elt,tq,PtrAtts(rgn,nbl,bs,zt,loc,rel,aq))):
    let elt2 = copy_type(elt);
    let rgn2 = copy_type(rgn);
    let nbl2 = copy_type(nbl);
    let tq2 = tq;
    // FIX?  Need to copy the expression in here?
    let bs2 = copy_type(bs);
    let zt2 = copy_type(zt);
    let rel2 = copy_type(rel);
    return new PointerType(PtrInfo(elt2,tq2,PtrAtts(rgn2,nbl2,bs2,zt2,loc,rel2,aq)));
  case &ArrayType(ArrayInfo{et,tq,eo,zt,ztl}):
    return new ArrayType(ArrayInfo{copy_type(et),tq,deep_copy_exp_opt(true,eo),
				     copy_type(zt),ztl});
  case &FnType(FnInfo{tvs,effopt,rt_tq,rt,args,c_varargs,cyc_varargs,qb,atts,req,
			req_rlns,ens,ens_rlns,thrws,thrws_rlns,ret_val,argvds,effc}):
    let tvs2 = map(copy_tvar,tvs);
    type_opt_t effopt2 = (effopt == NULL) ? NULL : copy_type(effopt);
    let rt2 = copy_type(rt);
    let args2 = map(copy_arg,args);
    let c_varargs2 = c_varargs;
    vararg_info_t* cyc_varargs2 = (cyc_varargs==NULL) ? NULL : new *cyc_varargs;
    if (cyc_varargs != NULL)
      cyc_varargs2->type = copy_type(cyc_varargs->type);
    let effc2 = map(copy_effconstr, effc);
    let qb2 = map(copy_type_pair,qb);
    let atts2 = atts;
    let req2 = deep_copy_exp_opt(true,req);
    let req_rlns2 = req_rlns;
    let ens2 = deep_copy_exp_opt(true,ens);
    let ens_rlns2 = ens_rlns;
    let thrws2 = deep_copy_exp_opt(true,thrws);
    let thrws_rlns2 = thrws_rlns;
    // we have to create new arg and return-value vardecls and then
    // make sure that the requires, ensures, and throws relations
    // talk about these.  We should *really* substitute within the
    // req/ens/throws expressions to be on the safe side.
    list_t<vardecl_opt_t> argvds2 = List::map(copy_vardecl_opt,argvds);
    vardecl_opt_t ret_val2 = copy_vardecl_opt(ret_val);
    return new FnType(FnInfo{tvs2,effopt2,rt_tq,rt2,args2,c_varargs2,
                               cyc_varargs2,qb2,atts2,req2,req_rlns2,
                               ens2,ens_rlns2,thrws2,thrws_rlns2,ret_val2,
                               argvds2,effc2});
  case &AnonAggrType(k,b,fs): return new AnonAggrType(k,b,map(copy_field,fs));
  case &ValueofType(e):     return new ValueofType(e); // FIX: should copy e
  case &TypeofType(e):      return new TypeofType(e);  // FIX: should copy e
  case &TypedefType(tdn,ts,td,_):
    return new TypedefType(tdn,map(copy_type,ts),td,NULL);
  // For these cases, we don't want to duplicate the definition
  case &TypeDeclType(&{.r = &Aggr_td(ad),...},_):
    let targs = map(tvar2type,ad->tvs);
    return aggr_type(UnknownAggr(ad->kind,ad->name,false),targs);
  case &TypeDeclType(&{.r = &Enum_td(ed),...},_):
    return enum_type(ed->name,NULL);
  case &TypeDeclType(&{.r = &Datatype_td(dd),...},_):
    let targs = map(tvar2type,dd->tvs);
    return datatype_type(UnknownDatatype(UnknownDatatypeInfo{dd->name,false}),targs);
  }
}

// copies an expression and eliminates any typechecking annotations
static designator_t copy_designator(bool preserve_types, designator_t d) {
  switch (d) {
  case &ArrayElement(e): return new ArrayElement(deep_copy_exp(preserve_types,e));
  case &FieldName(_): return d;
  }
}
static $(list_t<designator_t>,exp_t)@
copy_eds(bool preserve_types,$(list_t<designator_t>,exp_t)@ e) {
  return new $(map_c(copy_designator,preserve_types,e[0][0]),
	       deep_copy_exp(preserve_types,e[0][1]));
}
// does a deep copy, but not of vardecls, bindings
exp_t deep_copy_exp(bool preserve_types, exp_t e) {
  let DC = deep_copy_exp;
  exp_t new_e;
  let pt = preserve_types;
  switch (e->r) {
  case &Const_e(c):        new_e = const_exp(c,e->loc);  break;
  case &Var_e(b):          new_e = varb_exp(b,e->loc);   break;
  case &Pragma_e(p):       new_e = pragma_exp(p,e->loc); break;
  case &Primop_e(p, es):   new_e = primop_exp(p, map_c(DC,pt,es),e->loc); break;
  case &Increment_e(e1,i): new_e = increment_exp(DC(pt,e1),i,e->loc);     break;
  case &And_e(e1,e2):      new_e = and_exp(DC(pt,e1),DC(pt,e2),e->loc);   break;
  case &Or_e(e1,e2):       new_e = or_exp (DC(pt,e1),DC(pt,e2),e->loc);   break;
  case &SeqExp_e(e1,e2):   new_e = seq_exp(DC(pt,e1),DC(pt,e2),e->loc);   break;
  case &Conditional_e(e1,e2,e3):
    new_e = conditional_exp(DC(pt,e1),DC(pt,e2),DC(pt,e3),e->loc); break;
  case &AssignOp_e(e1,po,e2):
    new_e=assignop_exp(DC(pt,e1),(po ? new Opt(po->v) : NULL),DC(pt,e2),e->loc);
    break;
  case &FnCall_e(e1,es,&VarargCallInfo(n,is,&VarargInfo(nm,tq,t,i)),resolved):
    new_e = new_exp(new FnCall_e
		    (DC(pt,e1),map_c(DC,pt,es),
		     new VarargCallInfo
		     (n,is,new VarargInfo(nm,tq,copy_type(t),i)),resolved),
		    e->loc);
    break;
  case &FnCall_e(e1,es,vci,resolved): // must follow previous pattern
    new_e=new_exp(new FnCall_e(DC(pt,e1),map_c(DC,pt,es),vci,resolved),e->loc);
    break;
  case &Throw_e(e1,b): 
    new_e = b ? rethrow_exp(DC(pt,e1),e->loc) : throw_exp(DC(pt,e1),e->loc); 
    break;
  case &NoInstantiate_e(e1): 
    new_e = noinstantiate_exp(DC(pt,e1),e->loc); break;
  case &Instantiate_e(e1,ts):
    new_e = instantiate_exp(DC(pt,e1),map(copy_type,ts),e->loc); break;
  case &Cast_e(t,e1,b,c):
    new_e = cast_exp(copy_type(t),DC(pt,e1),b,c,e->loc); break;
  case &New_e(eo,e1,qo):
    new_e = New_exp((eo?(exp_opt_t)DC(pt,eo):NULL), DC(pt,e1), (qo?(exp_opt_t)DC(pt,qo):NULL), e->loc); break;
  case &Address_e(e1):     new_e = address_exp(DC(pt,e1),e->loc);         break;
  case &Sizeoftype_e(t):   new_e = sizeoftype_exp(copy_type(t),e->loc);   break;
  case &Sizeofexp_e(e1):   new_e = sizeofexp_exp(DC(pt,e1),e->loc);       break;
  case &Offsetof_e(t,ofs): new_e = offsetof_exp(copy_type(t),ofs,e->loc); break;
  case &Deref_e(e1):       new_e = deref_exp(DC(pt,e1),e->loc);           break;
  case &Extension_e(e1):   new_e = extension_exp(DC(pt,e1),e->loc);       break;
  case &AggrMember_e(e1,n,f1,f2):
    new_e = new_exp(new AggrMember_e(DC(pt,e1),n,f1,f2),e->loc); break;
  case &AggrArrow_e(e1,n,f1,f2):
    new_e = new_exp(new AggrArrow_e(DC(pt,e1),n,f1,f2),e->loc); break;
  case &Subscript_e(e1,e2): 
    new_e = subscript_exp(DC(pt,e1),DC(pt,e2),e->loc); break;
  case &Array_e(eds):
    new_e = new_exp(new Array_e(map_c(copy_eds,pt,eds)),e->loc); break;
  case &Datatype_e(es,dtd,dtf):
    new_e = new_exp(new Datatype_e(map_c(DC,pt,es),dtd,dtf),e->loc); break;
  case &Comprehension_e(vd,e1,e2,b):
    new_e = new_exp(new Comprehension_e(vd,DC(pt,e1),DC(pt,e2),b),e->loc);break;
  case &ComprehensionNoinit_e(e,t,b):
    new_e = new_exp(new ComprehensionNoinit_e(DC(pt,e),copy_type(t),b),e->loc);
    break;
  case &Aggregate_e(n,ts,eds,agr):
    new_e = new_exp(new Aggregate_e(n,map(copy_type,ts),map_c(copy_eds,pt,eds),agr),
		   e->loc);
    break;
  case &AnonStruct_e(topt,b,eds):
    type_opt_t new_topt = NULL;
    if (topt != NULL) {
      new_topt = copy_type((type_t)topt);
    }
    new_e = new_exp(new AnonStruct_e(new_topt,b,map_c(copy_eds,pt,eds)),e->loc);
    break;
  case &CompoundLit_e(&$(vopt,tq,t),eds):
    new_e = new_exp(new CompoundLit_e(new $(vopt,tq,copy_type(t)),
				     map_c(copy_eds,pt,eds)),e->loc);
    break;
  case &Enum_e(ed,ef): new_e = e; break;
  case &AnonEnum_e(t,ef):
    new_e = new_exp(new AnonEnum_e(copy_type(t),ef),e->loc); break;
  case &Malloc_e(MallocInfo(mk,r,q,t,n,res,inlc)):
    exp_t     e2 = copy_exp(e);
    exp_opt_t r1 = r; if (r != NULL) r1 = DC(pt,r);
    exp_opt_t q1 = q; if (q != NULL) q1 = DC(pt,q);
    type_t *  t1 = t; if (t != NULL) t1 = new copy_type(*t);
    e2->r = new Malloc_e(MallocInfo(mk,r1,q1,t1,n,res,inlc));
    new_e = e2;
    break;
  case &Swap_e(e1,e2): new_e = swap_exp(DC(pt,e1),DC(pt,e2),e->loc); break;
  case &UnresolvedMem_e(nopt,eds):
    opt_t<typedef_name_t> nopt1 = nopt;
    if (nopt != NULL) nopt1 = new Opt(nopt->v);
    new_e = new_exp(new UnresolvedMem_e(nopt1,map_c(copy_eds,pt,eds)),e->loc);
    break;
  case &StmtExp_e(_):
    throw new Core::Failure("deep_copy: statement expressions unsupported");
  case &Tagcheck_e(e1, fn): 
    new_e = new_exp(new Tagcheck_e(DC(pt,e1),fn),e->loc); break;
  case &Valueof_e(t):     new_e = valueof_exp(copy_type(t),e->loc); break;
  case &Asm_e(v,t,o,i,c): new_e = asm_exp(v,t,o,i,c,e->loc); break;
  case &Assert_e(e1):     new_e = assert_exp(e1,e->loc); break;
  case &Assert_false_e(e1): new_e = assert_false_exp(e1,e->loc); break;
  }
  // types/annotations are shared
  if (preserve_types) {
    new_e->topt = e->topt;
    new_e->annot = e->annot;
  }
  return new_e;
}

// figures out the kind of a field in a struct or union; used
// by type_kind below
static kind_t field_kind(type_t field_type,
			 list_t<type_t> ts, list_t<tvar_t> tvs) {
  kind_t k = type_kind(field_type);
  if (ts != NULL && k == &Kinds::ak) {
    // we have to substitute here, because the last type might be
    // instantiated with a ground type.
    region r;
    let inst = NULL;
    // filter out type vars that aren't abstract or int in in the instantiation
    for (; tvs != NULL; tvs=tvs->tl, ts=ts->tl) {
      let tv = tvs->hd;
      let t = ts->hd;
      switch (Kinds::tvar_kind(tv,&Kinds::bk)->kind) {
      case IntKind:
      case AnyKind: inst = rnew(r) List(rnew(r) $(tv,t), inst); break;
      default: break;
      }
    }
    if (inst != NULL) {
      field_type = rsubstitute(r,imp_rev(inst),field_type);
      k = type_kind(field_type);
    }
  }
  return k;
}

// Return the "least" kind of a type, according to the lattice above
// In some situations, we have to be conservative...
// Note that both Evars and VarTypes should have their kinds established
// by this point.
kind_t type_kind(type_t t) {
  // FIX: we're assuming sizeof(int) = sizeof(long) = sizeof(void *) here
  switch (compress(t)) {
  case &Evar(k,...):    return k->v;
  case &VarType(tv):    return Kinds::tvar_kind(tv,&Kinds::bk);
  case &AppType(c,ts):
    switch (c) {
    case &VoidCon:      return &Kinds::mk;
    case &IntCon(_,sz): 
      return (sz==Int_sz || sz==Long_sz) ? &Kinds::bk : &Kinds::mk;
    case &ComplexCon:
    case &FloatCon(_):  return &Kinds::mk;
    case &EnumCon(_,_):
    case &AnonEnumCon(_):
    case &RgnHandleCon:    return &Kinds::bk;
    case &AqualHandleCon:  return &Kinds::bk;
    case &UniqueHeapCon:	   
    case &RefCntHeapCon:	   
    case &HeapCon:         return &Kinds::ek;
    case &BuiltinCon(_,k): return k;
    case &TagCon:          return &Kinds::bk;
    case &JoinCon:
    case &RgnsCon:         return &Kinds::ek;
    case &FalseCon:
    case &TrueCon:         return &Kinds::boolk;
    case &ThinCon:
    case &FatCon:          return &Kinds::ptrbk;
    case &AqualVarCon:
    case &AqualConstCon(_):
    case &AqualsCon: return &Kinds::aqk;
    case &DatatypeCon(...): return &Kinds::ak; // datatypes always have abstract kind
    case &DatatypeFieldCon({.KnownDatatypefield = _}): return &Kinds::mk;
    case &DatatypeFieldCon({.UnknownDatatypefield = _}):
      Warn::impos2("type_kind: Unresolved DatatypeFieldType");
      // for structs or unions without definitions, we must be
      // conservative and treat them as having AnyKind
    case &AggrCon({.UnknownAggr = _}): return &Kinds::ak;
    case &AggrCon({.KnownAggr= & &Aggrdecl(strOrU,_,_,tvs,i,_,expected_mem_kind)}):
      if (i == NULL) 
	return expected_mem_kind ? &Kinds::mk : &Kinds::ak;
      let fields = i->fields;
      if (fields == NULL) return &Kinds::mk;
      // the kind of a struct depends upon the kind of its last field
      if (strOrU == StructA) {
        for (; fields->tl != NULL; fields = fields->tl)
	  ;
        let last_type = fields->hd->type;
        let k = field_kind(last_type, ts, tvs);
        if (k == &Kinds::ak)  return k;
      }
      // the kind of a union depends upon the kind of all its fields
      else
        for (; fields != NULL; fields = fields->tl) {
          let type = fields->hd->type;
          let k = field_kind(type, ts, tvs);
          if (k == &Kinds::ak) return k;
        }
      return &Kinds::mk;
    }
  case &FnType(_):         return &Kinds::ak;
  case &AnonAggrType(_,_,_): return &Kinds::mk;
  case &PointerType(pinfo):
    switch (compress(pinfo.ptr_atts.bounds)) {
    case &AppType(&ThinCon,_):
      return &Kinds::bk;
      // must assume worst case when the bounds are unconstrained
    case &AppType(&FatCon,_):
    default:
      return &Kinds::mk;
    }
  case &ValueofType(_): return &Kinds::ik;
  case &TypeofType(_): 
    // compress should've returned the type of the expression if we know it.
    // if we don't, then we must treat it as abstract.
    return &Kinds::ak; 
  case &ArrayType(ArrayInfo{_,_,num_elts,_,_}):
    if (num_elts == NULL || is_const_exp(num_elts)) return &Kinds::mk;
    return &Kinds::ak;
  case &TypedefType(_,_,td,_):
    if (td == NULL || td->kind == NULL)
      Warn::impos2("type_kind: typedef found: ",t);
    return td->kind->v;
  case &TypeDeclType(&{.r = &Enum_td(_),...},_): return &Kinds::bk;
  case &TypeDeclType(&{.r = &Aggr_td(_),...},_): 
  case &TypeDeclType(&{.r = &Datatype_td(_),...},_): return &Kinds::ak;
  }
}

static type_t rgns_of(type_t);

static type_t rgns_of_field(aggrfield_t af) {
  return rgns_of(af->type);
}

static $(tvar_t,type_t)@ region_free_subst(tvar_t tv) {
  type_t t;
  switch (Kinds::tvar_kind(tv,&Kinds::bk)) {
    //  case &Kind(RgnKind,_):         t = heap_rgn_type;   break;
  case &Kind(EffKind,_):         t = heap_rgn_type;    break;
  case &Kind(IntKind,_):         t = new ValueofType(uint_exp(0,0)); break;
  case &Kind(BoolKind,_):        t = true_type;       break;
  case &Kind(PtrBndKind,_):      t = fat_bound_type;  break;
  default:                       t = sint_type; break; // lives in every kind
  }
  return new $(tv,t);
}

// Calculate the regions of a type and return as an effect -- used
// in normalizing effects.
// NOTE: does a lot of unncecessary allocation (e.g. regions_t<`a> reallocates
//       every time!)
static type_t rgns_of(type_t t) {
  switch (compress(t)) {
  case &AppType(_,NULL): return empty_effect;
  case &AppType(&JoinCon,_): return t;
  case &AppType(_,ts): return normalize_effect(join_eff(map(rgns_of,ts)));
  case &Evar(...):
  case &VarType(_):
    switch (type_kind(t)) {
      //    case &Kind(RgnKind,_): return access_eff(t);
    case &Kind(EffKind,_): return t;
    case &Kind(IntKind,_): return empty_effect;
    default: return regionsof_eff(t);
    }
  case &PointerType(PtrInfo(et,_,PtrAtts(r,...))):
    // ignoring a sizeof(int*`r) in the bounds -- nobody will notice
    return normalize_effect(join_eff(list(r,rgns_of(et))));
  case &ArrayType(ArrayInfo{et,...}):
    return normalize_effect(rgns_of(et));
  case &AnonAggrType(_,_,fs):
    return normalize_effect(join_eff(map(rgns_of_field,fs)));
  case &FnType(FnInfo{tvs,eff,rt_tq,rt,args,_,cyc_varargs,rpo,...}):
    // NOTE:  we define RgnsEff(t) in this case to be the regions in the
    // effect.  So, if the effect is smaller than the argument or return
    // types, they won't show up.  This saves us from a lot of complication
    // with varargs, etc. and should result in a smaller effect.  But it
    // might bite us someday...
    // HACK:  we substitute region-free types for the bound type variables
    // and then compute the regions of that.
    let e = substitute(map(region_free_subst,tvs),(type_t)eff);
    return normalize_effect(e);
  case &TypedefType(_,ts,_,_): // Note: just for abstract typedefs
    return normalize_effect(join_eff(map(rgns_of,ts)));
  case &TypeDeclType(...): Warn::impos2("typedecl in rgns_of");
  case &ValueofType(_): 
  case &TypeofType(_): return empty_effect;
  }
}

// flattens out nested join effects when possible
// -- this has a side effect on the actual type when possible to
// memoize the computation.
static type_t normalize_effect_dups(type_t e) {
  e = compress(e);
  switch (e) {
  case &AppType(&JoinCon,*es):
    bool redo_join = false; // Dan: changed from true
    for (_ effs = *es; effs != NULL; effs = effs->tl) {
      let eff = effs->hd;
      effs->hd = compress(normalize_effect(eff));
      switch (effs->hd) {
      case &AppType(&JoinCon,_):
	//      case &AppType(&AccessCon,&List{&AppType(&HeapCon,_),NULL}):
	/*       case &AppType(&AccessCon,&List{&AppType(&RefCntCon,_),NULL}): */
	/*       case &AppType(&AccessCon,&List{&AppType(&UniqueCon,_),NULL}): */
        redo_join = true; break;
      default: break;
      }
    }
    if (!redo_join) return e;
    list_t<type_t> effects = NULL;
    for (_ effs = *es; effs != NULL; effs = effs->tl)
      switch (compress(effs->hd)) {
      case &AppType(&JoinCon,nested_effs):
        effects = List::revappend(nested_effs,effects); break;
	//      case &AppType(&AccessCon,&List{&AppType(&HeapCon,_),NULL}):
	/*       case &AppType(&AccessCon,&List{&AppType(&RefCntCon,_),NULL}): */
	/*       case &AppType(&AccessCon,&List{&AppType(&UniqueCon,_),NULL}):  */
	//	break;
      case e: effects = new List(e,effects); break;
      }
    *es = List::imp_rev(effects);
    return e;
  case &AppType(&RgnsCon,&List{t,_}): // special cases to avoid allocation
    switch(compress(t)) {
    case &Evar(...):
    case &VarType(_): return e;
    default: return rgns_of(t);
    }
  default: return e;
  }
}
static void imp_remove_dups(int cmp(`a, `a), list_t<`a> l);
type_t normalize_effect(type_t e) {
  e = normalize_effect_dups(e);
  switch(e) {
  case &AppType(&JoinCon, l):
    imp_remove_dups(typecmp, l);
    fallthru;
  default:
    return e;
  }
}

static bool type_equals(type_t t1,  type_t t2) {
  return (typecmp(t1, t2)==0);
}

// Create a dummy type that includes the effect:  void (@`H)(;eff)
static type_t dummy_fntype(type_t eff) {
  let fntype = new FnType(FnInfo{.tvars=NULL,.effect=eff,
                                 .ret_tqual = empty_tqual(0),
                                 .ret_type=void_type,
				 .args=NULL,.c_varargs=false,
                                 .cyc_varargs=NULL,.qual_bnd=NULL,
                                 .attributes = NULL, .requires_clause = NULL,
                                 .requires_assn = NULL,
                                 .ensures_clause = NULL,
                                 .ensures_assn = NULL,
                                 .throws_clause = NULL,
                                 .throws_assn = NULL,
                                 .return_value = NULL,
                                 .arg_vardecls = NULL, 
				 .effconstr = NULL});
  return atb_type(fntype,heap_rgn_type,al_qual_type,empty_tqual(0),bounds_one(),false_type,false_type);
}

// Returns true if the type t is in the effect e t as RgnsEff(t).
// If constrain is true, this might cause evars to become constrained.
// Note that t must either be an evar or a tvar.
bool type_in_effect(bool may_constrain_evars, type_t t, type_t e) {
  t = compress(t);
  e = normalize_effect(compress(e));
  switch (e) {
    //  case &AppType(&AccessCon,_): return false;
  case &AppType(&HeapCon, _):
    if(may_constrain_evars) return unify(t, heap_rgn_type);
    return (typecmp(t, heap_rgn_type) == 0);
  case &AppType(&JoinCon,es):
    for (; es != NULL; es = es->tl)
      if (type_in_effect(may_constrain_evars, t, es->hd))
	return true;
    return false;
  case &AppType(&RgnsCon,&List(t2,_)):
    t2 = compress(t2);
    if (t == t2) return true;
    if (may_constrain_evars) return unify(t,t2);
    switch (rgns_of(t)) {
    case &AppType(&RgnsCon,&List(t3,_)):
      switch ($(compress(t3),t2)) {
      case $(&VarType(tv1),&VarType(tv2)): return unify(t,t2); // ???
      default: return t3 == t2;
      }
    case e2: return type_in_effect(may_constrain_evars,t,e2);
    }
  case &Evar(k,*p,_,s):
    if (k == NULL || k->v->kind != EffKind)
      Warn::impos2("effect evar has wrong kind");
    if (!may_constrain_evars) return false;
    // we found a non-canonical evar -- we can grow it to include t
    // but this may cause problems later on with other constraints.
    let ev = new_evar(&Kinds::eko,s);
    // this has the effect of checking that any free variables in t
    // are contained in s.
    occurs(ev,heap_region,s->v,t);
    let new_typ = join_eff(list(ev,regionsof_eff(t)));
    *p = new_typ;
    return true;
  default: return (typecmp(t, e)==0);
  }
}

// Returns true if the effect type variable v is in the effect e.
// If constrain is true, this might cause effect evars to become constrained.
static bool variable_in_effect(bool may_constrain_evars, tvar_t v, type_t e) {
  e = compress(e);
  switch (e) {
  case &VarType(v2): return (tvar_cmp(v, v2) == 0);
  case &AppType(&JoinCon,es):
    for (; es != NULL; es = es->tl)
      if (variable_in_effect(may_constrain_evars, v, es->hd))
	return true;
    return false;
  case &AppType(&RgnsCon,&List(t,_)):
    switch (rgns_of(t)) {
    case &AppType(&RgnsCon,&List(t2,_)):
      if (!may_constrain_evars) return false;
      switch (compress(t2)) {
      case &Evar(k,*p,_,s):
        // we found regions(ev) where ev is an evar -- set ev to
        // be a dummy type t such that regions(t) = ev2+`e where ev2
        // is a fresh evar.
        let ev = new_evar(&Kinds::eko,s);
        // make sure v is in the allowed set of type variables in the evar
        if (!List::mem(fast_tvar_cmp,s->v,v)) return false;
        *p = dummy_fntype(join_eff(list(ev,var_type(v))));
        return true;
      default: return false;
      }
    case e2: return variable_in_effect(may_constrain_evars,v,e2);
    }
  case &Evar(k,*p,_,s):
    if (k == NULL || k->v->kind != EffKind)
      Warn::impos2("effect evar has wrong kind");
    // we found a non-canonical evar -- we can grow it to include v
    // but this may cause problems later on with other constraints.
    let ev = new_evar(&Kinds::eko,s);
    // make sure v is in the allowed set of type variables for the evar
    if (!List::mem(fast_tvar_cmp,s->v,v))
      return false;
    let new_typ = join_eff(list(ev,var_type(v)));
    *p = new_typ;
    return true;
  default: return false;
  }
}

// Returns true if the effect evar ev is in the effect e.
static bool evar_in_effect(type_t evar, type_t e) {
  e = compress(e);
  switch (e) {
  case &AppType(&JoinCon,es):
    for (; es != NULL; es = es->tl)
      if (evar_in_effect(evar, es->hd))
	return true;
    return false;
  case &AppType(&RgnsCon,&List{t,_}):
    switch (rgns_of(t)) {
    case &AppType(&RgnsCon,&List(t2,_)): return false;
    case e2: return evar_in_effect(evar, e2);
    }
  case &Evar(...): return (evar == e);
  default: return false;
  }
}

//eff is a normalized join effect
static bool unify_effect_component(type_t ev, type_t eff) {
  switch(ev) {
  case &Evar(_,*p,_,s):
    switch(eff) {
    case &AppType(&JoinCon, l):
      for(;l!=NULL;l=l->tl) {
	try {
	  Unify::occurs(ev, heap_region, s->v, l->hd);
	  *p = l->hd;
	  return true;
	}
	catch {
	default:
	  break;
	}
      }
      break;
    default:
      //eff failed an occurs check already; must be a join con
      return false;
    }
    break;
  default:
    Warn::impos("unify_effect_component expects an Evar");
  }
  return false;
}

// Returns true when e1 is a sub-effect of e2 -- this isn't very
// efficient and can constrain both effect and region evars in
// unpredictable ways (though it tries hard not to).
// When set_to_empty is true, evars in e1 that do not occur in (or
// cannot easily be made to occur in) e2 are constrained to the
// empty effect (or HeapRgn for region evars).  This is the "right"
// thing for when a function call needs to constrain the effect to
// an upper bound.  When set_to_empty is false, we instantiate
// unconstrained evars in e1 to be e2.
bool subset_effect(bool may_constrain_evars, type_t e1, type_t e2) {
  // if e2 is of the form JoinEff(ev::rest) where ev is an effect evar,
  // then we can instantiate ev to JoinEff(ev'::e1) where ev' is fresh
  if(e1 == e2) return true;
  e1 = compress(e1);
  switch (e1) {
  case &AppType(&HeapCon, _): //no special treatment of the heap ... want to prevent assignment of `H to `r
    return type_in_effect(may_constrain_evars, e1, e2);
  case &AppType(&JoinCon,es):
    for (; es != NULL; es = es->tl)
      if (!subset_effect(may_constrain_evars,es->hd,e2))
	return false;
    return true;
  case &VarType(v): return variable_in_effect(may_constrain_evars,v,e2);
  case &AppType(&RgnsCon,&List(t,_)):
    switch (rgns_of(t)) {
    case &AppType(&RgnsCon,&List(t2,_)):
      // similar to AccessEff(r) but we're grepping around for RgnsEff(t2)
      // within e2 -- if we don't find it, try unifying something, and
      // failing that, just try to pin it down to something without regions.
      return (type_in_effect(may_constrain_evars,t2,e2) ||
	      (may_constrain_evars && unify(t2,sint_type)));
    case e: return subset_effect(may_constrain_evars,e,e2);
    }
  case &Evar(_,*p,_,s):
    bool evar_occurs = evar_in_effect(e1,e2);
    //if this is not a "unification" call, then evar_occurs does not matter
    if (!may_constrain_evars && evar_occurs) 
      return true; 
    // We can set the evar to be any subset of e2.
    // Right now, we set it to the entire effect
    if(may_constrain_evars && !evar_occurs) {
      e2 = normalize_effect(e2);
      try {
	Unify::occurs(e1, heap_region, s->v, e2);
	*p = (type_opt_t)e2;
	return true;
      } catch {
      default: 
	if(type_in_effect(false, heap_rgn_type, e2)) {
	  *p = (type_opt_t)heap_rgn_type;
	  return true;
	} 
	else {
	  return unify_effect_component(e1, e2);
	}
      }
    }
    return false;
  default: return type_in_effect(may_constrain_evars, e1, e2);
  }
}

//this is used to sort elements of an effect to reach a canonical form
static int cmp_atomic_effect(type_t t1, type_t t2) {
  switch($(compress(t1), compress(t2))) {
  case $(&AppType(&HeapCon, _), _):
    return -1;
  case $(&VarType(_), &AppType(&RgnsCon, _)):
    return -1;
  case $(&VarType(_), &Evar(...)):
    return -1;
  case $(&AppType(&RgnsCon, _), &Evar(...)):
    return -1;
  case $(_, &AppType(&HeapCon, _)):
    return 1;
  case $(&AppType(&RgnsCon, _), &VarType(_)):
    return 1;
  case $(&Evar(...), &VarType(_)):
    return 1;
  case $(&Evar(...), &AppType(&RgnsCon, _)):
    return 1;
  case $(&VarType(tv1), &VarType(tv2)):
    return tv1->identity - tv2->identity;
  case $(&AppType(&RgnsCon, &List{tt1,_}), &AppType(&RgnsCon, &List{tt2,_})):
    let $(rtt1, rtt2) = $(rgns_of(tt1), rgns_of(tt2));
    switch($(rtt1, rtt2)) {
    case $(&AppType(&RgnsCon, &List{ev1, _}), &AppType(&RgnsCon, &List{ev2, _})):
      return cmp_atomic_effect(ev1, ev2);
    default:
      return cmp_atomic_effect(rtt1, rtt2);
    }
  case $(&Evar(_, _, ev1, _), &Evar(_, _, ev2, _)):
    return ev1 - ev2;
  default: 
    Warn::impos2("Cannot canonicalize effects that contain typedefs", t1, t2);
  }
}

//Identifies effects that cannot be coerced into a canonical form
static bool uncanonical_effect(type_t a) {
  switch(a) {
  case &AppType(&HeapCon, _):
  case &VarType(_):
  case &Evar(...): return false;
  case &AppType(&RgnsCon, l):
    return exists(uncanonical_effect, l);
  default:
    return true;
  }
}

//Imperatively canonicalizes a nomalized join effect
//returns false is the effect could not be canonicalized
static bool canonical_join_effect(type_t je) {
  switch(je) {
  case &AppType(&JoinCon, *l):
    if(!exists(uncanonical_effect, *l)) {
      *l = rimp_merge_sort(cmp_atomic_effect, *l);
      return true;
    }
    break;
  default:
    break;
  }
  return false;
}

//transitive closure of effects under the subset relation
static type_opt_t close_rgnof_effect(type_t rgn_of, list_t<effconstr_t,`H> effconstr);
static type_opt_t close_canonical_join(type_t je, list_t<effconstr_t,`H> effconstr);
static type_t close_effect(type_t eff, list_t<effconstr_t,`H> effconstr) {
  eff = normalize_effect(eff);
  switch(eff) {
  case &AppType(&JoinCon, e_lst):
    //first attempt to match the entire join e.g `H+`res+`arg
    _ can = canonical_join_effect(eff);
    if(can) {
      type_opt_t t = close_canonical_join(eff, effconstr);
      if(t != eff)
	return (type_t)t;
    }
    //matching the whole thing failed ... maybe we can match the components
    _ tmplist = NULL;
    for(_ i = e_lst; i != NULL; i = i->tl) {
      tmplist = new List(close_effect(i->hd, effconstr),
			 tmplist);
    }
    return normalize_effect(join_eff(tmplist));
  case &AppType(&RgnsCon, &List{t2, _}):
    let tt = rgns_of(t2);
    switch(tt) {
    case &AppType(&RgnsCon, &List{t22, _}):
      let to = close_rgnof_effect(t2, effconstr);
      return (to != NULL ? to : eff);
    default:
      return tt;
    }
  default: 
    for(_ effc = effconstr; effc!=NULL; effc=effc->tl) {
      switch(effc->hd) {
      case &SubsetConstraint(lhs, rhs):
	if(typecmp(normalize_effect(lhs), eff) == 0) {
	  return close_effect(rhs, effconstr);
	}
	break;
      default:
	break;
      }
    }
    return eff;
  }
}

static type_opt_t close_canonical_join(type_t je, 
				       list_t<effconstr_t,`H> effconstr) {
  for(_ effc = effconstr; effc!=NULL; effc=effc->tl) {
    switch(effc->hd) {
    case &SubsetConstraint(lhs, rhs):
      lhs = normalize_effect(lhs);
      switch(lhs) {
      case &AppType(&JoinCon, _):
	_ can = canonical_join_effect(lhs);
	if(can && (typecmp(lhs, je) == 0)) {
	  return close_effect(rhs, effconstr);
	}
	break;
      default:
	break;
      }
      break;
    default:
      break;
    }
  }
  return je;
}

static type_opt_t close_rgnof_effect(type_t rgnof, list_t<effconstr_t,`H> effconstr) {
  for(;effconstr != NULL; effconstr = effconstr->tl) {
    switch(effconstr->hd) {
    case &SubsetConstraint(lhs, rhs): 
      switch(compress(lhs)) {
      case &AppType(&RgnsCon, &List{t1, _}):
	if(!typecmp(t1, rgnof)) {
	  return close_effect(compress(rhs), effconstr);
	}
	break;
      default:
	break;
      }
      break; 
    default:
      break;
    }
  }
  return NULL;
}
//finds an effect in the capability
bool check_eff_in_cap(seg_t loc, bool may_constrain_evars, type_t eff, 
		      list_t<effconstr_t,`H> effconstr, 
		      type_t cap) {
  eff = compress(eff);
  switch(eff) {
  case &AppType(&RgnsCon, &List{t1, _}):
    switch (rgns_of(t1)) {
    case &AppType(&RgnsCon, &List{t2, _}):
      //close regions(`a) under the equality constraints 
      let e = close_effect(regionsof_eff(t2), effconstr); //stupid allocation ... 
      //and check that the effect is in the capability
      return subset_effect(may_constrain_evars, e, cap);
    case e:
      return subset_effect(may_constrain_evars, e, cap);
    }
  case &AppType(&JoinCon, l) : 
    for(;l != NULL; l = l->tl) {
      //check_eff_in_cap for each elt of l
      if(!check_eff_in_cap(loc, may_constrain_evars, l->hd, effconstr, cap))
	return false;
    }
    return true;
  default: 
    return (subset_effect(may_constrain_evars, eff, cap)  ||
	    subset_effect(may_constrain_evars, close_effect(eff, effconstr), cap));
  }
}
//attempts to prove e by looking for single(e) assertions in the environment env_ec
static bool check_single_constraint(type_t e, list_t<effconstr_t,`H> env_ec) {
  switch(e) {
  case &AppType(&JoinCon, l) : 
    if(List::length(l) == 1) 
      e = l->hd;
    else
      return false;
    break;
  default:
    break;
  }
  for(;env_ec != NULL; env_ec = env_ec->tl) {
    switch(env_ec->hd) {
    case &SingleConstraint(e1):
      if(typecmp(e1, e)==0)
	return true;
      break;
    default: 
      break;
    }
  }
  return false;
}
//crude attempt at provinv e->f0 disjoint from e2 given e->f1
//(the signature is weird because it is used in List::exists_c)
static bool disjoint_effects($(type_t, list_t<effconstr_t>) @e, type_t e2) {
  let &$(e1, env_ec) = e;
  for(; env_ec != NULL; env_ec = env_ec->tl) {
    switch(env_ec->hd) {
    case &DisjointConstraint(f1, f2):
      switch ($(f1, f2)) {
      case $(&AppType(&JoinCon, l1), &AppType(&JoinCon, l2)):
	 if((exists_c(type_equals, e1, l1) && exists_c(type_equals, e2, l2)) ||
	    (exists_c(type_equals, e2, l2) && exists_c(type_equals, e1, l1)))
	   return true;
	 break;
      case $(&AppType(&JoinCon, l1), ff): fallthru(ff, l1);
      case $(ff, &AppType(&JoinCon, l1)):
	if((typecmp(e1, ff)==0 && exists_c(type_equals, e2, l1)) ||
	   (typecmp(e2, ff)==0 && exists_c(type_equals, e1, l1)))
	  return true;
	break;
      default:
	if((typecmp(e1, f1)==0 && typecmp(e2, f2)==0) ||
	   (typecmp(e1, f2)==0 && typecmp(e2, f1)==0))
	  return true;
	break;
      }
      break;
    default:
      break;
    }
  }
  return false;
}
//wrapper to prove e1|e2
static bool check_disjoint_constraint(type_t e1, type_t e2, list_t<effconstr_t> env_ec) {
  switch($(e1,e2)) {
  case $(&AppType(&JoinCon, l1), &AppType(&JoinCon, l2)):
    for(; l1 != NULL; l1 = l1->tl) {
      let env = $(l1->hd, env_ec);
      if(!forall_c(disjoint_effects, &env, l2))
	return false;
    }
    return true;
  case $(&AppType(&JoinCon, l2), _):
    return check_disjoint_constraint(e2, e1, env_ec);
  case $(_, &AppType(&JoinCon, l2)):
    let env = $(e1, env_ec);
    return forall_c(disjoint_effects, &env, l2);
  default: //neither e1 nor e2 are joins
    let env = $(e1, env_ec);
    return disjoint_effects(&env, e2);
  }
}
//prove each constraint in ec given assertions in env_ec
bool satisfies_effect_constraints(seg_t loc, list_t<effconstr_t> ec, list_t<effconstr_t,`H> env_ec) {
  for(;ec != NULL; ec = ec->tl) {
    switch(ec->hd) {
    case &SingleConstraint(e):
      e = compress(e);
      if(!check_single_constraint(e, env_ec) &&
	 !check_single_constraint(close_effect(e, env_ec), env_ec))
	return false;
      break;
    case &DisjointConstraint(e1, e2):
      if(!check_disjoint_constraint(normalize_effect(e1), normalize_effect(e2), env_ec))
	return false;
      break;
    case &SubsetConstraint(e1, e2):  
      if(!subset_effect(false,close_effect(compress(e1),env_ec), compress(e2)))
	return false;
      break;
    }
  }
  return true;
}
//wrapper used from tcexp
type_t evaluate_effect(list_t<effconstr_t,`H> ec, type_t eff) {
  return close_effect(eff, ec);
}
//used to decide if aggrdecls can be merged, or in subtyping for functions
int cmp_effect_constraints(list_t<effconstr_t> ec0, 
			   list_t<effconstr_t> ec1) {
  for(; ec0 != NULL && ec1 != NULL; ec0 = ec0->tl, ec1 = ec1->tl) {
    switch(ec0->hd) {
    case &SingleConstraint(e01):
      switch(ec1->hd) {
      case &SingleConstraint(e11):	
	if(!Unify::unify(e01, e11))
	  return 1;
	break;
      default:
	return 1 ;
      }
      break;
    case &DisjointConstraint(e01, e02):
      switch(ec1->hd) {
      case &DisjointConstraint(e11, e12):
	if(!(Unify::unify(e01, e11) && Unify::unify(e02, e12)))
	  return 1;
	break;
      default:
	return 1;
      }
      break;
    case &SubsetConstraint(e01, e02):
      switch(ec1->hd) { 
      case &SubsetConstraint(e11, e12):
	if(!(Unify::unify(e01, e11) && Unify::unify(e02, e12)))
	  return 1;
	break;
      default:
	return 1;
      }
      break;
    }
  }
  return 0;
}


static int tycon2int(tycon_t t) {
  switch (t) {
  case &IntCon(Unsigned,Char_sz):     return 501;
  case &IntCon(Signed,Char_sz):       return 502;
  case &IntCon(None,Char_sz):         return 503;
  case &IntCon(Unsigned,Short_sz):    return 504;
  case &IntCon(Signed,Short_sz):      return 505;
  case &IntCon(None,Short_sz):        return 506;
  case &IntCon(Unsigned,Int_sz):      return 507;
  case &IntCon(Signed,Int_sz):        return 508;
  case &IntCon(None,Int_sz):          return 509;
  case &IntCon(Unsigned,Long_sz):     return 507;  // NB: treating long == int
  case &IntCon(Signed,Long_sz):       return 508;
  case &IntCon(None,Long_sz):         return 509;
  case &IntCon(Unsigned,LongLong_sz): return 513;
  case &IntCon(Signed,LongLong_sz):   return 514;
  case &IntCon(None,LongLong_sz):     return 515;
  case &FloatCon(0):                  return 516;
  case &FloatCon(1):                  return 517;
  case &FloatCon(_):                  return 518;
  default: return tagof(t);
  }
}
static int type_case_number(type_t t) {
  switch(t) {
  case &AppType(c,_):         return 1000 + tycon2int(c);
  default: return tagof(t);
  }
}
static int star_cmp(int (@cmp)(`a@`r,`a@`r),`a*`r a1, `a*`r a2) {
  if(a1 == a2) return 0;
  if(a1 == NULL && a2 != NULL) return -1;
  if(a1 != NULL && a2 == NULL) return 1;
  return cmp((_@)a1,(_@)a2);
}
static int enumfield_cmp(enumfield_t e1, enumfield_t e2) {
  let qc = qvar_cmp(e1->name,e2->name);
  if(qc != 0) return qc;
  return star_cmp(Evexp::uint_exp_cmp,e1->tag,e2->tag);
}
static qvar_t get_datatype_qvar(datatype_info_t i) {
  switch (i) {
  case {.KnownDatatype = &dd}: return dd->name;
  case {.UnknownDatatype = {.name = n,...}}: return n;
  }
}
static $(qvar_t,qvar_t) get_datatype_field_qvars(datatype_field_info_t i) {
  switch (i) {
  case {.KnownDatatypefield = $(dd,df)}:
    return $(dd->name, df->name);
  case {.UnknownDatatypefield = {.datatype_name = d, .field_name = f,...}}:
    return $(d,f);
  }
}
static $(aggr_kind_t,qvar_t) get_aggr_kind_and_qvar(aggr_info_t i) {
  switch (i) {
  case {.UnknownAggr = $(k,n,_)}: return $(k,n);
  case {.KnownAggr = &ad}: return $(ad->kind,ad->name);
  }
}
int tycon_cmp(tycon_t t1, tycon_t t2) {
  if (t1 == t2) return 0;
  int i1 = tycon2int(t1);
  int i2 = tycon2int(t2);
  if (i1 != i2) return i1 - i2;
  // top-level guaranteed to be the same
  switch $(t1,t2) {
  case $(&EnumCon(n1,_),&EnumCon(n2,_)): return qvar_cmp(n1,n2);
  case $(&BuiltinCon(s1,_),&BuiltinCon(s2,_)): return strcmp(s1,s2);
  case $(&AnonEnumCon(fs1),&AnonEnumCon(fs2)):
    return list_cmp(enumfield_cmp,fs1,fs2);
  case $(&DatatypeCon(info1),&DatatypeCon(info2)):
    return qvar_cmp(get_datatype_qvar(info1),get_datatype_qvar(info2));
  case $(&DatatypeFieldCon(info1),&DatatypeFieldCon(info2)):
    let $(d1,f1) = get_datatype_field_qvars(info1);
    let $(d2,f2) = get_datatype_field_qvars(info2);
    let c = qvar_cmp(d1,d2);
    if (c != 0) return c;
    return qvar_cmp(f1,f2);
  case $(&AggrCon(info1),&AggrCon(info2)):
    let $(k1,q1) = get_aggr_kind_and_qvar(info1);
    let $(k2,q2) = get_aggr_kind_and_qvar(info2);
    let c = qvar_cmp(q1,q2);
    if (c != 0) return c;
    return (int)k1 - (int)k2;
  default: return 0;
  }
}

static int tqual_cmp(tqual_t tq1, tqual_t tq2) {
  let i1 = tq1.real_const + (tq1.q_volatile << 1) + (tq1.q_restrict << 2);
  let i2 = tq2.real_const + (tq2.q_volatile << 1) + (tq2.q_restrict << 2);
  return intcmp(i1,i2);
}
static int tqual_type_cmp($(tqual_t,type_t)@ tqt1, $(tqual_t,type_t)@tqt2) {
  let &$(tq1,t1) = tqt1;
  let &$(tq2,t2) = tqt2;
  let tqc = tqual_cmp(tq1,tq2);
  if(tqc != 0) return tqc;
  return typecmp(t1,t2);
}

int aggrfield_cmp(aggrfield_t f1, aggrfield_t f2) {
  let zsc = strptrcmp(f1->name,f2->name);
  if(zsc != 0) return zsc;
  let tqc = tqual_cmp(f1->tq, f2->tq);
  if(tqc != 0) return tqc;
  let tc = typecmp(f1->type, f2->type);
  if(tc != 0) return tc;
  let ac = list_cmp(Atts::attribute_cmp,f1->attributes, f2->attributes);
  if(ac != 0) return ac;
  ac = star_cmp(Evexp::uint_exp_cmp,f1->width, f2->width);
  if(ac != 0) return ac;
  return star_cmp(Evexp::uint_exp_cmp,f1->requires_clause, f2->requires_clause);
}

// the real work of comparison
// returns -1 if t1 < t2, 0 if ==, 1 if t1 > t2
// error for type not to be closed (?? -- doesn't look like it's a problem)
int typecmp(type_t t1, type_t t2) {
  t1 = compress(t1);
  t2 = compress(t2);
  if (t1 == t2) return 0;
  let shallowcmp = intcmp(type_case_number(t1),type_case_number(t2));
  if(shallowcmp != 0)
    return shallowcmp;

  // guaranteed that top cases are the same
  switch ($(t2,t1)) {
  case $(&AppType(c1,ts1),&AppType(c2,ts2)):
    let c = tycon_cmp(c1,c2);
    if (c != 0) return c;
    return list_cmp(typecmp,ts1,ts2);
  case $(&Evar(...),&Evar(...)):
    return ((int)t1) - ((int)t2);
    //Warn::impos2("typecmp: can only compare closed types");

  case $(&VarType(tv2),&VarType(tv1)):
    // identities should be resolved
    return intcmp(tv1->identity,tv2->identity);

  case $(&PointerType(PtrInfo(t2a,tqual2a,PtrAtts(rgn2,null2a,b2,zt2,_,rel2,aq2))),
	 &PointerType(PtrInfo(t1a,tqual1a,PtrAtts(rgn1,null1a,b1,zt1,_,rel1,aq1)))):
    let etc = typecmp(t1a,t2a);
    if(etc != 0) return etc;
    let rc = typecmp(rgn1,rgn2);
    if(rc != 0) return rc;
    let tqc = tqual_cmp(tqual1a,tqual2a);
    if(tqc != 0) return tqc;
    let cc = typecmp(b1,b2);
    if (cc != 0) return cc;
    let zc = typecmp(zt1,zt2);
    if (zc != 0) return zc;
    let relc = typecmp(rel1,rel2);
    if (relc != 0) return relc;
    let bc = typecmp(b1,b2);
    if (bc != 0) return bc;
    if(aq1 != aq2) return 1;
    return typecmp(null1a,null2a);

  case $(&ArrayType(ArrayInfo{t2a,tq2a,e1,zt1,_}),
         &ArrayType(ArrayInfo{t1a,tq1a,e2,zt2,_})):
    let tqc = tqual_cmp(tq1a,tq2a);
    if(tqc != 0) return tqc;
    let tc = typecmp(t1a,t2a);
    if(tc != 0) return tc;
    let ztc = typecmp(zt1,zt2);
    if (ztc != 0) return ztc;
    if (e1 == e2) return 0;
    if (e1 == NULL || e2 == NULL)
      Warn::impos2("missing expression in array index");
    return star_cmp(Evexp::uint_exp_cmp,e1,e2);

  case $(&FnType(f1), &FnType(f2)):
    if (unify(t1,t2)) return 0;
    int r = typecmp(f1.ret_type,f2.ret_type);
    if (r != 0) return r;
    r = tqual_cmp(f1.ret_tqual,f2.ret_tqual);
    if (r != 0) return r;
    let args1 = f1.args;
    let args2 = f2.args;
    for (; args1 != NULL && args2 != NULL; args1=args1->tl,args2=args2->tl) {
      let $(_,tq1,t1) = *args1->hd;
      let $(_,tq2,t2) = *args2->hd;
      r = tqual_cmp(tq1,tq2);
      if (r != 0) return r;
      r = typecmp(t1,t2);
      if (r != 0) return r;
    }
    if (args1 != NULL) return 1;
    if (args2 != NULL) return -1;
    if (f1.c_varargs && !f2.c_varargs) return 1;
    if (!f1.c_varargs && f2.c_varargs) return -1;
    if (f1.cyc_varargs != NULL && f2.cyc_varargs == NULL) return 1;
    if (f1.cyc_varargs == NULL && f2.cyc_varargs != NULL) return -1;
    if (f1.cyc_varargs != NULL && f2.cyc_varargs != NULL) {
      r = tqual_cmp(f1.cyc_varargs->tq,f2.cyc_varargs->tq);
      if (r != 0) return r;
      r = typecmp(f1.cyc_varargs->type,f2.cyc_varargs->type);
      if (r != 0) return r;
      if (f1.cyc_varargs->inject && !f2.cyc_varargs->inject) return 1;
      if (!f1.cyc_varargs->inject && f2.cyc_varargs->inject) return -1;
    }
    r = star_cmp(typecmp,f1.effect,f2.effect);
    if (r != 0) return r;
/*     let rpo1 = f1.rgn_po; */
/*     let rpo2 = f2.rgn_po; */
/*     for (; rpo1 != NULL && rpo2 != NULL; rpo1=rpo1->tl, rpo2=rpo2->tl) { */
/*       let $(t1a,t1b) = *rpo1->hd; */
/*       let $(t2a,t2b) = *rpo2->hd; */
/*       r = typecmp(t1a,t2a); if (r != 0) return r; */
/*       r = typecmp(t1b,t2b); if (r != 0) return r; */
/*     } */
/*     if (rpo1 != NULL) return 1; */
/*     if (rpo2 != NULL) return -1; */
    if(cmp_effect_constraints(f1.effconstr, f2.effconstr)) 
      return 1;
    r = star_cmp(Evexp::uint_exp_cmp,f1.requires_clause,f2.requires_clause);
    if (r != 0) return r;
    r = star_cmp(Evexp::uint_exp_cmp,f1.ensures_clause,f2.ensures_clause);
    if (r != 0) return r;
    //attribute check was missing previously
    if(Atts::same_atts(f1.attributes, f2.attributes)) {
      // we did unify above, so if the types are actually equal, we
      // should never have gotten here...
      Warn::impos2("typecmp: function type comparison should never get here!");
    }
    return 1;
  case $(&AnonAggrType(k2,_,fs2), &AnonAggrType(k1,_,fs1)):
    if(k1 != k2) 
      return (k1==StructA) ? -1 : 1;
    return list_cmp(aggrfield_cmp,fs1,fs2);

  case $(&ValueofType(e1), &ValueofType(e2)): fallthru(e1,e2);
  case $(&TypeofType(e1),  &TypeofType(e2)):  return Evexp::uint_exp_cmp(e1,e2);
    
  case $(&TypedefType(n1,ts1,_,def1), &TypedefType(n2,ts2,_,def2)):
    if(def1 != NULL && def2 != NULL)
      Warn::impos2("typecmp: compress did not remove typedefs");
    int i = qvar_cmp(n1,n2); if(i != 0) return i;
    return list_cmp(typecmp,ts1,ts2);
  default: Warn::impos2("Unmatched case in typecmp");
  }
}



// we're about to convert a value of type t1 to type t2 (both arithmetic types)
// return true if we will potentially lose precision
static bool will_lose_precision(type_t t1, type_t t2) {
  switch ($(compress(t1),compress(t2))) {
  case $(&AppType(c1,_),&AppType(c2,_)):
    switch $(c1,c2) {
    case $(&FloatCon(i1), &FloatCon(i2)): return i2 < i1;
    case $(&FloatCon(_),  &IntCon(_,_)):
    case $(&FloatCon(_),  &TagCon): return true;
    case $(&IntCon(_,LongLong_sz),  &IntCon(_,LongLong_sz)): return false;
    case $(&IntCon(_,LongLong_sz),  _): return true; // see prev cases

      // FIX:  assuming sizeof(int) = sizeof(long)
    case $(&IntCon(_,Long_sz),  &IntCon(_,Int_sz)):
    case $(&IntCon(_,Int_sz),   &IntCon(_,Long_sz)): return false;

    case $(&IntCon(_,Long_sz),  &FloatCon(0)):
    case $(&IntCon(_,Int_sz),   &FloatCon(0)):
    case $(&IntCon(_,Long_sz),  &IntCon(_,Short_sz)):
    case $(&IntCon(_,Int_sz),   &IntCon(_,Short_sz)):
    case $(&TagCon,             &IntCon(_,Short_sz)):
    case $(&IntCon(_,Long_sz),  &IntCon(_,Char_sz)):
    case $(&IntCon(_,Int_sz),   &IntCon(_,Char_sz)):
    case $(&IntCon(_,Short_sz), &IntCon(_,Char_sz)):
    case $(&TagCon,             &IntCon(_,Char_sz)): return true;

    default: return false;
    }
  default: return false;
  }
}

type_t max_arithmetic_type(type_t t1, type_t t2) {
  switch ($(compress(t1),compress(t2))) {
  case $(&AppType(c1,_),&AppType(c2,_)):
    switch $(c1,c2) {
    case $(&FloatCon(i1),&FloatCon(i2)):
      if (i1!=0 && i1!=1) return t1; // t1 is long double
      if (i2!=0 && i2!=1) return t2; // t2 is long double
      if (i1>=i2) return t1; // t1 is double, or both are float
      return t2;             // t2 is double and t1 is float
    case $(&FloatCon(_),_): return t1;
    case $(_,&FloatCon(_)): return t2;
    case $(&IntCon(Unsigned,LongLong_sz),_):
    case $(_,&IntCon(Unsigned,LongLong_sz)): return ulonglong_type;
    case $(&IntCon(_,LongLong_sz),_):
    case $(_,&IntCon(_,LongLong_sz)): return slonglong_type;
    case $(&IntCon(Unsigned,Long_sz),_):
    case $(_,&IntCon(Unsigned,Long_sz)): return ulong_type;
      // FIX: I don't think these are the right promotion rules
    case $(&TagCon,_):
    case $(_,&TagCon):
    case $(&IntCon(Unsigned,Int_sz),_):
    case $(_,&IntCon(Unsigned,Int_sz)): return uint_type;
    case $(&IntCon(_,Long_sz),_):
    case $(_,&IntCon(_,Long_sz)): return slong_type;
    default: break;
    }
    break;
  default: break;
  }
  return sint_type;
}

// coerce the list e so that each element has type t -- used in arrays and
// conditionals
bool coerce_list(aqualbnds_t aqb, type_t t, list_t<exp_t> es) {
  // find the biggest arithmetic type (if any) for the list and determine
  // if all of the elements are boxed.
  opt_t<type_t> max_arith_type = NULL;
  for (list_t<exp_t> el = es; el != NULL; el = el->tl) {
    type_t t1 = compress((type_t)el->hd->topt);
    if (is_arithmetic_type(t1))
      if (max_arith_type == NULL || will_lose_precision(t1,max_arith_type->v))
	max_arith_type = new Opt(t1);
  }
    // unify the max arithmetic type with the result type t
  if (max_arith_type != NULL)
    if (!unify(t,max_arith_type->v))
      return false; // FIX? Why no error?
  // now coerce each expression to the type t as if by assignment
  for (list_t<exp_t> el = es; el != NULL; el = el->tl)
    if (!coerce_assign(aqb,el->hd,t)) {
      Warn::err2(el->hd->loc,"type mismatch: expecting ",t," but found ",
		 (type_t)el->hd->topt);
      return false;
    }
  return true;
}

// coerce e to have type "bool" (int) -- used in conditionals
// Note: explicit cast is needed only for fat pointers, I think.
bool coerce_to_bool(exp_t e) {
  if (!coerce_sint_type(e))
    switch (compress((type_t)e->topt)) {
    case &PointerType(_): unchecked_cast(e,uint_type,Other_coercion); break;
    default: return false;
    }
  return true;
}

static bool coerce_Xint_type(type_t Xint_type, exp_t e) {
  if (unify((type_t)e->topt,Xint_type))
    return true;
  // try arithmetic conversions -- we only allow integral values
  if (is_integral_type((type_t)e->topt)) {
    if (will_lose_precision((type_t)e->topt,Xint_type))
      Warn::warn2(e->loc,"integral size mismatch; conversion supplied");
    unchecked_cast(e,Xint_type,No_coercion);
    return true;
  }
  return false;
}
// coerce e to have type unsigned int -- used in subscript
bool coerce_uint_type(exp_t e) {
  return coerce_Xint_type(uint_type,e);
}
// coerce e to have type [signed] int -- used in coercions to "bool"
bool coerce_sint_type(exp_t e) {
  return coerce_Xint_type(sint_type,e);
}

// try to constrain the boolean kinded type to desired and then
// convert it the type to a boolean.
bool force_type2bool(bool desired, type_t t) {
  unify(desired ? true_type : false_type, t);
  return type2bool(desired, t);
}

// try to force the pointer-bound-kinded type to a thin{1}
type_t force_bounds_one(type_t t) {
  unify(t, bounds_one());
  return compress(t);
}

exp_t get_thin_bound(list_t<type_t> ts) {
  let t = compress(ts->hd);
  switch (t) {
  case &ValueofType(e): return e;
  default: 
    let v = valueof_exp(t,0);
    v->topt = uint_type;
    return v;
  }
}

// if the pointer bound is thin, returns the expression
// if the pointer bound is fat, returns NULL
// if the pointer bound is an evar, constrains to def
exp_opt_t get_bounds_exp(ptrbound_t def, ptrbound_t b) {
  unify(def,b);
  switch (compress(b)) {
  case &AppType(&FatCon,_):   return NULL;
  case &AppType(&ThinCon,ts): return get_thin_bound(ts);
  default: Warn::impos2("get_bounds_exp: ",b);
  }
}

exp_opt_t get_ptr_bounds_exp(ptrbound_t def, type_t t) {
  switch (compress(t)) {
  case &PointerType(PtrInfo{.ptr_atts = PtrAtts{.bounds = b,...},...}):
    return get_bounds_exp(def, b);
  default: Warn::impos2("get_ptr_bounds_exp not pointer: ",t);
  }
}

// unconstrained boolean-kinded type node
type_t any_bool(list_t<tvar_t,`H> tvs) {
  return new_evar(&Kinds::boolko,new Opt(tvs));
}
// unconstrained pointer bound type node
type_t any_bounds(list_t<tvar_t,`H> tvs) {
  return new_evar(&Kinds::ptrbko,new Opt(tvs));
}

// defined below
static bool ptrsubtype(list_t<$(type_t,type_t)@`H,`H>,
                       type_t, type_t);
static bool effect_subtype(type_t t1, type_t t2, bool) ;

// Can t1 be (implicitly) cast to t2? Assumes types are well-formed
// This is not the same as sub-typing, because we have the opportunity
// to do various coercions.  We only do coercions that don't have
// a failure here.
bool silent_castable(seg_t loc,type_t t1,type_t t2) {
  t1 = compress(t1);
  t2 = compress(t2);
  switch ($(t1,t2)) {
  case $(&PointerType(pinfo_a), &PointerType(pinfo_b)):
    // can coerce @ to *
    if (!unify(pinfo_a.ptr_atts.nullable, pinfo_b.ptr_atts.nullable)
	&& force_type2bool(false,pinfo_a.ptr_atts.nullable))
      return false;
    // can coerce *{e} to ? and *{e1} to *{e2} when e2 <= e1
    if (!unify(pinfo_a.ptr_atts.bounds,pinfo_b.ptr_atts.bounds)) {
      switch $(get_bounds_exp(bounds_one(),pinfo_a.ptr_atts.bounds),
               get_bounds_exp(bounds_one(),pinfo_b.ptr_atts.bounds)) {
      // okay regardless of nullable
      case $(_, NULL): break;

      case $(NULL, _):
        // when zero-terminated can silently cast from ? to *{1}/@{1}
        if (force_type2bool(false,pinfo_a.ptr_atts.zero_term)
            && unify(bounds_one(), pinfo_b.ptr_atts.bounds))
          break;
	return false;
      case $(e1,e2):
        // no need to warn for zero-terminated arrays -- they can get back
        // again (usually).
        // warn so *x = y where y is an array doesn't port too easily
        if (!force_type2bool(false,pinfo_b.ptr_atts.zero_term))
          Warn::warn2(loc, "implicit cast to shorter array");
        if(!Evexp::lte_const_exp((exp_t)e2,(exp_t)e1))
	  return false;
        break;
      }
    }
    // can only move from non-const to const or stay same
    if(pinfo_a.elt_tq.real_const && !pinfo_b.elt_tq.real_const)
      return false;
    // first effect must be a subset of the second
    if (!unify(pinfo_a.ptr_atts.eff,pinfo_b.ptr_atts.eff) &&
	!subset_effect(true, pinfo_a.ptr_atts.eff, pinfo_b.ptr_atts.eff)) {
      return false;
    }
    //must ensure that alias qualifiers are respected
    if(!unify(pinfo_a.ptr_atts.aqual, pinfo_b.ptr_atts.aqual) &&
       !alias_qual_subtype(pinfo_a.ptr_atts.aqual, pinfo_b.ptr_atts.aqual))
      return false;
    // must preserve zero-termination or second pointer must be const
    if(!unify(pinfo_a.ptr_atts.zero_term, pinfo_b.ptr_atts.zero_term)
       && (!force_type2bool(true,pinfo_a.ptr_atts.zero_term)
	   || !pinfo_b.elt_tq.real_const))
      return false;
    // can only move from autoreleased to not autoreleased, or stay the same
    if(!unify(pinfo_a.ptr_atts.autoreleased, pinfo_b.ptr_atts.autoreleased)
       && !force_type2bool(true,pinfo_a.ptr_atts.autoreleased))
      return false;
    // element types have to be equal or t1's element type must be a
    // pointer-sub-type of t2's element type (e.g., t1 = datatype D.C
    // and t2 = datatype D) and the t2 pointer must be const or
    // abstract.  
    //Allow t *`r <: t *`r+`s irrespective of bounds/zero term etc The
    //third arg indicates that only effects in a type are allowed to
    //be subtypes; everything else must unify. This is necessary since
    //the pointer may not be const, or is fat etc.
    if(unify(pinfo_a.elt_type,pinfo_b.elt_type) ||
       effect_subtype(pinfo_a.elt_type,pinfo_b.elt_type, false))
      return true;
    // we can only allow ptrsubtype when the pointer has a bound of
    // 1, is not fat, and is not zero-terminated!
    if(!unify(bounds_one(), pinfo_b.ptr_atts.bounds) 
       || force_type2bool(false,pinfo_b.ptr_atts.zero_term))
      return false;
    if(!pinfo_b.elt_tq.real_const 
       && !Kinds::kind_leq(&Kinds::ak,type_kind(pinfo_b.elt_type)))
      return false;
    return ptrsubtype(NULL,pinfo_a.elt_type,pinfo_b.elt_type);

  case $(&ArrayType(ArrayInfo{t1a,tq1a,e1,zt1,_}),
         &ArrayType(ArrayInfo{t2a,tq2a,e2,zt2,_})):
    if(!unify(zt1,zt2)) return false;
    if(e1==NULL || e2==NULL) return false;
    if(!Evexp::same_uint_const_exp((exp_t)e1,(exp_t)e2)) return false;
    if(!unify(t1a,t2a)) return false;
    // FIX: we need to take qualifiers into account on typedefs
    return (!tq1a.real_const || tq2a.real_const);
  default: return unify(t1,t2);
  }
}

type_t pointer_elt_type(type_t t) {
  switch (compress(t)) {
  case &PointerType(PtrInfo{.elt_type = e,...}): return e;
  default: Warn::impos2("pointer_elt_type");
  }
}
type_t pointer_region(type_t t) {
  switch (compress(t)) {
  case &PointerType(PtrInfo{.ptr_atts = *p,...}): return p->eff;
  default: Warn::impos2("pointer_elt_type");
  }
}

bool rgn_of_pointer(type_t t, type_t @rgn) {
  switch (compress(t)) {
  case &PointerType(PtrInfo{_,_,PtrAtts(r,...)}): *rgn = r; return true;
  default: return false;
  }
}

type_t pointer_aqual(type_t t) {
  switch (compress(t)) {
  case &PointerType(PtrInfo{.ptr_atts = *p,...}): return p->aqual;
  default: Warn::impos2("pointer_elt_type");
  }
}
// returns true if "0" is a value in the type.  Used for checking
// the well-formedness of zero-terminated array and pointer types.
// Currently, only integral types and thin pointers support this.
bool admits_zero(type_t t) {
  switch (compress(t)) {
  case &AppType(&IntCon(_,_),_):
  case &AppType(&FloatCon(_),_): return true;
  case &PointerType(PtrInfo(_,_,PtrAtts(_,nullable,bounds,...))):
      // for now, we're not allowing fat pointers to be in zero-terminated
      // arrays.  They cause way too many problems in the translation and
      // are of dubious use (I hope.)
    return (!unify(fat_bound_type,bounds) && force_type2bool(false,nullable));
  default: return false;
  }
}

// FIX: this is duplicated in toc; but the functions are slightly different
bool is_zero(exp_t e) {
  switch (e->r) {
  case &Const_e({.Int_c = $(_,0)}):
  case &Const_e({.Char_c = $(_,0)}):
  case &Const_e({.Short_c = $(_,0)}):
  case &Const_e({.LongLong_c = $(_,0)}):
  case &Pragma_e(...):   return true;
  case &Const_e({.Wchar_c = s}):
    let l = strlen(s);
    int i = 0;
    if (l>=2 && s[0] == '\\') {
      if (s[1] == '0') i = 2; // octal
      else if (s[1] == 'x' && l>=3 && s[2] == '0') i = 3; // hex
      else return false;
      for (; i<l; i++) // remaining chars must be '0'
        if (s[i] != '0') return false;
      return true;
    }
    return false;
  case &Cast_e(t,e2,_,_): return is_zero(e2) && admits_zero(t);
  default: return false;
  }
}

// if e1 is zero, and t2 a pointer type, changes e1 to NULL and
// returns true if t2 is a nullable pointer type
bool zero_to_null(type_t t2, exp_t e1) {
  if(!is_zero(e1))
    return false;
  switch(compress(t2)) {
  case &PointerType(PtrInfo(_,_,PtrAtts(_,nbl,...))):
    if(!force_type2bool(true,nbl))
      return false;
    e1->r = null_exp(0)->r;
    e1->topt = t2;
    return true;
  default: return false;
  }
}

bool is_aliasable_qual(aqualtype_t aq) {
  switch(compress(aq)) {
  case &AppType(&AqualConstCon(aqv), _):
    return aqv == Aliasable_qual;
  case &AppType(&AqualVarCon, tv_bnd):
    return is_aliasable_qual(tv_bnd->tl->hd);
  default:  
    return false;
  }
}

// returns a triple by doing the following
// (1) gensym's a variable name and creates an expression with that variable
// (2) generates an alias statement that defines that variable as aliasing
// the given expression, using the given tvar as the region
// the bool indicates if the alias coercion has a chance of being succesful
$(decl_t,exp_t,bool) insert_alias(exp_t e, type_t e_type) {
  static datatype KindBound.Eq_kb eff_kb = Eq_kb(&Kinds::ek);
  bool success = true;
  // generate a fresh variable to alias the given expression to
  static int counter = 0;
  qvar_t v = new $(Loc_n, new ((string_t)aprintf("__aliasvar%d",counter++)));
  vardecl_t vd = new_vardecl(0,v,e_type,e);
  exp_t ve = varb_exp(new Local_b(vd),e->loc);
  // generate a fresh region variable for it and make the type
  // of the variable be as close to the instantiated type as we
  // can.  We achieve this by unifying the expected type, which
  // should have an evar for the region of the pointer type, with
  // the new type variable.  
  tvar_t tv = new_tvar(&eff_kb);
  switch (compress(e_type)) {
  case &PointerType(PtrInfo{et,tq,PtrAtts{.eff=old_r,.aqual=aq,...}}):
    switch (compress(old_r)) {
    case &Evar(_,*topt,_,ts): 
      let new_r = var_type(tv);
      *topt = new_r;
      break;
      //this may be a vartype in the case where we have a `r::TR pointer
      //the region outlives rules prevent a (t *`r1::TR) from being cast to a (t *`r2::R)
      //we should allow this somehow ... but for now just bail out here to prevent infinite loop
/*     case &VarType(rtv):       */
/*       switch(rtv->kind) { */
/*       case &Eq_kb(knd): */
/* 	if(knd->aliasqual == Top) { */
/* 	  Warn::err2(e->loc, "Automatic alias coercion of top-kinded pointers not supported"); */
/* 	  success = false; */
/* 	} */
/* 	break; */
/*       default: break; */
/*       } */
/*       break; */
    default:
      break;
    }
    //similarly, alias_qual_subtype rules prevent coercion from RESTRICTED to ALIASABLE
    //So, if we have a RESTRICTED pointer here ... then bail out to prevent infinite loop
    if(!is_aliasable_qual(aq)) { //should have been cast to aliasable by the previous tcfncall
      Warn::err2(e->loc, "Automatic alias coercion of restricted pointers not supported");
      success = false;
    }
    break;
  default: break;
  }
  e->topt = NULL;
  vd->initializer = NULL;

  // generate the alias decl
  decl_t d = alias_decl(tv,vd,e,e->loc);

  return $(d,ve,success);
}

// returns true if we could insert an alias construct around the context
// of the expression with type has_typ to avoid consuming it
static bool can_insert_alias(aqualbnds_t aqb, exp_t e,  type_t e_type,
			     type_t wants_type, seg_t loc) {
  // check if the given expression is a pointer into a no-alias region
  if (is_noalias_path(aqb, e) 
      && is_noalias_pointer(aqb, e_type,false) 
      && is_pointer_type(e_type)) {
    // check if the expected type is has a pointer type into an
    // aliasable region but not the heap region
    switch (compress(wants_type)) {
    case &PointerType(PtrInfo(_,_,PtrAtts(r2,_,_,_,_,_,aq))):
      if (is_heap_rgn_type(r2)) return false;
      let k = type_kind(r2);
      return (k->kind == EffKind && 
	      is_aliasable_qual(aq));
    default: return false;
    }
  }
  return false;
}

// coerce e to have type t -- used in function call and explicit fallthru and assignop
bool coerce_arg(aqualbnds_t aqb, 
		exp_t e, type_t t2, 
		bool *alias_coercion) {
  type_t t1 = compress((type_t)e->topt);
  coercion_t c;
  //do this before unification -- because the region type can change after unification
  bool do_alias_coercion = can_insert_alias(aqb, e,t1, t2, e->loc); 
  // see if types immediately match
  if (unify(t1,t2)) 
    return true;
  // try arithmetic conversions
  if (is_arithmetic_type(t2) && is_arithmetic_type(t1) && !is_tag_type(t1)) {
    // issue a warning if we lose precision
    if (will_lose_precision(t1,t2))
      Warn::warn2(e->loc,"integral size mismatch; ",
		  t1," -> ",t2," conversion supplied");
    unchecked_cast(e,t2,No_coercion);
    return true;
  } 
  // check if we can do an alias coercion; if so, make sure it otherwise
  // typechecks before performing the coercion (for better error reporting).
  if (do_alias_coercion) {//can_insert_alias(e,t1,t2,e->loc)) {
    if (Flags::warn_alias_coerce)
      Warn::warn2(e->loc,"implicit alias coercion for ",e,":",t1," to ",t2);
    if(alias_coercion != NULL)
      *alias_coercion = true;
  }

  if (silent_castable(e->loc,t1,t2)) {
    unchecked_cast(e,t2,Other_coercion);
    return true;
  } 
  if (zero_to_null(t2,e))
    return true;
  if ((c = castable(e->loc,t1,t2)) != Unknown_coercion) {
    // if C supports the conversion, then we don't need the cast.
    if (c != No_coercion) 
      unchecked_cast(e,t2,c);
    if (c != Null_to_NonNull)
      Warn::warn2(e->loc,"implicit cast from ",t1," to ",t2);
    return true;
  }
  return false;
}

// coerce e to have type t -- used in assignment operations.  Neither
// gcc nor VC++ issue warnings for losing precision here, but I think
// it may be appropriate.
bool coerce_assign(aqualbnds_t aqb, exp_t e, type_t t) {
  // even if we can coerce the assignment, we don't bother because
  // the scope will be too small.
  bool bogus = false;
  return coerce_arg(aqb,e,t,&bogus);
}

// FIX:  all of the subtyping stuff needs to be re-examined in the light
// of packed/aligned attributes.  And we'd need to be careful to do this
// in an architecture-dependent way (based on alignement and so forth.)

// Flatten a type into a list of type qualifiers and types for
// use in subtype comparison.
static list_t<$(tqual_t,type_t)@`r,`r> flatten_type(region_t<`r>,bool,type_t);

static list_t<$(tqual_t,type_t)@`r,`r>
  flatten_type_f($(list_t<$(tvar_t,type_t)@`r,`r>,
                  region_t<`r>, bool)@ env,aggrfield_t x){
  let $(inst,r,flatten) = *env;
  let t = (inst == NULL) ? x->type : rsubstitute(r,inst,x->type);
  let ts = flatten_type(r,flatten,t);
  if (List::length(ts) == 1)
    return rnew(r) List{rnew(r) $(x->tq,t),NULL};
  return ts;
}
static list_t<$(tqual_t,type_t)@`r,`r>
  rcopy_tqt($(region_t<`r>,bool)@ env,$(tqual_t,type_t)@ x) {
  let $(r,flatten) = *env;
  let $(tq,t) = *x;
  let ts = flatten_type(r,flatten,t);
  if (List::length(ts) == 1)
    return rnew(r) List{rnew(r) $(tq,t),NULL};
  return ts;
}
static list_t<$(tqual_t,type_t)@`r,`r> 
flatten_type(region_t<`r> r, bool flatten, type_t t1) {
  if (flatten) {
    t1 = compress(t1);
    switch (t1) {
    case &AppType(&VoidCon,_): return NULL;
    case &AppType(&AggrCon({.KnownAggr = &ad}),ts):
      // FIX: too strict with existentials and constraints??
      if(ad->kind==UnionA || ad->impl==NULL
         || ad->impl->exist_vars != NULL || ad->impl->effconstr != NULL)
        return rnew(r) List(rnew(r) $(empty_tqual(0),t1),NULL);
      let inst = List::rzip(r,r,ad->tvs,ts);
      $(list_t<_,`r>,region_t<`r>,bool) env = $(inst,r,flatten);
      switch (ad->impl->fields) {
      case NULL: return NULL;
      case &List{hd,tl}:
        let hd2 = flatten_type_f(&env,hd);
        env[2] = false;
        let tl2 = List::rmap_c(r,flatten_type_f,&env,tl);
        let tts = rnew(r) List{hd2,tl2};
        return List::rflatten(r,tts);
      }
    case &AnonAggrType(StructA,_,fs):
      $(list_t<_,`r>,region_t<`r>,bool) env = $(NULL,r,flatten);
      switch (fs) {
      case NULL: return NULL;
      case &List{hd,tl}:
        let hd2 = flatten_type_f(&env,hd);
        env[2] = false;
        let tl2 = List::rmap_c(r,flatten_type_f,&env,tl);
        let tts = rnew(r) List{hd2,tl2};
        return rflatten(r,tts);
      }
    default: break;
    }
  }
  return rnew(r) List(rnew(r) $(empty_tqual(0),t1),NULL);
}

static bool isomorphic(type_t t1, type_t t2) {
  switch ($(compress(t1),compress(t2))) {
  case $(&AppType(&IntCon(_,b1),_), &AppType(&IntCon(_, b2),_)):
    return b1 == b2 || (b1 == Int_sz && b2 == Long_sz) ||
      (b1 == Long_sz && b2 == Int_sz);
  default: return false;
  }
}

static bool effect_inst_subtype(types_t l1, types_t l2) {
  bool subtypes = true;
  for(;l1 != NULL && l2 != NULL && subtypes; l1 = l1->tl, l2=l2->tl) {
    if(type_kind(l1->hd)==&Kinds::ek && type_kind(l2->hd) == &Kinds::ek) {
      subtypes = subset_effect(false, l1->hd, l2->hd);
    }
    else 
      subtypes = effect_subtype(l1->hd, l2->hd, false);
  }
  if(l1==NULL ^ l2 ==NULL)
    subtypes = false;
  return subtypes;
}

//this allows us to treat foo_t<`a::E> as a subtype of foo_t<`a+`b>
static bool effect_subtype(type_t t1, type_t t2, bool top_level) {
  switch($(compress(t1), compress(t2))){
  case $(&AppType(&AggrCon({.KnownAggr = &ad1}), l1),&AppType(&AggrCon({.KnownAggr = &ad2}), l2)): 
    return ((qvar_cmp(ad1->name, ad2->name)==0) && effect_inst_subtype(l1, l2));
  case $(&AppType(&DatatypeCon({.KnownDatatype = &dd1}), l1), 
	 &AppType(&DatatypeCon({.KnownDatatype = &dd2}), l2)):
    return ((qvar_cmp(dd1->name, dd2->name)==0) && effect_inst_subtype(l1, l2));
  case $(&AppType(&DatatypeFieldCon({.KnownDatatypefield = $(dd1, df1)}), l1),
	 &AppType(&DatatypeFieldCon({.KnownDatatypefield = $(dd2, df2)}), l2)):
    return ((qvar_cmp(dd1->name, dd2->name)==0) && 
	    (qvar_cmp(df1->name, df2->name)==0) && 
	    effect_inst_subtype(l1, l2));
  case $(&AppType(&DatatypeFieldCon({.KnownDatatypefield = $(dd1,df1)}),l1), 
         &AppType(&DatatypeCon({.KnownDatatype = &dd2}), l2)):
    return  (top_level &&
	     (dd1 == dd2 || qvar_cmp(dd1->name,dd2->name) == 0) &&
	     effect_inst_subtype(l1, l2));
  case $(&TypedefType(n1, l1, ...), &TypedefType(n2, l2, ...)): 
    return ((qvar_cmp(n1, n2)==0) && effect_inst_subtype(l1, l2));
  case $(&PointerType(PtrInfo(t_a, q_a, PtrAtts(eff_a,null_a,b_a,zt_a,_,_,aq_a))),
	 &PointerType(PtrInfo(t_b, q_b, PtrAtts(eff_b,null_b,b_b,zt_b,_,_,aq_b)))):
    return (subset_effect(false, eff_a, eff_b) &&
	    effect_subtype(t_a, t_b, false) &&
	    equal_tqual(q_a, q_b) &&  Unify::unify(null_a, null_b) &&
	    Unify::unify(b_a, b_b) && Unify::unify(zt_a, zt_b) &&
	    Unify::unify(aq_a, aq_b));
  default: 
    return (typecmp(t1, t2)==0);
  }
}

// FIX: the subtyping environment needs to take into account the
// qualifiers on the pointers.
bool subtype(list_t<$(type_t,type_t)@`H,`H> assume,
             type_t t1, type_t t2) {
  if (unify(t1,t2)) return true;
  for (_ a = assume; a != NULL; a = a->tl) 
    if (unify(t1,(*a->hd)[0]) && unify(t2,(*a->hd)[1]))
      return true;
  t1 = compress(t1);
  t2 = compress(t2);
  switch ($(t1,t2)) {
    // the following allows us to cast an unsigned int pointer to an int
    // pointer and vice versa.  This is okay because the types are isomorphic.
   case $(&PointerType(PtrInfo(t_a, q_a, PtrAtts(rt_a,null_a,b_a,zt_a,_,rel_a,aq_a))),
          &PointerType(PtrInfo(t_b, q_b, PtrAtts(rt_b,null_b,b_b,zt_b,_,rel_b,aq_b)))):
    // if t1 is const then t2 must be const
    if (q_a.real_const && !q_b.real_const)
      return false;
    // if t1 is * then t2 must be *
    if (!unify(null_a,null_b)
	&& type2bool(false,null_a) && !type2bool(false,null_b))
      return false;
    // if t1 is not zero-terminated, then t2 must not be zero-terminated
    if (unify(zt_a,zt_b)
        && !type2bool(false,zt_a) && type2bool(false,zt_b))
      return false;
    // if t1 is not autoreleased, then t2 must not be autoreleased
    if (unify(rel_a,rel_b)
        && !type2bool(false,rel_a) && type2bool(false,rel_b))
      return false;
    // rt_a must outlive rt_b
    if (!unify(rt_a,rt_b) && !subtype(assume, rt_a, rt_b) &&
	!subset_effect(false, rt_a, rt_b)) {
      return false;
    }
    if (!unify(aq_a, aq_b) && !alias_qual_subtype(aq_a, aq_b) && 
	!subtype(assume, aq_a, aq_b))
      return false;
    // need to check that the bounds match up
    if (!unify(b_a,b_b)) {
      let e1 = get_bounds_exp(bounds_one(),b_a);
      let e2 = get_bounds_exp(bounds_one(),b_b);
      if (e1 != e2)
        if (e1 == NULL || e2 == NULL || !Evexp::lte_const_exp(e2,e2)) 
          return false;
    }
    // check that qualifiers are the same or that t2's is at least const
    // (or it's element type is abstract).
    if (!q_b.real_const && q_a.real_const)
      if (!Kinds::kind_leq(&Kinds::ak,type_kind(t_b)))
        return false;
    // Note, we can only allow ptrsubtype when the second pointer has a
    // bound of 1, is not fat, and is not zero-terminated!
    let deep_subtype = unify(b_b,bounds_one()) && !force_type2bool(false,zt_b);

    // now check that t_a is a pointer sub-type of t_b
    return (deep_subtype && ptrsubtype(new List(new $(t1,t2),assume), t_a, t_b)) || (unify(t_a,t_b)) || isomorphic(t_a,t_b);

  case $(&AppType(&DatatypeFieldCon({.KnownDatatypefield = $(dd1,df)}),ts1), 
         &AppType(&DatatypeCon({.KnownDatatype = &dd2}), ts2)):
    // we're casting a datatype field to a datatype which is okay
    // when they match up.
    // check they're the same datatype
    if (dd1 != dd2 && qvar_cmp(dd1->name,dd2->name) != 0) return false;
    // check that type parameters are the same
    if (List::length(ts1) != List::length(ts2)) return false;
    for (; ts1 != NULL; ts1 = ts1->tl, ts2 = ts2->tl)
      if (!unify(ts1->hd,ts2->hd)) {
	return effect_subtype(t1, t2, true);
      }
    return true;

  case $(&FnType(f1), &FnType(f2)):
    if (f1.tvars != NULL || f2.tvars != NULL) {
      let tvs1 = f1.tvars;
      let tvs2 = f2.tvars;
      if (List::length(tvs1) != List::length(tvs2)) return false;
      list_t<$(tvar_t,type_t)@> inst = NULL;
      while (tvs1 != NULL) {
	if (!unify_kindbound(tvs1->hd->kind, tvs2->hd->kind)) return false;
	inst = new List(new$(tvs2->hd, var_type(tvs1->hd)),inst);
	tvs1 = tvs1->tl;
	tvs2 = tvs2->tl;
      }
      if (inst != NULL) {
	f1.tvars = NULL;
	f2.tvars = NULL;
	return subtype(assume,new FnType(f1),new FnType(f2));
      }
    }
    // covariant subtyping on results
    if (!subtype(assume,f1.ret_type,f2.ret_type)) return false;
    let args1 = f1.args;
    let args2 = f2.args;
    // argument lengths must match?  Perhaps C allows one to call
    // a function with extra arguments?  I don't think so...
    if (List::length(args1) != List::length(args2)) return false;
    // contravariant subtyping on arguments
    for (; args1 != NULL; args1 = args1->tl, args2 = args2->tl) {
      let $(_,tq1,t1) = *args1->hd;
      let $(_,tq2,t2) = *args2->hd;
      // FIX: we need to take any qualifiers into account on typedefs
      // JGM: I'm dropping the assumptions here -- not sure it's sound
      // to include them, and results in bad error messages...
      if ((tq2.real_const && !tq1.real_const) || !subtype(NULL,t2,t1)) 
        return false;
    }
    // deal with varargs
    if (f1.c_varargs != f2.c_varargs) return false;
    if (f1.cyc_varargs != NULL && f2.cyc_varargs != NULL) {
      let v1 = *f1.cyc_varargs;
      let v2 = *f2.cyc_varargs;
      // FIX: we need to take any qualifiers into account on typedefs
      if ((v2.tq.real_const && !v1.tq.real_const) ||
          !subtype(assume,v2.type,v1.type))
        return false;
    } else if (f1.cyc_varargs != NULL || f2.cyc_varargs != NULL) return false;
    // deal with effect
    if (!subset_effect(false,(type_t)f1.effect,(type_t)f2.effect)) return false;
    // deal with region partial order
    if(cmp_effect_constraints(f1.effconstr, f2.effconstr)) return false;
    // deal with attributes that can be dropped
    if (!Atts::sub_attributes(f1.attributes,f2.attributes)) return false;

    // generate list of terms (representing real values of args and memory
    let terms = NULL;
    
    for(let vds = f1.arg_vardecls; vds != NULL; vds = vds->tl) {
      terms = new List {AssnDef::fresh_var(vds->hd==NULL ? NULL:vds->hd->type),terms};
    }
    terms = imp_rev(terms);
    terms = new List {AssnDef::fresh_var(NULL),terms};

    // check f2.requires => f1.requires
    // f1.requires_assn == NULL, then f1.requires_assn = true, 
    // no need to check f2.req => f1.req
    
    if (f1.requires_assn != NULL) {
      let req1 = AssnDef::existassnfn2assn(f1.requires_assn,terms);
      let req2 = f2.requires_assn ? AssnDef::existassnfn2assn(f2.requires_assn,terms) : &AssnDef::true_assn;
      if (!AssnDef::simple_prove(req2,req1) && 
	  !PrattProver::constraint_prove(req2,req1))
	return false;
    }
    // check f1.ensures => f2.ensures
    // f2.ensures_assn == NULL, then f2.ensures_assn = true,
    // no need to check f1.ens => f2.ens
    if (f2.ensures_assn != NULL) {
      let ret_value = AssnDef::fresh_var(f1.return_value->type);
      let terms = new List {ret_value,terms};
      let ens2 = AssnDef::existassnfn2assn(f2.ensures_assn,terms);
      let ens1 = f1.ensures_assn ? AssnDef::existassnfn2assn(f1.ensures_assn,terms) : &AssnDef::true_assn;
      if (!AssnDef::simple_prove(ens1,ens2) && 
	  !PrattProver::constraint_prove(ens1,ens2))
	return false;
    }
    // check f1.throws => f2.throws
    if (f2.throws_assn != NULL) {
      let thrws2 = AssnDef::existassnfn2assn(f2.throws_assn,terms);
      let thrws1 = f1.throws_assn ? AssnDef::existassnfn2assn(f1.throws_assn,terms) : &AssnDef::true_assn;
      if (!AssnDef::simple_prove(thrws1,thrws2) && 
	  !PrattProver::constraint_prove(thrws1,thrws2))
	return false;
    }

    // otherwise okay
    return true;
  default: 
    return effect_subtype(t1, t2, true);
  }
}

// is t1* <= t2*?
//   we flatten t1 and t2 into structurally equivalent tuple types
//   (and thus ignore field names, associativity of nested tuples and
//   structs, etc.) and then check that t1 is a width extension of t2
//   and for each field, either (a) both t1 and t2 have qualifier "const"
//   and the t1 field is a subtype of the t2 field, or (b) t1 = t2.
static bool ptrsubtype(list_t<$(type_t,type_t)@`H,`H> assume, 
		       type_t t1, type_t t2) {
  list_t<$(tqual_t,type_t)@> tqs1 = flatten_type(heap_region,true,t1);
  list_t<$(tqual_t,type_t)@> tqs2 = flatten_type(heap_region,true,t2);
  for (; tqs2 != NULL; tqs2 = tqs2->tl, tqs1 = tqs1->tl) {
    if (tqs1 == NULL) return false;
    let &$(tq1,t1a) = tqs1->hd;
    let &$(tq2,t2a) = tqs2->hd;
    if (tq1.real_const && !tq2.real_const) return false;
    if ((tq2.real_const || Kinds::kind_leq(&Kinds::ak,type_kind(t2a)))
	&& subtype(assume,t1a,t2a))
      continue;
    if (unify(t1a,t2a) || isomorphic(t1a,t2a))
      continue;
    return false;
  }
  return true;
}


//compress handles aquals(`a) case too
bool check_aqual_bounds(aqualbnds_t aquals_bnd, 
			aqualtype_t aq, aqualtype_t bnd) {
  switch ($(compress(aq), compress(bnd))) {
  case $(&AppType(&AqualConstCon(v_sub), _), &AppType(&AqualConstCon(v_sup), _)):
    return (v_sup==v_sub || v_sup==Restricted_qual);
  case $(&AppType(&AqualVarCon, tv_sub), &AppType(&AqualConstCon(v_sup), _)):
    return check_aqual_bounds(aquals_bnd, tv_sub->tl->hd, bnd);
  case $(&AppType(&AqualsCon, _),  &AppType(&AqualConstCon(v_sup), _)):
    try { 
      let aq_bound = List::assoc_cmp(typecmp, aquals_bnd, aq);
      return check_aqual_bounds(aquals_bnd, aq_bound, bnd);
    }catch {
    case &Not_found:
      return false; 
    }
  default: 
    Warn::impos2("check_aqual_bounds expects a constant bound; got ", aq, ",", bnd);
  }
}

//typically t is a tvar
type_t lookup_aquals(aqualbnds_t aquals_map, type_t t) {
  let aqt = t;
  switch(t) {
  case &VarType(tv): 
    let Opt{k} = Kinds::tvar_kind_opt(tv);
    if(k && k->kind != AqualKind) {
      aqt = aqualsof_type(t);
    }
    break;
  default:
    break;
  }
  try { 
    return List::assoc_cmp(typecmp, aquals_map, aqt);
  }catch {
  case &Not_found:
    return al_qual_type;
  }
}

//can't use unify ... don't want side effects
//If aquals(`a) is present force identities to be the same
//otherwise dependencies to outer scopes gets ugly
bool alias_qual_subtype(aqualtype_t aq_sub, aqualtype_t aq_sup) {
  switch ($(compress(aq_sub), compress(aq_sup))) {
  case $(&AppType(&AqualConstCon(v_sub), _), &AppType(&AqualConstCon(v_sup), _))://c,c
    return ((v_sup==v_sub || v_sup==Restricted_qual)
	    ||(v_sup == Aliasable_qual && (v_sub == Unique_qual || v_sub == Refcnt_qual || v_sub == Restricted_qual)));
  case $(&AppType(&AqualVarCon, &List(&VarType(tv1), _)), &AppType(&AqualVarCon, &List(&VarType(tv2), _)))://v,v
    return (tv2->identity == tv1->identity);
  case $(&AppType(&AqualVarCon, &List(&AppType(&AqualsCon, &List{tv1, NULL}), _)), 
	 &AppType(&AqualVarCon, &List(&AppType(&AqualsCon, &List{tv2, NULL}), _))): //v,v
    return (typecmp(tv1, tv2)==0);
  case $(&AppType(&AqualVarCon, &List(&VarType(tv1), bnd1)), &AppType(&AqualVarCon, &List(&Evar(k, ...), bnd2)))://v,e
    return (Kinds::kind_eq(Kinds::tvar_kind(tv1,&Kinds::aqk), k->v) && alias_qual_subtype(bnd1->hd, bnd2->hd));
  case $(&AppType(&AqualVarCon, &List(&Evar(k1, ...), bnd1)), &AppType(&AqualVarCon, &List(&VarType(tv2), bnd2)))://e,v
    return (Kinds::kind_eq(k1->v, Kinds::tvar_kind(tv2, &Kinds::aqk)) && check_aqual_bounds(NULL, bnd2->hd, bnd1->hd));//fix NULL
  case $(&AppType(&AqualVarCon, &List(&Evar(k1, ...), bnd1)), &AppType(&AqualVarCon, &List(&Evar(k2, ...), bnd2)))://e,e
    return (Kinds::kind_eq(k1->v, k2->v) && alias_qual_subtype(bnd1->hd, bnd2->hd));
    //  case $(&AppType(&AqualVarCon, tv_sub), &AppType(&AqualVarCon, tv_sup)): 
    //    return (unify(tv_sub->hd, tv_sup->hd) && alias_qual_subtype(tv_sub->tl->hd, tv_sup->tl->hd));
    //we can use an @aqual(`q <= C) in place of C ... 
  case $(&AppType(&AqualVarCon, &List(&VarType(tv), bnd)), &AppType(&AqualConstCon(v_sup),_))://v,c
    return alias_qual_subtype(bnd->hd, aq_sup);
  case $(&AppType(&AqualVarCon, &List(&Evar(k, ...), bnd)), &AppType(&AqualConstCon(v_sup),_))://e,c
    return (Kinds::kind_eq(k->v, &Kinds::aqk) && check_aqual_bounds(NULL, aq_sup, bnd->hd));//, aq_sup));//fix NULL
    //but not C in place of @aqual(`q <= C) (VarType does not unify with AqualConst, but Evar does)
  case $(&AppType(&AqualConstCon(v_sub),_), &AppType(&AqualVarCon, &List(&VarType(tv), ...)))://c,v
    return false;
  case $(&AppType(&AqualConstCon(v_sub),_), &AppType(&AqualVarCon, &List(&Evar(k, ...), bnd)))://c,e
    return (Kinds::kind_eq(k->v, &Kinds::aqk) && alias_qual_subtype(aq_sub, bnd->hd));
  default:
    return false;
  }
}

// Can t1 be cast to t2?  Assumes that the types are well-formed.
// FIX: add function types...
coercion_t castable(seg_t loc, type_t t1, type_t t2){
  if(unify(t1,t2))
    return No_coercion;
  t1 = compress(t1);
  t2 = compress(t2);
  switch (t2) {
  case &AppType(&VoidCon,_): return No_coercion;
  // we can cast t1 to an int if t1 is a boxed type.
  case &AppType(&IntCon(_,Int_sz),_):
  case &AppType(&IntCon(_,Long_sz),_):
    if (type_kind(t1)->kind == BoxKind) return Other_coercion;
    break;
  default: break;
  }
  switch (t1) {
  case &PointerType(PtrInfo(t_a,q_a,PtrAtts(rt_a,null_a,b_a,zt_a,_,rel_a,aq_a))):
    
    // can cast t* to t@ and vice versa.
    // can cast a non-const pointer to a const pointer.
    // can cast a pointer in region r1 to a pointer in region r2 as
    // long as r1 outlives r2.
    // can cast a "bits-only" pointer to a char pointer ?NOZEROTERM
    // can cast a zero-terminated pointer to a non-zero terminated pointer
    // can cast an autoreleased pointer to a non-autoreleased pointer
    // can cast any aqual to an alias-restricted pointer
    switch (t2) {
    case &PointerType(PtrInfo(t_b,q_b,PtrAtts(rt_b,null_b,b_b,zt_b,_,rel_b,aq_b))):
      coercion_t coercion = Other_coercion;
      let assump = new List(new $(t1,t2),NULL);
      let quals_okay = (q_b.real_const || !q_a.real_const);
      // Can this get any more complicated?!??!?!?!?
      // First, we allow deep subtyping here if q_b is const or t_b is
      // abtract (makes it effectively const since you can't write to it
      // and this is needed for datatypes).  But we also allow you to
      // cast when the types are equal, isomorphic, or the the second
      // type is void.  (void is effectively abstract, but I'm too scared
      // to make it thus...)

      // Note, we can only allow ptrsubtype when the second pointer has a
      // bound of 1, is not fat, and is not zero-terminated!
      let deep_castable =
        unify(b_b,bounds_one()) && (!force_type2bool(false,zt_b));
      let ptrsub = quals_okay &&
        ((deep_castable && ptrsubtype(assump,t_a,t_b)) ||
         unify(t_a,t_b) || isomorphic(t_a,t_b) || unify(t_b,void_type));
      bool zeroterm_ok = unify(zt_a,zt_b) || !type2bool(false,zt_b);
      bool autoreleased_ok = unify(rel_a,rel_b) || !type2bool(false,rel_b);
      // FIX: we need to take any qualifiers into account on typedefs
      let bitcase = ptrsub ? false : (is_bits_only_type(t_a) && is_char_type(t_b)
                                      && !force_type2bool(false,zt_b)
                                      && (q_b.real_const || !q_a.real_const));
      bool bounds_ok = unify(b_a,b_b);
      if (!bounds_ok && !bitcase) {
        let e_a = get_bounds_exp(bounds_one(),b_a);
        let e_b = get_bounds_exp(bounds_one(),b_b);
        if (e_a != NULL && e_b != NULL && Evexp::lte_const_exp(e_b,e_a))
          bounds_ok = true;
        else if (e_a == NULL || e_b == NULL)
          bounds_ok = true;
      }
      bool t1_nullable = force_type2bool(false,null_a);
      bool t2_nullable = force_type2bool(false,null_b);
      if (t1_nullable && !t2_nullable)
        coercion = Null_to_NonNull;

      if (bounds_ok && zeroterm_ok && autoreleased_ok && 
	  (ptrsub || bitcase) && alias_qual_subtype(aq_a, aq_b) &&
          (unify(rt_a,rt_b) || subset_effect(false, rt_a,rt_b)))
        return coercion;
      else return Unknown_coercion;
    default: break;
    }
    return Unknown_coercion;
  case &ArrayType(ArrayInfo{t1a,tq1a,e1,zt1,_}):
    switch (t2) {
    case &ArrayType(ArrayInfo{t2a,tq2a,e2,zt2,_}):
      bool okay =
        (e1 != NULL && e2 != NULL && unify(zt1,zt2) &&
	 Evexp::lte_const_exp(e2,e1) && Evexp::lte_const_exp(e1,e2));
      return
        // FIX: we need to take any qualifiers into account on typedefs
        (okay && unify(t1a,t2a) && (!tq1a.real_const || tq2a.real_const)) ?
        No_coercion : Unknown_coercion;
    default: return Unknown_coercion;
    }
    return Unknown_coercion;
  // can cast a numeric type or bool to any numeric type
  case &AppType(&EnumCon(_,ed1),_):
    // can also cast an enum to a shorter enum
    switch(t2) {
    case &AppType(&EnumCon(_,ed2),_):
      if(ed1->fields != NULL && ed2->fields != NULL
	 && length(ed1->fields->v) >= length(ed2->fields->v))
	return Other_coercion;
      break;
    default: break;
    }
    fallthru;
  case &AppType(&IntCon(_,_),_):
  case &AppType(&FloatCon(_),_): 
    return is_strict_arithmetic_type(t2) ? Other_coercion : Unknown_coercion;
    // region_t<`r1> <= region_t<`r2> when `r1 outlives `r2
  case &AppType(&RgnHandleCon,&List(r1,_)):
    switch(t2) {
    case &AppType(&RgnHandleCon,&List(r2,_)):
      if (subset_effect(false, r1, r2)) return No_coercion;
      break;
    default: break;
    }
    return Unknown_coercion;
  default: return Unknown_coercion;
  }
}

// Replace e by a cast of e to t.  The caller must ensure that the cast is safe.
void unchecked_cast(exp_t e, type_t t, coercion_t c) {
  if (unify((type_t)e->topt,t))
    return;
  let inner = copy_exp(e);
  e->r    = new Cast_e(t,inner,false,c);
  e->topt = t;
}

// generating fresh tvars and tvar identities
static int tvar_id_counter = 0;
int new_tvar_id() {
  return tvar_id_counter++;
}

static int tvar_counter = 0;
tvar_t new_tvar(kindbound_t k) {
  return new Tvar(new (string_t)aprintf("#%d",tvar_counter++),-1,k,NULL);
}
bool is_temp_tvar(tvar_t t) {
  return (*(t->name)[0]=='#');
}

// Given a function declaration, return its type as a function type:
type_t fndecl2type(fndecl_t fd) {
  if (fd->cached_type == NULL) {
    // We don't cache this type as we want to expand out the effect
    // and so forth...  The caching happens after we check that the
    // function declaration is valid (see below).
    // First, separate the function type attributes from the rest
    // of the attributes and update the function declaration appropriately.
    let fn_type_atts = NULL;
    for (_ atts = fd->i.attributes; atts != NULL; atts = atts->tl)
      if (Atts::fntype_att(atts->hd))
        fn_type_atts = new List(atts->hd,fn_type_atts);
    let type_info = fd->i;
    type_info.attributes = fn_type_atts;
    return new FnType(type_info);
  }
  return (type_t)fd->cached_type;
}

// given a list of arguments for a function type, replace occurrences
// of the variables in the relational operand with the parameter number.
// As a special case, we have to replace "return_value" with RResult.
static void replace_rop(list_t<$(var_opt_t,tqual_t,type_t)@> args, 
                        Relations::reln_op_t@ rop) {
  switch (*rop) {
  case {.RVar = vd}: 
    let $(nmspace,var) = *vd->name;
    if (!tagcheck(nmspace.Loc_n)) break;
    if (strcmp(*var,"return_value") == 0) {
      *rop = Relations::RReturn();
      break;
    }
    unsigned int c = 0;
    for (let a = args; a != NULL; a = a->tl, c++) {
      let &$(vopt,_,_) = a->hd;
      if (vopt != NULL && strcmp(*var,*vopt) == 0) {
	*rop = Relations::RParam(c);
	break;
      }
    }
    break;
  case {.RNumelts = vd}:
    let $(nmspace,var) = *vd->name;
    if (!tagcheck(nmspace.Loc_n)) break;
    unsigned int c = 0;
    for (let a = args; a != NULL; a = a->tl, c++) {
      let &$(vopt,_,_) = a->hd;
      if (vopt != NULL && strcmp(*var,*vopt) == 0) {
	*rop = Relations::RParamNumelts(c);
	break;
      }
    }
    break;
  default: break;
  }
}

void replace_rops(list_t<$(var_opt_t,tqual_t,type_t)@> args, 
		  Relations::reln_t r) {
  replace_rop(args,&r->rop1);
  replace_rop(args,&r->rop2);
}

static Relations::relns_t 
extract_relns(list_t<$(var_opt_t,tqual_t,type_t)@> args, exp_opt_t e) {
  if (e == NULL) return NULL;
  let relns = Relations::exp2relns(heap_region, e);
  List::iter_c(replace_rops, args, relns);
  return relns;
}

// Substitution stuff
static $(tqual_t,type_t)@ map2_tq($(tqual_t,type_t)@`H pr, type_t t) {
  let &$(tq,t2) = pr;
  return (t2==t) ? pr : new $(tq,t);
}
static $($(var_opt_t,tqual_t)@`r,type_t)@`r
substitute_f1(region_t<`r> rgn, $(var_opt_t,tqual_t,type_t) @`r2 y) {
  return rnew(rgn) $(rnew(rgn) $((*y)[0],(*y)[1]),(*y)[2]);
}
static $(var_opt_t,tqual_t,type_t)@
substitute_f2($(var_opt_t,tqual_t,type_t)@`H orig_arg, type_t t) {
  let $(vopt_orig,tq_orig,t_orig) = *orig_arg;
  if (t == t_orig) return orig_arg;
  return new $(vopt_orig,tq_orig,t);
}
static list_t<type_t,`r2+`H> substs(region_t<`r>, list_t<$(tvar_t,type_t)@`r,`r>,
                                 list_t<type_t,`r2>);
static list_t<exp_t,`r2+`H> substs_exps(region_t<`r>, 
                                        list_t<$(tvar_t,type_t)@`r,`r>,
                                        list_t<exp_t,`r2>);
// used to copy an expression during substitution
static exp_t copye(exp_t old, raw_exp_t r) {
  // FIX? should we be substituting through the topt?
  return new Exp{old->topt, r, old->loc, old->annot};
}

// substitute the type instantiation inst throughout the expression e.
// assumes e is a type-level-expression (e.g., a "constant" expression.)
exp_t rsubsexp(region_t<`r> r, list_t<$(tvar_t,type_t)@`r,`r> inst, exp_t e) {
  switch (e->r) {
  case &Const_e(_):
  case &Enum_e(...):
  case &AnonEnum_e(...):
  case &Pragma_e(...):
  case &Var_e(...): return e;

  case &Primop_e(p,es):
    if (List::length(es) == 1) {
      let e1 = es->hd;
      let new_e1 = rsubsexp(r,inst,e1);
      return (new_e1==e1) ? e : copye(e, new Primop_e(p,list(new_e1)));
    } else if (List::length(es) == 2) {
      let e1 = es->hd;
      let e2 = es->tl->hd;
      let new_e1 = rsubsexp(r,inst,e1);
      let new_e2 = rsubsexp(r,inst,e2);
      if (new_e1 == e1 && new_e2 == e2) return e;
      return copye(e, new Primop_e(p,list(new_e1,new_e2)));
    } 
    return Warn::impos2("primop does not have 1 or 2 args!");
  case &Conditional_e(e1,e2,e3):
    let new_e1 = rsubsexp(r,inst,e1);
    let new_e2 = rsubsexp(r,inst,e2);
    let new_e3 = rsubsexp(r,inst,e3);
    if (new_e1 == e1 && new_e2 == e2 && new_e3 == e3) return e;
    return copye(e, new Conditional_e(new_e1,new_e2,new_e3));
  case &And_e(e1,e2):
    let new_e1 = rsubsexp(r,inst,e1);
    let new_e2 = rsubsexp(r,inst,e2);
    if (new_e1 == e1 && new_e2 == e2) return e;
    return copye(e, new And_e(new_e1,new_e2));
  case &Or_e(e1,e2):
    let new_e1 = rsubsexp(r,inst,e1);
    let new_e2 = rsubsexp(r,inst,e2);
    if (new_e1 == e1 && new_e2 == e2) return e;
    return copye(e, new Or_e(new_e1,new_e2));
  case &SeqExp_e(e1,e2):
    let new_e1 = rsubsexp(r,inst,e1);
    let new_e2 = rsubsexp(r,inst,e2);
    if (new_e1 == e1 && new_e2 == e2) return e;
    return copye(e, new SeqExp_e(new_e1,new_e2));
  case &FnCall_e(e1,args,vai,resolved):
    let new_e1 = rsubsexp(r,inst,e1);
    let new_args = substs_exps(r,inst,args);
    // FIX? vararg info
    if (new_e1 == e1 && new_args == args) return e;
    return copye(e, new FnCall_e(new_e1,new_args,vai,resolved));
  case &NoInstantiate_e(e1):
    let new_e1 = rsubsexp(r,inst,e1);
    if (new_e1 == e1) return e;
    return copye(e, new NoInstantiate_e(new_e1));
  case &Instantiate_e(e1,ts):
    let new_e1 = rsubsexp(r,inst,e1);
    let new_ts = substs(r,inst,ts);
    if (new_e1 == e1 && new_ts == ts) return e;
    return copye(e, new Instantiate_e(e1,ts));
  case &Cast_e(t,e1,b,c):
    let new_e1 = rsubsexp(r,inst,e1);
    let new_typ = rsubstitute(r,inst,t);
    if (new_e1 == e1 && new_typ == t) return e;
    return copye(e, new Cast_e(new_typ,new_e1,b,c));
  case &Address_e(e1):
    let new_e1 = rsubsexp(r,inst,e1);
    if (new_e1 == e1) return e;
    return copye(e, new Address_e(new_e1));
  case &Deref_e(e1):
    let new_e1 = rsubsexp(r,inst,e1);
    if (new_e1 == e1) return e;
    return copye(e, new Deref_e(new_e1));
  case &AggrMember_e(e1,f,it,ir):
    let new_e1 = rsubsexp(r,inst,e1);
    if (new_e1 == e1) return e;
    return copye(e, new AggrMember_e(new_e1,f,it,ir));
  case &AggrArrow_e(e1,f,it,ir):
    let new_e1 = rsubsexp(r,inst,e1);
    if (new_e1 == e1) return e;
    return copye(e, new AggrArrow_e(new_e1,f,it,ir));
  case &Subscript_e(e1,e2):
    let new_e1 = rsubsexp(r,inst,e1);
    let new_e2 = rsubsexp(r,inst,e2);
    if (new_e1 == e1 && new_e2 == e2) return e;
    return copye(e, new Subscript_e(new_e1,new_e2));
  case &Tagcheck_e(e1,f):
    let new_e1 = rsubsexp(r,inst,e1);
    if (new_e1 == e1) return e;
    return copye(e, new Tagcheck_e(e1,f));
  case &Sizeoftype_e(t):
    let new_typ = rsubstitute(r,inst,t);
    return (new_typ==t) ? e : copye(e, new Sizeoftype_e(new_typ));
  case &Sizeofexp_e(e1):
    let new_e1 = rsubsexp(r,inst,e1);
    return (new_e1==e1) ? e : copye(e, new Sizeofexp_e(new_e1));
  case &Extension_e(e1):
    let new_e1 = rsubsexp(r,inst,e1);
    return (new_e1==e1) ? e : copye(e, new Extension_e(new_e1));
  case &Offsetof_e(t,f):
    let new_typ = rsubstitute(r,inst,t);
    return (new_typ==t) ? e : copye(e, new Offsetof_e(new_typ,f));
  case &Valueof_e(t):
    let new_typ = rsubstitute(r,inst,t);
    if (new_typ == t) return e;
    // reduce valueof(valueof_t(e)) to e
    switch (compress(new_typ)) {
    case &ValueofType(e): return e;
    default: return copye(e, new Valueof_e(new_typ));
    }
  case &Assert_e(e1):
    let new_e1 = rsubsexp(r,inst,e1);
    return (new_e1==e1) ? e : copye(e, new Assert_e(new_e1));
  case &Assert_false_e(e1):
    let new_e1 = rsubsexp(r,inst,e1);
    return (new_e1==e1) ? e : copye(e, new Assert_false_e(new_e1));
  case &Array_e(...): // FIX: should be added
  case &Comprehension_e(...): // FIX: should be added
  case &Aggregate_e(...): // FIX: should be added
  case &AnonStruct_e(...): // FIX: should be added
  case &Datatype_e(...): // FIX: should be added
  case &ComprehensionNoinit_e(...): // FIX: should be added?
  case &CompoundLit_e(...): 
  case &StmtExp_e(...): // FIX: should be added?
  case &Malloc_e(...):
  case &New_e(...):
  case &Swap_e(...):
  case &AssignOp_e(...):
  case &Increment_e(...):
  case &UnresolvedMem_e(...):
  case &Asm_e(...):
  case &Throw_e(...):
    return Warn::impos2("non-type-level-expression in Tcutil::rsubsexp");
  }
}

static list_t<exp_t,`r2+`H> substs_exps(region_t<`r> rgn, 
                                        list_t<$(tvar_t,type_t)@`r,`r> inst,
                                        list_t<exp_t,`r2> es) {
  if(es == NULL)
    return NULL;
  let old_hd = es->hd;
  let old_tl = es->tl;
  let new_hd = rsubsexp(rgn, inst, old_hd);
  let new_tl = substs_exps(rgn, inst, old_tl);
  if(old_hd == new_hd && old_tl == new_tl)
    return es;
  return (new List(new_hd,new_tl)); 
  
}

static exp_opt_t rsubs_exp_opt(region_t<`r> r,
                               list_t<$(tvar_t,type_t)@`r,`r> inst, 
                               exp_opt_t e) {
  return (e==NULL) ? NULL : rsubsexp(r,inst,e);
}

static aggrfield_t subst_aggrfield(region_t<`r> r,
				   list_t<$(tvar_t,type_t)@`r,`r> inst, 
				   aggrfield_t f) {
  let t = f->type;
  let req = f->requires_clause;
  let new_typ = rsubstitute(r,inst,t);
  let new_req = rsubs_exp_opt(r,inst,req);
  if (t == new_typ && req == new_req) 
    return f;
  let ans = new *f;
  ans->type = new_typ;
  ans->requires_clause = new_req;
  return ans;
}

static list_t<aggrfield_t> subst_aggrfields(region_t<`r> r,
					    list_t<$(tvar_t,type_t)@`r,`r> inst,
					    list_t<aggrfield_t,`H> fs) {
  if (fs == NULL) return NULL;
  let f = fs->hd;
  let t = fs->tl;
  let new_f   = subst_aggrfield(r,inst,f);
  let new_typ = subst_aggrfields(r,inst,t);
  return (new_f == f && new_typ == t) ? fs : new List(new_f,new_typ);
}

list_t<$(type_t,type_t)@> rsubst_type_assoc(region_t<`r> rgn,
					    list_t<$(tvar_t,type_t)@`r,`r> inst,
					    list_t<$(type_t,type_t)@`H,`H> rgn_po) {
  let $(rpo1a,rpo1b) = List::rsplit(rgn,rgn,rgn_po);
  let rpo2a = substs(rgn,inst,rpo1a);
  let rpo2b = substs(rgn,inst,rpo1b);
  return (rpo2a == rpo1a && rpo2b == rpo1b) ? rgn_po : List::zip(rpo2a,rpo2b);
}

list_t<effconstr_t> rsubst_effconstr(region_t<`r> rgn,
				     list_t<$(tvar_t,type_t)@`r,`r> inst,
				     list_t<effconstr_t,`H> ec) {
  _ slist = NULL;
  for(;ec != NULL; ec=ec->tl) {
    switch(ec->hd) {
    case &SingleConstraint(t):
      let nt = rsubstitute(rgn, inst, t);
      if(nt == t)
	slist = new List{ec->hd, slist};
      else 
	slist = new List{(new SingleConstraint(nt)), slist};
      break;
    case &DisjointConstraint(t1, t2):
      let nt1 = rsubstitute(rgn, inst, t1);
      let nt2 = rsubstitute(rgn, inst, t2);
      if(nt1 == t1 && nt2 == t2) 
	slist = new List{ec->hd, slist};
      else 
	slist = new List{(new DisjointConstraint(nt1, nt2)), slist};
      break;
    case &SubsetConstraint(t1, t2):
      let nt1 = rsubstitute(rgn, inst, t1);
      let nt2 = rsubstitute(rgn, inst, t2);
      if(nt1 == t1 && nt2 == t2) 
	slist = new List{ec->hd, slist};
      else 
	slist = new List{(new SubsetConstraint(nt1, nt2)), slist};
      break;
    }
  }
  return slist;
}

// FIX!! hack to avoid substituting in function types during current
// region resolution
static bool skip_fntypes = false;

type_t rsubstitute(region_t<`r> rgn,
		   list_t<$(tvar_t,type_t)@`r,`r> inst,
		   type_t t) {
  switch (compress(t)) {
  case &VarType(v):
    // a tvar lookup, not a var lookup!
    try return List::assoc_cmp(tvar_cmp,inst,v);
    catch {case &Not_found: return t;}
  case &TypedefType(n,ts,td,topt):
    let new_ts = substs(rgn,inst,ts);
    return (new_ts == ts) ? t : new TypedefType(n,new_ts,td,topt);
  case &ArrayType(ArrayInfo{t1,tq,e,zt,ztl}):
    let new_t1 = rsubstitute(rgn,inst,t1);
    let new_e  = rsubs_exp_opt(rgn,inst,e);
    let new_zt = rsubstitute(rgn,inst,zt);
    return (new_t1 == t1 && new_e == e && new_zt == zt) ? t : 
      new ArrayType(ArrayInfo{new_t1,tq,new_e,new_zt,ztl});
  case &PointerType(PtrInfo(t1,tq,PtrAtts(r,n,b,zt,_,rel,aq))):
    let new_t1 = rsubstitute(rgn,inst,t1);
    let new_r  = rsubstitute(rgn,inst,r);
    let new_b  = rsubstitute(rgn,inst,b);
    let new_zt = rsubstitute(rgn,inst,zt);
    let new_rel = rsubstitute(rgn,inst,rel);
    let new_aq = rsubstitute(rgn,inst,aq);
    if(new_t1 == t1 && new_r == r && new_b == b && new_zt == zt && new_rel == rel && new_aq == aq)
      return t;
    return pointer_type(PtrInfo(new_t1,tq,PtrAtts(new_r,n,new_b,new_zt,NULL,new_rel,new_aq)));
  case &FnType(FnInfo{vs,eff,rtq,rtyp,args,c_varargs,cyc_varargs,qb,atts,
                        req,_,ens,_,thrws,_,ret_value,argvds,effconstr}): //sub the qb also ... need it for delayed checking
    if (skip_fntypes) return t;
    // FIX: capture??? 
    for (let p = vs; p != NULL; p = p->tl)
      inst = rnew(rgn) List(rnew(rgn) $(p->hd,var_type(p->hd)),inst);
    let $(qs,ts) = List::rsplit(rgn,rgn,
				List::rmap_c(rgn,substitute_f1,rgn,args));
    let args2 = args; //inst contains all abstracted tvars and their corresponding var_type's
    let ts2 = substs(rgn,inst,ts); //ts is the types of all the arguments
    if (ts2 != ts) //ts2 are the argtyps with free tvars replaced with the abstracted var_type's from inst
      args2 = List::map2(substitute_f2, args, ts2); //args list with new types
    type_opt_t eff2 = (eff==NULL) ? NULL : rsubstitute(rgn,inst,eff);

    vararg_info_t *cyc_varargs2;
    if (cyc_varargs == NULL)
      cyc_varargs2 = NULL;
    else {
      let VarargInfo{n,tq,t,i} = *cyc_varargs;
      let t2 = rsubstitute(rgn,inst,t);
      cyc_varargs2 = (t2 == t) ? cyc_varargs : new VarargInfo{n,tq,t2,i};
    }
    let effconstr2 = rsubst_effconstr(rgn, inst, effconstr);
    //    list_t<$(type_t,type_t)@> rgn_po2 = rsubst_rgnpo(rgn,inst,rgn_po);
    list_t<$(type_t,type_t)@> qb2 = rsubst_type_assoc(rgn,inst,qb);
    exp_opt_t req2 = rsubs_exp_opt(rgn,inst,req);
    exp_opt_t ens2 = rsubs_exp_opt(rgn,inst,ens);
    exp_opt_t thrws2 = rsubs_exp_opt(rgn,inst,thrws);

    // At this point, we need to generate fresh vardecls for the argvds,
    // and a fresh return_value that has the appropriate substituted
    // type.  Then we need to crawl through req2, ens2, and thrws2 and
    // substitute these fresh vars for the old ones.
    list_t<vardecl_opt_t> argvds2 = NULL;
    for (let avs = argvds; avs != NULL; avs = avs->tl) {
      vardecl_opt_t av = avs->hd;
      vardecl_opt_t av2 = NULL;
      if (av != NULL) {
        av2 = new *av;
        av2->type = rsubstitute(rgn,inst,av->type);
      }
      argvds2 = new List{av2,argvds2};
    }
    argvds2 = List::imp_rev(argvds2);
    vardecl_opt_t ret_value2 = NULL;
    if (ret_value != NULL) {
      ret_value2 = new *ret_value;
      ret_value2->type = rsubstitute(rgn,inst,ret_value2->type);
    }

    AssnDef::existassnfn_opt_t req_assn2 = NULL;
    AssnDef::existassnfn_opt_t ens_assn2 = NULL;
    AssnDef::existassnfn_opt_t thrws_assn2 = NULL;

    let vds1 = new List(ret_value,argvds);
    let vds2 = new List(ret_value2,argvds2);
    let boundvds = new List {(vardecl_opt_t)AssnDef::memory,argvds2};
    
    if (req2 != NULL) {
      let req_am2 = new Vcgen::clause2assn((exp_t)req2);
      req_am2 = AssnDef::subst_vardecls(vds1,vds2,req_am2);
      req_assn2 = AssnDef::assnmap2existassnfn(*req_am2,boundvds);
    }
    if (ens2 != NULL) {
      let ens_am2 = new Vcgen::clause2assn((exp_t)ens2);
      ens_am2 = AssnDef::subst_vardecls(vds1,vds2,ens_am2);
      new List {ret_value2,boundvds};
      ens_assn2 = AssnDef::assnmap2existassnfn(*ens_am2,new List {ret_value2,boundvds});
    }
    if (thrws2 != NULL) {
      let thrws_am2 = new Vcgen::clause2assn((exp_t)thrws2);
      thrws_am2 = AssnDef::subst_vardecls(vds1,vds2,thrws_am2);
      thrws_assn2 = AssnDef::assnmap2existassnfn(*thrws_am2,boundvds);
    }

    return new FnType(FnInfo{vs,eff2,rtq,rsubstitute(rgn,inst,rtyp),args2,
			       c_varargs,cyc_varargs2,qb2,atts,
			       req2,req_assn2,ens2,ens_assn2,
                               thrws2,thrws_assn2,ret_value2,argvds2,effconstr2});
  case &AnonAggrType(k,b,fs):
    let new_fs = subst_aggrfields(rgn,inst,fs);
    return (fs==new_fs) ? t : new AnonAggrType(k,b,new_fs);
  case &Evar(_,r,_,_):
    return (r==NULL) ? t : rsubstitute(rgn,inst,(type_t)r);
    /*   case &AppType(&AqualVarCon, ts): *///no need to special case this anymore
/*     return aqual_var_type(rsubstitute(rgn, inst,ts->hd),  */
/* 			  rsubstitute(rgn, inst,ts->tl->hd)); */
  case &AppType(c,ts):
    let new_ts = substs(rgn,inst,ts);
    return (ts==new_ts) ? t : new AppType(c,new_ts);
  case &ValueofType(e):
    let new_e = rsubsexp(rgn,inst,e);
    return (new_e==e) ? t : new ValueofType(new_e);
  case &TypeofType(e):
    let new_e = rsubsexp(rgn,inst,e);
    return (new_e==e) ? t : new TypeofType(new_e);
  case &TypeDeclType(...): 
    if (skip_fntypes) return t;
    Warn::impos2("found typedecltype in rsubs");
  }
}
// This is just a map beefed up to avoid unnecessary allocation.
static list_t<type_t,`r2+`H> substs(region_t<`r> rgn,
                                    list_t<$(tvar_t,type_t)@`r,`r> inst,
                                    list_t<type_t,`r2> ts) {
  if(ts == NULL)
    return NULL;
  let old_hd = ts->hd;
  let old_tl = ts->tl;
  let new_hd = rsubstitute(rgn, inst, old_hd);
  let new_tl = substs(rgn, inst, old_tl);
  if(old_hd == new_hd && old_tl == new_tl)
    return ts;
  return (new List(new_hd,new_tl)); 
}

type_t substitute(list_t<$(tvar_t,type_t)@`H,`H> inst, type_t t) {
  return (inst==NULL) ? t : rsubstitute(heap_region, inst, t);
}

type_t substitute_nofun(list_t<$(tvar_t,type_t)@`H,`H> inst, type_t t) {
  skip_fntypes = true;
  let new_typ = substitute(inst,t);
  skip_fntypes = false;
  return new_typ;
}

// Generate an appropriate evar for an instantiation of a type var
$(tvar_t,type_t)@ make_inst_var(list_t<tvar_t,`H> s, tvar_t tv) {
  let k = Kinds::kind_to_opt(Kinds::tvar_kind(tv,&Kinds::bk));
  return new $(tv, new_evar(k,new Opt(s)));
}

$(tvar_t,type_t)@`r r_make_inst_var($(list_t<tvar_t,`H>,region_t<`r>)@ env,
                                    tvar_t tv) {
  let &$(s,rgn) = env;
  let k = Kinds::kind_to_opt(Kinds::tvar_kind(tv,&Kinds::bk));
  return rnew(rgn) $(tv, new_evar(k,new Opt(s)));
}

void check_bitfield(seg_t loc, type_t field_type,
		    exp_opt_t width, stringptr_t<`H> fn) {
  if (width != NULL) {
    unsigned int w = 0;
    if (!is_const_exp(width)) 
      Warn::err2(loc,"bitfield ",*fn," does not have constant width");
    else {
      let $(i,known) = Evexp::eval_const_uint_exp(width);
      if(!known)
	Warn::warn2(loc,"cannot evaluate bitfield width at compile time");
      if ((int)i < 0)
	Warn::err2(loc,"bitfield has negative width");
      w = i;
    }
    switch (compress(field_type)) {
    case &AppType(&IntCon(_,b),_):
      // FIX: this is making size assumptions
      bool bad;
      switch (b) {
      case Char_sz:     bad = (w>8);  break;
      case Short_sz:    bad = (w>16); break;
      case Long_sz:
      case Int_sz:      bad = (w>32); break;
      case LongLong_sz: 
      default:          bad = (w>64); break;
      }
      if(bad)
	Warn::warn2(loc,"bitfield larger than type");
      break;
    default:
      Warn::err2(loc,"bitfield ",*fn," must have integral type but has type ",
		 field_type);
      break;
    }
  }
}

// If t is a typedef, returns true if the typedef is const, and warns
// if the flag declared_const is true.  Otherwise returns declared_const.
bool extract_const_from_typedef(seg_t loc, bool declared_const, type_t t) {
  switch (t) {
  case &TypedefType(_,_,td,tdopt):
    if (td->tq.real_const || td->tq.print_const) {
      if (declared_const) Warn::warn2(loc,"extra const");
      return true;
    }
    // not done yet -- the typedef could expand to a typedef
    if (tdopt)
      return extract_const_from_typedef(loc,declared_const,tdopt);
    return declared_const;
  default: return declared_const;
  }
}

void add_tvar_identity(tvar_t tv) {
  if (tv->identity == -1)
    tv->identity = new_tvar_id();
}
void add_tvar_identities(list_t<tvar_t> tvs) {
  List::iter(add_tvar_identity,tvs);
}

// Note: we expect lists to be very short.  Otherwise, a hashtable would
// be a better choice.
static void check_unique_unsorted(int (@cmp)(`a,`a), list_t<`a> vs,
				  seg_t loc,
				  string_t a2string(`a), string_t<`H> msg) {
  for(; vs != NULL; vs = vs->tl)
    for(_ vs2 = vs->tl; vs2 != NULL; vs2 = vs2->tl)
      if(cmp(vs->hd, vs2->hd)== 0)
	Warn::err2(loc, msg,": ",a2string(vs->hd));
}
static string_t<`r> strptr2string(string_t<`r> @s) {
  return *s;
}
void check_unique_vars(list_t<var_t> vs, seg_t loc, string_t<`H> msg) {
  check_unique_unsorted(strptrcmp,vs,loc,strptr2string,msg);
}
void check_unique_tvars(seg_t loc, list_t<tvar_t> tvs) {
  check_unique_unsorted(tvar_cmp,tvs,loc,Absynpp::tvar2string,
			"duplicate type variable");
}
static void imp_remove_dups(int cmp(`a, `a), list_t<`a> l) {
  for(_ l1 = l; l1 != NULL; l1 = l1->tl) {
    _ prev = l1;
    _ l2 = l1->tl;
    while(l2 != NULL) {
      if(!cmp(l1->hd, l2->hd)) {
	prev->tl = l2->tl;
	l2->tl = NULL;
	l2 = prev->tl;
      }      
      else {
	prev = prev->tl;
	l2 = l2->tl;
      }
    }
  }
}
// take a list of $(list_t<designator>,`a) things corresponding to a struct.
// ensure the struct is not abstract.
//  * check that each list_t<designator> has exactly one element which is a
//    FieldName or is empty
//  * match up the correct member of sd->fields with the `a.  If the list
//    is empty, take the first unused field. ?????
//    Bang in the corresponding designator in the des list element
//  * for structs, ensure that each field is used exactly once.
//  * for unions, ensure that at most one field is used.
// FIX: Pass in a flag to allow multiple field names ??
list_t<$(aggrfield_t,`a)@`r,`r>
resolve_aggregate_designators(region_t<`r> rgn, seg_t loc,
                              list_t<$(list_t<designator_t,`H>,`a)@> des,
                              aggr_kind_t aggr_kind,
                              list_t<aggrfield_t> sdfields) {
  region temp;
  // grab all the fields and mark them unused unless the field has an
  // empty name -- these are bitfields for padding and shouldn't be
  // initialized or projected.
  list_t<$(aggrfield_t,bool)@`temp,`temp> fields = NULL;
  for(_ sd_fields = sdfields; sd_fields != NULL; sd_fields = sd_fields->tl)
    if (strcmp(*sd_fields->hd->name,"") != 0)
      fields = rnew(temp) List(rnew(temp) $(sd_fields->hd,false), fields);
  fields = imp_rev(fields);

  string_t aggr_str = (aggr_kind == StructA) ? "struct" : "union";

  // match up each element of des
  list_t<$(aggrfield_t,`a)@`r,`r> ans = NULL;
  for(; des != NULL; des = des->tl) {
    let &$(dl,a) = des->hd;
    if(dl == NULL) {
      // grab first unused
      let fields2 = fields;
      for(; fields2 != NULL; fields2 = fields2->tl)
	if(!(*fields2->hd)[1]) {
	  (*fields2->hd)[1] = true;
	  (*des->hd)[0] = new List(new FieldName((*fields2->hd)[0]->name),NULL);
	  ans = rnew(rgn) List(rnew(rgn) $((*fields2->hd)[0],a), ans);
	  break;
	}
      if(fields2 == NULL)
	Warn::err2(loc, "too many arguments to ",aggr_str);
    } else if(dl->tl != NULL)
      // we don't support multiple designators
      Warn::err2(loc, "multiple designators are not yet supported");
    else
      // find the right field based on the designator
      switch (dl->hd) {
      case &ArrayElement(_):
	Warn::err2(loc, "array designator used in argument to ",aggr_str);
	break;
      case &FieldName(v):
	let fields2 = fields;
	for(; fields2 != NULL; fields2 = fields2->tl)
	  if(strptrcmp(v,((*fields2->hd)[0])->name) == 0) {
	    if((*fields2->hd)[1])
	      Warn::err2(loc, "member ",*v," has already been used as an argument");
	    (*fields2->hd)[1] = true;
	    ans = rnew(rgn) List(rnew(rgn) $((*fields2->hd)[0],a), ans);
	    break;
	  }
	if(fields2 == NULL)
	  Warn::err2(loc, "bad field designator ", *v);
	break;
      }
  }
  // have to make sure we use all fields of a struct and exactly one field of a
  // union, but that's easy w/o repeats and multiple designators
  if(aggr_kind == StructA) {
    if(length(ans) < length(fields))
       Warn::err2(loc, "too few arguments to struct");
  } else if (length(ans) != 1)
    Warn::err2(loc, "union expression should have one member");
  return imp_rev(ans);
}

// is e1 of the form *ea or ea[eb] where ea is a zero-terminated pointer?
// If so, return true and set ea and eb appropriately (for *ea set eb to 0).
// Finally, if the pointer is fat, set is_fat to true.
bool is_zero_ptr_deref(exp_t e1, type_t @ptr_type,
		       bool @is_fat, type_t @elt_type) {
  switch (e1->r) {
  case &Cast_e(...): Warn::impos2("we have a cast in a lhs: ",e1);
  case &Deref_e(e1a): fallthru(e1a);
  case &Subscript_e(e1a,_):
    return is_zero_ptr_type((type_t)e1a->topt,ptr_type,is_fat,elt_type);
  case &AggrArrow_e(e1a,...): fallthru(e1a);
  case &AggrMember_e(e1a,...):
    // sanity check
    if (is_zero_ptr_type((type_t)e1a->topt,ptr_type,is_fat,elt_type))
      Warn::impos2("found zero pointer aggregate member assignment: ",e1);
    return false;
  case &Instantiate_e(e1a,_): fallthru(e1a);
  case &NoInstantiate_e(e1a):
    if (is_zero_ptr_type((type_t)e1a->topt,ptr_type,is_fat,elt_type))
      Warn::impos2("found zero pointer instantiate/noinstantiate: ",e1);
    return false;
  case &Var_e(...): return false;
  default: Warn::impos2("found bad lhs in is_zero_ptr_deref: ",e1);
  }
}

/***************************************************/
/* Routines for dealing with non-aliasing pointers */
/***************************************************/

// warning: not just a predicate; side-effects VarTypes to be of non-unique
//   flavor if they are not yet set
/* bool is_noalias_region(type_t r, bool must_be_unique) { */
/*   return false; */
/* } */
/*   switch (compress(r)) { */
/*   case &AppType(&RefCntCon,_): return !must_be_unique; */
/*   case &AppType(&UniqueCon,_): return true; */
/*   case &TypedefType(_,_,&Typedefdecl{.kind=&Opt{.v=&Kind(k,a)},...},NULL):  */
/*     return ((k == RgnKind) && (a == Unique || (a == Top && !must_be_unique))); */
/* //     fallthru(k,a); */
/* //   case &Evar(&Core::Opt{.v=&Kind(k,a)},NULL,_,_): */
/*   case &VarType(tv): */
/*     let &Kind(k,a) = Kinds::tvar_kind(tv,&Kinds::rk); */
/*     if ((k == RgnKind) && (a == Unique || (a == Top && !must_be_unique))) */
/*       switch (Kinds::compress_kb(tv->kind)) { */
/*       case &Less_kb(*x,&Kind(RgnKind,Top)): */
/*         *x = new Opt(new Less_kb(NULL,&Kinds::rk)); */
/*         return false; */
/*       default: return true; */
/*       } */
/*     return false; */
/*   default: return false; */
/*   } */
/* } */

bool is_noalias_qual(aqualtype_t aq, bool must_be_unique) {
  switch(compress(aq)) {
  case &AppType(&AqualConstCon(aqv), _): {
    switch(aqv) {
    case Unique_qual: return true;
    case Refcnt_qual:
    case Restricted_qual: return !must_be_unique;
    default: return false;
    }
  }
    //ignore unconstrained evars -- show up in (_ a= NULL; &a;)...will be constrained later  	
  case &AppType(&AqualVarCon, &List(&VarType(...), bnd)): fallthru(bnd);
  case &AppType(&AqualVarCon, &List(&AppType(...), bnd)): { 
    switch(bnd->hd) {
    case &AppType(&AqualConstCon(Unique_qual), _): return true;
    case &AppType(&AqualConstCon(Refcnt_qual), _): 
    case &AppType(&AqualConstCon(Restricted_qual), _): return !must_be_unique;
    default: return false;
    }
  }
  default:
    return false;
  }
}
// warning: not just a predicate; side-effects VarTypes to be of non-unique
//   flavor if they are not yet solidly bounded
bool is_noalias_pointer(aqualbnds_t aqb, type_t t, bool must_be_unique) {
  switch (compress(t)) {
  case &PointerType(PtrInfo(_,_,PtrAtts(_,_,_,_,_,_,aq))):
    return is_noalias_qual(aq, must_be_unique);
  case &VarType(tv):
    return is_noalias_qual(lookup_aquals(aqb, t), must_be_unique);
    //    return false; //fix this with aquals_bounds
/*     let &Kind(k,a) = Kinds::tvar_kind(tv,&Kinds::bk); */
/*     switch (k) { */
/*     case BoxKind: case AnyKind: case MemKind: */
/*       if (a == Unique || (a == Top && !must_be_unique)) */
/* 	switch (Kinds::compress_kb(tv->kind)) { */
/* 	case &Less_kb(*x,&Kind(k,Top)): */
/* 	  *x = new Opt(new Less_kb(NULL,new Kind(k,Aliasable))); */
/* 	  return false; */
/* 	default: return true; */
/* 	} */
/*       return false; */
/*     default: return false; */
/*     } */

  default: return false;
  }
}
bool is_noalias_pointer_or_aggr(aqualbnds_t aqb, type_t t) {
  t = compress(t);
  if (is_noalias_pointer(aqb, t,false)) 
    return true;
  switch (t) {
  case &AppType(&AggrCon({.KnownAggr = adp}),ts):
    if ((*adp)->impl == NULL) 
      return false;
    let inst = List::zip((*adp)->tvs,ts);
    for(let x = (*adp)->impl->fields; x != NULL; x = x->tl)
      if (is_noalias_pointer_or_aggr(aqb, substitute(inst,x->hd->type))) 
	return true;
    return false;
  case &AnonAggrType(_,_,x):
    for(; x != NULL; x = x->tl)
      if (is_noalias_pointer_or_aggr(aqb, x->hd->type)) 
	return true;
    return false;
  case &AppType(&AggrCon({.UnknownAggr = _}),_):
  case &AppType(&DatatypeCon(_),_): return false; // FIX: ... ? (see below)

  case &AppType(&DatatypeFieldCon(tinfo),ts):
    switch (tinfo) {
    case {.UnknownDatatypefield = _}: return false;
    case {.KnownDatatypefield = $(td,fld)}:
      let inst = List::zip(td->tvs,ts);
      for(let typs = fld->typs; typs != NULL; typs = typs->tl) {
        t = (inst == NULL) ? ((*typs->hd)[1]) : substitute(inst,(*typs->hd)[1]);
        if (is_noalias_pointer_or_aggr(aqb, t)) 
	  return true;
      }
      return false;
    }
  default: return false;
  }
}

// returns true if the path [e] is entirely unique.  I.e. **x is unique
// if x has type (e.g.) int *`U*`U*`U x but not if it has type (e.g.)
// int *`U*`H*`U x
bool is_noalias_path(aqualbnds_t aqb, exp_t e) {
  switch (e->r) {
  case &Var_e(&Global_b(...)): return false;
  case &AggrArrow_e(e1,...): fallthru(e1);
  case &Deref_e(e1):
    return is_noalias_pointer(aqb, (type_t)e1->topt,true) && is_noalias_path(aqb, e1);
  case &AggrMember_e(e1,f,...): return is_noalias_path(aqb, e1);
  case &Subscript_e(e1,e2): return false;
  case &Conditional_e(_,e1,e2):
    return is_noalias_path(aqb, e1) && is_noalias_path(aqb, e2);
  case &SeqExp_e(_,e2): fallthru(e2);
  case &Cast_e(_,e2,...): return is_noalias_path(aqb,e2);
  case &StmtExp_e(s):
    while(true)
      switch(s->r) {
      case &Seq_s(s1,s2): s = s2; break;
      case &Decl_s(d,s1): s = s1; break;
      case &Exp_s(e): return is_noalias_path(aqb, e);
      default: Warn::impos2("is_noalias_stmt_exp: ill-formed StmtExp");
      }
  default: return true;
  }
}

// used by address of.
// Ensure e is an lvalue or function designator.
// Return if &e is const (true for const) and what region e is in (via a type
//    of RgnKind) 
// FIX: not sure const is sufficient to prevent assigning to a function
//      designator???
// Type errors should already have been reported, so we often silently return
//   a bogus answer to avoid duplicate errors.
// Note: regions might not be resolved (unification is order-dependent),
//   but that's okay because a later unification will ensure soundness.
// Note: As explained below, if e1 is a FixedArray, then &e1[e2] is only
//   legal if e1 is an lvalue.  This is not true in C, but I need it, at least
//   for now, and I doubt anyone minds.
$(bool,type_t) addressof_props(exp_t e) {
  // in some situations, the pointer must actually be const
  $(bool,type_t) bogus_ans = $(false, heap_rgn_type);
  switch (e->r) {
  case &Var_e(x):
    // where oh where does my variable live?
    switch(x) {
    case &Unresolved_b(_):
    case &Funname_b(_): return bogus_ans;
    case &Global_b(vd):
      switch (compress((type_t)e->topt)) {
	// arrays cannot be modified
      case &ArrayType(_): return $(true, heap_rgn_type);
      default: return $(vd->tq.real_const,heap_rgn_type);
      }
    case &Local_b(vd):
      switch (compress((type_t)e->topt)) {
      case &ArrayType(_): return $(true, (type_t)vd->rgn);
      default:
        vd->escapes = true;
        return $(vd->tq.real_const, (type_t)vd->rgn);
      }
    case &Pat_b(vd):   fallthru(vd);
    case &Param_b(vd):
      vd->escapes = true;
      return $(vd->tq.real_const, (type_t)vd->rgn);
    }
  case &AggrMember_e(e1,f,is_tagged,_):
    // disallow & on @tagged union members -- see Dan's ESOP paper
    if (is_tagged) return bogus_ans;
    // we have an unboxed thing, so we inherit e2's region
    // must check that f isn't a bitfield.
    switch (compress((type_t)e1->topt)) {
    case &AnonAggrType(_,_,fs):
      let finfo = lookup_field(fs,f);
      if(finfo != NULL && finfo->width == NULL) {
        let $(c,t) = addressof_props(e1);
	return $(finfo->tq.real_const || c, t);
      }
      return bogus_ans;
    case &AppType(&AggrCon({.KnownAggr = &ad}),_):
      let finfo = lookup_decl_field(ad,f);
      if(finfo != NULL && finfo->width == NULL) {
        let $(c,t) = addressof_props(e1);
	return $(finfo->tq.real_const || c, t);
      }
      return bogus_ans;
    default: return bogus_ans;
    }
  case &AggrArrow_e(e1,f,is_tagged,_):
    // disallow & on @tagged union members -- see Dan's ESOP paper
    if (is_tagged) return bogus_ans;
    // we have a boxed thing, so the region is in the pointer-type.
    // must check that f isn't a bitfield. 
    switch (compress((type_t)e1->topt)) {
    case &PointerType(PtrInfo(t1,_,PtrAtts(r,...))):
      struct Aggrfield * finfo;
      switch (compress(t1)) {
      case &AnonAggrType(_,_,fs):
	finfo = lookup_field(fs,f); break;
      case &AppType(&AggrCon({.KnownAggr = &ad}),_):
	finfo = lookup_decl_field(ad,f); break;
      default: return bogus_ans;
      }
      if(finfo != NULL && finfo->width == NULL)
	return $(finfo->tq.real_const, r);
      return bogus_ans;
    default: return bogus_ans;
    }
  case &Deref_e(e1):
    // we have a boxed thing, so the region is in the pointer-type.
    switch (compress((type_t)e1->topt)) {
    case &PointerType(PtrInfo(_,tq,PtrAtts(r,...))):
      return $(tq.real_const, r); // FIX: is tq set correctly?
    default: return bogus_ans;
    }
  case &Subscript_e(e1,e2):
    // here we need to figure out whether we've got a boxed thing
    // or not because [] is overloaded for all array kinds, and tuples
    type_t t = compress((type_t)e1->topt);
    switch (t) {
    case &PointerType(PtrInfo(_,tq,PtrAtts(r,...))):
      return $(tq.real_const,r);
    case &ArrayType(ArrayInfo{_,tq,...}):
      // Actually, this should be impossible since we've surely
      // promoted e1 to a pointer.
      // NOTE: Unlike C, we cannot allow any e1 -- it must be an lvalue.
      // (C doesn't need to know the region and we do!)
      return $(tq.real_const, addressof_props(e1)[1]);
    default: return bogus_ans;
    }
  default:
    Warn::err2(e->loc,"unary & applied to non-lvalue");
    return bogus_ans;
  }
}

// give an error when we can statically tell that the array bounds aren't
// large enough -- if the bounds are unconstrained, set them to i+1.
void check_bound(seg_t loc, unsigned int i, ptrbound_t b, bool do_warn) {
  let eopt = get_bounds_exp(bounds_one(),b);
  if (eopt == NULL) return; // fat bounds checked dynamically
  let $(j,known) = Evexp::eval_const_uint_exp(eopt);
  if(known && j <= i)
    (do_warn ? Warn::warn2 : Warn::err2)(loc,"a dereference is out of bounds: ",
					 j, " <= ", i);
  return;
}

void check_nonzero_bound(seg_t loc, ptrbound_t b) {
  check_bound(loc, 0, b, false);
}
// FIX: there are other expressions we could allow, such as
// &(x->y) or &(x[0]) that we do not support here...
// RENAME
// Actually need to distinguish two kinds of constant expressions, as in ANSI C
// This is now sort of for top-level expressions
static bool cnst_exp(bool var_okay, exp_t e) {
  let rec = cnst_exp;
  switch (e->r) {
  case &Const_e(_):
  case &Pragma_e(...):
  case &Sizeoftype_e(_):
  case &Sizeofexp_e(_):
  case &Offsetof_e(_,_):
  case &Enum_e(...):
  case &AnonEnum_e(...): return true;
  case &Var_e(b):
    // NB: top-level function names and arrays are "constant"
    // Ignore unbound variables b/c should be reported elsewhere
    switch (b) {
    case &Funname_b(_): return true;
    case &Global_b(vd):
      switch (compress(vd->type)) {
      case &ArrayType(_):
      case &FnType(_): return true;
      default: return var_okay;
      }
    case &Local_b(vd):     // local variables are OK if they are static
      if(vd->sc != Static)
	return var_okay;
      switch (compress(vd->type)) {
      case &ArrayType(_):
      case &FnType(_): return true;
      default: return var_okay;
      }
    case &Unresolved_b(_): return false;
    default: return var_okay;
    }
  case &Conditional_e(e1,e2,e3): 
    return rec(false,e1) && rec(false,e2) && rec(false,e3);
  case &SeqExp_e(e1,e2): return rec(false,e1) && rec(false,e2);
  case &Extension_e(e2):     fallthru(e2);
  case &NoInstantiate_e(e2): fallthru(e2);
  case &Instantiate_e(e2,_): fallthru(e2);
  case &Cast_e(_,e2,_,_):
    // FIX: We cannot allow casts w/ run-time effect b/c C will complain!
    return cnst_exp(var_okay,e2);
  case &Address_e(e2): return rec(true,e2);
  case &Comprehension_e(_,e1,e2,_): return rec(false,e1) && rec(false,e2);
  case &ComprehensionNoinit_e(e,_,_): return rec(false,e);
  case &Array_e(des):        fallthru(des);
  case &AnonStruct_e(_,_,des): fallthru(des);
  case &Aggregate_e(_,_,des,_):
    for (; des != NULL; des = des->tl)
      if (!cnst_exp(false,(*des->hd)[1]))
        return false;
    return true;
  case &Primop_e(_,es): fallthru(es);
  case &Datatype_e(es,_,_):
    for (; es != NULL; es = es->tl)
      if (!cnst_exp(false,es->hd))
        return false;
    return true;
  case &StmtExp_e(s): // special-case b/c of gcc 3.4 bug we are avoiding
    switch(s->r) {
    case &Exp_s(e): return cnst_exp(var_okay,e);
    default: return false;
    }
  default: return false;
  }
}
bool is_const_exp(exp_t e) {
  return cnst_exp(false,e);
}

static bool fields_zeroable(list_t<tvar_t>,list_t<type_t>,list_t<aggrfield_t>);
bool zeroable_type(type_t t) {
  switch (compress(t)) {
  case &AppType(c,ts):
    switch (c) {
    case &VoidCon:
    case &IntCon(_,_):
    case &ComplexCon: 
    case &FloatCon(_): return true;
    case &EnumCon(_,edo): // Not all enums have a 0!
      if(edo==NULL || edo->fields==NULL)
	return false;
      fallthru(edo->fields->v);
    case &AnonEnumCon(fs):
      for(let fs2 = fs; fs2 != NULL; fs2 = fs2->tl) {
	if(fs2->hd->tag == NULL) // DJG: Impossible?
	  return fs2 == fs; // first field would actually be a 0
	let $(i,known)= Evexp::eval_const_uint_exp((exp_t)fs2->hd->tag);
	if(known && i==0)
	  return true;
      }
      return false;
	
    case &AggrCon(info):
      let ad = get_known_aggrdecl(info);
      if(ad->impl == NULL) return false;
      if(ad->impl->exist_vars != NULL) return false; // FIX?
      if(ad->kind==UnionA && ad->impl->tagged) return false;
      return fields_zeroable(ad->tvs, ts, ad->impl->fields);
    default: return false;
    }
  case &PointerType(PtrInfo(_,_,PtrAtts(_,n,...))): 
    return force_type2bool(true,n);
  case &ArrayType(ArrayInfo{t,...}): return zeroable_type(t);
  case &AnonAggrType(_,_,fs): return fields_zeroable(NULL,NULL,fs); //never tagged
  default: return false;
  }
}
static bool fields_zeroable(list_t<tvar_t> tvs, list_t<type_t> ts,
			    list_t<aggrfield_t> fs) {
  region rgn; 
  let inst = List::rzip(rgn,rgn,tvs,ts);
  for (; fs != NULL; fs = fs->tl) {
    type_t t = fs->hd->type;
    if (zeroable_type(t)) continue;
    t = rsubstitute(rgn,inst,fs->hd->type);
    if (!zeroable_type(t)) return false;
  }
  return true;
}

// issue a warning if the type is a typedef with non-empty qualifiers
void check_no_qual(seg_t loc, type_t t) {
  switch (t) {
  case &TypedefType(_,_,tdopt,_):
    if(tdopt==NULL)
      return;
    let tq = tdopt->tq;
    if (tq.print_const || tq.q_volatile || tq.q_restrict || tq.real_const)
      Warn::warn2(loc,"qualifier within typedef type ",t," is ignored");
    return;
  default: return;
  }
}

// return the number of elements in an array or pointer type (if present)
exp_opt_t get_type_bound(type_t t) {
  switch (compress(t)) {
  case &PointerType(pi): return get_bounds_exp(bounds_one(),pi.ptr_atts.bounds);
  case &ArrayType(ArrayInfo{.num_elts = e,...}): return e;
  default: return NULL;
  }
}

// If b is a non-escaping variable binding, return a non-null pointer to
// the vardecl.  Mostly used by the relations code in the flow analysis.
struct Vardecl *nonesc_vardecl(binding_t b) {
  switch (b) {
  case &Pat_b(x):   fallthru(x);
  case &Local_b(x): fallthru(x);
  case &Param_b(x): fallthru(x);
  case &Global_b(x): return x->escapes ? NULL : x;
  default: return NULL;
  }
}

// removes NULL members; reverses the list
list_t<`a> filter_nulls(list_t<`a*> l) {
  let res = NULL;
  for (; l != NULL; l=l->tl)
    if (l->hd != NULL) res = new List(*l->hd,res);
  return res;
}

type_t promote_array(type_t t, type_t rgn, aqualtype_t aqual, bool convert_tag) {
  switch(compress(t)) { 
  case &ArrayType(ArrayInfo(et,tq,eopt,zt,_)):
    ptrbound_t b;
    if (eopt == NULL)
      b = fat_bound_type;
    else if (convert_tag) {
      if (eopt->topt == NULL)
	Warn::impos2("cannot convert tag without type!");
      switch(compress((type_t)eopt->topt)) {
      case &AppType(&TagCon,&List{t,_}):
	//b = thin_bounds_exp(cast_exp(uint_type,valueof_exp(t,0),false,No_coercion,0));
	b = thin_bounds_exp(valueof_exp(t,0));
	break;
      default: b = is_const_exp(eopt) ? thin_bounds_exp(eopt) : fat_bound_type;
      }
    } else
      b = thin_bounds_exp(eopt);
    return atb_type(et,rgn,aqual,tq,b,zt,false_type);
  default: return t;
  }
}

static bool aquals_bnds_pred($(type_t, type_t)@ bnd) {
  switch((*bnd)[0]) {
  case &AppType(&AqualsCon, _):
    return true;
  default:
    return false;
  }
}

list_t<$(type_t, type_t)@> get_aquals_bounds(fndecl_t fd) {
  //  return List::filter(aquals_bnds_pred, fd->i.qual_bnd);
  return fd->i.qual_bnd;
}

//extract the top-level alias qualifier if there is one
type_opt_t eval_aquals_of(aqualbnds_t aqb, type_t t) {
  switch(t) {
  case &PointerType(PtrInfo(_,_,PtrAtts(_,_,_,_,_,_,aq))):  
    return aq;
  case &VarType(_):
    return lookup_aquals(aqb, t);
  default:
    return NULL;
  }
}

$(tvar_t, bool)@ tvar_bool_pair(bool b, tvar_t t){
  return new $(t, b);
}

