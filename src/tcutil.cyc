/* Utility functions for type checking.
   Copyright (C) 2001 Greg Morrisett, AT&T
   This file is part of the Cyclone compiler.

   The Cyclone compiler is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   The Cyclone compiler is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with the Cyclone compiler; see the file COPYING. If not,
   write to the Free Software Foundation, Inc., 59 Temple Place -
   Suite 330, Boston, MA 02111-1307, USA. */

#include "absynpp.h"
#include <string.h>
#include "warn.h"
#include "evexp.h"
#include "tcutil.h"
#include "tcexp.h"
#include "tc.h"
#include "cyclone.h"
#include "relations.h"

using Core;
using List;
using Set;
using Absyn;
using Absynpp;
using Tcenv;

namespace Tcutil;

datatype exn {Unify};
datacon(exn,Unify);

extern void unify_it(type_t t1, type_t t2);

// flag to control whether or not we print a warning when implicitly casting
// a pointer from one region into another due to outlives constraints.
bool warn_region_coerce = false;

// Variables set to indicate where a failure occurs
type_t t1_failure = &VoidType_val;
bool tq1_const = false; // optional qualifier for t1_failure
type_t t2_failure = &VoidType_val;
bool tq2_const = false; // optional qualifier for t2_failure
// why the unification failed
const char ? failure_reason = NULL;
// print out an explanation about where and why a type error
// occurred -- this augments the high-level information with
// low-level specific details.
void explain_failure() {
  if(Position::num_errors >= Position::max_errors) return;
  fflush(stderr);

  // for qualifier mismatches, there's no need to print out the types
  if (strcmp("(qualifiers don't match)", failure_reason) == 0) {
    fprintf(stderr, "  %s\n",failure_reason);
    return;
  }
  // for effects, we need to tell the pretty printer to print them out
  if (strcmp("(function effects do not match)", failure_reason) == 0) {
    let p = Absynpp::tc_params_r;
    p.print_all_effects = true;
    Absynpp::set_params(&p);
  }
  string_t s1 = typ2string(t1_failure);
  string_t s2 = typ2string(t2_failure);
  int pos = 2;
  fprintf(stderr,"  %s",s1);
  pos += numelts(s1);
  if (pos + 5 >= 80) {
    fprintf(stderr,"\n\t");
    pos = 8;
  } else {
    fprintf(stderr," ");
    pos++;
  }
  fprintf(stderr,"and ");
  pos += 4;
  if (pos + numelts(s2) >= 80) {
    fprintf(stderr,"\n\t");
    pos = 8;
  }
  fprintf(stderr,"%s ",s2);
  pos += numelts(s2)+1;
  if (pos + 17 >= 80) {
    fprintf(stderr,"\n\t");
    pos = 8;
  }
  fprintf(stderr,"are not compatible. ");
  pos += 17;
  if (failure_reason != NULL) {
    if (pos+strlen(failure_reason) >= 80) {
      fprintf(stderr,"\n\t");
    };
    fprintf(stderr,"%s",failure_reason);
  }
  fprintf(stderr,"\n");
  fflush(stderr);
}

void terr(seg_t loc, string_t fmt, ... inject parg_t ap)
  __attribute__((format(printf,2,3))) {
  Position::post_error(Position::mk_err(loc,vrprintf(heap_region,fmt,ap)));
}
`a impos(string_t fmt, ... inject parg_t ap)
  __attribute__((format(printf,1,2), noreturn))
{
  string_t msg = vrprintf(heap_region,fmt,ap);
  fprintf(stderr,"Compiler Error (Tcutil::impos): %s\n",msg);
  fflush(stderr);
  throw new Impossible(msg);
}
void warn(seg_t sg, string_t fmt, ... inject parg_t ap)
  __attribute__((format(printf,2,3))) {
  Warn::vwarn(sg, fmt, ap);
}

//fast type-variable comparison -- can only be used when a tvar has an identity.
static int fast_tvar_cmp(tvar_t tv1, tvar_t tv2) {
  return (tv1->identity - tv2->identity);
}

// compress out any evars or typedefs or type declarations
type_t compress(type_t t) {
  switch (t) {
  case &Evar(_,NULL,_,_):
  case &TypedefType(_,_,_,NULL): return t;
  case &TypedefType(_,_,_,*topt_ref): // TRICKY
    type_t ta = (type_t)(*topt_ref);
    type_t t2 = compress(ta);
    if (t2 != ta)
      *topt_ref = t2;
    return t2;
  case &Evar(_,*t2opt_ref,_,_): // TRICKY
    type_t ta = (type_t)(*t2opt_ref);
    type_t t2 = compress(ta);
    if (t2 != ta)
      *t2opt_ref = t2;
    return t2;
  case &ValueofType(e):
    Evexp::eval_const_uint_exp(e);
    switch (e->r) {
    case &Valueof_e(t2): return compress(t2);
    default: return t;
    }
  case &TypeofType(e):
    let t2 = e->topt;
    if (t2 != NULL) return t2;
    else return t;
  case &TypeDeclType(_,&t):
    return compress(t);
  default: return t;
  }
}

// does a deep copy of a type to avoid sharing type variables.
// Note that any evars continue to be shared.  This should
// be run only before feeding the type to the well-formedness checker.
type_t copy_type(type_t t);
static list_t<type_t> copy_types(list_t<type_t> ts) {
  return List::map(copy_type, ts);
}
static conref_t<`a> copy_conref(conref_t<`a> cptr) {
  switch (cptr) {
  case &Constraint{.No_constr = _}: return empty_conref();
  case &Constraint{.Eq_constr = x}: return new_conref(x);
  case &Constraint{.Forward_constr = cr}: return copy_conref(cr);
  }
}
static kindbound_t copy_kindbound(kindbound_t kb) {
  switch (compress_kb(kb)) {
  case &Unknown_kb(_): return new Unknown_kb(NULL);
  case &Less_kb(_,k): return new Less_kb(NULL,k);
  default: return kb;
  }
}
static tvar_t copy_tvar(tvar_t tv) {
  // NB: loses sharing of identity here
  return new Tvar(tv->name,-1,copy_kindbound(tv->kind));
}
static $(var_opt_t,tqual_t,type_t)@
  copy_arg($(var_opt_t,tqual_t,type_t) @arg) {
  let &$(x,y,t) = arg;
  return new $(x,y,copy_type(t));
}
static $(tqual_t,type_t)@ copy_tqt($(tqual_t,type_t) @arg) {
  let &$(x,t) = arg;
  return new $(x,copy_type(t));
}
exp_opt_t deep_copy_exp_opt(bool preserve_types,exp_opt_t);

static aggrfield_t copy_field(aggrfield_t f) {
  return new Aggrfield{f->name,f->tq,copy_type(f->type),f->width,f->attributes,
                         deep_copy_exp_opt(true,f->requires_clause)};
}
static $(type_t,type_t)@ copy_rgncmp($(type_t,type_t)@ x) {
  let &$(r1,r2) = x;
  return new $(copy_type(r1),copy_type(r2));
}
static enumfield_t copy_enumfield(enumfield_t f) {
  return new Enumfield{f->name,f->tag,f->loc};
}
static type_t tvar2type(tvar_t t) {
  return new VarType(copy_tvar(t));
}

type_t copy_type(type_t t) {
  switch (compress(t)) {
  case &VoidType:
  case &Evar(_,_,_,_): return t;
  case &VarType(tv): return new VarType(copy_tvar(tv));
  case &DatatypeType(DatatypeInfo{tui,targs}):
    return new DatatypeType(DatatypeInfo{tui,copy_types(targs)});
  case &DatatypeFieldType(DatatypeFieldInfo{fi,targs}):
    return new DatatypeFieldType(DatatypeFieldInfo{fi,copy_types(targs)});
  case &PointerType(PtrInfo(elt,tq,PtrAtts(rgn,nbl,bs,zt,loc))):
    let elt2 = copy_type(elt);
    let rgn2 = copy_type(rgn);
    let nbl2 = copy_conref(nbl);
    let tq2 = tq;
    // Fix?  Need to copy the expression in here?
    let bs2 = copy_conref(bs);
    let zt2 = copy_conref(zt);
    return new PointerType(PtrInfo(elt2,tq2,PtrAtts(rgn2,nbl2,bs2,zt2,loc)));
  case &IntType(_,_):
  case &FloatType(_): return t;
  case &ArrayType(ArrayInfo{et,tq,eopt,zt,ztl}):
    exp_opt_t eopt2 = deep_copy_exp_opt(true,eopt);
    return new ArrayType(ArrayInfo{copy_type(et),
                                   tq,eopt2,copy_conref(zt),ztl});
  case &FnType(FnInfo{tvs,effopt,rt_tq,rt,args,c_varargs,cyc_varargs,rgn_po,atts,req,req_rlns,ens,ens_rlns}):
    let tvs2 = List::map(copy_tvar,tvs);
    type_opt_t effopt2 = (effopt == NULL) ? NULL : copy_type((type_t)effopt);
    let rt2 = copy_type(rt);
    let args2 = List::map(copy_arg,args);
    let c_varargs2 = c_varargs;
    vararg_info_t * cyc_varargs2 = NULL;
    if (cyc_varargs != NULL) {
      vararg_info_t @cv = (vararg_info_t @)cyc_varargs;
      cyc_varargs2 = new VarargInfo{cv->name,cv->tq,copy_type(cv->type),
                                    cv->inject};
    }
    let rgn_po2 = List::map(copy_rgncmp,rgn_po);
    let atts2 = atts;
    let req2 = deep_copy_exp_opt(true,req);
    let req_rlns2 = Relations::copy_relns(heap_region, req_rlns);
    let ens2 = deep_copy_exp_opt(true,ens);
    let ens_rlns2 = Relations::copy_relns(heap_region, ens_rlns);
    return new FnType(FnInfo{tvs2,effopt2,rt_tq,rt2,args2,c_varargs2,
                               cyc_varargs2,rgn_po2,atts2,req2,req_rlns2,
                               ens2,ens_rlns2});
  case &TupleType(tqts): return new TupleType(List::map(copy_tqt,tqts));
  case &AggrType(AggrInfo({.UnknownAggr = $(k,n,tgd)},ts)):
    return new AggrType(AggrInfo(UnknownAggr(k,n,tgd),copy_types(ts)));
  case &AggrType(AggrInfo({.KnownAggr = adp},ts)):
    return new AggrType(AggrInfo(KnownAggr(adp),copy_types(ts)));
  case &AnonAggrType(k,fs): return new AnonAggrType(k,List::map(copy_field,fs));
  case &EnumType(tdn,fs): return new EnumType(tdn,fs);
  case &AnonEnumType(fs): return new AnonEnumType(List::map(copy_enumfield,fs));
  case &TagType(t): return new TagType(copy_type(t));
  case &ValueofType(e):
    // FIX: we should copy e
    return new ValueofType(e);
  case &TypeofType(e):
    // FIX: we should copy e
    return new TypeofType(e);
  case &RgnHandleType(t): return new RgnHandleType(copy_type(t));
  case &DynRgnType(t1,t2): return new DynRgnType(copy_type(t1),copy_type(t2));
  case &TypedefType(tdn,ts,td,_):
    return new TypedefType(tdn,copy_types(ts),td,NULL);
  case &UniqueRgn:
  case &RefCntRgn:
  case &BuiltinType(_,_):
  case &HeapRgn: return t;
  case &AccessEff(t): return new AccessEff(copy_type(t));
  case &JoinEff(ts): return new JoinEff(copy_types(ts));
  case &RgnsEff(t): return new RgnsEff(copy_type(t));
  // For these cases, we don't want to duplicate the definition
  case &TypeDeclType(&{.r = &Aggr_td(ad),...},_):
    let targs = List::map(tvar2type,ad->tvs);
    return new AggrType(AggrInfo(UnknownAggr(ad->kind,ad->name,false),targs));
  case &TypeDeclType(&{.r = &Enum_td(ed),...},_):
    return new EnumType(ed->name,NULL);
  case &TypeDeclType(&{.r = &Datatype_td(dd),...},_):
    let targs = List::map(tvar2type,dd->tvs);
    return new DatatypeType(DatatypeInfo{UnknownDatatype(UnknownDatatypeInfo{dd->name,false}),targs});
  }
}

// copies an expression and eliminates any typechecking annotations
#define DC deep_copy_exp
// static vardecl_t copy_vardecl(vardecl_t v) {
//   let &Vardecl(s,n,q,t,eopt,r,atts,esc) = v;
//   let eopt1 = eopt;
//   if (eopt != NULL) eopt1 = DC(eopt);
//   let r1 = r;
//   if (r != NULL) r1 = new Opt(r->v);
//   return new Vardecl(s,n,q,copy_type(t),eopt1,r1,atts,esc);
// }
static designator_t copy_designator(bool preserve_types, designator_t d) {
  switch (d) {
  case &ArrayElement(e): return new ArrayElement(DC(preserve_types,e));
  case &FieldName(v): return d;
  }
}
static $(list_t<designator_t>,exp_t)@
copy_eds(bool preserve_types,$(list_t<designator_t>,exp_t)@ e) {
  return new $(map_c(copy_designator,preserve_types,e[0][0]),DC(preserve_types,e[0][1]));
}
// does a deep copy, but not of vardecls, bindings
exp_t deep_copy_exp(bool preserve_types, exp_t e) {
  exp_t new_e;
  let pt = preserve_types;
  switch (e->r) {
  case &Const_e(c): new_e = const_exp(c,e->loc); break;
  case &Var_e(b):   new_e = varb_exp(b,e->loc);  break;
  case &Pragma_e(p): new_e = pragma_exp(p,e->loc); break;
  case &Primop_e(p, es): new_e = primop_exp(p, map_c(DC,pt,es),e->loc); break;
  case &AssignOp_e(e1,po,e2):
    new_e=assignop_exp(DC(pt,e1),po ? new Opt(po->v) : NULL,DC(pt,e2),e->loc);
    break;
  case &Increment_e(e1,i): new_e = increment_exp(DC(pt,e1),i,e->loc); break;
  case &Conditional_e(e1,e2,e3):
    new_e = conditional_exp(DC(pt,e1),DC(pt,e2),DC(pt,e3),e->loc); break;
  case &And_e(e1,e2): new_e = and_exp(DC(pt,e1),DC(pt,e2),e->loc); break;
  case &Or_e(e1,e2): new_e = or_exp(DC(pt,e1),DC(pt,e2),e->loc); break;
  case &SeqExp_e(e1,e2): new_e = seq_exp(DC(pt,e1),DC(pt,e2),e->loc); break;
  case &FnCall_e(e1,es,vci,resolved):
    switch (vci) {
    case &VarargCallInfo(n,is,vai):
      let &VarargInfo(nm,tq,t,i) = vai;
      new_e = new_exp(new FnCall_e
		     (DC(pt,e1),map_c(DC,pt,es),
		      new VarargCallInfo
		      (n,is,new VarargInfo(nm,tq,copy_type(t),i)),resolved),
		     e->loc);
      break;
    default:
      new_e=new_exp(new FnCall_e(DC(pt,e1),map_c(DC,pt,es),vci,resolved),e->loc);
      break;
    }
    break;
  case &Throw_e(e1,b): 
    new_e = b ? rethrow_exp(DC(pt,e1),e->loc) : throw_exp(DC(pt,e1),e->loc); 
    break;
  case &NoInstantiate_e(e1): new_e = noinstantiate_exp(DC(pt,e1),e->loc);
    break;
  case &Instantiate_e(e1,ts):
    new_e = instantiate_exp(DC(pt,e1),map(copy_type,ts),e->loc);
    break;
  case &Cast_e(t,e1,b,c):
    new_e = cast_exp(copy_type(t),DC(pt,e1),b,c,e->loc); break;
  case &Address_e(e1): new_e = address_exp(DC(pt,e1),e->loc); break;
  case &New_e(eo,e1):
    exp_opt_t eo1 = eo; if (eo != NULL) eo1 = DC(pt,eo);
    new_e = New_exp(eo1,DC(pt,e1),e->loc);
    break;
  case &Sizeoftyp_e(t): new_e = sizeoftyp_exp(copy_type(t),e->loc);
    break;
  case &Sizeofexp_e(e1): new_e = sizeofexp_exp(DC(pt,e1),e->loc); break;
  case &Offsetof_e(t,ofs):
    new_e = offsetof_exp(copy_type(t),ofs,e->loc); break;
  case &Deref_e(e1): new_e = deref_exp(DC(pt,e1),e->loc); break;
  case &AggrMember_e(e1,n,f1,f2):
    new_e = new_exp(new AggrMember_e(DC(pt,e1),n,f1,f2),e->loc); break;
  case &AggrArrow_e(e1,n,f1,f2):
    new_e = new_exp(new AggrArrow_e(DC(pt,e1),n,f1,f2),e->loc); break;
  case &Subscript_e(e1,e2): new_e = subscript_exp(DC(pt,e1),DC(pt,e2),e->loc);
    break;
  case &Tuple_e(es): new_e = tuple_exp(map_c(DC,pt,es),e->loc); break;
  case &CompoundLit_e(&$(vopt,tq,t),eds):
    var_opt_t vopt1 = vopt;
    if (vopt != NULL) vopt1 = vopt;
    new_e = new_exp(new CompoundLit_e(new $(vopt1,tq,copy_type(t)),
				     map_c(copy_eds,pt,eds)),e->loc);
    break;
  case &Array_e(eds): new_e = new_exp(new Array_e(map_c(copy_eds,pt,eds)),e->loc);
    break;
  case &Comprehension_e(vd,e1,e2,b):
    new_e = new_exp(new Comprehension_e(vd,DC(pt,e1),DC(pt,e2),b),e->loc);
    break;
  case &ComprehensionNoinit_e(e,t,b):
    new_e = new_exp(new ComprehensionNoinit_e(DC(pt,e),copy_type(t),b),
		   e->loc);
    break;
  case &Aggregate_e(n,ts,eds,agr):
    new_e = new_exp(new Aggregate_e(n,map(copy_type,ts),map_c(copy_eds,pt,eds),agr),
		   e->loc);
    break;
  case &AnonStruct_e(t,eds):
    new_e = new_exp(new AnonStruct_e(copy_type(t),map_c(copy_eds,pt,eds)),e->loc);
    break;
  case &Datatype_e(es,dtd,dtf):
    new_e = new_exp(new Datatype_e(map_c(DC,pt,es),dtd,dtf),e->loc);
    break;
  case &Enum_e(ed,ef): new_e = e; break;
  case &AnonEnum_e(t,ef):
    new_e = new_exp(new AnonEnum_e(copy_type(t),ef),e->loc);
    break;
  case &Malloc_e(MallocInfo(ic,r,t,n,res,inlc)):
    let e2 = copy_exp(e);
    exp_opt_t r1 = r; if (r != NULL) r1 = DC(pt,r);
    type_t *t1 = t; if (t != NULL) t1 = new copy_type(*t);
    e2->r = new Malloc_e(MallocInfo(ic,r1,t1,n,res,inlc));
    new_e = e2;
    break;
  case &Swap_e(e1,e2): new_e = swap_exp(DC(pt,e1),DC(pt,e2),e->loc); break;
  case &UnresolvedMem_e(nopt,eds):
    opt_t<typedef_name_t> nopt1 = nopt;
    if (nopt != NULL) nopt1 = new Opt(nopt->v);
    new_e = new_exp(new UnresolvedMem_e(nopt1,map_c(copy_eds,pt,eds)),e->loc);
    break;
  case &StmtExp_e(_):
    throw new Core::Failure("deep_copy: statement expressions unsupported");
  case &Tagcheck_e(e1, fn): new_e=new_exp(new Tagcheck_e(DC(pt,e1),fn),e->loc);
    break;
  case &Valueof_e(t): new_e = valueof_exp(copy_type(t),e->loc);
    break;
  case &Asm_e(v,s): new_e = asm_exp(v,s,e->loc); break;
  }
  // types/annotations are shared
  if (preserve_types) {
    new_e->topt = e->topt;
    new_e->annot = e->annot;
  }
  return new_e;
}

exp_opt_t deep_copy_exp_opt(bool preserve_types, exp_opt_t e) {
  if (e == NULL) return NULL;
  else return deep_copy_exp(preserve_types, e);
}

// Our lattice looks like this:
//          AbsType   EffKind  RgnKind  * Top
//             V                          V V
//          MemType               Aliasable Unique
//             V
//          BoxType
// Only used during unification -- we can constrain an Evar or VarType
// as long as we move down in the lattice.
bool kind_leq(kind_t ka1, kind_t ka2) {
  let &Kind(k1,a1) = ka1;
  let &Kind(k2,a2) = ka2;
  // check the kind part
  if (k1 != k2) {
    switch ($(k1,k2)) {
    case $(BoxKind, MemKind):
    case $(BoxKind, AnyKind):
    case $(MemKind, AnyKind): break;
    default: return false;
    }
  }
  // check the aliasable part
  if (a1 != a2) {
    switch ($(a1,a2)) {
    case $(Aliasable, Top):
    case $(Unique, Top): return true;
    default: return false;
    }
  }
  return true;
}

kind_t tvar_kind(tvar_t tv, kind_t def) {
  switch (compress_kb(tv->kind)) {
  case &Eq_kb(k): return k;
  case &Less_kb(_,k): return k;
  default:
    tv->kind = new Less_kb(NULL,def);
    return def;
  }
}

bool unify_kindbound(kindbound_t kb1, kindbound_t kb2) {
  switch $(compress_kb(kb1), compress_kb(kb2)) {
  case $(&Eq_kb(k1), &Eq_kb(k2)): return k1 == k2;
  case $(&Less_kb(*x,k2), &Eq_kb(k1)):
    if (kind_leq(k1,k2)) {
      *x = new Opt(kb2);
      return true;
    } else return false;
  case $(&Eq_kb(k1), &Less_kb(*x,k2)):
    if (kind_leq(k1,k2)) {
      *x = new Opt(kb1);
      return true;
    } else return false;
  case $(&Less_kb(*x,k1), &Less_kb(*y,k2)):
    if (kind_leq(k1,k2)) {
      *y = new Opt(kb1);
      return true;
    } else if (kind_leq(k2,k1)) {
      *x = new Opt(kb2);
      return true;
    } else return false;
  case $(&Unknown_kb(*x), y): fallthru(y,x);
  case $(y, &Unknown_kb(*x)):
    *x = new Opt(y);
    return true;
  }
}

$(tvar_t,kindbound_t) swap_kind(type_t t, kindbound_t kb) {
  switch (compress(t)) {
  case &VarType(tv):
    let oldkb = tv->kind;
    tv->kind = kb;
    return $(tv,oldkb);
  default:
    impos("swap_kind: cannot update the kind of %s", typ2string(t));
  }
}

// figures out the kind of a field in a struct or union; used
// by typ_kind below
static kind_t field_kind(type_t field_typ,
			 list_t<type_t> ts, list_t<tvar_t> tvs) {
  kind_t k = typ_kind(field_typ);
  if (ts != NULL && (k == &ak || k == &tak)) {
    // we have to substitute here, because the last type might be
    // instantiated with a ground type.
    region temp;
    let inst = NULL;
    // filter out type vars that aren't abstract or int in in the instantiation
    for (; tvs != NULL; tvs=tvs->tl, ts=ts->tl) {
      let tv = tvs->hd;
      let t = ts->hd;
      switch (tvar_kind(tv,&bk)) {
      case &{.kind = IntKind, ...}:
      case &{.kind = AnyKind, ...}:
	inst = rnew(temp) List(rnew(temp) $(tv,t), inst); break;
      default: break;
      }
    }
    if (inst != NULL) {
      field_typ = rsubstitute(temp,List::imp_rev(inst),field_typ);
      k = typ_kind(field_typ);
    }
  }
  return k;
}

// Return the "least" kind of a type, according to the lattice above
// In some situations, we have to be conservative...
// Note that both Evars and VarTypes should have their kinds established
// by this point.
kind_t typ_kind(type_t t) {
  switch (compress(t)) {
  case &Evar(k,_,_,_):    return k->v;
  case &VarType(tv):      return tvar_kind(tv,&bk);
  case &VoidType:         return &mk;
    // FIX: we're assuming sizeof(int) = sizeof(long) = sizeof(void *) here
  case &IntType(_,sz):    return (sz==(size_of_t)Int_sz ||
                                  sz==(size_of_t)Long_sz) ? &bk : &mk;
  case &FloatType(_):     return &mk;
  case &FnType(_):        return &ak;
  case &DynRgnType(_,_):
  case &EnumType(_,_):
  case &AnonEnumType(_):
  case &RgnHandleType(_): return &bk;
  case &UniqueRgn:	  return &urk;
  case &HeapRgn:          return &rk;
  case &RefCntRgn:	  return &trk;
  case &DatatypeType(...):
    // datatypes always have abstract kind
    return &ak;
  case &DatatypeFieldType(DatatypeFieldInfo({.KnownDatatypefield = $(tud,tuf)},_)):
    return &mk;
  case &DatatypeFieldType(DatatypeFieldInfo({.UnknownDatatypefield = _},_)):
    impos("typ_kind: Unresolved DatatypeFieldType");
    // for structs or unions without definitions, we must be
    // conservative and treat them as having AnyKind
  case &AggrType(AggrInfo({.UnknownAggr = _},_)): return &ak;
  case &AggrType(AggrInfo({.KnownAggr = & &Aggrdecl(strOrU,_,_,tvs,i,_,expected_mem_kind)},ts)):
    if (i == NULL) {
      if (expected_mem_kind)
        return &mk;
      else 
        return &ak;
    }
    let fields = i->fields;
    if (fields == NULL) return &mk;
    // the kind of a struct depends upon the kind of its last field
    if (strOrU == StructA) {
      for (; fields->tl != NULL; fields = fields->tl);
      let last_type = fields->hd->type;
      let k = field_kind(last_type, ts, tvs);
      if (k == &ak || k == &tak) return k;
    }
    // the kind of a union depends upon the kind of all its fields
    else {
      for (; fields != NULL; fields = fields->tl) {
	let typ = fields->hd->type;
	let k = field_kind(typ, ts, tvs);
	if (k == &ak || k == &tak) return k;
      }
    }
    return &mk;
  case &AnonAggrType(_,_): return &mk;
  case &PointerType(pinfo):
    switch (conref_def((bounds_t)&DynEither_b_val,pinfo.ptr_atts.bounds)) {
    case &DynEither_b:
      switch (typ_kind(pinfo.ptr_atts.rgn)->aliasqual) {
      case Aliasable: return &mk;
      case Unique: return &umk;
      case Top: return &tmk;
      }
    case &Upper_b(_):
      switch (typ_kind(pinfo.ptr_atts.rgn)->aliasqual) {
      case Aliasable: return &bk;
      case Unique: return &ubk;
      case Top: return &tbk;
      }
    }
  case &ValueofType(_): return &ik;
  case &BuiltinType(_,k): return k;
  case &TypeofType(_): 
    // compress should've returned the type of the expression if we know it.
    // if we don't, then we must treat it as abstract.
    return &ak; 
  case &TagType(_): return &bk;
  case &ArrayType(ArrayInfo{_,_,num_elts,_,_}):
    if (num_elts == NULL || is_const_exp(num_elts)) return &mk;
    return &ak;
  case &TupleType(_): return &mk;
  case &TypedefType(_,_,td,_):
    if (td == NULL || td->kind == NULL)
      impos("typ_kind: typedef found: %s", typ2string(t));
    return td->kind->v;
  case &TypeDeclType(&{.r = &Aggr_td(_),...},_): return &ak;
  case &TypeDeclType(&{.r = &Enum_td(_),...},_): return &bk;
  case &TypeDeclType(&{.r = &Datatype_td(_),...},_): return &ak;
  case &AccessEff(_):
  case &JoinEff(_):
  case &RgnsEff(_): return &ek;
  }
}

bool kind_eq(kind_t k1, kind_t k2) {
  return k1 == k2 || (k1->kind == k2->kind && k1->aliasqual == k2->aliasqual);
}

// unify types t1 and t2, returning true iff the unification succeeds
bool unify(type_t t1, type_t t2) {
  try {
    unify_it(t1,t2);
    return true;
  } catch { case &Unify: return false; }
}

// see if evar occurs within t and also check that every free type
// variable in t occurs within the list env.
static void occurslist(type_t evar, region_t<`r> r, list_t<tvar_t,`r> env, list_t<type_t> ts); // mutually recursive fns
static void occurs(type_t evar,region_t<`r> r,list_t<tvar_t,`r> env,type_t t) {
  t = compress(t);
  switch (t) {
  case &VarType(tv):
    if (!List::mem(fast_tvar_cmp,env,tv)) {
      failure_reason = "(type variable would escape scope)";
      throw &Unify_val;
    }
    break;
  case &Evar(_,rg,_,*sopt):
    if (t == evar) {
      failure_reason = "(occurs check)";
      throw &Unify_val;
    }
    else if (rg != NULL) occurs(evar,r,env,rg);
    else {
      // check to see if sopt is a subset of env
      bool problem = false;
      for (_ s = (*sopt)->v; s != NULL; s = s->tl) {
        if (!List::mem(fast_tvar_cmp,env,s->hd)) {
          problem = true; break;
        }
      }
      // for sopt to be a subset of env
      if (problem) {
        let result = NULL;
        for (_ s = (*sopt)->v; s != NULL; s = s->tl) {
          if (List::mem(fast_tvar_cmp,env,s->hd))
            result = new List(s->hd,result);
        }
        *sopt = new Opt(result);
      }
    }
    break;
    // FIX: shouldn't we check for occurrence within the bound?
  case &PointerType(pinfo):
    occurs(evar,r,env,pinfo.elt_typ);
    occurs(evar,r,env,pinfo.ptr_atts.rgn);
    break;
    // FIX: shouldn't we check for occurrence within the bound?
  case &ArrayType(ArrayInfo{t2,_,_,_,_}): occurs(evar,r,env,t2); break;
    // FIX: shouldn't we check for occurrence within requires and ensures clauses?
  case &FnType(FnInfo{tvs,eff,rt_tq,rt,args,c_varargs,cyc_varargs,rgn_po,atts,req,req_relns,ens,ens_relns}):
    env = List::rappend(r,tvs,env);
    if (eff != NULL) occurs(evar,r,env,eff);
    occurs(evar,r,env,rt);
    for(; args != NULL; args = args->tl)
      occurs(evar,r,env,(*args->hd)[2]);
    if (cyc_varargs != NULL)
      occurs(evar,r,env,cyc_varargs->type);
    for (; rgn_po != NULL; rgn_po = rgn_po->tl) {
      let &$(r1,r2) = rgn_po->hd;
      occurs(evar,r,env,r1);
      occurs(evar,r,env,r2);
    }
    break;
  case &TupleType(args):
    for(; args != NULL; args = args->tl)
      occurs(evar,r,env,(*args->hd)[1]);
    break;
  case &DatatypeType(DatatypeInfo{_,ts}):
    occurslist(evar,r,env,ts); break;
  case &TypedefType(_,ts,_,_): fallthru(ts);
  case &DatatypeFieldType(DatatypeFieldInfo{_,ts}): fallthru(ts);
  case &AggrType(AggrInfo(_,ts)): occurslist(evar,r,env,ts); break;
  case &AnonAggrType(_,fs):
    // FIX: shouldn't we check for occurrence within the requires clauses?
    for (; fs != NULL; fs = fs->tl)
      occurs(evar, r, env, fs->hd->type);
    break;
  case &TagType(t0): fallthru(t0);
  case &AccessEff(t0): fallthru(t0);
  case &RgnHandleType(t0): fallthru(t0);
  case &RgnsEff(t0): occurs(evar,r,env,t0); break;
  case &JoinEff(ts): occurslist(evar,r,env,ts); break;
    // FIX: should check within expression of ValueofType(e)
    // FIX: should check within expression of TypeofType(e)
  default: break;
  }
}
static void occurslist(type_t evar, region_t<`r> r, list_t<tvar_t,`r> env,
                       list_t<type_t> ts) {
  for (; ts != NULL; ts = ts->tl)
    occurs(evar,r,env,ts->hd);
}

// unify two lists of types
static void unify_list(list_t<type_t> t1, list_t<type_t> t2) {
  for (; t1 != NULL && t2 != NULL; t1 = t1->tl, t2 = t2->tl)
    unify_it(t1->hd,t2->hd);
  if (t1 != NULL || t2 != NULL)
    throw &Unify_val;
}

// unify two type qualifiers -- throws Unify unless they are the same
static void unify_tqual(tqual_t tq1, type_t t1, tqual_t tq2, type_t t2) {
  if (tq1.print_const && !tq1.real_const)
    impos("tq1 real_const not set.");
  if (tq2.print_const && !tq2.real_const)
    impos("tq2 real_const not set.");

  if ((tq1.real_const != tq2.real_const)
      || (tq1.q_volatile != tq2.q_volatile)
      || (tq1.q_restrict != tq2.q_restrict)) {
    t1_failure = t1;
    t2_failure = t2;
    tq1_const = tq1.real_const;
    tq2_const = tq2.real_const;
    failure_reason = "(qualifiers don't match)";
    throw &Unify_val;
  }
  // clear these flags for error reporting purposes
  tq1_const = false;
  tq2_const = false;
}

bool equal_tqual(tqual_t tq1, tqual_t tq2) {
  return ((tq1.real_const == tq2.real_const)
	  && (tq1.q_volatile == tq2.q_volatile)
	  && (tq1.q_restrict == tq2.q_restrict));
}

// unify two constraint refs
static void unify_it_conrefs(int cmp(`a,`a), conref_t<`a> x, conref_t<`a> y,
                             string_t<`H> reason) {
  x = compress_conref(x);
  y = compress_conref(y);
  if (x == y) return;
  switch (x) {
  case &Constraint{.No_constr = _}:
    *x = Constraint{.Forward_constr = y}; return;
  case &Constraint{.Eq_constr = xv}:
    switch (y) {
    case &Constraint{.No_constr = _}: *y = *x; return;
    case &Constraint{.Eq_constr = yv}:
      if (cmp(xv,yv) != 0) {
        failure_reason = reason;
        throw &Unify_val;
      }
      return;
    case &Constraint{.Forward_constr = _}: impos("unify_conref: forward after compress(2)");
    }
  case &Constraint{.Forward_constr = _}: impos("unify_conref: forward after compress");
  }
}

static bool unify_conrefs(int cmp(`a,`a), conref_t<`a> x, conref_t<`a> y) {
  try {
    unify_it_conrefs(cmp,x,y,NULL);
    return true;
  } catch { case &Unify: return false; }
}

static int boundscmp(bounds_t b1, bounds_t b2) {
  switch ($(b1,b2)) {
  case $(&DynEither_b,&DynEither_b): return 0;
  case $(&DynEither_b,_): return -1;
  case $(_,&DynEither_b): return 1;
  case $(&Upper_b(e1),&Upper_b(e2)): return Evexp::const_exp_cmp(e1,e2);
  }
}

static void unify_cmp_exp(exp_t e1, exp_t e2) {
  switch $(e1->r,e2->r) {
    // FIX: not sure it's safe to peek under the casts,
    // but we need to in order to unify something like
    // int@{40} and int@{(unsigned int)valueof(`EI3)}
  case $(&Cast_e(_,e,...),_): unify_cmp_exp(e,e2); return;
  case $(_,&Cast_e(_,e,...)): unify_cmp_exp(e1,e); return;
  case $(&Valueof_e(t),_): 
    switch (compress(t)) {
    case &Evar(...): unify_it(t,new ValueofType(e2)); return;
    default: throw &Unify_val;
    }
  case $(_,&Valueof_e(t)):
    switch (compress(t)) {
    case &Evar(...): unify_it(t,new ValueofType(e1)); return;
    default: throw &Unify_val;
    }
  default: throw &Unify_val;
  }
}

static int unify_it_bounds(bounds_t b1, bounds_t b2) {
  switch ($(b1,b2)) {
  case $(&DynEither_b,&DynEither_b): return 0;
  case $(&DynEither_b,_): return -1;
  case $(_,&DynEither_b): return 1;
  case $(&Upper_b(e1),&Upper_b(e2)): 
    int r = Evexp::const_exp_cmp(e1,e2);
    if (r == 0) return 0;
    try {
      unify_cmp_exp(e1,e2);
      return 0;
    } catch {
    case &Unify: return r;
    }
  }
}

static int attribute_case_number(attribute_t att) {
  switch(att) {
  case &Regparm_att(_): return 0;
  case &Stdcall_att: return 1;
  case &Cdecl_att: return 2;
  case &Fastcall_att: return 3;
  case &Noreturn_att: return 4;
  case &Const_att: return 5;
  case &Aligned_att(_): return 6;
  case &Packed_att: return 7;
  case &Section_att(_): return 8;
  case &Nocommon_att: return 9;
  case &Shared_att: return 10;
  case &Unused_att: return 11;
  case &Weak_att: return 12;
  case &Dllimport_att: return 13;
  case &Dllexport_att: return 14;
  case &No_instrument_function_att: return 15;
  case &Constructor_att: return 16;
  case &Destructor_att: return 17;
  case &No_check_memory_usage_att: return 18;
  case &Format_att(...): return 19;
  case &Initializes_att(_): return 20;
  case _: return 21;
  }
}

static int attribute_cmp(attribute_t att1, attribute_t att2) {
  switch($(att1,att2)) {
  case $(&Regparm_att(i1),&Regparm_att(i2)): fallthru(i1,i2);
  case $(&Initializes_att(i1), &Initializes_att(i2)): 
    return intcmp(i1,i2);
  case $(&Aligned_att(e1),&Aligned_att(e2)): 
    if (e1 == e2) return 0;
    if (e1 == NULL) return -1;
    if (e2 == NULL) return 1;
    return Evexp::const_exp_cmp(e1,e2);
  case $(&Section_att(s1),&Section_att(s2)): return strcmp(s1,s2);
  case $(&Format_att(ft1,i1,j1),&Format_att(ft2,i2,j2)):
    let ftc = intcmp((unsigned int)ft1, (unsigned int)ft2);
    if(ftc != 0) return ftc;
    let ic = intcmp(i1,i2);
    if(ic != 0) return ic;
    return intcmp(j1,j2);
  default:
    return intcmp(attribute_case_number(att1), attribute_case_number(att2));
  }
}

static bool equal_att(attribute_t a1, attribute_t a2) {
  return attribute_cmp(a1,a2)==0;
}

bool same_atts(attributes_t a1, attributes_t a2) {
  for (_ a = a1; a != NULL; a = a->tl)
    if (!List::exists_c(equal_att,a->hd,a2)) return false;
  for (_ a = a2; a != NULL; a = a->tl)
    if (!List::exists_c(equal_att,a->hd,a1)) return false;
  return true;
}

// forward declarations
static type_t rgns_of(type_t t);

static type_t rgns_of_field(aggrfield_t af) {
  return rgns_of(af->type);
}

static $(tvar_t,type_t)@ region_free_subst(tvar_t tv) {
  type_t t;
  switch (tvar_kind(tv,&bk)) {
  case &Kind(RgnKind,Unique):    t = &UniqueRgn_val; break;
  case &Kind(RgnKind,Aliasable): t = &HeapRgn_val;   break;
  case &Kind(EffKind,_):         t = empty_effect;   break;
  case &Kind(IntKind,_):         t = new ValueofType(uint_exp(0,0)); break;
  default:                       t = sint_typ; break; // lives in every kind
  }
  return new $(tv,t);
}

// Calculate the regions of a type and return as an effect -- used
// in normalizing effects.
// NOTE: does a lot of unncecessary allocation (e.g. regions_t<`a> reallocates
//       every time!)
static type_t rgns_of(type_t t) {
  switch (compress(t)) {
  case &VoidType:
  case &FloatType(_):
  case &EnumType(_,_):
  case &AnonEnumType(_):
  case &ValueofType(_):
  case &TypeofType(_):
  case &BuiltinType(_,_):
  case &IntType(_,_): return empty_effect;
  case &Evar(...):
  case &VarType(_):
    switch (typ_kind(t)) {
    case &Kind(RgnKind,_): return new AccessEff(t);
    case &Kind(EffKind,_): return t;
    case &Kind(IntKind,_): return empty_effect;
    default: return new RgnsEff(t);
    }
  case &RgnHandleType(t): return new AccessEff(t);
  case &DynRgnType(t1,t2):
    // Note: for dynregion_t<t1,t2>, we only include t2 as part of the
    // effect, since t1 is checked dynamically.
    return new AccessEff(t2);
  case &DatatypeType(DatatypeInfo{_,targs}):
    list_t<type_t> ts = map(rgns_of,targs);
    return normalize_effect(new JoinEff(ts));
  case &PointerType(PtrInfo(et,_,PtrAtts(r,_,_,_,_))):
    // ignoring a sizeof(int*`r) in the bounds -- nobody will notice
    return normalize_effect(new JoinEff(list(new AccessEff(r),rgns_of(et))));
  case &ArrayType(ArrayInfo{et,_,_,_,_}):
    return normalize_effect(rgns_of(et));
  case &TupleType(tqts):
    let ts = NULL;
    for (; tqts != NULL; tqts = tqts->tl)
      ts = new List((*tqts->hd)[1],ts);
    fallthru(ts);
  case &DatatypeFieldType(DatatypeFieldInfo{_,ts}): fallthru(ts);
  case &AggrType(AggrInfo(_,ts)):
    return normalize_effect(new JoinEff(map(rgns_of,ts)));
  case &AnonAggrType(_,fs):
    return normalize_effect(new JoinEff(map(rgns_of_field,fs)));
  case &TagType(_): return empty_effect;
  case &FnType(FnInfo{tvs,eff,rt_tq,rt,args,_,cyc_varargs,rpo,_,_,_,_,_}):
    // NOTE:  we define RgnsEff(t) in this case to be the regions in the
    // effect.  So, if the effect is smaller than the argument or return
    // types, they won't show up.  This saves us from a lot of complication
    // with varargs, etc. and should result in a smaller effect.  But it
    // might bite us someday...
    // HACK:  we substitute region-free types for the bound type variables
    // and then compute the regions of that.
    let e = substitute(map(region_free_subst,tvs),(type_t)eff);
    return normalize_effect(e);
  case &UniqueRgn:
  case &RefCntRgn:
  case &HeapRgn: return empty_effect;
  case &AccessEff(_):
  case &JoinEff(_): return t;
  case &RgnsEff(t2): return rgns_of(t2);
  case &TypedefType(_,ts,_,_):
    return normalize_effect(new JoinEff(map(rgns_of,ts)));
  case &TypeDeclType(...): impos("typedecl in rgns_of");
  }
}

// flattens out nested join effects when possible
// -- this has a side effect on the actual type when possible to
// memoize the computation.
type_t normalize_effect(type_t e) {
  e = compress(e);
  switch (e) {
  case &JoinEff(*es):
    bool redo_join = false; // Dan: changed from true
    for (_ effs = *es; effs != NULL; effs = effs->tl) {
      let eff = effs->hd;
      effs->hd = compress(normalize_effect(eff));
      switch (effs->hd) {
      case &JoinEff(_):
      case &AccessEff(&HeapRgn): 
      case &AccessEff(&RefCntRgn): 
      case &AccessEff(&UniqueRgn): redo_join = true; break;
      default: break;
      }
    }
    if (!redo_join) return e;
    list_t<type_t> effects = NULL;
    for (_ effs = *es; effs != NULL; effs = effs->tl) {
      switch (compress(effs->hd)) {
      case &JoinEff(nested_effs):
        effects = List::revappend(nested_effs,effects);
        break;
      case &AccessEff(&HeapRgn): 
      case &AccessEff(&RefCntRgn): 
      case &AccessEff(&UniqueRgn): break;
      case e: effects = new List(e,effects); break;
      }
    }
    *es = List::imp_rev(effects);
    return e;
  case &RgnsEff(t): // special cases to avoid allocation
    switch(compress(t)) {
    case &Evar(_,_,_,_):
    case &VarType(_): return e;
    default: return rgns_of(t);
    }
  default: return e;
  }
}

// Create a dummy type that includes the effect:  void (@`H)(;eff)
static type_t dummy_fntype(type_t eff) {
  let fntype = new FnType(FnInfo{.tvars=NULL,.effect=eff,
                                 .ret_tqual = empty_tqual(0),
                                 .ret_typ=&VoidType_val,.
                                 args=NULL,.c_varargs=false,
                                 .cyc_varargs=NULL,.rgn_po=NULL,
                                 .attributes = NULL, .requires_clause = NULL,
                                 .requires_relns = NULL,
                                 .ensures_clause = NULL,
                                 .ensures_relns = NULL});
  return atb_typ(fntype, &HeapRgn_val, empty_tqual(0), bounds_one, false_conref);
}


// Returns true if the region r is in the effect e or else r is the
// heap or unique region.  If constrain is true, this might cause region or
// effect evars to become constrained.
bool region_in_effect(bool constrain, type_t r, type_t e) {
  r = compress(r);
  if (r == &HeapRgn_val || r == &UniqueRgn_val || r == &RefCntRgn_val)
    return true;
  switch (compress(e)) {
  case &AccessEff(r2):
    // note:  might constrain a region variable unnecessarily
    if (constrain) return unify(r,r2);
    r2 = compress(r2);
    if (r == r2) return true;
    switch ($(r, r2)) {
    case $(&VarType(tv1), &VarType(tv2)): return (tvar_cmp(tv1,tv2) == 0);
    default: return false;
    }
  case &JoinEff(es):
    for (; es != NULL; es = es->tl)
      if (region_in_effect(constrain, r, es->hd)) return true;
    return false;
  case &RgnsEff(t):
    switch (rgns_of(t)) {
    case &RgnsEff(t):
      if (!constrain) return false;
      switch (compress(t)) {
      case &Evar(k,*p,_,s):
        // we found regions(ev) -- constrain ev to a dummy function type
        // t such that regions(t) = ev2+{`r} where ev2 is a fresh effect evar
        let ev = new_evar(&eko,s);
        // this has the effect of checking that any free variables in r
        // are contained in s.
        occurs(ev,heap_region,s->v,r);
        let new_typ = dummy_fntype(new JoinEff(list(ev,new AccessEff(r))));
        *p = new_typ;
        return true;
      default: return false;
      }
    case e2: return region_in_effect(constrain,r,e2);
    }
  case &Evar(k,*p,_,s):
    if (k == NULL || k->v->kind != EffKind)
      impos("effect evar has wrong kind");
    if (!constrain) return false;
    // we found a non-canonical evar -- we can grow it to include r
    // but this may cause problems later on with other constraints.
    let ev = new_evar(&eko,s);
    // this has the effect of checking that any free variables in r
    // are contained in s.
    occurs(ev,heap_region,s->v,r);
    let new_typ = new JoinEff(new List{ev,new List{new AccessEff(r),NULL}});
    *p = new_typ;
    return true;
  default: return false;
  }
}

// Returns true if the type t is in the effect e t as RgnsEff(t).
// If constrain is true, this might cause evars to become constrained.
// Note that t must either be an evar or a tvar.
static bool type_in_effect(bool may_constrain_evars, type_t t, type_t e) {
  t = compress(t);
  switch (normalize_effect(compress(e))) {
  case &AccessEff(_): return false;
  case &JoinEff(es):
    for (; es != NULL; es = es->tl)
      if (type_in_effect(may_constrain_evars, t, es->hd))
	return true;
    return false;
  case &RgnsEff(t2):
    t2 = compress(t2);
    if (t == t2) return true;
    if (may_constrain_evars) return unify(t,t2);
    switch (rgns_of(t)) {
    case &RgnsEff(t3):
      switch ($(compress(t3),t2)) {
      case $(&VarType(tv1),&VarType(tv2)): return unify(t,t2); // ???
      default: return t3 == t2;
      }
    case e2: return type_in_effect(may_constrain_evars,t,e2);
    }
  case &Evar(k,*p,_,s):
    if (k == NULL || k->v->kind != EffKind)
      impos("effect evar has wrong kind");
    if (!may_constrain_evars) return false;
    // we found a non-canonical evar -- we can grow it to include t
    // but this may cause problems later on with other constraints.
    let ev = new_evar(&eko,s);
    // this has the effect of checking that any free variables in t
    // are contained in s.
    occurs(ev,heap_region,s->v,t);
    let new_typ = new JoinEff(new List{ev,new List{new RgnsEff(t),NULL}});
    *p = new_typ;
    return true;
  default: return false;
  }
}


// Returns true if the effect type variable v is in the effect e.
// If constrain is true, this might cause effect evars to become constrained.
static bool variable_in_effect(bool may_constrain_evars, tvar_t v, type_t e) {
  e = compress(e);
  switch (e) {
  case &VarType(v2): return (tvar_cmp(v, v2) == 0);
  case &JoinEff(es):
    for (; es != NULL; es = es->tl)
      if (variable_in_effect(may_constrain_evars, v, es->hd))
	return true;
    return false;
  case &RgnsEff(t):
    switch (rgns_of(t)) {
    case &RgnsEff(t2):
      if (!may_constrain_evars) return false;
      switch (compress(t2)) {
      case &Evar(k,*p,_,s):
        // we found regions(ev) where ev is an evar -- set ev to
        // be a dummy type t such that regions(t) = ev2+`e where ev2
        // is a fresh evar.
        let ev = new_evar(&eko,s);
        // make sure v is in the allowed set of type variables in the evar
        if (!List::mem(fast_tvar_cmp,s->v,v)) return false;
        let new_typ = dummy_fntype(new JoinEff(list(ev,new VarType(v))));
        *p = new_typ;
        return true;
      default: return false;
      }
    case e2: return variable_in_effect(may_constrain_evars,v,e2);
    }
  case &Evar(k,*p,_,s):
    if (k == NULL || k->v->kind != EffKind)
      impos("effect evar has wrong kind");
    // we found a non-canonical evar -- we can grow it to include v
    // but this may cause problems later on with other constraints.
    let ev = new_evar(&eko,s);
    // make sure v is in the allowed set of type variables for the evar
    if (!List::mem(fast_tvar_cmp,s->v,v))
      return false;
    let new_typ = new JoinEff(new List{ev,new List{new VarType(v),NULL}});
    *p = new_typ;
    return true;
  default: return false;
  }
}

// Returns true if the effect evar ev is in the effect e.
static bool evar_in_effect(type_t evar, type_t e) {
  e = compress(e);
  switch (e) {
  case &JoinEff(es):
    for (; es != NULL; es = es->tl)
      if (evar_in_effect(evar, es->hd))
	return true;
    return false;
  case &RgnsEff(t):
    switch (rgns_of(t)) {
    case &RgnsEff(t2): return false;
    case e2: return evar_in_effect(evar, e2);
    }
  case &Evar(_,_,_,_): return (evar == e);
  default: return false;
  }
}

// Returns true when e1 is a sub-effect of e2 -- this isn't very
// efficient and can constrain both effect and region evars in
// unpredictable ways (though it tries hard not to).
// When set_to_empty is true, evars in e1 that do not occur in (or
// cannot easily be made to occur in) e2 are constrained to the
// empty effect (or HeapRgn for region evars).  This is the "right"
// thing for when a function call needs to constrain the effect to
// an upper bound.  When set_to_empty is false, we instantiate
// unconstrained evars in e1 to be e2.
bool subset_effect(bool may_constrain_evars, type_t e1, type_t e2) {
  // if e2 is of the form JoinEff(ev::rest) where ev is an effect evar,
  // then we can instantiate ev to JoinEff(ev'::e1) where ev' is fresh
  //fprintf(stderr,"checking subset_effect(%s,%s)\n",
  //        typ2string(e1),typ2string(e2));
  switch (compress(e1)) {
  case &JoinEff(es):
    for (; es != NULL; es = es->tl)
      if (!subset_effect(may_constrain_evars,es->hd,e2))
	return false;
    return true;
  case &AccessEff(r):
    // Try checking if the region is in the effect without performing
    // any unification first and only if this fails do we actually
    // go in and try to unify something.  It's not clear whether it's
    // best to just pin the region to HeapRgn or try to unify it with
    // some region already in the effect e2.  We used to try the latter, then
    // the former.  Now we just pick the former.
    return (region_in_effect(may_constrain_evars,r,e2)
	    || (may_constrain_evars && unify(r,&HeapRgn_val))); 
  case &VarType(v): return variable_in_effect(may_constrain_evars,v,e2);
  case &RgnsEff(t):
    switch (rgns_of(t)) {
    case &RgnsEff(t2):
      // similar to AccessEff(r) but we're grepping around for RgnsEff(t2)
      // within e2 -- if we don't find it, try unifying something, and
      // failing that, just try to pin it down to something without regions.
      return (type_in_effect(may_constrain_evars,t2,e2) ||
	      (may_constrain_evars && unify(t2,sint_typ)));
    case e: return subset_effect(may_constrain_evars,e,e2);
    }
  case &Evar(_,*p,_,s):
    if (!evar_in_effect(e1,e2)) {
      // We can set the evar to be any subset of e2.
      // Right now, we set it to the empty effect which may
      // not be the best solution...
      *p = empty_effect;
      // Another option would be to set it to e2.
      // *p = (type_opt_t)e2;
      return true;
    } else
      return false;
  default: impos("subset_effect: bad effect: %s",typ2string(e1));
  }
}

// "unify" two effects
//    * We simply check that one
//      effect is a "subset" of the other.  If necessary, we instantiate
//      region or effect evars to force the subset relation.  This may
//      cause region or effect evars to become pinned down in an undesirable
//       way...  But the situation should be rare, and if it happens, users
//       should fall back on explicit typing.
//
// What we should really do:  generate some set equalities and hold
// on to them.  Then try to simplify and solve them later on after
// things have become more constrained.
static bool unify_effect(type_t e1, type_t e2) {
  e1 = normalize_effect(e1);
  e2 = normalize_effect(e2);
  if(subset_effect(false, e1, e2) && subset_effect(false, e2, e1))
    return true;
  if(subset_effect(true, e1, e2) && subset_effect(true, e2, e1))
    return true;
  return false;
}

// returns true when rpo1 is a sub-partial order of rpo2.  By this
// we mean that every inequation in rpo1 is also in rpo2, or else
// the inequation in rpo is of the form `H <= t.  Note that
// this might constrain region variables.  Note also that we don't
// do any sort of transitive closure to figure out causalities.
// FIX:  this isn't complete or efficient by far...
static bool sub_rgnpo(list_t<$(type_t,type_t)@> rpo1,
                      list_t<$(type_t,type_t)@> rpo2) {
  for (_ r1 = rpo1; r1 != NULL; r1 = r1->tl) {
    let &$(t1a,t1b) = r1->hd;
    bool found = (t1a == &HeapRgn_val);
    for (_ r2 = rpo2; r2 != NULL && !found; r2 = r2->tl) {
      let &$(t2a,t2b) = r2->hd;
      if (unify(t1a,t2a) && unify(t1b,t2b)) {
        found = true;
        break;
      }
    }
    if (!found) return false;
  }
  return true;
}

typedef Relations::relns_t<`r> relns_t<`r>;

// e1 and e2 represent requires/ensures clauses and we're to check
// that e1 as a predicate implies e2.
static bool check_logical_implication(relns_t<`H> r1, relns_t<`H> r2) {
  for (; r2 != NULL; r2 = r2->tl) {
    let r = Relations::negate(heap_region,r2->hd);
    let relns = new List{r,r1};
    if (Relations::consistent_relations(relns)) return false;
  }
  return true;
}

// e1 and e2 represent requires/ensures clauses and we're to check
// logical equivalence.
static bool check_logical_equivalence(relns_t<`H> r1, relns_t<`H> r2) {
  if (r1 == r2) return true;
  return check_logical_implication(r1,r2) && check_logical_implication(r2,r1);
}

// see if two region partial-orders are the same
static bool same_rgn_po(list_t<$(type_t,type_t)@> rpo1,
                        list_t<$(type_t,type_t)@> rpo2) {
  return (sub_rgnpo(rpo1,rpo2) && sub_rgnpo(rpo2,rpo1));
}

// the real work of unification
void unify_it(type_t t1, type_t t2) {
  t1_failure = t1;
  t2_failure = t2;
  failure_reason = NULL;
  t1 = compress(t1);
  t2 = compress(t2);
  if (t1 == t2) return;
  switch (t1) {
  case &Evar(kind1,*ref1_ref,_,s1opt):
    // check that the evar doesn't occur in t2 and that any free variables
    // of t2 are contained in s1.
    occurs(t1,heap_region,s1opt->v,t2);
    let kind2 = typ_kind(t2);
    // we can constrain the Evar to be equal to t2 only when the kind of
    // the evar is greater than or equal to the kind of t2 or t2 is an
    // evar that we can constrain to be equal to t1.
    if (kind_leq(kind2,kind1->v)) {
      *ref1_ref = t2;
      return;
    } else {
      switch (t2) {
      case &Evar(_,*ref2_ref,_,s2opt):
        // check that s2 is a subset of s1
        let s1 = s1opt->v;
        for (_ s2 = s2opt->v; s2 != NULL; s2 = s2->tl) {
          if (!List::mem(fast_tvar_cmp,s1,s2->hd)) {
            failure_reason = "(type variable would escape scope)";
            throw &Unify_val;
          }
        }
        if (kind_leq(kind1->v,kind2)) {
          *ref2_ref = t1; return;
        }
        failure_reason = "(kinds are incompatible)";
        break;
        // this is a special hack to deal with the fact that a boxed evar
        // can't unify with a pointer type where we don't know whether or
        // not it's a ? pointer vs. a * or @ pointer.
      case &PointerType(pinfo) && kind1->v->kind == BoxKind:
        let c = compress_conref(pinfo.ptr_atts.bounds);
        switch (c) {
        case &Constraint{.No_constr = _}:
          // set the pointer to be a * or @ to an array of size 1
          c->Eq_constr = bounds_one;
          *ref1_ref = t2;
          return;
        default: break;
        }
        break;
      default: break;
      }
      failure_reason = "(kinds are incompatible)";
      throw &Unify_val;
    }
  default: break;
  }
  // t1 is not an evar

    // in what follows, we throw &Unify_val unless we explicitly return.
  switch ($(t2,t1)) {

  case $(&Evar(_,_,_,_),_): // t2 is an evar, t1 is not, swap and try again
    unify_it(t2,t1);
    return;

  case $(&VoidType,&VoidType): return;

  case $(&VarType(tv2),&VarType(tv1)):
    let x2 = tv2->name;
    let x1 = tv1->name;
    // identities should be resolved
    let id2 = tv2->identity;
    let id1 = tv1->identity;
    if (id1 == id2) return;
    failure_reason = "(variable types are not the same)";
    break;

  case $(&AggrType(AggrInfo(info2,ts2)),&AggrType(AggrInfo(info1,ts1))):
    let $(k1,n1) = aggr_kinded_name(info1);
    let $(k2,n2) = aggr_kinded_name(info2);
    if(k1 != k2) { failure_reason = "(struct and union type)"; break; }
    if(qvar_cmp(n1,n2) != 0) { failure_reason = "(different type name)"; break;}
    unify_list(ts1,ts2);
    return;

    // don't use decl pointer -- it might not be set due to an earlier error
  case $(&EnumType(n1,_), &EnumType(n2,_)):
    if (qvar_cmp(n1,n2) == 0) return;
    failure_reason = "(different enum types)";
    break;

  case $(&AnonEnumType(fs1), &AnonEnumType(fs2)):
    bool bad = false;
    for (; fs1 != NULL && fs2 != NULL; fs1=fs1->tl, fs2=fs2->tl) {
      let f1 = fs1->hd;
      let f2 = fs2->hd;
      if (qvar_cmp(f1->name,f2->name) != 0) {
        failure_reason = "(different names for enum fields)";
        bad = true;
        break;
      }
      if (f1->tag == f2->tag) continue;
      if (f1->tag == NULL || f2->tag == NULL) {
        failure_reason = "(different tag values for enum fields)";
        bad = true;
        break;
      }
      if(!Evexp::same_const_exp((exp_t)f1->tag, (exp_t)f2->tag)) {
        failure_reason = "(different tag values for enum fields)";
        bad = true;
        break;
      }
    }
    if (bad) break;
    if (fs1 == NULL && fs2 == NULL) return;
    failure_reason = "(different number of fields for enums)";
    break;

  case $(&DatatypeType(DatatypeInfo({.KnownDatatype = &tud2},ts2)),
	 &DatatypeType(DatatypeInfo({.KnownDatatype = &tud1},ts1))):
    if(tud2 == tud1 || qvar_cmp(tud2->name,tud1->name) == 0) {
      unify_list(ts1,ts2);
      return;
    }
    break;

  case $(&DatatypeFieldType(DatatypeFieldInfo({.KnownDatatypefield = $(tud2,tuf2)},ts2)),
	 &DatatypeFieldType(DatatypeFieldInfo({.KnownDatatypefield = $(tud1,tuf1)},ts1))):
    if((tud2 == tud1 || qvar_cmp(tud2->name,tud1->name)==0)
       && (tuf2 == tuf1 || qvar_cmp(tuf2->name, tuf1->name)==0)) {
      unify_list(ts1,ts2);
      return;
    }
    failure_reason = "(different datatype field types)";
    break;

  case $(&PointerType(PtrInfo(t2a,tqual2a,PtrAtts(rgn2,null2a,b2,zt2,_))),
         &PointerType(PtrInfo(t1a,tqual1a,PtrAtts(rgn1,null1a,b1,zt1,_)))):
    unify_it(t1a,t2a);
    unify_it(rgn2,rgn1); // the whole reason regions are "types"
    t1_failure = t1;
    t2_failure = t2;
    unify_it_conrefs(intcmp,zt1,zt2,"(not both zero terminated)");
    unify_tqual(tqual1a,t1a,tqual2a,t2a);
    unify_it_conrefs(unify_it_bounds,b1,b2,"(different pointer bounds)");
    // Don't force the nullable's to be the same when the bounds are dyn.
    switch (conref_def(bounds_one,b1)) {
    case &DynEither_b: return;
    default: break;
    }
    unify_it_conrefs(intcmp,null1a,null2a,"(incompatible pointer types)");
    return;

  case $(&IntType(sn2,sz2), &IntType(sn1,sz1)):
    // FIX: we're assuming sizeof(int) = sizeof(long) here
    if ((sn1 == sn2) && ((sz1 == sz2) || ((sz1 == Int_sz && sz2 == Long_sz))
                         || (sz1 == Long_sz && sz2 == Int_sz))) return;
    failure_reason = "(different integral types)";
    break;

  case $(&FloatType(b2), &FloatType(b1)):
    if (b1==0 && b2==0) return;
    else if (b1==1 && b2==1) return;
    else // anything but 0 or 1 is long double
      if (b1 != 0 && b1 != 1 && b2 != 0 && b2 != 1) return;
    break;

  case $(&TagType(t1),&TagType(t2)): unify_it(t1,t2); return;

  case $(&ValueofType(e1), &ValueofType(e2)):
    if (!Evexp::same_const_exp(e1,e2)) {
      failure_reason = "(cannot prove expressions are the same)";
      break;
    }
    return;

  case $(&ArrayType(ArrayInfo{t2a,tq2a,e1,zt1,_}),
         &ArrayType(ArrayInfo{t1a,tq1a,e2,zt2,_})):
    unify_it(t1a,t2a);
    unify_tqual(tq1a,t1a,tq2a,t2a);
    t1_failure = t1;
    t2_failure = t2;
    unify_it_conrefs(intcmp,zt1,zt2,"(not both zero terminated)");
    if (e1 == e2) return;
    if (e1 == NULL || e2 == NULL) break;
    if (Evexp::same_const_exp((exp_t)e1, (exp_t)e2))
      return;
    failure_reason = "(different array sizes)";
    break;

  case $(&FnType(FnInfo{tvs2,eff2,rt_tq2,rt2,args2,c_vararg2,cyc_vararg2,rpo2,atts2,req1,req_relns1,ens1,ens_relns1}),
         &FnType(FnInfo{tvs1,eff1,rt_tq1,rt1,args1,c_vararg1,cyc_vararg1,rpo1,atts1,req2,req_relns2,ens2,ens_relns2})):
    bool done = false;
    { region rgn; 
    list_t<$(tvar_t,type_t)@`rgn,`rgn> inst = NULL;
    while (tvs1 != NULL) {
      if (tvs2 == NULL) {
        failure_reason = "(second function type has too few type variables)";
        throw &Unify_val;
      }
      let kb1 = tvs1->hd->kind;
      let kb2 = tvs2->hd->kind;
      if (!unify_kindbound(kb1,kb2)) {
        failure_reason = aprintf("(type var %s has different kinds %s and %s)",
                                 tvar2string(tvs1->hd),
                                 kind2string(tvar_kind(tvs1->hd,&bk)),
                                 kind2string(tvar_kind(tvs2->hd,&bk)));
        throw &Unify_val;
      }
      inst = rnew(rgn) List(rnew(rgn) $(tvs2->hd,new VarType(tvs1->hd)),inst);
      tvs1 = tvs1->tl;
      tvs2 = tvs2->tl;
    }
    if (tvs2 != NULL) {
      failure_reason = "(second function type has too many type variables)";
      break;
    }
    if (inst != NULL) {
      unify_it(new FnType(FnInfo{NULL,eff1,rt_tq1,rt1,args1,c_vararg1,
				   cyc_vararg1,rpo1,atts1,req1,req_relns1,ens1,
                                   ens_relns1}),
	       rsubstitute(rgn, inst,
                           new FnType(FnInfo{NULL,eff2,rt_tq2,rt2,args2,
                                               c_vararg2,cyc_vararg2,rpo2,
                                               atts2,req2,req_relns2,
                                               ens2,ens_relns2})));
      done = true;
    }
    }
    if(done)
      return;
    unify_it(rt1,rt2);
    unify_tqual(rt_tq1,rt1,rt_tq2,rt2);
    for (; args1!=NULL && args2!=NULL; args1 = args1->tl, args2 = args2->tl) {
      let $(_,tqa,ta) = *args1->hd;
      let $(_,tqb,tb) = *args2->hd;
      unify_it(ta,tb);
      unify_tqual(tqa,ta,tqb,tb);
    }
    t1_failure = t1;
    t2_failure = t2;
    if ((args1 != NULL) || (args2 != NULL)) {
      failure_reason = "(function types have different number of arguments)";
      break;
    }
    if (c_vararg1 != c_vararg2) {
      failure_reason = "(only one function type takes C varargs)";
      break;
    }
    // unify any cyclone varargs
    bool bad_cyc_vararg = false;
    switch ($(cyc_vararg1, cyc_vararg2)) {
    case $(NULL,NULL): break;
    case $(NULL,_):
    case $(_,NULL):
      bad_cyc_vararg = true;
      failure_reason = "(only one function type takes varargs)";
      break;
    case $(&VarargInfo{n1,tq1,tp1,i1}, &VarargInfo{n2,tq2,tp2,i2}):
      unify_it(tp1,tp2);
      unify_tqual(tq1,tp1,tq2,tp2);
      if (i1 != i2) {
        bad_cyc_vararg = true;
        failure_reason = "(only one function type injects varargs)";
      }
      break;
    }
    if (bad_cyc_vararg) break;
    // It's important to unify the effects and po after the arguments and
    // result so that the effects are pinned down as much as possible.
    bool bad_effect = false;
    switch($(eff1,eff2)) {
    case $(NULL,NULL): break;
    case $(NULL,_):
    case $(_,NULL): bad_effect = true; break;
    default: bad_effect = !unify_effect((type_t)eff1,(type_t)eff2); break;
    }
    t1_failure = t1;
    t2_failure = t2;
    if(bad_effect) {
      failure_reason = "(function effects do not match)";
      break;
    }
    if (!same_atts(atts2,atts1)) {
      failure_reason = "(function types have different attributes)";
      break;
    }
    if (!same_rgn_po(rpo2,rpo1)) {
      failure_reason = "(function types have different region lifetime orderings)";
      break;
    }
    if (!check_logical_equivalence(req_relns1,req_relns2)) {
      failure_reason = "(@requires clauses not equivalent)";
      break;
    }
    if (!check_logical_equivalence(ens_relns1,ens_relns2)) {
      failure_reason = "(@ensures clauses not equivalent)";
      break;
    }
    return;

  case $(&TupleType(ts2), &TupleType(ts1)):
    for (; ts1 != NULL && ts2 != NULL; ts1 = ts1->tl, ts2 = ts2->tl) {
      let $(tqa,ta) = *ts1->hd;
      let $(tqb,tb) = *ts2->hd;
      unify_it(ta,tb);
      unify_tqual(tqa,ta,tqb,tb);
    }
    if (ts1 == NULL && ts2 == NULL) return;
    t1_failure = t1;
    t2_failure = t2;
    failure_reason = "(tuple types have different numbers of components)";
    break;

  case $(&AnonAggrType(k2,fs2), &AnonAggrType(k1,fs1)):
    if(k1 != k2) { failure_reason = "(struct and union type)"; break; }
    for (; fs1 != NULL && fs2 != NULL; fs1 = fs1->tl, fs2 = fs2->tl) {
      let f1 = fs1->hd;
      let f2 = fs2->hd;
      if (strptrcmp(f1->name,f2->name) != 0) {
        failure_reason = "(different member names)";
        throw &Unify_val;
      }
      unify_it(f1->type, f2->type);
      unify_tqual(f1->tq, f1->type, f2->tq, f2->type);
      if (!same_atts(f1->attributes,f2->attributes)) {
        t1_failure = t1;
        t2_failure = t2;
        failure_reason = "(different attributes on member)";
        throw &Unify_val;
      }
      if ((f1->width != NULL && f2->width == NULL) ||
          (f2->width != NULL && f1->width == NULL) ||
          (f1->width != NULL && f2->width != NULL &&
	   !Evexp::same_const_exp((exp_t)f1->width, (exp_t)f2->width))) {
        t1_failure = t1;
        t2_failure = t2;
        failure_reason = "(different bitfield widths on member)";
        throw &Unify_val;
      }
      if ((f1->requires_clause != NULL && f2->requires_clause == NULL) ||
          (f1->requires_clause == NULL && f2->requires_clause != NULL) ||
          (f1->requires_clause == NULL && f2->requires_clause != NULL &&
           !Evexp::same_const_exp((exp_t)f1->requires_clause,
                                  (exp_t)f2->requires_clause))) {
        t1_failure = t1;
        t2_failure = t2;
        failure_reason = "(different @requires clauses on member)";
        throw &Unify_val;
      }
    }
    if (fs1 == NULL && fs2 == NULL) return;
    t1_failure = t1;
    t2_failure = t2;
    failure_reason = "(different number of members)";
    break;
  case $(&TypedefType(_,ts1,td1,_),&TypedefType(_,ts2,td2,_)):
    if (td1 != td2) {
      failure_reason = "(different abstract typedefs)";
      break;
    }
    failure_reason = "(type parameters to typedef differ)";
    unify_list(ts1,ts2);
    return;
  case $(&HeapRgn, &HeapRgn): return;
  case $(&UniqueRgn, &UniqueRgn): return;
  case $(&RefCntRgn, &RefCntRgn): return;
  case $(&RgnHandleType(rt1),&RgnHandleType(rt2)):
    unify_it(rt1,rt2);
    return;
  case $(&DynRgnType(r1a,r1b), &DynRgnType(r2a,r2b)):
    unify_it(r1a,r2a);
    unify_it(r1b,r2b);
    return;
  case $(&JoinEff(_), _):
  case $(_, &JoinEff(_)):
  case $(&AccessEff(_), _):
  case $(&RgnsEff(_), _):
  case $(_, &RgnsEff(_)):
  case $(_, &AccessEff(_)):
    if (unify_effect(t1,t2)) return;
    failure_reason = "(effects don't unify)";
    break;
  default: break;
  }
  throw &Unify_val;
}

int star_cmp<`a::A,`r::R,`r2::R>(int (@`r2 cmp)(`a@`r,`a@`r),`a*`r a1, `a*`r a2) {
  if(a1 == a2) return 0;
  if(a1 == NULL && a2 != NULL) return -1;
  if(a1 != NULL && a2 == NULL) return 1;
  return cmp((_@)a1,(_@)a2);
}

static int tqual_cmp(tqual_t tq1, tqual_t tq2) {
  let i1 = tq1.real_const + (tq1.q_volatile << 1) + (tq1.q_restrict << 2);
  let i2 = tq2.real_const + (tq2.q_volatile << 1) + (tq2.q_restrict << 2);
  return intcmp(i1,i2);
}

// unify two constraint refs
static int conrefs_cmp(int cmp(`a,`a), conref_t<`a> x, conref_t<`a> y) {
  x = compress_conref(x);
  y = compress_conref(y);
  if (x == y) return 0;
  switch (x) {
  case &Constraint{.No_constr = _}: return -1;
  case &Constraint{.Eq_constr = xv}:
    switch (y) {
    case &Constraint{.No_constr = _}: return 1;
    case &Constraint{.Eq_constr = yv}: return cmp(xv,yv);
    case &Constraint{.Forward_constr = _}: impos("unify_conref: forward after compress(2)");
    }
  case &Constraint{.Forward_constr = _}: impos("unify_conref: forward after compress");
  }
}

static int tqual_type_cmp($(tqual_t,type_t)@ tqt1, $(tqual_t,type_t)@tqt2) {
  let &$(tq1,t1) = tqt1;
  let &$(tq2,t2) = tqt2;
  let tqc = tqual_cmp(tq1,tq2);
  if(tqc != 0) return tqc;
  return typecmp(t1,t2);
}

static int aggrfield_cmp(aggrfield_t f1, aggrfield_t f2) {
  let zsc = strptrcmp(f1->name,f2->name);
  if(zsc != 0) return zsc;
  let tqc = tqual_cmp(f1->tq, f2->tq);
  if(tqc != 0) return tqc;
  let tc = typecmp(f1->type, f2->type);
  if(tc != 0) return tc;
  let ac = list_cmp(attribute_cmp,f1->attributes, f2->attributes);
  if(ac != 0) return ac;
  ac = star_cmp(Evexp::const_exp_cmp,f1->width, f2->width);
  if(ac != 0) return ac;
  return star_cmp(Evexp::const_exp_cmp,f1->requires_clause, f2->requires_clause);
}

static int enumfield_cmp(enumfield_t e1, enumfield_t e2) {
  let qc = qvar_cmp(e1->name,e2->name);
  if(qc != 0) return qc;
  return star_cmp(Evexp::const_exp_cmp,e1->tag,e2->tag);
}

static int type_case_number(type_t t) {
  switch(t) {
  case &VoidType: return 0;
  case &Evar(_,_,_,_): return 1;
  case &VarType(_): return 2;
  case &DatatypeType(_): return 3;
  case &DatatypeFieldType(_): return 4;
  case &PointerType(_): return 5;
  case &IntType(_,_): return 6;
  case &FloatType(0): return 7;
  case &FloatType(_): return 8;
  case &ArrayType(_): return 9;
  case &FnType(_): return 10;
  case &TupleType(_): return 11;
  case &AggrType(_): return 12;
  case &AnonAggrType(_,_): return 14;
  case &EnumType(_,_): return 16;
  case &AnonEnumType(_): return 17;
  case &RgnHandleType(_): return 18;
  case &TypedefType(_,_,_,_): return 19;
  case &UniqueRgn: return 20;
  case &HeapRgn: return 21;
  case &AccessEff(_): return 22;
  case &JoinEff(_): return 23;
  case &RgnsEff(_): return 24;
  case &RefCntRgn: return 25;
  case &TagType(_): return 26;
  case &DynRgnType(_,_): return 27;
  case &ValueofType(_): return 28;
  case &TypeDeclType(...): return 29;
  case &TypeofType(_): return 30;
  case &BuiltinType(...): return 31;
  }
}
// the real work of comparison
// returns -1 if t1 < t2, 0 if ==, 1 if t1 > t2
// error for type not to be closed (?? -- doesn't look like it's a problem)
int typecmp(type_t t1, type_t t2) {
  t1 = compress(t1);
  t2 = compress(t2);
  if (t1 == t2) return 0;
  let shallowcmp = intcmp(type_case_number(t1), type_case_number(t2));
  if(shallowcmp != 0)
    return shallowcmp;

  // guaranteed that top cases are the same
  switch ($(t2,t1)) {
  case $(&Evar(_,_,_,_),&Evar(_,_,_,_)):
    impos("typecmp: can only compare closed types");

  case $(&VarType(tv2),&VarType(tv1)):
    // identities should be resolved
    return intcmp(tv1->identity,tv2->identity);

  case $(&AggrType(AggrInfo(info1,ts1)),&AggrType(AggrInfo(info2,ts2))):
    // shouldn't have union and struct w/ same name, so ignore the kinds
    let $(_,n1) = aggr_kinded_name(info1);
    let $(_,n2) = aggr_kinded_name(info2);
    let ncmp = qvar_cmp(n1,n2);
    if(ncmp != 0) return ncmp;
    else return list_cmp(typecmp,ts1,ts2);

    // decl irrelevant and may not be set; name is enough
  case $(&EnumType(n1,_), &EnumType(n2,_)): return qvar_cmp(n1,n2);

  case $(&AnonEnumType(efs1), &AnonEnumType(efs2)):
    return list_cmp(enumfield_cmp,efs1,efs2);

  case $(&DatatypeType(DatatypeInfo({.KnownDatatype = &tud2},ts2)),
	 &DatatypeType(DatatypeInfo({.KnownDatatype = &tud1},ts1))):
    if(tud1 == tud2) return 0;
    let qc = qvar_cmp(tud1->name,tud2->name);
    if(qc != 0) return qc;
    return list_cmp(typecmp,ts1,ts2);

  case $(&DatatypeFieldType(DatatypeFieldInfo({.KnownDatatypefield = $(tud2,tuf2)},ts2)),
	 &DatatypeFieldType(DatatypeFieldInfo({.KnownDatatypefield = $(tud1,tuf1)},ts1))):
    if(tud1 == tud2) return 0;
    let qc1 =  qvar_cmp(tud2->name,tud1->name);
    if(qc1 != 0) return qc1;
    let qc2 = qvar_cmp(tuf2->name, tuf1->name);
    if(qc2 != 0) return qc2;
    return list_cmp(typecmp,ts1,ts2);

  case $(&PointerType(PtrInfo(t2a,tqual2a,PtrAtts(rgn2,null2a,b2,zt2,_))),
	 &PointerType(PtrInfo(t1a,tqual1a,PtrAtts(rgn1,null1a,b1,zt1,_)))):
    let etc = typecmp(t1a,t2a);
    if(etc != 0) return etc;
    let rc = typecmp(rgn1,rgn2);
    if(rc != 0) return rc;
    let tqc = tqual_cmp(tqual1a,tqual2a);
    if(tqc != 0) return tqc;
    let cc = conrefs_cmp(boundscmp,b1,b2);
    if (cc != 0) return cc;
    let zc = conrefs_cmp(intcmp,zt1,zt2);
    if (zc != 0) return zc;
    switch (conref_def(bounds_one,b1)) {
    case &DynEither_b: return 0;
    default: break;
    }
    return conrefs_cmp(intcmp,null1a,null2a);

  case $(&IntType(sn2,sz2), &IntType(sn1,sz1)):
    if(sn1 != sn2) return intcmp((unsigned int)sn1,(unsigned int)sn2);
    if(sz1 != sz2) return intcmp((unsigned int)sz1,(unsigned int)sz2);
    return 0;

  case $(&FloatType(i1), &FloatType(i2)):
    if (i1 == i2) return 0;
    else if (i2==0) return -1;
    else if (i2==1 && i1==0) return -1;
    else return 1;

  case $(&ArrayType(ArrayInfo{t2a,tq2a,e1,zt1,_}),
         &ArrayType(ArrayInfo{t1a,tq1a,e2,zt2,_})):
    let tqc = tqual_cmp(tq1a,tq2a);
    if(tqc != 0) return tqc;
    let tc = typecmp(t1a,t2a);
    if(tc != 0) return tc;
    let ztc = conrefs_cmp(intcmp,zt1,zt2);
    if (ztc != 0) return ztc;
    if (e1 == e2) return 0;
    if (e1 == NULL || e2 == NULL) {
      impos("missing expression in array index");
    }
    return star_cmp(Evexp::const_exp_cmp,e1,e2);

  case $(&FnType(_), &FnType(_)):
    impos("typecmp: function types not handled");

  case $(&TupleType(ts2), &TupleType(ts1)):
    return list_cmp(tqual_type_cmp,ts1,ts2);

  case $(&AnonAggrType(k2,fs2), &AnonAggrType(k1,fs1)):
    if(k1 != k2)
      if(k1 == StructA) return -1;
      else return 1;
    return list_cmp(aggrfield_cmp,fs1,fs2);

  case $(&RgnHandleType(rt1),&RgnHandleType(rt2)): return typecmp(rt1,rt2);
  case $(&DynRgnType(rt1a,rt1b),&DynRgnType(rt2a,rt2b)):
    let c = typecmp(rt1a,rt2a);
    if (c != 0) return c;
    else return typecmp(rt1b,rt2b);
  case $(&TagType(s1),&TagType(s2)): return typecmp(s1,s2);
  case $(&ValueofType(e1), &ValueofType(e2)): fallthru(e1,e2);
  case $(&TypeofType(e1), &TypeofType(e2)): 
    return Evexp::const_exp_cmp(e1,e2);
  case $(&BuiltinType(s1,_),&BuiltinType(s2,_)):
    return strcmp(s1,s2);
  case $(&JoinEff(_), _):
  case $(_, &JoinEff(_)):
  case $(&AccessEff(_), _):
  case $(&RgnsEff(_), _):
  case $(_, &RgnsEff(_)):
  case $(_, &AccessEff(_)): impos("typecmp: effects not handled");
  default: impos("Unmatched case in typecmp");
  }
}

bool is_arithmetic_type(type_t t) {
  switch (compress(t)) {
  case &IntType(_,_):
  case &FloatType(_):
  case &EnumType(_,_):
  case &AnonEnumType(_): return true;
  default: return false;
  }
}

// we're about to convert a value of type t1 to type t2 (both arithmetic types)
// return true if we will potentially lose precision
bool will_lose_precision(type_t t1, type_t t2) {
  t1 = compress(t1);
  t2 = compress(t2);
  switch ($(t1,t2)) {
  case $(&FloatType(i1), &FloatType(i2)):
   return ((i2==0 && i1!=0) || (i2==1 && i1!=0 && i1!=1));
  case $(&FloatType(_),  &IntType(_,_)):
  case $(&FloatType(_),  &TagType(_)): return true;
  case $(&IntType(_,LongLong_sz),  &IntType(_,LongLong_sz)): return false;
  case $(&IntType(_,LongLong_sz),  _): return true; // see prev cases

  // FIX:  assuming sizeof(int) = sizeof(long)
  case $(&IntType(_,Long_sz), &IntType(_,Int_sz)):
  case $(&IntType(_,Int_sz), &IntType(_,Long_sz)): return false;

  case $(&IntType(_,Long_sz), &FloatType(0)):
  case $(&IntType(_,Int_sz), &FloatType(0)):
  case $(&IntType(_,Long_sz), &IntType(_,Short_sz)):
  case $(&IntType(_,Int_sz), &IntType(_,Short_sz)):
  case $(&TagType(_), &IntType(_,Short_sz)):
  case $(&IntType(_,Long_sz), &IntType(_,Char_sz)):
  case $(&IntType(_,Int_sz), &IntType(_,Char_sz)):
  case $(&IntType(_,Short_sz), &IntType(_,Char_sz)):
  case $(&TagType(_), &IntType(_,Char_sz)): return true;

  default: return false;
  }
}

// coerce the list e so that each element has type t -- used in arrays and
// conditionals
bool coerce_list(tenv_t te, type_t t, list_t<exp_t> es) {
  // find the biggest arithmetic type (if any) for the list and determine
  // if all of the elements are boxed.
  opt_t<type_t> max_arith_type = NULL;
  for (list_t<exp_t> el = es; el != NULL; el = el->tl) {
    type_t t1 = compress((type_t)el->hd->topt);
    if (is_arithmetic_type(t1))
      if (max_arith_type == NULL ||
	  will_lose_precision(t1,max_arith_type->v))
	max_arith_type = new Opt(t1);
  }
    // unify the max arithmetic type with the result type t
  if (max_arith_type != NULL)
    if (!unify(t,max_arith_type->v))
      return false;
  // now coerce each expression to the type t as if by assignment
  for (list_t<exp_t> el = es; el != NULL; el = el->tl)
    if (!coerce_assign(te,el->hd,t)) {
      terr(el->hd->loc,"type mismatch: expecting %s but found %s",
           typ2string(t),typ2string((type_t)el->hd->topt));
      return false;
    }
  return true;
}

// coerce e to have type "bool" (int) -- used in conditionals
// Note: explicit cast is needed only for fat pointers, I think.
bool coerce_to_bool(tenv_t te, exp_t e) {
  if (!coerce_sint_typ(te,e))
    switch (compress((type_t)e->topt)) {
    case &PointerType(_): unchecked_cast(te,e,uint_typ,Other_coercion); break;
    default: return false;
    }
  return true;
}

bool is_integral_type(type_t t) {
  switch (compress(t)) {
  case &IntType(_,_):
  case &TagType(_):
  case &EnumType(_,_):
  case &AnonEnumType(_): return true;
  default: return false;
  }
}

// coerce e to have type unsigned int -- used in subscript
bool coerce_uint_typ(tenv_t te, exp_t e) {
  if (unify((type_t)e->topt,uint_typ))
    return true;
  // try arithmetic conversions -- we only allow integral values
  if (is_integral_type((type_t)e->topt)) {
    if (will_lose_precision((type_t)e->topt,uint_typ))
      warn(e->loc,"integral size mismatch; conversion supplied");
    unchecked_cast(te,e,uint_typ,No_coercion);
    return true;
  }
  return false;
}

// coerce e to have type [signed] int -- used in coercions to "bool"
bool coerce_sint_typ(tenv_t te, exp_t e) {
  if (unify((type_t)e->topt,sint_typ))
    return true;
  // try arithmetic conversions -- we only allow integral values
  if (is_integral_type((type_t)e->topt)) {
    if (will_lose_precision((type_t)e->topt,sint_typ))
      warn(e->loc,"integral size mismatch; conversion supplied");
    unchecked_cast(te,e,sint_typ,No_coercion);
    return true;
  }
  return false;
}


// defined below
static bool ptrsubtype(tenv_t te,
                       list_t<$(type_t,type_t)@`H,`H> assume,
                       type_t t1, type_t t2);

// Can t1 be (implicitly) cast to t2? Assumes types are well-formed
// This is not the same as sub-typing, because we have the opportunity
// to do various coercions.  We only do coercions that don't have
// a failure here.
bool silent_castable(tenv_t te, seg_t loc, type_t t1, type_t t2) {
  //fprintf(stderr,"silent_castable %s and %s\n",typ2string(t1),typ2string(t2));
  t1 = compress(t1);
  t2 = compress(t2);
  switch ($(t1,t2)) {
  case $(&PointerType(pinfo_a), &PointerType(pinfo_b)):
    bool okay = true;
    // can coerce @ to *
    if (!unify_conrefs(intcmp,
		       pinfo_a.ptr_atts.nullable,
		       pinfo_b.ptr_atts.nullable))
      okay = !(conref_constr(false,pinfo_a.ptr_atts.nullable));
    // can coerce *{e} to ? and *{e1} to *{e2} when e2 <= e1
    if (!unify_conrefs(unify_it_bounds,
		       pinfo_a.ptr_atts.bounds,
		       pinfo_b.ptr_atts.bounds)) {
      switch ($(conref_constr(bounds_one,pinfo_a.ptr_atts.bounds),
		conref_constr(bounds_one,pinfo_b.ptr_atts.bounds))) {
      case $(&Upper_b(_), &DynEither_b): // okay regardless of nullable
      case $(&DynEither_b, &DynEither_b): okay = true; break;
      case $(&Upper_b(e1),&Upper_b(e2)):
        okay = okay && Evexp::lte_const_exp(e2,e1);
        // no need to warn for zero-terminated arrays -- they can get back
        // again (usually).
        // warn so *x = y where y is an array doesn't port too easily
        if (!conref_constr(false,pinfo_b.ptr_atts.zero_term))
          warn(loc, "implicit cast to shorter array");
        break;
      case $(&DynEither_b, &Upper_b(e2)):
        // when zero-terminated can silently cast from ? to *{1}/@{1}
        if (conref_constr(false,pinfo_a.ptr_atts.zero_term)
            && is_bound_one(pinfo_b.ptr_atts.bounds))
          break;
        okay = false;
        break;
      }
    }
    //fprintf(stderr,"1: okay = %d\n",okay);
    // can only move from non-const to const or stay same
    okay = okay && (!pinfo_a.elt_tq.real_const || pinfo_b.elt_tq.real_const);
    //fprintf(stderr,"2: okay = %d\n",okay);
    // first region must outlive the second
    if (!unify(pinfo_a.ptr_atts.rgn,pinfo_b.ptr_atts.rgn)) {
      if (region_outlives(te,pinfo_a.ptr_atts.rgn,pinfo_b.ptr_atts.rgn)) {
        if (warn_region_coerce)
          warn(loc, "implicit cast from region %s to region %s", 
               typ2string(pinfo_a.ptr_atts.rgn),
               typ2string(pinfo_b.ptr_atts.rgn));
      } else okay = false;
    }
    //fprintf(stderr,"3: okay = %d\n",okay);
    // must preserve zero-termination or second pointer must be const
    okay = okay && (unify_conrefs(intcmp,
				  pinfo_a.ptr_atts.zero_term,
				  pinfo_b.ptr_atts.zero_term)
                    || (conref_constr(true,pinfo_a.ptr_atts.zero_term) &&
                        pinfo_b.elt_tq.real_const));
    // element types have to be equal or t1's element type must be a
    // pointer-sub-type of t2's element type (e.g., t1 = datatype D.C
    // and t2 = datatype D) and the t2 pointer must be const or abstract.

    // FIX: we can only allow ptrsubtype when the pointer has a bound of
    // 1, is not fat, and is not zero-terminated!
    let deep_subtype =
      unify_conrefs(unify_it_bounds,
                    pinfo_b.ptr_atts.bounds,bounds_one_conref) &&
      (!conref_constr(false,pinfo_b.ptr_atts.zero_term));
    //fprintf(stderr,"3.5: deep_subtype = %d, ak = %d\n",deep_subtype,
    //        kind_leq(&ak,typ_kind(pinfo_b.elt_typ)));

    okay = okay && (unify(pinfo_a.elt_typ,pinfo_b.elt_typ) ||
                    (deep_subtype && (pinfo_b.elt_tq.real_const || kind_leq(&ak,typ_kind(pinfo_b.elt_typ))) && ptrsubtype(te,NULL,pinfo_a.elt_typ,pinfo_b.elt_typ)));
    // fprintf(stderr,"4: okay = %d\n",okay);
    return okay;

  case $(&ArrayType(ArrayInfo{t1a,tq1a,e1,zt1,_}),
         &ArrayType(ArrayInfo{t2a,tq2a,e2,zt2,_})):
    bool okay;
    // we could allow e1 >= e2 but I think it's best to give an error
    okay = unify_conrefs(intcmp,zt1,zt2) &&
      (e1 != NULL && e2 != NULL && Evexp::same_const_exp((exp_t)e1,(exp_t)e2));
    // FIX: we need to take qualifiers into account on typedefs
    return (okay && unify(t1a,t2a) && (!tq1a.real_const || tq2a.real_const));

  case $(&TagType(_),&IntType(_,_)): return false;

  default: return unify(t1,t2);
  }
}

bool is_pointer_type(type_t t) {
  switch (compress(t)) {
  case &PointerType(_): return true;
  default: return false;
  }
}
type_t pointer_elt_type(type_t t) {
  switch (compress(t)) {
  case &PointerType(PtrInfo{.elt_typ = e,...}): return e;
  default: impos("pointer_elt_type");
  }
}
type_t pointer_region(type_t t) {
  switch (compress(t)) {
  case &PointerType(PtrInfo{.ptr_atts = *p,...}): return p->rgn;
  default: impos("pointer_elt_type");
  }
}

bool rgn_of_pointer(type_t t, type_t @rgn) {
  switch (compress(t)) {
  case &PointerType(PtrInfo{_,_,PtrAtts(r,_,_,_,_)}):
    *rgn = r;
    return true;
  default: return false;
  }
}

// return true if t has boxed kind.
bool is_boxed(type_t t) {
  return typ_kind(t)->kind == BoxKind;
}

bool is_dyneither_ptr(type_t t) {
  switch (compress(t)) {
  case &PointerType(PtrInfo{_,_,PtrAtts(_,_,b,_,_)}):
    return (conref_def(bounds_one,b) == &DynEither_b_val);
  default: return false;
  }
}

/* FIX: this is duplicated in toc; but the functions are slightly different */
bool is_zero(exp_t e) {
  switch (e->r) {
  case &Const_e({.Int_c = $(_,0)}):
  case &Const_e({.Char_c = $(_,0)}):
  case &Const_e({.Short_c = $(_,0)}):
  case &Const_e({.LongLong_c = $(_,0)}):
  case &Pragma_e(...):
    return true;
  case &Const_e({.Wchar_c = s}):
    let l = strlen(s);
    int i = 0;
    if (l>=2 && s[0] == '\\') {
      if (s[1] == '0') i = 2; // octal
      else if (s[1] == 'x' && l>=3 && s[2] == '0') i = 3; // hex
      else return false;
      for (; i<l; i++) // remaining chars must be '0'
        if (s[i] != '0') return false;
      return true;
    }
    else return false;
  case &Cast_e(t,e2,_,_): return is_zero(e2) && admits_zero(t);
  default: return false;
  }
}

struct Kind rk = Kind(RgnKind,Aliasable);
struct Kind ak = Kind(AnyKind,Aliasable);
struct Kind bk = Kind(BoxKind,Aliasable);
struct Kind mk = Kind(MemKind,Aliasable);
struct Kind ik = Kind(IntKind,Aliasable);
struct Kind ek = Kind(EffKind,Aliasable);

struct Kind trk = Kind(RgnKind,Top);
struct Kind tak = Kind(AnyKind,Top);
struct Kind tbk = Kind(BoxKind,Top);
struct Kind tmk = Kind(MemKind,Top);

struct Kind urk = Kind(RgnKind,Unique);
struct Kind uak = Kind(AnyKind,Unique);
struct Kind ubk = Kind(BoxKind,Unique);
struct Kind umk = Kind(MemKind,Unique);

struct Opt<kind_t> rko = {&rk};
struct Opt<kind_t> ako = {&ak};
struct Opt<kind_t> bko = {&bk};
struct Opt<kind_t> mko = {&mk};
struct Opt<kind_t> iko = {&ik};
struct Opt<kind_t> eko = {&ek};

struct Opt<kind_t> trko = {&trk};
struct Opt<kind_t> tako = {&tak};
struct Opt<kind_t> tbko = {&tbk};
struct Opt<kind_t> tmko = {&tmk};

struct Opt<kind_t> urko = {&urk};
struct Opt<kind_t> uako = {&uak};
struct Opt<kind_t> ubko = {&ubk};
struct Opt<kind_t> umko = {&umk};

opt_t<kind_t> kind_to_opt(kind_t ka) {
  let &Kind(k,a) = ka;
  switch (a) {
  case Aliasable:
    switch (k) {
    case AnyKind: return &ako;
    case MemKind: return &mko;
    case BoxKind: return &bko;
    case RgnKind: return &rko;
    case EffKind: return &eko;
    case IntKind: return &iko;
    }
  case Unique:
    switch (k) {
    case AnyKind: return &uako;
    case MemKind: return &umko;
    case BoxKind: return &ubko;
    case RgnKind: return &urko;
    default: break;
    }
    break;
  case Top:
    switch (k) {
    case AnyKind: return &tako;
    case MemKind: return &tmko;
    case BoxKind: return &tbko;
    case RgnKind: return &trko;
    default: break;
    }
    break;
  }
  impos("kind_to_opt: bad kind %s\n",Absynpp::kind2string(ka));
}

static kindbound_t @ kind_to_b(kind_t ka) {
  static datatype KindBound.Eq_kb ab_v = Eq_kb(&ak);
  static datatype KindBound.Eq_kb mb_v = Eq_kb(&mk);
  static datatype KindBound.Eq_kb bb_v = Eq_kb(&bk);
  static datatype KindBound.Eq_kb rb_v = Eq_kb(&rk);
  static datatype KindBound.Eq_kb eb_v = Eq_kb(&ek);
  static datatype KindBound.Eq_kb ib_v = Eq_kb(&ik);

  static kindbound_t ab = &ab_v;
  static kindbound_t mb = &mb_v;
  static kindbound_t bb = &bb_v;
  static kindbound_t rb = &rb_v;
  static kindbound_t eb = &eb_v;
  static kindbound_t ib = &ib_v;

  static datatype KindBound.Eq_kb tab_v = Eq_kb(&tak);
  static datatype KindBound.Eq_kb tmb_v = Eq_kb(&tmk);
  static datatype KindBound.Eq_kb tbb_v = Eq_kb(&tbk);
  static datatype KindBound.Eq_kb trb_v = Eq_kb(&trk);

  static kindbound_t tab = &tab_v;
  static kindbound_t tmb = &tmb_v;
  static kindbound_t tbb = &tbb_v;
  static kindbound_t trb = &trb_v;

  static datatype KindBound.Eq_kb uab_v = Eq_kb(&uak);
  static datatype KindBound.Eq_kb umb_v = Eq_kb(&umk);
  static datatype KindBound.Eq_kb ubb_v = Eq_kb(&ubk);
  static datatype KindBound.Eq_kb urb_v = Eq_kb(&urk);

  static kindbound_t uab = &uab_v;
  static kindbound_t umb = &umb_v;
  static kindbound_t ubb = &ubb_v;
  static kindbound_t urb = &urb_v;

  let &Kind(k,a) = ka;
  switch (a) {
  case Aliasable:
    switch (k) {
    case AnyKind: return &ab;
    case MemKind: return &mb;
    case BoxKind: return &bb;
    case RgnKind: return &rb;
    case EffKind: return &eb;
    case IntKind: return &ib;
    }
  case Unique:
    switch (k) {
    case AnyKind: return &uab;
    case MemKind: return &umb;
    case BoxKind: return &ubb;
    case RgnKind: return &urb;
    default: break;
    }
    break;
  case Top:
    switch (k) {
    case AnyKind: return &tab;
    case MemKind: return &tmb;
    case BoxKind: return &tbb;
    case RgnKind: return &trb;
    default: break;
    }
    break;
  }
  impos("kind_to_b: bad kind %s\n",Absynpp::kind2string(ka));
}

kindbound_t kind_to_bound(kind_t k) {
  return *kind_to_b(k);
}
opt_t<kindbound_t> kind_to_bound_opt(kind_t k) {
  // FIX: avoid allocation
  return new Opt(kind_to_bound(k));
}

// if e1 is zero, and t2 a pointer type, changes e1 to NULL and
// returns true if t2 is a nullable pointer type
bool zero_to_null(tenv_t te, type_t t2, exp_t e1) {
  if (is_pointer_type(t2) && is_zero(e1)) {
    e1->r = new Const_e(Null_c);
    let tenv_tvs = lookup_opt_type_vars(te);
    let t1 = new PointerType(PtrInfo(new_evar(&ako,tenv_tvs),
				     empty_tqual(0),
				     PtrAtts(new_evar(&trko,tenv_tvs),
					     true_conref,
					     empty_conref(),
					     empty_conref(),NULL)));
    e1->topt = t1;
    bool bogus = false;
    bool retv = coerce_arg(te, e1, t2, &bogus);
    if (bogus != false)
      impos("zero_to_null resulted in an alias coercion on %s at %s\n",
	    exp2string(e1), Position::string_of_segment(e1->loc));
    return retv;
  }
  return false;
}

string_t coercion2string(coercion_t c) {
  switch (c) {
  case Unknown_coercion: return "unknown";
  case No_coercion: return "no coercion";
  case Null_to_NonNull: return "null check";
  case Other_coercion: return "other coercion";
  }
}

bool warn_alias_coerce = false;

// returns a pair by doing the following
// (1) gensym's a variable name and creates an expression with that variable
// (2) generates an alias statement that defines that variable as aliasing
// the given expression, using the given tvar as the region
$(decl_t,exp_t) insert_alias(exp_t e, type_t e_typ) {
  static datatype KindBound.Eq_kb rgn_kb = Eq_kb(&rk);

  // generate a fresh variable to alias the given expression to
  static int counter = 0;
  qvar_t v = new $(Loc_n, new ((string_t)aprintf("__aliasvar%d",counter++)));
  vardecl_t vd = new_vardecl(0,v,e_typ,e);
  exp_t ve = varb_exp(new Local_b(vd),e->loc);
  // generate a fresh region variable for it and make the type
  // of the variable be as close to the instantiated type as we
  // can.  We achieve this by unifying the expected type, which
  // should have an evar for the region of the pointer type, with
  // the new type variable.  
  tvar_t tv = new_tvar(&rgn_kb);
  //fprintf(stderr,"before unifying, type is %s\n",typ2string(e_typ));
  switch (compress(e_typ)) {
  case &PointerType(PtrInfo{et,tq,PtrAtts{old_r,nb,b,zt,pl}}):
    switch (compress(old_r)) {
    case &Evar(_,*topt,_,ts): 
      let new_r = new VarType(tv);
      *topt = new_r;
      break;
    default: break;
    }
    break;
  default: break;
  }
  //fprintf(stderr,"after unifying, type is %s\n",typ2string(e_typ));
  e->topt = NULL;
  vd->initializer = NULL;

  // generate the alias decl
  decl_t d = alias_decl(tv,vd,e,e->loc);

  return $(d,ve);
}

// returns true if we could insert an alias construct around the context
// of the expression with type has_typ to avoid consuming it
static bool can_insert_alias(exp_t e, type_t e_typ,
			     type_t wants_typ, seg_t loc) {
  // check if the given expression is a pointer into a no-alias region
  if (is_noalias_path(e) 
      && is_noalias_pointer(e_typ,false) 
      && is_pointer_type(e_typ)) {
    // check if the expected type is has a pointer type into an
    // aliasable region but not the heap region
    switch (compress(wants_typ)) {
    case &PointerType(PtrInfo(_,_,PtrAtts(r2,...))):
      switch (compress(r2)) {
      case &HeapRgn: return false;
      default:
	let k = typ_kind(r2);
	return k->kind == RgnKind && k->aliasqual == Aliasable;
      }
    default: return false;
    }
  }
  return false;
}

// coerce e to have type t -- used in function call and explicit fallthru
bool coerce_arg(tenv_t te, exp_t e, type_t t2, bool @alias_coercion) {
  type_t t1 = compress((type_t)e->topt);
  coercion_t c;
  bool do_alias_coercion = false;
  // see if types immediately match
  if (unify(t1,t2)) return true;
  // try arithmetic conversions
  if (is_arithmetic_type(t2) && is_arithmetic_type(t1)) {
    // issue a warning if we lose precision
    if (will_lose_precision(t1,t2))
      warn(e->loc,"integral size mismatch; %s -> %s conversion supplied",
	   typ2string(t1), typ2string(t2));
    unchecked_cast(te,e,t2,No_coercion);
    return true;
  } else {
    // check if we can do an alias coercion; if so, make sure it otherwise
    // typechecks before performing the coercion (for better error reporting).
    if (can_insert_alias(e,t1,t2,e->loc)) {
      if (warn_alias_coerce)
	warn(e->loc,"implicit alias coercion for %s:%s to %s",
	     exp2string(e), typ2string(t1), typ2string(t2));
      *alias_coercion = true;
    }

    if (silent_castable(te,e->loc,t1,t2)) {
      unchecked_cast(te,e,t2,Other_coercion);
      return true;
    } else if (zero_to_null(te,t2,e)) {
      return true;
    } else if ((c = castable(te,e->loc,t1,t2)) != Unknown_coercion) {
      //fprintf(stderr,"found them to be castable: %s\n",coercion2string(c));
      // if C supports the conversion, then we don't need the cast.
      if (c != No_coercion) unchecked_cast(te,e,t2,c);
      if (c != Null_to_NonNull)
	warn(e->loc,"implicit cast from %s to %s",
	     typ2string(t1),typ2string(t2));
      return true;
    }
    else return false;
  }
}

// coerce e to have type t -- used in assignment operations.  Neither
// gcc nor VC++ issue warnings for losing precision here, but I think
// it may be appropriate.
bool coerce_assign(tenv_t te, exp_t e, type_t t) {
  // even if we can coerce the assignment, we don't bother because
  // the scope will be too small.
  bool bogus = false;
  return coerce_arg(te,e,t,&bogus);
}

bool coerceable(type_t t) {
  switch (compress(t)) {
  case &IntType(_,_):
  case &FloatType(_): return true;
  default: return false;
  }
}

// FIX:  all of the subtyping stuff needs to be re-examined in the light
// of packed/aligned attributes.  And we'd need to be careful to do this
// in an architecture-dependent way (based on alignement and so forth.)

// Flatten a type into a list of type qualifiers and types for
// use in subtype comparison.
// FIX:  we should recursively flatten tuple and struct types here,
// but doing so is tricky because we have to get the padding and
// alignment right.  This seems to be particularly weird on the
// x86 -- I need to find precise documentation on it before we do this.
static list_t<$(tqual_t,type_t)@`r,`r> flatten_typ(region_t<`r> r,
                                                   bool flatten,
                                                   tenv_t te,
                                                   type_t t1);
static list_t<$(tqual_t,type_t)@`r,`r>
  flatten_typ_f($(list_t<$(tvar_t,type_t)@`r,`r>,
                  region_t<`r>, tenv_t, bool)@ env,aggrfield_t x){
  let $(inst,r,te,flatten) = *env;
  //fprintf(stderr,"flattening field %s with real_const = %d and const = %d\n",*x->name,x->tq.real_const,x->tq.print_const);
  let t = (inst == NULL) ? x->type : rsubstitute(r,inst,x->type);
  let ts = flatten_typ(r,flatten,te,t);
  if (List::length(ts) == 1)
    return rnew(r) List{rnew(r) $(x->tq,t),NULL};
  else return ts;
}
static list_t<$(tqual_t,type_t)@`r,`r>
  rcopy_tqt($(region_t<`r>,tenv_t,bool)@ env,$(tqual_t,type_t)@ x) {
  let $(r,te,flatten) = *env;
  let $(tq,t) = *x;
  let ts = flatten_typ(r,flatten,te,t);
  if (List::length(ts) == 1)
    return rnew(r) List{rnew(r) $(tq,t),NULL};
  else return ts;
}
static list_t<$(tqual_t,type_t)@`r,`r> flatten_typ(region_t<`r> r,
                                                   bool flatten,
                                                   tenv_t te,
                                                   type_t t1) {
  if (flatten) {
    t1 = compress(t1);
    switch (t1) {
    case &VoidType: return NULL;
    case &TupleType(tqs):
      let env = $(r,te,flatten);
      // we can flatten only the first component recursively
      switch (tqs) {
      case NULL: return NULL;
      case &List{hd,tl}:
        let hd2 = rcopy_tqt(&env,hd);
        env[2] = false;
        let tl2 = rmap_c(r,rcopy_tqt,&env,tqs);
        let temp = rnew(r) List{hd2,tl2};
        return rflatten(r,rnew (r) List{hd2,tl2});
      }
    case &AggrType(AggrInfo({.KnownAggr = &ad},ts)):
      // FIX: too strict with existentials and constraints??
      if(ad->kind==UnionA || ad->impl==NULL
         || ad->impl->exist_vars != NULL || ad->impl->rgn_po != NULL)
        return rnew(r) List(rnew(r) $(empty_tqual(0),t1),NULL);
      let inst = List::rzip(r,r,ad->tvs,ts);
      $(list_t<_,`r>,region_t<`r>,_,bool) env = $(inst,r,te,flatten);
      switch (ad->impl->fields) {
      case NULL: return NULL;
      case &List{hd,tl}:
        let hd2 = flatten_typ_f(&env,hd);
        env[3] = false;
        let tl2 = List::rmap_c(r,flatten_typ_f,&env,tl);
        let tts = rnew(r) List{hd2,tl2};
        return List::rflatten(r,tts);
      }
    case &AnonAggrType(StructA,fs):
      $(list_t<_,`r>,region_t<`r>,_,bool) env = $(NULL,r,te,flatten);
      switch (fs) {
      case NULL: return NULL;
      case &List{hd,tl}:
        let hd2 = flatten_typ_f(&env,hd);
        env[3] = false;
        let tl2 = List::rmap_c(r,flatten_typ_f,&env,tl);
        let tts = rnew(r) List{hd2,tl2};
        return rflatten(r,tts);
      }
    default: break;
    }
  }
  return rnew(r) List(rnew(r) $(empty_tqual(0),t1),NULL);
}

// Returns true when attribute list a1 can be safely cast to a2
static bool sub_attributes(attributes_t a1, attributes_t a2) {
  for (attributes_t t = a1; t != NULL; t = t->tl) {
    switch (t->hd) {
    case &Pure_att: // can safely omit these in a2
    case &Noreturn_att:
    case &Initializes_att(_):
      continue;
    default:
      if (!List::exists_c(equal_att, t->hd, a2)) return false;
    }
  }
  for (; a2 != NULL; a2 = a2->tl) {
    if (!List::exists_c(equal_att, a2->hd, a1)) return false;
  }
  return true;
}

static bool isomorphic(type_t t1, type_t t2) {
  switch ($(compress(t1),compress(t2))) {
  case $(&IntType(_,b1), &IntType(_, b2)):
    return b1 == b2 || (b1 == Int_sz && b2 == Long_sz) ||
      (b1 == Long_sz && b2 == Int_sz);
  default: return false;
  }
}

// FIX: the subtyping environment needs to take into account the
// qualifiers on the pointers.
bool subtype(tenv_t te,
             list_t<$(type_t,type_t)@`H,`H> assume,
             type_t t1, type_t t2) {
  if (unify(t1,t2)) return true;
  for (_ a = assume; a != NULL; a = a->tl)
    if (unify(t1,(*a->hd)[0]) && unify(t2,(*a->hd)[1]))
      return true;

  t1 = compress(t1);
  t2 = compress(t2);
  switch ($(t1,t2)) {
    // the following allows us to cast an unsigned int pointer to an int
    // pointer and vice versa.  This is okay because the types are isomorphic.
   case $(&PointerType(PtrInfo(t_a, q_a, PtrAtts(rt_a,null_a,b_a,zt_a,_))),
          &PointerType(PtrInfo(t_b, q_b, PtrAtts(rt_b,null_b,b_b,zt_b,_)))):
    // if t1 is const then t2 must be const
    if (q_a.real_const && !q_b.real_const)
      return false;
    // if t1 is * then t2 must be *
    if (!unify_conrefs(intcmp,null_a,null_b)
	&& conref_def(false,null_a) && !conref_def(false,null_b))
      return false;
    // if t1 is not zero-terminated, then t2 must not be zero-terminated
    if (!unify_conrefs(intcmp,zt_a,zt_b)
        && !conref_def(false,zt_a) && conref_def(false,zt_b))
      return false;
    // rt_a must outlive rt_b
    if (!unify(rt_a,rt_b) && !region_outlives(te,rt_a,rt_b) && 
        !subtype(te, assume, rt_a, rt_b))
      return false;
    // need to check that the bounds match up
    if (!unify_conrefs(unify_it_bounds,b_a,b_b)) {
      switch ($(conref_val(b_a),conref_val(b_b))) {
      case $(&DynEither_b, &DynEither_b): break;
        //case $(&Upper_b(_), &DynEither_b): break;
      case $(&Upper_b(e1), &Upper_b(e2)):
	if(!Evexp::lte_const_exp(e2,e1))
	  return false;
	break;
      default: return false;
      }
    }
    // check that qualifiers are the same or that t2's is at least const
    // (or it's element type is abstract).
    if (!q_b.real_const && q_a.real_const) {
      if (!kind_leq(&ak,typ_kind(t_b)))
        return false;
    }
    // Note, we can only allow ptrsubtype when the second pointer has a
    // bound of 1, is not fat, and is not zero-terminated!
    let deep_subtype =
      unify_conrefs(unify_it_bounds,b_b,bounds_one_conref) &&
      (!conref_constr(false,zt_b));

    //fprintf(stderr,"subtype: got here on %s and %s\n",typ2string(t1), typ2string(t2));
    // now check that t_a is a pointer sub-type of t_b
    return (deep_subtype && ptrsubtype(te, new List(new $(t1,t2),assume), t_a, t_b)) || (unify(t_a,t_b)) || isomorphic(t_a,t_b);

  case $(&DatatypeFieldType(DatatypeFieldInfo{{.KnownDatatypefield = $(dd1,df)},ts1}), &DatatypeType(DatatypeInfo{{.KnownDatatype = &dd2}, ts2})):
    // we're casting a datatype field to a datatype which is okay
    // when they match up.
    // check they're the same datatype
    if (dd1 != dd2 && qvar_cmp(dd1->name,dd2->name) != 0) return false;
    // check that type parameters are the same
    if (List::length(ts1) != List::length(ts2)) return false;
    for (; ts1 != NULL; ts1 = ts1->tl, ts2 = ts2->tl)
      if (!unify(ts1->hd,ts2->hd)) return false;
    return true;

  case $(&FnType(f1), &FnType(f2)):

    if (f1.tvars != NULL || f2.tvars != NULL) {
      let tvs1 = f1.tvars;
      let tvs2 = f2.tvars;
      if (List::length(tvs1) != List::length(tvs2)) return false;
      list_t<$(tvar_t,type_t)@> inst = NULL;
      while (tvs1 != NULL) {
	if (!unify_kindbound(tvs1->hd->kind, tvs2->hd->kind)) return false;
	inst = new List(new$(tvs2->hd, new VarType(tvs1->hd)),inst);
	tvs1 = tvs1->tl;
	tvs2 = tvs2->tl;
      }
      if (inst != NULL) {
	f1.tvars = NULL;
	f2.tvars = NULL;
	return subtype(te,assume,new FnType(f1),new FnType(f2));
      }
    }
    // covariant subtyping on results
    if (!subtype(te,assume,f1.ret_typ,f2.ret_typ)) return false;
    let args1 = f1.args;
    let args2 = f2.args;
    // argument lengths must match?  Perhaps C allows one to call
    // a function with extra arguments?  I don't think so...
    if (List::length(args1) != List::length(args2)) return false;
    // contravariant subtyping on arguments
    for (; args1 != NULL; args1 = args1->tl, args2 = args2->tl) {
      let $(_,tq1,t1) = *args1->hd;
      let $(_,tq2,t2) = *args2->hd;
      // FIX: we need to take any qualifiers into account on typedefs
      if ((tq2.real_const && !tq1.real_const) || !subtype(te,assume,t2,t1))
          return false;
    }
    // deal with varargs
    if (f1.c_varargs != f2.c_varargs) return false;
    if (f1.cyc_varargs != NULL && f2.cyc_varargs != NULL) {
      let v1 = *f1.cyc_varargs;
      let v2 = *f2.cyc_varargs;
      // FIX: we need to take any qualifiers into account on typedefs
      if ((v2.tq.real_const && !v1.tq.real_const) ||
          !subtype(te,assume,v2.type,v1.type))
        return false;
    } else if (f1.cyc_varargs != NULL || f2.cyc_varargs != NULL) return false;
    // deal with effect
    if (!subset_effect(true,(type_t)f1.effect,(type_t)f2.effect)) return false;
    // deal with region partial order
    if (!sub_rgnpo(f1.rgn_po,f2.rgn_po)) return false;
    // deal with attributes that can be dropped
    if (!sub_attributes(f1.attributes,f2.attributes)) return false;
    // deal with requires clause
    if (!check_logical_implication(f2.requires_relns,f1.requires_relns)) 
      return false;
    // deal with ensures clause
    if (!check_logical_implication(f1.ensures_relns,f2.ensures_relns))
      return false;
    // otherwise okay
    return true;
  default: return false;
  }
}


// is t1* <= t2*?
//   we flatten t1 and t2 into structurally equivalent tuple types
//   (and thus ignore field names, associativity of nested tuples and
//   structs, etc.) and then check that t1 is a width extension of t2
//   and for each field, either (a) both t1 and t2 have qualifier "const"
//   and the t1 field is a subtype of the t2 field, or (b) t1 = t2.
static bool ptrsubtype(tenv_t te, list_t<$(type_t,type_t)@`H,`H> assume, type_t t1, type_t t2) {
  //fprintf(stderr,"ptrsubtype %s and %s\n",typ2string(t1),typ2string(t2));
  list_t<$(tqual_t,type_t)@> tqs1 = flatten_typ(heap_region,true,te,t1);
  list_t<$(tqual_t,type_t)@> tqs2 = flatten_typ(heap_region,true,te,t2);
  for (; tqs2 != NULL; tqs2 = tqs2->tl, tqs1 = tqs1->tl) {
    if (tqs1 == NULL) return false;
    let &$(tq1,t1a) = tqs1->hd;
    let &$(tq2,t2a) = tqs2->hd;
    //fprintf(stderr,"tq1.real_const = %d, tq2.real_const = %d\n",tq1.real_const,tq2.real_const);
    if (tq1.real_const && !tq2.real_const) return false;
    //fprintf(stderr,"ptrsubtype: qualifiers okay, looking at %s and %s\n",typ2string(t1a),typ2string(t2a));
    if ((tq2.real_const || kind_leq(&ak,typ_kind(t2a)))
	&& subtype(te,assume,t1a,t2a)) {
      //fprintf(stderr,"ptrsubtype: t2 is const (or abstract) and %s <= %s\n",typ2string(t1a),typ2string(t2a));
      continue;
    }
    if (unify(t1a,t2a)) {
      //fprintf(stderr,"ptrsubtype: %s unifies with %s\n",typ2string(t1a),typ2string(t2a));
      continue;
    }
    if (isomorphic(t1a,t2a)) {
      //fprintf(stderr,"ptrsubtype: %s isomorphic to %s\n",typ2string(t1a),typ2string(t2a));
      continue;
    }
    //fprintf(stderr,"not related!\n");
    return false;
  }
  return true;
}

static bool is_char_type(type_t t) {
  switch (compress(t)) {
  case &IntType(_,Char_sz): return true;
  default: return false;
  }
}

// Can t1 be cast to t2?  Assumes that the types are well-formed.
// FIX: add function types...
coercion_t castable(tenv_t te, seg_t loc, type_t t1, type_t t2) {
  if(unify(t1,t2))
    return No_coercion;
  t1 = compress(t1);
  t2 = compress(t2);
  //fprintf(stderr,"checking castable %s and %s\n",typ2string(t1),typ2string(t2));
  if(t2==&VoidType_val)
    return No_coercion;
  switch (t2) {
  // we can cast t1 to an int if t1 is a boxed type.
  case &IntType(_,Int_sz):
  case &IntType(_,Long_sz):
    if (typ_kind(t1)->kind == BoxKind) return Other_coercion;
    break;
  default: break;
  }
  switch (t1) {
  case &PointerType(PtrInfo(t_a,q_a,PtrAtts(rt_a,null_a,b_a,zt_a,_))):
    
    // can cast t* to t@ and vice versa.
    // can cast a non-const pointer to a const pointer.
    // can cast a pointer in region r1 to a pointer in region r2 as
    // long as r1 outlives r2.
    // can cast a "bits-only" pointer to a char pointer ?NOZEROTERM
    // can cast a zero-terminated pointer to a non-zero terminated pointer
    switch (t2) {
    case &PointerType(PtrInfo(t_b,q_b,PtrAtts(rt_b,null_b,b_b,zt_b,_))):
      //fprintf(stderr,"checking castable pointers, q_a.real_const = %d, q_b.real_const = %d\n",q_a.real_const, q_b.real_const);
      //fprintf(stderr,"type_kind(%s) = %s, kind_leq = %d\n",typ2string(t_b),kind2string(typ_kind(t_b)), kind_leq(&ak,typ_kind(t_b)));
      coercion_t coercion = Other_coercion;
      let assump = new List(new $(t1,t2),NULL);
      let quals_okay = (q_b.real_const || !q_a.real_const);
      //fprintf(stderr,"quals_okay = %d\n",quals_okay);
      // Can this get any more complicated?!??!?!?!?
      // First, we allow deep subtyping here if q_b is const or t_b is
      // abtract (makes it effectively const since you can't write to it
      // and this is needed for datatypes).  But we also allow you to
      // cast when the types are equal, isomorphic, or the the second
      // type is void.  (void is effectively abstract, but I'm too scared
      // to make it thus...)

      // Note, we can only allow ptrsubtype when the second pointer has a
      // bound of 1, is not fat, and is not zero-terminated!
      let deep_castable =
        unify_conrefs(unify_it_bounds,b_b,bounds_one_conref) &&
        (!conref_constr(false,zt_b));

      let ptrsub = quals_okay &&
        ((deep_castable && ptrsubtype(te,assump,t_a,t_b)) ||
         unify(t_a,t_b) || isomorphic(t_a,t_b) || unify(t_b,&VoidType_val));
      //fprintf(stderr,"ptrsub is %d\n",ptrsub);
      t1_failure = t1;
      t2_failure = t2;
      bool zeroterm_ok = unify_conrefs(intcmp,zt_a,zt_b) || !conref_val(zt_b);
      // FIX: we need to take any qualifiers into account on typedefs
      let bitcase = ptrsub ? false : (bits_only(t_a) && is_char_type(t_b)
                                      && !conref_def(false,zt_b)
                                      && (q_b.real_const || !q_a.real_const));
      bool bounds_ok = unify_conrefs(unify_it_bounds,b_a,b_b);
      if (!bounds_ok && !bitcase)
	switch ($(conref_val(b_a),conref_val(b_b))) {
	  // We allow casts of any form as long as we can't statically
	  // tell that the bounds will be violated
	  // and there aren't abstract bounds
	case $(&Upper_b(e_a),&Upper_b(e_b)):
	  if(Evexp::lte_const_exp(e_b,e_a))
	    bounds_ok = true;
	  break;
	  // jcheney: allow casts among abstract bounds if the bounds unify
	  // e.g. `a@{`i} <-> `a*{`i}
	default: bounds_ok = true; break;
	}
      bool t1_nullable = conref_def(false,null_a);
      bool t2_nullable = conref_def(false,null_b);
      if (t1_nullable && !t2_nullable)
        coercion = Null_to_NonNull;

        //fprintf(stderr,"bounds_ok = %d, zeroterm_ok = %d, ptrsub = %d, bitcase = %d\n",bounds_ok,zeroterm_ok,ptrsub,bitcase);

      if (bounds_ok && zeroterm_ok && (ptrsub || bitcase) &&
          (unify(rt_a,rt_b) || region_outlives(te,rt_a,rt_b)))
        return coercion;
      else return Unknown_coercion;
    default: break;
    }
    return Unknown_coercion;
  case &ArrayType(ArrayInfo{t1a,tq1a,e1,zt1,_}):
    switch (t2) {
    case &ArrayType(ArrayInfo{t2a,tq2a,e2,zt2,_}):
      bool okay;
      okay=
        (e1 != NULL && e2 != NULL && unify_conrefs(intcmp,zt1,zt2) &&
	 Evexp::lte_const_exp((exp_t)e2,(exp_t)e1) &&
         Evexp::lte_const_exp((exp_t)e1,(exp_t)e2));
      return
        // FIX: we need to take any qualifiers into account on typedefs
        (okay && unify(t1a,t2a) && (!tq1a.real_const || tq2a.real_const)) ?
        No_coercion : Unknown_coercion;
    default: return Unknown_coercion;
    }
    return Unknown_coercion;
  // can cast a numeric type or bool to any numeric type
  case &EnumType(_,ed1):
    // can also cast an enum to a shorter enum
    switch(t2) {
    case &EnumType(_,ed2):
      if(ed1->fields != NULL && ed2->fields != NULL
	 && length(ed1->fields->v) >= length(ed2->fields->v))
	return Other_coercion;
      break;
    default: break;
    }
    fallthru;
  case &IntType(_,_):
  case &FloatType(_): return coerceable(t2) ? Other_coercion : Unknown_coercion;
    // region_t<`r1> <= region_t<`r2> when `r1 outlives `r2
  case &RgnHandleType(r1):
    switch(t2) {
    case &RgnHandleType(r2):
      if (region_outlives(te,r1,r2)) return No_coercion;
      break;
    default: break;
    }
    return Unknown_coercion;
  default: return Unknown_coercion;
  }
}

// Replace e by a cast of e to t.  The caller must ensure that the cast is safe.
void unchecked_cast(tenv_t te, exp_t e, type_t t, coercion_t c) {
  if (!unify((type_t)e->topt,t)) {
    let inner = copy_exp(e);
    e->r    = new Cast_e(t,inner,false,c);
    e->topt = t;
  }
}

bool is_integral(exp_t e) {
  switch (compress((type_t)e->topt)) {
  case &IntType(_,_):
  case &EnumType(_,_):
  case &AnonEnumType(_):
  case &TagType(_): return true;
  case &Evar(_,_,_,_): return unify((type_t)e->topt,sint_typ);
  default: return false;
  }
}

bool is_numeric(exp_t e) {
  if(is_integral(e))
    return true;
  switch (compress((type_t)e->topt)) {
  case &FloatType(_): return true;
  default: return false;
  }
}

bool is_function_type(type_t t) {
  switch (compress(t)) {
  case &FnType(_): return true;
  default: return false;
  }
}

type_t max_arithmetic_type(type_t t1, type_t t2) {
  switch ($(t1,t2)) {
  case $(&FloatType(i1),&FloatType(i2)):
    if (i1!=0 && i1!=1) return t1; // t1 is long double
    else if (i2!=0 && i2!=1) return t2; // t2 is long double
    else if (i1>=i2) return t1; // t1 is double, or both are float
    else return t2;             // t2 is double and t1 is float
  case $(&FloatType(_),_): return t1;
  case $(_,&FloatType(_)): return t2;
  case $(&IntType(Unsigned,LongLong_sz),_):
  case $(_,&IntType(Unsigned,LongLong_sz)): return ulonglong_typ;
  case $(&IntType(_,LongLong_sz),_):
  case $(_,&IntType(_,LongLong_sz)): return slonglong_typ;
  case $(&IntType(Unsigned,Long_sz),_):
  case $(_,&IntType(Unsigned,Long_sz)): return ulong_typ;
    // FIX: I don't think these are the right promotion rules
  case $(&IntType(Unsigned,Int_sz),_):
  case $(_,&IntType(Unsigned,Int_sz)): return uint_typ;
  case $(&IntType(_,Long_sz),_):
  case $(_,&IntType(_,Long_sz)): return slong_typ;
  default: return sint_typ;
  }
}

/////////////////////////////////////////////////////////////////////
// Checking well-formedness of types
/////////////////////////////////////////////////////////////////////

// Given two kind constraint refs, merge them so that they will
// point to the most constrained kind -- if they're compatible
// return true, otherwise return false.
static bool constrain_kinds(kindbound_t c1, kindbound_t c2) {
  c1 = compress_kb(c1);
  c2 = compress_kb(c2);
  if (c1 == c2) return true;
  switch ($(c1,c2)) {
  case $(&Eq_kb(k1),&Eq_kb(k2)): return k1 == k2;
  case $(_,&Unknown_kb(*f)): *f = new Opt(c1); return true;
  case $(&Unknown_kb(*f),_): *f = new Opt(c2); return true;
  case $(&Less_kb(*f,k1),&Eq_kb(k2)):
    if (kind_leq(k2,k1)) {
      *f = new Opt(c2); return true;
    } else return false;
  case $(&Eq_kb(k1),&Less_kb(*f,k2)):
    if (kind_leq(k1,k2)) {
      *f = new Opt(c1); return true;
    } else return false;
  case $(&Less_kb(*f1,k1),&Less_kb(*f2,k2)):
    if (kind_leq(k1,k2)) {
      *f2 = new Opt(c1); return true;
    } else if (kind_leq(k2,k1)) {
      *f1 = new Opt(c2); return true;
    } else return false;
  }
}

// generating fresh tvars and tvar identities
static int tvar_id_counter = 0;
int new_tvar_id() {
  return tvar_id_counter++;
}

static int tvar_counter = 0;
tvar_t new_tvar(kindbound_t k) {
  int i = tvar_counter++;
  string_t s = aprintf("#%d",i);
  return new Tvar(new{s},-1,k);
}

bool is_temp_tvar(tvar_t t) {
  let s = *(t->name);
  return (s[0]=='#');
}

void rewrite_temp_tvar(tvar_t t) { // change t->name from "#xxx" to "`xxx"
  printf("%s", *(t->name));
  if (! is_temp_tvar(t)) return;
  let s = strconcat("`", *(t -> name));
  s[1] = 't';
  t -> name = new{(string_t)s};
}

// Given a function declaration, return its type as a function type:
static $(var_opt_t,tqual_t,type_t)@
  fndecl2typ_f($(var_t,tqual_t,type_t)@ x) {
  return new $((var_opt_t)((*x)[0]), (*x)[1], (*x)[2]);
}

type_t fndecl2typ(fndecl_t fd) {
  if (fd->cached_typ == NULL) {
    // We don't cache this type as we want to expand out the effect
    // and so forth...  The caching happens after we check that the
    // function declaration is valid (see below).
    // First, separate the function type attributes from the rest
    // of the attributes and update the function declaration appropriately.
    let fn_type_atts = NULL;
    for (_ atts = fd->attributes; atts != NULL; atts = atts->tl)
      if (fntype_att(atts->hd))
        fn_type_atts = new List(atts->hd,fn_type_atts);
    return new FnType(FnInfo{fd->tvs, fd->effect, fd->ret_tqual, fd->ret_type,
                               List::map(fndecl2typ_f, fd->args),
                               fd->c_varargs, fd->cyc_varargs,
                               fd->rgn_po, fn_type_atts,
                               fd->requires_clause, 
                               fd->requires_relns,
                               fd->ensures_clause, 
                               fd->ensures_relns});
  }
  return (type_t)fd->cached_typ;
}

// given a list of arguments for a function type, replace occurrences
// of the variables in the relational operand with the parameter number.
// As a special case, we have to replace "return_value" with RResult.
static void replace_rop(list_t<$(var_opt_t,tqual_t,type_t)@> args, 
                        Relations::reln_op_t@ rop) {
  switch (*rop) {
  case {.RVar = vd}: 
    let $(nmspace,var) = *vd->name;
    if (!tagcheck(nmspace.Loc_n)) break;
    if (strcmp(*var,"return_value") == 0) {
      *rop = Relations::RReturn();
      break;
    }
    unsigned int c = 0;
    for (let a = args; a != NULL; a = a->tl, c++) {
      let &$(vopt,_,_) = a->hd;
      if (vopt != NULL) {
        if (strcmp(*var,*vopt) == 0) {
          *rop = Relations::RParam(c);
          break;
        }
      }
    }
    break;
  case {.RNumelts = vd}:
    let $(nmspace,var) = *vd->name;
    if (!tagcheck(nmspace.Loc_n)) break;
    unsigned int c = 0;
    for (let a = args; a != NULL; a = a->tl, c++) {
      let &$(vopt,_,_) = a->hd;
      if (vopt != NULL) {
        if (strcmp(*var,*vopt) == 0) {
          *rop = Relations::RParamNumelts(c);
          break;
        }
      }
    }
    break;
  default: break;
  }
}

static void replace_rops(list_t<$(var_opt_t,tqual_t,type_t)@> args, 
                         Relations::reln_t r) {
  replace_rop(args,&r->rop1);
  replace_rop(args,&r->rop2);
}

static relns_t extract_relns(list_t<$(var_opt_t,tqual_t,type_t)@> args, 
                             exp_opt_t e) {
  if (e == NULL) return NULL;
  let relns = Relations::exp2relns(heap_region, e);
  List::iter_c(replace_rops, args, relns);
  return relns;
}

// Substitution stuff
static `a fst_fdarg($(`a,tqual_t,`c)@`r t) { return (*t)[0]; }
type_t snd_tqt($(tqual_t,type_t)@`r t) { return (*t)[1]; }
static $(tqual_t,type_t)@ map2_tq($(tqual_t,type_t)@`H pr, type_t t) {
  let &$(tq,t2) = pr;
  if (t2 == t) return pr;
  else return new $(tq,t);
}
static $($(var_opt_t,tqual_t)@`r,type_t)@`r
substitute_f1(region_t<`r> rgn, $(var_opt_t,tqual_t,type_t) @`r2 y) {
  return rnew(rgn) $(rnew(rgn) $((*y)[0],(*y)[1]),(*y)[2]);
}
static $(var_opt_t,tqual_t,type_t)@
substitute_f2($(var_opt_t,tqual_t,type_t)@`H orig_arg, type_t t) {
  let $(vopt_orig,tq_orig,t_orig) = *orig_arg;
  if (t == t_orig) return orig_arg;
  return new $(vopt_orig,tq_orig,t);
}
static type_t field_type(aggrfield_t f) {
  return f->type;
}
static list_t<type_t,`r2> substs(region_t<`r> rgn,
                                 list_t<$(tvar_t,type_t)@`r,`r> inst,
                                 list_t<type_t,`r2> ts);

// used to copy an expression during substitution
static exp_t copye(exp_t old, raw_exp_t r) {
  // FIX? should we be substituting through the topt?
  return new Exp{old->topt, r, old->loc, old->annot};
}

// substitute the type instantiation inst throughout the expression e.
// assumes e is a type-level-expression (e.g., a "constant" expression.)
exp_t rsubsexp(region_t<`r> r, list_t<$(tvar_t,type_t)@`r,`r> inst, exp_t e) {
  switch (e->r) {
  case &Const_e(_):
  case &Enum_e(...):
  case &AnonEnum_e(...):
  case &Pragma_e(...):
  case &Var_e(...): return e;

  case &Primop_e(p,es):
    if (List::length(es) == 1) {
      let e1 = es->hd;
      let new_e1 = rsubsexp(r,inst,e1);
      if (new_e1 == e1) return e;
      return copye(e, new Primop_e(p,list(new_e1)));
    } else if (List::length(es) == 2) {
      let e1 = es->hd;
      let e2 = es->tl->hd;
      let new_e1 = rsubsexp(r,inst,e1);
      let new_e2 = rsubsexp(r,inst,e2);
      if (new_e1 == e1 && new_e2 == e2) return e;
      return copye(e, new Primop_e(p,list(new_e1,new_e2)));
    } else return impos("primop does not have 1 or 2 args!");
  case &Conditional_e(e1,e2,e3):
    let new_e1 = rsubsexp(r,inst,e1);
    let new_e2 = rsubsexp(r,inst,e2);
    let new_e3 = rsubsexp(r,inst,e3);
    if (new_e1 == e1 && new_e2 == e2 && new_e3 == e3) return e;
    return copye(e, new Conditional_e(new_e1,new_e2,new_e3));
  case &And_e(e1,e2):
    let new_e1 = rsubsexp(r,inst,e1);
    let new_e2 = rsubsexp(r,inst,e2);
    if (new_e1 == e1 && new_e2 == e2) return e;
    return copye(e, new And_e(new_e1,new_e2));
  case &Or_e(e1,e2):
    let new_e1 = rsubsexp(r,inst,e1);
    let new_e2 = rsubsexp(r,inst,e2);
    if (new_e1 == e1 && new_e2 == e2) return e;
    return copye(e, new Or_e(new_e1,new_e2));
  case &SeqExp_e(e1,e2):
    let new_e1 = rsubsexp(r,inst,e1);
    let new_e2 = rsubsexp(r,inst,e2);
    if (new_e1 == e1 && new_e2 == e2) return e;
    return copye(e, new SeqExp_e(new_e1,new_e2));
  case &Cast_e(t,e1,b,c):
    let new_e1 = rsubsexp(r,inst,e1);
    let new_t = rsubstitute(r,inst,t);
    if (new_e1 == e1 && new_t == t) return e;
    return copye(e, new Cast_e(new_t,new_e1,b,c));
  case &Sizeoftyp_e(t):
    let new_t = rsubstitute(r,inst,t);
    if (new_t == t) return e;
    return copye(e, new Sizeoftyp_e(new_t));
  case &Sizeofexp_e(e1):
    let new_e1 = rsubsexp(r,inst,e1);
    if (new_e1 == e1) return e;
    return copye(e, new Sizeofexp_e(new_e1));
  case &Offsetof_e(t,f):
    let new_t = rsubstitute(r,inst,t);
    if (new_t == t) return e;
    return copye(e, new Offsetof_e(new_t,f));
  case &Valueof_e(t):
    let new_t = rsubstitute(r,inst,t);
    if (new_t == t) return e;
    // reduce valueof(valueof_t(e)) to e
    switch (compress(new_t)) {
    case &ValueofType(e): return e;
    default:
      return copye(e, new Valueof_e(new_t));
    }
  default:
    return impos("non-type-level-expression in Tcutil::rsubsexp");
  }
}

static exp_opt_t rsubs_exp_opt(region_t<`r> r,
                               list_t<$(tvar_t,type_t)@`r,`r> inst, 
                               exp_opt_t e) {
  if (e == NULL) return NULL;
  else return rsubsexp(r,inst,e);
}

aggrfield_t subst_aggrfield(region_t<`r> r,
                            list_t<$(tvar_t,type_t)@`r,`r> inst, aggrfield_t f)
{
  let t = f->type;
  let req = f->requires_clause;
  let new_t = rsubstitute(r,inst,t);
  let new_req = rsubs_exp_opt(r,inst,req);
  if (t == new_t && req == new_req) return f;
  else return new Aggrfield{.name = f->name, .tq = f->tq, .type = new_t,
                            .width = f->width, .attributes = f->attributes,
                            .requires_clause = new_req};
}

list_t<aggrfield_t> subst_aggrfields(region_t<`r> r,
                                     list_t<$(tvar_t,type_t)@`r,`r> inst, 
                                     list_t<aggrfield_t,`H> fs) {
  if (fs == NULL) return NULL;
  let f = fs->hd;
  let t = fs->tl;
  let new_f = subst_aggrfield(r,inst,f);
  let new_t = subst_aggrfields(r,inst,t);
  if (new_f == f && new_t == t) return fs;
  // return new List(f,fs);
  return new List(new_f,new_t);
}

list_t<$(type_t,type_t)@> rsubst_rgnpo(region_t<`r> rgn,
				       list_t<$(tvar_t,type_t)@`r,`r> inst,
				       list_t<$(type_t,type_t)@`H,`H> rgn_po) {
  let $(rpo1a,rpo1b) = List::rsplit(rgn,rgn,rgn_po);
  let rpo2a = substs(rgn,inst,rpo1a);
  let rpo2b = substs(rgn,inst,rpo1b);
  if (rpo2a == rpo1a && rpo2b == rpo1b)
    return rgn_po;
  else
    return List::zip(rpo2a,rpo2b);
}

type_t rsubstitute(region_t<`r> rgn,
		   list_t<$(tvar_t,type_t)@`r,`r> inst,
		   type_t t) {
  switch (compress(t)) {
  case &VarType(v):
    // a tvar lookup, not a var lookup!
    try return List::assoc_cmp(tvar_cmp,inst,v);
    catch {case &Not_found: return t;}
  case &AggrType(AggrInfo(info,ts)):
    let new_ts = substs(rgn,inst,ts);
    return (new_ts == ts) ? t : new AggrType(AggrInfo(info,new_ts));
  case &DatatypeType(DatatypeInfo{info,ts}):
    let new_ts = substs(rgn,inst,ts);
    return (new_ts == ts) ? t :
      new DatatypeType(DatatypeInfo{info,new_ts});
  case &DatatypeFieldType(DatatypeFieldInfo{info,ts}):
    let new_ts = substs(rgn,inst,ts);
    return (new_ts == ts) ? t :
      new DatatypeFieldType(DatatypeFieldInfo{info,new_ts});
  case &TypedefType(n,ts,td,topt):
    let new_ts = substs(rgn,inst,ts);
    return (new_ts == ts) ? t : new TypedefType(n,new_ts,td,topt);
  case &ArrayType(ArrayInfo{t1,tq,e,zt,ztl}):
    let new_t1 = rsubstitute(rgn,inst,t1);
    let new_e = (e == NULL) ? NULL : rsubsexp(rgn,inst,e);
    return (new_t1 == t1 && new_e == e) ? t : 
      new ArrayType(ArrayInfo{new_t1,tq,new_e,zt,ztl});
  case &PointerType(PtrInfo(t1,tq,PtrAtts(r,n,b,zt,_))):
    let new_t1 = rsubstitute(rgn,inst,t1);
    let new_r  = rsubstitute(rgn,inst,r);
    let new_b  = b;
    switch(conref_def((bounds_t)&DynEither_b_val,b)) {
    case &Upper_b(e):
      let new_e = rsubsexp(rgn,inst,e);
      if (new_e != e)
	new_b = new_conref(new Upper_b(new_e));
      break;
    default: break;
    }
    if(new_t1 == t1 && new_r == r && new_b == b)
      return t;
    return new PointerType(PtrInfo(new_t1,tq,PtrAtts(new_r,n,new_b,zt,NULL)));
  case &FnType(FnInfo{vs,eff,rtq,rtyp,args,c_varargs,cyc_varargs,rgn_po,atts,
                        req,_,ens,_}):
    // FIX: capture???
    for (let p = vs; p != NULL; p = p->tl)
      inst = rnew(rgn) List(rnew(rgn) $(p->hd,new VarType(p->hd)),inst);
    let $(qs,ts) = List::rsplit(rgn,rgn,
				List::rmap_c(rgn,substitute_f1,rgn,args));
    let args2 = args;
    let ts2 = substs(rgn,inst,ts);
    if (ts2 != ts) 
      args2 = List::map2(substitute_f2, args, ts2);
    type_opt_t eff2;
    if(eff == NULL)
      eff2 = NULL;
    else {
      type_opt_t new_eff = rsubstitute(rgn,inst,(type_t)eff);
      if(new_eff == eff)
	eff2 = eff;
      else
	eff2 = new_eff;
    }
    vararg_info_t *cyc_varargs2;
    if (cyc_varargs == NULL)
      cyc_varargs2 = NULL;
    else {
      let VarargInfo{n,tq,t,i} = *cyc_varargs;
      let t2 = rsubstitute(rgn,inst,t);
      if (t2 == t) cyc_varargs2 = cyc_varargs;
      else
        cyc_varargs2 = new VarargInfo{n,tq,t2,i};
    }
    list_t<$(type_t,type_t)@> rgn_po2 = rsubst_rgnpo(rgn,inst,rgn_po);
    exp_opt_t req2 = rsubs_exp_opt(rgn,inst,req);
    exp_opt_t ens2 = rsubs_exp_opt(rgn,inst,ens);
    let req_relns2 = extract_relns(args2,req2);
    let ens_relns2 = extract_relns(args2,ens2);
    return
      new FnType(FnInfo{vs,eff2,rtq,rsubstitute(rgn,inst,rtyp),args2,c_varargs,
                          cyc_varargs2,rgn_po2,atts,req2,req_relns2,
                          ens2,ens_relns2});
  case &TupleType(tqts):
    list_t<type_t,`r> ts2 = NULL;
    bool change = false;
    for (let ts1 = tqts; ts1 != NULL; ts1 = ts1->tl) {
      let t1 = (*ts1->hd)[1];
      let t2 = rsubstitute(rgn,inst,t1);
      if (t1 != t2) {
        change = true;
      }
      ts2 = rnew(rgn) List(t2,ts2);
    }
    if(!change)
      return t;
    let tqts2 = List::map2(map2_tq,tqts,List::imp_rev(ts2));
    return new TupleType(tqts2);
  case &AnonAggrType(k,fs):
    let new_fs = subst_aggrfields(rgn,inst,fs);
    if (fs == new_fs) return t;
    return new AnonAggrType(k,new_fs);
  case &Evar(_,r,_,_):
    if (r != NULL) return rsubstitute(rgn,inst,(type_t)r);
    else return t;
  case &RgnHandleType(rt):
    let new_rt = rsubstitute(rgn,inst,rt);
    return new_rt == rt ? t : new RgnHandleType(new_rt);
  case &DynRgnType(rt1,rt2):
    let new_rt1 = rsubstitute(rgn,inst,rt1);
    let new_rt2 = rsubstitute(rgn,inst,rt2);
    return (new_rt1 == rt1 && new_rt2 == rt2) ? t : new DynRgnType(new_rt1,new_rt2);
  case &TagType(t2):
    let new_t2 = rsubstitute(rgn,inst,t2);
    return new_t2 == t2 ? t : new TagType(new_t2);
  case &ValueofType(e):
    let new_e = rsubsexp(rgn,inst,e);
    return new_e == e ? t : new ValueofType(new_e);
  case &TypeofType(e):
    let new_e = rsubsexp(rgn,inst,e);
    return new_e == e ? t : new TypeofType(new_e);
  case &EnumType(_,_):
  case &AnonEnumType(_):
  case &VoidType:
  case &IntType(_,_):
  case &FloatType(_):
  case &RefCntRgn:
  case &UniqueRgn:
  case &BuiltinType(...):
  case &HeapRgn:        return t;
  case &RgnsEff(t2):
    let new_t2 = rsubstitute(rgn,inst,t2);
    return new_t2 == t2 ? t : new RgnsEff(new_t2);
  case &AccessEff(r):
    let new_r = rsubstitute(rgn,inst,r);
    return new_r == r ? t : new AccessEff(new_r);
  case &JoinEff(es):
    let new_es = substs(rgn,inst,es);
    return new_es == es ? t : new JoinEff(new_es);
  case &TypeDeclType(...): impos("found typedecltype in rsubs");
  }
}
// This is just a map beefed up to avoid unnecessary allocation.
static list_t<type_t,`r2> substs(region_t<`r> rgn,
                                 list_t<$(tvar_t,type_t)@`r,`r> inst,
                                 list_t<type_t,`r2> ts) {
  if(ts == NULL)
    return NULL;
  let old_hd = ts->hd;
  let old_tl = ts->tl;
  let new_hd = rsubstitute(rgn, inst, old_hd);
  let new_tl = substs(rgn, inst, old_tl);
  if(old_hd == new_hd && old_tl == new_tl)
    return ts;
  return (list_t<type_t,`r2>)(new List(new_hd,new_tl));
}

extern type_t substitute(list_t<$(tvar_t,type_t)@`H,`H> inst, type_t t) {
  if (inst != NULL) 
    return rsubstitute(heap_region, inst, t);
  else return t;
}

// Generate an appropriate evar for an instantiation of a type var
$(tvar_t,type_t)@ make_inst_var(list_t<tvar_t,`H> s, tvar_t tv) {
  let k = kind_to_opt(tvar_kind(tv,&bk));
  return new $(tv, new_evar(k,new Opt(s)));
}

$(tvar_t,type_t)@`r r_make_inst_var($(list_t<tvar_t,`H>,region_t<`r>)@ env,
                                    tvar_t tv) {
  let &$(s,rgn) = env;
  let k = kind_to_opt(tvar_kind(tv,&bk));
  return rnew(rgn) $(tv, new_evar(k,new Opt(s)));
}

// Adds tv to the list of tvars unless it's already present.  If it's
// already present, makes sure the kinds are compatible by choosing the
// most constrained kind as the kind of the variable, and in fact
// physically share the kinds so that further constraints on it are
// propagated.  Also ensures that the tvars share the same identity.
static list_t<tvar_t> add_free_tvar(seg_t loc,
                                    list_t<tvar_t,`H> tvs,
                                    tvar_t tv)
{
  for (_ tvs2 = tvs; tvs2 != NULL; tvs2 = tvs2->tl) {
    if (strptrcmp(tvs2->hd->name, tv->name) == 0) {
      kindbound_t k1 = tvs2->hd->kind;
      kindbound_t k2 = tv->kind;
      if (!constrain_kinds(k1,k2))
        terr(loc,"type variable %s is used with inconsistent kinds %s and %s",
             *tv->name, kindbound2string(k1), kindbound2string(k2));
      if (tv->identity == -1)
        tv->identity = tvs2->hd->identity;
      else if (tv->identity != tvs2->hd->identity)
        impos("same type variable has different identity!");
      return tvs;
    }
  }
  tv->identity = new_tvar_id();
  return new List(tv,tvs);
}

// This assumes the identities and kinds are set, and simply adds
// the tvar if it's not already present.
static list_t<tvar_t> fast_add_free_tvar(list_t<tvar_t,`H> tvs, tvar_t tv) {
  // sanity
  if (tv->identity == -1)
    impos("fast_add_free_tvar: bad identity in tv");
  for (_ tvs2 = tvs; tvs2 != NULL; tvs2 = tvs2->tl) {
    // sanity
    let tv2 = tvs2->hd;
    if (tv2->identity == -1)
      impos("fast_add_free_tvar: bad identity in tvs2");
    if (tv2->identity == tv->identity) {
      return tvs;
    }
  }
  return new List{tv,tvs};
}

// This assumes the identities and kinds are set, and simply adds
// the tvar if it's not already present.  Note that b here controls
// whether or not the variable gets put into effects.
static list_t<$(tvar_t,bool)@`r,`r>
fast_add_free_tvar_bool(region_t<`r> r,
                        list_t<$(tvar_t,bool)@`r,`r> tvs, tvar_t tv, bool b) {

  // sanity
  if (tv->identity == -1)
    impos("fast_add_free_tvar_bool: bad identity in tv");
  for (_ tvs2 = tvs; tvs2 != NULL; tvs2 = tvs2->tl) {
    // sanity
    let &$(tv2,*b2) = tvs2->hd;
    if (tv2->identity == -1)
      impos("fast_add_free_tvar_bool: bad identity in tvs2");
    if (tv2->identity == tv->identity) {
      *b2 = (*b2 || b);
      return tvs;
    }
  }
  return rnew(r) List{rnew(r) $(tv,b),tvs};
}

// will shadow other variables
static list_t<tvar_t> add_bound_tvar(list_t<tvar_t,`H> tvs, tvar_t tv) {
  // sanity
  if (tv->identity == -1)
    impos("bound tvar id for %s is NULL", tvar2string(tv));
  return new List(tv,tvs);
}

// assumes es is a list of evars, and e is an evar.  Adds in e only
// if not already present.  The booleans here indicate whether a
// variable must be put in an effect.  If any occurrence of the variable
// must be in the effect, then it always is true.
static list_t<$(type_t,bool)@`r,`r>
add_free_evar(region_t<`r> r, list_t<$(type_t,bool)@`r,`r> es, type_t e,
              bool b) {
  switch (compress(e)) {
  case &Evar(_,_,i,_):
    for (_ es2 = es; es2 != NULL; es2 = es2->tl) {
      let &$(t,*b2) = es2->hd;
      switch (compress(t)) {
      case &Evar(_,_,j,_):
        if (i == j) {
          if (b != *b2) *b2 = true;
          return es;
        }
        break;
      default: break;
      }
    }
    return rnew(r) List(rnew(r) $(e,b),es);
  default: return es;
  }
}

static list_t<tvar_t,`r> remove_bound_tvars(region_t<`r> rgn,
                                            list_t<tvar_t> tvs,
                                            list_t<tvar_t> btvs) {
  list_t<tvar_t,`r> r = NULL;
  for (; tvs != NULL; tvs = tvs->tl) {
    bool present = false;
    for (_ b = btvs; b != NULL; b = b->tl) {
      if (tvs->hd->identity == b->hd->identity) {
        present = true;
        break;
      }
    }
    if (!present) r = rnew(rgn) List(tvs->hd,r);
  }
  r = List::imp_rev(r);
  return r;
}


static list_t<$(tvar_t,bool)@`r,`r>
remove_bound_tvars_bool(region_t<`r> r,
                        list_t<$(tvar_t,bool)@`r,`r> tvs,
                        list_t<tvar_t> btvs) {
  list_t<$(tvar_t,bool)@> res = NULL;
  for (; tvs != NULL; tvs = tvs->tl) {
    let $(tv,b) = *tvs->hd;
    bool present = false;
    for (_ b = btvs; b != NULL; b = b->tl) {
      if (tv->identity == b->hd->identity) {
        present = true;
        break;
      }
    }
    if (!present) res = rnew(r) List(tvs->hd,res);
  }
  res = List::imp_rev(res);
  return res;
}

void check_bitfield(seg_t loc, tenv_t te, type_t field_typ,
                    exp_opt_t width, stringptr_t fn) {
  if (width != NULL) {
    unsigned int w = 0;
    if (!is_const_exp((exp_t)width))
      terr(loc,"bitfield %s does not have constant width",*fn);
    else {
      let $(i,known) = Evexp::eval_const_uint_exp((exp_t)width);
      if(!known)
	warn(loc,"cannot evaluate bitfield width at compile time");
      w = i;
    }
    switch (compress(field_typ)) {
    case &IntType(_,b):
      // FIX: this is making size assumptions
      switch (b) {
      case Char_sz: if (w > 8)  warn(loc,"bitfield larger than type"); break;
      case Short_sz: if (w > 16) warn(loc,"bitfield larger than type"); break;
      case Long_sz:
      case Int_sz:
        if (w > 32) warn(loc,"bitfield larger than type"); break;
      case LongLong_sz:
        if (w > 64) warn(loc,"bitfield larger than type"); break;
      }
      break;
    default:
      terr(loc,"bitfield %s must have integral type but has type %s",
           *fn,typ2string(field_typ));
      break;
    }
  }
}

static void check_field_atts(seg_t loc, stringptr_t fn, attributes_t atts) {
  for (; atts != NULL; atts = atts->tl)
    switch (atts->hd) {
    case &Packed_att: continue;
    case &Aligned_att(_): continue;
    default: terr(loc,"bad attribute %s on member %s",
		  attribute2string(atts->hd), *fn);
    }
}

// Check-Valid-Type environments
static struct CVTEnv<`r::R> {
  region_t<`r>   r;
  // passed down
  list_t<tvar_t> kind_env;  // used to get consistent id's and kinds for tvars
  // passed up -- the bools indicate whether these variables should go in
  // an effect.
  list_t<$(tvar_t,bool)@`r,`r> free_vars; // free tvars for this type
  list_t<$(type_t,bool)@`r,`r> free_evars;// free evars for this type
  // flag controlling whether to replace evars with fresh tvars
  bool generalize_evars;
  // flag controlling whether we are in a function result or not
  bool fn_result;
};
typedef struct CVTEnv<`r> cvtenv_t<`r>;

// If t is a typedef, returns true if the typedef is const, and warns
// if the flag declared_const is true.  Otherwise returns declared_const.
bool extract_const_from_typedef(seg_t loc, bool declared_const, type_t t) {
  switch (t) {
  case &TypedefType(_,_,td,tdopt):
    if (td->tq.real_const || td->tq.print_const) {
      if (declared_const) warn(loc,"extra const");
      return true;
    }
    // not done yet -- the typedef could expand to a typedef
    if (tdopt)
      return extract_const_from_typedef(loc,declared_const,(type_t)tdopt);
    else return declared_const;
  default: return declared_const;
  }
}

static bool typedef_tvar_is_ptr_rgn(tvar_t tvar, struct Typedefdecl *td) {
  if (td != NULL) {
    if (td->defn != NULL) {
      switch (compress((type_t)td->defn)) {
      case &PointerType(PtrInfo(_,_,PtrAtts(r,_,_,_,_))):
	switch (compress(r)) {
	case &VarType(tv):
	  return tvar_cmp(tvar,tv) == 0;
	default: break;
	}
	break;
      default: break;
      }
    }
  }
  else
    return true; // conservative for non-typedefs
  return false;
}

static kind_t tvar_inst_kind(tvar_t tvar, kind_t def_kind,
			     kind_t expected_kind,
			     struct Typedefdecl *td) {
  switch (compress_kb(tvar->kind)) {
  case &Less_kb(_,&Kind(RgnKind,Top)):
  case &Eq_kb(&Kind(RgnKind,Top)):
    // we may have to adjust the kind constraint of the
    // introduced evar from that of the given tvar so that the
    // overall kind constraint can be met.  This is only necessary
    // when the expected type could be a pointer, and the
    // the tvar is a region variable that would affect that pointer's
    // overall kind (i.e. TB, UB, B, etc.).
    if ((expected_kind->kind == BoxKind ||
	 expected_kind->kind == MemKind ||
	 expected_kind->kind == AnyKind) &&
	typedef_tvar_is_ptr_rgn(tvar,td)) {
      if (expected_kind->aliasqual == Aliasable)
	return &rk;
      else if (expected_kind->aliasqual == Unique)
	return &urk;
    }
    return &trk;
  default: return tvar_kind(tvar,def_kind);
  }
}

// forward declaration
static cvtenv_t<`r>
i_check_valid_type_level_exp(exp_t e, tenv_t te, cvtenv_t<`r> cvtenv);

// check that a @requires/@ensures clause is well-formed and satisfiable
static $(cvtenv_t<`r>,relns_t) 
  check_clause(seg_t loc, tenv_t te, cvtenv_t<`r> cvtenv,
               string_t clause_name, exp_opt_t clause) {
  relns_t relns = NULL;
  if (clause != NULL) {
    Tcexp::tcExp(te,NULL,clause);
    if (!is_integral(clause))
      terr(loc,"%s clause has type %s instead of integral type",
           clause_name,typ2string((type_t)clause->topt));
    cvtenv = i_check_valid_type_level_exp(clause,te,cvtenv);
    relns = Relations::exp2relns(heap_region,clause);
    if (!Relations::consistent_relations(relns))
      terr(clause->loc,"%s clause '%s' may be unsatisfiable",
           clause_name, exp2string(clause));
  }
  return $(cvtenv,relns);
}

// Checks that a type is well-formed and lives in kind expected_kind.
// Takes as input a location (for error reporting), a type environment
// (for looking up struct, enum, datatype, etc. decls), a check-valid-type
// environment (explained below), an expected kind, and the type itself t.
// It returns a check-valid-type-env as a result.
//
// In addition to checking that the type is valid, the routine needs
// to compute the set of free type variables and free evars in the
// type, and to constrain their kinds appropriately.  Normally, this
// would be coded by passing a kind_env down, and returning free_vars
// and free_evars as a result.  However, to cut down on allocation,
// we pass in the free variables of surrounding types and just add
// any new free variables to the result.  This way, we can calculate
// all of the free variables for a term in a store-passing style.
// The only situation where this breaks down is where we have binders
// as is the case for function types (see below).
//
// This also performs the following side-effects which most of the
// rest of the compiler rightly assumes have occurred:
// * expand typedefs
// * set pointers (or Known* variants) to declarations for
//   StructType, UnionType, DatatypeType, DatatypeFieldType
// * set the kind field of type variables: we use the expected kind
//   initially, but if later constraints force a more constrained kind,
//   then we move to the more constrained kind.  This is why we propagate
//   around the set of
// * add default effects for function types

static cvtenv_t<`r>
i_check_valid_type(seg_t loc, tenv_t te, cvtenv_t<`r> cvtenv,
                   kind_t expected_kind, type_t t,
                   bool put_in_effect,
                   bool allow_abs_aggr) {

  //   fprintf(stderr,"checking type %s with expected kind %s\n",
  //	  Absynpp::typ2string(t), kind2string(expected_kind));
  switch (compress(t)) {
  case &VoidType: break;
  case &Evar(*k,*ref,_,_):
    // if we have some latitude with moving the type var, do it here
    if ((*k == NULL) ||
	(kind_leq(expected_kind,(*k)->v) && !kind_leq((*k)->v,expected_kind)))
      *k = kind_to_opt(expected_kind);
    if (cvtenv.fn_result && cvtenv.generalize_evars &&
	expected_kind->kind == RgnKind) {
      if (expected_kind->aliasqual == Unique)
	*ref = &UniqueRgn_val;
      else // generalize Top RgnKind evars to be the heap in return values
	*ref = &HeapRgn_val;
    } else if (cvtenv.generalize_evars) {
      let v = new_tvar(new Less_kb(NULL,expected_kind));
      *ref = new VarType(v);
      fallthru(v);
    } else {
      cvtenv.free_evars = add_free_evar(cvtenv.r,cvtenv.free_evars,t,put_in_effect);
    }
    break;
  case &VarType(v):
    switch (compress_kb(v->kind)) {
    case &Unknown_kb(*f):
      *f = new Opt(new Less_kb(NULL,expected_kind)); break;
    default: break;
    }
    // this constrains the variable's kind according to other occurrences
    // of that variable and makes sure they share the same tvar identity.
    cvtenv.kind_env = add_free_tvar(loc, cvtenv.kind_env, v);
    // no need to constrain things here, but want to add it only if
    // it hasn't already been added.
    cvtenv.free_vars = fast_add_free_tvar_bool(cvtenv.r, cvtenv.free_vars, v, put_in_effect);
    // if we have some latitude with moving the type var, do it here
    switch (compress_kb(v->kind)) {
    case &Less_kb(*f,k): 
      if (kind_leq(expected_kind,k))
	*f = new Opt(new Less_kb(NULL,expected_kind));
      break;
    default: break;
    }
    break;

    // Here, we have a nested type declaration -- we check it and
    // enter it in the environment, and then check an instantiation
    // of that type.
  case &TypeDeclType(&{.r = td,...},*topt):
    type_t new_t = copy_type(compress(t));
    switch (td) {
    case &Aggr_td(ad):
      if (te->in_extern_c_include)
        ad->sc = ExternC;
      Tc::tcAggrdecl(te,loc,ad); break;
    case &Enum_td(ed):
      if (te->in_extern_c_include)
        ed->sc = ExternC;
      Tc::tcEnumdecl(te,loc,ed); break;
    case &Datatype_td(dd):
      Tc::tcDatatypedecl(te,loc,dd); break;
    }
    *topt = new new_t;
    return i_check_valid_type(loc,te,cvtenv,expected_kind,new_t,put_in_effect,
                              allow_abs_aggr);

  case &AnonEnumType(fs):
    // Note: this code is duplicated almost exactly in Tc::tcEnumdecl
    list_t<field_name_t> prev_fields = NULL;
    unsigned int tag_count = 0;
    for (; fs != NULL; fs = fs->tl) {
      let f = fs->hd;
      if (List::mem(strptrcmp,prev_fields,(*f->name)[1]))
	terr(f->loc,"duplicate enum field name %s",*((*f->name)[1]));
      else
	prev_fields = new List((*f->name)[1],prev_fields);

      if (f->tag == NULL)
	f->tag = uint_exp(tag_count, f->loc);
      else if (!is_const_exp((exp_t)f->tag))
	terr(loc,"enum field %s: expression is not constant",*(*f->name)[1]);
      
      unsigned int t1 = Evexp::eval_const_uint_exp((exp_t)f->tag)[0];
      tag_count = t1+1;
    }
    break;
  case &EnumType(n,*edp):
    if (*edp == NULL || (*edp)->fields == NULL)
      try {
        enumdecl_t @ed = lookup_enumdecl(te,loc,n);
        *edp = *ed;
      } catch {
      case &Dict::Absent:
        let ed_orig = new Enumdecl{Extern,n,NULL};
        Tc::tcEnumdecl(te,loc,ed_orig);
        enumdecl_t @ed = lookup_enumdecl(te,loc,n);
        *edp = *ed;
        break;
      }
    enumdecl_t ed = (enumdecl_t)*edp;
    break;
  case &DatatypeType(DatatypeInfo(*info,*targsp)):
    let targs = *targsp;
    switch(*info) {
    case {.UnknownDatatype = UnknownDatatypeInfo(n,is_x)}:
      datatypedecl_t@ tudp;
      try tudp = lookup_datatypedecl(te,loc,n);// FIX: lookup_xdatatypedecl needed?
      catch { case &Dict::Absent:
        // declare the datatype for the user
        let tud = new Datatypedecl{Extern, n, NULL, NULL, is_x};
        Tc::tcDatatypedecl(te, loc, tud);
        tudp = lookup_datatypedecl(te,loc,n);
        // give an error here if targs is non-empty
        if (targs != NULL) {
          terr(loc,"declare parameterized datatype %s before using",
               qvar2string(n));
          return cvtenv;
        }
        break;
      }
      // JGM: I'm allowing someone to just write "datatype Foo" even
      // when the datatype is extensible.
      if(is_x && !(*tudp)->is_extensible)
	terr(loc,"datatype %s was not declared @extensible",
             qvar2string(n));
      *info = KnownDatatype(tudp);
      fallthru(*tudp);
    case {.KnownDatatype = &tud}:
      // check the type arguments are well-formed
      list_t<tvar_t> tvs = tud->tvs;
      for (; targs != NULL && tvs != NULL; targs = targs->tl, tvs = tvs->tl) {
	type_t t = targs->hd;
        tvar_t tv = tvs->hd;
        // special case for recursive type where the parameters kinds
        // have not yet been figured out.
        switch $(compress_kb(tv->kind),t) {
        case $(&Unknown_kb(_), &VarType(tv2)):
          cvtenv.kind_env = add_free_tvar(loc, cvtenv.kind_env, tv2);
          cvtenv.free_vars = fast_add_free_tvar_bool(cvtenv.r, cvtenv.free_vars, tv2, true);
          continue;
        default: break;
        }
	kind_t k = tvar_kind(tv,&bk);
	cvtenv = i_check_valid_type(loc,te,cvtenv,k,t,true,allow_abs_aggr);
        check_no_qual(loc,t);
      }
      if (targs != NULL)
	terr(loc,"too many type arguments for datatype %s",
             qvar2string(tud->name));
      if (tvs != NULL) {
        // fill in missing type parameters
        list_t<type_t> hidden_ts = NULL;
        for (; tvs != NULL; tvs = tvs->tl) {
          kind_t k1 = tvar_inst_kind(tvs->hd, &bk, expected_kind, NULL);
          type_t e = new_evar(NULL,NULL);
          hidden_ts = new List(e,hidden_ts);
          cvtenv = i_check_valid_type(loc,te,cvtenv,k1,e,true,allow_abs_aggr);
        }
        *targsp = List::imp_append(*targsp,List::imp_rev(hidden_ts));
      }
      break;
    }
    break;

  case &DatatypeFieldType(DatatypeFieldInfo{*info,targs}):
    switch(*info) {
    case {.UnknownDatatypefield = UnknownDatatypeFieldInfo(tname,fname,is_x)}:
      // lookup should not fail because of binding phase
      datatypedecl_t  tud = *lookup_datatypedecl(te,loc,tname);
      datatypefield_t tuf;
      // binding phase also checked the field exists in the tud
      // we wait to bind it for uniformity with structs, which are delayed
      // because of typedefs and their strange scope
      for(let fs = tud->fields->v; true; fs = fs->tl) {
	if(fs == NULL)
	  impos("Tcutil found a bad datatypefield");
	if(qvar_cmp(fs->hd->name,fname)==0) {
	  tuf = fs->hd;
	  break;
	}
      }
      *info = KnownDatatypefield(tud,tuf);
      fallthru(tud,tuf);
    case {.KnownDatatypefield = $(tud,tuf)}:
      // check the type arguments are well-formed
      list_t<tvar_t> tvs = tud->tvs;
      for (; targs != NULL && tvs != NULL; targs = targs->tl, tvs = tvs->tl) {
	type_t t = targs->hd;
        tvar_t tv = tvs->hd;
        // special case for recursive type where the parameters kinds
        // have not yet been figured out.
        switch $(compress_kb(tv->kind),t) {
        case $(&Unknown_kb(_), &VarType(tv2)):
          cvtenv.kind_env = add_free_tvar(loc, cvtenv.kind_env, tv2);
          cvtenv.free_vars = fast_add_free_tvar_bool(cvtenv.r, cvtenv.free_vars, tv2, true);
          continue;
        default: break;
        }
	kind_t k = tvar_kind(tv,&bk);
	cvtenv = i_check_valid_type(loc,te,cvtenv,k,t,true,allow_abs_aggr);
        check_no_qual(loc,t);
      }
      if (targs != NULL)
	terr(loc,"too many type arguments for datatype %s.%s",
             qvar2string(tud->name),qvar2string(tuf->name));
      if (tvs != NULL)
	terr(loc,"too few type arguments for datatype %s.%s",
             qvar2string(tud->name),qvar2string(tuf->name));
      break;
    }
    break;
  case &PointerType(PtrInfo(t1,*tqp,PtrAtts(rgn_typ,nullable,b,zt,_))):
    // FIX: check that tqual is valid?
    bool is_zero_terminated;
    // note that here, we allow AnyKind types under the pointer
    cvtenv = i_check_valid_type(loc,te,cvtenv,&tak,t1,true,true);
    tqp->real_const = extract_const_from_typedef(loc,tqp->print_const,t1);
    kind_t k;
    switch (expected_kind->aliasqual) {
    case Aliasable: k = &rk; break;
    case Unique: k = &urk; break;
    case Top: k = &trk; break;
    }
    cvtenv = i_check_valid_type(loc,te,cvtenv,k,rgn_typ,true,true);
    switch (compress_conref(zt)) {
    case &Constraint{.No_constr = _}:
      // if zero_term is unconstrained, then set it to false unless
      // we have [signed] char */@/? {n}.
      switch (compress(t1)) {
      case &IntType(_,Char_sz):
        unify_conrefs(intcmp,zt,true_conref);
        is_zero_terminated = true;
        break;
      default:
        unify_conrefs(intcmp,zt,false_conref);
        is_zero_terminated = false;
        break;
      }
      break;
    case &Constraint{.Eq_constr = i} && i:
      // check that t1 admits zero as an element
      if (!admits_zero(t1))
        terr(loc,"cannot have a pointer to zero-terminated %s elements",
             typ2string(t1));
      is_zero_terminated = true;
      break;
    default:
      is_zero_terminated = false;
      break;
    }
    // check the bound
    switch (conref_constr(bounds_one,b)) {
    case &DynEither_b: break;
    case &Upper_b(e): // must be a constant expression
      Tcexp::tcExp(allow_valueof(te),NULL,e);
      cvtenv = i_check_valid_type_level_exp(e,te,cvtenv);
      if (!coerce_uint_typ(te,e))
        terr(loc,"pointer bounds expression is not an unsigned int");
      let $(sz,known) = Evexp::eval_const_uint_exp(e);
      if (is_zero_terminated && (!known || sz < 1))
        terr(loc,"zero-terminated pointer cannot point to empty sequence");
      break;
    }
    break;
  case &TagType(t1):
    cvtenv = i_check_valid_type(loc,te,cvtenv,&ik,t1,true,true); break;
  case &BuiltinType(_,_): break;
  case &ValueofType(e):
    // FIX:  when we have something like:
    // int foo<`i::I>(int *{valueof(`i)}`H x);
    // then the explicitly bound `i doesn't work out.
    Tcexp::tcExp(allow_valueof(te),NULL,e);
    if (!coerce_uint_typ(te,e))
      terr(loc,"valueof_t requires an int expression");
    cvtenv = i_check_valid_type_level_exp(e,te,cvtenv);
    break;
  case &TypeofType(e):
    // FIX:  when we have something like:
    // int foo<`i::I>(int *{valueof(`i)}`H x);
    // then the explicitly bound `i doesn't work out.
    Tcexp::tcExp(allow_valueof(te),NULL,e);
    break;
  case &IntType(_,_):
  case &FloatType(_): break;
  case &ArrayType(ArrayInfo{t1,*tqp,*eptr,zt,ztl}):
    // FIX: check that tqual is valid?
    // we don't allow abstract mem types as the elt type of an array type
    let e = *eptr;
    cvtenv = i_check_valid_type(loc,te,cvtenv,&tmk,t1,true,allow_abs_aggr);
    tqp->real_const = extract_const_from_typedef(loc,tqp->print_const,t1);
    bool is_zero_terminated;
    switch (compress_conref(zt)) {
    case &Constraint{.No_constr = _}:
      // if zero_term is unconstrained, then set it to false.
      unify_conrefs(intcmp,zt,false_conref);
      is_zero_terminated = false;
      /* This old code set it to true if we had char for the elt type
       * but this causes too many headaches, so I'm disabling it.
      switch (compress(t1)) {
      case &IntType(_,Char_sz):
        unify_conrefs(intcmp,zt,true_conref);
        is_zero_terminated = true;
        break;
      default:
        unify_conrefs(intcmp,zt,false_conref);
        is_zero_terminated = false;
        break;
      }
      */
      break;
    case &Constraint{.Eq_constr = i} && i:
      // check that t1 supports 0 as an element
      if (!admits_zero(t1))
        terr(loc,"cannot have a zero-terminated array of %s elements",
             typ2string(t1));
      is_zero_terminated = true;
      break;
    default:
      is_zero_terminated = false;
      break;
    }
    // FIX: should memoize the size so that we don't have to worry about
    // evaluating it during unification
    if(e==NULL) {
      // No explicit array bounds was given
      if (is_zero_terminated) {
        // zero-terminated arrays have at least size 1
        *eptr = e = uint_exp(1,0);
      } else {
        // warn that this array is essentially useless
        warn(loc,"array bound defaults to 1 here");
        *eptr = e = uint_exp(1,0);
      }
    }
    Tcexp::tcExp(allow_valueof(te),NULL,(exp_t)e);
    if (!coerce_uint_typ(te,(exp_t)e))
      terr(loc,"array bounds expression is not an unsigned int");
    cvtenv = i_check_valid_type_level_exp(e,te,cvtenv);
    /*
    if (!is_const_exp((exp_t)e))
      terr(loc,"array bounds expression is not constant");
    */
    let $(sz,known) = Evexp::eval_const_uint_exp((exp_t)e);
    // FIX: if we have an unknown size then it might not be zero-terminated!
    if (is_zero_terminated && known && sz < 1)
      warn(loc,"zero terminated array cannot have zero elements");
    // FIX: if we have an unknown size then it might turn out to be zero!
    if (known && sz < 1 && Cyclone::tovc_r) {
      warn(loc,"arrays with 0 elements are not supported except with gcc -- changing to 1.");
      *eptr = uint_exp(1,0);
    }
    break;
  case &FnType(FnInfo{*btvs,*eff,*rtq,tr,args,c_vararg,cyc_vararg,rgn_po,atts,req,*req_relns,ens,*ens_relns}):
    // This is an unusual and complicated case because (a) we may have to
    // bind type variables here, (b) we may have to calculate the effect.

    // attributes: check that the attributes are function type attributes
    // and that at most one of {stdcall, cdecl, fastcall} is there.
    int  num_convs = 0;
    bool seen_cdecl    = false;
    bool seen_stdcall  = false;
    bool seen_fastcall = false;
    bool seen_format   = false;
    enum Format_Type ft = Printf_ft;
    int fmt_desc_arg = -1;
    int fmt_arg_start = -1;
    for (; atts != NULL; atts = atts->tl) {
      if (!fntype_att(atts->hd))
	terr(loc,"bad function type attribute %s",attribute2string(atts->hd));
      switch(atts->hd) {
      case &Stdcall_att:
	if(!seen_stdcall)  { seen_stdcall=true;  ++num_convs;} break;
      case &Cdecl_att:
	if(!seen_cdecl)    { seen_cdecl=true;    ++num_convs;} break;
      case &Fastcall_att:
	if(!seen_fastcall) { seen_fastcall=true; ++num_convs;} break;
      case &Format_att(fmttype,i,j):
        if (!seen_format)  {
          seen_format = true;
	  ft = fmttype;
          fmt_desc_arg = i;
	  fmt_arg_start = j;
        } else
          terr(loc,"function can't have multiple format attributes");
        break;
      default: break;
      }
    }
    if(num_convs > 1)
      terr(loc,"function can't have multiple calling conventions");

    // bound type variables (we may add more) --
    // check unique, disallow MemKind, and add to cvtenv.kind_env.
    check_unique_tvars(loc,*btvs);
    for (_ b = *btvs; b != NULL; b = b->tl) {
      b->hd->identity = new_tvar_id();
      cvtenv.kind_env = add_bound_tvar(cvtenv.kind_env,b->hd);
      switch (compress_kb(b->hd->kind)) {
      case &Eq_kb(&Kind(MemKind,_)):
	terr(loc,"function attempts to abstract Mem type variable %s",
	     *b->hd->name); break;
      default: break;
      }
    }

    // We use a fresh environment here so that we only track the free type
    // vars (and evars) of the function type in case we have to abstract them.
    let new_cvtenv =
      CVTEnv{heap_region,cvtenv.kind_env,NULL,NULL,cvtenv.generalize_evars,true};

      // results and arguments of functions cannot be abstract mem types
      // FIX?: should check that variables are unique and that tquals are ok
      new_cvtenv = i_check_valid_type(loc,te,new_cvtenv,&tmk,tr,true,true);
      rtq->real_const = extract_const_from_typedef(loc,rtq->print_const,tr);
      new_cvtenv.fn_result = false;
      for (_ a = args; a != NULL; a = a->tl) {
        let trip = a->hd;
        let t = (*trip)[2];
        new_cvtenv = i_check_valid_type(loc,te,new_cvtenv,&tmk,t,true,true);
        let ec = extract_const_from_typedef(loc,(*trip)[1].print_const,t);
        (*trip)[1].real_const = ec;
        // after resolving t, it may be an array type.  if so, as an argument
        // to a function, we need to convert it to a pointer type.
	if (is_array(t)) {
          // create a new region variable for the pointer
          let ptr_rgn = new_evar(NULL,NULL);
          new_cvtenv = i_check_valid_type(loc,te,new_cvtenv,&rk,ptr_rgn,true,true);          
          (*trip)[2] = promote_array(t,ptr_rgn,false);
	}
      }

      // varargs
      if (cyc_vararg != NULL) {
        if (c_vararg) impos("both c_vararg and cyc_vararg"); // sanity
        let VarargInfo{_,_,vt,vi} = *cyc_vararg;
        new_cvtenv = i_check_valid_type(loc,te,new_cvtenv,&tmk,vt,true,true);
        cyc_vararg->tq.real_const = extract_const_from_typedef(loc,cyc_vararg->tq.print_const,vt);
        // if inject, then check the type is an appropriate datatype
        if (vi)
          switch (compress(vt)) {
          case &PointerType(PtrInfo{et,_,PtrAtts{_,_,bs,zt,_}}):
            switch (compress(et)) {
            case &DatatypeType(...):
              if (conref_constr(false,zt))
                terr(loc,"can't inject into a zeroterm pointer");
              switch (conref_constr(bounds_one,bs)) {
              case &DynEither_b:
                terr(loc,"can't inject into a fat pointer to datatype");
                break;
              default: break;
              }
              break;
            default: terr(loc,"can't inject a non-datatype type"); break;
            }
            break;
          default: terr(loc,"expecting a datatype pointer type"); break;
          }
      }

      // check the format attribute is consistent
      if (seen_format) {
        let num_args = List::length(args);
        if (fmt_desc_arg < 0 || fmt_desc_arg > num_args || fmt_arg_start < 0 ||
            // when no varargs, fmt_arg_start should be 0
            (cyc_vararg == NULL && !c_vararg && fmt_arg_start != 0) ||
            ((cyc_vararg != NULL || c_vararg) && 
             fmt_arg_start != num_args + 1)) // wrong??
          terr(loc,"bad format descriptor");
        else {
          // check that fmt_desc_arg is a string in some region
          let $(_,_,t) = *List::nth(args, fmt_desc_arg - 1);
          //can't use unification because evars aren't properly nailed down yet...
          switch (compress(t)) {
          case &PointerType(PtrInfo(et,_,PtrAtts(_,_,b,zt,_))):
            // FIX:  zero-termination?
            switch ($(compress(et), conref_def((bounds_t)&DynEither_b_val,b))) {
            case $(&IntType(_,Char_sz), &DynEither_b): 
              if (c_vararg) 
                terr(loc,"format descriptor is not a char * type"); 
              break;
            case $(&IntType(_,Char_sz), _): 
              if (!c_vararg)
                terr(loc,"format descriptor is not a char ? type"); 
              break;
            default: 
              terr(loc,"format descriptor is not a string type"); 
              break;
            }
            break;
          default: terr(loc,"format descriptor is not a string type"); break;
          }
          if (fmt_arg_start != 0 && !c_vararg) {
            // check the type of the varargs is either datatype PrintArg or
            // datatype ScanfArg according to ft.
            // FIX: shouldn't we just do this once when the declaration is made?
            bool problem;
            switch ($(ft,compress(pointer_elt_type(cyc_vararg->type)))) {
            case $(Printf_ft, &DatatypeType(DatatypeInfo({.KnownDatatype = &tud},_))):
              problem = (qvar_cmp(tud->name,datatype_print_arg_qvar) != 0); break;
            case $(Scanf_ft,  &DatatypeType(DatatypeInfo({.KnownDatatype = &tud},_))):
              problem = (qvar_cmp(tud->name,datatype_scanf_arg_qvar) != 0); break;
            default:
              problem = true; break;
            }
            if (problem)
              terr(loc,"format attribute and vararg types don't match");
          }
        }
      }
      // check the region partial order
      // FIX:  we need to ensure there are no circular dependencies...
      //       actually, allow circularities, but forbid effect variables
      for (_ rpo = rgn_po; rpo != NULL; rpo = rpo->tl) {
        let &$(r1,r2) = rpo->hd;
        new_cvtenv = i_check_valid_type(loc,te,new_cvtenv,&ek,r1,true,true);
        new_cvtenv = i_check_valid_type(loc,te,new_cvtenv,&trk,r2,true,true);
      }
      // check the @requires clause -- we build a bogus function environment
      // to make it possible to enter the parameters as variables that can
      // be mentioned in the @requires clause.  
      let fenv = bogus_fenv(tr, args);
      let ftenv = new Tenv{te->ns, te->ae, fenv, true, te->in_extern_c_include};
      let $(nenv,req_rs) = check_clause(loc,ftenv,new_cvtenv,"@requires",req);
      new_cvtenv = nenv;
      *req_relns = req_rs;
      List::iter_c(replace_rops, args, req_rs);
      // add a bogus "return_value" variable for the @ensures clause
      // DJG: this is done in the binding phase now
//       let var = new "return_value";
//       let vd = new Vardecl{.sc = Public, .name = new $((nmspace_t)Loc_n,var),.varloc=0,
//                            .tq = empty_tqual(0), .type = tr, 
//                            .initializer = NULL, .rgn = curr_rgn(ftenv), 
//                            .attributes = NULL, .escapes = false};
      let $(nenv,ens_rs) = check_clause(loc,ftenv,new_cvtenv,"@ensures",ens);
      new_cvtenv = nenv;
      *ens_relns = ens_rs;
      List::iter_c(replace_rops, args, ens_rs);
      // finally, the effect -- usually inferred
      if (*eff != NULL)
        new_cvtenv = i_check_valid_type(loc,te,new_cvtenv,&ek,(type_t)(*eff),true,true);
      else {
        list_t<type_t> effect = NULL;
        // Add in any free region or effect variables to the effect.
        // This is why we need a "new_cvtenv" above -- we only want the
        // type variables that actually occur in the function type
        // as opposed to elsewhere.
        for (_ tvs = new_cvtenv.free_vars; tvs != NULL; tvs = tvs->tl) {
          let $(tv,put_in_eff) = *tvs->hd;
          if (!put_in_eff) continue; // skip variables that shouldn't go in effs
          switch (compress_kb(tv->kind)) {
            // Coerce Top RgnKind to RgnKind if an upper bound
          case &Less_kb(*f,r) && r->kind == RgnKind:
	    if (r->aliasqual == Top) {
	      *f = kind_to_bound_opt(&rk); fallthru(r);
	    }
            *f = kind_to_bound_opt(r); fallthru(r);
          case &Eq_kb(r) && r->kind == RgnKind:
            effect = new List(new AccessEff(new VarType(tv)),effect); break;
          case &Less_kb(_,&Kind(IntKind,_)):
          case &Eq_kb(&Kind(IntKind,_)): break;
          case &Less_kb(*f,&Kind(EffKind,_)):
            *f = kind_to_bound_opt(&ek); fallthru;
          case &Eq_kb(&Kind(EffKind,_)):
            effect = new List(new VarType(tv),effect); break;
          case &Unknown_kb(*f):
            *f = new Opt(new Less_kb(NULL,&ak)); fallthru;
          default:
            // add regions(`a) to the default effect for every type variable `a.
            effect = new List(new RgnsEff(new VarType(tv)), effect); break;
          }
        }
        // Better add in any evars too:
        for (_ ts = new_cvtenv.free_evars; ts != NULL; ts = ts->tl) {
          let $(tv,put_in_eff) = *ts->hd;
          if (!put_in_eff) continue; // skip variables that shouldn't go in effs
          switch (typ_kind(tv)) {
          case &Kind(RgnKind,_):
	    effect = new List(new AccessEff(tv), effect); break;
          case &Kind(EffKind,_):
	    effect = new List(tv,                effect); break;
          case &Kind(IntKind,_): break;
          default:
	    effect = new List(new RgnsEff(tv),   effect); break;
          }
        }
        *eff = new JoinEff(effect); // used to reverse list (twice)
      }
      // Warn if afterwards any kind is still unconstrained and set it to
      // BoxKind. In addition, drive any MemKind or AnyKind bounded type
      // variables to BoxKind to ensure that we don't abstract a MemKind
      // variable.  Also drive Top kinds to Aliasable.
      if (*btvs != NULL)
        for(list_t<tvar_t> bs = *btvs; bs != NULL; bs = bs->tl) {
          switch (compress_kb(bs->hd->kind)) {
          case &Unknown_kb(*f):
            warn(loc,"Type variable %s unconstrained, assuming boxed",
                 *bs->hd->name);
	    fallthru(f);
          case &Less_kb(*f,&Kind(BoxKind,Top)): fallthru(f);
          case &Less_kb(*f,&Kind(MemKind,Top)): fallthru(f);
          case &Less_kb(*f,&Kind(MemKind,Aliasable)): fallthru(f);
          case &Less_kb(*f,&Kind(AnyKind,Top)): fallthru(f);
          case &Less_kb(*f,&Kind(AnyKind,Aliasable)):
	    *f = kind_to_bound_opt(&bk); break;
	  case &Less_kb(*f,&Kind(MemKind,Unique)): fallthru(f);
	  case &Less_kb(*f,&Kind(AnyKind,Unique)):
	    *f = kind_to_bound_opt(&ubk); break;
          case &Less_kb(*f,&Kind(RgnKind,Top)):
	    *f = kind_to_bound_opt(&rk); break;
          case &Less_kb(*f,k):
	    *f = kind_to_bound_opt(k); break;
          case &Eq_kb(&Kind(MemKind,_)):
            terr(loc,"functions can't abstract M types"); break;
          default: break;
          }
	}
      // remove the bound vars from the kind environment and the list of free vars
      cvtenv.kind_env = remove_bound_tvars(Core::heap_region,new_cvtenv.kind_env,*btvs);
      new_cvtenv.free_vars = remove_bound_tvars_bool(new_cvtenv.r,new_cvtenv.free_vars,*btvs);
      // add the free vars in to the set of all free vars
      for (_ tvs = new_cvtenv.free_vars; tvs != NULL; tvs = tvs->tl) {
        let $(t,b) = *tvs->hd;
        cvtenv.free_vars = fast_add_free_tvar_bool(cvtenv.r,cvtenv.free_vars,t,b);
      }
      // add the free evars in to the set of all free evars
      for (_ evs = new_cvtenv.free_evars; evs != NULL; evs = evs->tl) {
        let $(e,b) = *evs->hd;
        cvtenv.free_evars = add_free_evar(cvtenv.r,cvtenv.free_evars,e,b);
      }
    break;

  case &TupleType(tq_ts):
    for (; tq_ts != NULL; tq_ts = tq_ts->tl) {
      let p = tq_ts->hd;
      cvtenv = i_check_valid_type(loc,te,cvtenv,&tmk,(*p)[1],true,false);
      (*p)[0].real_const =
        extract_const_from_typedef(loc,(*p)[0].print_const,(*p)[1]);
    }
    break;

  case &AnonAggrType(k,fs):
    // FIX: this code is mostly duplicated in Tc::tcAggrdecl
    list_t<field_name_t> prev_fields = NULL;
    for (; fs != NULL; fs = fs->tl) {
      let &Aggrfield{fn,*tqp,t,width,atts,requires_clause} = fs->hd;
      if (List::mem(strptrcmp,prev_fields,fn))
	terr(loc,"duplicate field %s",*fn);
      if (strcmp(*fn,"") != 0)
	prev_fields = new List(fn,prev_fields);
      cvtenv = i_check_valid_type(loc,te,cvtenv,&tmk,t,true,false);
      tqp->real_const = extract_const_from_typedef(loc,tqp->print_const,t);

      //if(k==UnionA && !bits_only(t) && requires_clause == NULL)
      // FIX: bad error message when t is a zero-terminated type
      //warn(loc,"union member %s is not `bits-only' so it can only be written and not read", *fn);
      check_bitfield(loc,te,t,width,fn);
      check_field_atts(loc,fn,atts);
      if (requires_clause != NULL) {
	// FIX: check that this requires clause does not overlap with others?
	if(k!=UnionA)
	  terr(loc,"@requires clause is only allowed on union members");
	Tcexp::tcExp(allow_valueof(te),NULL,requires_clause);
	if (!is_integral(requires_clause))
	  terr(loc,"@requires clause has type %s instead of integral type", 
	       typ2string((type_t)requires_clause->topt));
	cvtenv = i_check_valid_type_level_exp(requires_clause,te,cvtenv);
      }
    }
    break;

  case &AggrType(AggrInfo(*info,*targs)):
    switch(*info) {
    case {.UnknownAggr = $(k,n,tgd)}:
      aggrdecl_t @ adp;
      try {
	adp = lookup_aggrdecl(te,loc,n);
        let ad = *adp;
        if (ad->kind != k) {
          if (ad->kind == StructA)
            terr(loc,"expecting struct %s instead of union %s",qvar2string(n),
                 qvar2string(n));
          else
            terr(loc,"expecting union %s instead of struct %s",qvar2string(n),
                 qvar2string(n));
        }
        if (tgd && tgd->v) {
          if (!ad->impl || !ad->impl->tagged)
            terr(loc,"@tagged qualfiers don't agree on union %s",
                 qvar2string(n));
        }
        // FIX: what to do about tgd?
	*info = KnownAggr(adp);
      } catch { case &Dict::Absent:
	// add as an abstract type declaration
	// FIX: use the correct namespace by examining the qvar_t n
	let ad = new Aggrdecl{k,Extern,n,NULL,NULL,NULL,false};
	Tc::tcAggrdecl(te,loc,ad);
	adp = lookup_aggrdecl(te,loc,n);
	*info = KnownAggr(adp);
        // give an error here if targs is non-empty:
        if (*targs != NULL) {
          terr(loc,"declare parameterized type %s before using",
	       qvar2string(n));
          return cvtenv;
        }
        break;
      }
      fallthru(*adp);
    case {.KnownAggr = &ad}:
      list_t<tvar_t> tvs = ad->tvs;
      list_t<type_t> ts = *targs;
      for (; ts != NULL && tvs != NULL; ts = ts->tl, tvs = tvs->tl) {
        let tv = tvs->hd;
        let t = ts->hd;
        // special case code in the situation where we have a recursive
        // type and the type parameters kinds have not yet been figured
        // out.
        switch $(compress_kb(tv->kind),t) {
        case $(&Unknown_kb(_), &VarType(tv2)):
          cvtenv.kind_env = add_free_tvar(loc, cvtenv.kind_env, tv2);
          cvtenv.free_vars = fast_add_free_tvar_bool(cvtenv.r, cvtenv.free_vars, tv2, true);
          continue;
        default: break;
        }
        kind_t k = tvar_kind(tvs->hd,&bk);
        cvtenv = i_check_valid_type(loc,te,cvtenv,k,ts->hd,true,allow_abs_aggr);
        check_no_qual(loc,ts->hd);
      }
      if (ts != NULL)
	terr(loc,"too many parameters for type %s", qvar2string(ad->name));
      if (tvs != NULL) {
	// add in hidden type parameters
	list_t<type_t> hidden_ts = NULL;
	for (; tvs != NULL; tvs = tvs->tl) {
          kind_t k = tvar_inst_kind(tvs->hd, &bk, expected_kind, NULL);
	  type_t e = new_evar(NULL,NULL);
	  hidden_ts = new List(e,hidden_ts);
	  cvtenv = i_check_valid_type(loc,te,cvtenv,k,e,true,allow_abs_aggr);
	}
	*targs = List::imp_append(*targs,List::imp_rev(hidden_ts));
      }
      if (allow_abs_aggr && 
          ad->impl == NULL && !kind_leq(&ak, expected_kind)) {
        // this must be later resolved as having at least the expected kind!
        // For now, we just force that to be &mk.  And come back to check that
        // it is later.
        ad->expected_mem_kind = true;
      }
    }
    break;

  case &TypedefType(tdn,*targs_ref,*tdopt,*toptp):
    list_t<type_t> targs = *targs_ref;
    // NB: since we called compress *toptp == NULL
    typedefdecl_t td;
    try td = lookup_typedefdecl(te,loc,tdn);
    catch { case &Dict::Absent:
      terr(loc,"unbound typedef name %s",qvar2string(tdn));
      return cvtenv;
    }
    *tdopt = td;
    list_t<tvar_t> tvs = td->tvs;
    list_t<type_t> ts = targs;
    list_t<$(tvar_t,type_t)@> inst = NULL;
    // check type arguments
    for (; ts != NULL && tvs != NULL; ts = ts->tl, tvs = tvs->tl) {
      kind_t k = tvar_inst_kind(tvs->hd, &tbk, expected_kind, td);
      // 	fprintf(stderr,"inst-var for typedef: tvar_kind=%s, inst_kind=%s\n",
// 		kind2string(tvar_kind(tvs->hd,&tbk)),
// 		kind2string(k));
      cvtenv = i_check_valid_type(loc,te,cvtenv,k,ts->hd,true,allow_abs_aggr);
      check_no_qual(loc,ts->hd);
      inst = new List(new $(tvs->hd,ts->hd),inst);
    }
    if (ts != NULL)
      terr(loc,"too many parameters for typedef %s",qvar2string(tdn));
    if (tvs != NULL) {
      list_t<type_t> hidden_ts = NULL;
      // fill in missing type parameters
      for (; tvs != NULL; tvs = tvs->tl) {
	kind_t k = tvar_inst_kind(tvs->hd, &bk, expected_kind, td);
	type_t e = new_evar(NULL,NULL);
	hidden_ts = new List(e,hidden_ts);
	cvtenv = i_check_valid_type(loc,te,cvtenv,k,e,true,allow_abs_aggr);
	inst = new List(new $(tvs->hd,e),inst);
      }
      // add the hidden type arguments back in so error messages are decent
      *targs_ref = List::imp_append(targs,List::imp_rev(hidden_ts));
    }
    if (td->defn != NULL) {
      type_t new_typ = 
	(inst == NULL) ? (type_t)td->defn : 
          substitute(inst,(type_t)td->defn);
      *toptp = new_typ;
    }
    break;
  case &RefCntRgn:
  case &UniqueRgn:
  case &HeapRgn: break;
  case &RgnHandleType(t2):
    cvtenv = i_check_valid_type(loc,te,cvtenv,&trk,t2,true,allow_abs_aggr); break;
  case &DynRgnType(t2,t3):
    // don't let dynamic regions point into the unique region (for now?)
    cvtenv = i_check_valid_type(loc,te,cvtenv,&rk,t2,false,false);
    cvtenv = i_check_valid_type(loc,te,cvtenv,&rk,t3,true,false);
    break;
  case &AccessEff(t2):
    cvtenv = i_check_valid_type(loc,te,cvtenv,&trk,t2,true,true); break;
  case &RgnsEff(t2):
    cvtenv = i_check_valid_type(loc,te,cvtenv,&tak,t2,true,true); break;
  case &JoinEff(ts):
    for (; ts != NULL; ts = ts->tl)
      cvtenv = i_check_valid_type(loc,te,cvtenv,&ek,ts->hd,true,true);
    break;
  }
  if (!kind_leq(typ_kind(t), expected_kind)) {
    terr(loc,"type %s has kind %s but as used here needs kind %s",
	 typ2string(t), kind2string(typ_kind(t)), kind2string(expected_kind));
  }
  return cvtenv;
}

// This is called *after* type-checking the expression to see that
// it's of type int, under the assumption that every valueof(T) in e is
// well-formed and T is of kind Int.  We must now make sure that these
// assumptions are true and extract the free type variables occurring
// within T.
static cvtenv_t<`r>
i_check_valid_type_level_exp(exp_t e, tenv_t te, cvtenv_t<`r> cvtenv) {
  switch (e->r) {
  case &Const_e(_):
  case &Enum_e(...):
  case &AnonEnum_e(...):
  case &Pragma_e(...):
  case &Var_e(...): break;
  case &Primop_e(_,es):
    for (; es != NULL; es = es->tl)
      cvtenv = i_check_valid_type_level_exp(es->hd,te,cvtenv);
    break;
  case &Conditional_e(e1,e2,e3):
    cvtenv = i_check_valid_type_level_exp(e1,te,cvtenv);
    cvtenv = i_check_valid_type_level_exp(e2,te,cvtenv);
    cvtenv = i_check_valid_type_level_exp(e3,te,cvtenv);
    break;
  case &And_e(e1,e2): fallthru(e1,e2);
  case &Or_e(e1,e2):  fallthru(e1,e2);
  case &SeqExp_e(e1,e2):
    cvtenv = i_check_valid_type_level_exp(e1,te,cvtenv);
    cvtenv = i_check_valid_type_level_exp(e2,te,cvtenv);
    break;
  case &Cast_e(t,e1,_,_):
    cvtenv = i_check_valid_type_level_exp(e1,te,cvtenv);
    cvtenv = i_check_valid_type(e->loc,te,cvtenv,&tak,t,true,false);
    break;
  case &Offsetof_e(t,_): fallthru(t);
  case &Sizeoftyp_e(t):
    cvtenv = i_check_valid_type(e->loc,te,cvtenv,&tak,t,true,false);
    break;
  case &Valueof_e(t):
    cvtenv = i_check_valid_type(e->loc,te,cvtenv,&ik,t,true,false);
    break;
  case &Sizeofexp_e(e):
    cvtenv = i_check_valid_type_level_exp(e,te,cvtenv);
    break;
  default:
    impos("non-type-level-expression in Tcutil::i_check_valid_type_level_exp");
  }
  return cvtenv;
}

static cvtenv_t<`r> check_valid_type(seg_t loc, tenv_t te,
                                     cvtenv_t<`r> cvt,
                                     kind_t expected_kind,
                                     bool allow_abs_aggr,
                                     type_t t) {
  let kind_env = cvt.kind_env;
  cvt = i_check_valid_type(loc,te,cvt,expected_kind,t,true,allow_abs_aggr);

  for (_ vs = cvt.free_vars; vs != NULL; vs = vs->tl) {
    let $(v,_) = *vs->hd;
    cvt.kind_env = fast_add_free_tvar(kind_env,v);
  }

  // run through the evars and constrain them so that when unified,
  // the resulting type can only have type variables drawn from the
  // kind environment or the set of free type variables mentioned here.
  for (_ evs = cvt.free_evars; evs != NULL; evs = evs->tl) {
    let $(e,_) = *evs->hd;
    switch (compress(e)) {
    case &Evar(_,_,_,*s):
      if (*s == NULL)
        *s = new Opt(kind_env);
      else {
        // constrain to the intersection of the contexts
        let tvs = (*s)->v;
        let result = NULL;
        for (; tvs != NULL; tvs = tvs->tl)
          if (List::mem(fast_tvar_cmp,kind_env,tvs->hd))
            result = new List(tvs->hd,result);
        *s = new Opt(result);
      }
      break;
    default: break;
    }
  }
  return cvt;
}

// we can constrain the region evars to HeapRgn and the
// effect evars to the empty effect, but we're out of luck
// for the type and int variables.
void check_free_evars(list_t<type_t> free_evars, type_t in_t, seg_t loc) {
  for (; free_evars != NULL; free_evars = free_evars->tl) {
    type_t e = free_evars->hd;
    switch (typ_kind(e)) {
    case &Kind(RgnKind,Unique):
      if (!unify(e,&UniqueRgn_val))
	impos("can't unify evar with unique region!");
      break;
    case &Kind(RgnKind,Aliasable): // unify with the heap
    case &Kind(RgnKind,Top):
      if (!unify(e,&HeapRgn_val)) impos("can't unify evar with heap!");
      break;
    case &Kind(EffKind,_):
      if (!unify(e,empty_effect)) impos("can't unify evar with {}!");
      break;
    default:
      terr(loc,"hidden type variable %s isn't abstracted in type %s",
	   typ2string(e), typ2string(in_t));
      break;
    }
  }
}


// Same as check_valid_type except that for function types, we check
// that either the bound type variables are empty (in which case we
// plug them in) or else the free type variables are contained in the
// list of the bound type variables and have the right kinds.
void check_valid_toplevel_type(seg_t loc, tenv_t te, type_t t) {
  bool generalize_evars = is_function_type(t);
  let te_vars = lookup_type_vars(te);
  kind_t expected_kind = generalize_evars ? &tak : &tmk;
  let cvt = check_valid_type(loc, te,
			     CVTEnv{heap_region, te_vars, NULL, NULL,
				    generalize_evars,false},
			     expected_kind, true, t);
  let free_tvars = List::map(fst,cvt.free_vars);
  let free_evars = List::map(fst,cvt.free_evars);

  // filter out free tvars that are in the environment
  if (te_vars != NULL) {
    let res = NULL;
    for (let fs = free_tvars; fs; fs = fs->tl) {
      let f = fs->hd;
      bool found = false;
      for (let ts = te_vars; ts; ts = ts->tl)
	if (tvar_cmp(f,ts->hd) == 0) { found = true; break; }
      if (!found)
	res = new List(fs->hd,res);
    }
    free_tvars = List::imp_rev(res);
  }

  // resolve the kinds of type variables.  If there's a kind that must
  // be less than Mem, make it boxed.  If there's a Top RgnKind
  // type variable, make it RgnKind
  for (_ x = free_tvars; x != NULL; x = x->tl) {
    switch (compress_kb(x->hd->kind)) {
    case &Unknown_kb(*f): fallthru(f);
    case &Less_kb(*f,&Kind(BoxKind,Top)): fallthru(f);
    case &Less_kb(*f,&Kind(MemKind,Top)): fallthru(f);
    case &Less_kb(*f,&Kind(MemKind,Aliasable)):
      *f = kind_to_bound_opt(&bk); break;
    case &Less_kb(*f,&Kind(MemKind,Unique)):
      *f = kind_to_bound_opt(&ubk); break;
    case &Less_kb(*f,&Kind(RgnKind,Top)):
      *f = kind_to_bound_opt(&rk); break;
    case &Less_kb(*f,k):
      *f = kind_to_bound_opt(k);       break;
    case &Eq_kb(&Kind(MemKind,a)):
      terr(loc,"type variable %s cannot have kind %s",
	   tvar2string(x->hd), kind2string(new Kind(MemKind,a)));
      break;
    default: break;
    }
  }

  if (free_tvars != NULL || free_evars != NULL) {
    switch (compress(t)) {
    case &FnType(FnInfo{*btvs,...}):
      if (*btvs == NULL) {
	// abstract the free tvars
	*btvs = List::copy(free_tvars);
	free_tvars = NULL;
      }
      break;
    default: break;
    }
    if (free_tvars != NULL)
      terr(loc,"unbound type variable %s",*free_tvars->hd->name);
    check_free_evars(free_evars,t,loc);
  }
}

// Check that the function declaration has a valid type:  all
// we do is build a FnType and then check that it is well-formed
// which has the side effect of giving us the effect and any
// bound type variables.
void check_fndecl_valid_type(seg_t loc,tenv_t te,fndecl_t fd) {
  type_t t = fndecl2typ(fd);
  // this fills in the missing bound type variables and effects
  check_valid_toplevel_type(loc,te,t);
  switch (compress(t)) {
  case &FnType(FnInfo{tvs,effect,rtq,rt,args,_,_,_,_,req,req_relns,ens,ens_relns}):
    fd->tvs = tvs;
    fd->effect = effect;
    for (let fdargs = fd->args; fdargs != NULL; fdargs = fdargs->tl,
           args = args->tl) {
      (*fdargs->hd)[1] = (*args->hd)[1]; // to pick up resolved qualifiers
      (*fdargs->hd)[2] = (*args->hd)[2]; // to pick up resolved types
    }
    fd->ret_tqual = rtq;
    fd->ret_type = rt;
    fd->ret_tqual.real_const = extract_const_from_typedef(loc,fd->ret_tqual.print_const,rt);
    fd->requires_clause = req;
    fd->requires_relns = req_relns;
    fd->ensures_clause = ens;
    fd->ensures_relns = ens_relns;
    break;
  default: impos("check_fndecl_valid_type: not a FnType");
  }
  check_unique_vars(map(fst_fdarg,fd->args), loc,
		    "function declaration has repeated parameter");
  // cache the type on the declaration so we don't have to recompute it
  fd->cached_typ = t;
}

// Same as check_valid_type except that we ensure the free type variables
// are drawn from the given set of bound type variables.
void check_type(seg_t loc, tenv_t te,
                list_t<tvar_t,`H> bound_tvars,
                kind_t expected_kind, 
                bool allow_evars, 
                bool allow_abs_aggr,
                type_t t) {
  let cvt = check_valid_type(loc, te,
			     CVTEnv{heap_region, bound_tvars, 
				    NULL, NULL, false,false},
			     expected_kind, allow_abs_aggr, t);
  let free_tvars = remove_bound_tvars(heap_region,map(fst,cvt.free_vars),
				      bound_tvars);
  let free_evars = map(fst,cvt.free_evars);
  for (_ fs = free_tvars; fs != NULL; fs = fs->tl) {
    let ftvn = fs->hd->name;
    terr(loc,"unbound type variable %s in type %s",*ftvn,typ2string(t));
  }
  if (!allow_evars)
    check_free_evars(free_evars,t,loc);
}

void add_tvar_identity(tvar_t tv) {
  if (tv->identity == -1)
    tv->identity = new_tvar_id();
}

void add_tvar_identities(list_t<tvar_t> tvs) {
  List::iter(add_tvar_identity,tvs);
}

// Note: we expect lists to be very short.  Otherwise, a hashtable would
// be a better choice.
static void check_unique_unsorted(int (@cmp)(`a,`a), list_t<`a> vs,
				  seg_t loc,
				  string_t a2string(`a), string_t msg) {
  for(; vs != NULL; vs = vs->tl)
    for(_ vs2 = vs->tl; vs2 != NULL; vs2 = vs2->tl)
      if(cmp(vs->hd, vs2->hd)== 0)
	terr(loc, "%s: %s",msg,a2string(vs->hd));
}

static string_t<`r> strptr2string(string_t<`r> @s) {
  return *s;
}

void check_unique_vars(list_t<var_t,`r> vs, seg_t loc, string_t msg) {
  check_unique_unsorted(strptrcmp,vs,loc,strptr2string,msg);
}

void check_unique_tvars(seg_t loc, list_t<tvar_t> tvs) {
  check_unique_unsorted(tvar_cmp,tvs,loc,tvar2string,"duplicate type variable");
}

// take a list of $(list_t<designator>,`a) things corresponding to a struct.
// ensure the struct is not abstract.
//  * check that each list_t<designator> has exactly one element which is a
//    FieldName or is empty
//  * match up the correct member of sd->fields with the `a.  If the list
//    is empty, take the first unused field. ?????
//    Bang in the corresponding designator in the des list element
//  * for structs, ensure that each field is used exactly once.
//  * for unions, ensure that at most one field is used.
// FIX: Pass in a flag to allow multiple field names ??
list_t<$(aggrfield_t,`a)@`r,`r>
resolve_aggregate_designators(region_t<`r> rgn, seg_t loc,
                              list_t<$(list_t<designator_t>,`a)@> des,
                              aggr_kind_t aggr_kind,
                              list_t<aggrfield_t> sdfields) {
  region temp;
  // grab all the fields and mark them unused unless the field has an
  // empty name -- these are bitfields for padding and shouldn't be
  // initialized or projected.
  list_t<$(aggrfield_t,bool)@`temp,`temp> fields = NULL;
  for(_ sd_fields = sdfields; sd_fields != NULL; sd_fields = sd_fields->tl) {
    if (strcmp(*sd_fields->hd->name,"") != 0)
      fields = rnew(temp) List(rnew(temp) $(sd_fields->hd,false), fields);
  }
  fields = imp_rev(fields);

  string_t aggr_str = (aggr_kind == StructA) ? "struct" : "union";

  // match up each element of des
  list_t<$(aggrfield_t,`a)@`r,`r> ans = NULL;
  for(; des != NULL; des = des->tl) {
    let &$(dl,a) = des->hd;
    if(dl == NULL) {
      // grab first unused
      let fields2 = fields;
      for(; fields2 != NULL; fields2 = fields2->tl)
	if(!(*fields2->hd)[1]) {
	  (*fields2->hd)[1] = true;
	  (*des->hd)[0] = new List(new FieldName((*fields2->hd)[0]->name),NULL);
	  ans = rnew(rgn) List(rnew(rgn) $((*fields2->hd)[0],a), ans);
	  break;
	}
      if(fields2 == NULL)
	terr(loc, "too many arguments to %s",aggr_str);
    } else if(dl->tl != NULL)
      // we don't support multiple designators
      terr(loc, "multiple designators are not yet supported");
    else
      // find the right field based on the designator
      switch (dl->hd) {
      case &ArrayElement(_):
	terr(loc, "array designator used in argument to %s",aggr_str);
	break;
      case &FieldName(v):
	let fields2 = fields;
	for(; fields2 != NULL; fields2 = fields2->tl)
	  if(strptrcmp(v,((*fields2->hd)[0])->name) == 0) {
	    if((*fields2->hd)[1])
	      terr(loc, "member %s has already been used as an argument", *v);
	    (*fields2->hd)[1] = true;
	    ans = rnew(rgn) List(rnew(rgn) $((*fields2->hd)[0],a), ans);
	    break;
	  }
	if(fields2 == NULL)
	  terr(loc, "bad field designator %s", *v);
	break;
      }
  }
  if (aggr_kind == StructA) {
    // make sure we used all the fields
    for(; fields != NULL; fields = fields->tl)
      if(!(*fields->hd)[1]) {
        terr(loc, "too few arguments to struct");
        break;
      }
  } else {
    // make sure we used exactly one of the fields
    bool found = false;
    for (; fields != NULL; fields = fields->tl) {
      if ((*fields->hd)[1]) {
        if (found) terr(loc,"only one member of a union is allowed");
        found = true;
      }
    }
    if (!found) terr(loc,"missing member for union");
  }

  return imp_rev(ans);
}

bool is_tagged_pointer_typ_elt(type_t t, type_t@ elt_typ_dest) {
  switch (compress(t)) {
  case &PointerType(PtrInfo(elt_typ,_,PtrAtts(_,_,b,_,_))):
    switch (conref_constr((bounds_t)&DynEither_b_val,b)) {
    case &DynEither_b:
      *elt_typ_dest = elt_typ;
      return true;
    default: return false;
    }
  default: return false;
  }
}

bool is_zero_pointer_typ_elt(type_t t, type_t@ elt_typ_dest) {
  switch (compress(t)) {
  case &PointerType(PtrInfo(elt_typ,_,PtrAtts(_,_,_,zt,_))):
    *elt_typ_dest = elt_typ;
    return conref_def(false,zt);
  default: return false;
  }
}

// return true if t is a zero-terminated pointer or array type and set the
// elt_type and ptr_type as appropriate.
bool is_zero_ptr_type(type_t t, type_t @ptr_type,
		      bool @is_dyneither, type_t @elt_type) {
  switch (compress(t)) {
  case &PointerType(PtrInfo{elt,_,PtrAtts(_,_,bnds,zt,_)}):
    if (conref_def(false,zt)) {
      *ptr_type = t;
      *elt_type = elt;
      switch (conref_def(bounds_one,bnds)) {
      case &DynEither_b: *is_dyneither = true; break;
      default: *is_dyneither = false; break;
      }
      return true;
    } else return false;
  case &ArrayType(ArrayInfo{elt,tq,n,zt,_}):
    if (conref_def(false,zt)) {
      *elt_type = elt;
      *is_dyneither = false;      
      *ptr_type = promote_array(t,&HeapRgn_val,false);
      return true;
    } else return false;
  default: return false;
  }
}

// is e1 of the form *ea or ea[eb] where ea is a zero-terminated pointer?
// If so, return true and set ea and eb appropriately (for *ea set eb to 0).
// Finally, if the pointer is fat, set is_dyneither to true.
bool is_zero_ptr_deref(exp_t e1, type_t @ptr_type,
		       bool @is_dyneither, type_t @elt_type) {
  switch (e1->r) {
  case &Cast_e(_,_,_,_):
    impos("we have a cast in a lhs:  %s",exp2string(e1));
  case &Deref_e(e1a): fallthru(e1a);
  case &Subscript_e(e1a,_):
    return is_zero_ptr_type((type_t)e1a->topt,ptr_type,is_dyneither,elt_type);
  case &AggrArrow_e(e1a,...): fallthru(e1a);
  case &AggrMember_e(e1a,...):
    // sanity check
    if (is_zero_ptr_type((type_t)e1a->topt,ptr_type,is_dyneither,elt_type))
      impos("found zero pointer aggregate member assignment: %s",
	    exp2string(e1));
    return false;
  case &Instantiate_e(e1a,_): fallthru(e1a);
  case &NoInstantiate_e(e1a):
    if (is_zero_ptr_type((type_t)e1a->topt,ptr_type,is_dyneither,elt_type))
      impos("found zero pointer instantiate/noinstantiate: %s",
	    exp2string(e1));
    return false;
  case &Var_e(...): return false;
  default: impos("found bad lhs in is_zero_ptr_deref: %s",exp2string(e1));
  }
}

bool is_tagged_pointer_typ(type_t t) {
  type_t ignore = &VoidType_val;
  return is_tagged_pointer_typ_elt(t, &ignore);
}

/***************************************************/
/* Routines for dealing with non-aliasing pointers */
/***************************************************/

// warning: not just a predicate; side-effects VarTypes to be of non-unique
//   flavor if they are not yet set
bool is_noalias_region(type_t r, bool must_be_unique) {
//   printf("is_noalias_region: %s/%s\n",typ2string(compress(r)),
// 	 must_be_unique ? "yes" : "no");
  switch (compress(r)) {
  case &RefCntRgn: return !must_be_unique;
  case &UniqueRgn: return true;
  case &TypedefType(_,_,&Typedefdecl{.kind=&Core::Opt{.v=&Kind(k,a)},...},NULL): 
    return ((k == RgnKind) && (a == Unique || (a == Top && !must_be_unique)));
//     fallthru(k,a);
//   case &Evar(&Core::Opt{.v=&Kind(k,a)},NULL,_,_):
  case &VarType(tv):
    let &Kind(k,a) = tvar_kind(tv,&rk);
    if ((k == RgnKind) && (a == Unique || (a == Top && !must_be_unique))) {
      switch (compress_kb(tv->kind)) {
      case &Less_kb(*x,&Kind(RgnKind,Top)):
        *x = new Opt(new Less_kb(NULL,&rk));
        return false;
      default: return true;
      }
    }
    return false;
  default: return false;
  }
}

// warning: not just a predicate; side-effects VarTypes to be of non-unique
//   flavor if they are not yet solidly bounded
bool is_noalias_pointer(type_t t, bool must_be_unique) {
  switch (compress(t)) {
  case &PointerType(PtrInfo(_,_,PtrAtts(r,_,_,_,_))):
    return is_noalias_region(r,must_be_unique);
  case &VarType(tv):
    let &Kind(k,a) = tvar_kind(tv,&bk);
    switch (k) {
    case BoxKind: case AnyKind: case MemKind:
      if (a == Unique || (a == Top && !must_be_unique)) {
	switch (compress_kb(tv->kind)) {
	case &Less_kb(*x,&Kind(k,Top)):
	  *x = new Opt(new Less_kb(NULL,new Kind(k,Aliasable)));
	  return false;
	default:
// 	  fprintf(stderr,"|%s| is a no-alias path?\n",typ2string(t));
	  return true;
	}
      }
      return false;
    default: return false;
    }
  default: return false;
  }
}
bool is_noalias_pointer_or_aggr(type_t t) {
  let t = compress(t);
  if (is_noalias_pointer(t,false)) return true;
  switch (t) {
  case &TupleType(qts):
    while (qts != NULL) {
      if (is_noalias_pointer_or_aggr((*qts->hd)[1])) return true;
      qts = qts->tl;
    }
    return false;
  case &AggrType(AggrInfo({.KnownAggr = adp},ts)):
    if ((*adp)->impl == NULL) return false;
    else {
      let inst = List::zip((*adp)->tvs,ts);
      let x = (*adp)->impl->fields;
      type_t t;
      while (x != NULL) {
        t = (inst == NULL) ? x->hd->type : substitute(inst,x->hd->type);
        if (is_noalias_pointer_or_aggr(t)) return true;
        x = x->tl;
      }
      return false;
    }
  case &AnonAggrType(_,x):
    while (x != NULL) {
      if (is_noalias_pointer_or_aggr(x->hd->type)) return true;
      x = x->tl;
    }
    return false;
  case &AggrType(AggrInfo({.UnknownAggr = _},_)):
    // impos("got unknown aggr in is_noalias_aggr");
    return false;
  case &DatatypeType(DatatypeInfo(tinfo,ts)):
    switch (tinfo) {
    case {.UnknownDatatype = UnknownDatatypeInfo(nm,isxt)}:
      // impos("got unknown datatype in is_noalias_aggr");
      return false;
    case {.KnownDatatype = &&Datatypedecl(_,_,tvs,flds,_)}:
      // FIX: ...?
      return false;
    }
  case &DatatypeFieldType(DatatypeFieldInfo(tinfo,ts)):
    switch (tinfo) {
    case {.UnknownDatatypefield = _}:
      // impos("got unknown datatype field in is_noalias_aggr");
      return false;
    case {.KnownDatatypefield = $(td,fld)}:
      let inst = List::zip(td->tvs,ts);
      let typs = fld->typs;
      while (typs != NULL) {
        t = (inst == NULL) ? ((*typs->hd)[1]) : substitute(inst,(*typs->hd)[1]);
        if (is_noalias_pointer_or_aggr(t)) return true;
        typs = typs->tl;
      }
      return false;
    }
  default: return false;
  }
}

// returns true if the path [e] is entirely unique.  I.e. **x is unique
// if x has type (e.g.) int *`U*`U*`U x but not if it has type (e.g.)
// int *`U*`H*`U x
bool is_noalias_path(exp_t e) {
  switch (e->r) {
  case &Var_e(&Global_b(...)): return false;
  case &AggrArrow_e(e1,...): fallthru(e1);
  case &Deref_e(e1):
    return is_noalias_pointer((type_t)e1->topt,true) && is_noalias_path(e1);
  case &AggrMember_e(e1,f,...): return is_noalias_path(e1);
  case &Subscript_e(e1,e2):
    switch (compress((type_t)e1->topt)) {
    case &TupleType(...): return is_noalias_path(e1);
    default: return false;
    }
  case &Conditional_e(_,e1,e2):
    return is_noalias_path(e1) && is_noalias_path(e2);
  case &SeqExp_e(_,e2): fallthru(e2);
  case &Cast_e(_,e2,...): return is_noalias_path(e2);
  case &StmtExp_e(s):
    while(true) {
      switch(s->r) {
      case &Seq_s(s1,s2): s = s2; break;
      case &Decl_s(d,s1): s = s1; break;
      case &Exp_s(e): return is_noalias_path(e);
      default: impos("is_noalias_stmt_exp: ill-formed StmtExp");
      }
    }
  default: return true;
  }
}

// used by address of.
// Ensure e is an lvalue or function designator.
// Return if &e is const (true for const) and what region e is in (via a type
//    of RgnKind).
// FIX: not sure const is sufficient to prevent assigning to a function
//      designator???
// Type errors should already have been reported, so we often silently return
//   a bogus answer to avoid duplicate errors.
// Note: regions might not be resolved (unification is order-dependent),
//   but that's okay because a later unification will ensure soundness.
// Note: As explained below, if e1 is a FixedArray, then &e1[e2] is only
//   legal if e1 is an lvalue.  This is not true in C, but I need it, at least
//   for now, and I doubt anyone minds.
$(bool,type_t) addressof_props(tenv_t te, exp_t e) {
  // in some situations, the pointer must actually be const
  $(bool,type_t) bogus_ans = $(false, &HeapRgn_val);
  switch (e->r) {
  case &Var_e(x):
    // where oh where does my variable live?
    switch(x) {
    case &Unresolved_b(_):
    case &Funname_b(_): return bogus_ans;
    case &Global_b(vd):
      switch (compress((type_t)e->topt)) {
	// arrays cannot be modified
      case &ArrayType(_): return $(true, &HeapRgn_val);
      default: return $(vd->tq.real_const,&HeapRgn_val);
      }
    case &Local_b(vd):
      switch (compress((type_t)e->topt)) {
      case &ArrayType(_): return $(true, (type_t)vd->rgn);
      default:
        vd->escapes = true;
        return $(vd->tq.real_const, (type_t)vd->rgn);
      }
    case &Pat_b(vd):   fallthru(vd);
    case &Param_b(vd):
      vd->escapes = true;
      return $(vd->tq.real_const, (type_t)vd->rgn);
    }
  case &AggrMember_e(e1,f,is_tagged,_):
    // disallow & on @tagged union members -- see Dan's ESOP paper
    if (is_tagged) return bogus_ans;
    // we have an unboxed thing, so we inherit e2's region
    // must check that f isn't a bitfield.
    switch (compress((type_t)e1->topt)) {
    case &AnonAggrType(_,fs):
      let finfo = lookup_field(fs,f);
      if(finfo != NULL && finfo->width == NULL) {
        let $(c,t) = addressof_props(te,e1);
	return $(finfo->tq.real_const || c, t);
      }
      return bogus_ans;
    case &AggrType(AggrInfo({.KnownAggr = &ad},_)):
      let finfo = lookup_decl_field(ad,f);
      if(finfo != NULL && finfo->width == NULL) {
        let $(c,t) = addressof_props(te,e1);
	return $(finfo->tq.real_const || c, t);
      }
      return bogus_ans;
    default: return bogus_ans;
    }
  case &AggrArrow_e(e1,f,is_tagged,_):
    // disallow & on @tagged union members -- see Dan's ESOP paper
    if (is_tagged) return bogus_ans;
    // we have a boxed thing, so the region is in the pointer-type.
    // must check that f isn't a bitfield. 
    switch (compress((type_t)e1->topt)) {
    case &PointerType(PtrInfo(t1,_,PtrAtts(r,...))):
      struct Aggrfield * finfo;
      switch (compress(t1)) {
      case &AnonAggrType(_,fs):
	finfo = lookup_field(fs,f); break;
      case &AggrType(AggrInfo({.KnownAggr = &ad},_)):
	finfo = lookup_decl_field(ad,f); break;
      default: return bogus_ans;
      }
      if(finfo != NULL && finfo->width == NULL)
	return $(finfo->tq.real_const, r);
      return bogus_ans;
    default: return bogus_ans;
    }
  case &Deref_e(e1):
    // we have a boxed thing, so the region is in the pointer-type.
    switch (compress((type_t)e1->topt)) {
    case &PointerType(PtrInfo(_,tq,PtrAtts(r,...))):
      return $(tq.real_const, r); // FIX: is tq set correctly?
    default: return bogus_ans;
    }
  case &Subscript_e(e1,e2):
    // here we need to figure out whether we've got a boxed thing
    // or not because [] is overloaded for all array kinds, and tuples
    type_t t = compress((type_t)e1->topt);
    switch (t) {
    case &TupleType(ts):
      // We need an lvalue in this unboxed case whereas "C w/ tuples" wouldn't.
      let $(i,known) = Evexp::eval_const_uint_exp(e2);
      if(!known)
	return bogus_ans;
      let finfo = lookup_tuple_field(ts,i);
      if(finfo != NULL)
	return $((*finfo)[0].real_const, addressof_props(te,e1)[1]);
      return bogus_ans;
    case &PointerType(PtrInfo(_,tq,PtrAtts(r,...))):
      return $(tq.real_const,r);
    case &ArrayType(ArrayInfo{_,tq,_,_,_}):
      // Actually, this should be impossible since we've surely
      // promoted e1 to a pointer.
      // NOTE: Unlike C, we cannot allow any e1 -- it must be an lvalue.
      // (C doesn't need to know the region and we do!)
      return $(tq.real_const, addressof_props(te,e1)[1]);
    default: return bogus_ans;
    }
  default:
    terr(e->loc,"unary & applied to non-lvalue");
    return bogus_ans;
  }
}

// give an error when we can statically tell that the array bounds aren't
// large enough -- if the bounds are unconstrained, set them to i+1.
void check_bound(seg_t loc, unsigned int i, conref_t<bounds_t> b) {
  b = compress_conref(b);
  switch (conref_constr(bounds_one,b)) {
  case &DynEither_b: return; // always checked dynamically
  case &Upper_b(e):
    let $(j,known) = Evexp::eval_const_uint_exp(e);
    if(known && j <= i)
      terr(loc, "dereference is out of bounds: %d <= %d", j, i);
    return;
  }
}

void check_nonzero_bound(seg_t loc, conref_t<bounds_t> b) {
  check_bound(loc, 0, b);
}

bool is_bound_one(conref_t<bounds_t> b) {
  switch(conref_def((bounds_t)&DynEither_b_val,b)) {
  case &Upper_b(e):
    let $(i,known) = Evexp::eval_const_uint_exp(e);
    return known && i==1;
  default: return false;
  }
}

bool bits_only(type_t t) {
  switch (compress(t)) {
  case &VoidType:
  case &IntType(_,_):
  case &FloatType(_): return true;
  case &EnumType(_,_):
  case &AnonEnumType(_): return false; //could be true but for pattern exhaustion!
  case &ArrayType(ArrayInfo{t,_,_,zero_term,_}):
    // can't allow a zero-terminated array to be treated as bits only
    // for initialization purposes
    return (!conref_def(false,zero_term)) && bits_only(t);
  case &TupleType(tqs):
    for (; tqs != NULL; tqs = tqs->tl)
      if (!bits_only((*tqs->hd)[1])) return false;
    return true;
  case &AggrType(AggrInfo({.UnknownAggr = _},_)): return false;
  case &AggrType(AggrInfo({.KnownAggr = &ad},ts)):
    if(ad->impl==NULL)
      return false;
    bool okay = true;
    for (_ fs = ad->impl->fields; fs != NULL; fs = fs->tl)
      if (!bits_only(fs->hd->type)) { okay = false; break; }
    if (okay) return true;
    region rgn; 
    let inst = List::rzip(rgn,rgn,ad->tvs,ts);
    for (_ fs = ad->impl->fields; fs != NULL; fs = fs->tl)
      if (!bits_only(rsubstitute(rgn,inst,fs->hd->type))) return false;
    return true;
  case &AnonAggrType(_,fs):
    for (; fs != NULL; fs = fs->tl)
      if (!bits_only(fs->hd->type)) return false;
    return true;
  default: return false;
  }
}

// returns true if [e] is "essentially" a variable
bool is_var_exp(exp_t e) {
  while (1) {
    switch (e->r) {
    case &Var_e(...): return true;
    case &NoInstantiate_e(e2): fallthru(e2);
    case &Instantiate_e(e2,_): e = e2; continue;
//     case &Cast_e(_,e2,_,_): e = e2; continue;
    default: return false;
    }
  }
}

// FIX: there are other expressions we could allow, such as
// &(x->y) or &(x[0]) that we do not support here...
// RENAME
// Actually need to distinguish two kinds of constant expressions, as in ANSI C
// This is now sort of for top-level expressions
static bool cnst_exp(bool var_okay, exp_t e) {
  switch (e->r) {
  case &Const_e(_):
  case &Pragma_e(...):
  case &Sizeoftyp_e(_):
  case &Sizeofexp_e(_):
  case &Offsetof_e(_,_):
  case &Enum_e(...):
  case &AnonEnum_e(...): return true;
  case &Var_e(b):
    // NB: top-level function names and arrays are "constant"
    // Ignore unbound variables b/c should be reported elsewhere
    switch (b) {
    case &Funname_b(_): return true;
    case &Global_b(vd):
      switch (compress(vd->type)) {
      case &ArrayType(_):
      case &FnType(_): return true;
      default: return var_okay;
      }
    // local variables are OK if they are static
    case &Local_b(vd):
      if (vd->sc == Static)
	switch (compress(vd->type)) {
	case &ArrayType(_):
	case &FnType(_): return true;
	default: return var_okay;
	}
      else
	return var_okay;
    case &Unresolved_b(_): return false;
    default: return var_okay;
    }

  case &Conditional_e(e1,e2,e3):
    return (cnst_exp(false,e1)
            && cnst_exp(false,e2)
            && cnst_exp(false,e3));
  case &SeqExp_e(e1,e2):
    return (cnst_exp(false,e1) && cnst_exp(false,e2));
  case &NoInstantiate_e(e2): fallthru(e2);
  case &Instantiate_e(e2,_):
    return cnst_exp(var_okay,e2);
  case &Cast_e(t,e2,_,No_coercion):
    return cnst_exp(var_okay,e2);
  case &Cast_e(t,e2,_,_):
    // Fix: We cannot allow casts w/ run-time effect b/c C will complain!
    return cnst_exp(var_okay,e2);
  case &Address_e(e2):
    return cnst_exp(true,e2);
  case &Comprehension_e(_,e1,e2,_):
    return cnst_exp(false,e1) && cnst_exp(false,e2);
  case &ComprehensionNoinit_e(e,_,_):
    return cnst_exp(false,e);
  case &Array_e(des): fallthru(des);
  case &AnonStruct_e(_,des): fallthru(des);
  case &Aggregate_e(_,_,des,_):
    for (; des != NULL; des = des->tl)
      if (!cnst_exp(false,(*des->hd)[1]))
        return false;
    return true;

  case &Primop_e(p,es): fallthru(es);
  case &Tuple_e(es):    fallthru(es);
  case &Datatype_e(es,_,_):
    for (; es != NULL; es = es->tl)
      if (!cnst_exp(false,es->hd))
        return false;
    return true;
  default: return false;
  }
}

bool is_const_exp(exp_t e) {
  return cnst_exp(false,e);
}

static bool fields_support_default(list_t<tvar_t> tvs, list_t<type_t> ts,
                                   list_t<aggrfield_t> fs);
bool supports_default(type_t t) {
  switch (compress(t)) {
  case &VoidType:
  case &IntType(_,_):
  case &FloatType(_): return true;

  case &PointerType(PtrInfo(_,_,PtrAtts(_,nullable,bounds,_,_))):
    switch (conref_def((bounds_t)&DynEither_b_val,bounds)) {
    case &DynEither_b: return true;
    default: return conref_constr(true,nullable);
    }

  case &ArrayType(ArrayInfo{t,_,_,_,_}): return supports_default(t);
  case &TupleType(tqs):
    for (; tqs != NULL; tqs = tqs->tl)
      if (!supports_default((*tqs->hd)[1])) return false;
    return true;
  case &AggrType(AggrInfo(info,ts)):
    let ad = get_known_aggrdecl(info);
    if(ad->impl == NULL) return false;
    if(ad->impl->exist_vars != NULL) return false; // FIX?
    return fields_support_default(ad->tvs, ts, ad->impl->fields);
  case &AnonAggrType(_,fs): return fields_support_default(NULL,NULL,fs);

  case &AnonEnumType(_):
  case &EnumType(_,_): return true; // FIX: may not include 0!

  default: return false;
  }
}

// issue a warning if the type is a typedef with non-empty qualifiers
void check_no_qual(seg_t loc, type_t t) {
  switch (t) {
  case &TypedefType(_,_,tdopt,_):
    if (tdopt != NULL) {
      let tq = tdopt->tq;
      if (tq.print_const || tq.q_volatile || tq.q_restrict ||
          tq.real_const) {
        //if (tq.loc != NULL) loc = tq.loc;
        warn(loc,"qualifier within typedef type %s is ignored",typ2string(t));
      }
    }
    break;
  default: break;
  }
}

static bool fields_support_default(list_t<tvar_t> tvs, list_t<type_t> ts,
                                   list_t<aggrfield_t> fs) {
  region rgn; 
  let inst = List::rzip(rgn,rgn,tvs,ts);
  for (; fs != NULL; fs = fs->tl) {
    type_t t = fs->hd->type;
    if (supports_default(t)) return true;
    t = rsubstitute(rgn,inst,fs->hd->type);
    if (!supports_default(t)) return false;
  }
  return true;
}

// returns true if "0" is a value in the type.  Used for checking
// the well-formedness of zero-terminated array and pointer types.
// Currently, only integral types and thin pointers support this.
bool admits_zero(type_t t) {
  switch (compress(t)) {
  case &IntType(_,_):
  case &FloatType(_): return true;
  case &PointerType(PtrInfo(_,_,PtrAtts(_,nullable,bounds,_,_))):
    switch (conref_def((bounds_t)&DynEither_b_val,bounds)) {
      // for now, we're not allowing fat pointers to be in zero-terminated
      // arrays.  They cause way too many problems in the translation and
      // are of dubious use (I hope.)
    case &DynEither_b: return false;
    default: return conref_def(false,nullable);
    }
  default: return false;
  }
}

bool is_noreturn(type_t t) {
  switch (compress(t)) {
  case &PointerType(PtrInfo(elt,_,_)): return is_noreturn(elt);
  case &FnType(FnInfo{.attributes = atts,...}):
    for (; atts != NULL; atts = atts->tl)
      switch (atts->hd) {
      case &Noreturn_att: return true;
      default: continue;
      }
    break;
  default: break;
  }
  return false;
}

// Transfer any function type attributes from the given list to the
// function type.
attributes_t transfer_fn_type_atts(type_t t, attributes_t atts) {
  switch (compress(t)) {
  case &FnType(FnInfo{.attributes = *fnatts,...}):
    let res_atts = NULL;
    for (; atts != NULL; atts = atts->tl)
      if (fntype_att(atts->hd)) {
	if (!List::mem(attribute_cmp,*fnatts,atts->hd))
	  *fnatts = new List(atts->hd,*fnatts);
      }
      else
        res_atts = new List(atts->hd,res_atts);
    return res_atts;
  default: impos("transfer_fn_type_atts");
  }
}

// return the number of elements in an array or pointer type (if present)
exp_opt_t get_type_bound(type_t t) {
  exp_opt_t bound = NULL;
  switch (compress(t)) {
  case &PointerType(*pi):
    switch (conref_val(pi->ptr_atts.bounds)) {
    case &Upper_b(e): bound = e; break;
    default: break;
    }
    break;
  case &ArrayType(ArrayInfo{.num_elts = e,...}):
    bound = e;
    break;
  default: break;
  }
  return bound;
}

// If b is a non-escaping variable binding, return a non-null pointer to
// the vardecl.  Mostly used by the relations code in the flow analysis.
struct Vardecl *nonesc_vardecl(binding_t b) {
  switch (b) {
  case &Pat_b(x): fallthru(x);
  case &Local_b(x): fallthru(x);
  case &Param_b(x): fallthru(x);
  case &Global_b(x): 
    if (!x->escapes) return x;
    break;
  default: break;
  }
  return NULL;
}

// removes NULL members; reverses the list
list_t<`a> filter_nulls(list_t<`a*> l) {
  let res = NULL;
  for (_ x = l; x != NULL; x=x->tl)
    if (x->hd != NULL) res = new List(*x->hd,res);
  return res;
}

bool is_array(type_t t) {
  switch(compress(t)) {
  case &ArrayType(_): return true;
  default: return false;
  }
}

type_t promote_array(type_t t, type_t rgn, bool convert_tag) {
  switch(compress(t)) { 
  case &ArrayType(ArrayInfo(et,tq,eopt,zt,ztl)):
    bounds_t b;
    if (eopt == NULL)
      b = &DynEither_b_val;
    else {
      exp_t bnd = (exp_t)eopt;
      if (convert_tag) {
	if (bnd->topt == NULL)
	  impos("cannot convert tag without type!");
	switch(compress((type_t)bnd->topt)) {
	case &TagType(t):
	  b = new Upper_b(cast_exp(uint_typ,valueof_exp(t,0),false,No_coercion,0));
	  break;
	default:
	  if(is_const_exp(bnd))
	    b = new Upper_b(bnd);
	  else
	    b = &DynEither_b_val;
	}
      }
      else
	b = new Upper_b(bnd);
    }
    return atb_typ(et,rgn,tq,
		   b,
	           zt);
  default: return t;
  }
}

// does the type admit zero?
bool zeroable_type(type_t t) {
  switch (compress(t)) {
  case &VoidType: return true;
  case &Evar(...):
  case &VarType(...):
  case &DatatypeType(...):
  case &DatatypeFieldType(...): return false;
  case &PointerType(PtrInfo(_,_,PtrAtts(_,n,_,_,_))):
    return (conref_def(true,n));
  case &IntType(...):
  case &FloatType(...): return true;
  case &ArrayType(ArrayInfo{t,...}): return zeroable_type(t);
  case &FnType(_): return false;
  case &TupleType(tqs):
    for (; tqs; tqs = tqs->tl)
      if (!zeroable_type((*tqs->hd)[1])) return false;
    return true;
  case &AggrType(AggrInfo(info,ts)):
    let ad = get_known_aggrdecl(info);
    if(ad->impl == NULL || ad->impl->exist_vars != NULL)
      return false;
    region r; 
    let inst = List::rzip(r,r,ad->tvs,ts);
    for (_ fs = ad->impl->fields; fs != NULL; fs = fs->tl)
      if (!zeroable_type(rsubstitute(r,inst,fs->hd->type))) return false;
    return true;
  case &EnumType(...): // FIX: explicit tags?
  case &TagType(...): return true; // FIX: true iff 0? Is sizeof right?
  case &AnonAggrType(_,fs):
    for (; fs != NULL; fs = fs->tl)
      if (!zeroable_type(fs->hd->type)) return false;
    return true;
  case &AnonEnumType(...): return true; // FIX: explicit tags?
  case &TypedefType(...):
  case &DynRgnType(...): 
  case &RgnHandleType(...): 
  case &BuiltinType(...): return false;

  case &TypeDeclType(...):
  case &TypeofType(...):
  case &ValueofType(...):
  case &HeapRgn:
  case &UniqueRgn:
  case &RefCntRgn:
  case &AccessEff(...):
  case &JoinEff(...):
  case &RgnsEff(...): impos("bad type `%s' in zeroable type",typ2string(t));
  }
}

