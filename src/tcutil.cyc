// Utility functions for type checking

#include "core.h"
#include "stdio.h"
#include "absyn.h"
#include "absynpp.h"
#include "set.h"
#include "position.h"
#include "tcenv.h"
#include "string.h"
#include "evexp.h"
#include "tcutil.h"
#include "tcexp.h"
using Core;
using Stdio;
using List;
using Set;
using Position;
using Absyn;
using Absynpp;
using Tcenv;

namespace Tcutil;

xtunion exn {TypeErr};

extern void unify_it(type_t t1, type_t t2);

void terr(seg_t loc, string s) {
  Position::post_error(Position::mk_err_elab(loc,s));
}

`a impos(string msg) {
  fprintf(stderr,"Error: %s\n",msg);
  fflush(stderr);
  throw TypeErr;
}

static string tvar2string(tvar_t tv) {
  return *tv->name;
}

void print_tvars(list_t<tvar_t> tvs) {
  for (; tvs != null; tvs = tvs->tl) 
    fprintf(stderr,"%s::%s ",tvar2string(tvs->hd),ckind2string(tvs->hd->kind));
  fprintf(stderr,"\n"); fflush(stderr);
}

static list_t<seg_t>     warning_segs = null;
static list_t<stringptr> warning_msgs = null;

// we batch warnings because we have to parse the file to determine
// line and column information.
void warn(seg_t sg, string msg) {
  warning_segs = new List(sg, warning_segs);
  // FIX:  cast to stringptr is necessary here...
  warning_msgs = new List((stringptr)(new {msg}),warning_msgs);
}
void flush_warnings() {
  if(warning_segs == null)
    return;
  fprintf(stderr,"***Warnings***\n");
  list_t<stringptr> seg_strs = strings_of_segments(warning_segs);
  warning_segs = null;
  warning_msgs = List::imp_rev(warning_msgs);
  while(warning_msgs != null) {
    fprintf(stderr,"%s: %s\n", *(seg_strs->hd), *(warning_msgs->hd));
    seg_strs     = seg_strs->tl;
    warning_msgs = warning_msgs->tl;
  }
  fprintf(stderr,"**************\n");
  fflush(stderr);
}

// set by by Tcenv::tc_init, used to reduce allocation and calls to Set::empty.
opt_t<set_t<var_t>> empty_var_set = null;

// fast type-variable comparison -- can only be used when a tvar has
// an identity.
static int fast_tvar_cmp(tvar_t tv1, tvar_t tv2) {
  return (*tv1->identity - *tv2->identity);
}

// compress out any evars or typedefs
type_t compress(type_t t) {
  switch (t) {
  case &Evar(_,null,_,_): 
    return t;
  case &Evar(_,*t2opt_ref,_,_): // TRICKY
    type_t t2 = compress((*t2opt_ref)->v);
    // only modify if something changed to avoid allocation
    if (t2 != (*t2opt_ref)->v)
      *t2opt_ref = new Opt(t2);
    return t2;
  case &TypedefType(_,_,null): 
    return t;
  case &TypedefType(_,_,*topt_ref):
    type_t t2 = compress((*topt_ref)->v);
    // only modify if something changed to avoid allocation
    if (t2 != (*topt_ref)->v)
      *topt_ref = new Opt(t2);
    return t2;
  default:
    return t;
  }
}

// Our lattice looks like this:
//          AbsType   EffKind  RgnKind
//             V
//          MemType
//             V
//          BoxType
// Only used during unification -- we can constrain an Evar or VarType
// as long as we move down in the lattice.
static bool kind_leq(kind_t k1, kind_t k2) {
  if (k1 == k2) return true;
  switch ($(k1,k2)) {
  case $(BoxKind, MemKind): return true;
  case $(BoxKind, AnyKind): return true;
  case $(MemKind, AnyKind): return true;
  default: return false;
  }
}


// Return the "least" kind of a type, according to the lattice above
// In some situations, we have to be conservative...
// Note that both Evars and VarTypes should have their kinds established
// by this point.
kind_t typ_kind(type_t t) {
  switch (compress(t)) {
  case &Evar(k,topt,_,_): return k->v; 
  case &VarType(tv):      return conref_val(tv->kind);
  case VoidType:          return MemKind;
  case &IntType(_,sz):    return (sz==(size_of_t)B4) ? BoxKind : MemKind;
  case FloatType:         return MemKind;
  case DoubleType:        return MemKind;
  case &FnType(_):        return MemKind;
  case &RgnHandleType(_): return BoxKind; 
  case HeapRgn:           return RgnKind;
  case &TunionType(_):    return BoxKind;
  case &TunionFieldType(TunionFieldInfo(&KnownTunionfield(_,tuf),_)):
    if(tuf->typs == null) return BoxKind;
    else return MemKind;
  case &TunionFieldType(TunionFieldInfo(&UnknownTunionfield(_),_)):
    return impos("typ_kind: Unresolved TunionFieldType");
    // for structs or unions without definitions, we must be conservative
  case &StructType(_,_,null): return AnyKind;
  case &UnionType(_,_,null) : return AnyKind;
  case &StructType(_,_,_):    return MemKind;
  case &UnionType(_,_,_):     return MemKind;
  case &AnonStructType(_):    return MemKind;
  case &AnonUnionType(_):     return MemKind;
  case &EnumType(_,_):        return BoxKind;
  case &PointerType(pinfo):
    switch (compress_conref(pinfo.bounds)->v) {
    case &Eq_constr(Unknown_b):  return MemKind;
    case &Eq_constr(&Upper_b(_)): return BoxKind;
    case No_constr:             return MemKind; 
      // be conservative -- this may later be constrained with an Unknown_b
    case &Forward_constr(_): 
      return impos("typ_kind: forward constraint in ptr bounds");
    }
  // Arrays are always of memkind
  case &ArrayType(t,_,_): return MemKind;
  case &TupleType(tqts):  return MemKind;
  case &TypedefType(_,_,topt): 
    return impos(xprintf("typ_kind: typedef found: %s", typ2string(t)));
  case &AccessEff(_):     return EffKind;
  case &JoinEff(_):       return EffKind;
  }
}

xtunion exn {Unify};

// unify types t1 and t2, returning true iff the unification succeeds 
bool unify(type_t t1, type_t t2) {
  try {
    unify_it(t1,t2);
    return true;
  } catch {
  case Unify: return false;
  }
}

// see if evar occurs within t and also check that every free type
// variable in t occurs within the list env.
static void occurslist(type_t evar, list_t<tvar_t> env, list_t<type_t> ts); // mutually recursive fns
static void occurs(type_t evar, list_t<tvar_t> env, type_t t) {
  switch (compress(t)) {
  case &VarType(tv): 
    if (!List::mem(fast_tvar_cmp,env,tv)) throw Unify; break;
  case &Evar(_,r,_,*sopt):
    if (t == evar) throw Unify;
    else if (r != null) occurs(evar,env,r->v);
    else {
      // check to see if sopt is a subset of env
      bool problem = false;
      for (_ s = (*sopt)->v; s != null; s = s->tl) {
        if (!List::mem(fast_tvar_cmp,env,s->hd)) {
          problem = true; break;
        }
      }
      // for sopt to be a subset of env
      if (problem) {
        let result = null;
        for (_ s = (*sopt)->v; s != null; s = s->tl) {
          if (List::mem(fast_tvar_cmp,env,s->hd)) 
            result = new List(s->hd,result);
        }
        *sopt = new Opt(result);
      }
    }
    break;
  case &PointerType(pinfo): 
    occurs(evar,env,pinfo.elt_typ); occurs(evar,env,pinfo.rgn_typ); break;
  case &ArrayType(t2,_,_): occurs(evar,env,t2); break;
  case &FnType(FnInfo{tvs,eff,rt,args,c_varargs,cyc_varargs,atts}): 
    if (eff != null) occurs(evar,env,eff->v);
    occurs(evar,env,rt);
    for(; args != null; args = args->tl)
      occurs(evar,env,(*args->hd)[2]);
    if (cyc_varargs != null) {
      let VarargInfo(_,_,t,r,_) = *cyc_varargs;
      occurs(evar,env,t); occurs(evar,env,r);
    }
    break;
  case &TupleType(args):
    for(; args != null; args = args->tl)
      occurs(evar,env,(*args->hd)[1]);
    break;
  case &RgnHandleType(rt): occurs(evar,env,rt); break;
  case &TunionType(TunionInfo{_,ts,r}):
    occurs(evar,env,r); occurslist(evar,env,ts); break;
  case &TypedefType(_,ts,topt): fallthru(ts);
  case &TunionFieldType(TunionFieldInfo{_,ts}): fallthru(ts);
  case &StructType(_,ts,_): occurslist(evar,env,ts); break;
  case &AnonStructType(fs): fallthru(fs);
  case &AnonUnionType(fs):
    for (; fs != null; fs = fs->tl)
      occurs(evar, env, fs->hd->type);
    break;
  case &AccessEff(t0): occurs(evar,env,t0); break;
  case &JoinEff(ts): occurslist(evar,env,ts); break;
  default: break;
  }
}
static void occurslist(type_t evar, list_t<tvar_t> env,list_t<type_t> ts) {
  for (; ts != null; ts = ts->tl)
    occurs(evar,env,ts->hd);
}

// unify two lists of types
static void unify_list(list_t<type_t> t1, list_t<type_t> t2) {
  try List::iter2(unify_it,t1,t2);
  catch {case List_mismatch: throw Unify;}
}

// unify two type qualifiers -- throws Unify unless they are the same
static void unify_tqual(tqual_t tq1, tqual_t tq2) {
  if ((tq1.q_const != tq2.q_const)    
      || (tq1.q_volatile != tq2.q_volatile) 
      || (tq1.q_restrict != tq2.q_restrict))
    throw Unify;
}

bool equal_tqual(tqual_t tq1, tqual_t tq2) {
  return ((tq1.q_const == tq2.q_const) 
	  && (tq1.q_volatile == tq2.q_volatile) 
	  && (tq1.q_restrict == tq2.q_restrict));
}

// unify two constraint refs
static void unify_it_conrefs(int cmp(`a,`a), conref_t<`a> x, conref_t<`a> y) {
  x = compress_conref(x);
  y = compress_conref(y);
  if (x == y) return;
  switch (x->v) {
  case No_constr: x->v = new Forward_constr(y); return;
  case &Forward_constr(_): 
    throw impos("unify_conref: forward after compress");
  case &Eq_constr(xv):
    switch (y->v) {
    case No_constr: y->v = x->v; return;
    case &Forward_constr(_):
      throw impos("unify_conref: forward after compress(2)");
    case &Eq_constr(yv):
      if (cmp(xv,yv) != 0) throw Unify;
      return;
    }
  }
}

static bool unify_conrefs(int cmp(`a,`a), conref_t<`a> x, conref_t<`a> y) {
  try {
    unify_it_conrefs(cmp,x,y);
    return true;
  } catch { case Unify: return false; }
}

static int boundscmp(bounds_t b1, bounds_t b2) {
  switch ($(b1,b2)) {
  case $(Unknown_b,Unknown_b): return 0;
  case $(Unknown_b,_): return -1;
  case $(_,Unknown_b): return 1;
  case $(&Upper_b(e1),&Upper_b(e2)): 
    int i1 = Evexp::eval_const_uint_exp(e1);
    int i2 = Evexp::eval_const_uint_exp(e2);
    if (i1 == i2) return 0;
    if (i1 < i2) return -1;
    return 1;
  }
}

static bool equal_att(attribute_t a1, attribute_t a2) {
  if (a1 == a2) return true;
  switch ($(a1,a2)) {
  case $(&Regparm_att(i1), &Regparm_att(i2)): fallthru(i1,i2);
  case $(&Aligned_att(i1), &Aligned_att(i2)): return i1 == i2;
  case $(&Section_att(s1), &Section_att(s2)):
    return String::strcmp(s1,s2) == 0;
  default: return false;
  }
}

bool same_atts(attributes_t a1, attributes_t a2) {
  for (_ a = a1; a != null; a = a->tl) 
    if (!List::exists_c(equal_att,a->hd,a2)) return false;
  for (_ a = a2; a != null; a = a->tl)
    if (!List::exists_c(equal_att,a->hd,a1)) return false;
  return true;
}

// flattens out nested join effects -- this has a side effect 
// on the actual type
static void normalize_effect(type_t e) {
  e = compress(e);
  switch (e) {
  case &JoinEff(*es):
    bool nested_join = false;
    for (_ effs = *es; effs != null; effs = effs->tl) {
      let eff = effs->hd;
      normalize_effect(eff);
      switch (compress(eff)) {
      case &JoinEff(_): nested_join = true; break;
      default: break;
      }
    }
    if (!nested_join) return;
    list_t<type_t> effects = null;
    for (_ effs = *es; effs != null; effs = effs->tl) {
      switch (compress(effs->hd)) {
      case &JoinEff(nested_effs): 
        effects = List::revappend(nested_effs,effects);
        break;
      case e: effects = new List(e,effects); break;
      }
    }
    *es = List::imp_rev(effects);
    break;
  default: break;
  }
}

// Tries to break an effect into an effect evar and the rest of the
// effect along with the set of free type variables for the evar.
// This fails unless the effect is either JoinEff(ev::rest)
// where ev is an unconstrained effect evar, or else the effect is
// an unconstrained evar.
static $(type_t, list_t<type_t>, list_t<tvar_t>)*get_effect_evar(type_t t)
{
  switch (compress(t)) {
  case &JoinEff(&List{.hd=ef1,.tl=ef2}):
    switch (compress(ef1)) {
    case &Evar(_,_,_,s): return new $(ef1,ef2,s->v);
    default: return null;
    }
  case &Evar(k,_,_,s): 
    if (k == null || k->v != EffKind) impos("effect evar has wrong kind");
    return new $(t,null,s->v);
  default: return null;
  }
}

static struct Opt<kind_t> ek = {EffKind};

// Returns true if the region r is in the effect e or else r is the
// heap region.  If constrain is true, this might cause region or
// effect evars to become constrained.
bool region_in_effect(bool constrain, type_t r, type_t e) {
  r = compress(r);
  if (r == HeapRgn) return true;
  switch (compress(e)) {
  case &AccessEff(r2): 
    // note:  might constrain a region variable unnecessarily
    if (constrain) return unify(r,r2);
    compress(r2);
    if (r == r2) return true;
    switch ($(r, r2)) {
    case $(&VarType(tv1), &VarType(tv2)): return (tvar_cmp(tv1,tv2) == 0);
    default: return false;
    }
  case &JoinEff(es): 
    for (; es != null; es = es->tl) 
      if (region_in_effect(constrain, r, es->hd)) return true;
    return false;
  case &Evar(k,*p,_,s): 
    if (k == null || k->v != EffKind) impos("effect evar has wrong kind");
    if (!constrain) return false;
    // we found a non-canonical evar -- we can grow it to include r
    // but this may cause problems later on with other constraints.
    let ev = new_evar(&ek,s);
    // this has the effect of checking that any free variables in r
    // are contained in s.
    occurs(ev,s->v,r);
    let new_typ = new JoinEff(new List{ev,new List{new AccessEff(r),null}});
    *p = new Opt(new_typ);
    return true;
  default: return false;
  }
}

// Returns true if the type variable v is in the effect e.
// If constrain is true, this might cause effect evars to become constrained.
static bool variable_in_effect(bool constrain, tvar_t v, type_t e) {
  e = compress(e);
  switch (e) {
  case &VarType(v2): return (tvar_cmp(v, v2) == 0);
  case &JoinEff(es):
    for (; es != null; es = es->tl) 
      if (variable_in_effect(constrain, v, es->hd)) return true;
    return false;
  case &Evar(k,*p,_,s):
    if (k == null || k->v != EffKind) impos("effect evar has wrong kind");
    // we found a non-canonical evar -- we can grow it to include v
    // but this may cause problems later on with other constraints.
    let ev = new_evar(&ek,s);
    // make sure v is in the allowed set of type variables for the evar
    if (!List::mem(fast_tvar_cmp,s->v,v))
      return false;
    let new_typ = new JoinEff(new List{ev,new List{new VarType(v),null}});
    *p = new Opt(new_typ);
    return true;
  default: return false;
  }
}

// Returns true if the effect evar ev is in the effect e.
static bool evar_in_effect(type_t evar, type_t e) {
  e = compress(e);
  switch (e) {
  case &JoinEff(es):
    for (; es != null; es = es->tl) 
      if (evar_in_effect(evar, es->hd)) return true;
    return false;
  case &Evar(_,_,_,_): return (evar == e);
  default: return false;
  }
}

// Returns true when e1 is a sub-effect of e2 -- this isn't very
// efficient and can constrain both effect and region evars in
// unpredictable ways (though it tries hard not to).  
// When set_to_empty is true, evars in e1 that do not occur in (or
// cannot easily be made to occur in) e2 are constrained to the 
// empty effect (or HeapRgn for region evars).  This is the "right" 
// thing for when a function call needs to constrain the effect to 
// an upper bound.  When set_to_empty is false, we instantiate 
// unconstrained evars in e1 to be e2.
bool subset_effect(bool set_to_empty, type_t e1, type_t e2) {
  // if e2 is of the form JoinEff(ev::rest) where ev is an effect evar,
  // then we can instantiate ev to JoinEff(ev'::e1) where ev' is fresh
  switch (get_effect_evar(e2)) {
  case &$(ev1,rest,s): 
    let ev = new_evar(&ek,new Opt(s));
    let new_typ = new JoinEff(new List{ev,new List{e1,null}});
    return unify(ev1, new_typ);
  default: break;
  }
  switch (compress(e1)) {
  case &JoinEff(es): 
    for (; es != null; es = es->tl)
      if (!subset_effect(set_to_empty,es->hd,e2))
	return false;
    return true;
  case &AccessEff(r): 
    // Try checking if the region is in the effect without performing
    // any unification first and only if this fails do we actually
    // go in and try to unify something.  It's not clear whether it's
    // best to just pin the region to HeapRgn or try to unify it with
    // some region already in the effect e2.  I'm opting for doing the
    // latter first, and then the former.
    return (region_in_effect(false,r,e2) || region_in_effect(true,r,e2) ||
            unify(r,HeapRgn));
  case &VarType(v): 
    // Same idea with effect variables
    return variable_in_effect(false,v,e2) || variable_in_effect(true,v,e2);
  case &Evar(_,*p,_,s): 
    if (!evar_in_effect(e1,e2)) 
      // We can set the evar to be any subset of e2.  When set_to_empty
      // is true, we set it to the empty effect, and otherwise set it to
      // e2.  Setting it to the empty effect is the right thing to do at
      // a function call when the instatiation and call occur simultaneously. 
      // For other situations, it's not clear what is the right thing to do.
      if (set_to_empty)
        *p = new Opt(new JoinEff(null));
      else {
        // check that e1 doesn't occur in e2 and that the free type
        // variables of e2 are contained in s.
        occurs(e1,s->v,e2);
        *p = new Opt(e2);
      }

    return true;
  default: 
    return impos(xprintf("subset_effect: bad effect: %s",typ2string(e1)));
  }
}

// "unify" two effects -- a total and complete HACK
// This all relies crucially upon the fact that either the algorithm
// for determining default effects, or the user puts in a (unique)
// effect variable on each function type at the beginning of the
// function (a la Tofte & Talpin's e.phi notation.)  
//
//  We first "normalize" the effect so that it is flattened but preserves
//  the original order.  Then there are two cases to consider:
//    * When the two effects are of the form JoinEff(ev1::rest1) and 
//      JoinEff(ev2::rest2), where ev1 and ev2 are unconstrained effect 
//      Evars, then we create a new evar ev, and set both ev1 and ev2 to 
//      point to JoinEff(ev::rest1@rest2).  This way, when the types are 
//      normalized again, we end up with each effect including the other plus 
//      some additional slack.  Note that we need to check that ev1 doesn't
//      occur in rest2 and that ev2 doesn't occur in rest1.  This can
//      actually happen if an evar shows up twice in an effect.
//      FIX:  should get rid of duplicates in effects but this might be
//      expensive.
//    * When the two effects are otherwise, we simply check that one
//      effect is a "subset" of the other.  If necessary, we instantiate
//      region or effect evars to force the subset relation.  This may 
//      cause region or effect evars to become pinned down in an undesirable 
//       way...  But the situation should be rare, and if it happens, users
//       should fall back on explicit typing.
//
// What we should really do:  generate some set equalities and hold
// on to them.  Then try to simplify and solve them later on after
// things have become more constrained.  
static bool unify_effect(type_t e1, type_t e2) {
  e1 = compress(e1);
  e2 = compress(e2);
  normalize_effect(e1);
  normalize_effect(e2);
  switch ($(get_effect_evar(e1),get_effect_evar(e2))) {
  case $(&$(ev1,rest1,s1), &$(ev2,rest2,s2)):
    // The fast path:  both effects are of the form JoinEff(ev::rest)
    let s = null;
    for (; s1 != null; s1 = s1->tl) {
      if (List::mem(fast_tvar_cmp,s2,s1->hd)) s = new List(s1->hd,s);
    }
    let ev = new_evar(&ek,new Opt(s));
    let new_typ = new JoinEff(new List{ev,List::append(rest1,rest2)});
    // the calls to unify here do the occurs check and also set the evars
    // to point to the new "union" effect
    return unify(ev1, new_typ) && unify(ev2, new_typ);
  default: 
    // The slow path -- see above.  we drive the slack in effects so
    // that the two effects will start to look like one another...
    return subset_effect(false, e1, e2) && subset_effect(false, e2, e1); 
  }
}

// the real work of unification
void unify_it(type_t t1, type_t t2) {
  t1 = compress(t1);
  t2 = compress(t2);
  if (t1 == t2) return;
  switch (t1) {
  case &Evar(kind1,*ref1_ref,_,s1opt):
    // check that the evar doesn't occur in t2 and that any free variables
    // of t2 are contained in s1.
    occurs(t1,s1opt->v,t2);
    let kind2 = typ_kind(t2);
    // we can constrain the Evar to be equal to t2 only when the kind of 
    // the evar is greater than or equal to the kind of t2 or t2 is an 
    // evar that we can constrain to be equal to t1.
    if (kind_leq(kind2,kind1->v)) {
      *ref1_ref = new Opt(t2);
      return;
    } else {
      switch (t2) {
      case &Evar(_,*ref2_ref,_,s2opt): 
        // check that s2 is a subset of s1
        let s1 = s1opt->v;
        for (_ s2 = s2opt->v; s2 != null; s2 = s2->tl) {
          if (!List::mem(fast_tvar_cmp,s1,s2->hd)) throw Unify;
        }
        if (kind_leq(kind1->v,kind2)) {
          *ref2_ref = new Opt(t1); return;
        }
        break;
        // this is a special hack to deal with the fact that a boxed evar
        // can't unify with a pointer type where we don't know whether or
        // not it's a ? pointer vs. a * or @ pointer.  
      case &PointerType(pinfo) && kind1->v == BoxKind:
        let c = compress_conref(pinfo.bounds);
        switch (c->v) {
        case No_constr:
          // set the pointer to be a * or @ to an array of size 1
          c->v = new Eq_constr((bounds_t)(new Upper_b(signed_int_exp(1,null))));
          *ref1_ref = new Opt(t2);
          return;
        default: break;
        }
        break;
      default: break;
      }
      throw Unify;
    }
  default: break; 
  }
  // t1 is not an evar

    // in what follows, we throw Unify unless we explicitly return.
  switch ($(t2,t1)) {

  case $(&Evar(_,_,_,_),_): // t2 is an evar, t1 is not, swap and try again
    unify_it(t2,t1);
    return;

  case $(VoidType,VoidType): return;

  case $(&VarType(tv2),&VarType(tv1)):
    let x2 = tv2->name;
    let x1 = tv1->name;
    // identities should be resolved
    let id2 = *tv2->identity;
    let id1 = *tv1->identity; 
    let k2 = conref_val(tv2->kind);
    let k1 = conref_val(tv1->kind);
    // kinds should already be resolved.  
    // FIX: shouldn't need the zstrptrcmp any more...
    if (id1 == id2 && String::zstrptrcmp(x2,x1) == 0) {
      // sanity check
      if (k2 != k1)
        impos(xprintf("same type variable %s has kinds %s and %s",
                      *x2,kind2string(k2),kind2string(k1)));
      return;
    } 
    break;

    // Note: don't use sdp or edp in next two cases because they
    //       might not be set due to an earlier type error.
  case $(&StructType(nopt2,ts2,sdp2),&StructType(nopt1,ts1,sdp1)): 
    if ((nopt1 != null && nopt2 != null
	 && qvar_cmp((qvar_t)nopt1,(qvar_t)nopt2) == 0) 
	|| (nopt1 == null && nopt2 == null)) {
      unify_list(ts1,ts2);
      return;
    }
    break;

  case $(&EnumType(n1,_), &EnumType(n2,_)):
    if (qvar_cmp(n1,n2) == 0) return;
    break;

  case $(&UnionType(nopt2,ts2,udp2), &UnionType(nopt1,ts1,udp1)):
    if ((nopt1 != null && nopt2 != null
         && qvar_cmp((qvar_t)nopt1,(qvar_t)nopt2) == 0)
        || nopt1 == null && nopt2 == null) {
      unify_list(ts1,ts2);
      return;
    }
    break;

  case $(&TunionType(TunionInfo(&KnownTunion(tud2),ts2,r2)),
	 &TunionType(TunionInfo(&KnownTunion(tud1),ts1,r1))):
    if(tud2 == tud1 || qvar_cmp(tud2->name,tud1->name) == 0) {
      unify_it(r1,r2);
      unify_list(ts1,ts2);
      return;
    }
    break;

  case $(&TunionFieldType(TunionFieldInfo(&KnownTunionfield(tud2,tuf2),ts2)),
	 &TunionFieldType(TunionFieldInfo(&KnownTunionfield(tud1,tuf1),ts1))):
    if((tud2 == tud1 || qvar_cmp(tud2->name,tud1->name)==0)
       && (tuf2 == tuf1 || qvar_cmp(tuf2->name, tuf1->name)==0)) {
      unify_list(ts1,ts2);
      return;
    }
    break;

  case $(&PointerType(PtrInfo{.elt_typ=t2a,.rgn_typ=rgn2,
                                 .nullable=null2a,.tq=tqual2a,.bounds=b2}),
	 &PointerType(PtrInfo{.elt_typ=t1a,.rgn_typ=rgn1,
                                 .nullable=null1a,.tq=tqual1a,.bounds=b1})):
    unify_it(t1a,t2a);
    unify_it(rgn2,rgn1); // the whole reason regions are "types"
    unify_tqual(tqual1a,tqual2a);
    unify_it_conrefs(boundscmp,b1,b2);
    // There's no need to force the nullable's to be the same when
    // the bounds are ?.
    switch (compress_conref(b1)->v) {
    case &Eq_constr(Unknown_b): return;
    default: break;
    }
    unify_it_conrefs(intcmp,null1a,null2a);
    return;

  case $(&IntType(sn2,sz2), &IntType(sn1,sz1)):
    if ((sn1 == sn2) && (sz1 == sz2)) return;
    break;

  case $(FloatType,  FloatType):  return;
  case $(DoubleType, DoubleType): return;

  case $(&ArrayType(t2a,tq2a,e1), &ArrayType(t1a,tq1a,e2)):
    unify_it(t1a,t2a);
    unify_tqual(tq1a,tq2a);
    if (e1 == e2) return;
    if (e1 == null || e2 == null) break;
    if (Evexp::eval_const_uint_exp((exp_t)e1) == 
        Evexp::eval_const_uint_exp((exp_t)e2))
      return;
    break;

  case $(&FnType(FnInfo{tvs2,eff2,rt2,args2,c_vararg2,cyc_vararg2,atts2}), 
         &FnType(FnInfo{tvs1,eff1,rt1,args1,c_vararg1,cyc_vararg1,atts1})):
    bool done = false;
    region rgn {
    glist_t<$(tvar_t,type_t)@`rgn,`rgn> inst = null;
    while (tvs1 != null) {
      if (tvs2 == null) break;
      inst = rnew(rgn) List(rnew(rgn) $(tvs2->hd,new VarType(tvs1->hd)),inst);
      tvs1 = tvs1->tl;
      tvs2 = tvs2->tl;
    }
    if (tvs2 != null) break;
    if (inst != null) {
      unify_it(new FnType(FnInfo{null,eff1,rt1,args1,c_vararg1,cyc_vararg1,
                                   atts1}),
	       rsubstitute(rgn, inst,
			   new FnType(FnInfo{null,eff2,rt2,args2,c_vararg2,
					       cyc_vararg2,atts2})));
      done = true;
    } 
    }
    if(done) // can do in region once run-time is fixed.
      return;
    unify_it(rt1,rt2);
    for (; args1!=null && args2!=null; args1 = args1->tl, args2 = args2->tl) {
      unify_tqual((*args1->hd)[1],(*args2->hd)[1]);
      unify_it((*args1->hd)[2],(*args2->hd)[2]);
    }
    if ((args1 != null) || (args2 != null)) break;
    if (c_vararg1 != c_vararg2) break;
    // unify any cyclone varargs
    bool bad_cyc_vararg = false;
    switch ($(cyc_vararg1, cyc_vararg2)) {
    case $(null,null): break;
    case $(null,_): fallthru;
    case $(_,null): bad_cyc_vararg = true; break;
    case $(&VarargInfo{n1,tq1,tp1,r1,i1}, &VarargInfo{n2,tq2,tp2,r2,i2}):
      unify_tqual(tq1,tq2);
      unify_it(tp1,tp2);
      unify_it(r1,r2);
      if (i1 != i2) bad_cyc_vararg = true;
      break;
    }
    if (bad_cyc_vararg) break;
    // It's important to unify the effects after the arguments and result
    // so that the effects are pinned down as much as possible.
    bool bad_effect = false;
    switch($(eff1,eff2)) {
    case $(null,null): break;
    case $(null,_): fallthru;
    case $(_,null): bad_effect = true; break;
    default: bad_effect = !unify_effect(eff1->v,eff2->v); break;
    }
    if(bad_effect)
      break;
    if (!same_atts(atts2,atts1)) 
      break;
    return;

  case $(&TupleType(ts2), &TupleType(ts1)):
    for (; ts1 != null && ts2 != null; ts1 = ts1->tl, ts2 = ts2->tl) {
      unify_tqual((*ts1->hd)[0],(*ts2->hd)[0]);
      unify_it((*ts1->hd)[1],(*ts2->hd)[1]);
    }
    if (ts1 == null && ts2 == null) return;
    break;

  case $(&AnonStructType(fs2), &AnonStructType(fs1)): fallthru(fs2,fs1);
  case $(&AnonUnionType(fs2), &AnonUnionType(fs1)): 
    for (; fs1 != null && fs2 != null; fs1 = fs1->tl, fs2 = fs2->tl) {
      let f1 = fs1->hd;
      let f2 = fs2->hd;
      if (String::zstrptrcmp(f1->name,f2->name) != 0) throw Unify;
      unify_tqual(f1->tq, f2->tq);
      unify_it(f1->type, f2->type);
      if (!same_atts(f1->attributes,f2->attributes) ||
          (f1->width != null && f2->width == null) ||
          (f2->width != null && f1->width == null) ||
          (f1->width != null && f2->width != null &&
           Evexp::eval_const_uint_exp(f1->width->v) != 
           Evexp::eval_const_uint_exp(f2->width->v))) throw Unify;
    }
    if (fs1 == null && fs2 == null) return;
    break;
  case $(HeapRgn, HeapRgn): return;
  case $(&RgnHandleType(rt1),&RgnHandleType(rt2)):
    unify_it(rt1,rt2);
    return;
  case $(&JoinEff(_), _)  : fallthru;
  case $(_, &JoinEff(_))  : fallthru;
  case $(&AccessEff(_), _): fallthru;
  case $(_, &AccessEff(_)): 
    if (unify_effect(t1,t2)) return;
    else break;
  default: break;
  }
  throw Unify;
}

bool is_arithmetic_type(type_t t) {
  switch (compress(t)) {
  case &IntType(_,_): return true;
  case FloatType:     return true;
  case DoubleType:    return true;
  case &EnumType(_,_):return true;
  default:            return false;
  }
}

// we're about to convert a value of type t1 to type t2 (both arithmetic types)
// return true if we will potentially lose precision
bool will_lose_precision(type_t t1, type_t t2) {
  t1 = compress(t1);
  t2 = compress(t2);
  switch ($(t1,t2)) {
  case $(DoubleType,     FloatType):       return true;
  case $(DoubleType,     &IntType(_,_)):   return true;
  case $(FloatType,      &IntType(_,_)):   return true;
  case $(&IntType(_,B8), &IntType(_,B8)):  return false;
  case $(&IntType(_,B8), _):               return true; // see prev case
  case $(&IntType(_,B4), FloatType):       return true;
  case $(&IntType(_,B4), &IntType(_,B2)):  return true;
  case $(&IntType(_,B4), &IntType(_,B1)):  return true;
  case $(&IntType(_,B2), &IntType(_,B1)):  return true;
  default: return false;
  }
}

// coerce the list e so that each element has type t -- used in arrays and
// conditionals 
bool coerce_list(tenv_t te, type_t t, glist_t<exp_t,`r> es) {
  // find the biggest arithmetic type (if any) for the list and determine
  // if all of the elements are boxed.
  opt_t<type_t> max_arith_type = null;
  for (glist_t<exp_t,`r> el = es; el != null; el = el->tl) {
    type_t t1 = compress(el->hd->topt->v);
    if (is_arithmetic_type(t1)) 
      if (max_arith_type == null || will_lose_precision(t1,max_arith_type->v))
	max_arith_type = new Opt(t1);
  }
  // unify the max arithmetic type with the result type t
  if (max_arith_type != null)
    if (!unify(t,max_arith_type->v))
      return false;
  // now coerce each expression to the type t as if by assignment
  for (glist_t<exp_t,`r> el = es; el != null; el = el->tl)
    if (!coerce_assign(te,el->hd,t)) {
      terr(el->hd->loc,xprintf("type mismatch: expecting %s but found %s",
			       typ2string(t),typ2string(el->hd->topt->v)));
      return false;
    }
  return true;
}

// coerce e to have type "bool" (int) -- used in conditionals 
bool coerce_to_bool(tenv_t te, exp_t e) {
  if (!coerce_sint_typ(te,e)) {
    switch (compress(e->topt->v)) {
    case &PointerType(_): unchecked_cast(te,e,uint_t); break;
    default: return false;
    }
  }
  return true;
}

bool is_integral_type(type_t t) {
  switch (compress(t)) {
  case &IntType(_,_): return true;
  case &EnumType(_,_): return true;
  default: return false;
  }
}

// coerce e to have type unsigned int -- used in subscript
bool coerce_uint_typ(tenv_t te, exp_t e) {
  if (unify(e->topt->v,uint_t)) 
    return true;
  // try arithmetic conversions -- we only allow integral values
  if (is_integral_type(e->topt->v)) {
    if (will_lose_precision(e->topt->v,uint_t))
      warn(e->loc,"integral size mismatch; conversion supplied");
    unchecked_cast(te,e,uint_t);
    return true;
  }
  return false;
}

// coerce e to have type [signed] int -- used in coercions to "bool"
bool coerce_sint_typ(tenv_t te, exp_t e) {
  if (unify(e->topt->v,sint_t)) 
    return true;
  // try arithmetic conversions -- we only allow integral values
  if (is_integral_type(e->topt->v)) {
    if (will_lose_precision(e->topt->v,sint_t))
      warn(e->loc,"integral size mismatch; conversion supplied");
    unchecked_cast(te,e,sint_t);
    return true;
  }
  return false;
}

// Can t1 be (implicitly) cast to t2? Assumes types are well-formed 
bool silent_castable(tenv_t te, seg_t loc, type_t t1, type_t t2) {
  t1 = compress(t1);
  t2 = compress(t2);
  switch ($(t1,t2)) {
  case $(&PointerType(pinfo_a), &PointerType(pinfo_b)):
    bool okay = true;
    // can coerce @ to *
    if (!unify_conrefs(intcmp,pinfo_a.nullable,pinfo_b.nullable)) {
      switch(compress_conref(pinfo_a.nullable)->v) {
      case &Eq_constr(b): okay = !b; break;
      default: throw impos("silent_castable conref not eq");
      }
    }
    // can coerce *{e} to ? and *{e1} to *{e2} when e2 <= e1
    if (!unify_conrefs(boundscmp,pinfo_a.bounds,pinfo_b.bounds)) {
      switch ($(compress_conref(pinfo_a.bounds)->v, 
		compress_conref(pinfo_b.bounds)->v)) {
      case $(&Eq_constr(&Upper_b(_)),&Eq_constr(Unknown_b)): 
	// Can cast to ? regardless of nullable
	okay = true; break;
	// JGM:  the following would be legal, but perhaps we don't
	// want to allow it to make porting easier -- I'm afraid
	// that writing t *x = y, where y is an array will go through
	// too easily...
	//case $(&Eq_constr(&Upper_b(e1)),&Eq_constr(&Upper_b(e2))):
	//okay = okay && (Evexp::eval_const_uint_exp(e1) >= 
	//		Evexp::eval_const_uint_exp(e2)); 
	//break;
      case $(&Eq_constr(Unknown_b),&Eq_constr(Unknown_b)):
	// Can cast ? to ? regardless of nullable
	okay = true; break;
      default:
	okay = false; break;
      }
    }
    return (okay && unify(pinfo_a.elt_typ,pinfo_b.elt_typ) &&
	    unify(pinfo_a.rgn_typ,pinfo_b.rgn_typ) &&
	    (!pinfo_a.tq.q_const || pinfo_b.tq.q_const));

  case $(&ArrayType(t1a,tq1a,e1),&ArrayType(t2a,tq2a,e2)):
    bool okay;
    // JGM: we could allow e1 >= e2 but I think it's best to give an error
    okay = 
      (e1 != null && e2 != null &&
       Evexp::eval_const_uint_exp((exp_t)e1) ==
       Evexp::eval_const_uint_exp((exp_t)e2));
    return (okay && unify(t1a,t2a) && (!tq1a.q_const || tq2a.q_const));

  // can cast a TunionFieldType to a TunionType if the field doesn't 
  // carry values.
    case $(&TunionFieldType(TunionFieldInfo{&KnownTunionfield(tud1,tuf),ts1}),
	   &TunionType(TunionInfo(&KnownTunion(tud2),ts2,_))):
       if ((tud1 == tud2 || qvar_cmp(tud1->name,tud2->name) == 0) 
	   && tuf->typs == null) {
	 for (; ts1 != null && ts2 != null; ts1=ts1->tl, ts2=ts2->tl)
	   if (!unify(ts1->hd,ts2->hd))
	     break;
	 if (ts1 == null && ts2 == null) 
	   return true;
       }
       return false;

  // can cast a "tunion T.f<ts> @`r1" to a "tunion `r2 T<ts>" when 
  //   field f carries values and r1==r2 or r1=='H
  case $(&PointerType(PtrInfo{t_a,rt_a,null_a,q_a,b_a}),
	 &TunionType(TunionInfo{&KnownTunion(tud2),ts2,r2})):
	   //n2,ts2,r2,_})):
    switch (compress(t_a)) {
    case &TunionFieldType(TunionFieldInfo{&KnownTunionfield(tud1,tuf1),ts1}):
      //n1,ts1,f1,_,tufd}):
      // regions must unify or source must be `H
      if (!unify(rt_a,r2) && rt_a != HeapRgn) return false;
      // pointer must be non-null(@) -- note could allow * but would have
      // to insert a bounds check?
      if (!unify_conrefs(intcmp,null_a,new_conref(false))) return false;
      // pointer must point to one element -- note, could allow > 0
      if (!unify_conrefs(boundscmp,b_a,new_conref(bounds_one)))
        return false;
      // field must carry values and tunion names must align
      if (qvar_cmp(tud2->name,tud1->name)==0 && tuf1->typs != null) {
        // check type arguments
        bool okay = true;
        for (; ts1 != null && ts2 != null; ts1=ts1->tl, ts2=ts2->tl) 
          if (!unify(ts1->hd,ts2->hd)) {
            okay = false; break;
          }
        if (!okay || ts1 != null || ts2 != null) return false;
        return true;
      }
      break;
    default: break;
    }
    return false;

  default: return unify(t1,t2);
  }
}

// coerce e to have type t -- used in function call and explicit fallthru
bool coerce_arg(tenv_t te, exp_t e, type_t t2) {
  type_t t1 = compress(e->topt->v);
  // see if types immediately match
  if (unify(t1,t2)) return true;
  // try arithmetic conversions
  if (is_arithmetic_type(t1) && is_arithmetic_type(t2)) {
    // issue a warning if we lose precision
    if (will_lose_precision(t1,t2))
      warn(e->loc,"integral size mismatch; conversion supplied");
    unchecked_cast(te,e,t2);
    return true;
  } else if (silent_castable(te,e->loc,t1,t2)) {
    unchecked_cast(te,e,t2);
    return true;
  } else if (castable(te,e->loc,t1,t2)) {
    unchecked_cast(te,e,t2);
    warn(e->loc,xprintf("implicit cast from %s to %s",typ2string(t1),
			typ2string(t2)));
    return true;
  } else return false;
}

// coerce e to have type t -- used in assignment operations.  Neither
// gcc nor VC++ issue warnings for losing precision here, but I think
// it may be appropriate.
bool coerce_assign(tenv_t te, exp_t e, type_t t) {
  return coerce_arg(te,e,t);
}

static bool any_promote(tenv_t te, exp_t e) {
  type_t old_typ = compress(e->topt->v);
  type_t t;
  switch (old_typ) {
  case &EnumType(_,_): t = sint_t; break;
  case &IntType(sn,sz):
    switch (sz) {
    case B1: t = sint_t; break; // convert to unboxed, signed int
    case B2: t = sint_t; break; // convert to unboxed, signed int
    case B4: 
      t = (sn == (sign_t)Unsigned) ? uint_t : sint_t; break;   // make unboxed
    case B8: 
      t = (sn == (sign_t)Unsigned) ? ulong_t : slong_t; break; // make unboxed
    }
    break;
  case FloatType:  t = float_t;  break; // make unboxed
  case DoubleType: t = double_t; break; // make unboxed
  default: return false;
  }
  unchecked_cast(te,e,t);
  return true;
}

// Convert e so that it has type t, possibly by casting t.  This is
// used in routines like function call or assignment where we may have
// to promote an integral type.
// FIX: THIS IS NOT RIGHT.
bool coerce_use(tenv_t te, exp_t e, type_t t2) {
  type_t t1 = compress(e->topt->v);
  if (unify(t1,t2)) 
    return true;
  // unification failed, try promoting
  any_promote(te,e);
  if (unify(e->topt->v,t2)) 
    return true;
  else if (silent_castable(te,e->loc,t1,t2)) {
    unchecked_cast(te,e,t2);
    return true;
  } else if (castable(te,e->loc,t1,t2)) {
    unchecked_cast(te,e,t2);
    warn(e->loc,xprintf("implicit cast from %s to %s",typ2string(t1),
		       typ2string(t2)));
    return true;
  } else 
    return false;
}

bool coerceable(type_t t) {
  switch (compress(t)) {
  case &IntType(_,_): return true;
  case FloatType:     return true;
  case DoubleType:    return true;
  default:            return false;
  }
}

// FIX:  all of the subtyping stuff needs to be re-examined in the light
// of packed/aligned attributes.  And we'd need to be careful to do this
// in an architecture-dependent way (based on alignement and so forth.)

// Flatten a type into a list of type qualifiers and types for
// use in subtype comparison.
// FIX:  we should recursively flatten tuple and struct types here,
// but doing so is tricky because we have to get the padding and
// alignment right.  This seems to be particularly weird on the
// x86 -- I need to find precise documentation on it before we do this.
static $(tqual_t,type_t)@ flatten_typ_f(list_t<$(tvar_t,type_t)@> inst,
                                      structfield_t x) {
  return new $(x->tq,substitute(inst,x->type));
}
static list_t<$(tqual_t,type_t)@> flatten_typ(tenv_t te,type_t t1) {
  t1 = compress(t1);
  switch (t1) {
  case VoidType:       return null;
  case &TupleType(tqs): return tqs; // FIX: recursively flatten here
  case &StructType(tdnopt,ts,sdp):
    if (sdp == null || tdnopt == null) 
      return new List(new $(empty_tqual(),t1),null);
    let sd   = *sdp;
    let n    = *tdnopt;
    let inst = List::zip(sd->tvs,ts);
    if (sd->fields == null) return new List(new $(empty_tqual(),t1),null);
    // FIX: recursively flatten here
    return List::map_c(flatten_typ_f,inst,sd->fields->v);
  case &AnonStructType(fs):
    // FIX: recursively flatten here
    return List::map_c(flatten_typ_f,null,fs);
  default: return new List(new $(empty_tqual(),t1),null);
  }
}

// FIX: the plan is, once we have a context that lets us assume t1 <= t2
// for recursive types, then to do deep subtyping.  
// FIX: allow casting one function type to another -- especially, allow
// effects to grow...
static bool ptrsubtype(tenv_t te, list_t<$(type_t,type_t)@> assume, type_t t1, type_t t2);
static bool subtype(tenv_t te, list_t<$(type_t,type_t)@> assume, type_t t1, type_t t2) {
  if (unify(t1,t2)) return true;
  for (_ a = assume; a != null; a = a->tl)
    if (unify(t1,(*a->hd)[0]) && unify(t2,(*a->hd)[1])) 
      return true;
  t1 = compress(t1);
  t2 = compress(t2);
  switch ($(t1,t2)) {
    case $(&PointerType(PtrInfo{t_a, rt_a, null_a, q_a, b_a}),
	   &PointerType(PtrInfo{t_b, rt_b, null_b, q_b, b_b})):
    // if t1 is const then t2 must be const
    if (q_a.q_const && !q_b.q_const) 
      return false;
    // if t1 is * then t2 must be *
    if (!unify_conrefs(intcmp,null_a,null_b) 
	&& conref_val(null_a) && !conref_val(null_b)) 
      return false;
    // if rt_a is not the heap, then rt_b must be the same (can relax this
    // later to a more general "outlives" relationship)
    switch (rt_a) {
    case HeapRgn: break;
    default: unify(rt_a,rt_b); break;
    }
    // need to check that the bounds match up
    if (!unify_conrefs(boundscmp,b_a,b_b)) {
      switch ($(conref_val(b_a),conref_val(b_b))) {
      case $(&Upper_b(_), Unknown_b): break;
      case $(&Upper_b(e1), &Upper_b(e2)): 
	if (Evexp::eval_const_uint_exp(e1) < Evexp::eval_const_uint_exp(e2))
	  return false;
	break;
      default: return false;
      }
    }
    return ptrsubtype(te, new List(new $(t1,t2),assume), t_a, t_b);
  default: return false;
  }
}

// is t1* <= t2*?
//   we flatten t1 and t2 into structurally equivalent tuple types 
//   (and thus ignore field names, associativity of nested tuples and
//   structs, etc.) and then check that t1 is a width extension of t2 
//   and for each field, either (a) both t1 and t2 have qualifier "const"
//   and the t1 field is a subtype of the t2 field, or (b) t1 = t2.
static bool ptrsubtype(tenv_t te, list_t<$(type_t,type_t)@> assume, type_t t1, type_t t2) {
  list_t<$(tqual_t,type_t)@> tqs1 = flatten_typ(te,t1);
  list_t<$(tqual_t,type_t)@> tqs2 = flatten_typ(te,t2);
  for (; tqs2 != null; tqs2 = tqs2->tl, tqs1 = tqs1->tl) {
    if (tqs1 == null) return false;
    let &$(tq1,t1a) = tqs1->hd;
    let &$(tq2,t2a) = tqs2->hd;
    if (tq2.q_const && subtype(te,assume,t1a,t2a)) continue;
    else if (unify(t1a,t2a)) continue;
    else return false;
  }
  return true;
}

// Can t1 be cast to t2?  Assumes that the types are well-formed.
bool castable(tenv_t te, seg_t loc, type_t t1, type_t t2) {
  if(unify(t1,t2))
    return true;
  t1 = compress(t1);
  t2 = compress(t2);
  // we can cast t1 to a union type if t1 matches one of the fields
  // in the union -- note that I'm only allowing equal types here.
  switch (t2) {
  case &UnionType(_,ts,udp):
    if (udp == null) break;
    let ud = *udp;
    if (ud->fields == null) break;
    let inst = List::zip(ud->tvs,ts);
    for (_ fs = ud->fields->v; fs != null; fs = fs->tl) {
      if (unify(t1,substitute(inst,fs->hd->type))) return true;
    }
    break;
  // we can cast t1 to an int if t1 is a boxed type.
  case &IntType(_,B4):
    if (typ_kind(t2) == BoxKind) return true;
    break;
  default: break;
  }
  switch (t1) {
  case &PointerType(PtrInfo{t_a,rt_a,null_a,q_a,b_a}):
    // can cast t* to t@ and vice versa.  
    // can cast a non-const pointer to a const pointer.  
    // can cast a pointer in the heap to a pointer to some other region
    switch (t2) {
    case &PointerType(PtrInfo{t_b,rt_b,null_b,q_b,b_b}):
      let assump = new List(new $(t1,t2),null);
      let ptrsub =
	ptrsubtype(te,assump,t_a,t_b) && (!q_a.q_const || q_b.q_const);
      bool bounds_ok = unify_conrefs(boundscmp,b_a,b_b);
      if (!bounds_ok) {
	switch ($(conref_val(b_a),conref_val(b_b))) {
	  // We allow casts of any form as long as we can't statically
	  // tell that the bounds will be violated.
	case $(&Upper_b(e_a),&Upper_b(e_b)): 
	  if (Evexp::eval_const_uint_exp(e_a) >= 
	      Evexp::eval_const_uint_exp(e_b)) 
	    bounds_ok = true;
	  break;
	default: bounds_ok = true; break;
	}
      }
      return bounds_ok && ptrsub && (rt_a == HeapRgn || unify(rt_a,rt_b));
    default: break;
    }
    return false;
  case &ArrayType(t1a,tq1a,e1):
    switch (t2) {
    case &ArrayType(t2a,tq2a,e2):
      bool okay;
      okay=
        (e1 != null && e2 != null && 
         Evexp::eval_const_uint_exp((exp_t)e1) >= 
         Evexp::eval_const_uint_exp((exp_t)e2));
      return (okay && unify(t1a,t2a) && (!tq1a.q_const || tq2a.q_const));
    default: return false;
    }
    return false;
  // can cast a numeric type or bool to any numeric type
  case &EnumType(_,ed1): 
    // can also cast an enum to a shorter enum
    switch(t2) {
    case &EnumType(_,ed2):
      if(ed1->fields != null && ed2->fields != null
	 && length(ed1->fields->v) >= length(ed2->fields->v))
	return true;
      break;
    default: break;
    }
    fallthru;
  case &IntType(_,_): fallthru;
  case FloatType :  fallthru;
  case DoubleType:  return coerceable(t2);
  default: return false;
  }
}

// Replace e by a cast of e to t.  The caller must ensure that the cast is safe.
void unchecked_cast(tenv_t te, exp_t e, type_t t) {
  if (!unify(e->topt->v,t)) {
    let inner = copy_exp(e);
    e->r    = new Cast_e(t,inner);
    e->topt = new Opt(t);
  }
}

bool is_integral(exp_t e) {
  switch (compress(e->topt->v)) {
  case &EnumType(_,_):  fallthru;
  case &IntType(_,_): return true;
  case &Evar(_,_,_,_):
    if (unify(e->topt->v,sint_t))
      return true;
    return false;
  default: return false;
  }
}

bool is_numeric(exp_t e) {
  if(is_integral(e))
    return true;
  switch (compress(e->topt->v)) {
  case FloatType:  fallthru;
  case DoubleType: return true;
  default:         return false;
  }
}

bool is_function_type(type_t t) {
  switch (compress(t)) {
  case &FnType(_): return true;
  default: return false;
  }
}

type_t max_arithmetic_type(type_t t1, type_t t2) {
  switch ($(t1,t2)) {
  case $(DoubleType,_): fallthru;
  case $(_,DoubleType): return DoubleType;
  case $(FloatType,_):  fallthru;
  case $(_,FloatType):  return FloatType;
  case $(&IntType(Unsigned,B8),_): fallthru;
  case $(_,&IntType(Unsigned,B8)): return ulong_t;
  case $(&IntType(Signed,B8),_):   fallthru;
  case $(_,&IntType(Signed,B8)):   return slong_t;
  case $(&IntType(Unsigned,B4),_): fallthru;
  case $(_,&IntType(Unsigned,B4)): return uint_t;
  default: return sint_t;
  }
}

// used to warn when a while, for, if, or do test contains an assignment
void check_contains_assign(exp_t e) {
  switch (e->r) {
  case &AssignOp_e(_,null,_): warn(e->loc,"assignment in test"); break;
  default: break;
  }
}

// Given two kind constraint refs, merge them so that they will
// point to the most constrained kind.  
static bool constrain_kinds(conref_t<kind_t> c1, conref_t<kind_t> c2) {
  c1 = compress_conref(c1);
  c2 = compress_conref(c2);
  if (c1 == c2) return true;
  if (c1->v == No_constr) {
    c1->v = new Forward_constr(c2); return true;
  } else if (c2->v == No_constr) {
    c2->v = new Forward_constr(c1); return true;
  } else {
    kind_t k1 = conref_val(c1);
    kind_t k2 = conref_val(c2);
    if (kind_leq(k1,k2)) {
      c2->v = new Forward_constr(c1); return true;
    } else if (kind_leq(k2,k1)) {
      c1->v = new Forward_constr(c2); return true;
    } else return false;
  }
}


static int tvar_id_counter = 0;
int *new_tvar_id() {
  return new (tvar_id_counter++);
}

static int tvar_counter = 0;
tvar_t new_tvar(kind_t k) {
  int i = tvar_counter++;
  string s = xprintf("#%d",i);
  return new Tvar(new{s},null,new_conref(k));
}

bool is_temp_tvar(tvar_t t) {
  let s = *(t->name);
  return (s[0]=='#');
}

void rewrite_temp_tvar(tvar_t t) { // change t->name from "#xxx" to "`txxx"
  if (! is_temp_tvar(t)) return;
  let s = String::strconcat("`", *(t -> name));
  s[1] = 't';
  t -> name = new{s};
}

static $(opt_t<var_t>,tqual_t,type_t)@ 
  fndecl2typ_f($(var_t,tqual_t,type_t)@ x) {
  return new $((opt_t<var_t>)(new Opt((*x)[0])), (*x)[1], (*x)[2]);
}

type_t fndecl2typ(fndecl_t fd) {
  if (fd->cached_typ == null) {
    // We don't cache this type as we want to expand out the effect
    // and so forth...  The caching happens after we check that the
    // function declaration is valid (see below).
    // First, separate the function type attributes from the rest
    // of the attributes and update the function declaration appropriately.
    let fn_type_atts = null;
    for (_ atts = fd->attributes; atts != null; atts = atts->tl) {
      if (fntype_att(atts->hd)) {
        fn_type_atts = new List(atts->hd,fn_type_atts); 
      } 
    }
    return new FnType(FnInfo{fd->tvs, fd->effect, fd->ret_type,
                               List::map(fndecl2typ_f, fd->args),
                               fd->c_varargs, fd->cyc_varargs, fn_type_atts});
  };
  return (fd->cached_typ->v);
}

static `a fst_fdarg($(`a,tqual_t,`c)@`r t)    { return (*t)[0]; }
type_t snd_tqt($(tqual_t,type_t)@`r t) { return (*t)[1]; }
static $(tqual_t,type_t)@ map2_tq($(tqual_t,type_t)@`r1 pr, type_t t) {
  return new $((*pr)[0],t);
}
// Check that the function declaration has a valid type:  all
// we do is build a FnType and then check that it is well-formed
// which has the side effect of giving us the effect and any
// bound type variables.
void check_fndecl_valid_type(seg_t loc,tenv_t te,fndecl_t fd) {
  type_t t = fndecl2typ(fd);
  // this fills in the missing bound type variables and effects
  check_valid_toplevel_type(loc,te,t);
  switch (compress(t)) {
  case &FnType(FnInfo{tvs,effect,rt,args,c_varargs,cyc_varargs,atts}):
    fd->tvs = tvs;
    fd->effect = effect;
    break;
  default: impos("check_fndecl_valid_type: not a FnType"); return;
  };
  // check for repeated paramater names (not allowed in C and makes no sense)
  region r {
    check_unique_vars(rmap(r,fst_fdarg,fd->args), loc, 
		      "function declaration has repeated parameter");
  }
  // cache the type on the declaration so we don't have to recompute it
  fd->cached_typ = new Opt(t);
}

static $($(opt_t<var_t>,tqual_t)@`r,type_t)@`r
substitute_f1(region_t<`r> rgn, $(opt_t<var_t>,tqual_t,type_t) @`r2 y) {
  return rnew(rgn) $(rnew(rgn) $((*y)[0],(*y)[1]),(*y)[2]);
}
static $(opt_t<var_t>,tqual_t,type_t)@ 
substitute_f2($($(opt_t<var_t>,tqual_t)@`r2,type_t)@`r1 w) {
  let $(p,t) = *w;
  let $(vopt,tq) = *p;
  return new $(vopt,tq,t);
}
static type_t field_type(structfield_t f) {
  return f->type;
}
static structfield_t zip_field_type(structfield_t f, type_t t) {
  return new Structfield {.name = f->name, .tq = f->tq, .type = t,
                             .width = f->width, .attributes = f->attributes};
}

static glist_t<type_t,`r2> substs(region_t<`r> rgn,
				  glist_t<$(tvar_t,type_t)@`r,`r> inst, 
				  glist_t<type_t,`r2> ts);

type_t rsubstitute(region_t<`r> rgn, 
		   glist_t<$(tvar_t,type_t)@`r,`r> inst, 
		   type_t t) {
  switch (compress(t)) {
  case &VarType(v):
    // a tvar lookup, not a var lookup!
    try return List::assoc_cmp(tvar_cmp,inst,v);
    catch {case Not_found: return t;}
  case &StructType(no,ts,sd):   
    let new_ts = substs(rgn,inst,ts);
    return new_ts == ts ? t : new StructType(no,new_ts,sd);
  case &UnionType(no,ts,ud):
    let new_ts = substs(rgn,inst, ts);
    return new_ts == ts ? t : new UnionType(no,new_ts,ud);
  case &TunionType(TunionInfo{info,ts,r}):     
    let new_ts = substs(rgn,inst,ts);
    let new_r  = rsubstitute(rgn,inst,r);
    return (new_ts == ts && new_r == r) ? t : 
      new TunionType(TunionInfo{info,new_ts,new_r});
  case &TunionFieldType(TunionFieldInfo{info,ts}):
    let new_ts = substs(rgn,inst,ts);
    return (new_ts == ts) ? t : 
      new TunionFieldType(TunionFieldInfo{info,new_ts});
  case &TypedefType(n,ts,topt): 
    let new_ts = substs(rgn,inst,ts);
    return new_ts == ts ? t : new TypedefType(n,new_ts,topt);
  case &ArrayType(t1,tq,e):     
    let new_t1 = rsubstitute(rgn,inst,t1);
    return new_t1 == t1 ? t : new ArrayType(new_t1,tq,e);
  case &PointerType(PtrInfo{t1,r,n,tq,b}): 
    let new_t1 = rsubstitute(rgn,inst,t1);
    let new_r  = rsubstitute(rgn,inst,r);
    if(new_t1 == t1 && new_r == r)
      return t;
    return new PointerType(PtrInfo(new_t1,new_r,n,tq,b));
  case &FnType(FnInfo{vs,eff,rtyp,args,c_varargs,cyc_varargs,atts}):
    for (let p = vs; p != null; p = p->tl)
      inst = rnew(rgn) List(rnew(rgn) $(p->hd,new VarType(p->hd)),inst);
    let $(qs,ts) = List::rsplit(rgn,rgn, 
				List::rmap_c(rgn,substitute_f1,rgn,args));
    let ts2      = substs(rgn,inst,ts);
    let args2    = List::map(substitute_f2, List::rzip(rgn,rgn,qs,ts2));
    opt_t<type_t> eff2;
    if(eff == null)
      eff2 = null;
    else {
      let new_eff = rsubstitute(rgn,inst,eff->v);
      if(new_eff == eff->v)
	eff2 = eff;
      else
	eff2 = new Opt(new_eff);
    }
    vararg_info_t *cyc_varargs2;
    if (cyc_varargs == null) 
      cyc_varargs2 = null;
    else {
      let VarargInfo{n,tq,t,r,i} = *cyc_varargs;
      let t2 = rsubstitute(rgn,inst,t);
      let r2 = rsubstitute(rgn,inst,r);
      if (t2 == t && r == r2) cyc_varargs2 = cyc_varargs;
      else 
        cyc_varargs2 = new VarargInfo{n,tq,t2,r2,i};
    }
    return 
      new FnType(FnInfo{vs,eff2,rsubstitute(rgn,inst,rtyp),args2,c_varargs,
                          cyc_varargs2,atts});
  case &TupleType(tqts):
    let ts  = List::rmap(rgn,snd_tqt,tqts);
    let ts2 = substs(rgn,inst,ts);
    if(ts2 == ts)
      return t;
    let tqts2 = List::map2(map2_tq,tqts,ts2);
    return new TupleType(tqts2);
  case &AnonStructType(fs):
    let ts = List::rmap(rgn,field_type,fs);
    let ts2 = substs(rgn,inst,ts);
    if (ts2 == ts)
      return t;
    let fs2 = List::map2(zip_field_type,fs,ts2);
    return new AnonStructType(fs2);
  case &AnonUnionType(fs):
    let ts = List::rmap(rgn,field_type,fs);
    let ts2 = substs(rgn,inst,ts);
    if (ts2 == ts)
      return t;
    let fs2 = List::map2(zip_field_type,fs,ts2);
    return new AnonStructType(fs2);
  case &Evar(_,r,_,_):
    if (r != null) return rsubstitute(rgn,inst,r->v);
    else return t;
  case &RgnHandleType(rt): 
    let new_rt = rsubstitute(rgn,inst,rt);
    return new_rt == rt ? t : new RgnHandleType(new_rt);
  case &EnumType(_,_): return t;
  case VoidType:       return t;
  case &IntType(_,_):  return t;
  case FloatType:      return t;
  case DoubleType:     return t;
  case HeapRgn:        return t;
  case &AccessEff(r): 
    let new_r = rsubstitute(rgn,inst,r);
    return new_r == r ? t : new AccessEff(new_r);
  case &JoinEff(es):  
    let new_es = substs(rgn,inst,es);
    return new_es == es ? t : new JoinEff(new_es);
  }
}
// This is just a map beefed up to avoid unnecessary allocation.
static glist_t<type_t,`r2> substs(region_t<`r> rgn,
				  glist_t<$(tvar_t,type_t)@`r,`r> inst, 
				  glist_t<type_t,`r2> ts) {
  if(ts == null)
    return null;
  let old_hd = ts->hd;
  let old_tl = ts->tl;
  let new_hd = rsubstitute(rgn, inst, old_hd);
  let new_tl = substs(rgn, inst, old_tl);
  if(old_hd == new_hd && old_tl == new_tl)
    return ts;
  return (glist_t<type_t,`r2>)(new List(new_hd,new_tl));
}

extern type_t substitute(list_t<$(tvar_t,type_t)@> inst, type_t t) {
  return rsubstitute(heap_region, inst, t);
}

exp_t default_initializer(tenv_t te, type_t t, seg_t loc) {
  exp_t e = new_exp(new Const_e(Null_c),loc);

  switch (compress(t)) {
  case &PointerType(_): break; // FIX: non-nullable is an error!
  case &IntType(sg,B1):
    e->r = new Const_e(new Char_c(Signed,'\000'));
    break;
  case &IntType(sg,sz):
    e->r = new Const_e(new Int_c(sg,0));
    if (sz != (size_of_t)B4)
      e = new_exp(new Cast_e(t,e),loc);
    break;
  case FloatType:
    e->r = new Const_e(new Float_c("0.0"));
    break;
  case DoubleType:
    e->r = new Cast_e(t,new_exp(new Const_e(new Float_c("0.0")), loc));
    break;
  default:
    terr(loc, xprintf("declaration of type %s requires initializer",
		      typ2string(t)));
    break;
  }
  return e;
}

// Generate an appropriate evar for an instantiation of a type var
$(tvar_t,type_t)@ make_inst_var(list_t<tvar_t> s, tvar_t tv) {
  kind_t k = conref_val(tv->kind);
  return new $(tv, new_evar(new Opt(k),new Opt(s)));
}

$(tvar_t,type_t)@`r r_make_inst_var($(list_t<tvar_t>,region_t<`r>)@`r2 env,
                                    tvar_t tv) {
  let &$(s,rgn) = env;
  kind_t k = conref_val(tv->kind);
  return rnew(rgn) $(tv, new_evar(new Opt(k),new Opt(s)));
}

// Adds tv to the list of tvars unless it's already present.  If it's
// already present, makes sure the kinds are compatible by choosing the
// most constrained kind as the kind of the variable, and in fact
// physically share the kinds so that further constraints on it are
// propagated.  Also ensures that the tvars share the same identity.
static list_t<tvar_t> add_free_tvar(seg_t loc, list_t<tvar_t> tvs, 
                                    tvar_t tv)
{
  for (_ tvs2 = tvs; tvs2 != null; tvs2 = tvs2->tl) {
    if (String::zstrptrcmp(tvs2->hd->name, tv->name) == 0) {
      conref_t<kind_t> k1 = tvs2->hd->kind;
      conref_t<kind_t> k2 = tv->kind;
      if (!constrain_kinds(k1,k2))
        terr(loc,xprintf("type variable %s is used with inconsistent "
                         "kinds %s and %s",*tv->name, 
                         ckind2string(k1), ckind2string(k2)));
      if (tv->identity == null)
        tv->identity = tvs2->hd->identity;
      else if (*tv->identity != *tvs2->hd->identity)
        impos(xprintf("same type variable has different identity!"));
      return tvs;
    }
  }
  tv->identity = new_tvar_id();
  return new List(tv,tvs);
}

// This assumes the identities and kinds are set, and simply adds
// the tvar if it's not already present.
static list_t<tvar_t> fast_add_free_tvar(list_t<tvar_t> tvs, tvar_t tv)
{
  // sanity
  if (tv->identity == null)
      impos("fast_add_free_tvar: bad identity in tv");
  for (_ tvs2 = tvs; tvs2 != null; tvs2 = tvs2->tl) {
    // sanity
    if (tvs2->hd->identity == null)
      impos("fast_add_free_tvar: bad identity in tvs2");
    if (*tvs2->hd->identity == *tv->identity) {
      return tvs;
    } 
  }
  return new List{tv,tvs};
}

// will shadow other variables
static list_t<tvar_t> add_bound_tvar(list_t<tvar_t> tvs, tvar_t tv) {
  // sanity
  if (tv->identity == null) impos(xprintf("bound tvar id for %s is null",
                                          tvar2string(tv)));
  return new List(tv,tvs);
}

// assumes es is a list of evars, and e is an evar.  Adds in e only
// if not already present.
static list_t<type_t> add_free_evar(list_t<type_t> es, type_t e) {
  switch (compress(e)) {
  case &Evar(_,_,i,_):
    for (_ es2 = es; es2 != null; es2 = es2->tl) {
      switch (compress(es2->hd)) {
      case &Evar(_,_,j,_): if (i == j) return es; break;
      default: break;
      }
    }
    return new List(e,es);
  default: return es;
  }
}  

static list_t<tvar_t> remove_bound_tvars(list_t<tvar_t> tvs, list_t<tvar_t> btvs) {
  list_t<tvar_t> r = null;
  for (; tvs != null; tvs = tvs->tl) {
    bool present = false;
    for (_ b = btvs; b != null; b = b->tl) {
      if (*tvs->hd->identity == *b->hd->identity) {
        present = true;
        break;
      }
    }
    if (!present) r = new List(tvs->hd,r);
  }
  r = List::imp_rev(r);
  return r;
}

// Check-Valid-Type environments
static struct CVTEnv { 
  list_t<tvar_t> kind_env;  
  list_t<tvar_t> free_vars; 
  list_t<type_t> free_evars;
};
typedef struct CVTEnv cvtenv_t;

// Checks that a type is well-formed and lives in kind expected_kind.  
// Takes as input a location (for error reporting), a type environment 
// (for looking up struct, enum, tunion, etc. decls), a check-valid-type
// environment (explained below), an expected kind, and the type itself t.
// It returns a check-valid-type-env as a result.
//
// In addition to checking that the type is valid, the routine needs
// to compute the set of free type variables and free evars in the
// type, and to constrain their kinds appropriately.  Normally, this
// would be coded by passing a kind_env down, and returning free_vars
// and free_evars as a result.  However, to cut down on allocation,
// we pass in the free variables of surrounding types and just add
// any new free variables to the result.  This way, we can calculate
// all of the free variables for a term in a store-passing style.
// The only situation where this breaks down is where we have binders
// as is the case for function types (see below).
//
// This also performs the following side-effects which most of the 
// rest of the compiler rightfully assumes have occurred:
// * expand typedefs
// * set pointers (or Known* variants) to declarations for 
//   StructType, UnionType, TunionType, TunionFieldType
// * change relative type names to absolute type names
// * set the kind field of type variables: we use the expected kind
//   initially, but if later constraints force a more constrained kind,
//   then we move to the more constrained kind.  This is why we propagate
//   around the set of 
// * add default effects for function types -- the default effect
//   causes a fresh EffKind type variable e to be generated, and
//   consists of e and any free effect or region variables/evars within
//   the function type.  
static cvtenv_t i_check_valid_type(seg_t loc, tenv_t te, cvtenv_t cvtenv, 
                                   kind_t expected_kind, type_t t) {
  switch (compress(t)) {
  case VoidType: break;
  case &Evar(*k,_,_,_): 
    if (*k == null) *k = new Opt(expected_kind);
    // FIX: we should really only add the tvar if it's unique
    cvtenv.free_evars = add_free_evar(cvtenv.free_evars,t);
    break;
  case &VarType(v):
    conref_t<kind_t> c = compress_conref(v->kind);
    if (c->v == No_constr)
      c->v = new Eq_constr(expected_kind);
    // this constrains the kind of the variable according to other
    // occurrences of that variable and makes sure they share the same
    // tvar identity.
    cvtenv.kind_env = add_free_tvar(loc, cvtenv.kind_env, v);
    // no need to constrain things here, but want to add it only if
    // it hasn't already been added.
    cvtenv.free_vars = fast_add_free_tvar(cvtenv.free_vars, v);
    break;
  case &EnumType(n,*edp):
    if (*edp == null)
      try {
        enumdecl_t @ed = lookup_enumdecl(te,loc,n);
        *edp = *ed;
      } catch {
      case Dict::Absent:
        terr(loc,xprintf("unbound type enum %s",qvar2string(n)));
        return cvtenv;
      }
    enumdecl_t ed = (enumdecl_t)*edp;
    // Make relative name absolute
    *n = (ed->name)[0];
    break;
  case &TunionType(TunionInfo(*info,targs,rgn)):
    switch(*info) {
    case &UnknownTunion(UnknownTunionInfo(n,is_x)):
      tuniondecl_t tud;
      try tud = *lookup_tuniondecl(te,loc,n);// FIX: lookup_xtuniondecl needed?
      catch { 
      case Dict::Absent:
        terr(loc,xprintf("unbound type [x]tunion %s",qvar2string(n)));
        return cvtenv;
      }
      if(tud->is_xtunion != is_x)
	terr(loc,xprintf("[x]tunion is different from type declaration %s",
			 qvar2string(n)));
      *info = new KnownTunion(tud);
      fallthru(tud);
    case &KnownTunion(tud):
      // check the region is well-formed
      cvtenv = i_check_valid_type(loc,te,cvtenv,RgnKind,rgn);
      // check the type arguments are well-formed
      list_t<tvar_t> tvs = tud->tvs;
      for (; targs != null && tvs != null; targs = targs->tl, tvs = tvs->tl) {
	type_t t1 = targs->hd;
	kind_t k1 = conref_val(tvs->hd->kind);
	cvtenv = i_check_valid_type(loc,te,cvtenv,k1,t1);
      }
      if (targs != null)
	terr(loc,xprintf("too many type arguments for tunion %s",
			 qvar2string(tud->name)));
      if (tvs != null) 
	terr(loc,xprintf("too few type arguments for tunion %s",
			 qvar2string(tud->name)));
      break;
    }
    break;

  case &TunionFieldType(TunionFieldInfo{*info,targs}):
    switch(*info) {
    case &UnknownTunionfield(UnknownTunionFieldInfo(tname,fname,is_x)):
      tuniondecl_t  tud;
      tunionfield_t tuf;
      try *lookup_tuniondecl(te,loc,tname);//FIX lookup_xtuniondecl needed?
      catch { case Dict::Absent:
        terr(loc,xprintf("unbound type tunion %s",qvar2string(tname)));
      return cvtenv;
      }
      try 
	switch(lookup_ordinary(te,loc,fname)) {
	case &TunionRes(tud2,tuf2):
	  tuf = tuf2;
	  /* Mathieu: this check is not valid any more
	  if(tud2 != tud) != 0) {
	    terr(loc,xprintf("unbound field %s in type tunion %s",
                             qvar2string(fname), qvar2string(tname)));
            return cvtenv;
          }
	  */
	  tud = tud2;
	  if(tud->is_xtunion != is_x)
	    terr(loc,xprintf("[x]tunion is different from type declaration %s",
			     qvar2string(tname)));
	  break;
	default: terr(loc,xprintf("unbound field %s in type tunion %s",
				  qvar2string(fname), qvar2string(tname)));
          return cvtenv;
        }
      catch {
      case Dict::Absent:
        terr(loc,xprintf("unbound field %s in type tunion %s",
                         qvar2string(fname), qvar2string(tname)));
        return cvtenv;
      }  
      *info = new KnownTunionfield(tud,tuf);
      fallthru(tud,tuf);
    case &KnownTunionfield(tud,tuf):
      // check the type arguments are well-formed
      list_t<tvar_t> tvs = tud->tvs;
      for (; targs != null && tvs != null; targs = targs->tl, tvs = tvs->tl) {
	type_t t1 = targs->hd;
	kind_t k1 = conref_val(tvs->hd->kind);
	cvtenv = i_check_valid_type(loc,te,cvtenv,k1,t1);
      }
      if (targs != null)
	terr(loc,xprintf("too many type arguments for tunion %s.%s",
			 qvar2string(tud->name),qvar2string(tuf->name)));
      if (tvs != null) 
	terr(loc,xprintf("too few type arguments for tunion %s.%s",
			 qvar2string(tud->name),qvar2string(tuf->name)));
      break;
    }
    break;
  case &PointerType(PtrInfo{.elt_typ=t1,.rgn_typ=rgn_typ,.
                               nullable=nullable,.tq=tq,.bounds=b}):
    // FIX: check that tqual is valid?
    // note that here, we allow AnyKind types under the pointer
    cvtenv = i_check_valid_type(loc,te,cvtenv,AnyKind,t1);
    cvtenv = i_check_valid_type(loc,te,cvtenv,RgnKind,rgn_typ);
    // check that any bound is a constant expression
    switch (compress_conref(b)->v) {
    case &Eq_constr(&Upper_b(e)): 
      if (!is_const_exp(te,e)) 
        terr(loc,"pointer bounds expression is not a constant");
      Tcexp::tcExp(te,null,e);
      if (!coerce_uint_typ(te,e))
        terr(loc,"pointer bounds expression is not an unsigned int");
      Evexp::eval_const_uint_exp(e); 
      break;
    default: break;
    }
    break;
  case &IntType(_,_): break; 
  case FloatType:    break; 
  case DoubleType:   break; 
  case &ArrayType(t1,tq,e):
    // FIX: check that tqual is valid?
    // we don't allow abstract mem types as the elt type of an array type
    cvtenv = i_check_valid_type(loc,te,cvtenv,MemKind,t1);
    // FIX: should memoize the size so that we don't have to worry about
    // evaluating it during unification
    if (e == null || !is_const_exp(te,(exp_t)e))
      terr(loc,"array bounds expression is not constant");
    Tcexp::tcExp(te,null,(exp_t)e);
    if (!coerce_uint_typ(te,(exp_t)e))
      terr(loc,"array bounds expression is not an unsigned int");
    Evexp::eval_const_uint_exp((exp_t)e); // check that e is of constant size
    break;
  case &FnType(FnInfo{*btvs,*eff,tr,args,c_vararg,cyc_vararg,atts}):
    // check that the attributes are function type attributes
    // and that at most one of {stdcall, cdecl, fastcall} is there.
    int  num_convs = 0;
    bool seen_cdecl    = false;
    bool seen_stdcall  = false;
    bool seen_fastcall = false;
    for (; atts != null; atts = atts->tl) {
      if (!fntype_att(atts->hd))
	terr(loc,xprintf("bad function type attribute %s",
			 attribute2string(atts->hd)));
      switch(atts->hd) {
      case Stdcall_att: 
	if(!seen_stdcall)  { seen_stdcall=true;  ++num_convs;} break;
      case Cdecl_att: 
	if(!seen_cdecl)    { seen_cdecl=true;    ++num_convs;} break;
      case Fastcall_att: 
	if(!seen_fastcall) { seen_fastcall=true; ++num_convs;} break;
      default: break;
      }
    }
    if(num_convs > 1)
      terr(loc,xprintf("function can't have multiple calling conventions"));

    check_unique_tvars(loc,*btvs);
    // check that the function doesn't try to abstract a MemKind 
    // and add the bound variable in to the kind_env of cvtenv
    for (_ b = *btvs; b != null; b = b->tl) {
      b->hd->identity = new_tvar_id();
      cvtenv.kind_env = add_bound_tvar(cvtenv.kind_env,b->hd);
      switch (compress_conref(b->hd->kind)->v) {
      case &Eq_constr(MemKind): 
        terr(loc,xprintf("function attempts to abstract Mem type variable %s",
                         *b->hd->name)); break;
      default: break;
      }
    }
    let new_cvtenv = CVTEnv{cvtenv.kind_env, null, null};

    // results and arguments of functions cannot be abstract mem types
    new_cvtenv = i_check_valid_type(loc,te,new_cvtenv,MemKind,tr);
    for (; args != null; args = args->tl) {
      // FIX: should check that variables are unique and that tquals are ok
      new_cvtenv = i_check_valid_type(loc,te,new_cvtenv,MemKind,
                                      (*args->hd)[2]);
    }
    // check the varargs
    if (cyc_vararg != null) {
      if (c_vararg) impos("both c_vararg and cyc_vararg"); // sanity
      let VarargInfo{vn,vtq,vt,vr,vi} = *cyc_vararg;
      new_cvtenv = i_check_valid_type(loc,te,new_cvtenv,MemKind,vt);
      // if vr is an evar, constrain it to a gensym'd type variable, 
      // and complain if vr isn't a type variable (i.e., it's HeapRgn)
      switch (compress(vr)) {
      case &Evar(_,_,_,_): 
        type_t vr_tvar = new VarType(new_tvar(RgnKind));
        unify(vr,vr_tvar);
        break;
      case &VarType(_): break;
      case HeapRgn:
        terr(loc,"varargs should be in a region, not heap-allocated");
        break;
      default: break; // next line will pick up the error
      }
      new_cvtenv = i_check_valid_type(loc,te,new_cvtenv,RgnKind,vr);
      // if inject, then check the type is an appropriate [x]tunion
      if (vi) {
        switch (compress(vt)) {
        case &TunionType(TunionInfo{&KnownTunion(_),_,tuir}): 
          // if tuir is an evar, constrain it to a vr
          // and complain if tuir is HeapRgn.
          switch (compress(tuir)) {
          case &Evar(_,_,_,_): 
            unify(vr,tuir);
            break;
          case &VarType(_): break;
          case HeapRgn:
            terr(loc,"injected vararg [x]tunion should be in a region, not heap-allocated");
            break;
          default: break; // can't happen
          }
          break;
        default:
          terr(loc,"can't inject a non-[x]tunion type");
          break;
        }
      }
    }
    if (*eff != null) {
      new_cvtenv = i_check_valid_type(loc,te,new_cvtenv,EffKind,(*eff)->v);
    } else {
      // add in an effect variable and calculate the default effect
      tvar_t e = new_tvar(EffKind); // guaranteed unique
      // this will also give e a unique identity
      new_cvtenv.free_vars = add_free_tvar(loc,new_cvtenv.free_vars,e);
      // here, keep e at the rear of the effect -- we get reversed later on
      list_t<type_t> effect = null;
      // Add in any free region or effect variables to the effect.
      // This is why we need a "new_cvtenv" above -- we only want the
      // type variables that actually occur in the function type 
      // as opposed to elsewhere.
      for (_ tvs = new_cvtenv.free_vars; tvs != null; tvs = tvs->tl) {
        switch (compress_conref(tvs->hd->kind)->v) {
        case &Eq_constr(RgnKind):
          effect = new List(new AccessEff(new VarType(tvs->hd)),effect); 
          break;
        case &Eq_constr(EffKind):
          effect = new List(new VarType(tvs->hd),effect); break;
        default: break;
        }
      }
      // Better add in any evars too:
      for (_ ts = new_cvtenv.free_evars; ts != null; ts = ts->tl) {
        switch (typ_kind(ts->hd)) {
        case RgnKind: 
          effect = new List(new AccessEff(ts->hd),effect); break;
        case EffKind: effect = new List(ts->hd,effect); break;
        default: break;
        }
      }
      *eff = new Opt(new JoinEff(List::imp_rev(effect)));
    }
    // Warn if afterwards any kind is still unconstrained and set it to 
    // BoxKind. In addition, drive any MemKind type variables to BoxKind 
    // to ensure that we don't abstract a MemKind variable.
    if (*btvs != null) {
      for(list_t<tvar_t> bs = *btvs; bs != null; bs = bs->tl) {
        let c = compress_conref(bs->hd->kind);
        switch (c->v) {
        case No_constr:
          warn(loc,xprintf("Type variable %s unconstrained, assuming boxed",
                           *bs->hd->name));
          fallthru;
        case &Eq_constr(MemKind):
          c->v = new Eq_constr(BoxKind); break;
        default: break;
        }
      }
    }
    // remove the bound vars from the kind environment
    cvtenv.kind_env = remove_bound_tvars(new_cvtenv.kind_env,*btvs);
    // remove the bound vars from the list of free vars
    new_cvtenv.free_vars = 
      remove_bound_tvars(new_cvtenv.free_vars,*btvs);
    // add the free vars in to the set of all free vars
    for (_ tvs = new_cvtenv.free_vars; tvs != null; tvs = tvs->tl)
      cvtenv.free_vars = fast_add_free_tvar(cvtenv.free_vars,tvs->hd);
    // add the free evars in to the set of all free evars
    for (_ evs = new_cvtenv.free_evars; evs != null; evs = evs->tl)
      cvtenv.free_evars = add_free_evar(cvtenv.free_evars,evs->hd);
    break;

  case &TupleType(tq_ts):
    // FIX: check the tquals
    for (; tq_ts != null; tq_ts = tq_ts->tl)
      cvtenv = i_check_valid_type(loc,te,cvtenv,MemKind,(*tq_ts->hd)[1]);
    break;

  case &AnonStructType(fs):
    // FIX: this code is mostly duplicated in Tc::tcStructdecl
    region sprev_rgn {
      glist_t<field_name_t,`sprev_rgn> prev_fields = null;
      for (; fs != null; fs = fs->tl) {
        let &Structfield{fn,tq,t,width,atts} = fs->hd;
        if (List::mem(String::zstrptrcmp,prev_fields,fn))
          terr(loc,xprintf("duplicate field %s in struct",*fn));
        if (String::strcmp(*fn,"") != 0)
          prev_fields = rnew(sprev_rgn) List(fn,prev_fields);
        cvtenv = i_check_valid_type(loc,te,cvtenv,MemKind,t);
        if (width != null) {
          unsigned int w = 0;
          if (!is_const_exp(te,width->v))
            terr(loc,xprintf("bitfield %s does not have constant width",*fn));
          else w = Evexp::eval_const_uint_exp(width->v);
          switch (compress(t)) {
          case &IntType(_,b):
            switch (b) {
            case B1: if (w > 8)  terr(loc,"bitfield larger than type"); break;
            case B2: if (w > 16) terr(loc,"bitfield larger than type"); break;
            case B4: if (w > 32) terr(loc,"bitfield larger than type"); break;
            case B8: if (w > 64) terr(loc,"bitfield larger than type"); break;
            }
            break;
          default:
            terr(loc,xprintf("bitfield %s must have integral type but has "
                             "type %s",*fn,typ2string(t)));
            break;
          }
        }
        for (; atts != null; atts = atts->tl) {
          switch (atts->hd) {
          case Packed_att: continue;
          case &Aligned_att(_): continue;
          default: terr(loc,xprintf("bad attribute %s on struct member %s",
                                    attribute2string(atts->hd), *fn));
          break;
          }
        }
      }      
    }
    break;

  case &AnonUnionType(fs):
    // FIX: this code is mostly duplicated in Tc::tcUniondecl and above
    region uprev_rgn {
      glist_t<field_name_t,`uprev_rgn> prev_fields = null;
      for (; fs != null; fs = fs->tl) {
        let &Structfield{fn,tq,t,width,atts} = fs->hd;
        if (List::mem(String::zstrptrcmp,prev_fields,fn))
          terr(loc,xprintf("duplicate field %s in struct",*fn));
        if (String::strcmp(*fn,"") != 0)
          prev_fields = rnew(uprev_rgn) List(fn,prev_fields);
        cvtenv = i_check_valid_type(loc,te,cvtenv,MemKind,t);
        if (!bits_only(t)) 
          terr(loc,xprintf("%s has a type that is possibly incompatible "
                           "with other members of union",*fn));
        if (width != null) {
          unsigned int w = 0;
          if (!is_const_exp(te,width->v))
            terr(loc,xprintf("bitfield %s does not have constant width",*fn));
          else w = Evexp::eval_const_uint_exp(width->v);
          switch (compress(t)) {
          case &IntType(_,b):
            switch (b) {
            case B1: if (w > 8)  terr(loc,"bitfield larger than type"); break;
            case B2: if (w > 16) terr(loc,"bitfield larger than type"); break;
            case B4: if (w > 32) terr(loc,"bitfield larger than type"); break;
            case B8: if (w > 64) terr(loc,"bitfield larger than type"); break;
            }
            break;
          default:
            terr(loc,xprintf("bitfield %s must have integral type but has "
                             "type %s",*fn,typ2string(t)));
            break;
          }
        }
        for (; atts != null; atts = atts->tl) {
          switch (atts->hd) {
          case Packed_att: continue;
          case &Aligned_att(_): continue;
          default: terr(loc,xprintf("bad attribute %s on struct member %s",
                                    attribute2string(atts->hd), *fn));
          break;
          }
        }
      }      
    }
    break;

  case &StructType(tdnopt,targs,*sdp):
    if (tdnopt == null) {
      // better be an anonymous struct
      if (*sdp == null) {
        terr(loc,xprintf("bad anonymous struct")); 
        return cvtenv;
      }
      structdecl_t sd = **sdp;
    }
    if(*sdp == null) {
      try *sdp = lookup_structdecl(te,loc,(qvar_t)tdnopt);
      catch { case Dict::Absent:
	terr(loc,xprintf("unbound type struct %s",
                         qvar2string((qvar_t)tdnopt)));
        return cvtenv;
      }
    }
    structdecl_t sd = **sdp;
    // Make relative name absolute (or replace absolute name with itself)
    if (sd->name != null) // sanity check
      *tdnopt = sd->name->v[0];
    list_t<tvar_t> tvs = sd->tvs;
    int lvs   = List::length(tvs);
    int largs = List::length(targs);
    if (lvs != largs) 
      terr(loc,xprintf("struct %s expects %d type arguments but was given %d",
		       qvar2string((qvar_t)tdnopt),lvs,largs));
    // check that each of the type arguments is well-formed
    for (; targs != null; targs = targs->tl, tvs = tvs->tl) {
      type_t t1 = targs->hd;
      kind_t k1 = conref_val(tvs->hd->kind);
      cvtenv = i_check_valid_type(loc,te,cvtenv,k1,t1);
    }
    break;
  case &UnionType(tdnopt,targs,*udp):
    if (tdnopt == null) {
      terr(loc,"missing union name");
      return cvtenv;
    }
    if(*udp == null) {
      try *udp = lookup_uniondecl(te,loc,(qvar_t)tdnopt);
      catch { case Dict::Absent:
	terr(loc,xprintf("unbound type union %s",qvar2string((qvar_t)tdnopt)));
        return cvtenv;
      }
    }
    uniondecl_t ud = **udp;
    // Make relative name absolute (or replace absolute name with itself)
    if (ud->name != null) // sanity check
      *tdnopt = ud->name->v[0];
    list_t<tvar_t> tvs = ud->tvs;
    int lvs   = List::length(tvs);
    int largs = List::length(targs);
    if (lvs != largs) 
      terr(loc,xprintf("union %s expects %d type arguments but was given %d",
		       qvar2string((qvar_t)tdnopt),lvs,largs));
    // check that each of the type arguments is well-formed
    for (; targs != null; targs = targs->tl, tvs = tvs->tl) {
      type_t t1 = targs->hd;
      kind_t k1 = conref_val(tvs->hd->kind);
      cvtenv = i_check_valid_type(loc,te,cvtenv,k1,t1);
    }
    break;
  case &TypedefType(tdn,targs,*toptp):
    // NB: since we called compress *toptp == null
    typedefdecl_t td;
    try td = lookup_typedefdecl(te,loc,tdn);
    catch { case Dict::Absent:
      terr(loc,xprintf("unbound typedef name %s",qvar2string(tdn)));
      return cvtenv;
    }
    // Make relative name absolute (or replace absolute name with itself)
    tdn[0] = td->name[0];
    list_t<tvar_t> tvs = td->tvs;
    list_t<type_t> ts = targs;
    list_t<$(tvar_t,type_t)@> inst = null;
    for (; ts != null && tvs != null; ts = ts->tl, tvs = tvs->tl) {
      kind_t k = conref_val(tvs->hd->kind);
      cvtenv = i_check_valid_type(loc,te,cvtenv,k,ts->hd);
      inst = new List(new $(tvs->hd,ts->hd),inst);
    }
    if (tvs != null || ts != null) {
      terr(loc,xprintf("typedef %s expects a different number of arguments",
		       qvar2string(tdn)));
      return cvtenv;
    }
    type_t new_typ = substitute(inst,td->defn);
    *toptp = new Opt(new_typ);
    break;
  case HeapRgn:
    break;
  case &RgnHandleType(t2): 
    fallthru(t2);
  case &AccessEff(t2): 
    cvtenv = i_check_valid_type(loc,te,cvtenv,RgnKind,t2);
    break;
  case &JoinEff(ts):
    for (; ts != null; ts = ts->tl)
      cvtenv = i_check_valid_type(loc,te,cvtenv,EffKind,ts->hd);
    break;
  } 
  if (!kind_leq(typ_kind(t), expected_kind))
    terr(loc,xprintf("type %s has kind %s but as used here needs kind %s",
                     typ2string(t), kind2string(typ_kind(t)), 
                     kind2string(expected_kind)));
  return cvtenv;
}

list_t<tvar_t> check_valid_type(seg_t loc, tenv_t te, 
                                list_t<tvar_t> kind_env, 
                                kind_t expected_kind, type_t t) {
  let cvt = i_check_valid_type(loc,te,CVTEnv{kind_env,null,null},
                               expected_kind,t);
  // run through the evars and constrain them so that when unified,
  // the resulting type can only have type variables drawn from the
  // kind environment or the set of free type variables mentioned here.
  for (_ vs = cvt.free_vars; vs != null; vs = vs->tl)
    fast_add_free_tvar(kind_env,vs->hd);

  for (_ evs = cvt.free_evars; evs != null; evs = evs->tl) {
    switch (compress(evs->hd)) {
    case &Evar(_,_,_,*s): 
      if (*s == null)
        *s = new Opt(kind_env); 
      else {
        // constrain to the intersection of the contexts
        let tvs = (*s)->v;
        let result = null;
        for (; tvs != null; tvs = tvs->tl) {
          if (List::mem(fast_tvar_cmp,kind_env,tvs->hd)) {
            result = new List(tvs->hd,result);
          }
        }
        *s = new Opt(result);
      }
      break;
    default: break;
    }
  }
  return cvt.free_vars;
}

// Same as check_valid_type except that for function types, we check
// that either the bound type variables are empty (in which case we
// plug them in) or else the free type variables are contained in the
// list of the bound type variables and have the right kinds.
void check_valid_toplevel_type(seg_t loc, tenv_t te, type_t t) {
  let free_tvars = check_valid_type(loc, te, null, MemKind, t);

  // force type variables of unresolved or mem kinds to boxed kinds
  for (_ x = free_tvars; x != null; x = x->tl) {
    conref_t<kind_t> c = compress_conref(x->hd->kind);
    switch (c->v) {
    case No_constr: fallthru;
    case &Eq_constr(MemKind):
      c->v = new Eq_constr(BoxKind);
      break;
    default: break;
    }
  }
  if (free_tvars != null) {
    switch (compress(t)) {
    case &FnType(FnInfo{*btvs,eff,tr,args,c_vararg,cyc_vararg,atts}):
      if (*btvs == null)
        *btvs = free_tvars;
      else if (free_tvars != null) {
        string s = *free_tvars->hd->name;
        if (s[0] == '?')
          // Try to give the user a clue as to what happened...
          terr(loc,xprintf("You failed to abstract over the generated type variables. \nRemove the bound type variables or else make the effects of the type explicit\nand then abstract the free type variables properly."));
        else
          terr(loc,xprintf("unbound type variable %s",s));
      }
      break;
    default: 
      terr(loc,xprintf("unbound type variable %s",*free_tvars->hd->name));
      return;
    }
  }
}

void add_tvar_identity(tvar_t tv) {
  if (tv->identity == null) 
    tv->identity = new_tvar_id();
}

void add_tvar_identities(glist_t<tvar_t,`r> tvs) {
  List::iter(add_tvar_identity,tvs);
}

// Same as check_valid_type except that we ensure the free type variables
// are drawn from the given set of bound type variables.
void check_type(seg_t loc, tenv_t te, list_t<tvar_t> bound_tvars, 
                kind_t expected_kind, type_t t) {
  let free_tvars = check_valid_type(loc,te,bound_tvars,expected_kind,t);
  let free_tvars = remove_bound_tvars(free_tvars, bound_tvars);
  for (_ fs = free_tvars; fs != null; fs = fs->tl) {
    let ftvn = fs->hd->name;
    terr(loc,xprintf("unbound type variable %s in type %s",*ftvn,
                     typ2string(t)));
  }
}

// Note: we expect lists to be very short.  Otherwise, a hashtable would
// be a better choice.
static void check_unique_unsorted(int (@cmp)(`a,`a), glist_t<`a,`r> vs,
				  seg_t loc, 
				  string a2string(`a), string msg) {
  for(; vs != null; vs = vs->tl)
    for(_ vs2 = vs->tl; vs2 != null; vs2 = vs2->tl)
      if(cmp(vs->hd, vs2->hd)== 0)
	terr(loc, xprintf("%s: %s",msg,a2string(vs->hd)));
}

static string strptr2string(string @s) {
  return *s;
}

void check_unique_vars(glist_t<var_t,`r> vs, seg_t loc, string msg) {
  check_unique_unsorted(String::zstrptrcmp,vs,loc,strptr2string,msg);
}

void check_unique_tvars(seg_t loc, list_t<tvar_t> tvs) {
  check_unique_unsorted(tvar_cmp,tvs,loc,tvar2string,
                        "duplicate type variable");
}

// take a list of $(list_t<designator>,`a) things corresponding to a struct.
// ensure the struct is not abstract.
//  * check that each list_t<designator> has exactly one element which is a 
//    FieldName or is empty
//  * match up the correct member of sd->fields with the `a.  If the list
//    is empty, take the first unused field. ?????
//    Bang in the corresponding designator in the des list element
//  * ensure that each field is used exactly once.
// (This functionality was repeated in tcPat and tcExp and was annoying me.)
// FIX: Pass in a flag to allow multiple field names ??
glist_t<$(structfield_t,`a)@`r,`r>
resolve_struct_designators(region_t<`r> rgn, seg_t loc,
                           glist_t<$(list_t<designator_t>,`a)@`r2,`r3> des, 
                           list_t<structfield_t> sdfields) {

  // grab all the fields and mark them unused unless the field has an
  // empty name -- these are bitfields for padding and shouldn't be
  // initialized or projected.
  list_t<$(structfield_t,bool)@> fields = null;
  for(_ sd_fields = sdfields; sd_fields != null; sd_fields = sd_fields->tl) {
    if (String::strcmp(*sd_fields->hd->name,"") != 0)
      fields = new List(new $(sd_fields->hd,false), fields);
  }
  fields = imp_rev(fields);

  // match up each element of des
  glist_t<$(structfield_t,`a)@`r,`r> ans = null;
  for(; des != null; des = des->tl) {
    let &$(dl,a) = des->hd;
    if(dl == null) {
      // grab first unused
      let fields2 = fields;
      for(; fields2 != null; fields2 = fields2->tl)
	if(!(*fields2->hd)[1]) {
	  (*fields2->hd)[1] = true;
	  (*des->hd)[0] = new List(new FieldName((*fields2->hd)[0]->name), null);
	  ans = rnew(rgn) List(rnew(rgn) $((*fields2->hd)[0],a), ans);
	  break;
	}
      if(fields2 == null)
	terr(loc, "too many arguments to struct");
    } else if(dl->tl != null)
      // we don't support multiple designators
      terr(loc, "multiple designators are not supported");
    else
      // find the right field based on the designator
      switch (dl->hd) {
      case &ArrayElement(_): 
	terr(loc, "array designator used in argument to struct");
	break;
      case &FieldName(v):
	let fields2 = fields;
	for(; fields2 != null; fields2 = fields2->tl)
	  if(String::zstrptrcmp(v,((*fields2->hd)[0])->name) == 0) {
	    if((*fields2->hd)[1])
	      terr(loc, 
		   xprintf("field %s has already been used as an argument", 
			   *v));
	    (*fields2->hd)[1] = true;
	    ans = rnew(rgn) List(rnew(rgn) $((*fields2->hd)[0],a), ans);
	    break;
	  }
	if(fields2 == null)
	  terr(loc, xprintf("bad field designator %s", *v));
	break;
      }
  }
  
  // make sure we used all the fields
  for(; fields != null; fields = fields->tl)
    if(!(*fields->hd)[1]) {
      terr(loc, "too few arguments to struct");
      break;
    }

  return imp_rev(ans);
}

bool is_tagged_pointer_typ(type_t t) {
  switch (compress(t)) {
  case &PointerType(PtrInfo{_,_,_,_,b}):
    let b = compress_conref(b);
    switch (compress_conref(b)->v) {
    case &Eq_constr(Unknown_b): return true;
    case No_constr: 
      b->v = new Eq_constr((bounds_t)Unknown_b); return true;
    default: return false;
    }
  default: return false;
  }
}

// used by address of.  
// Ensure e is an lvalue or function designator.
// Return if &e is const (true for const) and what region e is in (via a type
//    of RgnKind).
// FIX: not sure const is sufficient to prevent assigning to a function
//      designator???
// Type errors should already have been reported, so we often silently return
//   a bogus answer to avoid duplicate errors.
// Note: regions might not be resolved (unification is order-dependent),
//   but that's okay because a later unification will ensure soundness.
// Note: As explained below, if e1 is a FixedArray, then &e1[e2] is only
//   legal if e1 is an lvalue.  This is not true in C, but I need it, at least
//   for now, and I doubt anyone minds.
$(bool,type_t) addressof_props(tenv_t te, exp_t e) {
  // in some situations, the pointer must actually be const
  $(bool,type_t) bogus_ans = $(false, HeapRgn);
  switch (e->r) {
  case &Var_e(q,x):
    // where oh where does my variable live?
    switch(x) {
    case Unresolved_b: return bogus_ans;
    case &Funname_b(_): return $(true, HeapRgn); 
    case &Global_b(vd): 
      switch (compress(e->topt->v)) {
	// arrays cannot be modified
      case &ArrayType(_,_,_): return $(true, HeapRgn);
      default: return $(vd->tq.q_const,HeapRgn);
      }
    case &Local_b(vd):  
      switch (compress(e->topt->v)) {
      case &ArrayType(_,_,_): return $(true, vd->rgn->v);
      default: return $(vd->tq.q_const, vd->rgn->v);
      }
    case &Pat_b(vd):   fallthru(vd);
    case &Param_b(vd): return $(vd->tq.q_const, vd->rgn->v);
    }
  case &StructMember_e(e1,f):
    // we have an unboxed thing, so we inherit e2's region
    // must check that f isn't a bitfield.
    switch (compress(e1->topt->v)) {
    case &AnonStructType(fs): fallthru(fs);
    case &AnonUnionType(fs):
      let finfo = lookup_field(fs,f);
      if(finfo != null && finfo->width != null)
	return $(finfo->tq.q_const, addressof_props(te,e1)[1]);
      return bogus_ans;
    case &StructType(_,_,&sd):
      let finfo = lookup_struct_field(sd,f);
      if(finfo != null && finfo->width != null)
	return $(finfo->tq.q_const, addressof_props(te,e1)[1]);
      return bogus_ans;
    case &UnionType(_,_,&ud):
      let finfo = lookup_union_field(ud,f);
      if (finfo != null)
        return $(finfo->tq.q_const, addressof_props(te,e1)[1]);
      fallthru;
    default: return bogus_ans;
    }
  case &StructArrow_e(e1,f): 
    // we have a boxed thing, so the region is in the pointer-type.
    // must check that f isn't a bitfield.
    switch (compress(e1->topt->v)) {
    case &PointerType(PtrInfo{t1,r,_,_,_}): 
      switch (compress(t1)) {
      case &AnonStructType(fs): fallthru(fs);
      case &AnonUnionType(fs):
        let finfo = lookup_field(fs,f);
	if(finfo != null && finfo->width != null)
	  return $(finfo->tq.q_const, r);
	return bogus_ans;
      case &StructType(_,_,&sd):
	let finfo = lookup_struct_field(sd,f);
	if(finfo != null && finfo->width != null)
	  return $(finfo->tq.q_const, r);
	return bogus_ans;
      case &UnionType(_,_,&ud):
	let finfo = lookup_union_field(ud,f);
	if(finfo != null)
	  return $(finfo->tq.q_const, r);
	return bogus_ans;
      default: return bogus_ans;
      }
    default: return bogus_ans;
    }
  case &Deref_e(e1):
    // we have a boxed thing, so the region is in the pointer-type.
    switch (compress(e1->topt->v)) {
    case &PointerType(PtrInfo{_,r,_,tq,_}): 
      return $(tq.q_const, r); // FIX: is tq set correctly?
    default: return bogus_ans;
    }

  case &Subscript_e(e1,e2):
    // here we need to figure out whether we've got a boxed thing
    // or not because [] is overloaded for all array kinds, and tuples
    // FIX: eventually a tagged array's elements may live in a region, for now, 
    // they always in the heap
    type_t t = compress(e1->topt->v);
    switch (t) {
    case &ArrayType(_,tq,_): 
      // Actually, this should be impossible since we've surely
      // promoted e1 to a pointer.
      // NOTE: Unlike C, we cannot allow any e1 -- it must be an lvalue.
      // (C doesn't need to know the region and we do!)
      return $(tq.q_const, addressof_props(te,e1)[1]);
    case &TupleType(ts):
      // We need an lvalue in this unboxed case whereas "C w/ tuples" wouldn't.
      let finfo = lookup_tuple_field(ts,Evexp::eval_const_uint_exp(e2));
      if(finfo != null)
	return $((*finfo)[0].q_const, addressof_props(te,e1)[1]);
      return bogus_ans;

    case &PointerType(PtrInfo{t2,r,_,tq,b}): 
      return $(tq.q_const,r);
    default: return bogus_ans;
    }
  default: 
    terr(e->loc,"unary & applied to non-lvalue");
    return bogus_ans;
  }
}

// Coerce an expression of array type to a pointer type.  In
// certain situations, we undo this coercion, notably when e is
// a string constant or Array_e expression occurring as follows:
//    t x[c] = e
//    {.... e ... }  where the {...} is an Array_e
//    Foo(.... e ....)  where Foo is a struct or [x]tunion with a 
//     corresponding field that has type t 
type_t array_to_ptr(tenv_t te, type_t e_typ, exp_t e) {
  switch (compress(e_typ)) {
  case &ArrayType(t,tq,_):
    let $(_,rgn) = addressof_props(te,e);
    return atb_typ(t,rgn,tq,new Upper_b(e));
  default: 
    return e_typ;
  }
}

// give an error when we can statically tell that the array bounds
// aren't large enough -- if the bounds are unconstrained, set them
// to i+1.
void check_bound(seg_t loc, unsigned int i, conref_t<bounds_t> b) {
  b = compress_conref(b);
  switch (b->v) {
  case &Eq_constr(Unknown_b): return; // checked dynamically
  case &Eq_constr(&Upper_b(e)):
    if (Evexp::eval_const_uint_exp(e) <= i)
      terr(loc, "dereference is out of bounds");
    return;
  default:
    // constrain the bounds to be i+1
    b->v = new Eq_constr((bounds_t)(new Upper_b(uint_exp(i+1,null))));
    return;
  }
}

void check_nonzero_bound(seg_t loc, conref_t<bounds_t> b) {
  check_bound(loc, 0, b);
}

bool bits_only(type_t t) {
  switch (compress(t)) {
  case VoidType: return true;
  case &IntType(_,_): return true;
  case FloatType: return true;
  case DoubleType: return true;
  case &EnumType(_,_): return true;
  case &ArrayType(t,_,_): return bits_only(t);
  case &TupleType(tqs):
    for (; tqs != null; tqs = tqs->tl) 
      if (!bits_only((*tqs->hd)[1])) return false;
    return true;
  case &StructType(_,ts,sdp):
    if (sdp == null) return false;
    let sd = *sdp;
    if (sd->fields == null) return false;
    region rgn {
      let inst = List::rzip(rgn,rgn,sd->tvs,ts);
      for (_ fs = sd->fields->v; fs != null; fs = fs->tl)
	if (!bits_only(rsubstitute(rgn,inst,fs->hd->type))) return false;
      return true;
    }
  case &UnionType(_,ts,udp):
    if (udp == null) return false;
    let ud = *udp;
    if (ud->fields == null) return false;
    region rgn {
      let inst = List::rzip(rgn,rgn,ud->tvs,ts);
      for (_ fs = ud->fields->v; fs != null; fs = fs->tl)
	if (!bits_only(rsubstitute(rgn,inst,fs->hd->type))) return false;
      return true;
    }
  case &AnonStructType(fs): fallthru(fs);
  case &AnonUnionType(fs):
    for (; fs != null; fs = fs->tl)
      if (!bits_only(fs->hd->type)) return false;
    return true;
  default: return false;
  }
}

// FIX: there are other expressions we could allow, such as
// &(x->y) or &(x[0]) that we do not support here...
static bool cnst_exp(tenv_t te, bool var_okay, exp_t e) {
  switch (e->r) {
  case &Const_e(_):  return true;
  case &Sizeoftyp_e(t): return true;
  case &Sizeofexp_e(e1): return cnst_exp(te,true,e1);
  case &Enum_e(_,_,_): return true;
  case &Var_e(qv,_):
    // NB: top-level function names and arrays are "constant"
    // Ignore unbound variables b/c should be reported elsewhere
    try switch (lookup_ordinary(te, e->loc, qv)) {
    case &VarRes(&Funname_b(_)): return true;
    case &VarRes(&Global_b(vd)):
      switch (compress(vd->type)) {
      case &ArrayType(_,_,_): return true;
      default: return var_okay;
      }
    default: return var_okay;
    } catch { case Dict::Absent: return false; }

  case &Conditional_e(e1,e2,e3):
    return (cnst_exp(te,false,e1)
            && cnst_exp(te,false,e2)
            && cnst_exp(te,false,e3));
  case &SeqExp_e(e1,e2):
    return (cnst_exp(te,false,e1) && cnst_exp(te,false,e2));
  case &NoInstantiate_e(e2): fallthru(e2);
  case &Instantiate_e(e2,_):
    return cnst_exp(te,var_okay,e2);
  case &Cast_e(t,e2):
    // FIX:  We cannot allow casts w/ run-time effect b/c C will complain!
    return cnst_exp(te,var_okay,e2);
  case &Address_e(e2):
    return cnst_exp(te,true,e2);
  case &Comprehension_e(_,e1,e2):
    return cnst_exp(te,false,e1) && cnst_exp(te,false,e2);
  case &Array_e(des): fallthru(des);
  case &AnonStruct_e(_,des): fallthru(des);
  case &Struct_e(_,_,des,_):
    for (; des != null; des = des->tl)
      if (!cnst_exp(te,false,(*des->hd)[1]))
        return false;
    return true;

  case &Primop_e(p,es):     fallthru(es);
  case &Tuple_e(es):        fallthru(es);
  case &Tunion_e(_,_,es,_,_):
    for (; es != null; es = es->tl)
      if (!cnst_exp(te,false,es->hd))
        return false;
    return true;
    // eventually -- should support comprehensions for initializers
  //case Comprehension_e(vd,e1,e2):
  //return (cnst_exp(te,false,e1) && cnst_exp(te,false,e2));
  default:
    return false;
  }
}

bool is_const_exp(tenv_t te, exp_t e) {
  return cnst_exp(te,false,e);
}

static bool fields_support_default(list_t<tvar_t> tvs, list_t<type_t> ts, 
                                   list_t<structfield_t> fs);
bool supports_default(type_t t) {
  switch (compress(t)) {
  case VoidType: return true;
  case &Evar(_,_,_,_): return false;
  case &VarType(_): return false;
  case &TunionType(_): return false;
  case &TunionFieldType(_): return false;
  case &PointerType(PtrInfo{elt_typ,_,nullable,_,bounds}):
    switch (compress_conref(bounds)->v) {
    case &Eq_constr(Unknown_b): return true;
    case &Eq_constr(&Upper_b(_)):
      switch (compress_conref(nullable)->v) {
      case &Eq_constr(b): return b;
      default: return false;
      }
    default: return false;
    }
  case &IntType(_,_): return true;
  case FloatType: return true;
  case DoubleType: return true;
  case &ArrayType(t,_,_): return supports_default(t);
  case &FnType(_): return false;
  case &TupleType(tqs):
    for (; tqs != null; tqs = tqs->tl)
      if (!supports_default((*tqs->hd)[1])) return false;
    return true;
  case &StructType(_,ts,sdp):
    if (sdp == null) return false;
    structdecl_t sd = *sdp;
    if (sd->fields == null) return false;
    return fields_support_default(sd->tvs, ts,sd->fields->v);
  case &UnionType(_,ts,udp):
    if (udp == null) return false;
    uniondecl_t ud = *udp;
    if (ud->fields == null) return false;
    return fields_support_default(ud->tvs, ts,ud->fields->v);
  case &AnonStructType(fs): fallthru(fs);
  case &AnonUnionType(fs):
    return fields_support_default(null,null,fs);
  case &EnumType(_,_): 
    // FIX: may not include 0!
    return true;
  default: return false;
  }
}

static bool fields_support_default(list_t<tvar_t> tvs, list_t<type_t> ts, 
                                   list_t<structfield_t> fs) {
  region rgn {
    let inst = List::rzip(rgn,rgn,tvs,ts);
    for (; fs != null; fs = fs->tl) {
      type_t t = rsubstitute(rgn,inst,fs->hd->type);
      if (!supports_default(t)) return false;
    }
  }
  return true;
}
