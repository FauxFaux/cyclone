/* Utility functions for type checking */

#include "absyn.h"
#include "absynpp.h"
#include "set.h"
#include "position.h"
#include "tcenv.h"
#include "string.h"
#include "evexp.h"
#include "tcutil.h"
using Core;
using List;
using Set;
using Position;
using Absyn;
using Absynpp;
using Tcenv;

namespace Tcutil;

xenum exn {TypeErr};

extern void unify_it(typ t1, typ t2);

void terr(segment loc, string s) {
  Position::post_error(Position::mk_err_elab(loc,s));
}

`a impos<`a>(string msg) {
  fprintf(cyc_stderr,"Error: %s\n",msg);
  fflush(cyc_stderr);
  throw TypeErr;
}

static list<segment> warning_segs = null;
static list<string>  warning_msgs = null;

// we batch warnings because we have to parse the file to determine
// line and column information.
void warn(segment sg, string msg) {
  warning_segs = &cons(sg, warning_segs);
  warning_msgs = &cons(msg,warning_msgs);
}
void flush_warnings() {
  if(warning_segs == null)
    return;
  fprintf(cyc_stderr,"***Warnings***\n");
  list<string> seg_strs = strings_of_segments(warning_segs);
  warning_segs = null;
  warning_msgs = List::imp_rev(warning_msgs);
  while(warning_msgs != null) {
    fprintf(cyc_stderr,"%s: %s\n", seg_strs->hd, warning_msgs->hd);
    seg_strs     = seg_strs->tl;
    warning_msgs = warning_msgs->tl;
  }
  fprintf(cyc_stderr,"**************\n");
  fflush(cyc_stderr);
}

// set by by Tcenv::tc_init, used to reduce allocation and calls to Set::empty.
Opt_t<Set<var>> empty_var_set = null;

// compress out any evars or typedefs
typ compress(typ t) {
  switch (t) {
  case Evar(_,null,      _): 
    return t;
  case Evar(_,*t2opt_ref,_): // TRICKY
    typ t2 = compress((*t2opt_ref)->v);
    *t2opt_ref = &Opt(t2);
    return t2;
  case TypedefType(_,_,null): 
    return t;
  case TypedefType(_,_,*topt_ref):
    typ t2 = compress((*topt_ref)->v);
    *topt_ref = &Opt(t2);
    return t2;
  default:
    return t;
  }
}

// FIX: It's much faster to do this as a straight table lookup
//      instead of a procedural implementation of the lattice.
//      But since this kind system is still experimental, I've just
//      coded up the lattice quite literally:
//                          Unresolved
//                       /         |
//                   MemU         Rgn
//                    |   \
//                   RegU  MemP   
//                    |  \  |
//                   BoxU  RegP
//                       \  |
//                         BoxP               
static bool kind_leq(kind_t k1, kind_t k2) {
  if(k1 == k2)
    return true;
  switch (k2) {
  case UnresolvedKind: return true; // okay, so I snuck in 1 important fast-path
  case BoxPKind: return false;
  case RegPKind: return kind_leq(k1,BoxPKind);
  case BoxUKind: return kind_leq(k1,BoxPKind);
  case MemPKind: return kind_leq(k1,RegPKind);
  case RegUKind: return kind_leq(k1,BoxUKind) || kind_leq(k1,RegPKind);
  case MemUKind: return kind_leq(k1,RegUKind) || kind_leq(k1,MemPKind);
  case RgnKind:  return false;
  }
}

// return the "least" kind of a type, according to the lattice above
// FIX: The "enums, structs, and xenums are packable" rule
//      is currently enforced stringently in Tc and should change some day.
// FIX: I think the Evar case should be an error, but I'm not sure yet.
extern bool is_packable(typ);
static kind_t typ_kind(typ t) {
  switch (compress(t)) {
    // FIX: this isn't the least kind -- what if it got constrained to
    // unpackable later?!?!?
    // But unify_it calls this with an evar, so let it go for now.
  case Evar(k,topt,_):    return k; 

  case VarType(&$(_,k)):  return k;
  case VoidType:          return MemPKind;
  case IntType(_,sz,bx):  return (sz==B4 || bx==Boxed) ? BoxPKind : RegPKind;
  case FloatType(bx):     return (bx==Boxed)           ? BoxPKind : RegPKind;
  case DoubleType(bx):    return (bx==Boxed)           ? BoxPKind : RegPKind;
  case FnType(_,_,_,_):   return MemPKind;
  case RgnHandleType(_):  return BoxUKind; // the whole point on packability
  case HeapRgnType:       return RgnKind;

  case EnumType(_,_,_):   return BoxPKind; // see FIX above
  case XenumType(_,_):    return BoxPKind; // see FIX above
  case StructType(_,_,_): return MemPKind; // see FIX above

  // For pointers, the rgntyp is irrelevant for packability because
  // an existential bound variable cannot have RgnKind, so it can't be hidden
  // FIX: That assumption will change if the ability to name ever doesn't
  // imply the capability to access.
  case PointerType(t,rgntyp,_,_): return is_packable(t) ? BoxPKind : BoxUKind;

  // FIX: should tagged arrays be allowed to point at arrays not in the heap?
  case ArrayType(t,_,TaggedArray): return is_packable(t) ? BoxPKind : BoxUKind;
  case ArrayType(t,_,_):           return is_packable(t) ? MemPKind : MemUKind;
  case TupleType(tqts):
    for(; tqts != null; tqts = tqts->tl)
      if(!is_packable(tqts->hd[1]))
	return MemUKind;
    return MemPKind;

  case TypedefType(_,_,topt): 
    return impos(xprintf("typ_kind: typedef found: %s", typ2string(t)));
  case UnionType: return impos("union type");
  }
}
static bool is_packable(typ t) {
  switch (compress(t)) {
  case Evar(_,_,_): return false; // conservative -- will it be a pain?
  default: 
    switch(typ_kind(t)) {
    case MemUKind: return false;
    case RegUKind: return false;
    case BoxUKind: return false;
    case MemPKind: return true;
    case RegPKind: return true;
    case BoxPKind: return true;
    case RgnKind:        throw Impossible("is_packable found RgnKind");
    case UnresolvedKind: throw Impossible("is_packable found UnresolvedKind");
    }
  }
}

xenum exn {Unify};

// unify types t1 and t2, returning true iff the unification succeeds 
bool unify(typ t1, typ t2) {
  try {
    unify_it(t1,t2);
    return true;
  } catch {
  case Unify: return false;
  }
}

// see if evar occurs within t
extern void occurslist(typ evar, list<typ> ts); // mutually recursive fns
static void occurs(typ evar, typ t) {
  switch (compress(t)) {
  case Evar(_,r,_):
    if (t == evar) throw Unify;
    else if (r != null) occurs(evar,r->v);
    break;
  case PointerType(t2,rt,_,_): occurs(evar,t2); occurs(evar,rt); break;
  case ArrayType(t2,_,_):      occurs(evar,t2);                  break;
  case FnType(tvs,rt,args,varargs): // FIX: OK to ignore binding of type vars?
    occurs(evar,rt);
    for(; args != null; args = args->tl)
      occurs(evar,args->hd[2]);
    break;
  case TupleType(args):
    for(; args != null; args = args->tl)
      occurs(evar,args->hd[1]);
    break;
  case RgnHandleType(rt): occurs(evar,rt); break;
  case TypedefType(_,ts,topt): fallthru(ts);
  case EnumType(_,ts,_):       fallthru(ts);
  case StructType(_,ts,_):     occurslist(evar,ts); break;
  default: break;
  }
}
static void occurslist(typ evar, list<typ> ts) {
  for (; ts != null; ts = ts->tl)
    occurs(evar,ts->hd);
}

// unify two lists of types
static void unify_list(list<typ> t1, list<typ> t2) {
  try List::iter2(unify_it,t1,t2);
  catch {case List_mismatch: throw Unify;}
}

// unify two type qualifiers -- throws Unify unless they are the same
static void unify_tqual(tqual tq1, tqual tq2) {
  if ((tq1->q_const != tq2->q_const)    
      || (tq1->q_volatile != tq2->q_volatile) 
      || (tq1->q_restrict != tq2->q_restrict))
    throw Unify;
}

bool equal_tqual(tqual tq1, tqual tq2) {
  return ((tq1->q_const == tq2->q_const) 
	  && (tq1->q_volatile == tq2->q_volatile) 
	  && (tq1->q_restrict == tq2->q_restrict));
}

// compress a conref
conref<`a> compress_conref<`a>(conref<`a> x) {
  switch (x->v) {
  case No_constr:    return x;
  case Eq_constr(_): return x;
  case Forward_constr(y):
    let z = compress_conref(y);
    x->v = z->v;
    return z;
  }
}

`a conref_val<`a>(conref<`a> x) {
  switch (compress_conref(x)->v) {
  case Eq_constr(v): return v;
  default:           return impos("conref_val");
  }
}

// unify two constraint refs
static void unify_it_conrefs<`a>(int cmp(`a,`a), conref<`a> x, conref<`a> y) {
  x = compress_conref(x);
  y = compress_conref(y);
  if (x == y) return;
  switch (x->v) {
  case No_constr: x->v = Forward_constr(y); return;
  case Forward_constr(_): throw impos("unify_conref: forward after compress");
  case Eq_constr(xv):
    switch (y->v) {
    case No_constr: y->v = x->v; return;
    case Forward_constr(_):
      throw impos("unify_confref: forward after compress(2)");
    case Eq_constr(yv):
      if (cmp(xv,yv) != 0) throw Unify;
      return;
    }
  }
}

static bool unify_conrefs<`a>(int cmp(`a,`a), conref<`a> x, conref<`a> y) {
  try {
    unify_it_conrefs(cmp,x,y);
    return true;
  } catch { case Unify: return false; }
}

// the real work of unification
void unify_it(typ t1, typ t2) {
  t1 = compress(t1);
  t2 = compress(t2);
  if (t1 == t2) return;
  switch (t1) {
  case Evar(kind1,*ref1_ref,_):
    // this really shouldn't happen since we compressed t1
    if (*ref1_ref != null) {
      unify_it((*ref1_ref)->v,t2);
      return;
    }
    // check that the evar doesn't occur in t2
    occurs(t1,t2);
    _ kind2 = typ_kind(t2);
    // we can constrain the Evar to be equal to t2 only when the kind of the
    // evar is greater than or equal to the kind of t2 or t2 is an evar that
    // we can constrain to be equal to t1.
    if (kind_leq(kind2,kind1)) {
      *ref1_ref = &Opt(t2);
      return;
    } else {
      switch (t2) {
      case Evar(_,*ref2_ref,_): *ref2_ref = &Opt(t1); return;
      default: throw Unify;
      }
    }
  default: break; 
  }
  // t1 is not an evar

    // in what follows, we throw Unify unless we explicitly return.
  switch ($(t2,t1)) {

  case $(Evar(_,_,_),_): // t2 is an evar, t1 is not, swap and try again
    unify_it(t2,t1);
    return;

  case $(VoidType,VoidType): return;

  case $(VarType(&$(x2,k2)),VarType(&$(x1,k1))):
    // kinds should already be resolved, otherwise we could "unify"
    // UnresolvedKind with something else???
    if(k2 == k1 && String::zstrcmp(x2,x1) == 0) return;
    break;

  case $(StructType(nopt2,ts2,sd2), StructType(nopt1,ts1,sd1)): 
    // FIX: equivalent and more efficient to pointer-compare sds
    if ((nopt1 != null && nopt2 != null
	 && qvar_cmp(nopt1->v,nopt2->v) == 0) 
	|| (nopt1 == null && nopt2 == null)) {
      unify_list(ts1,ts2);
      return;
    }
    break;

  case $(EnumType(nopt2,ts2,edp2), EnumType(nopt1,ts1,edp1)):
    if (*edp2 == *edp1) {
      unify_list(ts1,ts2);
      return;
    }
    break;

  case $(XenumType(n2,xedp2),XenumType(n1,xedp1)):
    if(*xedp2 == *xedp1)
      return;
    break;

  case $(PointerType(t2a,rgn2,null2a,tqual2a),
	 PointerType(t1a,rgn1,null1a,tqual1a)):
    unify_it(t1a,t2a);
    unify_it(rgn2,rgn1); // the whole reason regions are "types"
    unify_tqual(tqual1a,tqual2a);
    unify_it_conrefs(intcmp,null1a,null2a);
    return;

  case $(IntType(sn2,sz2,bx2), IntType(sn1,sz1,bx1)):
    if ((sn1 == sn2) && (sz1 == sz2) && (bx1 == bx2)) return;
    break;

  case $(FloatType(Boxed),    FloatType(Boxed)):    return;
  case $(FloatType(Unboxed),  FloatType(Unboxed)):  return;
  case $(DoubleType(Boxed),   DoubleType(Boxed)):   return;
  case $(DoubleType(Unboxed), DoubleType(Unboxed)): return;

  case $(ArrayType(t2a,tq2a,ak2a), ArrayType(t1a,tq1a,ak1a)):
    unify_it(t1a,t2a);
    unify_tqual(tq1a,tq2a);
    switch ($(ak1a,ak2a)) {
    case $(UntaggedArray,  UntaggedArray):  return;
    case $(TaggedArray,    TaggedArray):    return;
    case $(FixedArray(e1), FixedArray(e2)):
      if (Evexp::eval_const_uint_exp(e1) == Evexp::eval_const_uint_exp(e2)) 
	return;
      break;
    default: break;
    }
    break;

  case $(FnType(tvs2,rt2,args2,vararg2), FnType(tvs1,rt1,args1,vararg1)):
    list<$(tvar,typ)@> inst = null;
    while (tvs1 != null) {
      if (tvs2 == null) break;
      inst = &cons(&$(tvs2->hd,VarType(tvs1->hd)),inst);
      tvs1 = tvs1->tl;
      tvs2 = tvs2->tl;
    }
    if (tvs2 != null) break;
    if (inst != null) {
      unify_it(FnType(null,rt1,args1,vararg1),
	       substitute(inst,FnType(null,rt2,args2,vararg2)));
      return;
    } 
    unify_it(rt1,rt2);
    for (; args1!=null && args2!=null; args1 = args1->tl, args2 = args2->tl) {
      unify_tqual(args1->hd[1],args2->hd[1]);
      unify_it(args1->hd[2],args2->hd[2]);
    }
    if ((args1 != null) || (args2 != null)) break;
    if (vararg1 == vararg2) return;
    break;

  case $(TupleType(ts2), TupleType(ts1)):
    for (; ts1 != null && ts2 != null; ts1 = ts1->tl, ts2 = ts2->tl) {
      unify_tqual(ts1->hd[0],ts2->hd[0]);
      unify_it(ts1->hd[1],ts2->hd[1]);
    }
    if (ts1 == null && ts2 == null) return;
    break;

  case $(HeapRgnType, HeapRgnType): return;
  case $(RgnHandleType(rt1),RgnHandleType(rt2)):
    unify_it(rt1,rt2);
    return;

  default: break;
  }
  throw Unify;
}

static void unbox_exp(tenv te, exp e) {
  switch (compress(e->topt->v)) {
  case IntType(sn,sz,Boxed): unchecked_cast(te,e,IntType(sn,sz,Unboxed)); break;
  case FloatType(Boxed):     unchecked_cast(te,e,float_t);  break;
  case DoubleType(Boxed):    unchecked_cast(te,e,double_t); break;
  default: break;
  }
}

bool is_arithmetic_type(typ t) {
  switch (compress(t)) {
  case IntType(_,_,_): return true;
  case FloatType(_):   return true;
  case DoubleType(_):  return true;
  default:             return false;
  }
}

// we're about to convert a value of type t1 to type t2 (both arithmetic types)
// return true if we will potentially loose precision
bool will_lose_precision(typ t1, typ t2) {
  t1 = compress(t1);
  t2 = compress(t2);
  switch ($(t1,t2)) {
  case $(DoubleType(_),   FloatType(_)):    return true;
  case $(DoubleType(_),   IntType(_,_,_)):  return true;
  case $(FloatType(_),    IntType(_,_,_)):  return true;
  case $(IntType(_,B8,_), IntType(_,B8,_)): return false;
  case $(IntType(_,B8,_), _):               return true; // see prev case
  case $(IntType(_,B4,_), FloatType(_)):    return true;
  case $(IntType(_,B4,_), IntType(_,B2,_)): return true;
  case $(IntType(_,B4,_), IntType(_,B1,_)): return true;
  case $(IntType(_,B2,_), IntType(_,B1,_)): return true;
  default: return false;
  }
}

bool is_boxed_type(typ t) {
  switch (compress(t)) {
  case IntType(_,_,bx): return (bx == Boxed);
  case FloatType(bx):   return (bx == Boxed);
  case DoubleType(bx):  return (bx == Boxed);
  default:              return false;
  }
}

typ make_unboxed_type(typ t) {
  switch (compress(t)) {
  case IntType(sn,sz,bx): return (bx == Unboxed) ? t : IntType(sn,sz,Unboxed);
  case FloatType(_):      return float_t;
  case DoubleType(_):     return double_t;
  default:                return t;
  }
}

// coerce the list e so that each element has type t -- used in arrays and
// conditionals 
bool coerce_list(tenv te, typ t, list<exp> es) {
  // find the biggest arithmetic type (if any) for the list and determine
  // if all of the elements are boxed.
  Opt_t<typ> max_arith_type = null;
  bool all_boxed = true;
  for (list<exp> el = es; el != null; el = el->tl) {
    typ t1 = compress(el->hd->topt->v);
    if (is_arithmetic_type(t1)) 
      if (max_arith_type == null || will_lose_precision(t1,max_arith_type->v))
	max_arith_type = &Opt(t1);
    if (!is_boxed_type(t1)) 
      all_boxed = false;
  }
  // if even one of the expressions is unboxed, then we unbox all of them
  if (!all_boxed && max_arith_type != null)
    max_arith_type = &Opt(make_unboxed_type(max_arith_type->v));
  // unify the max arithmetic type with the result type t
  if (max_arith_type != null)
    if (!unify(t,max_arith_type->v))
      return false;
  // now coerce each expression to the type t as if by assignment
  for (list<exp> el = es; el != null; el = el->tl)
    if (!coerce_assign(te,el->hd,t)) {
      terr(el->hd->loc,xprintf("type mismatch: expecting %s but found %s",
			       typ2string(t),typ2string(el->hd->topt->v)));
      return false;
    }
  return true;
}

// coerce e to have type "bool" (int) -- used in conditionals 
bool coerce_to_bool(tenv te, exp e) {
  if (!coerce_sint_typ(te,e)) {
    switch (compress(e->topt->v)) {
    case PointerType(_,_,_,_): unchecked_cast(te,e,uint_t); break;
    default: return false;
    }
  }
  return true;
}

bool is_integral_type(typ t) {
  switch (compress(t)) {
  case IntType(_,_,_): return true;
  default: return false;
  }
}

// coerce e to have type unsigned int -- used in subscript
bool coerce_uint_typ(tenv te, exp e) {
  if (unify(e->topt->v,uint_t)) 
    return true;
  // try unboxing e
  if (typ_kind(e->topt->v) == BoxPKind) {
    unbox_exp(te,e);
    if (unify(e->topt->v,uint_t)) 
      return true;
  }
  // try arithmetic conversions -- we only allow integral values
  if (is_integral_type(e->topt->v)) {
    if (will_lose_precision(e->topt->v,uint_t))
      warn(e->loc,"integral size mismatch; conversion supplied");
    unchecked_cast(te,e,uint_t);
    return true;
  }
  return false;
}

// coerce e to have type [signed] int -- used in coercions to "bool"
bool coerce_sint_typ(tenv te, exp e) {
  if (unify(e->topt->v,sint_t)) 
    return true;
  // try unboxing e
  if (typ_kind(e->topt->v) == BoxPKind) {
    unbox_exp(te,e);
    if (unify(e->topt->v,sint_t)) 
      return true;
  }
  // try arithmetic conversions -- we only allow integral values
  if (is_integral_type(e->topt->v)) {
    if (will_lose_precision(e->topt->v,sint_t))
      warn(e->loc,"integral size mismatch; conversion supplied");
    unchecked_cast(te,e,sint_t);
    return true;
  }
  return false;
}

// Can t1 be (implicitly) cast to t2? Assumes types are well-formed 
// FIX: allow cast between t@ and t[],t[1].
bool silent_castable(tenv te, segment loc, typ t1, typ t2) {
  t1 = compress(t1);
  t2 = compress(t2);
  switch ($(t1,t2)) {
 
  case $(PointerType(t_a,r_a,null_a,q_a),PointerType(t_b,r_b,null_b,q_b)):
    // can cast t@ to t* but not vice versa.  can cast a non-const pointer
    // to a const pointer.  Regions must unify.
    bool okay = true;
    if (!unify_conrefs(intcmp,null_a,null_b)) {
      switch (compress_conref(null_a)->v) {
      case Eq_constr(b): okay = !b; break;
      default: throw impos("silent_castable: conref not eq");
      }
    }
    return (okay 
	    && unify(t_a,t_b) 
	    && unify(r_a,r_b)
	    && (!q_a->q_const || q_b->q_const));
  
  case $(ArrayType(t1a,tq1a,ak1a),ArrayType(t2a,tq2a,ak2a)):
    bool okay;
    switch ($(ak1a,ak2a)) {
    case $(UntaggedArray,  UntaggedArray): okay = true;  break;
    case $(TaggedArray,    UntaggedArray): okay = true;  break;
    case $(TaggedArray,    TaggedArray):   okay = true;  break;
    case $(FixedArray(e1), FixedArray(e2)):
      okay = (Evexp::eval_const_uint_exp(e1) == Evexp::eval_const_uint_exp(e2));
      break;
    case $(FixedArray(_),  _):             okay = true;  break;
    default:                               okay = false; break;
    }
    return (okay && unify(t1a,t2a) && (!tq1a->q_const || tq2a->q_const));
  
  default: return unify(t1,t2);
  }
}

// coerce e to have type t -- used in function call and explicit fallthru
bool coerce_arg(tenv te, exp e, typ t2) {
  typ t1 = compress(e->topt->v);
  // see if types immediately match
  if (unify(t1,t2)) return true;
  // try unboxing e
  if (typ_kind(t1) == BoxPKind && typ_kind(t2) == RegPKind) {
    unbox_exp(te,e);
    if (unify(t1,t2)) return true;
  }
  // try arithmetic conversions
  if (is_arithmetic_type(t1) && is_arithmetic_type(t2)) {
    // issue a warning if we lose precision
    if (will_lose_precision(t1,t2))
      warn(e->loc,"integral size mismatch; conversion supplied");
    unchecked_cast(te,e,t2);
    return true;
  } else if (silent_castable(te,e->loc,t1,t2)) {
    unchecked_cast(te,e,t2);
    return true;
  } else if (castable(te,e->loc,t1,t2)) {
    unchecked_cast(te,e,t2);
    warn(e->loc,xprintf("implicit cast from %s to %s",typ2string(t1),
			typ2string(t2)));
    return true;
  } else return false;
}

// coerce e to have type t -- used in assignment operations.  Neither
// gcc nor VC++ issue warnings for losing precision here, but I think
// it may be appropriate.
bool coerce_assign(tenv te, exp e, typ t) {
  return coerce_arg(te,e,t);
}

static bool any_promote(tenv te, exp e) {
  typ old_typ = compress(e->topt->v);
  typ t;
  switch (old_typ) {
  case IntType(sn,sz,b):
    switch (sz) {
    case B1: t = sint_t; break; // convert to unboxed, signed int
    case B2: t = sint_t; break; // convert to unboxed, signed int
    case B4: t = (sn == Unsigned) ? uint_t : sint_t; break;   // make unboxed
    case B8: t = (sn == Unsigned) ? ulong_t : slong_t; break; // make unboxed
    }
    break;
  case FloatType(b):  t = float_t;  break; // make unboxed
  case DoubleType(b): t = double_t; break; // make unboxed
  default: return false;
  }
  unchecked_cast(te,e,t);
  return true;
}

// Convert e so that it has type t, possibly by casting t.  This is
// used in routines like function call or assignment where we may have
// to promote an integral type, may have to unbox, etc.  
// FIX: THIS IS NOT RIGHT.
// FIX: account for unpackable kinds?
bool coerce_use(tenv te, exp e, typ t2) {
  typ    t1 = compress(e->topt->v);
  kind_t k1 = typ_kind(t1);
  kind_t k2 = typ_kind(t2);
  if (k1 == BoxPKind && k2 == RegPKind)
    unbox_exp(te,e);
  if (unify(t1,t2)) 
    return true;
  // unification failed, try unboxing e
  any_promote(te,e);
  if (unify(e->topt->v,t2)) 
    return true;
  else if (silent_castable(te,e->loc,t1,t2)) {
    unchecked_cast(te,e,t2);
    return true;
  } else if (castable(te,e->loc,t1,t2)) {
    unchecked_cast(te,e,t2);
    warn(e->loc,xprintf("implicit cast from %s to %s",typ2string(t1),
		       typ2string(t2)));
    return true;
  } else 
    return false;
}

bool coerceable(typ t) {
  switch (compress(t)) {
  case IntType(_,_,_): return true;
  case FloatType(_):   return true;
  case DoubleType(_):  return true;
  default:             return false;
  }
}

// Flatten a type into a list of type qualifiers and types for
// use in subtype comparison.
// FIX:  we should recursively flatten tuple and struct types here,
// but doing so is tricky because we have to get the padding and
// alignment right.  This seems to be particularly weird on the
// x86 -- I need to find precise documentation on it before we 
// do this.
static $(tqual,typ)@ flatten_typ_f(list<$(tvar,typ)@> inst,
                                   $(field_name,tqual,typ)@ x) {
  return &$(x[1],substitute(inst,x[2]));
}
static list<$(tqual,typ)@> flatten_typ(tenv te,typ t1) {
  t1 = compress(t1);
  switch (t1) {
  case VoidType:       return null;
  case TupleType(tqs): return tqs; // FIX: recursively flatten here
  case StructType(tdnopt,ts,sdp):
    _ sd   = *sdp;
    _ n    = tdnopt->v;
    _ inst = List::zip(sd->tvs,ts);
    if (sd->fields == null) return &cons(&$(empty_tqual(),t1),null);
    // FIX: recursively flatten here
    return List::map_c(flatten_typ_f,inst,sd->fields->v);
  default: return &cons(&$(empty_tqual(),t1),null);
  }
}

// FIX: the plan is, once we have a context that lets us assume t1 <= t2
// for recursive types, then to do deep subtyping.  
extern bool ptrsubtype(tenv te, list<$(typ,typ)@> assume, typ t1, typ t2);
static bool subtype(tenv te, list<$(typ,typ)@> assume, typ t1, typ t2) {
  if (unify(t1,t2)) return true;
  for (_ a = assume; a != null; a = a->tl)
    if (unify(t1,a->hd[0]) && unify(t2,a->hd[1])) 
      return true;
  t1 = compress(t1);
  t2 = compress(t2);
  switch ($(t1,t2)) {
  case $(PointerType(t_a,rt_a,null_a,q_a), PointerType(t_b,rt_b,null_b,q_b)):
    // if t1 is const then t2 must be const
    if (q_a->q_const && !q_b->q_const) 
      return false;
    // if t1 is * then t2 must be *
    if (!unify_conrefs(intcmp,null_a,null_b) 
	&& conref_val(null_a) && !conref_val(null_b)) 
      return false;
    // if rt_a is not the heap, then rt_b must be the same (can relax this
    // later to a more general "outlives" relationship)
    switch (rt_a) {
    case HeapRgnType: break;
    default: unify(rt_a,rt_b); break;
    }
    return ptrsubtype(te, &cons(&$(t1,t2),assume), t_a, t_b);
  default: return false;
  }
}

// is t1* <= t2*?
//   we flatten t1 and t2 into structurally equivalent tuple types 
//   (and thus ignore field names, associativity of nested tuples and
//   structs, etc.) and then check that t1 is a width extension of t2 
//   and for each field, either (a) both t1 and t2 have qualifier "const"
//   and the t1 field is a subtype of the t2 field, or (b) t1 = t2.
static bool ptrsubtype(tenv te, list<$(typ,typ)@> assume, typ t1, typ t2) {
  list<$(tqual,typ)@> tqs1 = flatten_typ(te,t1);
  list<$(tqual,typ)@> tqs2 = flatten_typ(te,t2);
  for (; tqs2 != null; tqs2 = tqs2->tl, tqs1 = tqs1->tl) {
    if (tqs1 == null) return false;
    let &$(tq1,t1a) = tqs1->hd;
    let &$(tq2,t2a) = tqs2->hd;
    if (tq2->q_const && subtype(te,assume,t1a,t2a)) continue;
    else if (unify(t1a,t2a)) continue;
    else return false;
  }
  return true;
}

// Can t1 be cast to t2?  Assumes that the types are well-formed.
bool castable(tenv te, segment loc, typ t1, typ t2) {
  t1 = compress(t1);
  t2 = compress(t2);
  if(unify(t1,t2))
    return true;
  switch (t1) {
  case EnumType(name_opt,ts,ed):
    // can cast an enum to an int -- extracts the tag
    return (coerceable(t2));
    // FIX: look at regions!
  case PointerType(t_a,rt_a,null_a,q_a):
    // can cast t* to t@ and vice versa.  
    // can cast a non-const pointer to a const pointer.  
    // can cast a t heap pointer to a t[],t[1], or t[?]
    // can cast a pointer in the heap to a pointer to some other region
    switch (t2) {
    case PointerType(t_b,rt_b,null_b,q_b):
      _ assump = &cons(&$(t1,t2),null);
      _ ptrsub =
	ptrsubtype(te,assump,t_a,t_b) && (!q_a->q_const || q_b->q_const);
      return ptrsub && (rt_a == HeapRgnType || unify(rt_a,rt_b));
    case ArrayType(t_b,q_b,ak):
      _ assump = &cons(&$(t1,t2),null);
      if (!(ptrsubtype(te,assump,t_a,t_b) && (!q_a->q_const || q_b->q_const)))
	return false;
      switch (ak) {
      case FixedArray(e): return (Evexp::eval_const_uint_exp(e) == 1);
      default: return true;
      }
    default: return false;
    }
  case ArrayType(t1a,tq1a,ak1a):
    switch (t2) {
    case ArrayType(t2a,tq2a,ak2a):
      bool okay;
      switch ($(ak1a,ak2a)) {
      case $(FixedArray(e1),FixedArray(e2)):
	okay=(Evexp::eval_const_uint_exp(e1) >= Evexp::eval_const_uint_exp(e2));
	break;
      case $(UntaggedArray, _): okay = false; break;
      case $(_, UntaggedArray): okay = false; break; // FIX! Toc should allow!
      default: okay = true; break;
      }
      return (okay && unify(t1a,t2a) && (!tq1a->q_const || tq2a->q_const));
    default: return false;
    }
  // can cast a numeric type or bool to any numeric type
  case IntType(_,_,_): fallthru;
  case FloatType(_) :  fallthru;
  case DoubleType(_):  return coerceable(t2);
  default: return false;
  }
}

// Replace e by a cast of e to t.  The caller must ensure that the cast is safe.
void unchecked_cast(tenv te, exp e, typ t) {
  if (!unify(e->topt->v,t)) {
    _ inner = copy_exp(e);
    e->r    = Cast_e(t,inner);
    e->topt = &Opt(t);
  }
}

// for comparison operators, we do not unbox Double and Long Long, but
// rather do a pointer comparison.  However, we issue a warning.
bool comparison_promote(tenv te, exp e) {
  typ t;
  switch (compress(e->topt->v)) {
  case IntType(sn,sz,b):
    switch (sz) {
    case B1: t = sint_t; break; // convert to unboxed, signed int
    case B2: t = sint_t; break; // convert to unboxed, signed int
    case B4: t = (sn == Unsigned) ? uint_t : sint_t; break; // make uboxed
    case B8:
      if (b == Boxed) {
	warn(e->loc,"pointer comparison of Long Long");
	return false;
      } else return true;
    }
    break;
  case FloatType(b): t = float_t; break; // make unboxed
  case DoubleType(b):
    if (b == Boxed) {
      warn(e->loc,"pointer comparison of Double");
      return false;
    } else return true;
  default: return false;
  }
  unchecked_cast(te,e,t);
  return true;
}

// check that the expression has an arithmetic type and, if it's boxed
// or a size that is smaller than an int, then promote it up to int.
// Note that unsigned char or unsigned short will be promoted to
// signed int.  Otherwise, the sign is preserved.
bool arithmetic_promote(tenv te, exp e) {
  typ old_typ = compress(e->topt->v);
  typ t;
  switch (old_typ) {
  case IntType(sn,sz,b):
    switch (sz) {
    case B1:  t = sint_t; break; // convert to unboxed, signed int
    case B2:  t = sint_t; break; // convert to unboxed, signed int
    case B4: // make unboxed
      t = (sn == Unsigned) ? uint_t : sint_t;
      break;
    case B8: // make unboxed
      t = (sn == Unsigned) ? ulong_t : slong_t;
      break;
    }
    break;
  case FloatType(b):    t = float_t;  break; // make unboxed
  case DoubleType(b):   t = double_t; break; // make unboxed
  case EnumType(_,_,_): t = sint_t;   break; // convert to unboxed, signed int
  case Evar(_,_,_):
    t = sint_t;
    if (!unify(old_typ,t))
      if (!unify(old_typ,sInt_typ))
	return false;
    break;
  default:
    return false;
  }
  unchecked_cast(te,e,t);
  return true;
}


// Make sure that e has integral type; if it's boxed or a size that is
// smaller than an int, then promote it up to int.  Note that unsigned
// char or unsigned short will be promoted to signed int.  Otherwise,
// the sign is preserved.
bool integral_promote(tenv te, exp e) {
  typ old_typ = compress(e->topt->v);
  typ t;
  switch (old_typ) {
  case IntType(sn,sz,b):
    switch (sz) {
    case B1: t = sint_t; break; // convert to unboxed, signed int
    case B2: t = sint_t; break; // convert to unboxed, signed int
    case B4: t = (sn == Unsigned) ? uint_t  : sint_t;  break; // make unboxed
    case B8: t = (sn == Unsigned) ? ulong_t : slong_t; break; // make unboxed
    }
    break;
  case EnumType(_,_,_):
    t = sint_t;
    break; // convert to unboxed, signed int
  case Evar(_,_,_):
    t = sint_t;
    if (!unify(old_typ,t))
      if (!unify(old_typ,sInt_typ))
	return false;
    break;
  default:
    return false;
  }
  unchecked_cast(te,e,t);
  return true;
}
typ max_arithmetic_type(typ t1, typ t2) {
  switch ($(t1,t2)) {
  case $(DoubleType(_),_): fallthru;
  case $(_,DoubleType(_)): return DoubleType(Unboxed);
  case $(FloatType(_),_):  fallthru;
  case $(_,FloatType(_)):  return FloatType(Unboxed);
  case $(IntType(Unsigned,B8,_),_): fallthru;
  case $(_,IntType(Unsigned,B8,_)): return IntType(Unsigned,B8,Unboxed);
  case $(IntType(Signed,B8,_),_):   fallthru;
  case $(_,IntType(Signed,B8,_)):   return IntType(Signed,B8,Unboxed);
  case $(IntType(Unsigned,B4,_),_): fallthru;
  case $(_,IntType(Unsigned,B4,_)): return IntType(Unsigned,B4,Unboxed);
  default: return IntType(Signed,B4,Unboxed);
  }
}

// used to warn when a while, for, if, or do test contains an assignment
void check_contains_assign(exp e) {
  switch (e->r) {
  case AssignOp_e(_,null,_): warn(e->loc,"assignment in test"); break;
  default: break;
  }
}

// Note: The kind inference in check_valid_type updates the kinds in the tyvars.
void check_fndecl_valid_type(segment loc,tenv te,fndecl fd) {
  check_unique_tvars(loc,fd->tvs);
  check_valid_type(loc,te,fd->tvs,fd->ret_type);
  for (_ x = fd->args; x != null; x = x->tl)
    check_valid_type(loc,te,fd->tvs,x->hd[2]);
}

static $(Opt_t<var>,tqual,typ)@ fndecl2typ_f($(var,tqual,typ)@ x) {
  return &$((Opt_t<var>)&Opt(x[0]), x[1], x[2]);
}
typ fndecl2typ(fndecl fd) {
  return FnType(fd->tvs,
                fd->ret_type,
                List::map(fndecl2typ_f, fd->args),
                fd->varargs);
}

static $($(Opt_t<var>,tqual)@,typ)@ substitute_f1($(Opt_t<var>,tqual,typ)@ y) {
  return &$(&$(y[0],y[1]),y[2]);
}
static $(Opt_t<var>,tqual,typ)@ substitute_f2($($(Opt_t<var>,tqual)@,typ)@ w) {
  return &$(w[0][0],w[0][1],w[1]);
}
extern list<typ> substs(list<$(tvar,typ)@> inst, list<typ> ts);
typ substitute(list<$(tvar,typ)@> inst, typ t) {
  switch (compress(t)) {
  case VarType(v):
    // a tvar lookup, not a var lookup!
    try return List::assoc_cmp(tvar_cmp,inst,v);
    catch {case Not_found: return t;}
  case StructType(no,ts,sd):   return StructType(no,substs(inst,ts),sd);
  case EnumType(no,ts,ed):     return EnumType(no,substs(inst,ts),ed);
  case TypedefType(n,ts,topt): return TypedefType(n,substs(inst,ts),topt);
  case ArrayType(t1,tq,eopt):  return ArrayType(substitute(inst,t1),tq,eopt);
  case PointerType(t1,r,n,tq): 
    return PointerType(substitute(inst,t1),substitute(inst,r),n,tq);
  case FnType(vs,rtyp,args,varargs):
    for (let p = vs; p != null; p = p->tl)
      inst = &cons(&$(p->hd,VarType(p->hd)),inst);
    let $(qs,ts) = List::split(List::map(substitute_f1, args));
    _   ts2      = substs(inst,ts);
    _   args2    = List::map(substitute_f2, List::zip(qs,ts2));
    return FnType(vs,substitute(inst,rtyp), args2, varargs);
  case TupleType(tqts):
    let $(tqs,ts) = List::split(tqts);
    _   ts2       = substs(inst,ts);
    _   tqts2     = List::zip(tqs,ts2);
    return TupleType(tqts2);
  case Evar(_,r,_):
    if (r != null) return(substitute(inst,r->v));
    else return t;
  case RgnHandleType(rt): return RgnHandleType(substitute(inst,rt)); 

  case VoidType:       return t;
  case XenumType(_,_): return t;
  case IntType(_,_,_): return t;
  case FloatType(_):   return t;
  case DoubleType(_):  return t;
  case HeapRgnType:    return t;

  case UnionType:      return t;
  }
}
static list<typ> substs(list<$(tvar,typ)@> inst, list<typ> ts) {
  return List::map_c(substitute,inst,ts);
}

exp default_initializer(tenv te, typ t, segment loc) {
  exp e = new_exp(Const_e(Null_c),loc);

  switch (compress(t)) {
  case PointerType(_,_,_,_): break; // FIX: non-nullable is an error!
  case IntType(sg,B1,Unboxed):
    e->r = Const_e(Char_c(Signed,'\000'));
    break;
  case IntType(sg,sz,Unboxed):
    e->r = Const_e(Int_c(sg,0));
    if (sz != B4)
      e = new_exp(Cast_e(t,e),loc);
    break;
  case FloatType(Unboxed):
    e->r = Const_e(Float_c("0.0"));
    break;
  case DoubleType(Unboxed):
    e->r = Cast_e(t,new_exp(Const_e(Float_c("0.0")), loc));
    break;
/*
  case ArrayType*(t,eopt):
    if (eopt == null)
      e->r = ConstArray_e(null,&Opt(t));
    else {
      e->r =
	FnCall_e(&Exp(null,Var("new_array"),loc),null,
	&cons(eopt->v,&cons(default_initializer(te,t,loc),null)));
    }

  case StringType:  e->r = Const_e(String_c(""));
  case CharType:    e->r = Const_e(Char_c('\000'));
  case TupleType(ts):
    e->r = NewTuple_e(List::map_c(def_init,&$(te,loc),ts));
  case NamedType(p):
    let n  = p[0];
    let ts = p[1];
    // check for an opened type name
    if (!(Dict::member(te->structs,n)
	  || Dict::member(te->unions,n)
	  || Dict::member(te->abstracts,n))) {
      try {
	n = Dict::lookup(te->open_typs,n);
	p[0] = n;
      } catch {
      case Dict::Absent: terr2(loc,"unbound type name ",n);
      }
    }
    // if it's possibly null, we'e done otherwise...
    if (possibly_null(te,n)) return e;
    let sdopt = Dict::lookup_opt(te->structs,n);
    let udopt;
    if (sdopt != null) {
      // n is a struct -- return a struct of the default expressions for
      // each of the field types->
      let sd = sdopt->v[0];
      let inst = List::zip(sd->tvs,ts);
      let es =
	List::map_c(fun *(<field_name>Opt,exp)
		     f(*(*(tenv,segment),list<$(var,typ)@>) env,
		       *(field_name,capability,typ)               field){
		       return &$(null,def_init(env[0],subst(env[1],field[2])));
		    },
                   &$(&$(te,loc),inst),
		   sd->fields);
      e->r = NewStruct_e(n,&Opt(ts),es);
    } else if ((udopt = Dict::lookup_opt(te->unions,n)) != null) {
      // n is a union -- return the first field (and an expression of the
      // argument type if any->)
      let ud = udopt->v[0];
      if (ud->fields == null) {
	terr(loc,"Union has no fields!");
      } else {
	// get first field
	let field = ud->fields->hd[0];
	// get its type
	typ t = ud->fields->hd[1];
	// if it's void then the field doesn't carry a value
	if (t == VoidType)
	  e->r = NewUnion_e(n,&Opt(ts),field,null);
	else {
	  // otherwise construct a default value for that type
	  let inst = List::zip(ud->tvs,ts);
	  let e2 = &Opt(default_initializer(te,subst(inst,t),loc));
	  e->r = NewUnion_e(n,&Opt(ts),field,e2);
	}
      }
    } else
      terr(loc,"Abstract types require initializers->");
*/

  default:
    terr(loc, xprintf("declaration of type %s requires initializer",
		      typ2string(t)));
    break;
  }
  return e;
}

$(tvar,typ)@ make_inst_var(tvar tv) {
  return &$(tv, new_evar(UnresolvedKind));
}

// Check that the type is valid assuming that the free type variables
// are drawn from the given list.  Perform the following side-effects,
// which most of the compiler rightfully assumes have occurred:
// * expand typedefs
// * set pointers to declarations for StructType, EnumType, and XenumType
// * change relative type names to absolute type names
// * set the kind field of type variables.  We do just a tad of trivial 
//   inference: if the parse leaves the kind of a tyvar Unresolved, then
//   it's RgnKind if it appears in a region position, a BoxPKind if it appears
//   elsewhere, and a BoxPKind with a warning if it doesn't appear.
// Note: check_valid_type should only be called with types that should not have
//       RgnKind. Analogously, check_valid_rgn should only be called with types
//       that should have RgnKind.
// FIX: Right under a pointer, infer a type variable has kind MemPKind.
//      (Add a mutually recursive check_valid_mem_type.  This isn't too useful
//       until structdecls and enumdecls can have memkind type parameters.)
void check_valid_rgn(segment loc,tenv te,list<tvar> bound_vars, typ t){
  switch (compress(t)) {
  case HeapRgnType: return;
  case Evar(*k,null,i):
    switch(*k) {
    case UnresolvedKind: *k = RgnKind; return;
    case RgnKind: return;
    default: terr(loc,"This type should be a region."); return;
    }
  case VarType(pr):
    let &$(tv,k) = pr;
    for(; bound_vars != null; bound_vars = bound_vars->tl)
      if(String::zstrcmp(bound_vars->hd[0],tv)==0) {
	_ bk = bound_vars->hd[1];
	if((bk != RgnKind && bk != UnresolvedKind)
	   || (k != RgnKind && k != UnresolvedKind)) {
	  terr(loc, "Type variable used as region");
	  return;
	}
	pr[1] = bound_vars->hd[1] = RgnKind;
	return;
      }
    terr(loc,xprintf("unbound type variable %s",tv));
    return;
    
  default: terr(loc,"This type should be a region."); return;
  }
}
void check_valid_type(segment loc, tenv te, list<tvar> bound_vars, typ t) {
  switch (compress(t)) {
  case VoidType: break;
  case Evar(RgnKind,topt,i): fallthru;
  case HeapRgnType: 
    terr(loc,"This type should not be a region.");
    return;
  case Evar(*k,topt,i):
    if(*k==UnresolvedKind)
      *k = MemUKind;
    break;
  case VarType(pr):
    let &$(tv,k) = pr;
    for(; bound_vars != null; bound_vars = bound_vars->tl)
      if(String::zstrcmp(bound_vars->hd[0],tv)==0)
	switch ($(bound_vars->hd[1],k)) {
	case $(_,RgnKind): fallthru;
	case $(RgnKind,_): terr(loc,"Region variable used as type"); return;
	case $(UnresolvedKind,BoxPKind): fallthru;
	case $(UnresolvedKind,UnresolvedKind):
	  pr[1] = bound_vars->hd[1] = BoxPKind;
	  return;
	case $(UnresolvedKind,_):
	  terr(loc,"Wrong kind for type variable");
	  return;
	case $(bk,_):
	  if(k==UnresolvedKind || bk==k)
	    pr[1] = bk;
	  else
	    terr(loc,"Wrong kind for type variable");
	  return;
	}
    terr(loc,xprintf("unbound type variable %s",tv));
    return;
  case EnumType(tdnopt,targs,*edp):
    if (tdnopt == null) {
      terr(loc,"missing enum name");
      return;
    }
    _ tdn = tdnopt->v;
    if(*edp == null) {
      try *edp = lookup_enumdecl(te,loc,tdn);
      catch { case Dict::Absent: 
	terr(loc,xprintf("unbound type enum %s",qvar2string(tdn)));
      return;
      }
    } 
    enumdecl ed = **edp;
    // Make relative name absolute (or replace absolute name with itself)
    if (ed->name != null) // sanity check
      tdn[0] = ed->name->v[0];
    int lvs   = List::length(ed->tvs);
    int largs = List::length(targs);
    if (lvs != largs)
      terr(loc,xprintf("enum %s expects %d type arguments, not %d",
		       qvar2string(tdn),lvs,largs));
    // check that each of the type arguments is well-formed packable box type
    for (; targs != null; targs = targs->tl) {
      typ t1 = targs->hd;
      check_valid_type(loc,te,bound_vars,t1);
      if (typ_kind(t1) != BoxPKind) 
	terr(loc,xprintf("type %s is not a packable boxed type",
			 typ2string(t1)));
    }
    break;
  case XenumType(tdn,*xedp):
    if(*xedp == null) {
      try { 
	Opt_t<xenumdecl@> xed = lookup_xenumdecl(te,loc,tdn);
	if(xed == null) {
	  terr(loc,xprintf("unbound xenum %s",qvar2string(tdn)));
	  return;
	}
	*xedp = xed->v;
      } catch { case Dict::Absent:
	terr(loc,xprintf("unbound xenum %s",qvar2string(tdn)));
        return;
      }
    }
    xenumdecl xed = **xedp;
    // Make relative name absolute (or replace absolute name with itself)
    tdn[0] = xed->name[0];
    break;
  case PointerType(t1,rgn_typ,nullable,tq):
    // FIX: check that tqual is valid?
    check_valid_type(loc,te,bound_vars,t1);
    check_valid_rgn(loc,te,bound_vars,rgn_typ);
    break;
  case RgnHandleType(rgn_typ):
    check_valid_rgn(loc,te,bound_vars,rgn_typ);
    break;
  case IntType(_,_,_): break; 
  case FloatType(_):   break; 
  case DoubleType(_):  break; 
  case ArrayType(t1,tq,ak):
    // FIX: check that tqual is valid?
    check_valid_type(loc,te,bound_vars,t1);
    switch (ak) {
    case UntaggedArray: break; // skip
    case TaggedArray  : break; // skip
    case FixedArray(e):
      // FIX: should memoize the size so that we don't have to worry about
      // evaluating it during unification
      Evexp::eval_const_uint_exp(e); // check that e is of constant size
      break;
    }
    break;
  case FnType(btvs,tr,args,vararg):
    check_unique_tvars(loc,btvs);
    list<tvar> new_bound_vars = List::append(btvs,bound_vars);
    check_valid_type(loc,te,new_bound_vars,tr);
    for (; args != null; args = args->tl) {
      // FIX: should check that variables are unique and that tquals are okay
      check_valid_type(loc,te,new_bound_vars,args->hd[2]);
    }
    // if any kinds are still unresolved, warn and make them BoxPKind
    for(; btvs != null; btvs = btvs->tl)
      if(btvs->hd[1] == UnresolvedKind) {
	warn(loc,xprintf("Type variable %s unused, assuming boxed",
			 btvs->hd[0]));
	btvs->hd[1] = BoxPKind;
      }
    break;
  case TupleType(tq_ts):
    // FIX: check the tquals
    for (; tq_ts != null; tq_ts = tq_ts->tl)
      check_valid_type(loc,te,bound_vars,tq_ts->hd[1]);
    break;
  case StructType(tdnopt,targs,*sdp):
    if (tdnopt == null) {
      terr(loc,"missing struct name");
      return;
    }
    _ tdn = tdnopt->v;
    if(*sdp == null) {
      try *sdp = lookup_structdecl(te,loc,tdn);
      catch { case Dict::Absent:
	terr(loc,xprintf("unbound type struct %s",qvar2string(tdn)));
        return;
      }
    }
    structdecl sd = **sdp;
    // Make relative name absolute (or replace absolute name with itself)
    if (sd->name != null) // sanity check
      tdn[0] = sd->name->v[0];
    int lvs   = List::length(sd->tvs);
    int largs = List::length(targs);
    if (lvs != largs) 
      terr(loc,xprintf("struct %s expects %d type arguments but was given %d",
		       qvar2string(tdn),lvs,largs));
    // check that each of the type arguments is a well-formed packable box type
    for (; targs != null; targs = targs->tl) {
      typ t1 = targs->hd;
      check_valid_type(loc,te,bound_vars,t1);
      if (typ_kind(t1) != BoxPKind)
	terr(loc,xprintf("type %s is not a packable boxed type",
			 typ2string(t1)));
    }
    break;
  case TypedefType(tdn,targs,*toptp):
    // NB: since we called compress *toptp == null
    typedefdecl td;
    try td = lookup_typedefdecl(te,loc,tdn);
    catch { case Dict::Absent:
      terr(loc,xprintf("unbound typedef name %s",qvar2string(tdn)));
      return;
    }
    // Make relative name absolute (or replace absolute name with itself)
    tdn[0] = td->name[0];
    
    // FIX: allow typedefs over other kinds???
    for (list<typ> ts = targs; ts != null; ts = ts->tl) {
      check_valid_type(loc,te,bound_vars,ts->hd);
      if (typ_kind(ts->hd) != BoxPKind)
	terr(loc,xprintf("type %s is not a packable boxed type",
			 typ2string(ts->hd)));
    }
    list<$(tvar,typ)@> inst;
    try inst = List::zip(td->tvs,targs);
    catch { case List::List_mismatch:
      terr(loc,xprintf("typedef %s expects a different number of arguments",
		       qvar2string(tdn)));
      return;
    }
    typ new_typ = substitute(inst,td->defn);
    *toptp = &Opt(new_typ);
    break;
  case UnionType:
    terr(loc,"union type unsupported");
    break;
  } 
}

// Note: we expect lists to be very short.  Otherwise, a hashtable would
// be a better choice.
static void check_unique_unsorted<`a>(int (@cmp)(`a,`a), list<`a> vs,
				      segment loc, string msg) {
  for(; vs != null; vs = vs->tl)
    for(_ vs2 = vs->tl; vs2 != null; vs2 = vs2->tl)
      if(cmp(vs->hd, vs2->hd)== 0)
	terr(loc, msg);
}

void check_unique_vars(list<var> vs, segment loc, string msg) {
  check_unique_unsorted(String::zstrcmp,vs,loc,msg);
}

void check_unique_tvars(segment loc, list<tvar> tvs) {
  check_unique_unsorted(tvar_cmp,tvs,loc,"duplicate type variable");
}

// take a list of $(list<designator>,`a) things corresponding to a struct.
// ensure the struct is not abstract.
//  * check that each list<designator> has exactly one element which is a 
//    FieldName or is empty
//  * match up the correct member of sd->fields with the `a.  If the list
//    is empty, take the first unused field. ?????
//    Bang in the corresponding designator in the des list element
//  * ensure that each field is used exactly once.
// (This functionality was repeated in tcPat and tcExp and was annoying me.)
// FIX: Pass in a flag to allow multiple field names ??
list<$($(field_name,tqual,typ)@,`a)@>
resolve_struct_designators<`a>(seg_t loc,
			       list<$(list<designator>,`a)@> des, 
			       structdecl sd) {
  if(sd->fields == null)
    terr(loc, "inappropriate use of abstract struct");

  // grab all the fields and mark them unused
  list<$($(field_name,tqual,typ)@,bool)@> fields = null;
  for(_ sd_fields = sd->fields->v; sd_fields != null; sd_fields = sd_fields->tl)
    fields = &cons(&$(sd_fields->hd,false), fields);
  fields = imp_rev(fields);

  // match up each element of des
  list<$($(field_name,tqual,typ)@,`a)@> ans = null;
  for(; des != null; des = des->tl) {
    let &$(dl,a) = des->hd;
    if(dl == null) {
      // grab first unused
      _ fields2 = fields;
      for(; fields2 != null; fields2 = fields2->tl)
	if(!fields2->hd[1]) {
	  fields2->hd[1] = true;
	  des->hd[0] = &cons(FieldName(fields2->hd[0][0]), null);
	  ans = &cons(&$(fields2->hd[0],a), ans);
	  break;
	}
      if(fields2 == null)
	terr(loc, "too many arguments to struct");
    } else if(dl->tl != null)
      // we don't support multiple designators
      terr(loc, "multiple designators are not supported");
    else
      // find the right field based on the designator
      switch (dl->hd) {
      case ArrayElement(_): 
	terr(loc, "array designator used in argument to struct");
	break;
      case FieldName(v):
	_ fields2 = fields;
	for(; fields2 != null; fields2 = fields2->tl)
	  if(String::zstrcmp(v,fields2->hd[0][0]) == 0) {
	    if(fields2->hd[1])
	      terr(loc, 
		   xprintf("field %s has already been used as an argument", v));
	    fields2->hd[1] = true;
	    ans = &cons(&$(fields2->hd[0],a), ans);
	    break;
	  }
	if(fields2 == null)
	  terr(loc, xprintf("bad field designator %s", v));
	break;
      }
  }
  
  // make sure we used all the fields
  for(; fields != null; fields = fields->tl)
    if(!fields->hd[1]) {
      terr(loc, "too few arguments to struct");
      break;
    }

  return imp_rev(ans);
}
