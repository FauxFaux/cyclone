/* Utility functions for type checking */

#include "core.h"
#include "stdio.h"
#include "absyn.h"
#include "absynpp.h"
#include "set.h"
#include "position.h"
#include "tcenv.h"
#include "string.h"
#include "evexp.h"
#include "tcutil.h"
using Core;
using Stdio;
using List;
using Set;
using Position;
using Absyn;
using Absynpp;
using Tcenv;

namespace Tcutil;

xenum exn {TypeErr};

extern void unify_it(typ t1, typ t2);

void terr(seg_t loc, string s) {
  Position::post_error(Position::mk_err_elab(loc,s));
}

`a impos(string msg) {
  fprintf(stderr,"Error: %s\n",msg);
  fflush(stderr);
  throw TypeErr;
}

static string tvar2string(tvar tv) {
  return *(*tv)[0];
}

void print_tvars(list_t<tvar> tvs) {
  for (; tvs != null; tvs = tvs->tl) 
    fprintf(stderr,"%s ",tvar2string(tvs->hd));
  fprintf(stderr,"\n"); fflush(stderr);
}

static list_t<seg_t> warning_segs = null;
static list_t<stringptr>  warning_msgs = null;

// we batch warnings because we have to parse the file to determine
// line and column information.
void warn(seg_t sg, string msg) {
  warning_segs = &List(sg, warning_segs);
  // FIX:  cast to stringptr is necessary here...
  warning_msgs = &List((stringptr)new {msg},warning_msgs);
}
void flush_warnings() {
  if(warning_segs == null)
    return;
  fprintf(stderr,"***Warnings***\n");
  list_t<stringptr> seg_strs = strings_of_segments(warning_segs);
  warning_segs = null;
  warning_msgs = List::imp_rev(warning_msgs);
  while(warning_msgs != null) {
    fprintf(stderr,"%s: %s\n", *(seg_strs->hd), *(warning_msgs->hd));
    seg_strs     = seg_strs->tl;
    warning_msgs = warning_msgs->tl;
  }
  fprintf(stderr,"**************\n");
  fflush(stderr);
}

// set by by Tcenv::tc_init, used to reduce allocation and calls to Set::empty.
opt_t<set_t<var>> empty_var_set = null;

// compress out any evars or typedefs
typ compress(typ t) {
  switch (t) {
  case Evar(_,null,      _): 
    return t;
  case Evar(_,*t2opt_ref,_): // TRICKY
    typ t2 = compress((*t2opt_ref)->v);
    *t2opt_ref = &Opt(t2);
    return t2;
  case TypedefType(_,_,null): 
    return t;
  case TypedefType(_,_,*topt_ref):
    typ t2 = compress((*topt_ref)->v);
    *topt_ref = &Opt(t2);
    return t2;
  default:
    return t;
  }
}

// Only used during unification
static bool kind_leq(kind_t k1, kind_t k2) {
  return ((k1 == k2) || (k1 == BoxKind && k2 == MemKind));
}

// return the "least" kind of a type, according to the lattice above
static kind_t typ_kind(typ t) {
  switch (compress(t)) {
    // FIX: this isn't the least kind -- what if it gets constrained from
    // UnresolvedKind to something or from MemKind to BoxKind?
    // But unify_it calls this with an evar, so let it go for now.
  case Evar(k,topt,_):    return k; 

  case VarType(&$(_,k)):  return k;
  case VoidType:          return MemKind;
  case IntType(_,sz):     return (sz==B4) ? BoxKind : MemKind;
  case FloatType:         return MemKind;
  case DoubleType:        return MemKind;
  case FnType(_):         return MemKind;
  case RgnHandleType(_):  return BoxKind; 
  case HeapRgn:           return RgnKind;

  case EnumType(_,_,_):   return BoxKind;
  case XenumType(_,_):    return BoxKind; 
  case StructType(_,_,_): return MemKind;

  case PointerType(pinfo):
    switch (compress_conref(pinfo.bounds)->v) {
    case Eq_constr(Unknown_b): return MemKind;
    case Eq_constr(Upper_b(_)): return BoxKind;
    case No_constr: return MemKind; 
      // be conservative -- this may later be constrained with an Unknown_b
    case Forward_constr(_): 
      return impos("typ_kind: forward constraint in ptr bounds");
    }
  // Arrays are always of memkind
  case ArrayType(t,_,_): return MemKind;
  case TupleType(tqts):  return MemKind;
  case TypedefType(_,_,topt): 
    return impos(xprintf("typ_kind: typedef found: %s", typ2string(t)));
  case UnionType: return impos("union type");
  case AccessEff(_): return EffKind;
  case JoinEff(_): return EffKind;
  }
}

xenum exn {Unify};

// unify types t1 and t2, returning true iff the unification succeeds 
bool unify(typ t1, typ t2) {
  try {
    unify_it(t1,t2);
    return true;
  } catch {
  case Unify: return false;
  }
}

// see if evar occurs within t
static void occurslist(typ evar, list_t<typ> ts); // mutually recursive fns
static void occurs(typ evar, typ t) {
  switch (compress(t)) {
  case Evar(_,r,_):
    if (t == evar) throw Unify;
    else if (r != null) occurs(evar,r->v);
    break;
  case PointerType(pinfo): 
    occurs(evar,pinfo.elt_typ); occurs(evar,pinfo.rgn_typ); break;
  case ArrayType(t2,_,_): occurs(evar,t2); break;
  case FnType(FnInfo{tvs,eff,rt,args,varargs}): 
    // FIX: OK to ignore binding of type vars?
    if (eff != null) occurs(evar,eff->v);
    occurs(evar,rt);
    for(; args != null; args = args->tl)
      occurs(evar,(*args->hd)[2]);
    break;
  case TupleType(args):
    for(; args != null; args = args->tl)
      occurs(evar,(*args->hd)[1]);
    break;
  case RgnHandleType(rt): occurs(evar,rt); break;
  case TypedefType(_,ts,topt): fallthru(ts);
  case EnumType(_,ts,_):       fallthru(ts);
  case StructType(_,ts,_):     occurslist(evar,ts); break;
  case AccessEff(t0): occurs(evar,t0); break;
  case JoinEff(ts): occurslist(evar,ts); break;
  default: break;
  }
}
static void occurslist(typ evar, list_t<typ> ts) {
  for (; ts != null; ts = ts->tl)
    occurs(evar,ts->hd);
}

// unify two lists of types
static void unify_list(list_t<typ> t1, list_t<typ> t2) {
  try List::iter2(unify_it,t1,t2);
  catch {case List_mismatch: throw Unify;}
}

// unify two type qualifiers -- throws Unify unless they are the same
static void unify_tqual(tqual tq1, tqual tq2) {
  if ((tq1->q_const != tq2->q_const)    
      || (tq1->q_volatile != tq2->q_volatile) 
      || (tq1->q_restrict != tq2->q_restrict))
    throw Unify;
}

bool equal_tqual(tqual tq1, tqual tq2) {
  return ((tq1->q_const == tq2->q_const) 
	  && (tq1->q_volatile == tq2->q_volatile) 
	  && (tq1->q_restrict == tq2->q_restrict));
}

// compress a conref
conref<`a> compress_conref(conref<`a> x) {
  switch (x->v) {
  case No_constr:    return x;
  case Eq_constr(_): return x;
  case Forward_constr(y):
    let z = compress_conref(y);
    x->v = z->v;
    return z;
  }
}

`a conref_val(conref<`a> x) {
  switch (compress_conref(x)->v) {
  case Eq_constr(v): return v;
  default:           return impos("conref_val");
  }
}

// unify two constraint refs
static void unify_it_conrefs(int cmp(`a,`a), conref<`a> x, conref<`a> y) {
  x = compress_conref(x);
  y = compress_conref(y);
  if (x == y) return;
  switch (x->v) {
  case No_constr: x->v = Forward_constr(y); return;
  case Forward_constr(_): throw impos("unify_conref: forward after compress");
  case Eq_constr(xv):
    switch (y->v) {
    case No_constr: y->v = x->v; return;
    case Forward_constr(_):
      throw impos("unify_confref: forward after compress(2)");
    case Eq_constr(yv):
      if (cmp(xv,yv) != 0) throw Unify;
      return;
    }
  }
}

static bool unify_conrefs(int cmp(`a,`a), conref<`a> x, conref<`a> y) {
  try {
    unify_it_conrefs(cmp,x,y);
    return true;
  } catch { case Unify: return false; }
}

static int boundscmp(bounds_t b1, bounds_t b2) {
  switch ($(b1,b2)) {
  case $(Unknown_b,Unknown_b): return 0;
  case $(Unknown_b,_): return -1;
  case $(_,Unknown_b): return 1;
  case $(Upper_b(e1),Upper_b(e2)): 
    int i1 = Evexp::eval_const_uint_exp(e1);
    int i2 = Evexp::eval_const_uint_exp(e2);
    if (i1 == i2) return 0;
    if (i1 < i2) return -1;
    return 1;
  }
}

// flattens out nested join effects -- this has a side effect 
// on the actual type
static void normalize_effect(typ e) {
  e = compress(e);
  switch (e) {
  case JoinEff(*es):
    bool nested_join = false;
    for (_ effs = *es; effs != null; effs = effs->tl) {
      let eff = effs->hd;
      normalize_effect(eff);
      switch (compress(eff)) {
      case JoinEff(_): nested_join = true; break;
      default: break;
      }
    }
    if (!nested_join) return;
    list_t<typ> effects = null;
    for (_ effs = *es; effs != null; effs = effs->tl) {
      switch (compress(effs->hd)) {
      case JoinEff(nested_effs): 
        effects = List::revappend(nested_effs,effects);
        break;
      case e: effects = &List(e,effects); break;
      }
    }
    *es = List::imp_rev(effects);
    break;
  default: break;
  }
}

// Tries to break an effect into an effect evar and the rest of the
// effect.  This fails unless the effect is either JoinEff(ev::rest)
// where ev is an unconstrained effect evar, or else the effect is
// an unconstrained evar.
static $(typ, list_t<typ>)* get_effect_evar(typ t) {
  switch (compress(t)) {
  case JoinEff(&List{.hd=ef1,.tl=ef2}):
    switch (compress(ef1)) {
    case Evar(_,_,_): return &$(ef1,ef2);
    default: return null;
    }
  case Evar(*k,*p,_): 
    if (*k == UnresolvedKind) *k = EffKind;
    if (*k != EffKind) impos("effect evar has wrong kind");
    return &$(t,null);
  default: return null;
  }
}

// Returns true if the region r is in the effect e or else r is the
// heap region.  If constrain is true, this might cause region or
// effect evars to become constrained.
bool region_in_effect(bool constrain, typ r, typ e) {
  r = compress(r);
  if (r == HeapRgn) return true;
  switch (compress(e)) {
  case AccessEff(r2): 
    // note:  might constrain a region variable unnecessarily
    if (constrain) return unify(r,r2);
    compress(r2);
    if (r == r2) return true;
    switch ($(r, r2)) {
    case $(VarType(tv1), VarType(tv2)): return (tvar_cmp(tv1,tv2) == 0);
    default: return false;
    }
  case JoinEff(es): 
    for (; es != null; es = es->tl) 
      if (region_in_effect(constrain, r, es->hd)) return true;
    return false;
  case Evar(*k,*p,_): 
    if (!constrain) return false;
    // we found a non-canonical evar -- we can grow it to include r
    // but this may cause problems later on with other constraints.
    let ev = new_evar(EffKind);
    let new_typ = JoinEff(&List{ev,&List{AccessEff(r),null}});
    *p = &Opt(new_typ);
    return true;
  default: return false;
  }
}

// Returns true if the type variable v is in the effect e.
// If constrain is true, this might cause effect evars to become constrained.
static bool variable_in_effect(bool constrain, tvar v, typ e) {
  e = compress(e);
  switch (e) {
  case VarType(v2): return (tvar_cmp(v, v2) == 0);
  case JoinEff(es):
    for (; es != null; es = es->tl) 
      if (variable_in_effect(constrain, v, es->hd)) return true;
    return false;
  case Evar(_,*p,_):
    // we found a non-canonical evar -- we can grow it to include v
    // but this may cause problems later on with other constraints.
    let ev = new_evar(EffKind);
    let new_typ = JoinEff(&List{ev,&List{VarType(v),null}});
    *p = &Opt(new_typ);
    return true;
  default: return false;
  }
}

// Returns true if the effect evar ev is in the effect e.
static bool evar_in_effect(typ evar, typ e) {
  e = compress(e);
  switch (e) {
  case JoinEff(es):
    for (; es != null; es = es->tl) 
      if (evar_in_effect(evar, es->hd)) return true;
    return false;
  case Evar(_,_,_): return (evar == e);
  default: return false;
  }
}


// Returns true when e1 is a sub-effect of e2 -- this isn't very
// efficient and can constrain both effect and region evars in
// unpredictable ways (though it tries hard not to).  
// When set_to_empty is true, evars in e1 that do not occur in (or
// cannot easily be made to occur in) e2 are constrained to the 
// empty effect (or HeapRgn for region evars).  This is the "right" 
// thing for when a function call needs to constrain the effect to 
// an upper bound.  When set_to_empty is false, we instantiate 
// unconstrained evars in e1 to be e2.
bool subset_effect(bool set_to_empty, typ e1, typ e2) {
  // if e2 is of the form JoinEff(ev::rest) where ev is an effect evar,
  // then we can instantiate ev to JoinEff(ev'::e1) where ev' is fresh
  switch (get_effect_evar(e2)) {
  case &$(ev1,rest): 
    let ev = new_evar(EffKind);
    let new_typ = JoinEff(&List{ev,&List{e1,null}});
    return unify(ev1, new_typ);
  default: break;
  }
  switch (compress(e1)) {
  case JoinEff(es): 
    for (; es != null; es = es->tl) {
      if (subset_effect(set_to_empty,es->hd,e2)) continue;
      return false;
    }
    return true;
  case AccessEff(r): 
    // Try checking if the region is in the effect without performing
    // any unification first and only if this fails do we actually
    // go in and try to unify something.  It's not clear whether it's
    // best to just pin the region to HeapRgn or try to unify it with
    // some region already in the effect e2.  I'm opting for doing the
    // latter first, and then the former.
    return (region_in_effect(false,r,e2) || region_in_effect(true,r,e2) ||
            unify(r,HeapRgn));
  case VarType(v): 
    // Same idea with effect variables
    return variable_in_effect(false,v,e2) || variable_in_effect(true,v,e2);
  case Evar(_,*p,_): 
    if (!evar_in_effect(e1,e2)) 
      // We can set the evar to be any subset of e2.  When set_to_empty
      // is true, we set it to the empty effect, and otherwise set it to
      // e2.  Setting it to the empty effect is the right thing to do at
      // a function call when the instatiation and call occur simultaneously. 
      // For other situations, it's not clear what is the right thing to do.
      if (set_to_empty)
        *p = &Opt(JoinEff(null));
      else 
        *p = &Opt(e2);

    return true;
  default: 
    return impos(xprintf("subset_effect: bad effect: %s",typ2string(e1)));
  }
}

// "unify" two effects -- a total and complete HACK
// This all relies crucially upon the fact that either the algorithm
// for determining default effects, or the user puts in a (unique)
// effect variable on each function type at the beginning of the
// function (a la Tofte & Talpin's e.phi notation.)  
//
//  We first "normalize" the effect so that it is flattened but preserves
//  the original order.  Then there are two cases to consider:
//    * When the two effects are of the form JoinEff(ev1::rest1) and 
//      JoinEff(ev2::rest2), where ev1 and ev2 are unconstrained effect 
//      Evars, then we create a new evar ev, and set both ev1 and ev2 to 
//      point to JoinEff(ev::rest1@rest2).  This way, when the types are 
//      normalized again, we end up with each effect including the other plus 
//      some additional slack.  Note that we need to check that ev1 doesn't
//      occur in rest2 and that ev2 doesn't occur in rest1.  This can
//      actually happen if an evar shows up twice in an effect.
//      FIX:  should get rid of duplicates in effects but this might be
//      expensive.
//    * When the two effects are otherwise, we simply check that one
//      effect is a "subset" of the other.  If necessary, we instantiate
//      region or effect evars to force the subset relation.  This may 
//      cause region or effect evars to become pinned down in an undesirable 
//       way...  But the situation should be rare, and if it happens, users
//       should fall back on explicit typing.
//
// What we should really do:  generate some set equalities and hold
// on to them.  Then try to simplify and solve them later on after
// things have become more constrained.  
static bool unify_effect(typ e1, typ e2) {
  e1 = compress(e1);
  e2 = compress(e2);
  normalize_effect(e1);
  normalize_effect(e2);
  switch ($(get_effect_evar(e1),get_effect_evar(e2))) {
  case $(&$(ev1,rest1), &$(ev2,rest2)):
    // The fast path:  both effects are of the form JoinEff(ev::rest)
    let ev = new_evar(EffKind);
    let new_typ = JoinEff(&List{ev,List::append(rest1,rest2)});
    // the calls to unify here do the occurs check and also set the evars
    // to point to the new "union" effect
    return unify(ev1, new_typ) && unify(ev2, new_typ);
  default: 
    // The slow path -- see above.  we drive the slack in effects so
    // that the two effects will start to look like one another...
    return subset_effect(false, e1, e2) && subset_effect(false, e2, e1); 
  }
}

// the real work of unification
void unify_it(typ t1, typ t2) {
  t1 = compress(t1);
  t2 = compress(t2);
  if (t1 == t2) return;
  switch (t1) {
  case Evar(kind1,*ref1_ref,_):
    // check that the evar doesn't occur in t2
    occurs(t1,t2);
    _ kind2 = typ_kind(t2);
    // we can constrain the Evar to be equal to t2 only when the kind of the
    // evar is greater than or equal to the kind of t2 or t2 is an evar that
    // we can constrain to be equal to t1.
    if (kind_leq(kind2,kind1) || kind1 == UnresolvedKind) {
      *ref1_ref = &Opt(t2);
      return;
    } else {
      switch (t2) {
      case Evar(_,*ref2_ref,_): 
        if (kind_leq(kind1,kind2) || kind2 == UnresolvedKind) {
          *ref2_ref = &Opt(t1); return;
        }
        fallthru;
      default: throw Unify;
      }
    }
  default: break; 
  }
  // t1 is not an evar

    // in what follows, we throw Unify unless we explicitly return.
  switch ($(t2,t1)) {

  case $(Evar(_,_,_),_): // t2 is an evar, t1 is not, swap and try again
    unify_it(t2,t1);
    return;

  case $(VoidType,VoidType): return;

  case $(VarType(&$(x2,k2)),VarType(&$(x1,k1))):
    // kinds should already be resolved, otherwise we could "unify"
    // UnresolvedKind with something else???
    if(k2 == k1 && String::zstrptrcmp(x2,x1) == 0) return;
    break;

  case $(StructType(nopt2,ts2,sd2), StructType(nopt1,ts1,sd1)): 
    // FIX: equivalent and more efficient to pointer-compare sds
    if ((nopt1 != null && nopt2 != null
	 && qvar_cmp((qvar)nopt1,(qvar)nopt2) == 0) 
	|| (nopt1 == null && nopt2 == null)) {
      unify_list(ts1,ts2);
      return;
    }
    break;

  case $(EnumType(nopt2,ts2,edp2), EnumType(nopt1,ts1,edp1)):
    if (*edp2 == *edp1) {
      unify_list(ts1,ts2);
      return;
    }
    break;

  case $(XenumType(n2,xedp2),XenumType(n1,xedp1)):
    if(*xedp2 == *xedp1)
      return;
    break;

  case $(PointerType(PtrInfo{.elt_typ=t2a,.rgn_typ=rgn2,
			     .nullable=null2a,.tq=tqual2a,.bounds=b2}),
	 PointerType(PtrInfo{.elt_typ=t1a,.rgn_typ=rgn1,
			     .nullable=null1a,.tq=tqual1a,.bounds=b1})):
    unify_it(t1a,t2a);
    unify_it(rgn2,rgn1); // the whole reason regions are "types"
    unify_tqual(tqual1a,tqual2a);
    unify_it_conrefs(boundscmp,b1,b2);
    // There's no need to force the nullable's to be the same when
    // the bounds are ?.
    switch (compress_conref(b1)->v) {
    case Eq_constr(Unknown_b): return;
    default: break;
    }
    unify_it_conrefs(intcmp,null1a,null2a);
    return;

  case $(IntType(sn2,sz2), IntType(sn1,sz1)):
    if ((sn1 == sn2) && (sz1 == sz2)) return;
    break;

  case $(FloatType,    FloatType):    return;
  case $(DoubleType,   DoubleType):   return;

  case $(ArrayType(t2a,tq2a,e1), ArrayType(t1a,tq1a,e2)):
    unify_it(t1a,t2a);
    unify_tqual(tq1a,tq2a);
    if (Evexp::eval_const_uint_exp(e1) == Evexp::eval_const_uint_exp(e2)) 
      return;
    break;

  case $(FnType(FnInfo{tvs2,eff2,rt2,args2,vararg2}), 
         FnType(FnInfo{tvs1,eff1,rt1,args1,vararg1})):
    list_t<$(tvar,typ)@> inst = null;
    while (tvs1 != null) {
      if (tvs2 == null) break;
      inst = &List(&$(tvs2->hd,VarType(tvs1->hd)),inst);
      tvs1 = tvs1->tl;
      tvs2 = tvs2->tl;
    }
    if (tvs2 != null) break;
    if (inst != null) {
      unify_it(FnType(FnInfo{null,eff1,rt1,args1,vararg1}),
	       substitute(inst,FnType(FnInfo{null,eff2,rt2,args2,vararg2})));
      return;
    } 
    unify_it(rt1,rt2);
    for (; args1!=null && args2!=null; args1 = args1->tl, args2 = args2->tl) {
      unify_tqual((*args1->hd)[1],(*args2->hd)[1]);
      unify_it((*args1->hd)[2],(*args2->hd)[2]);
    }
    if ((args1 != null) || (args2 != null)) break;
    if (vararg1 != vararg2) break;
    // It's important to unify the effects after the arguments and result
    // so that the effects are pinned down as much as possible.
    if ((eff1 == null && eff2 != null) || (eff1 != null) && (eff2 == null))
      break;
    if (!unify_effect(eff1->v,eff2->v)) break;
    return;

  case $(TupleType(ts2), TupleType(ts1)):
    for (; ts1 != null && ts2 != null; ts1 = ts1->tl, ts2 = ts2->tl) {
      unify_tqual((*ts1->hd)[0],(*ts2->hd)[0]);
      unify_it((*ts1->hd)[1],(*ts2->hd)[1]);
    }
    if (ts1 == null && ts2 == null) return;
    break;

  case $(HeapRgn, HeapRgn): return;
  case $(RgnHandleType(rt1),RgnHandleType(rt2)):
    unify_it(rt1,rt2);
    return;
  case $(JoinEff(_), _)  : fallthru;
  case $(_, JoinEff(_))  : fallthru;
  case $(AccessEff(_), _): fallthru;
  case $(_, AccessEff(_)): 
    if (unify_effect(t1,t2)) return;
    else break;
  default: break;
  }
  throw Unify;
}

bool is_arithmetic_type(typ t) {
  switch (compress(t)) {
  case IntType(_,_): return true;
  case FloatType:    return true;
  case DoubleType:   return true;
  default:           return false;
  }
}

// we're about to convert a value of type t1 to type t2 (both arithmetic types)
// return true if we will potentially loose precision
bool will_lose_precision(typ t1, typ t2) {
  t1 = compress(t1);
  t2 = compress(t2);
  switch ($(t1,t2)) {
  case $(DoubleType,   FloatType):       return true;
  case $(DoubleType,   IntType(_,_)):    return true;
  case $(FloatType,    IntType(_,_)):    return true;
  case $(IntType(_,B8), IntType(_,B8)):  return false;
  case $(IntType(_,B8), _):              return true; // see prev case
  case $(IntType(_,B4), FloatType):      return true;
  case $(IntType(_,B4), IntType(_,B2)):  return true;
  case $(IntType(_,B4), IntType(_,B1)):  return true;
  case $(IntType(_,B2), IntType(_,B1)):  return true;
  default: return false;
  }
}

// coerce the list e so that each element has type t -- used in arrays and
// conditionals 
bool coerce_list(tenv te, typ t, list_t<exp> es) {
  // find the biggest arithmetic type (if any) for the list and determine
  // if all of the elements are boxed.
  opt_t<typ> max_arith_type = null;
  for (list_t<exp> el = es; el != null; el = el->tl) {
    typ t1 = compress(el->hd->topt->v);
    if (is_arithmetic_type(t1)) 
      if (max_arith_type == null || will_lose_precision(t1,max_arith_type->v))
	max_arith_type = &Opt(t1);
  }
  // unify the max arithmetic type with the result type t
  if (max_arith_type != null)
    if (!unify(t,max_arith_type->v))
      return false;
  // now coerce each expression to the type t as if by assignment
  for (list_t<exp> el = es; el != null; el = el->tl)
    if (!coerce_assign(te,el->hd,t)) {
      terr(el->hd->loc,xprintf("type mismatch: expecting %s but found %s",
			       typ2string(t),typ2string(el->hd->topt->v)));
      return false;
    }
  return true;
}

// coerce e to have type "bool" (int) -- used in conditionals 
bool coerce_to_bool(tenv te, exp e) {
  if (!coerce_sint_typ(te,e)) {
    switch (compress(e->topt->v)) {
    case PointerType(_): unchecked_cast(te,e,uint_t); break;
    default: return false;
    }
  }
  return true;
}

bool is_integral_type(typ t) {
  switch (compress(t)) {
  case IntType(_,_): return true;
  default: return false;
  }
}

// coerce e to have type unsigned int -- used in subscript
bool coerce_uint_typ(tenv te, exp e) {
  if (unify(e->topt->v,uint_t)) 
    return true;
  // try arithmetic conversions -- we only allow integral values
  if (is_integral_type(e->topt->v)) {
    if (will_lose_precision(e->topt->v,uint_t))
      warn(e->loc,"integral size mismatch; conversion supplied");
    unchecked_cast(te,e,uint_t);
    return true;
  }
  return false;
}

// coerce e to have type [signed] int -- used in coercions to "bool"
bool coerce_sint_typ(tenv te, exp e) {
  if (unify(e->topt->v,sint_t)) 
    return true;
  // try arithmetic conversions -- we only allow integral values
  if (is_integral_type(e->topt->v)) {
    if (will_lose_precision(e->topt->v,sint_t))
      warn(e->loc,"integral size mismatch; conversion supplied");
    unchecked_cast(te,e,sint_t);
    return true;
  }
  return false;
}

// Can t1 be (implicitly) cast to t2? Assumes types are well-formed 
bool silent_castable(tenv te, seg_t loc, typ t1, typ t2) {
  t1 = compress(t1);
  t2 = compress(t2);
  switch ($(t1,t2)) {
 
  case $(PointerType(pinfo_a), PointerType(pinfo_b)):
    bool okay = true;
    // can coerce @ to *
    if (!unify_conrefs(intcmp,pinfo_a.nullable,pinfo_b.nullable)) {
      switch(compress_conref(pinfo_a.nullable)->v) {
      case Eq_constr(b): okay = !b; break;
      default: throw impos("silent_castable conref not eq");
      }
    }
    // can coerce *{e} to ? and *{e1} to *{e2} when e2 <= e1
    if (!unify_conrefs(boundscmp,pinfo_a.bounds,pinfo_b.bounds)) {
      switch ($(compress_conref(pinfo_a.bounds)->v, 
		compress_conref(pinfo_b.bounds)->v)) {
      case $(Eq_constr(Upper_b(_)),Eq_constr(Unknown_b)): 
	// Can cast to ? regardless of nullable
	okay = true; break;
	// JGM:  the following would be legal, but perhaps we don't
	// want to allow it to make porting easier -- I'm afraid
	// that writing t *x = y, where y is an array will go through
	// too easily...
	//case $(Eq_constr(Upper_b(e1)),Eq_constr(Upper_b(e2))):
	//okay = okay && (Evexp::eval_const_uint_exp(e1) >= 
	//		Evexp::eval_const_uint_exp(e2)); 
	//break;
      case $(Eq_constr(Unknown_b),Eq_constr(Unknown_b)):
	// Can cast ? to ? regardless of nullable
	okay = true; break;
      default:
	okay = false; break;
      }
    }
    return (okay && unify(pinfo_a.elt_typ,pinfo_b.elt_typ) &&
	    unify(pinfo_a.rgn_typ,pinfo_b.rgn_typ) &&
	    (!pinfo_a.tq->q_const || pinfo_b.tq->q_const));

  case $(ArrayType(t1a,tq1a,e1),ArrayType(t2a,tq2a,e2)):
    bool okay;
    okay = (Evexp::eval_const_uint_exp(e1)>=Evexp::eval_const_uint_exp(e2));
    return (okay && unify(t1a,t2a) && (!tq1a->q_const || tq2a->q_const));

  default: return unify(t1,t2);
  }
}

// coerce e to have type t -- used in function call and explicit fallthru
bool coerce_arg(tenv te, exp e, typ t2) {
  typ t1 = compress(e->topt->v);
  // see if types immediately match
  if (unify(t1,t2)) return true;
  // try arithmetic conversions
  if (is_arithmetic_type(t1) && is_arithmetic_type(t2)) {
    // issue a warning if we lose precision
    if (will_lose_precision(t1,t2))
      warn(e->loc,"integral size mismatch; conversion supplied");
    unchecked_cast(te,e,t2);
    return true;
  } else if (silent_castable(te,e->loc,t1,t2)) {
    unchecked_cast(te,e,t2);
    return true;
  } else if (castable(te,e->loc,t1,t2)) {
    unchecked_cast(te,e,t2);
    warn(e->loc,xprintf("implicit cast from %s to %s",typ2string(t1),
			typ2string(t2)));
    return true;
  } else return false;
}

// coerce e to have type t -- used in assignment operations.  Neither
// gcc nor VC++ issue warnings for losing precision here, but I think
// it may be appropriate.
bool coerce_assign(tenv te, exp e, typ t) {
  return coerce_arg(te,e,t);
}

static bool any_promote(tenv te, exp e) {
  typ old_typ = compress(e->topt->v);
  typ t;
  switch (old_typ) {
  case IntType(sn,sz):
    switch (sz) {
    case B1: t = sint_t; break; // convert to unboxed, signed int
    case B2: t = sint_t; break; // convert to unboxed, signed int
    case B4: t = (sn == Unsigned) ? uint_t : sint_t; break;   // make unboxed
    case B8: t = (sn == Unsigned) ? ulong_t : slong_t; break; // make unboxed
    }
    break;
  case FloatType:  t = float_t;  break; // make unboxed
  case DoubleType: t = double_t; break; // make unboxed
  default: return false;
  }
  unchecked_cast(te,e,t);
  return true;
}

// Convert e so that it has type t, possibly by casting t.  This is
// used in routines like function call or assignment where we may have
// to promote an integral type.
// FIX: THIS IS NOT RIGHT.
bool coerce_use(tenv te, exp e, typ t2) {
  typ    t1 = compress(e->topt->v);
  if (unify(t1,t2)) 
    return true;
  // unification failed, try promoting
  any_promote(te,e);
  if (unify(e->topt->v,t2)) 
    return true;
  else if (silent_castable(te,e->loc,t1,t2)) {
    unchecked_cast(te,e,t2);
    return true;
  } else if (castable(te,e->loc,t1,t2)) {
    unchecked_cast(te,e,t2);
    warn(e->loc,xprintf("implicit cast from %s to %s",typ2string(t1),
		       typ2string(t2)));
    return true;
  } else 
    return false;
}

bool coerceable(typ t) {
  switch (compress(t)) {
  case IntType(_,_): return true;
  case FloatType:    return true;
  case DoubleType:   return true;
  default:           return false;
  }
}

// Flatten a type into a list of type qualifiers and types for
// use in subtype comparison.
// FIX:  we should recursively flatten tuple and struct types here,
// but doing so is tricky because we have to get the padding and
// alignment right.  This seems to be particularly weird on the
// x86 -- I need to find precise documentation on it before we 
// do this.
static $(tqual,typ)@ flatten_typ_f(list_t<$(tvar,typ)@> inst,
                                   $(field_name,tqual,typ)@ x) {
  return &$((*x)[1],substitute(inst,(*x)[2]));
}
static list_t<$(tqual,typ)@> flatten_typ(tenv te,typ t1) {
  t1 = compress(t1);
  switch (t1) {
  case VoidType:       return null;
  case TupleType(tqs): return tqs; // FIX: recursively flatten here
  case StructType(tdnopt,ts,sdp):
    _ sd   = *sdp;
    _ n    = *tdnopt;
    _ inst = List::zip(sd->tvs,ts);
    if (sd->fields == null) return &List(&$(empty_tqual(),t1),null);
    // FIX: recursively flatten here
    return List::map_c(flatten_typ_f,inst,sd->fields->v);
  default: return &List(&$(empty_tqual(),t1),null);
  }
}

// FIX: the plan is, once we have a context that lets us assume t1 <= t2
// for recursive types, then to do deep subtyping.  
// FIX: allow casting one function type to another -- especially, allow
// effects to grow...
static bool ptrsubtype(tenv te, list_t<$(typ,typ)@> assume, typ t1, typ t2);
static bool subtype(tenv te, list_t<$(typ,typ)@> assume, typ t1, typ t2) {
  if (unify(t1,t2)) return true;
  for (_ a = assume; a != null; a = a->tl)
    if (unify(t1,(*a->hd)[0]) && unify(t2,(*a->hd)[1])) 
      return true;
  t1 = compress(t1);
  t2 = compress(t2);
  switch ($(t1,t2)) {
    case $(PointerType(PtrInfo{t_a, rt_a, null_a, q_a, b_a}),
	   PointerType(PtrInfo{t_b, rt_b, null_b, q_b, b_b})):
    // if t1 is const then t2 must be const
    if (q_a->q_const && !q_b->q_const) 
      return false;
    // if t1 is * then t2 must be *
    if (!unify_conrefs(intcmp,null_a,null_b) 
	&& conref_val(null_a) && !conref_val(null_b)) 
      return false;
    // if rt_a is not the heap, then rt_b must be the same (can relax this
    // later to a more general "outlives" relationship)
    switch (rt_a) {
    case HeapRgn: break;
    default: unify(rt_a,rt_b); break;
    }
    // need to check that the bounds match up
    if (!unify_conrefs(boundscmp,b_a,b_b)) {
      switch ($(conref_val(b_a),conref_val(b_b))) {
      case $(Upper_b(_), Unknown_b): break;
      case $(Upper_b(e1), Upper_b(e2)): 
	if (Evexp::eval_const_uint_exp(e1) < Evexp::eval_const_uint_exp(e2))
	  return false;
	break;
      default: return false;
      }
    }
    return ptrsubtype(te, &List(&$(t1,t2),assume), t_a, t_b);
  default: return false;
  }
}

// is t1* <= t2*?
//   we flatten t1 and t2 into structurally equivalent tuple types 
//   (and thus ignore field names, associativity of nested tuples and
//   structs, etc.) and then check that t1 is a width extension of t2 
//   and for each field, either (a) both t1 and t2 have qualifier "const"
//   and the t1 field is a subtype of the t2 field, or (b) t1 = t2.
static bool ptrsubtype(tenv te, list_t<$(typ,typ)@> assume, typ t1, typ t2) {
  list_t<$(tqual,typ)@> tqs1 = flatten_typ(te,t1);
  list_t<$(tqual,typ)@> tqs2 = flatten_typ(te,t2);
  for (; tqs2 != null; tqs2 = tqs2->tl, tqs1 = tqs1->tl) {
    if (tqs1 == null) return false;
    let &$(tq1,t1a) = tqs1->hd;
    let &$(tq2,t2a) = tqs2->hd;
    if (tq2->q_const && subtype(te,assume,t1a,t2a)) continue;
    else if (unify(t1a,t2a)) continue;
    else return false;
  }
  return true;
}

// Can t1 be cast to t2?  Assumes that the types are well-formed.
bool castable(tenv te, seg_t loc, typ t1, typ t2) {
  t1 = compress(t1);
  t2 = compress(t2);
  if(unify(t1,t2))
    return true;
  switch (t1) {
  case EnumType(name_opt,ts,ed):
    // can cast an enum to an int -- extracts the tag
    // FIX:  when the enum carries a value?!?
    return (coerceable(t2));
  case PointerType(PtrInfo{t_a,rt_a,null_a,q_a,b_a}):
    // can cast t* to t@ and vice versa.  
    // can cast a non-const pointer to a const pointer.  
    // can cast a t heap pointer to a t[],t[1], or t[?]
    // can cast a pointer in the heap to a pointer to some other region
    switch (t2) {
    case PointerType(PtrInfo{t_b,rt_b,null_b,q_b,b_b}):
      _ assump = &List(&$(t1,t2),null);
      _ ptrsub =
	ptrsubtype(te,assump,t_a,t_b) && (!q_a->q_const || q_b->q_const);
      bool bounds_ok = unify_conrefs(boundscmp,b_a,b_b);
      if (!bounds_ok) {
	switch ($(conref_val(b_a),conref_val(b_b))) {
	  // We allow casts of any form as long as we can't statically
	  // tell that the bounds will be violated.
	case $(Upper_b(e_a),Upper_b(e_b)): 
	  if (Evexp::eval_const_uint_exp(e_a) >= 
	      Evexp::eval_const_uint_exp(e_b)) 
	    bounds_ok = true;
	  break;
	default: bounds_ok = true; break;
	}
      }
      return bounds_ok && ptrsub && (rt_a == HeapRgn || unify(rt_a,rt_b));
    default: return false;
    }
  case ArrayType(t1a,tq1a,e1):
    switch (t2) {
    case ArrayType(t2a,tq2a,e2):
      bool okay;
      okay=(Evexp::eval_const_uint_exp(e1) >= Evexp::eval_const_uint_exp(e2));
      return (okay && unify(t1a,t2a) && (!tq1a->q_const || tq2a->q_const));
    default: return false;
    }
  // can cast a numeric type or bool to any numeric type
  case IntType(_,_): fallthru;
  case FloatType :  fallthru;
  case DoubleType:  return coerceable(t2);
  default: return false;
  }
}

// Replace e by a cast of e to t.  The caller must ensure that the cast is safe.
void unchecked_cast(tenv te, exp e, typ t) {
  if (!unify(e->topt->v,t)) {
    _ inner = copy_exp(e);
    e->r    = Cast_e(t,inner);
    e->topt = &Opt(t);
  }
}

bool comparison_promote(tenv te, exp e) {
  typ t;
  switch (compress(e->topt->v)) {
  case IntType(sn,sz):
    switch (sz) {
    case B1: t = sint_t; break; // convert to unboxed, signed int
    case B2: t = sint_t; break; // convert to unboxed, signed int
    case B4: t = (sn == Unsigned) ? uint_t : sint_t; break; // make uboxed
    case B8: return true;
    }
    break;
  case FloatType: t = float_t; break; // make unboxed
  case DoubleType: return true;
  default: return false;
  }
  unchecked_cast(te,e,t);
  return true;
}

// check that the expression has an arithmetic type and, if it's 
// a size that is smaller than an int, then promote it up to int.
// Note that unsigned char or unsigned short will be promoted to
// signed int.  Otherwise, the sign is preserved.
bool arithmetic_promote(tenv te, exp e) {
  typ old_typ = compress(e->topt->v);
  typ t;
  switch (old_typ) {
  case IntType(sn,sz):
    switch (sz) {
    case B1:  t = sint_t; break; // convert to unboxed, signed int
    case B2:  t = sint_t; break; // convert to unboxed, signed int
    case B4: // make unboxed
      t = (sn == Unsigned) ? uint_t : sint_t;
      break;
    case B8: // make unboxed
      t = (sn == Unsigned) ? ulong_t : slong_t;
      break;
    }
    break;
  case FloatType:  t = float_t;  break; // make unboxed
  case DoubleType: t = double_t; break; // make unboxed
  case EnumType(_,_,_): t = sint_t;   break; // convert to unboxed, signed int
  case Evar(_,_,_):
    t = sint_t;
    if (!unify(old_typ,t))
      return false;
    break;
  default:
    return false;
  }
  unchecked_cast(te,e,t);
  return true;
}


// Make sure that e has integral type; if it's a size that is
// smaller than an int, then promote it up to int.  Note that unsigned
// char or unsigned short will be promoted to signed int.  Otherwise,
// the sign is preserved.
bool integral_promote(tenv te, exp e) {
  typ old_typ = compress(e->topt->v);
  typ t;
  switch (old_typ) {
  case IntType(sn,sz):
    switch (sz) {
    case B1: t = sint_t; break; // convert to unboxed, signed int
    case B2: t = sint_t; break; // convert to unboxed, signed int
    case B4: t = (sn == Unsigned) ? uint_t  : sint_t;  break; // make unboxed
    case B8: t = (sn == Unsigned) ? ulong_t : slong_t; break; // make unboxed
    }
    break;
  case EnumType(_,_,_):
    t = sint_t;
    break; // convert to unboxed, signed int
  case Evar(_,_,_):
    t = sint_t;
    if (!unify(old_typ,t))
      return false;
    break;
  default:
    return false;
  }
  unchecked_cast(te,e,t);
  return true;
}
typ max_arithmetic_type(typ t1, typ t2) {
  switch ($(t1,t2)) {
  case $(DoubleType,_): fallthru;
  case $(_,DoubleType): return DoubleType;
  case $(FloatType,_):  fallthru;
  case $(_,FloatType):  return FloatType;
  case $(IntType(Unsigned,B8),_): fallthru;
  case $(_,IntType(Unsigned,B8)): return IntType(Unsigned,B8);
  case $(IntType(Signed,B8),_):   fallthru;
  case $(_,IntType(Signed,B8)):   return IntType(Signed,B8);
  case $(IntType(Unsigned,B4),_): fallthru;
  case $(_,IntType(Unsigned,B4)): return IntType(Unsigned,B4);
  default: return IntType(Signed,B4);
  }
}

// used to warn when a while, for, if, or do test contains an assignment
void check_contains_assign(exp e) {
  switch (e->r) {
  case AssignOp_e(_,null,_): warn(e->loc,"assignment in test"); break;
  default: break;
  }
}


// Adds tv to the list of tvars unless it's already present.  If it's
// already present, makes sure the kinds are compatible.  Returns the
// newly updated list and the original tvar.  This way, we can make
// sure all of the tvars share so that if we update the kind, it happens
// for all free occurrences. 
static $(list_t<tvar>,tvar) add_free_tvar(seg_t loc, list_t<tvar> tvs, tvar tv) {
  if (tvs == null) { 
    return $((list_t<tvar>)&List{tv,null},tv);
  } else {
    for (_ tvs2 = tvs; tvs2 != null; tvs2 = tvs2->tl) {
      if (String::zstrptrcmp((*tvs2->hd)[0], (*tv)[0]) == 0) {
        kind_t k1 = (*tvs2->hd)[1];
        kind_t k2 = (*tv)[1];
        if (k1 == UnresolvedKind) (*tvs2->hd)[1] = k1 = k2;
        if (k2 == UnresolvedKind) (*tv)[1] = k2 = k1;
        if (k1 != k2)
          terr(loc,xprintf("tvar %s used with inconsistent kinds %s and %s",
                           *(*tv)[0], kind2string((*tv)[1]),
                           kind2string((*tvs2->hd)[1])));
        return $(tvs, tvs2->hd);
      } else if (tvs2->tl == null) {
        tvs2->tl = &List(tv,null);
        return $(tvs, tv);
      }
    }
    return impos("Tcutil::add_free_tvar:expecting to have returned.");
  }
}
//FIX: do update in place...
static list_t<tvar> remove_bound_tvars(list_t<tvar> tvs, list_t<tvar> btvs) {
  list_t<tvar> r = null;
  for (; tvs != null; tvs = tvs->tl) {
    bool present = false;
    for (_ b = btvs; b != null; b = b->tl) {
      if (String::zstrptrcmp((*tvs->hd)[0], (*b->hd)[0]) == 0) {
        present = true;
        break;
      }
    }
    if (!present) r = &List(tvs->hd,r);
  }
  return List::imp_rev(r);
}

static int tvar_counter = 0;
tvar new_tvar(kind_t k) {
  string s = xprintf("?%d",tvar_counter++);
  return &$(new{s},k);
}

static $(opt_t<var>,tqual,typ)@ fndecl2typ_f($(var,tqual,typ)@ x) {
  return &$((opt_t<var>)&Opt((*x)[0]), (*x)[1], (*x)[2]);
}

typ fndecl2typ(fndecl fd) {
  if (fd->cached_typ == null) {
    // We don't cache this type as we want to expand out the effect
    // and so forth...  The caching happens after we check that the
    // function declaration is valid (see below).
    return FnType(FnInfo{fd->tvs, fd->effect, fd->ret_type,
                           List::map(fndecl2typ_f, fd->args),
                           fd->varargs});
  };
  return (fd->cached_typ->v);
}

// Check that the function declaration has a valid type:  all
// we do is build a FnType and then check that it is well-formed
// which has the side effect of giving us the effect and any
// bound type variables.
void check_fndecl_valid_type(seg_t loc,tenv te,fndecl fd) {
  typ t = fndecl2typ(fd);
  // this fills in the missing bound type variables and effects
  check_valid_toplevel_type(loc,te,t);
  switch (compress(t)) {
  case FnType(FnInfo{tvs,effect,rt,args,varargs}):
    fd->tvs = tvs;
    fd->effect = effect;
    break;
  default: impos("check_fndecl_valid_type: not a FnType"); return;
  };
  // cache the type on the declaration so we don't have to recompute it
  fd->cached_typ = &Opt(t);
}

static $($(opt_t<var>,tqual)@,typ)@ substitute_f1($(opt_t<var>,tqual,typ)@ y) {
  return &$(&$((*y)[0],(*y)[1]),(*y)[2]);
}
static $(opt_t<var>,tqual,typ)@ substitute_f2($($(opt_t<var>,tqual)@,typ)@ w) {
  let $(p,t) = *w;
  let $(vopt,tq) = *p;
  return &$(vopt,tq,t);
}
static list_t<typ> substs(list_t<$(tvar,typ)@> inst, list_t<typ> ts);
typ substitute(list_t<$(tvar,typ)@> inst, typ t) {
  switch (compress(t)) {
  case VarType(v):
    // a tvar lookup, not a var lookup!
    try return List::assoc_cmp(tvar_cmp,inst,v);
    catch {case Not_found: return t;}
  case StructType(no,ts,sd):   return StructType(no,substs(inst,ts),sd);
  case EnumType(no,ts,ed):     return EnumType(no,substs(inst,ts),ed);
  case TypedefType(n,ts,topt): return TypedefType(n,substs(inst,ts),topt);
  case ArrayType(t1,tq,e):     return ArrayType(substitute(inst,t1),tq,e);
  case PointerType(PtrInfo{t1,r,n,tq,b}): 
    return PointerType(PtrInfo{substitute(inst,t1),substitute(inst,r),n,tq,b});
  case FnType(FnInfo{vs,eff,rtyp,args,varargs}):
    for (let p = vs; p != null; p = p->tl)
      inst = &List(&$(p->hd,VarType(p->hd)),inst);
    let $(qs,ts) = List::split(List::map(substitute_f1, args));
    let ts2      = substs(inst,ts);
    let args2    = List::map(substitute_f2, List::zip(qs,ts2));
    let eff2     = (eff == null) ? null : &Opt(substitute(inst,eff->v));
    return FnType(FnInfo{vs, eff2, substitute(inst,rtyp), args2, varargs});
  case TupleType(tqts):
    let $(tqs,ts) = List::split(tqts);
    let ts2       = substs(inst,ts);
    let tqts2     = List::zip(tqs,ts2);
    return TupleType(tqts2);
  case Evar(_,r,_):
    if (r != null) return(substitute(inst,r->v));
    else return t;
  case RgnHandleType(rt): return RgnHandleType(substitute(inst,rt)); 

  case VoidType:        return t;
  case XenumType(_,_):  return t;
  case IntType(_,_):    return t;
  case FloatType:       return t;
  case DoubleType:      return t;
  case HeapRgn:         return t;
  case UnionType:       return t;
  case AccessEff(r): return AccessEff(substitute(inst, r));
  case JoinEff(es):  return JoinEff(substs(inst,es));
  }
}
static list_t<typ> substs(list_t<$(tvar,typ)@> inst, list_t<typ> ts) {
  return List::map_c(substitute,inst,ts);
}

exp default_initializer(tenv te, typ t, seg_t loc) {
  exp e = new_exp(Const_e(Null_c),loc);

  switch (compress(t)) {
  case PointerType(_): break; // FIX: non-nullable is an error!
  case IntType(sg,B1):
    e->r = Const_e(Char_c(Signed,'\000'));
    break;
  case IntType(sg,sz):
    e->r = Const_e(Int_c(sg,0));
    if (sz != B4)
      e = new_exp(Cast_e(t,e),loc);
    break;
  case FloatType:
    e->r = Const_e(Float_c("0.0"));
    break;
  case DoubleType:
    e->r = Cast_e(t,new_exp(Const_e(Float_c("0.0")), loc));
    break;
/*
  case ArrayType*(t,eopt):
    if (eopt == null)
      e->r = ConstArray_e(null,&Opt(t));
    else {
      e->r =
	FnCall_e(&Exp(null,Var("new_array"),loc),null,
	&List(eopt->v,&List(default_initializer(te,t,loc),null)));
    }

  case StringType:  e->r = Const_e(String_c(""));
  case CharType:    e->r = Const_e(Char_c('\000'));
  case TupleType(ts):
    e->r = NewTuple_e(List::map_c(def_init,&$(te,loc),ts));
  case NamedType(p):
    let n  = p[0];
    let ts = p[1];
    // check for an opened type name
    if (!(Dict::member(te->structs,n)
	  || Dict::member(te->unions,n)
	  || Dict::member(te->abstracts,n))) {
      try {
	n = Dict::lookup(te->open_typs,n);
	p[0] = n;
      } catch {
      case Dict::Absent: terr2(loc,"unbound type name ",n);
      }
    }
    // if it's possibly null, we'e done otherwise...
    if (possibly_null(te,n)) return e;
    let sdopt = Dict::lookup_opt(te->structs,n);
    let udopt;
    if (sdopt != null) {
      // n is a struct -- return a struct of the default expressions for
      // each of the field types->
      let sd = sdopt->v[0];
      let inst = List::zip(sd->tvs,ts);
      let es =
	List::map_c(fun *(<field_name>Opt,exp)
		     f(*(*(tenv,seg_t),list_t<$(var,typ)@>) env,
		       *(field_name,capability,typ)               field){
		       return &$(null,def_init(env[0],subst(env[1],field[2])));
		    },
                   &$(&$(te,loc),inst),
		   sd->fields);
      e->r = NewStruct_e(n,&Opt(ts),es);
    } else if ((udopt = Dict::lookup_opt(te->unions,n)) != null) {
      // n is a union -- return the first field (and an expression of the
      // argument type if any->)
      let ud = udopt->v[0];
      if (ud->fields == null) {
	terr(loc,"Union has no fields!");
      } else {
	// get first field
	let field = ud->fields->hd[0];
	// get its type
	typ t = ud->fields->hd[1];
	// if it's void then the field doesn't carry a value
	if (t == VoidType)
	  e->r = NewUnion_e(n,&Opt(ts),field,null);
	else {
	  // otherwise construct a default value for that type
	  let inst = List::zip(ud->tvs,ts);
	  let e2 = &Opt(default_initializer(te,subst(inst,t),loc));
	  e->r = NewUnion_e(n,&Opt(ts),field,e2);
	}
      }
    } else
      terr(loc,"Abstract types require initializers->");
*/

  default:
    terr(loc, xprintf("declaration of type %s requires initializer",
		      typ2string(t)));
    break;
  }
  return e;
}

$(tvar,typ)@ make_inst_var(tvar tv) {
  return &$(tv, new_evar(UnresolvedKind));
}

// Checks that a region type is well-formed (but not necessarily that
// the region is accessible.)  This adds to the input list of free 
// variables any new free variables that arise.  This allows us to
// calculate free variables of types in a bottom up fashion and then
// check that they are all bound at the top-level.
static list_t<tvar> i_check_valid_rgn(seg_t loc,tenv te,list_t<tvar> free_vars, 
                                    typ t){
  switch (compress(t)) {
  case HeapRgn: return free_vars;
  case Evar(*k,null,i):
    switch(*k) {
    case UnresolvedKind: *k = RgnKind; return free_vars;
    case RgnKind: return free_vars;
    default: 
      terr(loc,xprintf("bad region %s",typ2string(t))); return free_vars;
    }
  case VarType(*pr):
    let &$(tv,k) = *pr;
    if (k == UnresolvedKind) (**pr)[1] = k = RgnKind;
    if (k != RgnKind)
      terr(loc, xprintf("Type variable %s used as region",*tv));
    let $(new_free_tvars, pr2) = add_free_tvar(loc, free_vars, *pr);
    // bang in the unique copy of the tvar so that the kinds share
    *pr = pr2;
    return new_free_tvars;
  default: terr(loc,xprintf("Type %s treated as region",typ2string(t)));
    return free_vars;
  }
}

// Checks that an effect type is well-formed.  This adds to the 
// input list of free variables any new free variables that arise.  
// This allows us to calculate free variables of types in a bottom 
// up fashion and then check that they are all bound at the top-level.
static list_t<tvar> i_check_valid_effect(seg_t loc, tenv te, 
                                       list_t<tvar> free_vars, typ e) {
  switch (compress(e)) {
  case Evar(*k,_,_): 
    switch (*k) {
    case EffKind: break;
    case UnresolvedKind: *k = EffKind; break;
    default:
      terr(loc,xprintf("Ill-formed effect %s",typ2string(e)));
      break;
    }
    return free_vars;
  case VarType(*pr):
    let &$(tv,k) = *pr;
    if (k == UnresolvedKind) (**pr)[1] = k = EffKind;
    if (k != EffKind) {
      terr(loc,xprintf("Ill-formed effect %s",typ2string(e)));
      return free_vars;
    }
    let $(new_free_tvars, pr2) = add_free_tvar(loc, free_vars, *pr);
    *pr = pr2;
    return new_free_tvars;
  case JoinEff(es):
    for (; es != null; es = es->tl) 
      free_vars = i_check_valid_effect(loc,te,free_vars,es->hd);
    return free_vars;
  case AccessEff(r):
    free_vars = i_check_valid_rgn(loc,te,free_vars,r);
    return free_vars;
  default:
    terr(loc,xprintf("Ill-formed effect %s",typ2string(e)));
    return free_vars;
  }
}

// Forward declaration
static list_t<tvar> i_check_valid_type(seg_t loc, tenv te, 
                                     list_t<tvar> free_vars, 
                                     bool ok_abstract_mem, typ t);

static list_t<tvar> i_check_valid_kinded_type(seg_t loc, tenv te, 
                                            list_t<tvar> free_vars,
                                            kind_t k, typ t) {
  switch (k) {
  case MemKind: return i_check_valid_type(loc,te,free_vars,true,t);
  case BoxKind: return i_check_valid_type(loc,te,free_vars,false,t);
  case RgnKind: return i_check_valid_rgn(loc,te,free_vars,t);
  case EffKind: return i_check_valid_effect(loc,te,free_vars,t);
  case UnresolvedKind:
    // we don't know what the kind of some type parameter is yet.
    kind_t k2 = typ_kind(t);
    if (k2 != UnresolvedKind) 
      return i_check_valid_kinded_type(loc,te,free_vars,k2,t);
    switch (compress(t)) {
    case VarType(*pr):
      let $(new_free_tvars, pr2) = add_free_tvar(loc,free_vars,*pr);
      *pr = pr2;
      return new_free_tvars;
    default: 
      warn(loc,xprintf("can't figure out kind of type %s, assuming boxed",
                       typ2string(t)));
      i_check_valid_type(loc,te,free_vars,false,t);
      return free_vars;
    }
  }
}


// Checks that a type is well-formed.  This adds to the 
// input list of free variables any new free variables that arise.  
// This allows us to calculate free variables of types in a bottom 
// up fashion and then check that they are all bound at the top-level.
//
// This also performs the following side-effects which most of the 
// rest of the compiler rightfully assumes have occurred:
// * expand typedefs
// * set pointers to declarations for StructType, EnumType, and XenumType
// * change relative type names to absolute type names
// * set the kind field of type variables.  We do just a tad of trivial 
//   inference: if the parse leaves the kind of a tyvar Unresolved, then
//   it's RgnKind if it appears in a region position, a BoxKind if it appears
//   elsewhere, and a BoxKind with a warning if it doesn't appear.
// * add default effects for function types -- the default effect
//   causes a fresh EffKind type variable e to be generated, and
//   consists of e and any free effect or region variables within
//   the function type.  
static list_t<tvar> i_check_valid_type(seg_t loc, tenv te, 
                                     list_t<tvar> free_vars, 
                                     bool ok_abstract_mem, typ t) {
  switch (compress(t)) {
  case VoidType: break;
  case Evar(RgnKind,_,_): fallthru;
  case Evar(EffKind,_,_): fallthru;
  case HeapRgn: fallthru;
  case AccessEff(_): fallthru;
  case JoinEff(_): 
    terr(loc,xprintf("Invalid type %s",typ2string(t)));
    return free_vars;
  case Evar(*k,topt,i):
    if(*k==UnresolvedKind)
      *k = MemKind;
    break;    
  case VarType(*pr):
    let &$(tv,k) = *pr;
    if (k == EffKind || k == RgnKind)
      terr(loc,xprintf("Type variable %s of kind %s used as a type",*tv,
                       kind2string(k)));
    if (!ok_abstract_mem) {
      if (k == UnresolvedKind) 
        (**pr)[1] = k = BoxKind;
      if (k != BoxKind)
        terr(loc,xprintf("Type variable %s needs to have box kind",*tv));
    }
    let $(nft, pr2) = add_free_tvar(loc, free_vars, *pr);
    // bang in the unique copy of the tvar so that the kinds share
    // this way, if the kind is still unresolved, it can be properly pinned
    // down later.
    *pr = pr2;
    return nft;
  case EnumType(tdnopt,targs,*edp):
    if (tdnopt == null) {
      terr(loc,"missing enum name");
      return free_vars;
    }
    if(*edp == null) {
      try *edp = lookup_enumdecl(te,loc,(typedef_name_t)tdnopt);
      catch { case Dict::Absent: 
	terr(loc,xprintf("unbound type enum %s",qvar2string((qvar)tdnopt)));
      return free_vars;
      }
    } 
    enumdecl ed = **edp;
    // Make relative name absolute (or replace absolute name with itself)
    if (ed->name != null) // sanity check
      *tdnopt = ed->name->v[0];
    list_t<tvar> tvs = ed->tvs;
    int lvs   = List::length(tvs);
    int largs = List::length(targs);
    if (lvs != largs)
      terr(loc,xprintf("enum %s expects %d type arguments, not %d",
		       qvar2string((qvar)tdnopt),lvs,largs));
    // check that each of the type arguments is well-formed and of the 
    // right type
    for (; targs != null; targs = targs->tl, tvs = tvs->tl) {
      typ t1 = targs->hd;
      kind_t k1 = (*tvs->hd)[1];
      free_vars = i_check_valid_kinded_type(loc,te,free_vars,k1,t1);
      if (typ_kind(t1) != k1) 
	terr(loc,xprintf("type %s is not of the right kind (%s)",
			 typ2string(t1),kind2string(k1)));
    }
    break;
  case XenumType(tdn,*xedp):
    if(*xedp == null) {
      try { 
	opt_t<xenumdecl@> xed = lookup_xenumdecl(te,loc,tdn);
	if(xed == null) {
	  terr(loc,xprintf("unbound xenum %s",qvar2string(tdn)));
	  return free_vars;
	}
	*xedp = xed->v;
      } catch { 
      case Dict::Absent:
	terr(loc,xprintf("unbound xenum %s",qvar2string(tdn)));
        return free_vars;
      }
    }
    xenumdecl xed = **xedp;
    // Make relative name absolute (or replace absolute name with itself)
    tdn[0] = xed->name[0];
    break;
  case PointerType(PtrInfo{.elt_typ=t1,.rgn_typ=rgn_typ,.nullable=nullable,
			      .tq=tq,.bounds=b}):
    // FIX: check that tqual is valid?
    // note that here, we allow abstract mem types under the pointer
    free_vars = i_check_valid_type(loc,te,free_vars,true,t1);
    free_vars = i_check_valid_rgn(loc,te,free_vars,rgn_typ);
    // check that any bound is a constant expression
    switch (compress_conref(b)->v) {
    case Eq_constr(Upper_b(e)): Evexp::eval_const_uint_exp(e); break;
    default: break;
    }
    break;
  case RgnHandleType(rgn_typ):
    free_vars = i_check_valid_rgn(loc,te,free_vars,rgn_typ);
    break;
  case IntType(_,_): break; 
  case FloatType:    break; 
  case DoubleType:   break; 
  case ArrayType(t1,tq,e):
    // FIX: check that tqual is valid?
    // we don't allow abstract mem types as the elt type of an array type
    free_vars = i_check_valid_type(loc,te,free_vars,false,t1);
    // FIX: should memoize the size so that we don't have to worry about
    // evaluating it during unification
    Evexp::eval_const_uint_exp(e); // check that e is of constant size
    break;
  case FnType(*fninfo):
    let &FnInfo{*btvs,*eff,tr,args,vararg} = fninfo;
    // FIX:  make sure that `H is not a bound variable...
    check_unique_tvars(loc,*btvs);
    list_t<tvar> new_free_vars = null;
    // results and arguments of functions cannot be abstract mem types
    new_free_vars = i_check_valid_type(loc,te,new_free_vars,false,tr);
    for (; args != null; args = args->tl) {
      // FIX: should check that variables are unique and that tquals are okay
      new_free_vars = 
        i_check_valid_type(loc,te,new_free_vars,false,(*args->hd)[2]);
    }
    if (*eff != null) {
      new_free_vars = i_check_valid_effect(loc,te,new_free_vars,(*eff)->v);
    } else {
      // add in an effect variable and calculate the default effect
      tvar e = new_tvar(EffKind); // guaranteed unique
      new_free_vars = &List(e,new_free_vars);
      list_t<typ> effect = null;
      for (_ tvs = new_free_vars; tvs != null; tvs = tvs->tl) {
        if ((*tvs->hd)[1] == RgnKind)
          effect = &List(AccessEff(VarType(tvs->hd)),effect);
        else if ((*tvs->hd)[1] == EffKind)
          effect = &List(VarType(tvs->hd),effect);
      }
      *eff = &Opt(JoinEff(List::imp_rev(effect)));
    }
    // Add in the bound type variables -- this will cause their kinds
    // to be constrained to the kinds of the free occurrences.  Warn
    // if afterwards any kind is still unconstrained and set it to BoxKind.
    if (*btvs != null) {
      list_t<tvar> new_btvs = null;
      for(list_t<tvar> bs = *btvs; bs != null; bs = bs->tl) {
        let $(nfv, btv) = add_free_tvar(loc, new_free_vars, bs->hd);
        new_free_vars = nfv;
        new_btvs = &List(btv,new_btvs);
        if((*btv)[1] == UnresolvedKind) {
          warn(loc,xprintf("Type variable %s unconstrained, assuming boxed",
                           *((*btv)[0])));
          (*btv)[1] = BoxKind;
        }
      }
      *btvs = List::imp_rev(new_btvs);
      new_free_vars = remove_bound_tvars(new_free_vars,*btvs);
    }
    for (; new_free_vars != null; new_free_vars = new_free_vars->tl) 
      free_vars = (add_free_tvar(loc, free_vars, new_free_vars->hd))[0];
    return(free_vars);

  case TupleType(tq_ts):
    // FIX: check the tquals
    for (; tq_ts != null; tq_ts = tq_ts->tl)
      free_vars = i_check_valid_type(loc,te,free_vars,false,(*tq_ts->hd)[1]);
    break;
  case StructType(tdnopt,targs,*sdp):
    if (tdnopt == null) {
      terr(loc,"missing struct name");
      return free_vars;
    }
    if(*sdp == null) {
      try *sdp = lookup_structdecl(te,loc,(qvar)tdnopt);
      catch { case Dict::Absent:
	terr(loc,xprintf("unbound type struct %s",qvar2string((qvar)tdnopt)));
        return free_vars;
      }
    }
    structdecl sd = **sdp;
    // Make relative name absolute (or replace absolute name with itself)
    if (sd->name != null) // sanity check
      *tdnopt = sd->name->v[0];
    list_t<tvar> tvs = sd->tvs;
    int lvs   = List::length(tvs);
    int largs = List::length(targs);
    if (lvs != largs) 
      terr(loc,xprintf("struct %s expects %d type arguments but was given %d",
		       qvar2string((qvar)tdnopt),lvs,largs));
    // check that each of the type arguments is well-formed
    for (; targs != null; targs = targs->tl, tvs = tvs->tl) {
      typ t1 = targs->hd;
      kind_t k1 = (*tvs->hd)[1];
      free_vars = i_check_valid_kinded_type(loc,te,free_vars,k1,t1);
      if (typ_kind(t1) != k1)
	terr(loc,xprintf("type %s is not of the right kind (%s)",
			 typ2string(t1),kind2string(k1)));
    }
    // only allow abstract structs when ok_abstract_mem
    if (!ok_abstract_mem && sd->fields == null)
      terr(loc,xprintf("abstract struct type %s not allowed here",
                       typ2string(t)));
    break;
  case TypedefType(tdn,targs,*toptp):
    // NB: since we called compress *toptp == null
    typedefdecl td;
    try td = lookup_typedefdecl(te,loc,tdn);
    catch { case Dict::Absent:
      terr(loc,xprintf("unbound typedef name %s",qvar2string(tdn)));
      return free_vars;
    }
    // Make relative name absolute (or replace absolute name with itself)
    tdn[0] = td->name[0];
    list_t<tvar> tvs = td->tvs;
    list_t<typ> ts = targs;
    list_t<$(tvar,typ)@> inst = null;
    for (; ts != null && tvs != null; ts = ts->tl, tvs = tvs->tl) {
      kind_t k = (*tvs->hd)[1];
      free_vars = i_check_valid_kinded_type(loc,te,free_vars,k,ts->hd);
      if (typ_kind(ts->hd) != k)
	terr(loc,xprintf("type %s has the wrong kind -- expecting %s",
			 typ2string(ts->hd), kind2string(k)));
      inst = &List(&$(tvs->hd,ts->hd),inst);
    }
    if (tvs != null || ts != null) {
      terr(loc,xprintf("typedef %s expects a different number of arguments",
		       qvar2string(tdn)));
      return free_vars;
    }
    typ new_typ = substitute(inst,td->defn);
    *toptp = &Opt(new_typ);
    break;
  case UnionType:
    terr(loc,"union type unsupported");
    break;
  } 
  return free_vars;
}

// Same as i_check_valid_type except that for function types, we check
// that either the bound type variables are empty (in which case we
// plug them in) or else the free type variables are contained in the
// list of the bound type variables and have the right kinds.
void check_valid_toplevel_type(seg_t loc, tenv te, typ t) {
  // don't allow an abstract mem type -- it needs to be under a pointer
  list_t<tvar> free_tvars = i_check_valid_type(loc, te, null, false, t);
  // force the unconstrained type variables to boxed type
  for (_ x = free_tvars; x != null; x = x->tl) {
    kind_t k = (*x->hd)[1];
    if (k == UnresolvedKind) {
      warn(loc,xprintf("type variable %s is unconstrained, assuming box type",
                       *(*x->hd)[0]));
      (*x->hd)[1] = BoxKind;
    }
  }
  if (free_tvars != null) {
    switch (compress(t)) {
    case FnType(*fninfo):
      let &FnInfo{*btvs,eff,tr,args,vararg} = fninfo;
      if (*btvs == null)
        *btvs = free_tvars;
      else if (free_tvars != null) {
        string s = *(*free_tvars->hd)[0];
        if (s[0] == '?')
          // Try to give the user a clue as to what happened...
          terr(loc,xprintf("You failed to abstract over the generated type variables. \nRemove the bound type variables or else make the effects of the type explicit\nand then abstract the free type variables properly."));
        else
          terr(loc,xprintf("unbound type variable %s",*(*free_tvars->hd)[0]));
      }
      break;
    default: 
      terr(loc,xprintf("unbound type variable %s",*(*free_tvars->hd)[0]));
      return;
    }
  }
}

// Same as i_check_valid_type except that we ensure the free type variables
// are compatible with a list of bound type variables.  
void check_type(seg_t loc, tenv te, list_t<tvar> bound_tvars, 
                       bool abs_type_okay, typ t) {
  list_t<tvar> free_tvars = i_check_valid_type(loc, te, null, abs_type_okay, t);
  for (_ fs = free_tvars; fs != null; fs = fs->tl) {
    tvar ftv = fs->hd;
    let $(ftvn,ftvk) = *ftv;
    bool present = false;
    for (_ bs = bound_tvars; bs != null; bs = bs->tl) {
      tvar btv = bs->hd;
      let $(btvn,btvk) = *btv;
      if (String::zstrptrcmp(ftvn,btvn) == 0) {
        present = true;
        if (btvk == UnresolvedKind) (*btv)[1] = btvk = ftvk;
        if (ftvk == UnresolvedKind) (*ftv)[1] = ftvk = btvk;
        if (ftvk == UnresolvedKind) {
          warn(loc,xprintf("assuming type variable %s is of kind box",*btvn));
          (*btv)[1] = (*ftv)[1] = ftvk = btvk = BoxKind;
        }
        if (ftvk != btvk)
          terr(loc,xprintf("type variable %s has kind %s but is used here at"
                           "kind %s",*ftvn,kind2string(btvk),
                           kind2string(ftvk)));
        break;
      }
    }
    if (!present)
      terr(loc,xprintf("unbound type variable %s in type %s",*ftvn,
                       typ2string(t)));
  }
}

// Same as check_type except that we don't allow abstract mem types
void check_valid_type(seg_t loc, tenv te, list_t<tvar> bound_tvars, typ t) {
  check_type(loc,te,bound_tvars,false,t);
}

void check_valid_kinded_type(seg_t loc, tenv te, list_t<tvar> bound_tvars, 
                             kind_t k, typ t) {
  _ free_vars = remove_bound_tvars(i_check_valid_kinded_type(loc,te,null,k,t),
                                   bound_tvars);
  if (free_vars != null)
    terr(loc,xprintf("unbound type variable %s in type %s",
                     *(*free_vars->hd)[0], typ2string(t)));
}  



// Note: we expect lists to be very short.  Otherwise, a hashtable would
// be a better choice.
static void check_unique_unsorted(int (@cmp)(`a,`a), list_t<`a> vs,
				      seg_t loc, 
                                      string a2string(`a), string msg) {
  for(; vs != null; vs = vs->tl)
    for(_ vs2 = vs->tl; vs2 != null; vs2 = vs2->tl)
      if(cmp(vs->hd, vs2->hd)== 0)
	terr(loc, xprintf("%s: %s",msg,a2string(vs->hd)));
}

static string strptr2string(string @s) {
  return *s;
}

void check_unique_vars(list_t<var> vs, seg_t loc, string msg) {
  check_unique_unsorted(String::zstrptrcmp,vs,loc,strptr2string,msg);
}

void check_unique_tvars(seg_t loc, list_t<tvar> tvs) {
  check_unique_unsorted(tvar_cmp,tvs,loc,tvar2string,
                        "duplicate type variable");
}

// take a list of $(list_t<designator>,`a) things corresponding to a struct.
// ensure the struct is not abstract.
//  * check that each list_t<designator> has exactly one element which is a 
//    FieldName or is empty
//  * match up the correct member of sd->fields with the `a.  If the list
//    is empty, take the first unused field. ?????
//    Bang in the corresponding designator in the des list element
//  * ensure that each field is used exactly once.
// (This functionality was repeated in tcPat and tcExp and was annoying me.)
// FIX: Pass in a flag to allow multiple field names ??
list_t<$($(field_name,tqual,typ)@,`a)@>
resolve_struct_designators(seg_t loc,
                           list_t<$(list_t<designator>,`a)@> des, 
                           structdecl sd) {
  if(sd->fields == null)
    terr(loc, "inappropriate use of abstract struct");

  // grab all the fields and mark them unused
  list_t<$($(field_name,tqual,typ)@,bool)@> fields = null;
  for(_ sd_fields = sd->fields->v; sd_fields != null; sd_fields = sd_fields->tl)
    fields = &List(&$(sd_fields->hd,false), fields);
  fields = imp_rev(fields);

  // match up each element of des
  list_t<$($(field_name,tqual,typ)@,`a)@> ans = null;
  for(; des != null; des = des->tl) {
    let &$(dl,a) = des->hd;
    if(dl == null) {
      // grab first unused
      let fields2 = fields;
      for(; fields2 != null; fields2 = fields2->tl)
	if(!(*fields2->hd)[1]) {
	  (*fields2->hd)[1] = true;
	  (*des->hd)[0] = &List(FieldName((*(*fields2->hd)[0])[0]), null);
	  ans = &List(&$((*fields2->hd)[0],a), ans);
	  break;
	}
      if(fields2 == null)
	terr(loc, "too many arguments to struct");
    } else if(dl->tl != null)
      // we don't support multiple designators
      terr(loc, "multiple designators are not supported");
    else
      // find the right field based on the designator
      switch (dl->hd) {
      case ArrayElement(_): 
	terr(loc, "array designator used in argument to struct");
	break;
      case FieldName(v):
	_ fields2 = fields;
	for(; fields2 != null; fields2 = fields2->tl)
	  if(String::zstrptrcmp(v,(*(*fields2->hd)[0])[0]) == 0) {
	    if((*fields2->hd)[1])
	      terr(loc, 
		   xprintf("field %s has already been used as an argument", 
			   *v));
	    (*fields2->hd)[1] = true;
	    ans = &List(&$((*fields2->hd)[0],a), ans);
	    break;
	  }
	if(fields2 == null)
	  terr(loc, xprintf("bad field designator %s", *v));
	break;
      }
  }
  
  // make sure we used all the fields
  for(; fields != null; fields = fields->tl)
    if(!(*fields->hd)[1]) {
      terr(loc, "too few arguments to struct");
      break;
    }

  return imp_rev(ans);
}

bool is_tagged_pointer_typ(typ t) {
  switch (compress(t)) {
  case PointerType(PtrInfo{_,_,_,_,b}):
    let b = compress_conref(b);
    switch (compress_conref(b)->v) {
    case Eq_constr(Unknown_b): return true;
    case No_constr: 
      b->v = Eq_constr(Unknown_b); return true;
    default: return false;
    }
  default: return false;
  }
}

// used by address of.  
// Ensure e is an lvalue or function designator.
// Return if &e is const (true for const) and what region e is in (via a type
//    of RgnKind).
// FIX: not sure const is sufficient to prevent assigning to a function
//      designator???
// Type errors should already have been reported, so we often silently return
//   a bogus answer to avoid duplicate errors.
// Note: regions might not be resolved (unification is order-dependent),
//   but that's okay because a later unification will ensure soundness.
// Note: As explained below, if e1 is a FixedArray, then &e1[e2] is only
//   legal if e1 is an lvalue.  This is not true in C, but I need it, at least
//   for now, and I doubt anyone minds.
$(bool,typ) addressof_props(tenv te, exp e) {
  // in some situations, the pointer must actually be const
  $(bool,typ) bogus_ans = $(false,HeapRgn);
  switch (e->r) {
  case Var_e(q,x):
    // where oh where does my variable live?
    switch(x) {
    case Unresolved_b: return bogus_ans;
    case Funname_b(_): return $(true, HeapRgn); 
    case Global_b(vd): 
      switch (compress(e->topt->v)) {
	// arrays cannot be modified
      case ArrayType(_,_,_): return $(true, HeapRgn);
      default: return $(vd->tq->q_const, HeapRgn);
      }
    case Local_b(vd):  
      switch (compress(e->topt->v)) {
      case ArrayType(_,_,_): return $(true, vd->region->v);
      default: return $(vd->tq->q_const, vd->region->v);
      }
    case Pat_b(vd):    
      return $(vd->tq->q_const, vd->region->v);
      // KLUDGE: assumes parameters are block 0
    case Param_b(&$(_,tq,_)): return $(tq->q_const, parameter_rgn(te));
    }
  case StructMember_e(e1,f):
    // we have an unboxed thing, so we inherit e2's region
    switch (compress(e1->topt->v)) {
    case StructType(_,_,&sd):
      let finfo = lookup_struct_field(sd,f);
      if(finfo != null)
	return $((*finfo)[1]->q_const, addressof_props(te,e1)[1]);
      fallthru;
    default: return bogus_ans;
    }
  case StructArrow_e(e1,f): 
    // we have a boxed thing, so the region is in the pointer-type.
    switch (compress(e1->topt->v)) {
    case PointerType(PtrInfo{t1,r,_,_,_}): 
      switch (compress(t1)) {
      case StructType(_,_,&sd):
	let finfo = lookup_struct_field(sd,f);
	if(finfo != null)
	  return $((*finfo)[1]->q_const, r);
	fallthru;
      default: return bogus_ans;
      }
    default: return bogus_ans;
    }
  case Deref_e(e1):
    // we have a boxed thing, so the region is in the pointer-type.
    switch (compress(e1->topt->v)) {
    case PointerType(PtrInfo{_,r,_,tq,_}): 
      return $(tq->q_const, r); // FIX: is tq set correctly?
    default: return bogus_ans;
    }

  case Subscript_e(e1,e2):
    // here we need to figure out whether we've got a boxed thing
    // or not because [] is overloaded for all array kinds, tuples, and
    // tuple pointers.
    // FIX: eventually a tagged array's elements may live in a region, for now, 
    // they always in the heap
    typ t = compress(e1->topt->v);
    switch (t) {
    case ArrayType(_,tq,_): 
      // NOTE: Unlike C, we cannot allow any e1 -- it must be an lvalue.
      // (C doesn't need to know the region and we do!)
      return $(tq->q_const, addressof_props(te,e1)[1]);
    case TupleType(ts):
      // We need an lvalue in this unboxed case whereas "C w/ tuples" wouldn't.
      let finfo = lookup_tuple_field(ts,Evexp::eval_const_uint_exp(e2));
      if(finfo != null)
	return $((*finfo)[0]->q_const, addressof_props(te,e1)[1]);
      return bogus_ans;
    case PointerType(PtrInfo{t2,r,_,_,b}): 
      // boxed tuple case -- so the region is in the pointer type.
      switch(compress(t2)) {
      case TupleType(ts):
	let finfo = lookup_tuple_field(ts,Evexp::eval_const_uint_exp(e2));
	if(finfo != null)
	  return $((*finfo)[0]->q_const, r);
	fallthru;
      default: return bogus_ans;
      }
    default: return bogus_ans;
    }
  default: 
    terr(e->loc,"invalid portion in left-hand-side"); 
    return bogus_ans;
  }
}

// Coerce an expression of array type to a pointer type.  In
// certain situations, we undo this coercion, notably when e is
// a string constant or Array_e expression occurring as follows:
//    t x[c] = e
//    {.... e ... }  where the {...} is an Array_e
//    Foo(.... e ....)  where Foo is a struct or enum with a corresponding 
//         field that has type t 

typ array_to_ptr(tenv te, typ e_typ, exp e) {
  switch (compress(e_typ)) {
  case ArrayType(t,tq,_):
    let $(_,rgn) = addressof_props(te,e);
    return atb_typ(t,rgn,tq,Upper_b(e));
  default: 
    return e_typ;
  }
}

// give an error when we can statically tell that the array bounds
// aren't large enough -- if the bounds are unconstrained, set them
// to i+1.
void check_bound(seg_t loc, unsigned int i, conref<bounds_t> b) {
  b = compress_conref(b);
  switch (b->v) {
  case Eq_constr(Unknown_b): return; // checked dynamically
  case Eq_constr(Upper_b(e)):
    if (Evexp::eval_const_uint_exp(e) <= i)
      terr(loc, "dereference is out of bounds");
    return;
  default:
    // constrain the bounds to be i+1
    b->v = Eq_constr(Upper_b(uint_exp(i+1,null)));
    return;
  }
}

void check_nonzero_bound(seg_t loc, conref<bounds_t> b) {
  check_bound(loc, 0, b);
}

