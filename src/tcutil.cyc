/* Utility functions for type checking.
   Copyright (C) 2001 Greg Morrisett, AT&T
   This file is part of the Cyclone compiler.

   The Cyclone compiler is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   The Cyclone compiler is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with the Cyclone compiler; see the file COPYING. If not,
   write to the Free Software Foundation, Inc., 59 Temple Place -
   Suite 330, Boston, MA 02111-1307, USA. */


#include <core.h>
#include <stdio.h>
#include "absyn.h"
#include "absynpp.h"
#include <set.h>
#include <position.h>
#include "tcenv.h"
#include <string.h>
#include "evexp.h"
#include "tcutil.h"
#include "tcexp.h"
#include "tc.h"
using Core;
using List;
using Set;
using Position;
using Absyn;
using Absynpp;
using Tcenv;

namespace Tcutil;

xtunion exn {TypeErr};

extern void unify_it(type_t t1, type_t t2);


// Variables set to indicate where a failure occurs
type_t t1_failure = VoidType;
type_t t2_failure = VoidType;
// why the unification failed
const char ? failure_reason = NULL;
// print out an explanation about where and why a type error
// occurred -- this augments the high-level information with
// low-level specific details.
void explain_failure() {
  fflush(stderr);
  string_t s1 = typ2string(t1_failure);
  string_t s2 = typ2string(t2_failure);
  int pos = 8;
  fprintf(stderr,"\t%s and ",s1);
  pos += s1.size+5;
  if (pos >= 80) {
    fprintf(stderr,"\n\t");
    pos = 8;
  }
  fprintf(stderr,"%s ",s2);
  pos += s2.size+1;
  if (pos >= 80) {
    fprintf(stderr,"\n\t");
    pos = 8;
  }
  fprintf(stderr,"failed to unify. ");
  pos += 17;
  if (failure_reason != NULL) {
    if (pos >= 80) {
      fprintf(stderr,"\n\t");
      pos = 8;
    };
    fprintf(stderr,"%s",failure_reason);
  }
  fprintf(stderr,"\n");
  fflush(stderr);
}

void terr(seg_t loc, string_t fmt, ... inject parg_t ap) 
  __attribute__((format(printf,2,3)))
{
  Position::post_error(Position::mk_err_elab(loc,vrprintf(heap_region,fmt,ap)));
}

`a impos(string_t fmt, ... inject parg_t ap) 
  __attribute__((format(printf,1,2)))
{
  string_t msg = vrprintf(heap_region,fmt,ap);
  fprintf(stderr,"Error: %s\n",msg);
  fflush(stderr);
  throw TypeErr;
}

static string_t tvar2string(tvar_t tv) {
  return *tv->name;
}

void print_tvars(list_t<tvar_t> tvs) {
  for (; tvs != NULL; tvs = tvs->tl) 
    fprintf(stderr,"%s::%s ",tvar2string(tvs->hd),ckind2string(tvs->hd->kind));
  fprintf(stderr,"\n"); fflush(stderr);
}

static list_t<seg_t>     warning_segs = NULL;
static list_t<stringptr_t> warning_msgs = NULL;

// we batch warnings because we have to parse the file to determine
// line and column information.
void warn(seg_t sg, string_t fmt, ... inject parg_t<`r2> ap) 
  __attribute__((format(printf,2,3)))
{
  string_t msg = vrprintf(heap_region,fmt,ap);
  warning_segs = new List(sg,      warning_segs);
  warning_msgs = new List(new msg, warning_msgs);
}
void flush_warnings() {
  if(warning_segs == NULL)
    return;
  fprintf(stderr,"***Warnings***\n");
  let seg_strs = strings_of_segments(warning_segs);
  warning_segs = NULL;
  warning_msgs = List::imp_rev(warning_msgs);
  while(warning_msgs != NULL) {
    fprintf(stderr,"%s: %s\n", *(seg_strs->hd), *(warning_msgs->hd));
    seg_strs     = seg_strs->tl;
    warning_msgs = warning_msgs->tl;
  }
  fprintf(stderr,"**************\n");
  fflush(stderr);
}

// set by by Tcenv::tc_init, used to reduce allocation and calls to Set::empty.
opt_t<set_t<var_t>> empty_var_set = NULL;

// fast type-variable comparison -- can only be used when a tvar has
// an identity.
static int fast_tvar_cmp(tvar_t tv1, tvar_t tv2) {
  return (*tv1->identity - *tv2->identity);
}

// compress out any evars or typedefs
type_t compress(type_t t) {
  switch (t) {
  case &Evar(_,NULL,_,_): 
    return t;
  case &Evar(_,*t2opt_ref,_,_): // TRICKY
    type_t t2 = compress((*t2opt_ref)->v);
    // only modify if something changed to avoid allocation
    if (t2 != (*t2opt_ref)->v)
      *t2opt_ref = new Opt(t2);
    return t2;
  case &TypedefType(_,_,NULL): 
    return t;
  case &TypedefType(_,_,*topt_ref):
    type_t t2 = compress((*topt_ref)->v);
    // only modify if something changed to avoid allocation
    if (t2 != (*topt_ref)->v)
      *topt_ref = new Opt(t2);
    return t2;
  default:
    return t;
  }
}

// does a deep copy of a type to avoid sharing type variables.
// Note that any evars continue to be shared.  This should only 
// be run before feeding the type to the well-formedness checker.
type_t copy_type(type_t t);
static list_t<type_t> copy_types(list_t<type_t> ts) {
  return List::map(copy_type, ts);
}
static conref_t<`a> copy_conref(conref_t<`a> c) {
  switch (c->v) {
  case No_constr: return empty_conref();
  case &Eq_constr(x): return new_conref(x);
  case &Forward_constr(cr): return copy_conref(cr);
  }
}
static tvar_t copy_tvar(tvar_t tv) {
  // NB: loses sharing of identity here
  return new Tvar(tv->name,NULL,copy_conref(tv->kind));
}
static $(opt_t<var_t>,tqual_t,type_t)@ 
  copy_arg($(opt_t<var_t,`H>,tqual_t,type_t) @arg) {
  let $(x,y,t) = *arg;
  return new $(x,y,copy_type(t));
}
static $(tqual_t,type_t)@ copy_tqt($(tqual_t,type_t) @arg) {
  let $(x,t) = *arg;
  return new $(x,copy_type(t));
}
static structfield_t copy_field(structfield_t f) {
  return new Structfield{f->name,f->tq,copy_type(f->type),f->width,
                           f->attributes};
}
static $(type_t,type_t)@ copy_rgncmp($(type_t,type_t)@ x) {
  let &$(r1,r2) = x;
  return new $(copy_type(r1),copy_type(r2));
}
type_t copy_type(type_t t) {
  switch (compress(t)) {
  case VoidType:
  case &Evar(_,_,_,_): return t;
  case &VarType(tv):
    return new VarType(copy_tvar(tv));
  case &TunionType(TunionInfo{tui,targs,rgn}):
    return new TunionType(TunionInfo{tui,copy_types(targs),
                                       copy_type(rgn)});
  case &TunionFieldType(TunionFieldInfo{fi,targs}):
    return new TunionFieldType(TunionFieldInfo{fi,copy_types(targs)});
  case &PointerType(PtrInfo{elt,rgn,nbl,tq,bs}):
    let elt2 = copy_type(elt);
    let rgn2 = copy_type(rgn);
    let nbl2 = copy_conref(nbl);
    let tq2 = tq;
    let bs2 = copy_conref(bs);
    return new PointerType(PtrInfo{elt2,rgn2,nbl2,tq2,bs2});
  case &IntType(sn,sz): return new IntType(sn,sz);
  case FloatType: 
  case DoubleType: return t;
  case &ArrayType(et,tq,eopt): 
    // FIX: should really copy eopt
    return new ArrayType(copy_type(et),tq,eopt);
  case &FnType(FnInfo{tvs,effopt,rt,args,c_varargs,cyc_varargs,rgn_po,atts}):
    let tvs2 = List::map(copy_tvar,tvs);
    let effopt2 = (effopt == NULL) ? NULL : new Opt(copy_type(effopt->v));
    let rt2 = copy_type(rt);
    let args2 = List::map(copy_arg,args);
    let c_varargs2 = c_varargs;
    vararg_info_t * cyc_varargs2 = NULL;
    if (cyc_varargs != NULL) {
      vararg_info_t @cv = (vararg_info_t @)cyc_varargs;
      cyc_varargs2 = new VarargInfo{cv->name,cv->tq,copy_type(cv->type),
                                    cv->inject};
    }
    let rgn_po2 = List::map(copy_rgncmp,rgn_po);
    let atts2 = atts;
    return new FnType(FnInfo{tvs2,effopt2,rt2,args2,c_varargs2,
                               cyc_varargs2,rgn_po2,atts2});
  case &TupleType(tqts):
    return new TupleType(List::map(copy_tqt,tqts));
  case &StructType(tdnopt,ts,_):
    return new StructType(tdnopt,copy_types(ts),NULL);
  case &UnionType(tdnopt,ts,_):
    return new UnionType(tdnopt,copy_types(ts),NULL);
  case &AnonStructType(fs):
    return new AnonStructType(List::map(copy_field,fs));
  case &AnonUnionType(fs):
    return new AnonUnionType(List::map(copy_field,fs));
  case &EnumType(tdn,_):
    return new EnumType(tdn,NULL);
  case &RgnHandleType(t): return new RgnHandleType(copy_type(t));
  case &TypedefType(tdn,ts,_):
    return new TypedefType(tdn,copy_types(ts),NULL);
  case HeapRgn: return t;
  case &AccessEff(t): return new AccessEff(copy_type(t));
  case &JoinEff(ts): return new JoinEff(copy_types(ts));
  case &RgnsEff(t): return new RgnsEff(copy_type(t));
  }
}

// Our lattice looks like this:
//          AbsType   EffKind  RgnKind
//             V
//          MemType
//             V
//          BoxType
// Only used during unification -- we can constrain an Evar or VarType
// as long as we move down in the lattice.
static bool kind_leq(kind_t k1, kind_t k2) {
  if (k1 == k2) return true;
  switch ($(k1,k2)) {
  case $(BoxKind, MemKind): 
  case $(BoxKind, AnyKind): 
  case $(MemKind, AnyKind): return true;
  default: return false;
  }
}

kind_t tvar_kind(tvar_t tv) {
  return conref_val(tv->kind);
}

// Return the "least" kind of a type, according to the lattice above
// In some situations, we have to be conservative...
// Note that both Evars and VarTypes should have their kinds established
// by this point.
kind_t typ_kind(type_t t) {
  switch (compress(t)) {
  case &Evar(k,topt,_,_): return k->v; 
  case &VarType(tv):      return conref_val(tv->kind);
  case VoidType:          return MemKind;
  case &IntType(_,sz):    return (sz==(size_of_t)B4) ? BoxKind : MemKind;
  case FloatType:         
  case DoubleType:        
  case &FnType(_):        return MemKind;
  case &RgnHandleType(_): return BoxKind; 
  case HeapRgn:           return RgnKind;
  case &TunionType(_):    return BoxKind;
  case &TunionFieldType(TunionFieldInfo(&KnownTunionfield(_,tuf),_)):
    if(tuf->typs == NULL) return BoxKind;
    else return MemKind;
  case &TunionFieldType(TunionFieldInfo(&UnknownTunionfield(_),_)):
    return impos("typ_kind: Unresolved TunionFieldType");
    // for structs, unions, or enums without definitions, we must be 
    // conservative and treat them as having AnyKind
  case &StructType(_,_,NULL): 
  case &UnionType(_,_,NULL) : 
  case &EnumType(_,NULL)    : return AnyKind;
  case &StructType(_,_,_)   :    
  case &UnionType(_,_,_)    :     
  case &AnonStructType(_)   :    
  case &AnonUnionType(_)    : return MemKind;   
  case &EnumType(_,ed): 
    if (ed->fields == NULL) return AnyKind; else return MemKind;
  case &PointerType(pinfo):
    switch (compress_conref(pinfo.bounds)->v) {
    case &Eq_constr(Unknown_b): return MemKind;
    case &Eq_constr(&Upper_b(_)): return BoxKind;
    case No_constr: return MemKind; 
      // be conservative -- this may later be constrained with an Unknown_b
    case &Forward_constr(_): 
      return impos("typ_kind: forward constraint in ptr bounds");
    }
  // Arrays are always of memkind
  case &ArrayType(_,_,_): 
  case &TupleType(_): return MemKind;
  case &TypedefType(_,_,topt): 
    return impos("typ_kind: typedef found: %s", typ2string(t));
  case &AccessEff(_):     
  case &JoinEff(_):       
  case &RgnsEff(_): return EffKind;
  }
}

xtunion exn {Unify};

// unify types t1 and t2, returning true iff the unification succeeds 
bool unify(type_t t1, type_t t2) {
  try {
    unify_it(t1,t2);
    return true;
  } catch {
  case Unify: return false;
  }
}

// see if evar occurs within t and also check that every free type
// variable in t occurs within the list env.
static void occurslist(type_t evar, list_t<tvar_t> env, list_t<type_t> ts); // mutually recursive fns
static void occurs(type_t evar, list_t<tvar_t> env, type_t t) {
  switch (compress(t)) {
  case &VarType(tv): 
    if (!List::mem(fast_tvar_cmp,env,tv)) { 
      failure_reason = "(type variable would escape scope)"; 
      throw Unify; 
    }
    break;
  case &Evar(_,r,_,*sopt):
    if (t == evar) {
      failure_reason = "(occurs check)";
      throw Unify;
    }
    else if (r != NULL) occurs(evar,env,r->v);
    else {
      // check to see if sopt is a subset of env
      bool problem = false;
      for (_ s = (*sopt)->v; s != NULL; s = s->tl) {
        if (!List::mem(fast_tvar_cmp,env,s->hd)) {
          problem = true; break;
        }
      }
      // for sopt to be a subset of env
      if (problem) {
        let result = NULL;
        for (_ s = (*sopt)->v; s != NULL; s = s->tl) {
          if (List::mem(fast_tvar_cmp,env,s->hd)) 
            result = new List(s->hd,result);
        }
        *sopt = new Opt(result);
      }
    }
    break;
  case &PointerType(pinfo): 
    occurs(evar,env,pinfo.elt_typ); occurs(evar,env,pinfo.rgn_typ); break;
  case &ArrayType(t2,_,_): occurs(evar,env,t2); break;
  case &FnType(FnInfo{tvs,eff,rt,args,c_varargs,cyc_varargs,rgn_po,atts}): 
    if (eff != NULL) occurs(evar,env,eff->v);
    occurs(evar,env,rt);
    for(; args != NULL; args = args->tl)
      occurs(evar,env,(*args->hd)[2]);
    if (cyc_varargs != NULL) {
      let VarargInfo(_,_,t,_) = *cyc_varargs;
      occurs(evar,env,t); 
    }
    for (; rgn_po != NULL; rgn_po = rgn_po->tl) {
      let &$(r1,r2) = rgn_po->hd;
      occurs(evar,env,r1);
      occurs(evar,env,r2);
    }
    break;
  case &TupleType(args):
    for(; args != NULL; args = args->tl)
      occurs(evar,env,(*args->hd)[1]);
    break;
  case &RgnHandleType(rt): occurs(evar,env,rt); break;
  case &TunionType(TunionInfo{_,ts,r}):
    occurs(evar,env,r); occurslist(evar,env,ts); break;
  case &TypedefType(_,ts,topt): fallthru(ts);
  case &TunionFieldType(TunionFieldInfo{_,ts}): fallthru(ts);
  case &StructType(_,ts,_): occurslist(evar,env,ts); break;
  case &AnonStructType(fs): fallthru(fs);
  case &AnonUnionType(fs):
    for (; fs != NULL; fs = fs->tl)
      occurs(evar, env, fs->hd->type);
    break;
  case &AccessEff(t0): occurs(evar,env,t0); break;
  case &JoinEff(ts): occurslist(evar,env,ts); break;
  case &RgnsEff(t0): occurs(evar,env,t0); break;
  default: break;
  }
}
static void occurslist(type_t evar, list_t<tvar_t> env,list_t<type_t> ts) {
  for (; ts != NULL; ts = ts->tl)
    occurs(evar,env,ts->hd);
}

// unify two lists of types
static void unify_list(list_t<type_t> t1, list_t<type_t> t2) {
  for (; t1 != NULL && t2 != NULL; t1 = t1->tl, t2 = t2->tl) {
    unify_it(t1->hd,t2->hd);
  }
  if (t1 != NULL || t2 != NULL)
    throw Unify;
}

// unify two type qualifiers -- throws Unify unless they are the same
static void unify_tqual(tqual_t tq1, tqual_t tq2) {
  if ((tq1.q_const != tq2.q_const)    
      || (tq1.q_volatile != tq2.q_volatile) 
      || (tq1.q_restrict != tq2.q_restrict)) {
    failure_reason = "(qualifiers don't match)";
    throw Unify;
  }
}

bool equal_tqual(tqual_t tq1, tqual_t tq2) {
  return ((tq1.q_const == tq2.q_const) 
	  && (tq1.q_volatile == tq2.q_volatile) 
	  && (tq1.q_restrict == tq2.q_restrict));
}

// unify two constraint refs
static void unify_it_conrefs(int cmp(`a,`a), conref_t<`a> x, conref_t<`a> y,
                             string_t<`H> reason) {
  x = compress_conref(x);
  y = compress_conref(y);
  if (x == y) return;
  switch (x->v) {
  case No_constr: x->v = new Forward_constr(y); return;
  case &Forward_constr(_): 
    throw impos("unify_conref: forward after compress");
  case &Eq_constr(xv):
    switch (y->v) {
    case No_constr: y->v = x->v; return;
    case &Forward_constr(_):
      throw impos("unify_conref: forward after compress(2)");
    case &Eq_constr(yv):
      if (cmp(xv,yv) != 0) {
        failure_reason = reason;
        throw Unify;
      }
      return;
    }
  }
}

static bool unify_conrefs(int cmp(`a,`a), conref_t<`a> x, conref_t<`a> y) {
  try {
    unify_it_conrefs(cmp,x,y,NULL);
    return true;
  } catch { case Unify: return false; }
}

static int boundscmp(bounds_t b1, bounds_t b2) {
  switch ($(b1,b2)) {
  case $(Unknown_b,Unknown_b): return 0;
  case $(Unknown_b,_): return -1;
  case $(_,Unknown_b): return 1;
  case $(&Upper_b(e1),&Upper_b(e2)): 
    int i1 = Evexp::eval_const_uint_exp(e1);
    int i2 = Evexp::eval_const_uint_exp(e2);
    if (i1 == i2) return 0;
    if (i1 < i2) return -1;
    return 1;
  }
}

static bool equal_att(attribute_t a1, attribute_t a2) {
  if (a1 == a2) return true;
  switch ($(a1,a2)) {
  case $(&Format_att(ft1,i1,j1), &Format_att(ft2,i2,j2)):
    return (ft1 == ft2 && i1 == i2 && j1 == j2);
  case $(&Regparm_att(i1), &Regparm_att(i2)): fallthru(i1,i2);
  case $(&Aligned_att(i1), &Aligned_att(i2)): return i1 == i2;
  case $(&Section_att(s1), &Section_att(s2)):
    return strcmp(s1,s2) == 0;
  default: return false;
  }
}

bool same_atts(attributes_t a1, attributes_t a2) {
  for (_ a = a1; a != NULL; a = a->tl) 
    if (!List::exists_c(equal_att,a->hd,a2)) return false;
  for (_ a = a2; a != NULL; a = a->tl)
    if (!List::exists_c(equal_att,a->hd,a1)) return false;
  return true;
}

// forward declarations
static type_t normalize_effect(type_t e);
static type_t rgns_of(type_t t);

static type_t rgns_of_field(structfield_t sf) {
  return rgns_of(sf->type);
}

static $(tvar_t,type_t)@ region_free_subst(tvar_t tv) {
  type_t t;
  switch (conref_val(tv->kind)) {
  case RgnKind: t = HeapRgn; break;
  case EffKind: t = empty_effect; break;
  default: t = sint_t; // lives in every kind
    break;
  }
  return new $(tv,t);
}

// Calculate the regions of a type and return as an effect -- used
// in normalizing effects.
static type_t rgns_of(type_t t) {
  switch (compress(t)) {
  case VoidType: 
  case FloatType: 
  case DoubleType: 
  case &EnumType(_,_):
  case &IntType(_,_): return empty_effect;
  case &Evar(_,_,_,_):
  case &VarType(_): 
    switch (typ_kind(t)) {
    case RgnKind: return new AccessEff(t);
    case EffKind: return t;
    default: return new RgnsEff(t);
    }
  case &RgnHandleType(t): return new AccessEff(t);
  case &TunionType(TunionInfo{_,targs,r}):
    list_t<type_t> ts = new List(new AccessEff(r), map(rgns_of,targs));
    return normalize_effect(new JoinEff(ts));
  case &PointerType(PtrInfo{et,r,_,_,_}):
    return normalize_effect(new JoinEff(list(new AccessEff(r),rgns_of(et))));
  case &ArrayType(et,_,_):
    return normalize_effect(rgns_of(et));
  case &TupleType(tqts):
    let ts = NULL;
    for (; tqts != NULL; tqts = tqts->tl)
      ts = new List((*tqts->hd)[1],ts);
    fallthru(ts);
  case &TunionFieldType(TunionFieldInfo{_,ts}): fallthru(ts);
  case &StructType(_,ts,_): fallthru(ts);
  case &UnionType(_,ts,_):
    return normalize_effect(new JoinEff(map(rgns_of,ts)));
  case &AnonStructType(sfs): fallthru(sfs);
  case &AnonUnionType(sfs):
    return normalize_effect(new JoinEff(map(rgns_of_field,sfs)));
  case &FnType(FnInfo{tvs,eff,rt,args,_,cyc_varargs,rpo,_}):
    // NOTE:  we define RgnsEff(t) in this case to be the regions in the
    // effect.  So, if the effect is smaller than the argument or return
    // types, they won't show up.  This saves us from a lot of complication
    // with varargs, etc. and should result in a smaller effect.  But it
    // might bite us someday...
    // HACK:  we substitute region-free types for the bound type variables
    // and then compute the regions of that.
    let e = substitute(map(region_free_subst,tvs),eff->v);
    return normalize_effect(e);
  case HeapRgn: return empty_effect;
  case &AccessEff(_):
  case &JoinEff(_): return t;
  case &RgnsEff(t2): return rgns_of(t2);
  case &TypedefType(_,_,_): return impos("typedef in compressed type");
  }
}


// flattens out nested join effects when possible
// -- this has a side effect on the actual type when possible to
// memoize the computation.
static type_t normalize_effect(type_t e) {
  e = compress(e);
  switch (e) {
  case &JoinEff(*es):
    bool nested_join = true;
    for (_ effs = *es; effs != NULL; effs = effs->tl) {
      let eff = effs->hd;
      effs->hd = compress(normalize_effect(eff));
      switch (effs->hd) {
      case &JoinEff(_): nested_join = true; break;
      default: break;
      }
    }
    if (!nested_join) return e;
    list_t<type_t> effects = NULL;
    for (_ effs = *es; effs != NULL; effs = effs->tl) {
      switch (compress(effs->hd)) {
      case &JoinEff(nested_effs): 
        effects = List::revappend(nested_effs,effects);
        break;
      case &AccessEff(HeapRgn): 
        break;
      case e: effects = new List(e,effects); break;
      }
    }
    *es = List::imp_rev(effects);
    return e;
  case &RgnsEff(t): return rgns_of(t);
  default: return e;
  }
}

// Tries to break an effect into an effect evar and the rest of the
// effect along with the set of free type variables for the evar.
// This fails unless the effect is either JoinEff(ev::rest)
// where ev is an unconstrained effect evar, or else the effect is
// an unconstrained evar.
static $(type_t, list_t<type_t>, list_t<tvar_t>)*get_effect_evar(type_t t)
{
  switch (compress(t)) {
  case &JoinEff(&List{.hd=ef1,.tl=ef2}):
    switch (compress(ef1)) {
    case &Evar(_,_,_,s): return new $(ef1,ef2,s->v);
    default: return NULL;
    }
  case &Evar(k,_,_,s): 
    if (k == NULL || k->v != EffKind) impos("effect evar has wrong kind");
    return new $(t,NULL,s->v);
  default: return NULL;
  }
}

static struct Opt<kind_t> ek = {EffKind};

// Create a dummy type that includes the effect:  void (@`H)(;eff)
static type_t dummy_fntype(type_t eff) {
  let fntype = new FnType(FnInfo{.tvars=NULL,.effect=new Opt(eff),
                               .ret_typ=VoidType,.args=NULL,.c_varargs=false,
                               .cyc_varargs=NULL,.rgn_po=NULL,
                               .attributes = NULL});
  return atb_typ(fntype, HeapRgn, empty_tqual(), bounds_one);
}

// Returns true if the region r is in the effect e or else r is the
// heap region.  If constrain is true, this might cause region or
// effect evars to become constrained.
bool region_in_effect(bool constrain, type_t r, type_t e) {
  r = compress(r);
  if (r == HeapRgn) return true;
  switch (compress(e)) {
  case &AccessEff(r2): 
    // note:  might constrain a region variable unnecessarily
    if (constrain) return unify(r,r2);
    r2 = compress(r2);
    if (r == r2) return true;
    switch ($(r, r2)) {
    case $(&VarType(tv1), &VarType(tv2)): return (tvar_cmp(tv1,tv2) == 0);
    default: return false;
    }
  case &JoinEff(es): 
    for (; es != NULL; es = es->tl) 
      if (region_in_effect(constrain, r, es->hd)) return true;
    return false;
  case &RgnsEff(t):
    switch (rgns_of(t)) {
    case &RgnsEff(t):
      if (!constrain) return false;
      switch (compress(t)) {
      case &Evar(k,*p,_,s):
        // we found regions(ev) -- constrain ev to a dummy function type
        // t such that regions(t) = ev2+{`r} where ev2 is a fresh effect evar
        let ev = new_evar(&ek,s);
        // this has the effect of checking that any free variables in r
        // are contained in s.
        occurs(ev,s->v,r);
        let new_typ = dummy_fntype(new JoinEff(list(ev,new AccessEff(r))));
        *p = new Opt(new_typ);
        return true;
      default: return false;
      }
    case e2: return region_in_effect(constrain,r,e2);
    }
  case &Evar(k,*p,_,s): 
    if (k == NULL || k->v != EffKind) impos("effect evar has wrong kind");
    if (!constrain) return false;
    // we found a non-canonical evar -- we can grow it to include r
    // but this may cause problems later on with other constraints.
    let ev = new_evar(&ek,s);
    // this has the effect of checking that any free variables in r
    // are contained in s.
    occurs(ev,s->v,r);
    let new_typ = new JoinEff(new List{ev,new List{new AccessEff(r),NULL}});
    *p = new Opt(new_typ);
    return true;
  default: return false;
  }
}

// Returns true if the type t is in the effect e t as RgnsEff(t).
// If constrain is true, this might cause evars to become constrained.
// Note that t must either be an evar or a tvar.
static bool type_in_effect(bool constrain, type_t t, type_t e) {
  t = compress(t);
  switch (compress(e)) {
  case &AccessEff(_): 
    return false;
  case &JoinEff(es): 
    for (; es != NULL; es = es->tl) 
      if (type_in_effect(constrain, t, es->hd)) return true;
    return false;
  case &RgnsEff(t2):
    t2 = compress(t2);
    if (t == t2) return true;
    if (constrain) return unify(t,t2);
    switch (rgns_of(t)) {
    case &RgnsEff(t2):
      switch ($(t,compress(t2))) {
      case $(&VarType(tv1),&VarType(tv2)): return unify(t,t2);
      default: return t == t2;
      }
    case e2: return type_in_effect(constrain,t,e2);
    }
  case &Evar(k,*p,_,s): 
    if (k == NULL || k->v != EffKind) impos("effect evar has wrong kind");
    if (!constrain) return false;
    // we found a non-canonical evar -- we can grow it to include t
    // but this may cause problems later on with other constraints.
    let ev = new_evar(&ek,s);
    // this has the effect of checking that any free variables in t
    // are contained in s.
    occurs(ev,s->v,t);
    let new_typ = new JoinEff(new List{ev,new List{new RgnsEff(t),NULL}});
    *p = new Opt(new_typ);
    return true;
  default: return false;
  }
}


// Returns true if the effect type variable v is in the effect e.
// If constrain is true, this might cause effect evars to become constrained.
static bool variable_in_effect(bool constrain, tvar_t v, type_t e) {
  e = compress(e);
  switch (e) {
  case &VarType(v2): return (tvar_cmp(v, v2) == 0);
  case &JoinEff(es):
    for (; es != NULL; es = es->tl) 
      if (variable_in_effect(constrain, v, es->hd)) return true;
    return false;
  case &RgnsEff(t):
    switch (rgns_of(t)) {
    case &RgnsEff(t2): 
      if (!constrain) return false;
      switch (compress(t2)) {
      case &Evar(k,*p,_,s):
        // we found regions(ev) where ev is an evar -- set ev to
        // be a dummy type t such that regions(t) = ev2+`e where ev2
        // is a fresh evar.
        let ev = new_evar(&ek,s);
        // make sure v is in the allowed set of type variables in the evar
        if (!List::mem(fast_tvar_cmp,s->v,v)) return false;
        let new_typ = dummy_fntype(new JoinEff(list(ev,new VarType(v))));
        *p = new Opt(new_typ);
        return true;
      default: return false;
      }
    case e2: return variable_in_effect(constrain,v,e2);
    }
  case &Evar(k,*p,_,s):
    if (k == NULL || k->v != EffKind) impos("effect evar has wrong kind");
    // we found a non-canonical evar -- we can grow it to include v
    // but this may cause problems later on with other constraints.
    let ev = new_evar(&ek,s);
    // make sure v is in the allowed set of type variables for the evar
    if (!List::mem(fast_tvar_cmp,s->v,v))
      return false;
    let new_typ = new JoinEff(new List{ev,new List{new VarType(v),NULL}});
    *p = new Opt(new_typ);
    return true;
  default: return false;
  }
}

// Returns true if the effect evar ev is in the effect e.
static bool evar_in_effect(type_t evar, type_t e) {
  e = compress(e);
  switch (e) {
  case &JoinEff(es):
    for (; es != NULL; es = es->tl) 
      if (evar_in_effect(evar, es->hd)) return true;
    return false;
  case &RgnsEff(t):
    switch (rgns_of(t)) {
    case &RgnsEff(t2): return false;
    case e2: return evar_in_effect(evar, e2);
    }
  case &Evar(_,_,_,_): return (evar == e);
  default: return false;
  }
}

// Returns true when e1 is a sub-effect of e2 -- this isn't very
// efficient and can constrain both effect and region evars in
// unpredictable ways (though it tries hard not to).  
// When set_to_empty is true, evars in e1 that do not occur in (or
// cannot easily be made to occur in) e2 are constrained to the 
// empty effect (or HeapRgn for region evars).  This is the "right" 
// thing for when a function call needs to constrain the effect to 
// an upper bound.  When set_to_empty is false, we instantiate 
// unconstrained evars in e1 to be e2.
bool subset_effect(bool set_to_empty, type_t e1, type_t e2) {
  // if e2 is of the form JoinEff(ev::rest) where ev is an effect evar,
  // then we can instantiate ev to JoinEff(ev'::e1) where ev' is fresh
  /* JGM: uncomment to get the old compiler's effects
  switch (get_effect_evar(e2)) {
  case &$(ev1,rest,s): 
    let ev = new_evar(&ek,new Opt(s));
    let new_typ = new JoinEff(new List{ev,new List{e1,NULL}});
    if (unify(ev1, new_typ)) return true;
    break;
  default: break;
  }
  */
  // Note:  we could do the same thing as above with RgnsOf(ev) except
  // that we'd instantiate ev with a dummy type t such that RgnsOf(t) = 
  // ev2+e1.
  switch (compress(e1)) {
  case &JoinEff(es): 
    for (; es != NULL; es = es->tl)
      if (!subset_effect(set_to_empty,es->hd,e2))
	return false;
    return true;
  case &AccessEff(r): 
    // Try checking if the region is in the effect without performing
    // any unification first and only if this fails do we actually
    // go in and try to unify something.  It's not clear whether it's
    // best to just pin the region to HeapRgn or try to unify it with
    // some region already in the effect e2.  I'm opting for doing the
    // latter first, and then the former.
    return (region_in_effect(false,r,e2) || region_in_effect(true,r,e2) ||
            unify(r,HeapRgn));
  case &VarType(v): 
    // Same idea with effect variables
    return variable_in_effect(false,v,e2) || variable_in_effect(true,v,e2);
  case &RgnsEff(t):
    switch (rgns_of(t)) {
    case &RgnsEff(t2): 
      // similar to AccessEff(r) but we're grepping around for RgnsEff(t2)
      // within e2 -- if we don't find it, try unifying something, and 
      // failing that, just try to pin it down to something without regions.
      return (type_in_effect(false,t2,e2) || 
              type_in_effect(true,t2,e2) ||
              unify(t2,sint_t));
    case e: return subset_effect(set_to_empty,e,e2);
    }
  case &Evar(_,*p,_,s): 
    if (!evar_in_effect(e1,e2)) 
      // We can set the evar to be any subset of e2.  When set_to_empty
      // is true, we set it to the empty effect, and otherwise set it to
      // e2.  Setting it to the empty effect is the right thing to do at
      // a function call when the instatiation and call occur simultaneously. 
      // For other situations, it's not clear what is the right thing to do.
      if (set_to_empty)
        *p = new Opt(new JoinEff(NULL));
      else {
        // check that e1 doesn't occur in e2 and that the free type
        // variables of e2 are contained in s.
        occurs(e1,s->v,e2);
        *p = new Opt(e2);
      }

    return true;
  default: 
    return impos("subset_effect: bad effect: %s",typ2string(e1));
  }
}


// "unify" two effects -- a total and complete HACK
// This all relies crucially upon the fact that either the algorithm
// for determining default effects, or the user puts in a (unique)
// effect variable on each function type at the beginning of the
// function (a la Tofte & Talpin's e.phi notation.)  
//
//  We first "normalize" the effect so that it is flattened but preserves
//  the original order.  Then there are two cases to consider:
//    * When the two effects are of the form JoinEff(ev1::rest1) and 
//      JoinEff(ev2::rest2), where ev1 and ev2 are unconstrained effect 
//      Evars, then we create a new evar ev, and set both ev1 and ev2 to 
//      point to JoinEff(ev::rest1@rest2).  This way, when the types are 
//      normalized again, we end up with each effect including the other plus 
//      some additional slack.  Note that we need to check that ev1 doesn't
//      occur in rest2 and that ev2 doesn't occur in rest1.  This can
//      actually happen if an evar shows up twice in an effect.
//      FIX:  should get rid of duplicates in effects but this might be
//      expensive.
//    * When the two effects are otherwise, we simply check that one
//      effect is a "subset" of the other.  If necessary, we instantiate
//      region or effect evars to force the subset relation.  This may 
//      cause region or effect evars to become pinned down in an undesirable 
//       way...  But the situation should be rare, and if it happens, users
//       should fall back on explicit typing.
//
// What we should really do:  generate some set equalities and hold
// on to them.  Then try to simplify and solve them later on after
// things have become more constrained.  
static bool unify_effect(type_t e1, type_t e2) {
  e1 = normalize_effect(e1);
  e2 = normalize_effect(e2);
  switch ($(get_effect_evar(e1),get_effect_evar(e2))) {
    /*
  case $(&$(ev1,rest1,s1), &$(ev2,rest2,s2)):
    // The fast path:  both effects are of the form JoinEff(ev::rest)
    let s = NULL;
    // compute the intersection of the sets of allowed type variables for
    // the new evar
    for (; s1 != NULL; s1 = s1->tl) {
      if (List::mem(fast_tvar_cmp,s2,s1->hd)) s = new List(s1->hd,s);
    }
    let ev = new_evar(&ek,new Opt(s));
    let new_typ = new JoinEff(new List{ev,List::append(rest1,rest2)});
    // the calls to unify here do the occurs check and also set the evars
    // to point to the new "union" effect
    return unify(ev1, new_typ) && unify(ev2, new_typ);
    */
  default: 
    // The slow path -- see above.  we drive the slack in effects so
    // that the two effects will start to look like one another...
    return subset_effect(false, e1, e2) && subset_effect(false, e2, e1); 
  }
}

// returns true when rpo1 is a sub-partial order of rpo2.  By this
// we mean that every inequation in rpo1 is also in rpo2, or else
// the inequation in rpo is of the form `H <= t.  Note that
// this might constrain region variables.  Note also that we don't
// do any sort of transitive closure to figure out causalities.
// FIX:  this isn't complete or efficient by far...
static bool sub_rgnpo(list_t<$(type_t,type_t)@> rpo1, 
                      list_t<$(type_t,type_t)@> rpo2) {
  for (_ r1 = rpo1; r1 != NULL; r1 = r1->tl) {
    let &$(t1a,t1b) = r1->hd;
    bool found = (t1a == HeapRgn);
    for (_ r2 = rpo2; r2 != NULL && !found; r2 = r2->tl) {
      let &$(t2a,t2b) = r2->hd;
      if (unify(t1a,t2a) && unify(t1b,t2b)) {
        found = true;
        break;
      }
    }
    if (!found) return false;
  }
  return true;
}

// see if two region partial-orders are the same
static bool same_rgn_po(list_t<$(type_t,type_t)@> rpo1, 
                        list_t<$(type_t,type_t)@> rpo2) {
  return (sub_rgnpo(rpo1,rpo2) && sub_rgnpo(rpo2,rpo1));
}

// the real work of unification
void unify_it(type_t t1, type_t t2) {
  t1_failure = t1;
  t2_failure = t2;
  failure_reason = NULL;
  t1 = compress(t1);
  t2 = compress(t2);
  if (t1 == t2) return;
  switch (t1) {
  case &Evar(kind1,*ref1_ref,_,s1opt):
    // check that the evar doesn't occur in t2 and that any free variables
    // of t2 are contained in s1.
    occurs(t1,s1opt->v,t2);
    let kind2 = typ_kind(t2);
    // we can constrain the Evar to be equal to t2 only when the kind of 
    // the evar is greater than or equal to the kind of t2 or t2 is an 
    // evar that we can constrain to be equal to t1.
    if (kind_leq(kind2,kind1->v)) {
      *ref1_ref = new Opt(t2);
      return;
    } else {
      switch (t2) {
      case &Evar(_,*ref2_ref,_,s2opt): 
        // check that s2 is a subset of s1
        let s1 = s1opt->v;
        for (_ s2 = s2opt->v; s2 != NULL; s2 = s2->tl) {
          if (!List::mem(fast_tvar_cmp,s1,s2->hd)) {
            failure_reason = "(type variable would escape scope)";
            throw Unify;
          }
        }
        if (kind_leq(kind1->v,kind2)) {
          *ref2_ref = new Opt(t1); return;
        }
        failure_reason = "(kinds are incompatible)";
        break;
        // this is a special hack to deal with the fact that a boxed evar
        // can't unify with a pointer type where we don't know whether or
        // not it's a ? pointer vs. a * or @ pointer.  
      case &PointerType(pinfo) && kind1->v == BoxKind:
        let c = compress_conref(pinfo.bounds);
        switch (c->v) {
        case No_constr:
          // set the pointer to be a * or @ to an array of size 1
          c->v = new Eq_constr((bounds_t)(new Upper_b(signed_int_exp(1,NULL))));
          *ref1_ref = new Opt(t2);
          return;
        default: break;
        }
        break;
      default: break;
      }
      failure_reason = "(kinds are incompatible)";
      throw Unify;
    }
  default: break; 
  }
  // t1 is not an evar

    // in what follows, we throw Unify unless we explicitly return.
  switch ($(t2,t1)) {

  case $(&Evar(_,_,_,_),_): // t2 is an evar, t1 is not, swap and try again
    unify_it(t2,t1);
    return;

  case $(VoidType,VoidType): return;

  case $(&VarType(tv2),&VarType(tv1)):
    let x2 = tv2->name;
    let x1 = tv1->name;
    // identities should be resolved
    let id2 = *tv2->identity;
    let id1 = *tv1->identity; 
    let k2 = conref_val(tv2->kind);
    let k1 = conref_val(tv1->kind);
    // kinds should already be resolved.  
    // FIX: shouldn't need the zstrptrcmp any more...
    if (id1 == id2 && zstrptrcmp(x2,x1) == 0) {
      // sanity check
      if (k2 != k1)
        impos("same type variable %s has kinds %s and %s",
              *x2,kind2string(k2),kind2string(k1));
      return;
    } 
    failure_reason = "(variable types are not the same)";
    break;

    // Note: don't use sdp or edp in next two cases because they
    //       might not be set due to an earlier type error.
  case $(&StructType(nopt2,ts2,sdp2),&StructType(nopt1,ts1,sdp1)): 
    if ((nopt1 != NULL && nopt2 != NULL
	 && qvar_cmp((qvar_t)nopt1,(qvar_t)nopt2) == 0) 
	|| (nopt1 == NULL && nopt2 == NULL)) {
      unify_list(ts1,ts2);
      return;
    }
    failure_reason = "(different struct types)";
    break;

  case $(&EnumType(n1,_), &EnumType(n2,_)):
    if (qvar_cmp(n1,n2) == 0) return;
    failure_reason = "(different enum types)";
    break;

  case $(&UnionType(nopt2,ts2,udp2), &UnionType(nopt1,ts1,udp1)):
    if ((nopt1 != NULL && nopt2 != NULL
         && qvar_cmp((qvar_t)nopt1,(qvar_t)nopt2) == 0)
        || nopt1 == NULL && nopt2 == NULL) {
      unify_list(ts1,ts2);
      return;
    }
    failure_reason = "(different union types)";
    break;

  case $(&TunionType(TunionInfo(&KnownTunion(&tud2),ts2,r2)),
	 &TunionType(TunionInfo(&KnownTunion(&tud1),ts1,r1))):
    if(tud2 == tud1 || qvar_cmp(tud2->name,tud1->name) == 0) {
      unify_it(r1,r2);
      unify_list(ts1,ts2);
      return;
    }
    failure_reason = "(different tunion types)";
    break;

  case $(&TunionFieldType(TunionFieldInfo(&KnownTunionfield(tud2,tuf2),ts2)),
	 &TunionFieldType(TunionFieldInfo(&KnownTunionfield(tud1,tuf1),ts1))):
    if((tud2 == tud1 || qvar_cmp(tud2->name,tud1->name)==0)
       && (tuf2 == tuf1 || qvar_cmp(tuf2->name, tuf1->name)==0)) {
      unify_list(ts1,ts2);
      return;
    }
    failure_reason = "(different tunion field types)";
    break;

  case $(&PointerType(PtrInfo{.elt_typ=t2a,.rgn_typ=rgn2,
                                 .nullable=null2a,.tq=tqual2a,.bounds=b2}),
	 &PointerType(PtrInfo{.elt_typ=t1a,.rgn_typ=rgn1,
                                 .nullable=null1a,.tq=tqual1a,.bounds=b1})):
    unify_it(t1a,t2a);
    unify_it(rgn2,rgn1); // the whole reason regions are "types"
    t1_failure = t1;
    t2_failure = t2;
    unify_tqual(tqual1a,tqual2a);
    unify_it_conrefs(boundscmp,b1,b2,"(different pointer bounds)");
    // There's no need to force the nullable's to be the same when
    // the bounds are ?.
    switch (compress_conref(b1)->v) {
    case &Eq_constr(Unknown_b): return;
    default: break;
    }
    unify_it_conrefs(intcmp,null1a,null2a,"(different pointer types)");
    return;

  case $(&IntType(sn2,sz2), &IntType(sn1,sz1)):
    if ((sn1 == sn2) && (sz1 == sz2)) return;
    failure_reason = "(different integral types)";
    break;

  case $(FloatType,  FloatType):  return;
  case $(DoubleType, DoubleType): return;

  case $(&ArrayType(t2a,tq2a,e1), &ArrayType(t1a,tq1a,e2)):
    unify_tqual(tq1a,tq2a);
    unify_it(t1a,t2a);
    if (e1 == e2) return;
    if (e1 == NULL || e2 == NULL) break;
    if (Evexp::eval_const_uint_exp((exp_t)e1) == 
        Evexp::eval_const_uint_exp((exp_t)e2))
      return;
    failure_reason = "(different array sizes)";
    break;

  case $(&FnType(FnInfo{tvs2,eff2,rt2,args2,c_vararg2,cyc_vararg2,rpo2,atts2}), 
         &FnType(FnInfo{tvs1,eff1,rt1,args1,c_vararg1,cyc_vararg1,rpo1,atts1})):
    bool done = false;
    region rgn {
    list_t<$(tvar_t,type_t)@`rgn,`rgn> inst = NULL;
    while (tvs1 != NULL) {
      if (tvs2 == NULL) { 
        failure_reason = "(second function type has too few type variables)"; 
        break;
      }
      inst = rnew(rgn) List(rnew(rgn) $(tvs2->hd,new VarType(tvs1->hd)),inst);
      tvs1 = tvs1->tl;
      tvs2 = tvs2->tl;
    }
    if (tvs2 != NULL) {
      failure_reason = "(second function type has too many type variables)";
      break;
    }
    if (inst != NULL) {
      unify_it(new FnType(FnInfo{NULL,eff1,rt1,args1,c_vararg1,cyc_vararg1,
                                   rpo1,atts1}),
	       rsubstitute(rgn, inst,
                           new FnType(FnInfo{NULL,eff2,rt2,args2,c_vararg2,
					       cyc_vararg2,rpo2,atts2})));
      done = true;
    } 
    }
    if(done) // can do in region once run-time is fixed.
      return;
    unify_it(rt1,rt2);
    for (; args1!=NULL && args2!=NULL; args1 = args1->tl, args2 = args2->tl) {
      unify_tqual((*args1->hd)[1],(*args2->hd)[1]);
      unify_it((*args1->hd)[2],(*args2->hd)[2]);
    }
    t1_failure = t1; 
    t2_failure = t2;
    if ((args1 != NULL) || (args2 != NULL)) {
      failure_reason = "(function types have different number of arguments)";
      break;
    }
    if (c_vararg1 != c_vararg2) {
      failure_reason = "(only one function type takes C varargs)";
      break;
    }
    // unify any cyclone varargs
    bool bad_cyc_vararg = false;
    switch ($(cyc_vararg1, cyc_vararg2)) {
    case $(NULL,NULL): break;
    case $(NULL,_): 
    case $(_,NULL): 
      bad_cyc_vararg = true; 
      failure_reason = "(only one function type takes varargs)";
      break;
    case $(&VarargInfo{n1,tq1,tp1,i1}, &VarargInfo{n2,tq2,tp2,i2}):
      unify_tqual(tq1,tq2);
      unify_it(tp1,tp2);
      if (i1 != i2) { 
        bad_cyc_vararg = true;
        failure_reason = "(only one function type injects varargs)";
      }
      break;
    }
    if (bad_cyc_vararg) break;
    // It's important to unify the effects and po after the arguments and 
    // result so that the effects are pinned down as much as possible.
    bool bad_effect = false;
    switch($(eff1,eff2)) {
    case $(NULL,NULL): break;
    case $(NULL,_): 
    case $(_,NULL): bad_effect = true; break;
    default: bad_effect = !unify_effect(eff1->v,eff2->v); break;
    }
    t1_failure = t1; 
    t2_failure = t2;
    if(bad_effect) {
      failure_reason = "(function type effects do not unify)";
      break;
    }
    if (!same_atts(atts2,atts1)) {
      failure_reason = "(function types have different attributes)";
      break;
    }
    if (!same_rgn_po(rpo2,rpo1)) {
      failure_reason = "(function types have different region lifetime orderings)";
      break;
    }
    return;

  case $(&TupleType(ts2), &TupleType(ts1)):
    for (; ts1 != NULL && ts2 != NULL; ts1 = ts1->tl, ts2 = ts2->tl) {
      unify_tqual((*ts1->hd)[0],(*ts2->hd)[0]);
      unify_it((*ts1->hd)[1],(*ts2->hd)[1]);
    }
    if (ts1 == NULL && ts2 == NULL) return;
    t1_failure = t1; 
    t2_failure = t2;
    failure_reason = "(tuple types have different numbers of components)";
    break;

  case $(&AnonStructType(fs2), &AnonStructType(fs1)): fallthru(fs2,fs1);
  case $(&AnonUnionType(fs2), &AnonUnionType(fs1)): 
    for (; fs1 != NULL && fs2 != NULL; fs1 = fs1->tl, fs2 = fs2->tl) {
      let f1 = fs1->hd;
      let f2 = fs2->hd;
      if (zstrptrcmp(f1->name,f2->name) != 0) {
        failure_reason = "(different member names in anonymous structs/unions)";
        throw Unify;
      }
      unify_tqual(f1->tq, f2->tq);
      unify_it(f1->type, f2->type);
      if (!same_atts(f1->attributes,f2->attributes)) {
        t1_failure = t1; 
        t2_failure = t2;
        failure_reason = "(different attributes on member)";
        throw Unify;
      }
      if ((f1->width != NULL && f2->width == NULL) ||
          (f2->width != NULL && f1->width == NULL) ||
          (f1->width != NULL && f2->width != NULL &&
           Evexp::eval_const_uint_exp((exp_t)f1->width) != 
           Evexp::eval_const_uint_exp((exp_t)f2->width))) {
        t1_failure = t1; 
        t2_failure = t2;
        failure_reason = "(different bitfield widths on member)";
        throw Unify;
      }
    }
    if (fs1 == NULL && fs2 == NULL) return;
    t1_failure = t1; 
    t2_failure = t2;
    failure_reason = "(different number of members)";
    break;
  case $(HeapRgn, HeapRgn): return;
  case $(&RgnHandleType(rt1),&RgnHandleType(rt2)):
    unify_it(rt1,rt2);
    return;
  case $(&JoinEff(_), _)  : 
  case $(_, &JoinEff(_))  : 
  case $(&AccessEff(_), _): 
  case $(&RgnsEff(_), _)  : 
  case $(_, &RgnsEff(_))  : 
  case $(_, &AccessEff(_)): 
    if (unify_effect(t1,t2)) return;
    failure_reason = "(effects don't unify)";
    break;
  default: 
    break;
  }
  throw Unify;
}

bool is_arithmetic_type(type_t t) {
  switch (compress(t)) {
  case &IntType(_,_): 
  case FloatType:     
  case DoubleType:    
  case &EnumType(_,_): return true;
  default: return false;
  }
}

// we're about to convert a value of type t1 to type t2 (both arithmetic types)
// return true if we will potentially lose precision
bool will_lose_precision(type_t t1, type_t t2) {
  t1 = compress(t1);
  t2 = compress(t2);
  switch ($(t1,t2)) {
  case $(DoubleType,     FloatType):       
  case $(DoubleType,     &IntType(_,_)):   
  case $(FloatType,      &IntType(_,_)):  return true;
  case $(&IntType(_,B8), &IntType(_,B8)): return false;
  case $(&IntType(_,B8), _): // see prev case
  case $(&IntType(_,B4), FloatType):       
  case $(&IntType(_,B4), &IntType(_,B2)):  
  case $(&IntType(_,B4), &IntType(_,B1)):  
  case $(&IntType(_,B2), &IntType(_,B1)): return true;
  default: return false;
  }
}

// coerce the list e so that each element has type t -- used in arrays and
// conditionals 
bool coerce_list(tenv_t te, type_t t, list_t<exp_t,`r> es) {
  // find the biggest arithmetic type (if any) for the list and determine
  // if all of the elements are boxed.
  opt_t<type_t> max_arith_type = NULL;
  for (list_t<exp_t,`r> el = es; el != NULL; el = el->tl) {
    type_t t1 = compress(el->hd->topt->v);
    if (is_arithmetic_type(t1)) 
      if (max_arith_type == NULL || will_lose_precision(t1,max_arith_type->v))
	max_arith_type = new Opt(t1);
  }
  // unify the max arithmetic type with the result type t
  if (max_arith_type != NULL)
    if (!unify(t,max_arith_type->v))
      return false;
  // now coerce each expression to the type t as if by assignment
  for (list_t<exp_t,`r> el = es; el != NULL; el = el->tl)
    if (!coerce_assign(te,el->hd,t)) {
      terr(el->hd->loc,"type mismatch: expecting %s but found %s",
           typ2string(t),typ2string(el->hd->topt->v));
      return false;
    }
  return true;
}

// coerce e to have type "bool" (int) -- used in conditionals 
bool coerce_to_bool(tenv_t te, exp_t e) {
  if (!coerce_sint_typ(te,e)) {
    switch (compress(e->topt->v)) {
    case &PointerType(_): unchecked_cast(te,e,uint_t); break;
    default: return false;
    }
  }
  return true;
}

bool is_integral_type(type_t t) {
  switch (compress(t)) {
  case &IntType(_,_): 
  case &EnumType(_,_): return true;
  default: return false;
  }
}

// coerce e to have type unsigned int -- used in subscript
bool coerce_uint_typ(tenv_t te, exp_t e) {
  if (unify(e->topt->v,uint_t)) 
    return true;
  // try arithmetic conversions -- we only allow integral values
  if (is_integral_type(e->topt->v)) {
    if (will_lose_precision(e->topt->v,uint_t))
      warn(e->loc,"integral size mismatch; conversion supplied");
    unchecked_cast(te,e,uint_t);
    return true;
  }
  return false;
}

// coerce e to have type [signed] int -- used in coercions to "bool"
bool coerce_sint_typ(tenv_t te, exp_t e) {
  if (unify(e->topt->v,sint_t)) 
    return true;
  // try arithmetic conversions -- we only allow integral values
  if (is_integral_type(e->topt->v)) {
    if (will_lose_precision(e->topt->v,sint_t))
      warn(e->loc,"integral size mismatch; conversion supplied");
    unchecked_cast(te,e,sint_t);
    return true;
  }
  return false;
}

// Can t1 be (implicitly) cast to t2? Assumes types are well-formed 
bool silent_castable(tenv_t te, seg_t loc, type_t t1, type_t t2) {
  t1 = compress(t1);
  t2 = compress(t2);
  switch ($(t1,t2)) {
  case $(&PointerType(pinfo_a), &PointerType(pinfo_b)):
    bool okay = true;
    // can coerce @ to *
    if (!unify_conrefs(intcmp,pinfo_a.nullable,pinfo_b.nullable)) {
      switch(compress_conref(pinfo_a.nullable)->v) {
      case &Eq_constr(b): okay = !b; break;
      default: throw impos("silent_castable conref not eq");
      }
    }
    // can coerce *{e} to ? and *{e1} to *{e2} when e2 <= e1
    if (!unify_conrefs(boundscmp,pinfo_a.bounds,pinfo_b.bounds)) {
      switch ($(compress_conref(pinfo_a.bounds)->v, 
		compress_conref(pinfo_b.bounds)->v)) {
      case $(&Eq_constr(&Upper_b(_)),&Eq_constr(Unknown_b)): 
	// Can cast to ? regardless of nullable
	okay = true; break;
	// JGM:  the following would be legal, but perhaps we don't
	// want to allow it to make porting easier -- I'm afraid
	// that writing t *x = y, where y is an array will go through
	// too easily...
	// DAN: okay, so make it a warning...
      case $(&Eq_constr(&Upper_b(e1)),&Eq_constr(&Upper_b(e2))):
	okay = okay && (Evexp::eval_const_uint_exp(e1) >= 
			Evexp::eval_const_uint_exp(e2)); 
	warn(loc, "implicit cast to shorter array");
	break;
      case $(&Eq_constr(Unknown_b),&Eq_constr(Unknown_b)):
	// Can cast ? to ? regardless of nullable
	okay = true; break;
      default:
	okay = false; break;
      }
    }
    // element types have to be compatible
    okay = okay && unify(pinfo_a.elt_typ,pinfo_b.elt_typ);
    // first region must outlive the second
    okay = okay && (unify(pinfo_a.rgn_typ,pinfo_b.rgn_typ) || 
                    region_outlives(te,pinfo_a.rgn_typ,pinfo_b.rgn_typ));
    // can only move from non-const to const or stay same
    okay = okay && (!pinfo_a.tq.q_const || pinfo_b.tq.q_const);
    return okay;

  case $(&ArrayType(t1a,tq1a,e1),&ArrayType(t2a,tq2a,e2)):
    bool okay;
    // JGM: we could allow e1 >= e2 but I think it's best to give an error
    okay = 
      (e1 != NULL && e2 != NULL &&
       Evexp::eval_const_uint_exp((exp_t)e1) ==
       Evexp::eval_const_uint_exp((exp_t)e2));
    return (okay && unify(t1a,t2a) && (!tq1a.q_const || tq2a.q_const));

  // can cast a TunionFieldType to a TunionType if the field doesn't 
  // carry values.
    case $(&TunionFieldType(TunionFieldInfo{&KnownTunionfield(tud1,tuf),ts1}),
	   &TunionType(TunionInfo(&KnownTunion(&tud2),ts2,_))):
       if ((tud1 == tud2 || qvar_cmp(tud1->name,tud2->name) == 0) 
	   && tuf->typs == NULL) {
	 for (; ts1 != NULL && ts2 != NULL; ts1=ts1->tl, ts2=ts2->tl)
	   if (!unify(ts1->hd,ts2->hd))
	     break;
	 if (ts1 == NULL && ts2 == NULL) 
	   return true;
       }
       return false;

  // can cast a "tunion T.f<ts> @`r1" to a "tunion `r2 T<ts>" when 
  //   field f carries values and r1==r2 or r1 outlives r2
  case $(&PointerType(PtrInfo{t_a,rt_a,null_a,q_a,b_a}),
	 &TunionType(TunionInfo{&KnownTunion(&tud2),ts2,r2})):
	   //n2,ts2,r2,_})):
    switch (compress(t_a)) {
    case &TunionFieldType(TunionFieldInfo{&KnownTunionfield(tud1,tuf1),ts1}):
      //n1,ts1,f1,_,tufd}):
      // regions must unify or rt_a must outlive r2
      if (!unify(rt_a,r2) && !region_outlives(te,rt_a,r2))
        return false;
      // pointer must be non-NULL(@) -- note could allow * but would have
      // to insert a bounds check?
      if (!unify_conrefs(intcmp,null_a,new_conref(false))) return false;
      // pointer must point to one element -- note, could allow > 0
      if (!unify_conrefs(boundscmp,b_a,new_conref(bounds_one)))
        return false;
      // field must carry values and tunion names must align
      if (qvar_cmp(tud2->name,tud1->name)==0 && tuf1->typs != NULL) {
        // check type arguments
        bool okay = true;
        for (; ts1 != NULL && ts2 != NULL; ts1=ts1->tl, ts2=ts2->tl) 
          if (!unify(ts1->hd,ts2->hd)) {
            okay = false; break;
          }
        if (!okay || ts1 != NULL || ts2 != NULL) return false;
        return true;
      }
      break;
    default: break;
    }
    return false;

  default: return unify(t1,t2);
  }
}

// coerce e to have type t -- used in function call and explicit fallthru
bool coerce_arg(tenv_t te, exp_t e, type_t t2) {
  type_t t1 = compress(e->topt->v);
  // see if types immediately match
  if (unify(t1,t2)) return true;
  // try arithmetic conversions
  if (is_arithmetic_type(t1) && is_arithmetic_type(t2)) {
    // issue a warning if we lose precision
    if (will_lose_precision(t1,t2))
      warn(e->loc,"integral size mismatch; conversion supplied");
    unchecked_cast(te,e,t2);
    return true;
  } else if (silent_castable(te,e->loc,t1,t2)) {
    unchecked_cast(te,e,t2);
    return true;
  } else if (castable(te,e->loc,t1,t2)) {
    unchecked_cast(te,e,t2);
    warn(e->loc,"implicit cast from %s to %s",typ2string(t1),typ2string(t2));
    return true;
  } else return false;
}

// coerce e to have type t -- used in assignment operations.  Neither
// gcc nor VC++ issue warnings for losing precision here, but I think
// it may be appropriate.
bool coerce_assign(tenv_t te, exp_t e, type_t t) {
  return coerce_arg(te,e,t);
}

bool coerceable(type_t t) {
  switch (compress(t)) {
  case &IntType(_,_): 
  case FloatType:     
  case DoubleType: return true;
  default: return false;
  }
}

// FIX:  all of the subtyping stuff needs to be re-examined in the light
// of packed/aligned attributes.  And we'd need to be careful to do this
// in an architecture-dependent way (based on alignement and so forth.)

// Flatten a type into a list of type qualifiers and types for
// use in subtype comparison.
// FIX:  we should recursively flatten tuple and struct types here,
// but doing so is tricky because we have to get the padding and
// alignment right.  This seems to be particularly weird on the
// x86 -- I need to find precise documentation on it before we do this.
static $(tqual_t,type_t)@ flatten_typ_f(list_t<$(tvar_t,type_t)@`H,`H> inst,
                                      structfield_t x) {
  return new $(x->tq,substitute(inst,x->type));
}
static list_t<$(tqual_t,type_t)@> flatten_typ(tenv_t te,type_t t1) {
  t1 = compress(t1);
  switch (t1) {
  case VoidType: return NULL;
  case &TupleType(tqs): return tqs; // FIX: recursively flatten here
  case &StructType(tdnopt,ts,sdp):
    if (sdp == NULL || tdnopt == NULL) 
      return new List(new $(empty_tqual(),t1),NULL);
    let sd   = *sdp;
    let n    = *tdnopt;
    let inst = List::zip(sd->tvs,ts);
    if (sd->fields == NULL) return new List(new $(empty_tqual(),t1),NULL);
    // FIX: recursively flatten here
    return List::map_c(flatten_typ_f,inst,sd->fields->v);
  case &AnonStructType(fs):
    // FIX: recursively flatten here
    return List::map_c(flatten_typ_f,NULL,fs);
  default: return new List(new $(empty_tqual(),t1),NULL);
  }
}

// FIX: the plan is, once we have a context that lets us assume t1 <= t2
// for recursive types, then to do deep subtyping.  
// FIX: allow casting one function type to another -- especially, allow
// effects to grow...
static bool ptrsubtype(tenv_t te, list_t<$(type_t,type_t)@`H,`H> assume, type_t t1, type_t t2);
static bool subtype(tenv_t te, list_t<$(type_t,type_t)@`H,`H> assume, type_t t1, type_t t2) {
  if (unify(t1,t2)) return true;
  for (_ a = assume; a != NULL; a = a->tl)
    if (unify(t1,(*a->hd)[0]) && unify(t2,(*a->hd)[1])) 
      return true;
  t1 = compress(t1);
  t2 = compress(t2);
  switch ($(t1,t2)) {
    // the following allows us to cast an unsigned int pointer to an int 
    // pointer and vice versa.  This is okay because the types are isomorphic.
    case $(&PointerType(PtrInfo{t_a, rt_a, null_a, q_a, b_a}),
	   &PointerType(PtrInfo{t_b, rt_b, null_b, q_b, b_b})):
    // if t1 is const then t2 must be const
    if (q_a.q_const && !q_b.q_const) 
      return false;
    // if t1 is * then t2 must be *
    if (!unify_conrefs(intcmp,null_a,null_b) 
	&& conref_val(null_a) && !conref_val(null_b)) 
      return false;
    // rt_a must outlive rt_b
    if (!unify(rt_a,rt_b) && !region_outlives(te,rt_a,rt_b))
      return false;
    // need to check that the bounds match up
    if (!unify_conrefs(boundscmp,b_a,b_b)) {
      switch ($(conref_val(b_a),conref_val(b_b))) {
      case $(&Upper_b(_), Unknown_b): break;
      case $(&Upper_b(e1), &Upper_b(e2)): 
	if (Evexp::eval_const_uint_exp(e1) < Evexp::eval_const_uint_exp(e2))
	  return false;
	break;
      default: return false;
      }
    }
    return ptrsubtype(te, new List(new $(t1,t2),assume), t_a, t_b);
  default: return false;
  }
}

static bool isomorphic(type_t t1, type_t t2) {
  switch ($(compress(t1),compress(t2))) {
  case $(&IntType(_,b1), &IntType(_, b2)): return b1 == b2;
  default: return false;
  }
}

// is t1* <= t2*?
//   we flatten t1 and t2 into structurally equivalent tuple types 
//   (and thus ignore field names, associativity of nested tuples and
//   structs, etc.) and then check that t1 is a width extension of t2 
//   and for each field, either (a) both t1 and t2 have qualifier "const"
//   and the t1 field is a subtype of the t2 field, or (b) t1 = t2.
static bool ptrsubtype(tenv_t te, list_t<$(type_t,type_t)@`H,`H> assume, type_t t1, type_t t2) {
  list_t<$(tqual_t,type_t)@> tqs1 = flatten_typ(te,t1);
  list_t<$(tqual_t,type_t)@> tqs2 = flatten_typ(te,t2);
  for (; tqs2 != NULL; tqs2 = tqs2->tl, tqs1 = tqs1->tl) {
    if (tqs1 == NULL) return false;
    let &$(tq1,t1a) = tqs1->hd;
    let &$(tq2,t2a) = tqs2->hd;
    if (tq2.q_const && subtype(te,assume,t1a,t2a)) continue;
    else if (unify(t1a,t2a)) continue;
    else if (isomorphic(t1a,t2a)) continue;
    else return false;
  }
  return true;
}

// Can t1 be cast to t2?  Assumes that the types are well-formed.
// FIX: add function types...
bool castable(tenv_t te, seg_t loc, type_t t1, type_t t2) {
  if(unify(t1,t2))
    return true;
  t1 = compress(t1);
  t2 = compress(t2);
  // we can cast t1 to a union type if t1 matches one of the fields
  // in the union -- note that I'm only allowing equal types here.
  switch (t2) {
  case &UnionType(_,ts,udp):
    if (udp == NULL) break;
    let ud = *udp;
    if (ud->fields == NULL) break;
    let inst = List::zip(ud->tvs,ts);
    for (_ fs = ud->fields->v; fs != NULL; fs = fs->tl) {
      if (unify(t1,substitute(inst,fs->hd->type))) return true;
    }
    break;
  // we can cast t1 to an int if t1 is a boxed type.
  case &IntType(_,B4):
    if (typ_kind(t2) == BoxKind) return true;
    break;
  default: break;
  }
  switch (t1) {
  case &PointerType(PtrInfo{t_a,rt_a,null_a,q_a,b_a}):
    // can cast t* to t@ and vice versa.  
    // can cast a non-const pointer to a const pointer.  
    // can cast a pointer in region r1 to a pointer in region r2 as
    // long as r1 outlives r2.
    switch (t2) {
    case &PointerType(PtrInfo{t_b,rt_b,null_b,q_b,b_b}):
      let assump = new List(new $(t1,t2),NULL);
      let ptrsub =
	ptrsubtype(te,assump,t_a,t_b) && (!q_a.q_const || q_b.q_const);
      bool bounds_ok = unify_conrefs(boundscmp,b_a,b_b);
      if (!bounds_ok) {
	switch ($(conref_val(b_a),conref_val(b_b))) {
	  // We allow casts of any form as long as we can't statically
	  // tell that the bounds will be violated.
	case $(&Upper_b(e_a),&Upper_b(e_b)): 
	  if (Evexp::eval_const_uint_exp(e_a) >= 
	      Evexp::eval_const_uint_exp(e_b)) 
	    bounds_ok = true;
	  break;
	default: bounds_ok = true; break;
	}
      }
      return bounds_ok && ptrsub && 
        (unify(rt_a,rt_b) || region_outlives(te,rt_a,rt_b));
    case VoidType: return true;
    default: break;
    }
    return false;
  case &ArrayType(t1a,tq1a,e1):
    switch (t2) {
    case &ArrayType(t2a,tq2a,e2):
      bool okay;
      okay=
        (e1 != NULL && e2 != NULL && 
         Evexp::eval_const_uint_exp((exp_t)e1) >= 
         Evexp::eval_const_uint_exp((exp_t)e2));
      return (okay && unify(t1a,t2a) && (!tq1a.q_const || tq2a.q_const));
    default: return false;
    }
    return false;
  // can cast a numeric type or bool to any numeric type
  case &EnumType(_,ed1): 
    // can also cast an enum to a shorter enum
    switch(t2) {
    case &EnumType(_,ed2):
      if(ed1->fields != NULL && ed2->fields != NULL
	 && length(ed1->fields->v) >= length(ed2->fields->v))
	return true;
      break;
    default: break;
    }
    fallthru;
  case &IntType(_,_): 
  case FloatType :  
  case DoubleType: return coerceable(t2) || t2 == VoidType;
  case VoidType:   return t2 == VoidType;
  default: return false;
  }
}

// Replace e by a cast of e to t.  The caller must ensure that the cast is safe.
void unchecked_cast(tenv_t te, exp_t e, type_t t) {
  if (!unify(e->topt->v,t)) {
    let inner = copy_exp(e);
    e->r    = new Cast_e(t,inner);
    e->topt = new Opt(t);
  }
}

bool is_integral(exp_t e) {
  switch (compress(e->topt->v)) {
  case &EnumType(_,_):
  case &IntType(_,_): return true;
  case &Evar(_,_,_,_): return unify(e->topt->v,sint_t);
  default: return false;
  }
}

bool is_numeric(exp_t e) {
  if(is_integral(e))
    return true;
  switch (compress(e->topt->v)) {
  case FloatType:  
  case DoubleType: return true;
  default:         return false;
  }
}

bool is_function_type(type_t t) {
  switch (compress(t)) {
  case &FnType(_): return true;
  default: return false;
  }
}

type_t max_arithmetic_type(type_t t1, type_t t2) {
  switch ($(t1,t2)) {
  case $(DoubleType,_): 
  case $(_,DoubleType): return DoubleType;
  case $(FloatType,_):  
  case $(_,FloatType):  return FloatType;
  case $(&IntType(Unsigned,B8),_): 
  case $(_,&IntType(Unsigned,B8)): return ulonglong_t;
  case $(&IntType(Signed,B8),_):   
  case $(_,&IntType(Signed,B8)):   return slonglong_t;
  case $(&IntType(Unsigned,B4),_): 
  case $(_,&IntType(Unsigned,B4)): return uint_t;
  default: return sint_t;
  }
}

// used to warn when a while, for, if, or do test contains an assignment
void check_contains_assign(exp_t e) {
  switch (e->r) {
  case &AssignOp_e(_,NULL,_): warn(e->loc,"assignment in test"); break;
  default: break;
  }
}

/////////////////////////////////////////////////////////////////////
// Checking well-formedness of types
/////////////////////////////////////////////////////////////////////

// Given two kind constraint refs, merge them so that they will
// point to the most constrained kind.  
static bool constrain_kinds(conref_t<kind_t> c1, conref_t<kind_t> c2) {
  c1 = compress_conref(c1);
  c2 = compress_conref(c2);
  if (c1 == c2) return true;
  if (c1->v == No_constr) {
    c1->v = new Forward_constr(c2); return true;
  } else if (c2->v == No_constr) {
    c2->v = new Forward_constr(c1); return true;
  } else {
    kind_t k1 = conref_val(c1);
    kind_t k2 = conref_val(c2);
    if (kind_leq(k1,k2)) {
      c2->v = new Forward_constr(c1); return true;
    } else if (kind_leq(k2,k1)) {
      c1->v = new Forward_constr(c2); return true;
    } else return false;
  }
}

// generating fresh tvars and tvar identities
static int tvar_id_counter = 0;
int *new_tvar_id() {
  return new (tvar_id_counter++);
}

static int tvar_counter = 0;
tvar_t new_tvar(kind_t k) {
  int i = tvar_counter++;
  string_t s = aprintf("#%d",i);
  return new Tvar(new{s},NULL,new_conref(k));
}

bool is_temp_tvar(tvar_t t) {
  let s = *(t->name);
  return (s[0]=='#');
}

void rewrite_temp_tvar(tvar_t t) { // change t->name from "#xxx" to "`txxx"
  printf("%s", *(t->name));
  if (! is_temp_tvar(t)) return;
  let s = strconcat("`", *(t -> name));
  s[1] = 't';
  t -> name = new{(string_t)s};
}

// Given a function declaration, return its type as a function type:
static $(opt_t<var_t>,tqual_t,type_t)@ 
  fndecl2typ_f($(var_t,tqual_t,type_t)@ x) {
  return new $((opt_t<var_t>)(new Opt((*x)[0])), (*x)[1], (*x)[2]);
}

type_t fndecl2typ(fndecl_t fd) {
  if (fd->cached_typ == NULL) {
    // We don't cache this type as we want to expand out the effect
    // and so forth...  The caching happens after we check that the
    // function declaration is valid (see below).
    // First, separate the function type attributes from the rest
    // of the attributes and update the function declaration appropriately.
    let fn_type_atts = NULL;
    for (_ atts = fd->attributes; atts != NULL; atts = atts->tl) {
      if (fntype_att(atts->hd)) {
        fn_type_atts = new List(atts->hd,fn_type_atts); 
      } 
    }
    return new FnType(FnInfo{fd->tvs, fd->effect, fd->ret_type,
                               List::map(fndecl2typ_f, fd->args),
                               fd->c_varargs, fd->cyc_varargs, 
                               fd->rgn_po, fn_type_atts});
  }
  return (fd->cached_typ->v);
}

// Substitution stuff
static `a fst_fdarg($(`a,tqual_t,`c)@`r t)    { return (*t)[0]; }
type_t snd_tqt($(tqual_t,type_t)@`r t) { return (*t)[1]; }
static $(tqual_t,type_t)@ map2_tq($(tqual_t,type_t)@`r1 pr, type_t t) {
  return new $((*pr)[0],t);
}
static $($(opt_t<var_t>,tqual_t)@`r,type_t)@`r
substitute_f1(region_t<`r> rgn, $(opt_t<var_t,`H>,tqual_t,type_t) @`r2 y) {
  return rnew(rgn) $(rnew(rgn) $((*y)[0],(*y)[1]),(*y)[2]);
}
static $(opt_t<var_t>,tqual_t,type_t)@ 
substitute_f2($($(opt_t<var_t,`H>,tqual_t)@`r2,type_t)@`r1 w) {
  let $(p,t) = *w;
  let $(vopt,tq) = *p;
  return new $(vopt,tq,t);
}
static type_t field_type(structfield_t f) {
  return f->type;
}
static structfield_t zip_field_type(structfield_t f, type_t t) {
  return new Structfield {.name = f->name, .tq = f->tq, .type = t,
                             .width = f->width, .attributes = f->attributes};
}

static list_t<type_t,`r2> substs(region_t<`r> rgn,
				  list_t<$(tvar_t,type_t)@`r,`r> inst, 
				  list_t<type_t,`r2> ts);

type_t rsubstitute(region_t<`r> rgn, 
		   list_t<$(tvar_t,type_t)@`r,`r> inst, 
		   type_t t) {
  switch (compress(t)) {
  case &VarType(v):
    // a tvar lookup, not a var lookup!
    try return List::assoc_cmp(tvar_cmp,inst,v);
    catch {case Not_found: return t;}
  case &StructType(no,ts,sd):   
    let new_ts = substs(rgn,inst,ts);
    return new_ts == ts ? t : new StructType(no,new_ts,sd);
  case &UnionType(no,ts,ud):
    let new_ts = substs(rgn,inst, ts);
    return new_ts == ts ? t : new UnionType(no,new_ts,ud);
  case &TunionType(TunionInfo{info,ts,r}):     
    let new_ts = substs(rgn,inst,ts);
    let new_r  = rsubstitute(rgn,inst,r);
    return (new_ts == ts && new_r == r) ? t : 
      new TunionType(TunionInfo{info,new_ts,new_r});
  case &TunionFieldType(TunionFieldInfo{info,ts}):
    let new_ts = substs(rgn,inst,ts);
    return (new_ts == ts) ? t : 
      new TunionFieldType(TunionFieldInfo{info,new_ts});
  case &TypedefType(n,ts,topt): 
    let new_ts = substs(rgn,inst,ts);
    return new_ts == ts ? t : new TypedefType(n,new_ts,topt);
  case &ArrayType(t1,tq,e):     
    let new_t1 = rsubstitute(rgn,inst,t1);
    return new_t1 == t1 ? t : new ArrayType(new_t1,tq,e);
  case &PointerType(PtrInfo{t1,r,n,tq,b}): 
    let new_t1 = rsubstitute(rgn,inst,t1);
    let new_r  = rsubstitute(rgn,inst,r);
    if(new_t1 == t1 && new_r == r)
      return t;
    return new PointerType(PtrInfo(new_t1,new_r,n,tq,b));
  case &FnType(FnInfo{vs,eff,rtyp,args,c_varargs,cyc_varargs,rgn_po,atts}):
    for (let p = vs; p != NULL; p = p->tl)
      inst = rnew(rgn) List(rnew(rgn) $(p->hd,new VarType(p->hd)),inst);
    let $(qs,ts) = List::rsplit(rgn,rgn, 
				List::rmap_c(rgn,substitute_f1,rgn,args));
    let ts2      = substs(rgn,inst,ts);
    let args2    = List::map(substitute_f2, List::rzip(rgn,rgn,qs,ts2));
    opt_t<type_t> eff2;
    if(eff == NULL)
      eff2 = NULL;
    else {
      let new_eff = rsubstitute(rgn,inst,eff->v);
      if(new_eff == eff->v)
	eff2 = eff;
      else
	eff2 = new Opt(new_eff);
    }
    vararg_info_t *cyc_varargs2;
    if (cyc_varargs == NULL) 
      cyc_varargs2 = NULL;
    else {
      let VarargInfo{n,tq,t,i} = *cyc_varargs;
      let t2 = rsubstitute(rgn,inst,t);
      if (t2 == t) cyc_varargs2 = cyc_varargs;
      else 
        cyc_varargs2 = new VarargInfo{n,tq,t2,i};
    }
    list_t<$(type_t,type_t)@> rgn_po2;
    let $(rpo1a,rpo1b) = List::rsplit(rgn,rgn,rgn_po);
    let rpo2a = substs(rgn,inst,rpo1a);
    let rpo2b = substs(rgn,inst,rpo1b);
    if (rpo2a == rpo1a && rpo2b == rpo1b) 
      rgn_po2 = rgn_po;
    else 
      rgn_po2 = List::zip(rpo2a,rpo2b);
    return 
      new FnType(FnInfo{vs,eff2,rsubstitute(rgn,inst,rtyp),args2,c_varargs,
                          cyc_varargs2,rgn_po2,atts});
  case &TupleType(tqts):
    let ts  = List::rmap(rgn,snd_tqt,tqts);
    let ts2 = substs(rgn,inst,ts);
    if(ts2 == ts)
      return t;
    let tqts2 = List::map2(map2_tq,tqts,ts2);
    return new TupleType(tqts2);
  case &AnonStructType(fs):
    let ts = List::rmap(rgn,field_type,fs);
    let ts2 = substs(rgn,inst,ts);
    if (ts2 == ts)
      return t;
    let fs2 = List::map2(zip_field_type,fs,ts2);
    return new AnonStructType(fs2);
  case &AnonUnionType(fs):
    let ts = List::rmap(rgn,field_type,fs);
    let ts2 = substs(rgn,inst,ts);
    if (ts2 == ts)
      return t;
    let fs2 = List::map2(zip_field_type,fs,ts2);
    return new AnonStructType(fs2);
  case &Evar(_,r,_,_):
    if (r != NULL) return rsubstitute(rgn,inst,r->v);
    else return t;
  case &RgnHandleType(rt): 
    let new_rt = rsubstitute(rgn,inst,rt);
    return new_rt == rt ? t : new RgnHandleType(new_rt);
  case &EnumType(_,_): return t;
  case VoidType:       return t;
  case &IntType(_,_):  return t;
  case FloatType:      return t;
  case DoubleType:     return t;
  case HeapRgn:        return t;
  case &RgnsEff(t2):
    let new_t2 = rsubstitute(rgn,inst,t2);
    return new_t2 == t2 ? t : new RgnsEff(new_t2);
  case &AccessEff(r): 
    let new_r = rsubstitute(rgn,inst,r);
    return new_r == r ? t : new AccessEff(new_r);
  case &JoinEff(es):  
    let new_es = substs(rgn,inst,es);
    return new_es == es ? t : new JoinEff(new_es);
  }
}
// This is just a map beefed up to avoid unnecessary allocation.
static list_t<type_t,`r2> substs(region_t<`r> rgn,
				  list_t<$(tvar_t,type_t)@`r,`r> inst, 
				  list_t<type_t,`r2> ts) {
  if(ts == NULL)
    return NULL;
  let old_hd = ts->hd;
  let old_tl = ts->tl;
  let new_hd = rsubstitute(rgn, inst, old_hd);
  let new_tl = substs(rgn, inst, old_tl);
  if(old_hd == new_hd && old_tl == new_tl)
    return ts;
  return (list_t<type_t,`r2>)(new List(new_hd,new_tl));
}

extern type_t substitute(list_t<$(tvar_t,type_t)@`H,`H> inst, type_t t) {
  return rsubstitute(heap_region, inst, t);
}

exp_t default_initializer(tenv_t te, type_t t, seg_t loc) {
  exp_t e = new_exp(new Const_e(Null_c),loc);

  switch (compress(t)) {
  case &PointerType(_): break; // FIX: non-nullable is an error!
  case &IntType(sg,B1):
    e->r = new Const_e(new Char_c(Signed,'\000'));
    break;
  case &IntType(sg,sz):
    e->r = new Const_e(new Int_c(sg,0));
    if (sz != (size_of_t)B4)
      e = new_exp(new Cast_e(t,e),loc);
    break;
  case FloatType:
    e->r = new Const_e(new Float_c("0.0"));
    break;
  case DoubleType:
    e->r = new Cast_e(t,new_exp(new Const_e(new Float_c("0.0")), loc));
    break;
  default:
    terr(loc, "declaration of type %s requires initializer", typ2string(t));
		      
    break;
  }
  return e;
}

// Generate an appropriate evar for an instantiation of a type var
$(tvar_t,type_t)@ make_inst_var(list_t<tvar_t,`H> s, tvar_t tv) {
  kind_t k = conref_val(tv->kind);
  return new $(tv, new_evar(new Opt(k),new Opt(s)));
}

$(tvar_t,type_t)@`r r_make_inst_var($(list_t<tvar_t,`H>,region_t<`r>)@`r2 env,
                                    tvar_t tv) {
  let &$(s,rgn) = env;
  kind_t k = conref_val(tv->kind);
  return rnew(rgn) $(tv, new_evar(new Opt(k),new Opt(s)));
}

// Adds tv to the list of tvars unless it's already present.  If it's
// already present, makes sure the kinds are compatible by choosing the
// most constrained kind as the kind of the variable, and in fact
// physically share the kinds so that further constraints on it are
// propagated.  Also ensures that the tvars share the same identity.
static list_t<tvar_t> add_free_tvar(seg_t loc, list_t<tvar_t,`H> tvs, 
                                    tvar_t tv)
{
  for (_ tvs2 = tvs; tvs2 != NULL; tvs2 = tvs2->tl) {
    if (zstrptrcmp(tvs2->hd->name, tv->name) == 0) {
      conref_t<kind_t> k1 = tvs2->hd->kind;
      conref_t<kind_t> k2 = tv->kind;
      if (!constrain_kinds(k1,k2))
        terr(loc,"type variable %s is used with inconsistent kinds %s and %s",
             *tv->name, ckind2string(k1), ckind2string(k2));
      if (tv->identity == NULL)
        tv->identity = tvs2->hd->identity;
      else if (*tv->identity != *tvs2->hd->identity)
        impos("same type variable has different identity!");
      return tvs;
    }
  }
  tv->identity = new_tvar_id();
  return new List(tv,tvs);
}

// This assumes the identities and kinds are set, and simply adds
// the tvar if it's not already present.
static list_t<tvar_t> fast_add_free_tvar(list_t<tvar_t,`H> tvs, tvar_t tv)
{
  // sanity
  if (tv->identity == NULL)
      impos("fast_add_free_tvar: bad identity in tv");
  for (_ tvs2 = tvs; tvs2 != NULL; tvs2 = tvs2->tl) {
    // sanity
    if (tvs2->hd->identity == NULL)
      impos("fast_add_free_tvar: bad identity in tvs2");
    if (*tvs2->hd->identity == *tv->identity) {
      return tvs;
    } 
  }
  return new List{tv,tvs};
}

// will shadow other variables
static list_t<tvar_t> add_bound_tvar(list_t<tvar_t,`H> tvs, tvar_t tv) {
  // sanity
  if (tv->identity == NULL) impos("bound tvar id for %s is NULL",
                                  tvar2string(tv));
  return new List(tv,tvs);
}

// assumes es is a list of evars, and e is an evar.  Adds in e only
// if not already present.
static list_t<type_t> add_free_evar(list_t<type_t,`H> es, type_t e) {
  switch (compress(e)) {
  case &Evar(_,_,i,_):
    for (_ es2 = es; es2 != NULL; es2 = es2->tl) {
      switch (compress(es2->hd)) {
      case &Evar(_,_,j,_): if (i == j) return es; break;
      default: break;
      }
    }
    return new List(e,es);
  default: return es;
  }
}  

static list_t<tvar_t> remove_bound_tvars(list_t<tvar_t> tvs, list_t<tvar_t> btvs) {
  list_t<tvar_t> r = NULL;
  for (; tvs != NULL; tvs = tvs->tl) {
    bool present = false;
    for (_ b = btvs; b != NULL; b = b->tl) {
      if (*tvs->hd->identity == *b->hd->identity) {
        present = true;
        break;
      }
    }
    if (!present) r = new List(tvs->hd,r);
  }
  r = List::imp_rev(r);
  return r;
}

void check_bitfield(seg_t loc, tenv_t te, type_t field_typ, 
                    exp_opt_t width, stringptr_t fn)
{
  if (width != NULL) {
    unsigned int w = 0;
    if (!is_const_exp(te,(exp_t)width))
      terr(loc,"bitfield %s does not have constant width",*fn);
    else w = Evexp::eval_const_uint_exp((exp_t)width);
    switch (compress(field_typ)) {
    case &IntType(_,b):
      switch (b) {
      case B1: if (w > 8)  terr(loc,"bitfield larger than type"); break;
      case B2: if (w > 16) terr(loc,"bitfield larger than type"); break;
      case B4: if (w > 32) terr(loc,"bitfield larger than type"); break;
      case B8: if (w > 64) terr(loc,"bitfield larger than type"); break;
      }
      break;
    default:
      terr(loc,"bitfield %s must have integral type but has type %s",
           *fn,typ2string(field_typ));
      break;
    }
  }
}

static void check_field_atts(seg_t loc, stringptr_t fn, attributes_t atts) {
  for (; atts != NULL; atts = atts->tl) {
    switch (atts->hd) {
    case Packed_att: continue;
    case &Aligned_att(_): continue;
    default: terr(loc,"bad attribute %s on member %s",
                  attribute2string(atts->hd), *fn);
    break;
    }
  }
}

// Check-Valid-Type environments
static struct CVTEnv { 
  // passed down
  list_t<tvar_t> kind_env;  // used to get consistent id's and kinds for tvars
  // passed up 
  list_t<tvar_t> free_vars; // free tvars for this type
  list_t<type_t> free_evars;// free evars for this type
  // flag controlling whether to replace evars with fresh tvars
  bool generalize_evars; 
  // flag controlling whether we are in a function result or not
  bool fn_result;
};
typedef struct CVTEnv cvtenv_t;

// Checks that a type is well-formed and lives in kind expected_kind.  
// Takes as input a location (for error reporting), a type environment 
// (for looking up struct, enum, tunion, etc. decls), a check-valid-type
// environment (explained below), an expected kind, and the type itself t.
// It returns a check-valid-type-env as a result.
//
// In addition to checking that the type is valid, the routine needs
// to compute the set of free type variables and free evars in the
// type, and to constrain their kinds appropriately.  Normally, this
// would be coded by passing a kind_env down, and returning free_vars
// and free_evars as a result.  However, to cut down on allocation,
// we pass in the free variables of surrounding types and just add
// any new free variables to the result.  This way, we can calculate
// all of the free variables for a term in a store-passing style.
// The only situation where this breaks down is where we have binders
// as is the case for function types (see below).
//
// This also performs the following side-effects which most of the 
// rest of the compiler rightfully assumes have occurred:
// * expand typedefs
// * set pointers (or Known* variants) to declarations for 
//   StructType, UnionType, TunionType, TunionFieldType
// * change relative type names to absolute type names
// * set the kind field of type variables: we use the expected kind
//   initially, but if later constraints force a more constrained kind,
//   then we move to the more constrained kind.  This is why we propagate
//   around the set of 
// * add default effects for function types -- the default effect
//   causes a fresh EffKind type variable e to be generated, and
//   consists of e and any free effect or region variables/evars within
//   the function type.  
static cvtenv_t i_check_valid_type(seg_t loc, tenv_t te, cvtenv_t cvtenv, 
                                   kind_t expected_kind, type_t t) {
  switch (compress(t)) {
  case VoidType: break;
  case &Evar(*k,*ref,_,_): 
    if (*k == NULL) *k = new Opt(expected_kind);
    if (cvtenv.fn_result && cvtenv.generalize_evars && 
        expected_kind == RgnKind) {
      *ref = new Opt(HeapRgn);
    } else if (cvtenv.generalize_evars) {
      let v = new_tvar(expected_kind);
      *ref = new Opt(new VarType(v));
      fallthru(v);
    } else {
      cvtenv.free_evars = add_free_evar(cvtenv.free_evars,t);
    }
    break;
  case &VarType(v):
    conref_t<kind_t> c = compress_conref(v->kind);
    if (c->v == No_constr)
      c->v = new Eq_constr(expected_kind);
    // this constrains the kind of the variable according to other
    // occurrences of that variable and makes sure they share the same
    // tvar identity.
    cvtenv.kind_env = add_free_tvar(loc, cvtenv.kind_env, v);
    // no need to constrain things here, but want to add it only if
    // it hasn't already been added.
    cvtenv.free_vars = fast_add_free_tvar(cvtenv.free_vars, v);
    break;
  case &EnumType(n,*edp):
    if (*edp == NULL)
      try {
        enumdecl_t @ed = lookup_enumdecl(te,loc,n);
        *edp = *ed;
      } catch {
      case Dict::Absent:
        let ge = Dict::lookup(te->ae,te->ns);
        let ed_orig = new Enumdecl{Extern,n,NULL};
        Tc::tcEnumdecl(te,ge,loc,ed_orig);
        enumdecl_t @ed = lookup_enumdecl(te,loc,n);
        *edp = *ed;
        break;
        //terr(loc,"unbound type enum %s",qvar2string(n));
        //return cvtenv;
      }
    enumdecl_t ed = (enumdecl_t)*edp;
    // Make relative name absolute
    *n = (ed->name)[0];
    break;
  case &TunionType(TunionInfo(*info,targs,rgn)):
    switch(*info) {
    case &UnknownTunion(UnknownTunionInfo(n,is_x)):
      tuniondecl_t@ tudp;
      try tudp = lookup_tuniondecl(te,loc,n);// FIX: lookup_xtuniondecl needed?
      catch { 
      case Dict::Absent:
        // declare the tunion for the user
        let ge = Dict::lookup(te->ae,te->ns);
        let tud = new Tuniondecl{Extern, n, NULL, NULL, is_x};
        Tc::tcTuniondecl(te, ge, loc, tud);
        tudp = lookup_tuniondecl(te,loc,n);
        // give an error here if targs is non-empty
        if (targs != NULL) {
          terr(loc,"please declare parameterized %s %s before using",
               (is_x ? (const char ?)"xtunion" : "tunion"), qvar2string(n));
          return cvtenv;
        }        
        break;
        // terr(loc,"unbound type [x]tunion %s",qvar2string(n));
        // return cvtenv;
      }
      if((*tudp)->is_xtunion != is_x)
	terr(loc,"[x]tunion is different from type declaration %s",
			 qvar2string(n));
      *info = new KnownTunion(tudp);
      fallthru(*tudp);
    case &KnownTunion(&tud):
      // check the region is well-formed
      cvtenv = i_check_valid_type(loc,te,cvtenv,RgnKind,rgn);
      // check the type arguments are well-formed
      list_t<tvar_t> tvs = tud->tvs;
      for (; targs != NULL && tvs != NULL; targs = targs->tl, tvs = tvs->tl) {
	type_t t1 = targs->hd;
	kind_t k1 = conref_val(tvs->hd->kind);
	cvtenv = i_check_valid_type(loc,te,cvtenv,k1,t1);
      }
      if (targs != NULL)
	terr(loc,"too many type arguments for tunion %s",
             qvar2string(tud->name));
      if (tvs != NULL) 
	terr(loc,"too few type arguments for tunion %s",
			 qvar2string(tud->name));
      break;
    }
    break;

  case &TunionFieldType(TunionFieldInfo{*info,targs}):
    switch(*info) {
    case &UnknownTunionfield(UnknownTunionFieldInfo(tname,fname,is_x)):
      tuniondecl_t  tud;
      tunionfield_t tuf;
      try *lookup_tuniondecl(te,loc,tname);//FIX lookup_xtuniondecl needed?
      catch { case Dict::Absent:
        terr(loc,"unbound type tunion %s",qvar2string(tname));
      return cvtenv;
      }
      try 
	switch(lookup_ordinary(te,loc,fname)) {
	case &TunionRes(tud2,tuf2):
	  tuf = tuf2;
	  /* Mathieu: this check is not valid any more
	  if(tud2 != tud) != 0) {
	    terr(loc,"unbound field %s in type tunion %s",
                 qvar2string(fname), qvar2string(tname));
            return cvtenv;
          }
	  */
	  tud = tud2;
	  if(tud->is_xtunion != is_x)
	    terr(loc,"[x]tunion is different from type declaration %s",
                 qvar2string(tname));
	  break;
	default: terr(loc,"unbound field %s in type tunion %s",
                      qvar2string(fname), qvar2string(tname));
          return cvtenv;
        }
      catch {
      case Dict::Absent:
        terr(loc,"unbound field %s in type tunion %s",
             qvar2string(fname), qvar2string(tname));
        return cvtenv;
      }  
      *info = new KnownTunionfield(tud,tuf);
      fallthru(tud,tuf);
    case &KnownTunionfield(tud,tuf):
      // check the type arguments are well-formed
      list_t<tvar_t> tvs = tud->tvs;
      for (; targs != NULL && tvs != NULL; targs = targs->tl, tvs = tvs->tl) {
	type_t t1 = targs->hd;
	kind_t k1 = conref_val(tvs->hd->kind);
	cvtenv = i_check_valid_type(loc,te,cvtenv,k1,t1);
      }
      if (targs != NULL)
	terr(loc,"too many type arguments for tunion %s.%s",
             qvar2string(tud->name),qvar2string(tuf->name));
      if (tvs != NULL) 
	terr(loc,"too few type arguments for tunion %s.%s",
             qvar2string(tud->name),qvar2string(tuf->name));
      break;
    }
    break;
  case &PointerType(PtrInfo{.elt_typ=t1,.rgn_typ=rgn_typ,.
                               nullable=nullable,.tq=tq,.bounds=b}):
    // FIX: check that tqual is valid?
    // note that here, we allow AnyKind types under the pointer
    cvtenv = i_check_valid_type(loc,te,cvtenv,AnyKind,t1);
    cvtenv = i_check_valid_type(loc,te,cvtenv,RgnKind,rgn_typ);
    // check that any bound is a constant expression
    switch (compress_conref(b)->v) {
    case &Eq_constr(&Upper_b(e)): 
      if (!is_const_exp(te,e)) 
        terr(loc,"pointer bounds expression is not a constant");
      Tcexp::tcExp(te,NULL,e);
      if (!coerce_uint_typ(te,e))
        terr(loc,"pointer bounds expression is not an unsigned int");
      Evexp::eval_const_uint_exp(e); 
      break;
    default: break;
    }
    break;
  case &IntType(_,_): break; 
  case FloatType:    break; 
  case DoubleType:   break; 
  case &ArrayType(t1,tq,e):
    // FIX: check that tqual is valid?
    // we don't allow abstract mem types as the elt type of an array type
    cvtenv = i_check_valid_type(loc,te,cvtenv,MemKind,t1);
    // FIX: should memoize the size so that we don't have to worry about
    // evaluating it during unification
    if (e == NULL || !is_const_exp(te,(exp_t)e))
      terr(loc,"array bounds expression is not constant");
    Tcexp::tcExp(te,NULL,(exp_t)e);
    if (!coerce_uint_typ(te,(exp_t)e))
      terr(loc,"array bounds expression is not an unsigned int");
    Evexp::eval_const_uint_exp((exp_t)e); // check that e is of constant size
    break;
  case &FnType(FnInfo{*btvs,*eff,tr,args,c_vararg,cyc_vararg,rgn_po,atts}):
    // This is an unusual and complicated case because (a) we may have to
    // bind type variables here, (b) we may have to calculate the effect.
    //
    // check that the attributes are function type attributes
    // and that at most one of {stdcall, cdecl, fastcall} is there.
    int  num_convs = 0;
    bool seen_cdecl    = false;
    bool seen_stdcall  = false;
    bool seen_fastcall = false;
    bool seen_format = false;
    format_type_t ft = Printf_ft;
    int fmt_desc_arg = -1;
    int fmt_arg_start = -1;
    for (; atts != NULL; atts = atts->tl) {
      if (!fntype_att(atts->hd))
	terr(loc,"bad function type attribute %s",attribute2string(atts->hd));
      switch(atts->hd) {
      case Stdcall_att: 
	if(!seen_stdcall)  { seen_stdcall=true;  ++num_convs;} break;
      case Cdecl_att: 
	if(!seen_cdecl)    { seen_cdecl=true;    ++num_convs;} break;
      case Fastcall_att: 
	if(!seen_fastcall) { seen_fastcall=true; ++num_convs;} break;
      case &Format_att(fmttype,i,j):
        if (!seen_format)  { 
          seen_format = true; ft = fmttype; 
          fmt_desc_arg = i; fmt_arg_start = j;
        } else 
          terr(loc,"function can't have multiple format attributes");
        break;
      default: break;
      }
    }
    if(num_convs > 1)
      terr(loc,"function can't have multiple calling conventions");

    check_unique_tvars(loc,*btvs);
    // check that the function doesn't try to abstract a MemKind 
    // and add the bound variable in to the kind_env of cvtenv
    for (_ b = *btvs; b != NULL; b = b->tl) {
      b->hd->identity = new_tvar_id();
      cvtenv.kind_env = add_bound_tvar(cvtenv.kind_env,b->hd);
      switch (compress_conref(b->hd->kind)->v) {
      case &Eq_constr(MemKind): 
        terr(loc,"function attempts to abstract Mem type variable %s",
             *b->hd->name); break;
      default: break;
      }
    }

    // We need to use a fresh environment here so that we only track
    // the free type vars (and evars) of the function type in case we
    // have to abstract them.
    let new_cvtenv = 
      CVTEnv{cvtenv.kind_env,NULL,NULL,cvtenv.generalize_evars,true};

    // results and arguments of functions cannot be abstract mem types
    new_cvtenv = i_check_valid_type(loc,te,new_cvtenv,MemKind,tr);
    new_cvtenv.fn_result = false;
    for (_ a = args; a != NULL; a = a->tl) {
      // FIX: should check that variables are unique and that tquals are ok
      new_cvtenv = i_check_valid_type(loc,te,new_cvtenv,MemKind,
                                      (*a->hd)[2]);
    }
    // check the varargs
    if (cyc_vararg != NULL) {
      if (c_vararg) impos("both c_vararg and cyc_vararg"); // sanity
      let VarargInfo{vn,vtq,vt,vi} = *cyc_vararg;
      new_cvtenv = i_check_valid_type(loc,te,new_cvtenv,MemKind,vt);
      // if inject, then check the type is an appropriate [x]tunion
      if (vi) {
        switch (compress(vt)) {
        case &TunionType(TunionInfo{&KnownTunion(_),_,tuir}): 
          break;
        default:
          terr(loc,"can't inject a non-[x]tunion type");
          break;
        }
      }
    }
    // check the format attribute is consistent
    if (seen_format) {
      let num_args = List::length(args);
      if (fmt_desc_arg < 0 || fmt_desc_arg > num_args ||
          fmt_arg_start < 0 || 
          // when no varargs, fmt_arg_start should be 0
          (cyc_vararg == NULL && fmt_arg_start != 0) ||
          (cyc_vararg != NULL && fmt_arg_start != num_args + 1))
        terr(loc,"bad format descriptor");
      else {
        // check that fmt_desc_arg is a string in some region
        let $(_,_,t) = *List::nth(args, fmt_desc_arg - 1);
        // can't use unification yet because evars aren't properly
        // nailed down yet...
        switch (compress(t)) {
        case &PointerType(PtrInfo{et,_,_,_,b}):
          switch ($(compress(et), conref_def((bounds_t)Unknown_b,b))) {
          case $(&IntType(Unsigned,B1), Unknown_b): break;
          default: 
            terr(loc,"format descriptor is not a char ? type"); break;
          }
          break;
        default:
          terr(loc,"format descriptor is not a char ? type"); break;
        }
        if (fmt_arg_start != 0) {
          // check the type of the varargs is either tunion PrintArg or 
          // tunion ScanfArg according to format_type_t ft.
	  // FIX: shouldn't we just do this once when the declaration is made?
          let va_type = compress(cyc_vararg->type);
          bool problem;
          switch (ft) {
          case Printf_ft:
            switch (va_type) {
            case &TunionType(TunionInfo(&KnownTunion(&tud),_,_)):
              problem = (qvar_cmp(tud->name,tunion_print_arg_qvar) != 0);
              break;
            default: problem = true; break;
            }
            break;
          case Scanf_ft:
            switch (va_type) {
            case &TunionType(TunionInfo(&KnownTunion(&tud),_,_)):
              problem = (qvar_cmp(tud->name,tunion_scanf_arg_qvar) != 0);
              break;
            default: problem = true; break;
            }
            break;
          }
          if (problem)
            terr(loc,"format attribute and vararg types don't match");
        }
      }
    }
    // check the region partial order
    // FIX:  we need to ensure there are no circular dependencies...
    for (_ rpo = rgn_po; rpo != NULL; rpo = rpo->tl) {
      let &$(r1,r2) = rpo->hd;
      new_cvtenv = i_check_valid_type(loc,te,new_cvtenv,RgnKind,r1);
      new_cvtenv = i_check_valid_type(loc,te,new_cvtenv,RgnKind,r2);
    }
    if (*eff != NULL) {
      new_cvtenv = i_check_valid_type(loc,te,new_cvtenv,EffKind,(*eff)->v);
    } else {
      // add in a slack variable for the effect 
      if (cvtenv.generalize_evars) {
// JGM:  uncomment this to go back to the old style of defaults
        // tvar_t e = new_tvar(EffKind);
        // new_cvtenv.free_vars = add_free_tvar(loc,new_cvtenv.free_vars,e);
        ;
      } else {
        //type_t e = new_evar(new Opt(EffKind),NULL);
        //new_cvtenv.free_evars = add_free_evar(new_cvtenv.free_evars,e);
        ;
      }
      list_t<type_t> effect = NULL;
      // Add in any free region or effect variables to the effect.
      // This is why we need a "new_cvtenv" above -- we only want the
      // type variables that actually occur in the function type 
      // as opposed to elsewhere.
      for (_ tvs = new_cvtenv.free_vars; tvs != NULL; tvs = tvs->tl) {
        switch (compress_conref(tvs->hd->kind)->v) {
        case &Eq_constr(RgnKind):
          effect = new List(new AccessEff(new VarType(tvs->hd)),effect); 
          break;
        case &Eq_constr(EffKind):
          effect = new List(new VarType(tvs->hd),effect); break;
        default:
          // What we're doing here is adding regions(`a) to the default
          // effect for every type variable `a.
// JGM: comment out the following line to get the old behavior without 
// any regions(-) in the effect -- however, this really shouldn't be 
// necessary...
          effect = new List(new RgnsEff(new VarType(tvs->hd)), effect);
          break;
        }
      }
      // Reverse the list so that it comes out in the right order
      effect = List::imp_rev(effect);
      // Better add in any evars too:
      for (_ ts = new_cvtenv.free_evars; ts != NULL; ts = ts->tl) {
        switch (typ_kind(ts->hd)) {
        case RgnKind: 
          effect = new List(new AccessEff(ts->hd),effect); break;
        case EffKind: effect = new List(ts->hd,effect); break;
        default: 
// JGM: comment out the following line to get the old behavior without 
// any regions(-) in the effect -- however, this really shouldn't be 
// necessary...
          effect = new List(new RgnsEff(ts->hd), effect);
          break;
        }
      }
      *eff = new Opt(new JoinEff(List::imp_rev(effect)));
    }
    // Warn if afterwards any kind is still unconstrained and set it to 
    // BoxKind. In addition, drive any MemKind type variables to BoxKind 
    // to ensure that we don't abstract a MemKind variable.
    if (*btvs != NULL) {
      for(list_t<tvar_t> bs = *btvs; bs != NULL; bs = bs->tl) {
        let c = compress_conref(bs->hd->kind);
        switch (c->v) {
        case No_constr:
          warn(loc,"Type variable %s unconstrained, assuming boxed",
               *bs->hd->name);
          fallthru;
        case &Eq_constr(MemKind):
          c->v = new Eq_constr(BoxKind); break;
        default: break;
        }
      }
    }
    // remove the bound vars from the kind environment
    cvtenv.kind_env = remove_bound_tvars(new_cvtenv.kind_env,*btvs);
    // remove the bound vars from the list of free vars
    new_cvtenv.free_vars = 
      remove_bound_tvars(new_cvtenv.free_vars,*btvs);
    // add the free vars in to the set of all free vars
    for (_ tvs = new_cvtenv.free_vars; tvs != NULL; tvs = tvs->tl)
      cvtenv.free_vars = fast_add_free_tvar(cvtenv.free_vars,tvs->hd);
    // add the free evars in to the set of all free evars
    for (_ evs = new_cvtenv.free_evars; evs != NULL; evs = evs->tl)
      cvtenv.free_evars = add_free_evar(cvtenv.free_evars,evs->hd);
    break;

  case &TupleType(tq_ts):
    // FIX: check the tquals
    for (; tq_ts != NULL; tq_ts = tq_ts->tl)
      cvtenv = i_check_valid_type(loc,te,cvtenv,MemKind,(*tq_ts->hd)[1]);
    break;

  case &AnonStructType(fs):
    // FIX: this code is mostly duplicated in Tc::tcStructdecl
    region sprev_rgn {
      list_t<field_name_t,`sprev_rgn> prev_fields = NULL;
      for (; fs != NULL; fs = fs->tl) {
        let &Structfield{fn,tq,t,width,atts} = fs->hd;
        if (List::mem(zstrptrcmp,prev_fields,fn))
          terr(loc,"duplicate field %s in struct",*fn);
        if (strcmp(*fn,"") != 0)
          prev_fields = rnew(sprev_rgn) List(fn,prev_fields);
        cvtenv = i_check_valid_type(loc,te,cvtenv,MemKind,t);
        check_bitfield(loc,te,t,width,fn);
        check_field_atts(loc,fn,atts);
      }      
    }
    break;

  case &AnonUnionType(fs):
    // FIX: this code is mostly duplicated in Tc::tcUniondecl and above
    region uprev_rgn {
      list_t<field_name_t,`uprev_rgn> prev_fields = NULL;
      for (; fs != NULL; fs = fs->tl) {
        let &Structfield{fn,tq,t,width,atts} = fs->hd;
        if (List::mem(zstrptrcmp,prev_fields,fn))
          terr(loc,"duplicate field %s in struct",*fn);
        if (strcmp(*fn,"") != 0)
          prev_fields = rnew(uprev_rgn) List(fn,prev_fields);
        cvtenv = i_check_valid_type(loc,te,cvtenv,MemKind,t);
        if (!bits_only(t)) 
          terr(loc,"%s has a type that is possibly incompatible "
               "with other members of union",*fn);
        check_bitfield(loc,te,t,width,fn);
        check_field_atts(loc,fn,atts);
      }      
    }
    break;

  case &StructType(tdnopt,targs,*sdp):
    if (tdnopt == NULL) {
      // better be an anonymous struct
      if (*sdp == NULL) {
        terr(loc,"bad anonymous struct"); 
        return cvtenv;
      }
      structdecl_t sd = **sdp;
    }
    if(*sdp == NULL) {
      try *sdp = lookup_structdecl(te,loc,(qvar_t)tdnopt);
      catch { case Dict::Absent:
        // pretend like the struct was declared abstractly in the current
        // namespace
        typedef_name_t tdn = (typedef_name_t)tdnopt;
        let ge = Dict::lookup(te->ae,te->ns);
        let sd = new Structdecl{Extern, new Opt(tdn), NULL, NULL, NULL};
        Tc::tcStructdecl(te, ge, loc, sd);
        *sdp = lookup_structdecl(te,loc,tdn);
        // give an error here if targs is non-empty:
        if (targs != NULL) {
          terr(loc,"please declare parameterized struct %s before using",
               qvar2string(tdn));
          return cvtenv;
        }
        break;
        // terr(loc,"unbound type struct %s", qvar2string((qvar_t)tdnopt));
        // return cvtenv;
      }
    }
    structdecl_t sd = **sdp;
    // Make relative name absolute (or replace absolute name with itself)
    if (sd->name != NULL) // sanity check
      *tdnopt = sd->name->v[0];
    list_t<tvar_t> tvs = sd->tvs;
    // FIX: allow partial instantiation with defaults
    int lvs   = List::length(tvs);
    int largs = List::length(targs);
    if (lvs != largs) 
      terr(loc,"struct %s expects %d type arguments but was given %d",
           qvar2string((qvar_t)tdnopt),lvs,largs);
    // check that each of the type arguments is well-formed
    for (; targs != NULL; targs = targs->tl, tvs = tvs->tl) {
      type_t t1 = targs->hd;
      kind_t k1 = conref_val(tvs->hd->kind);
      cvtenv = i_check_valid_type(loc,te,cvtenv,k1,t1);
    }
    break;
  case &UnionType(tdnopt,targs,*udp):
    if (tdnopt == NULL) {
      terr(loc,"missing union name");
      return cvtenv;
    }
    if(*udp == NULL) {
      try *udp = lookup_uniondecl(te,loc,(qvar_t)tdnopt);
      catch { case Dict::Absent:
        // declare the union for the user
        let tdn = (typedef_name_t)tdnopt;
        let ge = Dict::lookup(te->ae,te->ns);
        let ud = new Uniondecl{Extern, new Opt(tdn), NULL, NULL, NULL};
        Tc::tcUniondecl(te, ge, loc, ud);
        *udp = lookup_uniondecl(te,loc,tdn);
        // give an error here if targs is non-empty
        if (targs != NULL) {
          terr(loc,"please declare parameterized union %s before using",
               qvar2string(tdn));
          return cvtenv;
        }
        break;
	//terr(loc,"unbound type union %s",qvar2string((qvar_t)tdnopt));
        //return cvtenv;
      }
    }
    uniondecl_t ud = **udp;
    // Make relative name absolute (or replace absolute name with itself)
    if (ud->name != NULL) // sanity check
      *tdnopt = ud->name->v[0];
    list_t<tvar_t> tvs = ud->tvs;
    int lvs   = List::length(tvs);
    int largs = List::length(targs);
    if (lvs != largs) 
      terr(loc,"union %s expects %d type arguments but was given %d",
           qvar2string((qvar_t)tdnopt),lvs,largs);
    // check that each of the type arguments is well-formed
    for (; targs != NULL; targs = targs->tl, tvs = tvs->tl) {
      type_t t1 = targs->hd;
      kind_t k1 = conref_val(tvs->hd->kind);
      cvtenv = i_check_valid_type(loc,te,cvtenv,k1,t1);
    }
    break;
  case &TypedefType(tdn,*targs_ref,*toptp):
    list_t<type_t> targs = *targs_ref;
    // NB: since we called compress *toptp == NULL
    typedefdecl_t td;
    try td = lookup_typedefdecl(te,loc,tdn);
    catch { case Dict::Absent:
      terr(loc,"unbound typedef name %s",qvar2string(tdn));
      return cvtenv;
    }
    // Make relative name absolute (or replace absolute name with itself)
    tdn[0] = td->name[0];
    list_t<tvar_t> tvs = td->tvs;
    list_t<type_t> ts = targs;
    list_t<$(tvar_t,type_t)@> inst = NULL;
    // check type arguments
    for (; ts != NULL && tvs != NULL; ts = ts->tl, tvs = tvs->tl) {
      kind_t k = conref_val(tvs->hd->kind);
      cvtenv = i_check_valid_type(loc,te,cvtenv,k,ts->hd);
      inst = new List(new $(tvs->hd,ts->hd),inst);
    }
    if (ts != NULL)
      terr(loc,"too many parameters for typedef %s",qvar2string(tdn));
    if (tvs != NULL) {
      list_t<type_t> hidden_ts = NULL;
      // too few parameters plug them in for the user using evars
      for (; tvs != NULL; tvs = tvs->tl) {
        kind_t k = conref_val(tvs->hd->kind);
        type_t e = new_evar(NULL,NULL);
        hidden_ts = new List(e,hidden_ts);
        cvtenv = i_check_valid_type(loc,te,cvtenv,k,e);
        inst = new List(new $(tvs->hd,e),inst);
      }
      // add the hidden type arguments back in so error messages are decent
      *targs_ref = List::imp_append(targs,List::imp_rev(hidden_ts));
    }
    type_t new_typ = substitute(inst,td->defn);
    *toptp = new Opt(new_typ);
    break;
  case HeapRgn:
    break;
  case &RgnHandleType(t2): fallthru(t2);
  case &AccessEff(t2): 
    cvtenv = i_check_valid_type(loc,te,cvtenv,RgnKind,t2);
    break;
  case &RgnsEff(t2):
    cvtenv = i_check_valid_type(loc,te,cvtenv,AnyKind,t2);
    break;
  case &JoinEff(ts):
    for (; ts != NULL; ts = ts->tl)
      cvtenv = i_check_valid_type(loc,te,cvtenv,EffKind,ts->hd);
    break;
  } 
  if (!kind_leq(typ_kind(t), expected_kind))
    terr(loc,"type %s has kind %s but as used here needs kind %s",
         typ2string(t), kind2string(typ_kind(t)), 
         kind2string(expected_kind));
  return cvtenv;
}

static cvtenv_t check_valid_type(seg_t loc, tenv_t te, 
                                 list_t<tvar_t,`H> kind_env, 
                                 kind_t expected_kind, 
                                 bool generalize_evars,
                                 type_t t) {
  let cvt = i_check_valid_type(loc,te,
                               CVTEnv{kind_env,NULL,NULL,
                                      generalize_evars,false},
                               expected_kind,t);

  for (_ vs = cvt.free_vars; vs != NULL; vs = vs->tl)
    cvt.kind_env = fast_add_free_tvar(kind_env,vs->hd);

  // run through the evars and constrain them so that when unified,
  // the resulting type can only have type variables drawn from the
  // kind environment or the set of free type variables mentioned here.
  for (_ evs = cvt.free_evars; evs != NULL; evs = evs->tl) {
    switch (compress(evs->hd)) {
    case &Evar(_,_,_,*s): 
      if (*s == NULL)
        *s = new Opt(kind_env); 
      else {
        // constrain to the intersection of the contexts
        let tvs = (*s)->v;
        let result = NULL;
        for (; tvs != NULL; tvs = tvs->tl) {
          if (List::mem(fast_tvar_cmp,kind_env,tvs->hd)) {
            result = new List(tvs->hd,result);
          }
        }
        *s = new Opt(result);
      }
      break;
    default: break;
    }
  }
  return cvt;
}

// Same as check_valid_type except that for function types, we check
// that either the bound type variables are empty (in which case we
// plug them in) or else the free type variables are contained in the
// list of the bound type variables and have the right kinds.
void check_valid_toplevel_type(seg_t loc, tenv_t te, type_t t) {
  bool generalize_evars = is_function_type(t);
  let cvt = check_valid_type(loc, te, NULL, MemKind, generalize_evars, t);
  let free_tvars = cvt.free_vars;
  let free_evars = cvt.free_evars;

  // force type variables of unresolved or mem kinds to boxed kinds
  for (_ x = free_tvars; x != NULL; x = x->tl) {
    conref_t<kind_t> c = compress_conref(x->hd->kind);
    switch (c->v) {
    case No_constr: 
    case &Eq_constr(MemKind): c->v = new Eq_constr(BoxKind); break;
    default: break;
    }
  }
  if (free_tvars != NULL || free_evars != NULL) {
    switch (compress(t)) {
    case &FnType(FnInfo{*btvs,eff,tr,args,c_vararg,cyc_vararg,rgn_po,atts}):
      if (*btvs == NULL) {
        // abstract the free tvars
        *btvs = free_tvars;
        free_tvars = NULL;
      }
      break;
    default: break;
    }
    if (free_tvars != NULL) 
      terr(loc,"unbound type variable %s",*free_tvars->hd->name);
    // we can constrain the region evars to HeapRgn and the 
    // effect evars to the empty effect, but we're out of luck
    // for the type variables.
    if (free_evars != NULL) {
      for (; free_evars != NULL; free_evars = free_evars->tl) {
        type_t e = free_evars->hd;
        switch (typ_kind(e)) {
        case RgnKind: 
          if (!unify(e,HeapRgn)) impos("can't unify evar with heap!");
          break;
        case EffKind: 
          if (!unify(e,empty_effect)) impos("can't unify evar with {}!");
          break;
        default:
          terr(loc,"hidden type variable %s isn't abstracted in type %s",
               typ2string(e), typ2string(t));
          break;
        }
      }
    }
  }
}
    

// Check that the function declaration has a valid type:  all
// we do is build a FnType and then check that it is well-formed
// which has the side effect of giving us the effect and any
// bound type variables.
void check_fndecl_valid_type(seg_t loc,tenv_t te,fndecl_t fd) {
  type_t t = fndecl2typ(fd);
  // this fills in the missing bound type variables and effects
  check_valid_toplevel_type(loc,te,t);
  switch (compress(t)) {
  case &FnType(FnInfo{tvs,effect,rt,args,c_varargs,cyc_varargs,rgn_rpo,atts}):
    fd->tvs = tvs;
    fd->effect = effect;
    break;
  default: impos("check_fndecl_valid_type: not a FnType"); return;
  };
  // check for repeated paramater names (not allowed in C and makes no sense)
  region r {
    check_unique_vars(rmap(r,fst_fdarg,fd->args), loc, 
		      "function declaration has repeated parameter");
  }
  // cache the type on the declaration so we don't have to recompute it
  fd->cached_typ = new Opt(t);
}

// Same as check_valid_type except that we ensure the free type variables
// are drawn from the given set of bound type variables.
void check_type(seg_t loc, tenv_t te, 
                list_t<tvar_t,`H> bound_tvars, 
                kind_t expected_kind, bool allow_evars, type_t t) {
  let cvt = check_valid_type(loc,te,bound_tvars,expected_kind,false,t);
  let free_tvars = remove_bound_tvars(cvt.free_vars, bound_tvars);
  let free_evars = cvt.free_evars;
  for (_ fs = free_tvars; fs != NULL; fs = fs->tl) {
    let ftvn = fs->hd->name;
    terr(loc,"unbound type variable %s in type %s",*ftvn,typ2string(t));
  }
  if (!allow_evars && free_evars != NULL) {
    for (; free_evars != NULL; free_evars = free_evars->tl) {
      type_t e = free_evars->hd;
      switch (typ_kind(e)) {
      case RgnKind: 
        if (!unify(e,HeapRgn)) impos("can't unify evar with heap!");
          break;
      case EffKind: 
        if (!unify(e,new JoinEff(NULL))) impos("can't unify evar with {}!");
        break;
      default:
        terr(loc,"hidden type variable %s isn't abstracted in type %s",
             typ2string(e), typ2string(t));
        break;
      }
    }
  }
}

void add_tvar_identity(tvar_t tv) {
  if (tv->identity == NULL) 
    tv->identity = new_tvar_id();
}

void add_tvar_identities(list_t<tvar_t,`r> tvs) {
  List::iter(add_tvar_identity,tvs);
}

// Note: we expect lists to be very short.  Otherwise, a hashtable would
// be a better choice.
static void check_unique_unsorted(int (@cmp)(`a,`a), list_t<`a,`r> vs,
				  seg_t loc, 
				  string_t a2string(`a), string_t msg) {
  for(; vs != NULL; vs = vs->tl)
    for(_ vs2 = vs->tl; vs2 != NULL; vs2 = vs2->tl)
      if(cmp(vs->hd, vs2->hd)== 0)
	terr(loc, "%s: %s",msg,a2string(vs->hd));
}

static string_t<`r> strptr2string(string_t<`r> @s) {
  return *s;
}

void check_unique_vars(list_t<var_t,`r> vs, seg_t loc, string_t msg)
{
  check_unique_unsorted(zstrptrcmp,vs,loc,strptr2string,msg);
}

void check_unique_tvars(seg_t loc, list_t<tvar_t> tvs) {
  check_unique_unsorted(tvar_cmp,tvs,loc,tvar2string,
                        "duplicate type variable");
}

// take a list of $(list_t<designator>,`a) things corresponding to a struct.
// ensure the struct is not abstract.
//  * check that each list_t<designator> has exactly one element which is a 
//    FieldName or is empty
//  * match up the correct member of sd->fields with the `a.  If the list
//    is empty, take the first unused field. ?????
//    Bang in the corresponding designator in the des list element
//  * ensure that each field is used exactly once.
// (This functionality was repeated in tcPat and tcExp and was annoying me.)
// FIX: Pass in a flag to allow multiple field names ??
list_t<$(structfield_t,`a)@`r,`r>
resolve_struct_designators(region_t<`r> rgn, seg_t loc,
                           list_t<$(list_t<designator_t>,`a)@`r2,`r3> des, 
                           list_t<structfield_t> sdfields) {

  // grab all the fields and mark them unused unless the field has an
  // empty name -- these are bitfields for padding and shouldn't be
  // initialized or projected.
  list_t<$(structfield_t,bool)@> fields = NULL;
  for(_ sd_fields = sdfields; sd_fields != NULL; sd_fields = sd_fields->tl) {
    if (strcmp(*sd_fields->hd->name,"") != 0)
      fields = new List(new $(sd_fields->hd,false), fields);
  }
  fields = imp_rev(fields);

  // match up each element of des
  list_t<$(structfield_t,`a)@`r,`r> ans = NULL;
  for(; des != NULL; des = des->tl) {
    let &$(dl,a) = des->hd;
    if(dl == NULL) {
      // grab first unused
      let fields2 = fields;
      for(; fields2 != NULL; fields2 = fields2->tl)
	if(!(*fields2->hd)[1]) {
	  (*fields2->hd)[1] = true;
	  (*des->hd)[0] = new List(new FieldName((*fields2->hd)[0]->name), NULL);
	  ans = rnew(rgn) List(rnew(rgn) $((*fields2->hd)[0],a), ans);
	  break;
	}
      if(fields2 == NULL)
	terr(loc, "too many arguments to struct");
    } else if(dl->tl != NULL)
      // we don't support multiple designators
      terr(loc, "multiple designators are not supported");
    else
      // find the right field based on the designator
      switch (dl->hd) {
      case &ArrayElement(_): 
	terr(loc, "array designator used in argument to struct");
	break;
      case &FieldName(v):
	let fields2 = fields;
	for(; fields2 != NULL; fields2 = fields2->tl)
	  if(zstrptrcmp(v,((*fields2->hd)[0])->name) == 0) {
	    if((*fields2->hd)[1])
	      terr(loc, "field %s has already been used as an argument", *v);
	    (*fields2->hd)[1] = true;
	    ans = rnew(rgn) List(rnew(rgn) $((*fields2->hd)[0],a), ans);
	    break;
	  }
	if(fields2 == NULL)
	  terr(loc, "bad field designator %s", *v);
	break;
      }
  }
  
  // make sure we used all the fields
  for(; fields != NULL; fields = fields->tl)
    if(!(*fields->hd)[1]) {
      terr(loc, "too few arguments to struct");
      break;
    }

  return imp_rev(ans);
}

bool is_tagged_pointer_typ_elt(type_t t, type_t@`r elt_typ_dest) {
  switch (compress(t)) {
  case &PointerType(PtrInfo{elt_typ,_,_,_,b}):
    let b = compress_conref(b);
    switch (compress_conref(b)->v) {
    case &Eq_constr(Unknown_b): 
      *elt_typ_dest = elt_typ; 
      return true;
    case No_constr: 
      b->v = new Eq_constr((bounds_t)Unknown_b); 
      *elt_typ_dest = elt_typ; 
      return true;
    default: return false;
    }
  default: return false;
  }
}

bool is_tagged_pointer_typ(type_t t) {
  type_t ignore = VoidType;
  return is_tagged_pointer_typ_elt(t, &ignore);
}

// used by address of.  
// Ensure e is an lvalue or function designator.
// Return if &e is const (true for const) and what region e is in (via a type
//    of RgnKind).
// FIX: not sure const is sufficient to prevent assigning to a function
//      designator???
// Type errors should already have been reported, so we often silently return
//   a bogus answer to avoid duplicate errors.
// Note: regions might not be resolved (unification is order-dependent),
//   but that's okay because a later unification will ensure soundness.
// Note: As explained below, if e1 is a FixedArray, then &e1[e2] is only
//   legal if e1 is an lvalue.  This is not true in C, but I need it, at least
//   for now, and I doubt anyone minds.
$(bool,type_t) addressof_props(tenv_t te, exp_t e) {
  // in some situations, the pointer must actually be const
  $(bool,type_t) bogus_ans = $(false, HeapRgn);
  switch (e->r) {
  case &Var_e(q,x):
    // where oh where does my variable live?
    switch(x) {
    case Unresolved_b: return bogus_ans;
    case &Funname_b(_): return $(false, HeapRgn); 
    case &Global_b(vd): 
      switch (compress(e->topt->v)) {
	// arrays cannot be modified
      case &ArrayType(_,_,_): return $(true, HeapRgn);
      default: return $(vd->tq.q_const,HeapRgn);
      }
    case &Local_b(vd):  
      switch (compress(e->topt->v)) {
      case &ArrayType(_,_,_): return $(true, vd->rgn->v);
      default: return $(vd->tq.q_const, vd->rgn->v);
      }
    case &Pat_b(vd):   fallthru(vd);
    case &Param_b(vd): return $(vd->tq.q_const, vd->rgn->v);
    }
  case &StructMember_e(e1,f):
    // we have an unboxed thing, so we inherit e2's region
    // must check that f isn't a bitfield.
    switch (compress(e1->topt->v)) {
    case &AnonStructType(fs): fallthru(fs);
    case &AnonUnionType(fs):
      let finfo = lookup_field(fs,f);
      if(finfo != NULL && finfo->width != NULL)
	return $(finfo->tq.q_const, addressof_props(te,e1)[1]);
      return bogus_ans;
    case &StructType(_,_,&sd):
      let finfo = lookup_struct_field(sd,f);
      if(finfo != NULL && finfo->width != NULL)
	return $(finfo->tq.q_const, addressof_props(te,e1)[1]);
      return bogus_ans;
    case &UnionType(_,_,&ud):
      let finfo = lookup_union_field(ud,f);
      if (finfo != NULL)
        return $(finfo->tq.q_const, addressof_props(te,e1)[1]);
      fallthru;
    default: return bogus_ans;
    }
  case &StructArrow_e(e1,f): 
    // we have a boxed thing, so the region is in the pointer-type.
    // must check that f isn't a bitfield.
    switch (compress(e1->topt->v)) {
    case &PointerType(PtrInfo{t1,r,_,_,_}): 
      switch (compress(t1)) {
      case &AnonStructType(fs): fallthru(fs);
      case &AnonUnionType(fs):
        let finfo = lookup_field(fs,f);
	if(finfo != NULL && finfo->width != NULL)
	  return $(finfo->tq.q_const, r);
	return bogus_ans;
      case &StructType(_,_,&sd):
	let finfo = lookup_struct_field(sd,f);
	if(finfo != NULL && finfo->width != NULL)
	  return $(finfo->tq.q_const, r);
	return bogus_ans;
      case &UnionType(_,_,&ud):
	let finfo = lookup_union_field(ud,f);
	if(finfo != NULL)
	  return $(finfo->tq.q_const, r);
	return bogus_ans;
      default: return bogus_ans;
      }
    default: return bogus_ans;
    }
  case &Deref_e(e1):
    // we have a boxed thing, so the region is in the pointer-type.
    switch (compress(e1->topt->v)) {
    case &PointerType(PtrInfo{_,r,_,tq,_}): 
      return $(tq.q_const, r); // FIX: is tq set correctly?
    default: return bogus_ans;
    }

  case &Subscript_e(e1,e2):
    // here we need to figure out whether we've got a boxed thing
    // or not because [] is overloaded for all array kinds, and tuples
    // FIX: eventually a tagged array's elements may live in a region, for now, 
    // they always in the heap
    type_t t = compress(e1->topt->v);
    switch (t) {
    case &ArrayType(_,tq,_): 
      // Actually, this should be impossible since we've surely
      // promoted e1 to a pointer.
      // NOTE: Unlike C, we cannot allow any e1 -- it must be an lvalue.
      // (C doesn't need to know the region and we do!)
      return $(tq.q_const, addressof_props(te,e1)[1]);
    case &TupleType(ts):
      // We need an lvalue in this unboxed case whereas "C w/ tuples" wouldn't.
      let finfo = lookup_tuple_field(ts,Evexp::eval_const_uint_exp(e2));
      if(finfo != NULL)
	return $((*finfo)[0].q_const, addressof_props(te,e1)[1]);
      return bogus_ans;

    case &PointerType(PtrInfo{t2,r,_,tq,b}): 
      return $(tq.q_const,r);
    default: return bogus_ans;
    }
  default: 
    terr(e->loc,"unary & applied to non-lvalue");
    return bogus_ans;
  }
}

// Coerce an expression of array type to a pointer type.  In
// certain situations, we undo this coercion, notably when e is
// a string constant or Array_e expression occurring as follows:
//    t x[c] = e
//    {.... e ... }  where the {...} is an Array_e
//    Foo(.... e ....)  where Foo is a struct or [x]tunion with a 
//     corresponding field that has type t 
type_t array_to_ptr(tenv_t te, type_t e_typ, exp_t e) {
  switch (compress(e_typ)) {
  case &ArrayType(t,tq,_):
    let $(_,rgn) = addressof_props(te,e);
    return atb_typ(t,rgn,tq,new Upper_b(e));
  default: 
    return e_typ;
  }
}

// give an error when we can statically tell that the array bounds
// aren't large enough -- if the bounds are unconstrained, set them
// to i+1.
void check_bound(seg_t loc, unsigned int i, conref_t<bounds_t> b) {
  b = compress_conref(b);
  switch (b->v) {
  case &Eq_constr(Unknown_b): return; // checked dynamically
  case &Eq_constr(&Upper_b(e)):
    if (Evexp::eval_const_uint_exp(e) <= i)
      terr(loc, "dereference is out of bounds");
    return;
  default:
    // constrain the bounds to be i+1
    b->v = new Eq_constr((bounds_t)(new Upper_b(uint_exp(i+1,NULL))));
    return;
  }
}

void check_nonzero_bound(seg_t loc, conref_t<bounds_t> b) {
  check_bound(loc, 0, b);
}

bool is_bound_one(conref_t<bounds_t> b) {
  switch(compress_conref(b)->v) {
  case &Eq_constr(&Upper_b(e)): return Evexp::eval_const_uint_exp(e)==1;
  default: return false;
  }
}

bool bits_only(type_t t) {
  switch (compress(t)) {
  case VoidType: 
  case &IntType(_,_): 
  case FloatType: 
  case DoubleType: return true;
  case &EnumType(_,_): return false; //could be true but for pattern exhaustion!
  case &ArrayType(t,_,_): return bits_only(t);
  case &TupleType(tqs):
    for (; tqs != NULL; tqs = tqs->tl) 
      if (!bits_only((*tqs->hd)[1])) return false;
    return true;
  case &StructType(_,ts,sdp):
    if (sdp == NULL) return false;
    let sd = *sdp;
    if (sd->fields == NULL) return false;
    region rgn {
      let inst = List::rzip(rgn,rgn,sd->tvs,ts);
      for (_ fs = sd->fields->v; fs != NULL; fs = fs->tl)
	if (!bits_only(rsubstitute(rgn,inst,fs->hd->type))) return false;
      return true;
    }
  case &UnionType(_,ts,udp):
    if (udp == NULL) return false;
    let ud = *udp;
    if (ud->fields == NULL) return false;
    region rgn {
      let inst = List::rzip(rgn,rgn,ud->tvs,ts);
      for (_ fs = ud->fields->v; fs != NULL; fs = fs->tl)
	if (!bits_only(rsubstitute(rgn,inst,fs->hd->type))) return false;
      return true;
    }
  case &AnonStructType(fs): fallthru(fs);
  case &AnonUnionType(fs):
    for (; fs != NULL; fs = fs->tl)
      if (!bits_only(fs->hd->type)) return false;
    return true;
  default: return false;
  }
}

// FIX: there are other expressions we could allow, such as
// &(x->y) or &(x[0]) that we do not support here...
// RENAME
// Actually need to distinguish two kinds of constant expressions, as in ANSI C
// This is now sort of for top-level expressions
static bool cnst_exp(tenv_t te, bool var_okay, exp_t e) {
  switch (e->r) {
  case &Const_e(_):     return true;
  case &Sizeoftyp_e(_): return true;
  case &Sizeofexp_e(_): return true; // exp is not evaluated
    // jcheney: offsetof is constant?? need it to be for typerep anyway...
  case &Offsetof_e(_,_): return true;
  case &Gentyp_e(_,_):    return true;
  case &Enum_e(_,_,_):  return true;
  case &Var_e(qv,_):
    // NB: top-level function names and arrays are "constant"
    // Ignore unbound variables b/c should be reported elsewhere
    try switch (lookup_ordinary(te, e->loc, qv)) {
    case &VarRes(&Funname_b(_)): return true;
    case &VarRes(&Global_b(vd)):
      switch (compress(vd->type)) {
      case &ArrayType(_,_,_): return true;
      default: return var_okay;
      }
    case &VarRes(Unresolved_b): return false;
    default: return var_okay;
    } catch { case Dict::Absent: return false; }

  case &Conditional_e(e1,e2,e3):
    return (cnst_exp(te,false,e1)
            && cnst_exp(te,false,e2)
            && cnst_exp(te,false,e3));
  case &SeqExp_e(e1,e2):
    return (cnst_exp(te,false,e1) && cnst_exp(te,false,e2));
  case &NoInstantiate_e(e2): fallthru(e2);
  case &Instantiate_e(e2,_):
    return cnst_exp(te,var_okay,e2);
  case &Cast_e(t,e2):
    // FIX:  We cannot allow casts w/ run-time effect b/c C will complain!
    return cnst_exp(te,var_okay,e2);
  case &Address_e(e2): 
    return cnst_exp(te,true,e2);
  case &Comprehension_e(_,e1,e2):
    return cnst_exp(te,false,e1) && cnst_exp(te,false,e2);
  case &Array_e(des): fallthru(des);
  case &AnonStruct_e(_,des): fallthru(des);
  case &Struct_e(_,_,des,_):
    for (; des != NULL; des = des->tl)
      if (!cnst_exp(te,false,(*des->hd)[1]))
        return false;
    return true;

  case &Primop_e(p,es):     fallthru(es);
  case &Tuple_e(es):        fallthru(es);
  case &Tunion_e(_,_,es,_,_):
    for (; es != NULL; es = es->tl)
      if (!cnst_exp(te,false,es->hd))
        return false;
    return true;
  default:
    return false;
  }
}

bool is_const_exp(tenv_t te, exp_t e) {
  return cnst_exp(te,false,e);
}

static bool fields_support_default(list_t<tvar_t> tvs, list_t<type_t> ts, 
                                   list_t<structfield_t> fs);
bool supports_default(type_t t) {
  switch (compress(t)) {
  case VoidType: 
  case &IntType(_,_): 
  case FloatType: 
  case DoubleType: return true;

  case &PointerType(PtrInfo{_,_,nullable,_,bounds}):
    switch (compress_conref(bounds)->v) {
    case &Eq_constr(Unknown_b): return true;
    case &Eq_constr(&Upper_b(_)):
      switch (compress_conref(nullable)->v) {
      case &Eq_constr(b): return b;
      default: return false;
      }
    default: return false;
    }
  case &ArrayType(t,_,_): return supports_default(t);
  case &TupleType(tqs):
    for (; tqs != NULL; tqs = tqs->tl)
      if (!supports_default((*tqs->hd)[1])) return false;
    return true;
  case &StructType(_,ts,sdp):
    if (sdp == NULL) return false;
    structdecl_t sd = *sdp;
    if (sd->fields == NULL) return false;
    return fields_support_default(sd->tvs, ts,sd->fields->v);
  case &UnionType(_,ts,udp):
    if (udp == NULL) return false;
    uniondecl_t ud = *udp;
    if (ud->fields == NULL) return false;
    return fields_support_default(ud->tvs, ts,ud->fields->v);
  case &AnonStructType(fs): fallthru(fs);
  case &AnonUnionType(fs):
    return fields_support_default(NULL,NULL,fs);

  case &EnumType(_,_): 
    // FIX: may not include 0!
    return true;

  default: return false;
  }
}

static bool fields_support_default(list_t<tvar_t> tvs, list_t<type_t> ts, 
                                   list_t<structfield_t> fs) {
  region rgn {
    let inst = List::rzip(rgn,rgn,tvs,ts);
    for (; fs != NULL; fs = fs->tl) {
      type_t t = rsubstitute(rgn,inst,fs->hd->type);
      if (!supports_default(t)) return false;
    }
  }
  return true;
}
