/* Routines for evaluating expressions that should be "constant".
   Copyright (C) 2001 Greg Morrisett, AT&T
   This file is part of the Cyclone compiler.

   The Cyclone compiler is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   The Cyclone compiler is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with the Cyclone compiler; see the file COPYING. If not,
   write to the Free Software Foundation, Inc., 59 Temple Place -
   Suite 330, Boston, MA 02111-1307, USA. */

// FIX: Add appropriate support for float, double, and long long

#include <core.h>
#include <list.h>
#include <position.h>

#include "absyn.h"
#include "absynpp.h"
#include "tcutil.h"
#include "evexp.h"

using Core;
using Absyn;
using List;
using Position;
using Absynpp;
using Tcutil;

namespace Evexp;

void exp_err(seg_t loc, string_t msg) {
  Position::post_error(Position::mk_err_elab(loc, xprintf("Exp_err: %s",msg)));
}

cnst_t eval_const_exp(exp_t e); // forward reference for mutual recursion

cnst_t promote_const(cnst_t cn) {
  switch (cn) {
  case &Char_c(sn,c):  return new Int_c(sn,(int)c);
  case &Short_c(sn,s): return new Int_c(sn,(int)s); 
  default:             return cn;
  }
}

unsigned int eval_const_uint_exp(exp_t e) {
  switch (promote_const(eval_const_exp(e))) {
  case &Int_c(_,i): return (unsigned int)i;
  default:         exp_err(e->loc,"expecting unsigned int"); return 0u;
  }
}

bool eval_const_bool_exp(exp_t e) {
  switch (promote_const(eval_const_exp(e))) {
  case &Int_c(_,b)     : return b != 0;
  case &LongLong_c(_,b): return b != 0;
  case Null_c         : return false;
  default             : exp_err(e->loc,"expecting bool"); return false;
  }
}

// called by tcSizeof (which ignores result) and eval_szof.
// Note in the latter case, this code really needs to be in sync with the
// type translation to C.
// Note that a StructType better be checked so we can get the structdecl
bool okay_szofarg(type_t t) {
  switch (Tcutil::compress(t)) {
  case VoidType: return false;
  case &VarType(tv):
    switch (conref_val(tv->kind)) {
    case BoxKind: return true;
    default:      return false;
    }
  case &Evar(&Opt{BoxKind},_,_,_): return true; // Possible?
  case &Evar(_,_,_,_): return false;
  case &TunionType(_): return true;
  case &TunionFieldType(TunionFieldInfo{&KnownTunionfield(_,tuf),_}):
    fallthru(tuf->typs);
  case &TupleType(tqs):
    for (; tqs != null; tqs = tqs->tl)
      if(!okay_szofarg((*tqs->hd)[1]))
	return false;
    return true;

  case &TunionFieldType(_): return false;

  case &PointerType(PtrInfo{_,_,_,_,b}):  
    switch (compress_conref(b)->v) {
    case &Eq_constr(Unknown_b): return true;
    case &Eq_constr(_): return true;
    default: return false;
    }
  case &IntType(_,_): return true;
  case FloatType:     return true;
  case DoubleType:    return true;
  case &ArrayType(t2,_,e): // assume e constant checked elsewhere
    return (e != null); 
  case &FnType(_): return false;
  case &RgnHandleType(_): return true;
  case &StructType(_,_,sdp):
    if(sdp == null)
      return Tcutil::impos("szof on unchecked StructType");
    let sd = *sdp;
    if(sd->fields == null)
      return false;
    fallthru(sd->fields->v);
  case &AnonStructType(fs):
    for(; fs != null; fs = fs->tl)
      if(!okay_szofarg(fs->hd->type))
	return false;
    return true;
  case &UnionType(_,ts,udp):
    if (udp == null)
      return Tcutil::impos("szof on unchecked UnionType");
    let ud = *udp;
    if (ud->fields == null)
      return false;
    fallthru(ud->fields->v);
  case &AnonUnionType(fs):
    for(; fs != null; fs = fs->tl)
      if(!okay_szofarg(fs->hd->type))
	return false;
    return true;
  case &EnumType(_,_): return true;
  case HeapRgn: return false;
  case &JoinEff(_):   return false;
  case &AccessEff(_): return false;

  case &TypedefType(_,_,_): 
    return Tcutil::impos(xprintf("szof typedeftype %s",typ2string(t)));
  }
}

cnst_t eval_const_unprimop(primop_t p,exp_t e) {
  cnst_t cn = promote_const(eval_const_exp(e));
  switch ($(p,cn)) {
  case $(Plus,_): return cn;
  case $(Minus,  &Int_c(s,i)):   return new Int_c(Signed,  -i);
  case $(Bitnot, &Int_c(s,i)):   return new Int_c(Unsigned,~i);
  case $(Not,    &Int_c(_,i)):   return new Int_c(Signed,  i == 0 ? 1 : 0);
  case $(Not,    Null_c)     :   return new Int_c(Signed,  1);
  default: 
    exp_err(e->loc,"bad constant expression");
    return cn;
  }
}

// FIX: should allow pointer-comparison of non-integers (eg. null==null)
cnst_t eval_const_binprimop(primop_t p,exp_t e1,exp_t e2) {
  let cn1 = promote_const(eval_const_exp(e1));
  let cn2 = promote_const(eval_const_exp(e2));
  sign_t s1, s2;
  int    i1, i2;
  switch (cn1) {
  case &Int_c(x,y): s1 = x; i1 = y; break;
  default: exp_err(e1->loc, "bad constant expression"); return cn1;
  }
  switch (cn2) {
  case &Int_c(x,y): s2 = x; i2 = y; break;
  default: exp_err(e2->loc, "bad constant expression"); return cn1;
  }
  switch (p) {
  case Div: fallthru;
  case Mod: 
    if (i2 == 0) {
      exp_err(e2->loc,"division by zero in constant expression");
      return cn1;
    }
    break;
  default: break;
  }
  bool has_u_arg = (s1 == (sign_t)Unsigned || s2 == (sign_t)Unsigned);
  unsigned int u1 = (unsigned int)i1;
  unsigned int u2 = (unsigned int)i2;
  int          i3 = 0;    // definite assignment not smart enough
  unsigned int u3 = 0;    // definite assignment not smart enough
  bool         b3 = true; // definite assignment not smart enough
  bool use_i3 = false;
  bool use_u3 = false;
  bool use_b3 = false;
  switch ($(p,has_u_arg)) {
  case $(Plus,     false): i3 = i1 +  i2; use_i3 = true; break;
  case $(Times,    false): i3 = i1 *  i2; use_i3 = true; break;
  case $(Minus,    false): i3 = i1 -  i2; use_i3 = true; break;
  case $(Div,      false): i3 = i1 /  i2; use_i3 = true; break;
  case $(Mod,      false): i3 = i1 %  i2; use_i3 = true; break;
  case $(Plus,      true): u3 = u1 +  u2; use_u3 = true; break;
  case $(Times,     true): u3 = u1 *  u2; use_u3 = true; break;
  case $(Minus,     true): u3 = u1 -  u2; use_u3 = true; break;
  case $(Div,       true): u3 = u1 /  u2; use_u3 = true; break;
  case $(Mod,       true): u3 = u1 %  u2; use_u3 = true; break;
  case $(Eq,           _): b3 = i1 == i2; use_b3 = true; break;
  case $(Neq,          _): b3 = i1 != i2; use_b3 = true; break;
  case $(Gt,       false): b3 = i1 >  i2; use_b3 = true; break;
  case $(Lt,       false): b3 = i1 <  i2; use_b3 = true; break;
  case $(Gte,      false): b3 = i1 >= i2; use_b3 = true; break;
  case $(Lte,      false): b3 = i1 <= i2; use_b3 = true; break;
  case $(Gt,        true): b3 = u1 >  u2; use_b3 = true; break;
  case $(Lt,        true): b3 = u1 <  u2; use_b3 = true; break;
  case $(Gte,       true): b3 = u1 >= u2; use_b3 = true; break;
  case $(Lte,       true): b3 = u1 <= u2; use_b3 = true; break;
  case $(Bitand,       _): u3 = u1 &  u2; use_u3 = true; break;
  case $(Bitor,        _): u3 = u1 |  u2; use_u3 = true; break;
  case $(Bitxor,       _): u3 = u1 ^  u2; use_u3 = true; break;
  case $(Bitlshift,    _): u3 = u1 << u2; use_u3 = true; break;
  case $(Bitlrshift,   _): u3 = u1 >> u2; use_u3 = true; break;
  case $(Bitarshift,   _): exp_err(e1->loc, ">>> NOT IMPLEMENTED"); return cn1;
  default: exp_err(e1->loc, "bad constant expression"); return cn1;
  }
  if(use_i3) return new Int_c(Signed,   i3);
  if(use_u3) return new Int_c(Unsigned, (int)u3);
  if(use_b3) return new Int_c(Signed, b3 ? 1 : 0);
  throw new Unreachable("Evexp::eval_const_binop");
}

// The main routine -- side-effects the expression e, overwriting its
// r field with the resulting constant (only if there's no error)
cnst_t eval_const_exp(exp_t e) {
  cnst_t cn;
  switch (e->r) {
  case &Const_e(c): return c; // return eagerly to avoid allocation
  case &Conditional_e(e1,e2,e3):
    cn = (eval_const_bool_exp(e1) ? eval_const_exp(e2) : eval_const_exp(e3));
    break;
  case &Primop_e(p,es):
    if (es == null) {
      exp_err(e->loc,"bad static expression (no args to primop)");
      return new Int_c(Signed,0);
    }
    if (es->tl == null) 
      cn = eval_const_unprimop(p,es->hd);
    else if (es->tl->tl != null) {
      exp_err(e->loc,"bad static expression (too many args to primop)");
      return new Int_c(Signed,0);
    } else 
      cn = eval_const_binprimop(p,es->hd,es->tl->hd);
    break;
  case &Sizeoftyp_e(_): fallthru;
  case &Sizeofexp_e(_):
    exp_err(e->loc, 
	    "sizeof(...) is not an integral constant expression in Cyclone");
    return new Int_c(Signed,0);
  case &Offsetof_e(_,_):
    exp_err(e->loc, 
	    "offsetof(...) is not an integral constant expression in Cyclone");
    return new Int_c(Signed,0);
  case &Cast_e(t,e2):
    // FIX: this needs to be generalized
    cn = eval_const_exp(e2);
    switch ($(compress(t),cn)) {
    case $(&IntType(sn,sz),&Char_c(sn2,x)):  fallthru(sn,sz,sn2,x);
    case $(&IntType(sn,sz),&Short_c(sn2,x)): fallthru(sn,sz,sn2,x);
    case $(&IntType(sn,sz),&Int_c(sn2,x)): 
      if(sn != sn2)
	cn = new Int_c(sn,x); 
      break;
    default:
      exp_err(e->loc,xprintf("eval_const: cannot cast to %s",typ2string(t)));
      return new Int_c(Signed,0);
    }
    break;
  case &Enum_e(_,_,ef):
    return eval_const_exp((exp_t)ef->tag);
  default: 
    exp_err(e->loc,"bad static expression");
    return new Int_c(Signed,0);
  }
  e->r = new Const_e(cn);
  return cn;
}
