// Routines for evaluating expressions that should be "constant".

#include "core.h"
#include "list.h"
#include "position.h"
#include "absyn.h"
#include "absynpp.h"
#include "tcutil.h"
#include "evexp.h"

namespace Evexp;

using Core;
using Absyn;
using List;
using Position;
using Absynpp;

void exp_err(segment loc, string msg) {
  Position::post_error(Position::mk_err_elab(loc, 
					     xprintf("Exp_err: %s\n",msg)));
}

// forward references
extern cnst promote_const(cnst cn);
extern cnst eval_const_exp(exp e);
extern cnst eval_const_unprimop(primop p,exp e);
extern cnst eval_const_binprimop(primop p,exp e1,exp e2);
extern cnst eval_sizeof(typ t);

unsigned int eval_const_uint_exp(exp e) {
  switch (promote_const(eval_const_exp(e))) {
  case Int_c(_,i): return (unsigned int)i;
  default:         exp_err(e->loc,"expecting unsigned int"); return 0u;
  }
}

// FIX: What about LongLong?
cnst promote_const(cnst cn) {
  switch (cn) {
  case Char_c(sn,c): 
    cn = Int_c(sn,(int)c);
    break;
  case Short_c(sn,s):
    cn = Int_c(sn,(int)s);
    break;
  default: break; // skip
  }
  return cn;
}

bool eval_const_bool_exp(exp e) {
  switch (promote_const(eval_const_exp(e))) {
  case Int_c(_,b)     : return b != 0;
  case LongLong_c(_,b): return b != 0;
  case Null_c         : return false;
  default             : exp_err(e->loc,"expecting bool"); return false;
  }
}

// The main routine -- side-effects the expression e, overwriting its
// r field with the resulting constant (only if there's no error)
cnst eval_const_exp(exp e) {
  cnst cn;
  switch (e->r) {
  case Const_e(c):
    cn = c;
    break;
  case Conditional_e(e1,e2,e3):
    cn = (eval_const_bool_exp(e1) ? eval_const_exp(e2) : eval_const_exp(e3));
    break;
  case Primop_e(p,es):
    if (es == null) {
      exp_err(e->loc,"bad static expression (no args to primop)");
      return Int_c(Signed,0);
    }
    if (es->tl == null) 
      cn = eval_const_unprimop(p,es->hd);
    else if (es->tl->tl != null) {
      exp_err(e->loc,"bad static expression (too many args to primop)");
      return Int_c(Signed,0);
    } else 
      cn = eval_const_binprimop(p,es->hd,es->tl->hd);
    break;
  case Sizeof_e(t):
    cn = eval_sizeof(t);
    break;
  case Cast_e(t,e2):
    // FIX: this needs to be generalized
    cn = eval_const_exp(e2);
    switch (t) {
    case IntType(sn,sz,bx):
      if (bx == Boxed) {
        exp_err(e->loc,xprintf("eval_const: cannot cast to %s",typ2string(t)));
        return Int_c(Signed,0);
      }
      switch (cn) {
      case Int_c(sn2,x):
        cn = Int_c(sn,x);
        break;
      default:
        exp_err(e->loc,xprintf("eval_const: cannot cast to %s",typ2string(t)));
        return Int_c(Signed,0);
      }
      break;
    default:
      exp_err(e->loc,xprintf("eval_const: cannot cast to %s",typ2string(t)));
      return Int_c(Signed,0);
    }
    break;
  default: 
    exp_err(e->loc,"bad static expression");
    return Int_c(Signed,0);
  }
  e->r = Const_e(cn);
  return cn;
}

static unsigned int szof(typ t) {
  switch (Tcutil::compress(t)) {
  case VoidType:   return 0u;
  case VarType(_): return 4u;
  case Evar(k,_,_): 
    if (k == BoxKind) return 4u; else return Tcutil::impos("szof evar");
  case EnumType(_,_): return 4u;
  case XenumType(_):  return 4u;
  case PointerType(_,_,_):    return 4u;
  case IntType(_,_, Boxed):   return 4u;
  case IntType(_,B1,Unboxed): return 1u;
  case IntType(_,B2,Unboxed): return 1u;
  case IntType(_,B4,Unboxed): return 1u;
  case IntType(_,B8,Unboxed): return 1u;
  case FloatType(_):          return 4u;
  case DoubleType(Boxed):     return 4u;
  case DoubleType(Unboxed):   return 8u;
  case ArrayType(_,_,TaggedArray):    return 4u;
  case ArrayType(t2,_,FixedArray(e)): //FIX: insert padding for alignment
		                      return szof(t2) * eval_const_uint_exp(e);
  case ArrayType(_,_,UntaggedArray):  return Tcutil::impos("szof []");
  case FnType(_,_,_,_): return 4u;
  case TupleType(tqs):
    // FIX: we need to insert padding to ensure alignment
    unsigned int s = 0;
    for (; tqs != null; tqs = tqs->tl)
      s += szof(tqs->hd[1]);
    return s;
  case StructType(tdnopt,ts):
    // FIX: we need the environment to calculate
    // FIX: we need to insert padding to ensure alignment
                           return Tcutil::impos("szof on structtype");
  case TypedefType(_,_,_): return Tcutil::impos("szof typedeftype");
  case UnionType:          return Tcutil::impos("szof uniontype");
  }
}

cnst eval_sizeof(typ t) {
  return Int_c(Unsigned,(int)szof(t));
}

bool is_arith_const(cnst cn) {
  switch (cn) {
  case Char_c(_,_): return true;
  case Int_c(_,_):  return true;
  case Float_c(_):  return true;
  default: return false;
  }
}

cnst eval_const_unprimop(primop p,exp e) {
  cnst cn = promote_const(eval_const_exp(e));
  switch ($(p,cn)) {
  case $(Plus,_): 
    if (!is_arith_const(cn)) 
      exp_err(e->loc,"expecting arithmetic constant");
    return cn;
  case $(Minus,  Int_c(s,i)): return Int_c(Signed,-i);
  case $(Not,    Int_c(_,i)): return Int_c(Signed,i == 0 ? 1 : 0);
  case $(Not,    Null_c)    : return Int_c(Signed,1);
  case $(Bitnot, Int_c(s,i)): return Int_c(Unsigned,~i);
  default: 
    exp_err(e->loc,"bad constant expression");
    return cn;
  }
}

// FIX: should allow pointer-comparison of non-integers (eg. null==null)
cnst eval_const_binprimop(primop p,exp e1,exp e2) {
  let cn1 = promote_const(eval_const_exp(e1));
  let cn2 = promote_const(eval_const_exp(e2));
  // FIX: See above, do non-integer possibilities here!
  sign s1, s2;
  int i1, i2;
  switch (cn1) {
  case Int_c(x,y): s1 = x; i1 = y; break;
  default: exp_err(e1->loc, "bad constant expression"); return cn1;
  }
  switch (cn2) {
  case Int_c(x,y): s2 = x; i2 = y; break;
  default: exp_err(e2->loc, "bad constant expression"); return cn1;
  }
  switch (p) {
  case Div: 
    if (i2 == 0) {
      exp_err(e2->loc,"division by zero in constant expression");
      return cn1;
    }
    break;
    // FIX: when implemented, delete above and just have fallthru;
  case Mod: 
    if (i2 == 0) {
      exp_err(e2->loc,"division by zero in constant expression");
      return cn1;
    }
    break;
  default: break;
  }
  bool has_u_arg = (s1 == Unsigned || s2 == Unsigned);
  unsigned int u1 = (unsigned int)i1;
  unsigned int u2 = (unsigned int)i2;
  int          i3 = 0;    // definite assignment not smart enough
  unsigned int u3 = 0;    // definite assignment not smart enough
  bool         b3 = true; // definite assignment not smart enough
  bool use_i3 = false;
  bool use_u3 = false;
  bool use_b3 = false;
  switch ($(p,has_u_arg)) {
  case $(Plus,     false): i3 = i1 +  i2; use_i3 = true; break;
  case $(Times,    false): i3 = i1 *  i2; use_i3 = true; break;
  case $(Minus,    false): i3 = i1 -  i2; use_i3 = true; break;
  case $(Div,      false): i3 = i1 /  i2; use_i3 = true; break;
  case $(Mod,      false): i3 = i1 %  i2; use_i3 = true; break;
  case $(Plus,      true): u3 = u1 +  u2; use_u3 = true; break;
  case $(Times,     true): u3 = u1 *  u2; use_u3 = true; break;
  case $(Minus,     true): u3 = u1 -  u2; use_u3 = true; break;
  case $(Div,       true): u3 = u1 /  u2; use_u3 = true; break;
  case $(Mod,       true): u3 = u1 %  u2; use_u3 = true; break;
  case $(Eq,           _): b3 = i1 == i2; use_b3 = true; break;
  case $(Neq,          _): b3 = i1 != i2; use_b3 = true; break;
  case $(Gt,       false): b3 = i1 >  i2; use_b3 = true; break;
  case $(Lt,       false): b3 = i1 <  i2; use_b3 = true; break;
  case $(Gte,      false): b3 = i1 >= i2; use_b3 = true; break;
  case $(Lte,      false): b3 = i1 <= i2; use_b3 = true; break;
  case $(Gt,        true): b3 = u1 >  u2; use_b3 = true; break;
  case $(Lt,        true): b3 = u1 <  u2; use_b3 = true; break;
  case $(Gte,       true): b3 = u1 >= u2; use_b3 = true; break;
  case $(Lte,       true): b3 = u1 <= u2; use_b3 = true; break;
  case $(Bitand,       _): u3 = u1 &  u2; use_u3 = true; break;
  case $(Bitor,        _): u3 = u1 |  u2; use_u3 = true; break;
  case $(Bitxor,       _): u3 = u1 ^  u2; use_u3 = true; break;
  case $(Bitlshift,    _): u3 = u1 << u2; use_u3 = true; break;
  case $(Bitlrshift,   _): u3 = u1 >> u2; use_u3 = true; break;
  case $(Bitarshift,   _): exp_err(e1->loc, ">>> NOT IMPLEMENTED"); return cn1;
  default: exp_err(e1->loc, "bad constant expression"); return cn1;
  }
  if(use_i3) return Int_c(Signed,   i3);
  if(use_u3) return Int_c(Unsigned, (int)u3);
  if(use_b3) return Int_c(Signed, b3 ? 1 : 0);
  throw Unreachable("Evexp::eval_const_binop");
}
