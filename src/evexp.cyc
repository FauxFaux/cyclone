// Routines for evaluating expressions that should be "constant".

#include "core.h"
#include "list.h"
#include "position.h"
#include "absyn.h"
#include "absynpp.h"
#include "tcutil.h"
#include "evexp.h"

using Core;
using Absyn;
using List;
using Position;
using Absynpp;
using Tcutil;

namespace Evexp;

void exp_err(seg_t loc, string msg) {
  Position::post_error(Position::mk_err_elab(loc, xprintf("Exp_err: %s",msg)));
}

// forward references
extern cnst_t promote_const(cnst_t cn);
extern cnst_t eval_const_exp(exp e);
extern cnst_t eval_const_unprimop(primop p,exp e);
extern cnst_t eval_const_binprimop(primop p,exp e1,exp e2);
extern cnst_t eval_sizeof(typ t, seg_t loc);

unsigned int eval_const_uint_exp(exp e) {
  switch (promote_const(eval_const_exp(e))) {
  case Int_c(_,i): return (unsigned int)i;
  default:         exp_err(e->loc,"expecting unsigned int"); return 0u;
  }
}

// FIX: What about LongLong?
cnst_t promote_const(cnst_t cn) {
  switch (cn) {
  case Char_c(sn,c):  return Int_c(sn,(int)c);
  case Short_c(sn,s): return Int_c(sn,(int)s); 
  default:            return cn;
  }
}

bool eval_const_bool_exp(exp e) {
  switch (promote_const(eval_const_exp(e))) {
  case Int_c(_,b)     : return b != 0;
  case LongLong_c(_,b): return b != 0;
  case Null_c         : return false;
  default             : exp_err(e->loc,"expecting bool"); return false;
  }
}

// The main routine -- side-effects the expression e, overwriting its
// r field with the resulting constant (only if there's no error)
cnst_t eval_const_exp(exp e) {
  cnst_t cn;
  switch (e->r) {
  case Const_e(c): return c; // return eagerly to avoid allocation
  case Conditional_e(e1,e2,e3):
    cn = (eval_const_bool_exp(e1) ? eval_const_exp(e2) : eval_const_exp(e3));
    break;
  case Primop_e(p,es):
    if (es == null) {
      exp_err(e->loc,"bad static expression (no args to primop)");
      return Int_c(Signed,0);
    }
    if (es->tl == null) 
      cn = eval_const_unprimop(p,es->hd);
    else if (es->tl->tl != null) {
      exp_err(e->loc,"bad static expression (too many args to primop)");
      return Int_c(Signed,0);
    } else 
      cn = eval_const_binprimop(p,es->hd,es->tl->hd);
    break;
  case Sizeof_e(t):
    cn = eval_sizeof(t,e->loc);
    break;
  case Cast_e(t,e2):
    // FIX: this needs to be generalized
    cn = eval_const_exp(e2);
    switch ($(t,cn)) {
    case $(IntType(sn,sz),Int_c(sn2,x)): 
      if(sn != sn2)
	cn = Int_c(sn,x); 
      break;
    default:
      exp_err(e->loc,xprintf("eval_const: cannot cast to %s",typ2string(t)));
      return Int_c(Signed,0);
    }
    break;
  default: 
    exp_err(e->loc,"bad static expression");
    return Int_c(Signed,0);
  }
  e->r = Const_e(cn);
  return cn;
}

// called by tcSizeof (which ignores result) and eval_szof.
// Note in the latter case, this code really needs to be in sync with the
// type translation to C.
// Note that a StructType better be checked so we can get the structdecl
unsigned int szof(typ t, seg_t loc) {
  switch (Tcutil::compress(t)) {
  case VoidType:   terr(loc,"cannot apply sizeof to void type"); return 0u;
  case VarType(tv):
    switch (conref_val(tv->kind)) {
    case BoxKind: return 4u;
    case AnyKind: 
      fallthru;
    case MemKind: 
      terr(loc,"cannot apply sizeof to a non-boxed type variable"); return 0u;
    case RgnKind:
      terr(loc,"cannot apply sizeof to a region"); return 0u;
    case EffKind:
      terr(loc,"cannot apply sizeof to an effect"); return 0u;
    }
  case Evar(BoxKind,_,_): return 4u; // Possible?
  case Evar(_,_,_): terr(loc,"cannot apply sizeof to unknown type"); return 0u;
  case EnumType(_,_,_):  return 4u;
  case XenumType(_,_):   return 4u;
  case PointerType(PtrInfo{_,_,_,_,b}):  
    switch (compress_conref(b)->v) {
    case Eq_constr(Unknown_b): return 12u;
    case Eq_constr(_): return 4u;
    default: 
      terr(loc,"bounds information not known for pointer type"); return 0u;
    }
  case IntType(_,B1): return 1u;
  case IntType(_,B2): return 1u;
  case IntType(_,B4): return 1u;
  case IntType(_,B8): return 1u;
  case FloatType:     return 4u;
  case DoubleType:    return 8u;
  case ArrayType(t2,_,e): 
    // FIX: insert padding for alignment
    return szof(t2,loc) * eval_const_uint_exp(e);
  case FnType(_): terr(loc, "cannot apply sizeof to function type"); return 0u;
  case TupleType(tqs):
    // FIX: we need to insert padding to ensure alignment
    unsigned int s = 0;
    for (; tqs != null; tqs = tqs->tl)
      s += szof((*tqs->hd)[1],loc);
    return s;
  case RgnHandleType(_): return 4u;
  case StructType(_,ts,sdp):
    // FIX: we need to insert padding to ensure alignment and deal
    // with packed and aligned attributes.
    if(sdp == null)
      return Tcutil::impos("szof on unchecked StructType");
    let sd = *sdp;
    if(sd->fields == null)
      terr(loc,"cannot apply sizeof to abstract struct type");
    unsigned int s = 0;
    for(let fs = sd->fields->v; fs != null; fs = fs->tl)
      s += szof(fs->hd->type,loc);
    return s;
  case HeapRgn: terr(loc, "cannot apply sizoef to a region"); return 0u;
  case TypedefType(_,_,_): return Tcutil::impos("szof typedeftype");
  case UnionType:          return Tcutil::impos("szof uniontype");
  case JoinEff(_): fallthru;
  case AccessEff(_): terr(loc, "cannot apply sizoef to an effect"); return 0u;
  }
}

cnst_t eval_sizeof(typ t,seg_t loc) {
  return Int_c(Unsigned,(int)szof(t,loc));
}

bool is_arith_const(cnst_t cn) {
  switch (cn) {
  case Char_c(_,_): return true;
  case Int_c(_,_):  return true;
  case Float_c(_):  return true;
  default: return false;
  }
}

cnst_t eval_const_unprimop(primop p,exp e) {
  cnst_t cn = promote_const(eval_const_exp(e));
  switch ($(p,cn)) {
  case $(Plus,_): 
    if (!is_arith_const(cn)) 
      exp_err(e->loc,"expecting arithmetic constant");
    return cn;
  case $(Minus,  Int_c(s,i)):   return Int_c(Signed,  -i);
  case $(Minus,  Short_c(s,i)): return Short_c(Signed,-i);
  case $(Minus,  Char_c(s,i)):  return Char_c(Signed, -i);
  case $(Not,    Int_c(_,i)):   return Int_c(Signed,  i == 0 ? 1 : 0);
  case $(Not,    Null_c)    :   return Int_c(Signed,  1);
  case $(Bitnot, Int_c(s,i)):   return Int_c(Unsigned,~i);
  default: 
    exp_err(e->loc,"bad constant expression");
    return cn;
  }
}

// FIX: should allow pointer-comparison of non-integers (eg. null==null)
cnst_t eval_const_binprimop(primop p,exp e1,exp e2) {
  let cn1 = promote_const(eval_const_exp(e1));
  let cn2 = promote_const(eval_const_exp(e2));
  // FIX: See above, do non-integer possibilities here!
  sign_t s1, s2;
  int    i1, i2;
  switch (cn1) {
  case Int_c(x,y): s1 = x; i1 = y; break;
  default: exp_err(e1->loc, "bad constant expression"); return cn1;
  }
  switch (cn2) {
  case Int_c(x,y): s2 = x; i2 = y; break;
  default: exp_err(e2->loc, "bad constant expression"); return cn1;
  }
  switch (p) {
  case Div: 
    if (i2 == 0) {
      exp_err(e2->loc,"division by zero in constant expression");
      return cn1;
    }
    break;
    // FIX: when implemented, delete above and just have fallthru;
  case Mod: 
    if (i2 == 0) {
      exp_err(e2->loc,"division by zero in constant expression");
      return cn1;
    }
    break;
  default: break;
  }
  bool has_u_arg = (s1 == Unsigned || s2 == Unsigned);
  unsigned int u1 = (unsigned int)i1;
  unsigned int u2 = (unsigned int)i2;
  int          i3 = 0;    // definite assignment not smart enough
  unsigned int u3 = 0;    // definite assignment not smart enough
  bool         b3 = true; // definite assignment not smart enough
  bool use_i3 = false;
  bool use_u3 = false;
  bool use_b3 = false;
  switch ($(p,has_u_arg)) {
  case $(Plus,     false): i3 = i1 +  i2; use_i3 = true; break;
  case $(Times,    false): i3 = i1 *  i2; use_i3 = true; break;
  case $(Minus,    false): i3 = i1 -  i2; use_i3 = true; break;
  case $(Div,      false): i3 = i1 /  i2; use_i3 = true; break;
  case $(Mod,      false): i3 = i1 %  i2; use_i3 = true; break;
  case $(Plus,      true): u3 = u1 +  u2; use_u3 = true; break;
  case $(Times,     true): u3 = u1 *  u2; use_u3 = true; break;
  case $(Minus,     true): u3 = u1 -  u2; use_u3 = true; break;
  case $(Div,       true): u3 = u1 /  u2; use_u3 = true; break;
  case $(Mod,       true): u3 = u1 %  u2; use_u3 = true; break;
  case $(Eq,           _): b3 = i1 == i2; use_b3 = true; break;
  case $(Neq,          _): b3 = i1 != i2; use_b3 = true; break;
  case $(Gt,       false): b3 = i1 >  i2; use_b3 = true; break;
  case $(Lt,       false): b3 = i1 <  i2; use_b3 = true; break;
  case $(Gte,      false): b3 = i1 >= i2; use_b3 = true; break;
  case $(Lte,      false): b3 = i1 <= i2; use_b3 = true; break;
  case $(Gt,        true): b3 = u1 >  u2; use_b3 = true; break;
  case $(Lt,        true): b3 = u1 <  u2; use_b3 = true; break;
  case $(Gte,       true): b3 = u1 >= u2; use_b3 = true; break;
  case $(Lte,       true): b3 = u1 <= u2; use_b3 = true; break;
  case $(Bitand,       _): u3 = u1 &  u2; use_u3 = true; break;
  case $(Bitor,        _): u3 = u1 |  u2; use_u3 = true; break;
  case $(Bitxor,       _): u3 = u1 ^  u2; use_u3 = true; break;
  case $(Bitlshift,    _): u3 = u1 << u2; use_u3 = true; break;
  case $(Bitlrshift,   _): u3 = u1 >> u2; use_u3 = true; break;
  case $(Bitarshift,   _): exp_err(e1->loc, ">>> NOT IMPLEMENTED"); return cn1;
  default: exp_err(e1->loc, "bad constant expression"); return cn1;
  }
  if(use_i3) return Int_c(Signed,   i3);
  if(use_u3) return Int_c(Unsigned, (int)u3);
  if(use_b3) return Int_c(Signed, b3 ? 1 : 0);
  throw Unreachable("Evexp::eval_const_binop");
}
