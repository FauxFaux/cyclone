/* Routines for evaluating expressions that should be "constant".
   Copyright (C) 2001 Greg Morrisett, AT&T
   This file is part of the Cyclone compiler.

   The Cyclone compiler is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   The Cyclone compiler is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with the Cyclone compiler; see the file COPYING. If not,
   write to the Free Software Foundation, Inc., 59 Temple Place -
   Suite 330, Boston, MA 02111-1307, USA. */

// FIX: Add appropriate support for float, double, and long long

#include <core.h>
#include <list.h>
#include <position.h>
#include <stdio.h>
#include "absyn.h"
#include "absynpp.h"
#include "tcutil.h"
#include "evexp.h"

using Core;
using Absyn;
using List;
using Position;
using Absynpp;
using Tcutil;

namespace Evexp;

cnst_t eval_const_exp(exp_t e); // forward reference for mutual recursion

cnst_t promote_const(cnst_t cn) {
  switch (cn) {
  case &Char_c(sn,c):  return new Int_c(sn,(int)c);
  case &Short_c(sn,s): return new Int_c(sn,(int)s); 
  default:             return cn;
  }
}

unsigned int eval_const_uint_exp(exp_t e) {
  switch (promote_const(eval_const_exp(e))) {
  case &Int_c(_,i): return (unsigned int)i;
  default:          terr(e->loc,"expecting unsigned int"); return 0u;
  }
}

bool eval_const_bool_exp(exp_t e) {
  switch (promote_const(eval_const_exp(e))) {
  case &Int_c(_,b)     : return b != 0;
  case &LongLong_c(_,b): return b != 0;
  case Null_c         : return false;
  default             : terr(e->loc,"expecting bool"); return false;
  }
}

// called by tcSizeof (which ignores result) and eval_szof.
// Note in the latter case, this code really needs to be in sync with the
// type translation to C.
// Note that an AggrType better be checked so we can get the aggrdecl
bool okay_szofarg(type_t t) {
  switch (Tcutil::compress(t)) {
  case VoidType: return false;
  case &VarType(tv):
    switch (tvar_kind(tv)) {
    case BoxKind: return true;
    default:      return false;
    }
  case &Evar(&Opt{BoxKind},_,_,_): return true; // Possible?
  case &Evar(_,_,_,_): return false;
  case &TunionType(_): return true;
  case &TunionFieldType(TunionFieldInfo{&KnownTunionfield(_,tuf),_}):
    fallthru(tuf->typs);
  case &TupleType(tqs):
    for (; tqs != NULL; tqs = tqs->tl)
      if(!okay_szofarg((*tqs->hd)[1]))
	return false;
    return true;

  case &TunionFieldType(_): return false;

  case &PointerType(PtrInfo{_,_,_,_,b}):  // ???
    switch (compress_conref(b)->v) {
    case &Eq_constr(_): return true;
    default: return false;
    }
  case &SizeofType(_):
  case &TagType(_):
  case &IntType(_,_): 
  case FloatType:    
  case &DoubleType(_): return true;
  case &ArrayType(t2,_,e): // assume e constant checked elsewhere
    return (e != NULL); 
  case &FnType(_): return false;
  case &RgnHandleType(_): return true;
  case &AggrType(AggrInfo(info,_)):
    _ ad;
    switch(info) {
    case &UnknownAggr(_,_): impos("szof on unchecked StructType");
    case &KnownAggr(&ad2): ad = ad2;
    }
    if(ad->fields == NULL)
      return false;
    fallthru(ad->fields->v);
  case &AnonAggrType(_,fs):
    for(; fs != NULL; fs = fs->tl)
      if(!okay_szofarg(fs->hd->type))
	return false;
    return true;
  case &EnumType(_,_):
  case &AnonEnumType(_): return true;
  case &TypeInt(_):
  case HeapRgn: 
  case &JoinEff(_):
  case &AccessEff(_):
  case &RgnsEff(_):   return false;
  case &TypedefType(_,_,td,_): 
    if (td == NULL || td->kind == NULL)
      impos(aprintf("szof typedeftype %s",typ2string(t)));
    else switch(td->kind->v) {
    case BoxKind: return true;
    default: return false;
    }
  }
}

cnst_t eval_const_unprimop(primop_t p,exp_t e) {
  cnst_t cn = promote_const(eval_const_exp(e));
  switch ($(p,cn)) {
  case $(Plus,_): return cn;
  case $(Minus,  &Int_c(s,i)): return new Int_c(Signed,  -i);
  case $(Bitnot, &Int_c(s,i)): return new Int_c(Unsigned,~i);
  case $(Not,    &Int_c(_,i)): return new Int_c(Signed,  i == 0 ? 1 : 0);
  case $(Not,    Null_c):      return new Int_c(Signed,  1);
  default: 
    terr(e->loc,"bad constant expression");
    return cn;
  }
}

// FIX: should allow pointer-comparison of non-integers (e.g., NULL==NULL)
cnst_t eval_const_binprimop(primop_t p,exp_t e1,exp_t e2) {
  let cn1 = promote_const(eval_const_exp(e1));
  let cn2 = promote_const(eval_const_exp(e2));
  sign_t s1, s2;
  int    i1, i2;
  switch (cn1) {
  case &Int_c(x,y): s1 = x; i1 = y; break;
  default: terr(e1->loc, "bad constant expression"); return cn1;
  }
  switch (cn2) {
  case &Int_c(x,y): s2 = x; i2 = y; break;
  default: terr(e2->loc, "bad constant expression"); return cn1;
  }
  switch (p) {
  case Div:
  case Mod: 
    if (i2 == 0) {
      terr(e2->loc,"division by zero in constant expression");
      return cn1;
    }
    break;
  default: break;
  }
  bool has_u_arg = (s1 == (sign_t)Unsigned || s2 == (sign_t)Unsigned);
  unsigned int u1 = (unsigned int)i1;
  unsigned int u2 = (unsigned int)i2;
  int          i3 = 0;    // definite assignment not smart enough
  unsigned int u3 = 0;    // definite assignment not smart enough
  bool         b3 = true; // definite assignment not smart enough
  bool use_i3 = false;
  bool use_u3 = false;
  bool use_b3 = false;
  switch ($(p,has_u_arg)) {
  case $(Plus,     false): i3 = i1 +  i2; use_i3 = true; break;
  case $(Times,    false): i3 = i1 *  i2; use_i3 = true; break;
  case $(Minus,    false): i3 = i1 -  i2; use_i3 = true; break;
  case $(Div,      false): i3 = i1 /  i2; use_i3 = true; break;
  case $(Mod,      false): i3 = i1 %  i2; use_i3 = true; break;
  case $(Plus,      true): u3 = u1 +  u2; use_u3 = true; break;
  case $(Times,     true): u3 = u1 *  u2; use_u3 = true; break;
  case $(Minus,     true): u3 = u1 -  u2; use_u3 = true; break;
  case $(Div,       true): u3 = u1 /  u2; use_u3 = true; break;
  case $(Mod,       true): u3 = u1 %  u2; use_u3 = true; break;
  case $(Eq,           _): b3 = i1 == i2; use_b3 = true; break;
  case $(Neq,          _): b3 = i1 != i2; use_b3 = true; break;
  case $(Gt,       false): b3 = i1 >  i2; use_b3 = true; break;
  case $(Lt,       false): b3 = i1 <  i2; use_b3 = true; break;
  case $(Gte,      false): b3 = i1 >= i2; use_b3 = true; break;
  case $(Lte,      false): b3 = i1 <= i2; use_b3 = true; break;
  case $(Gt,        true): b3 = u1 >  u2; use_b3 = true; break;
  case $(Lt,        true): b3 = u1 <  u2; use_b3 = true; break;
  case $(Gte,       true): b3 = u1 >= u2; use_b3 = true; break;
  case $(Lte,       true): b3 = u1 <= u2; use_b3 = true; break;
  case $(Bitand,       _): u3 = u1 &  u2; use_u3 = true; break;
  case $(Bitor,        _): u3 = u1 |  u2; use_u3 = true; break;
  case $(Bitxor,       _): u3 = u1 ^  u2; use_u3 = true; break;
  case $(Bitlshift,    _): u3 = u1 << u2; use_u3 = true; break;
  case $(Bitlrshift,   _): u3 = u1 >> u2; use_u3 = true; break;
  case $(Bitarshift,   _): terr(e1->loc, ">>> NOT IMPLEMENTED"); return cn1;
  default: terr(e1->loc, "bad constant expression"); return cn1;
  }
  if(use_i3) return new Int_c(Signed,   i3);
  if(use_u3) return new Int_c(Unsigned, (int)u3);
  if(use_b3) return new Int_c(Signed, b3 ? 1 : 0);
  impos("Evexp::eval_const_binop");
}

// The main routine -- side-effects the expression e, overwriting its
// r field with the resulting constant (only if there's no error)
cnst_t eval_const_exp(exp_t e) {
  cnst_t cn;
  switch (e->r) {
  case &Const_e(c): return c; // return eagerly to avoid allocation
  case &Conditional_e(e1,e2,e3):
    cn = (eval_const_bool_exp(e1) ? eval_const_exp(e2) : eval_const_exp(e3));
    break;
  case &Primop_e(p,es):
    if (es == NULL) {
      terr(e->loc,"bad static expression (no args to primop)");
      return new Int_c(Signed,0);
    }
    if (es->tl == NULL) 
      cn = eval_const_unprimop(p,es->hd);
    else if (es->tl->tl != NULL) {
      terr(e->loc,"bad static expression (too many args to primop)");
      return new Int_c(Signed,0);
    } else 
      cn = eval_const_binprimop(p,es->hd,es->tl->hd);
    break;
  case &Sizeoftyp_e(_): 
  case &Sizeofexp_e(_):
    terr(e->loc,
	 "sizeof(...) is not an integral constant expression in Cyclone");
    return new Int_c(Signed,0);
  case &Offsetof_e(_,_):
    terr(e->loc,
	 "offsetof(...) is not an integral constant expression in Cyclone");
    return new Int_c(Signed,0);
  case &Cast_e(t,e2):
    // FIX: this needs to be generalized
    cn = eval_const_exp(e2);
    switch ($(compress(t),cn)) {
    case $(&IntType(sn,sz),&Char_c(sn2,x)):  fallthru(sn,sz,sn2,x);
    case $(&IntType(sn,sz),&Short_c(sn2,x)): fallthru(sn,sz,sn2,x);
    case $(&IntType(sn,sz),&Int_c(sn2,x)): 
      if(sn != sn2)
	cn = new Int_c(sn,x); 
      break;
    default:
      terr(e->loc,"eval_const: cannot cast to %s",typ2string(t));
      return new Int_c(Signed,0);
    }
    break;
  case &AnonEnum_e(_,_,ef): fallthru(ef);
  case &Enum_e(_,_,ef): return eval_const_exp((exp_t)ef->tag);
  default: 
    terr(e->loc,"bad static expression");
    return new Int_c(Signed,0);
  }
  e->r = new Const_e(cn);
  return cn;
}
