/* Type checking types.
   Copyright (C) 2001 Greg Morrisett, Dan Grossman, AT&T
   This file is part of the Cyclone compiler.

   The Cyclone compiler is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   The Cyclone compiler is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with the Cyclone compiler; see the file COPYING. If not,
   write to the Free Software Foundation, Inc., 59 Temple Place -
   Suite 330, Boston, MA 02111-1307, USA. */
#include <string.h>
#include "unify.h"
#include "tcutil.h"
#include "evexp.h"
#include "tcexp.h"
#include "tc.h"
#include "cyclone.h"
#include "relations-ap.h"
#include "warn.h"
#include "tctyp.h"
#include "absynpp.h"

using List;
using Core;
using Warn; // put Warn first so Absyn shadows
using Absyn;
using Tcutil;
namespace Tctyp;

// bool indicates whether the element should go in an effect
typedef list_t<$(tvar_t,bool)@> free_tvars_t;
typedef list_t<$(type_t,bool)@> free_evars_t;

// Check-Valid-Type environments
static struct CVTEnv {
  // passed down:
  seg_t loc;
  Tcenv::tenv_t te;
  list_t<tvar_t> kind_env;  // used to get consistent id's and kinds for tvars
  bool fn_result;           // whether we are in a function result
  bool generalize_evars;    // whether we replace evars with fresh tvars
  // passed up: 
  free_tvars_t free_vars;  // free tvars found in this type
  free_evars_t free_evars; // free evars found in this type
};
typedef struct CVTEnv cvtenv_t;

// Checks that a type is well-formed and lives in kind expected_kind.
// Takes as input a location (for error reporting), a type environment
// (for looking up struct, enum, datatype, etc. decls), a check-valid-type
// environment (explained below), an expected kind, and the type itself t.
// It returns a check-valid-type-env as a result.
//
// In addition to checking that the type is valid, the routine needs
// to compute the set of free type variables and free evars in the
// type, and to constrain their kinds appropriately.  Normally, this
// would be coded by passing a kind_env down, and returning free_vars
// and free_evars as a result.  However, to cut down on allocation,
// we pass in the free variables of surrounding types and just add
// any new free variables to the result.  This way, we can calculate
// all of the free variables for a term in a store-passing style.
// The only situation where this breaks down is where we have binders
// as is the case for function types (see below).
//
// This also performs the following side-effects which most of the
// rest of the compiler rightly assumes have occurred:
// * expand typedefs
// * set pointers (or Known* variants) to declarations for
//   StructType, UnionType, DatatypeType, DatatypeFieldType
// * set the kind field of type variables: we use the expected kind
//   initially, but if later constraints force a more constrained kind,
//   then we move to the more constrained kind.  This is why we propagate
//   around the set of
// * add default effects for function types
static cvtenv_t i_check_type(cvtenv_t, kind_t, type_t, bool, bool);

// assumes es is a list of evars, and e is an evar.  Adds in e only
// if not already present.  The booleans here indicate whether a
// variable must be put in an effect.  If any occurrence of the variable
// must be in the effect, then it always is true.
static free_evars_t add_free_evar(free_evars_t es, type_t e, bool b) {
  switch (compress(e)) {
  case &Evar(_,_,i,_):
    for (_ es2 = es; es2 != NULL; es2 = es2->tl) {
      let &$(t,*b2) = es2->hd;
      switch (compress(t)) {
      case &Evar(_,_,j,_):
        if (i == j) {
          if (b != *b2) *b2 = true;
          return es;
        }
        break;
      default: break;
      }
    }
    return new List(new $(e,b),es);
  default: return es;
  }
}

// will shadow other variables
static list_t<tvar_t> add_bound_tvar(list_t<tvar_t,`H> tvs, tvar_t tv) {
  if (tv->identity == -1)
    impos2("bound tvar id for ",tv," is NULL");
  return new List(tv,tvs);
}
static list_t<`a> remove_bound_tvars(list_t<`a> tvs, list_t<tvar_t> btvs,
				     tvar_t (@get)(`a)) {
  list_t<`a> r = NULL;
  for (; tvs != NULL; tvs = tvs->tl) {
    _ b = btvs;
    for (; b != NULL; b = b->tl)
      if (get(tvs->hd)->identity == b->hd->identity)
        break;
    if (b==NULL) 
      r = new List(tvs->hd,r);
  }
  r = imp_rev(r);
  return r;
}

// we can constrain the region evars to HeapRgn and the
// effect evars to the empty effect, the bool evars to
// false, and the pointer bound kinds to bounds one,
// but we're out of luck for the type and int variables.
static void check_free_evars(free_evars_t free_evars, type_t in_typ, seg_t loc){
  for (; free_evars != NULL; free_evars = free_evars->tl) {
    type_t e = (*free_evars->hd)[0];
    switch (compress(e)) {
    case &Evar(...): break;
    default: continue; // already constrained
    }
    type_t t;
    string_t s;
    switch (type_kind(e)) {
    case &Kind(RgnKind,Unique): t = unique_rgn_type; s = "unique region"; break;
    case &Kind(RgnKind,Aliasable): 
    case &Kind(RgnKind,Top):    t = heap_rgn_type;   s = "heap";       break; 
    case &Kind(EffKind,_):      t = empty_effect;    s = "{}";         break;
    case &Kind(BoolKind,_):     t = false_type;      s = "@false";     break;
    case &Kind(PtrBndKind,_):   t = bounds_one();    s = "bounds_one"; break;
    default:
      err2(loc,"hidden type variable ",e," isn't abstracted in type ",in_typ);
      return;
    }
    if (!Unify::unify(e,t))
      impos2("can't unify evar ",e," with ",s,"!");
  }
}


// Given two kind constraint refs, merge them so that they will
// point to the most constrained kind -- if they're compatible
// return true, otherwise return false.
static bool constrain_kinds(kindbound_t c1, kindbound_t c2) {
  c1 = compress_kb(c1);
  c2 = compress_kb(c2);
  if (c1 == c2) return true;
  switch ($(c1,c2)) {
  case $(&Eq_kb(k1),&Eq_kb(k2)): return k1 == k2;
  case $(_,&Unknown_kb(*f)): *f = new Opt(c1); return true;
  case $(&Unknown_kb(*f),_): *f = new Opt(c2); return true;
  case $(&Less_kb(*f,k1),&Eq_kb(k2)):
    if (!kind_leq(k2,k1)) 
      return false;
    *f = new Opt(c2); 
    return true;
  case $(&Eq_kb(k1),&Less_kb(*f,k2)):
    if (!kind_leq(k1,k2)) 
      return false;
    *f = new Opt(c1); 
    return true;
  case $(&Less_kb(*f1,k1),&Less_kb(*f2,k2)):
    if (kind_leq(k1,k2)) {
      *f2 = new Opt(c1); 
      return true;
    } 
    if (kind_leq(k2,k1)) {
      *f1 = new Opt(c2); 
      return true;
    } 
    return false;
  }
}

// Adds tv to the list of tvars unless it's already present.  If it's
// already present, makes sure the kinds are compatible by choosing the
// most constrained kind as the kind of the variable, and in fact
// physically share the kinds so that further constraints on it are
// propagated.  Also ensures that the tvars share the same identity.
static list_t<tvar_t> add_free_tvar(seg_t loc,list_t<tvar_t,`H> tvs,tvar_t tv) {
  for (_ tvs2 = tvs; tvs2 != NULL; tvs2 = tvs2->tl)
    if (strptrcmp(tvs2->hd->name, tv->name) == 0) {
      kindbound_t k1 = tvs2->hd->kind;
      kindbound_t k2 = tv->kind;
      if (!constrain_kinds(k1,k2))
        err2(loc,"type variable ",tv," used with inconsistent kinds ",
	     k1," and ",k2);
      if (tv->identity == -1)
        tv->identity = tvs2->hd->identity;
      else if (tv->identity != tvs2->hd->identity)
        impos2("same type variable has different identity!");
      return tvs;
    }
  tv->identity = new_tvar_id();
  return new List(tv,tvs);
}

// This assumes the identities and kinds are set, and simply adds
// the tvar if it's not already present.
static list_t<tvar_t> fast_add_free_tvar(list_t<tvar_t,`H> tvs, tvar_t tv) {
  if (tv->identity == -1)
    impos2("fast_add_free_tvar: bad identity in tv");
  for (_ tvs2 = tvs; tvs2 != NULL; tvs2 = tvs2->tl) {
    let tv2 = tvs2->hd;
    if (tv2->identity == -1)
      impos2("fast_add_free_tvar: bad identity in tvs2");
    if (tv2->identity == tv->identity)
      return tvs;
  }
  return new List{tv,tvs};
}

// This assumes the identities and kinds are set, and simply adds the
// tvar if it's not already present.  b controls whether or not the
// variable gets put into effects.
static free_tvars_t fast_add_free_tvar_bool(free_tvars_t tvs, tvar_t tv,bool b){
  if (tv->identity == -1)
    impos2("fast_add_free_tvar_bool: bad identity in tv");
  for (_ tvs2 = tvs; tvs2 != NULL; tvs2 = tvs2->tl) {
    let &$(tv2,*b2) = tvs2->hd;
    if (tv2->identity == -1)
      impos2("fast_add_free_tvar_bool: bad identity in tvs2");
    if (tv2->identity == tv->identity) {
      *b2 = (*b2 || b);
      return tvs;
    }
  }
  return new List(new $(tv,b),tvs);
}

// This is called *after* type-checking the expression to see that
// it's of type int, under the assumption that every valueof(T) in e is
// well-formed and T is of kind Int.  We must now make sure that these
// assumptions hold and extract the free type variables occurring within T.
static cvtenv_t i_check_type_level_exp(exp_t e, cvtenv_t env) {
  env.loc = e->loc;
  switch (e->r) {
  case &Const_e(_):
  case &Enum_e(...):
  case &AnonEnum_e(...):
  case &Pragma_e(...):
  case &Var_e(...): break;
  case &Primop_e(_,es):
    for (; es != NULL; es = es->tl)
      env = i_check_type_level_exp(es->hd,env);
    break;
  case &Conditional_e(e1,e2,e3):
    env = i_check_type_level_exp(e1,env);
    fallthru(e2,e3);
  case &And_e(e1,e2): fallthru(e1,e2);
  case &Or_e(e1,e2):  fallthru(e1,e2);
  case &SeqExp_e(e1,e2):
    env = i_check_type_level_exp(e1,env);
    env = i_check_type_level_exp(e2,env);
    break;
  case &Cast_e(t,e1,_,_):
    env = i_check_type_level_exp(e1,env);
    env = i_check_type(env,&tak,t,true,false);
    break;
  case &Offsetof_e(t,_): fallthru(t);
  case &Sizeoftype_e(t): env = i_check_type(env,&tak,t,true,false); break;
  case &Valueof_e(t):    env = i_check_type(env,&ik,t,true,false);  break;
  case &Sizeofexp_e(e):  fallthru(e);
  case &Extension_e(e):  env = i_check_type_level_exp(e,env); break;
  default: impos2("bad expression in Tctyp::i_check_type_level_exp");
  }
  return env;
}

static bool typedef_tvar_is_ptr_rgn(tvar_t tvar, struct Typedefdecl *td) {
  if(td==NULL)
    return true;
  if(td->defn == NULL)
    return false;
  switch (compress((type_t)td->defn)) {
  case &PointerType(PtrInfo(_,_,PtrAtts(r,...))):
    switch (compress(r)) {
    case &VarType(tv): return tvar_cmp(tvar,tv) == 0;
    default: return false;
    }
  default: return false;
  }
}

static kind_t tvar_inst_kind(tvar_t tvar, kind_t def_kind, kind_t expected_kind,
			     struct Typedefdecl *td) {
  switch (compress_kb(tvar->kind)) {
  case &Less_kb(_,&Kind(RgnKind,Top)):
  case &Eq_kb(&Kind(RgnKind,Top)):
    // we may have to adjust the kind constraint of the
    // introduced evar from that of the given tvar so that the
    // overall kind constraint can be met.  This is only necessary
    // when the expected type could be a pointer, and the
    // the tvar is a region variable that would affect that pointer's
    // overall kind (i.e. TB, UB, B, etc.).
    let k = expected_kind->kind;
    if ((k == BoxKind || k == MemKind || k == AnyKind) &&
	typedef_tvar_is_ptr_rgn(tvar,td)) {
      if (expected_kind->aliasqual == Aliasable)
	return &rk;
      if (expected_kind->aliasqual == Unique)
	return &urk;
    }
    return &trk;
  default: return tvar_kind(tvar,def_kind);
  }
}
static cvtenv_t check_type_inst(cvtenv_t env, types_t @ targsp, 
				list_t<tvar_t,`H> tvs, kind_t expected_kind,
				bool allow_abs_aggr, qvar_t typname,
				struct Typedefdecl *td) {
  // *targsp is mutated appropriately for implicit instantiation
  let targs = *targsp;
  for (; targs != NULL && tvs != NULL; targs = targs->tl,tvs = tvs->tl) {
    type_t t = targs->hd;
    tvar_t tv = tvs->hd;
    // special case for recursive type where the parameters kinds
    // have not yet been figured out.
    switch $(compress_kb(tv->kind),t) {
    case $(&Unknown_kb(_), &VarType(tv2)):
      env.kind_env  = add_free_tvar(env.loc, env.kind_env, tv2);
      env.free_vars = fast_add_free_tvar_bool(env.free_vars, tv2, true);
      continue;
    default: break;
    }
    kind_t k = tvar_kind(tv,&bk);
    env = i_check_type(env,k,t,true,allow_abs_aggr);
    check_no_qual(env.loc,t);
  }
  if (targs != NULL)
    err2(env.loc,"too many type arguments for ", typname);
  // take care of implicit instantiation
  list_t<type_t> hidden_ts = NULL;
  for (; tvs != NULL; tvs = tvs->tl) {
    type_t e = new_evar(NULL,NULL);
    hidden_ts = new List(e,hidden_ts);
    kind_t k = tvar_inst_kind(tvs->hd, &bk, expected_kind, td);
    env = i_check_type(env,k,e,true,allow_abs_aggr);
  }
  *targsp = imp_append(*targsp,imp_rev(hidden_ts));
  return env;
}

static void check_field_atts(seg_t loc, stringptr_t<`H> fn, attributes_t atts) {
  for (; atts != NULL; atts = atts->tl)
    switch (atts->hd) {
    case &Packed_att: 
    case &Aligned_att(_): continue;
    default: err2(loc,"bad attribute ",atts->hd," on member ",*fn);
    }
}

// check that a @requires/@ensures clause is well-formed and satisfiable
static $(cvtenv_t,Relations::relns_t) check_clause(cvtenv_t env, 
						   string_t<`H> clause_name, 
						   exp_opt_t clause) {
  if(clause==NULL)
    return $(env,NULL);
  Tcexp::tcExp(env.te,NULL,clause);
  if (!is_integral(clause))
    err2(env.loc, clause_name," clause has type ",clause->topt,
	 " instead of integral type");
  env = i_check_type_level_exp(clause,env);
  let relns = Relations::exp2relns(heap_region,clause);
  if (!Relations::consistent_relations(relns))
    err2(clause->loc, clause_name," clause '",clause,"' may be unsatisfiable");
  return $(env,relns);
}

// helper function to check aggregates
static cvtenv_t i_check_aggr(cvtenv_t env, kind_t expected_kind,
			     aggr_info_t @info, types_t @targs, 
			     bool allow_abs_aggr) {
  let CVTEnv(loc,te,...) = env;
  switch(*info) {
  case {.UnknownAggr = $(k,n,tgd)}:
    aggrdecl_t @ adp;
    try {
      adp = Tcenv::lookup_aggrdecl(te,loc,n);
      let ad = *adp;
      if (ad->kind != k) {
        if (ad->kind == StructA)
          err2(loc,"expecting struct ", n, "instead of union ", n);
        else
          err2(loc,"expecting union ", n, "instead of struct ", n);
      }
      if (tgd && tgd->v && (!ad->impl || !ad->impl->tagged))
	err2(loc,"@tagged qualfiers don't agree on union ", n);
      // FIX: what to do about tgd?
      *info = KnownAggr(adp);
    } catch { case &Dict::Absent:
      // add as an abstract type declaration
      // FIX: use the correct namespace by examining the qvar_t n
      Tc::tcAggrdecl(te,loc,new Aggrdecl{k,Extern,n,NULL,NULL,NULL,false});
      adp = Tcenv::lookup_aggrdecl(te,loc,n);
      *info = KnownAggr(adp);
      // give an error here if targs is non-empty:
      if (*targs != NULL) {
        err2(loc,"declare parameterized type ", n, " before using");
        return env;
      }
      break;
    }
    fallthru(*adp);
  case {.KnownAggr = &ad}:
    env = check_type_inst(env,targs,ad->tvs,
			  expected_kind,allow_abs_aggr,ad->name,NULL);
    if (allow_abs_aggr && ad->impl == NULL && !kind_leq(&ak, expected_kind))
      // this must be later resolved as having at least the expected kind!
      // For now, we just force that to be &mk.  And come back to check that
      // it is later.
      ad->expected_mem_kind = true;
    return env;
  }
}

// helper function to check datatypes
static cvtenv_t i_check_datatype(cvtenv_t env, kind_t expected_kind, 
				 datatype_info_t @info, types_t @targsp,
				 bool allow_abs_aggr) {
  let CVTEnv(loc,te,...) = env;
  let targs = *targsp;
  switch(*info) {
  case {.UnknownDatatype = UnknownDatatypeInfo(n,is_x)}:
    datatypedecl_t@ tudp;
    try tudp = Tcenv::lookup_datatypedecl(te,loc,n);//FIX: lookup_xdatatypedecl?
    catch { case &Dict::Absent:
      // declare the datatype for the user
      Tc::tcDatatypedecl(te,loc,new Datatypedecl{Extern, n, NULL, NULL, is_x});
      tudp = Tcenv::lookup_datatypedecl(te,loc,n);
      // give an error here if targs is non-empty
      if (targs != NULL) {
        err2(loc,"declare parameterized datatype ", n, " before using");
        return env;
      }
      break;
    }
    // JGM: I'm allowing someone to just write "datatype Foo" even
    // when the datatype is extensible.
    if(is_x && !(*tudp)->is_extensible)
      err2(loc,"datatype ", n, " was not declared @extensible");
    *info = KnownDatatype(tudp);
    fallthru(*tudp);
  case {.KnownDatatype = &tud}:
    return check_type_inst(env,targsp,tud->tvs,
			   expected_kind,allow_abs_aggr,tud->name,NULL);
  }
}

// helper function check datatype fields
static cvtenv_t i_check_datatype_field(cvtenv_t env, kind_t expected_kind,
				       datatype_field_info_t @info,
				       types_t @targsp, bool allow_abs_aggr) {
  switch(*info) {
  case {.UnknownDatatypefield = UnknownDatatypeFieldInfo(tname,fname,is_x)}:
    // lookup should not fail because of binding phase
    datatypedecl_t  tud = *Tcenv::lookup_datatypedecl(env.te,env.loc,tname);
    datatypefield_t tuf;
    // binding phase also checked the field exists in the tud
    // we wait to bind it for uniformity with structs, which are delayed
    // because of typedefs and their strange scope
    for(let fs = tud->fields->v; true; fs = fs->tl) {
      if(fs == NULL) impos2("Tcutil found a bad datatypefield");
      if(qvar_cmp(fs->hd->name,fname)==0) {
        tuf = fs->hd;
        break;
      }
    }
    *info = KnownDatatypefield(tud,tuf);
    fallthru(tud,tuf);
  case {.KnownDatatypefield = $(tud,tuf)}:
    return check_type_inst(env,targsp,tud->tvs,expected_kind,allow_abs_aggr,
			   tuf->name,NULL);//FIX? tud->name not in error message
  }
}

static cvtenv_t i_check_unary_app(cvtenv_t env, kind_t k, types_t ts, 
				  bool put_in_effect, string_t<`H> s) {
  if(length(ts) != 1)
    impos2(s," has wrong number of arguments");
  return i_check_type(env,k,ts->hd,put_in_effect,true);
}

static cvtenv_t i_check_type_app(cvtenv_t env, kind_t expected_kind, 
				 tycon_t c, types_t@ targsp,
				 bool put_in_effect, bool allow_abs_aggr){
  let CVTEnv(loc,te,...) = env;
  let ts = *targsp;
  switch (c) {
  // zero-arity constructors
  case &IntCon(...): case &FloatCon(...): case &VoidCon:
  case &RefCntCon: case &UniqueCon: case &HeapCon:
  case &FalseCon: case &TrueCon: case &FatCon:
  case &BuiltinCon(...): 
    if (ts != NULL) 
      impos2(new AppType(c,ts)," applied to argument(s)");
    return env;
  case &JoinCon: 
    for (; ts != NULL; ts = ts->tl)
      env = i_check_type(env,&ek,ts->hd,true,true);
    return env;
  case &EnumCon(n,*edp): // FIX: do this in binding phase
    if (ts != NULL) impos2("enum applied to argument(s)");
    if (*edp == NULL || (*edp)->fields == NULL) {
      try *edp = *Tcenv::lookup_enumdecl(te,loc,n);
      catch {case &Dict::Absent:
        Tc::tcEnumdecl(te,loc,new Enumdecl{Extern,n,NULL});
        *edp = *Tcenv::lookup_enumdecl(te,loc,n);
        break;
      }
    }
    return env;
  case &AnonEnumCon(fs):
    if (ts != NULL) 
      impos2("enum applied to argument(s)");
    // Note: this code is duplicated almost exactly in Tc::tcEnumdecl
    list_t<field_name_t> prev_fields = NULL;
    unsigned int tag_count = 0;
    for (; fs != NULL; fs = fs->tl) {
      let f = fs->hd;
      if (List::mem(strptrcmp,prev_fields,(*f->name)[1]))
        err2(f->loc,"duplicate enum field name ",f->name);
      else
        prev_fields = new List((*f->name)[1],prev_fields);
      if (f->tag == NULL)
        f->tag = uint_exp(tag_count, f->loc);
      else if (!is_const_exp((exp_t)f->tag))
        err2(loc,"enum field ",f->name,": expression is not constant");
      tag_count = 1 + Evexp::eval_const_uint_exp((exp_t)f->tag)[0];
    }
    return env;
  case &RgnsCon:      return i_check_unary_app(env,&tak,ts,true,"regions");
  case &RgnHandleCon: return i_check_unary_app(env,&trk,ts,true,"region_t");
  case &AccessCon:    return i_check_unary_app(env,&trk,ts,true,"access");
  case &TagCon:       return i_check_unary_app(env,&ik,ts,false,"tag_t");
  case &ThinCon:      return i_check_unary_app(env,&ik,ts,false,"@thin");
  case &AggrCon(*info):
    return i_check_aggr(env,expected_kind,info,targsp,allow_abs_aggr);
  case &DatatypeCon(*info):
    return i_check_datatype(env,expected_kind,info,targsp,allow_abs_aggr);
  case &DatatypeFieldCon(*info):
    return i_check_datatype_field(env,expected_kind,info,targsp,allow_abs_aggr);
  }
}


static cvtenv_t i_check_type(cvtenv_t env, kind_t expected_kind, type_t t,
			     bool put_in_effect, bool allow_abs_aggr) {
  let CVTEnv(loc,te,...) = env;
  switch (compress(t)) {
  case &AppType(c,*targsp):
    env = i_check_type_app(env,expected_kind,c,targsp,
			   put_in_effect,allow_abs_aggr);
    break;
  case &Evar(*k,*ref,_,_):
    // if we have some latitude with moving the type var, do it here
    if ((*k == NULL) ||
	(kind_leq(expected_kind,(*k)->v) && !kind_leq((*k)->v,expected_kind)))
      *k = kind_to_opt(expected_kind);
    if (env.fn_result && env.generalize_evars &&
	expected_kind->kind == RgnKind && !te->tempest_generalize) {
      if (expected_kind->aliasqual == Unique)
	*ref = unique_rgn_type;
      else // generalize Top RgnKind evars to be the heap in return values
	*ref = heap_rgn_type;
    } else if (env.generalize_evars && expected_kind->kind != BoolKind
               && expected_kind->kind != PtrBndKind) {
      // generalize evars that aren't bool or ptrbounds.
      let v = new_tvar(new Less_kb(NULL,expected_kind));
      *ref = var_type(v);
      fallthru(v);
    } else {
      env.free_evars = add_free_evar(env.free_evars,t,put_in_effect);
    }
    break;
  case &VarType(v):
    switch (compress_kb(v->kind)) {
    case &Unknown_kb(*f): *f = new Opt(new Less_kb(NULL,expected_kind)); break;
    default: break;
    }
    // this constrains the variable's kind according to other occurrences
    // of that variable and makes sure they share the same tvar identity.
    env.kind_env = add_free_tvar(loc, env.kind_env, v);
    // no need to constrain things here, but want to add it only if
    // it hasn't already been added.
    env.free_vars = fast_add_free_tvar_bool(env.free_vars, v, put_in_effect);
    // if we have some latitude with moving the type var, do it here
    switch (compress_kb(v->kind)) {
    case &Less_kb(*f,k): 
      if (kind_leq(expected_kind,k))
	*f = new Opt(new Less_kb(NULL,expected_kind));
      break;
    default: break;
    }
    break;

    // Here, we have a nested type declaration -- we check it and enter it
    // in the environment, and then check an instantiation of that type.
  case &TypeDeclType(&{.r = td,...},*topt):
    type_t new_typ = copy_type(compress(t));
    switch (td) {
    case &Aggr_td(ad):
      if (env.te->in_extern_c_include)
        ad->sc = ExternC;
      Tc::tcAggrdecl(te,loc,ad); break;
    case &Enum_td(ed):
      if (env.te->in_extern_c_include)
        ed->sc = ExternC;
      Tc::tcEnumdecl(te,loc,ed); break;
    case &Datatype_td(dd):
      Tc::tcDatatypedecl(te,loc,dd); break;
    }
    *topt = new new_typ;
    return i_check_type(env,expected_kind,new_typ,put_in_effect,allow_abs_aggr);

  case &PointerType(PtrInfo(t1,*tqp,PtrAtts(rgn_type,nullable,b,zt,_))):
    // FIX: check that tqual is valid?
    kind_t rgnk;
    switch (expected_kind->aliasqual) {
    case Aliasable:    rgnk = &rk;  break;
    case Unique:       rgnk = &urk; break;
    case Top: default: rgnk = &trk; break;
    }
    env = i_check_type(env,&tak,  t1,      true, true);//allow AnyKind under ptr
    env = i_check_type(env,rgnk,  rgn_type,true, true);
    env = i_check_type(env,&boolk,zt,      false,true);
    env = i_check_type(env,&boolk,nullable,false,true);
    env = i_check_type(env,&ptrbk,b,       false,allow_abs_aggr);

    tqp->real_const = extract_const_from_typedef(env.loc,tqp->print_const,t1);

    // if zero_term is unconstrained, then set it to false unless
    // we have [signed] char */@/? {n}.
    Unify::unify(zt, is_char_type(t1) ? true_type : false_type);
    bool is_zero_terminated = type2bool(false,zt);
    if (is_zero_terminated  && !admits_zero(t1))
      err2(loc,"cannot have a pointer to zero-terminated ",t1," elements");

    // check the bound -- unify with bounds one to force bound to zero
    let e = get_bounds_exp(bounds_one(),b);
    if (e != NULL) {
      let $(sz,known) = Evexp::eval_const_uint_exp(e);
      if (is_zero_terminated && (!known || sz < 1))
        err2(loc,"zero-terminated pointer cannot point to empty sequence");
    }
    break;
  case &ValueofType(e):
    // FIX:  when we have something like:
    // int foo<`i::I>(int *{valueof(`i)}`H x);
    // then the explicitly bound `i doesn't work out.
    Tcexp::tcExp(Tcenv::allow_valueof(te),NULL,e);
    if (!coerce_uint_type(e))
      err2(loc,"valueof_t requires an int expression");
    env = i_check_type_level_exp(e,env);
    break;
  case &TypeofType(e):
    // FIX:  when we have something like:
    // int foo<`i::I>(int *{valueof(`i)}`H x);
    // then the explicitly bound `i doesn't work out.
    Tcexp::tcExp(Tcenv::allow_valueof(te),NULL,e);
    break;
  case &ArrayType(ArrayInfo{t1,*tqp,*eptr,zt,ztl}):
    // FIX: check that tqual is valid?
    // we don't allow abstract mem types as the elt type of an array type
    let e = *eptr;
    env = i_check_type(env,&tmk,t1,true,allow_abs_aggr);
    tqp->real_const = extract_const_from_typedef(loc,tqp->print_const,t1);
    // if zero_term is unconstrained, then set it to false.
    bool is_zero_terminated = force_type2bool(false, zt);
    if (is_zero_terminated) {
      // check that t1 supports 0 as an element
      if (!admits_zero(t1))
        err2(loc,"cannot have a zero-terminated array of ",t1," elements");
    }
    // FIX: should memoize the size so that we don't have to worry about
    // evaluating it during unification
    if(e==NULL) {
      // No explicit array bounds was given
      // zero-terminated arrays have at least size 1
      if(!is_zero_terminated)   // warn that this array is essentially useless?
        warn2(loc,"array bound defaults to 1 here");
      *eptr = e = uint_exp(1,0);
    }
    Tcexp::tcExp(Tcenv::allow_valueof(te),NULL,e);
    if (!coerce_uint_type(e))
      err2(loc,"array bounds expression is not an unsigned int");
    env = i_check_type_level_exp(e,env);
    let $(sz,known) = Evexp::eval_const_uint_exp(e);
    // FIX: if we have an unknown size then it might not be zero-terminated!
    if (is_zero_terminated && known && sz < 1)
      warn2(loc,"zero terminated array cannot have zero elements");
    // FIX: if we have an unknown size then it might turn out to be zero!
    if (known && sz < 1 && Cyclone::tovc_r) {
      warn2(loc,"0-element arrays are supported only with gcc, changing to 1");
      *eptr = uint_exp(1,0);
    }
    break;
  case &FnType(FnInfo{*btvs,*eff,*rtq,tr,args,c_vararg,cyc_vararg,rgn_po,atts,req,*req_relns,ens,*ens_relns,_}):
    // This is an unusual and complicated case because (a) we may have to
    // bind type variables here, (b) we may have to calculate the effect.

    // attributes: check that the attributes are function type attributes
    // and that at most one of {stdcall, cdecl, fastcall} is there.
    int num_formats = 0;
    int is_cdecl    = 0;
    int is_stdcall  = 0;
    int is_fastcall = 0;
    enum Format_Type ft = Printf_ft;
    int fmt_desc_arg = -1;
    int fmt_arg_start = -1;
    for (; atts != NULL; atts = atts->tl)
      switch(atts->hd) {
      case &Stdcall_att:  is_stdcall  = 1; break;
      case &Cdecl_att:    is_cdecl    = 1; break;
      case &Fastcall_att: is_fastcall = 1; break;
      case &Format_att(fmttype,i,j):
	++num_formats;
	ft = fmttype;
	fmt_desc_arg = i;
	fmt_arg_start = j;
        break;
      default: 
	if (!fntype_att(atts->hd))
	  err2(loc,"bad function type attribute ",atts->hd);
      }
    if((is_stdcall + is_cdecl + is_fastcall) > 1)
      err2(loc,"function can't have multiple calling conventions");
    if (num_formats > 1)  
      err2(loc,"function can't have multiple format attributes");

    // bound type variables (we may add more) --
    // check unique, disallow MemKind, and add to env.kind_env.
    check_unique_tvars(loc,*btvs);
    for (_ b = *btvs; b != NULL; b = b->tl) {
      b->hd->identity = new_tvar_id();
      env.kind_env = add_bound_tvar(env.kind_env,b->hd);
      switch (compress_kb(b->hd->kind)) {
      case &Eq_kb(&Kind(MemKind,_)):
	err2(loc,"function abstracts Mem type variable ", b->hd); break;
      default: break;
      }
    }
    // We use a fresh environment here so that we only track the free type
    // vars (and evars) of the function type in case we have to abstract them.
    _ new_env = CVTEnv{loc,te,env.kind_env,true,env.generalize_evars,NULL,NULL};
    new_env = i_check_type(new_env,&tmk,tr,true,true);
    rtq->real_const = extract_const_from_typedef(loc,rtq->print_const,tr);
    new_env.fn_result = false;
    // results and arguments of functions cannot be abstract mem types
    // FIX?: should check that variables are unique and that tquals are ok
    for (_ a = args; a != NULL; a = a->tl) {
      let trip = a->hd;
      let t = (*trip)[2];
      new_env = i_check_type(new_env,&tmk,t,true,true);
      let ec = extract_const_from_typedef(loc,(*trip)[1].print_const,t);
      (*trip)[1].real_const = ec;
      // after resolving t, it may be an array type.  if so, as an argument
      // to a function, we need to convert it to a pointer type.
      if (is_array_type(t)) {
	// create a new region variable for the pointer
	let ptr_rgn = new_evar(NULL,NULL);
	new_env = i_check_type(new_env,&rk,ptr_rgn,true,true);
	(*trip)[2] = promote_array(t,ptr_rgn,false);
      }
    }
    // varargs
    if (cyc_vararg != NULL) {
      if (c_vararg) impos2("both c_vararg and cyc_vararg"); // sanity
      let VarargInfo{_,_,vt,vi} = *cyc_vararg;
      new_env = i_check_type(new_env,&tmk,vt,true,true);
      cyc_vararg->tq.real_const = extract_const_from_typedef(loc,cyc_vararg->tq.print_const,vt);
      // if inject, then check the type is an appropriate datatype
      if (vi)
	switch (compress(vt)) {
	case &PointerType(PtrInfo{et,_,PtrAtts{_,_,bs,zt,_}}):
	  switch (compress(et)) {
	  case &AppType(&DatatypeCon(...),_):
	    if (force_type2bool(false,zt))
	      err2(loc,"can't inject into a zeroterm pointer");
	    if (!Unify::unify(bounds_one(),bs)) 
	      err2(loc,"can't inject into a fat pointer to datatype");
	    break;
	  default: err2(loc,"can't inject a non-datatype type"); break;
	  }
	  break;
	default: err2(loc,"expecting a datatype pointer type"); break;
	}
    }
    // check the format attribute is consistent
    if (num_formats > 0) {
      let num_args = List::length(args);
      if (fmt_desc_arg < 0 || fmt_desc_arg > num_args || fmt_arg_start < 0 ||
	  // when no varargs, fmt_arg_start should be 0
	  (cyc_vararg == NULL && !c_vararg && fmt_arg_start != 0) ||
	  ((cyc_vararg != NULL || c_vararg) && 
	   fmt_arg_start != num_args + 1)) // wrong??
	err2(loc,"bad format descriptor");
      else {
	// check that fmt_desc_arg is a string in some region
	let $(_,_,t) = *List::nth(args, fmt_desc_arg - 1);
	//can't use unification because evars aren't properly nailed down yet...
	switch (compress(t)) {
	case &PointerType(PtrInfo(et,_,PtrAtts(_,_,b,_,_))):
	  // FIX:  zero-termination?
	  if (!is_char_type(et)) 
	    err2(loc,"format descriptor is not a string");
	  else {
	    let e = get_bounds_exp(bounds_one(),b);
	    if (e == NULL && c_vararg)
	      err2(loc,"format descriptor is not a char * type"); 
	    else if (e != NULL && !c_vararg)
	      err2(loc,"format descriptor is not a char ? type"); 
	  }
	  break;
	default: err2(loc,"format descriptor is not a string type"); break;
	}
	if (fmt_arg_start != 0 && !c_vararg) {
	  // check the type of the varargs is either datatype PrintArg or
	  // datatype ScanfArg according to ft.
	  // FIX: shouldn't we just do this once when the declaration is made?
	  bool problem;
	  switch ($(ft,compress(pointer_elt_type(cyc_vararg->type)))) {
	  case $(Printf_ft, &AppType(&DatatypeCon({.KnownDatatype = &tud}),_)):
	    problem = (qvar_cmp(tud->name,datatype_print_arg_qvar()) != 0);
	    break;
	  case $(Scanf_ft,  &AppType(&DatatypeCon({.KnownDatatype = &tud}),_)):
	    problem = (qvar_cmp(tud->name,datatype_scanf_arg_qvar()) != 0); 
	    break;
	  default:
	    problem = true; 
	    break;
	  }
	  if (problem)
	    err2(loc,"format attribute and vararg types don't match");
	}
      }
    }
    // check the region partial order
    // FIX:  we need to ensure there are no circular dependencies...
    //       actually, allow circularities, but forbid effect variables
    for (_ rpo = rgn_po; rpo != NULL; rpo = rpo->tl) {
      let &$(r1,r2) = rpo->hd;
      new_env = i_check_type(new_env,&ek,r1,true,true);
      new_env = i_check_type(new_env,&trk,r2,true,true);
    }
    // check the @requires clause -- we build a bogus function environment
    // to make it possible to enter the parameters as variables that can
    // be mentioned in the @requires clause.  
    let fenv = Tcenv::bogus_fenv(tr, args);
    let old_te = new_env.te;
    new_env.te = new Tcenv::Tenv{te->ns,te->ae, fenv, true, 
				 te->in_extern_c_include, 
				 te->in_tempest,te->tempest_generalize, 
				 te->in_extern_c_inc_repeat};
    let $(nenv,req_rs) = check_clause(new_env,"@requires",req);
    new_env = nenv;
    *req_relns = req_rs;
    List::iter_c(replace_rops, args, req_rs);
    let $(nenv,ens_rs) = check_clause(new_env,"@ensures",ens);
    new_env = nenv;
    *ens_relns = ens_rs;
    List::iter_c(replace_rops, args, ens_rs);
    new_env.te = old_te;
    // finally, the effect -- usually inferred
    if (*eff != NULL)
      new_env = i_check_type(new_env,&ek,(type_t)(*eff),true,true);
    else {
      list_t<type_t> effect = NULL;
      // Add in any free region or effect variables to the effect.
      // This is why we need a "new_env" above -- we only want the
      // type variables that actually occur in the function type
      // as opposed to elsewhere.
      for (_ tvs = new_env.free_vars; tvs != NULL; tvs = tvs->tl) {
	let $(tv,put_in_eff) = *tvs->hd;
	if (!put_in_eff) continue; // skip variables that shouldn't go in effs
	switch (compress_kb(tv->kind)) {
	  // Coerce Top RgnKind to RgnKind if an upper bound
	case &Less_kb(*f,r) && r->kind == RgnKind:
	  if (r->aliasqual == Top) {
	    *f = kind_to_bound_opt(&rk); fallthru(r);
	  }
	  *f = kind_to_bound_opt(r); fallthru(r);
	case &Eq_kb(r) && r->kind == RgnKind:
	  effect = new List(access_eff(var_type(tv)),effect); break;
	case &Less_kb(_,&Kind(BoolKind,_)):
	case &Less_kb(_,&Kind(PtrBndKind,_)):
	case &Less_kb(_,&Kind(IntKind,_)):
	case &Eq_kb(&Kind(BoolKind,_)): 
	case &Eq_kb(&Kind(PtrBndKind,_)): 
	case &Eq_kb(&Kind(IntKind,_)): break;
	case &Less_kb(*f,&Kind(EffKind,_)):
	  *f = kind_to_bound_opt(&ek); fallthru;
	case &Eq_kb(&Kind(EffKind,_)):
	  effect = new List(var_type(tv),effect); break;
	case &Unknown_kb(*f):
	  *f = new Opt(new Less_kb(NULL,&ak)); fallthru;
	default:
	  // add regions(`a) to the default effect for every type variable `a.
	  effect = new List(regionsof_eff(var_type(tv)), effect); break;
	}
      }
      // Better add in any evars too:
      for (_ ts = new_env.free_evars; ts != NULL; ts = ts->tl) {
	let $(tv,put_in_eff) = *ts->hd;
	if (!put_in_eff) continue; // skip variables that shouldn't go in effs
	switch (type_kind(tv)) {
	case &Kind(RgnKind,_): effect = new List(access_eff(tv), effect); break;
	case &Kind(EffKind,_): effect = new List(tv, effect); break;
	case &Kind(IntKind,_): break;
	default: effect = new List(regionsof_eff(tv), effect); break;
	}
      }
      *eff = join_eff(effect); // used to reverse list (twice)
    }
    // Warn if afterwards any kind is still unconstrained and set it to
    // BoxKind. In addition, drive any MemKind or AnyKind bounded type
    // variables to BoxKind to ensure that we don't abstract a MemKind
    // variable.  Also drive Top kinds to Aliasable.
    if (*btvs != NULL)
      for(list_t<tvar_t> bs = *btvs; bs != NULL; bs = bs->tl) {
	switch (compress_kb(bs->hd->kind)) {
	case &Unknown_kb(*f):
	  warn2(loc,"type variable ",bs->hd," unconstrained, assuming boxed");
	  *f = kind_to_bound_opt(&bk);  
	  break;
	case &Less_kb(*f,k):
	  switch(k) {
	  case &Kind(BoxKind,Top):
	  case &Kind(MemKind,Top):
	  case &Kind(MemKind,Aliasable):
	  case &Kind(AnyKind,Top):
	  case &Kind(AnyKind,Aliasable): *f = kind_to_bound_opt(&bk);  break;
	  case &Kind(MemKind,Unique):
	  case &Kind(AnyKind,Unique):    *f = kind_to_bound_opt(&ubk); break;
	  case &Kind(RgnKind,Top):       *f = kind_to_bound_opt(&rk);  break;
	  default:                       *f = kind_to_bound_opt(k);    break;
	  }
	  break;
	case &Eq_kb(&Kind(MemKind,_)):
	  err2(loc,"functions can't abstract M types"); break;
	default: break;
	}
      }
    // remove the bound vars from the kind environment and the list of free vars
    env.kind_env = remove_bound_tvars(new_env.kind_env,*btvs,identity);
    new_env.free_vars = remove_bound_tvars(new_env.free_vars,*btvs,fst);
    // add the free vars in to the set of all free vars
    for (_ tvs = new_env.free_vars; tvs != NULL; tvs = tvs->tl) {
      let $(t,b) = *tvs->hd;
      env.free_vars = fast_add_free_tvar_bool(env.free_vars,t,b);
    }
    // add the free evars in to the set of all free evars
    for (_ evs = new_env.free_evars; evs != NULL; evs = evs->tl) {
      let $(e,b) = *evs->hd;
      env.free_evars = add_free_evar(env.free_evars,e,b);
    }
    break;

  case &TupleType(tq_ts):
    for (; tq_ts != NULL; tq_ts = tq_ts->tl) {
      let p = tq_ts->hd;
      env = i_check_type(env,&tmk,(*p)[1],true,false);
      (*p)[0].real_const =
        extract_const_from_typedef(loc,(*p)[0].print_const,(*p)[1]);
    }
    break;

  case &AnonAggrType(k,fs):
    // FIX: this code is mostly duplicated in Tc::tcAggrdecl
    list_t<field_name_t> prev_fields = NULL;
    for (; fs != NULL; fs = fs->tl) {
      let &Aggrfield{fn,*tqp,t,width,atts,requires_clause} = fs->hd;
      if (List::mem(strptrcmp,prev_fields,fn))
	err2(loc,"duplicate field ",*fn);
      if (strcmp(*fn,"") != 0)
	prev_fields = new List(fn,prev_fields);
      env = i_check_type(env,&tmk,t,true,false);
      tqp->real_const = extract_const_from_typedef(loc,tqp->print_const,t);
      check_bitfield(loc,t,width,fn);
      check_field_atts(loc,fn,atts);
      if (requires_clause != NULL) {
	// FIX: check that this requires clause does not overlap with others?
	if(k!=UnionA)
	  err2(loc,"@requires clause is only allowed on union members");
	Tcexp::tcExp(Tcenv::allow_valueof(te),NULL,requires_clause);
	if (!is_integral(requires_clause))
	  err2(loc,"@requires clause has type ", requires_clause->topt, 
	       " instead of integral type");
	env = i_check_type_level_exp(requires_clause,env);
      }
    }
    break;

  case &TypedefType(tdn,*targs_ref,*tdopt,*toptp):
    // NB: since we called compress *toptp == NULL
    typedefdecl_t td;
    try td = Tcenv::lookup_typedefdecl(te,loc,tdn);
    catch { case &Dict::Absent:
      err2(loc,"unbound typedef name ",tdn);
      return env;
    }
    *tdopt = td;
    env = check_type_inst(env,targs_ref,td->tvs,
			  expected_kind,allow_abs_aggr,tdn,td);
    if (td->defn != NULL) { // don't use zip in case we had too many args
      list_t<$(tvar_t,type_t)@> inst = NULL;
      let tvs = td->tvs;
      let ts = *targs_ref;
      for(; tvs != NULL; tvs=tvs->tl, ts=ts->tl)
	inst = new List(new $(tvs->hd,ts->hd),inst);
      *toptp = substitute(inst,(type_t)td->defn);
    }
    break;
  }
  if (!kind_leq(type_kind(t), expected_kind))
    err2(loc,"type ",t," has kind ",type_kind(t),
	 " but as used here needs kind ",expected_kind);
  return env;
}

static cvtenv_t check_valid_type(cvtenv_t cvt, kind_t expected_kind,
				 bool allow_abs_aggr, type_t t) {
  let kind_env = cvt.kind_env;
  cvt = i_check_type(cvt,expected_kind,t,true,allow_abs_aggr);

  for (_ vs = cvt.free_vars; vs != NULL; vs = vs->tl)
    cvt.kind_env = fast_add_free_tvar(kind_env,(*vs->hd)[0]);

  // run through the evars and constrain them so that when unified,
  // the resulting type can only have type variables drawn from the
  // kind environment or the set of free type variables mentioned here.
  for (_ evs = cvt.free_evars; evs != NULL; evs = evs->tl) {
    let $(e,_) = *evs->hd;
    switch (compress(e)) {
    case &Evar(_,_,_,*s):
      if (*s == NULL)
        *s = new Opt(kind_env);
      else {
        // constrain to the intersection of the contexts
        let result = NULL;
        for (let tvs = (*s)->v; tvs != NULL; tvs = tvs->tl)
          if (List::mem(fast_tvar_cmp,kind_env,tvs->hd))
            result = new List(tvs->hd,result);
        *s = new Opt(result);
      }
      break;
    default: break;
    }
  }
  return cvt;
}

// Same as check_valid_type except that for function types, we check
// that either the bound type variables are empty (in which case we
// plug them in) or else the free type variables are contained in the
// list of the bound type variables and have the right kinds.
void check_valid_toplevel_type(seg_t loc, Tcenv::tenv_t te, type_t t) {
  bool generalize_evars = 
    is_function_type(t) && (!te->in_tempest || te->tempest_generalize);
  kind_t expected_kind = is_function_type(t) ? &tak : &tmk;
  let te_vars = Tcenv::lookup_type_vars(te);
  let cvt = check_valid_type(CVTEnv{loc,te,
				    te_vars,false,generalize_evars,NULL,NULL},
			     expected_kind, true, t);
  let free_tvars = List::map(fst,cvt.free_vars);
  let free_evars = cvt.free_evars;
  // filter out free tvars that are in the environment
  if (te_vars != NULL) {
    let res = NULL;
    for (let fs = free_tvars; fs; fs = fs->tl) {
      let ts = te_vars;
      for (; ts != NULL; ts = ts->tl)
	if (tvar_cmp(fs->hd,ts->hd) == 0) 
	  break;
      if (ts==NULL)
	res = new List(fs->hd,res);
    }
    free_tvars = imp_rev(res);
  }
  // resolve the kinds of type variables.  If there's a kind that must
  // be less than Mem, make it boxed.  If there's a Top RgnKind
  // type variable, make it RgnKind
  for (_ x = free_tvars; x != NULL; x = x->tl) {
    switch (compress_kb(x->hd->kind)) {
    case &Unknown_kb(*f): *f = kind_to_bound_opt(&bk); break;
    case &Less_kb(*f,k):
      switch(k) {
      case &Kind(BoxKind,Top): 
      case &Kind(MemKind,Top): 
      case &Kind(MemKind,Aliasable): *f = kind_to_bound_opt(&bk);  break;
      case &Kind(MemKind,Unique):    *f = kind_to_bound_opt(&ubk); break;
      case &Kind(RgnKind,Top):       *f = kind_to_bound_opt(&rk);  break;
      default:                       *f = kind_to_bound_opt(k);    break;
      }
      break;
    case &Eq_kb(&Kind(MemKind,a)):
      err2(loc,"type variable ",x->hd," cannot have kind ",new Kind(MemKind,a));
      break;
    default: break;
    }
  }

  if (free_tvars != NULL || free_evars != NULL) {
    switch (compress(t)) {
    case &FnType(FnInfo{*btvs,...}):
      if (*btvs == NULL) {
	// abstract the free tvars
	*btvs = List::copy(free_tvars);
	free_tvars = NULL;
      }
      break;
    default: break;
    }
    if (free_tvars != NULL)
      err2(loc,"unbound type variable ",free_tvars->hd, " when checking ", t);
    if (!is_function_type(t) || !te->in_tempest)
      check_free_evars(free_evars,t,loc);
  }
}

// Check that the function declaration has a valid type:  all
// we do is build a FnType and then check that it is well-formed
// which has the side effect of giving us the effect and any
// bound type variables.
void check_fndecl_valid_type(seg_t loc, Tcenv::tenv_t te, fndecl_t fd) {
  type_t t = fndecl2type(fd);
  // this fills in the missing bound type variables and effects
  check_valid_toplevel_type(loc,te,t);
  switch (compress(t)) {
  case &FnType(i):
    let atts = fd->i.attributes;
    fd->i = i;
    fd->i.attributes = atts;
    fd->i.ret_tqual.real_const = 
      extract_const_from_typedef(loc,i.ret_tqual.print_const,i.ret_type);
    break;
  default: impos2("check_fndecl_valid_type: not a FnType");
  }
  let argnames = NULL;
  for(let args = fd->i.args; args != NULL; args = args->tl)
    argnames = new List((var_t)(*args->hd)[0], argnames);
  check_unique_vars(argnames,loc,"function declaration has repeated parameter");
  // cache the type on the declaration so we don't have to recompute it
  fd->cached_type = t;
}

// Same as check_valid_type except that we ensure the free type variables
// are drawn from the given set of bound type variables.
void check_type(seg_t loc, Tcenv::tenv_t te, list_t<tvar_t,`H> bound_tvars,
                kind_t expected_kind, bool allow_evars, bool allow_abs_aggr,
                type_t t) {
  let cvt = check_valid_type(CVTEnv{loc,te,bound_tvars,false,false,NULL,NULL},
			     expected_kind, allow_abs_aggr, t);
  let free_tvs= remove_bound_tvars(cvt.free_vars,bound_tvars,fst);
  for (; free_tvs != NULL; free_tvs = free_tvs->tl)
    err2(loc,"unbound type variable ",(*free_tvs->hd)[0]," in type ",t);
  if (!allow_evars)
    check_free_evars(cvt.free_evars,t,loc);
}
