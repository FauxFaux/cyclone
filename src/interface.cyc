/* Interface checking.
   Copyright (C) 2001 Greg Morrisett
   This file is part of the Cyclone compiler.

   The Cyclone compiler is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   The Cyclone compiler is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with the Cyclone compiler; see the file COPYING. If not,
   write to the Free Software Foundation, Inc., 59 Temple Place -
   Suite 330, Boston, MA 02111-1307, USA. */

#include "interface.h"

#include <dict.h>
#include <string.h>
#include <position.h>
#include <marshal.h>
#include "absynpp.h"
#include "tc.h"
#include "parse.h"
#include "tcutil.h"
#include "tcdecl.h"
using Core;
using List;
using Absyn;
using Tcenv;
using Absynpp;
using Tcutil;

namespace Lex {
  extern void lex_init();
}

namespace Interface {

/* ------ definition of an interface ------- */

typedef Tcdecl::xtunionfielddecl_t xtunionfielddecl_t;

// clone of Genv, but with only what we need
struct Ienv {
  Dict::dict_t<var_t,aggrdecl_t>    aggrdecls;
  Dict::dict_t<var_t,tuniondecl_t>  tuniondecls;
  Dict::dict_t<var_t,enumdecl_t>    enumdecls;
  Dict::dict_t<var_t,typedefdecl_t> typedefdecls;
  Dict::dict_t<var_t,vardecl_t>     vardecls;
  Dict::dict_t<var_t,xtunionfielddecl_t> xtunionfielddecls;
};

typedef struct Ienv @ienv_t;

// finally the definition of an interface
struct I {
  Dict::dict_t<list_t<var_t>,ienv_t> imports; // what is needed
  Dict::dict_t<list_t<var_t>,ienv_t> exports; // what is provided
};

static ienv_t new_ienv() {
  return new Ienv {
    .aggrdecls    = Dict::empty(strptrcmp),
    .tuniondecls  = Dict::empty(strptrcmp),
    .enumdecls    = Dict::empty(strptrcmp),
    .typedefdecls = Dict::empty(strptrcmp),
    .vardecls     = Dict::empty(strptrcmp),
    .xtunionfielddecls = Dict::empty(strptrcmp)
  };
}

static ienv_t lazy_new_ienv() {
  static struct Ienv * ie = NULL;
  if (ie == NULL)
    ie = new_ienv();
  return (ienv_t) ie;
}

static ienv_t skel2i_f(`a ignored) {
  return new_ienv();
}

static i_t skel2i(Dict::dict_t<list_t<var_t,`H>,`a> skel) {
  return new I(Dict::map(skel2i_f, skel), Dict::map(skel2i_f, skel));
}

i_t empty() {
  return new I(Dict::empty(varlist_cmp), Dict::empty(varlist_cmp));
}

// dual of the initial environment defined in Tcenv::tc_init
// + requirement for a function main
i_t final() {
  let i = empty();
  // add definition of xtunion exn
  let ie1 = new_ienv();
  let exn_d = new *exn_tud;
  exn_d->sc = Public;
  ie1->tuniondecls = Dict::insert(ie1->tuniondecls, (*exn_name)[1], exn_d);
  for(let tufs = exn_tud->fields->v; tufs != NULL; tufs = tufs->tl) {
    let exn_f = new *tufs->hd;
    exn_f->sc = Public;
    let exn_fd = new Tcdecl::Xtunionfielddecl(exn_d, exn_f);
    ie1->xtunionfielddecls = Dict::insert(ie1->xtunionfielddecls,
					  (*tufs->hd->name)[1], exn_fd);
  }    
  i->exports = Dict::insert(i->exports, NULL, ie1);
  // add requirement of function main
  let ie2 = new_ienv();
  qvar_t qmain = new $(Abs_n(NULL), new ((string_t)"main"));
  let vd = new_vardecl(qmain,
		       function_typ(NULL, NULL, sint_typ,
				    new List(new $(NULL, empty_tqual(NULL), uint_typ),
					     new List(new $(NULL, empty_tqual(NULL),
							    dyneither_typ(dyneither_typ(char_typ,
										  HeapRgn,
										  empty_tqual(NULL),false_conref),
								       HeapRgn,
								       empty_tqual(NULL),false_conref)),
						      NULL)),
				    false, NULL, NULL, NULL),
		       NULL);
  vd->sc = Extern;
  ie2->vardecls = Dict::insert(ie2->vardecls, (*qmain)[1], vd);
  i->imports = Dict::insert(i->exports, NULL, ie2);

  return i;
}

/* ********* invariants for interfaces ***********
 *
 * _ typedefs are stored in exports
 * _ possible scopes in exports are : Public (here structs are always complete)
 *   and Abstract (here structs are always incomplete)
 * _ possible scopes in imports are : Extern and ExternC
 * _ no var is initialized, there are no functions either (only prototypes)
 * _ all the qvars match the namespace they are in
 * _ a same object cannot be both in exports and in imports (except xtunions)
 * _ fields of xtunions are sorted by name
 *
 * ***********************************************/

/* ------ throwing an error ------ */

// note: we need to call reset_position(file_name) before all
static void err(string_t msg) {
  Tcutil::terr(NULL, msg);
}
static `a invalid_arg(string_t<`H> s) __attribute__((noreturn)) {
  throw new Core::Invalid_argument(s);
}
static void fields_err(string_t sc, string_t t, qvar_t n) {
  err(aprintf("fields of %s %s %s have never been defined",
	      sc, t, Absynpp::qvar2string(n)));
}
static void body_err(string_t sc, qvar_t n) {
  err(aprintf("the body of %s function %s has never been defined",
	      sc, Absynpp::qvar2string(n)));
}

// don't print anything if obj1 == NULL
static void static_err(string_t obj1,qvar_t name1,string_t obj2,qvar_t name2) {
  if (obj1 != NULL)
    err(aprintf("declaration of %s %s relies on static %s %s",
		obj1, Absynpp::qvar2string(name1), 
		obj2, Absynpp::qvar2string(name2)));
}

// id.
static void abstract_err(string_t obj1,qvar_t name1,string_t obj2,qvar_t name2){
  if (obj1 != NULL)
    err(aprintf("declaration of %s %s relies on fields of abstract %s %s",
		obj1, Absynpp::qvar2string(name1), 
		obj2, Absynpp::qvar2string(name2)));
}

/* ------ checking that a given type can be safely exported ----- */

/* --- to keep a track of already checked structures --- */
struct Seen {
  Dict::dict_t<qvar_t, bool> aggrs;
  Dict::dict_t<qvar_t, bool> tunions;
};

typedef struct Seen @ seen_t;

static seen_t new_seen() {
  return new Seen(Dict::empty(qvar_cmp), 
		  Dict::empty(qvar_cmp));
}

/* --- functions that actually perform the check --- */
typedef Dict::dict_t<list_t<var_t>, genv_t<`g>,`r> aenv_t<`g,`r>;

static bool check_public_type(aenv_t ae, seen_t seen, string_t obj, 
			      qvar_t name, type_t t);

static bool check_public_type_list(aenv_t ae, seen_t seen, string_t obj, 
				   qvar_t name, type_t (@f)(`a), list_t<`a> l) {
  let res = true;
  for (; l != NULL; l = l->tl)
    if (! check_public_type(ae, seen, obj, name, f(l->hd))) 
      res = false;
  return res;
}
static bool check_public_aggrdecl(aenv_t ae, seen_t seen, aggrdecl_t d) {
  try return Dict::lookup(seen->aggrs, d->name);
  catch { case Dict::Absent: break; }
  let res = true;
  seen->aggrs = Dict::insert(seen->aggrs, d->name, res); // necessary for recursive datas
  if (d->impl != NULL)
    for(let fs = d->impl->fields; fs != NULL; fs=fs->tl)
      if (!check_public_type(ae, seen, "type", d->name, fs->hd->type)) 
	res = false;

  seen->aggrs = Dict::insert(seen->aggrs, d->name, res); // save the result
  return res;
}

static type_t get_type1($(tqual_t,type_t) @ x) {
  return (*x)[1];
}
static type_t get_type2($(opt_t<string_t @>, struct Tqual, type_t) @ x) {
  return (*x)[2];
}

static bool check_public_tuniondecl(aenv_t ae, seen_t seen, tuniondecl_t d) {
  try return Dict::lookup(seen->tunions, d->name);
  catch { case Dict::Absent: break; }
  let res = true;
  seen->tunions = Dict::insert(seen->tunions, d->name, res); // necessary for recursive datas
  if (d->fields != NULL)
    for(let fs = d->fields->v; fs != NULL; fs=fs->tl)
      if (!check_public_type_list(ae, seen, "[x]tunion", d->name,
				  get_type1, fs->hd->typs)) 
	res = false;

  seen->tunions = Dict::insert(seen->tunions, d->name, res); // save result
  return res;
}

static bool check_public_enumdecl(aenv_t ae, seen_t seen, enumdecl_t d) {
  return true;
}

static bool check_public_typedefdecl(aenv_t ae, seen_t seen, typedefdecl_t d) {
  if (d->defn != NULL)
    return check_public_type(ae, seen, NULL/*"typedef"*/, d->name, d->defn->v);
  else return true;
  // don't print an error message for typedefs (we'll just not export the decl)
}

static bool check_public_vardecl(aenv_t ae, seen_t seen, vardecl_t d) {
  return check_public_type(ae, seen, "variable", d->name, d->type);
}

static list_t<var_t> get_abs_ns(datatype Nmspace ns) {
  switch (ns) {
  case Abs_n(l): return l;
  default: invalid_arg("get_abs_ns");
  }
}

static bool check_public_type(aenv_t ae, seen_t seen, string_t obj, qvar_t name, type_t t) {
  switch (compress(t)) {
  case &PointerType(PtrInfo{t,_,_}): fallthru(t);
  case &ArrayType(ArrayInfo{t,_,_,_,_}): fallthru(t);
  case &TypedefType(_,_,_, &t):
    return check_public_type(ae, seen, obj, name, t);

  case &FnType(FnInfo(_,_,ret,args,_,cyc_varargs,_,_)):
    bool b = check_public_type_list(ae, seen, obj, name, get_type2, args)
      && check_public_type(ae, seen, obj, name, ret);
    if (cyc_varargs != NULL) {
      let VarargInfo{_,_,vt,_} = *cyc_varargs;
      b = check_public_type(ae, seen, obj, name, vt);
    }
    return b;

  case &TupleType(lt):
    return check_public_type_list(ae, seen, obj, name, get_type1, lt);

  case &AggrType(AggrInfo(info,targs)):
    let ad = get_known_aggrdecl(info);
    if (ad->sc == Static) {
      static_err(obj, name, "type", ad->name);
      return false;
    }
    return check_public_type_list(ae, seen, obj, name, identity, targs)
      && check_public_aggrdecl(ae, seen, ad);

  case &EnumType(name, _):
    let &$(tns, v) = name;
    let ns = get_abs_ns(tns);
    enumdecl_t ed;
    try {
      let ge = Dict::lookup(ae, ns);
      ed = *Dict::lookup(ge->enumdecls, v);
    } catch {
    case Dict::Absent: 
      invalid_arg(aprintf("check_public_type (can't find enum %s)",
			  qvar2string(name)));
    }
    if (ed->sc == Static) {
      static_err(obj, name, "enum", ed->name);
      return false;
    }
    return true /*check_public_enum(ae, seen, ed)*/;

  case &TunionType(TunionInfo(KnownTunion(&tud0),targs,_)):
    let &$(tns, v) = tud0->name;
    let ns = get_abs_ns(tns);
    tuniondecl_t tud;
    try {
      let ge = Dict::lookup(ae, ns);
      tud = *Dict::lookup(ge->tuniondecls, v);
    } catch { case Dict::Absent: 
      invalid_arg(aprintf("check_public_type (can't find [x]tunion %s)",
			  qvar2string(tud0->name)));
    }
    if (tud->sc == Static) {
      static_err(obj, name, "[x]tunion", tud->name);
      return false;
    }
    return check_public_type_list(ae, seen, obj, name, identity, targs)
      && check_public_tuniondecl(ae, seen, tud);

  case &TunionFieldType(TunionFieldInfo{KnownTunionfield(tud0,tuf0), targs}):
    let &$(tns, v) = tud0->name;
    let ns = get_abs_ns(tns);
    tuniondecl_t tud;
    try {
      let ge = Dict::lookup(ae, ns);
      tud = *Dict::lookup(ge->tuniondecls, v);
    } catch {
    case Dict::Absent:
      invalid_arg(aprintf("check_public_type (can't find [x]tunion %s and search its fields)",
			  qvar2string(tud0->name)));
    }
    if (tud->fields == NULL) 
      invalid_arg(aprintf("check_public_type ([x]tunion %s has no fields)",
			  qvar2string(tud->name)));

    struct Tunionfield * tuf1 = NULL;
    for (let fs = tud->fields->v; fs != NULL; fs = fs->tl)
      if (strptrcmp((*tuf0->name)[1], (*fs->hd->name)[1]) == 0) {
	  tuf1 = fs->hd;
	  break;
	}
  
    if (tuf1 == NULL) 
      invalid_arg(aprintf("check_public_type (can't find [x]tunionfield %s)",
			  qvar2string(tuf0->name)));
    tunionfield_t tuf = (tunionfield_t) tuf1;

    if (tud->sc == Static) {
      static_err(obj, name, "[x]tunion", tud->name);
      return false;
    }
    if (tud->sc == Abstract) {
      abstract_err(obj, name, "[x]tunion", tud->name);
      return false;
    }
    if (tuf->sc == Static) {
      static_err(obj, name, 
		 aprintf("field %s of", qvar2string(tuf->name)),tud->name);
      return false;
    }
    return check_public_type_list(ae, seen, obj, name, identity, targs)
      && check_public_tuniondecl(ae, seen, tud);

  default: return true;
  }
}

/* ------ extracting an interface from a global environment ------ */

static void extract_aggrdecl($(ienv_t,ienv_t,bool,aenv_t,seen_t,i_t) @ env,
				var_t x, aggrdecl_t@ dp) {
  let &$(imp, exp, check_complete_defs, ae, seen, _) = env;
  let d = *dp;
  switch(d->sc) {
  case Static:
    if (check_complete_defs && d->impl == NULL)
      fields_err("static", "struct/union", d->name);
    break;
  case Abstract:
    if (d->impl == NULL) {
      if (check_complete_defs)
	fields_err("abstract", "struct/union", d->name);
    } else {
      d = new *d;
      d->impl = NULL;
    }
    if (check_public_aggrdecl(ae, seen, d))
      exp->aggrdecls = Dict::insert(exp->aggrdecls, x, d);
    break;
  case Public:
    if (d->impl == NULL) {
      fields_err("public", "struct/union", d->name);
      d = new *d;
      d->sc = Abstract;
    }
    if (check_public_aggrdecl(ae, seen, d))
      exp->aggrdecls = Dict::insert(exp->aggrdecls, x, d);
    break;
  case ExternC: 
  case Extern:
    if (check_public_aggrdecl(ae, seen, d)) 
      imp->aggrdecls = Dict::insert(imp->aggrdecls, x, d);
    break;
  case Register: 
    invalid_arg("add_aggrdecl");
    break;
  }
}
static void extract_enumdecl($(ienv_t,ienv_t,bool,aenv_t,seen_t,i_t) @ env,
				var_t x, enumdecl_t@ dp) {
  let &$(imp, exp, check_complete_defs, ae, seen, _) = env;
  let d = *dp;
  switch(d->sc) {
  case Static:
    if (check_complete_defs && d->fields == NULL)
      fields_err("static", "enum", d->name);
    break;
  case Abstract:
    if (d->fields == NULL) {
      if (check_complete_defs)
	fields_err("abstract", "enum", d->name);
    } else {
      d = new *d;
      d->fields = NULL;
    }
    if (check_public_enumdecl(ae, seen, d))
      exp->enumdecls = Dict::insert(exp->enumdecls, x, d);
    break;
  case Public:
    if (d->fields == NULL) {
      fields_err("public", "enum", d->name);
      d = new *d;
      d->sc = Abstract;
    }
    if (check_public_enumdecl(ae, seen, d))
      exp->enumdecls = Dict::insert(exp->enumdecls, x, d);
    break;
  case ExternC:
  case Extern:
    if (check_public_enumdecl(ae, seen, d))
      imp->enumdecls = Dict::insert(imp->enumdecls, x, d);
    break;
  case Register: 
    invalid_arg("add_enumdecl");
    break;
  }
}

static void
extract_xtunionfielddecl(i_t i, tuniondecl_t d, tunionfield_t f) {
  let ns = NULL;
  switch ((*(f->name))[0]) {
  case Rel_n(l): fallthru(l);
  case Abs_n(l): ns = l; break;
  default: break;
  }
  _ dict;
  switch (f->sc) {
  case Static: return;
  case Extern: dict = & i->imports; break;
  case Public: dict = & i->exports; break;
  default: invalid_arg("add_xtunionfielddecl");
  }

  ienv_t env;
  try {
    env = Dict::lookup(*dict, ns);
  } catch {
  case Dict::Absent:
    env = new_ienv();
    *dict = Dict::insert(*dict, ns, env);
    break;
  }
  env->xtunionfielddecls =
    Dict::insert(env->xtunionfielddecls, (*(f->name))[1] , new Tcdecl::Xtunionfielddecl(d, f));
}

static void extract_tuniondecl($(ienv_t,ienv_t,bool,aenv_t,seen_t,i_t) @ env, 
			       var_t x, tuniondecl_t@ dp) {
  let &$(imp, exp, check_complete_defs, ae, seen, i) = env;
  let d = *dp;

  switch(d->sc) {
  case Static:
    if (!d->is_xtunion && check_complete_defs && d->fields == NULL) {
      fields_err("static", "tunion", d->name);
    }
    break;
  case Abstract:
    if (d->fields == NULL) {
      if (!d->is_xtunion && check_complete_defs) {
	fields_err("abstract", "tunion", d->name);
      }
    } else {
      d = new *d;
      d->fields = NULL;
    }
    if (check_public_tuniondecl(ae, seen, d))
      exp->tuniondecls = Dict::insert(exp->tuniondecls, x, d);
    break;
  case Public:
    d = new *d;
    if (!d->is_xtunion && d->fields == NULL) {
      fields_err("public", "tunion", d->name);
      d->sc = Abstract;
    }
    if (check_public_tuniondecl(ae, seen, d)) {
      if (d->is_xtunion && d->fields != NULL) {
	let fields = d->fields->v;
	d->fields = NULL;
	for (let f = fields; f != NULL; f = f->tl) {
	  extract_xtunionfielddecl(i, d, f->hd);
	}
      }
      exp->tuniondecls = Dict::insert(exp->tuniondecls, x, d);
    }
    break;
  case ExternC: invalid_arg("extract_tuniondecl");
  case Extern:
    if (check_public_tuniondecl(ae, seen, d)) {
      if (d->is_xtunion && d->fields != NULL) {
	d = new *d;
	let fields = d->fields->v;
	d->fields = NULL;
	for (let f = fields; f != NULL; f = f->tl) {
	  extract_xtunionfielddecl(i, d, f->hd);
	}
      }
      imp->tuniondecls = Dict::insert(imp->tuniondecls, x, d);
    }
    break;
  case Register: 
    invalid_arg("add_tuniondecl");
    break;
  }
}

static void extract_typedef($(ienv_t, ienv_t, bool, aenv_t, seen_t, i_t) @ env,
			    var_t x, typedefdecl_t d) {
  let &$(_, exp, _, ae, seen, _) = env;
  if (check_public_typedefdecl(ae, seen, d))
    exp->typedefdecls = Dict::insert(exp->typedefdecls, x, d);
}

static void extract_ordinarie($(ienv_t,ienv_t,bool,aenv_t,seen_t,i_t) @ env,
			      var_t x, $(resolved_t,bool)@ v) {
  let &$(imp, exp, check_complete_defs, ae, seen, _) = env;
  let r = (* v)[0];
  
  switch(r) {
  case &VarRes(b):
    switch (b) {
    case &Funname_b(fd):
      let vd = new Vardecl{
	.sc = fd->sc,
	.name = fd->name,
	.tq = empty_tqual(NULL),
	.type = (fd->cached_typ)->v,
	.initializer = NULL,
	.rgn = NULL,
	.attributes = NULL,
        .escapes = false
      };
      check_complete_defs = false; // the body of the function has been defined
      fallthru(vd);
    case &Global_b(d):
      if (d->initializer != NULL) {
	d = new *d;
	d->initializer = NULL; // drop the initializer
      }
      switch(d->sc) {
      case Static:
	if (check_complete_defs && Tcutil::is_function_type(d->type)) {
	  body_err("static", d->name);
	}
	break;
      case Register: 
      case Abstract: invalid_arg("extract_ordinarie");
      case Public:
	if (check_complete_defs && Tcutil::is_function_type(d->type)) {
	  body_err("public", d->name);
	}
	if (check_public_vardecl(ae, seen, d))
	  exp->vardecls = Dict::insert(exp->vardecls, x, d);
	break;
      case ExternC: fallthru;
      case Extern:
	if (check_public_vardecl(ae, seen, d))
	  imp->vardecls = Dict::insert(imp->vardecls, x, d);
	break;
      }
      break;
    default: break;
    }
    break;
  default: break;
  }
}

static void extract_f($(i_t, bool, aenv_t, seen_t) @ env_f, 
		      list_t<var_t,`H> ns, genv_t ge) {
  let &$(i, check_complete_defs, ae, seen) = env_f;
  let env = $(Dict::lookup(i->imports, ns),
	      Dict::lookup(i->exports, ns),
	      check_complete_defs,
	      ae, seen,
	      i);
  Dict::iter_c(extract_aggrdecl,   &env,  ge->aggrdecls);
  Dict::iter_c(extract_tuniondecl, &env,  ge->tuniondecls);
  Dict::iter_c(extract_enumdecl,   &env,  ge->enumdecls);
  Dict::iter_c(extract_typedef,    &env,  ge->typedefs);
  Dict::iter_c(extract_ordinarie,  &env,  ge->ordinaries);
}

static i_t gen_extract(Dict::dict_t<list_t<var_t,`H>, genv_t> ae, 
		       bool check_complete_defs) {
  $(i_t,bool,aenv_t,seen_t) env = 
    $(skel2i(ae), check_complete_defs, ae, new_seen());
  Dict::iter_c(extract_f, &env, ae);
  return env[0];
}

i_t extract(Dict::dict_t<list_t<var_t,`H>, genv_t> ae) {
  return gen_extract(ae, true);
}

////// checking inclusion ///////

inline static void check_err(string_t<`H> * msg1, string_t<`H> msg2) {
  Tcdecl::merr(NULL, msg1, "%s", msg2);
}

static void incl_dict_f($(bool,
			  Dict::dict_t<var_t, `a,`H>,
			  bool (@)(`a, `a, string_t<`H> *`H),
			  string_t<`H>,
			  string_t<`H> *`H) @ env,
			var_t x,
			`a y1) {
  let &$(*res, dic2, incl_f, t, msg) = env;
  try {
    let y2 = Dict::lookup(dic2, x);
    if (! incl_f(y1, y2, msg)) (*res) = false;
  } catch {
  case Dict::Absent:
    check_err(msg, aprintf("%s %s is missing", t, *x));
    *res = false;
    break;
  }
}

static bool incl_dict(Dict::dict_t<var_t, `a,`H> dic1,
		      Dict::dict_t<var_t, `a,`H> dic2,
		      bool (@incl_f)(`a, `a, string_t<`H> *`H),
		      string_t<`H> t,
		      string_t<`H> *`H msg) {
  let env = $(true, dic2, incl_f, t, msg);
  Dict::iter_c(incl_dict_f, &env, dic1);
  return env[0];
}

// FIX: Make this hack go away
#define INCL_DECL(OBJ, TYPEOBJ, NAMEOPT) \
static bool incl_##OBJ##decl(OBJ##decl_t d0, OBJ##decl_t d1, string_t<`H> *`H msg) { \
  let d = Tcdecl::merge_##OBJ##decl(d0, d1, NULL, msg); \
  if (d == NULL) return false; \
  if (d0 != d) { \
    check_err(msg, aprintf("declaration of " TYPEOBJ " %s discloses too much information", \
			   qvar2string(d1 NAMEOPT))); \
    return false; \
  } \
  return true; \
}

INCL_DECL(aggr, "type", ->name)

INCL_DECL(tunion, "tunion", ->name)

INCL_DECL(enum, "enum", ->name)

INCL_DECL(var, "variable", ->name)

INCL_DECL(typedef, "typedef", ->name)

INCL_DECL(xtunionfield, "xtunionfield", ->field->name)

#define INCL_DICT(OBJ, NAMEOBJ)\
  incl_dict(ie1->OBJ##decls, ie2->OBJ##decls, incl_##OBJ##decl, NAMEOBJ, msg)

Dict::dict_t<var_t, `a::A @> *
compat_merge_dict(Dict::dict_t<var_t, `a @`H,`H> dic1,
		  Dict::dict_t<var_t, `a @`H,`H> dic2,
		  Dict::dict_t<var_t, `a @`H,`H> excl,
		  `a * (@merge_f)(`a@`H, `a@`H, Position::seg_t,
				  string_t<`H> *`H),
		  string_t<`H> t,
		  string_t<`H> *`H msg);

static bool incl_ienv(ienv_t ie1, ienv_t ie2, string_t<`H> *`H msg) {
  let r1 = INCL_DICT(aggr, "type");
  let r2 = INCL_DICT(tunion, "tunion");
  let r3 = INCL_DICT(enum, "enum");
  /* special case for typedefs */
  let r4 = (compat_merge_dict(ie1->typedefdecls, ie2->typedefdecls,
			      Dict::empty(strptrcmp), Tcdecl::merge_typedefdecl,
			      "typedef", msg) != NULL);
  let r5 = INCL_DICT(var, "variable");
  let r6 = INCL_DICT(xtunionfield, "xtunionfield");
  return (r1 && r2 && r3 && r4 && r5 && r6);
}

static void incl_ns_f($(bool,
			Dict::dict_t<list_t<var_t,`H>,ienv_t,`H>,
			string_t<`H> *`H) @ env,
		      list_t<var_t,`H> ns,
		      ienv_t ie1) {
  let &$(*res, dic2, msg) = env;

  ienv_t ie2;

  // it's OK to use lazy_new_ienv because everything's functional
  try ie2 = Dict::lookup(dic2, ns);
  catch {case Dict::Absent: ie2 = lazy_new_ienv(); break;}

  if (! incl_ienv(ie1, ie2, msg)) *res = false;
}

static bool incl_ns(Dict::dict_t<list_t<var_t,`H>, ienv_t,`H> dic1,
		    Dict::dict_t<list_t<var_t,`H>, ienv_t,`H> dic2,
		    string_t<`H> *`H msg) {
  let env = $(true, dic2, msg);
  Dict::iter_c(incl_ns_f, &env, dic1);
  return (env[0]);
}

bool is_subinterface(i_t i1, i_t i2, $(string_t<`H>, string_t<`H>) * info) {
  try {
    let res = true;
    string_t * msg = NULL;
  
    if (info != NULL)
      msg = new ((string_t)aprintf("checking inclusion of %s exports into %s exports,", (*info)[0], (*info)[1]));
    if (!incl_ns(i1->exports, i2->exports, msg)) res = false;
    
    if (info != NULL)
      msg = new ((string_t)aprintf("checking inclusion of %s imports into %s imports,", (*info)[1], (*info)[0]));
    if (!incl_ns(i2->imports, i1->imports, msg)) res = false;
    
    return res;
  } catch {
  case Tcdecl::Incompatible: return false;
  }
}

/* ------- merging 2 interfaces -------- */

/* --- functions for compatible union (and compatible substraction) --- */

void compat_merge_dict_f($(bool,
			   Dict::dict_t<var_t, `a::A @`H,`H>,
			   Dict::dict_t<var_t, `a @`H,`H>,
			   Dict::dict_t<var_t, `a @`H,`H>,
			   `a * (@)(`a @`H, `a @`H, Position::seg_t, string_t<`H> *`H),
			   string_t<`H>, string_t<`H> *`H ) @ env,
			 var_t x, `a @`H y2) {
  let &$(*res, *res_dic, dic1, excl, merge_f, t, msg) = env;
  `a @ y;
  try {
    let y1 = Dict::lookup(dic1, x);
    
    // try to merge y1 and y2 into y
    let yt = merge_f(y1, y2, NULL, msg);
    if (!yt) {
      *res = false;
      return;
    }
    y = (`a @) yt;
  } catch {
  case Dict::Absent:
    y = y2;
    break;
  }
  
  try {
    let ye = Dict::lookup(excl, x);

    // check that y is included in ye
    // otherwise it means that we are trying to guess fields of an abstract structure
    let yt = merge_f(ye, y, NULL, msg);
    if (yt != ye) {
      if (yt) // if yt is NULL, the error came from the merging
	check_err(msg, aprintf("abstract %s %s is being imported as non-abstract",
			       t, *x));
      *res = false;
    }
  } catch {
  case Dict::Absent:
    if (*res)
      *res_dic = Dict::insert(*res_dic, x, y);
    break;
  }
}

Dict::dict_t<var_t, `a::A @> *
compat_merge_dict(Dict::dict_t<var_t, `a @`H,`H> dic1,
		  Dict::dict_t<var_t, `a @`H,`H> dic2,
		  Dict::dict_t<var_t, `a @`H,`H> excl,
		  `a * (@merge_f)(`a @`H, `a @`H, 
				  Position::seg_t, string_t<`H> *`H),
		  string_t<`H> t,
		  string_t<`H> *`H msg) {
  let env = $(true, dic1, dic1, excl, merge_f, t, msg);

  Dict::iter_c(compat_merge_dict_f, &env, dic2);

  if (env[0])
    return new env[1];
  return NULL;
}

#define COMPAT_MERGE_DICT(OBJ, NAME)\
  compat_merge_dict(ie1->OBJ##decls, ie2->OBJ##decls, \
		    iexcl->OBJ##decls, Tcdecl::merge_##OBJ##decl,\
		    NAME, msg)

struct Ienv * compat_merge_ienv(ienv_t ie1, ienv_t ie2, ienv_t iexcl, string_t<`H> *`H msg) {
  let r1 = COMPAT_MERGE_DICT(aggr, "type");
  let r2 = COMPAT_MERGE_DICT(tunion, "tunion");
  let r3 = COMPAT_MERGE_DICT(enum, "enum");
  let r4 = COMPAT_MERGE_DICT(typedef, "typedef");
  let r5 = COMPAT_MERGE_DICT(var, "variable");
  let r6 = COMPAT_MERGE_DICT(xtunionfield, "xtunionfield");
  if (!r1 || !r2 || !r3 || !r4 || !r5 || !r6 )
    return NULL;
  return new Ienv(*r1, *r2, *r3, *r4, *r5, *r6);
}

void compat_merge_ns_f($(bool,
			 Dict::dict_t<list_t<var_t,`H>, ienv_t,`H>,
			 Dict::dict_t<list_t<var_t,`H>, ienv_t,`H>,
			 Dict::dict_t<list_t<var_t,`H>, ienv_t,`H>,
			 string_t<`H> *`H) @ env,
		       list_t<var_t,`H> ns, ienv_t ie2) {
  let &$(*res, *res_dic, dic1, excl, msg) = env;

  ienv_t ie1, iexcl;

  // it's OK to use lazy_new_ienv because everything's functional
  try iexcl = Dict::lookup(excl, ns);
  catch {case Dict::Absent: iexcl = lazy_new_ienv(); break;}

  try {
    ie1 = Dict::lookup(dic1, ns);
    let ie =  compat_merge_ienv(lazy_new_ienv(), ie1, iexcl, msg); //substract iexcl from ie1
    if (ie == NULL) {
      *res = false;
      return;
    }
    ie1 = (ienv_t) ie;
  } catch {case Dict::Absent: ie1 = lazy_new_ienv(); break;}

  let ie = compat_merge_ienv(ie1, ie2, iexcl, msg);

  if (ie == NULL)
    *res = false;
  else
    if (*res)
      *res_dic = Dict::insert(*res_dic, ns, (ienv_t) ie);
}

Dict::dict_t<list_t<var_t>, ienv_t> *
compat_merge_ns(Dict::dict_t<list_t<var_t,`H>, ienv_t,`H> dic1,
		Dict::dict_t<list_t<var_t,`H>, ienv_t,`H> dic2,
		Dict::dict_t<list_t<var_t,`H>, ienv_t,`H> excl,
		string_t<`H> *`H msg) {
  Dict::dict_t<list_t<var_t,`H>, ienv_t, `H> d = Dict::empty(varlist_cmp);
  let env = $(true, d, dic1, excl, msg);

  Dict::iter_c(compat_merge_ns_f, &env, dic2);

  if (env[0])
    return new env[1];
  return NULL;
}

/* --- functions for disjoint union --- */
void disj_merge_dict_f($(bool, Dict::dict_t<var_t,`a,`H>,
			 Dict::dict_t<var_t,`a,`H>,string_t<`H>,string_t<`H> *`H) @ env,
		       var_t x, `a y) {
  let &$(*res, *res_dic, dic1, t, msg) = env;
  if (Dict::member(dic1, x)) {
    check_err(msg, aprintf("%s %s is exported more than once", t, *x));
    *res = false;
  } else {
    if (*res) *res_dic = Dict::insert(*res_dic, x, y);
  }
}

Dict::dict_t<var_t, `a>* disj_merge_dict(Dict::dict_t<var_t, `a,`H> dic1,
                                         Dict::dict_t<var_t, `a,`H> dic2,
                                         string_t<`H> t, 
                                         string_t<`H> *`H msg) {
  let env = $(true, dic1, dic1, t, msg);
  Dict::iter_c(disj_merge_dict_f, &env, dic2);
  if (env[0])
    return new env[1];
  return NULL;
}

struct Ienv * disj_merge_ienv(ienv_t ie1, ienv_t ie2, string_t<`H> *`H msg) {
  let r1 = compat_merge_dict(ie1->aggrdecls, ie2->aggrdecls, 
			     Dict::empty(strptrcmp),
			     Tcdecl::merge_aggrdecl, "type", msg);
  let r2 = disj_merge_dict(ie1->tuniondecls,ie2->tuniondecls,"[x]tunion",msg);
  let r3 = disj_merge_dict(ie1->enumdecls, ie2->enumdecls, "enum", msg);
  /* special case for typedefs */
  let r4 = compat_merge_dict(ie1->typedefdecls, ie2->typedefdecls, 
			     Dict::empty(strptrcmp),
			     Tcdecl::merge_typedefdecl, "typedef", msg);
  let r5 = disj_merge_dict(ie1->vardecls, ie2->vardecls, "variable", msg);
  let r6 = disj_merge_dict(ie1->xtunionfielddecls, ie2->xtunionfielddecls,
			   "xtunionfield", msg);

  if (!r1 || !r2 || !r3 || !r4 || !r5 || !r6)
    return NULL;
  return new Ienv(*r1, *r2, *r3, *r4, *r5, *r6);
}

void disj_merge_ns_f($(bool, Dict::dict_t<list_t<var_t,`H>, ienv_t,`H>,
		       Dict::dict_t<list_t<var_t,`H>, ienv_t,`H>, string_t<`H> *`H) @ env,
		     list_t<var_t,`H> ns, ienv_t ie2) {
  let &$(*res, *res_dic, dic1, msg) = env;

  ienv_t ie1;

  try ie1 = Dict::lookup(dic1, ns);
  catch { case Dict::Absent: ie1 = lazy_new_ienv(); break; }

  let ie = disj_merge_ienv(ie1, ie2, msg);

  if (ie == NULL)
    *res = false;
  else
    if (*res)
      *res_dic = Dict::insert(*res_dic, ns, (ienv_t) ie);
}

Dict::dict_t<list_t<var_t>, ienv_t> * 
disj_merge_ns(Dict::dict_t<list_t<var_t,`H>, ienv_t,`H> dic1,
	      Dict::dict_t<list_t<var_t,`H>, ienv_t,`H> dic2,
	      string_t<`H> *`H msg) {
  let env = $(true, dic1, dic1, msg);
  Dict::iter_c(disj_merge_ns_f, &env, dic2);
  if (env[0])
    return new env[1];
  return NULL;
}

/* --- main function --- */
struct I * merge(i_t i1, i_t i2, $(string_t<`H>, string_t<`H>) * info) {
  try {
    string_t * msg = NULL;

    if (info != NULL)
      msg = new ((string_t)aprintf("merging exports of %s and %s,", 
				   (*info)[0], (*info)[1]));

    let exp = disj_merge_ns(i1->exports, i2->exports, msg);
    if (exp == NULL) return NULL;

    if (info != NULL)
      msg = new ((string_t)aprintf("merging imports of %s and %s,", 
				   (*info)[0], (*info)[1]));

    let imp = compat_merge_ns(i1->imports, i2->imports, *exp, msg);
    if (imp == NULL) return NULL;

    return new I(*imp, *exp);
  } catch { case Tcdecl::Incompatible: return NULL; }
}

struct I * merge_list(list_t<i_t,`H> li, list_t<string_t<`H> @`H,`H> linfo) {
  if (li == NULL) return empty();

  i_t curr_i = li->hd;
  string_t * curr_info = (linfo != NULL ? (string_t *)linfo->hd : NULL);
  li=li->tl;
  if (linfo != NULL) linfo=linfo->tl;

  for (; li != NULL; li=li->tl) {
    let i = merge(curr_i, li->hd,
		  (curr_info != NULL && linfo != NULL ? new $(*curr_info, *linfo->hd) : NULL) );
    if (i == NULL) return NULL;
    curr_i = (i_t) i;
    if (curr_info != NULL) {
      curr_info = (linfo != NULL ? new ((string_t)aprintf("%s+%s", *curr_info, *linfo->hd)) : NULL);
    }
    if (linfo != NULL) linfo = linfo->tl;
  }
  return curr_i;
}

struct I * get_and_merge_list(i_t (@get)(`a), list_t<`a,`H> la, list_t<string_t<`H> @`H,`H> linfo) {
  if (la == NULL) return empty();

  i_t curr_i = get(la->hd);
  string_t * curr_info = (linfo != NULL ? (string_t *)linfo->hd : NULL);
  la=la->tl;
  if (linfo != NULL) linfo=linfo->tl;

  for (; la != NULL; la=la->tl) {
    let i = merge(curr_i, get(la->hd),
		  (curr_info != NULL && linfo != NULL ? new $(*curr_info, *linfo->hd) : NULL) );
    if (i == NULL) return NULL;
    curr_i = (i_t) i;
    if (curr_info != NULL) {
      curr_info = (linfo != NULL ? new ((string_t)aprintf("%s+%s", *curr_info, *linfo->hd)) : NULL);
    }
    if (linfo != NULL) linfo = linfo->tl;
  }
  return curr_i;
}

/* ------- printing an interface ------ */

static list_t<decl_t> add_namespace(list_t<decl_t,`H> tds, list_t<var_t,`H> ns){
  if (ns == NULL) return tds;
  return new List(new_decl(new Namespace_d(ns->hd, add_namespace(tds, ns->tl)),
			   NULL), NULL);
}

static list_t<decl_t> add_aggrdecl(var_t x,aggrdecl_t d,list_t<decl_t,`H> tds) {
  return new List(new_decl(new Aggr_d(d), NULL),tds);
}

static list_t<decl_t> add_aggrdecl_header(var_t x, aggrdecl_t d, 
					  list_t<decl_t,`H> tds) {
  d = new *d;
  d->impl = NULL;
  if (d->sc != ExternC) d->sc = Extern;
  return new List(new_decl(new Aggr_d(d), NULL),tds);
}

static list_t<decl_t> add_tuniondecl(var_t x, tuniondecl_t d, list_t<decl_t,`H> tds) {
  return new List(new_decl(new Tunion_d(d), NULL),tds);
}

static string_t us = "_";
static stringptr_t us_p = &us;

static $(tqual_t,type_t)@ rewrite_tunionfield_type($(tqual_t,type_t)@`H x) {
  return new $(empty_tqual(NULL),
	       new VarType(new Tvar(us_p, -1, kind_to_bound(BoxKind))));
}

static tunionfield_t rewrite_tunionfield(tunionfield_t f) {
  f = new *f;
  f->typs = map(rewrite_tunionfield_type, f->typs);
  return f;
}

static list_t<decl_t> add_tuniondecl_header(var_t x, tuniondecl_t d, 
					    list_t<decl_t,`H> tds) {
  d = new *d;
  //d->fields = NULL;
  if (d->fields != NULL) d->fields = new Opt(map(rewrite_tunionfield, d->fields->v));
  if (d->sc != ExternC) d->sc = Extern;
  return new List(new_decl(new Tunion_d(d), NULL),tds);
}

static list_t<decl_t> add_enumdecl(var_t x,enumdecl_t d,list_t<decl_t,`H> tds) {
  return new List(new_decl(new Enum_d(d), NULL),tds);
}

static list_t<decl_t> add_enumdecl_header(var_t x, enumdecl_t d, 
					  list_t<decl_t,`H> tds) {
  d = new *d;
  d->fields = NULL;
  if (d->sc != ExternC) d->sc = Extern;
  return new List(new_decl(new Enum_d(d), NULL),tds);
}

static list_t<decl_t> add_typedef(var_t x, typedefdecl_t d, 
				  list_t<decl_t,`H> tds) {
  return new List(new_decl(new Typedef_d(d), NULL),tds);
}

static list_t<decl_t> add_vardecl(var_t x, vardecl_t d, list_t<decl_t,`H> tds) {
  return new List(new_decl(new Var_d(d), NULL),tds);
}

static list_t<decl_t> add_xtunionfielddecl(var_t x, xtunionfielddecl_t d, 
					   list_t<decl_t,`H> tds) {
  let &Tcdecl::Xtunionfielddecl(b,f)=d;
  b = new *b;
  b->fields = new Opt(new List(f,NULL));
  b->sc = Extern;
  return new List(new_decl(new Tunion_d(b), NULL),tds);
}

static list_t<decl_t> add_xtunionfielddecl_header(var_t x, xtunionfielddecl_t d,
						  list_t<decl_t,`H> tds) {
  let &Tcdecl::Xtunionfielddecl(b,f)=d;
  b = new *b;
  f = rewrite_tunionfield(f);
  f->sc = Extern;
  b->fields = new Opt(new List(f,NULL));
  b->sc = Extern;
  return new List(new_decl(new Tunion_d(b), NULL),tds);
}

static void print_ns_headers(FILE @ f, list_t<var_t,`H> ns, ienv_t ie) {
  let tds = NULL;
  tds = Dict::fold(add_aggrdecl_header,   ie->aggrdecls,   tds);
  tds = Dict::fold(add_tuniondecl_header, ie->tuniondecls, tds);
  tds = Dict::fold(add_enumdecl_header,   ie->enumdecls,   tds);

  if (tds != NULL) {
    tds = imp_rev(tds);
    tds = add_namespace(tds, ns);
    Absynpp::decllist2file(tds, f);
  }
}

static void print_ns_xtunionfielddecl_headers(FILE @ f, list_t<var_t,`H> ns,
					      ienv_t ie) {
  let tds = Dict::fold(add_xtunionfielddecl_header,ie->xtunionfielddecls,NULL);
  if (tds != NULL) {
    tds = imp_rev(tds);
    tds = add_namespace(tds, ns);
    Absynpp::decllist2file(tds, f);
  }
}

static void print_ns_typedefs(FILE @ f, list_t<var_t,`H> ns, ienv_t ie) {
  let tds = Dict::fold(add_typedef, ie->typedefdecls, NULL);
  if (tds != NULL) {
    tds = imp_rev(tds);
    tds = add_namespace(tds, ns);
    Absynpp::decllist2file(tds, f);
  }
}

static void print_ns_decls(FILE @ f, list_t<var_t,`H> ns, ienv_t ie) {
  let tds = NULL;
  tds = Dict::fold(add_aggrdecl,   ie->aggrdecls,   tds);
  tds = Dict::fold(add_tuniondecl, ie->tuniondecls, tds);
  tds = Dict::fold(add_enumdecl,   ie->enumdecls,   tds);
  tds = Dict::fold(add_vardecl,    ie->vardecls,    tds);
  tds = Dict::fold(add_xtunionfielddecl, ie->xtunionfielddecls, tds);

  if (tds != NULL) {
    tds = imp_rev(tds);
    tds = add_namespace(tds, ns);
    Absynpp::decllist2file(tds, f);
  }
}

// everything is extremely verbose
// but there's no other solution as long as we have to
// declare structures before using them
void print(i_t i, FILE @ f) {
  Absynpp::set_params(&Absynpp::cyci_params_r);
  fprintf(f,   "/****** needed (headers) ******/\n");
  Dict::iter_c(print_ns_headers, f, i->imports);

  fprintf(f, "\n/****** provided (headers) ******/\n");
  Dict::iter_c(print_ns_headers, f, i->exports);

  // we handle xtunionfields separately because they can be in a different
  // namespace from their corresponding xtuniondecls
  fprintf(f,   "\n/****** needed (headers of xtunionfielddecls) ******/\n");
  Dict::iter_c(print_ns_xtunionfielddecl_headers, f, i->imports);

  fprintf(f, "\n/****** provided (headers of xtunionfielddecls) ******/\n");
  Dict::iter_c(print_ns_xtunionfielddecl_headers, f, i->exports);

  //typedefs are always public...
  fprintf(f, "\n/****** provided (typedefs) ******/\n");
  Dict::iter_c(print_ns_typedefs, f, i->exports);

  fprintf(f, "\n/****** needed (declarations) ******/\n");
  Dict::iter_c(print_ns_decls, f, i->imports);

  fprintf(f, "\n/****** provided (declarations) ******/\n");
  Dict::iter_c(print_ns_decls, f, i->exports);
}

/* ------ parsing a text file ------ */

// WARNING: Position::reset_position must be called before using parse
i_t parse(FILE @ f) { 
  Lex::lex_init();
  let tds = Parse::parse_file(f);
  region r; {
    let te  = Tcenv::tc_init(r);
    Tc::tc(r, te, false, tds); // no "Cyc" prefix, no default initializer 
    return gen_extract(te->ae, false); //don't check that definitions are complete
  }
}

/* ------ binary loading and saving ------ */
}

using Marshal;
using Typerep;

//  static tunion Typerep::Typestruct i_t_rep = gen(i_t);

extern datatype Typestruct.Struct struct_Absyn_Aggrdecl_rep;
static datatype Typestruct.ThinPtr aggrdecl_p = ThinPtr(1,(datatype Typestruct)&struct_Absyn_Aggrdecl_rep);
datatype Typestruct aggrdecl_rep = (datatype Typestruct)&aggrdecl_p;

extern datatype Typestruct.Struct struct_Absyn_Tuniondecl_rep;
static datatype Typestruct.ThinPtr tuniondecl_p = ThinPtr(1,(datatype Typestruct)&struct_Absyn_Tuniondecl_rep);
datatype Typestruct tuniondecl_rep = (datatype Typestruct)&tuniondecl_p;

extern datatype Typestruct.Struct struct_Absyn_Enumdecl_rep;
static datatype Typestruct.ThinPtr enumdecl_p = ThinPtr(1,(datatype Typestruct)&struct_Absyn_Enumdecl_rep);
datatype Typestruct enumdecl_rep = (datatype Typestruct)&enumdecl_p;

extern datatype Typestruct.Struct struct_Absyn_Typedefdecl_rep;
static datatype Typestruct.ThinPtr typedefdecl_p = ThinPtr(1,(datatype Typestruct)&struct_Absyn_Typedefdecl_rep);
datatype Typestruct typedefdecl_rep = (datatype Typestruct)&typedefdecl_p;

extern datatype Typestruct.Struct struct_Absyn_Vardecl_rep;
static datatype Typestruct.ThinPtr vardecl_p = ThinPtr(1,(datatype Typestruct)&struct_Absyn_Vardecl_rep);
datatype Typestruct vardecl_rep = (datatype Typestruct)&vardecl_p;

extern datatype Typestruct.Struct struct_Absyn_Tunionfield_rep;
static datatype Typestruct.ThinPtr tunionfield_p = ThinPtr(1,(datatype Typestruct)&struct_Absyn_Tunionfield_rep);
datatype Typestruct tunionfield_rep = (datatype Typestruct)&tunionfield_p;

namespace Interface {

#define MARSHALTYP(X,R)							\
static addr_index_t write_##X(addr_index_t env, FILE @fp, X decl) {	\
  return write_type_base(R,env,fp,decl);				\
}

MARSHALTYP(aggrdecl_t,aggrdecl_rep)
MARSHALTYP(tuniondecl_t,tuniondecl_rep)
MARSHALTYP(enumdecl_t,enumdecl_rep)
MARSHALTYP(typedefdecl_t,typedefdecl_rep)
MARSHALTYP(vardecl_t,vardecl_rep)
MARSHALTYP(tunionfield_t,tunionfield_rep)
  /* XXX need one for var_t's and for list_t<var_t>'s */

/* construct xtunionfielddecl marshaller by hand from its components since
   we can't do it automatically (due to parts of the rep structure being
   generated already by absyn.h) */
static addr_index_t write_xtunionfielddecl_t(addr_index_t env, FILE @fp,
					     xtunionfielddecl_t decl) {
  env = write_tuniondecl_t(env,fp,decl->base);
  env = write_tunionfield_t(env,fp,decl->field);
  return env;
}

  /* XXX need to create a function for ienv_t's */

// Mathieu : so far, there's nothing binary here, but let's pretend it is :-)
void save(i_t i, FILE @ f) {
  print(i, f);  
//    write_type(i_t_rep,f,i);
}

  /* XXX need to create the dual of all of the write functions above */

i_t load(FILE @ f) {
  return parse(f);
//    return read_type(i_t_rep, f);
}
}
