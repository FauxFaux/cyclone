/* Interface checking.
   Copyright (C) 2001 Greg Morrisett
   This file is part of the Cyclone compiler.

   The Cyclone compiler is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   The Cyclone compiler is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with the Cyclone compiler; see the file COPYING. If not,
   write to the Free Software Foundation, Inc., 59 Temple Place -
   Suite 330, Boston, MA 02111-1307, USA. */

#include "interface.h"

#include "absynpp.h"
#include <dict.h>
#include "tc.h"
#include "parse.h"
#include <pp.h>
#include <string.h>
#include "tcutil.h"
#include "tcdecl.h"
#include <position.h>

using Core;
using List;
using Absyn;
using Stdio;
using Tcenv;
using Absynpp;
using Tcutil;
using String;

namespace Lex {
  extern void lex_init();
}

namespace Interface;

/* ------ definition of an interface ------- */

typedef Tcdecl::xtunionfielddecl_t xtunionfielddecl_t;

// clone of Genv, but with only what we need
struct Ienv {
  Dict::dict_t<var_t,structdecl_t>  structdecls;
  Dict::dict_t<var_t,uniondecl_t>   uniondecls;
  Dict::dict_t<var_t,tuniondecl_t>  tuniondecls;
  Dict::dict_t<var_t,enumdecl_t>    enumdecls;
  Dict::dict_t<var_t,typedefdecl_t> typedefdecls;
  Dict::dict_t<var_t,vardecl_t>     vardecls;
  Dict::dict_t<var_t,xtunionfielddecl_t> xtunionfielddecls;
};

typedef struct Ienv @ienv_t;

// finally the definition of an interface
struct I {
  Dict::dict_t<list_t<var_t>,ienv_t> imports; // what is needed
  Dict::dict_t<list_t<var_t>,ienv_t> exports; // what is provided
};

static ienv_t new_ienv() {
  return new Ienv {
    .structdecls  = Dict::empty(String::zstrptrcmp),
    .uniondecls   = Dict::empty(String::zstrptrcmp),
    .tuniondecls  = Dict::empty(String::zstrptrcmp),
    .enumdecls    = Dict::empty(String::zstrptrcmp),
    .typedefdecls = Dict::empty(String::zstrptrcmp),
    .vardecls     = Dict::empty(String::zstrptrcmp),
    .xtunionfielddecls = Dict::empty(String::zstrptrcmp)
  };
}

static ienv_t lazy_new_ienv() {
  static struct Ienv * ie = NULL;
  if (ie == NULL) {
    ie = new_ienv();
  }
  return (ienv_t) ie;
}

static ienv_t skel2i_f(`a ignored) {
  return new_ienv();
}

static i_t skel2i(Dict::dict_t<list_t<var_t,`H>,`a,`H> skel) {
  return new I(Dict::map(skel2i_f, skel), Dict::map(skel2i_f, skel));
}

i_t empty() {
  return new I(Dict::empty(varlist_cmp), Dict::empty(varlist_cmp));
}

// dual of the initial environment defined in Tcenv::tc_init
// + requirement for a function main
i_t final() {
  let i = empty();
  // add definition of xtunion exn
  let ie1 = new_ienv();
  let exn_d = new *exn_tud;
  exn_d->sc = Public;
  ie1->tuniondecls = Dict::insert(ie1->tuniondecls, (*exn_name)[1], exn_d);
  let np_exn_f = new *null_pointer_exn_tuf;
  np_exn_f->sc = Public;
  let np_exn_fd = new Tcdecl::Xtunionfielddecl(exn_d, np_exn_f);
  ie1->xtunionfielddecls = Dict::insert(ie1->xtunionfielddecls, (*null_pointer_exn_name)[1], np_exn_fd);
  let m_exn_f = new *match_exn_tuf;
  m_exn_f->sc = Public;
  let m_exn_fd = new Tcdecl::Xtunionfielddecl(exn_d, m_exn_f);
  ie1->xtunionfielddecls = Dict::insert(ie1->xtunionfielddecls, (*match_exn_name)[1], m_exn_fd);
  i->exports = Dict::insert(i->exports, NULL, ie1);
  // add requirement of function main
  let ie2 = new_ienv();
  qvar_t qmain = new $(new Abs_n(NULL), new ((string_t)"main"));
  let vd = new_vardecl(qmain,
		       function_typ(NULL, NULL, sint_t,
				    new List(new $(NULL, empty_tqual(), uint_t),
					     new List(new $(NULL, empty_tqual(),
							    tagged_typ(tagged_typ(uchar_t,
										  HeapRgn,
										  empty_tqual()),
								       HeapRgn,
								       empty_tqual())),
						      NULL)),
				    false, NULL, NULL, NULL),
		       NULL);
  vd->sc = Extern;
  ie2->vardecls = Dict::insert(ie2->vardecls, (*qmain)[1], vd);
  i->imports = Dict::insert(i->exports, NULL, ie2);

  return i;
}

/* ********* invariants for interfaces ***********
 *
 * _ typedefs are stored in exports
 * _ possible scopes in exports are : Public (here structs are always complete)
 *   and Abstract (here structs are always incomplete)
 * _ possible scopes in imports are : Extern and ExternC
 * _ no var is initialized, there are no functions either (only prototypes)
 * _ all the qvars match the namespace they are in
 * _ a same object cannot be both in exports and in imports (except xtunions)
 * _ fields of xtunions are sorted by name
 *
 * ***********************************************/

/* ------ throwing an error ------ */

// note : we need to call reset_position(file_name) before all
static void err(string_t msg) {
  Tcutil::terr(NULL, msg);
}

#define invalid_arg(s) throw(new Core::InvalidArg(s))
//better than a function regarding to the control flow

static void fields_err(string_t sc, string_t t, qvar_t n) {
  err(aprintf("fields of %s %s %s have never been defined",
	      sc, t, Absynpp::qvar2string(n)));
}

static void body_err(string_t sc, qvar_t n) {
  err(aprintf("the body of %s function %s has never been defined",
	      sc, Absynpp::qvar2string(n)));
}

// don't print anything if obj1 == NULL
static void static_err(string_t obj1, qvar_t name1, string_t obj2, qvar_t name2) {
  if (obj1 != NULL) {
    err(aprintf("declaration of %s %s relies on static %s %s",
		obj1, Absynpp::qvar2string(name1), obj2, Absynpp::qvar2string(name2)));
  }
}

// id.
static void abstract_err(string_t obj1, qvar_t name1, string_t obj2, qvar_t name2) {
  if (obj1 != NULL) {
    err(aprintf("declaration of %s %s relies on fields of abstract %s %s",
		obj1, Absynpp::qvar2string(name1), obj2, Absynpp::qvar2string(name2)));
  }
}

/* ------ checking that a given type can be safely exported ----- */

/* --- to keep a track of already checked structures --- */
struct Seen {
  Dict::dict_t<qvar_t, bool> structs;
  Dict::dict_t<qvar_t, bool> unions;
  Dict::dict_t<qvar_t, bool> tunions;
};

typedef struct Seen @ seen_t;

static seen_t new_seen() {
  return new Seen(Dict::empty(qvar_cmp), Dict::empty(qvar_cmp), Dict::empty(qvar_cmp));
}

/* --- functions that actually perform the check --- */
typedef Dict::dict_t<list_t<var_t>, genv_t> aenv_t;

static bool check_public_type(aenv_t ae, seen_t seen, string_t obj, qvar_t name, type_t t);

static bool check_public_type_list(aenv_t ae, seen_t seen, string_t obj, qvar_t name,
			      type_t (@f)(`a), list_t<`a> l) {
  let res = true;
  for (; l != NULL; l = l->tl) {
    if (! check_public_type(ae, seen, obj, name, f(l->hd))) res = false;
  }
  return res;
}

static bool check_public_structdecl(aenv_t ae, seen_t seen, structdecl_t d) {
  try {
    return Dict::lookup(seen->structs, d->name->v);
  } catch {
  case Dict::Absent:
    let res = true;
    seen->structs = Dict::insert(seen->structs, d->name->v, res); // necessary for recursive datas
    if (d->fields != NULL)
      for(let fs = d->fields->v; fs != NULL; fs=fs->tl) {
	if (!check_public_type(ae, seen, "struct", d->name->v, fs->hd->type)) res = false;
      }

    seen->structs = Dict::insert(seen->structs, d->name->v, res); // save the result
    return res;
  }
}

static bool check_public_uniondecl(aenv_t ae, seen_t seen, uniondecl_t d) {
  try {
    return Dict::lookup(seen->unions, d->name->v);
  } catch {
  case Dict::Absent:
    let res = true;
    seen->unions = Dict::insert(seen->unions, d->name->v, res); // necessary for recursive datas
    if (d->fields != NULL)
      for(let fs = d->fields->v; fs != NULL; fs=fs->tl) {
	if (!check_public_type(ae, seen, "union", d->name->v, fs->hd->type)) res = false;
      }

    seen->unions = Dict::insert(seen->unions, d->name->v, res); // save the result
    return res;
  }
}

static type_t get_type1($(struct Absyn::Tqual,tunion Absyn::Type) @ x) {
  return (*x)[1];
}

static bool check_public_tuniondecl(aenv_t ae, seen_t seen, tuniondecl_t d) {
  try {
    return Dict::lookup(seen->tunions, d->name);
  } catch {
  case Dict::Absent:
    let res = true;
    seen->tunions = Dict::insert(seen->tunions, d->name, res); // necessary for recursive datas
    if (d->fields != NULL)
      for(let fs = d->fields->v; fs != NULL; fs=fs->tl) {
	if (!check_public_type_list(ae, seen, "[x]tunion", d->name,
				get_type1, fs->hd->typs)) res = false;
      }

    seen->tunions = Dict::insert(seen->tunions, d->name, res); // save the result
    return res;
  }
}

static bool check_public_enumdecl(aenv_t ae, seen_t seen, enumdecl_t d) {
  return true;
}

static bool check_public_typedefdecl(aenv_t ae, seen_t seen, typedefdecl_t d) {
  return check_public_type(ae, seen, NULL /*"typedef"*/, d->name, d->defn);
  // don't print an error message for typedefs (we'll just not export the typedef) 
}

static bool check_public_vardecl(aenv_t ae, seen_t seen, vardecl_t d) {
  return check_public_type(ae, seen, "variable", d->name, d->type);
}

static type_t get_type2($(opt_t<string_t @>, struct Tqual, type_t) @ x) {
  return (*x)[2];
}

static list_t<var_t> get_abs_ns(tunion Nmspace ns) {
  switch (ns) {
  case &Abs_n(l): return l;
  default: invalid_arg("get_abs_ns");
  }
}

static bool check_public_type(aenv_t ae, seen_t seen, string_t obj, qvar_t name, type_t t) {
  switch (compress(t)) {
  case &PointerType(PtrInfo(t,_,_,_,_)):
    return check_public_type(ae, seen, obj, name, t);

  case &ArrayType(t,_,_):
    return check_public_type(ae, seen, obj, name, t);

  case &TypedefType(_,_, &Opt(t)):
    return check_public_type(ae, seen, obj, name, t);

  case &FnType(FnInfo(_,_,ret,args,_,cyc_varargs,_,_)):
    bool b = check_public_type_list(ae, seen, obj, name, get_type2, args)
      && check_public_type(ae, seen, obj, name, ret);
    if (cyc_varargs != NULL) {
      let VarargInfo{_,_,vt,_,_} = *cyc_varargs;
      b = check_public_type(ae, seen, obj, name, vt);
    }
    return b;

  case &TupleType(lt):
    return check_public_type_list(ae, seen, obj, name, get_type1, lt);

  case &StructType(_,targs,&sd):
    if (sd->sc == Static) {
      static_err(obj, name, "struct", sd->name->v);
      return false;
    }
    return check_public_type_list(ae, seen, obj, name, identity, targs)
      && check_public_structdecl(ae, seen, sd);

  case &UnionType(_,targs,&ud):
    if (ud->sc == Static) {
      static_err(obj, name, "union", ud->name->v);
      return false;
    }
    return check_public_type_list(ae, seen, obj, name, identity, targs)
      && check_public_uniondecl(ae, seen, ud);

  case &EnumType(name, _):
    let &$(tns, v) = name;
    let ns = get_abs_ns(tns);
    enumdecl_t ed;
    try {
      let ge = Dict::lookup(ae, ns);
      ed = *Dict::lookup(ge->enumdecls, v);
    } catch {
    case Dict::Absent: invalid_arg(aprintf("check_public_type (can't find enum %s)",
					   qvar2string(name)));
    }
    if (ed->sc == Static) {
      static_err(obj, name, "enum", ed->name);
      return false;
    }
    return true /*check_public_enum(ae, seen, ed)*/;

  case &TunionType(TunionInfo(&KnownTunion(tud0),targs,_)):
    let &$(tns, v) = tud0->name;
    let ns = get_abs_ns(tns);
    tuniondecl_t tud;
    try {
      let ge = Dict::lookup(ae, ns);
      tud = *Dict::lookup(ge->tuniondecls, v);
    } catch {
    case Dict::Absent: invalid_arg(aprintf("check_public_type (can't find [x]tunion %s)",
					   qvar2string(tud0->name)));
    }
    if (tud->sc == Static) {
      static_err(obj, name, "[x]tunion", tud->name);
      return false;
    }
    return check_public_type_list(ae, seen, obj, name, identity, targs)
      && check_public_tuniondecl(ae, seen, tud);

  case &TunionFieldType(TunionFieldInfo{&KnownTunionfield(tud0,tuf0), targs}):
    let &$(tns, v) = tud0->name;
    let ns = get_abs_ns(tns);
    tuniondecl_t tud;
    try {
      let ge = Dict::lookup(ae, ns);
      tud = *Dict::lookup(ge->tuniondecls, v);
    } catch {
    case Dict::Absent:
      invalid_arg(aprintf("check_public_type (can't find [x]tunion %s and search its fields)",
			  qvar2string(tud0->name)));
    }
    if (tud->fields == NULL) invalid_arg(aprintf("check_public_type ([x]tunion %s has no fields)",
						 qvar2string(tud->name)));

    struct Tunionfield * tuf1 = NULL;
    for (let fs = tud->fields->v; fs != NULL; fs = fs->tl)
      if (strptrcmp((*tuf0->name)[1], (*fs->hd->name)[1]) == 0) {
	  tuf1 = fs->hd;
	  break;
	}
  
    if (tuf1 == NULL) invalid_arg(aprintf("check_public_type (can't find [x]tunionfield %s)",
					  qvar2string(tuf0->name)));
    tunionfield_t tuf = (tunionfield_t) tuf1;

    if (tud->sc == Static) {
      static_err(obj, name, "[x]tunion", tud->name);
      return false;
    }
    if (tud->sc == Abstract) {
      abstract_err(obj, name, "[x]tunion", tud->name);
      return false;
    }
    if (tuf->sc == Static) {
      static_err(obj, name, aprintf("field %s of", qvar2string(tuf->name)),tud->name);
      return false;
    }
    return check_public_type_list(ae, seen, obj, name, identity, targs)
      && check_public_tuniondecl(ae, seen, tud);

  default: return true;
  }
}

/* ------ extracting an interface from a global environment ------ */

// Mathieu : I know this is very ugly
// but sharing the same code using a function required too many closures
#define EXTRACT_DECL(OBJ, NAMEOPT)\
static void extract_##OBJ##decl($(ienv_t, ienv_t, bool, aenv_t, seen_t, i_t) @ `r env, var_t x, OBJ##decl_t@ dp) {\
  let &$(imp, exp, check_complete_defs, ae, seen, _) = env;\
  let d = *dp;\
\
  switch(d->sc) {\
  case Static:\
    if (check_complete_defs && d->fields == NULL) {\
      fields_err("static", #OBJ, d->name NAMEOPT);\
    }\
    break;\
  case Abstract:\
    if (d->fields == NULL) {\
      if (check_complete_defs) {\
	fields_err("abstract", #OBJ, d->name NAMEOPT);\
      }\
    } else {\
      d = new *d;\
      d->fields = NULL;\
    }\
    if (check_public_##OBJ##decl(ae, seen, d))\
      exp->OBJ##decls = Dict::insert(exp->OBJ##decls, x, d);\
    break;\
  case Public:\
    if (d->fields == NULL) {\
      fields_err("public", #OBJ, d->name NAMEOPT);\
      d = new *d;\
      d->sc = Abstract;\
    }\
    if (check_public_##OBJ##decl(ae, seen, d)) {\
      exp->OBJ##decls = Dict::insert(exp->OBJ##decls, x, d);\
    }\
    break;\
  case ExternC: fallthru;\
  case Extern:\
    if (check_public_##OBJ##decl(ae, seen, d)) {\
      imp->OBJ##decls = Dict::insert(imp->OBJ##decls, x, d);\
    }\
    break;\
  }\
}

EXTRACT_DECL(struct, -> v)

EXTRACT_DECL(union,->v)

EXTRACT_DECL(enum, )

static void
extract_xtunionfielddecl(i_t i, tuniondecl_t d, tunionfield_t f) {
  let ns = NULL;
  switch ((*(f->name))[0]) {
  case &Rel_n(l): fallthru(l);
  case &Abs_n(l): ns = l; break;
  default: break;
  }
  _ dict;
  switch (f->sc) {
  case Static: return;
  case Extern: dict = & i->imports; break;
  case Public: dict = & i->exports; break;
  default: invalid_arg("add_xtunionfielddecl");
  }

  ienv_t env;
  try {
    env = Dict::lookup(*dict, ns);
  } catch {
  case Dict::Absent:
    env = new_ienv();
    *dict = Dict::insert(*dict, ns, env);
    break;
  }
  env->xtunionfielddecls =
    Dict::insert(env->xtunionfielddecls, (*(f->name))[1] , new Tcdecl::Xtunionfielddecl(d, f));
}

static void extract_tuniondecl($(ienv_t, ienv_t, bool, aenv_t, seen_t, i_t) @ `r env, var_t x, tuniondecl_t@ dp) {
  let &$(imp, exp, check_complete_defs, ae, seen, i) = env;
  let d = *dp;

  switch(d->sc) {
  case Static:
    if (!d->is_xtunion && check_complete_defs && d->fields == NULL) {
      fields_err("static", "tunion", d->name);
    }
    break;
  case Abstract:
    if (d->fields == NULL) {
      if (!d->is_xtunion && check_complete_defs) {
	fields_err("abstract", "tunion", d->name);
      }
    } else {
      d = new *d;
      d->fields = NULL;
    }
    if (check_public_tuniondecl(ae, seen, d))
      exp->tuniondecls = Dict::insert(exp->tuniondecls, x, d);
    break;
  case Public:
    d = new *d;
    if (!d->is_xtunion && d->fields == NULL) {
      fields_err("public", "tunion", d->name);
      d->sc = Abstract;
    }
    if (check_public_tuniondecl(ae, seen, d)) {
      if (d->is_xtunion && d->fields != NULL) {
	let fields = d->fields->v;
	d->fields = NULL;
	for (let f = fields; f != NULL; f = f->tl) {
	  extract_xtunionfielddecl(i, d, f->hd);
	}
      }
      exp->tuniondecls = Dict::insert(exp->tuniondecls, x, d);
    }
    break;
  case ExternC: invalid_arg("extract_tuniondecl");
  case Extern:
    if (check_public_tuniondecl(ae, seen, d)) {
      if (d->is_xtunion && d->fields != NULL) {
	d = new *d;
	let fields = d->fields->v;
	d->fields = NULL;
	for (let f = fields; f != NULL; f = f->tl) {
	  extract_xtunionfielddecl(i, d, f->hd);
	}
      }
      imp->tuniondecls = Dict::insert(imp->tuniondecls, x, d);
    }
    break;
  }
}

static void extract_typedef($(ienv_t, ienv_t, bool, aenv_t, seen_t, i_t) @ `r env, var_t x, typedefdecl_t d) {
  let &$(_, exp, _, ae, seen, _) = env;
  if (check_public_typedefdecl(ae, seen, d))
    exp->typedefdecls = Dict::insert(exp->typedefdecls, x, d);
}

static void extract_ordinarie($(ienv_t, ienv_t, bool, aenv_t, seen_t, i_t) @ `r env,
			      var_t x, $(resolved_t,bool)@ v) {
  let &$(imp, exp, check_complete_defs, ae, seen, _) = env;
  let r = (* v)[0];
  
  switch(r) {
  case &VarRes(b):
    switch (b) {
    case &Funname_b(fd):
      let vd = new Vardecl{
	.sc = fd->sc,
	.name = fd->name,
	.tq = Tqual(false, false, false),
	.type = (fd->cached_typ)->v,
	.initializer = NULL,
	.rgn = NULL,
	.attributes = NULL
      };
      check_complete_defs = false; // the body of the function has been defined
      fallthru(vd);
    case &Global_b(d):
      if (d->initializer != NULL) {
	d = new *d;
	d->initializer = NULL; // drop the initializer
      }
      switch(d->sc) {
      case Static:
	if (check_complete_defs && Tcutil::is_function_type(d->type)) {
	  body_err("static", d->name);
	}
	break;
      case Abstract: invalid_arg("extract_ordinarie");
      case Public:
	if (check_complete_defs && Tcutil::is_function_type(d->type)) {
	  body_err("public", d->name);
	}
	if (check_public_vardecl(ae, seen, d))
	  exp->vardecls = Dict::insert(exp->vardecls, x, d);
	break;
      case ExternC: fallthru;
      case Extern:
	if (check_public_vardecl(ae, seen, d))
	  imp->vardecls = Dict::insert(imp->vardecls, x, d);
	break;
      }
      break;
    default: break;
    }
    break;
  default: break;
  }
}

static void extract_f($(i_t, bool, aenv_t, seen_t) @ `r env_f, list_t<var_t,`H> ns, genv_t ge) {
  let &$(i, check_complete_defs, ae, seen) = env_f;
  let env = $(Dict::lookup(i->imports, ns),
	      Dict::lookup(i->exports, ns),
	      check_complete_defs,
	      ae, seen,
	      i);
  Dict::iter_c(extract_structdecl, &env,  ge->structdecls);
  Dict::iter_c(extract_uniondecl,  &env,  ge->uniondecls);
  Dict::iter_c(extract_tuniondecl, &env,  ge->tuniondecls);
  Dict::iter_c(extract_enumdecl,   &env,  ge->enumdecls);
  Dict::iter_c(extract_typedef,    &env,  ge->typedefs);
  Dict::iter_c(extract_ordinarie,  &env,  ge->ordinaries);
}

static i_t gen_extract(Dict::dict_t<list_t<var_t,`H>, genv_t,`H> ae, bool check_complete_defs) {
  let env = $(skel2i(ae), check_complete_defs, ae, new_seen());
  Dict::iter_c(extract_f, &env, ae);
  return env[0];
}

i_t extract(Dict::dict_t<list_t<var_t,`H>, genv_t,`H> ae) {
  return gen_extract(ae, true);
}

/* ------- checking inclusion ------- */

inline static void check_err(string_t<`H> *msg1, string_t<`H> msg2) {
  Tcdecl::merr(NULL, msg1, msg2);
}

static void incl_dict_f($(bool,
			  Dict::dict_t<var_t, `a,`H>,
			  bool (@)(`a, `a, string_t<`H> *`H),
			  string_t<`H>,
			  string_t<`H> *`H) @ `r env,
			var_t x,
			`a y1) {
  let &$(*res, dic2, incl_f, t, msg) = env;
  try {
    let y2 = Dict::lookup(dic2, x);
    if (! incl_f(y1, y2, msg)) (*res) = false;
  } catch {
  case Dict::Absent:
    check_err(msg, aprintf("%s %s is missing", t, *x));
    *res = false;
    break;
  }
}

static bool incl_dict(Dict::dict_t<var_t, `a,`H> dic1,
		      Dict::dict_t<var_t, `a,`H> dic2,
		      bool (@incl_f)(`a, `a, string_t<`H> *`H),
		      string_t<`H> t,
		      string_t<`H> *`H msg) {
  let env = $(true, dic2, incl_f, t, msg);
  Dict::iter_c(incl_dict_f, &env, dic1);
  return env[0];
}

#define INCL_DECL(OBJ, TYPEOBJ, NAMEOPT) \
static bool incl_##OBJ##decl(OBJ##decl_t d0, OBJ##decl_t d1, string_t<`H> *`H msg) { \
  let d = Tcdecl::merge_##OBJ##decl(d0, d1, NULL, msg); \
  if (d == NULL) return false; \
  if (d0 != d) { \
    check_err(msg, aprintf("declaration of " TYPEOBJ " %s discloses too much information", \
			   qvar2string(d1 NAMEOPT))); \
    return false; \
  } \
  return true; \
}

INCL_DECL(struct, "struct", ->name->v)

INCL_DECL(union, "union", ->name->v)

INCL_DECL(tunion, "tunion", ->name)

INCL_DECL(enum, "enum", ->name)

INCL_DECL(var, "variable", ->name)

INCL_DECL(typedef, "typedef", ->name)

INCL_DECL(xtunionfield, "xtunionfield", ->field->name)

#define INCL_DICT(OBJ, NAMEOBJ)\
  incl_dict(ie1->OBJ##decls, ie2->OBJ##decls, incl_##OBJ##decl, NAMEOBJ, msg)

opt_t<Dict::dict_t<var_t, `a @>> compat_merge_dict(Dict::dict_t<var_t, `a @`H,`H> dic1,
						   Dict::dict_t<var_t, `a @`H,`H> dic2,
						   Dict::dict_t<var_t, `a @`H,`H> excl,
						   `a * (@merge_f)(`a @`H, `a @`H, Position::seg_t, string_t<`H> *`H),
						   string_t<`H> t,
						   string_t<`H> *`H msg);

static bool incl_ienv(ienv_t ie1, ienv_t ie2, string_t<`H> *`H msg) {
  let r1 = INCL_DICT(struct, "struct");
  let r2 = INCL_DICT(union, "union");
  let r3 = INCL_DICT(tunion, "tunion");
  let r4 = INCL_DICT(enum, "enum");
  /* special case for typedefs */
  let r5 = (compat_merge_dict(ie1->typedefdecls, ie2->typedefdecls,
			      Dict::empty(strptrcmp), Tcdecl::merge_typedefdecl,
			      "typedef", msg) != NULL);
  let r6 = INCL_DICT(var, "variable");
  let r7 = INCL_DICT(xtunionfield, "xtunionfield");
  return (r1 && r2 && r3 && r4 && r5 && r6 && r7);
}

static void incl_ns_f($(bool,
			Dict::dict_t<list_t<var_t,`H>,ienv_t,`H>,
			string_t<`H> *`H) @ `r env,
		      list_t<var_t,`H> ns,
		      ienv_t ie1) {
  let &$(*res, dic2, msg) = env;

  ienv_t ie2;

  try {
    ie2 = Dict::lookup(dic2, ns);
  } catch {
  case Dict::Absent:
    ie2 = lazy_new_ienv(); break; // it's OK to use lazy_new_ienv because everything's functional
  }

  if (! incl_ienv(ie1, ie2, msg)) *res = false;
}

static bool incl_ns(Dict::dict_t<list_t<var_t,`H>, ienv_t,`H> dic1,
		    Dict::dict_t<list_t<var_t,`H>, ienv_t,`H> dic2,
		    string_t<`H> *`H msg) {
  let env = $(true, dic2, msg);

  Dict::iter_c(incl_ns_f, &env, dic1);

  return (env[0]);
}

bool is_subinterface(i_t i1, i_t i2, $(string_t<`H>, string_t<`H>) * `r info) {
  try {
    let res = true;
    string_t * msg = NULL;
  
    if (info != NULL)
      msg = new ((string_t)aprintf("checking inclusion of %s exports into %s exports,", (*info)[0], (*info)[1]));
    if (!incl_ns(i1->exports, i2->exports, msg)) res = false;
    
    if (info != NULL)
      msg = new ((string_t)aprintf("checking inclusion of %s imports into %s imports,", (*info)[1], (*info)[0]));
    if (!incl_ns(i2->imports, i1->imports, msg)) res = false;
    
    return res;
  } catch {
  case Tcdecl::Incompatible: return false;
  }
}

/* ------- merging 2 interfaces -------- */

/* --- functions for compatible union (and compatible substraction) --- */

void compat_merge_dict_f($(bool,
			   Dict::dict_t<var_t, `a @`H,`H>,
			   Dict::dict_t<var_t, `a @`H,`H>,
			   Dict::dict_t<var_t, `a @`H,`H>,
			   `a * (@)(`a @`H, `a @`H, Position::seg_t, string_t<`H> *`H),
			   string_t<`H>, string_t<`H> *`H ) @ `r env,
			 var_t x, `a @`H y2) {
  let &$(*res, *res_dic, dic1, excl, merge_f, t, msg) = env;
  `a @ y;
  try {
    let y1 = Dict::lookup(dic1, x);
    
    // try to merge y1 and y2 into y
    let yt = merge_f(y1, y2, NULL, msg);
    if (!yt) {
      *res = false;
      return;
    }
    y = (`a @) yt;
  } catch {
  case Dict::Absent:
    y = y2;
    break;
  }
  
  try {
    let ye = Dict::lookup(excl, x);

    // check that y is included in ye
    // otherwise it means that we are trying to guess fields of an abstract structure
    let yt = merge_f(ye, y, NULL, msg);
    if (yt != ye) {
      if (yt) // if yt is NULL, the error came from the merging
	check_err(msg, aprintf("abstract %s %s is being imported as non-abstract",
			       t, *x));
      *res = false;
    }
  } catch {
  case Dict::Absent:
    if (*res) {
      *res_dic = Dict::insert(*res_dic, x, y);
    }
    break;
  }
}

opt_t<Dict::dict_t<var_t, `a @>> compat_merge_dict(Dict::dict_t<var_t, `a @`H,`H> dic1,
						   Dict::dict_t<var_t, `a @`H,`H> dic2,
						   Dict::dict_t<var_t, `a @`H,`H> excl,
						   `a * (@merge_f)(`a @`H, `a @`H, Position::seg_t, string_t<`H> *`H),
						   string_t<`H> t,
						   string_t<`H> *`H msg) {
  let env = $(true, dic1, dic1, excl, merge_f, t, msg);

  Dict::iter_c(compat_merge_dict_f, &env, dic2);

  if (env[0])
    return new Opt(env[1]);
  else
    return NULL;
}

#define COMPAT_MERGE_DICT(OBJ, NAME)\
  compat_merge_dict(ie1->OBJ##decls, ie2->OBJ##decls, \
		    iexcl->OBJ##decls, Tcdecl::merge_##OBJ##decl,\
		    NAME, msg)

struct Ienv * compat_merge_ienv(ienv_t ie1, ienv_t ie2, ienv_t iexcl, string_t<`H> *`H msg) {
  let r1 = COMPAT_MERGE_DICT(struct, "struct");
  let r2 = COMPAT_MERGE_DICT(union, "union");
  let r3 = COMPAT_MERGE_DICT(tunion, "tunion");
  let r4 = COMPAT_MERGE_DICT(enum, "enum");
  let r5 = COMPAT_MERGE_DICT(typedef, "typedef");
  let r6 = COMPAT_MERGE_DICT(var, "variable");
  let r7 = COMPAT_MERGE_DICT(xtunionfield, "xtunionfield");
  if (!r1 || !r2 || !r3 || !r4 || !r5 || !r6 || !r7)
    return NULL;
  else
    return new Ienv(r1->v, r2->v, r3->v, r4->v, r5->v, r6->v, r7->v);
}

void compat_merge_ns_f($(bool,
			 Dict::dict_t<list_t<var_t,`H>, ienv_t,`H>,
			 Dict::dict_t<list_t<var_t,`H>, ienv_t,`H>,
			 Dict::dict_t<list_t<var_t,`H>, ienv_t,`H>,
			 string_t<`H> *`H) @ `r env,
		       list_t<var_t,`H> ns, ienv_t ie2) {
  let &$(*res, *res_dic, dic1, excl, msg) = env;

  ienv_t ie1, iexcl;

  try {
    iexcl = Dict::lookup(excl, ns);
  } catch {
  case Dict::Absent:
    iexcl = lazy_new_ienv(); break; // it's OK to use lazy_new_ienv because everything's functional
  }

  try {
    ie1 = Dict::lookup(dic1, ns);
    let ie =  compat_merge_ienv(lazy_new_ienv(), ie1, iexcl, msg); //substract iexcl from ie1
    if (ie == NULL) {
      *res = false;
      return;
    }
    ie1 = (ienv_t) ie;
  } catch {
  case Dict::Absent:
    ie1 = lazy_new_ienv(); break;
  }

  let ie = compat_merge_ienv(ie1, ie2, iexcl, msg);

  if (ie == NULL) {
    *res = false;
  } else {
    if (*res) {
      *res_dic = Dict::insert(*res_dic, ns, (ienv_t) ie);
    }
  }
}

opt_t<Dict::dict_t<list_t<var_t>, ienv_t>> compat_merge_ns(Dict::dict_t<list_t<var_t,`H>, ienv_t,`H> dic1,
							   Dict::dict_t<list_t<var_t,`H>, ienv_t,`H> dic2,
							   Dict::dict_t<list_t<var_t,`H>, ienv_t,`H> excl,
							   string_t<`H> *`H msg) {
  Dict::dict_t<list_t<var_t,`H>, ienv_t, `H> d = Dict::empty(varlist_cmp);
  let env = $(true, d, dic1, excl, msg);

  Dict::iter_c(compat_merge_ns_f, &env, dic2);

  if (env[0])
    return new Opt(env[1]);
  else
    return NULL;
}

/* --- functions for disjoint union --- */
void disj_merge_dict_f($(bool, Dict::dict_t<var_t, `a, `H>,
			 Dict::dict_t<var_t, `a, `H>, string_t<`H>, string_t<`H> *`H) @ `r env,
		       var_t x, `a y) {
  let &$(*res, *res_dic, dic1, t, msg) = env;
  if (Dict::member(dic1, x)) {
    check_err(msg, aprintf("%s %s is exported more than once", t, *x));
    *res = false;
  } else {
    if (*res) *res_dic = Dict::insert(*res_dic, x, y);
  }
}

opt_t<Dict::dict_t<var_t, `a>> disj_merge_dict(Dict::dict_t<var_t, `a,`H> dic1,
					       Dict::dict_t<var_t, `a,`H> dic2,
					       string_t<`H> t, string_t<`H> *`H msg) {
  let env = $(true, dic1, dic1, t, msg);

  Dict::iter_c(disj_merge_dict_f, &env, dic2);

  if (env[0])
    return new Opt(env[1]);
  else
    return NULL;
}

struct Ienv * disj_merge_ienv(ienv_t ie1, ienv_t ie2, string_t<`H> *`H msg) {
  let r1 = disj_merge_dict(ie1->structdecls, ie2->structdecls, "struct", msg);
  let r2 = disj_merge_dict(ie1->uniondecls, ie2->uniondecls, "union", msg);
  let r3 = disj_merge_dict(ie1->tuniondecls, ie2->tuniondecls, "[x]tunion", msg);
  let r4 = disj_merge_dict(ie1->enumdecls, ie2->enumdecls, "enum", msg);
  /* special case for typedefs */
  let r5 = compat_merge_dict(ie1->typedefdecls, ie2->typedefdecls, Dict::empty(zstrptrcmp),
			     Tcdecl::merge_typedefdecl, "typedef", msg);
  let r6 = disj_merge_dict(ie1->vardecls, ie2->vardecls, "variable", msg);
  let r7 = disj_merge_dict(ie1->xtunionfielddecls, ie2->xtunionfielddecls, "xtunionfield", msg);

  if (!r1 || !r2 || !r3 || !r4 || !r5 || !r6 || !r7)
    return NULL;
  else
    return new Ienv(r1->v, r2->v, r3->v, r4->v, r5->v, r6->v, r7->v);
}

void disj_merge_ns_f($(bool, Dict::dict_t<list_t<var_t,`H>, ienv_t,`H>,
		       Dict::dict_t<list_t<var_t,`H>, ienv_t,`H>, string_t<`H> *`H) @ `r env,
		     list_t<var_t,`H> ns, ienv_t ie2) {
  let &$(*res, *res_dic, dic1, msg) = env;

  ienv_t ie1;

  try {
    ie1 = Dict::lookup(dic1, ns);
  } catch {
  case Dict::Absent:
    ie1 = lazy_new_ienv(); break;
  }

  let ie = disj_merge_ienv(ie1, ie2, msg);

  if (ie == NULL) {
    *res = false;
  } else {
    if (*res) {
      *res_dic = Dict::insert(*res_dic, ns, (ienv_t) ie);
    }
  }
}

opt_t<Dict::dict_t<list_t<var_t>, ienv_t>> disj_merge_ns(Dict::dict_t<list_t<var_t,`H>, ienv_t,`H> dic1,
							 Dict::dict_t<list_t<var_t,`H>, ienv_t,`H> dic2,
							 string_t<`H> *`H msg) {
  let env = $(true, dic1, dic1, msg);

  Dict::iter_c(disj_merge_ns_f, &env, dic2);

  if (env[0])
    return new Opt(env[1]);
  else
    return NULL;
}

/* --- main function --- */
struct I * merge(i_t i1, i_t i2, $(string_t<`H>, string_t<`H>) * `r info) {
  try {
    string_t * msg = NULL;

    if (info != NULL)
      msg = new ((string_t)aprintf("merging exports of %s and %s,", (*info)[0], (*info)[1]));

    let exp = disj_merge_ns(i1->exports, i2->exports, msg);
    if (exp == NULL) return NULL;

    if (info != NULL)
      msg = new ((string_t)aprintf("merging imports of %s and %s,", (*info)[0], (*info)[1]));

    let imp = compat_merge_ns(i1->imports, i2->imports, exp->v, msg);
    if (imp == NULL) return NULL;

    return new I(imp->v, exp->v);
  } catch {
  case Tcdecl::Incompatible: return NULL;
  }
}

struct I * merge_list(list_t<i_t,`H> li, list_t<string_t<`H> @`H,`H> linfo) {
  if (li == NULL) return empty();

  i_t curr_i = li->hd;
  string_t * curr_info = (linfo != NULL ? (string_t *)linfo->hd : NULL);
  li=li->tl;
  if (linfo != NULL) linfo=linfo->tl;

  for (; li != NULL; li=li->tl) {
    let i = merge(curr_i, li->hd,
		  (curr_info != NULL && linfo != NULL ? new $(*curr_info, *linfo->hd) : NULL) );
    if (i == NULL) return NULL;
    curr_i = (i_t) i;
    if (curr_info != NULL) {
      curr_info = (linfo != NULL ? new ((string_t)aprintf("%s+%s", *curr_info, *linfo->hd)) : NULL);
    }
    if (linfo != NULL) linfo = linfo->tl;
  }
  return curr_i;
}

struct I * get_and_merge_list(i_t (@get)(`a), list_t<`a,`H> la, list_t<string_t<`H> @`H,`H> linfo) {
  if (la == NULL) return empty();

  i_t curr_i = get(la->hd);
  string_t * curr_info = (linfo != NULL ? (string_t *)linfo->hd : NULL);
  la=la->tl;
  if (linfo != NULL) linfo=linfo->tl;

  for (; la != NULL; la=la->tl) {
    let i = merge(curr_i, get(la->hd),
		  (curr_info != NULL && linfo != NULL ? new $(*curr_info, *linfo->hd) : NULL) );
    if (i == NULL) return NULL;
    curr_i = (i_t) i;
    if (curr_info != NULL) {
      curr_info = (linfo != NULL ? new ((string_t)aprintf("%s+%s", *curr_info, *linfo->hd)) : NULL);
    }
    if (linfo != NULL) linfo = linfo->tl;
  }
  return curr_i;
}

/* ------- printing an interface ------ */

static list_t<decl_t> add_namespace(list_t<decl_t,`H> tds, list_t<var_t,`H> ns) {
  if (ns == NULL) return tds;
  return new List(new_decl(new Namespace_d(ns->hd, add_namespace(tds, ns->tl)),NULL), NULL);
}

static list_t<decl_t> add_structdecl(var_t x, structdecl_t d, list_t<decl_t,`H> tds) {
  return new List(new_decl(new Struct_d(d), NULL),tds);
}

static list_t<decl_t> add_structdecl_header(var_t x, structdecl_t d, list_t<decl_t,`H> tds) {
  d = new *d;
  d->fields = NULL;
  if (d->sc != ExternC) d->sc = Extern;
  return new List(new_decl(new Struct_d(d), NULL),tds);
}

static list_t<decl_t> add_uniondecl(var_t x, uniondecl_t d, list_t<decl_t,`H> tds) {
  return new List(new_decl(new Union_d(d), NULL),tds);
}

static list_t<decl_t> add_uniondecl_header(var_t x, uniondecl_t d, list_t<decl_t,`H> tds) {
  d = new *d;
  d->fields = NULL;
  if (d->sc != ExternC) d->sc = Extern;
  return new List(new_decl(new Union_d(d), NULL),tds);
}

static list_t<decl_t> add_tuniondecl(var_t x, tuniondecl_t d, list_t<decl_t,`H> tds) {
  return new List(new_decl(new Tunion_d(d), NULL),tds);
}

static string_t us = "_";
static stringptr_t us_p = &us;

static $(tqual_t,type_t)@ rewrite_tunionfield_type($(tqual_t,type_t)@`H x) {
  return new $(empty_tqual(),
	       new VarType(new Tvar(us_p, NULL, new_conref(BoxKind)))
	       );
}

static tunionfield_t rewrite_tunionfield(tunionfield_t f) {
  f = new *f;
  f->typs = map(rewrite_tunionfield_type, f->typs);
  return f;
}

static list_t<decl_t> add_tuniondecl_header(var_t x, tuniondecl_t d, list_t<decl_t,`H> tds) {
  d = new *d;
  //d->fields = NULL;
  if (d->fields != NULL) d->fields = new Opt(map(rewrite_tunionfield, d->fields->v));
  if (d->sc != ExternC) d->sc = Extern;
  return new List(new_decl(new Tunion_d(d), NULL),tds);
}

static list_t<decl_t> add_enumdecl(var_t x, enumdecl_t d, list_t<decl_t,`H> tds) {
  return new List(new_decl(new Enum_d(d), NULL),tds);
}

static list_t<decl_t> add_enumdecl_header(var_t x, enumdecl_t d, list_t<decl_t,`H> tds) {
  d = new *d;
  d->fields = NULL;
  if (d->sc != ExternC) d->sc = Extern;
  return new List(new_decl(new Enum_d(d), NULL),tds);
}

static list_t<decl_t> add_typedef(var_t x, typedefdecl_t d, list_t<decl_t,`H> tds) {
  return new List(new_decl(new Typedef_d(d), NULL),tds);
}

static list_t<decl_t> add_vardecl(var_t x, vardecl_t d, list_t<decl_t,`H> tds) {
  return new List(new_decl(new Var_d(d), NULL),tds);
}

static list_t<decl_t> add_xtunionfielddecl(var_t x, xtunionfielddecl_t d, list_t<decl_t,`H> tds) {
  let &Tcdecl::Xtunionfielddecl(b,f)=d;
  b = new *b;
  b->fields = new Opt(new List(f,NULL));
  b->sc = Extern;
  return new List(new_decl(new Tunion_d(b), NULL),tds);
}

static list_t<decl_t> add_xtunionfielddecl_header(var_t x, xtunionfielddecl_t d, list_t<decl_t,`H> tds) {
  let &Tcdecl::Xtunionfielddecl(b,f)=d;
  b = new *b;
  f = rewrite_tunionfield(f);
  f->sc = Extern;
  b->fields = new Opt(new List(f,NULL));
  b->sc = Extern;
  return new List(new_decl(new Tunion_d(b), NULL),tds);
}

static void print_ns_headers(FILE @`H f, list_t<var_t,`H> ns, ienv_t ie) {
  let tds = NULL;

  tds = Dict::fold(add_structdecl_header,  ie->structdecls,  tds);
  tds = Dict::fold(add_uniondecl_header,   ie->uniondecls,   tds);
  tds = Dict::fold(add_tuniondecl_header,  ie->tuniondecls,  tds);
  tds = Dict::fold(add_enumdecl_header,    ie->enumdecls,    tds);

  if (tds != NULL) {
    tds = imp_rev(tds);

    tds = add_namespace(tds, ns);

    Absynpp::decllist2file(tds, f);
  }
}

static void print_ns_xtunionfielddecl_headers(FILE @`H f, list_t<var_t,`H> ns, ienv_t ie) {
  let tds = NULL;

  tds = Dict::fold(add_xtunionfielddecl_header, ie->xtunionfielddecls, tds);

  if (tds != NULL) {
    tds = imp_rev(tds);

    tds = add_namespace(tds, ns);

    Absynpp::decllist2file(tds, f);
  }
}

static void print_ns_typedefs(FILE @`H f, list_t<var_t,`H> ns, ienv_t ie) {
  let tds = NULL;

  tds = Dict::fold(add_typedef, ie->typedefdecls, tds);

  if (tds != NULL) {
    tds = imp_rev(tds);

    tds = add_namespace(tds, ns);

    Absynpp::decllist2file(tds, f);
  }
}

static void print_ns_decls(FILE @`H f, list_t<var_t,`H> ns, ienv_t ie) {
  let tds = NULL;

  tds = Dict::fold(add_structdecl,  ie->structdecls,  tds);
  tds = Dict::fold(add_uniondecl,   ie->uniondecls,   tds);
  tds = Dict::fold(add_tuniondecl,  ie->tuniondecls,  tds);
  tds = Dict::fold(add_enumdecl,    ie->enumdecls,    tds);
  tds = Dict::fold(add_vardecl,     ie->vardecls,     tds);
  tds = Dict::fold(add_xtunionfielddecl, ie->xtunionfielddecls, tds);

  if (tds != NULL) {
    tds = imp_rev(tds);

    tds = add_namespace(tds, ns);

    Absynpp::decllist2file(tds, f);
  }
}

// everything is extremely verbose
// but there's no other solution as long as we have to
// declare structures before using them
void print(i_t i, FILE @`H f) {
  Absynpp::set_params(&Absynpp::cyci_params_r);
  fprintf(f,   "/****** needed (headers) ******/\n");
  Dict::iter_c(print_ns_headers, f, i->imports);

  fprintf(f, "\n/****** provided (headers) ******/\n");
  Dict::iter_c(print_ns_headers, f, i->exports);

  // we have to handle xtunionfields separately because they can be in a different
  // namespace from their corresponding xtuniondecls
  fprintf(f,   "/****** needed (headers of xtunionfielddecls) ******/\n");
  Dict::iter_c(print_ns_xtunionfielddecl_headers, f, i->imports);

  fprintf(f, "\n/****** provided (headers of xtunionfielddecls) ******/\n");
  Dict::iter_c(print_ns_xtunionfielddecl_headers, f, i->exports);

  //typedefs are always public...
  fprintf(f, "\n/****** provided (typedefs) ******/\n");
  Dict::iter_c(print_ns_typedefs, f, i->exports);

  fprintf(f, "\n/****** needed (declarations) ******/\n");
  Dict::iter_c(print_ns_decls, f, i->imports);

  fprintf(f, "\n/****** provided (declarations) ******/\n");
  Dict::iter_c(print_ns_decls, f, i->exports);
}

/* ------ parsing a text file ------ */

i_t parse(FILE @`H f) { // warning : Position::reset_position must be called before using parse
  Lex::lex_init();
  let tds = Parse::parse_file(f);

  let te = Tcenv::tc_init();
  Tc::tc(te, false, tds); // no "Cyc" prefix, no default initializer 

  return gen_extract(te->ae, false); // don't check that definitions are complete
}

/* ------ binary loading and saving ------ */

// Mathieu : so far, there's nothing binary here
// but let's pretend it is :-)
void save(i_t i, FILE @`H f) {
  print(i, f);  
}

i_t load(FILE @`H f) {
  return parse(f);
}

