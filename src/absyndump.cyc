/* Ugly printer for the abstract syntax.
   Copyright (C) 2001 Dan Grossman, Greg Morrisett, AT&T
   This file is part of the Cyclone compiler.

   The Cyclone compiler is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   The Cyclone compiler is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with the Cyclone compiler; see the file COPYING. If not,
   write to the Free Software Foundation, Inc., 59 Temple Place -
   Suite 330, Boston, MA 02111-1307, USA. */

// Note that since we don't have an indent program for Cyclone, using this
// module for non-C code gives you fairly worthless stuff.  (And it hasn't
// been tested.) 

#include <core.h>
#include <cycboot.h>
#include <list.h>
#include <string.h>
#include "absyn.h"
#include "absynpp.h"
#include "evexp.h"
#include "tcutil.h"
#include "cyclone.h"

namespace Lex {
  extern $(const char ?, unsigned int) xlate_pos(Position::seg_t);
}

using Cyclone;
using Core;
using List;
using Absyn;

namespace Absyndump;

// Flag controlling whether typedefs are expanded during printing
static bool expand_typedefs;

// Flag controlling how to print identifiers (better performance (???) than
// re-writing them all in Toc).
static bool qvar_to_Cids;

// Flag controlling whether to add the cyc prefix to the C-identifiers
static bool add_cyc_prefix;

// Flag controlling whether debugging #lines are produced.
static bool generate_line_directives;

// Flag controlling whether the (C) output should be for VC instead of gcc.
// (Differences: long long vs. __int64 and inline vs. __inline)
static bool to_VC;

void set_params(struct Absynpp::Params @ fs) {
  expand_typedefs = fs->expand_typedefs;
  qvar_to_Cids = fs->qvar_to_Cids;
  add_cyc_prefix = fs->add_cyc_prefix;
  to_VC = fs->to_VC;
  generate_line_directives = fs->generate_line_directives;
  //decls_first = fs->decls_first;
  //rewrite_temp_tvars = fs->rewrite_temp_tvars;
  //print_all_tvars = fs->print_all_tvars;
  //print_all_kinds = fs->print_all_kinds;
  //print_using_stmts = fs->print_using_stmts;
  //print_externC_stmts = fs->print_externC_stmts;
  //print_full_evars = fs->print_full_evars;

  // since absyndump uses absynpp, we must set the parameters of absynpp too !!!
  Absynpp::set_params(fs);
}

void dumptyp(type_t);
void dumpntyp(type_t t);
void dumpexp(exp_t);
void dumpexp_prec(int,exp_t);
void dumppat(pat_t);
void dumpstmt(stmt_t,bool expstmt);
void dumpvardecl(vardecl_t,Position::seg_t,bool do_semi);
void dumpdecl(decl_t);
void dumptms(bool is_char_ptr, list_t<type_modifier_t> tms, void f(`a), `a a);
void dumptqtd(tqual_t, type_t, void f(`a), `a);
void dumpaggrfields(list_t<aggrfield_t> fields);
void dumpenumfields(list_t<enumfield_t> fields);
// really want to change this to char[] (need a control character for format
// prims and the ability to cast to untagged (from Tagged requires Toc hlep,
// from Fixed requires trivial Toc help)
typedef string_t<`r> dump_string_t<`r>;
void dumploc(Position::seg_t); // dumps a #line directive

// set by dumpdecllist2file (this module is not re-entrant)
FILE @@ dump_file = &stdout; 

void ignore(`a x) { return; }

static unsigned int pos = 0;
static char prev_char = 'x';

bool need_space_before() {
  switch(prev_char) {
  case '{':
  case '}':
  case '(':
  case ')':
  case '[':
  case ']':
  case ';':
  case ',':
  case '=':
  case '?':
  case '!':
  case ' ':
  case '\n':
  case '*': return false;
  default: return true;
  }
}

void dump(dump_string_t s) {
  unsigned int sz = strlen(s);
  // pos += sz;
  /* if (pos > 80) {
    pos = sz;
    fputc('\n',*dump_file);
    } else */
  if(need_space_before())
    fputc(' ',*dump_file);
  if(sz >= 1) {
    prev_char = s[sz-1];
    file_string_write(*dump_file, s, 0, sz);
  }
}

void dump_nospace(dump_string_t s) {
  int sz = strlen(s);
  // pos += sz;
  if(sz >= 1) {
    file_string_write(*dump_file, s, 0, sz);
    prev_char = s[sz-1];
  }
}
void dump_char(int c) { // no space
  // ++pos;
  fputc(c,*dump_file);
  prev_char = (char)c;
}

void dumploc(Position::seg_t loc) {
  static const char ?last_file = "";
  static unsigned last_line = 0;
  if(loc == 0) return;
  if(!generate_line_directives) return;
  //let s = Position::get_line_directive(loc);
  let $(f,d) = Lex::xlate_pos(loc);
  if (f == NULL || ((f == last_file) && (d == last_line))) return;
  if (f == last_file && d == last_line + 1)
    fprintf(*dump_file,"\n");
  else if (f == last_file)
    fprintf(*dump_file,"\n# %d\n",d);
  else 
    fprintf(*dump_file,"\n# %d %s\n",d,f);
  // pos = 1;
  last_file = f;
  last_line = d;
  // dump(s);
}

// this needs to take a boxed type b/c it's used to instantiate `a
void dump_str(stringptr_t s) {
  dump(*s);
}

void dump_semi() {
  dump_char(';');
}

void dump_sep(void f(`a), list_t<`a> l, dump_string_t sep) {
  if(l == NULL)
    return;
  for(; l->tl != NULL; l = l->tl) {
    f(l->hd);
    dump_nospace(sep); 
  }
  f(l->hd);
}
void dump_sep_c(void f(`b,`a), `b env, list_t<`a> l, dump_string_t sep) {
  if(l == NULL)
    return;
  for(; l->tl != NULL; l = l->tl) {
    f(env,l->hd);
    dump_nospace(sep); 
  }
  f(env,l->hd);
}
void group(void f(`a), list_t<`a> l,
           dump_string_t start, dump_string_t end, dump_string_t sep) {
  dump_nospace(start);
  dump_sep(f,l,sep);
  dump_nospace(end);
}
void group_c(void f(`b,`a), `b env, list_t<`a> l,
             dump_string_t start, dump_string_t end, dump_string_t sep) {
  dump_nospace(start);
  dump_sep_c(f,env,l,sep);
  dump_nospace(end);
}
void egroup(void f(`a), list_t<`a> l,
            dump_string_t start, dump_string_t end, dump_string_t sep) {
  if(l != NULL)
    group(f,l,start,end,sep);
}

// is this backwards for nested namespaces? Consistent either way, but
// should do the right thing!
void dumpqvar(qvar_t v) {
  let nsl = NULL;
  stringptr_t *prefix = NULL;
  switch ((*v)[0]) {
  case {.Loc_n = _}: fallthru(NULL);
  case {.Rel_n = x}:
    nsl = x;
    break;
  case {.C_n = x}:
    // No namespaces included in the C namespace.  
    // We need a separator space here, because the rest of the name is 
    // printed without spaces!
    dump_char(' ');
    break;
  case {.Abs_n = x}:
    if (qvar_to_Cids || add_cyc_prefix) 
      prefix = &Absynpp::cyc_stringptr;
    nsl = x;
    break;
  }
  if (prefix != NULL) {
    dump_str(*prefix);
    if(qvar_to_Cids) dump_char('_');
    else dump_nospace("::");
  }
  if (nsl != NULL) {
    dump_nospace(*(nsl->hd));
    for(nsl = nsl->tl; nsl != NULL; nsl = nsl->tl) {
      // Note: This is the most common reason the result goes over 80 columns,
      //       but who really cares.
      if(qvar_to_Cids) dump_char('_');
      else dump_nospace("::");
      dump_nospace(*(nsl->hd));
    }
    if(qvar_to_Cids) dump_nospace("_");
    else dump_nospace("::");
    dump_nospace(*((*v)[1]));
  } else {
    if (prefix != NULL)
      dump_nospace(*((*v)[1]));
    else 
      dump_str((*v)[1]);
  }
}

void dumptq(tqual_t tq) {
  if(tq.q_restrict)  dump("restrict");
  if(tq.q_volatile)  dump("volatile");
  if(tq.print_const) dump("const");
}

void dumpscope(scope_t sc) {
  switch (sc) {
  case Static:   dump("static"); return;
  case Public:   return;
  case Extern:   dump("extern"); return;
  case ExternC:  dump("extern \"C\""); return;
  case Abstract: dump("abstract"); return;
  case Register: dump("register"); return;
  }
}

void dumpkind(kind_t ka) {
  let &Kind(k,a) = ka;
  switch (k) {
  case AnyKind:
    switch (a) {
    case Aliasable: dump("A"); return;
    case Unique: dump("UA"); return;
    case Top: dump("TA"); return;
    }
  case MemKind:
    switch (a) {
    case Aliasable: dump("M"); return;
    case Unique: dump("UM"); return;
    case Top: dump("TM"); return;
    }
  case BoxKind:
    switch (a) {
    case Aliasable: dump("B"); return;
    case Unique: dump("UB"); return;
    case Top: dump("TB"); return;
    }
  case RgnKind: 
    switch (a) {
    case Aliasable: dump("R"); return;
    case Unique: dump("UR"); return;
    case Top: dump("TR"); return;
    }
  case EffKind: dump("E"); return;
  case IntKind: dump("I"); return;
  }
}

void dumpaggr_kind(aggr_kind_t k) {
  switch(k) {
  case StructA: dump("struct "); return;
  case UnionA:  dump("union ");  return;
  }
}

void dumptps(list_t<type_t> ts) {
  egroup(dumptyp,ts,"<",">",",");
}
void dumptvar(tvar_t tv) {
  const char ?n = *tv->name;
  if (n[0] == '#') {
    dump("`G");
    switch (compress_kb(tv->kind)) {
    case &Eq_kb(k): fallthru(k);
    case &Less_kb(_,k): dumpkind(k); break;
    default: dump_nospace("K"); break;
    }
    dump_nospace(n+1);
  } else 
    dump(n);
}
void dumpkindedtvar(tvar_t tv) {
  dumptvar(tv);
  switch (compress_kb(tv->kind)) {
  case &Unknown_kb(_): break;
  case &Less_kb(_,k): break;
  case &Eq_kb(&Kind(BoxKind,Aliasable)): break;
  case &Eq_kb(k): dump("::"); dumpkind(k); break;
  }
}
void dumptvars(list_t<tvar_t> tvs) {
  egroup(dumptvar,tvs,"<",">",",");
}
void dumpkindedtvars(list_t<tvar_t> tvs) {
  egroup(dumpkindedtvar,tvs,"<",">",",");
}

void dumparg($(tqual_t,type_t)@ pr) {
  dumptqtd((*pr)[0],(*pr)[1],ignore,0);
}
void dumpargs(list_t<$(tqual_t,type_t)@> ts) {
  group(dumparg,ts,"(",")",",");
}

void dump_callconv(attributes_t atts) {
  for(; atts != NULL; atts = atts->tl)
    switch(atts->hd) {
    case &Stdcall_att:  dump("_stdcall");  return;
    case &Cdecl_att:    dump("_cdecl");    return;
    case &Fastcall_att: dump("_fastcall"); return;
    default: break;
    }
}

void dump_noncallconv(attributes_t atts) {
  // NOTE: Only for to_VC.  Ignore a calling-convention attribute.
  bool hasatt = false;
  for(_ atts2 = atts; atts2 != NULL; atts2 = atts2->tl)
    switch(atts->hd) {
    case &Stdcall_att:  
    case &Cdecl_att:    
    case &Fastcall_att: break;
    default: hasatt = true; break;
    }
  if(!hasatt)
    return;
  dump("__declspec(");
  for (; atts != NULL; atts = atts->tl)
    switch(atts->hd) {
    case &Stdcall_att:  
    case &Cdecl_att:    
    case &Fastcall_att: break;
    default: dump(attribute2string(atts->hd)); break;
    }
  dump_char(')');
}

void dumpatts(attributes_t atts) {
  if (atts == NULL) return;
  switch(c_compiler){
  case Gcc_c:
    dump(" __attribute__((");
    for (; atts != NULL; atts = atts->tl) {
      dump(attribute2string(atts->hd));
      if (atts->tl != NULL) dump(",");
    }
    dump(")) ");
    return;
  case Vc_c:
    dump_noncallconv(atts);
    return;
  }
}

bool next_is_pointer(list_t<type_modifier_t> tms) {
  if (tms==NULL) return false;
  switch (tms->hd) {
  case &Pointer_mod(_,_): return true;
  default: return false;
  }
}

static void dumprgn(type_t t) {
  switch (Tcutil::compress(t)) {
  case &HeapRgn: dump("`H"); break;
  default: dumpntyp(t); break;
  }
}

static $(list_t<type_t>, list_t<type_t>) effects_split(type_t t) {
  list_t<type_t> rgions = NULL;
  list_t<type_t> effects = NULL;

  switch (Tcutil::compress(t)) {
  case &AccessEff(r): rgions = new List(r,rgions); break;
  case &JoinEff(ts):
    for (; ts != NULL; ts = ts->tl) {
      let $(rs,es) = effects_split(ts->hd);
      rgions = List::imp_append(rs,rgions);
      effects = List::imp_append(es,effects);
    }
    break;
  default: effects = new List(t,effects); break;
  }
  return $(rgions, effects);
}

static void dumpeff(type_t t) {
  let $(rgions,effects) = effects_split(t);
  rgions = List::imp_rev(rgions);
  effects = List::imp_rev(effects);
  if (effects != NULL) {
    for (let e=effects; e != NULL; e = e->tl) {
      dumpntyp(e->hd);
      if (e->tl != NULL)
        dump_char('+');
    }
    if (rgions != NULL) dump_char('+');
  }
  if (rgions != NULL || effects == NULL) {
    dump_char('{');
    for (; rgions != NULL; rgions = rgions->tl) {
      dumprgn(rgions->hd);
      if (rgions->tl != NULL) dump_char(',');
    }
    dump_char('}');
  }
}

static void dump_aggrdecl(aggrdecl_t);
static void dump_enumdecl(enumdecl_t);
static void dump_datatypedecl(datatypedecl_t);

// Convert a normalized typ to a doc
void dumpntyp(type_t t) {
  switch (t) {
    // The first three cases never turn up in normalized types.
  case &ArrayType(_): 
  case &FnType(_): 
  case &PointerType(_): return;
  case &VoidType: dump("void"); return;
  case &VarType(tv): dumptvar(tv); return; // FIX: may want explicit kinds
  case &Evar(k,NULL,i,_): 
    dump("`E"); 
    if (k == NULL) dump("K"); else dumpkind(k->v); 
    dump(aprintf("%d",i)); return;
  case &Evar(k,t,i,_): dumpntyp((type_t)t); return; // shouldn't happen!
  case &DatatypeType(DatatypeInfo(tu_info,ts)):
    switch(tu_info) {
    case {.UnknownDatatype = UnknownDatatypeInfo(n,is_x)}: fallthru(n,is_x);
    case {.KnownDatatype = & &Datatypedecl(_,n,_,_,is_x)}:
      if(is_x) dump("@extensible "); 
      dump("datatype ");
      dumpqvar(n);
      dumptps(ts);
      break;
    }
    break;
  case &DatatypeFieldType(DatatypeFieldInfo(tuf_info,ts)):
    switch(tuf_info) {
    case {.UnknownDatatypefield = UnknownDatatypeFieldInfo(tname,fname,is_x)}:
      fallthru(tname,is_x,fname);
    case {.KnownDatatypefield = $(&Datatypedecl(_,tname,_,_,is_x),
                                  &Datatypefield(fname,_,_,_))}:
      if(is_x) dump("@extensible ");
      dump("datatype ");                            
      dumpqvar(tname);
      dump(".");
      dumpqvar(fname);
      dumptps(ts);
      break;
    }
    break;
  case &IntType(None,   Int_sz):
  case &IntType(Signed, Int_sz): dump("int"); return;
  case &IntType(None,   Long_sz):
  case &IntType(Signed, Long_sz): dump("long"); return;
  case &IntType(None,   Char_sz): dump("char"); return;
  case &IntType(Signed, Char_sz): dump("signed char"); return;
  case &IntType(Unsigned, Char_sz): dump("unsigned char"); return;
  case &IntType(None,   Short_sz):
  case &IntType(Signed, Short_sz): dump("short"); return;
  case &IntType(Unsigned, Short_sz): dump("unsigned short"); return;
  case &IntType(Unsigned, Int_sz): dump("unsigned int"); return;
  case &IntType(Unsigned, Long_sz): dump("unsigned long"); return;
  case &IntType(None, LongLong_sz):
  case &IntType(Signed, LongLong_sz): 
    switch(c_compiler){
    case Gcc_c: dump("long long"); return;
    case Vc_c: dump("__int64"); return;
    }
  case &IntType(Unsigned, LongLong_sz): 
    switch(c_compiler){
    case Vc_c:  dump("unsigned __int64");return;
    case Gcc_c: dump("unsigned long long"); return;
    }
  case &FloatType(i): 
    if (i==0) 
      dump("float"); 
    else if (i==1) 
      dump("double");
    else 
      dump("long double"); 
    return;
  case &TupleType(ts): dump_char('$'); dumpargs(ts); return;
  case &AggrType(AggrInfo(info,ts)):
    let $(k,n) = aggr_kinded_name(info);
    dumpaggr_kind(k); dumpqvar(n); dumptps(ts); 
    return;
  case &AnonAggrType(k,fs):
    dumpaggr_kind(k); dump_char('{'); dumpaggrfields(fs); dump_char('}');return;
  case &EnumType(n,_):    dump("enum "); dumpqvar(n); return;
  case &AnonEnumType(fs): dump("enum {"); dumpenumfields(fs); dump("}"); return;
  case &TypedefType(n,ts,_,_):  dumpqvar(n), dumptps(ts); return;
  case &ValueofType(e): dump("valueof_t("); dumpexp(e); dump(")"); return;
  case &TypeofType(e): dump("typeof("); dumpexp(e); dump(")"); return;
  case &BuiltinType(t,_): dump(t); return;
  case &RgnHandleType(rgn): 
    dump("region_t<"); dumprgn(rgn); dump(">"); return;
  case &DynRgnType(r1,r2): dump("dynregion_t<"); dumprgn(r1);
    dump(","); dumprgn(r2); dump(">"); return;
  case &TagType(t): dump("tag_t<"); dumpntyp(t); dump(">"); return;
  case &UniqueRgn: dump("`U"); break;
  case &RefCntRgn: dump("`RC"); break;
  case &TypeDeclType(&{.r = &Aggr_td(ad),...},_):
    dump_aggrdecl(ad); return;
  case &TypeDeclType(&{.r = &Enum_td(ed),...},_):
    dump_enumdecl(ed); return;
  case &TypeDeclType(&{.r = &Datatype_td(dd),...},_):
    dump_datatypedecl(dd); return;
  case &HeapRgn: dump("`H"); break;
  case &AccessEff(ts): dump("{"); dumptyp(ts); dump("}"); break;
  case &RgnsEff(ts): dump("regions("); dumptyp(ts); dump(")"); break;
  case &JoinEff(ts): 
    for (; ts != NULL; ts = ts->tl) {
      dumptyp(ts->hd);
      if (ts->tl != NULL) dump("+");
    }
  }
}

void dumpvaropt(var_opt_t vo) {
  if(vo != NULL) dump_str((var_t)vo);
}
void dumpfunarg($(var_opt_t,tqual_t,type_t)@ t) {
  dumptqtd((*t)[1],(*t)[2],dumpvaropt,(*t)[0]);
}
void dump_rgncmp($(type_t,type_t)@ cmp) {
  let &$(r1,r2) = cmp;
  dumpeff(r1); dump_char('>'); dumprgn(r2);
}
void dump_rgnpo(list_t<$(type_t,type_t)@> rgn_po) {
  dump_sep(dump_rgncmp,rgn_po,",");
}
void dumpfunargs(list_t<$(var_opt_t,tqual_t,type_t)@> args, bool c_varargs, 
                 vararg_info_t *cyc_varargs, type_opt_t effopt,
                 list_t<$(type_t,type_t)@> rgn_po,
                 exp_opt_t req, exp_opt_t ens) {
  dump_char('(');
  for (; args != NULL; args = args->tl) {
    dumpfunarg(args->hd);
    if (args->tl != NULL || c_varargs || cyc_varargs != NULL) dump_char(',');
  }
  if (c_varargs) 
    dump("...");
  else if (cyc_varargs != NULL) {
    let arg = new $(cyc_varargs->name, cyc_varargs->tq, cyc_varargs->type);
    dump("...");
    if (cyc_varargs->inject) dump(" inject ");
    dumpfunarg(arg);
  }
  if (effopt != NULL) {
    dump_semi();
    dumpeff(effopt);
  }
  if (rgn_po != NULL) {
    dump_char(':');
    dump_rgnpo(rgn_po);
  }
  dump_char(')');
  if (req != NULL) {
    dump(" @requires(");
    dumpexp(req);
    dump_char(')');
  }
  if (ens != NULL) {
    dump(" @ensures(");
    dumpexp(ens);
    dump_char(')');
  }
}

void dumptyp(type_t t) {
  dumptqtd(empty_tqual(0),t,ignore,0);
}

void dumpdesignator(designator_t d) {
  switch (d) {
  case &ArrayElement(e): dump(".["); dumpexp(e); dump_char(']'); break;
  case &FieldName(v):    dump_char('.'); dump_nospace(*v); break;
  }
}

void dumpde($(list_t<designator_t>,exp_t)@ de) {
  egroup(dumpdesignator,(*de)[0],"","=","=");
  dumpexp((*de)[1]);
}

void dumpexps_prec(int inprec, list_t<exp_t> es) {
  group_c(dumpexp_prec, inprec, es, "", "", ",");
}

void dumpexp_prec(int inprec, exp_t e) {
  int myprec = Absynpp::exp_prec(e);
  if(inprec >= myprec)
    dump_nospace("(");
  switch (e->r) {
  case &Const_e({.Char_c = $(sg,ch)}):
    dump_char('\''); dump_nospace(Absynpp::char_escape(ch)); dump_char('\''); 
    break;
  case &Const_e({.Wchar_c = s}):           dump(aprintf("L\'%s\'",s)); break;
  case &Const_e({.Short_c = $(sg,s)}):     dump(aprintf("%d",s)); break;
  case &Const_e({.Int_c = $(None,i)}):     fallthru(i);
  case &Const_e({.Int_c = $(Signed,i)}):   dump(aprintf("%d",i)); break;
  case &Const_e({.Int_c = $(Unsigned,i)}): dump(aprintf("%u",(unsigned)i)); break;
  case &Const_e({.LongLong_c = $(sg,i)}):
    // FIX -- take sign into account
    dump(Absynpp::longlong2string(i)); break;
  case &Const_e({.Float_c = $(x,_)}): dump(x); break;
  case &Const_e({.Null_c = _}): dump("NULL"); break;
  case &Const_e({.String_c = s}):
    dump_char('"'); dump_nospace(Absynpp::string_escape(s)); dump_char('"');
    break;
  case &Const_e({.Wstring_c = s}):
    dump("L\""); dump_nospace(s); dump_char('"');
    break;

  case &Var_e(b): dumpqvar(binding2qvar(b)); break;

  case &Primop_e(p,es):
    let pstr = Absynpp::prim2str(p);
    switch (List::length(es)) {
    case 1:
      if (p == (primop_t)Numelts) {
        dump("numelts(");
        dumpexp(es->hd);
        dump(")");
      } else {
        dump(pstr);
        dumpexp_prec(myprec,es->hd);
      }
      break;
    case 2:
      dumpexp_prec(myprec,es->hd);
      dump(pstr);
      dump_char(' '); // avoids problem with '/' followed by '*'
      dumpexp_prec(myprec,es->tl->hd);
      break;
    default: 
      throw new Failure("Absyndump -- Bad number of arguments to primop");
    }
    break;

  case &AssignOp_e(e1,popt,e2):
    dumpexp_prec(myprec,e1);
    if(popt != NULL)
      dump(Absynpp::prim2str(popt->v));
    dump_nospace("=");
    dumpexp_prec(myprec,e2);
    break;

  case &Increment_e(e2,PreInc):  dump("++"); dumpexp_prec(myprec,e2); break;
  case &Increment_e(e2,PreDec):  dump("--"); dumpexp_prec(myprec,e2); break;
  case &Increment_e(e2,PostInc): dumpexp_prec(myprec,e2); dump("++"); break;
  case &Increment_e(e2,PostDec): dumpexp_prec(myprec,e2); dump("--"); break;

  case &Conditional_e(e1,e2,e3):
    dumploc(e->loc);
    dumpexp_prec(myprec,e1);
    dump_char('?'); dumpexp_prec(0,e2);
    dump_char(':'); dumpexp_prec(myprec,e3);
    break;

  case &And_e(e1,e2):
    dumploc(e->loc);
    dumpexp_prec(myprec,e1); dump(" && "); dumpexp_prec(myprec,e2); break;

  case &Or_e(e1,e2):
    dumploc(e->loc);
    dumpexp_prec(myprec,e1); dump(" || "); dumpexp_prec(myprec,e2); break;

  case &SeqExp_e(e1,e2):
    // DAN: put in parens because in initializers , doesn't mean SeqExp and
    // our recursive descent doesn't know if we're in an initializer.
    dumploc(e->loc);
    dump_char('(');
    dumpexp_prec(myprec,e1); dump_char(','); dumpexp_prec(myprec,e2); 
    dump_char(')');
    break;

  case &FnCall_e(e1,es,...):
    dumploc(e->loc);
    dumpexp_prec(myprec,e1);
    dump_nospace("(");
    // JGM: can't dump locations inside macro arguments, so we turn
    // this off if the location of the function call (or the function
    // itself) is 0.
    bool old_generate_line_directives = generate_line_directives;
    generate_line_directives = 
      old_generate_line_directives && !(e->loc == 0) && !(e1->loc == 0);
    dumpexps_prec(20,es);
    dump_nospace(")");
    generate_line_directives = old_generate_line_directives;
    break;

  case &Throw_e(e1,_): 
    dumploc(e->loc);
    dump("throw"); dumpexp_prec(myprec,e1); break;

  case &NoInstantiate_e(e1): fallthru(e1);
  case &Instantiate_e(e1,_): dumpexp_prec(inprec,e1); break;

  case &Cast_e(t,e1,_,_):
    dump_char('('); dumptyp(t); dump_char(')'); dumpexp_prec(myprec,e1);
    break;

  case &Address_e(e1):
    dump_char('&'); dumpexp_prec(myprec,e1); break;

  case &New_e(ropt,e1):
    dump("new "); dumpexp_prec(myprec,e1); break;

  case &Sizeoftyp_e(t):
    dump("sizeof("); dumptyp(t); dump_char(')'); break;

  case &Sizeofexp_e(e1):
    dump("sizeof("); dumpexp(e1); dump_char(')'); break;

  case &Valueof_e(t):
    dump("valueof("); dumptyp(t); dump_char(')'); break;

  case &Asm_e(vol,s):
    dump("__asm__");
    if (vol) dump(" volatile ");
    dump_char('(');
    dump_nospace(s);
    dump_char(')');
    break;

  case &Tagcheck_e(e,f):
    dump("tagcheck("); dumpexp(e); dump_char('.'); dump_nospace(*f); 
    dump_char(')'); 
    break;

  case &Offsetof_e(t,l):
    dump("offsetof("); dumptyp(t); dump_char(','); 
    for (; l != NULL; l=l->tl) {
      switch (l->hd) {
      case &StructField(n):
	dump_nospace(*n);
	break;
      case &TupleIndex(n):
	dump(aprintf("%d",n));
	break;
      }
      if (l->tl != NULL) dump_char('.');
    }
    dump_char(')'); 
    break;

  case &Deref_e(e1):
    dump_char('*'); dumpexp_prec(myprec,e1); break;

  case &AggrMember_e(e1,n,...):
    dumpexp_prec(myprec,e1); dump_char('.');  dump_nospace(*n);
    break;

  case &AggrArrow_e(e1,n,...):
    dumpexp_prec(myprec,e1); dump_nospace("->"); dump_nospace(*n);
    break;

  case &Subscript_e(e1,e2):
    dumpexp_prec(myprec,e1);
    dump_char('['); dumpexp(e2); dump_char(']'); break;

  case &Tuple_e(es):
    dump("$("); dumpexps_prec(20,es); dump_char(')'); break;

  case &CompoundLit_e(vat,des):
    dump_char('(');
    dumptyp((*vat)[2]); // OK to ignore qualifiers??
    dump_char(')');
    group(dumpde,des,"{","}",",");
    break;

  case &Array_e(des):  
    group(dumpde,des,"{","}",",");
    break;

  case &Comprehension_e(vd,e1,e2,_):
    dump("{for"); dump_str((*vd->name)[1]); dump_char('<'); dumpexp(e1);
    dump_char(':'); dumpexp(e2); dump_char('}');
    break;

  case &ComprehensionNoinit_e(e,t,_):
    dump("{for x "); dump_char('<'); dumpexp(e);
    dump_char(':'); dumptyp(t); dump_char('}');
    break;

  case &Aggregate_e(n,ts,des,_):
    dumpqvar(n);
    dump_char('{');
    if(ts != NULL)
      dumptps(ts);
    group(dumpde,des,"","}",",");
    break;

  case &AnonStruct_e(_,des):
    group(dumpde,des,"{","}",",");
    break;

  case &Datatype_e(es,_,tuf):
    dumpqvar(tuf->name);
    if (es != NULL) group(dumpexp,es,"(",")",",");
    break;

  case &Enum_e(_,ef): dumpqvar(ef->name); break;
  case &AnonEnum_e(_,ef): dumpqvar(ef->name); break;

  case &Malloc_e(MallocInfo{is_calloc,ropt,topt,e,_,inline_call}):
    dumploc(e->loc);
    if (is_calloc) {
      if (ropt != NULL) {
        dump("rcalloc(");
        dumpexp((exp_t)ropt); dump(",");
      } else {
        dump("calloc");
      }
      dumpexp(e);
      dump(",");
      dumpexp(sizeoftyp_exp(*topt,0));  
      dump(")");
    } else {
      if (ropt != NULL) {
        if (inline_call)
          dump("rmalloc_inline(");
        else
          dump("rmalloc(");
        dumpexp((exp_t)ropt); dump(",");
      } else {
        dump("malloc(");
      }
      // see comments in absyn.h
      if (topt != NULL) 
        dumpexp(times_exp(sizeoftyp_exp(*topt,0),e,0));
      else 
        dumpexp(e); 
      dump(")");
    }
    break;

  case &Swap_e(e1,e2):
    dumpexp_prec(myprec,e1);
    dump_nospace(":=:");
    dumpexp_prec(myprec,e2);
    break;

  case &UnresolvedMem_e(n,des):
    // Currently n is always NULL from the parser ???
    group(dumpde, des, "{","}",",");
    break;

  case &StmtExp_e(s): 
    dump_nospace("({"); 
    dumpstmt(s,true);
    dump_nospace("})"); 
    break;
  }
  if(inprec >= myprec)
    dump_char(')');
}

void dumpexp(exp_t e) {
  dumpexp_prec(0,e);
}

void dumpswitchclauses(list_t<switch_clause_t> scs) {
  for(; scs != NULL; scs = scs->tl) {
    let c = scs->hd;
    if(c->where_clause == NULL && c->pattern->r == (raw_pat_t)&Wild_p_val) 
      dump("default:");
    else {
      dump("case");
      dumppat(c->pattern);
      if(c->where_clause != NULL) {
	dump("&&");
	dumpexp((exp_t)c->where_clause);
      }
      dump_nospace(":");
    }
    dumpstmt(c->body,false);
  }
}

void dumpstmt(stmt_t s,bool expstmt) {
  dumploc(s->loc);
  switch(s->r) {
  case &Skip_s:   dump_semi(); break;
  case &Exp_s(e): dumpexp(e); dump_semi(); break;
    // FIX:  gcc only allows declarations to be used at the beginning
    // of blocks, so we force some explicit blocks to be written below.
    // It is verbose for Cyclone; maybe it should be controlled by a flag.
  case &Seq_s(s1,s2):
    if(Absynpp::is_declaration(s1)) {
      dump_char('{'); dumpstmt(s1,false); dump_char('}');
    } else
      dumpstmt(s1,false);
    if(Absynpp::is_declaration(s2)) {
      if (expstmt) dump_char('(');
      dump_char('{'); dumpstmt(s2,expstmt); 
      dump_char('}');
      if (expstmt) dump_char(')'); dump_semi();
    } else
      dumpstmt(s2,expstmt);
    break;
  case &Return_s(NULL): dump("return;"); break;
  case &Return_s(e): dump("return"); dumpexp((exp_t)e); dump_semi(); break;
  case &IfThenElse_s(e,s1,s2):
    dump("if("); dumpexp(e); 
    switch(s1->r) {
    case &Seq_s(_,_):
    case &Decl_s(_,_): 
    case &IfThenElse_s(_,_,_):
    case &Label_s(_,_): dump_nospace("){"); dumpstmt(s1,false); dump_char('}'); break;
    default: dump_char(')'); dumpstmt(s1,false);
    }
    switch (s2->r) {
    case &Skip_s: break;
    default: dump("else{"); dumpstmt(s2,false); dump_char('}'); break;
    }
    break;
  case &While_s($(e,_),s1):
    dump("while("); dumpexp(e); dump_nospace("){");
    dumpstmt(s1,false);
    dump_char('}');
    break;
  case &Break_s:    dump("break;");    break;
  case &Continue_s: dump("continue;"); break;
  case &Goto_s(x):  dump("goto"); dump_str(x); dump_semi(); break;

  case &For_s(e1,$(e2,_),$(e3,_),s1):
    dump("for("); dumpexp(e1);dump_semi(); dumpexp(e2);dump_semi(); dumpexp(e3);
    dump_nospace("){"); dumpstmt(s1,false); dump_char('}');
    break;
  case &Switch_s(e,ss,_):
    dump("switch("); dumpexp(e); dump_nospace("){");
    dumpswitchclauses(ss);
    dump_char('}');
    break;

  case &Decl_s(d,s1): dumpdecl(d); dumpstmt(s1,expstmt); break;

  case &Label_s(x,s1):
    // FIX:  gcc does not allow declarations to be used immediately after
    // labels.  This next case forces an explicit block to be written.
    // It is verbose for Cyclone; maybe it should be controlled by a flag.
    if(Absynpp::is_declaration(s1)) {
      dump_str(x); 
      if (expstmt) dump_nospace(": ({"); else dump_nospace(": {"); 
      dumpstmt(s1,expstmt); 
      if (expstmt) dump_nospace("});}"); else dump_char('}');
    } else {
      dump_str(x); dump_char(':'); dumpstmt(s1,expstmt);
    }
    break;

  case &Do_s(s1,$(e,_)):
    dump("do{"); dumpstmt(s1,false); 
    dump_nospace("}while("); dumpexp(e); dump_nospace(");");
    break;

  case &Fallthru_s(NULL,_): dump("fallthru;");     break;
  case &Fallthru_s(es,_):
    dump("fallthru("); dumpexps_prec(20,es); dump_nospace(");"); break;

  case &TryCatch_s(s1,ss,_):
    dump("try"); dumpstmt(s1,false); 
    dump("catch{");
    dumpswitchclauses(ss); dump_char('}');
    break;

  case &ResetRegion_s(e):
    dump("reset_region("); dumpexp(e); dump(");");
    break;

  }
}

void dumpdp($(list_t<designator_t>,pat_t)@ dp) {
  egroup(dumpdesignator,(*dp)[0],"","=","=");
  dumppat((*dp)[1]);
}

void dumppat(pat_t p) {
  switch(p->r) {
  case &Wild_p: dump_char('_'); break;
  case &Null_p: dump("NULL");   break;
  case &Int_p(None,i):     fallthru(i);
  case &Int_p(Signed,i):   dump(aprintf("%d",i)); break;
  case &Int_p(Unsigned,i): dump(aprintf("%u",i)); break;
  case &Char_p(ch):
    dump("'"); dump_nospace(Absynpp::char_escape(ch)); dump_nospace("'"); break;
  case &Float_p(x,_): dump(x); break;
  case &Var_p(vd,&Pat{.r = &Wild_p,...}): dumpqvar(vd->name); break;
  case &Var_p(vd,p2): dumpqvar(vd->name); dump(" as "); dumppat(p2); break;
  case &AliasVar_p(tv,vd): 
    dump("alias");
    dump("<"); dumptvar(tv); dump(">" );
    dumpvardecl(vd,p->loc,false);
    break;
  case &Tuple_p(ts,dots):     
    string_t term = dots ? ", ...)" : ")";
    group(dumppat,ts,"$(",term,","); break;
  case &Pointer_p(p2):   dump("&"); dumppat(p2); break;
  case &Reference_p(vd,&Pat{.r = &Wild_p,...}): 
    dump("*"); dumpqvar(vd->name); break;
  case &Reference_p(vd,p2):
    dump("*"); dumpqvar(vd->name); dump(" as "); dumppat(p2); break;
  case &TagInt_p(tv,vd): 
    dumpqvar(vd->name); dump_char('<'); dumptvar(tv); dump_char('>'); break;
  case &UnknownId_p(q):  dumpqvar(q); break;
  case &UnknownCall_p(q,ps,dots): 
    string_t term = dots ? ", ...)" : ")";
    dumpqvar(q); group(dumppat,ps,"(",term,","); break;
  case &Aggr_p(&AggrInfo(info,_),exists,dps,dots):
    let $(_,n) = aggr_kinded_name(info);
    string_t term = dots ? ", ...)" : ")";
    dumpqvar(n); dump_char('{');
    egroup(dumptvar,exists,"[","]",",");
    group(dumpdp,dps,"",term,",");
    break;
  case &Aggr_p(NULL,exists,dps,dots):
    string_t term = dots ? ", ...)" : ")";
    dump_char('{');
    egroup(dumptvar,exists,"[","]",",");
    group(dumpdp,dps,"",term,",");
    break;
  case &Datatype_p(_,tuf,ps,dots):
    string_t term = dots ? ", ...)" : ")";
    dumpqvar(tuf->name); 
    if (ps != NULL) group(dumppat,ps,"(",term,",");
    break;
  case &Enum_p(_,ef): fallthru(ef);
  case &AnonEnum_p(_,ef): dumpqvar(ef->name); break;
  case &Exp_p(e): dumpexp(e); break;
  }
}

void dumpdatatypefield(datatypefield_t ef) { 
  dumpqvar(ef->name);
  if(ef->typs != NULL)
    dumpargs(ef->typs);
}
void dumpdatatypefields(list_t<datatypefield_t> fields) {
  dump_sep(dumpdatatypefield,fields,",");
}
void dumpenumfield(enumfield_t ef) {
  dumpqvar(ef->name);
  if (ef->tag != NULL) {
    dump(" = ");
    dumpexp((exp_t)ef->tag);
  }
}
void dumpenumfields(list_t<enumfield_t> fields) {
  dump_sep(dumpenumfield,fields,",");
}

void dumpaggrfields(list_t<aggrfield_t> fields) {
  for(; fields != NULL; fields = fields->tl) {
    let &Aggrfield{name,tq,type,width,atts,req} = fields->hd;

    switch(c_compiler){
    case Gcc_c:
      dumptqtd(tq,type,dump_str,name);
      dumpatts(atts);
      break;
    case Vc_c:
      dumpatts(atts);
      dumptqtd(tq,type,dump_str,name);
      break;
    }
    if (req) {
      dump("@requires ");
      dumpexp(req);
    }
    if (width != NULL) {
      dump_char(':');
      dumpexp((exp_t)width);
    }
    dump_semi();
  }
}

void dumptypedefname(typedefdecl_t td) {
  dumpqvar(td->name);
  dumptvars(td->tvs);
}

static void dump_atts_qvar(fndecl_t fd) {
  dumpatts(fd->attributes);
  dumpqvar(fd->name);
}
static void dump_callconv_qvar($(attribute_t,qvar_t)@`r pr) {
  switch((*pr)[0]) {
  case &Unused_att: break;
  case &Stdcall_att:  dump("_stdcall");  break;
  case &Cdecl_att:    dump("_cdecl");    break;
  case &Fastcall_att: dump("_fastcall"); break;
  default: break;
  }
  dumpqvar((*pr)[1]);
}
static void dump_callconv_fdqvar(fndecl_t fd) {
  dump_callconv(fd->attributes);
  dumpqvar(fd->name);
}

static void dumpids(list_t<vardecl_t> vds) {
  for (; vds != NULL; vds = vds->tl) {
    dumpqvar(vds->hd->name);
    if (vds->tl != NULL) dump_char(',');
  }
}

static bool is_char_ptr(type_t t) {
  // want to avoid compressing here when possible
  switch (t) {
  case &Evar(_,def,_,_) && def != NULL: return is_char_ptr((type_t)def);
  case &PointerType(PtrInfo{elt_typ,_,_}):
  L:
    switch (elt_typ) {
    case &Evar(_,t,_,_) && t != NULL: elt_typ = (type_t)t; goto L;
    case &TypedefType(_,_,_,t) && t != NULL: elt_typ = (type_t)t; goto L;
    case &IntType(_,Char_sz): return true;
    default: return false;
    }
  default: return false;
  }
}

void dumpvardecl(vardecl_t vd,Position::seg_t loc,bool do_semi) {
  let &Vardecl{sc,name,tq,type,initializer,_,atts,_} = vd;
  switch(c_compiler){
  case Gcc_c:
    // hack to avoid writing so many useless externs:
    if(sc == Extern && qvar_to_Cids)
      switch(Tcutil::compress(type)) {
      case &FnType(_): break;
      default: dumpscope(sc);
      }
    else
      dumpscope(sc);
    dumptqtd(tq, type, dumpqvar, name);
    dumpatts(atts);
    break;
  case Vc_c:
    dumpatts(atts);
    dumpscope(sc);
    region temp; {
      bool is_cp = is_char_ptr(type);
      let $(tq,t,tms) = Absynpp::to_tms(temp,tq,type);
      // a kludge -- seems to work -- Unused_att is just a hack for "no spec"
      attribute_t call_conv = &Unused_att_val;
      for(_ tms2 = tms; tms2 != NULL; tms2 = tms2->tl)
        switch(tms2->hd) {
        case &Attributes_mod(_,atts):
          for(; atts != NULL; atts = atts->tl)
            switch(atts->hd) {
            case &Stdcall_att:  call_conv = &Stdcall_att_val;  break;
            case &Cdecl_att:    call_conv = &Cdecl_att_val;    break;
            case &Fastcall_att: call_conv = &Fastcall_att_val; break;
            default: break;
            }
          break;
        default: break;
        }
      dumptq(tq);
      dumpntyp(t);
      let pr = $(call_conv,name);
      dumptms(is_cp, List::imp_rev(tms), dump_callconv_qvar, &pr);
    }
    break;
  }

  if(initializer != NULL) {
    dump_char('=');
    dumpexp((exp_t)initializer);
  }
  if (do_semi) dump_semi();
}

static void dump_aggrdecl(aggrdecl_t ad) {
  dumpscope(ad->sc);
  if (ad->impl != NULL && ad->impl->tagged)
    dump("@tagged ");
  dumpaggr_kind(ad->kind); 
  dumpqvar(ad->name);
  dumpkindedtvars(ad->tvs);
  if(ad->impl == NULL) return;
  else {
    dump_char('{');
    if(ad->impl->exist_vars != NULL)
      egroup(dumpkindedtvar,ad->impl->exist_vars,"<",">",",");
    if(ad->impl->rgn_po != NULL) {
      dump_char(':');
      dump_rgnpo(ad->impl->rgn_po);
    }
    dumpaggrfields(ad->impl->fields);
    dump("}");
    dumpatts(ad->attributes);
  }
}
static void dump_enumdecl(enumdecl_t ed) {
  let &Enumdecl{sc,nm,fields} = ed;
  dumpscope(sc);
  dump("enum ");
  dumpqvar(nm);
  if (fields != NULL) {
    dump_char('{');
    dumpenumfields(fields->v);
    dump_nospace("}");
  }
}
static void dump_datatypedecl(datatypedecl_t dd) {
  let &Datatypedecl(sc,name,tvs,fields,is_x) = dd;
  dumpscope(sc);
  if (is_x) dump("@extensible ");
  dump("datatype ");
  dumpqvar(name);
  dumptvars(tvs);
  if(fields != NULL) {
    dump_char('{');
    dumpdatatypefields(fields->v);
    dump_nospace("}");
  }
}

void dumpdecl(decl_t d) {
  dumploc(d->loc);
  switch(d->r) {
  case &Var_d(vd):
    dumpvardecl(vd,d->loc,true);
    break;
  case &Fn_d(fd):
    //    fprintf(stderr,"%s",*(*fd->name)[1]); fflush(stdout);
    switch(c_compiler) {
    case Vc_c: dumpatts(fd->attributes); break;
    case Gcc_c: break;
    }
    if(fd->is_inline) 
      switch(c_compiler){
      case Vc_c: dump("__inline"); break;
      case Gc_c: dump("inline");   break;
      }
    dumpscope(fd->sc);
    type_t t = new FnType(FnInfo{fd->tvs, fd->effect, fd->ret_tqual,
                                 fd->ret_type,
                                 List::map(Absynpp::arg_mk_opt,fd->args), 
                                 fd->c_varargs, fd->cyc_varargs,
                                 fd->rgn_po, NULL, fd->requires_clause,
                                 fd->requires_relns,
                                 fd->ensures_clause,fd->ensures_relns});
    switch(c_compiler){
    case Gcc_c:
      dumptqtd(empty_tqual(0), t, dump_atts_qvar,fd);
      break;
    case Vc_c:
      dumptqtd(empty_tqual(0), t, dump_callconv_fdqvar,fd);
      break;  
    }
    dump_char('{');
    dumpstmt(fd->body,false);
    dump_char('}');
    break;
  case &Aggr_d(ad):
    dump_aggrdecl(ad); dump_semi();
    break;
  case &Datatype_d(dd):
    dump_datatypedecl(dd); dump_semi();
    break;
  case &Enum_d(ed): 
    dump_enumdecl(ed); dump_semi();
    break;
  case &Let_d(p,_,e,_):
    dump("let");
    dumppat(p);
    dump_char('=');
    dumpexp(e);
    dump_semi();
    break;
  case &Letv_d(vds):
    dump("let ");
    dumpids(vds);
    dump_semi();
    break;
  case &Region_d(tv,vd,resetable,open_exp_opt):
    dump("region"); 
    dump("<"); dumptvar(tv); dump("> "); dumpqvar(vd->name);
    if (open_exp_opt) {
      dump(" = open(");
      dumpexp(open_exp_opt);
      dump(")");
    }
    if (resetable) dump("@resetable");
    dump_semi();
    break;

  case &Typedef_d(td):
    // JGM: commenting out because abstract typdefs don't get printed
    // otherwise (e.g., typedef _ T;)
    // if (!expand_typedefs || (td->defn != NULL) && (Absynpp::is_anon_aggrtype(td->defn->v))) {
      dump("typedef");
      type_t t;
      if (td->defn == NULL) 
        t = new_evar(td->kind,NULL);
      else 
        t = (type_t)td->defn;
      dumptqtd(td->tq,t,dumptypedefname,td);
      dumpatts(td->atts);
      dump_semi();
      //}
    break;
  case &Namespace_d(v,tdl):
    dump("namespace ");
    dump_str(v);
    dump_char('{');
    for(; tdl != NULL; tdl = tdl->tl)
      dumpdecl(tdl->hd);
    dump_char('}');
    break;
  case &Using_d(q,tdl):
    dump("using ");
    dumpqvar(q);
    dump_char('{');
    for(; tdl != NULL; tdl = tdl->tl)
      dumpdecl(tdl->hd);
    dump_char('}');
    break;
  case &ExternC_d(tdl):
    dump("extern \"C\" {");
    for(; tdl != NULL; tdl = tdl->tl)
      dumpdecl(tdl->hd);
    dump_char('}');
    break;
  case &ExternCinclude_d(tdl,exs):
    dump("extern \"C include\" {");
    for(; tdl != NULL; tdl = tdl->tl)
      dumpdecl(tdl->hd);
    dump_char('}');
    if (exs != NULL) {
      dump(" export {");
      for (; exs != NULL; exs = exs->tl) {
        let $(_,v,_) = *exs->hd;
        dumpqvar(v);
        if (exs->tl != NULL) dump_char(',');
      }
      dump("}");
    }
    break;
  case &Porton_d:
    dump(" __cyclone_port_on__; ");
    break;
  case &Portoff_d:
    dump(" __cyclone_port_off__; ");
    break;
  }
}

static void dump_upperbound(exp_t e) {
  $(unsigned int,bool) pr = Evexp::eval_const_uint_exp(e);
  if (pr[0] != 1 || !pr[1]) {
    dump_char('{'); dumpexp(e); dump_char('}');
  }
}

void dumptms(bool is_char_ptr, list_t<type_modifier_t> tms, void f(`a), `a a) {
  if(tms == NULL) {
    f(a);
    return;
  }
  switch(tms->hd) {
    // FIX: doesn't invert zeroterm default when elt type is char!! (never did)
    // FIX? What about attributes that we parse before tq2??
  case &Pointer_mod(PtrAtts(rgn,nullable,bd,zt,_),tq2):
    switch(conref_def(bounds_one,bd)) {
    case &DynEither_b: dump_char('?'); break;
    case &Upper_b(e):
      dump_char(conref_def(true,nullable) ? '*' : '@');
      dump_upperbound(e);
      break;
    }
    if(!qvar_to_Cids && !is_char_ptr && conref_def(false,zt)) dump("@zeroterm");
    if(!qvar_to_Cids && is_char_ptr && !conref_def(false,zt)) dump("@nozeroterm");
    switch(Tcutil::compress(rgn)) {
    case &HeapRgn: if (!qvar_to_Cids) dump("`H"); break;
    case &UniqueRgn: dump("`U"); break;
    case &RefCntRgn: dump("`RC"); break;
    case &VarType(tv): dumptvar(tv); break;
    case &Evar(_,NULL,_,_): dumpntyp(Tcutil::compress(rgn)); break;
    case &TypedefType(...): dump("@region("); dumptyp(rgn); dump(")"); break;
    default: Tcutil::impos("dumptms: bad rgn type in Pointer_mod");
    }
    dumptq(tq2); // rare
    dumptms(false,tms->tl,f,a);
    return;

  default:
    bool next_is_pointer = false;
    if(tms->tl != NULL)
      switch (tms->tl->hd) {
      case &Pointer_mod(_,_): next_is_pointer = true; break;
      default: break;
      }
    if(next_is_pointer)
      dump_char('(');
    dumptms(false, tms->tl, f, a);
    if(next_is_pointer)
      dump_char(')');
    switch(tms->hd) {
    case &Carray_mod(zeroterm,_): 
      dump("[]"); 
      if (conref_def(false,zeroterm)) dump("@zeroterm");
      break;
    case &ConstArray_mod(e,zeroterm,_):
      dump_char('['); dumpexp(e); dump_char(']'); 
      if (conref_def(false,zeroterm)) dump("@zeroterm");
      break;
    case &Function_mod(&WithTypes(args,c_varargs,cyc_varargs,effopt,rgn_po,req,ens)):
      dumpfunargs(args,c_varargs,cyc_varargs,effopt,rgn_po,req,ens); break;
    case &Function_mod(&NoTypes(sl,loc)):
      group(dump_str,sl,"(",")",","); break;
    case &TypeParams_mod(ts,loc,print_kinds): 
      if (print_kinds) dumpkindedtvars(ts); else dumptvars(ts); break;
    case &Attributes_mod(_,atts): dumpatts(atts); break;
    case &Pointer_mod(_,_): Tcutil::impos("dumptms");
    }
    return;
  }
}

void dumptqtd(tqual_t tq, type_t t, void f(`a), `a a) {
  let cp = is_char_ptr(t);
  region temp; {
    let $(tq,t,tms) = Absynpp::to_tms(temp,tq,t);
    dumptq(tq);
    dumpntyp(t);
    dumptms(cp, List::imp_rev(tms),f,a);
  }
}

void dumpdecllist2file(list_t<decl_t> tdl, FILE @`H f) {
  //pos = 0;
  *dump_file = f;
  for(; tdl != NULL; tdl = tdl->tl)
    dumpdecl(tdl->hd);
  fprintf(f,"\n");
}

static void dump_decl_interface(decl_t d) {
  switch (d->r) {
  case &Var_d(vd):
    if (vd->sc == Static) return;
    exp_opt_t init = vd->initializer;
    vd->initializer = NULL;
    if (vd->sc == Public)
      dump("extern ");
    dumpvardecl(vd,d->loc,true);
    dump("\n");
    vd->initializer = init;
    break;
  case &Fn_d(fd):
    if (fd->sc == Static) return;
    dumpscope(fd->sc);
    type_t t = new FnType(FnInfo{fd->tvs, fd->effect, fd->ret_tqual,
                                 fd->ret_type, 
                                 List::map(Absynpp::arg_mk_opt,fd->args),
                                 fd->c_varargs, fd->cyc_varargs, 
                                 fd->rgn_po, NULL, fd->requires_clause,
                                 fd->requires_relns,
                                 fd->ensures_clause, fd->ensures_relns});
    dumptqtd(empty_tqual(0), t, dump_atts_qvar, fd);
    dump(";\n");
    break;
  case &Aggr_d(ad):
    if (ad->sc == Static) return;
    struct AggrdeclImpl *impl = ad->impl;
    if (ad->sc == Abstract) ad->impl = NULL;
    dump_aggrdecl(ad); 
    ad->impl = impl;
    dump(";\n");
    break;
  case &Datatype_d(dd):
    dump_datatypedecl(dd);
    dump(";\n");
    break;
  case &Enum_d(ed):
    dump_enumdecl(ed);
    dump(";\n");
    break;
  case &Typedef_d(td):
    if (td->defn == NULL) {
      dumpdecl(d);
      dump("\n");
    }
    break;
  case &Namespace_d(v,ds): 
    dump("namespace ");
    dump_str(v);
    dump("{\n");
    for (; ds != NULL; ds = ds->tl)
      dump_decl_interface(ds->hd);
    dump("}\n");
    break;
  case &Using_d(_,ds):
    for (; ds != NULL; ds = ds->tl)
      dump_decl_interface(ds->hd);
    break;
  case &ExternC_d(ds):
    dump("extern \"C\" {");
    for(; ds != NULL; ds = ds->tl)
      dump_decl_interface(ds->hd);
    dump("}\n");
    break;
  case &ExternCinclude_d(ds,exs): 
    /* omit these for now
    dump("extern \"C include\" {");
    for(; ds != NULL; ds = ds->tl)
      dump_decl_interface(ds->hd);
    dump_char('}');
    if (exs != NULL) {
      dump(" export {");
      for (; exs != NULL; exs = exs->tl) {
        let $(_,v,_) = *exs->hd;
        dumpqvar(v);
        if (exs->tl != NULL) dump_char(',');
      }
      dump("}");
    }
    */
    break;
  default: Tcutil::impos("bad top-level declaration");
  }
}

void dump_interface(list_t<decl_t> ds, FILE @`H f) {
  *dump_file = f;
  for (; ds != NULL; ds = ds->tl)
    dump_decl_interface(ds->hd);
}
