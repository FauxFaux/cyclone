
// Note that since we don't have an indent program for Cyclone, using this
// module for non-C code gives you fairly worthless stuff.  (And it hasn't
// been tested.) Actually, we could see how badly indent bombs on Cyclone --
// I'm guessing "very".

#include "core.h"
#include "stdio.h"
#include "list.h"
#include "absyn.h"
#include "absynpp.h"
#include "evexp.h"
#include "tcutil.h"

using Core;
using Stdio;
using List;
using Absyn;

namespace Absyndump;

extern void dumptyp(typ);
extern void dumpntyp(typ t);
extern void dumpexp(exp);
extern void dumpexp_prec(int,exp);
extern void dumppat(pat);
extern void dumpstmt(stmt);
extern void dumpdecl(decl);
extern void dumptqtd(struct Tqual *, typ, void f(`a), `a);

// really want to change this to char[] (need a control character for format
// prims and the ability to cast to untagged (from Tagged requires Toc hlep,
// from Fixed requires trivial Toc help)
typedef string dump_string_t;

// set by dumpdecllist2file (this module is not re-entrant)
FILE @@ dump_file = &stdout; 

void ignore(`a x) { return; }

static unsigned int pos = 0;
// It would be really nice to have a control character for untagged arrays!
// (Think of all the saved allocation for punctuation and keywords!)
void dump(dump_string_t s) {
  int sz = s.size;
  if(!s[sz-1])
    --sz;
  pos += sz+1;
  if (pos > 80) {
    pos = sz;
    fputc('\n',*dump_file);
  } else
    Stdio::fputc(' ',*dump_file);
  Stdio::file_string_write(*dump_file, s, 0, sz);
}
void dump_nospace(dump_string_t s) {
  int sz = s.size;
  if(!s[sz-1])
    --sz;
  pos += sz;
  Stdio::file_string_write(*dump_file, s, 0, sz);
}
void dump_char(int c) { // no space
  ++pos;
  Stdio::fputc(c,*dump_file);
}

// this needs to take a boxed type b/c it's used to instantiate `a
void dump_str(stringptr s) {
  dump(*s);
}

void dump_semi() {
  dump_char(';');
}

void dump_sep(void f(`a), list_t<`a> l, dump_string_t sep) {
  if(l == null)
    return;
  for(; l->tl != null; l = l->tl) {
    f(l->hd);
    dump_nospace(sep); // still have the unnecessary space afterwards, though
  }
  f(l->hd);
}
void dump_sep_c(void f(`b,`a), `b env, list_t<`a> l, dump_string_t sep) {
  if(l == null)
    return;
  for(; l->tl != null; l = l->tl) {
    f(env,l->hd);
    dump_nospace(sep); // still have the unnecessary space afterwards, though
  }
  f(env,l->hd);
}
void group(void f(`a), list_t<`a> l,
           dump_string_t start, dump_string_t end, dump_string_t sep) {
  dump_nospace(start);
  dump_sep(f,l,sep);
  dump_nospace(end);
}
void group_c(void f(`b,`a), `b env, list_t<`a> l,
             dump_string_t start, dump_string_t end, dump_string_t sep) {
  dump_nospace(start);
  dump_sep_c(f,env,l,sep);
  dump_nospace(end);
}
void egroup(void f(`a), list_t<`a> l,
            dump_string_t start, dump_string_t end, dump_string_t sep) {
  if(l != null)
    group(f,l,start,end,sep);
}

// is this backwards for nested namespaces? Consistent either way, but
// should do the right thing!
void dumpqvar(qvar v) {
  let nsl = null;
  switch ((*v)[0]) {
  case Loc_n:       fallthru;
  case Rel_n(null): fallthru;
  case Abs_n(null): dump_str((*v)[1]); return;
  case Rel_n(x):    fallthru(x);
  case Abs_n(x):    nsl = x; break;
  }
  dump_str(nsl->hd);
  for(nsl = nsl->tl; nsl != null; nsl = nsl->tl) {
    // Note: This is the most common reason the result goes over 80 columns,
    //       but who really cares.
    if(Absynpp::qvar_to_Cids) dump_char('_');
    else dump_nospace("::");
    dump_nospace(*(nsl->hd));
  }
  if(Absynpp::qvar_to_Cids) dump_nospace("_");
  else dump_nospace("::");
  dump_nospace(*((*v)[1]));
}

void dumptq(tqual tq) {
  if(tq->q_restrict) dump("restrict");
  if(tq->q_volatile) dump("volatile");
  if(tq->q_const)    dump("const");
}

void dumpscope(scope sc) {
  switch (sc) {
  case Static:   dump("static"); return;
  case Public:   return;
  case Extern:   dump("extern"); return;
  case ExternC:  dump("extern \"C\""); return;
  case Abstract: dump("abstract"); return;
  }
}

void dumpkind(kind_t k) {
  switch (k) {
  case AnyKind       : dump("A"); return;
  case MemKind       : dump("M"); return;
  case BoxKind       : dump("B"); return;
  case RgnKind       : dump("R"); return;
  case EffKind       : dump("E"); return;
  }
}

void dumptps(list_t<typ> ts) {
  egroup(dumptyp,ts,"<",">",",");
}
void dumptvar(tvar tv) {
  dump_str(tv->name);
}
void dumpkindedtvar(tvar tv) {
  dump_str(tv->name);
  switch (compress_conref(tv->kind)->v) {
  case Eq_constr(BoxKind): break;
  case Eq_constr(k): dump("::"); dumpkind(k); break;
  default: dump("::?"); break;
  }
}
void dumptvars(list_t<tvar> tvs) {
  egroup(dumptvar,tvs,"<",">",",");
}
void dumpkindedtvars(list_t<tvar> tvs) {
  egroup(dumpkindedtvar,tvs,"<",">",",");
}

void dumparg($(tqual,typ)@ pr) {
  dumptqtd((*pr)[0],(*pr)[1],ignore,0);
}
void dumpargs(list_t<$(tqual,typ)@> ts) {
  group(dumparg,ts,"(",")",",");
}

void dumpatts(attributes_t atts) {
  if (atts == null) return;
  dump(" __attribute__((");
  for (; atts != null; atts = atts->tl) {
    dump(attribute2string(atts->hd));
    if (atts->tl != null) dump(",");
  };
  dump(")) ");
}

bool next_is_pointer(list_t<type_modifier> tms) {
  if (tms==null) return false;
  switch (tms->hd) {
  case Pointer_mod(_,_,_): return true;
  default: return false;
  }
}

static void dumprgn(typ t) {
  switch (Tcutil::compress(t)) {
  case HeapRgn: dump("`H"); break;
  default: dumpntyp(t); break;
  }
}

static $(list_t<typ>, list_t<typ>) effects_split(typ t) {
  list_t<typ> regions = null;
  list_t<typ> effects = null;

  switch (Tcutil::compress(t)) {
  case AccessEff(r): regions = new List(r,regions); break;
  case JoinEff(ts):
    for (; ts != null; ts = ts->tl) {
      let $(rs,es) = effects_split(ts->hd);
      regions = List::imp_append(rs,regions);
      effects = List::imp_append(es,effects);
    }
    break;
  default: effects = new List(t,effects); break;
  }
  return $(regions, effects);
}

static void dumpeff(typ t) {
  let $(regions,effects) = effects_split(t);
  regions = List::imp_rev(regions);
  effects = List::imp_rev(effects);
  for (; effects != null; effects = effects->tl) {
    dumpntyp(effects->hd);
    dump_char('+');
  }
  dump_char('{');
  for (; regions != null; regions = regions->tl) {
    dumprgn(regions->hd);
    if (regions->tl != null) dump_char(',');
  }
  dump_char('}');
}

// Convert a normalized typ to a doc
void dumpntyp(typ t) {
  switch (t) {
    // The first three cases never turn up in normalized types.
  case ArrayType(_,_,_): return;
  case FnType(_)       : return;
  case PointerType(_)  : return;
  case VoidType:         dump("void"); return;
  case VarType(tv): dump_str(tv->name); return; // FIX: may want explicit kinds
  case Evar(k,null,i): dump("%"); dumpkind(k); dump(xprintf("(%d)",i)); return;
  case Evar(k,&Opt(t),i): dumpntyp(t); return; // shouldn't happen!
  case EnumType(null,ts,_):dump("enum");                    dumptps(ts); return;
  case EnumType(n,  ts,_): dump("enum"); dumpqvar((qvar)n); dumptps(ts); return;
  case XenumType(n,_):     dump("xenum"); dumpqvar(n);                  return;
  case IntType(Signed,   B1): dump("signed char");           return;
  case IntType(Unsigned, B1): dump("char");                  return;
  case IntType(Signed,   B2): dump("short");                 return;
  case IntType(Unsigned, B2): dump("unsigned short");        return;
  case IntType(Signed,   B4): dump("int");                   return;
  case IntType(Unsigned, B4): dump("unsigned int");          return;
  case IntType(Signed,   B8): dump("long long");             return;
  case IntType(Unsigned, B8): dump("unsigned long long");    return;
  case FloatType:  dump("float");  return;
  case DoubleType: dump("double"); return;
  case TupleType(ts): dump_char('$'); dumpargs(ts); return;
  case StructType(null,ts,_):   dump("struct"); dumptps(ts); return;
  case StructType(n,  ts,_):
    dump("struct"); dumpqvar((qvar)n); dumptps(ts); return;
  case UnionType(null,ts,_):   dump("union"); dumptps(ts); return;
  case UnionType(n,  ts,_):
    dump("union"); dumpqvar((qvar)n); dumptps(ts); return;
  case TypedefType(n,ts,topt):  dumpqvar(n), dumptps(ts); return;
  case RgnHandleType(rgn):
    dumprgn(rgn); return;
  case HeapRgn: return; 
  case AccessEff(_): return;
  case JoinEff(_): return;
  }
}

void dumpvaropt(opt_t<var> vo) {
  if(vo != null) dump_str(vo->v);
}
void dumpfunarg($(opt_t<var>,tqual,typ)@ t) {
  dumptqtd((*t)[1],(*t)[2],dumpvaropt,(*t)[0]);
}
void dumpfunargs(list_t<$(opt_t<var>,tqual,typ)@> args, bool varargs, 
                 opt_t<typ> effopt) {
  dump_char('(');
  for (; args != null; args = args->tl) {
    dumpfunarg(args->hd);
    if (args->tl != null || varargs) dump_char(',');
  }
  if (varargs) dump("...");
  if (effopt != null) {
    dump_semi();
    dumpeff(effopt->v);
  }
  dump_char(')');
}

void dumptyp(typ t) {
  dumptqtd(null,t,ignore,0);
}

void dumpdesignator(designator d) {
  switch (d) {
  case ArrayElement(e): dump(".["); dumpexp(e); dump_char(']'); break;
  case FieldName(v):    dump_char('.'); dump_nospace(*v); break;
  }
}

void dumpde($(list_t<designator>,exp)@ de) {
  egroup(dumpdesignator,(*de)[0],"","=","=");
  dumpexp((*de)[1]);
}

void dumpexps_prec(int inprec, list_t<exp> es) {
  group_c(dumpexp_prec, inprec, es, "", "", ",");
}

void dumpexp_prec(int inprec, exp e) {
  int myprec = Absynpp::exp_prec(e);
  if(inprec >= myprec)
    dump_nospace("(");
  switch (e->r) {
  case Const_e(Char_c(sg,ch)):
    dump_char('\''); dump_nospace(Absynpp::char_escape(ch)); dump_char('\''); 
    break;
  case Const_e(Short_c(sg,s)):
    dump("(short)"); dump_nospace(string_of_int(s)); break;
  case Const_e(Int_c(Signed,i)):
    dump(string_of_int(i)); break;
  case Const_e(Int_c(Unsigned,i)):
    dump(string_of_int(i)); dump_nospace("u"); break;
  case Const_e(LongLong_c(sg,i)):
    dump("<<FIX LONG LONG CONSTANT>>"); break; // FIX
  case Const_e(Float_c(x)):    dump(x);      break;
  case Const_e(Null_c):        dump("null"); break;
  case Const_e(String_c(s)):
    dump_char('"'); dump_nospace(Absynpp::string_escape(s)); dump_char('"');
    break;

    // FIX: w.r.t. shadowing???
  case UnknownId_e(x): fallthru(x);
  case Var_e(x,_):     dumpqvar(x); break;

  case Primop_e(p,es):
    // FIX: total waste to allocate, but compiler cannot cast to
    // UntaggedArray correctly (fix Tcutil::coerce_arg and extend
    // Toc conversions).
    string pstr = Absynpp::prim2str(p);
    if(!is_format_prim(p)) {
      switch (List::length(es)) {
      case 1:
	if (p == Size) {
	  dumpexp_prec(myprec,es->hd);
	  dump(".size");
	} else {
	  dump(pstr);
	  dumpexp_prec(myprec,es->hd);
	}
	break;
      case 2:
	dumpexp_prec(myprec,es->hd);
	dump(pstr);
	dumpexp_prec(myprec,es->tl->hd);
	break;
      default: throw Failure("Absyndump -- Bad number of arguments to primop");
      }
    } else {
      dump(pstr); dump_nospace("("); dumpexps_prec(20,es); dump_nospace(")");
    }
    break;

  case AssignOp_e(e1,popt,e2):
    dumpexp_prec(myprec,e1);
    if(popt != null)
      dump(Absynpp::prim2str(popt->v));
    dump_nospace("=");
    dumpexp_prec(myprec,e2);
    break;

  case Increment_e(e2,PreInc):  dump("++"); dumpexp_prec(myprec,e2); break;
  case Increment_e(e2,PreDec):  dump("--"); dumpexp_prec(myprec,e2); break;
  case Increment_e(e2,PostInc): dumpexp_prec(myprec,e2); dump("++"); break;
  case Increment_e(e2,PostDec): dumpexp_prec(myprec,e2); dump("--"); break;

  case Conditional_e(e1,e2,e3):
    dumpexp_prec(myprec,e1);
    dump_char('?'); dumpexp_prec(0,e2);
    dump_char(':'); dumpexp_prec(myprec,e3);
    break;

  case SeqExp_e(e1,e2):
    dumpexp_prec(myprec,e1); dump_char(','); dumpexp_prec(myprec,e2); break;

  case UnknownCall_e(e1,es): fallthru(e1,es);
  case FnCall_e(e1,es):
    dumpexp_prec(myprec,e1);
    dump_nospace("(");
    dumpexps_prec(20,es);
    dump_nospace(")");
    break;

  case Throw_e(e1): dump("throw"); dumpexp_prec(myprec,e1); break;

  case NoInstantiate_e(e1): fallthru(e1);
  case Instantiate_e(e1,_): dumpexp_prec(inprec,e1); break;

  case Cast_e(t,e1):
    dump_char('('); dumptyp(t); dump_char(')'); dumpexp_prec(myprec,e1);
    break;

  case Address_e(e1):
    dump_char('&'); dumpexp_prec(myprec,e1); break;

  case New_e(e1):
    dump("new "); dumpexp_prec(myprec,e1); break;

  case Sizeoftyp_e(t):
    dump("sizeof("); dumptyp(t); dump_char(')'); break;

  case Sizeofexp_e(e1):
    dump("sizeof("); dumpexp_prec(myprec,e1); dump_char(')'); break;

  case Deref_e(e1):
    dump_char('*'); dumpexp_prec(myprec,e1); break;

  case StructMember_e(e1,n):
    dumpexp_prec(myprec,e1); dump_char('.');  dump_nospace(*n);
    break;

  case StructArrow_e(e1,n):
    dumpexp_prec(myprec,e1); dump_nospace("->"); dump_nospace(*n);
    break;

  case Subscript_e(e1,e2):
    dumpexp_prec(myprec,e1);
    dump_char('['); dumpexp(e2); dump_char(']'); break;

  case Tuple_e(es):
    dump("$("); dumpexps_prec(20,es); dump_char(')'); break;

  case CompoundLit_e(vat,des):
    dump_char('(');
    dumptyp((*vat)[2]); // OK to ignore qualifiers??
    dump_char(')');
    group(dumpde,des,"{","}",",");
    break;

  case Array_e(des):  
    group(dumpde,des,"{","}",",");
    break;

  case Comprehension_e(vd,e1,e2):
    dump("new {for"); dump_str((*vd->name)[1]); dump_char('<'); dumpexp(e1);
    dump_char(':'); dumpexp(e2); dump_char('}');
    break;

  case Struct_e(n,_,des,_):
    dumpqvar(n);
    group(dumpde,des,"{","}",",");
    break;

  case Enum_e(_,_,es,_,ef): fallthru(es,ef);
  case Xenum_e(_,es,_,ef):
    dumpqvar(ef->name);
    if (es != null) group(dumpexp,es,"(",")",",");
    break;

  case Malloc_e(ma):
    dump("malloc(sizeof(");
    switch(ma) {
    case Typ_m(t):         dumptyp(t); break;
    case Enum_m(_,ef):     fallthru(ef);
    case Xenum_m(_,ef):    fallthru(ef->name);
    case Unresolved_m(qv): dumpqvar(qv); break;
    }
    dump("))");
    break;

  case UnresolvedMem_e(n,des):
    // Currently n is always null from the parser ???
    group(dumpde, des, "{","}",",");
    break;

  case StmtExp_e(s): dump_nospace("({"); dumpstmt(s); dump_nospace("})"); break;

  case Codegen_e(fd):
    dump("codegen(");
    dumpdecl(new Decl(Fn_d(fd),e->loc));
    dump(")");
    break;

  case Fill_e(e1): dump("fill("); dumpexp(e1); dump(")"); break;

  }
  if(inprec >= myprec)
    dump_char(')');
}

void dumpexp(exp e) {
  dumpexp_prec(0,e);
}

void dumpswitchclauses(list_t<switch_clause> scs) {
  for(; scs != null; scs = scs->tl) {
    let c = scs->hd;
    if(c->where_clause == null && c->pattern->r == Wild_p)
      dump("default:");
    else {
      dump("case");
      dumppat(c->pattern);
      if(c->where_clause != null) {
	dump("&&");
	dumpexp((exp)c->where_clause);
      }
      dump_nospace(":");
    }
    dumpstmt(c->body);
  }
}

void dumpstmt(stmt s) {
  switch(s->r) {
  case Skip_s:   dump_semi(); break;
  case Exp_s(e): dumpexp(e); dump_semi(); break;
    // FIX:  gcc only allows declarations to be used at the beginning
    // of blocks, so we force some explicit blocks to be written below.
    // It is verbose for Cyclone; maybe it should be controlled by a flag.
  case Seq_s(s1,s2):
    if(Absynpp::is_declaration(s1)) {
      dump_char('{'); dumpstmt(s1); dump_char('}');
    } else
      dumpstmt(s1);
    if(Absynpp::is_declaration(s2)) {
      dump_char('{'); dumpstmt(s2); dump_char('}');
    } else
      dumpstmt(s2);
    break;
  case Return_s(null): dump("return;"); break;
  case Return_s(e): dump("return"); dumpexp((exp)e); dump_semi(); break;
  case IfThenElse_s(e,s1,s2):
    dump("if("); dumpexp(e); dump_nospace("){");
    dumpstmt(s1);
    dump_char('}');
    switch (s2->r) {
    case Skip_s: break;
    default: dump("else{"); dumpstmt(s2); dump_char('}'); break;
    }
    break;
  case While_s($(e,_),s1):
    dump("while("); dumpexp(e); dump_nospace(") {");
    dumpstmt(s1);
    dump_char('}');
    break;
  case Break_s(_):         dump("break;");        break;
  case Continue_s(_):      dump("continue;");     break;
  case Goto_s(x,_):        dump("goto"); dump_str(x); dump_semi(); break;
  case Fallthru_s(null,_): dump("fallthru;");     break;
  case Fallthru_s(es,_):
    dump("fallthru("); dumpexps_prec(20,es); dump_nospace(");"); break;

  case For_s(e1,$(e2,_),$(e3,_),s1):
    dump("for("); dumpexp(e1);dump_semi(); dumpexp(e2);dump_semi(); dumpexp(e3);
    dump_nospace("){"); dumpstmt(s1); dump_char('}');
    break;
  case Switch_s(e,ss):
    dump("switch("); dumpexp(e); dump_nospace("){");
    dumpswitchclauses(ss);
    dump_char('}');
    break;

  case Decl_s(d,s1): dumpdecl(d);    dumpstmt(s1); break;
  case Cut_s(s1):    dump("cut");    dumpstmt(s1); break;
  case Splice_s(s1): dump("splice"); dumpstmt(s1); break;

  case Label_s(x,s1):
    // FIX:  gcc does not allow declarations to be used immediately after
    // labels.  This next case forces an explicit block to be written.
    // It is verbose for Cyclone; maybe it should be controlled by a flag.
    if(Absynpp::is_declaration(s1)) {
      dump_str(x); dump_nospace(": {"); dumpstmt(s1); dump_char('}');
    } else {
      dump_str(x); dump_char(':'); dumpstmt(s1);
    }
    break;

  case Do_s(s1,$(e,_)):
    dump("do {"); dumpstmt(s1); 
    dump_nospace("} while ("); dumpexp(e); dump_nospace(");");
    break;

  case TryCatch_s(s1,ss):
    dump("try"); dumpstmt(s1); dump("catch {");
    dumpswitchclauses(ss); dump_char('}');
    break;
  }
}

void dumpdp($(list_t<designator>,pat)@ dp) {
  egroup(dumpdesignator,(*dp)[0],"","=","=");
  dumppat((*dp)[1]);
}

void dumppat(pat p) {
  switch(p->r) {
  case Wild_p: dump_char('_');    break;
  case Null_p: dump("null"); break;
  case Int_p(Signed,i):   dump(xprintf("%d",i)); break;
  case Int_p(Unsigned,i): dump(xprintf("%u",i)); break;
  case Char_p(ch):
    dump("'"); dump_nospace(Absynpp::char_escape(ch)); dump_nospace("'"); break;
  case Float_p(x):      dump(x);            break;
  case Var_p(vd):       dumpqvar(vd->name); break;
  case Tuple_p(ts):     group(dumppat,ts,"$(",")",","); break;
  case Pointer_p(p2):   dump("&"); dumppat(p2); break;
  case Reference_p(vd): dump("*"); dumpqvar(vd->name); break;
  case UnknownId_p(q):  dumpqvar(q); break;
  case UnknownCall_p(q,tvs,ps):
    dumpqvar(q); dumptvars(tvs); group(dumppat,ps,"(",")",","); break;
  case UnknownFields_p(q,tvs,dps):
    dumpqvar(q); dumptvars(tvs); group(dumpdp,dps,"{","}",","); break;
  case Struct_p(sd,_,tvs,dps):
    if(sd->name != null)
      dumpqvar(sd->name->v);
    dumptvars(tvs);
    group(dumpdp,dps,"{","}",",");
    break;
  case Enum_p(n,_,tvs,ps,_,_): fallthru(n,tvs,ps);
  case Xenum_p(n,tvs,ps,_,_):
    dumpqvar(n); dumptvars(tvs);
    if (ps != null) group(dumppat,ps,"(",")",",");
    break;
  }
}

void dumpenumfield(enumfield ef) {
  dumpqvar(ef->name);
  if(ef->tag != null) {
    dump_char('=');
    dumpexp((exp)ef->tag);
  }
  if(ef->typs != null)
    dumpargs(ef->typs);
}
void dumpenumfields(list_t<enumfield> fields) {
  dump_sep(dumpenumfield,fields,",");
}

void dumpstructfields(list_t<structfield_t> fields) {
  for(; fields != null; fields = fields->tl) {
    let &Structfield{name,tq,type,width,atts} = fields->hd;
    dumptqtd(tq,type,dump_str,name);
    dumpatts(atts);
    if (width != null) {
      dump_char(':');
      dumpexp(width->v);
    }
    dump_semi();
  }
}

void dumptypedefname(typedefdecl td) {
  dumpqvar(td->name);
  dumptvars(td->tvs);
}

static void dump_atts_qvar(fndecl fd) {
  dumpatts(fd->attributes);
  dumpqvar(fd->name);
}

void dumpdecl(decl d) {
  switch(d->r) {
  case Fn_d(fd):
    if(fd->is_inline) dump("inline");
    dumpscope(fd->sc);
    typ t = FnType(FnInfo{fd->tvs, fd->effect, fd->ret_type,
                          List::map(Absynpp::arg_mk_opt,fd->args), 
                          fd->varargs, null});
    dumptqtd(null,t,dump_atts_qvar,fd);
    dump_char('{');
    dumpstmt(fd->body);
    dump_char('}');
    break;
  case Struct_d(sd):
    dumpscope(sd->sc);
    dump("struct");
    if(sd->name != null) dumpqvar(sd->name->v);
    dumptvars(sd->tvs);
    if(sd->fields == null)
      dump_semi();
    else {
      dump_char('{');
      dumpstructfields(sd->fields->v);
      dump("}");
      dumpatts(sd->attributes);
      dump(";");
    }
    break;
  case Union_d(ud):
    dumpscope(ud->sc);
    dump("union");
    if(ud->name != null) dumpqvar(ud->name->v);
    dumptvars(ud->tvs);
    if(ud->fields == null)
      dump_semi();
    else {
      dump_char('{');
      dumpstructfields(ud->fields->v);
      dump("}");
      dumpatts(ud->attributes);
      dump(";");
    }
    break;
  case Var_d(&Vardecl(sc,name,tq,type,initializer,shadow_depth,_,atts)):
    // FIX: use shadow_depth information
    dumpscope(sc);
    dumptqtd(tq,type,dumpqvar,name);
    dumpatts(atts);
    if(initializer != null) {
      dump_char('=');
      dumpexp((exp)initializer);
    }
    dump_semi();
    break;
  case Enum_d(ed):
    dumpscope(ed->sc);
    dump("enum");
    if(ed->name != null) dumpqvar(ed->name->v);
    dumptvars(ed->tvs);
    dump_char('{');
    if(ed->fields == null)
      dump_semi();
    else {
      dump_char('{');
      dumpenumfields(ed->fields->v);
      dump_nospace("};");
    }
    break;
  case Xenum_d(xed):
    dumpscope(xed->sc);
    dump("xenum");
    dumpqvar(xed->name);
    dump_char('{');
    if(xed->fields == null)
      dump_semi();
    else {
      dump_char('{');
      dumpenumfields(xed->fields);
      dump_nospace("};");
    }
    break;
  case Let_d(p,_,_,e,_):
    dump("let");
    dumppat(p);
    dump_char('=');
    dumpexp(e);
    dump_semi();
    break;
  case Typedef_d(td):
    dump("typedef");
    dumptqtd(null,td->defn,dumptypedefname,td);
    dump_semi();
    break;
  case Namespace_d(v,tdl):
    dump("namespace");
    dump_str(v);
    dump_char('{');
    for(; tdl != null; tdl = tdl->tl)
      dumpdecl(tdl->hd);
    dump_char('}');
    break;
  case Using_d(q,tdl):
    dump("using");
    dumpqvar(q);
    dump_char('{');
    for(; tdl != null; tdl = tdl->tl)
      dumpdecl(tdl->hd);
    dump_char('}');
    break;
  case ExternC_d(tdl):
    dump("extern \"C\" {");
    for(; tdl != null; tdl = tdl->tl)
      dumpdecl(tdl->hd);
    dump_char('}');
    break;
  }
}

static void dump_upperbound(exp e) {
  unsigned int i = Evexp::eval_const_uint_exp(e);
  if (i != 1) {
    dump_char('{'); dumpexp(e); dump_char('}');
  }
}

void dumptms(list_t<type_modifier> tms, void f(`a), `a a) {
  if(tms == null) {
    f(a);
    return;
  }
  switch(tms->hd) {
    // FIX?? What about tq2?
  case Pointer_mod(Nullable_ps(ue),  HeapRgn,  tq2):
    dump_char('*'); dump_upperbound(ue); dumptms(tms->tl,f,a); return;
  case Pointer_mod(NonNullable_ps(ue), HeapRgn,  tq2):
    dump_char('@'); dump_upperbound(ue); dumptms(tms->tl,f,a); return;
  case Pointer_mod(TaggedArray_ps, HeapRgn,  tq2):
    dump_char('?'); dumptms(tms->tl,f,a); return;
  case Pointer_mod(Nullable_ps(ue),  VarType(tv), tq2):
    dump_char('*'); dump_upperbound(ue); dump_str(tv->name);
    dumptms(tms->tl,f,a); return;
  case Pointer_mod(NonNullable_ps(ue), VarType(tv), tq2):
    dump_char('@'); dump_upperbound(ue);
    dump_str(tv->name); dumptms(tms->tl,f,a); return;
  case Pointer_mod(TaggedArray_ps, VarType(tv), tq2):
    dump_char('?'); dump_str(tv->name); dumptms(tms->tl,f,a); return;
  case Pointer_mod(_,_,_): throw Impossible("dumptms: bad Pointer_mod");

  default:
    bool next_is_pointer = false;
    if(tms->tl != null)
      switch (tms->tl->hd) {
      case Pointer_mod(_,_,_): next_is_pointer = true; break;
      default: break;
      }
    if(next_is_pointer)
      dump_char('(');
    dumptms(tms->tl, f, a);
    if(next_is_pointer)
      dump_char(')');
    switch(tms->hd) {
    case Carray_mod: dump("[]"); break;
    case ConstArray_mod(e):
      dump_char('['); dumpexp(e); dump_char(']'); break;
    case Function_mod(WithTypes(args,varargs,effopt)):
      dumpfunargs(args,varargs,effopt); break;
    case Function_mod(NoTypes(sl,loc)):
      group(dump_str,sl,"(",")",","); break;
    case TypeParams_mod(ts,loc,print_kinds): 
      if (print_kinds) dumpkindedtvars(ts); else dumptvars(ts); break;
    case Attributes_mod(_,atts): 
      dumpatts(atts); break;
    case Pointer_mod(nullable,tq2,_): throw Impossible("dumptms");
    }
    return;
  }
}

static struct Tqual empty_tq_v = Tqual{false,false,false};
static tqual empty_tq = &empty_tq_v;
void dumptqtd(struct Tqual * tq, typ t, void f(`a), `a a) {
  if(tq == null)
    tq = empty_tq;
  let $(tq,t,tms) = Absynpp::to_tms((tqual)tq,t);
  dumptq(tq);
  dumpntyp(t);
  dumptms(List::imp_rev(tms),f,a);
}

void dumpdecllist2file(list_t<decl> tdl, FILE @f) {
  pos = 0;
  *dump_file = f;
  for(; tdl != null; tdl = tdl->tl)
    dumpdecl(tdl->hd);
}
