
// Note that since we don't have an indent program for Cyclone, using this
// module for non-C code gives you fairly worthless stuff.  (And it hasn't
// been tested.) 

#include <core.h>
#include <stdio.h>
#include <list.h>
#include "absyn.h"
#include "absynpp.h"
#include "evexp.h"
#include "tcutil.h"

using Core;
using Stdio;
using List;
using Absyn;

namespace Absyndump;

void dumptyp(type_t);
void dumpntyp(type_t t);
void dumpexp(exp_t);
void dumpexp_prec(int,exp_t);
void dumppat(pat_t);
void dumpstmt(stmt_t);
void dumpdecl(decl_t);
void dumptms(list_t<type_modifier_t> tms, void f(`a), `a a);
void dumptqtd(tqual_t, type_t, void f(`a), `a);
void dumpstructfields(list_t<structfield_t> fields);
// really want to change this to char[] (need a control character for format
// prims and the ability to cast to untagged (from Tagged requires Toc hlep,
// from Fixed requires trivial Toc help)
typedef string_t dump_string_t;

// set by dumpdecllist2file (this module is not re-entrant)
FILE @@ dump_file = &stdout; 

void ignore(`a x) { return; }

static unsigned int pos = 0;
// It would be really nice to have a control character for untagged arrays!
// (Think of all the saved allocation for punctuation and keywords!)
void dump(dump_string_t s) {
  int sz = s.size;
  if(!s[sz-1])
    --sz;
  pos += sz+1;
  if (pos > 80) {
    pos = sz;
    fputc('\n',*dump_file);
  } else
    Stdio::fputc(' ',*dump_file);
  Stdio::file_string_write(*dump_file, s, 0, sz);
}
void dump_nospace(dump_string_t s) {
  int sz = s.size;
  if(!s[sz-1])
    --sz;
  pos += sz;
  Stdio::file_string_write(*dump_file, s, 0, sz);
}
void dump_char(int c) { // no space
  ++pos;
  Stdio::fputc(c,*dump_file);
}

// this needs to take a boxed type b/c it's used to instantiate `a
void dump_str(stringptr_t s) {
  dump(*s);
}

void dump_semi() {
  dump_char(';');
}

void dump_sep(void f(`a), list_t<`a> l, dump_string_t sep) {
  if(l == null)
    return;
  for(; l->tl != null; l = l->tl) {
    f(l->hd);
    dump_nospace(sep); // still have the unnecessary space afterwards, though
  }
  f(l->hd);
}
void dump_sep_c(void f(`b,`a), `b env, list_t<`a> l, dump_string_t sep) {
  if(l == null)
    return;
  for(; l->tl != null; l = l->tl) {
    f(env,l->hd);
    dump_nospace(sep); // still have the unnecessary space afterwards, though
  }
  f(env,l->hd);
}
void group(void f(`a), list_t<`a> l,
           dump_string_t start, dump_string_t end, dump_string_t sep) {
  dump_nospace(start);
  dump_sep(f,l,sep);
  dump_nospace(end);
}
void group_c(void f(`b,`a), `b env, list_t<`a> l,
             dump_string_t start, dump_string_t end, dump_string_t sep) {
  dump_nospace(start);
  dump_sep_c(f,env,l,sep);
  dump_nospace(end);
}
void egroup(void f(`a), list_t<`a> l,
            dump_string_t start, dump_string_t end, dump_string_t sep) {
  if(l != null)
    group(f,l,start,end,sep);
}

// is this backwards for nested namespaces? Consistent either way, but
// should do the right thing!
void dumpqvar(qvar_t v) {
  let nsl = null;
  switch ((*v)[0]) {
  case Loc_n:       fallthru;
  case &Rel_n(null): fallthru;
  case &Abs_n(null): dump_str((*v)[1]); return;
  case &Rel_n(x):    fallthru(x);
  case &Abs_n(x):    nsl = x; break;
  }
  dump_str(nsl->hd);
  for(nsl = nsl->tl; nsl != null; nsl = nsl->tl) {
    // Note: This is the most common reason the result goes over 80 columns,
    //       but who really cares.
    if(Absynpp::qvar_to_Cids) dump_char('_');
    else dump_nospace("::");
    dump_nospace(*(nsl->hd));
  }
  if(Absynpp::qvar_to_Cids) dump_nospace("_");
  else dump_nospace("::");
  dump_nospace(*((*v)[1]));
}

void dumptq(tqual_t tq) {
  if(tq.q_restrict) dump("restrict");
  if(tq.q_volatile) dump("volatile");
  if(tq.q_const)    dump("const");
}

void dumpscope(scope_t sc) {
  switch (sc) {
  case Static:   dump("static"); return;
  case Public:   return;
  case Extern:   dump("extern"); return;
  case ExternC:  dump("extern \"C\""); return;
  case Abstract: dump("abstract"); return;
  }
}

void dumpkind(kind_t k) {
  switch (k) {
  case AnyKind       : dump("A"); return;
  case MemKind       : dump("M"); return;
  case BoxKind       : dump("B"); return;
  case RgnKind       : dump("R"); return;
  case EffKind       : dump("E"); return;
  }
}

void dumptps(list_t<type_t> ts) {
  egroup(dumptyp,ts,"<",">",",");
}
void dumptvar(tvar_t tv) {
  dump_str(tv->name);
}
void dumpkindedtvar(tvar_t tv) {
  dump_str(tv->name);
  switch (compress_conref(tv->kind)->v) {
  case &Eq_constr(BoxKind): break;
  case &Eq_constr(k): dump("::"); dumpkind(k); break;
  default: dump("::?"); break;
  }
}
void dumptvars(list_t<tvar_t> tvs) {
  egroup(dumptvar,tvs,"<",">",",");
}
void dumpkindedtvars(list_t<tvar_t> tvs) {
  egroup(dumpkindedtvar,tvs,"<",">",",");
}

void dumparg($(tqual_t,type_t)@ pr) {
  dumptqtd((*pr)[0],(*pr)[1],ignore,0);
}
void dumpargs(list_t<$(tqual_t,type_t)@> ts) {
  group(dumparg,ts,"(",")",",");
}

void dump_callconv(attributes_t atts) {
  for(; atts != null; atts = atts->tl)
    switch(atts->hd) {
    case Stdcall_att:  dump("_stdcall");  return;
    case Cdecl_att:    dump("_cdecl");    return;
    case Fastcall_att: dump("_fastcall"); return;
    default: break;
    }
}

void dump_noncallconv(attributes_t atts) {
  // NOTE: Only for to_VC.  Ignore a calling-convention attribute.
  bool hasatt = false;
  for(_ atts2 = atts; atts2 != null; atts2 = atts2->tl)
    switch(atts->hd) {
    case Stdcall_att:  break;
    case Cdecl_att:    break;
    case Fastcall_att: break;
    default: hasatt = true; break;
    }
  if(!hasatt)
    return;
  dump("__declspec(");
  for (; atts != null; atts = atts->tl)
    switch(atts->hd) {
    case Stdcall_att:  break;
    case Cdecl_att:    break;
    case Fastcall_att: break;
    default: dump(attribute2string(atts->hd)); break;
    }
  dump_char(')');
}

void dumpatts(attributes_t atts) {
  if (atts == null) return;
  if(Absynpp::to_VC) {
    dump_noncallconv(atts);
    return;
  }
  dump(" __attribute__((");
  for (; atts != null; atts = atts->tl) {
    dump(attribute2string(atts->hd));
    if (atts->tl != null) dump(",");
  }
  dump(")) ");
}

bool next_is_pointer(list_t<type_modifier_t> tms) {
  if (tms==null) return false;
  switch (tms->hd) {
  case &Pointer_mod(_,_,_): return true;
  default: return false;
  }
}

static void dumprgn(type_t t) {
  switch (Tcutil::compress(t)) {
  case HeapRgn: dump("`H"); break;
  default: dumpntyp(t); break;
  }
}

static $(list_t<type_t>, list_t<type_t>) effects_split(type_t t) {
  list_t<type_t> regions = null;
  list_t<type_t> effects = null;

  switch (Tcutil::compress(t)) {
  case &AccessEff(r): regions = new List(r,regions); break;
  case &JoinEff(ts):
    for (; ts != null; ts = ts->tl) {
      let $(rs,es) = effects_split(ts->hd);
      regions = List::imp_append(rs,regions);
      effects = List::imp_append(es,effects);
    }
    break;
  default: effects = new List(t,effects); break;
  }
  return $(regions, effects);
}

static void dumpeff(type_t t) {
  let $(regions,effects) = effects_split(t);
  regions = List::imp_rev(regions);
  effects = List::imp_rev(effects);
  for (; effects != null; effects = effects->tl) {
    dumpntyp(effects->hd);
    dump_char('+');
  }
  dump_char('{');
  for (; regions != null; regions = regions->tl) {
    dumprgn(regions->hd);
    if (regions->tl != null) dump_char(',');
  }
  dump_char('}');
}

// Convert a normalized typ to a doc
void dumpntyp(type_t t) {
  switch (t) {
    // The first three cases never turn up in normalized types.
  case &ArrayType(_,_,_): return;
  case &FnType(_)       : return;
  case &PointerType(_)  : return;
  case VoidType:         dump("void"); return;
  case &VarType(tv): 
    dump_str(tv->name); return; // FIX: may want explicit kinds
  case &Evar(k,null,i,_): 
    dump("%"); 
    if (k == null) dump("?"); else dumpkind(k->v); 
    dump(xprintf("(%d)",i)); return;
  case &Evar(k,&Opt(t),i,_): dumpntyp(t); return; // shouldn't happen!
  case &TunionType(TunionInfo(tu_info,ts,r)):
    switch(tu_info) {
    case &UnknownTunion(UnknownTunionInfo(n,is_x)): fallthru(n,is_x);
    case &KnownTunion(&Tuniondecl(_,n,_,_,is_x)):
      if(is_x) dump("xtunion "); else dump("tunion ");
      switch (Tcutil::compress(r)) {
      case HeapRgn: break;
      default: dumptyp(r); dump(" "); break;
      }
      dumpqvar(n);
      dumptps(ts);
      break;
    }
    break;
  case &TunionFieldType(TunionFieldInfo(tuf_info,ts)):
    switch(tuf_info) {
    case &UnknownTunionfield(UnknownTunionFieldInfo(tname,fname,is_x)):
      fallthru(tname,is_x,fname);
    case &KnownTunionfield(&Tuniondecl(_,tname,_,_,is_x),
			   &Tunionfield(fname,_,_,_,_)):
      if(is_x) dump("xtunion "); else dump("tunion ");
      dumpqvar(tname);
      dump(".");
      dumpqvar(fname);
      dumptps(ts);
      break;
    }
    break;
  case &EnumType(n,_): dump("enum "); dumpqvar(n); return;
  case &IntType(Signed,   B4): dump("int"); return;
  case &IntType(Signed,   B1): dump("signed char"); return;
  case &IntType(Unsigned, B1): dump("unsigned char"); return;
  case &IntType(Signed,   B2): dump("short"); return;
  case &IntType(Unsigned, B2): dump("unsigned short"); return;
  case &IntType(Unsigned, B4): dump("unsigned int"); return;
  case &IntType(Signed,   B8) && Absynpp::to_VC: dump("__int64"); return;
  case &IntType(Signed,   B8): dump("long long"); return;
  case &IntType(Unsigned,B8) && Absynpp::to_VC: dump("unsigned __int64");return;
  case &IntType(Unsigned, B8): dump("unsigned long long");    return;
  case FloatType:  dump("float");  return;
  case DoubleType: dump("double"); return;
  case &TupleType(ts): dump_char('$'); dumpargs(ts); return;
  case &StructType(null,ts,_):   dump("struct"); dumptps(ts); return;
  case &StructType(n,  ts,_):
    dump("struct"); dumpqvar((qvar_t)n); dumptps(ts); return;
  case &UnionType(null,ts,_):   dump("union"); dumptps(ts); return;
  case &UnionType(n,  ts,_):
    dump("union"); dumpqvar((qvar_t)n); dumptps(ts); return;
  case &AnonStructType(fs):
    dump("struct {"); dumpstructfields(fs); dump("}"); return;
  case &AnonUnionType(fs):
    dump("union {"); dumpstructfields(fs); dump("}"); return;
  case &TypedefType(n,ts,topt):  dumpqvar(n), dumptps(ts); return;
  case &RgnHandleType(rgn):
    dumprgn(rgn); return;
  case HeapRgn: return; 
  case &AccessEff(_): return;
  case &JoinEff(_): return;
  }
}

void dumpvaropt(opt_t<var_t> vo) {
  if(vo != null) dump_str(vo->v);
}
void dumpfunarg($(opt_t<var_t>,tqual_t,type_t)@ t) {
  dumptqtd((*t)[1],(*t)[2],dumpvaropt,(*t)[0]);
}
void dump_rgncmp($(type_t,type_t)@ cmp) {
  let &$(r1,r2) = cmp;
  dumptyp(r1); dump_char('<'); dumptyp(r2);
}
void dump_rgnpo(list_t<$(type_t,type_t)@> rgn_po) {
  dump_sep(dump_rgncmp,rgn_po,",");
}
void dumpfunargs(list_t<$(opt_t<var_t>,tqual_t,type_t)@> args, bool c_varargs, 
                 vararg_info_t *cyc_varargs, opt_t<type_t> effopt,
                 list_t<$(type_t,type_t)@> rgn_po) {
  dump_char('(');
  for (; args != null; args = args->tl) {
    dumpfunarg(args->hd);
    if (args->tl != null || c_varargs || cyc_varargs != null) dump_char(',');
  }
  if (c_varargs) 
    dump("...");
  else if (cyc_varargs != null) {
    let arg = new $(cyc_varargs->name, cyc_varargs->tq, cyc_varargs->type);
    dump("...");
    dumptyp(cyc_varargs->rgn);
    if (cyc_varargs->inject) dump(" inject ");
    dumpfunarg(arg);
  }
  if (effopt != null) {
    dump_semi();
    dumpeff(effopt->v);
  }
  if (rgn_po != null) {
    dump_char(':');
    dump_rgnpo(rgn_po);
  }
  dump_char(')');
}

void dumptyp(type_t t) {
  dumptqtd(Tqual(false,false,false),t,ignore,0);
}

void dumpdesignator(designator_t d) {
  switch (d) {
  case &ArrayElement(e): dump(".["); dumpexp(e); dump_char(']'); break;
  case &FieldName(v):    dump_char('.'); dump_nospace(*v); break;
  }
}

void dumpde($(list_t<designator_t>,exp_t)@ de) {
  egroup(dumpdesignator,(*de)[0],"","=","=");
  dumpexp((*de)[1]);
}

void dumpexps_prec(int inprec, list_t<exp_t> es) {
  group_c(dumpexp_prec, inprec, es, "", "", ",");
}

void dumpexp_prec(int inprec, exp_t e) {
  int myprec = Absynpp::exp_prec(e);
  if(inprec >= myprec)
    dump_nospace("(");
  switch (e->r) {
  case &Const_e(&Char_c(sg,ch)):
    dump_char('\''); dump_nospace(Absynpp::char_escape(ch)); dump_char('\''); 
    break;
  case &Const_e(&Short_c(sg,s)):
    dump(string_of_int(s)); break;
  case &Const_e(&Int_c(Signed,i)):
    dump(string_of_int(i)); break;
  case &Const_e(&Int_c(Unsigned,i)):
    dump(string_of_int(i)); dump_nospace("u"); break;
  case &Const_e(&LongLong_c(sg,i)):
    dump("<<FIX LONG LONG CONSTANT>>"); break; // FIX
  case &Const_e(&Float_c(x)):    dump(x);      break;
  case &Const_e(Null_c):        dump("null"); break;
  case &Const_e(&String_c(s)):
    dump_char('"'); dump_nospace(Absynpp::string_escape(s)); dump_char('"');
    break;

  case &UnknownId_e(x): fallthru(x);
  case &Var_e(x,_):     dumpqvar(x); break;

  case &Primop_e(p,es):
    let pstr = Absynpp::prim2str(p);
    if(!is_format_prim(p)) {
      switch (List::length(es)) {
      case 1:
	if (p == (primop_t)Size) {
	  dumpexp_prec(myprec,es->hd);
	  dump(".size");
	} else {
	  dump(pstr);
	  dumpexp_prec(myprec,es->hd);
	}
	break;
      case 2:
	dumpexp_prec(myprec,es->hd);
	dump(pstr);
	dumpexp_prec(myprec,es->tl->hd);
	break;
      default: 
        throw new Failure("Absyndump -- Bad number of arguments to primop");
      }
    } else {
      dump(pstr); dump_nospace("("); dumpexps_prec(20,es); dump_nospace(")");
    }
    break;

  case &AssignOp_e(e1,popt,e2):
    dumpexp_prec(myprec,e1);
    if(popt != null)
      dump(Absynpp::prim2str(popt->v));
    dump_nospace("=");
    dumpexp_prec(myprec,e2);
    break;

  case &Increment_e(e2,PreInc):  dump("++"); dumpexp_prec(myprec,e2); break;
  case &Increment_e(e2,PreDec):  dump("--"); dumpexp_prec(myprec,e2); break;
  case &Increment_e(e2,PostInc): dumpexp_prec(myprec,e2); dump("++"); break;
  case &Increment_e(e2,PostDec): dumpexp_prec(myprec,e2); dump("--"); break;

  case &Conditional_e(e1,e2,e3):
    dumpexp_prec(myprec,e1);
    dump_char('?'); dumpexp_prec(0,e2);
    dump_char(':'); dumpexp_prec(myprec,e3);
    break;

  case &SeqExp_e(e1,e2):
    // DAN: put in parens because in initializers , doesn't mean SeqExp and
    // our recursive descent doesn't know if we're in an initializer.
    dump_char('(');
    dumpexp_prec(myprec,e1); dump_char(','); dumpexp_prec(myprec,e2); 
    dump_char(')');
    break;

  case &UnknownCall_e(e1,es): fallthru(e1,es);
  case &FnCall_e(e1,es,_):
    dumpexp_prec(myprec,e1);
    dump_nospace("(");
    dumpexps_prec(20,es);
    dump_nospace(")");
    break;

  case &Throw_e(e1): dump("throw"); dumpexp_prec(myprec,e1); break;

  case &NoInstantiate_e(e1): fallthru(e1);
  case &Instantiate_e(e1,_): dumpexp_prec(inprec,e1); break;

  case &Cast_e(t,e1):
    dump_char('('); dumptyp(t); dump_char(')'); dumpexp_prec(myprec,e1);
    break;

  case &Address_e(e1):
    dump_char('&'); dumpexp_prec(myprec,e1); break;

  case &New_e(ropt,e1):
    dump("new "); dumpexp_prec(myprec,e1); break;

  case &Sizeoftyp_e(t):
    dump("sizeof("); dumptyp(t); dump_char(')'); break;

  case &Sizeofexp_e(e1):
    dump("sizeof("); dumpexp_prec(myprec,e1); dump_char(')'); break;

  case &Offsetof_e(t,n):
    dump("offsetof("); dumptyp(t); dump_char(','); dump_nospace(*n);
    dump_char(')'); 
    break;

  case &Deref_e(e1):
    dump_char('*'); dumpexp_prec(myprec,e1); break;

  case &StructMember_e(e1,n):
    dumpexp_prec(myprec,e1); dump_char('.');  dump_nospace(*n);
    break;

  case &StructArrow_e(e1,n):
    dumpexp_prec(myprec,e1); dump_nospace("->"); dump_nospace(*n);
    break;

  case &Subscript_e(e1,e2):
    dumpexp_prec(myprec,e1);
    dump_char('['); dumpexp(e2); dump_char(']'); break;

  case &Tuple_e(es):
    dump("$("); dumpexps_prec(20,es); dump_char(')'); break;

  case &CompoundLit_e(vat,des):
    dump_char('(');
    dumptyp((*vat)[2]); // OK to ignore qualifiers??
    dump_char(')');
    group(dumpde,des,"{","}",",");
    break;

  case &Array_e(des):  
    group(dumpde,des,"{","}",",");
    break;

  case &Comprehension_e(vd,e1,e2):
    dump("new {for"); dump_str((*vd->name)[1]); dump_char('<'); dumpexp(e1);
    dump_char(':'); dumpexp(e2); dump_char('}');
    break;

  case &Struct_e(n,_,des,_):
    dumpqvar(n);
    group(dumpde,des,"{","}",",");
    break;

  case &AnonStruct_e(_,des):
    group(dumpde,des,"{","}",",");
    break;

  case &Tunion_e(_,_,es,_,tuf):
    dumpqvar(tuf->name);
    if (es != null) group(dumpexp,es,"(",")",",");
    break;

  case &Enum_e(n,_,_): dumpqvar(n); break;

  case &Malloc_e(ropt,t):
    if (ropt != null) {
      dump("rmalloc(");
      dumpexp((exp_t)ropt); dump(",");
    } else {
      dump("malloc(");
    }
    dump("sizeof(");
    dumptyp(t); 
    dump("))");
    break;

  case &UnresolvedMem_e(n,des):
    // Currently n is always null from the parser ???
    group(dumpde, des, "{","}",",");
    break;

  case &StmtExp_e(s): dump_nospace("({"); dumpstmt(s); dump_nospace("})"); break;

  case &Codegen_e(fd):
    dump("codegen(");
    dumpdecl(new Decl(new Fn_d(fd),e->loc));
    dump(")");
    break;

  case &Fill_e(e1): dump("fill("); dumpexp(e1); dump(")"); break;

  }
  if(inprec >= myprec)
    dump_char(')');
}

void dumpexp(exp_t e) {
  dumpexp_prec(0,e);
}

void dumpswitchclauses(list_t<switch_clause_t> scs) {
  for(; scs != null; scs = scs->tl) {
    let c = scs->hd;
    if(c->where_clause == null && c->pattern->r == (raw_pat_t)Wild_p)
      dump("default:");
    else {
      dump("case");
      dumppat(c->pattern);
      if(c->where_clause != null) {
	dump("&&");
	dumpexp((exp_t)c->where_clause);
      }
      dump_nospace(":");
    }
    dumpstmt(c->body);
  }
}

void dumpstmt(stmt_t s) {
  switch(s->r) {
  case Skip_s:   dump_semi(); break;
  case &Exp_s(e): dumpexp(e); dump_semi(); break;
    // FIX:  gcc only allows declarations to be used at the beginning
    // of blocks, so we force some explicit blocks to be written below.
    // It is verbose for Cyclone; maybe it should be controlled by a flag.
  case &Seq_s(s1,s2):
    if(Absynpp::is_declaration(s1)) {
      dump_char('{'); dumpstmt(s1); dump_char('}');
    } else
      dumpstmt(s1);
    if(Absynpp::is_declaration(s2)) {
      dump_char('{'); dumpstmt(s2); dump_char('}');
    } else
      dumpstmt(s2);
    break;
  case &Return_s(null): dump("return;"); break;
  case &Return_s(e): dump("return"); dumpexp((exp_t)e); dump_semi(); break;
  case &IfThenElse_s(e,s1,s2):
    dump("if("); dumpexp(e); dump_nospace("){");
    dumpstmt(s1);
    dump_char('}');
    switch (s2->r) {
    case Skip_s: break;
    default: dump("else{"); dumpstmt(s2); dump_char('}'); break;
    }
    break;
  case &While_s($(e,_),s1):
    dump("while("); dumpexp(e); dump_nospace(") {");
    dumpstmt(s1);
    dump_char('}');
    break;
  case &Break_s(_):         dump("break;");        break;
  case &Continue_s(_):      dump("continue;");     break;
  case &Goto_s(x,_):        dump("goto"); dump_str(x); dump_semi(); break;

  case &For_s(e1,$(e2,_),$(e3,_),s1):
    dump("for("); dumpexp(e1);dump_semi(); dumpexp(e2);dump_semi(); dumpexp(e3);
    dump_nospace("){"); dumpstmt(s1); dump_char('}');
    break;
  case &Switch_s(e,ss):
    dump("switch("); dumpexp(e); dump_nospace("){");
    dumpswitchclauses(ss);
    dump_char('}');
    break;

  case &Decl_s(d,s1): dumpdecl(d); dumpstmt(s1); break;

  case &Label_s(x,s1):
    // FIX:  gcc does not allow declarations to be used immediately after
    // labels.  This next case forces an explicit block to be written.
    // It is verbose for Cyclone; maybe it should be controlled by a flag.
    if(Absynpp::is_declaration(s1)) {
      dump_str(x); dump_nospace(": {"); dumpstmt(s1); dump_char('}');
    } else {
      dump_str(x); dump_char(':'); dumpstmt(s1);
    }
    break;

  case &Do_s(s1,$(e,_)):
    dump("do {"); dumpstmt(s1); 
    dump_nospace("} while ("); dumpexp(e); dump_nospace(");");
    break;

  case &SwitchC_s(e,ss): 
    dump("switch \"C\" ("); dumpexp(e); dump_nospace("){");
    for(; ss != null; ss = ss->tl) {
      let &SwitchC_clause(e,s,_) = ss->hd;
      if(e == null)
	dump("default: ");
      else {
	dump("case "); dumpexp((exp_t)e); dump_char(':');
      }
      dumpstmt(s);
    }
    dump_char('}');
    break;

  case &Fallthru_s(null,_): dump("fallthru;");     break;
  case &Fallthru_s(es,_):
    dump("fallthru("); dumpexps_prec(20,es); dump_nospace(");"); break;

  case &TryCatch_s(s1,ss):
    dump("try"); dumpstmt(s1); dump("catch {");
    dumpswitchclauses(ss); dump_char('}');
    break;

  case &Region_s(tv,vd,ss):
    dump("region<"); dumptvar(tv); dump("> "); dumpqvar(vd->name);
    dump("{"); dumpstmt(ss); dump("}");
    break;

  case &Cut_s(s1):    dump("cut");    dumpstmt(s1); break;
  case &Splice_s(s1): dump("splice"); dumpstmt(s1); break;
  }
}

void dumpdp($(list_t<designator_t>,pat_t)@ dp) {
  egroup(dumpdesignator,(*dp)[0],"","=","=");
  dumppat((*dp)[1]);
}

void dumppat(pat_t p) {
  switch(p->r) {
  case Wild_p: dump_char('_');    break;
  case Null_p: dump("null"); break;
  case &Int_p(Signed,i):   dump(xprintf("%d",i)); break;
  case &Int_p(Unsigned,i): dump(xprintf("%u",i)); break;
  case &Char_p(ch):
    dump("'"); dump_nospace(Absynpp::char_escape(ch)); dump_nospace("'"); break;
  case &Float_p(x):      dump(x);            break;
  case &Var_p(vd):       dumpqvar(vd->name); break;
  case &Tuple_p(ts):     group(dumppat,ts,"$(",")",","); break;
  case &Pointer_p(p2):   dump("&"); dumppat(p2); break;
  case &Reference_p(vd): dump("*"); dumpqvar(vd->name); break;
  case &UnknownId_p(q):  dumpqvar(q); break;
  case &UnknownCall_p(q,tvs,ps):
    dumpqvar(q); dumptvars(tvs); group(dumppat,ps,"(",")",","); break;
  case &UnknownFields_p(q,tvs,dps):
    dumpqvar(q); dumptvars(tvs); group(dumpdp,dps,"{","}",","); break;
  case &Struct_p(sd,_,tvs,dps):
    if(sd->name != null)
      dumpqvar(sd->name->v);
    dumptvars(tvs);
    group(dumpdp,dps,"{","}",",");
    break;
  case &Tunion_p(_,tuf,tvs,ps):
    dumpqvar(tuf->name); 
    dumptvars(tvs);
    if (ps != null) group(dumppat,ps,"(",")",",");
    break;
  case &Enum_p(_,ef): dumpqvar(ef->name); break;
  }
}

void dumptunionfield(tunionfield_t ef) {
  dumpqvar(ef->name);
  if(ef->typs != null)
    dumpargs(ef->typs);
}
void dumptunionfields(list_t<tunionfield_t> fields) {
  dump_sep(dumptunionfield,fields,",");
}
void dumpenumfield(enumfield_t ef) {
  dumpqvar(ef->name);
  if (ef->tag != null) {
    dump(" = ");
    dumpexp((exp_t)ef->tag);
  }
}
void dumpenumfields(list_t<enumfield_t> fields) {
  dump_sep(dumpenumfield,fields,",");
}

void dumpstructfields(list_t<structfield_t> fields) {
  for(; fields != null; fields = fields->tl) {
    let &Structfield{name,tq,type,width,atts} = fields->hd;
    dumptqtd(tq,type,dump_str,name);
    dumpatts(atts);
    if (width != null) {
      dump_char(':');
      dumpexp(width->v);
    }
    dump_semi();
  }
}

void dumptypedefname(typedefdecl_t td) {
  dumpqvar(td->name);
  dumptvars(td->tvs);
}

static void dump_atts_qvar(fndecl_t fd) {
  dumpatts(fd->attributes);
  dumpqvar(fd->name);
}
static void dump_callconv_qvar($(attribute_t,qvar_t)@`r pr) {
  switch((*pr)[0]) {
  case Unused_att: break;
  case Stdcall_att:  dump("_stdcall");  break;
  case Cdecl_att:    dump("_cdecl");    break;
  case Fastcall_att: dump("_fastcall"); break;
  default: break;
  }
  dumpqvar((*pr)[1]);
}
static void dump_callconv_fdqvar(fndecl_t fd) {
  dump_callconv(fd->attributes);
  dumpqvar(fd->name);
}

static void dumpids(list_t<vardecl_t> vds) {
  for (; vds != null; vds = vds->tl) {
    dumpqvar(vds->hd->name);
    if (vds->tl != null) dump_char(',');
  }
}

void dumpdecl(decl_t d) {
  switch(d->r) {
  case &Fn_d(fd):
    if(Absynpp::to_VC)
      dumpatts(fd->attributes);
    if(fd->is_inline) 
      if(Absynpp::to_VC)
	dump("__inline");
      else
	dump("inline");
    dumpscope(fd->sc);
    type_t t = new FnType(FnInfo{fd->tvs, fd->effect, fd->ret_type,
                                 List::map(Absynpp::arg_mk_opt,fd->args), 
                                 fd->c_varargs, fd->cyc_varargs,
                                 fd->rgn_po, null});
    dumptqtd(Tqual(false,false,false),t,
	     Absynpp::to_VC ? dump_callconv_fdqvar : dump_atts_qvar,fd);
    dump_char('{');
    dumpstmt(fd->body);
    dump_char('}');
    break;
  case &Struct_d(sd):
    dumpscope(sd->sc);
    dump("struct");
    if(sd->name != null) dumpqvar(sd->name->v);
    dumptvars(sd->tvs);
    if(sd->fields == null)
      dump_semi();
    else {
      dump_char('{');
      dumpstructfields(sd->fields->v);
      dump("}");
      dumpatts(sd->attributes);
      dump(";");
    }
    break;
  case &Union_d(ud):
    dumpscope(ud->sc);
    dump("union");
    if(ud->name != null) dumpqvar(ud->name->v);
    dumptvars(ud->tvs);
    if(ud->fields == null)
      dump_semi();
    else {
      dump_char('{');
      dumpstructfields(ud->fields->v);
      dump("}");
      dumpatts(ud->attributes);
      dump(";");
    }
    break;
  case &Var_d(&Vardecl(sc,name,tq,type,initializer,_,atts)):
    if(Absynpp::to_VC) {
      dumpatts(atts);
      dumpscope(sc);
      let $(tq,t,tms) = Absynpp::to_tms(tq,type);
      dumptq(tq);
      // a kludge -- seems to work -- Unused_att is just a hack for "no spec"
      attribute_t call_conv = Unused_att;
      for(_ tms2 = tms; tms2 != null; tms2 = tms2->tl)
	switch(tms2->hd) {
	case &Attributes_mod(_,atts):
	  for(; atts != null; atts = atts->tl)
	    switch(atts->hd) {
	    case Stdcall_att:  call_conv = Stdcall_att;  break;
	    case Cdecl_att:    call_conv = Cdecl_att;    break;
	    case Fastcall_att: call_conv = Fastcall_att; break;
	    default: break;
	    }
	  break;
	default: break;
	}
      dumptq(tq);
      dumpntyp(t);
      let pr = $(call_conv,name);
      dumptms(List::imp_rev(tms), dump_callconv_qvar, &pr);
    } else {
      dumpscope(sc);
      dumptqtd(tq, type, dumpqvar, name);
      dumpatts(atts);
    }
    if(initializer != null) {
      dump_char('=');
      dumpexp((exp_t)initializer);
    }
    dump_semi();
    break;
  case &Tunion_d(&Tuniondecl(sc,name,tvs,fields,is_xtunion)):
    dumpscope(sc);
    if(is_xtunion)
      dump("xtunion ");
    else
      dump("tunion ");
    dumpqvar(name);
    dumptvars(tvs);
    if(fields == null)
      dump_semi();
    else  {
      dump_char('{');
      dumptunionfields(fields->v);
      dump_nospace("};");
    }
    break;
  case &Enum_d(&Enumdecl{sc,nm,fields}):
    dumpscope(sc);
    dump("enum ");
    dumpqvar(nm);
    if (fields == null)
      dump_semi();
    else {
      dump_char('{');
      dumpenumfields(fields->v);
      dump_nospace("};");
    }
    return;
  case &Let_d(p,_,_,e,_):
    dump("let");
    dumppat(p);
    dump_char('=');
    dumpexp(e);
    dump_semi();
    break;
  case &Letv_d(vds):
    dump("let ");
    dumpids(vds);
    dump_semi();
    break;
  case &Typedef_d(td):
    if(!Absynpp::expand_typedefs) {
      dump("typedef");
      dumptqtd(Tqual(false,false,false),td->defn,dumptypedefname,td);
      dump_semi();
    }
    break;
  case &Namespace_d(v,tdl):
    dump("namespace");
    dump_str(v);
    dump_char('{');
    for(; tdl != null; tdl = tdl->tl)
      dumpdecl(tdl->hd);
    dump_char('}');
    break;
  case &Using_d(q,tdl):
    dump("using");
    dumpqvar(q);
    dump_char('{');
    for(; tdl != null; tdl = tdl->tl)
      dumpdecl(tdl->hd);
    dump_char('}');
    break;
  case &ExternC_d(tdl):
    dump("extern \"C\" {");
    for(; tdl != null; tdl = tdl->tl)
      dumpdecl(tdl->hd);
    dump_char('}');
    break;
  }
}

static void dump_upperbound(exp_t e) {
  unsigned int i = Evexp::eval_const_uint_exp(e);
  if (i != 1) {
    dump_char('{'); dumpexp(e); dump_char('}');
  }
}

void dumptms(list_t<type_modifier_t> tms, void f(`a), `a a) {
  if(tms == null) {
    f(a);
    return;
  }
  switch(tms->hd) {
    // FIX?? What about tq2?
  case &Pointer_mod(&Nullable_ps(ue),  HeapRgn,  tq2):
    dump_char('*'); dump_upperbound(ue); dumptms(tms->tl,f,a); return;
  case &Pointer_mod(&NonNullable_ps(ue), HeapRgn,  tq2):
    dump_char('@'); dump_upperbound(ue); dumptms(tms->tl,f,a); return;
  case &Pointer_mod(TaggedArray_ps, HeapRgn,  tq2):
    dump_char('?'); dumptms(tms->tl,f,a); return;
  case &Pointer_mod(&Nullable_ps(ue),  &VarType(tv), tq2):
    dump_char('*'); dump_upperbound(ue); dump_str(tv->name);
    dumptms(tms->tl,f,a); return;
  case &Pointer_mod(&NonNullable_ps(ue), &VarType(tv), tq2):
    dump_char('@'); dump_upperbound(ue);
    dump_str(tv->name); dumptms(tms->tl,f,a); return;
  case &Pointer_mod(TaggedArray_ps, &VarType(tv), tq2):
    dump_char('?'); dump_str(tv->name); dumptms(tms->tl,f,a); return;
  case &Pointer_mod(_,_,_): throw new Impossible("dumptms: bad Pointer_mod");

  default:
    bool next_is_pointer = false;
    if(tms->tl != null)
      switch (tms->tl->hd) {
      case &Pointer_mod(_,_,_): next_is_pointer = true; break;
      default: break;
      }
    if(next_is_pointer)
      dump_char('(');
    dumptms(tms->tl, f, a);
    if(next_is_pointer)
      dump_char(')');
    switch(tms->hd) {
    case Carray_mod: dump("[]"); break;
    case &ConstArray_mod(e):
      dump_char('['); dumpexp(e); dump_char(']'); break;
    case &Function_mod(&WithTypes(args,c_varargs,cyc_varargs,effopt,rgn_po)):
      dumpfunargs(args,c_varargs,cyc_varargs,effopt,rgn_po); break;
    case &Function_mod(&NoTypes(sl,loc)):
      group(dump_str,sl,"(",")",","); break;
    case &TypeParams_mod(ts,loc,print_kinds): 
      if (print_kinds) dumpkindedtvars(ts); else dumptvars(ts); break;
    case &Attributes_mod(_,atts): dumpatts(atts); break;
    case &Pointer_mod(nullable,tq2,_): throw new Impossible("dumptms");
    }
    return;
  }
}

void dumptqtd(tqual_t tq, type_t t, void f(`a), `a a) {
  let $(tq,t,tms) = Absynpp::to_tms(tq,t);
  dumptq(tq);
  dumpntyp(t);
  dumptms(List::imp_rev(tms),f,a);
}

void dumpdecllist2file(list_t<decl_t> tdl, FILE @f) {
  pos = 0;
  *dump_file = f;
  for(; tdl != null; tdl = tdl->tl)
    dumpdecl(tdl->hd);
}
