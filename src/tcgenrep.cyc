/* Generating typereps from types.
   Copyright (C) 2001 Greg Morrisett, AT&T
   This file is part of the Cyclone compiler.

   The Cyclone compiler is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   The Cyclone compiler is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with the Cyclone compiler; see the file COPYING. If not,
   write to the Free Software Foundation, Inc., 59 Temple Place -
   Suite 330, Boston, MA 02111-1307, USA. */

#include <core.h>
#include <ctype.h>
#include <list.h>
#include <dict.h>
#include <string.h>
#include <hashtable.h>
#include <position.h>
#include <typerep.h>
#include <time.h>
#include "absyn.h"
#include "absynpp.h"
#include "evexp.h"
#include "tcutil.h"
#include "tcenv.h"
#include "toc.h"



using Absyn;
using Absynpp;
using Core;
using Tcenv;
using Dict;
using List;
using Position;

namespace Tcgenrep;

/* the dictionary entries should be indexed by types and be a three-tuple
     1) A LIST of declarations
     2) An expression which evaluates to the appropriate Typestruct
     3) A list of pointers to other three tuples that these declarations
        depend on.
     4) A flag indicating whether this series of declarations has
        been emitted yet for the current file.

     At the end, we pull out the three tuples and sort them
     topologically.  We then reverse the list and have our list of
     declarations to return.
  */



typedef struct RepInfo {
  list_t<decl_t> decls;
  exp_opt_t exp; 
  list_t<struct RepInfo @> dependencies;
  opt_t<decl_t> fwd_decl;
  int emitted;
  bool is_extern;
} @repinfo_t;

/*------------------------------------------------------------------------*/
/* Helper functions & data */


dict_t<type_t,repinfo_t> empty_typerep_dict() {
  return empty(Tcutil::typecmp);
}

void print_dict_entry(type_t type, repinfo_t info) {
  printf("(%s,%x:%d,",typ2string(type),(unsigned int)info,info->emitted);
  for(_ p = info->dependencies; p != NULL; p = p->tl) {
    printf("%x",(unsigned int)p->hd);
    if(p->tl != NULL) printf(",");
  }
  printf(")\n");
}

void print_typerep_dict(dict_t<type_t,repinfo_t,`H> dict) {
  Dict::iter(print_dict_entry,dict);
}

// These routines are used to hash repinfos to keep track of nodes visited
static int rephash(repinfo_t ri) {
  return (int)ri;
}

static int repcmp(repinfo_t r1, repinfo_t r2) {
  unsigned int r1p, r2p;
  r1p = (unsigned int)r1;
  r2p = (unsigned int)r2;
  if (r1 < r2) return -1;
  else if (r1 == r2) return 0;
  else return 1;
}

// get field from known tunion type
static tunionfield_t getField(tuniondecl_t td, qvar_t fieldname) {
  if (td->fields == NULL)
    Tcutil::impos("Could not find field in tuniondecl");
  else {
    for (list_t<tunionfield_t> l = td->fields->v; l != NULL; l = l->tl)
      if (!qvar_cmp(l->hd->name,fieldname))
	return l->hd;
  }
  Tcutil::impos("Could not find field in tuniondecl");
  throw Tcutil::TypeErr; // redundant, as impos will do this
}

// defines the Tcgenrep namespace as an absyn value
static string_t tcgenrep_nm = "Tcgenrep";
static struct List<var_t,`H> l = { .hd=&tcgenrep_nm, .tl=NULL };
static tunion Nmspace.Abs_n tcgenrep_nmspace = Abs_n(&l);
static nmspace_t tcgenrep_nmspace2 = (tunion Nmspace)&tcgenrep_nmspace;
// defines the Tcgenrep namespace as an absyn value
static string_t typerep_nm = "Typerep";
static struct List<var_t,`H> l2 = { .hd=&typerep_nm, .tl=NULL };
static tunion Nmspace.Abs_n typerep_nmspace = Abs_n(&l2);

/*------------------------------------------------------------------------*/
// depth-first-search on repinfo_t's, based on the dependency edges.
//   this allows for a topological sort to extract the relevant
//   declarations.
// new: uses emitted flag to determine whether to include decls in list;
// sets it if unset
static list_t<list_t<decl_t>>
dfsvisit(repinfo_t ri, Hashtable::table_t<repinfo_t, int> visited) {
  try {
    Hashtable::lookup(visited,ri);
    // did not raise exception, so we already visited it
    //printf("cycle!\n");
    return NULL;
  } catch {
  case Not_found:
    // mark the node as visited
    Hashtable::insert(visited,ri,1);
    // process the children
    list_t ds = NULL;
    for (list_t l = ri->dependencies; l != NULL; l = l->tl)
      ds = imp_append(ds,dfsvisit(l->hd,visited));
    // add our own decls
    if(ri->emitted == 0) {
      // prefix with forward decl, if present
      if(ri->fwd_decl != NULL) {
      	ds = new List(list(ri->fwd_decl->v),ds);
      }
      let l = new List(ri->decls,NULL);
      ri->emitted = 1;
      return imp_append(ds,l);
    }
    else {
      //printf("Skipping ... { \n%s\n }\n", decllist2string(ri->decls));
      return ds;
    }
  }
}    
static list_t<decl_t> dfs(repinfo_t ri)
{
  Hashtable::table_t tab = Hashtable::create(53,repcmp,rephash);
  list_t ds = dfsvisit(ri,tab);
  return (flatten(ds));
} 

// We look up the Typestruct tunion declaration
// once and for all, and then use that when generating
// syntax
static string_t typestruct_str = "Typestruct";
static string_t var_str = "Var";
static string_t int_str = "Int";
static string_t float_str = "Float";
static string_t double_str = "Double";
static string_t thinptr_str = "ThinPtr";
static string_t fatptr_str = "FatPtr";
static string_t tuple_str = "Tuple";
static string_t tunion_str = "TUnion";
static string_t xtunion_str = "XTUnion";
static string_t union_str = "Union";

static string_t name_t_str = "name_t";
static $(nmspace_t,var_t) @
typerep_name(var_t name) {
  return new $((tunion Nmspace)&typerep_nmspace, name);
}

static int gen_id_counter = 0;
static stringptr_t new_gen_id(string_t name) {
  return new (string_t)aprintf("_gen%s_%d",name,gen_id_counter++);
}

static void print_params(list_t<type_t>l) {
  printf ("<");
  for(list_t<type_t> p = l ; 
      p != NULL;
      p = p->tl) {
    printf("%s%c",typ2string(p->hd),(p->tl != NULL)? ',' : ' ');
  }
  printf(">\n");
}

static void print_tvars(list_t<tvar_t>l) {
  printf ("<");
  for(list_t<tvar_t> p = l ; 
      p != NULL;
      p = p->tl) {
    printf("%s%c",*p->hd->name,(p->tl != NULL)? ',' : ' ');
  }
  printf(">\n");
}

static tunion Nmspace.Rel_n top_nm_0 = Rel_n(NULL);
static tunion Nmspace top_nm = (tunion Nmspace)&top_nm_0;
static qvar_t toplevel_name(var_t name) {
  return new $(top_nm, (var_t)name);
}

static qvar_t relative_name(list_t<var_t,`H> pathl, var_t name) {
  tunion Nmspace.Rel_n@ path = new Rel_n(pathl);
  return new $((tunion Nmspace)path, (var_t)name);
}
static decl_t gen_decl(stringptr_t<`H,`H> name, type_t type, exp_opt_t init,seg_t seg)
{
  qvar_t qvar = toplevel_name(name);
  vardecl_t vd = new_vardecl(qvar,type,init);
  vd->sc = Static;
  tunion Raw_decl.Var_d@ r1 = new Var_d(vd);
  tunion Raw_decl r2 = (tunion Raw_decl)r1;
  return new_decl(r2,seg);
}

static decl_t gen_vardecl(qvar_t name, type_t type, exp_opt_t init,scope_t sc,seg_t seg)
{
  qvar_t topname = toplevel_name((*name)[1]);
  vardecl_t vd = new_vardecl(topname,type,init);
  vd->sc = sc;
  tunion Raw_decl.Var_d@ r1 = new Var_d(vd);
  tunion Raw_decl r2 = (tunion Raw_decl)r1;
  return new_decl(r2,seg);
}


static exp_t cnst_string(string_t<`H> s,seg_t seg) {
  return const_exp((tunion Cnst)(new String_c(s)),seg);
}

static exp_t cnst_string_cls(seg_t seg,var_t s) {
  return const_exp((tunion Cnst)(new String_c(*s)),seg);
}


static exp_t cnst_int(int i,seg_t seg) {
  return const_exp((tunion Cnst)(new Int_c(Signed,i)),seg);
}

static exp_t cnst_int_cls(seg_t seg,int i) {
  return const_exp((tunion Cnst)(new Int_c(Signed,i)),seg);
}

static int size_of2int(size_of_t sz) {
  switch(sz) {
  case B1: return 8;
  case B2: return 16;
  case B4: return 32;
  case B8: return 64;
  }
}

static type_t array_typ(type_t ty, tqual_t tq, exp_opt_t e) {
  return new ArrayType(ty,tq,e);
}

static type_t tunion_typ(qvar_t name) {
  return new TunionType(
			TunionInfo(
				   new UnknownTunion(UnknownTunionInfo(name,
								       false)),
				   NULL,
				   HeapRgn));
}
static type_t tunionfield_typ(qvar_t name, qvar_t fieldname) {
  return new TunionFieldType(TunionFieldInfo(new UnknownTunionfield(UnknownTunionFieldInfo(name,fieldname,false)),NULL));
}

static exp_t call_exp(qvar_t name, list_t<exp_t,`H> args, seg_t loc) {
  return unknowncall_exp(unknownid_exp(name,loc),args,loc);
}

static decl_t tunion_constructor_decl(qvar_t tunionname, 
				      qvar_t fieldname, 
				      qvar_t varname, 
				      list_t<exp_t,`H> args,
				      scope_t sc, 
				      seg_t loc) {
  let t1 = tunionfield_typ(tunionname,fieldname);
  let e1 = call_exp(fieldname,args,loc);
  let d1 = gen_vardecl(varname,t1,e1,sc,loc);
  return d1;
}

//FIX: polymorphize these
static type_t get_second($(tqual_t,type_t)@ pair) {
  return (*pair)[1];
}

static var_t get_first($(var_t,exp_t)@ pair) {
  return (*pair)[0];
}


static string_t list_str = "list";
static string_t List_str = "List";



static exp_t tuple2_exp_cls(seg_t loc, $(exp_t,exp_t)@ es) {
  let &$(e1,e2) = es;
  return tuple_exp(list(e1,e2),loc);
}
static string_t null_str = "NULL";

static exp_t list_exp(list_t<exp_t,`H> l, seg_t loc) {
  if(l == NULL) return null_exp(loc);
  return call_exp(toplevel_name(&list_str),
		  l,
		  loc);
}

static exp_t make_offsetof_exp($(type_t,seg_t)@ typeloc,int index) {
  let &$(type,loc) = typeloc;
  return offsetof_exp(type,new TupleIndex(index),loc);
}


static exp_t get_and_cast_ri_exp(seg_t loc, repinfo_t info) {
  return cast_exp(tunion_typ(typerep_name(&typestruct_str)),(exp_t)info->exp,loc);
}

static $(var_t,exp_t)@ gen_id_for_exp(exp_t e) {
  return new $(new_gen_id("tuple"),e);
}

static decl_t gen_decl_cls($(type_t,seg_t)@ env, $(var_t,exp_t)@ name_exp) {
  let &$(ty,loc) = env;
  let &$(name,exp) = name_exp;
  return gen_decl(name,ty,exp,loc);
}

static $(list_t<designator_t,`H>,exp_t)@ null_designator_exp(exp_t e) {
  return new $(NULL,e);
}

static exp_t arr_init_exp(list_t<exp_t,`H> l,seg_t loc) {
  // map exp_t's into $(list_t<designator_t,`H>,exp_t)@'s
  // where the first component is NULL.
  let l2 = List::map(null_designator_exp,l);
  return unresolvedmem_exp(NULL,l2,loc);
}

static exp_t address_exp_cls(seg_t loc, exp_t e) {
  return address_exp(e,loc);
}
static exp_t unknownid_exp_cls(seg_t loc, qvar_t e) {
  return unknownid_exp(e,loc);
}

static bool has_bitfield(structfield_t sf) {
  return sf->width != NULL;
}

static int add_bitfield_sizes(int total, structfield_t sf) {
  return Evexp::eval_const_uint_exp((exp_t)sf->width) + total;
}

static type_t select_structfield_type(structfield_t sf) {
  // check safety
  if(strcmp(*(sf->name),"") == 0)
    Tcutil::impos("gen(): anonymous (padding) structfield not handled yet");
  if(has_bitfield(sf)) // indicating a bit-field 
    Tcutil::impos("gen(): mixed struct bitfields and union bitfields not handled");
  return sf->type;
}

// trickiness: fwd_decls only used if creating a new ri, ignroed if updateing existing

static dict_t<type_t,repinfo_t,`H>
update_info(dict_t<type_t,repinfo_t,`H> dict,
	    type_t type,
	    list_t<decl_t,`H> decls,
	    exp_opt_t exp,
	    list_t<repinfo_t,`H> dependencies,
	    opt_t<decl_t,`H> fwd_decl) {
  // is there an info record there already?
  let info = lookup_opt(dict,type);
  if(info != NULL ) { // if so, update it with new information
    //printf("Updated ri for %s(%s)\n",typ2string(type),exp2string(exp));
    if(info->v->decls != NULL) {
      print_typerep_dict(dict);
      Tcutil::impos("Updating non-forward declaration");
    }
    info->v->decls = decls;
    info->v->exp = exp;
    info->v->dependencies = dependencies;
    // emitted should be and remain 0
    return dict;
  }
  else {
    //printf("Added ri for %s (%s)\n",typ2string(type),exp2string(exp) );
    return insert(dict,type,new RepInfo{.decls=decls,
					   .exp=exp,
					   .dependencies=dependencies,
					   .fwd_decl = fwd_decl,
					   .emitted=0,
					   .is_extern=false});
  }
}

static dict_t<type_t,repinfo_t,`H>
make_fwd_decl_info(dict_t<type_t,repinfo_t,`H> dict,
		   type_t type,
		   exp_opt_t exp,
		   opt_t<decl_t,`H> fwd_decl,
		   bool is_extern) {
  // is there an info record there already?
  let info = lookup_opt(dict,type);
  if(info != NULL ) { 
    Tcutil::impos("Repinfo for fwd declaration of %s already exists",typ2string(type));
    return dict;
  }
  
  else {
    //printf("Added ri for %s (%s)\n",typ2string(type),exp2string(exp) );
    return insert(dict,type,new RepInfo{.decls=NULL,
					   .exp=exp,
					   .dependencies=NULL,
					   .fwd_decl = fwd_decl,
					   .emitted=0,
					   .is_extern=is_extern});
  }
}

static tqual_t tq_none = Tqual{.q_const=0,.q_volatile=0,.q_restrict=0};

static $(tqual_t,type_t)@ tqual_type(tqual_t* tq,type_t type) {
  return new $(*tq,type);
}

static type_t tuple_typ(list_t<type_t,`H> types) {
  let tqualtypes = List::map_c(tqual_type,&tq_none,types);
  tunion Type.TupleType @ tuple_type_base = new TupleType(tqualtypes);
  type_t tuple_type = (tunion Type) tuple_type_base;
  return tuple_type;
}

// Given a type, varname, and list of exps, construct
// a sequence of decls that build an array structure, and 
// return an exp containing the array's name
static $(list_t<decl_t>, exp_t) @
array_decls(type_t type, list_t<exp_t,`H> exps, seg_t loc) {
  
  let nameexplist = List::map(gen_id_for_exp,exps);
  // generate n decls, one for each type, name, exp triple.
  let decls = List::map_c(gen_decl_cls,new $(type,loc),nameexplist);
  // then generate one decl that combines them all in an array initializer
  // step 1: find the names
  let names = List::map(get_first,nameexplist);
  let topnames = List::map(toplevel_name,names);
  let topexpnames = List::map_c(unknownid_exp_cls,loc,topnames);
  // step 2: take their addresses to get tunion Typestruct exp's
  let addrnames = List::map_c(address_exp_cls,loc,topexpnames);
  // step 3: wrap them all inside an array initializer exp
  let addrnamesexp = arr_init_exp(addrnames,loc);
  // step 4: declare an unspecified-length array initialized to this
  let arrname = new_gen_id("arr");
  let pptr_type = at_typ(type,HeapRgn,tq_none);
  let arrty = array_typ(pptr_type,tq_none,NULL);
  let d1 = gen_decl(arrname,arrty,addrnamesexp,loc);
  let resultexp = unknownid_exp(toplevel_name(arrname),loc);
  return new $(imp_append(decls,list(d1)),resultexp);
}

static type_t 
check_tunionfield_and_get_type(tunionfield_t tuf) {
  if(tuf->tvs != NULL) {
    Tcutil::impos("gen(): tunionfield type varaibles not handled");
  }
  // preserves tquals of original tunion...
  return new TupleType(List::imp_append(List::list(new $(tq_none,uint_t)),tuf->typs));
}
static $(var_t,type_t)@
check_xtunionfield_and_get_name_type(tunionfield_t tuf) {
  if(tuf->tvs != NULL) {
    Tcutil::impos("gen(): tunionfield type varaibles not handled");
  }
  ;
  // preserves tquals of original tunion...
  return new $((*tuf->name)[1],new TupleType(List::imp_append(List::list(new $(tq_none,star_typ(uchar_t,HeapRgn,tq_none))),tuf->typs)));
}


static bool filter_empty_tunionfield(tunionfield_t tuf) {
  return (tuf->typs != NULL);
}

static var_t get_tunionfield_name(tunionfield_t tuf) {
  return ((*tuf->name)[1]);
}


structfield_t substitute_structfield_type(list_t<$(tvar_t,type_t)@`H,`H> subst,
					  structfield_t sf) {
  return new Structfield{sf->name,sf->tq,Tcutil::substitute(subst,sf->type),
			   sf->width,sf->attributes};
}

$(tqual_t,type_t)@ substitute_tqual_type(list_t<$(tvar_t,type_t)@`H,`H> subst,
					 $(tqual_t,type_t)@ pair) {
  let &$(tq,type) = pair;
  return new $(tq,Tcutil::substitute(subst,type));
}
tunionfield_t substitute_tunionfield_type(list_t<$(tvar_t,type_t)@`H,`H> subst,
					  tunionfield_t tf) {
  return new Tunionfield{tf->name,tf->tvs,
			   List::map_c(substitute_tqual_type,subst,tf->typs),
			   tf->loc,tf->sc};
}


type_t monomorphize_type(type_t type) {
  //printf("monomorphizing %s\n",typ2string(type));
  switch(Tcutil::compress(type)) {
  case &StructType(name,params,stdeclopt):
    if(stdeclopt == NULL)
      Tcutil::impos("struct decl must exist at this point");
    let stdecl = *stdeclopt;
    let tvs = stdecl->tvs;
    if(List::length(params) != List::length(tvs))
      Tcutil::impos("gen(): number of params %d differs from number of tyvars %d",List::length(params), List::length(tvs));
    
    let subst = List::zip(tvs,params);
    opt_t<list_t<structfield_t>> fields = NULL;
    if(stdecl->fields != NULL) 
      fields = new Opt{List::map_c(substitute_structfield_type,subst,stdecl->fields->v)};

    structdecl_t stdecl2 = new Structdecl{stdecl->sc,stdecl->name,NULL,fields,stdecl->attributes};
    let stdeclopt2 = new stdecl2;
    let type2 = new StructType(name,params,stdeclopt2);
    return type2;

  case &UnionType(name,params,udeclopt):
    if(udeclopt == NULL)
      Tcutil::impos("struct decl must exist at this point");
    let udecl = *udeclopt;
    let tvs = udecl->tvs;
    if(List::length(params) != List::length(tvs))
      Tcutil::impos("gen(): number of params %d differs from number of tyvars %d",List::length(params), List::length(tvs));
    
    let subst = List::zip(tvs,params);
    opt_t<list_t<structfield_t>> fields = NULL;
    if(udecl->fields != NULL) 
      fields = new Opt{List::map_c(substitute_structfield_type,subst,udecl->fields->v)};

    uniondecl_t udecl2 = new Uniondecl{udecl->sc,udecl->name,NULL,fields,udecl->attributes};
    let udeclopt2 = new udecl2;
    let type2 = new UnionType(name,params,udeclopt2);
    return type2;

  case &TunionType(TunionInfo{&KnownTunion(&tud),params,rgn}):
    let tvs = tud->tvs;
    if(List::length(params) != List::length(tvs))
      Tcutil::impos("gen(): number of params %d differs from number of tyvars %d",List::length(params), List::length(tvs));
    
    let subst = List::zip(tvs,params);
    opt_t<list_t<tunionfield_t>> fields = NULL;
    if(tud->fields != NULL) 
      fields = new Opt{List::map_c(substitute_tunionfield_type,subst,tud->fields->v)};
    let tud2 = new Tuniondecl{tud->sc,tud->name,NULL,fields,tud->is_xtunion};
    let type2 = new TunionType(TunionInfo{new KnownTunion(new tud2),params,rgn});
    
    let loc = segment_of_abs(0,0);
    //printf("before: %s\n after: %s\n", 
    //decllist2string(list(new_decl(new Tunion_d(tud),loc))),
    //decllist2string(list(new_decl(new Tunion_d(tud2),loc))));
    return type2;
  
  default:
    return type;
  }
}

string_t make_type_cstring(type_t t) {
  mstring_t s = strdup(typ2cstring(t));
  for(int i = 0; i < strlen(s); i++) {
    if(s[i] == ' ') s[i] = '_';
    else if(!isalnum(s[i]) && (s[i] != '_')) {
      s[i] = (char)('0' + (s[i] % 10));
    }
  }
  return strconcat(s,"_rep");
}

// forward declaration
static $(dict_t<type_t,repinfo_t,`H>,repinfo_t) @
lookupRep(tenv_t te, dict_t<type_t,repinfo_t,`H> dict, seg_t loc, type_t type);



static $(dict_t<type_t,repinfo_t,`H>,list_t<repinfo_t,`H>) @
lookupRepsCls($(tenv_t,seg_t)@ env,
	      type_t type,
	      $(dict_t<type_t,repinfo_t,`H>,list_t<repinfo_t,`H>)@ carry) {
  let &$(dict,ri) = lookupRep((*env)[0],(*carry)[0],(*env)[1],type);
  return new $(dict,new List{.hd=ri,.tl=(*carry)[1]});
}


static dict_t<type_t,repinfo_t,`H>
buildRepTuple(tenv_t te, dict_t<type_t,repinfo_t,`H> dict, seg_t loc, qvar_t varname, scope_t sc, type_t type, list_t<type_t> types)
{
  let sizeof_tuple = sizeoftyp_exp(type,loc);
  // use closures here to apply partially evaluated lookuprep
  let env = new $(te,loc);
  let carry = new $(dict,NULL);
  // this should really be a fold, producing the typeris list and the dict.
  // that way, the dicts will be merged right in the end
  let &$(dict2,ris) = List::fold_right_c(lookupRepsCls,env,types,carry);
  dict = dict2;
  let indices = List::tabulate(List::length(types),identity);
  let offsetofs = List::map_c(make_offsetof_exp,new $(type,loc),indices);
  let riexps = List::map_c(get_and_cast_ri_exp,loc,ris);
  let tuplelist = List::map_c(tuple2_exp_cls,loc,List::zip(offsetofs,riexps));

  // construct the (globally unique) type of components of the tuple array
  // FIX: Make this not duplicate so much run time data.

  type_t tuple_type = tuple_typ(list(uint_t,tunion_typ(typerep_name(&typestruct_str))));

  let &$(tupledecls,arrexp) = array_decls(tuple_type,tuplelist,loc);
  // generate a declaration
  let d2 = tunion_constructor_decl(typerep_name(&typestruct_str),
				   typerep_name(&tuple_str), 
				   varname,
				   list(sizeof_tuple,
					arrexp),
				   sc,
				   loc);
  let decls = imp_append(tupledecls,list(d2));
  
  return update_info(dict,type,decls,
		     address_exp(unknownid_exp(varname,loc),loc),
		     ris,
		     NULL);
}

static dict_t<type_t,repinfo_t,`H>
buildRepUnion(tenv_t te, dict_t<type_t,repinfo_t,`H> dict, seg_t loc, qvar_t varname, scope_t sc, type_t type, list_t<type_t> types)
{
  // use closures here to apply partially evaluated lookuprep
  let env = new $(te,loc);
  let carry = new $(dict,NULL);
  // this should really be a fold, producing the typeris list and the dict.
  // that way, the dicts will be merged right in the end
  let &$(dict2,ris) = List::fold_right_c(lookupRepsCls,env,types,carry);
  dict = dict2;
  let riexps = List::map_c(get_and_cast_ri_exp,loc,ris);
  let &$(decls,arrexp) = array_decls(tunion_typ(typerep_name(&typestruct_str)),riexps,loc);
  // generate a declaration
  let d2 = tunion_constructor_decl(typerep_name(&typestruct_str),
				   typerep_name(&union_str), 
				   varname,
				   list(arrexp),
				   sc,
				   loc);
  return update_info(dict,type,imp_append(decls,list(d2)),
		     address_exp(unknownid_exp(varname,loc),loc),
		     ris,
		     NULL);
}

// builds Typestruct.Tunion for given set of types
static dict_t<type_t,repinfo_t,`H>
buildRepTunion(tenv_t te, dict_t<type_t,repinfo_t,`H> dict, seg_t loc, qvar_t varname, scope_t sc, type_t type, list_t<type_t> types){
  let env = new $(te,loc);
  let carry = new $(dict,NULL);
  // fetch (building if necessary) repinfos for all component types
  let &$(dict2,ris) = List::fold_right_c(lookupRepsCls,env,types,carry);
  dict = dict2;
  // build tag list of appropriate length
  let tagints = List::tabulate(List::length(ris),identity);
  let tags = List::map_c(cnst_int_cls,loc,tagints);
  // build list of tunion case types
  let riexps = List::map_c(get_and_cast_ri_exp,loc,ris);
  // pair these with tags 
  let tagriexps = List::zip(tags,riexps);
  let tuplelist = List::map_c(tuple2_exp_cls,loc,tagriexps);
  // build the type of elements of Tunion array
  type_t tuple_type = tuple_typ(list(uint_t,tunion_typ(typerep_name(&typestruct_str))));
  let &$(tupledecls,arrexp) = array_decls(tuple_type,tuplelist,loc);
  // generate a declaration
  let d2 = tunion_constructor_decl(typerep_name(&typestruct_str),
				   typerep_name(&tunion_str), 
				   varname,
				   list(arrexp),
				   sc,
				   loc);
  return update_info(dict,type,imp_append(tupledecls,list(d2)),
		     address_exp(unknownid_exp(varname,loc),loc),
		     ris,
		     NULL);
  return dict;
}
// builds Typestruct.XTunion for given set of types
static dict_t<type_t,repinfo_t,`H>
buildRepXTunion(tenv_t te, dict_t<type_t,repinfo_t,`H> dict, seg_t loc, qvar_t varname, scope_t sc, type_t type, list_t<$(var_t,type_t)@> nametypes){
  let $(names,types) = List::split(nametypes);
  let env = new $(te,loc);
  let carry = new $(dict,NULL);
  // fetch (building if necessary) repinfos for all component types
  let &$(dict2,ris) = List::fold_right_c(lookupRepsCls,env,types,carry);
  dict = dict2;
  // build tag list of appropriate length
  let tags = List::map_c(cnst_string_cls,loc,names);
  // build list of tunion case types
  let riexps = List::map_c(get_and_cast_ri_exp,loc,ris);
  // pair these with tags 
  let tagriexps = List::zip(tags,riexps);
  let tuplelist = List::map_c(tuple2_exp_cls,loc,tagriexps);
  // build the type of elements of Tunion array
  type_t name_type = tagged_typ(uchar_t,HeapRgn,Tqual{.q_const=true,.q_volatile=false,.q_restrict=0});
  type_t tuple_type = tuple_typ(list(name_type,
				     tunion_typ(typerep_name(&typestruct_str))));
  let &$(tupledecls,arrexp) = array_decls(tuple_type,tuplelist,loc);
  // generate a declaration
  let d2 = tunion_constructor_decl(typerep_name(&typestruct_str),
				   typerep_name(&xtunion_str), 
				   varname,
				   list(arrexp),
				   sc,
				   loc);
  return update_info(dict,type,imp_append(tupledecls,list(d2)),
		     address_exp(unknownid_exp(varname,loc),loc),
		     ris,
		     NULL);
  return dict;
}
/*------------------------------------------------------------------------*/
// Given a type, looks for the typestruct decl for that type in the
// dictionary.  If found, it returns the dictionary back, along
// with an expression containing the variable name of the decl.
// If not found, it generates the decl(s), enters them into the
// dictionary, and returns as before.  Will operate recursively.
static $(dict_t<type_t,repinfo_t,`H>,repinfo_t) @
lookupRep(tenv_t te, dict_t<type_t,repinfo_t,`H> dict, seg_t loc, type_t type)
{
  //  printf("Type %s (%x)\n", typ2string(type),type);


  Core::opt_t<repinfo_t> info = lookup_opt(dict,type);

  if (info != NULL) {
    if(info->v->is_extern) {
      //printf("removing externdecl for %s\n",typ2string(type));
      
      dict = Dict::delete(dict,type);
    }
    else {
      //printf("Done %s\n",typ2string(type));
      let ret = new $(dict,info->v);
      return ret;
    }
  }
  
  switch (Tcutil::compress(monomorphize_type(type))) {
  case &IntType(_,sz):
    
    // tunion Typestruct.Int rep = Int(32);
    let varname = toplevel_name(new_gen_id("rep"));
    let d1 = tunion_constructor_decl(typerep_name(&typestruct_str),
				     typerep_name(&int_str), 
				     varname,
				     list(cnst_int(size_of2int(sz),loc)),
				     Static,
				     loc);     
    dict = update_info(dict,
		       type,
		       list(d1),
		       address_exp(unknownid_exp(varname,
						 loc),loc),
		       NULL,NULL);
    break;
  case FloatType:
    dict = update_info(dict,
		       type,
		       NULL,
		       unknownid_exp(typerep_name(&float_str),loc),
		       NULL,NULL);
    break;
  case &DoubleType(b):
    dict = update_info(dict,
		       type,
		       NULL,
		       unknownid_exp(typerep_name(&double_str),loc),
		       NULL,NULL);
    break;
    
  case &PointerType(pt): // ptr_info_t
    //printf("Pointer type: %s (%x)\n", typ2string(pt.elt_typ),pt.elt_typ);
    switch(conref_val(pt.bounds)) {
    case &Upper_b(e):
      let varname = toplevel_name(new_gen_id("rep"));
      // fwd_decl = extern tunion Typestruct.Tuple `varname`;
      let fwd_decl = new Opt{.v=gen_vardecl(varname,tunionfield_typ(typerep_name(&typestruct_str),typerep_name(&thinptr_str)),NULL,Extern,loc)};
      dict = make_fwd_decl_info(dict,type,address_exp(unknownid_exp(varname,loc),loc),fwd_decl,false);
      
      let &$(dict2,base_info) = lookupRep(te,dict,loc,pt.elt_typ);
      dict = dict2;
      
      // e must be a constant; evaluate it
      unsigned int bound = Evexp::eval_const_uint_exp(e);
      // tunion Typestruct.ThinPtr gen = ThinPtr(`bound`,`base_info->exp`);
      let d1 = tunion_constructor_decl(typerep_name(&typestruct_str),
				       typerep_name(&thinptr_str), 
				       varname,
				       list(cnst_int(bound,loc),
					    (exp_t)base_info->exp),Static,loc);
      
	
      dict = update_info(dict,
			 type,
			 list(d1),
			 address_exp(unknownid_exp(varname,loc),loc),
			 list(base_info),NULL);
      break;
    case Unknown_b:
      // a ? pointer
      // tunion Typestruct.FatPtr(`base_info->exp`);
      let varname = toplevel_name(new_gen_id("rep"));

	// fwd_decl = extern tunion Typestruct.Tuple `varname`;
      let fwd_decl = new Opt{.v=gen_vardecl(varname,tunionfield_typ(typerep_name(&typestruct_str),typerep_name(&fatptr_str)),NULL,Extern,loc)};
      dict = make_fwd_decl_info(dict,type,address_exp(unknownid_exp(varname,loc),loc),fwd_decl,false);

      let &$(dict2,base_info) = lookupRep(te,dict,loc,pt.elt_typ);
      dict = dict2;

      let d1 = tunion_constructor_decl(typerep_name(&typestruct_str),
				       typerep_name(&fatptr_str), 
				       varname,
				       list((exp_t)base_info->exp),Static,loc);
      dict = update_info(dict,
			 type,
			 list(d1),
			 address_exp(unknownid_exp(varname,loc),loc),
			 list(base_info),NULL);
      break;
    }
    break;
  case &ArrayType(arrtype,tq,e):
    if(e == NULL) {
      Tcutil::impos("tcgenrep:At this point, array bounds must be constants");
    }
    // get info for base type
    let &$(dict2,base_info) = lookupRep(te,dict,loc,arrtype);
    dict = dict2;
    // e must be a constant; evaluate it
    unsigned int bound = Evexp::eval_const_uint_exp((exp_t)e);
    // tunion Typestruct.ThinPtr gen = ThinPtr(`bound`,`base_info->exp`);
    let varname = toplevel_name(new_gen_id("rep"));
    let d1 = tunion_constructor_decl(typerep_name(&typestruct_str),
				     typerep_name(&thinptr_str), 
				     varname,
				     list(cnst_int(bound,loc),
					  (exp_t)base_info->exp),Static,loc);
    dict = update_info(dict,
		       type,
		       list(d1),
		       address_exp(unknownid_exp(varname,loc),loc),
		       list(base_info),NULL);
    break;
  case &TupleType(fields):
    // idea: generate reps for each component type
    // emit 
    // tunion Typestruct.Tuple tuple_rep = Tuple(sizeof(tuple_type),
    //                                    (sizeof(t1),rep_exp(t1),...));
    // problems: what to do about tq's?
    // FIX: forward declarations because of resursion and structural identity
    let varname = toplevel_name(new_gen_id("rep"));
    let fwd_decl = new Opt{.v=gen_vardecl(varname,tunionfield_typ(typerep_name(&typestruct_str),typerep_name(&tuple_str)),NULL, Extern, loc)};
    dict = make_fwd_decl_info(dict,type,address_exp(unknownid_exp(varname,loc),loc),fwd_decl,false);
    let types = List::map(get_second,fields);
    dict = buildRepTuple(te,dict,loc,varname,Static,type,types);
    break;
  case &TypedefType(name,params,def):
    if(def == NULL) 
      Tcutil::impos("gen(): typedef definition must be present by now");
    // lookup rep for definition
    // throws away current "info"
    let &$(dict2,info2) = lookupRep(te,dict,loc,def->v);
    dict = insert(dict2,type,info2);
    break;
  case &StructType(name,params,stdeclopt): // MemKind
    if(stdeclopt == NULL)
      Tcutil::impos("gen(): struct declaration must be present by now");
    // Almost identical to Tuple case.
    // Filter structfield list of stdecl to form like that in tuple case
    // Wrinkle: anonymous padding bytes (would like to omit, but safe to include)
    // Wrinkle: Type parameters
    // Wrinkle: Recursive structs (recursive uses of struct name within def)
    let stdecl = *stdeclopt;
    /*	if (stdecl->tvs != NULL) {
	//	  Tcutil::impos("gen(): structs with tyvariables not yet supported");
	print_tvars(stdecl->tvs);
	}*/
    if (stdecl->fields == NULL) {
      // This indicates an imported struct.
      // Generate a forward decl of the imported typerep
      // Generate a reference to a standard name.
      //string_t s = strconcat(qvar2cstring((qvar_t)name),"_struct_typerep");
      //let varname = new $((*name)[0],new make_type_cstring(type));
      let varname = toplevel_name(new make_type_cstring(type));
      let fwd_decl = new Opt{.v=gen_vardecl(varname,tunionfield_typ(typerep_name(&typestruct_str),typerep_name(&tuple_str)),NULL,Extern,loc)};
      //printf("adding externdecl for %s\n",qvar2string(varname));
      dict = make_fwd_decl_info(dict,
				type,
				address_exp(unknownid_exp(varname,loc),loc),
				NULL/*fwd_decl*/,true);
      break;

      //Tcutil::impos("gen(): external structs not yet handled");
    }
    if(stdecl->fields->v != NULL && forall(has_bitfield,stdecl->fields->v)) {
      let bits = fold_left(add_bitfield_sizes,0,stdecl->fields->v);
      let bytes = bits / 8 + ((bits % 8) == 0 ? 0 : 1);
      list_t<$(tqual_t,type_t)@> chars = NULL;
      for(int i = 0; i < bytes; i++) {
	chars = new List(new $(tq_none,uchar_t),chars);
      }
      type_t base_type = new TupleType(chars);
      let &$(dict2,base_info) = lookupRep(te,dict,loc,base_type);
      dict = insert(dict2,type,base_info);
    } else {
      // Add forward declaration in case of recursive struct
      // Gensym a new var name & create an address exp for exp; this
      // exp is needed 
      //string_t s = strconcat(qvar2cstring((qvar_t)name),"_struct_typerep");
      //let varname = new $((*name)[0],new make_type_cstring(type));
      let varname = toplevel_name(new make_type_cstring(type));
      // fwd_decl = extern tunion Typestruct.Tuple `varname`;
      let fwd_decl = new Opt{.v=gen_vardecl(varname,tunionfield_typ(typerep_name(&typestruct_str),typerep_name(&tuple_str)),NULL,Extern,loc)};
      dict = make_fwd_decl_info(dict,type,address_exp(unknownid_exp(varname,loc),loc),fwd_decl,false);
      let types = List::map(select_structfield_type,stdecl->fields->v);
      dict = buildRepTuple(te,dict,loc,varname,Public,type,types);
    }
	
  
    break;
  case &AnonStructType(fields): // MemKind
    // Almost identical to Struct case.
    // Filter structfield list of stdecl to form like that in tuple case
    // Wrinkle: anonymous padding bytes (would like to omit, but safe to include)
    if(fields != NULL && forall(has_bitfield,fields)) {
      let bits = fold_left(add_bitfield_sizes,0,fields);
      let bytes = bits / 8 + ((bits % 8) == 0 ? 0 : 1);
      type_t base_type = new ArrayType(uchar_t,tq_none,cnst_int(bytes,loc));
      let &$(dict2,base_info) = lookupRep(te,dict,loc,base_type);
      dict = insert(dict2,type,base_info);
    } else {
      let types = List::map(select_structfield_type,fields);
      let varname = toplevel_name(new_gen_id("rep"));
      dict = buildRepTuple(te,dict,loc,varname,Static,type,types);
    }
    break;


  case VoidType: 
    Tcutil::terr(loc,"found void in gen() expression");
    break;
  case &Evar(_,_,_,_):
    Tcutil::terr(loc,"found evar in gen() expression");
    break;
  case &VarType(tvar):
    Tcutil::terr(loc,"found tyvar in gen() expression");
    /*      // string_t name = `*tvar->name`;
	    let strname = new_gen_id("name");
	    let d1 = gen_decl(strname,string_typ(HeapRgn),cnst_string(*tvar->name,loc),loc);
	    // tunion Typestruct.Var gen = Var(&name);
	    let varname = new_gen_id("gen");
	    let d2 = tunion_constructor_decl(&typestruct_str,&var_str, varname,
	    list(address_exp(unknownid_exp(toplevel_name(strname),loc),loc)),
	    loc);     
	    dict = update_info(dict,
	    type,
	    list(d1,d2),
	    address_exp(unknownid_exp(toplevel_name(varname),
	    loc),loc),
	    NULL,NULL);
    */
    break;
    Tcutil::terr(loc,"found variable type in gen() expression");
    break;
  case &FnType(fi): 
    Tcutil::terr(loc,"found function type in gen() expression");
    break;
    // conceivably we might have to marshal these somehow... how?
  case &RgnHandleType(_): fallthru;
  case HeapRgn:           fallthru;
  case &AccessEff(_):     fallthru;
  case &JoinEff(_):       fallthru;
  case &RgnsEff(_):       
    Tcutil::terr(loc,"gen(): unhandled region, handle or effect type");
    break;
  case &TunionType(TunionInfo{&KnownTunion(&tudecl),params,rgn}):
    if(tudecl->tvs != NULL) 
      Tcutil::impos("gen(): tunion type variables not handled yet");
    if(tudecl->fields == NULL) {      
      let varname = toplevel_name(new make_type_cstring(type));
      let fwd_decl = new Opt{.v=gen_vardecl(varname,tunionfield_typ(typerep_name(&typestruct_str),typerep_name(&tunion_str)),NULL,Extern,loc)};
      //printf("adding externdecl for %s\n",qvar2string(varname));
      dict = make_fwd_decl_info(dict,
				type,
				address_exp(unknownid_exp(varname,loc),loc),
				NULL/*fwd_decl*/,true);
      break;
      //Tcutil::impos("gen(): tunion fields must be present by now");
    }
    if(!tudecl->is_xtunion) {
      // build fwd decl in case of recursion
      let varname = toplevel_name(new make_type_cstring(type));
      // fwd_decl = extern tunion Typestruct.Tuple `varname`;
      let fwd_decl = new Opt{.v=gen_vardecl(varname,tunionfield_typ(typerep_name(&typestruct_str),typerep_name(&tunion_str)),NULL,Extern,loc)};
      dict = make_fwd_decl_info(dict,type,address_exp(unknownid_exp(varname,loc),loc),fwd_decl,false);
      let fields = tudecl->fields->v;
      let nonemptyfields = List::filter(filter_empty_tunionfield,fields);
      let types = List::map(check_tunionfield_and_get_type,nonemptyfields);
      // this builds absyn for Typestruct.Tunion with appropriate entries
      dict = buildRepTunion(te,dict,loc,varname,Public,type,types);
    }
    else {
      // build fwd decl in case of recursion
      let varname = toplevel_name(new make_type_cstring(type));
      // fwd_decl = extern tunion Typestruct.Tuple `varname`;
      let fwd_decl = new Opt{.v=gen_vardecl(varname,tunionfield_typ(typerep_name(&typestruct_str),typerep_name(&xtunion_str)),NULL,Extern,loc)};
      dict = make_fwd_decl_info(dict,type,address_exp(unknownid_exp(varname,loc),loc),fwd_decl,false);
      let fields = tudecl->fields->v;
      let nonemptyfields = List::filter(filter_empty_tunionfield,fields);
      let types = List::map(check_xtunionfield_and_get_name_type,nonemptyfields);
      // this builds absyn for Typestruct.Tunion with appropriate entries
      dict = buildRepXTunion(te,dict,loc,varname,Public,type,types);
      //Tcutil::impos("gen(): xtunions not yet handled");
    }
      break;
  case &TunionType(_):
    Tcutil::impos("gen(): tunion must be resolved by now");
    break;
  case &TunionFieldType(tfieldinfo): // tunion_field_info_t
    // should be similar to tuple
    if(tfieldinfo.targs != NULL)
      Tcutil::impos("gen(): tunionfield type parameters not handled yet");
    switch (tfieldinfo.field_info) {
    case &KnownTunionfield(decl,field):
      if(field->tvs != NULL) 
	Tcutil::impos("gen(): tunionfield type parameters not handled yet");
      let types = List::map(get_second,field->typs);
      let types2 = new List(uint_t,types);
      let varname = toplevel_name(new_gen_id("rep"));
      dict = buildRepTuple(te,dict,loc,varname,Static,type,types2);
      break;
    default:
      Tcutil::impos("gen(): tunionfield must be known at this point");
      break;
    }
    break;
  case &UnionType(name,params,udeclopt):   
    if(udeclopt == NULL)
      Tcutil::impos("gen(): union declaration must be present by now");
    // Almost identical to Tuple case.
    // Filter structfield list of stdecl to form like that in tuple case
    // Wrinkle: Type parameters

      
    let udecl = *udeclopt;
    if(udecl->tvs != NULL)
      Tcutil::impos("gen: unions with parameters not yet supported");
    if (udecl->fields == NULL) {
      let varname = toplevel_name(new make_type_cstring(type));
      let fwd_decl = new Opt{.v=gen_vardecl(varname,tunionfield_typ(typerep_name(&typestruct_str),typerep_name(&union_str)),NULL,Extern,loc)};
      //printf("adding externdecl for %s\n",qvar2string(varname));
      dict = make_fwd_decl_info(dict,
				type,
				address_exp(unknownid_exp(varname,loc),loc),
				NULL/*fwd_decl*/,true);
      break;
      //Tcutil::impos("gen(): union fields must be present by now");
    }
    let types = List::map(select_structfield_type,udecl->fields->v);

    let varname = toplevel_name(new make_type_cstring(type));
    dict = buildRepUnion(te,dict,loc,varname,Public,type,types);
    break;
      
  case &AnonUnionType(fields): // MemKind
    // Almost identical to Struct case.
    // Filter structfield list of stdecl to form like that in tuple case
    // Wrinkle: anonymous padding bytes (would like to omit, but safe to include)
    let types = List::map(select_structfield_type,fields);
    let varname = toplevel_name(new_gen_id("rep"));
    dict = buildRepUnion(te,dict,loc,varname,Static,type,types);
    break;

  case &EnumType(_,_): 
  case &AnonEnumType(_): 
    // tunion Typestruct.Int rep = Int(32);
    let varname = toplevel_name(new_gen_id("rep"));
    let d1 = tunion_constructor_decl(typerep_name(&typestruct_str),
				     typerep_name(&int_str), 
				     varname,
				     list(cnst_int(32,loc)),
				     Static,
				     loc);     
    dict = update_info(dict,
		       type,
		       list(d1),
		       address_exp(unknownid_exp(varname,
						 loc),loc),
		       NULL,NULL);
    break;
    //    default:
    //      Tcutil::impos("gen() expression not yet supported");
    //      throw Tcutil::TypeErr; // redundant, as impos will do this
  case &SizeofType(_):
    Tcutil::impos("gen() for sizeof_t<-> not yet supported"); break;
  }
  //printf("Done %s\n",typ2string(type));
  return new $(dict,lookup(dict,type));
}



static bool not_emitted_filter(repinfo_t ri) {
  return (ri->emitted == 0);
}
static void mark_emitted(repinfo_t ri) {
  ri->emitted = 1;
}
/*------------------------------------------------------------------------*/
// Replaces a gen(t) expression with a Typestruct value.  As a result,
// it needs to generate a number of static declarations of data, and 
// finally an expression of type tunion Typestruct.  FIX: take in
// and return a Dictionary so that we can reuse declarations from
// previous gen()'s in the same file.
$(dict_t<type_t,repinfo_t,`H>,list_t<decl_t>,exp_t)
  tcGenrep(tenv_t te, genv_t ge, seg_t loc, type_t type,dict_t<type_t,repinfo_t,`H> dict)
{
  // first check that type is well-formed
  Tcutil::check_valid_toplevel_type(loc,te,type);
  Tcutil::check_valid_toplevel_type(loc,te,type);

  // generate the declarations
  let &$(dict,ri) = lookupRep(te, dict, loc, type);  
  let decls = dfs(ri);
  //printf("Emitting...\n%s\n",decllist2string(decls));
  

  return $(dict,decls, (exp_t)ri->exp);
}

