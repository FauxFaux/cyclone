/* Generating typereps from types.
   Copyright (C) 2001 Greg Morrisett, AT&T
   This file is part of the Cyclone compiler.

   The Cyclone compiler is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   The Cyclone compiler is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with the Cyclone compiler; see the file COPYING. If not,
   write to the Free Software Foundation, Inc., 59 Temple Place -
   Suite 330, Boston, MA 02111-1307, USA. */

#include <core.h>
#include <ctype.h>
#include <list.h>
#include <dict.h>
#include <string.h>
#include <hashtable.h>
#include <position.h>
#include <typerep.h>
#include <time.h>
#include "absyn.h"
#include "absynpp.h"
#include "evexp.h"
#include "tcutil.h"
#include "tcenv.h"
#include "toc.h"
using Absyn;
using Absynpp;
using Core;
using Tcenv;
using Dict;
using List;
using Position;

namespace Tcgenrep;

/* the dictionary entries should be indexed by types and be a three-tuple
     1) A LIST of declarations
     2) An expression which evaluates to the appropriate Typestruct
     3) A list of pointers to other three tuples that these declarations
        depend on.
     4) A flag indicating whether this series of declarations has
        been emitted yet for the current file.

     At the end, we pull out the three tuples and sort them
     topologically.  We then reverse the list and have our list of
     declarations to return.
  */


typedef struct RepInfo {
  list_t<decl_t> decls;
  exp_opt_t exp; 
  list_t<struct RepInfo @> dependencies;
  opt_t<decl_t> fwd_decl;
  int emitted;
  bool is_extern;
} @repinfo_t;

/*------------------------------------------------------------------------*/
/* Helper functions & data */


dict_t<type_t,repinfo_t> empty_typerep_dict() {
  return empty(Tcutil::typecmp);
}

void print_dict_entry(type_t type, repinfo_t info) {
  printf("(%s,%x:%d,",typ2string(type),(unsigned int)info,info->emitted);
  for(_ p = info->dependencies; p != NULL; p = p->tl) {
    printf("%x",(unsigned int)p->hd);
    if(p->tl != NULL) printf(",");
  }
  printf(")\n");
}

void print_typerep_dict(dict_t<type_t,repinfo_t,`H> dict) {
  Dict::iter(print_dict_entry,dict);
}

// These routines are used to hash repinfos to keep track of nodes visited
static int rephash(repinfo_t ri) {
  return (int)ri;
}

static int repcmp(repinfo_t r1, repinfo_t r2) {
  unsigned int r1p, r2p;
  r1p = (unsigned int)r1;
  r2p = (unsigned int)r2;
  if (r1 < r2) return -1;
  else if (r1 == r2) return 0;
  else return 1;
}

// get field from known tunion type
static tunionfield_t getField(tuniondecl_t td, qvar_t fieldname) {
  if (td->fields == NULL)
    Tcutil::impos("Could not find field in tuniondecl");
  else {
    for (list_t<tunionfield_t> l = td->fields->v; l != NULL; l = l->tl)
      if (!qvar_cmp(l->hd->name,fieldname))
	return l->hd;
  }
  Tcutil::impos("Could not find field in tuniondecl");
}

// defines the Tcgenrep namespace as an absyn value
/*
static string_t tcgenrep_nm = "Tcgenrep";
static struct List<var_t,`H> l = { .hd=&tcgenrep_nm, .tl=NULL };
static tunion Nmspace.Abs_n tcgenrep_nmspace = Abs_n(&l);
static nmspace_t tcgenrep_nmspace2 = (tunion Nmspace)&tcgenrep_nmspace;
*/
// defines the Tcgenrep namespace as an absyn value
static string_t typerep_nm = "Typerep";
static struct List<var_t,`H> l2 = { .hd=&typerep_nm, .tl=NULL };
#define typerep_nmspace Abs_n(&l2)
//static tunion Nmspace.Abs_n typerep_nmspace = Abs_n(&l2);

/*------------------------------------------------------------------------*/
// depth-first-search on repinfo_t's, based on the dependency edges.
//   this allows for a topological sort to extract the relevant
//   declarations.
// new: uses emitted flag to determine whether to include decls in list;
// sets it if unset
static list_t<list_t<decl_t>>
dfsvisit(repinfo_t ri, Hashtable::table_t<repinfo_t, int> visited) {
  try {
    Hashtable::lookup(visited,ri);
    // did not raise exception, so we already visited it
    //printf("cycle!\n");
    return NULL;
  } catch {
  case Not_found:
    // mark the node as visited
    Hashtable::insert(visited,ri,1);
    // process the children
    list_t ds = NULL;
    for (list_t l = ri->dependencies; l != NULL; l = l->tl)
      ds = imp_append(ds,dfsvisit(l->hd,visited));
    // add our own decls
    if(ri->emitted == 0) {
      // prefix with forward decl, if present
      if(ri->fwd_decl != NULL) {
      	ds = new List(list(ri->fwd_decl->v),ds);
      }
      let l = new List(ri->decls,NULL);
      ri->emitted = 1;
      return imp_append(ds,l);
    }
    else {
      //printf("Skipping ... { \n%s\n }\n", decllist2string(ri->decls));
      return ds;
    }
  }
}    
static list_t<decl_t> dfs(repinfo_t ri)
{
  Hashtable::table_t tab = Hashtable::create(53,repcmp,rephash);
  list_t ds = dfsvisit(ri,tab);
  return (flatten(ds));
} 

// We look up the Typestruct tunion declaration
// once and for all, and then use that when generating
// syntax
static string_t typestruct_str = "Typestruct";
static string_t var_str = "Var";
static string_t int_str = "Int";
static string_t float_str = "Float";
static string_t double_str = "Double";
static string_t thinptr_str = "ThinPtr";
static string_t fatptr_str = "FatPtr";
static string_t tuple_str = "Tuple";
static string_t tunionfield_str = "TUnionField";
static string_t struct_str = "Struct";
static string_t tunion_str = "TUnion";
static string_t xtunion_str = "XTUnion";
static string_t union_str = "Union";
static string_t enum_str = "Enum";

static string_t name_t_str = "name_t";
static $(nmspace_t,var_t) @
typerep_name(var_t name) {
  return new $(typerep_nmspace, name);
}

static int gen_id_counter = 0;
static stringptr_t new_gen_id(string_t name) {
  return new (string_t)aprintf("_gen%s_%d",name,gen_id_counter++);
}

static void print_params(list_t<type_t>l) {
  printf ("<");
  for(list_t<type_t> p = l ; 
      p != NULL;
      p = p->tl) {
    printf("%s%c",typ2string(p->hd),(p->tl != NULL)? ',' : ' ');
  }
  printf(">\n");
}

static void print_tvars(list_t<tvar_t>l) {
  printf ("<");
  for(list_t<tvar_t> p = l ; 
      p != NULL;
      p = p->tl) {
    printf("%s%c",*p->hd->name,(p->tl != NULL)? ',' : ' ');
  }
  printf(">\n");
}

static qvar_t toplevel_name(var_t name) {
  return new $(Rel_n(NULL), (var_t)name);
}

static qvar_t relative_name(list_t<var_t,`H> pathl, var_t name) {
  return new $(Rel_n(pathl), (var_t)name);
}
static decl_t gen_decl(stringptr_t<`H,`H> name, type_t type, exp_opt_t init,seg_t seg)
{
  qvar_t qvar = toplevel_name(name);
  vardecl_t vd = new_vardecl(qvar,type,init);
  vd->sc = Static;
  tunion Raw_decl.Var_d@ r1 = new Var_d(vd);
  tunion Raw_decl r2 = (tunion Raw_decl)r1;
  return new_decl(r2,seg);
}

static decl_t gen_vardecl(qvar_t name, type_t type, exp_opt_t init,scope_t sc,seg_t seg)
{
  qvar_t topname = toplevel_name((*name)[1]);
  vardecl_t vd = new_vardecl(topname,type,init);
  vd->sc = sc;
  tunion Raw_decl.Var_d@ r1 = new Var_d(vd);
  tunion Raw_decl r2 = (tunion Raw_decl)r1;
  return new_decl(r2,seg);
}


static exp_t cnst_string(string_t<`H> s,seg_t seg) {
  return const_exp((tunion Cnst)(String_c(s)),seg);
}

static exp_t cnst_string_cls(seg_t seg,var_t s) {
  return const_exp((tunion Cnst)(String_c(*s)),seg);
}

static exp_t cnst_qvar_string_cls(seg_t seg,qvar_t s) {
  return const_exp((tunion Cnst)(String_c(*(*s)[1])),seg);
}


static exp_t cnst_int(int i,seg_t seg) {
  return const_exp((tunion Cnst)(Int_c(Signed,i)),seg);
}

static exp_t cnst_int_cls(seg_t seg,int i) {
  return const_exp((tunion Cnst)(Int_c(Signed,i)),seg);
}

static int size_of2int(size_of_t sz) {
  switch(sz) {
    // FIX: lots of assumptions about sizes here
  case Char_sz: return 8;
  case Short_sz: return 16;
  case Int_sz: return 32;
  case Long_sz: return 32;
  case LongLong_sz: return 64;
  }
}

static type_t tunion_typ(qvar_t name) {
  return new TunionType(
			TunionInfo(UnknownTunion(UnknownTunionInfo(name,
                                                                   false,
                                                                   false)),
				   NULL,
				   new Opt(HeapRgn)));
}
static type_t tunionfield_typ(qvar_t name, qvar_t fieldname) {
  return new TunionFieldType(TunionFieldInfo(UnknownTunionfield(UnknownTunionFieldInfo(name,fieldname,false)),NULL));
}

static exp_t call_exp(qvar_t name, list_t<exp_t,`H> args, seg_t loc) {
  return unknowncall_exp(unknownid_exp(name,loc),args,loc);
}

static decl_t tunion_constructor_decl(qvar_t tunionname, 
				      qvar_t fieldname, 
				      qvar_t varname, 
				      list_t<exp_t,`H> args,
				      scope_t sc, 
				      seg_t loc) {
  let t1 = tunionfield_typ(tunionname,fieldname);
  let e1 = call_exp(fieldname,args,loc);
  let d1 = gen_vardecl(varname,t1,e1,sc,loc);
  return d1;
}

//FIX: polymorphize these
static type_t get_second($(tqual_t,type_t)@ pair) {
  return (*pair)[1];
}

static var_t get_first($(var_t,exp_t)@ pair) {
  return (*pair)[0];
}


static string_t list_str = "list";
static string_t List_str = "List";



static exp_t tuple2_exp_cls(seg_t loc, $(exp_t,exp_t)@ es) {
  let &$(e1,e2) = es;
  return tuple_exp(list(e1,e2),loc);
}
static exp_t tuple3_exp_cls(seg_t loc, $(exp_t,exp_t,exp_t)@ es) {
  let &$(e1,e2,e3) = es;
  return tuple_exp(list(e1,e2,e3),loc);
}
static string_t null_str = "NULL";

static exp_t list_exp(list_t<exp_t,`H> l, seg_t loc) {
  if(l == NULL) return null_exp(loc);
  return call_exp(toplevel_name(&list_str),
		  l,
		  loc);
}

static exp_t make_offsetof_exp($(type_t,seg_t)@ typeloc,int index) {
  let &$(type,loc) = typeloc;
  return offsetof_exp(type,new TupleIndex(index),loc);
}


static exp_t get_and_cast_ri_exp(seg_t loc, repinfo_t info) {
  return cast_exp(tunion_typ(typerep_name(&typestruct_str)),(exp_t)info->exp,true,Unknown_coercion,loc);
}

static $(var_t,exp_t)@ gen_id_for_exp(exp_t e) {
  return new $(new_gen_id("tuple"),e);
}

static decl_t gen_decl_cls($(type_t,seg_t)@ env, $(var_t,exp_t)@ name_exp) {
  let &$(ty,loc) = env;
  let &$(name,exp) = name_exp;
  return gen_decl(name,ty,exp,loc);
}

static $(list_t<designator_t,`H>,exp_t)@ null_designator_exp(exp_t e) {
  return new $(NULL,e);
}

static exp_t arr_init_exp(list_t<exp_t,`H> l,seg_t loc) {
  // map exp_t's into $(list_t<designator_t,`H>,exp_t)@'s
  // where the first component is NULL.
  let l2 = List::map(null_designator_exp,l);
  return unresolvedmem_exp(NULL,l2,loc);
}

static exp_t address_exp_cls(seg_t loc, exp_t e) {
  return address_exp(e,loc);
}
static exp_t unknownid_exp_cls(seg_t loc, qvar_t e) {
  return unknownid_exp(e,loc);
}

static bool has_bitfield(aggrfield_t sf) {
  return sf->width != NULL;
}

static int add_bitfield_sizes(int total, aggrfield_t sf) {
  let $(i,known) = Evexp::eval_const_uint_exp((exp_t)sf->width);
  if(!known)
    Tcutil::impos("add_bitfield_sizes: sizeof or offsetof in bitfield size");
  return i + total;
}

static type_t select_structfield_type(aggrfield_t sf) {
  // check safety
  if(strcmp(*(sf->name),"") == 0)
    Tcutil::impos("gen(): anonymous (padding) structfield not handled yet");
  if(has_bitfield(sf)) // indicating a bit-field 
    Tcutil::impos("gen(): mixed struct bitfields and union bitfields not handled");
  return sf->type;
}

static $(field_name_t,type_t)@ select_structfield_nmtype(aggrfield_t sf) {
  // check safety
  if(strcmp(*(sf->name),"") == 0)
    Tcutil::impos("gen(): anonymous (padding) structfield not handled yet");
  if(has_bitfield(sf)) // indicating a bit-field 
    Tcutil::impos("gen(): mixed struct bitfields and union bitfields not handled");
  return new $(sf->name,sf->type);
}

$(int, qvar_t)@ select_enumfield_tagnm(enumfield_t ef) {
  if(ef->tag == NULL)
    Tcutil::impos("Enum tag exp should be filled in by now");
  return new $((int)Evexp::eval_const_uint_exp((_@)ef->tag)[0],ef->name);
}

// trickiness: fwd_decls only used if creating a new ri, ignroed if updateing existing



static dict_t<type_t,repinfo_t,`H>
update_info(dict_t<type_t,repinfo_t,`H> dict,
	    type_t type,
	    list_t<decl_t,`H> decls,
	    exp_opt_t exp,
	    list_t<repinfo_t,`H> dependencies,
	    opt_t<decl_t,`H> fwd_decl) {
  // is there an info record there already?
  let info = lookup_opt(dict,type);
  if(info != NULL ) { // if so, update it with new information
    //printf("Updated ri for %s(%s)\n",typ2string(type),exp2string(exp));
    if((*info)->decls != NULL) {
      print_typerep_dict(dict);
      Tcutil::impos("Updating non-forward declaration");
    }
    (*info)->decls = decls;
    (*info)->exp = exp;
    (*info)->dependencies = dependencies;
    // emitted should be and remain 0
    return dict;
  }
  else {
    //printf("Added ri for %s (%s)\n",typ2string(type),exp2string(exp) );
    return insert(dict,type,new RepInfo{.decls=decls,
					   .exp=exp,
					   .dependencies=dependencies,
					   .fwd_decl = fwd_decl,
					   .emitted=0,
					   .is_extern=false});
  }
}

static dict_t<type_t,repinfo_t,`H>
make_fwd_decl_info(dict_t<type_t,repinfo_t,`H> dict,
		   type_t type,
		   exp_opt_t exp,
		   opt_t<decl_t,`H> fwd_decl,
		   bool is_extern) {
  // is there an info record there already?
  let info = lookup_opt(dict,type);
  if(info != NULL ) { 
    Tcutil::impos("Repinfo for fwd declaration of %s already exists",typ2string(type));
    return dict;
  }
  
  else {
    //printf("Added ri for %s (%s)\n",typ2string(type),exp2string(exp) );
    return insert(dict,type,new RepInfo{.decls=NULL,
					   .exp=exp,
					   .dependencies=NULL,
					   .fwd_decl = fwd_decl,
					   .emitted=0,
					   .is_extern=is_extern});
  }
}

static tqual_t tq_none = Tqual{.print_const=0,.q_volatile=0,.q_restrict=0,.real_const=0,.loc=NULL};

static $(tqual_t,type_t)@ tqual_type(tqual_t* tq,type_t type) {
  return new $(*tq,type);
}

static type_t tuple_typ(list_t<type_t,`H> types) {
  let tqualtypes = List::map_c(tqual_type,&tq_none,types);
  tunion Type.TupleType @ tuple_type_base = new TupleType(tqualtypes);
  type_t tuple_type = (tunion Type) tuple_type_base;
  return tuple_type;
}

// Given a type, varname, and list of exps, construct
// a sequence of decls that build an array structure, and 
// return an exp containing the array's name
static $(list_t<decl_t>, exp_t) @
array_decls(type_t type, list_t<exp_t,`H> exps, seg_t loc) {
  
  let nameexplist = List::map(gen_id_for_exp,exps);
  // generate n decls, one for each type, name, exp triple.
  let decls = List::map_c(gen_decl_cls,new $(type,loc),nameexplist);
  // then generate one decl that combines them all in an array initializer
  // step 1: find the names
  let names = List::map(get_first,nameexplist);
  let topnames = List::map(toplevel_name,names);
  let topexpnames = List::map_c(unknownid_exp_cls,loc,topnames);
  // step 2: take their addresses to get tunion Typestruct exp's
  let addrnames = List::map_c(address_exp_cls,loc,topexpnames);
  // step 3: wrap them all inside an array initializer exp
  let addrnamesexp = arr_init_exp(addrnames,loc);
  // step 4: declare an unspecified-length array initialized to this
  let arrname = new_gen_id("arr");
  let pptr_type = at_typ(type,HeapRgn,tq_none,false_conref);
  let arrty = array_typ(pptr_type,tq_none,NULL,false_conref,NULL);
  let d1 = gen_decl(arrname,arrty,addrnamesexp,loc);
  let resultexp = unknownid_exp(toplevel_name(arrname),loc);
  return new $(imp_append(decls,list(d1)),resultexp);
}

static type_t 
check_tunionfield_and_get_type(tunionfield_t tuf) {
  // preserves tquals of original tunion...
  return new TupleType(List::imp_append(List::list(new $(tq_none,uint_typ)),tuf->typs));
}
static qvar_t
check_tunionfield_and_get_name(tunionfield_t tuf) {
  // preserves tquals of original tunion...
  return tuf->name;
}

static $(qvar_t,type_t)@
check_tunionfield_and_get_nmtype(tunionfield_t tuf) {
  // preserves tquals of original tunion...
  return new $(tuf->name,new TupleType(List::imp_append(List::list(new $(tq_none,uint_typ)),tuf->typs)));
}
static $(var_t,type_t)@
check_xtunionfield_and_get_name_type(tunionfield_t tuf) {
  // preserves tquals of original tunion...
  return new $((*tuf->name)[1],new TupleType(List::imp_append(List::list(new $(tq_none,star_typ(char_typ,HeapRgn,tq_none,true_conref))),tuf->typs)));
}

// FIX: get rid of this useless stuff
static bool filter_empty_tunionfield(tunionfield_t tuf) {
  return (tuf->typs != NULL);
}
static bool filter_nonempty_tunionfield(tunionfield_t tuf) {
  return (tuf->typs == NULL);
}

static var_t get_tunionfield_name(tunionfield_t tuf) {
  return ((*tuf->name)[1]);
}


aggrfield_t substitute_structfield_type(list_t<$(tvar_t,type_t)@`H,`H> subst,
					aggrfield_t sf) {
  return new Aggrfield{sf->name,sf->tq,Tcutil::substitute(subst,sf->type),
			   sf->width,sf->attributes};
}

$(tqual_t,type_t)@ substitute_tqual_type(list_t<$(tvar_t,type_t)@`H,`H> subst,
					 $(tqual_t,type_t)@ pair) {
  let &$(tq,type) = pair;
  return new $(tq,Tcutil::substitute(subst,type));
}
tunionfield_t substitute_tunionfield_type(list_t<$(tvar_t,type_t)@`H,`H> subst,
					  tunionfield_t tf) {
  return new Tunionfield{tf->name,
			 List::map_c(substitute_tqual_type,subst,tf->typs),
			 tf->loc,tf->sc};
}


type_t monomorphize_type(type_t type) {
  //printf("monomorphizing %s\n",typ2string(type));
  switch(Tcutil::compress(type)) {
  case &AggrType(AggrInfo(info,params)):
    let ad = get_known_aggrdecl(info);
    let tvs = ad->tvs;
    if(List::length(params) != List::length(tvs))
      Tcutil::impos("gen(): number of params %d differs from number of tyvars %d",List::length(params), List::length(tvs));
    
    let subst = List::zip(tvs,params);
    list_t<aggrfield_t> fields = NULL;
    if(ad->impl != NULL) 
      fields = List::map_c(substitute_structfield_type,subst,ad->impl->fields);
    let impl = ad->impl==NULL ? NULL : new AggrdeclImpl(NULL, NULL, fields);
    aggrdecl_t ad2 = new Aggrdecl{ad->kind,ad->sc,ad->name,NULL,impl,
				  ad->attributes};
    return new AggrType(AggrInfo(KnownAggr(new ad2),NULL));

  case &TunionType(TunionInfo{KnownTunion(&tud),params,rgn}):
    let tvs = tud->tvs;
    if(List::length(params) != List::length(tvs))
      Tcutil::impos("gen(): number of params %d differs from number of tyvars %d",List::length(params), List::length(tvs));
    
    let subst = List::zip(tvs,params);
    opt_t<list_t<tunionfield_t>> fields = NULL;
    if(tud->fields != NULL) 
      fields = new Opt{List::map_c(substitute_tunionfield_type,subst,tud->fields->v)};
    let tud2 = new Tuniondecl{tud->sc,tud->name,NULL,fields,tud->is_xtunion,tud->is_flat};
    let type2 = new TunionType(TunionInfo{KnownTunion(new tud2),params,rgn});
    
    let loc = segment_of_abs(0,0);
    //printf("before: %s\n after: %s\n", 
    //decllist2string(list(new_decl(new Tunion_d(tud),loc))),
    //decllist2string(list(new_decl(new Tunion_d(tud2),loc))));
    return type2;
  
  default: return type;
  }
}

string_t make_type_cstring(type_t t) {
  mstring_t s = strdup(typ2cstring(t));
  for(int i = 0; i < strlen(s); i++) {
    if(s[i] == ' ') s[i] = '_';
    else if(!isalnum(s[i]) && (s[i] != '_')) {
      s[i] = (char)('0' + (s[i] % 10));
    }
  }
  return strconcat(s,"_rep");
}

// forward declaration
static $(dict_t<type_t,repinfo_t,`H>,repinfo_t) @
lookupRep(tenv_t te, dict_t<type_t,repinfo_t,`H> dict, seg_t loc, type_t type);



static $(dict_t<type_t,repinfo_t,`H>,list_t<repinfo_t,`H>) @
lookupRepsCls($(tenv_t,seg_t)@ env,
	      type_t type,
	      $(dict_t<type_t,repinfo_t,`H>,list_t<repinfo_t,`H>)@ carry) {
  let &$(dict,ri) = lookupRep((*env)[0],(*carry)[0],(*env)[1],type);
  return new $(dict,new List{.hd=ri,.tl=(*carry)[1]});
}


static dict_t<type_t,repinfo_t,`H>
buildRepTuple(tenv_t te, dict_t<type_t,repinfo_t,`H> dict, seg_t loc, qvar_t varname, scope_t sc, type_t type, list_t<type_t> types)
{
  let sizeof_tuple = sizeoftyp_exp(type,loc);
  // use closures here to apply partially evaluated lookuprep
  let env = new $(te,loc);
  let carry = new $(dict,NULL);
  // this should really be a fold, producing the typeris list and the dict.
  // that way, the dicts will be merged right in the end
  let &$(dict2,ris) = List::fold_right_c(lookupRepsCls,env,types,carry);
  dict = dict2;
  let indices = List::tabulate(List::length(types),identity);
  let offsetofs = List::map_c(make_offsetof_exp,new $(type,loc),indices);
  let riexps = List::map_c(get_and_cast_ri_exp,loc,ris);
  let tuplelist = List::map_c(tuple2_exp_cls,loc,List::zip(offsetofs,riexps));

  // construct the (globally unique) type of components of the tuple array
  // FIX: Make this not duplicate so much run time data.

  type_t tuple_type = tuple_typ(list(uint_typ,tunion_typ(typerep_name(&typestruct_str))));

  let &$(tupledecls,arrexp) = array_decls(tuple_type,tuplelist,loc);
  // generate a declaration
  let d2 = tunion_constructor_decl(typerep_name(&typestruct_str),
				   typerep_name(&tuple_str), 
				   varname,
				   list(sizeof_tuple,
					arrexp),
				   sc,
				   loc);
  let decls = imp_append(tupledecls,list(d2));
  
  return update_info(dict,type,decls,
		     address_exp(unknownid_exp(varname,loc),loc),
		     ris,
		     NULL);
}
static dict_t<type_t,repinfo_t,`H>
buildRepTunionfield(typedef_name_t tname, qvar_t fname, tenv_t te, dict_t<type_t,repinfo_t,`H> dict, seg_t loc, qvar_t varname, scope_t sc, type_t type, list_t<type_t> types)
{
  let sizeof_tuple = sizeoftyp_exp(type,loc);
  // use closures here to apply partially evaluated lookuprep
  let env = new $(te,loc);
  let carry = new $(dict,NULL);
  // this should really be a fold, producing the typeris list and the dict.
  // that way, the dicts will be merged right in the end
  let &$(dict2,ris) = List::fold_right_c(lookupRepsCls,env,types,carry);
  dict = dict2;
  let indices = List::tabulate(List::length(types),identity);
  let offsetofs = List::map_c(make_offsetof_exp,new $(type,loc),indices);
  let riexps = List::map_c(get_and_cast_ri_exp,loc,ris);
  let tuplelist = List::map_c(tuple2_exp_cls,loc,List::zip(offsetofs,riexps));

  // construct the (globally unique) type of components of the tuple array
  // FIX: Make this not duplicate so much run time data.

  type_t tuple_type = tuple_typ(list(uint_typ,tunion_typ(typerep_name(&typestruct_str))));
  // build name exps (ignore namespaces)
  let tnameexp = cnst_string(*(*tname)[1],loc);
  let fnameexp = cnst_string(*(*fname)[1],loc);
  let &$(tupledecls,arrexp) = array_decls(tuple_type,tuplelist,loc);
  // generate a declaration
  let d2 = tunion_constructor_decl(typerep_name(&typestruct_str),
				   typerep_name(&tunionfield_str), 
				   varname,
				   list(tnameexp, fnameexp,sizeof_tuple,
					arrexp),
				   sc,
				   loc);
  let decls = imp_append(tupledecls,list(d2));
  
  return update_info(dict,type,decls,
		     address_exp(unknownid_exp(varname,loc),loc),
		     ris,
		     NULL);
}
static dict_t<type_t,repinfo_t,`H>
buildRepStruct(opt_t<typedef_name_t> sname, tenv_t te, dict_t<type_t,repinfo_t,`H> dict, seg_t loc, qvar_t varname, scope_t sc, type_t type, list_t<$(field_name_t,type_t)@> nmtypes)
{
  let sizeof_tuple = sizeoftyp_exp(type,loc);
  // use closures here to apply partially evaluated lookuprep
  let env = new $(te,loc);
  let carry = new $(dict,NULL);
  let $(names,types) = List::split(nmtypes);
  // this should really be a fold, producing the typeris list and the dict.
  // that way, the dicts will be merged right in the end
  let &$(dict2,ris) = List::fold_right_c(lookupRepsCls,env,types,carry);
  dict = dict2;
  let indices = List::tabulate(List::length(types),identity);
  let offsetofs = List::map_c(make_offsetof_exp,new $(type,loc),indices);
  let nmexps = List::map_c(cnst_string_cls,loc,names);
  let riexps = List::map_c(get_and_cast_ri_exp,loc,ris);
  let tuplelist = List::map_c(tuple3_exp_cls,loc,List::zip3(offsetofs,nmexps,riexps));

  // construct the (globally unique) type of components of the tuple array
  // FIX: Make this not duplicate so much run time data.

  type_t tuple_type = tuple_typ(list(uint_typ,const_string_typ(HeapRgn),tunion_typ(typerep_name(&typestruct_str))));

  let &$(tupledecls,arrexp) = array_decls(tuple_type,tuplelist,loc);
  // name
  exp_t name;
  if(sname == NULL) {
    name = null_exp(loc);
  } else {
    // string_t gen_nameNN = "`*name`";
    let namename = new_gen_id("name");
    let dname = gen_decl(namename,const_string_typ(HeapRgn),cnst_string(*(*sname->v)[1],loc),loc);
    // add dname to decls
    tupledecls = new List{dname,tupledecls};
    // assign name exp
    name = address_exp(unknownid_exp(toplevel_name(namename),loc),loc);
  }
  // generate a declaration
  let d2 = tunion_constructor_decl(typerep_name(&typestruct_str),
				   typerep_name(&struct_str), 
				   varname,
				   list(name,sizeof_tuple,
					arrexp),
				   sc,
				   loc);
  let decls = imp_append(tupledecls,list(d2));
  
  return update_info(dict,type,decls,
		     address_exp(unknownid_exp(varname,loc),loc),
		     ris,
		     NULL);
}

static dict_t<type_t,repinfo_t,`H>
buildRepUnion(opt_t<typedef_name_t> uname, tenv_t te, dict_t<type_t,repinfo_t,`H> dict, seg_t loc, qvar_t varname, scope_t sc, type_t type, list_t<$(field_name_t,type_t)@> nmtypes)
{
  let sizeofexp = sizeoftyp_exp(type,loc);
  // use closures here to apply partially evaluated lookuprep
  let env = new $(te,loc);
  let carry = new $(dict,NULL);
  let $(names,types) = List::split(nmtypes);
  // this should really be a fold, producing the typeris list and the dict.
  // that way, the dicts will be merged right in the end
  let &$(dict2,ris) = List::fold_right_c(lookupRepsCls,env,types,carry);
  dict = dict2;
  let nmexps = List::map_c(cnst_string_cls,loc,names);
  let riexps = List::map_c(get_and_cast_ri_exp,loc,ris);
  let nmriexps = List::map_c(tuple2_exp_cls,loc,List::zip(nmexps, riexps));
  let tuple_type = tuple_typ(list(const_string_typ(HeapRgn),tunion_typ(typerep_name(&typestruct_str))));
  let &$(decls,arrexp) = array_decls(tuple_type,nmriexps,loc);
  // make name expression: null for now (FIX)
  // name
  exp_t name;
  if(uname == NULL) {
    name = null_exp(loc);
  } else {
    // string_t gen_nameNN = "`*name`";
    let namename = new_gen_id("name");
    let dname = gen_decl(namename,const_string_typ(HeapRgn),cnst_string(*(*uname->v)[1],loc),loc);
    // add dname to decls
    decls = new List{dname,decls};
    // assign name exp
    name = address_exp(unknownid_exp(toplevel_name(namename),loc),loc);
  }
  // generate a declaration
  let d2 = tunion_constructor_decl(typerep_name(&typestruct_str),
				   typerep_name(&union_str), 
				   varname,
				   list(name,sizeofexp,arrexp),
				   sc,
				   loc);
  return update_info(dict,type,imp_append(decls,list(d2)),
		     address_exp(unknownid_exp(varname,loc),loc),
		     ris,
		     NULL);
}
static dict_t<type_t,repinfo_t,`H>
buildRepEnum(typedef_name_t* ename, tenv_t te, dict_t<type_t,repinfo_t,`H> dict, seg_t loc, qvar_t varname, scope_t sc, type_t type, list_t<$(int,qvar_t)@> tagnms)
{
  let sizeof_enum = sizeoftyp_exp(type,loc);
  // use closures here to apply partially evaluated lookuprep
  let $(tags,names) = List::split(tagnms);
  let nmexps = List::map_c(cnst_qvar_string_cls,loc,names);
  let tagexps = List::map_c(cnst_int_cls,loc,tags);
  let tagnmexps = List::map_c(tuple2_exp_cls,loc,List::zip(tagexps, nmexps));
  let tuple_type = tuple_typ(list(uint_typ,const_string_typ(HeapRgn)));
  let &$(decls,arrexp) = array_decls(tuple_type,tagnmexps,loc);
  // name
  exp_t name;
  if(ename == NULL) {
    name = null_exp(loc);
  } else {
    // string_t gen_nameNN = "`*name`";
    let namename = new_gen_id("name");
    let dname = gen_decl(namename,const_string_typ(HeapRgn),cnst_string(*(**ename)[1],loc),loc);
    // add dname to decls
    decls = new List{dname,decls};
    // assign name exp
    name = address_exp(unknownid_exp(toplevel_name(namename),loc),loc);
  }
  // generate a declaration
  let d2 = tunion_constructor_decl(typerep_name(&typestruct_str),
				   typerep_name(&enum_str), 
				   varname,
				   list(name,sizeof_enum,arrexp),
				   sc,
				   loc);
  return update_info(dict,type,imp_append(decls,list(d2)),
		     address_exp(unknownid_exp(varname,loc),loc),
		     NULL,
		     NULL);
}

// builds Typestruct.Tunion for given set of types
static dict_t<type_t,repinfo_t,`H>
buildRepTunion(qvar_t tname, tenv_t te, dict_t<type_t,repinfo_t,`H> dict, seg_t loc, qvar_t varname, scope_t sc, type_t type, list_t<qvar_t> tonames, list_t<$(qvar_t,type_t)@> nmtypes){
  
  // first, build the tagonly list.
  let tagints = List::tabulate(List::length(tonames), identity);
  let totags = List::map_c(cnst_int_cls,loc,tagints);
  let nmexps = List::map_c(cnst_qvar_string_cls,loc,tonames);
  let tagnmexps = List::zip(totags, nmexps);
  let tuplelist1 = List::map_c(tuple2_exp_cls,loc,tagnmexps);
  let tuple_type1 = tuple_typ(list(uint_typ, const_string_typ(HeapRgn)));
  let &$(tupledecls1,arrexp1) = array_decls(tuple_type1,tuplelist1,loc);

  // then build the tag+data list.
  let env = new $(te,loc);
  let carry = new $(dict,NULL);
  let $(names,types) = List::split(nmtypes);
  // fetch (building if necessary) repinfos for all component types
  let &$(dict2,ris) = List::fold_right_c(lookupRepsCls,env,types,carry);
  dict = dict2;
  // build tag list of appropriate length
  let tagints = List::tabulate(List::length(ris),identity);
  let tags = List::map_c(cnst_int_cls,loc,tagints);
  // build list of name exps
  let nmexps = List::map_c(cnst_qvar_string_cls, loc, names);
  // build list of tunion case types
  let riexps = List::map_c(get_and_cast_ri_exp,loc,ris);
  // pair these with tags 
  let tagnmriexps = List::zip3(tags,nmexps,riexps);
  let tuplelist2 = List::map_c(tuple3_exp_cls,loc,tagnmriexps);
  // build the type of elements of Tunion array
  type_t tuple_type2 = tuple_typ(list(uint_typ,const_string_typ(HeapRgn),tunion_typ(typerep_name(&typestruct_str))));
  let &$(tupledecls2,arrexp2) = array_decls(tuple_type2,tuplelist2,loc);
  // build name expression
  let name = cnst_string(*(*tname)[1],loc); // ignore namespace for now
  // generate a declaration
  let d2 = tunion_constructor_decl(typerep_name(&typestruct_str),
				   typerep_name(&tunion_str), 
				   varname,
				   list(name,arrexp1,arrexp2),
				   sc,
				   loc);
  return update_info(dict,type,imp_append(tupledecls1,imp_append(tupledecls2,list(d2))),
		     address_exp(unknownid_exp(varname,loc),loc),
		     ris,
		     NULL);
  return dict;
}
// builds Typestruct.XTunion for given set of types
static dict_t<type_t,repinfo_t,`H>
buildRepXTunion(qvar_t xname, tenv_t te, dict_t<type_t,repinfo_t,`H> dict, seg_t loc, qvar_t varname, scope_t sc, type_t type, list_t<$(var_t,type_t)@> nametypes){
  let $(names,types) = List::split(nametypes);
  let env = new $(te,loc);
  let carry = new $(dict,NULL);
  // fetch (building if necessary) repinfos for all component types
  let &$(dict2,ris) = List::fold_right_c(lookupRepsCls,env,types,carry);
  dict = dict2;
  // build tag list of appropriate length
  let tags = List::map_c(cnst_string_cls,loc,names);
  // build list of tunion case types
  let riexps = List::map_c(get_and_cast_ri_exp,loc,ris);
  // pair these with tags 
  let tagriexps = List::zip(tags,riexps);
  let tuplelist = List::map_c(tuple2_exp_cls,loc,tagriexps);
  // build the type of elements of Tunion array
  type_t name_type = dyneither_typ(char_typ,HeapRgn,Tqual{.print_const=true,.q_volatile=false,.q_restrict=0,.real_const=true,.loc=NULL},true_conref);
  type_t tuple_type = tuple_typ(list(name_type,
				     tunion_typ(typerep_name(&typestruct_str))));
  let &$(tupledecls,arrexp) = array_decls(tuple_type,tuplelist,loc);
  // build name (ignoring namespace for now)
  let name = cnst_string(*(*xname)[1],loc); // ignore namespace for now
  // generate a declaration
  let d2 = tunion_constructor_decl(typerep_name(&typestruct_str),
				   typerep_name(&xtunion_str), 
				   varname,
				   list(name,arrexp),
				   sc,
				   loc);
  return update_info(dict,type,imp_append(tupledecls,list(d2)),
		     address_exp(unknownid_exp(varname,loc),loc),
		     ris,
		     NULL);
  return dict;
}
/*------------------------------------------------------------------------*/
// Given a type, looks for the typestruct decl for that type in the
// dictionary.  If found, it returns the dictionary back, along
// with an expression containing the variable name of the decl.
// If not found, it generates the decl(s), enters them into the
// dictionary, and returns as before.  Will operate recursively.
static $(dict_t<type_t,repinfo_t,`H>,repinfo_t) @
lookupRep(tenv_t te, dict_t<type_t,repinfo_t,`H> dict, seg_t loc, type_t type)
{
  //  printf("Type %s (%x)\n", typ2string(type),type);


  repinfo_t* info = lookup_opt(dict,type);

  if (info != NULL) {
    if((*info)->is_extern) {
      //printf("removing externdecl for %s\n",typ2string(type));
      
      dict = Dict::delete(dict,type);
    }
    else {
      //printf("Done %s\n",typ2string(type));
      let ret = new $(dict,*info);
      return ret;
    }
  }
  
  switch (Tcutil::compress(monomorphize_type(type))) {
  case &IntType(sn,sz):
    
    // tunion Typestruct.Int rep = Int(sn,sz);
    let varname = toplevel_name(new_gen_id("rep"));
    let d1 = tunion_constructor_decl(typerep_name(&typestruct_str),
				     typerep_name(&int_str), 
				     varname,
				     list(cnst_int(sn==Signed?1:0,loc),
					  cnst_int(size_of2int(sz),loc)),
				     Static,
				     loc);     
    dict = update_info(dict,
		       type,
		       list(d1),
		       address_exp(unknownid_exp(varname,
						 loc),loc),
		       NULL,NULL);
    break;
  case FloatType:
    dict = update_info(dict,
		       type,
		       NULL,
		       unknownid_exp(typerep_name(&float_str),loc),
		       NULL,NULL);
    break;
  case &DoubleType(b):
    dict = update_info(dict,
		       type,
		       NULL,
		       unknownid_exp(typerep_name(&double_str),loc),
		       NULL,NULL);
    break;
    
  case &PointerType(pt): // ptr_info_t
    //printf("Pointer type: %s (%x)\n", typ2string(pt.elt_typ),pt.elt_typ);
    switch(conref_val(pt.ptr_atts.bounds)) {
    case &Upper_b(e):
      let varname = toplevel_name(new_gen_id("rep"));
      // fwd_decl = extern tunion Typestruct.Tuple `varname`;
      let fwd_decl = new Opt{.v=gen_vardecl(varname,tunionfield_typ(typerep_name(&typestruct_str),typerep_name(&thinptr_str)),NULL,Extern,loc)};
      dict = make_fwd_decl_info(dict,type,address_exp(unknownid_exp(varname,loc),loc),fwd_decl,false);
      
      let &$(dict2,base_info) = lookupRep(te,dict,loc,pt.elt_typ);
      dict = dict2;
      
      // tunion Typestruct.ThinPtr gen = ThinPtr(`bound`,`base_info->exp`);
      let d1 = tunion_constructor_decl(typerep_name(&typestruct_str),
				       typerep_name(&thinptr_str), 
				       varname,
				       list(e,
					    (exp_t)base_info->exp),Static,loc);
      
	
      dict = update_info(dict,
			 type,
			 list(d1),
			 address_exp(unknownid_exp(varname,loc),loc),
			 list(base_info),NULL);
      break;
    case DynEither_b:
      // a ? pointer
      // tunion Typestruct.FatPtr(`base_info->exp`);
      let varname = toplevel_name(new_gen_id("rep"));

	// fwd_decl = extern tunion Typestruct.Tuple `varname`;
      let fwd_decl = new Opt{.v=gen_vardecl(varname,tunionfield_typ(typerep_name(&typestruct_str),typerep_name(&fatptr_str)),NULL,Extern,loc)};
      dict = make_fwd_decl_info(dict,type,address_exp(unknownid_exp(varname,loc),loc),fwd_decl,false);

      let &$(dict2,base_info) = lookupRep(te,dict,loc,pt.elt_typ);
      dict = dict2;

      let d1 = tunion_constructor_decl(typerep_name(&typestruct_str),
				       typerep_name(&fatptr_str), 
				       varname,
				       list((exp_t)base_info->exp),Static,loc);
      dict = update_info(dict,
			 type,
			 list(d1),
			 address_exp(unknownid_exp(varname,loc),loc),
			 list(base_info),NULL);
      break;
    }
    break;
  case &ArrayType(ArrayInfo{arrtype,tq,e,zt,_}):
    // FIX: need to deal with zero-termination
    if(e == NULL) {
      Tcutil::impos("tcgenrep:At this point, array bounds must be constants");
    }
    // get info for base type
    let &$(dict2,base_info) = lookupRep(te,dict,loc,arrtype);
    dict = dict2;
    // tunion Typestruct.ThinPtr gen = ThinPtr(`bound`,`base_info->exp`);
    let varname = toplevel_name(new_gen_id("rep"));
    let d1 = tunion_constructor_decl(typerep_name(&typestruct_str),
				     typerep_name(&thinptr_str), 
				     varname,
				     list((exp_t)e,
					  (exp_t)base_info->exp),Static,loc);
    dict = update_info(dict,
		       type,
		       list(d1),
		       address_exp(unknownid_exp(varname,loc),loc),
		       list(base_info),NULL);
    break;
  case &TupleType(fields):
    // idea: generate reps for each component type
    // emit 
    // tunion Typestruct.Tuple tuple_rep = Tuple(sizeof(tuple_type),
    //                                    (sizeof(t1),rep_exp(t1),...));
    // problems: what to do about tq's?
    // FIX: forward declarations because of resursion and structural identity
    let varname = toplevel_name(new_gen_id("rep"));
    let fwd_decl = new Opt{.v=gen_vardecl(varname,tunionfield_typ(typerep_name(&typestruct_str),typerep_name(&tuple_str)),NULL, Extern, loc)};
    dict = make_fwd_decl_info(dict,type,address_exp(unknownid_exp(varname,loc),loc),fwd_decl,false);
    let types = List::map(get_second,fields);
    dict = buildRepTuple(te,dict,loc,varname,Static,type,types);
    break;
  case &TypedefType(name,params,td,def):
    if(def == NULL) 
      Tcutil::impos("gen(): can't gen for abstract typedef");
    // lookup rep for definition
    // throws away current "info"
    let &$(dict2,info2) = lookupRep(te,dict,loc,*def);
    dict = insert(dict2,type,info2);
    break;

  case VoidType: 
    Tcutil::terr(loc,"found void in gen() expression"); break;
  case &Evar(_,_,_,_):
    Tcutil::terr(loc,"found evar in gen() expression"); break;
  case &VarType(tvar):
    Tcutil::terr(loc,"found tyvar in gen() expression");
    /*      // string_t name = `*tvar->name`;
	    let strname = new_gen_id("name");
	    let d1 = gen_decl(strname,string_typ(HeapRgn),cnst_string(*tvar->name,loc),loc);
	    // tunion Typestruct.Var gen = Var(&name);
	    let varname = new_gen_id("gen");
	    let d2 = tunion_constructor_decl(&typestruct_str,&var_str, varname,
	    list(address_exp(unknownid_exp(toplevel_name(strname),loc),loc)),
	    loc);     
	    dict = update_info(dict,
	    type,
	    list(d1,d2),
	    address_exp(unknownid_exp(toplevel_name(varname),
	    loc),loc),
	    NULL,NULL);
    */
    break;
  case &FnType(fi): 
    Tcutil::terr(loc,"found function type in gen() expression");
    break;
    // conceivably we might have to marshal these somehow... how?
  case &RgnHandleType(_): 
  case &DynRgnType(_,_): 
  case UniqueRgn:           
  case HeapRgn:           
  case &AccessEff(_):     
  case &JoinEff(_):
  case &RgnsEff(_):       
    Tcutil::terr(loc,"gen(): unhandled region, handle or effect type");
    break;
  case &TunionType(TunionInfo{KnownTunion(&tudecl),params,rgn}):
    if(tudecl->tvs != NULL) 
      Tcutil::impos("gen(): tunion type variables not handled yet");
    if(tudecl->fields == NULL) {      
      let varname = toplevel_name(new make_type_cstring(type));
      let fwd_decl = new Opt{.v=gen_vardecl(varname,tunionfield_typ(typerep_name(&typestruct_str),typerep_name(&tunion_str)),NULL,Extern,loc)};
      //printf("adding externdecl for %s\n",qvar2string(varname));
      dict = make_fwd_decl_info(dict,
				type,
				address_exp(unknownid_exp(varname,loc),loc),
				fwd_decl,true);
      break;
      //Tcutil::impos("gen(): tunion fields must be present by now");
    }
    if(!tudecl->is_xtunion) {
      // build fwd decl in case of recursion
      let varname = toplevel_name(new make_type_cstring(type));
      // fwd_decl = extern tunion Typestruct.Tuple `varname`;
      let fwd_decl = new Opt{.v=gen_vardecl(varname,tunionfield_typ(typerep_name(&typestruct_str),typerep_name(&tunion_str)),NULL,Extern,loc)};
      dict = make_fwd_decl_info(dict,type,address_exp(unknownid_exp(varname,loc),loc),fwd_decl,false);
      let fields = tudecl->fields->v;
      let nonemptyfields = List::filter(filter_empty_tunionfield,fields);
      let emptyfields = List::filter(filter_nonempty_tunionfield,fields);
      let nmtypes = List::map(check_tunionfield_and_get_nmtype,nonemptyfields);
      let tonames = List::map(check_tunionfield_and_get_name,emptyfields);
      // this builds absyn for Typestruct.Tunion with appropriate entries
      dict = buildRepTunion(tudecl->name,te,dict,loc,varname,Public,type,tonames,nmtypes);
    }
    else {
      // build fwd decl in case of recursion
      let varname = toplevel_name(new make_type_cstring(type));
      // fwd_decl = extern tunion Typestruct.Tuple `varname`;
      let fwd_decl = new Opt{.v=gen_vardecl(varname,tunionfield_typ(typerep_name(&typestruct_str),typerep_name(&xtunion_str)),NULL,Extern,loc)};
      dict = make_fwd_decl_info(dict,type,address_exp(unknownid_exp(varname,loc),loc),fwd_decl,false);
      let fields = tudecl->fields->v;
      let nonemptyfields = List::filter(filter_empty_tunionfield,fields);
      let types = List::map(check_xtunionfield_and_get_name_type,nonemptyfields);
      // this builds absyn for Typestruct.Tunion with appropriate entries
      dict = buildRepXTunion(tudecl->name,te,dict,loc,varname,Public,type,types);
      //Tcutil::impos("gen(): xtunions not yet handled");
    }
      break;
  case &TunionType(_):
    Tcutil::impos("gen(): tunion must be resolved by now");
  case &TunionFieldType(tfieldinfo): // tunion_field_info_t
    // should be similar to tuple
    if(tfieldinfo.targs != NULL)
      Tcutil::impos("gen(): tunionfield type parameters not handled yet");
    switch (tfieldinfo.field_info) {
    case KnownTunionfield(decl,field):
      let types = List::map(get_second,field->typs);
      let types2 = new List(uint_typ,types);
      let varname = toplevel_name(new_gen_id("rep"));
      dict = buildRepTunionfield(decl->name,field->name,te,dict,loc,varname,Static,type,types2);
      break;
    default:
      Tcutil::impos("gen(): tunionfield must be known at this point");
    }
    break;

  case &AggrType(AggrInfo(info,params)): // MemKind
    let adecl = get_known_aggrdecl(info);
    if(adecl->impl != NULL && adecl->impl->exist_vars != NULL)
      Tcutil::impos("gen(): existential type variables not yet supported");
    if(adecl->kind == StructA) {
      let stdecl = adecl;
      // Almost identical to Tuple case.
      // Filter structfield list of stdecl to form like that in tuple case
      // Wrinkle: anonymous padding bytes (would like to omit, but safe to include)
      // Wrinkle: Type parameters
      // Wrinkle: Recursive structs (recursive uses of struct name within def)
      /*	if (stdecl->tvs != NULL) {
		//	  Tcutil::impos("gen(): structs with tyvariables not yet supported");
		print_tvars(stdecl->tvs);
		}*/
      if (stdecl->impl == NULL) {
	// This indicates an imported struct.
	// Generate a forward decl of the imported typerep
	// Generate a reference to a standard name.
	//string_t s = strconcat(qvar2cstring((qvar_t)name),"_struct_typerep");
	//let varname = new $((*name)[0],new make_type_cstring(type));
	let varname = toplevel_name(new make_type_cstring(type));
	let fwd_decl = new Opt{.v=gen_vardecl(varname,tunionfield_typ(typerep_name(&typestruct_str),typerep_name(&struct_str)),NULL,Extern,loc)};
	//printf("adding externdecl for %s\n",qvar2string(varname));
	dict = make_fwd_decl_info(dict,
				  type,
				  address_exp(unknownid_exp(varname,loc),loc),
				  fwd_decl,true);
	break;
	
	//Tcutil::impos("gen(): external structs not yet handled");
      }
      if(stdecl->impl->fields != NULL 
	 && forall(has_bitfield,stdecl->impl->fields)) {
	let bits = fold_left(add_bitfield_sizes,0,stdecl->impl->fields);
	let bytes = bits / 8 + ((bits % 8) == 0 ? 0 : 1);
	list_t<$(tqual_t,type_t)@> chars = NULL;
	for(int i = 0; i < bytes; i++) {
	  chars = new List(new $(tq_none,char_typ),chars);
	}
	type_t base_type = new TupleType(chars);
	let &$(dict2,base_info) = lookupRep(te,dict,loc,base_type);
	dict = insert(dict2,type,base_info);
      } else {
	// Add forward declaration in case of recursive struct
	// Gensym a new var name & create an address exp for exp; this
	// exp is needed 
	//string_t s = strconcat(qvar2cstring((qvar_t)name),"_struct_typerep");
	//let varname = new $((*name)[0],new make_type_cstring(type));
	let varname = toplevel_name(new make_type_cstring(type));
	// fwd_decl = extern tunion Typestruct.Tuple `varname`;
	let fwd_decl = new Opt{.v=gen_vardecl(varname,tunionfield_typ(typerep_name(&typestruct_str),typerep_name(&struct_str)),NULL,Extern,loc)};
	dict = make_fwd_decl_info(dict,type,address_exp(unknownid_exp(varname,loc),loc),fwd_decl,false);
	let nmtypes = List::map(select_structfield_nmtype,stdecl->impl->fields);
	dict = buildRepStruct(new Opt{stdecl->name},te,dict,loc,varname,Public,type,nmtypes);
      }
    } else {
      let udecl = adecl;
      // union case
      if(udecl->tvs != NULL)
	Tcutil::impos("gen: unions with parameters not yet supported");
      if (udecl->impl == NULL) {
	let varname = toplevel_name(new make_type_cstring(type));
	let fwd_decl = new Opt{.v=gen_vardecl(varname,tunionfield_typ(typerep_name(&typestruct_str),typerep_name(&union_str)),NULL,Extern,loc)};
      //printf("adding externdecl for %s\n",qvar2string(varname));
	dict = make_fwd_decl_info(dict,
				  type,
				  address_exp(unknownid_exp(varname,loc),loc),
				  fwd_decl,true);
	break;
	//Tcutil::impos("gen(): union fields must be present by now");
      }
      let nmtypes = List::map(select_structfield_nmtype,udecl->impl->fields);
      
      let varname = toplevel_name(new make_type_cstring(type));
      dict = buildRepUnion(new Opt{udecl->name},te,dict,loc,varname,Public,type,nmtypes);
    }
    break;

    
      
  case &AnonAggrType(StructA,fields):
    // Almost identical to Struct case.
    // Filter structfield list of stdecl to form like that in tuple case
    // Wrinkle: anonymous padding bytes (would like to omit, but safe to include)
    if(fields != NULL && forall(has_bitfield,fields)) {
      let bits = fold_left(add_bitfield_sizes,0,fields);
      let bytes = bits / 8 + ((bits % 8) == 0 ? 0 : 1);
      type_t base_type = array_typ(char_typ,tq_none,cnst_int(bytes,loc),
                                   true_conref,NULL);
      let &$(dict2,base_info) = lookupRep(te,dict,loc,base_type);
      dict = insert(dict2,type,base_info);
    } else {
      let nmtypes = List::map(select_structfield_nmtype,fields);
      let varname = toplevel_name(new_gen_id("rep"));
      dict = buildRepStruct(NULL,te,dict,loc,varname,Static,type,nmtypes);
    }
    break;

  case &AnonAggrType(UnionA,fields):
    // Almost identical to Struct case.
    // Filter structfield list of stdecl to form like that in tuple case
    // Wrinkle: anonymous padding bytes (would like to omit, but safe to include)
    let nmtypes = List::map(select_structfield_nmtype,fields);
    let varname = toplevel_name(new_gen_id("rep"));
    dict = buildRepUnion(NULL,te,dict,loc,varname,Static,type,nmtypes);
    break;

    // FIX: Convert this to Enum typestructs.
  case &EnumType(_,edeclopt): 
    if(edeclopt == NULL)
      Tcutil::impos("gen(): enum declaration must be present by now");
    let edecl = *edeclopt;
    if (edecl.fields == NULL) {
      let varname = toplevel_name(new make_type_cstring(type));
      let fwd_decl = new Opt{.v=gen_vardecl(varname,tunionfield_typ(typerep_name(&typestruct_str),typerep_name(&enum_str)),NULL,Extern,loc)};
      //printf("adding externdecl for %s\n",qvar2string(varname));
      dict = make_fwd_decl_info(dict,
				type,
				address_exp(unknownid_exp(varname,loc),loc),
				fwd_decl,true);
      break;
    }
    let tagnms = List::map(select_enumfield_tagnm,edecl.fields->v);
    let varname = toplevel_name(new make_type_cstring(type));
    dict = buildRepEnum(&edecl.name,te,dict,loc,varname,Public,type,tagnms);
    break;
    
  case &AnonEnumType(fields): 
    let tagnms = List::map(select_enumfield_tagnm,fields);
    let varname = toplevel_name(new_gen_id("rep"));
    dict = buildRepEnum(NULL,te,dict,loc,varname,Static,type,tagnms);
    break;

    // tunion Typestruct.Int rep = Int(sn=false,32);
    /*    let varname = toplevel_name(new_gen_id("rep"));
    let d1 = tunion_constructor_decl(typerep_name(&typestruct_str),
				     typerep_name(&int_str), 
				     varname,
				     list(cnst_int(0,loc), // false (unsigned)
					  cnst_int(32,loc)),
				     Static,
				     loc);     
    dict = update_info(dict,
		       type,
		       list(d1),
		       address_exp(unknownid_exp(varname,
						 loc),loc),
		       NULL,NULL);
		       break;*/
    //    default:
    //      Tcutil::impos("gen() expression not yet supported");
    //      throw Tcutil::TypeErr; // redundant, as impos will do this
  case &TagType(_):
    Tcutil::impos("gen() for tag_t<-> not yet supported");
  case &ValueofType(_):
    Tcutil::impos("gen() for valueof_t<-> not yet supported");
  }
  //printf("Done %s\n",typ2string(type));
  return new $(dict,lookup(dict,type));
}



static bool not_emitted_filter(repinfo_t ri) {
  return (ri->emitted == 0);
}
static void mark_emitted(repinfo_t ri) {
  ri->emitted = 1;
}
/*------------------------------------------------------------------------*/
// Replaces a gen(t) expression with a Typestruct value.  As a result,
// it needs to generate a number of static declarations of data, and 
// finally an expression of type tunion Typestruct.  FIX: take in
// and return a Dictionary so that we can reuse declarations from
// previous gen()'s in the same file.
$(dict_t<type_t,repinfo_t,`H>,list_t<decl_t>,exp_t)
  tcGenrep(tenv_t te, genv_t ge, seg_t loc, type_t type,dict_t<type_t,repinfo_t,`H> dict)
{
  // first check that type is well-formed
  Tcutil::check_valid_toplevel_type(loc,te,type);
  Tcutil::check_valid_toplevel_type(loc,te,type);

  // generate the declarations
  let &$(dict,ri) = lookupRep(te, dict, loc, type);  
  let decls = dfs(ri);
  //printf("Emitting...\n%s\n",decllist2string(decls));
  

  return $(dict,decls, (exp_t)ri->exp);
}

