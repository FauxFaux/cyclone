stdio.h:
BUFSIZ
_IOFBF
_IOLBF
_IONBF
SEEK_CUR
SEEK_END
SEEK_SET
FILENAME_MAX
FOPEN_MAX
EOF
fpos_t
size_t
wchar_t
{
#include <core.h>
namespace Std {
using Core;
/* The name __sFILE is derived from Cygwin but we have our own
   implementation in runtime_cyc.c */
extern struct __sFILE;  
typedef struct __sFILE FILE;

/* Standard streams.  */
extern FILE @stdout;
extern FILE @stdin;
extern FILE @stderr;

/* Remove file FILENAME.  */
extern int remove (const char ?);
/* Rename file OLD to NEW.  */
extern int rename (const char ?, const char ?);

/* Close STREAM.  */
extern int fclose (FILE @);
/* Flush STREAM, or all streams if STREAM is NULL.  */
extern int fflush (FILE *);

/* Open a file and create a new stream for it.  */
extern FILE *fopen (const char ?__filename, const char ?__modes);
/* Open a file, replacing an existing stream with it. */
extern FILE *freopen (const char ?, const char ?, FILE @);

/* If BUF is NULL, make STREAM unbuffered.
   Else make it use buffer BUF, of size BUFSIZ.  */
extern void setbuf (FILE @ __stream, char ? __buf);
/* Make STREAM use buffering mode MODE.
   If BUF is not NULL, use N bytes of it for buffering;
   else allocate an internal buffer N bytes long.  */
extern int setvbuf (FILE @ __stream, char ? __buf,
		    int __modes, size_t __n);

/* Read a character from STREAM.  */
extern int fgetc (FILE @__stream);
extern int getc (FILE @__stream);

/* Read a character from stdin.  */
  //FIX: not much use doing this because getc is not a macro
#define	getchar() getc(stdin)

/* Get a newline-terminated string from stdin, removing the newline.
   DO NOT USE THIS FUNCTION!!  There is no limit on how much it will read.  */
// extern string     gets(string); // unsafe!

/* Get a newline-terminated string of finite length from STREAM.  */
extern char ?`r fgets (char ?`r __s, int __n, FILE @ __stream);

/* Write a character to STREAM.  */
extern int fputc (int __c, FILE @__stream);
extern int putc (int __c, FILE @__stream);

/* Write a character to stdout.  */
  //FIX: not much use doing this because putc is not a macro, no speedup
#define	putchar(__c) putc(__c, stdout)

/* Write a string to STREAM.  */
extern int fputs (const char ? __s, FILE @ __stream);
/* Write a string, followed by a newline, to stdout.  */
extern int puts (const char ? __s);

/* Push a character back onto the input buffer of STREAM.  */
extern int ungetc (int __c, FILE @ __stream);

/* Read chunks of generic data from STREAM.  */
extern size_t fread (char ? __ptr, size_t __size,
		     size_t __n, FILE @ __stream);
/* Write chunks of generic data to STREAM.  */
extern size_t fwrite (const char ? __ptr, size_t __size,
		      size_t __n, FILE @ __s);

/* Seek to a certain position on STREAM.  */
extern int fseek (FILE @__stream, long __off, int __whence);
/* Return the current position of STREAM.  */
extern long ftell (FILE @__stream);
/* Rewind to the beginning of STREAM.  */
extern void rewind (FILE @__stream);

/* Get STREAM's position.  */
extern int fgetpos (FILE @__stream, fpos_t @ __pos);
/* Set STREAM's position.  */
extern int fsetpos (FILE @__stream, fpos_t @ __pos);

/* Clear the error and EOF indicators for STREAM.  */
extern void clearerr (FILE @__stream);
/* Return the EOF indicator for STREAM.  */
extern int feof (FILE @__stream);
/* Return the error indicator for STREAM.  */
extern int ferror (FILE @__stream);

/* Print a message describing the meaning of the value of errno.  */
extern void perror (const char ?__s);

/* Create a new stream that refers to an existing system file descriptor.  */
extern FILE *fdopen (int __fd, const char ?__modes);

/* Return the system file descriptor for STREAM.  */
extern int fileno (FILE @__stream);

/* Get a word (int) from STREAM.  */
extern int getw (FILE @__stream);

/* Write a word (int) to STREAM.  */
extern int putw (int __w, FILE @__stream);

  //FIX: setbuffer and setlinebuf only if __USE_BSD
/* If BUF is NULL, make STREAM unbuffered.
   Else make it use SIZE bytes of BUF for buffering.  */
extern void setbuffer (FILE @__stream, char ?__buf, size_t __size);
/* Make STREAM line-buffered.  */
extern void setlinebuf (FILE @__stream);

// 
// Routines added for Cyclone
//
extern xtunion exn {
  extern FileOpenError(const char ?);
  extern FileCloseError;
};

extern FILE @file_open(const char ?`r1 fname, const char ?`r2 mode);
extern void file_close(FILE @`r);
extern void file_delete(const char ?`r);
extern void file_length(const char ?`r);
// these two provided in cyc_runtime.c
extern int file_string_read(FILE @`r1 fd, char ?`r2 dest, int dest_offset, 
			    int max_count);
extern int file_string_write(FILE @`r1 fd, const char?`r2 src, int src_offset, 
			     int max_count);

//////////////////////////////////////////////////////////////
// printf and friends:  see printf.cyc
//////////////////////////////////////////////////////////////
// vararg union for printf, fprintf, sprintf 
extern tunion PrintArg<`r::R> {
  String_pa(const char ?`r);
  Int_pa(unsigned long);
  Double_pa(double);
  ShortPtr_pa(short @`r);
  IntPtr_pa(unsigned long @`r);
};
typedef tunion `r PrintArg<`r> parg_t<`r>;

// Printing functions behave as with C
extern int fprintf(FILE @`r1,const char ?`r2 fmt, ... inject parg_t<`r4>)
  __attribute__((format(printf,2,3)))
  ;
extern int printf(const char ?`r fmt, ... inject parg_t<`r2>)
  __attribute__((format(printf,1,2)))
  ;
extern int sprintf(char ?`r1 s, const char ?`r2 fmt, ... inject parg_t<`r4>)
  __attribute__((format(printf,2,3)))
  ;
// Similar to sprintf but allocates a result of the right size
extern char ? aprintf(const char ?`r2 fmt, ... inject parg_t<`r4>)
  __attribute__((format(printf,1,2)))
  ;
extern char ?`r1 rprintf(region_t<`r1>, const char ?`r2 fmt, 
                         ... inject parg_t<`r4> ap)
  __attribute__((format(printf,2,3)))
  ;

// Same as above but suitable for calling from a user's vararg function
extern int vfprintf(FILE @`r1,const char ?`r2 fmt, parg_t<`r3> ? `r4 ap)
  __attribute__((format(printf,2,0)))
  ;
extern int vprintf(const char ?`r fmt, parg_t<`r2> ? `r1)
  __attribute__((format(printf,1,0)))
  ;
extern int vsprintf(char ?`r1 s, const char ?`r2 fmt, parg_t<`r4> ? `r3)
  __attribute__((format(printf,2,0)))
  ;
extern char ?`r1 vrprintf(region_t<`r1> r1, const char ?`r2 fmt, 
                          parg_t<`r4> ? `r3 ap)
  __attribute__((format(printf,2,0)))
  ;

//////////////////////////////////////////////////////////////
// scanf and friends:  see scanf.cyc
//////////////////////////////////////////////////////////////
// vararg tunion for scanf, fscanf, sscanf, etc.
extern tunion ScanfArg<`r::R> {
  ShortPtr_sa(short @`r);
  UShortPtr_sa(unsigned short @`r);
  IntPtr_sa(int @`r);
  UIntPtr_sa(unsigned int @`r);
  StringPtr_sa(char ?`r);
  DoublePtr_sa(double @`r);
  FloatPtr_sa(float @`r);
};
typedef tunion `r2 ScanfArg<`r1> sarg_t<`r1,`r2>;

// Scanning functions behave as in C...
extern int scanf(const char ?`r1 fmt, ... inject sarg_t<`r3,`r4>)
  __attribute__((format(scanf,1,2)))
  ;
extern int fscanf(FILE @`r1 stream, const char ?`r2 fmt, 
                     ... inject sarg_t<`r4,`r5>)
  __attribute__((format(scanf,2,3)))
  ;
extern int sscanf(const char ?`r src, const char ?`r1 fmt, 
                     ... inject sarg_t<`r3,`r4>)
  __attribute__((format(scanf,2,3)))
  ;


// Same as above but suitable for calling from a user's vararg function
extern int vfscanf(FILE @`r1 stream, const char ?`r2 fmt, 
                   sarg_t<`r3,`r4> ? `r5)
  __attribute__((format(scanf,2,0)))
  ;
extern int vsscanf(const char ?`r src, const char ?`r1 fmt, 
                   sarg_t<`r3,`r4> ? `r2)
  __attribute__((format(scanf,2,0)))
  ;
}
}

stdlib.h:
EXIT_FAILURE
EXIT_SUCCESS
RAND_MAX
div_t
ldiv_t
lldiv_t
size_t
wchar_t
WNOHANG
WUNTRACED
WEXITSTATUS
WIFEXITED
WIFSIGNALED
WIFSTOPPED
WSTOPSIG
WTERMSIG
{
/* Get size_t from <stddef.h> */
#include <cstddef.h>
#include <core.h>

namespace Std {
extern "C" {
int system(Cstring);

/* Return the absolute value of X.  */
extern int abs (int __x);

/* Register a function to be called when `exit' is called.  */
extern int atexit (void (*__func) (void));

/* Return the `div_t' or `ldiv_t' representation
   of the value of NUMER over DENOM. */
/* GCC may have built-ins for these someday.  */
extern div_t div (int __numer, int __denom);
extern ldiv_t ldiv (long int __numer, long int __denom);

/* These are the functions that actually do things.  The `random', `srandom',
   `initstate' and `setstate' functions are those from BSD Unices.
   The `rand' and `srand' functions are required by the ANSI standard.
   We provide both interfaces to the same random number generator.  */
/* Return a random long integer between 0 and RAND_MAX inclusive.  */
extern long int random (void);

/* Seed the random number generator with the given number.  */
extern void srandom (unsigned int __seed);

/* Return a random integer between 0 and RAND_MAX inclusive.  */
extern int rand (void);
/* Seed the random number generator with the given number.  */
extern void srand (unsigned int __seed);
/* Reentrant interface according to POSIX.1.  */
extern int rand_r (unsigned int *__seed);

  // THE NEXT TWO FUNCTIONS MIGHT NEED TO BE COMMENTED OUT IN LINUX
/* Chown the slave to the calling user.  */
extern int grantpt (int __fd);

/* Release an internal lock so the slave can be opened.
   Call after grantpt().  */
extern int unlockpt (int __fd);
}

/* Convert a string to a floating-point number.  */
extern double atof(const char ?`r);
/* Convert a string to an integer.  */
extern int atoi(const char ?`r);
/* Convert a string to a long integer.  */
extern long atol(const char ?`r);

/* Return the value of envariable NAME, or NULL if it doesn't exist.  */
extern char ?getenv(const char ?);

/* Convert a string to a floating-point number.  */
extern double strtod(const char ?`r n, const char ?`r *`r2 end);
/* Convert a string to a long integer.  */
extern long strtol(const char ?`r n, const char ?`r *`r2 end, int base);
/* Convert a string to an unsigned long integer.  */
extern unsigned long strtoul(const char ?`r n,const char ?`r *`r2 end, int base);
}
}

stddef.h:
ptrdiff_t
size_t
{}

sys/stat.h:
stat
**OMIT_VARIABLE stat
S_IFBLK
S_IFCHR
S_IFIFO
S_IFREG
S_IFDIR
S_IFLNK
S_IFSOCK
S_IRWXU
S_IRUSR
S_IWUSR
S_IXUSR
S_IRWXG
S_IRGRP
S_IWGRP
S_IXGRP
S_IRWXO
S_IROTH
S_IWOTH
S_IXOTH
S_ISUID
S_ISGID
S_ISVTX
S_ISBLK
S_ISCHR
S_ISDIR
S_ISFIFO
S_ISREG
S_ISLNK
S_ISSOCK
S_TYPEISMQ
S_TYPEISSEM
S_TYPEISSHM
S_TYPEISTMO
{
#include <Core.h> // for string_t
namespace Std {
  extern int chmod(string_t, mode_t);
  extern "C" int fchmod(int, mode_t);
  extern "C" int fstat(int fd, struct stat @buf);
  extern int lstat(string_t filename, struct stat @buf);
  extern int mkdir(string_t pathname, mode_t mode);
  extern int mkfifo(string_t pathname, mode_t mode);
  extern int mknod(string_t pathname, mode_t mode, dev_t);
  extern int stat(string_t filename, struct stat @buf);
  extern "C" mode_t umask(mode_t mask);
}
}

sys/types.h:
blkcnt_t
blksize_t
dev_t
gid_t
ino_t
mode_t
nlink_t
off_t
pid_t
size_t
ssize_t
time_t
uid_t
{}
