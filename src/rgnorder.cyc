/* Region orders.
   Copyright (C) 2002 Dan Grossman
   This file is part of the Cyclone compiler.

   The Cyclone compiler is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   The Cyclone compiler is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with the Cyclone compiler; see the file COPYING. If not,
   write to the Free Software Foundation, Inc., 59 Temple Place -
   Suite 330, Boston, MA 02111-1307, USA. */

// Note: Many operations are O(n^2logn) time and/or space where n is the number
//       of regions or type variables in scope.  That should be okay and is
//       pretty simple.  But we should be careful.

#include <stdio.h>
#include "list.h"
#include "dict.h"
#include "absyn.h"
#include "rgnorder.h"
#include "tcutil.h"
#include "tcenv.h"
#include "absynpp.h"

using List;
using Absyn;
using Tcutil;
namespace RgnOrder;

// Encodes partial order for region lifetimes
struct RgnInfo {
  type_t these_outlive; // EffKind
  bool   resetable;
};
struct RgnPO<`r::R> {
  Dict::dict_t<tvar_t, struct RgnInfo@`r,`r> d;
  type_t these_outlive_heap; // EffKind
  tvar_t youngest_unresettable; // fact: there always is one
};

// adds constraint: [eff] outlives [rgn]
// Note: Evars get constrained to HeapRgn!
// Note: assumes not resettable and all regions of RgnKind
rgn_po_t<`r> add_outlives_constraint(region_t<`r> r, rgn_po_t<`r> po, 
                                     type_t eff, type_t rgn) {
  let ans = rnew(r) *po;
  switch(compress(rgn)) {
  case &VarType(tv):
    let d = po->d;
    if(Dict::member(d,tv)) {
      let old = Dict::lookup(d,tv)->these_outlive;
      d = Dict::insert(d,tv,rnew(r) RgnInfo(new JoinEff(list(eff,old)), false));
    } else
      d = Dict::insert(d,tv,rnew(r) RgnInfo(eff,false));
    ans->d = d;
    return ans;
  case &Evar(_,_,_,_):
    unify(rgn,HeapRgn);
    fallthru;
  case HeapRgn:
    ans->these_outlive_heap = new JoinEff(list(eff,po->these_outlive_heap));
    return ans;
  default: impos("RgnOrder::add_outlives_constraint passed a bad region");
  }
}

rgn_po_t<`r> add_youngest(region_t<`r> r,rgn_po_t<`r> po, tvar_t rgn, bool resettable, bool opened) {
  // sanity check
  if(!opened && Dict::member(po->d,rgn))
    impos("RgnOrder::add_youngest: repeated region");
  let ans = rnew(r) *po;
  let eff = new AccessEff(new VarType(po->youngest_unresettable));
  ans->d = Dict::insert(po->d, rgn, rnew(r) RgnInfo(eff, resettable));
  if(!resettable); //  && !opened
    ans->youngest_unresettable = rgn;
  return ans;
}

rgn_po_t<`r> initial_fn_po(region_t<`r> r,
                           list_t<tvar_t> tvs, list_t<$(type_t,type_t)@> po,
                           type_t effect, tvar_t fst_rgn, Position::seg_t loc){
  // put all region tvs in the dict and make fst_rgn outlive all tvs
  Dict::dict_t<_,struct RgnInfo@`r,`r> d = Dict::rempty(r,tvar_cmp);
  for(let tvs2 = tvs; tvs2 != NULL; tvs2 = tvs2->tl)
    switch(tvar_kind(tvs2->hd)) {
    case RgnKind: 
    case UniqueRgnKind: 
      d = Dict::insert(d,tvs2->hd,rnew (r) RgnInfo(empty_effect,false)); break;
    case TopRgnKind: 
      Tcutil::terr(loc,"initial_fn_po: tvar %s has TopRgnKind",
		   *tvs2->hd->name); break;
    default: break;
    }
  d = Dict::insert(d, fst_rgn, rnew(r) RgnInfo(effect,false));
  // add in the explicit partial order -- no longer detects cycles
  let ans = rnew(r) RgnPO(d,empty_effect,fst_rgn);
  for(; po != NULL; po = po->tl)
    ans = add_outlives_constraint(r, ans, (*po->hd)[0], (*po->hd)[1]);
  return ans;
}

// Note: rgn better be in the dict!
bool is_region_resetable(rgn_po_t po, Absyn::tvar_t r) {
  return Dict::lookup(po->d,r)->resetable;
}

static bool contains_rgnseff(tvar_t rgns_of_var, type_t eff) {
  switch(normalize_effect(compress(eff))) {
  case &RgnsEff(t): 
    switch(compress(t)) {
    case &VarType(tv): return tvar_cmp(tv,rgns_of_var)==0;
    default: return false;
    }
  case &JoinEff(effs):
    for(; effs != NULL; effs = effs->tl)
      if(contains_rgnseff(rgns_of_var,effs->hd))
	return true;
    return false;
  default: return false;
  }
}

static struct OutlivesEnv<`r::R> {
  region_t<`r> r;
  list_t<tvar_t,`r> seen;
  list_t<tvar_t,`r> todo;
};
 
static void add_to_search(struct OutlivesEnv @ env, type_t eff) {
  switch(compress(eff)) {
  case &AccessEff(&VarType(tv)):
    for(let seen = env->seen; seen != NULL; seen = seen->tl)
      if(tvar_cmp(tv,seen->hd)==0)
	return;
    env->seen = rnew (env->r) List(tv,env->seen);
    env->todo = rnew (env->r) List(tv,env->todo);
    return;
  case &JoinEff(effs):
    for(; effs != NULL; effs = effs->tl)
      add_to_search(env,effs->hd);
    return;
  default: return;
  }
}

static struct OutlivesEnv<`r> 
initial_env(region_t<`r> listrgn, rgn_po_t po, type_t rgn) {
  let ans = OutlivesEnv(listrgn,NULL,NULL);
  add_to_search(&ans,po->these_outlive_heap);
  switch(compress(rgn)) {
  case &VarType(tv): 
    ans.seen = rnew(listrgn) List(tv,ans.seen);
    ans.todo = rnew(listrgn) List(tv,ans.todo);
    fallthru;
  default: return ans;
  }
}

// does [po] prove that [eff] outlives [rgn]?
// evar treatment: return false and do not constrain
static bool atomic_effect_outlives(rgn_po_t po, type_t eff, type_t rgn) {
  region listrgn { // FIX: make a small initial size
  switch(compress(eff)) {
  case &AccessEff(vt):
    switch(compress(vt)) {
    case UniqueRgn: return true;
    case HeapRgn:
      if (rgn != UniqueRgn) return true;
      else return false;
    case &VarType(tv):
      let env = initial_env(listrgn,po,rgn);
      while(env.todo != NULL) {
	let next = env.todo->hd;
	env.todo = env.todo->tl;
	if(tvar_cmp(next,tv)==0) // found it in po
	  return true;
	if(Dict::member(po->d,next)) {
	  add_to_search(&env,Dict::lookup(po->d,next)->these_outlive);
	} else impos("RgnOrder: type variable not in dict");
      }
      return false;
    default: return false;
    }
  case &RgnsEff(vt):
    switch(compress(vt)) {
    case &VarType(tv):
      let env = initial_env(listrgn,po,rgn);
      if(contains_rgnseff(tv,po->these_outlive_heap))
	return true;
      while(env.todo != NULL) {
	let next = env.todo->hd;
	env.todo = env.todo->tl;
	if(Dict::member(po->d,next)) {
	  let next_eff = Dict::lookup(po->d,next)->these_outlive;
	  if(contains_rgnseff(tv,next_eff))
	    return true;
	  add_to_search(&env,next_eff);
	} else impos("RgnOrder: type variable not in dict");
      }
      return false;
    default: return false;
    }
  default: return false; // see comment above about evars
  }
  }
}

// does [po] prove that all regions in [eff] outlive [rgn]?
// evar treatment: return false and do not constrain
bool effect_outlives(rgn_po_t po, type_t eff, type_t rgn) {
  eff = normalize_effect(eff);
  switch(compress(eff)) {
  case &JoinEff(effs):
    for(; effs != NULL; effs = effs->tl)
      if(!effect_outlives(po,effs->hd,rgn))
	return false;
    return true;
  default: return atomic_effect_outlives(po,eff,rgn);
  }
}

static void pin_effect(type_t eff, type_t bd) {
  eff = normalize_effect(eff);
  switch(compress(eff)) {
  case &JoinEff(effs):
    for(; effs != NULL; effs = effs->tl)
      pin_effect(effs->hd,bd);
    return;
  case &RgnsEff(t):
    switch(compress(t)) {
    case &Evar(_,_,_,_): unify(t,uint_typ); return;
    default: return;
    }
  case &AccessEff(r):
    switch(compress(r)) {
    case &Evar(_,_,_,_): unify(r,bd); return;
    default: return;
    }
  case &Evar(_,_,_,_): unify(eff,empty_effect); return; // going away 
  default: return;
  }
}

// does po prove all the constraints
// evar treatment: 
//    evar on right of e > r -- constrain r to rgn
//    evar in left  of e > r -- rgnkind: make r, anykind: make int
// so call this last when doing a pack or call, and programmers will probably
// want to use an explicit instantiation.  (A better thing to do for the 
// evar on right is find the longest living region that satisfies the
// constraints, but for now we do this simpler thing.)
// Of course, this sucks without explicit type instantiation on structs, but
// the topt in tcexp, lets struct Foo<`r> x = Foo(...) do what we want. Sigh.
bool satisfies_constraints(rgn_po_t po, list_t<$(type_t,type_t)@> constraints,
			   type_t default_bound, bool do_pin) {
  // do all the bounds first so order doesn't matter
  for(let cs=constraints; cs != NULL; cs = cs->tl) {
    let &$(_,bd) = cs->hd;
    switch(compress(bd)) {
    case &Evar(_,_,_,_): 
      if(do_pin) 
	unify(bd,default_bound); 
      break;
    default: break;
    }
  }
  for(let cs=constraints; cs != NULL; cs = cs->tl) {
    let &$(eff,bd) = cs->hd;
    if(do_pin)
      pin_effect(eff,bd);
    if(!effect_outlives(po,eff,bd))
      return false;
  }
  return true;
}

static bool eff_outlives_atomic_eff(rgn_po_t po, type_t eff1, type_t eff2) {
  // assumes eff1 is compressed and normalized
  eff2 = compress(normalize_effect(eff2));
  switch(eff2) {
  case &JoinEff(effs):
    for(; effs != NULL; effs = effs->tl)
      if(eff_outlives_atomic_eff(po, eff1, effs->hd))
	return true;
    return false;
  case &AccessEff(vt): return effect_outlives(po, eff1, vt);
  case &RgnsEff(vt1):
    switch(eff1) {
    case &RgnsEff(vt2):
      switch ($(compress(vt1),compress(vt2))) {
      case $(&VarType(tv1),&VarType(tv2)): return tvar_cmp(tv1,tv2)==0;
      default: break;
      }
      fallthru;
    default: return eff1==HeapRgn;
    }
  default: return eff1==HeapRgn;
  }
}

bool eff_outlives_eff(rgn_po_t po, type_t eff1, type_t eff2) {
  eff1 = compress(normalize_effect(eff1));
  switch(eff1) {
  case &JoinEff(effs):
    for(; effs != NULL; effs = effs->tl)
      if(!eff_outlives_eff(po,effs->hd,eff2))
	return false;
    return true;
  default: return eff_outlives_atomic_eff(po, eff1, eff2);
  }
}

// DEBUGGING
void print_region_po(rgn_po_t po) {
  region r { 
    let iter = Dict::make_iter(r,po->d);
    let elem = *Dict::rchoose(r,po->d);
    fprintf(stderr,"region po:\n");
    while(Iter::next(iter,&elem)) {
      fprintf(stderr,"  %s outlived by %s\n",*(elem[0]->name),
	      Absynpp::typ2string(elem[1]->these_outlive));
    }
    fprintf(stderr,"  these outlive heap: %s\n",
	    Absynpp::typ2string(po->these_outlive_heap));
  }
}
