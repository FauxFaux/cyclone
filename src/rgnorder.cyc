/* Region orders.
   Copyright (C) 2002 Dan Grossman
   This file is part of the Cyclone compiler.

   The Cyclone compiler is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   The Cyclone compiler is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with the Cyclone compiler; see the file COPYING. If not,
   write to the Free Software Foundation, Inc., 59 Temple Place -
   Suite 330, Boston, MA 02111-1307, USA. */

// Note: Many operations are O(n^2logn) time and/or space where n is the number
//       of regions or type variables in scope.  That should be okay and is
//       pretty simple.  But we should be careful.

#include <cycboot.h>
#include <list.h>
#include <dict.h>
#include "absyn.h"
#include "rgnorder.h"
#include "tcutil.h"
#include "tcenv.h"
#include "absynpp.h"

using List;
using Absyn;
using Tcutil;
using Absynpp;
namespace RgnOrder;
static string_t tvar2string(tvar_t t) {
  return *t->name;
}
static bool valid_constraint(type_t eff, type_t rgn);
static type_t filter_effect(type_t eff, kind_t k);

// Encodes partial order for region lifetimes
struct RgnInfo {
  type_t these_outlive; // EffKind
  bool   resetable;
};
struct RgnPO<`r::R> {
  Dict::dict_t<tvar_t, struct RgnInfo@`r,`r> d;
  type_t these_outlive_heap; // EffKind
  type_t these_outlive_unique; // EffKind
  tvar_t youngest_unresettable; // fact: there always is one
};

/* Can assign a (col) to a (row):
       R  UR TR
   R   x  x  x
   UR     x
   TR        x

   Therefore, we allow outlives constraints that have the form:
     x can outlive an R
     UR can outlive a UR
     TR can outlive a TR
   Or said another way
     UR can outlive R,UR
     R  can outlive R
     TR can outlive TR,R
*/

// makes sure that for all regions r in [eff], kind(r) <= kind([rgn]);
// also allows regions(`a) to outlive only regions having R kind
static bool valid_constraint(type_t eff, type_t rgn) {
  let &Kind(k,a) = typ_kind(rgn);
  if (k != RgnKind)
    impos("bad region type |%s| passed to add_outlives_constraint",
	  Absynpp::typ2string(rgn));
  switch (compress(eff)) {
  case &JoinEff(es):
    for (; es != NULL; es = es->tl) 
      if (!valid_constraint(es->hd, rgn)) return false;
    return true;
    // FIX: do I need to worry about how the effect might be instantiated?
  case &Evar(_,_,_,_):
  case &VarType(_): return true;
  case &RgnsEff(t): 
    // Only allow regions(`a) to outlive R kinded vars
    //   FIX: this will change when we properly deal with uniqueness and
    //   polymorphism
    if (a == Aliasable) return true; else return false;
  case &AccessEff(r): 
//     fprintf(stderr,"checking %s > %s; are the kinds reversed?\n",
// 	    Absynpp::typ2string(rgn), Absynpp::typ2string(r));
    let &Kind(rk,ra) = typ_kind(r);
    return (k == RgnKind) && ((a == Aliasable) || (ra == a));
//     return kind_leq(typ_kind(r),rgnkind);
  default:
    impos("bad effect |%s| passed to add_outlives_constraint",
	  Absynpp::typ2string(eff));
  }
}

// removes all elements from the effect having kind k
static type_t filter_effect(type_t eff, kind_t k) {
  let e = compress(eff);
  switch (e) {
  case &JoinEff(es):
    _ effs = NULL;
    for (; es != NULL; es = es->tl) {
      let e2 = filter_effect(es->hd,k);
      if (e2 != &VoidType_val) effs = new List(e2,effs);
    }
    return new JoinEff(List::imp_rev(effs));
  case &Evar(_,_,_,_):
  case &RgnsEff(_): return e;
  case &AccessEff(t): if (typ_kind(t) != k) return e; else return &VoidType_val;
  default: impos("bad effect passed to filter_effect");
  }
}

// adds constraint: [eff] outlives [rgn]
// Note: Evars get constrained to HeapRgn!
// Note: assumes not resettable and all regions of RgnKind
rgn_po_t<`r> add_outlives_constraint(region_t<`r> r, rgn_po_t<`r> po, 
                                     type_t eff, type_t rgn,
				     Position::seg_t loc) {
  eff = normalize_effect(eff);
  let ans = rnew(r) *po;
  // first check that this is a valid constraint
  if (!valid_constraint(eff,rgn)) {
    terr(loc,"Invalid region ordering constraint; kind mismatch");
    return ans;
  }
  // now add it to the PO
  switch(compress(rgn)) {
  case &VarType(tv):
    let d = po->d;
    if(Dict::member(d,tv)) {
      let old = Dict::lookup(d,tv)->these_outlive;
      d = Dict::insert(d,tv,rnew(r) RgnInfo(new JoinEff(list(eff,old)), false));
    } else
      d = Dict::insert(d,tv,rnew(r) RgnInfo(eff,false));
    ans->d = d;
    return ans;
  case &Evar(_,_,_,_):
    unify(rgn,&HeapRgn_val);
    fallthru;
  case &HeapRgn:
    ans->these_outlive_heap = new JoinEff(list(eff,po->these_outlive_heap));
    return ans;
  case &UniqueRgn:
    ans->these_outlive_unique =
      new JoinEff(list(eff,po->these_outlive_unique));
    return ans;
  default: impos("RgnOrder::add_outlives_constraint passed a bad region");
  }
}

rgn_po_t<`r> add_youngest(region_t<`r> r,rgn_po_t<`r> po, tvar_t rgn, bool resettable, bool opened) {
  // sanity check
  if(!opened && Dict::member(po->d,rgn))
    impos("RgnOrder::add_youngest: repeated region");
  let ans = rnew(r) *po;
  let eff = new AccessEff(new VarType(po->youngest_unresettable));
  ans->d = Dict::insert(po->d, rgn, rnew(r) RgnInfo(eff, resettable));
  if(!resettable); //  && !opened
    ans->youngest_unresettable = rgn;
  return ans;
}

rgn_po_t<`r> initial_fn_po(region_t<`r> r,
                           list_t<tvar_t> tvs, list_t<$(type_t,type_t)@> po,
                           type_t effect, tvar_t fst_rgn, Position::seg_t loc){
  // put all region tvs in the dict and make fst_rgn outlive all tvs
  Dict::dict_t<_,struct RgnInfo@`r,`r> d = Dict::rempty(r,tvar_cmp);
  for(let tvs2 = tvs; tvs2 != NULL; tvs2 = tvs2->tl)
    if (tvar_kind(tvs2->hd,&bk)->kind == RgnKind) {
//       fprintf(stderr,"  Adding tvar %s to dict\n",
// 	      Absynpp::typ2string(new VarType(tvs2->hd)));
      d = Dict::insert(d,tvs2->hd,rnew (r) RgnInfo(empty_effect,false));
    }

  // make sure we don't have any bogus constraints
  if (!valid_constraint(effect,new VarType(fst_rgn))) {
//     fprintf(stderr,"filtering effect\n");
    terr(loc,"Invalid region ordering constraint; kind mismatch");
    return rnew(r) RgnPO(d,empty_effect,empty_effect,fst_rgn);
  }
//   fprintf(stderr,"  Relating %s <= effect %s\n",
// 	  Absynpp::typ2string(new VarType(fst_rgn)),
// 	  Absynpp::typ2string(effect));	  
  d = Dict::insert(d, fst_rgn, rnew(r) RgnInfo(effect,false));
  // add in the explicit partial order -- no longer detects cycles
  let ans = rnew(r) RgnPO(d,empty_effect,empty_effect,fst_rgn);
  for(; po != NULL; po = po->tl)
    ans = add_outlives_constraint(r, ans, (*po->hd)[0], (*po->hd)[1], loc);
//   print_region_po(ans);
  return ans;
}

// FIX: this can probably lead to tyvars not in the dict
//  bool sub_constraints(region_t<`r> r, list_t<tvar_t> tvs,
//  		     list_t<$(type_t,type_t)@> po1, 
//  		     list_t<$(type_t,type_t)@> po2) {
//    tvar_t dummy = new Tvar(new "",0,new Eq_kb(RgnKind)); // ALLOCATION
//    Dict::dict_t<_,struct RgnInfo@`r,`r> d = Dict::rempty(r,tvar_cmp);
//    for(let tvs2 = tvs; tvs2 != NULL; tvs2 = tvs2->tl)
//      switch(tvar_kind(tvs2->hd,BoxKind)) {
//      case RgnKind: 
//      case UniqueRgnKind: 
//      case TopRgnKind: 
//        d = Dict::insert(d,tvs2->hd,rnew (r) RgnInfo(empty_effect,false)); break;
//        break;
//      default: break;
//      }
//    let ans = rnew(r) RgnPO(d,empty_effect,empty_effect,dummy);
//    for(; po2 != NULL; po2 = po2->tl)
//      ans = add_outlives_constraint(r, ans, (*po2->hd)[0], (*po2->hd)[1], NULL);
//    return satisfies_constraints(ans,po1,&HeapRgn_val,false);
//  }

// Note: rgn better be in the dict!
bool is_region_resetable(rgn_po_t po, Absyn::tvar_t r) {
  return Dict::lookup(po->d,r)->resetable;
}

// is regions(`rgns_of_var) in eff?
static bool contains_rgnseff(tvar_t rgns_of_var, type_t eff) {
  switch(normalize_effect(compress(eff))) {
  case &RgnsEff(t): 
    switch(compress(t)) {
    case &VarType(tv): return tvar_cmp(tv,rgns_of_var)==0;
    default: return false;
    }
  case &JoinEff(effs):
    for(; effs != NULL; effs = effs->tl)
      if(contains_rgnseff(rgns_of_var,effs->hd))
	return true;
    return false;
  default: return false;
  }
}

static struct OutlivesEnv<`r::R> {
  region_t<`r> r;
  list_t<tvar_t,`r> seen; // region vars that we have already considered
  list_t<tvar_t,`r> todo; // region vars that outlive vars already considered 
};
 
static void add_to_search(struct OutlivesEnv @ env, type_t eff) {
  switch(compress(eff)) {
  case &AccessEff(&VarType(tv)):
    for(let seen = env->seen; seen != NULL; seen = seen->tl)
      if(tvar_cmp(tv,seen->hd)==0)
	return;
    env->seen = rnew (env->r) List(tv,env->seen);
    env->todo = rnew (env->r) List(tv,env->todo);
    return;
  case &JoinEff(effs):
    for(; effs != NULL; effs = effs->tl)
      add_to_search(env,effs->hd);
    return;
  default: return;
  }
}

static struct OutlivesEnv<`r> 
initial_env(region_t<`r> listrgn, rgn_po_t po, type_t rgn) {
  let ans = OutlivesEnv(listrgn,NULL,NULL);
  type_t r = compress(rgn);
  let &Kind(k,a) = typ_kind(r);
  if (k == RgnKind) {
    switch (a) {
    case Aliasable: add_to_search(&ans,po->these_outlive_heap); break;
    case Unique:  add_to_search(&ans,po->these_outlive_unique); break;
    case Top:
      add_to_search(&ans,po->these_outlive_heap);
      add_to_search(&ans,po->these_outlive_unique); break;
    }
  }
  else
    impos("RgnOrder: rgn not of correct kind");

  switch(r) {
  case &VarType(tv): 
    ans.seen = rnew(listrgn) List(tv,ans.seen);
    ans.todo = rnew(listrgn) List(tv,ans.todo);
    fallthru;
  default: return ans;
  }
}

// does [po] prove that [eff] outlives [rgn]?
// evar treatment: return false and do not constrain
static bool atomic_effect_outlives(rgn_po_t po, type_t eff, type_t rgn) {
  region listrgn; { // FIX: make a small initial size
  switch(compress(eff)) {
  case &AccessEff(vt):
    // does `vt outlive `rgn ?
    switch(compress(vt)) {
    case &UniqueRgn: return true;
    case &HeapRgn:
      // The heap outlives all regions except the unique region
      //   and regions with UR and TR kind
      switch (compress(rgn)) {
      case &UniqueRgn: return false;
      case &VarType(tv):
	let &Kind(k,a) = tvar_kind(tv,&bk);
	if ((k == RgnKind) && (a == Aliasable)) return true;
	else return false;
      default:
	return true;
      }
    case &VarType(tv):
      // To determine if tv outlives rgn, we generate the transitive
      // set of variables (env.todo) that outlive rgn.  If during this
      // process we discover tv is in this set, we return true; if we
      // reach a fixed-point, then we return false.  We start by
      // building the set to include rgn and all those variables that
      // outlive the heap.
      //fprintf(stderr,"seeing if %s outlives %s\n",tvar2string(tv),typ2string(rgn));
      let env = initial_env(listrgn,po,rgn);
      while(env.todo != NULL) {
	let next = env.todo->hd;
	env.todo = env.todo->tl;
        //fprintf(stderr,"found %s\n",tvar2string(next));

	if(tvar_cmp(next,tv)==0) {
          //fprintf(stderr,"that's what we needed\n");
	  return true;
        }

	// didn't find it; add all variables that outlive this variable
	// to the env.todo list, unless they appear in env.seen list
	// (meaning we already tried them or will try them).
	if(Dict::member(po->d,next)) {
          //fprintf(stderr,"adding %s outlives: %s\n",tvar2string(next),
          //        typ2string(Dict::lookup(po->d,next)->these_outlive));

	  add_to_search(&env,Dict::lookup(po->d,next)->these_outlive);
	} else 
	  impos(aprintf("RgnOrder: type variable %s not in dict",*tv->name));
      }
      return false;
    default: return false;
    }
  case &RgnsEff(vt):
    switch(compress(vt)) {
    // does regions(`tv) outlive `rgn?
    case &VarType(tv):
      // This is similar to the VarType case, above, except that we
      // check that for each variable `r in todo, whether regions(`tv)
      // outlives it.
      let env = initial_env(listrgn,po,rgn);
      let &Kind(k,a) = typ_kind(rgn);
      if ((k == RgnKind) && (a == Aliasable || a == Top))
	if(contains_rgnseff(tv,po->these_outlive_heap))
	  return true;
      if ((k == RgnKind) && (a == Unique || a == Top))
	if(contains_rgnseff(tv,po->these_outlive_unique))
	  return true;
      while(env.todo != NULL) {
	let next = env.todo->hd;
	env.todo = env.todo->tl;
	if(Dict::member(po->d,next)) {
	  let next_eff = Dict::lookup(po->d,next)->these_outlive;
	  if(contains_rgnseff(tv,next_eff))
	    return true;
	  add_to_search(&env,next_eff);
	} else impos("RgnOrder: type variable not in dict");
      }
      return false;
    default: return false;
    }
  default: return false; // see comment above about evars
  }
  }
}

// does [po] prove that all regions in [eff] outlive [rgn]?
// evar treatment: return false and do not constrain
bool effect_outlives(rgn_po_t po, type_t eff, type_t rgn) {
  eff = normalize_effect(eff);
  switch(compress(eff)) {
  case &JoinEff(effs):
    for(; effs != NULL; effs = effs->tl)
      if(!effect_outlives(po,effs->hd,rgn))
	return false;
    return true;
  default:
    return atomic_effect_outlives(po,eff,rgn);
  }
}

static void pin_effect(type_t eff, type_t bd) {
  eff = normalize_effect(eff);
  switch(compress(eff)) {
  case &JoinEff(effs):
    for(; effs != NULL; effs = effs->tl)
      pin_effect(effs->hd,bd);
    return;
  case &RgnsEff(t):
    switch(compress(t)) {
    case &Evar(_,_,_,_): unify(t,uint_typ); return;
    default: return;
    }
  case &AccessEff(r):
    switch(compress(r)) {
    case &Evar(_,_,_,_): unify(r,bd); return;
    default: return;
    }
  case &Evar(_,_,_,_): unify(eff,empty_effect); return; // going away 
  default: return;
  }
}

// does po prove all the constraints
// evar treatment: 
//    evar on right of e > r -- constrain r to rgn
//    evar in left  of e > r -- rgnkind: make r, anykind: make int
// so call this last when doing a pack or call, and programmers will probably
// want to use an explicit instantiation.  (A better thing to do for the 
// evar on right is find the longest living region that satisfies the
// constraints, but for now we do this simpler thing.)
// Of course, this sucks without explicit type instantiation on structs, but
// the topt in tcexp, lets struct Foo<`r> x = Foo(...) do what we want. Sigh.
bool satisfies_constraints(rgn_po_t po, list_t<$(type_t,type_t)@> constraints,
			   type_t default_bound, bool do_pin) {
  // do all the bounds first so order doesn't matter
  for(let cs=constraints; cs != NULL; cs = cs->tl) {
    let &$(_,bd) = cs->hd;
    switch(compress(bd)) {
    case &Evar(_,_,_,_): 
      if(do_pin) 
	unify(bd,default_bound); 
      break;
    default: break;
    }
  }
  for(let cs=constraints; cs != NULL; cs = cs->tl) {
    let &$(eff,bd) = cs->hd;
    if(do_pin)
      pin_effect(eff,bd);
    if(!effect_outlives(po,eff,bd))
      return false;
  }
  return true;
}

static bool eff_outlives_atomic_eff(rgn_po_t po, type_t eff1, type_t eff2) {
  // assumes eff1 is compressed and normalized
  eff2 = compress(normalize_effect(eff2));
  switch(eff2) {
  case &JoinEff(effs):
    for(; effs != NULL; effs = effs->tl)
      if(eff_outlives_atomic_eff(po, eff1, effs->hd))
	return true;
    return false;
  case &AccessEff(vt): return effect_outlives(po, eff1, vt);
  case &RgnsEff(vt1):
    switch(eff1) {
    case &RgnsEff(vt2):
      switch ($(compress(vt1),compress(vt2))) {
      case $(&VarType(tv1),&VarType(tv2)): return tvar_cmp(tv1,tv2)==0;
      default: break;
      }
      fallthru;
    default: return eff1==&HeapRgn_val;
    }
  default: return eff1==&HeapRgn_val;
  }
}

bool eff_outlives_eff(rgn_po_t po, type_t eff1, type_t eff2) {
  eff1 = compress(normalize_effect(eff1));
  switch(eff1) {
  case &JoinEff(effs):
    for(; effs != NULL; effs = effs->tl)
      if(!eff_outlives_eff(po,effs->hd,eff2))
	return false;
    return true;
  default: return eff_outlives_atomic_eff(po, eff1, eff2);
  }
}

// DEBUGGING
void print_region_po(rgn_po_t po) {
  region r; { 
    Iter::iter_t<_,`r> iter = Dict::make_iter(r,po->d);
    let elem = *Dict::rchoose(r,po->d);
    fprintf(stderr,"region po:\n");
    while(Iter::next(iter,&elem)) {
      fprintf(stderr,"  %s outlived by %s\n",*(elem[0]->name),
	      Absynpp::typ2string(elem[1]->these_outlive));
    }
    fprintf(stderr,"  these outlive heap: %s\n",
	    Absynpp::typ2string(po->these_outlive_heap));
    fprintf(stderr,"  these outlive unique: %s\n",
	    Absynpp::typ2string(po->these_outlive_unique));
  }
}
