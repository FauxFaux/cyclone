/* Computing Strongest Post-conditions
   Copyright (C) 2003 Greg Morrisett
   This file is part of the Cyclone compiler.

   The Cyclone compiler is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   The Cyclone compiler is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with the Cyclone compiler; see the file COPYING. If not,
   write to the Free Software Foundation, Inc., 59 Temple Place -
   Suite 330, Boston, MA 02111-1307, USA. */

/* 
What we are doing here is computing a pre/post-condition in a forwards
fashion for each statement and expression within a function.  We are
also generating verification conditions at certain key points to be
used within insert_checks.  These verification conditions are of the
form A => B where A describes the set of possible states for the
control-flow point, and B describes a safety check that needs to be
done (e.g., an array index is in bounds, a pointer is not NULL, etc.)

The assertion language is very simple: equality and inequality over
terms, disjunction, and conjunction (no quantifiers yet) so we cannot
yet generate strongest post-conditions.  The terms include what we
consider to be "constant" expressions in Cyclone, primops of terms,
program variables, and logical variables.

The system currently uses two provers.  One prover is extremely simple
and essentially syntactic and is used to discharge most of the
verification conditions.  The other prover is based on solving
difference constraints on terms and is quite a bit more expensive.  In
particular, it computes a DNF representation for a verification
condition so there can be an exponential blow-up (roughly
corresponding to the number of execution paths reaching a particular
control-flow point.)

To keep the system scalable by default, we employ a number of
strategies.  First, at join-points, we do not simply take the
disjunction of the incoming assertions.  Rather, we weaken the
disjunction by factoring out the syntactically common conjuncts.  This
ensures that most verification conditions do not have a large number
of disjunctions and essentially makes the analysis path insensitive by
default.  Users can override this behavior by either (a) putting in an
explicit assertion at the join-point, or (b) turning on "allpaths"
using a pragma.

Second, we use a very simple strategy for constructing loop
invariants.  In particular, we use an iterative approach which weakens (in
the sense above) the proposed invariant each time around the loop.
Since the weakening is syntactic, the size of the assertion decreases
each time we iterate.  So the worst case fixed-point is the assertion
True.  However, this tends to get the easy invariants with
relatively little overhead.  Users can override this default by
putting in explicit loop invariants.

Third, it is crucial that we physically share term and assertion
nodes as much as possible to avoid an exponential space blow-up when
we are path-sensitive.  We use hash-consing to share all term & assertion 
nodes, and we use lazy substitution to avoid breaking the sharing 
as much as possible.

To keep the analysis simple and somewhat structured, we essentially
punt on goto's.  More properly, whenever we hit a labelled statement, 
we reset the incoming pre-condition to "true", unless there's an
explicit @assert(A) invariant.  This allows us to
do purely local iteration for calculating the assertions.  To handle
other non-local edges (e.g., break, continue, throw) we essentially
pile up assertions on the statement and OR them in with the natural
flow's pre-condition.  

Also to keep the analysis simple, we punt on alias analysis.  Variables 
have a flag indicating whether or not they escape syntactically.
When updating an escaping variable, we essentially "kill" all 
escaping variables.  The same happens for a function call.  This is
not thread-safe.  To achieve that, we would have to kill all escaping
things after each step. 

There are a lot of ways we should improve this analysis and a few
things that need to be fixed:

* We need to replace the relations stuff in the type-checker (e.g.,
  subtyping) with calls to manipulate the @requires/@ensures stuff
  in here.
* We should take pattern matching tests into account for a switch.
* We shouldn't kill unique variables.
* We should only kill "type-compatible" expressions on an update.
  For instance, we don't need to kill pointer variables if we're
  assigning an integer value.  Note that if we had terms like
  *t or t.f or t->f or t1[t2] then we'd have to kill any of those
  though...
* We should make the simple thm. prover a bit smarter.
* We should add support for more predicates and relations (e.g.,
  track whether x == null, or tagcheck(x.f), or datatype tags, etc.)?
* Could have user-defined predicates...
* If we knew that a goto was forward, then we could deal with it...  

*/

#include "vcgen.h"
#include "absyn.h"
#include "absynpp.h"
#include "tcutil.h"
#include "attributes.h"
#include "evexp.h"
#include "assndef.h"
#include "pratt_prover.h"
#include "warn.h"
#include "flags.h"
#include <hashtable.h>
#include <dict.h>
#include <string.h> 
#include <cycboot.h> 
#include <set.h>


//#define VCGEN_DEBUG

namespace Vcgen;
using List;
using AssnDef;
using PrattProver;

////// Forward Declaration for Environments /////
struct Env;
typedef struct Env @env_t;

// returns true if a2 is provable from a1 (i.e., a1 |- a2)
// only tries simple_prove.
static bool simple_implies(assn_t @a1, assn_t @a2) {
  *a1 = reduce(*a1);
  *a2 = reduce(*a2);
  return simple_prove(*a1,*a2);
}

// same as simple_implies but also tries the constraint prover.
static bool implies(assn_t @a1, assn_t @a2) {
  return simple_implies(a1,a2) || constraint_prove(*a1,*a2);
}

// only widens when env->shared->widen_paths is true (defined below)
static assn_t may_widen(env_t env, assn_t a);

////////// Updating an Assertion //////////////////
static term_t fresh_nonescvar(env_t env, vardecl_t vd);

static assn_t kill_var(env_t env, vardecl_t vd, assn_t a) {
  if (vd->escapes) {
    a = kill(a);
  } else {
    let v2 = fresh_nonescvar(env,vd);
    a = subst(vd,v2,a);
  }
  return a;
}

// We are executing tgt := src
static assn_t do_assign(env_t env, assn_t a, term_opt_t tgt, term_opt_t src) {
  switch (tgt) {
  case NULL: 
    // We don't know what the target is except that it's not a non-escaping
    // variable, so we must kill those references.
    return kill(a);
  case &Var(vd):
    // We know what the target is -- if it escapes then we kill all 
    // escaping variables, otherwise we just kill the target vd by
    // substituting a fresh logic variable.
    // We must make sure to also kill within the src term.
    if (vd->escapes) {
      a = kill(a);
      src = (src == NULL) ? NULL : kill_mem_term(src);
    } else {
      let v2 = fresh_nonescvar(env,vd);
      a = subst(vd,v2,a);
      src = (src == NULL) ? NULL : subst_term(src,vd,v2);
    }
    // Finally, add in tgt == src.
    return and(a,eq(tgt,src));
  default: Warn::impos("vcgen do_assign");
  }
}

///////////////////// Analysis /////////////////////

////////// Analysis Environment /////////////////////
struct SharedEnv {
  // a mapping from statements to accumulated pre-conditions 
  Hashtable::table_t<stmt_t,assn_t@> assn_table;
  // a mapping for successors in the control-flow graph (from jump_analysis)
  Hashtable::table_t<stmt_t,stmt_opt_t> succ_table;
  // the assertion accumulated for the current exception handler if any
  assn_t* try_assn;
  // when not-null is used to record the resulting value of an expr-stmt.
  term_opt_t* exp_stmt;
  // used to record the result terms and assertions for a function.  Only
  // needed when the function has an ensures clause.
  term_opt_t  res_term; // the return_value 
  assn_t*     res_assn;
  // true by default: controls whether we widen assertions at join points
  bool        widen_paths;
};

typedef Dict::dict_t<vardecl_t,int> state_counter_t;

struct Env {
  struct SharedEnv @shared;
  // A clever idea from Yanling for simulating SSA:
  // For non-escaping variables, we keep a state counter so that when
  // we kill a variable on two separate paths, we retain some sharing
  // for the old values.  For instance, if we have:
  //     [x==0 && x==y] if (c) { x := 4; } else { x := 5; }
  // then we want to end up killing x with the same variable _x0 
  // upon each update so that we get on output:
  // ([_x0==0 && _x0==y && c && x == 4] ||[_x0==0 && _x0==y && !c && x == 5])
  // This will make it easier to collapse this into:
  //  [_x0==0 && _x0==y && (c && x == 4 || !c && x == 5)]
  state_counter_t state_counter;
  assn_info_t assn_info;
};

static int hash_ptr(`a s) { return (int)s; }

static assn_t may_widen(env_t env, assn_t a) {
  return (env->shared->widen_paths) ? widen(a) : a;
}

static env_t 
initial_env(JumpAnalysis::jump_anal_res_t tables, Absyn::fndecl_t fd, assn_info_t assn_info, assn_t *`H res_assn, term_opt_t res_term) {
  let succ_table = Hashtable::lookup(tables->succ_tables,fd);
  let assn_table = Hashtable::create(57, Core::ptrcmp, hash_ptr);
  let senv =  new SharedEnv{.assn_table = assn_table,
                            .succ_table = succ_table,
                            .try_assn = NULL,
                            .exp_stmt = NULL,
                            .res_term = res_term,
                            .res_assn = res_assn,
                            .widen_paths = !Flags::allpaths};
  let d = Dict::empty(Core::ptrcmp);
  return new Env { .shared = senv, .state_counter = d, .assn_info = assn_info};
}

static env_t copy_env(env_t env) {
  return new(*env);
}

// we have to merge environments at a join-point to get the
// next in a sequence.
static int max_counter(int dummy, vardecl_t vd, int i, int j) {
  return (i < j) ? j : i;
}

static void merge_env(env_t old_env, env_t new_env) {
  old_env->state_counter = Dict::union_two_c(max_counter, 0, 
                                             old_env->state_counter, 
                                             new_env->state_counter);
}

// generate a fresh logic variable for a non-escaping variable --
// the next one in a sequence.
static term_t fresh_nonescvar(env_t env, vardecl_t vd) {
  int res = 0;
  Dict::lookup_bool(env->state_counter,vd,&res);
  env->state_counter = Dict::insert(env->state_counter,vd,res+1);
  return logicvar(vd,res,vd->type);
}

// each statement may have an assertion associated with it from
// other incoming edges -- we must take into account all paths.
static assn_t pre_stmt_update(env_t env, stmt_t s, assn_t ain) {
  let popt = Hashtable::lookup_opt(env->shared->assn_table,s);
  if (popt != NULL) {
    assn_t @p = *popt;
    let new_precondition = or(ain,*p);
    *p = new_precondition;
    return new_precondition;
  } else 
    return ain;
}

// get the pre-condition currently associated with a statement.
static assn_t@ get_assn(env_t env, stmt_t s) {
  static assn_t false_pointer = &false_assn;
  assn_t @* popt = Hashtable::lookup_opt(env->shared->assn_table,s);
  if (popt != NULL)
    return *popt;
  else
    return &false_pointer;
}

// similar to pre_stmt_update except that we use widen instead of or
// since this is part of a loop back-edge.
static assn_t loop_assn(env_t env, stmt_t s, assn_t ain) {
  assn_t @* aprevopt = Hashtable::lookup_opt(env->shared->assn_table,s);
  if (aprevopt != NULL) {
    let aprev = *aprevopt;
    // No choice about widening here -- must ensure termination.
    ain = widen(or(ain,*aprev));
    *aprev = ain;
  } else {
    Hashtable::insert(env->shared->assn_table,s,new ain);
  }
  return ain;
}

// similar to pre_stmt_update but makes sure to put the
// result on the statement.  
static assn_t forward_assn(env_t env, stmt_t s, assn_t ain) {
  assn_t@* aprevopt = Hashtable::lookup_opt(env->shared->assn_table,s);
  if (aprevopt != NULL) {
    let aprev = *aprevopt;
    ain = may_widen(env,or(ain,*aprev));
    *aprev = ain;
  } else {
    Hashtable::insert(env->shared->assn_table,s,new ain);
  }
  return ain;
}

// update the assertion associated with the current 
// exception handler.  
static void update_try_assn(env_t env, assn_t a) {
  if (env->shared->try_assn == NULL) return;
  a = may_widen(env,or(*env->shared->try_assn,a));
  *env->shared->try_assn = a;
}

// update the return information for a function
static void update_return(env_t env, term_opt_t t, assn_t a, type_opt_t topt) {
  let shared = env->shared;
  if (shared->res_assn == NULL) return;
  if (shared->res_term != NULL) {
    *shared->res_assn = or(and(a,eq(shared->res_term,t)),*shared->res_assn);
  } else {
    *shared->res_assn = or(a,*shared->res_assn);
  }
}

// functions related to maintain the information passed to insert_checks
assn_info_t new_assn_info(void){
  let assn_info =  Hashtable::create(57, Core::ptrcmp, hash_ptr);
  return new assn_info;
}

exp_checks_t @ exp2ctxt_checks(assn_info_t assn_info, Absyn::exp_t e){
  let result = Hashtable::lookup_opt(*assn_info, e);
  if (result == NULL){
    static exp_checks_t b = {.ctxt = &true_assn, 
                             .bounds_check = &false_assn,
                             .null_check = &false_assn};
    //wangyl: we don't know any info about vcgen here, so the ctxt
    //should be true and the assertion we need to prove should be false
    return &b;
  }else{
    return *result;
  }
}

static void insert_exp_checks(assn_info_t assn_info, Absyn::exp_t e, exp_checks_t @`H exp_check) {
#ifdef VCGEN_DEBUG
  fprintf(stderr, "###################\n");
  fprintf(stderr, "expression: %s\n", Absynpp::exp2string(e));
  fprintf(stderr, "ctxt assns    : %s \n", AssnDef::assn2string(exp_check->ctxt));
  fprintf(stderr, "bnds chk assn : %s \n", AssnDef::assn2string(exp_check->bounds_check));
  fprintf(stderr, "null chk assn : %s \n", AssnDef::assn2string(exp_check->null_check));
  fprintf(stderr, "###################\n");
#endif
  Hashtable::insert(*assn_info, e, exp_check);
  return;
}

static exp_t zero_exp() {
  exp_t ans = Absyn::uint_exp(0,0);
  ans->topt = Absyn::uint_type;
  return ans;
}

// forward declarations for the analysis functions.

// Vcgen for statements.  ain is an assertion describing the state
// on input to the statement, and this returns an assertion describing 
// the output state. 
static assn_t vcgen_stmt_nodebug(env_t env, stmt_t s, assn_t ain);
// Analyze a term given precondition ain and generate an optional term
// and post-condition representing the value of the expression and
// the resulting machine state.
static $(term_opt_t,assn_t) vcgen_rexp_nodebug(env_t env, exp_t e, assn_t ain);
// If the term is "undefined" then we return a fresh variable.
static $(term_t,assn_t) vcgen_rexp_always(env_t env, exp_t e, assn_t ain);
// Same as above, but for lhs-expressions.
static $(term_opt_t,assn_t) vcgen_lexp(env_t env, exp_t e, assn_t ain);
// Analyze a test expression returning two assertions corresponding
// to the test succeeding (true-case) or failing (false-case).
static $(assn_t t,assn_t f) vcgen_test(env_t env, exp_t e, assn_t ain);
// Analyze a list of expressions returning an optional list of
// terms and the output assertion.  If any of the expressions'
// is unknown, then so is the whole thing.
static $(list_t<term_t>*,assn_t) vcgen_rexps(env_t env, list_t<exp_t> es, assn_t a);
// Similar to above but here we don't care what the resulting terms
// are at all.
static assn_t vcgen_rexps_nosave(env_t env, list_t<exp_t> es, assn_t a);
// Folds vcgen_rexp_always across the list.
static $(list_t<term_t>,assn_t) vcgen_rexps_always(env_t env, list_t<exp_t> es, assn_t ain);
// Do vcgen for all of the cases in a switch.  
static assn_t vcgen_switch(env_t env, list_t<switch_clause_t> scs, assn_t ain);
// Do vcgen for a local declaration
static assn_t vcgen_local_decl(env_t env, decl_t d, assn_t a);

static string_t stmt2shortstring(stmt_t s) {
  switch (s->r) {
  case &Absyn::IfThenElse_s(e,...): 
    return aprintf("if (%s) ...",Absynpp::exp2string(e));
  case &Absyn::While_s($(e,_),_):
    return aprintf("while (%s) ...",Absynpp::exp2string(e));
  case &Absyn::For_s(e1,$(e2,_),$(e3,_),_):
    return aprintf("for (%s;%s;%s) ...",Absynpp::exp2string(e1),
                   Absynpp::exp2string(e2),Absynpp::exp2string(e3));
  case &Absyn::Switch_s(e,...): 
    return aprintf("switch (%s) ...",Absynpp::exp2string(e));
  case &Absyn::Do_s(_,$(e,_)):
    return aprintf("do ... while (%s)",Absynpp::exp2string(e));
  case &Absyn::TryCatch_s(s,...): 
    return aprintf("try %s catch ...",stmt2shortstring(s));
  case &Absyn::Seq_s(s,...): return stmt2shortstring(s);
  default: 
    let s = Absynpp::stmt2string(s);
    unsigned max = numelts(s) < 11 ? numelts(s) : 11;
    char ?@nozeroterm res = malloc(sizeof(char)*max);
    for (int i = 0; i < max-1; i++)
      res[i] = s[i];
    return aprintf("%s...",res);
  }
}

#ifdef VCGEN_DEBUG
#define vcgen_rexp(env,e,a) vcgen_rexp_debug(env,e,a)
#define vcgen_stmt(env,s,a) vcgen_stmt_debug(env,s,a)
static unsigned int indent = 0;
static void print_tabs() {
  for (unsigned i = indent; i > 0; i--)
    fprintf(stderr," ");
}
static assn_t vcgen_stmt_debug(env_t env, stmt_t s, assn_t ain) {
  switch (s->r) {
  case &Absyn::Seq_s(_,_): 
  case &Absyn::Decl_s(...):
    //case &Absyn::Exp_s(...):
  case &Absyn::Skip_s: return vcgen_stmt_nodebug(env,s,ain);
  default:
    print_tabs();
    let str = assn2string(ain);
    //    fprintf(stderr,"stmt %s pre(%d/%d)=%s\n",stmt2shortstring(s),assn_size(ain),tree_size,str);
    fprintf(stderr,"stmt %s =%s\n",stmt2shortstring(s),str);
    indent += 2;
    let aout = vcgen_stmt_nodebug(env,s,ain);
    indent -= 2;
    print_tabs();
    let str = assn2string(aout);
    //    fprintf(stderr,"stmt %s, post(%d/%d)=%s\n",stmt2shortstring(s),assn_size(aout),tree_size,str);
    return aout;
  }
}
static $(term_opt_t,assn_t) vcgen_rexp_debug(env_t env, exp_t e, assn_t ain) {
  print_tabs();
  fprintf(stderr,"exp %s, pre=%s\n",Absynpp::exp2string(e),assn2string(ain));
  indent += 2;
  let $(t,a) = vcgen_rexp_nodebug(env,e,ain);
  indent -= 2;
  print_tabs();
  fprintf(stderr,"exp %s ==> %s, post: %s\n",Absynpp::exp2string(e),
          ((t == NULL) ? "?" : term2string((term_t)t)), assn2string(ain));
  return $(t,a);
}

#else
#define vcgen_rexp(env,e,a) vcgen_rexp_nodebug(env,e,a)
#define vcgen_stmt(env,s,a) vcgen_stmt_nodebug(env,s,a)
#endif


static list_t<assn_t> heuristic_loop_invariants(env_t env, stmt_t s, assn_t ain){
  list_t<assn_t> loop_invariants = NULL;
  switch (s->r){
  case &Absyn::For_s(e1,$(e2,dummy2),$(e3,dummy3),s):
    switch (e2->r){
    case &Absyn::Primop_e(Absyn::Lt, es):
      let exp = Absyn::primop_exp(Absyn::Lte, es, 0);
      assn_t a = vcgen_test(env, Absyn::primop_exp(Absyn::Lte, es, 0), &true_assn)[0];
      if (implies(&ain, &a)) loop_invariants = new List(a, loop_invariants);
      break;
    default:break;
    }
    break;
  case &Absyn::While_s($(e,dummy),s):
    break;
  case &Absyn::Do_s(s,$(e,dummy)):
    break;
  default:
    break;
  }
  return loop_invariants;
}

static exp_opt_t find_assert_e(stmt_t s) {
  while (true) {
    switch (s->r) {
    case &Absyn::Exp_s(&Absyn::Exp{.r = &Absyn::Assert_e(e),...}): return e;
    case &Absyn::Seq_s(sa,_): s = sa; continue;
    default: return NULL;
    }
  }
}

// To simplify things, I'm treating the control-flow as if it were
// structured.  Upon reaching a labelled statement, I set the pre-
// condition to "True" which is conservative, unless there's an 
// explicit invariant associated with the label.   This lets me do
// local iteration for loops and so forth to generate invariants,
// since the only back-edges in the simplified graph are always
// part of the control constructs, or have an explicit invariant
// associated with them.  
static assn_t vcgen_stmt_nodebug(env_t env, stmt_t s, assn_t ain) {
  // merge the pre-condition with any pre-recorded assertions.
  // we'll have one if there was some control-flow to this statement.
 LOOP:
  ain = pre_stmt_update(env,s,ain);
  //assn_size(ain);

  /* JGM: can't skip -- we might run into a label in which case
     we're re-setting the assertion to true...
  switch (ain) {
  case &False: return ain;
  default: break;
  }
  */

  switch (s->r) {
  case &Absyn::Skip_s: return ain;
  case &Absyn::Exp_s(e): 
    let $(t,aout) = vcgen_rexp(env,e,ain);
    // a little trickery to deal with statement expressions -- we
    // record the result in the environment here.
    if (env->shared->exp_stmt != NULL) 
      *(env->shared->exp_stmt) = t;
    return aout;
  case &Absyn::Seq_s(s1,s2): 
    ain = vcgen_stmt(env,s1,ain);
    s = s2;
    goto LOOP;
  case &Absyn::Return_s(NULL): 
    update_return(env,NULL,ain,NULL);
    return &false_assn;
  case &Absyn::Return_s(e as &_): 
    let $(t,aout) = vcgen_rexp(env,(exp_t)e,ain);
    update_return(env,t,aout,e->topt);
    return &false_assn;
  case &Absyn::IfThenElse_s(e1,s1,s2):
    let $(at,af) = vcgen_test(env,e1,ain);
    let env2 = copy_env(env);
    at = vcgen_stmt(env,s1,at);
    af = vcgen_stmt(env2,s2,af);
    merge_env(env,env2);
    return may_widen(env,or(at,af));
  case &Absyn::While_s($(e,dummy),s):
    // we're doing local iteration here -- we join with the
    // assertion on the dummy and widen each time around the loop since
    // its assertion will be updated by a continue.  We disallow
    // goto's in the analysis by essentially forcing their destination's
    // assertion to be true.
    assn_t loop_inv = &true_assn;
    switch (e->r){
      // we treat e2 = @assert(...) && ... specially
      // the @assert would be considered as loop a invariant
    case &Absyn::And_e(eleft, eright):
      switch (eleft->r){
      case &Absyn::Assert_e(eassn):
	let $(tm, an) = vcgen_rexp(env, eleft, ain);
	loop_inv = vcgen_test(env, eassn, &true_assn)[0];
	e = eright;
	ain = an;
	break;
      default:
	break;
      }
      break;
    default:
      break;
    }
    while (true) {
      ain = loop_assn(env,dummy,ain);
      ain = and(ain, loop_inv);
      let $(at,af) = vcgen_test(env,e,ain);
      ain = vcgen_stmt(env,s,at);
      if (!implies(&ain, &loop_inv)){
	//failed in testing invariance;
	Warn::err(e->loc, "cannot prove loop invariant %s from %s\n",
		  assn2string(loop_inv), assn2string(ain));
	return &true_assn;
      }
      if (simple_implies(&ain,get_assn(env,dummy))) return af;
    } 
  case &Absyn::Continue_s: fallthru;
    // continue is a backwards jump in a loop, but we take
    // that into account as part of the loop iteration.
    let dest = Hashtable::lookup(env->shared->succ_table,s);
    loop_assn(env, (stmt_t)dest, ain);
    return &false_assn;
  case &Absyn::Break_s:
    // break is a forwards jump so we can do an Or.  This assertion
    // that we set on the destination will be picked up when we hit
    // that statement.  
    let dest = Hashtable::lookup(env->shared->succ_table,s);
    if (dest == NULL) 
      update_return(env,NULL,ain,NULL);
    else 
      forward_assn(env, (stmt_t)dest, ain);
    return &false_assn;
  case &Absyn::For_s(e1,$(e2,dummy2),$(e3,dummy3),s):
    let $(_,a) = vcgen_rexp(env,e1,ain);
    ain = a;
    assn_t loop_inv = &true_assn;
    switch (e2->r){
      // we treat e2 = @assert(...) && ... specially
      // the @assert would be considered as loop invariance
    case &Absyn::And_e(eleft, eright):
      switch (eleft->r){
      case &Absyn::Assert_e(eassn):
	let $(tm, an) = vcgen_rexp(env, eleft, ain);
	loop_inv = vcgen_test(env, eassn, &true_assn)[0];
	e2 = eright;
	ain = an;
	break;
      default:
	break;
      }
      break;
    default:
      break;
    }
    let heuristic_inv = heuristic_loop_invariants(env, Absyn::for_stmt(e1, e2, e3, s, 0), ain);
    bool right_loop_inv;
    while (true) {
      ain = loop_assn(env,dummy2,ain);
      ain = and(ain, loop_inv);
      ain = fold_left(and, ain, heuristic_inv);
      let $(at,af) = vcgen_test(env,e2,ain);
      ain = vcgen_stmt(env,s,at);
      // must do pre-statement check because continue goes here
      ain = pre_stmt_update(env,dummy3,ain);
      ain = vcgen_rexp(env,e3,ain)[1];
      //filtering the heuristic loop invariants generated
      let invs = heuristic_inv;

      heuristic_inv = NULL;
      right_loop_inv = true;
      for(; invs != NULL; invs = invs->tl){
	if(implies(&ain, &(invs->hd)))
	  heuristic_inv = new List(invs->hd, heuristic_inv);
	else
	  right_loop_inv = false;
      }
      if (!implies(&ain, &loop_inv)){
	//failed in testing invariance;
	Warn::err(e2->loc, "cannot prove loop invariant %s from %s\n",
		  assn2string(loop_inv), assn2string(ain));
	return &true_assn;
      }
      if ((simple_implies(&ain,get_assn(env,dummy2))) &&
	  (implies(&ain, &loop_inv) && right_loop_inv)){
	loop_inv = fold_left(and, loop_inv, heuristic_inv);
	return and(loop_inv,af);
      }
    }
  case &Absyn::Do_s(s,$(e,dummy)):
    // similar to while loop
    assn_t loop_inv = &true_assn;
    switch (e->r){
      // we treat e2 = @assert(...) && ... specially
      // the @assert would be considered as loop invariance
    case &Absyn::And_e(eleft, eright):
      switch (eleft->r){
      case &Absyn::Assert_e(eassn):
	ain = vcgen_stmt(env, s, ain);
	let $(tm, an) = vcgen_rexp(env, eleft, ain);
	loop_inv = vcgen_test(env, eassn, &true_assn)[0];
	e = eright;
	ain = an;
	break;
      default:
	break;
      }
      break;
    default:
      break;
    }
    while (true) {
      ain = and(ain, loop_inv);
      ain = vcgen_stmt(env,s,ain);
      if (!implies(&ain, &loop_inv)){
	//failed in testing invariance;
	Warn::err(e->loc, "cannot prove loop invariant %s from %s\n",
		  assn2string(loop_inv), assn2string(ain));
	return &true_assn;
      }
      let $(at,af) = vcgen_test(env,e,ain);
      ain = may_widen(env,or(*get_assn(env,dummy),ain));
      if (simple_implies(&ain,get_assn(env,dummy))) return af;
      loop_assn(env,dummy,ain);
    }
  case &Absyn::Switch_s(e,scs,_):
    // FIX: take into acount test of e
    // note that we do not split the state counter for a switch
    // because a fallthru might lead to problems.  if we merged
    // environments at entry points of control-flow paths, then
    // we could handle this.
    let $(t,a) = vcgen_rexp(env,e,ain);
    return vcgen_switch(env,scs,a);
  case &Absyn::Fallthru_s(_,NULL): Warn::impos("vcgen fallthru");
  case &Absyn::Fallthru_s(es,&dest):
    // Also a forward jump so we can do an or.
    let $(ts,a) = vcgen_rexps_always(env,es,ain);
    if (ts != NULL){
      //pat_vars has a bunch of nulls before meaning full pat vars;
      let x = Tcutil::filter_nulls(List::split(dest->pat_vars->v)[0]);
      // initialize the pattern variables with their corresponding terms
      for (; x != NULL; x = x->tl,ts = ts->tl) {
	let vd = x->hd;
	if (vd != NULL) 
	  a = do_assign(env,a,var(vd),ts->hd);
      }
    }
    forward_assn(env, dest->body, a);
    return &false_assn;
  case &Absyn::Decl_s(d,s1):
    ain = vcgen_local_decl(env,d,ain);
    s = s1;
    goto LOOP;
  case &Absyn::Label_s(_,s1): 
    // check to see if s1 is an assertion -- if so, use it as the
    // assumption.  When we do a goto, we'll also look to see if
    // the target label has an assertion and check the implication.
    exp_opt_t label_assn_opt = find_assert_e(s1);
    if (label_assn_opt == NULL) {
      // by making the assertion True here, we're effectively losing
      // all information when we do a goto.  This is conservative, 
      // and means that I don't have to worry about non-structured
      // control-flow.
      ain = &true_assn;
    }
    s = s1;
    goto LOOP;
  case &Absyn::Goto_s(_): 
    // if the target label has an @assert associated with it,
    // then check that we imply the assertion.
    let destopt = Hashtable::lookup(env->shared->succ_table,s);
    if (destopt != NULL) {
      switch (destopt->r) {
      case &Absyn::Label_s(_,s1):
        exp_opt_t label_assn_opt = find_assert_e(s1);
        if (label_assn_opt == NULL) break;
        exp_t label_assn = (exp_t)label_assn_opt;
        let $(at,_) = vcgen_test(env,label_assn,&true_assn);
        if (!implies(&ain,&at))
          Warn::err(s->loc, "cannot prove @assert(%s)\nfrom %s",
                    assn2string(at), assn2string(reduce(ain)));
        break;
      default: break;
      }
    }
    return &false_assn; // see above
  case &Absyn::TryCatch_s(s,scs,_):
    // save old try/catch-handler assertion
    let old_try_assn = env->shared->try_assn;
    // install new try/catch-handler assertion
    env->shared->try_assn = new ((assn_t)&false_assn);
    // run vcgen on the body -- this will update the env->shared->try_assn 
    // with assertions of any state that might throw an exn.
    ain = vcgen_stmt(env,s,ain);
    // restore the old handler's assertion.
    let new_try_assn = *env->shared->try_assn;
    env->shared->try_assn = old_try_assn;
    // analyze the catch handlers and merge with the body to get
    // the final output.
    return or(ain,vcgen_switch(env,scs,new_try_assn));
  }
}

static assn_t vcgen_switch(env_t env, list_t<switch_clause_t> scs, assn_t ain) {
  // note that all of the clauses should explicitly jump (via break)
  // or something else outside of the clause so the result should always
  // be false...
  assn_t res = &false_assn;
  for (; scs != NULL; scs = scs->tl) {
    let sc = scs->hd;
    let a = ain;
    for (let pvs = sc->pat_vars->v; pvs != NULL; pvs = pvs->tl) {
      let &$(vdopt,eopt) = pvs->hd;
      if (vdopt != NULL) {
        // FIX: the expression associated with the vardecls isn't right.
        //if (eopt != NULL)
        //  a = do_assign(env,a,var(*vdopt),vcgen_rexp(env,(exp_t)eopt,a)[0]);
        //else 
          a = kill_var(env,*vdopt,a);
          //do_assign(env,a,var(*vdopt),fresh_var((*vdopt)->type));
      }
    }
    if (sc->where_clause != NULL) 
      a = vcgen_test(env, (exp_t)sc->where_clause, a)[0];
    res = or(res,vcgen_stmt(env,sc->body,a));
  }
  return res;
}

static assn_t add_vardecl(env_t env, vardecl_t vd, assn_t a) {
  // stupid C semantics means I have to put in a dummy value for vd first,
  // then run the initializer.  
  let tv = var(vd);
  a = kill_var(env,vd,a);
  if (vd->initializer != NULL) {
    let $(t,a1) = vcgen_rexp(env,(exp_t)vd->initializer,a);
    a = do_assign(env,a1,tv,t);
  }
  return a;
}

static assn_t vcgen_local_decl(env_t env, decl_t d, assn_t a) {
  switch (d->r) {
  case &Absyn::Var_d(vd): return add_vardecl(env,vd,a);
  case &Absyn::Let_d(p,vds,e,_): 
    let $(_,a) = vcgen_rexp(env,e,a);
    for (let vds = vds->v; vds != NULL; vds = vds->tl) {
      let $(vdopt,eopt) = *vds->hd;
      if (vdopt != NULL) {
        if (eopt == NULL) a = add_vardecl(env,*vdopt,a);
        else {
          let $(t,a1) = vcgen_rexp(env,eopt,a);
          let tv = var(*vdopt);
          a = do_assign(env,a1,tv,t);
        }
      }
    }
    return a;
  case &Absyn::Letv_d(vds): 
    for (; vds != NULL; vds = vds->tl)
      a = add_vardecl(env,vds->hd,a);
    return a;
  case &Absyn::Region_d(_,vd,eopt): 
    if (eopt != NULL) {
      let $(t,a1) = vcgen_rexp(env,(exp_t)eopt,a);
      a = a1;
    }
    // FIX: inaccurate but okay for now.
    a = add_vardecl(env,vd,a);
    return a;
  default: return a;
  }
}

// determine whether a comparing these two expressions is an 
// unsigned or a signed comparison.
static bool unsigned_comparison(exp_t e1, exp_t e2) {
  let t1 = Absyn::compress((type_t)e1->topt);
  let t2 = Absyn::compress((type_t)e2->topt);
  switch $(t1,t2) {
  case $(&Absyn::AppType(&Absyn::IntCon(Absyn::Unsigned,_),_),_): return true;
  case $(_,&Absyn::AppType(&Absyn::IntCon(Absyn::Unsigned,_),_)): return true;
  case $(&Absyn::PointerType(_),&Absyn::PointerType(_)): return true;
  default: return false;
  }
}

#define sgte(t1,t2) (slte(t2,t1))
#define ugte(t1,t2) (ulte(t2,t1))
#define sgt(t1,t2) (slt(t2,t1))
#define ugt(t1,t2) (ult(t2,t1))

static $(assn_t,assn_t) vcgen_test(env_t env, exp_t e, assn_t ain) {
  switch (e->r) {
  case &Absyn::Conditional_e(e1,e2,e3):
    let $(a1t,a1f) = vcgen_test(env,e1,ain);
    let $(a2t,a2f) = vcgen_test(env,e2,a1t);
    let $(a3t,a3f) = vcgen_test(env,e3,a1f);
    return $(or(a2t,a3t),or(a2f,a3f));
  case &Absyn::And_e(e1,e2):
    let $(a1t,a1f) = vcgen_test(env,e1,ain);
    let $(a2t,a2f) = vcgen_test(env,e2,a1t);
    return $(a2t, or(a1f,a2f));
  case &Absyn::Or_e(e1,e2):
    let $(a1t,a1f) = vcgen_test(env,e1,ain);
    let $(a2t,a2f) = vcgen_test(env,e2,a1f);
    return $(or(a1t,a2t),a2f);
  case &Absyn::SeqExp_e(e1,e2):
    let $(_,ain) = vcgen_rexp(env,e1,ain);
    return vcgen_test(env,e2,ain);
  case &Absyn::Primop_e(Absyn::Not,&List(e1,_)):
    let $(at,af) = vcgen_test(env,e1,ain);
    return $(af,at);
  case &Absyn::Primop_e(p,&List(e1,&List(e2,NULL))):
    let $(t1,a1) = vcgen_rexp(env,e1,ain);
    let $(t2,a2) = vcgen_rexp(env,e2,a1);
    let at = a2;
    let af = a2;
    switch p {
    case Absyn::Eq:  
      at = and(at,eq(t1,t2)); af = and(af,neq(t1,t2)); break;
    case Absyn::Neq: 
      at = and(at,neq(t1,t2)); af = and(af,eq(t1,t2)); break;
    case Absyn::Lt:
      if (unsigned_comparison(e1,e2)) {
        at = and(at,ult(t1,t2));  af = and(af,ugte(t1,t2)); 
      } else {
        at = and(at,slt(t1,t2));  af = and(af,sgte(t1,t2)); 
      }
      break;
    case Absyn::Lte: 
      if (unsigned_comparison(e1,e2)) {
        at = and(at,ulte(t1,t2)); af = and(af,ugt(t1,t2)); 
      } else {
        at = and(at,slte(t1,t2)); af = and(af,sgt(t1,t2)); 
      }
      break;
    case Absyn::Gt:  
      if (unsigned_comparison(e1,e2)) {
        at = and(at,ugt(t1,t2));  af = and(af,ulte(t1,t2)); 
      } else {
        at = and(at,sgt(t1,t2));  af = and(af,slte(t1,t2)); 
      }
      break;
    case Absyn::Gte: 
      if (unsigned_comparison(e1,e2)) {
        at = and(at,ugte(t1,t2)); af = and(af,ult(t1,t2)); 
      } else {
        at = and(at,sgte(t1,t2)); af = and(af,slt(t1,t2)); 
      }
      break;
    default: break;
    }
    return $(at,af);
  default:
    let $(t,aout) = vcgen_rexp(env,e,ain);
    return $(and(aout,ugte(t,one())),and(aout,eq(t,zero())));
  }
}

static assn_t vcgen_rexps_nosave(env_t env, list_t<exp_t> es, assn_t a) {
  for (; es != NULL; es = es->tl) 
    a = vcgen_rexp(env,es->hd,a)[1];
  return a;
}

static $(list_t<term_t>*,assn_t) vcgen_rexps(env_t env, list_t<exp_t> es, assn_t a) {
  list_t<term_t> res = NULL;
  bool valid = true;
  for (; es != NULL; es = es->tl) {
    let $(t,aout) = vcgen_rexp(env,es->hd,a);
    a = aout;
    if (valid && t != NULL) {
      res = new List{(term_t)t,res};
    } else {
      valid = false;
    }
  }
  return $(valid ? new (imp_rev(res)) : NULL, a);
}

static $(term_t,assn_t) vcgen_rexp_always(env_t env, exp_t e, assn_t ain) {
  let $(topt,a) = vcgen_rexp(env,e,ain);
  return $(topt == NULL ? fresh_var(e->topt) : (term_t)topt, a);
}

static $(list_t<term_t>,assn_t) vcgen_rexps_always(env_t env, list_t<exp_t> es, assn_t ain) {
  list_t<term_t> res = NULL;
  for (; es != NULL; es = es->tl) {
    let $(t,a) = vcgen_rexp_always(env,es->hd,ain);
    ain = a;
    res = new List(t,res);
  }
  return $(List::imp_rev(res),ain);
}

static struct Absyn::Vardecl *bind2vardecl(Absyn::binding_t b) {
  switch (b) {
  case &Absyn::Global_b(vd): return vd;
  case &Absyn::Funname_b(fd): return fd->fn_vardecl;
  case &Absyn::Unresolved_b(...): Warn::impos("vcgen bind2vardecl");
  case &Absyn::Param_b(vd): return vd;
  case &Absyn::Local_b(vd): return vd;
  case &Absyn::Pat_b(vd): return vd;
  }
}

static term_opt_t varopt(Absyn::binding_t b) {
  let vdopt = bind2vardecl(b); 
  if (vdopt == NULL) return NULL;
  return var((vardecl_t)vdopt);
}

static $(term_opt_t,assn_t) vcgen_lexp(env_t env, exp_t e, assn_t ain) {
  switch (e->r) {
  case &Absyn::Var_e(b): return $(varopt(b),ain);
  default: return $(NULL, vcgen_rexp(env,e,ain)[1]);
  }
}

// extract the arguments, requires, and ensures clause for a function from
// its type.
static $(list_t<$(var_opt_t,tqual_t,type_t)@> args, list_t<vardecl_t> argvds, exp_opt_t req, exp_opt_t ens, vardecl_opt_t ret_value) get_requires_and_ensures_info(Absyn::fn_info_t @fi) {
  return $(fi->args,fi->arg_vardecls,fi->requires_clause,fi->ensures_clause,fi->return_value);
}

static $(list_t<$(var_opt_t,tqual_t,type_t)@> args, list_t<vardecl_t> argvds, exp_opt_t req, exp_opt_t ens, vardecl_opt_t ret_value) get_requires_and_ensures(type_opt_t topt) {
  if (topt != NULL) {
    type_t t = Tcutil::pointer_elt_type((type_t)topt);
    switch (t) {
    case &Absyn::FnType(*fi): return get_requires_and_ensures_info(fi);
    default: break;
    }
  } 
  return $(NULL,NULL,NULL,NULL,NULL);
}

static void check_requires(Position::seg_t loc,
                           env_t env, list_t<term_t> inputs,
                           list_t<vardecl_t> argvds,
                           assn_t a, exp_opt_t reqopt) {
  if (reqopt != NULL) {
    exp_t req = (exp_t)reqopt;
    // pretend like we're assigning the actual values to the parameter
    // values
    for (; argvds != NULL && inputs != NULL; argvds = argvds->tl, inputs = inputs->tl) {
      let vd = argvds->hd;
      a = and(a,eq(var(vd),inputs->hd));
    }
    // FIX? varargs.
    let $(at,_) = vcgen_test(env,(exp_t)reqopt,&true_assn);
    if (!implies(&a,&at))
      Warn::err(loc, "cannot prove @requires %s from %s",
                assn2string(reduce(at)), assn2string(reduce(a)));
  }
}

static term_opt_t deref_lterm(env_t env, term_opt_t lt, assn_t ain) {
  return lt;
}

static bool is_unsigned_int_exp(exp_t e){
  type_opt_t t= e->topt;
  if (t == NULL) return false;
  switch(t){
    //wangyl:: FIX, dependence on sizeof(int) == sizeof(long) !!!!!
  case &Absyn::AppType(&Absyn::IntCon(Absyn::Unsigned, sz), _):
    if ((sz == Absyn::Long_sz) || (sz == Absyn::Int_sz))
      return true;
    else return false;
  default: return false;
  }

}
static $(term_opt_t,assn_t) vcgen_rexp_nodebug(env_t env, exp_t e, assn_t ain) {
  if (Tcutil::is_const_exp(e)){
     // special case for pragmas
     switch (e->r) {
     case &Absyn::Pragma_e(s):
       if (strcmp(s,"print_assn") == 0) {
         let seg_str = Position::string_of_segment(e->loc);
         fprintf(stderr,"%s: current assn is %s\n",seg_str,assn2string(reduce(ain)));
       }
       if (strcmp(s,"all_paths") == 0) {
         env->shared->widen_paths = false;
       }
       if (strcmp(s,"one_path") == 0) {
         env->shared->widen_paths = true;
       }
       return $(zero(),ain);
     default:  break;
     }
     let $(cn, known)= Evexp::eval_const_uint_exp(e);
     if (known) return $(uint(cn), ain);
  }
  switch (e->r) {
  case &Absyn::Const_e(c): 
    // should really be caught by the above...
    return $(cnst(e),ain);
  case &Absyn::Var_e(b): return $(varopt(b),ain);
  case &Absyn::Primop_e(p,&List{e1,NULL}):
    let $(t, aout) = vcgen_rexp_always(env, e1, ain);
    return $(unop(p,t,e->topt),aout);
  case &Absyn::Primop_e(p,&List{e1,&List{e2,_}}):
    let $(t1, aout1) = vcgen_rexp_always(env, e1, ain);
    let $(t2, aout) = vcgen_rexp_always(env, e2, aout1);
    let t = binop(p, t1, t2, e->topt);
    // if  the expression has type unsigned, then we may conclude
    // t == t1 % t2 u< t2
    if ((p == Absyn::Mod) && (is_unsigned_int_exp(e))){
      //      fprintf(stderr,"e1 mod e2 is unsigned\n");
      aout = and(aout, ult(t1, t2));
    }
    return $(t, aout);
  case &Absyn::Primop_e(_,_): Warn::impos("vcgen: bad primop");
  case &Absyn::AssignOp_e(e1,popt,e2):
    let $(t2,a1) = vcgen_rexp(env,e2,ain);
    let $(lt,a2) = vcgen_lexp(env,e1,a1);
    if (popt != NULL) {
      let t1 = deref_lterm(env,lt,a2);
      if (t1 == NULL || t2 == NULL) 
        t2 = NULL;
      else
        t2 = binop(popt->v,(term_t)t1,(term_t)t2,e->topt);
    }
    let a = do_assign(env,a2,lt,t2);
    return $(lt,a);
  case &Absyn::Increment_e(e,i):
    let $(lt,a1) = vcgen_lexp(env,e,ain);
    let t1 = deref_lterm(env,lt,a1);
    term_opt_t res = NULL;
    term_opt_t assn = NULL;
    switch (i) {
    case Absyn::PreInc: 
      if (t1 != NULL) assn = plus(t1,one(),e->topt);
      res = assn;
      break;
    case Absyn::PostInc:
      res = t1;
      if (t1 != NULL) assn = plus(t1,one(),e->topt);
      break;
    case Absyn::PreDec:
      if (t1 != NULL) assn = minus(t1,one(),e->topt);
      res = assn;
      break;
    case Absyn::PostDec:
      res = t1;
      if (t1 != NULL) assn = minus(t1,one(),e->topt);
      break;
    default: Warn::impos("vcgen vcgen_rexp increment_e");
    }
    let a = do_assign(env,a1,lt,assn);
    return $(res,a);
  case &Absyn::Conditional_e(e1,e2,e3):
    let $(at,af) = vcgen_test(env,e1,ain);
    let $(t1,at) = vcgen_rexp(env,e2,at);
    let $(t2,af) = vcgen_rexp(env,e3,af);
    if (t1 != NULL && t2 != NULL) {
      let v = fresh_var(e->topt);
      at = and(at,eq(v,t1));
      af = and(af,eq(v,t2));
      return $(v,may_widen(env,or(at,af)));
    } else
      return $(NULL,may_widen(env,or(at,af)));
  case &Absyn::And_e(e1,e2):
    let $(at,af) = vcgen_test(env,e1,ain);
    let $(t,at) = vcgen_rexp(env,e2,at);
    let v = fresh_var(e->topt);
    at = and(at,eq(v,t));
    af = and(af,eq(v,zero()));
    return $(v,may_widen(env,or(at,af)));
  case &Absyn::Or_e(e1,e2):
    let $(at,af) = vcgen_test(env,e1,ain);
    let $(t,af) = vcgen_rexp(env,e2,af);
    let v = fresh_var(e->topt);
    at = and(at,eq(v,one()));
    af = and(af,eq(v,t));
    return $(v,may_widen(env,or(at,af)));
  case &Absyn::SeqExp_e(e1,e2):
    let $(_,a) = vcgen_rexp(env,e1,ain);
    return vcgen_rexp(env,e2,a);
  case &Absyn::FnCall_e(e1,es,...):
    let $(ts,a) = vcgen_rexps_always(env,es,ain);
    let $(_,a2) = vcgen_rexp(env,e1,a);
    // check @requires clause on function
    let $(args,argvds,reqopt,ensopt,ret_value) = get_requires_and_ensures(e1->topt);
    check_requires(e->loc,env,ts,argvds,a2,reqopt);
    // kill every variable that points into memory -- could refine
    // this to only those reachable from globals or the parameters.
    a2 = kill(a2);
    update_try_assn(env,a2);
    // noreturn functions don't return...
    if (Atts::is_noreturn_fn_type((type_t)e1->topt)) a2 = &false_assn;
    if (ensopt == NULL) 
      return $(NULL,a2);
    exp_t ensures = (exp_t)ensopt;
    // add in the @ensures clause for the result
    let $(at,_) = vcgen_test(env,ensures,a2);
    // substitute ts for function formals in resulting assertion
    for (; args != NULL && ts != NULL; args=args->tl, ts=ts->tl) {
      let &$(vdopt,_,_) = args->hd;
      if (vdopt != NULL) {
        let vd = argvds->hd;
        argvds = argvds->tl;
        at = subst(vd,ts->hd,at);
      }
    }
    // substitute v for the return_value
    if (ret_value != NULL) {
      let v = fresh_var(((vardecl_t)ret_value)->type);
      // FIX: substitute ts for formal parameters
      at = subst((vardecl_t)ret_value,v,at);
      return $(v,at);
    } 
    return $(NULL,at);
  case &Absyn::Throw_e(e,_):
    let $(_,a) = vcgen_rexp(env,e,ain);
    update_try_assn(env,a);
    return $(NULL,&false_assn);
  case &Absyn::NoInstantiate_e(e): return vcgen_rexp(env,e,ain);
  case &Absyn::Instantiate_e(e,_):  return vcgen_rexp(env,e,ain);

  case &Absyn::Cast_e(tp,e1,_,c): 
    // FIX: really need to put C coercions in terms...
    let $(topt,a) = vcgen_rexp(env,e1,ain);
    // we only need to retain the cast on the term if it
    // changes the size of the value.  In particular, we
    // can drop a cast from an int to an unsigned int and
    // vice versa.  We might be able to get away with 
    // dropping other casts (e.g., char->int) but we'll be
    // conservative now.
    switch $(Absyn::compress(tp),Absyn::compress((type_t)e->topt)) {
      // these two cases allow us to drop a cast of a tag_t to int/long
      // or unsigned int/unsigned long.
    case $(&Absyn::AppType(&Absyn::IntCon(_,Absyn::Int_sz),_),&Absyn::AppType(&Absyn::TagCon,_)):
      return $(topt,a);
    case $(&Absyn::AppType(&Absyn::IntCon(_,Absyn::Long_sz),_),&Absyn::AppType(&Absyn::TagCon,_)):
      return $(topt,a);
      // this case lets us drop a cast when they are two integers and the
      // size is the same.
    case $(&Absyn::AppType(&Absyn::IntCon(u1,s1),_),&Absyn::AppType(&Absyn::IntCon(u2,s2),_)):
      //wangyl: a hack to tell compiler that long and int have the same size
      //FIX: this is machine dependent!
      s1 = (s1 == Absyn::Long_sz? Absyn::Int_sz:s1);
      s2 = (s2 == Absyn::Long_sz? Absyn::Int_sz:s2);
      if (s1 == s2) return $(topt,a);
      break;
    case $(&Absyn::PointerType(p2),&Absyn::PointerType(p1)):
      let n1 = Tcutil::force_type2bool(false,p1.ptr_atts.nullable);
      let n2 = Tcutil::force_type2bool(false,p2.ptr_atts.nullable);
      let b1 = Tcutil::get_bounds_exp(Absyn::bounds_one(),p1.ptr_atts.bounds);
      let b2 = Tcutil::get_bounds_exp(Absyn::bounds_one(),p2.ptr_atts.bounds);
      switch $(b1,b2) {
      case $(&_, &_):  
        // Both thin pointers -- type-checker should ensure that 
        // we're casting to a smaller length so we don't have to worry about
        // that check.  Now check to see if we have to do a NULL-check.
        if (n1 && !n2) {
          if (topt != NULL) {
            term_t term = (term_t)topt;
            let null_check = neq(zero(),term);
            let exp_checks = new ExpChecks{.ctxt=a,.bounds_check=&true_assn,
                                           .null_check=null_check};
            update_try_assn(env,and(a,eq(term,zero())));
            return $(term,and(a,null_check));
          } else {
            update_try_assn(env,a);
          }
        }
        return $(topt,a);
      case $(&_,NULL):  // cast to fat -- no failure possible
        return $(topt,a);
      case $(NULL,&_):  
        // cast from fat -- need bounds check and possible null check
        // depending upon n2.
        if (topt != NULL) {
          let term = (term_t)topt;
          let null_check = n2 ? (assn_t)&true_assn : neq(zero(),term);
          let $(b,_) = vcgen_rexp_always(env, (exp_t)b2, a);
          let bcheck = ulte(b,unop(Absyn::Numelts,term,Absyn::uint_type));
          let exp_checks = new ExpChecks{.ctxt=a,.bounds_check=bcheck,
                                         .null_check=null_check};
          let checks = and(null_check,bcheck);
          update_try_assn(env,and(a,not(checks)));
          return $(term,and(a,checks));
        } else {
          update_try_assn(env,a);
        }
        return $(topt,a);
      case $(NULL,NULL): // fat to fat -- no failure possible
        return $(topt,a);
      }
    default: break;
    }
    if (c == Absyn::No_coercion) {
      if (topt == NULL) return $(NULL,a);
      term_t t = (term_t)topt;
      return $(cast(tp,t),a);
    } else {
      // FIX:  we really need to interpret the casts appropriately.
      update_try_assn(env,ain); // coercion could fail
      return $(topt == NULL ? NULL : cast(tp,(term_t)topt),a);
    }
  case &Absyn::New_e(eopt,e,qopt):
    if (eopt != NULL)
      ain = vcgen_rexp(env,(exp_t)eopt,ain)[1];
    if (qopt != NULL)
      ain = vcgen_rexp(env,(exp_t)qopt,ain)[1];
    return $(NULL,vcgen_rexp(env,e,ain)[1]);

  // these cases should be captured by the const-expression check above.
  case &Absyn::Enum_e(...):
  case &Absyn::AnonEnum_e(...):
  case &Absyn::Sizeoftype_e(_):
  case &Absyn::Sizeofexp_e(_):
  case &Absyn::Valueof_e(_):
  case &Absyn::Offsetof_e(_,_): return $(cnst(e),ain);

  // These can all throw exceptions
  case &Absyn::AggrMember_e(e,...): fallthru(e);
    ain = vcgen_rexp(env,e,ain)[1];
    update_try_assn(env,ain);
    return $(NULL,ain);

  case &Absyn::Tagcheck_e(e,_): fallthru(e);
  case &Absyn::Address_e(e): 
    return $(NULL,vcgen_rexp(env,e,ain)[1]);

  case &Absyn::Deref_e(e): fallthru(e);
  case &Absyn::AggrArrow_e(e,...): fallthru(e, zero_exp());
  case &Absyn::Subscript_e(e1,e2): 
    let $(t1,a1) = vcgen_rexp_always(env,e1,ain);
    let $(t2,a2) = vcgen_rexp(env,e2,a1);
    term_t term_numelts, term_typebound;
    // we don't know t2, can't really infer anything about the bound
    if (t2 == NULL) { 
      update_try_assn(env, a2);
      return $(NULL,a2);
    }
    let eopt = Tcutil::get_type_bound((type_t)e1->topt);
    if (eopt == NULL) {
      // fat pointer -- express bounds in terms of numelts(t1)
      term_numelts = unop(Absyn::Numelts, t1, Absyn::uint_type);
    } else {
      // thin pointer -- express bounds directly from type
      exp_t e = (exp_t)eopt;
      term_numelts = vcgen_rexp_always(env, e, a2)[0];
    }
    let bnds_check = ult(t2, term_numelts);
    // note that although this is a neq, the prover will not blow
    // up because it need only consider 0 < t1.
    let null_check = neq(zero(),t1);
    // if we have an exception, then we know either the bounds check
    // failed or the null check failed.
    update_try_assn(env,and(a2,or(not(bnds_check),not(null_check))));
    // associate these checks with the expression for insert_checks
    let exp_checks = new ExpChecks{.ctxt=a2,.bounds_check=bnds_check,
                                   .null_check=null_check};
    insert_exp_checks(env->assn_info, e1, exp_checks);
    // afterwards, we know both the bounds check and null check succeeded.
    a2 = and(and(a2,bnds_check),null_check);;
    return $(NULL,a2);

  case &Absyn::Datatype_e(es,...): return $(NULL,vcgen_rexps_nosave(env,es,ain));

  case &Absyn::CompoundLit_e(_,dles):   fallthru(dles);
  case &Absyn::Array_e(dles):           fallthru(dles);
  case &Absyn::Aggregate_e(_,_,dles,_): fallthru(dles);
  case &Absyn::UnresolvedMem_e(_,dles): fallthru(dles);
  case &Absyn::AnonStruct_e(_,_,dles):
    for (; dles != NULL; dles = dles->tl) {
      let &$(_,e) = dles->hd;
      ain = (vcgen_rexp(env,e,ain))[1];
    }
    return $(NULL,ain);

  case &Absyn::Comprehension_e(vd,e1,e2,_): 
    // similar to a while-loop except we evaluate e1 only once.
    let $(t1,a) = vcgen_rexp_always(env,e1,ain);
    let v = var(vd);
    // start off with index 0
    a = do_assign(env,a,v,zero());
    while (true) {
      let at = and(a,ult(v,t1));  // simulate test
      let af = and(a,ugte(v,t1));
      let $(_,abody) = vcgen_rexp(env,e2,at);  // run body and add one
      abody = do_assign(env,abody,v,plus(v,one(),vd->type));
      if (simple_implies(&abody,&a)) { a = af; break; }
      // no choice about widening here to ensure termination
      a = widen(or(abody,a));  // widen and possibly iterate
    }
    return $(NULL,a);
  case &Absyn::ComprehensionNoinit_e(e,_,_):
    return $(NULL,vcgen_rexp(env,e,ain)[1]);
  case &Absyn::Malloc_e(mi):
    if (mi.rgn != NULL) 
      ain = vcgen_rexp(env,(exp_t)mi.rgn,ain)[1];
    return $(NULL,vcgen_rexp(env,mi.num_elts,ain)[1]);
  case &Absyn::Swap_e(e1,e2): 
    let $(lt1,a1) = vcgen_lexp(env,e1,ain);
    update_try_assn(env,a1); // could have null-exn?
    let $(lt2,a2) = vcgen_lexp(env,e2,a1);
    update_try_assn(env,a2); // could have null-exn?
    let t1 = deref_lterm(env,lt1,a2);
    let t2 = deref_lterm(env,lt2,a2);
    a2 = do_assign(env,a2,lt1,t2);
    a2 = do_assign(env,a2,lt2,t1);
    return $(NULL,a2);
  case &Absyn::StmtExp_e(s):
    let old_exp_stmt = env->shared->exp_stmt;
    env->shared->exp_stmt = new NULL;
    let aout = vcgen_stmt(env,s,ain);
    let t = *(env->shared->exp_stmt);
    env->shared->exp_stmt = old_exp_stmt;
    return $(t,aout);
  case &Absyn::Asm_e(...): return $(NULL,ain);
  case &Absyn::Extension_e(e): return vcgen_rexp(env,e,ain);
  case &Absyn::Pragma_e(s):  return $(zero(),ain);
  case &Absyn::Assert_e(e1):
    let $(at,_) = vcgen_test(env,e1,&true_assn);
    if (!implies(&ain,&at)) 
      Warn::err(e->loc, "cannot prove @assert(%s) \nfrom %s",
                assn2string(at), assn2string(reduce(ain)));
    return $(one(),and(ain,at));
  }
}


// FIX? take into account top-level (const) variable intializers?
void vcgen_fundecl(JumpAnalysis::jump_anal_res_t tables, Absyn::fndecl_t fd, assn_info_t assn_info){
  assn_t a = &true_assn;
  // put in the requires clause as an assumption.
  let $(args,arvds,reqopt,ensopt,ret_value) = get_requires_and_ensures_info(&fd->i);
  assn_t *result_assn = (ensopt == NULL) ? NULL : new ((assn_t)&false_assn);
  term_opt_t res_term = (ret_value == NULL) ? NULL : (var((vardecl_t)ret_value));
  let env = initial_env(tables,fd,assn_info,result_assn,res_term);
  if (reqopt != NULL) {
    // hope the vards in here point to the vardecls in the fn...
    a = vcgen_test(env,(exp_t)reqopt,a)[0];
  }
  vcgen_stmt(env,fd->body,a);
  // check the ensures clause
  if (ensopt != NULL) {
    exp_t ens = (exp_t)ensopt;
    let $(at,_) = vcgen_test(env,ens,&true_assn);
    let senv = env->shared;
    let res_assn_opt = *senv->res_assn;
    assn_t res_assn = &false_assn;
    if (res_assn_opt != NULL) res_assn = ((assn_t)res_assn_opt);
    if (!implies(&res_assn,&at))
      Warn::err(ens->loc, "cannot prove the @ensures clause %s from %s",
		assn2string(reduce(at)),assn2string(reduce(res_assn)));
  }
  reset_hash_cons_table(); // collect table
}
