/* Computing Strongest Post-conditions
   Copyright (C) 2003 Greg Morrisett
   This file is part of the Cyclone compiler.

   The Cyclone compiler is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   The Cyclone compiler is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with the Cyclone compiler; see the file COPYING. If not,
   write to the Free Software Foundation, Inc., 59 Temple Place -
   Suite 330, Boston, MA 02111-1307, USA. */

#include <hashtable.h>
#include <dict.h>
#include <string.h>
#include <list.h>
#include "flags.h"
#include "vcgen.h"
#include "assndef.h"
#include "tcutil.h"
#include "evexp.h"
#include "warn.h"
#include "pratt_prover.h"
#include "absynpp.h"
#include "cf_flowinfo.h"
#include "attributes.h"
#include <cycboot.h>

#define VCGEN_DEBUG
namespace Vcgen;
using AssnDef;
using List;
///////////////////// Analysis /////////////////////


////////// Analysis Environment /////////////////////

// it contains information that will be used through out the analysis
// it is also responsible for collecting information during analysis
struct Env {
  // a mapping from statements to accumulated pre-conditions 
  Hashtable::table_t<stmt_t,assn_map_t@> assn_table;
  // a mapping for successors in the control-flow graph (from jump_analysis)
  Hashtable::table_t<stmt_t,stmt_opt_t> succ_table;
  // a mapping from expressions to assertions to be proved 
  // in insert_checks to ensure operation is safe.
  assn_info_t assn_info;
  // the assertion accumulated for the current exception handler if any
  assn_map_opt_t try_assnmap;
  // when not-null is used to record the resulting value of an expr-stmt.
  term_t* exp_stmt;
  // used to record the result terms and assertions for a function.  Only
  // needed when the function has an ensures clause.
  // the return_value is represented by a logical var
  term_opt_t res_term;
  assn_map_opt_t res_assnmap; 
  assn_map_opt_t continue_assnmap;
  // true by default: controls whether we widen assertions at join points
  bool    widen_paths;
  // determines whether we are interpreting the expression as a "pure"
  // expression (i.e., as short-hand for an assertion).
  bool    pure_exp;
};

typedef struct Env @env_t;

static int hash_ptr(`a s) { return (int)s; }

// creating the initial environment in the beginning of
// the analysis for a function
static env_t 
initial_env(JumpAnalysis::jump_anal_res_t tables, Absyn::fndecl_t fd, 
	    assn_info_t assn_info, assn_map_opt_t res_assnmap, 
	    assn_map_opt_t try_assnmap, term_opt_t res_term) {
  let succ_table = Hashtable::lookup(tables->succ_tables,fd);
  let assn_table = Hashtable::create(57, Core::ptrcmp, hash_ptr);
  let env =  new Env{.assn_table = assn_table,
                     .succ_table = succ_table,
		     .assn_info = assn_info,
                     .try_assnmap = try_assnmap,
                     .exp_stmt = NULL,
                     .res_term = res_term,
                     .res_assnmap = res_assnmap,
		     .continue_assnmap = NULL,
                     .widen_paths = !Flags::allpaths,
                     .pure_exp = false};
  return env;
}

// creating a bogus environment for processing a pure expression
// for now, this is only used to turn @requires,@ensures @throws
// expression in function definition into assertions.
static env_t bogus_env(){
  let succ_table = Hashtable::create(1,Core::ptrcmp,hash_ptr);
  let assn_table = Hashtable::create(1,Core::ptrcmp,hash_ptr);
  let assn_info = new Hashtable::create(1, Core::ptrcmp, hash_ptr);
  env_t env = new Env{.assn_table = assn_table,
		      .succ_table = succ_table,
		      .assn_info = assn_info,
		      .try_assnmap = NULL,
		      .exp_stmt = NULL,
		      .res_term = NULL,
		      .res_assnmap = NULL,
		      .continue_assnmap = NULL,
                      .widen_paths = false,
                      .pure_exp = true};
  return env;
}

// widening only makes sure that the assn in assnmap is relaxed
static assn_map_t may_widen(env_t env, assn_map_t am){
  if (env->widen_paths) {
    return widen_assnmap(am);
  }
  return am;
}

/* the following functions manipulate the assn_table which contains
   the precondition for each statement in the program. */

// lookup assertions accumulated from previously control flow
static assn_map_t lookup_stmt_assnmap(env_t env, stmt_t s) {
  assn_map_t @*preconopt = Hashtable::lookup_opt(env->assn_table,s);
  if (preconopt != NULL) return **preconopt;
  else return false_assnmap();
}

// update assertions reaching a statement 
static void update_stmt_assnmap(env_t env, stmt_t s, assn_map_t newam){
  assn_map_t @*preconopt = Hashtable::lookup_opt(env->assn_table,s);
  if (preconopt != NULL) **preconopt = may_widen(env,or_assnmap_assnmap(**preconopt,newam));
  else Hashtable::insert(env->assn_table,s,new newam);
}

// replace assertions reaching a statement 
// discard whatever was in there before.
static void replace_stmt_assnmap(env_t env, stmt_t s, assn_map_t newam){
  Hashtable::insert(env->assn_table,s,new newam);
}

// vcgen for statements. amin is the assertion and mapping that
// describes the beginning state. return the assertion and mapping
// that describes the output state.
static assn_map_t vcgen_stmt(env_t, stmt_t, assn_map_t amin);
// analyze an expression given a initial machine state and 
// generate a term that represents the r-value of the expression
// and an assetion and mapping that describes the output state.
static $(term_t,assn_map_t) vcgen_rexp(env_t, exp_t, assn_map_t);
// analyze a list of expressions in order and return
// a list of terms and the final assertion
static $(list_t<term_t>,assn_map_t) vcgen_rexps(env_t,list_t<exp_t>,assn_map_t);
// similar to vcgen_rexp except that the term represents the
// expression's l-value
static $(term_t,assn_map_t) vcgen_lexp(env_t, exp_t, assn_map_t);
// analyze a boolean expression. returns assertion-mappings that
// describe either the machine state when the expression evaluates
// to true or the machine state when the exp evaluates to false
static $(assn_map_t,assn_map_t) vcgen_test(env_t, exp_t,assn_map_t);

// analyze a pattern of a term v, the term's lvalue is used during
// reference pattern, and the result gives an assertion for 
// matching case and one for non-matching case
static $(assn_map_t,assn_map_t) vcgen_pat(env_t env, Absyn::pat_t p, 
					  term_opt_t lvalue, term_t v, assn_map_t amin);

static assn_map_t vcgen_switch(env_t, term_t, list_t<switch_clause_t>, assn_map_t);
static assn_map_t vcgen_local_decl(env_t, decl_t, assn_map_t);

static bool simple_implies(assn_t a1, assn_t a2){
  return AssnDef::simple_prove(a1,a2);
}

static bool implies(assn_t a1, assn_t a2){
  return simple_implies(a1,a2) || PrattProver::constraint_prove(a1,a2);
}

static bool implies_assnmap(assn_map_t am1, assn_map_t am2){
  // am1 and am2 might have different var_maps,
  // unify_var_maps would generate two new assertions
  // and a mapping such that am1 <=> AssnMap(a1,map) and
  // AssnMap(a2,map) <=> am2
  let $(a1,a2,map) = unify_var_maps(am1,am2);
  return simple_implies(a1,a2) || PrattProver::constraint_prove(a1,a2);
}

// helper function, retrieve the vardecl from a binding.
static struct Absyn::Vardecl *bind2vardecl(Absyn::binding_t b) {
  switch (b) {
  case &Absyn::Global_b(vd): return vd;
  case &Absyn::Funname_b(fd): return fd->fn_vardecl;
  case &Absyn::Unresolved_b(...): Warn::impos("vcgen bind2vardecl");
  case &Absyn::Param_b(vd): return vd;
  case &Absyn::Local_b(vd): return vd;
  case &Absyn::Pat_b(vd): return vd;
  }
}

// checking if an expression has type unsigned int 
static bool is_unsigned_int_exp(exp_t e){
  type_opt_t t= e->topt;
  if (t == NULL) return false;
  switch(t){
    //wangyl:: FIX, dependence on sizeof(int) == sizeof(long) !!!!!
  case &Absyn::AppType(&Absyn::IntCon(Absyn::Unsigned, sz), _):
    if ((sz == Absyn::Long_sz) || (sz == Absyn::Int_sz))
      return true;
    else return false;
  default: return false;
  }
}


// given a lvalue (address), get the content of that address
// if the address is the address of an nonescaping variable,
// the value is in nonescvarmap
// otherwise, we select the address from the memory
static $(term_t,assn_map_t) deref_lterm(env_t env, term_t lt, assn_map_t am){
  switch (lt){
  case &Addr(vd):
    if (!vd->escapes) {
      return lookup_var_map(vd,am);
    }
    fallthru;
  default:
    let $(mem,am1) = lookup_var_map(memory,am);
    return $(select(mem,lt,NULL),am1);
  }
}

// assignment lt = t
// based on what lt is, we will either update the content of memory,
// or update the nonescvar-map
static assn_map_t do_assign(env_t env, assn_map_t am, term_t lt, term_t t){
  switch (lt) {
  case &Addr(vd): 
    if (!vd->escapes) {
      return update_var_map(vd, t, am);
    }
    fallthru;
  default:
    let $(mem,am1) = lookup_var_map(memory,am);
    return update_var_map(memory, update(mem,lt,t),am1);
  }
}

// update the assertion associated with
// the current exception handler
static void update_try_assnmap(env_t env, assn_map_t am, term_t exn_value){
  if (env->try_assnmap == NULL) return;
  am = do_assign(env,am,addr(exception_vardecl()),exn_value);
  am = may_widen(env,or_assnmap_assnmap(*env->try_assnmap,am));
  *env->try_assnmap = am;
}

static assn_map_t vcgen_local_decl(env_t env, decl_t d, assn_map_t amin){
  switch (d->r) {
  case &Absyn::Var_d(vd):
    // when declaring a variable, it's "initialized" with a random value
    // before we actually run the initializer...
    amin = do_assign(env,amin,addr(vd),fresh_var(vd->type));
    if (vd->initializer != NULL) {
      let $(t,am) = vcgen_rexp(env,(exp_t)vd->initializer,amin);
      am = do_assign(env,am,addr(vd),t);
      return am;
    }
    return amin;
  case &Absyn::Let_d(p,_,e,dtree):
    let $(v,am) = vcgen_rexp(env,e,amin);
    let $(amt,amf) = vcgen_pat(env,p,NULL,v,am);
    // currently we are just creating a fresh logic var for
    // the value of the exception, in the future we should
    // construct a proper exception datatype value
    if (amf.assn != &false_assn)
      update_try_assnmap(env,amf,fresh_var(Absyn::exn_type()));
    return amt;
  case &Absyn::Letv_d(vds):
    // no need to go through the vds because they have
    // no initializers
    return amin;
  case &Absyn::Region_d(_,vd,eopt):
    if (eopt != NULL) {
      let $(t,am) = vcgen_rexp(env,(exp_t)eopt,amin);
      am = do_assign(env,am,addr(vd),t);
      return am;
    }
    return amin;
  default: return amin;
  }
}

// extract the arguments, requires, and ensures clause for a function from
// its type.
static $(list_t<$(var_opt_t,tqual_t,type_t)@> args, list_t<vardecl_opt_t> argvds, assn_map_opt_t req, assn_map_opt_t ens, assn_map_opt_t thrws, vardecl_opt_t ret_value) get_requires_and_ensures_info(Absyn::fn_info_t @fi) {
  return $(fi->args,fi->arg_vardecls,fi->requires_assn,
           fi->ensures_assn,fi->throws_assn,fi->return_value);
}

static $(list_t<$(var_opt_t,tqual_t,type_t)@> args, list_t<vardecl_opt_t> argvds, assn_map_opt_t req, assn_map_opt_t ens, assn_map_opt_t thrws, vardecl_opt_t ret_value) get_requires_and_ensures(type_opt_t topt) {
  if (topt != NULL) {
    type_t t = Tcutil::pointer_elt_type((type_t)topt);
    switch (t) {
    case &Absyn::FnType(*fi): return get_requires_and_ensures_info(fi);
    default: break;
    }
  } 
  return $(NULL,NULL,NULL,NULL,NULL,NULL);
}

static unsigned datatype_constructor_index(Absyn::datatypedecl_t dd,
                                           Absyn::datatypefield_t df) {
  unsigned i = 0;
  let fs = dd->fields->v;
  for (; fs != NULL; fs = fs->tl, ++i) {
    if (fs->hd == df) return i;
    if (Absyn::qvar_cmp(df->name,fs->hd->name) == 0) return i;
  }
  Warn::impos("vcgen: datatype_constructor_index");
}

static $(bool is_tagged,Absyn::aggr_kind_t,list_t<Absyn::aggrfield_t>) 
  get_aggr_info(type_t t) {
  switch (Absyn::compress(t)) {
  case &Absyn::AppType(&Absyn::AggrCon(info),_):
    let ad = Absyn::get_known_aggrdecl(info);
    return $(ad->impl->tagged, ad->kind, ad->impl->fields);
  case &Absyn::AnonAggrType(ak,is_tuple,fs):
    return $(false,ak,fs);
  default: Warn::impos("vcgen: bad type in get_aggr_info");
  }
}

static int cmp_index($(int,`a)@ x,$(int,`a)@ y) {
  return x->f0 - y->f0;
}

// functions related to maintain the information passed to insert_checks
assn_info_t new_assn_info(void){
  let assn_info =  Hashtable::create(57, Core::ptrcmp, hash_ptr);
  return new assn_info;
}

exp_checks_t @ exp2ctxt_checks(assn_info_t assn_info, Absyn::exp_t e){
  let result = Hashtable::lookup_opt(*assn_info, e);
  if (result == NULL){
    static exp_checks_t *b = NULL;
    if (b == NULL) {
      b = new ExpChecks{.ctxt = true_assnmap(),
                        .bounds_check = &false_assn,
                        .null_check = &false_assn};
    }
    //wangyl: we don't know any info about vcgen here, so the ctxt
    //should be true and the assertion we need to prove should be false
    return (exp_checks_t @)b;
  }else{
    return *result;
  }
}

static void insert_exp_checks(assn_info_t assn_info, Absyn::exp_t e, exp_checks_t @`H exp_check) {
  Hashtable::insert(*assn_info, e, exp_check);
  return;
}

static exp_t zero_exp() {
  exp_t ans = Absyn::uint_exp(0,0);
  ans->topt = Absyn::uint_type;
  return ans;
}

static $(assn_t,assn_t) okderef(term_t root, term_t i){
  switch (root) {
  case &Alloc(_,size,_,_): return $(ult(i,size),&true_assn);
  case &Offseti(i0,r,_): 
    let $(bndck,nullck) = okderef(r,plus(i,i0,NULL));
    return $(or(ult(i,numelts_term(root)),
		bndck),
	     or(neq(root,zero()),nullck));
  case &Addr(vd):
    switch (Absyn::compress(vd->type)) {
    case &Absyn::ArrayType(ai):
      if (ai.num_elts != NULL) {
	let $(size,_) = vcgen_rexp(bogus_env(),(exp_t)ai.num_elts,true_assnmap());
	return $(ult(i,size),&true_assn);
      }
      break;
    default: 
      break;
    }
    return $(ult(i,numelts_term(root)),&true_assn);
  default:
    let tp = get_term_type(root);
    if (tp != NULL) {
      switch (Absyn::compress((type_t)tp)) {
      case &Absyn::PointerType(p1):
	let b1 = Tcutil::get_bounds_exp(Absyn::bounds_one(),p1.ptr_atts.bounds);
        let b2 = Tcutil::is_nullable_pointer_type(tp,false);
        let nullck = b2 ? neq(root,zero()) : &true_assn;
	if (b1 != NULL)
          // for thin pointers, the type may be declared with a size
          // that's less than the actual number of elements -- putting
          // this or in here lets us get the common case where the
          // index is less than the known type-based bound, as well as 
          // the uncommon case where the index is provably less than the 
          // number of elements.
	  return $(or(ult(i,cnst((exp_t)b1)),
                      ult(i,numelts_term(root))),nullck);
	break;
      default:
	break;
      }
    }
    break;
  }
  return $(ult(i,numelts_term(root)),neq(root,zero()));
}

// factor out code for *e, e->f and e[i]
static $(term_t,term_t,assn_map_t) vcgen_deref(env_t env, exp_t root,
					       exp_t index, assn_map_t amin) {
  let $(t1,am1) = vcgen_rexp(env,root,amin);
  let $(t2,am2) = vcgen_rexp(env,index,am1);
  if (!env->pure_exp) {
    // checks that are generated based
    // on the value of the root and index
    let $(bnds_check,null_check) = okderef(t1,t2);
    // the following checks are real checks
    // that will be inserted by the compiler
    // if above checks couldn't be verified.
    // they are stronger asserssions which
    // should imply earlier checks
    let eopt = Tcutil::get_type_bound((type_t)root->topt);
    term_t term_numelts;
    assn_t bnds_check_sufficient;
    if (eopt == NULL) {
      // fat pointer, doesn't know bounds
      term_numelts = numelts_term(t1);
      bnds_check_sufficient = ult(t2,term_numelts);
    } else {
      term_numelts = vcgen_rexp(env,(exp_t)eopt, true_assnmap())[0];
      bnds_check_sufficient = ult(t2, term_numelts);
    }
    update_try_assnmap(env,and_assnmap_assn(am2,or(not(bnds_check_sufficient),not(null_check))),fresh_var(Absyn::exn_type()));
    // associate these checks with the expression for insert_checks
    let exp_checks = new ExpChecks{.ctxt=am2,.bounds_check=bnds_check,
                                   .null_check=null_check};
    insert_exp_checks(env->assn_info, root, exp_checks);
    // afterwards, we know both the bounds check and null check succeeded.
    am2 = and_assnmap_assn(am2,and(bnds_check,null_check));
  }
  return $(t1,t2,am2);
}

static $(term_t res, assn_map_t amout)
  vcgen_comprehension(env_t env, vardecl_t vd, exp_t e1, exp_t e2, 
                      type_t res_type, assn_map_t amin) {
  // similar to a while-loop except we evaluate e1 only once.
  let $(t1,amin) = vcgen_rexp(env,e1,amin);
  // start off with index 0
  term_t v = zero();
  amin = do_assign(env,amin,addr(vd),v);
  while (true) {
    amin = canonical_assnmap(amin);
    //fprintf(stderr,"current invariant is %s\n",assnmap2string(amin));
    let $(v2,am2) = lookup_var_map(vd,amin);
    v = v2; amin = am2;
    let amt = and_assnmap_assn(amin,ult(v,t1));
    let amf = and_assnmap_assn(amin,ulte(t1,v));
    let $(_,ambody) = vcgen_rexp(env,e2,amt);
    // increment vd
    let $(v2,am2) = lookup_var_map(vd,ambody);
    ambody = do_assign(env,am2,addr(vd),plus(v2,one(),Absyn::uint_type));
    ambody = canonical_assnmap(ambody);
    //fprintf(stderr,"after body %s\n",assnmap2string(ambody));
    let $(a1,a2,map) = unify_var_maps_subst(amin,ambody);
    //fprintf(stderr,"after unify %s || %s\n",assnmap2string(AssnMap(a1,map)),
    //        assnmap2string(AssnMap(a2,map)));
    if (implies(a2,a1)) { 
      //fprintf(stderr,"fixed point reached, returning %s\n",assnmap2string(amf));
      amin = amf; 
      break; 
    }
    amin = widen_assnmap(AssnMap(or(a1,a2),map));
    //fprintf(stderr,"no fixed point, looping with %s\n",assnmap2string(amin));
  }
  let res = fresh_var(res_type);
  // can add it in that numelts(res) == t1
  amin = and_assnmap_assn(amin,eq(numelts_term(res),t1));
  return $(res,amin);
}

static $(term_t,assn_map_t) vcgen_rexp(env_t env, exp_t e, assn_map_t amin){
  if (Tcutil::is_const_exp(e)){
     // special case for pragmas
     switch (e->r) {
     case &Absyn::Pragma_e(s):
       if (strcmp(s,"print_assn") == 0) {
         let seg_str = Position::string_of_segment(e->loc);
         fprintf(stderr,"%s: %s\n",seg_str,assnmap2string(amin));
       }
       if (strcmp(s,"print_dag") == 0) {
         let seg_str = Position::string_of_segment(e->loc);
         fprintf(stderr,"%s: %s\n",seg_str,assnmap2dag(amin));
       }
       if (strcmp(s,"all_paths") == 0) {
         env->widen_paths = false;
       }
       if (strcmp(s,"one_path") == 0) {
         env->widen_paths = true;
       }
       return $(zero(),amin);
     case &Absyn::Comprehension_e(...): 
       // comprehensions are treated as "constant" when the initializer
       // is constant, but I don't really want to allow this for now.
       // In fact, I'm wondering if we wouldn't be better off avoiding
       // this call all together...
       goto ANALYZE;
     default:  break;
     }
     let $(cn, known)= Evexp::eval_const_uint_exp(e);
     if (known) return $(uint(cn), amin);
     else return $(cnst(e),amin);
  }
 ANALYZE:
  switch (e->r) {
  case &Absyn::Const_e(c): 
  case &Absyn::Pragma_e(...):
    Warn::impos("Const_e Pragma_e are const_exps\n");
  case &Absyn::Var_e(b): 
    // a variable's r-value would be a select from
    // current memory if the var can escape, 
    // otherwise the r-value is recorded in nonescvar_map
    let vdopt = bind2vardecl(b);
    if (vdopt == NULL) return $(fresh_var(NULL),amin);
    let vd = (vardecl_t)vdopt;
    if (vd->escapes){
      let $(mem,am1) = lookup_var_map(memory,amin);
      return $(select(mem,addr(vd),vd->type),am1);
    }
    else {
      switch (Absyn::compress(vd->type)) {
	// the right value of an array it's actually the first element's address
      case &Absyn::ArrayType(_): return $(addr(vd),amin);
      default: break;
      }
      let $(t,am) = lookup_var_map(vd,amin);
      return $(t,am);
      return lookup_var_map(vd,amin);
    }
  case &Absyn::Primop_e(p,&List{e1,NULL}):
    // an expression with a unary operator
    let $(t,am) = vcgen_rexp(env,e1,amin);
    return $(unop(p,t,e->topt),am);
  case &Absyn::Primop_e(p,&List{e1,&List{e2,_}}):
    // an expression with a binary operator
    let $(t1,am1) = vcgen_rexp(env,e1,amin);
    let $(t2,am2) = vcgen_rexp(env,e2,am1);
    // if e1 is a thin, zeroterminated pointer, p is Plus, then we might
    // have an exception here...
    let e1_type = (type_t)e1->topt;
    if (!env->pure_exp && p == Absyn::Plus && 
        Tcutil::is_zeroterm_pointer_type(e1_type) && 
        !Tcutil::is_fat_pointer_type(e1_type))
      update_try_assnmap(env,am2,fresh_var(Absyn::exn_type()));
    let t = binop(p,t1,t2,e->topt);
    // if the expression has type unsigned, then we may
    // conclude t == t1%t2 u< t2;
    if (!env->pure_exp && p == Absyn::Mod && is_unsigned_int_exp(e)){
      return $(t,and_assnmap_assn(am2,ult(t,t2)));
    }
    return $(t,am2);
  case &Absyn::Primop_e(_,_): Warn::impos("vcgen: bad primop");
  case &Absyn::AssignOp_e(e1,popt,e2):
    // FIX:  for zeroterm pointers (thin or fat!), if e2 is not zero, this can fail...
    let $(t2,am1) = vcgen_rexp(env,e2,amin);
    let $(lt,am2) = vcgen_lexp(env,e1,am1);
    assn_map_t amout;
    if (popt != NULL) {
      let $(t1,am3) = deref_lterm(env,lt,am2);
      t2 = binop(popt->v,t1,t2,e->topt);
      amout = do_assign(env,am3,lt,t2);
    } else
      amout = do_assign(env,am2,lt,t2);
    return $(t2,amout);
  case &Absyn::Increment_e(e,i):
    let $(lt,am1) = vcgen_lexp(env,e,amin);
    let $(t1,am2) = deref_lterm(env,lt,am1);
    term_t res, rvalue;
    switch (i) {
    case Absyn::PostInc:
      res = t1;
      rvalue = plus(t1,one(),e->topt);
      // if e is a thin, zeroterminated pointer, then we might
      // have an exception here...
      let e_type = (type_t)e->topt;
      if (Tcutil::is_zeroterm_pointer_type(e_type) && !
          Tcutil::is_fat_pointer_type(e_type))
        update_try_assnmap(env,am2,fresh_var(Absyn::exn_type()));
      break;
    case Absyn::PreInc:
      rvalue = plus(t1,one(),e->topt);
      res = rvalue;
      // if e is a thin, zeroterminated pointer, then we might
      // have an exception here...
      let e_type = (type_t)e->topt;
      if (Tcutil::is_zeroterm_pointer_type(e_type) && !
          Tcutil::is_fat_pointer_type(e_type))
        update_try_assnmap(env,am2,fresh_var(Absyn::exn_type()));
      break;
    case Absyn::PostDec:
      res = t1;
      rvalue = minus(t1,one(),e->topt);
      break;
    case Absyn::PreDec:
      rvalue = minus(t1,one(),e->topt);
      res = rvalue;
      break;
    default:
      Warn::impos("vcgen rexp increment_e");
    }
    let amout = do_assign(env,am2,lt,rvalue);
    return $(res,amout);
  case &Absyn::Conditional_e(e1,e2,e3):
    let $(amt,amf) = vcgen_test(env,e1,amin);
    let $(t1,amt) = vcgen_rexp(env,e2,amt);
    let $(t2,amf) = vcgen_rexp(env,e3,amf);
    let v = fresh_var(e->topt);
    amt = and_assnmap_assn(amt,eq(v,t1));
    amf = and_assnmap_assn(amf,eq(v,t2));
    return $(v,may_widen(env,or_assnmap_assnmap(amt,amf)));
  case &Absyn::And_e(e1,e2):
    let $(amt,amf) = vcgen_test(env,e1,amin);
    let $(t,amt) = vcgen_rexp(env,e2,amt);
    let v = fresh_var(e->topt);
    amt = and_assnmap_assn(amt,eq(v,t));
    amf = and_assnmap_assn(amf,eq(v,zero()));
    return $(v,may_widen(env,or_assnmap_assnmap(amt,amf)));
  case &Absyn::Or_e(e1,e2):
    let $(amt,amf) = vcgen_test(env,e1,amin);
    let $(t,amf) = vcgen_rexp(env,e2,amf);
    let v = fresh_var(e->topt);
    amt = and_assnmap_assn(amt,neq(v,zero()));
    amf = and_assnmap_assn(amf,eq(v,t));
    return $(v,may_widen(env,or_assnmap_assnmap(amt,amf)));
  case &Absyn::SeqExp_e(e1,e2):
    let $(_,am1) = vcgen_rexp(env,e1,amin);
    return vcgen_rexp(env,e2,am1);
  case &Absyn::FnCall_e(e1,es,...):
    let $(f,am1) = vcgen_rexp(env,e1,amin);
    let $(ts,am2) = vcgen_rexps(env,es,am1);
    let $(pre_memory,am2) = lookup_var_map(memory,am2);

    let $(args,argvds,reqopt,ensopt,thrwsopt,ret_value) = get_requires_and_ensures(e1->topt);
    // if there is a return value, create a
    // fresh logicvar to represent it.
    term_t actual_ret = fresh_var(e->topt);
    // checking requires assertion
    if (reqopt != NULL) {
      // subst the formal args with the actual values
      let req_assn = subst_args(argvds,ret_value,ts,actual_ret,pre_memory,*reqopt);
      if (!implies(am2.assn,req_assn)) {
	Warn::err(e->loc, "current assertion:\n%s\ndoes not satisfy the pre-condition of the function:\n%s\n",
		  assnmap2string(am2), assn2string(req_assn));
      }
    }
    // after the function call, all non-escaping var's value
    // should not change, so we should keep the mapping except for
    // memory
    let new_memory = fresh_var(NULL);
    let am3 = update_var_map(memory,new_memory,am2);
    // merge this with the throws assertion from the function and 
    // update the exception handler.
    if (thrwsopt != NULL) {
      let v = fresh_var(Absyn::exn_type());
      let throws_assn = subst_args(argvds,exception_vardecl(),ts,v,new_memory,*thrwsopt);
      update_try_assnmap(env,and_assnmap_assn(am3,throws_assn),v);
    }
    // and merge this with the ensures assertion from the function
    if (ensopt != NULL) {
      let ens_assn = subst_args(argvds,ret_value,ts,actual_ret,new_memory,*ensopt);
      am3 = and_assnmap_assn(am3,ens_assn);
    }
    // if the function is marked with attribute noreturn, then the
    // post-condition is "false".
    if (Atts::is_noreturn_fn_type((type_t)e1->topt))
        am3.assn = &false_assn;
    return $(actual_ret,am3);
  case &Absyn::Throw_e(e,_):
    let $(t,am1) = vcgen_rexp(env,e,amin);
    update_try_assnmap(env,am1,t);
    return $(fresh_var(NULL),false_assnmap());
  case &Absyn::NoInstantiate_e(e): return vcgen_rexp(env,e,amin);
  case &Absyn::Instantiate_e(e,_): return vcgen_rexp(env,e,amin);
  case &Absyn::Cast_e(tp,e1,_,c): 
    // FIX: really need to put C coercions in terms...
    let $(t,am) = vcgen_rexp(env,e1,amin);
    // we only need to retain the cast on the term if it
    // changes the size of the value.  In particular, we
    // can drop a cast from an int to an unsigned int and
    // vice versa.  We might be able to get away with 
    // dropping other casts (e.g., char->int) but we'll be
    // conservative now.
    switch $(Absyn::compress(tp),Absyn::compress((type_t)e1->topt)) {
      // these two cases allow us to drop a cast of a tag_t to int/long
      // or unsigned int/unsigned long.
    case $(&Absyn::AppType(&Absyn::IntCon(_,Absyn::Int_sz),_),&Absyn::AppType(&Absyn::TagCon,tagtps)):
      return $(cnst(Absyn::valueof_exp(tagtps->hd,e1->loc)),am);
    case $(&Absyn::AppType(&Absyn::IntCon(_,Absyn::Long_sz),_),&Absyn::AppType(&Absyn::TagCon,tagtps)):
      return $(cnst(Absyn::valueof_exp(tagtps->hd,e1->loc)),am);
      //      return $(t,am);
      // this case lets us drop a cast when they are two integers and the
      // size is the same.
    case $(&Absyn::AppType(&Absyn::IntCon(u1,s1),_),&Absyn::AppType(&Absyn::IntCon(u2,s2),_)):
      //wangyl: a hack to tell compiler that long and int have the same size
      //FIX: this is machine dependent!
      s1 = (s1 == Absyn::Long_sz? Absyn::Int_sz:s1);
      s2 = (s2 == Absyn::Long_sz? Absyn::Int_sz:s2);
      if (s1 == s2) return $(t,am);
      break;
    case $(&Absyn::PointerType(p2),&Absyn::PointerType(p1)):
      let n1 = Tcutil::force_type2bool(false,p1.ptr_atts.nullable);
      let n2 = Tcutil::force_type2bool(false,p2.ptr_atts.nullable);
      let b1 = Tcutil::get_bounds_exp(Absyn::bounds_one(),p1.ptr_atts.bounds);
      let b2 = Tcutil::get_bounds_exp(Absyn::bounds_one(),p2.ptr_atts.bounds);
      switch $(b1,b2) {
      case $(&_, &_) && !env->pure_exp:  
        // Both thin pointers -- type-checker should ensure that 
        // we're casting to a smaller length so we don't have to worry about
        // that check.  Now check to see if we have to do a NULL-check.
        let null_check = neq(zero(),t);
        let exp_checks = new ExpChecks{.ctxt=am,.bounds_check=&true_assn,
                                       .null_check=null_check};
        update_try_assnmap(env,and_assnmap_assn(am,eq(t,zero())),fresh_var(Absyn::exn_type()));
        return $(t,and_assnmap_assn(am,null_check));
      case $(&_,NULL):  // cast to fat -- no failure possible
        return $(t,am);
      case $(NULL,&_) && !env->pure_exp:  
        // cast from fat -- need bounds check and possible null check
        // depending upon n2.
	let null_check = (env->pure_exp || n2) ? 
          (assn_t)&true_assn : neq(zero(),t);
	let $(b,_) = vcgen_rexp(env, (exp_t)b2, am);
	let bcheck = ulte(b,numelts_term(t));
	let exp_checks = new ExpChecks{.ctxt=am,.bounds_check=bcheck,
				       .null_check=null_check};
	let checks = and(null_check,bcheck);
        update_try_assnmap(env,and_assnmap_assn(am,not(checks)),fresh_var(Absyn::exn_type()));
        return $(t,and_assnmap_assn(am,checks));
      case $(_,_): // fat to fat -- no failure possible
        return $(t,am);
      }
    default: break;
    }
    if (env->pure_exp || c == Absyn::No_coercion) {
      return $(cast(tp,t),am);
    } else {
      // FIX:  we really need to interpret the casts appropriately.
      update_try_assnmap(env,amin,fresh_var(Absyn::exn_type())); // coercion could fail
      return $(t,am);
    }
  case &Absyn::New_e(eopt,e1,qopt):
    // IMPROVE: could assert that the resulting value is not equal to
    // the address of any variable...
    if (eopt != NULL)
      amin = vcgen_rexp(env,(exp_t)eopt,amin)[1];
    if (qopt != NULL)
      amin = vcgen_rexp(env,(exp_t)qopt,amin)[1];
    // allocation of arrays must be handled specially
    switch (e1->r) {
      // FIX?  new "string"?   -- no, that works out okay.  But we need
      // to fix char x[4] = "foo";  This should be treated the same as
      // char x[4] = {'f','o','o',0}
    case &Absyn::Array_e(dles):
      let $(_,amin) = vcgen_rexp(env,e1,amin);
      let size = uint(List::length(dles));
      let res = alloc(e,uint(List::length(dles)),e->topt);
      amin = and_assnmap_assn(amin,and(neq(res,zero()),
                                       eq(numelts_term(res),size)));
      // FIX: would like to add also that select(mem,res,i) = ith term
      // in the array.  But this could really, really blow up the assertion.
      return $(res,amin);
    case &Absyn::Comprehension_e(vd,e1,e2,_):
      let $(res,amin) = vcgen_comprehension(env,vd,e1,e2,(type_t)e->topt,amin);
      amin = and_assnmap_assn(amin,neq(res,zero()));
      return $(res,amin);
    default:
      let $(t,amin) = vcgen_rexp(env,e1,amin);
      let res =alloc(e,one(),e->topt);
      let $(mem,amin) = lookup_var_map(memory,amin);
      amin = and_assnmap_assn(amin,and(eq(select(mem,res,e1->topt),t),
                                       neq(res,zero())));
      return $(res,amin);
    }
  case &Absyn::Enum_e(...):
  case &Absyn::AnonEnum_e(...):
  case &Absyn::Sizeoftype_e(_):
  case &Absyn::Sizeofexp_e(_):
  case &Absyn::Valueof_e(_):
  case &Absyn::Offsetof_e(_,_): return $(cnst(e),amin);
  case &Absyn::AggrMember_e(e1,f,is_tagged,is_read): 
    let $(t,amin) = vcgen_rexp(env,e1,amin);
    let i = CfFlowInfo::get_field_index((type_t)e1->topt,f);
    // can throw an exception
    if (!env->pure_exp && is_tagged && is_read) {
      // FIX: have insert_checks look for tag here...
      let ck = eq(tagof_tm(t),uint(i));
      update_try_assnmap(env,and_assnmap_assn(amin,not(ck)),fresh_var(Absyn::exn_type()));
      amin = and_assnmap_assn(amin,ck);
    }
    return $(proj(t,i,e->topt),amin);
  case &Absyn::Tagcheck_e(e1,_): 
    // FIX!!!
    fallthru(e);
  case &Absyn::Address_e(e1): 
    return vcgen_lexp(env,e1,amin);
  case &Absyn::Deref_e(e1): 
    let $(t1,_,amin) = vcgen_deref(env, e1, zero_exp(), amin);
    let $(mem,amin) = lookup_var_map(memory,amin);
    return $(select(mem,t1,e->topt),amin);
  case &Absyn::AggrArrow_e(e1,f,is_tagged,is_read): 
    let $(t1,_,amin) = vcgen_deref(env, e1, zero_exp(), amin);
    let i = CfFlowInfo::get_field_index(Tcutil::pointer_elt_type((type_t)e1->topt),f);
    let $(mem,amin) = lookup_var_map(memory,amin);
    if (!env->pure_exp && is_tagged && is_read) {
      let ck = eq(tagof_tm(select(mem,t1,NULL)),
                  uint(i));
      update_try_assnmap(env,and_assnmap_assn(amin,not(ck)),fresh_var(Absyn::exn_type()));
      amin = and_assnmap_assn(amin,ck);
    }
    let elt_type = Tcutil::pointer_elt_type((type_t)e1->topt);
    return $(proj(select(mem,t1,elt_type),i,e->topt),amin);
  case &Absyn::Subscript_e(e1,e2): 
    let $(t1,t2,amin) = vcgen_deref(env, e1, e2, amin);
    let $(mem,amin) = lookup_var_map(memory,amin);
    return $(select(mem,plus(t1,t2,NULL),e->topt),amin);
  case &Absyn::Datatype_e(es,dd,df): 
    let $(ts,amin) = vcgen_rexps(env,es,amin);
    let i = datatype_constructor_index(dd,df);
    return $(datatype_aggr(i,ts,e->topt),amin);

    // FIX: at least for structs, we can use the Aggr(...) term.
  case &Absyn::CompoundLit_e(_,dles):   fallthru(dles);
  case &Absyn::Array_e(dles):           fallthru(dles);
  case &Absyn::UnresolvedMem_e(_,dles): 
    for (; dles != NULL; dles = dles->tl) {
      let &$(_,e) = dles->hd;
      amin = (vcgen_rexp(env,e,amin))[1];
    }
    return $(fresh_var(NULL),amin);
  case &Absyn::Aggregate_e(_,_,dles,_): fallthru(dles);
  case &Absyn::AnonStruct_e(_,_,dles):
    let atype = (type_t)e->topt;
    let $(is_tagged,ak,_) = get_aggr_info(atype);
    list_t<$(int,term_t)@> dlvs = NULL;
    unsigned tag = 0;
    for (; dles != NULL; dles = dles->tl) {
      let &$(dl,e) = dles->hd;
      let $(v,a) = vcgen_rexp(env,e,amin);
      amin = a;
      switch (dl) {
      case &List{&Absyn::FieldName(f),NULL}:
        let i = CfFlowInfo::get_field_index(atype,f);
        tag = i;
        dlvs = new List{new $(i,v),dlvs};        
        break;
      default: Warn::impos("no field name in designator!");
      }
    }
    dlvs = rimp_merge_sort(cmp_index,dlvs);
    let vs = map(Core::snd,dlvs);
    let res = (ak == Absyn::UnionA) ? union_aggr(tag,vs,e->topt) : 
      struct_aggr(vs,e->topt);
    return $(res,amin);
  case &Absyn::Comprehension_e(vd,e1,e2,_): 
    return vcgen_comprehension(env,vd,e1,e2,(type_t)e->topt,amin);
  case &Absyn::ComprehensionNoinit_e(e,_,_):
    return $(fresh_var(NULL),vcgen_rexp(env,e,amin)[1]);
  case &Absyn::Malloc_e(mi):
    if (mi.rgn != NULL) 
      amin = vcgen_rexp(env,(exp_t)mi.rgn,amin)[1];
    let $(t,am1) = vcgen_rexp(env,mi.num_elts,amin);
    let res = alloc(e,t,e->topt);
    let am2 = and_assnmap_assn(am1,and(neq(res,zero()),eq(numelts_term(res),t)));
    return $(res,am2);
  case &Absyn::Swap_e(e1,e2): 
    // FIX?  exceptions?  e.g., x.f :=: y.g?  
    let $(lt1,am1) = vcgen_lexp(env,e1,amin);
    let $(lt2,am2) = vcgen_lexp(env,e2,am1);
    let $(t1,am3) = deref_lterm(env,lt1,am2);
    let $(t2,am4) = deref_lterm(env,lt2,am3);
    let am5 = do_assign(env,am4,lt1,t2);
    let am6 = do_assign(env,am5,lt2,t1);
    return $(fresh_var(NULL),am6);
  case &Absyn::StmtExp_e(s):
    let old_exp_stmt = env->exp_stmt;
    env->exp_stmt = new fresh_var(NULL);
    let amout = vcgen_stmt(env,s,amin);
    let t = *(env->exp_stmt);
    env->exp_stmt = old_exp_stmt;
    return $(t,amout);
  case &Absyn::Asm_e(...): return $(fresh_var(NULL),amin);
  case &Absyn::Extension_e(e): return vcgen_rexp(env,e,amin);
  case &Absyn::Assert_e(e1):
    let old_widen_paths = env->widen_paths;
    let old_pure_exp = env->pure_exp;
    env->widen_paths = false;
    env->pure_exp = true;
    let $(amt,_) = vcgen_test(env,e1,AssnMap{&true_assn,amin.map});
    env->widen_paths = old_widen_paths;
    env->pure_exp = old_pure_exp;
    if (!implies(amin.assn,amt.assn)) 
      Warn::err(e->loc, "cannot prove @assert(%s)\nfrom\n %s",
                assnmap2string(amt), assnmap2string(amin));
    return $(one(),and_assnmap_assn(amin,amt.assn));
  case &Absyn::Assert_false_e(e1):
    let old_widen_paths = env->widen_paths;
    let old_pure_exp = env->pure_exp;
    env->widen_paths = false;
    env->pure_exp = true;
    let $(amt,_) = vcgen_test(env,e1,AssnMap{&true_assn,amin.map});
    env->widen_paths = old_widen_paths;
    env->pure_exp = old_pure_exp;
    if (implies(amin.assn,amt.assn)) 
      Warn::err(e->loc, "proved @assert_false(%s)\nfrom\n %s",
                assnmap2string(amt), assnmap2string(amin));
    return $(one(),amin);;
  }
}

static $(list_t<term_t>,assn_map_t) vcgen_rexps(env_t env, list_t<exp_t> es, assn_map_t amin){
  let result = NULL;
  for(;es != NULL; es = es->tl){
    let $(t,am) = vcgen_rexp(env,es->hd,amin);
    result = new List(t,result);
    amin = am;
  }
  return $(List::imp_rev(result),amin);
}


// generating a term that represents the address
// during the evaluation, assn_map_t might change.
static $(term_t,assn_map_t) vcgen_lexp(env_t env, exp_t e, assn_map_t amin){
  switch (e->r) {
  case &Absyn::Var_e(&Absyn::Global_b(vd)): fallthru(vd);
  case &Absyn::Var_e(&Absyn::Local_b(vd)): 
    // a regular (global/local) variable, check it's not array type
    switch (Absyn::compress(vd->type)) {
    case &Absyn::ArrayType(_): Warn::impos("array type var is not a valid l-value");
    default: return $(addr(vd),amin);
    }
  case &Absyn::Var_e(&Absyn::Param_b(vd)): fallthru(vd);
  case &Absyn::Var_e(&Absyn::Pat_b(vd)):
    // function parameters and pattern variables should not be of array type.
    // an array type will be promoted to a pointer type
    return $(addr(vd),amin);
  case &Absyn::Deref_e(e1):           
    // lexp of the form *e, first evaluate r-value of e,
    // lvalue of *e is rvalue(e) + 0;
    // let $(t,am1) = vcgen_rexp(env,e1,amin);
    let $(t1,t2,am1) = vcgen_deref(env,e1,zero_exp(),amin);
    return $(t1,am1);
  case &Absyn::Subscript_e(e1,e2): 
    // let $(t1,am1) = vcgen_rexp(env,e1,amin);
    // let $(t2,am2) = vcgen_rexp(env,e2,am1);
    let $(t1,t2,am1) = vcgen_deref(env,e1,e2,amin);
    return $(offseti(t2,t1,e->topt),am1);
  case &Absyn::AggrArrow_e(e1,f,...):
    // let $(t1,am1) = vcgen_rexp(env,e1,amin);
    let $(t1,t2,am1) = vcgen_deref(env,e1,zero_exp(),amin);
    let i = CfFlowInfo::get_field_index(Tcutil::pointer_elt_type((type_t)e1->topt),f);
    return $(offsetf(t1,i,e->topt),am1);
  case &Absyn::AggrMember_e(e1,f,...):
    let $(t1,am1) = vcgen_lexp(env,e1,amin);
    let i = CfFlowInfo::get_field_index((type_t)e1->topt,f);
    return $(offsetf(t1,i,e->topt),am1);
  case &Absyn::Instantiate_e(e1,...):fallthru(e1);
  case &Absyn::NoInstantiate_e(e1):  
    return vcgen_lexp(env,e1,amin);
  default: return $(fresh_var(e->topt),amin);
  }
}

// determine whether a comparing these two expressions is an 
// unsigned or a signed comparison.
static bool unsigned_comparison(exp_t e1, exp_t e2) {
  let t1 = Absyn::compress((type_t)e1->topt);
  let t2 = Absyn::compress((type_t)e2->topt);
  switch $(t1,t2) {
  case $(&Absyn::AppType(&Absyn::IntCon(Absyn::Unsigned,_),_),_): return true;
  case $(_,&Absyn::AppType(&Absyn::IntCon(Absyn::Unsigned,_),_)): return true;
  case $(&Absyn::PointerType(_),&Absyn::PointerType(_)): return true;
  default: return false;
  }
}

#define sgte(t1,t2) (slte(t2,t1))
#define ugte(t1,t2) (ulte(t2,t1))
#define sgt(t1,t2) (slt(t2,t1))
#define ugt(t1,t2) (ult(t2,t1))


// generating assnmap for when e evaluates to true and when e evalutes to false
static $(assn_map_t,assn_map_t) vcgen_test(env_t env, exp_t e, assn_map_t ain){
    switch (e->r) {
  case &Absyn::Conditional_e(e1,e2,e3):
    let $(a1t,a1f) = vcgen_test(env,e1,ain);
    let $(a2t,a2f) = vcgen_test(env,e2,a1t);
    let $(a3t,a3f) = vcgen_test(env,e3,a1f);
    return $(may_widen(env,or_assnmap_assnmap(a2t,a3t)),
	     may_widen(env,or_assnmap_assnmap(a2f,a3f)));
  case &Absyn::And_e(e1,e2):
    let $(a1t,a1f) = vcgen_test(env,e1,ain);
    let $(a2t,a2f) = vcgen_test(env,e2,a1t);
    return $(a2t, may_widen(env,or_assnmap_assnmap(a1f,a2f)));
  case &Absyn::Or_e(e1,e2):
    let $(a1t,a1f) = vcgen_test(env,e1,ain);
    let $(a2t,a2f) = vcgen_test(env,e2,a1f);
    return $(may_widen(env,or_assnmap_assnmap(a1t,a2t)),a2f);
  case &Absyn::SeqExp_e(e1,e2):
    let $(_,ain) = vcgen_rexp(env,e1,ain);
    return vcgen_test(env,e2,ain);
  case &Absyn::Primop_e(Absyn::Not,&List(e1,_)):
    let $(at,af) = vcgen_test(env,e1,ain);
    return $(af,at);
  case &Absyn::Primop_e(p,&List(e1,&List(e2,NULL))):
    let $(t1,a1) = vcgen_rexp(env,e1,ain);
    let $(t2,a2) = vcgen_rexp(env,e2,a1);
    let at = a2;
    let af = a2;
    switch p {
    case Absyn::Eq:  
      at = and_assnmap_assn(at,eq(t1,t2)); af = and_assnmap_assn(af,neq(t1,t2)); 
      break;
    case Absyn::Neq: 
      at = and_assnmap_assn(at,neq(t1,t2)); af = and_assnmap_assn(af,eq(t1,t2)); break;
    case Absyn::Lt:
      if (unsigned_comparison(e1,e2)) {
        at = and_assnmap_assn(at,ult(t1,t2));  af = and_assnmap_assn(af,ugte(t1,t2)); 
      } else {
        at = and_assnmap_assn(at,slt(t1,t2));  af = and_assnmap_assn(af,sgte(t1,t2)); 
      }
      break;
    case Absyn::Lte: 
      if (unsigned_comparison(e1,e2)) {
        at = and_assnmap_assn(at,ulte(t1,t2)); af = and_assnmap_assn(af,ugt(t1,t2)); 
      } else {
        at = and_assnmap_assn(at,slte(t1,t2)); af = and_assnmap_assn(af,sgt(t1,t2)); 
      }
      break;
    case Absyn::Gt:  
      if (unsigned_comparison(e1,e2)) {
        at = and_assnmap_assn(at,ugt(t1,t2));  af = and_assnmap_assn(af,ulte(t1,t2)); 
      } else {
        at = and_assnmap_assn(at,sgt(t1,t2));  af = and_assnmap_assn(af,slte(t1,t2)); 
      }
      break;
    case Absyn::Gte: 
      if (unsigned_comparison(e1,e2)) {
        at = and_assnmap_assn(at,ugte(t1,t2)); af = and_assnmap_assn(af,ult(t1,t2)); 
      } else {
        at = and_assnmap_assn(at,sgte(t1,t2)); af = and_assnmap_assn(af,slt(t1,t2)); 
      }
      break;
    default: 
      // FIX:  treat as if p(e1,e2) != 0 
      // FIX:  p could be + and e1 could be a thin, zero-terminated pointer which throws an
      // exception. 
      break;
    }
    return $(at,af);
  default:
    let $(t,aout) = vcgen_rexp(env,e,ain);
    switch (t) {
    case &Uint(0,_): // conditional is always false
      return $(and_assnmap_assn(aout,&false_assn),aout);
    case &Uint(_,_): // conditional is always true
      return $(aout,and_assnmap_assn(aout,&false_assn));
    default:
      return $(and_assnmap_assn(aout,ugte(t,one())),and_assnmap_assn(aout,eq(t,zero())));
    }
  }
}


static void update_return(env_t env, term_opt_t t, assn_map_t a, type_opt_t tp) {
  // there is no ensures clause, nothing needs to be done with the return
  if (env->res_assnmap == NULL) return;
}

static exp_opt_t find_assert_e(stmt_t s) {
  while (true) {
    switch (s->r) {
    case &Absyn::Exp_s(&Absyn::Exp{.r = &Absyn::Assert_e(e),...}): return e;
    case &Absyn::Seq_s(sa,_): s = sa; continue;
    default: return NULL;
    }
  }
}

// To simplify things, I'm treating the control-flow as if it were
// structured.  Upon reaching a labelled statement, I set the pre-
// condition to "True" which is conservative, unless there's an 
// explicit invariant associated with the label.   This lets me do
// local iteration for loops and so forth to generate invariants,
// since the only back-edges in the simplified graph are always
// part of the control constructs, or have an explicit invariant
// associated with them.  
static assn_map_t vcgen_stmt(env_t env, stmt_t s, assn_map_t amin) {
 LOOP:
  let oldam = lookup_stmt_assnmap(env,s);
  amin = or_assnmap_assnmap(oldam,amin);
  switch (s->r) {
  case &Absyn::Skip_s: return amin;
  case &Absyn::Exp_s(e): 
    let $(t,amout) = vcgen_rexp(env,e,amin);
    if (env->exp_stmt != NULL) 
      *(env->exp_stmt) = t;
    return amout;
  case &Absyn::Seq_s(s1,s2): 
    amin = vcgen_stmt(env,s1,amin);
    s = s2;
    goto LOOP;
  case &Absyn::Return_s(e as &_): 
    let $(t,amout) = vcgen_rexp(env,(exp_t)e,amin);
    update_return(env,t,amout,e->topt);
    fallthru;
  case &Absyn::Return_s(NULL): 
    // if there is no return value, there is no ensures clause
    // FIX?  what if we fall off a (bits-only) function?
    return false_assnmap();
  case &Absyn::IfThenElse_s(e1,s1,s2):
    let $(amt,amf) = vcgen_test(env,e1,amin);
    amt = vcgen_stmt(env,s1,amt);
    amf = vcgen_stmt(env,s2,amf);
    return may_widen(env,or_assnmap_assnmap(amt,amf));
  case &Absyn::While_s($(e,dummy),s1): 
    assn_map_opt_t old_continue_assnmap = env->continue_assnmap;
    env->continue_assnmap = new false_assnmap();
    exp_opt_t loop_inv_exp = NULL;
    assn_map_t loop_inv_assnmap;
    switch (e->r) {
    case &Absyn::And_e(eleft, eright):
      switch (eleft->r){
      case &Absyn::Assert_e(eassn):
	loop_inv_exp = eassn;
	e = eright;
	break;
      default:
	break;
      }
      break;
    default:
      break;
    }
    if (loop_inv_exp != NULL) {
      let old_widen_paths = env->widen_paths;
      env->widen_paths = false;
      loop_inv_assnmap = vcgen_test(env,(exp_t)loop_inv_exp, AssnMap{&true_assn,amin.map})[0];
      env->widen_paths = old_widen_paths;
    }
    else 
      loop_inv_assnmap = AssnMap(&true_assn,amin.map);
    if (!implies(amin.assn,loop_inv_assnmap.assn)) {
      Warn::err(e->loc, "cannot prove loop invariant %s from %s\n",
		assnmap2string(loop_inv_assnmap),assnmap2string(amin));
      env->continue_assnmap = old_continue_assnmap;
      return true_assnmap();
    }
    amin = canonical_assnmap(amin);
    while (true) {
      // merge(and widen) incoming flow with existing info on the loop
      let amold = lookup_stmt_assnmap(env,dummy);
      amin = widen_assnmap(or_assnmap_assnmap(amold,amin));
      replace_stmt_assnmap(env,dummy,amin);
      if (loop_inv_exp != NULL) {
	amin = vcgen_test(env,(exp_t)loop_inv_exp,amin)[0];
      }
      let $(amt,amf) = vcgen_test(env,e,amin);
      amin = vcgen_stmt(env,s1,amt);
      // merging in flow from continue statement
      amin = or_assnmap_assnmap(amin,*env->continue_assnmap);
      if (loop_inv_exp != NULL) {
	let old_widen_paths = env->widen_paths;
	env->widen_paths = false;
	loop_inv_assnmap = vcgen_test(env,(exp_t)loop_inv_exp, AssnMap{&true_assn,amin.map})[0];
	env->widen_paths = old_widen_paths;
      }
      else 
	loop_inv_assnmap = AssnMap(&true_assn,amin.map);
      if (!implies(amin.assn,loop_inv_assnmap.assn)) {
	Warn::err(e->loc, "cannot prove loop invariant %s from %s\n",
		  assnmap2string(loop_inv_assnmap),assnmap2string(amin));
	env->continue_assnmap = old_continue_assnmap;
	return true_assnmap();
      }
      amin = canonical_assnmap(amin);
//       fprintf(stderr,"amold = %s\n",assnmap2string(lookup_stmt_assnmap(env,dummy)));
//       fprintf(stderr,"amnow = %s\n",assnmap2string(amin));
      let $(a1,a2,map) = unify_var_maps_subst(lookup_stmt_assnmap(env,dummy),amin);
//       fprintf(stderr,"a1 = %s\n",assn2string(a1));
//       fprintf(stderr,"a2 = %s\n",assn2string(a2));
//       fprintf(stderr,"%s\n",map2string(map));
//       int i;
//       scanf("%d",&i);
      amin = AssnMap(a2,map);
      if (implies(a2,a1)) {
	env->continue_assnmap = old_continue_assnmap;
	return amf;
      }
    }
    
  case &Absyn::Continue_s: 
    *env->continue_assnmap = or_assnmap_assnmap(*env->continue_assnmap,amin);
    return false_assnmap();
  case &Absyn::Break_s:
    let dest = Hashtable::lookup(env->succ_table,s);
    if (dest == NULL) 
      update_return(env,NULL,amin,NULL);
    else 
      update_stmt_assnmap(env, (stmt_t)dest, amin);
    return false_assnmap();
  case &Absyn::For_s(e1,$(e2,dummy2),$(e3,dummy3),s1):
    assn_map_opt_t old_continue_assnmap = env->continue_assnmap;
    env->continue_assnmap = new false_assnmap();
    exp_opt_t loop_inv_exp = NULL;
    assn_map_t loop_inv_assnmap;
    switch (e2->r) {
    case &Absyn::And_e(eleft, eright):
      switch (eleft->r){
      case &Absyn::Assert_e(eassn):
	loop_inv_exp = eassn;
	e2 = eright;
	break;
      default:
	break;
      }
      break;
    default:
      break;
    }
    // the initialization
    let $(_,amin) = vcgen_rexp(env,e1,amin);
    if (loop_inv_exp != NULL) {
      let old_widen_paths = env->widen_paths;
      env->widen_paths = false;
      loop_inv_assnmap = vcgen_test(env,(exp_t)loop_inv_exp, AssnMap{&true_assn,amin.map})[0];
      env->widen_paths = old_widen_paths;
    }
    else 
      loop_inv_assnmap = AssnMap(&true_assn,amin.map);
    if (!implies(amin.assn,loop_inv_assnmap.assn)) {
      Warn::err(e2->loc, "cannot prove loop invariant %s from %s\n",
		assnmap2string(loop_inv_assnmap),assnmap2string(amin));
      env->continue_assnmap = old_continue_assnmap;
      return true_assnmap();
    }
    amin = canonical_assnmap(amin);
    while (true) {
      // merge(and widen) incoming flow with existing info on the loop
      let amold = lookup_stmt_assnmap(env,dummy2);
      amin = widen_assnmap(or_assnmap_assnmap(amin,amold));
      replace_stmt_assnmap(env,dummy2,amin);
      if (loop_inv_exp != NULL) {
	amin = vcgen_test(env,(exp_t)loop_inv_exp,amin)[0];
      }
      let $(amt,amf) = vcgen_test(env,e2,amin);
      
      amin = vcgen_stmt(env,s1,amt);
      let $(_,am) = vcgen_rexp(env,e3,amin);
      amin = am;
      if (loop_inv_exp != NULL) {
	let old_widen_paths = env->widen_paths;
	env->widen_paths = false;
	loop_inv_assnmap = vcgen_test(env,(exp_t)loop_inv_exp, AssnMap{&true_assn,amin.map})[0];
	env->widen_paths = old_widen_paths;
      }
      else 
	loop_inv_assnmap = AssnMap(&true_assn,amin.map);
      if (!implies(amin.assn,loop_inv_assnmap.assn)) {
	Warn::err(e2->loc, "cannot prove loop invariant %s from %s\n",
		  assnmap2string(loop_inv_assnmap),assnmap2string(amin));
	env->continue_assnmap = old_continue_assnmap;
	return true_assnmap();
      }
      amin = canonical_assnmap(amin);
      let $(a1,a2,map) = unify_var_maps_subst(lookup_stmt_assnmap(env,dummy2),amin);
//       fprintf(stderr,"a1 = %s\n",assn2string(a1));
//       fprintf(stderr,"a2 = %s\n",assn2string(a2));
//       fprintf(stderr,"map = %s\n",map2string(map));
      amin = AssnMap(a2,map);
      if (implies(a2,a1)) {
	env->continue_assnmap = old_continue_assnmap;
	return amf;
      }
    }
  case &Absyn::Do_s(s1,$(e,dummy)):
    assn_map_opt_t old_continue_assnmap = env->continue_assnmap;
    env->continue_assnmap = new false_assnmap();
    amin = vcgen_stmt(env,s1,amin);
    exp_opt_t loop_inv_exp = NULL;
    assn_map_t loop_inv_assnmap;
    switch (e->r) {
    case &Absyn::And_e(eleft, eright):
      switch (eleft->r){
      case &Absyn::Assert_e(eassn):
	loop_inv_exp = eassn;
	e = eright;
	break;
      default:
	break;
      }
      break;
    default:
      break;
    }
    if (loop_inv_exp != NULL) {
      let old_widen_paths = env->widen_paths;
      env->widen_paths = false;
      loop_inv_assnmap = vcgen_test(env,(exp_t)loop_inv_exp, AssnMap{&true_assn,amin.map})[0];
      env->widen_paths = old_widen_paths;
    }
    else 
      loop_inv_assnmap = AssnMap(&true_assn,amin.map);
    if (!implies(amin.assn,loop_inv_assnmap.assn)) {
      Warn::err(e->loc, "cannot prove loop invariant %s from %s\n",
		assnmap2string(loop_inv_assnmap),assnmap2string(amin));
      env->continue_assnmap = old_continue_assnmap;
      return true_assnmap();
    }
    amin = canonical_assnmap(amin);
    while (true) {
      // merge(and widen) incoming flow with existing info on the loop
      let amold = lookup_stmt_assnmap(env,dummy);
      amin = widen_assnmap(or_assnmap_assnmap(amold,amin));
      replace_stmt_assnmap(env,dummy,amin);
      if (loop_inv_exp != NULL) {
	amin = vcgen_test(env,(exp_t)loop_inv_exp,amin)[0];
      }
      let $(amt,amf) = vcgen_test(env,e,amin);
      amin = vcgen_stmt(env,s1,amt);
      // merging in flow from continue statement
      amin = or_assnmap_assnmap(amin,*env->continue_assnmap);
      if (loop_inv_exp != NULL) {
	let old_widen_paths = env->widen_paths;
	env->widen_paths = false;
	loop_inv_assnmap = vcgen_test(env,(exp_t)loop_inv_exp, AssnMap{&true_assn,amin.map})[0];
	env->widen_paths = old_widen_paths;
      }
      else 
	loop_inv_assnmap = AssnMap(&true_assn,amin.map);
      if (!implies(amin.assn,loop_inv_assnmap.assn)) {
	Warn::err(e->loc, "cannot prove loop invariant %s from %s\n",
		  assnmap2string(loop_inv_assnmap),assnmap2string(amin));
	env->continue_assnmap = old_continue_assnmap;
	return true_assnmap();
      }
      amin = canonical_assnmap(amin);
//       fprintf(stderr,"amin = %s\n",assnmap2string(amin));
//       fprintf(stderr,"amold = %s\n",assnmap2string(lookup_stmt_assnmap(env,dummy)));
      let $(a1,a2,map) = unify_var_maps_subst(lookup_stmt_assnmap(env,dummy),amin);
//       fprintf(stderr,"a1 = %s\n",assn2string(a1));
//       fprintf(stderr,"a2 = %s\n",assn2string(a2));
//       fprintf(stderr,"map = %s\n",map2string(map));
      amin = AssnMap(a2,map);
      if (implies(a2,a1)) {
	env->continue_assnmap = old_continue_assnmap;
	return amf;
      }
    }
  case &Absyn::Switch_s(e,scs,dtree):
    let $(t,am) = vcgen_rexp(env,e,amin);
    return vcgen_switch(env,t,scs,am);
  case &Absyn::Fallthru_s(_,NULL): Warn::impos("vcgen fallthru");
  case &Absyn::Fallthru_s(es,&dest):
    // Also a forward jump so we can do an or.
    let $(ts,am) = vcgen_rexps(env,es,amin);
    if (ts != NULL){
      //pat_vars has a bunch of nulls before meaning full pat vars;
      let x = Tcutil::filter_nulls(List::split(dest->pat_vars->v)[0]);
      // initialize the pattern variables with their corresponding terms
      for (; x != NULL; x = x->tl,ts = ts->tl) {
	let vd = x->hd;
	if (vd != NULL) 
	  am = do_assign(env,am,addr(vd),ts->hd);
      }
    }
    update_stmt_assnmap(env, dest->body, am);
    return false_assnmap();
  case &Absyn::Decl_s(d,s1):
    amin = vcgen_local_decl(env,d,amin);
    s = s1;
    goto LOOP;
  case &Absyn::Label_s(_,s1): 
    // check to see if s1 is an assertion -- if so, use it as the
    // assumption.  When we do a goto, we'll also look to see if
    // the target label has an assertion and check the implication.
    exp_opt_t label_assn_opt = find_assert_e(s1);
    if (label_assn_opt == NULL) {
      // by making the assertion True here, we're effectively losing
      // all information when we do a goto.  This is conservative, 
      // and means that I don't have to worry about non-structured
      // control-flow.
      amin = true_assnmap();
    } else {
      // need to compute the assertion with the current map
      let $(amt,_) = vcgen_test(env,(exp_t)label_assn_opt,AssnMap{&true_assn,amin.map});
      if (!implies(amin.assn,amt.assn))
	Warn::err(s->loc, "can not prove @assert(%s) \n from %s",
		  assnmap2string(amin),assnmap2string(amt));
      // now we've done verifying that the assertion is satisfied by
      // incoming flow, we want to generate a fresh new map for
      // the following analysis
      let $(amt,_) = vcgen_test(env,(exp_t)label_assn_opt,true_assnmap());
      amin = amt;
    }
    s = s1;
    goto LOOP;
  case &Absyn::Goto_s(_): 
    // if the target label has an @assert associated with it,
    // then check that we imply the assertion.
    let destopt = Hashtable::lookup(env->succ_table,s);
    if (destopt != NULL) {
      switch (destopt->r) {
      case &Absyn::Label_s(_,s1):
        exp_opt_t label_assn_opt = find_assert_e(s1);
        if (label_assn_opt == NULL) break;
        exp_t label_assn = (exp_t)label_assn_opt;
        let $(amt,_) = vcgen_test(env,label_assn,AssnMap{&true_assn,amin.map});
        if (!implies(amin.assn,amt.assn))
          Warn::err(s->loc, "cannot prove @assert(%s)\nfrom %s",
                    assnmap2string(amt), assnmap2string(amin));
        break;
      default: Warn::impos("vcgen goto");
      }
    }
    return false_assnmap(); // see above
  case &Absyn::TryCatch_s(s,scs,dtree):
    let old_try_assnmap = env->try_assnmap;
    // install new try/catch-handler assertion
    env->try_assnmap = new (false_assnmap());
    // run vcgen on the body -- this will update the env->shared->try_assn 
    // with assertions of any state that might throw an exn.
    let am1 = vcgen_stmt(env,s,amin);
    // restore the old handler's assertion.
    let new_try_assnmap = *env->try_assnmap;
    env->try_assnmap = old_try_assnmap;
    // analyze the catch handlers and merge with the body to get
    // the final output.
    let $(exc,am2) = lookup_var_map(exception_vardecl(),am1);
    let am3 = vcgen_switch(env,exc,scs,new_try_assnmap);
    return may_widen(env,or_assnmap_assnmap(am1,am2));
  }
}

static $(assn_map_t,assn_map_t) vcgen_pat(env_t env, Absyn::pat_t p, 
					  term_opt_t lvalue, term_t v, assn_map_t amin){
  switch (p->r) {
  case &Absyn::Wild_p:  // _
    return $(amin,false_assnmap());
  case &Absyn::Var_p(vd,p2): // x as p2
    let $(amt,amf) = vcgen_pat(env,p2,lvalue,v,amin);
    return $(do_assign(env,amt,addr(vd),v),amf);
  case &Absyn::AliasVar_p(tv,vd):
    return $(do_assign(env,amin,addr(vd),v),false_assnmap());
  case &Absyn::Reference_p(vd,p2):
    let $(amt,amf) = vcgen_pat(env,p2,lvalue,v,amin);
    if (lvalue == NULL) Warn::impos("vcgen reference pattern matching");
    return $(do_assign(env,amt,addr(vd),(term_t)lvalue),amf);
  case &Absyn::TagInt_p(_,vd):
    return $(do_assign(env,amin,addr(vd),v),false_assnmap());
  case &Absyn::Null_p:
    let t = zero();
    return $(and_assnmap_assn(amin,eq(v,t)),and_assnmap_assn(amin,neq(v,t)));
  case &Absyn::Int_p(s,i):
    let t = uint(i);
    return $(and_assnmap_assn(amin,eq(v,t)),and_assnmap_assn(amin,neq(v,t)));
  case &Absyn::Char_p(c):
    let t = uint(c);
    return $(and_assnmap_assn(amin,eq(v,t)),and_assnmap_assn(amin,neq(v,t)));
  case &Absyn::Float_p(f,i): 
    let e = Absyn::float_exp(f,i,0);
    e->topt = Absyn::gen_float_type(i);
    let t = cnst(e);
    return $(and_assnmap_assn(amin,eq(v,t)),and_assnmap_assn(amin,neq(v,t)));
  case &Absyn::Enum_p(ed,ef):
    let e = Absyn::new_exp(new Absyn::Enum_e(ed,ef),0);
    e->topt = p->topt;
    let t = cnst(e);
    return $(and_assnmap_assn(amin,eq(v,t)),and_assnmap_assn(amin,neq(v,t)));
  case &Absyn::AnonEnum_p(type,ef):
    let e = Absyn::new_exp(new Absyn::AnonEnum_e(type,ef),0);
    e->topt = p->topt;
    let t = cnst(e);
    return $(and_assnmap_assn(amin,eq(v,t)),and_assnmap_assn(amin,neq(v,t)));
  case &Absyn::Pointer_p(p2):
    // the value to be matched with p2 is the content of location v
    let $(mem,amin) = lookup_var_map(memory,amin);
    let v2 = select(mem,v,p->topt);
    let $(amt,amf) = vcgen_pat(env,p2,v,v2,amin);
    // the false branch could be that v is not a pointer
    return $(and_assnmap_assn(amt,neq(zero(),v)),or_assnmap_assn(amf,eq(zero(),v)));
  case &Absyn::Aggr_p(topt,_,_,dlps,_):
    type_t type = (type_t)topt;
    let $(is_tagged,_,fields) = get_aggr_info(type);
    assn_map_t amt = amin;
    assn_map_t amf = false_assnmap();
    for (; dlps != NULL; dlps = dlps->tl) {
      let tup = dlps->hd;
      let p2 = tup->f1;
      if (p2->r == &Absyn::Wild_p_val) continue;
      let f = Absyn::designatorlist_to_fieldname(tup->f0);
      let i = CfFlowInfo::get_field_index(type,f);
      if (is_tagged) {
        // for tagged unions, we pretend the tag is an extra member
        // at the end of the aggregate.
        let tag_check = eq(tagof_tm(v),uint(i));
        amt = and_assnmap_assn(amt,tag_check);
        amf = or_assnmap_assn(amf,not(tag_check));
      }
      let member = proj(v,i,p2->topt);
      let path = NULL;
      if (lvalue != NULL) 
	path = offsetf(lvalue,i,NULL);
      let $(amt2,amf2) = vcgen_pat(env,p2,path,member,amt);
      amf = may_widen(env,or_assnmap_assnmap(amf,amf2));
      amt = amt2;
    }
    return $(amt,amf);
  case &Absyn::Datatype_p(dd,df,ps,_):
    // for datatypes, we pretend we have an aggregate with the first
    // field being an integer corresponding to the constructor.
    int i = datatype_constructor_index(dd,df);
    assn_t tag_check = eq(tagof_tm(v),uint(i));
    assn_map_t amt = and_assnmap_assn(amin,tag_check);
    assn_map_t amf = false_assnmap();
    for (unsigned j = 0; ps != NULL; ps=ps->tl, ++j) {
      let p2 = ps->hd;
      let member = proj(v,j,p2->topt);
      let path = NULL;
      if (lvalue != NULL) {
	path = offsetf(lvalue,j,NULL);
      }
      let $(amt2,amf2) = vcgen_pat(env,p2,path,member,amt);
      amf = may_widen(env,or_assnmap_assnmap(amf,amf2));
      amt = amt2;
    }
    amf = or_assnmap_assn(amf,not(tag_check));
    return $(amt,amf);
  case &Absyn::UnknownId_p(_):
  case &Absyn::UnknownCall_p(...):
  case &Absyn::Exp_p(_): Warn::impos("vcgen pat found bad pattern");
  }
}

static assn_map_t vcgen_switch(env_t env, term_t v, 
                           list_t<switch_clause_t> scs, assn_map_t amin) {
  // note that all of the clauses should explicitly jump (via break)
  // or something else outside of the clause so the result should always
  // be false...
  assn_map_t res = false_assnmap();
  for (; scs != NULL; scs = scs->tl) {
    let sc = scs->hd;
    let $(amt,amf) = vcgen_pat(env,sc->pattern,NULL,v,amin);
    if (sc->where_clause != NULL) {
      let $(amt2,amf2) = vcgen_test(env, (exp_t)sc->where_clause, amt);
      amt = amt2;
      amf = may_widen(env,or_assnmap_assnmap(amf,amf2));
    }
    res = may_widen(env,or_assnmap_assnmap(res,vcgen_stmt(env,sc->body,amt)));
    if (!env->widen_paths)
      amin = amf;
  }
  return res;
}


assn_map_t clause2assn(exp_t e){
  let env = bogus_env();
  let am = update_var_map(memory,fresh_var(NULL),true_assnmap());
  let res =  vcgen_test(env,e,am).f0;
  return res;
}

void vcgen_fundecl(Position::seg_t loc, JumpAnalysis::jump_anal_res_t tables, Absyn::fndecl_t fd, assn_info_t assn_info){
  let $(args,arvds,reqopt,ensopt,thrwsopt,ret_value) = get_requires_and_ensures_info(&fd->i);
  assn_map_t am = true_assnmap();
  // put in the requires clause as an assumption.
  if (reqopt != NULL) {
    am = *reqopt;
  }
  // if we have a throws clause, then pretend like we're installing
  // a "fake" exception handler so we can check to see if the function
  // throws.
  assn_map_t *thrws_assn = NULL;
  if (thrwsopt != NULL) {
    thrws_assn = new false_assnmap();
  }
  assn_map_t *result_assn = (ensopt == NULL) ? NULL : new false_assnmap();
  term_opt_t res_term = NULL;
  if (ensopt != NULL && ret_value != NULL) {
    let $(t,_) = lookup_var_map(ret_value,*ensopt);
    res_term = t;
  }
  let env = initial_env(tables,fd,assn_info,result_assn,thrws_assn,res_term);
  vcgen_stmt(env,fd->body,am);
  // check the ensures clause
  if (ensopt != NULL) {
    if (env->res_assnmap == NULL) Warn::impos("vcgen checking ensures");
    if (!implies(env->res_assnmap->assn,ensopt->assn))
      Warn::err(loc, "cannot prove the @ensures clause %s from %s",
		assnmap2string(*ensopt),
		assnmap2string(*env->res_assnmap));
  }
  // check the throws clause
  if (thrwsopt != NULL) {
    if (!implies(env->try_assnmap->assn,thrwsopt->assn))
      Warn::err(loc, "cannot prove the @throws clause %s from %s",
                assnmap2string(*thrwsopt),
                assnmap2string(*env->try_assnmap));
  }
}

