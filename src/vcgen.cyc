/* Computing Strongest Post-conditions
   Copyright (C) 2003 Greg Morrisett
   This file is part of the Cyclone compiler.

   The Cyclone compiler is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   The Cyclone compiler is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with the Cyclone compiler; see the file COPYING. If not,
   write to the Free Software Foundation, Inc., 59 Temple Place -
   Suite 330, Boston, MA 02111-1307, USA. */

/* What we are doing here is computing a pre/post-condition in a forwards
   fashion for each statement and expression within a function.  The 
   assertion language is very simple: equality and inequality over
   terms, disjunction, and conjunction (no quantifiers).  The terms
   include what we consider to be "constant" expressions in Cyclone,
   primops of terms, program variables, and logical variables.  

   There's an extremely simple, essentially syntactic prover that is
   used to show implications.  There's also an extremely simple strategy
   for generating loop invariants.  The trickyness is in ensuring
   that the iterative analysis terminates.  In essence, each time
   around a loop, we're guaranteeing that we get a smaller (in terms
   of total node count) assertion.  The worst case is we fall back to "true".

   To keep the analysis simple and somewhat structured, we essentially
   punt on goto's.  More properly, whenever we hit a labelled statement,
   we reset the incoming pre-condition to "true".  This allows me to
   do purely local iteration for calculating the assertions.  To handle
   other non-local edges (e.g., break, continue, throw) we essentially
   pile up assertions on the statement and OR them in with the natural
   flow's pre-condition.  

   Also to keep the analysis simple, we punt on alias analysis.  Variables 
   have a flag indicating whether or not they escape syntactically.
   When updating an escaping variable, we essentially "kill" all 
   escaping variables.  The same happens for a function call.  This is
   *not* thread-safe.  To achieve that, we would have to kill all escaping
   things after each step. 

   We use hash-consing to try to get maximal sharing among 
   assertion nodes.  Maintaining sharing is crucial for avoiding
   an exponential space blow up.  I've experimented with lazy
   substitution as well, but this didn't seem to work that well.

   There are a lot of ways we should improve this analysis and a few
   things that need to be fixed:

   * We need to extend terms to account for casts/coercions.
   * We need to make a distinction between signed and unsigned comparisons.
   * We need to replace the relations stuff in the type-checker (e.g.,
     subtyping) with calls to manipulate the @requires/@ensures stuff
     in here.
   * We need to have a "throttle" for controlling assertion size.  Sooner
     or later we will run into iterated if's/diamond control-flow patterns
     that will result in a zillion disjunctions.  Although we share the
     resulting assertions, the theorem prover needs some way to avoid
     crawling over the assertion as if it's a tree.

   * We should use the Pratt constraint solver where possible.
   * We should take pattern matching tests into account for a switch.
   * We shouldn't kill unique variables.
   * We should only kill "type-compatible" expressions on an update.
     For instance, we don't need to kill pointer variables if we're
     assigning an integer value.  Note that if we had terms like
     *t or t.f or t->f or t1[t2] then we'd have to kill any of those
     though...
   * We should make the simple thm. prover a bit smarter.
   * We should perhaps try to simplify the assertions to remove
     redundancies?
   * We should add support for more predicates and relations (e.g.,
     track whether x == null, or tagcheck(x.f), or datatype tags, etc.)?
   * Could have user-defined predicates...
   * If we knew that a goto was forward, then we could deal with it...
   */
#include "vcgen.h"
#include "absynpp.h"
#include "tcutil.h"
#include "attributes.h"
#include "evexp.h"
#include "assndef.h"
#include "pratt_prover.h"
#include "warn.h"
#include <hashtable.h>
#include <dict.h>
#include <string.h> 
#include <cycboot.h> 


//#define VCGEN_DEBUG

namespace Vcgen;
using List;
using AssnDef;
using PrattProver;

////// Forward Declaration for Environments /////
struct Env;
typedef struct Env @env_t;
// returns true if a2 is provable from a1 (i.e., a1 |- a2)
// tries simple_prove first and then tries the constraint solver
static bool implies_noreduce(assn_t a1, assn_t a2) {
  return simple_prove(a1,a2) || constraint_prove(a1,a2);
}

// same as above but as a side effect, reduces the caller's
// assertions.
static bool implies(assn_t @a1, assn_t @a2) {
  *a1 = reduce(*a1);
  *a2 = reduce(*a2);
  return implies_noreduce(*a1,*a2);
}

////////// Widening for Assertions ////////////////////

// We want to find an assertion a' such that ctxt => a' and a => a'.
// (so or(ctxt,a) => a'.)  In addition, we want a' to have size less
// than or equal to a.  
static assn_t weaken_it(assn_t ctxt, assn_t a) {
  if (simple_prove(ctxt,a)) return a;
  assn_t res;
  switch (a) {
  case &And(a1,a2):
    let b1 = weaken_it(ctxt,a1);            // IH: ctxt=>b1 & a1=>b1
    let b2 = weaken_it(ctxt,a2);            // IH: ctxt=>b2 & a2=>b2
    //if (implies_noreduce(b1,b2)) return b1;
    //if (implies_noreduce(b2,b1)) return b2;
    res = and(b1,b2);                   // ctxt => b1&b2  a1&a2=> b1&b2
    break;
  case &Or(a1,a2):
    let b1 = weaken_it(a2,a1);           // a1=>b1 & a2=>b1
    let b2 = weaken_it(a1,a2);           // a2=>b2 & a1=>b2
    res = weaken_it(ctxt,and(b1,b2));  // ctxt=>c  b1&b2=>c  a1|a2=>b1&b2
    break;
  case &True: 
  case &False: 
  case &Prim(...): 
    res = &true_assn;
    break;
  default: return weaken_it(ctxt, reduce(a));
  }
  return res;
}


// We are given assertions A1 and A2 and would like to find
// the strongest assertion A such that A1 implies A and
// A2 implies A.  However, we would like to also ensure that
// A is "smaller" than A2.  The widen operation ensures that
// either we get back A2 or else the assertion is smaller
// (or as a technical hitch, we flip once from false to true.)
static assn_t weaken_assn(assn_t ctxt, assn_t a) {
  if (implies(&ctxt,&a)) return a;
  return weaken_it(ctxt,a);
}

////////// Updating an Assertion //////////////////
static term_t fresh_nonescvar(env_t env, vardecl_t vd);

// We are executing tgt := src
static assn_t do_assign(env_t env, assn_t a, term_opt_t tgt, term_opt_t src) {
  switch (tgt) {
  case NULL: 
    // We don't know what the target is except that it's not a non-escaping
    // variable, so we must kill those references.
    return kill(a);
  case &Var(vd):
    // We know what the target is -- if it escapes then we kill all 
    // escaping variables, otherwise we just kill the target vd by
    // substituting a fresh logic variable.
    // We must make sure to also kill within the src term.
    if (vd->escapes) {
      a = kill(a);
      src = (src == NULL) ? NULL : kill_mem_term(src);
    } else {
      let v2 = fresh_nonescvar(env,vd);
      a = subst(vd,v2,a);
      src = (src == NULL) ? NULL : subst_term(src,vd,v2);
    }
    // Finally, add in tgt == src.
    return and(a,eq(tgt,src));
  default: Warn::impos("vcgen do_assign");
  }
}

///////////////////// Analysis /////////////////////

////////// Analysis Environment /////////////////////
struct SharedEnv {
  // a mapping from statements to accumulated pre-conditions 
  Hashtable::table_t<stmt_t,assn_t@> assn_table;
  // a mapping for successors in the control-flow graph (from jump_analysis)
  Hashtable::table_t<stmt_t,stmt_opt_t> succ_table;
  // the assertion accumulated for the current exception handler
  assn_t try_assn;
  // when not-null is used to record the resulting value of an expr-stmt.
  term_opt_t* exp_stmt;
  // used to record the result terms and assertions for a function
  term_opt_t  res_term;
  assn_t      res_assn;
};

typedef Dict::dict_t<vardecl_t,int> state_counter_t;

struct Env {
  struct SharedEnv @shared;
  // A clever idea from Yanling for simulating SSA:
  // For non-escaping variables, we keep a state counter so that when
  // we kill a variable on two separate paths, we retain some sharing
  // for the old values.  For instance, if we have:
  //     [x==0 && x==y] if (c) { x := 4; } else { x := 5; }
  // then we want to end up killing x with the same variable _x0 
  // upon each update so that we get on output:
  // ([_x0==0 && _x0==y && c && x == 4] ||[_x0==0 && _x0==y && !c && x == 5])
  // This will make it easier to collapse this into:
  //  [_x0==0 && _x0==y && (c && x == 4 || !c && x == 5)]
  state_counter_t state_counter;
};

static int hash_ptr(`a s) { return (int)s; }

static env_t 
initial_env(JumpAnalysis::jump_anal_res_t tables, Absyn::fndecl_t fd) {
  let succ_table = Hashtable::lookup(tables->succ_tables,fd);
  let assn_table = Hashtable::create(57, Core::ptrcmp, hash_ptr);
  let senv =  new SharedEnv{.assn_table = assn_table,
                            .succ_table = succ_table,
                            .try_assn = &false_assn,
                            .exp_stmt = NULL,
                            .res_term = NULL,
                            .res_assn = &false_assn};
  let d = Dict::empty(Core::ptrcmp);
  return new Env { .shared = senv, .state_counter = d };
}

static env_t copy_env(env_t env) {
  return new(*env);
}

// we have to merge environments at a join-point to get the
// next in a sequence.
static int max_counter(int dummy, vardecl_t vd, int i, int j) {
  return (i < j) ? j : i;
}

static void merge_env(env_t old_env, env_t new_env) {
  old_env->state_counter = Dict::union_two_c(max_counter, 0, 
                                             old_env->state_counter, 
                                             new_env->state_counter);
}

// generate a fresh logic variable for a non-escaping variable --
// the next one in a sequence.
static term_t fresh_nonescvar(env_t env, vardecl_t vd) {
  int res = 0;
  Dict::lookup_bool(env->state_counter,vd,&res);
  env->state_counter = Dict::insert(env->state_counter,vd,res+1);
  return new LogicVar(vd,res);
}

// each statement may have an assertion associated with it from
// other incoming edges -- we must take into account all paths.
static assn_t pre_stmt_update(env_t env, stmt_t s, assn_t ain) {
  let popt = Hashtable::lookup_opt(env->shared->assn_table,s);
  if (popt != NULL) {
    assn_t @p = *popt;
    let new_precondition = or(ain,*p);
    *p = new_precondition;
    return new_precondition;
  } else 
    return ain;
}

// get the pre-condition currently associated with a statement.
static assn_t@ get_assn(env_t env, stmt_t s) {
  static assn_t false_pointer = &false_assn;
  assn_t @* popt = Hashtable::lookup_opt(env->shared->assn_table,s);
  if (popt != NULL)
    return *popt;
  else
    return &false_pointer;
}

// similar to pre_stmt_update except that we use widen instead of or
// since this is part of a loop back-edge.
static assn_t loop_assn(env_t env, stmt_t s, assn_t ain) {
  assn_t @* aprevopt = Hashtable::lookup_opt(env->shared->assn_table,s);
  if (aprevopt != NULL) {
    let aprev = *aprevopt;
    ain = weaken_assn(ain,*aprev);
    *aprev = ain;
  } else {
    Hashtable::insert(env->shared->assn_table,s,new ain);
  }
  return ain;
}

// similar to pre_stmt_update but makes sure to put the
// result on the statement.
static assn_t forward_assn(env_t env, stmt_t s, assn_t ain) {
  assn_t@* aprevopt = Hashtable::lookup_opt(env->shared->assn_table,s);
  if (aprevopt != NULL) {
    let aprev = *aprevopt;
    ain = or(ain,*aprev);
    *aprev = ain;
  } else {
    Hashtable::insert(env->shared->assn_table,s,new ain);
  }
  return ain;
}

// update the assertion associated with the current 
// exception handler.
static void update_try_assn(env_t env, assn_t a) {
  env->shared->try_assn = or(env->shared->try_assn,a);
}

// update the return information for a function
static void update_return(env_t env, term_opt_t t, assn_t a) {
  let shared = env->shared;
  if (shared->res_term != NULL || t != NULL) {
    let v = fresh_var();
    shared->res_term = v;
    shared->res_assn = 
      or(and(a,eq(v,t)),and(shared->res_assn,eq(v,shared->res_term)));
  } else {
    shared->res_assn = or(a,shared->res_assn);
  }
}

// forward declarations for the analysis functions.

// Vcgen for statements.  ain is an assertion describing the state
// on input to the statement, and this returns an assertion describing 
// the output state. 
static assn_t vcgen_stmt_nodebug(env_t env, stmt_t s, assn_t ain);
// Analyze a term given precondition ain and generate an optional term
// and post-condition representing the value of the expression and
// the resulting machine state.
static $(term_opt_t,assn_t) vcgen_rexp_nodebug(env_t env, exp_t e, assn_t ain);
// If the term is "undefined" then we return a fresh variable.
static $(term_t,assn_t) vcgen_rexp_always(env_t env, exp_t e, assn_t ain);
// Same as above, but for lhs-expressions.
static $(term_opt_t,assn_t) vcgen_lexp(env_t env, exp_t e, assn_t ain);
// Analyze a test expression returning two assertions corresponding
// to the test succeeding (true-case) or failing (false-case).
static $(assn_t t,assn_t f) vcgen_test(env_t env, exp_t e, assn_t ain);
// Analyze a list of expressions returning an optional list of
// terms and the output assertion.  If any of the expressions'
// is unknown, then so is the whole thing.
static $(list_t<term_t>*,assn_t) vcgen_rexps(env_t env, list_t<exp_t> es, assn_t a);
// Similar to above but here we don't care what the resulting terms
// are at all.
static assn_t vcgen_rexps_nosave(env_t env, list_t<exp_t> es, assn_t a);
// Folds vcgen_rexp_always across the list.
static $(list_t<term_t>,assn_t) vcgen_rexps_always(env_t env, list_t<exp_t> es, assn_t ain);
// Do vcgen for all of the cases in a switch.  
static assn_t vcgen_switch(env_t env, list_t<switch_clause_t> scs, assn_t ain);
// Do vcgen for a local declaration
static assn_t vcgen_local_decl(env_t env, decl_t d, assn_t a);

static string_t stmt2shortstring(stmt_t s) {
  switch (s->r) {
  case &Absyn::IfThenElse_s(e,...): 
    return aprintf("if (%s) ...",Absynpp::exp2string(e));
  case &Absyn::While_s($(e,_),_):
    return aprintf("while (%s) ...",Absynpp::exp2string(e));
  case &Absyn::For_s(e1,$(e2,_),$(e3,_),_):
    return aprintf("for (%s;%s;%s) ...",Absynpp::exp2string(e1),
                   Absynpp::exp2string(e2),Absynpp::exp2string(e3));
  case &Absyn::Switch_s(e,...): 
    return aprintf("switch (%s) ...",Absynpp::exp2string(e));
  case &Absyn::Do_s(_,$(e,_)):
    return aprintf("do ... while (%s)",Absynpp::exp2string(e));
  case &Absyn::TryCatch_s(s,...): 
    return aprintf("try %s catch ...",stmt2shortstring(s));
  case &Absyn::Seq_s(s,...): return stmt2shortstring(s);
  default: 
    let s = Absynpp::stmt2string(s);
    unsigned max = numelts(s) < 11 ? numelts(s) : 11;
    char ?@nozeroterm res = malloc(sizeof(char)*max);
    for (int i = 0; i < max-1; i++)
      res[i] = s[i];
    return aprintf("%s...",res);
  }
}

#ifdef VCGEN_DEBUG
#define vcgen_rexp(env,e,a) vcgen_rexp_debug(env,e,a)
#define vcgen_stmt(env,s,a) vcgen_stmt_debug(env,s,a)
static unsigned int indent = 0;
static void print_tabs() {
  for (unsigned i = indent; i > 0; i--)
    fprintf(stderr," ");
}
static assn_t vcgen_stmt_debug(env_t env, stmt_t s, assn_t ain) {
  switch (s->r) {
  case &Absyn::Seq_s(_,_): 
  case &Absyn::Decl_s(...):
    //case &Absyn::Exp_s(...):
  case &Absyn::Skip_s: return vcgen_stmt_nodebug(env,s,ain);
  default:
    print_tabs();
    let str = assn2string(ain);
    //    fprintf(stderr,"stmt %s pre(%d/%d)=%s\n",stmt2shortstring(s),assn_size(ain),tree_size,str);
    fprintf(stderr,"stmt %s =%s\n",stmt2shortstring(s),str);
    indent += 2;
    let aout = vcgen_stmt_nodebug(env,s,ain);
    indent -= 2;
    print_tabs();
    let str = assn2string(aout);
    fprintf(stderr,"stmt %s, post(%d/%d)=%s\n",stmt2shortstring(s),assn_size(aout),tree_size,str);
    return aout;
  }
}
static $(term_opt_t,assn_t) vcgen_rexp_debug(env_t env, exp_t e, assn_t ain) {
  print_tabs();
  fprintf(stderr,"exp %s, pre=%s\n",Absynpp::exp2string(e),assn2string(ain));
  indent += 2;
  let $(t,a) = vcgen_rexp_nodebug(env,e,ain);
  indent -= 2;
  print_tabs();
  fprintf(stderr,"exp %s ==> %s, post: %s\n",Absynpp::exp2string(e),
          ((t == NULL) ? "?" : term2string((term_t)t)), assn2string(ain));
  return $(t,a);
}

#else
#define vcgen_rexp(env,e,a) vcgen_rexp_nodebug(env,e,a)
#define vcgen_stmt(env,s,a) vcgen_stmt_nodebug(env,s,a)
#endif

// To simplify things, I'm treating the control-flow as if it were
// structured.  Upon reaching a labelled statement, I set the pre-
// condition to "True" which is conservative.   This lets me do
// local iteration for loops and so forth to generate invariants,
// since the only back-edges in the simplified graph are always
// part of the control constructs.  
static assn_t vcgen_stmt_nodebug(env_t env, stmt_t s, assn_t ain) {
  // merge the pre-condition with any pre-recorded assertions.
  // we'll have one if there was some control-flow to this statement.
 LOOP:
  ain = pre_stmt_update(env,s,ain);
  //assn_size(ain);
  // don't bother analyzing if we can show the assertion is false
  // (effectively an unreachable state.)
  switch (ain) {
  case &False: return ain;
  default: break;
  }
  switch (s->r) {
  case &Absyn::Skip_s: return ain;
  case &Absyn::Exp_s(e): 
    let $(t,aout) = vcgen_rexp(env,e,ain);
    // a little trickery to deal with statement expressions -- we
    // record the result in the environment here.
    if (env->shared->exp_stmt != NULL) 
      *(env->shared->exp_stmt) = t;
    return aout;
  case &Absyn::Seq_s(s1,s2): 
    ain = vcgen_stmt(env,s1,ain);
    s = s2;
    goto LOOP;
  case &Absyn::Return_s(NULL): 
    update_return(env,NULL,ain);
    return &false_assn;
  case &Absyn::Return_s(e as &_): 
    let $(t,aout) = vcgen_rexp(env,(exp_t)e,ain);
    update_return(env,t,aout);
    return &false_assn;
  case &Absyn::IfThenElse_s(e1,s1,s2):
    let $(at,af) = vcgen_test(env,e1,ain);
    let env2 = copy_env(env);
    at = vcgen_stmt(env,s1,at);
    af = vcgen_stmt(env2,s2,af);
    merge_env(env,env2);
    return or(at,af);
  case &Absyn::While_s($(e,dummy),s):
    // we're doing local iteration here -- we join with the
    // assertion on the dummy and widen each time around the loop since
    // its assertion will be updated by a continue.  We disallow
    // goto's in the analysis by essentially forcing their destination's
    // assertion to be true.
    while (true) {
      ain = loop_assn(env,dummy,ain);
      let $(at,af) = vcgen_test(env,e,ain);
      ain = vcgen_stmt(env,s,at);
      if (implies(&ain,get_assn(env,dummy))) return af;
    } 
  case &Absyn::Continue_s: fallthru;
    // continue is a backwards jump in a loop, but we take
    // that into account as part of the loop iteration.
    let dest = Hashtable::lookup(env->shared->succ_table,s);
    loop_assn(env, (stmt_t)dest, ain);
    return &false_assn;
  case &Absyn::Break_s:
    // break is a forwards jump so we can do an Or.  This assertion
    // that we set on the destination will be picked up when we hit
    // that statement.  
    let dest = Hashtable::lookup(env->shared->succ_table,s);
    if (dest == NULL) 
      update_return(env,NULL,ain);
    else 
      forward_assn(env, (stmt_t)dest, ain);
    return &false_assn;
  case &Absyn::For_s(e1,$(e2,dummy2),$(e3,dummy3),s):
    let $(_,a) = vcgen_rexp(env,e2,ain);
    ain = a;
    // similar to while loop.
    while (true) {
      ain = loop_assn(env,dummy2,ain);
      let $(at,af) = vcgen_test(env,e2,ain);
      ain = vcgen_stmt(env,s,at);
      // must do pre-statement check because continue goes here
      ain = pre_stmt_update(env,dummy3,ain);
      ain = vcgen_rexp(env,e3,ain)[1];
      if (implies(&ain,get_assn(env,dummy2))) return af;
    }
  case &Absyn::Do_s(s,$(e,dummy)):
    // similar to while loop
    while (true) {
      ain = vcgen_stmt(env,s,ain);
      let $(at,af) = vcgen_test(env,e,ain);
      ain = weaken_assn(*get_assn(env,dummy),ain);
      if (implies(&ain,get_assn(env,dummy))) return af;
      loop_assn(env,dummy,ain);
    }
  case &Absyn::Switch_s(e,scs,_):
    // FIX: take into acount test of e
    // note that we do not split the state counter for a switch
    // because a fallthru might lead to problems.  if we merged
    // environments at entry points of control-flow paths, then
    // we could handle this.
    let $(t,a) = vcgen_rexp(env,e,ain);
    return vcgen_switch(env,scs,a);
  case &Absyn::Fallthru_s(_,NULL): Warn::impos("vcgen fallthru");
  case &Absyn::Fallthru_s(es,&dest):
    // Also a forward jump so we can do an or.
    let $(ts,a) = vcgen_rexps_always(env,es,ain);
    if (ts != NULL){
      //pat_vars has a bunch of nulls before meaning full pat vars;
      let x = Tcutil::filter_nulls(List::split(dest->pat_vars->v)[0]);
      // initialize the pattern variables with their corresponding terms
      for (; x != NULL; x = x->tl,ts = ts->tl) {
	let vd = x->hd;
	if (vd != NULL) 
	  a = do_assign(env,a,new Var(vd),ts->hd);
      }
    }
    forward_assn(env, dest->body, a);
    return &false_assn;
  case &Absyn::Decl_s(d,s1):
    ain = vcgen_local_decl(env,d,ain);
    s = s1;
    goto LOOP;
  case &Absyn::Label_s(_,s): 
    // by making the assertion True here, we're effectively losing
    // all information when we do a goto.  This is conservative, 
    // and means that I don't have to worry about non-structured
    // control-flow.
    return vcgen_stmt(env,s,&true_assn);
  case &Absyn::Goto_s(_): return &false_assn; // see above
  case &Absyn::TryCatch_s(s,scs,_):
    // save old try/catch-handler assertion
    let old_try_assn = env->shared->try_assn;
    // install new try/catch-handler assertion
    env->shared->try_assn = &false_assn;
    // run vcgen on the body -- this will update the env->shared->try_assn 
    // with assertions of any state that might throw an exn.
    ain = vcgen_stmt(env,s,ain);
    // restore the old handler's assertion.
    let new_try_assn = env->shared->try_assn;
    env->shared->try_assn = old_try_assn;
    // analyze the catch handlers and merge with the body to get
    // the final output.
    return or(ain,vcgen_switch(env,scs,new_try_assn));
  }
}

static assn_t vcgen_switch(env_t env, list_t<switch_clause_t> scs, assn_t ain) {
  // note that all of the clauses should explicitly jump (via break)
  // or something else outside of the clause so the result should always
  // be false...
  assn_t res = &false_assn;
  for (; scs != NULL; scs = scs->tl) {
    let sc = scs->hd;
    let a = ain;
    for (let pvs = sc->pat_vars->v; pvs != NULL; pvs = pvs->tl) {
      let &$(vdopt,eopt) = pvs->hd;
      if (vdopt != NULL) {
        if (eopt != NULL)
          a = do_assign(env,a,new Var(*vdopt),vcgen_rexp(env,(exp_t)eopt,a)[0]);
        else 
          a = do_assign(env,a,new Var(*vdopt),fresh_var());
      }
    }
    if (sc->where_clause != NULL) 
      a = vcgen_test(env, (exp_t)sc->where_clause, a)[0];
    res = or(res,vcgen_stmt(env,sc->body,a));
  }
  return res;
}

static assn_t add_vardecl(env_t env, vardecl_t vd, assn_t a) {
  // stupid C semantics means I have to put in a dummy value for vd first,
  // then run the initializer.  
  let tv = new Var(vd);
  a = do_assign(env,a,tv,fresh_var());
  if (vd->initializer != NULL) {
    let $(t,a1) = vcgen_rexp(env,(exp_t)vd->initializer,a);
    a = do_assign(env,a1,tv,t);
  }
  return a;
}

static assn_t vcgen_local_decl(env_t env, decl_t d, assn_t a) {
  switch (d->r) {
  case &Absyn::Var_d(vd): return add_vardecl(env,vd,a);
  case &Absyn::Let_d(p,vds,e,_): 
    let $(_,a) = vcgen_rexp(env,e,a);
    for (let vds = vds->v; vds != NULL; vds = vds->tl) {
      let $(vdopt,eopt) = *vds->hd;
      if (vdopt != NULL) {
        if (eopt == NULL) a = add_vardecl(env,*vdopt,a);
        else {
          let $(t,a1) = vcgen_rexp(env,e,a);
          let tv = new Var(*vdopt);
          a = do_assign(env,a1,tv,t);
        }
      }
    }
    return a;
  case &Absyn::Letv_d(vds): 
    for (; vds != NULL; vds = vds->tl)
      a = add_vardecl(env,vds->hd,a);
    return a;
  case &Absyn::Region_d(_,vd,eopt): 
    if (eopt != NULL) {
      let $(t,a1) = vcgen_rexp(env,(exp_t)eopt,a);
      a = a1;
    }
    // FIX: inaccurate but okay for now.
    a = add_vardecl(env,vd,a);
    return a;
  default: return a;
  }
}

// determine whether a comparing these two expressions is an 
// unsigned or a signed comparison.
static bool unsigned_comparison(exp_t e1, exp_t e2) {
  let t1 = Absyn::compress((type_t)e1->topt);
  let t2 = Absyn::compress((type_t)e2->topt);
  switch $(t1,t2) {
  case $(&Absyn::AppType(&Absyn::IntCon(Absyn::Unsigned,_),_),_): return true;
  case $(_,&Absyn::AppType(&Absyn::IntCon(Absyn::Unsigned,_),_)): return true;
  case $(&Absyn::PointerType(_),&Absyn::PointerType(_)): return true;
  default: return false;
  }
}

#define sgte(t1,t2) (slte(t2,t1))
#define ugte(t1,t2) (ulte(t2,t1))
#define sgt(t1,t2) (slt(t2,t1))
#define ugt(t1,t2) (ult(t2,t1))

static $(assn_t,assn_t) vcgen_test(env_t env, exp_t e, assn_t ain) {
  switch (e->r) {
  case &Absyn::Conditional_e(e1,e2,e3):
    let $(a1t,a1f) = vcgen_test(env,e1,ain);
    let $(a2t,a2f) = vcgen_test(env,e2,a1t);
    let $(a3t,a3f) = vcgen_test(env,e3,a1f);
    return $(or(a2t,a3t),or(a2f,a3f));
  case &Absyn::And_e(e1,e2):
    let $(a1t,a1f) = vcgen_test(env,e1,ain);
    let $(a2t,a2f) = vcgen_test(env,e2,a1t);
    return $(a2t, or(a1f,a2f));
  case &Absyn::Or_e(e1,e2):
    let $(a1t,a1f) = vcgen_test(env,e1,ain);
    let $(a2t,a2f) = vcgen_test(env,e2,a1f);
    return $(or(a1t,a2t),a2f);
  case &Absyn::SeqExp_e(e1,e2):
    let $(_,ain) = vcgen_rexp(env,e1,ain);
    return vcgen_test(env,e2,ain);
  case &Absyn::Primop_e(Absyn::Not,&List(e1,_)):
    let $(at,af) = vcgen_test(env,e1,ain);
    return $(af,at);
  case &Absyn::Primop_e(p,&List(e1,&List(e2,NULL))):
    let $(t1,a1) = vcgen_rexp(env,e1,ain);
    let $(t2,a2) = vcgen_rexp(env,e2,a1);
    let at = a2;
    let af = a2;
    switch p {
    case Absyn::Eq:  at = and(at,eq(t1,t2));  af = and(af,neq(t1,t2)); break;
    case Absyn::Neq: at = and(at,neq(t1,t2)); af = and(af,eq(t1,t2)); break;
    case Absyn::Lt:
      if (unsigned_comparison(e1,e2)) {
        at = and(at,ult(t1,t2));  af = and(af,ugte(t1,t2)); 
      } else {
        at = and(at,slt(t1,t2));  af = and(af,sgte(t1,t2)); 
      }
      break;
    case Absyn::Lte: 
      if (unsigned_comparison(e1,e2)) {
        at = and(at,ulte(t1,t2)); af = and(af,ugt(t1,t2)); 
      } else {
        at = and(at,slte(t1,t2)); af = and(af,sgt(t1,t2)); 
      }
      break;
    case Absyn::Gt:  
      if (unsigned_comparison(e1,e2)) {
        at = and(at,ugt(t1,t2));  af = and(af,ulte(t1,t2)); 
      } else {
        at = and(at,sgt(t1,t2));  af = and(af,slte(t1,t2)); 
      }
      break;
    case Absyn::Gte: 
      if (unsigned_comparison(e1,e2)) {
        at = and(at,ugte(t1,t2)); af = and(af,ult(t1,t2)); 
      } else {
        at = and(at,sgte(t1,t2)); af = and(af,slt(t1,t2)); 
      }
      break;
    default: break;
    }
    return $(at,af);
  default:
    let $(t,aout) = vcgen_rexp(env,e,ain);
    return $(and(aout,neq(t,zero())),and(aout,eq(t,zero())));
  }
}

static assn_t vcgen_rexps_nosave(env_t env, list_t<exp_t> es, assn_t a) {
  for (; es != NULL; es = es->tl) 
    a = vcgen_rexp(env,es->hd,a)[1];
  return a;
}

static $(list_t<term_t>*,assn_t) vcgen_rexps(env_t env, list_t<exp_t> es, assn_t a) {
  list_t<term_t> res = NULL;
  bool valid = true;
  for (; es != NULL; es = es->tl) {
    let $(t,aout) = vcgen_rexp(env,es->hd,a);
    a = aout;
    if (valid && t != NULL) {
      res = new List{(term_t)t,res};
    } else {
      valid = false;
    }
  }
  return $(valid ? new (imp_rev(res)) : NULL, a);
}

static $(term_t,assn_t) vcgen_rexp_always(env_t env, exp_t e, assn_t ain) {
  let $(topt,a) = vcgen_rexp(env,e,ain);
  return $(topt == NULL ? fresh_var() : (term_t)topt, a);
}

static $(list_t<term_t>,assn_t) vcgen_rexps_always(env_t env, list_t<exp_t> es, assn_t ain) {
  list_t<term_t> res = NULL;
  for (; es != NULL; es = es->tl) {
    let $(t,a) = vcgen_rexp_always(env,es->hd,ain);
    ain = a;
    res = new List(t,res);
  }
  return $(List::imp_rev(res),ain);
}

static vardecl_t bind2vardecl(Absyn::binding_t b) {
  switch (b) {
  case &Absyn::Global_b(vd): return vd;
  case &Absyn::Funname_b(fd): return (vardecl_t)fd->fn_vardecl;
  case &Absyn::Unresolved_b(...): Warn::impos("vcgen bind2vardecl");
  case &Absyn::Param_b(vd): return vd;
  case &Absyn::Local_b(vd): return vd;
  case &Absyn::Pat_b(vd): return vd;
  }
}

static $(term_opt_t,assn_t) vcgen_lexp(env_t env, exp_t e, assn_t ain) {
  switch (e->r) {
  case &Absyn::Var_e(b): 
      return $(new Var(bind2vardecl(b)),ain);
  default: return $(NULL, vcgen_rexp(env,e,ain)[1]);
  }
}

// extract the arguments, requires, and ensures clause for a function from
// its type.
static $(list_t<$(var_opt_t,tqual_t,type_t)@> args, exp_opt_t req, exp_opt_t ens, vardecl_opt_t ret_value) get_requires_and_ensures_info(Absyn::fn_info_t @fi) {
  return $(fi->args,fi->requires_clause,fi->ensures_clause,fi->return_value);
}

static $(list_t<$(var_opt_t,tqual_t,type_t)@> args, exp_opt_t req, exp_opt_t ens, vardecl_opt_t ret_value) get_requires_and_ensures(type_opt_t topt) {
  if (topt != NULL) {
    type_t t = Tcutil::pointer_elt_type((type_t)topt);
    switch (t) {
    case &Absyn::FnType(*fi): return get_requires_and_ensures_info(fi);
    default: break;
    }
  } 
  return $(NULL,NULL,NULL,NULL);
}

static void check_requires(env_t env, list_t<term_t> inputs,
                           list_t<$(var_opt_t,tqual_t,type_t)@> args,
                           assn_t a, exp_opt_t reqopt) {
  if (reqopt != NULL) {
    exp_t req = (exp_t)reqopt;
    // pretend like we're assigning the actual values to the parameter
    // values
    for (; args != NULL && inputs != NULL; args = args->tl, inputs = inputs->tl) {
      let &$(vopt,tq,t) = args->hd;
      if (vopt != NULL) {
        // have to fake up a vardecl
        Absyn::qvar_t qv = new $(Absyn::Loc_n,(Absyn::var_t)vopt);
        let vd = new Absyn::Vardecl {.sc = Absyn::Public,
                                     .name = qv,.varloc = 0,.tq = tq,
                                     .type = t,.initializer = NULL,
                                     .rgn = NULL,.attributes = NULL,
                                     .escapes = false, .is_proto=false};
          a = and(a,eq(new Var(vd),inputs->hd));
        }
    }
    // FIX? varargs.
    let $(at,_) = vcgen_test(env,(exp_t)reqopt,&true_assn);
    if (!implies(&a,&at))
      Warn::err(req->loc, "cannot prove @requires %s from %s",
                assn2string(reduce(at)), assn2string(reduce(a)));
  }
}

static term_opt_t deref_lterm(env_t env, term_opt_t lt, assn_t ain) {
  return lt;
}

static $(term_opt_t,assn_t) vcgen_rexp_nodebug(env_t env, exp_t e, assn_t ain) {
  if (Tcutil::is_const_exp(e)) return $(cnst(e),ain);
  switch (e->r) {
  case &Absyn::Const_e(c): 
    // should really be caught by the above...
    return $(new Const(e),ain);
  case &Absyn::Var_e(b): return $(new Var(bind2vardecl(b)),ain);
  case &Absyn::Primop_e(p,es):
    let $(ts,aout) = vcgen_rexps(env,es,ain);
    term_opt_t t = NULL;
    if (ts != NULL) t = primop(p,*ts);
    return $(t, aout);
  case &Absyn::AssignOp_e(e1,popt,e2):
    let $(lt,a1) = vcgen_lexp(env,e1,ain);
    let $(t2,a2) = vcgen_rexp(env,e2,a1);
    if (popt != NULL) {
      let t1 = deref_lterm(env,lt,a2);
      if (t1 == NULL || t2 == NULL) 
        t2 = NULL;
      else
        t2 = primop(popt->v,list((term_t)t1,(term_t)t2));
    }
    let a = do_assign(env,a2,lt,t2);
    return $(lt,a);
  case &Absyn::Increment_e(e,i):
    let $(lt,a1) = vcgen_lexp(env,e,ain);
    let t1 = deref_lterm(env,lt,a1);
    term_opt_t res = NULL;
    term_opt_t assn = NULL;
    switch (i) {
    case Absyn::PreInc: 
      if (t1 != NULL) assn = primop(Absyn::Plus,list((term_t)t1,one()));
      res = assn;
      break;
    case Absyn::PostInc:
      res = t1;
      if (t1 != NULL) assn = primop(Absyn::Plus,list((term_t)t1,one()));
      break;
    case Absyn::PreDec:
      if (t1 != NULL) assn = primop(Absyn::Minus,list((term_t)t1,one()));
      res = assn;
      break;
    case Absyn::PostDec:
      res = t1;
      if (t1 != NULL) assn = primop(Absyn::Minus,list((term_t)t1,one()));
      break;
    default: Warn::impos("vcgen vcgen_rexp increment_e");
    }
    let a = do_assign(env,a1,lt,assn);
    return $(res,a);
  case &Absyn::Conditional_e(e1,e2,e3):
    let $(at,af) = vcgen_test(env,e1,ain);
    let $(t1,at) = vcgen_rexp(env,e2,at);
    let $(t2,af) = vcgen_rexp(env,e3,af);
    if (t1 != NULL && t2 != NULL) {
      let v = fresh_var();
      at = and(at,eq(v,t1));
      af = and(af,eq(v,t2));
      return $(v,or(at,af));
    } else
      return $(NULL,or(at,af));
  case &Absyn::And_e(e1,e2):
    let $(at,af) = vcgen_test(env,e1,ain);
    let $(t,at) = vcgen_rexp(env,e2,at);
    let v = fresh_var();
    at = and(at,eq(v,t));
    af = and(af,eq(v,zero()));
    return $(v,or(at,af));
  case &Absyn::Or_e(e1,e2):
    let $(at,af) = vcgen_test(env,e1,ain);
    let $(t,af) = vcgen_rexp(env,e2,af);
    let v = fresh_var();
    at = and(at,eq(v,one()));
    af = and(af,eq(v,t));
    return $(v,or(at,af));
  case &Absyn::SeqExp_e(e1,e2):
    let $(_,a) = vcgen_rexp(env,e1,ain);
    return vcgen_rexp(env,e2,a);
  case &Absyn::FnCall_e(e,es,...):
    let $(ts,a) = vcgen_rexps_always(env,es,ain);
    let $(_,a2) = vcgen_rexp(env,e,a);
    // check @requires clause on function
    let $(args,reqopt,ensopt,ret_value) = get_requires_and_ensures(e->topt);
    check_requires(env,ts,args,a2,reqopt);
    // kill every variable that points into memory -- could refine
    // this to only those reachable from globals or the parameters.
    a2 = kill(a2);
    update_try_assn(env,a2);
    // noreturn functions don't return...
    if (Atts::is_noreturn_fn_type((type_t)e->topt)) a2 = &false_assn;
    if (ensopt == NULL) 
      return $(NULL,a2);
    exp_t ensures = (exp_t)ensopt;
    // add in the @ensures clause for the result
    let $(at,_) = vcgen_test(env,ensures,a2);
    if (ret_value != NULL) {
      let v = fresh_var();
      // FIX: substitute ts for formal parameters
      at = subst((vardecl_t)ret_value,v,at);
      return $(v,at);
    } 
    return $(NULL,at);
  case &Absyn::Throw_e(e,_):
    let $(_,a) = vcgen_rexp(env,e,ain);
    update_try_assn(env,a);
    return $(NULL,&false_assn);
  case &Absyn::NoInstantiate_e(e): return vcgen_rexp(env,e,ain);
  case &Absyn::Instantiate_e(e,_):  return vcgen_rexp(env,e,ain);

  case &Absyn::Cast_e(tp,e,_,c): 
    // FIX: really need to put C coercions in terms...
    let $(topt,a) = vcgen_rexp(env,e,ain);
    if (c == Absyn::No_coercion) {
      if (topt == NULL) return $(NULL,a);
      term_t t = (term_t)topt;
      // we only need to retain the cast on the term if it
      // changes the size of the value.  In particular, we
      // can drop a cast from an int to an unsigned int and
      // vice versa.  We might be able to get away with 
      // dropping other casts (e.g., char->int) but we'll be
      // conservative now.
      switch $(Absyn::compress(tp),Absyn::compress((type_t)e->topt)) {
      case $(&Absyn::AppType(&Absyn::IntCon(u1,s1),_),&Absyn::AppType(&Absyn::IntCon(u2,s2),_)):
        if (s1 == s2) return $(t,a);
        break;
      default: break;
      }
      return $(cast(tp,t),a);
    }
    else {
      update_try_assn(env,ain); // coercion could fail
      return $(topt == NULL ? NULL : cast(tp,(term_t)topt),a);
    }
  case &Absyn::New_e(eopt,e):
    if (eopt != NULL)
      ain = vcgen_rexp(env,(exp_t)eopt,ain)[1];
    return $(NULL,vcgen_rexp(env,e,ain)[1]);

  // these cases should be captured by the const-expression check above.
  case &Absyn::Enum_e(...):
  case &Absyn::AnonEnum_e(...):
  case &Absyn::Sizeoftype_e(_):
  case &Absyn::Sizeofexp_e(_):
  case &Absyn::Valueof_e(_):
  case &Absyn::Offsetof_e(_,_): return $(NULL,ain);

  // These can all throw exceptions
  case &Absyn::Deref_e(e): fallthru(e);
  case &Absyn::AggrMember_e(e,...): fallthru(e);
  case &Absyn::AggrArrow_e(e,...):
    ain = vcgen_rexp(env,e,ain)[1];
    update_try_assn(env,ain);
    return $(NULL,ain);

  case &Absyn::Tagcheck_e(e,_): fallthru(e);
  case &Absyn::Address_e(e): 
    return $(NULL,vcgen_rexp(env,e,ain)[1]);

  case &Absyn::Subscript_e(e1,e2): 
    let $(t1,a1) = vcgen_rexp(env,e1,ain);
    let $(t2,a2) = vcgen_rexp(env,e2,a1);
    switch (Absyn::compress((type_t)e1->topt)) {
    case &Absyn::TupleType(_): break;
    default:
      if (t1 != NULL) {
        update_try_assn(env,ain);
        a2 = and(a2,ult(t2,primop(Absyn::Numelts,list(t1))));
      }
    }
    return $(NULL,a2);

  case &Absyn::Datatype_e(es,...): fallthru(es);
  case &Absyn::Tuple_e(es): return $(NULL,vcgen_rexps_nosave(env,es,ain));

  case &Absyn::CompoundLit_e(_,dles):   fallthru(dles);
  case &Absyn::Array_e(dles):           fallthru(dles);
  case &Absyn::Aggregate_e(_,_,dles,_): fallthru(dles);
  case &Absyn::UnresolvedMem_e(_,dles): fallthru(dles);
  case &Absyn::AnonStruct_e(_,dles):
    for (; dles != NULL; dles = dles->tl) {
      let &$(_,e) = dles->hd;
      ain = (vcgen_rexp(env,e,ain))[1];
    }
    return $(NULL,ain);

  case &Absyn::Comprehension_e(vd,e1,e2,_): 
    // similar to a while-loop except we evaluate e1 only once.
    let $(t1,a) = vcgen_rexp(env,e1,ain);
    let t1 = (t1 == NULL) ? fresh_var() : (term_t)t1;
    let v = new Var(vd);
    // start off with index 0
    a = do_assign(env,a,v,zero());
    while (true) {
      let at = and(a,ult(v,t1));  // simulate test
      let af = and(a,ugte(v,t1));
      let $(_,abody) = vcgen_rexp(env,e2,at);  // run body and add one
      abody = do_assign(env,abody,v,primop(Absyn::Plus,list(v,one())));
      if (implies(&abody,&a)) { a = af; break; }
      a = weaken_assn(abody,a);  // widen and possibly iterate
    }
    return $(NULL,a);
  case &Absyn::ComprehensionNoinit_e(e,_,_):
    return $(NULL,vcgen_rexp(env,e,ain)[1]);
  case &Absyn::Malloc_e(mi):
    if (mi.rgn != NULL) 
      ain = vcgen_rexp(env,(exp_t)mi.rgn,ain)[1];
    return $(NULL,vcgen_rexp(env,mi.num_elts,ain)[1]);
  case &Absyn::Swap_e(e1,e2): 
    let $(lt1,a1) = vcgen_lexp(env,e1,ain);
    update_try_assn(env,a1); // could have null-exn?
    let $(lt2,a2) = vcgen_lexp(env,e2,a1);
    update_try_assn(env,a2); // could have null-exn?
    let t1 = deref_lterm(env,lt1,a2);
    let t2 = deref_lterm(env,lt2,a2);
    a2 = do_assign(env,a2,lt1,t2);
    a2 = do_assign(env,a2,lt2,t1);
    return $(NULL,a2);
  case &Absyn::StmtExp_e(s):
    let old_exp_stmt = env->shared->exp_stmt;
    env->shared->exp_stmt = new NULL;
    let aout = vcgen_stmt(env,s,ain);
    let t = *(env->shared->exp_stmt);
    env->shared->exp_stmt = old_exp_stmt;
    return $(t,aout);
  case &Absyn::Asm_e(...): return $(NULL,ain);
  case &Absyn::Extension_e(e): return vcgen_rexp(env,e,ain);
  case &Absyn::Pragma_e(s): 
    if (strcmp(s,"print_assn")) {
      let seg_str = Position::string_of_segment(e->loc);
      fprintf(stderr,"%s: current assn is %s\n",seg_str,assn2string(ain));
    }
    return $(zero(),ain);
  case &Absyn::Assert_e(e1):
    let $(at,_) = vcgen_test(env,e1,&true_assn);
    if (!implies(&ain,&at)) 
      Warn::err(e->loc, "cannot prove @assert from %s",
                assn2string(reduce(ain)));
    return $(one(),and(ain,at));
  }
}

// FIX? take into account top-level (const) variable intializers?
void vcgen_fundecl(JumpAnalysis::jump_anal_res_t tables, Absyn::fndecl_t fd){
  let env = initial_env(tables,fd);
  assn_t a = &true_assn;
  // put in the requires clause as an assumption.
  let $(args,reqopt,ensopt,ret_value) = get_requires_and_ensures_info(&fd->i);
  if (reqopt != NULL) {
    // hope the vards in here point to the vardecls in the fn...
    a = vcgen_test(env,(exp_t)reqopt,a)[0];
  }
  vcgen_stmt(env,fd->body,a);
  // check the requires clause
  if (ensopt != NULL) {
    exp_t ens = (exp_t)ensopt;
    let $(at,_) = vcgen_test(env,ens,&true_assn);
    let senv = env->shared;
    let res_assn_opt = senv->res_assn;
    assn_t res_assn = &false_assn;
    if (res_assn_opt != NULL) res_assn = ((assn_t)res_assn_opt);
    string_t str = "NULL";
    if (senv->res_term != NULL) str = term2string((term_t)senv->res_term);
    if (ret_value != NULL && senv->res_term) 
      res_assn = and(res_assn,eq(new Var((vardecl_t)ret_value),senv->res_term));
    if (!implies(&res_assn,&at))
      Warn::err(ens->loc, "cannot prove the @ensures clause %s from %s",
		assn2string(reduce(at)),assn2string(reduce(res_assn)));
  }
  reset_hash_cons_table(); // collect table
}
