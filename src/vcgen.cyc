/* Computing Strongest Post-conditions
   Copyright (C) 2003 Greg Morrisett
   This file is part of the Cyclone compiler.

   The Cyclone compiler is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   The Cyclone compiler is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with the Cyclone compiler; see the file COPYING. If not,
   write to the Free Software Foundation, Inc., 59 Temple Place -
   Suite 330, Boston, MA 02111-1307, USA. */

/* What we are doing here is computing a pre/post-condition in a forwards
   fashion for each statement and expression within a function.  The 
   assertion language is very simple: equality and inequality over
   terms, disjunction, and conjunction (no quantifiers).  The terms
   include what we consider to be "constant" expressions in Cyclone,
   primops of terms, program variables, and logical variables.  

   There's an extremely simple, essentially syntactic prover that is
   used to show implications.  There's also an extremely simple strategy
   for generating loop invariants.  The trickyness is in ensuring
   that the iterative analysis terminates.  In essence, each time
   around a loop, we're guaranteeing that we get a smaller (in terms
   of total node count) assertion.  The worst case is we fall back to "true".

   To keep the analysis simple and somewhat structured, we essentially
   punt on goto's.  More properly, whenever we hit a labelled statement,
   we reset the incoming pre-condition to "true".  This allows me to
   do purely local iteration for calculating the assertions.  To handle
   other non-local edges (e.g., break, continue, throw) we essentially
   pile up assertions on the statement and OR them in with the natural
   flow's pre-condition.  

   Also to keep the analysis simple, we punt on alias analysis.  Variables 
   have a flag indicating whether or not they escape syntactically.
   When updating an escaping variable, we essentially "kill" all 
   escaping variables.  The same happens for a function call.  This is
   *not* thread-safe.  To achieve that, we would have to kill all escaping
   things after each step. 

   We use hash-consing to try to get maximal sharing among 
   assertion nodes.  Maintaining sharing is crucial for avoiding
   an exponential space blow up.  I've experimented with lazy
   substitution as well, but this didn't seem to work that well.

   There are a lot of ways we should improve this analysis and a few
   things that need to be fixed:

   * We need to extend terms to account for casts/coercions.
   * We need to make a distinction between signed and unsigned comparisons.
   * We need to replace the relations stuff in the type-checker (e.g.,
     subtyping) with calls to manipulate the @requires/@ensures stuff
     in here.
   * We need to have a "throttle" for controlling assertion size.  Sooner
     or later we will run into iterated if's/diamond control-flow patterns
     that will result in a zillion disjunctions.  Although we share the
     resulting assertions, the theorem prover needs some way to avoid
     crawling over the assertion as if it's a tree.

   * We should use the Pratt constraint solver where possible.
   * We should take pattern matching tests into account for a switch.
   * We shouldn't kill unique variables.
   * We should only kill "type-compatible" expressions on an update.
     For instance, we don't need to kill pointer variables if we're
     assigning an integer value.  Note that if we had terms like
     *t or t.f or t->f or t1[t2] then we'd have to kill any of those
     though...
   * We should make the simple thm. prover a bit smarter.
   * We should perhaps try to simplify the assertions to remove
     redundancies?
   * We should add support for more predicates and relations (e.g.,
     track whether x == null, or tagcheck(x.f), or datatype tags, etc.)?
   * Could have user-defined predicates...
   * If we knew that a goto was forward, then we could deal with it...
   */
#include "vcgen.h"
#include "absynpp.h"
#include "tcutil.h"
#include "evexp.h"
#include <hashtable.h>
#include <dict.h>
#include <string.h> 
#include <cycboot.h> 
#include <warn.h>

//#define VCGEN_DEBUG

namespace Vcgen;
using List;
typedef Absyn::type_t type_t;
typedef Absyn::type_opt_t type_opt_t;
typedef Absyn::vardecl_t vardecl_t;
typedef Absyn::vardecl_opt_t vardecl_opt_t;
typedef Absyn::exp_t exp_t;
typedef Absyn::decl_t decl_t;
typedef Absyn::stmt_t stmt_t;
typedef Absyn::stmt_opt_t stmt_opt_t;
typedef Absyn::switch_clause_t switch_clause_t;
typedef Absyn::var_opt_t var_opt_t;
typedef Absyn::tqual_t tqual_t;
typedef Absyn::exp_opt_t exp_opt_t;
typedef Absyn::cnst_t cnst_t;
////// Forward Declaration for Environments /////
struct Env;
typedef struct Env @env_t;

///////////////////// Terms /////////////////////
typedef datatype Term @term_t, *term_opt_t;

datatype Term {
  Const(exp_t); // a Cyclone "constant" expression (e.g., 3, sizeof(e), etc.)
  Var(vardecl_t);
  LogicVar(vardecl_opt_t,int);
  Primop(Absyn::primop_t,list_t<term_t>);
  Cast(Absyn::type_t, term_t);
};

string_t term2string(term_t t) {
  switch (t) {
  case &Const(e): return Absynpp::exp2string(e);
  case &Var(vd): return Absynpp::qvar2string(vd->name);
  case &LogicVar(NULL,i): return aprintf("_X%d",i);
  case &LogicVar(vd,i): return aprintf("_%s%d",Absynpp::qvar2string(vd->name),i);
  case &Primop(p,&List{t1,&List{t2,NULL}}): 
    return aprintf("(%s%s%s)",term2string(t1),
                   Absynpp::prim2string(p),term2string(t2));
  case &Primop(p,&List{t,_}):
    return aprintf("%s(%s)",Absynpp::prim2string(p),term2string(t));
  case &Cast(tp,tm):
    return aprintf("(%s)%s",Absynpp::typ2string(tp),term2string(t));
  default: Tcutil::impos("term2string primop args");
  }
}

static term_t cnst(Absyn::exp_t e) { return new Const(e); }
static term_t zero() {
  static term_opt_t z = NULL;
  if (z == NULL) {
    let e = Absyn::int_exp(Absyn::None,0,0);
    e->topt = Absyn::int_type(Absyn::None,Absyn::Int_sz);
    let r = cnst(e);
    z = r;
    return r;
  } else return (term_t)z;
}
static term_t one() {
  static term_opt_t n = NULL;
  if (n == NULL) {
    let e = Absyn::int_exp(Absyn::None,1,0);
    e->topt = Absyn::int_type(Absyn::None,Absyn::Int_sz);
    let r = cnst(e);
    n = r;
    return r;
  } else return (term_t)n;
}
  
static term_t var(vardecl_t vd) { return new Var(vd); }
static term_t primop(Absyn::primop_t p, list_t<term_t,`H> ts) {
  return new Primop(p,ts);
}
static term_t cast(Absyn::type_t tp, term_t tm) {
  return new Cast(tp,tm);
}
static term_t fresh_var() {
  static int counter = 0;
  return new LogicVar(NULL,counter++);
}

static int cmp_term(term_t t1, term_t t2) {
  switch $(t1,t2) {
  case $(&Const(e1),&Const(e2)): return Evexp::exp_cmp(e1,e2);
  case $(&Const(_),_): return -1;
  case $(_,&Const(_)): return 1;
  case $(&Var(vd1),&Var(vd2)): return (int)vd1 - (int)vd2;
  case $(&Var(_),_): return -1;
  case $(_,&Var(_)): return 1;
  case $(&LogicVar(vd1,i),&LogicVar(vd2,j)): 
    if (vd1 == vd2) return (i - j);
    return (int)vd1 - (int)vd2;
  case $(&LogicVar(_,_),_): return -1;
  case $(_,&LogicVar(_,_)): return 1;
  case $(&Cast(tp1,tm1),&Cast(tp2,tm2)):
    int c = Tcutil::typecmp(tp1,tp2);
    if (c != 0) return c;
    return cmp_term(tm1,tm2);
  case $(&Cast(...),_): return -1;
  case $(_,&Cast(...)): return 1;
  case $(&Primop(p1,ts1),&Primop(p2,ts2)):
    if (p1 != p2) return (int)p1 - (int)p2;
    return list_cmp(cmp_term, ts1, ts2);
  }
}

static bool same_term(term_t t1, term_t t2) { return cmp_term(t1,t2) == 0; }

///////////////////// Assertions /////////////////////
typedef datatype Assn @assn_t;

typedef enum Primreln { Eq, Neq, SLt, SLte, ULt, ULte } prim_reln_t;

datatype Assn {
  True;
  False;
  Prim(term_t,prim_reln_t,term_t);
  And(assn_t,assn_t);
  Or(assn_t,assn_t);
  Subst(vardecl_t x,term_t t,assn_t a); // a[t/x] -- lazy substitution
  Kill(assn_t); // replace all escaping variables with fresh logic variables
};

// inner loop for calculating the size of an assertion -- we
// take care to figure out the size as a dag and not a tree.
static unsigned int 
  assn_size_loop(assn_t a, unsigned int c, list_t<assn_t,`H>@ prev){
  LOOP:
  if (memq(*prev,a)) return c;
  *prev = new List(a,*prev);
  switch (a) {
  case &True:  return c;
  case &False: return c;
  case &Prim(...): return 1+c;
  case &And(a1,a2): fallthru(a1,a2);
  case &Or(a1,a2): 
    c = assn_size_loop(a2,1+c,prev);
    a = a1;
    goto LOOP;
  case &Subst(vd,t,a1):
    ++c;
    a = a1;
    goto LOOP;
  case &Kill(a1): 
    ++c;
    a = a1;
    goto LOOP;
  }
}

// counter used for reporting purposes
static unsigned int max_assn_size = 0;

// calculate the size of an assertion
static unsigned int assn_size(assn_t a) {
  list_t<assn_t,`H> prev = NULL;
  let c = assn_size_loop(a,0,&prev);
  if (c > max_assn_size) {
    max_assn_size = c;
  }
  return c;
}

// calculate a string representation (and total tree node count) for an
// assertion.  the prec field (precedent) is used to avoid some parens.
static string_t a2string(assn_t a, int prec, int@ size) {
  switch (a) {
  case &True: return "true";
  case &False: return "false";
  case &Prim(t1,p,t2):
    *size += 1;
    string_t ps;
    switch (p) {
    case Eq: ps = "=="; break;
    case Neq: ps = "!="; break;
    case SLt: ps = "S<"; break;
    case SLte: ps = "S<="; break;
    case ULt: ps = "U<"; break;
    case ULte: ps = "U<="; break;
    default: Tcutil::impos("assn2string primop");
    }
    return aprintf("%s%s%s",term2string(t1),ps,term2string(t2));
  case &Or(a1,a2): 
    *size += 1;
    if (prec <= 5)
      return aprintf("%s || %s",a2string(a1,5,size),a2string(a2,5,size));
    else 
      return aprintf("(%s || %s)",a2string(a1,5,size),a2string(a2,5,size));
  case &And(a1,a2): 
    *size += 1;
    return aprintf("%s && %s",a2string(a1,10,size),a2string(a2,10,size));
  case &Subst(vd,t,a):
    *size += 1;
    return aprintf("Subst[%s:=%s](%s)",Absynpp::qvar2string(vd->name),
                   term2string(t),a2string(a,0,size));
  case &Kill(a):
    *size += 1;
    return aprintf("Kill(%s)",a2string(a,0,size));
  }
}

static int tree_size = 0;

// convert an assertion to a string.
string_t assn2string(assn_t a) {
  tree_size = 0;
  return a2string(a,0,&tree_size);
}

// assertion constants for true and false
static datatype Assn.True true_assn = True;
static datatype Assn.False false_assn = False;

//////////////////////////////////////////////////////////////
// hash-consing to try to preserve as much sharing as we
// can -- has a nice impact on performance (much better than
// lazy substitution), but alas, we still end up allocating a lot.  
// It would be better if we didn't have to allocate the thing 
// that want to lookup.  That could happen if we had a different 
// type for hashtable lookup (as we did with dictionaries.)

static int assnhash(datatype Assn @a) {
  switch (a) {
  case &False: return 0;
  case &True: return 1;
  case &Prim(t1,p,t2): 
    return (unsigned int)t1 ^ (unsigned int)p ^ (unsigned int)t2;
  case &And(a1,a2): return (unsigned int)a1 ^ (unsigned int)a2;
  case &Or(a1,a2): return ((unsigned int)a1 ^ (unsigned int)a2) | 1;
  case &Subst(vd,t,a): return ((unsigned int)a ^ (unsigned int)vd ^
                               (unsigned int)t) | 3;
  case &Kill(a): return (unsigned int)a + 37;
  }
}

// compare two assertions for structural equality -- does not assume
// the components have been hash-consed, but probably could.
static int assncmp(datatype Assn @a1, datatype Assn @a2) {
 LOOP:
  if (a1 == a2) return 0;
  switch $(a1,a2) {
  case $(&True,&True): return 0;
  case $(&True,_): return -1;
  case $(_,&True): return 1;
  case $(&False,&False): return 0;
  case $(&False,_): return -1;
  case $(_,&False): return 1;
  case $(&Or(a11,a12),&Or(a21,a22)): fallthru(a11,a12,a21,a22);
  case $(&And(a11,a12),&And(a21,a22)): 
    int c = assncmp(a11,a21);
    if (c != 0) return c;
    a1 = a12;
    a2 = a22;
    goto LOOP;
  case $(&Or(_,_),_): return -1;
  case $(_,&Or(_,_)): return 1;
  case $(&And(_,_),_): return -1;
  case $(_,&And(_,_)): return 1;
  case $(&Prim(t11,p1,t12),&Prim(t21,p2,t22)):
    int c = (int)p1 - (int)p2;
    if (c != 0) return c;
    c = cmp_term(t11,t21);
    if (c != 0) return c;
    return cmp_term(t12,t22);
  case $(&Prim(...),_): return -1;
  case $(_,&Prim(...)): return 1;
  case $(&Kill(a1),&Kill(a2)): return assncmp(a1,a2);
  case $(&Kill(_),_): return -1;
  case $(_,&Kill(_)): return 1;
  case $(&Subst(vd1,t1,a11),&Subst(vd2,t2,a22)):
    int c = (int)vd1 - (int)vd2;
    if (c != 0) return c;
    c = cmp_term(t1,t2);
    if (c != 0) return c;
    a1 = a11;
    a2 = a22;
    goto LOOP;
  }
}

// a hash-table to hold all of the assertion nodes to maximize
// sharing.  we also record whether or not a node has delayed
// substitutions or kills within it.
static struct Hashtable::Table<assn_t,$(assn_t,bool reduced)@> 
*hash_cons_table = NULL;

// lookup an assertion to see if it has delayed substitutions or
// kills with in it.  
static bool is_reduced(assn_t a) {
  if (hash_cons_table == NULL) return false;
  let resopt = Hashtable::lookup_opt((Hashtable::table_t)hash_cons_table,a);
  if (resopt == NULL) return false;
  let &$(_,b) = *resopt;
  return b;
}

// shallow copy of an assertion from region `r to the heap and 
// simultaneously determine whether or not the assertion is
// reduced so that we can put the information in the table.
static $(assn_t,bool reduced) copy_assn(datatype Assn@`r a){
  switch (a) {
  case &True: return $(&true_assn,true);
  case &False: return $(&false_assn,false);
  case &And(a1,a2): 
    return $(new And(a1,a2),is_reduced(a1) && is_reduced(a2));
  case &Or(a1,a2): 
    return $(new Or(a1,a2),is_reduced(a1) && is_reduced(a2));
  case &Prim(t1,p,t2): return $(new Prim(t1,p,t2),true);
  case &Subst(vd1,t1,a1): return $(new Subst(vd1,t1,a1),false);
  case &Kill(a): return $(new Kill(a),false);
  }
}

// given an assertion node, look it up in the hash-table.  If it's
// not already there, then make a shallow copy and enter it (along
// with info regarding whether or not it's been reduced) into the
// hash table.
static assn_t hash_cons(datatype Assn@`r a) {
  Hashtable::table_t h;
  if (hash_cons_table == NULL) {
    h = Hashtable::create(123, assncmp, assnhash);
    hash_cons_table = h;
    // make sure true and false are in the table so we can
    // ask if they are reduced.
    Hashtable::insert(h,&true_assn,new $(&true_assn,true));
    Hashtable::insert(h,&false_assn,new $(&false_assn,true));
  } else 
    h = (Hashtable::table_t)hash_cons_table;
  let resopt = Hashtable::lookup_other_opt(h,a,assncmp,assnhash);
  if (resopt == NULL) {
    let $(res,reduced) = copy_assn(a);
    Hashtable::insert(h,res,new $(res,reduced));
    return res;
  } else {
    let &$(res,_) = *resopt;
    return res;
  }
}

// build a kill node.
static assn_t kill(assn_t a) {
  switch (a) {
  case &True: 
  case &False:
  case &Kill(_): return a; // Kill(Kill(a)) = Kill(a)
  default:
    let p = Kill(a);
    return hash_cons(&p);
  }
}

// build an and node.
static assn_t and(assn_t a1, assn_t a2) {
  if (a1 == a2) return a1;
  switch $(a1,a2) {
  case $(&True,_): return a2;
  case $(_,&True): return a1;
  case $(&False,_): return a1;
  case $(_,&False): return a2;
  default: 
    // Sort the two operands so that we're more likely to share.
    // Note that we could do more than this and, for instance,
    // right-associate and's but this doesn't seem to be a win.
    if ((int)a1 > (int)a2)
      a1 :=: a2;
    let a = And(a1,a2);
    return hash_cons(&a);
  }
}

// build an or-node.
static assn_t or(assn_t a1, assn_t a2) {
  if (a1 == a2) return a1;
  switch $(a1,a2) {
  case $(&True,_): return a1;
  case $(_,&True): return a2;
  case $(&False,_): return a2;
  case $(_,&False): return a1;
  default: 
    // sort the operands and hash-cons.
    if ((int)a1 > (int)a2)
      a1 :=: a2;
    let a = Or(a1,a2);
    return hash_cons(&a);
  }
}

// build a lazy substitution node.  
static assn_t subst(vardecl_t x, term_t newx, assn_t a) {
  switch (a) {
  case &True:
  case &False: return a;
  default:
    let p = Subst(x,newx,a); 
    return hash_cons(&p);
  }
}

// build a primitive relation node.
static assn_t prim(term_t t1, prim_reln_t p, term_t t2) {
  let ptr = Prim(t1,p,t2);
  return hash_cons(&ptr);
}

// some macros and functions for particular primitive relations.
#define prim_assn(p,P) static assn_t p(term_opt_t t1, term_opt_t t2) { \
  if (t1 == NULL || t2 == NULL) return &true_assn; \
  return prim((term_t)t1,P,(term_t)t2); \
}
prim_assn(eq,Eq)
prim_assn(neq,Neq)
prim_assn(slt,SLt)
prim_assn(slte,SLte)
prim_assn(ult,ULt)
prim_assn(ulte,ULte)
#define sgte(t1,t2) (slte(t2,t1))
#define ugte(t1,t2) (ulte(t2,t1))
#define sgt(t1,t2) (slt(t2,t1))
#define ugt(t1,t2) (ult(t2,t1))

// forward declaration 
static assn_t reduce(assn_t a);

// compute negation of assertion -- unfortunately requires
// reducing the assertion (i.e., getting rid of Subst and Kill
// nodes.)
static assn_t not(assn_t a) {
  switch (a) {
  case &True: return &false_assn;
  case &False: return &true_assn;
  case &And(a1,a2): return or(not(a1),not(a2));
  case &Or(a1,a2): return and(not(a1),not(a2));
  case &Prim(t1,p,t2):
    switch (p) {
    case Eq : return neq(t1,t2);
    case Neq: return eq(t1,t2);
    case SLt : return sgte(t1,t2);
    case SLte: return sgt(t1,t2);
    case ULt : return ugte(t1,t2);
    case ULte: return ugt(t1,t2);
    default: Tcutil::impos("Vcgen::invert: non-primop");
    }
  case &Subst(...): return not(reduce(a));
  case &Kill(...): return not(reduce(a));
  }
}

////// Push Through Subst and Kill nodes ////
// These functions take care of eliminating all of the Kill and
// Subst nodes in an assertion in one pass.  It is, unfortunately,
// something that requires crawling over the tree, not just the dag.
// However, we could improve things by memoizing the results, since
// it's likely that we'll hit the same substitutions for various
// assertion nodes.  The problem is that we will generally have
// different environments built up when we run into them.

// Both reduce_term and reduce_assn take in a substitution for 
// non-escaping variables, as well as a pointer to a substitution
// for escaping variables.  We want to reduce Kill(a) to something
// like substitute fresh logic variables for each escaping variable
// in a.  We do this by accumulating a substitution for the escaping
// variables as we go.  So, the esc_subst pointer is non-NULL when
// we are under a Kill node.

// TRY: we could try using dictionaries here instead of lists.
static term_t 
reduce_term(term_t t, list_t<$(vardecl_t,term_t)@`H,`H> non_esc_subst,
            list_t<$(vardecl_t,term_t)@`H,`H> *esc_subst) {
  switch (t) {
  case &Const(_):
  case &LogicVar(...): return t;
  case &Cast(tp,tm):
    let tm2 = reduce_term(tm,non_esc_subst,esc_subst);
    if (tm != tm2) return cast(tp,tm2);
    else return t;
  case &Primop(p,ts):
    list_t<term_t> res = NULL;
    bool change = false;
    for (let ptr = ts; ptr != NULL; ptr = ptr->tl) {
      let old_term = ptr->hd;
      let new_term = reduce_term(old_term,non_esc_subst,esc_subst);
      res = new List{new_term,res};
      if (new_term != old_term) change = true;
    }
    if (!change) return t;
    return primop(p,imp_rev(res));
  case &Var(vd):
    if (vd->escapes && esc_subst != NULL) {
      // it's an escaping variable and we're under a Kill node.
      // see if we've already assigned it a fresh variable in the esc_subst.
      let s = *esc_subst;
      for (; s != NULL; s = s->tl) {
        let $(vd2,t2) = *s->hd;
        if (vd2 == vd) return t;
      }
      // if not, then assign it a fresh variable and record it in the
      // esc_subst.
      let t = fresh_var();
      *esc_subst = new List{new $(vd,t),*esc_subst};
      return fresh_var();
    } else if (!vd->escapes) {
      // it's a non-escaping variable -- look it up in non_esc_subst.
      for (; non_esc_subst != NULL; non_esc_subst = non_esc_subst->tl) {
        let $(vd2,t2) = *non_esc_subst->hd;
        if (vd == vd2) return t2;
      }
    }
    return t;
  }
}

static assn_t 
reduce_assn(assn_t a, list_t<$(vardecl_t,term_t)@`H,`H> non_esc_subst, 
            list_t<$(vardecl_t,term_t)@`H,`H> *esc_subst) {
 LOOP:
  switch (a) {
  case &True:
  case &False: return a;
  case &Prim(t1,p,t2):
    let newt1 = reduce_term(t1,non_esc_subst,esc_subst);
    let newt2 = reduce_term(t2,non_esc_subst,esc_subst);
    if (t1 == newt1 && t2 == newt2) return a;
    return prim(newt1,p,newt2);
  case &And(a1,a2):
    let newa1 = reduce_assn(a1,non_esc_subst,esc_subst);
    let newa2 = reduce_assn(a2,non_esc_subst,esc_subst);
    if (a1 == newa1 && a2 == newa2) return a;
    return and(newa1,newa2);
  case &Or(a1,a2):
    let newa1 = reduce_assn(a1,non_esc_subst,esc_subst);
    let newa2 = reduce_assn(a2,non_esc_subst,esc_subst);
    if (a1 == newa1 && a2 == newa2) return a;
    return or(newa1,newa2);
  case &Kill(a): 
    // start a new esc_subst for a.  not sure this is necessary
    // when esc_subst is non-null...
    list_t<$(vardecl_t,term_t)@> new_esc_subst = NULL;
    return reduce_assn(a,non_esc_subst,&new_esc_subst);
  case &Subst(vd,t,a1):
    // add vd->t to the non_esc_subst
    t = reduce_term(t,non_esc_subst,esc_subst);
    non_esc_subst = new List(new $(vd,t),non_esc_subst);
    a = a1;
    goto LOOP;
  }
}

// get rid of all Kill and Subst nodes.
static assn_t reduce(assn_t a) {
  // check to see if we've already eliminated them.
  if (is_reduced(a)) return a;
  return reduce_assn(a,NULL,NULL);
}

// a one-shot substitution -- needed in the assignment code below.
static term_t subst_term(term_t t, vardecl_t x, term_t newx) {
  switch (t) {
  case &Var(vd):
    if (vd == x) return newx;
    return t;
  case &Primop(p,ts):
    list_t<term_t> res = NULL;
    bool change = false;
    for (let ptr = ts; ptr != NULL; ptr = ptr->tl) {
      let old_term = ptr->hd;
      let new_term = subst_term(old_term,x,newx);
      res = new List{new_term,res};
      if (new_term != old_term) change = true;
    }
    if (!change) return t;
    return primop(p,imp_rev(res));
  case &Cast(tp,tm):
    let tm2 = subst_term(tm,x,newx);
    if (tm != tm2) return cast(tp,tm2);
    else return t;
  case &Const(_):
  case &LogicVar(...): return t;
  }
}

// an eager kill for terms (we don't bother to do terms lazily, only assns)
static term_t kill_mem_term(term_t t) {
  let esc_subst = NULL;
  return reduce_term(t,NULL,&esc_subst);
}


/////////////////// Assertion Factoring //////////////////
// This code isn't currently used but may be useful.  The
// basic idea is to try to pull the common conjuncts out
// to a wider scope.  Eg..,  (A & B & C) || (A & D & C) 
// should factor into (A & C) & (B || D).  

// intersect two lists of assertions returning the common
// assertions, and the remainders of the two lists.  Assumes
// the assertions are in sorted order.
static void intersect(list_t<assn_t,`H> a1s, list_t<assn_t,`H> a2s, 
                      list_t<assn_t,`H>@common,
                      list_t<assn_t,`H>@res1,
                      list_t<assn_t,`H>@res2) {
  while (true) {
    switch $(a1s,a2s) {
    case $(NULL,NULL): return;
    case $(_,NULL): *res1 = List::revappend(a1s,*res1); return;
    case $(NULL,_): *res2 = List::revappend(a2s,*res2); return;
    default: 
      int c = assncmp(a1s->hd,a2s->hd);
      if (c == 0) {
        *common = new List(a1s->hd,*common);
        a1s = a1s->tl;
        a2s = a2s->tl;
      } else if (c < 0) {
        *res1 = new List(a1s->hd,*res1);
        a1s = a1s->tl;
      } else {
        *res2 = new List(a2s->hd,*res2);
        a2s = a2s->tl;
      }
    }
  }
}

static $(list_t<assn_t> common, list_t<assn_t> res1, list_t<assn_t> res2) 
  intersect_assns(list_t<assn_t,`H> a1s, list_t<assn_t,`H> a2s) {
  let common = NULL;
  let res1 = NULL;
  let res2 = NULL;
  intersect(a1s,a2s,&common,&res1,&res2);
  return $(List::imp_rev(common),List::imp_rev(res1),List::imp_rev(res2));
}

// pull out the common primitive relations, but avoid duplicating
// things in forming the full cross-product
static $(list_t<assn_t>,assn_t) factor(assn_t a) {
  switch (a) {
  case &True: return $(NULL,&true_assn);
  case &False: return $(NULL,&false_assn);
  case &Prim(...): return $(new List{a,NULL},&true_assn);
  case &And(a1,a2):
    let $(c1s,a1) = factor(a1);
    let $(c2s,a2) = factor(a2);
    return $(List::merge(assncmp,c1s,c2s),and(a1,a2));
  case &Or(a1,a2):
    let $(c1s,a1) = factor(a1);
    let $(c2s,a2) = factor(a2);
    let $(cs,c1s,c2s) = intersect_assns(c1s,c2s);
    return $(cs,or(List::fold_left(and,a1,c1s),List::fold_left(and,a2,c2s)));
  default: return $(NULL,a);
  }
}

static assn_t factor_assn(assn_t a) {
  //unsigned int asize = assn_size(a);
  let $(cs,a) = factor(a);
  a = List::fold_left(and,a,cs);
  //unsigned int newsize = assn_size(a);
  //fprintf(stderr,"factor before %d after %d\n",asize,newsize);
  //fprintf(stderr,"%s\n",assn2string(a));
  return a;
}


////////// Syntactic Implication for Assertions //////////////
// returns true when ctxt |- t1 p t2
// uses only very local, syntactic matching.
static bool find_ctxt(assn_t ctxt, term_t t1, prim_reln_t p1, term_t u1) {
 LOOP:
  switch (ctxt) {
  case &False: return true;
  case &True: return false;
  case &And(a1,a2): 
    if (find_ctxt(a1,t1,p1,u1)) return true;
    ctxt = a2;
    goto LOOP;
  case &Or(a1,a2): 
    if (!find_ctxt(a1,t1,p1,u1)) return false;
    ctxt = a2;
    goto LOOP;
  case &Prim(t2,p2,u2):
    switch $(p2,p1) {
    case $(Neq,Neq):
    case $(Eq,Eq): 
    case $(Eq,SLte):
    case $(Eq,ULte):
      return (same_term(t1,t2) && same_term(u1,u2) ||
              same_term(t1,u2) && same_term(u1,t2));
    case $(SLt,Neq): 
    case $(ULt,Neq): 
      return (same_term(t1,t2) && same_term(u1,u2) ||
              same_term(t1,u2) && same_term(u1,t2));
    case $(SLt,SLt):
    case $(ULt,ULt):
    case $(SLt,SLte): 
    case $(ULt,ULte): 
    case $(SLte,SLte):
    case $(ULte,ULte):
      return same_term(t1,t2) && same_term(u1,u2);
    default: return false;
    }
  default: 
    ctxt = reduce(ctxt);
    goto LOOP;
  }
}

// returns true when ctxt |- a
// uses only very local, syntactic matching.
static bool simple_prove(assn_t ctxt, assn_t a) {
 LOOP:
  if (ctxt == a) return true;
  switch (a) {
  case &True: return true;
  case &False: return false;
  case &And(a1,a2): 
    if (!simple_prove(ctxt,a1)) return false;
    a = a2;
    goto LOOP;
  case &Or(a1,a2): 
    if (simple_prove(ctxt,a1)) return true;
    a = a2;
    goto LOOP;
  case &Prim(t1,p,t2): return find_ctxt(ctxt,t1,p,t2); 
  default: 
    a = reduce(a);
    goto LOOP;
  }
}


//////////////////// Constraint Solving //////////////////
// We use a variation of the Pratt algorithm here where we keep
// track of a distance between terms and find the minimal length path
// between any two terms.  If we ever get a negative-length cycle,
// then the constraints are inconsistent.  
//
// We represent a conjunction of constraints as a sparse matrix of
// the distances.  We consider distance(i,j) == 0 implicitly, and
// otherwise, if (i,j) are not in the graph, the distance is infinite.
//
// To deal with an entire assertion, we must collect a set of graphs.
// representing alternative states.  This effectively converts the 
// assertion to DNF which is an exponential blowup.  To avoid running
// out of time or memory, we limit the blowup according to the
// variable max_paths.

typedef struct Distance {
  struct Distance *next;  // ptr to next entry in sparse matrix
  term_t t1;
  term_t t2;
  int    dist;
} *distance_t;

typedef struct Graph {
  struct Graph *next;    // ptr to next graph in disjunction
  list_t<term_t> nodes;
  distance_t distance;
} graph_t;

// print out a set of graphs
static void print_graphs(graph_t* gs) {
  fprintf(stderr,"Graphs:\n");
  for (; gs != NULL; gs = gs->next) {
    fprintf(stderr,"\t{");
    for (let ds = gs->distance; ds != NULL; ds = ds->next) {
      fprintf(stderr,"%s - %s <= %d",term2string(ds->t1),term2string(ds->t2),
              ds->dist);
      if (ds->next != NULL) fprintf(stderr,",");
    }
    fprintf(stderr,"}\n");
  }
}

// determine the number of graphs
static unsigned int num_graphs(graph_t *`H gs) {
  unsigned n = 0;
  for (; gs != NULL; gs = gs->next)
    ++n;
  return n;
}

// represents "true" -- a singleton graph with no edges (everything
// is infinitely far apart.)
static graph_t @true_graph() { return new Graph{NULL,NULL,NULL};}

// used in copying of graphs
static distance_t copy_distance(distance_t ds) {
  distance_t res = NULL;
  for (; ds != NULL; ds = ds->next) {
    res = new Distance{res,ds->t1,ds->t2,ds->dist};
  }
  return res;
}

// copies a whole set of graphs -- used when we have a disjunction
static graph_t *copy_graph(graph_t * g) {
  graph_t *res = NULL;
  for (; g != NULL; g = g->next) {
    res = new Graph{res,g->nodes,copy_distance(g->distance)};
  }
  return res;
}

// appends to sets of graphs -- could be smarter and try to remove
// duplicates...
static graph_t *graph_append(graph_t *`H g1, graph_t *`H g2) {
  if (g1 == NULL) return g2;
  if (g2 == NULL) return g1;
  graph_t @p = g1;
  for (let x = p->next; x != NULL; p = x, x=p->next) /* skip */ ;
  p->next = g2;
  return g1;
}

// add a node to a single graph if not already present
static void add_node(graph_t @g, term_t n) {
  if (!List::mem(cmp_term,g->nodes,n))
    g->nodes = new List{n,g->nodes};
}

// lookup the distance between two nodes in the graph -- returns NULL
// if the distance is infinite.
static int* lookup_distance(graph_t @g, term_t i, term_t j) {
  static int zero = 0;
  if (cmp_term(i,j) == 0) return &zero; // same term always at distance 0
  for (let ds = g->distance; ds != NULL; ds = ds->next) {
    if (cmp_term(i,ds->t1) == 0 && cmp_term(j,ds->t2) == 0) return &ds->dist;
  }
  return NULL;
}

// add an edge to a graph and close it off to find shortest paths.
// returns true if the resulting graph remains consistent and false
// otherwise.
static bool add_edge(graph_t @g, term_t i, term_t j, int dist) {
  add_node(g,i);
  add_node(g,j);
  int* ij_dist = lookup_distance(g,i,j);
  // if we already have a shorter path, then this constraint is redundant
  if (ij_dist != NULL && *ij_dist < dist) 
    return true;
  int* ji_dist = lookup_distance(g,j,i);
  // if  j -n-> i -dist-> j  and n+dist is negative, we have a contradiction.
  if (ji_dist != NULL && (*ji_dist + dist) < 0)
    return false; 
  // update shortest path for each pair of nodes
  for (let ks = g->nodes; ks != NULL; ks = ks->tl) {
    let k = ks->hd;
    let ki_dist = lookup_distance(g,k,i);
    if (ki_dist == NULL) continue;
    for (let ls = g->nodes; ls != NULL; ls = ls->tl) {
      let l = ls->hd;
      let jl_dist = lookup_distance(g,j,l);
      if (jl_dist != NULL) {
        let kl_dist = lookup_distance(g,k,l);
        let new_dist = *ki_dist + dist + *jl_dist;
        if (kl_dist == NULL) {
          g->distance = new Distance{g->distance,k,l,new_dist};
        } else if (*kl_dist > new_dist) {
          *kl_dist = new_dist;
        }
      }
    }
  }
  return true;
}

// convert a primitive assertion to a constraint and add it to the graph.
// returns true if the resulting graph remains consistent, false otherwise.
static bool add_constraint(graph_t @g, term_t t1, prim_reln_t p, term_t t2) {
  // FIX:  we need to do a lot more here, ranging from taking constants
  // into account, to dealing with the signed/unsigned issue.
  switch (p) {
  case Eq:
    // add t1 - t2 <= 0 and t2 - t1 <= 0
    if (!add_edge(g,t1,t2,0)) return false;
    return add_edge(g,t2,t1,0);
  case ULt:
    // add t1 - t2 <= -1
    return add_edge(g,t1,t2,-1);
  case ULte:
    // add t1 - t2 <= 0
    return add_edge(g,t1,t2,0);
  case SLt:
  case SLte: 
    // for now, we can't do anything about these
    return true;
  default: Tcutil::impos("Vcgen:found bad primop in add_constraint");
  }
}

datatype exn { TooLarge };
datatype exn.TooLarge too_large = TooLarge;

//FIX: add a way for the user to control this.
unsigned int max_paths = 33;
unsigned int max_paths_seen = 0;

// given a set of graphs gs representing A1 or A2 or ... or An
// and given assertion a, compute the set of graphs representing
// (A1 or A2 ... or An) and a.  This is written with explicit
// tail-calls to be as fast as possible.  If we end up with two
// many disjuncts, then we throw an exception to back out of the
// whole thing.  
static graph_t *cgraph(graph_t *`H gs, assn_t a) {
 LOOP:
  if (gs == NULL) return gs; // already inconsistent
  switch (a) {
  case &True: break;         // gs and true == gs
  case &False: gs = NULL; break; // gs and false == false
  case &And(a1,a2): 
    gs = cgraph(gs,a2);  // gs and (a1 and a2) == (gs and a2) and a1
    a = a1;
    goto LOOP;
  case &Or(a1,a2):
    unsigned int n = num_graphs(gs);
    if (max_paths_seen < n) max_paths_seen = n;
    // too many disjuncts -- give up.  
    if (n >= max_paths) throw &too_large; // could just set gs = true_graph(); 
    // must copy the graphs since we mutate them in place
    graph_t *gs1 = gs;
    graph_t *gs2 = copy_graph(gs);
    // compute (gs and a1)
    gs1 = cgraph(gs1,a1);
    // compute (gs and a2)
    gs2 = cgraph(gs2,a2);
    // return (gs and a1) or (gs and a2)
    gs = graph_append(gs1,gs2);
    break;
  case &Prim(t1,Neq,t2): 
    // must handle neq specially as t1 < t2 or t2 < t1.
    a = or(ult(t1,t2),ult(t2,t1));
    goto LOOP;
  case &Prim(t1,p,t2):
    // add the primitive relation to each graph, pruning out the
    // inconsistent ones.
    graph_t *prev = NULL;
    for (let g = gs; g != NULL; g = g->next) {
      if (!add_constraint(g,t1,p,t2)) {
        if (prev == NULL) {
          gs = g->next;
        } else {
          prev->next = g->next;
        }
      } else {
        prev = g;
      }
    }
    break;
  default: 
    // reduce any substitutions and go around the loop.
    a = reduce(a);
    goto LOOP;
  }
  // return the set of graphs
  return gs;
}

// check to see if an assertion is consistent using the constraint solver.
// if it returns false, then the assertion is definitely inconsistent.
// if it returns true, then the assertion might be consistent.
static bool consistent(assn_t a) {
  try {
    // start with just an empty graph (true) and then add in a
    graph_t ?gs = cgraph(true_graph(),a);
    // if we get back an empty list of disjuncts (false) then
    // the graph is not consistent.
    return (gs != NULL);
  } catch {
    // if the graph has too many paths in it, we'll end up here.
    // we must conservatively assume that the assertion is consistent.
  case &TooLarge: return true;
  }
}

// see if ctxt |- a by trying to prove that ctxt and not(a) is inconsistent.
static bool constraint_prove(assn_t ctxt, assn_t a) {
  assn_t b = and(ctxt,not(a));
  return !consistent(b);
}

// returns true if a2 is provable from a1 (i.e., a1 |- a2)
// tries simple_prove first and then tries the constraint solver
static bool implies_noreduce(assn_t a1, assn_t a2) {
  return simple_prove(a1,a2) || constraint_prove(a1,a2);
}

// same as above but as a side effect, reduces the caller's
// assertions.
static bool implies(assn_t @a1, assn_t @a2) {
  *a1 = reduce(*a1);
  *a2 = reduce(*a2);
  return implies_noreduce(*a1,*a2);
}

////////// Widening for Assertions ////////////////////

// We want to find an assertion a' such that ctxt => a' and a => a'.
// (so or(ctxt,a) => a'.)  In addition, we want a' to have size less
// than or equal to a.  
static assn_t weaken_it(assn_t ctxt, assn_t a) {
  if (simple_prove(ctxt,a)) return a;
  assn_t res;
  switch (a) {
  case &And(a1,a2):
    let b1 = weaken_it(ctxt,a1);            // IH: ctxt=>b1 & a1=>b1
    let b2 = weaken_it(ctxt,a2);            // IH: ctxt=>b2 & a2=>b2
    //if (implies_noreduce(b1,b2)) return b1;
    //if (implies_noreduce(b2,b1)) return b2;
    res = and(b1,b2);                   // ctxt => b1&b2  a1&a2=> b1&b2
    break;
  case &Or(a1,a2):
    let b1 = weaken_it(a2,a1);           // a1=>b1 & a2=>b1
    let b2 = weaken_it(a1,a2);           // a2=>b2 & a1=>b2
    res = weaken_it(ctxt,and(b1,b2));  // ctxt=>c  b1&b2=>c  a1|a2=>b1&b2
    break;
  case &True: 
  case &False: 
  case &Prim(...): 
    res = &true_assn;
    break;
  default: return weaken_it(ctxt, reduce(a));
  }
  return res;
}

// We are given assertions A1 and A2 and would like to find
// the strongest assertion A such that A1 implies A and
// A2 implies A.  However, we would like to also ensure that
// A is "smaller" than A2.  The widen operation ensures that
// either we get back A2 or else the assertion is smaller
// (or as a technical hitch, we flip once from false to true.)
static assn_t weaken_assn(assn_t ctxt, assn_t a) {
  if (implies(&ctxt,&a)) return a;
  return weaken_it(ctxt,a);
}

////////// Updating an Assertion //////////////////
static term_t fresh_nonescvar(env_t env, vardecl_t vd);

// We are executing tgt := src
static assn_t do_assign(env_t env, assn_t a, term_opt_t tgt, term_opt_t src) {
  switch (tgt) {
  case NULL: 
    // We don't know what the target is except that it's not a non-escaping
    // variable, so we must kill those references.
    return kill(a);
  case &Var(vd):
    // We know what the target is -- if it escapes then we kill all 
    // escaping variables, otherwise we just kill the target vd by
    // substituting a fresh logic variable.
    // We must make sure to also kill within the src term.
    if (vd->escapes) {
      a = kill(a);
      src = (src == NULL) ? NULL : kill_mem_term(src);
    } else {
      let v2 = fresh_nonescvar(env,vd);
      a = subst(vd,v2,a);
      src = (src == NULL) ? NULL : subst_term(src,vd,v2);
    }
    // Finally, add in tgt == src.
    return and(a,eq(tgt,src));
  default: Tcutil::impos("vcgen do_assign");
  }
}

///////////////////// Analysis /////////////////////

////////// Analysis Environment /////////////////////
struct SharedEnv {
  // a mapping from statements to accumulated pre-conditions 
  Hashtable::table_t<stmt_t,assn_t@> assn_table;
  // a mapping for successors in the control-flow graph (from jump_analysis)
  Hashtable::table_t<stmt_t,stmt_opt_t> succ_table;
  // the assertion accumulated for the current exception handler
  assn_t try_assn;
  // when not-null is used to record the resulting value of an expr-stmt.
  term_opt_t* exp_stmt;
  // used to record the result terms and assertions for a function
  term_opt_t  res_term;
  assn_t      res_assn;
};

typedef Dict::dict_t<vardecl_t,int> state_counter_t;

struct Env {
  struct SharedEnv @shared;
  // A clever idea from Yanling for simulating SSA:
  // For non-escaping variables, we keep a state counter so that when
  // we kill a variable on two separate paths, we retain some sharing
  // for the old values.  For instance, if we have:
  //     [x==0 && x==y] if (c) { x := 4; } else { x := 5; }
  // then we want to end up killing x with the same variable _x0 
  // upon each update so that we get on output:
  // ([_x0==0 && _x0==y && c && x == 4] ||[_x0==0 && _x0==y && !c && x == 5])
  // This will make it easier to collapse this into:
  //  [_x0==0 && _x0==y && (c && x == 4 || !c && x == 5)]
  state_counter_t state_counter;
};

static int hash_ptr(`a s) { return (int)s; }

static env_t 
initial_env(JumpAnalysis::jump_anal_res_t tables, Absyn::fndecl_t fd) {
  let succ_table = Hashtable::lookup(tables->succ_tables,fd);
  let assn_table = Hashtable::create(57, Core::ptrcmp, hash_ptr);
  let senv =  new SharedEnv{.assn_table = assn_table,
                            .succ_table = succ_table,
                            .try_assn = &false_assn,
                            .exp_stmt = NULL,
                            .res_term = NULL,
                            .res_assn = &false_assn};
  let d = Dict::empty(Core::ptrcmp);
  return new Env { .shared = senv, .state_counter = d };
}

static env_t copy_env(env_t env) {
  return new(*env);
}

// we have to merge environments at a join-point to get the
// next in a sequence.
static int max_counter(int dummy, vardecl_t vd, int i, int j) {
  return (i < j) ? j : i;
}

static void merge_env(env_t old_env, env_t new_env) {
  old_env->state_counter = Dict::union_two_c(max_counter, 0, 
                                             old_env->state_counter, 
                                             new_env->state_counter);
}

// generate a fresh logic variable for a non-escaping variable --
// the next one in a sequence.
static term_t fresh_nonescvar(env_t env, vardecl_t vd) {
  int res = 0;
  Dict::lookup_bool(env->state_counter,vd,&res);
  env->state_counter = Dict::insert(env->state_counter,vd,res+1);
  return new LogicVar(vd,res);
}

// each statement may have an assertion associated with it from
// other incoming edges -- we must take into account all paths.
static assn_t pre_stmt_update(env_t env, stmt_t s, assn_t ain) {
  let popt = Hashtable::lookup_opt(env->shared->assn_table,s);
  if (popt != NULL) {
    assn_t @p = *popt;
    let new_precondition = or(ain,*p);
    *p = new_precondition;
    return new_precondition;
  } else 
    return ain;
}

// get the pre-condition currently associated with a statement.
static assn_t@ get_assn(env_t env, stmt_t s) {
  static assn_t false_pointer = &false_assn;
  assn_t @* popt = Hashtable::lookup_opt(env->shared->assn_table,s);
  if (popt != NULL)
    return *popt;
  else
    return &false_pointer;
}

// similar to pre_stmt_update except that we use widen instead of or
// since this is part of a loop back-edge.
static assn_t loop_assn(env_t env, stmt_t s, assn_t ain) {
  assn_t @* aprevopt = Hashtable::lookup_opt(env->shared->assn_table,s);
  if (aprevopt != NULL) {
    let aprev = *aprevopt;
    ain = weaken_assn(ain,*aprev);
    *aprev = ain;
  } else {
    Hashtable::insert(env->shared->assn_table,s,new ain);
  }
  return ain;
}

// similar to pre_stmt_update but makes sure to put the
// result on the statement.
static assn_t forward_assn(env_t env, stmt_t s, assn_t ain) {
  assn_t@* aprevopt = Hashtable::lookup_opt(env->shared->assn_table,s);
  if (aprevopt != NULL) {
    let aprev = *aprevopt;
    ain = or(ain,*aprev);
    *aprev = ain;
  } else {
    Hashtable::insert(env->shared->assn_table,s,new ain);
  }
  return ain;
}

// update the assertion associated with the current 
// exception handler.
static void update_try_assn(env_t env, assn_t a) {
  env->shared->try_assn = or(env->shared->try_assn,a);
}

// update the return information for a function
static void update_return(env_t env, term_opt_t t, assn_t a) {
  let shared = env->shared;
  if (shared->res_term != NULL || t != NULL) {
    let v = fresh_var();
    shared->res_term = v;
    shared->res_assn = 
      or(and(a,eq(v,t)),and(shared->res_assn,eq(v,shared->res_term)));
  } else {
    shared->res_assn = or(a,shared->res_assn);
  }
}

// forward declarations for the analysis functions.

// Vcgen for statements.  ain is an assertion describing the state
// on input to the statement, and this returns an assertion describing 
// the output state. 
static assn_t vcgen_stmt_nodebug(env_t env, stmt_t s, assn_t ain);
// Analyze a term given precondition ain and generate an optional term
// and post-condition representing the value of the expression and
// the resulting machine state.
static $(term_opt_t,assn_t) vcgen_rexp_nodebug(env_t env, exp_t e, assn_t ain);
// If the term is "undefined" then we return a fresh variable.
static $(term_t,assn_t) vcgen_rexp_always(env_t env, exp_t e, assn_t ain);
// Same as above, but for lhs-expressions.
static $(term_opt_t,assn_t) vcgen_lexp(env_t env, exp_t e, assn_t ain);
// Analyze a test expression returning two assertions corresponding
// to the test succeeding (true-case) or failing (false-case).
static $(assn_t t,assn_t f) vcgen_test(env_t env, exp_t e, assn_t ain);
// Analyze a list of expressions returning an optional list of
// terms and the output assertion.  If any of the expressions'
// is unknown, then so is the whole thing.
static $(list_t<term_t>*,assn_t) vcgen_rexps(env_t env, list_t<exp_t> es, assn_t a);
// Similar to above but here we don't care what the resulting terms
// are at all.
static assn_t vcgen_rexps_nosave(env_t env, list_t<exp_t> es, assn_t a);
// Folds vcgen_rexp_always across the list.
static $(list_t<term_t>,assn_t) vcgen_rexps_always(env_t env, list_t<exp_t> es, assn_t ain);
// Do vcgen for all of the cases in a switch.  
static assn_t vcgen_switch(env_t env, list_t<switch_clause_t> scs, assn_t ain);
// Do vcgen for a local declaration
static assn_t vcgen_local_decl(env_t env, decl_t d, assn_t a);

static string_t stmt2shortstring(stmt_t s) {
  switch (s->r) {
  case &Absyn::IfThenElse_s(e,...): 
    return aprintf("if (%s) ...",Absynpp::exp2string(e));
  case &Absyn::While_s($(e,_),_):
    return aprintf("while (%s) ...",Absynpp::exp2string(e));
  case &Absyn::For_s(e1,$(e2,_),$(e3,_),_):
    return aprintf("for (%s;%s;%s) ...",Absynpp::exp2string(e1),
                   Absynpp::exp2string(e2),Absynpp::exp2string(e3));
  case &Absyn::Switch_s(e,...): 
    return aprintf("switch (%s) ...",Absynpp::exp2string(e));
  case &Absyn::Do_s(_,$(e,_)):
    return aprintf("do ... while (%s)",Absynpp::exp2string(e));
  case &Absyn::TryCatch_s(s,...): 
    return aprintf("try %s catch ...",stmt2shortstring(s));
  case &Absyn::Seq_s(s,...): return stmt2shortstring(s);
  default: 
    let s = Absynpp::stmt2string(s);
    unsigned max = numelts(s) < 11 ? numelts(s) : 11;
    char ?@nozeroterm res = malloc(sizeof(char)*max);
    for (int i = 0; i < max-1; i++)
      res[i] = s[i];
    return aprintf("%s...",res);
  }
}

#ifdef VCGEN_DEBUG
#define vcgen_rexp(env,e,a) vcgen_rexp_debug(env,e,a)
#define vcgen_stmt(env,s,a) vcgen_stmt_debug(env,s,a)
static unsigned int indent = 0;
static void print_tabs() {
  for (unsigned i = indent; i > 0; i--)
    fprintf(stderr," ");
}
static assn_t vcgen_stmt_debug(env_t env, stmt_t s, assn_t ain) {
  switch (s->r) {
  case &Absyn::Seq_s(_,_): 
  case &Absyn::Decl_s(...):
    //case &Absyn::Exp_s(...):
  case &Absyn::Skip_s: return vcgen_stmt_nodebug(env,s,ain);
  default:
    print_tabs();
    let str = assn2string(ain);
    fprintf(stderr,"stmt %s pre(%d/%d)=%s\n",stmt2shortstring(s),assn_size(ain),tree_size,str);
    indent += 2;
    let aout = vcgen_stmt_nodebug(env,s,ain);
    indent -= 2;
    print_tabs();
    let str = assn2string(aout);
    fprintf(stderr,"stmt %s, post(%d/%d)=%s\n",stmt2shortstring(s),assn_size(aout),tree_size,str);
    return aout;
  }
}
static $(term_opt_t,assn_t) vcgen_rexp_debug(env_t env, exp_t e, assn_t ain) {
  print_tabs();
  fprintf(stderr,"exp %s, pre=%s\n",Absynpp::exp2string(e),assn2string(ain));
  indent += 2;
  let $(t,a) = vcgen_rexp_nodebug(env,e,ain);
  indent -= 2;
  print_tabs();
  fprintf(stderr,"exp %s ==> %s, post: %s\n",Absynpp::exp2string(e),
          ((t == NULL) ? "?" : term2string((term_t)t)), assn2string(ain));
  return $(t,a);
}

#else
#define vcgen_rexp(env,e,a) vcgen_rexp_nodebug(env,e,a)
#define vcgen_stmt(env,s,a) vcgen_stmt_nodebug(env,s,a)
#endif

// To simplify things, I'm treating the control-flow as if it were
// structured.  Upon reaching a labelled statement, I set the pre-
// condition to "True" which is conservative.   This lets me do
// local iteration for loops and so forth to generate invariants,
// since the only back-edges in the simplified graph are always
// part of the control constructs.  
static assn_t vcgen_stmt_nodebug(env_t env, stmt_t s, assn_t ain) {
  // merge the pre-condition with any pre-recorded assertions.
  // we'll have one if there was some control-flow to this statement.
 LOOP:
  ain = pre_stmt_update(env,s,ain);
  //assn_size(ain);
  // don't bother analyzing if we can show the assertion is false
  // (effectively an unreachable state.)
  switch (ain) {
  case &False: return ain;
  default: break;
  }
  switch (s->r) {
  case &Absyn::Skip_s: return ain;
  case &Absyn::Exp_s(e): 
    let $(t,aout) = vcgen_rexp(env,e,ain);
    // a little trickery to deal with statement expressions -- we
    // record the result in the environment here.
    if (env->shared->exp_stmt != NULL) 
      *(env->shared->exp_stmt) = t;
    return aout;
  case &Absyn::Seq_s(s1,s2): 
    ain = vcgen_stmt(env,s1,ain);
    s = s2;
    goto LOOP;
  case &Absyn::Return_s(NULL): 
    update_return(env,NULL,ain);
    return &false_assn;
  case &Absyn::Return_s(e as &_): 
    let $(t,aout) = vcgen_rexp(env,(exp_t)e,ain);
    update_return(env,t,aout);
    return &false_assn;
  case &Absyn::IfThenElse_s(e1,s1,s2):
    let $(at,af) = vcgen_test(env,e1,ain);
    let env2 = copy_env(env);
    at = vcgen_stmt(env,s1,at);
    af = vcgen_stmt(env2,s2,af);
    merge_env(env,env2);
    return or(at,af);
  case &Absyn::While_s($(e,dummy),s):
    // we're doing local iteration here -- we join with the
    // assertion on the dummy and widen each time around the loop since
    // its assertion will be updated by a continue.  We disallow
    // goto's in the analysis by essentially forcing their destination's
    // assertion to be true.
    while (true) {
      ain = loop_assn(env,dummy,ain);
      let $(at,af) = vcgen_test(env,e,ain);
      ain = vcgen_stmt(env,s,at);
      if (implies(&ain,get_assn(env,dummy))) return af;
    } 
  case &Absyn::Continue_s: fallthru;
    // continue is a backwards jump in a loop, but we take
    // that into account as part of the loop iteration.
    let dest = Hashtable::lookup(env->shared->succ_table,s);
    loop_assn(env, (stmt_t)dest, ain);
    return &false_assn;
  case &Absyn::Break_s:
    // break is a forwards jump so we can do an Or.  This assertion
    // that we set on the destination will be picked up when we hit
    // that statement.  
    let dest = Hashtable::lookup(env->shared->succ_table,s);
    if (dest == NULL) 
      update_return(env,NULL,ain);
    else 
      forward_assn(env, (stmt_t)dest, ain);
    return &false_assn;
  case &Absyn::For_s(e1,$(e2,dummy2),$(e3,dummy3),s):
    let $(_,a) = vcgen_rexp(env,e2,ain);
    ain = a;
    // similar to while loop.
    while (true) {
      ain = loop_assn(env,dummy2,ain);
      let $(at,af) = vcgen_test(env,e2,ain);
      ain = vcgen_stmt(env,s,at);
      // must do pre-statement check because continue goes here
      ain = pre_stmt_update(env,dummy3,ain);
      ain = vcgen_rexp(env,e3,ain)[1];
      if (implies(&ain,get_assn(env,dummy2))) return af;
    }
  case &Absyn::Do_s(s,$(e,dummy)):
    // similar to while loop
    while (true) {
      ain = vcgen_stmt(env,s,ain);
      let $(at,af) = vcgen_test(env,e,ain);
      ain = weaken_assn(*get_assn(env,dummy),ain);
      if (implies(&ain,get_assn(env,dummy))) return af;
      loop_assn(env,dummy,ain);
    }
  case &Absyn::Switch_s(e,scs,_):
    // FIX: take into acount test of e
    // note that we do not split the state counter for a switch
    // because a fallthru might lead to problems.  if we merged
    // environments at entry points of control-flow paths, then
    // we could handle this.
    let $(t,a) = vcgen_rexp(env,e,ain);
    return vcgen_switch(env,scs,a);
  case &Absyn::Fallthru_s(_,NULL): Tcutil::impos("vcgen fallthru");
  case &Absyn::Fallthru_s(es,&dest):
    // Also a forward jump so we can do an or.
    let $(ts,a) = vcgen_rexps_always(env,es,ain);
    // initialize the pattern variables with their corresponding terms
    for (let x = dest->pat_vars->v; x != NULL; x = x->tl,ts = ts->tl) {
      let &$(vd,ve) = x->hd;
      if (vd != NULL) 
        a = do_assign(env,a,new Var(*vd),ts->hd);
    }
    forward_assn(env, dest->body, a);
    return &false_assn;
  case &Absyn::Decl_s(d,s1):
    ain = vcgen_local_decl(env,d,ain);
    s = s1;
    goto LOOP;
  case &Absyn::Label_s(_,s): 
    // by making the assertion True here, we're effectively losing
    // all information when we do a goto.  This is conservative, 
    // and means that I don't have to worry about non-structured
    // control-flow.
    return vcgen_stmt(env,s,&true_assn);
  case &Absyn::Goto_s(_): return &false_assn; // see above
  case &Absyn::TryCatch_s(s,scs,_):
    // save old try/catch-handler assertion
    let old_try_assn = env->shared->try_assn;
    // install new try/catch-handler assertion
    env->shared->try_assn = &false_assn;
    // run vcgen on the body -- this will update the env->shared->try_assn 
    // with assertions of any state that might throw an exn.
    ain = vcgen_stmt(env,s,ain);
    // restore the old handler's assertion.
    let new_try_assn = env->shared->try_assn;
    env->shared->try_assn = old_try_assn;
    // analyze the catch handlers and merge with the body to get
    // the final output.
    return or(ain,vcgen_switch(env,scs,new_try_assn));
  }
}

static assn_t vcgen_switch(env_t env, list_t<switch_clause_t> scs, assn_t ain) {
  // note that all of the clauses should explicitly jump (via break)
  // or something else outside of the clause so the result should always
  // be false...
  assn_t res = &false_assn;
  for (; scs != NULL; scs = scs->tl) {
    let sc = scs->hd;
    let a = ain;
    for (let pvs = sc->pat_vars->v; pvs != NULL; pvs = pvs->tl) {
      let &$(vdopt,eopt) = pvs->hd;
      if (vdopt != NULL) {
        if (eopt != NULL)
          a = do_assign(env,a,new Var(*vdopt),vcgen_rexp(env,(exp_t)eopt,a)[0]);
        else 
          a = do_assign(env,a,new Var(*vdopt),fresh_var());
      }
    }
    if (sc->where_clause != NULL) 
      a = vcgen_test(env, (exp_t)sc->where_clause, a)[0];
    res = or(res,vcgen_stmt(env,sc->body,a));
  }
  return res;
}

static assn_t add_vardecl(env_t env, vardecl_t vd, assn_t a) {
  // stupid C semantics means I have to put in a dummy value for vd first,
  // then run the initializer.  
  let tv = new Var(vd);
  a = do_assign(env,a,tv,fresh_var());
  if (vd->initializer != NULL) {
    let $(t,a1) = vcgen_rexp(env,(exp_t)vd->initializer,a);
    a = do_assign(env,a1,tv,t);
  }
  return a;
}

static assn_t vcgen_local_decl(env_t env, decl_t d, assn_t a) {
  switch (d->r) {
  case &Absyn::Var_d(vd): return add_vardecl(env,vd,a);
  case &Absyn::Let_d(p,vds,e,_): 
    let $(_,a) = vcgen_rexp(env,e,a);
    for (let vds = vds->v; vds != NULL; vds = vds->tl) {
      let $(vdopt,eopt) = *vds->hd;
      if (vdopt != NULL) {
        if (eopt == NULL) a = add_vardecl(env,*vdopt,a);
        else {
          let $(t,a1) = vcgen_rexp(env,e,a);
          let tv = new Var(*vdopt);
          a = do_assign(env,a1,tv,t);
        }
      }
    }
    return a;
  case &Absyn::Letv_d(vds): 
    for (; vds != NULL; vds = vds->tl)
      a = add_vardecl(env,vds->hd,a);
    return a;
  case &Absyn::Region_d(_,vd,eopt): 
    if (eopt != NULL) {
      let $(t,a1) = vcgen_rexp(env,(exp_t)eopt,a);
      a = a1;
    }
    // FIX: inaccurate but okay for now.
    a = add_vardecl(env,vd,a);
    return a;
  default: return a;
  }
}

// determine whether a comparing these two expressions is an 
// unsigned or a signed comparison.
static bool unsigned_comparison(exp_t e1, exp_t e2) {
  let t1 = Tcutil::compress((type_t)e1->topt);
  let t2 = Tcutil::compress((type_t)e2->topt);
  switch $(t1,t2) {
  case $(&Absyn::AppType(&Absyn::IntCon(Absyn::Unsigned,_),_),_): return true;
  case $(_,&Absyn::AppType(&Absyn::IntCon(Absyn::Unsigned,_),_)): return true;
  case $(&Absyn::PointerType(_),&Absyn::PointerType(_)): return true;
  default: return false;
  }
}

static $(assn_t,assn_t) vcgen_test(env_t env, exp_t e, assn_t ain) {
  switch (e->r) {
  case &Absyn::Conditional_e(e1,e2,e3):
    let $(a1t,a1f) = vcgen_test(env,e1,ain);
    let $(a2t,a2f) = vcgen_test(env,e2,a1t);
    let $(a3t,a3f) = vcgen_test(env,e3,a1f);
    return $(or(a2t,a3t),or(a2f,a3f));
  case &Absyn::And_e(e1,e2):
    let $(a1t,a1f) = vcgen_test(env,e1,ain);
    let $(a2t,a2f) = vcgen_test(env,e2,a1t);
    return $(a2t, or(a1f,a2f));
  case &Absyn::Or_e(e1,e2):
    let $(a1t,a1f) = vcgen_test(env,e1,ain);
    let $(a2t,a2f) = vcgen_test(env,e2,a1f);
    return $(or(a1t,a2t),a2f);
  case &Absyn::SeqExp_e(e1,e2):
    let $(_,ain) = vcgen_rexp(env,e1,ain);
    return vcgen_test(env,e2,ain);
  case &Absyn::Primop_e(Absyn::Not,&List(e1,_)):
    let $(at,af) = vcgen_test(env,e1,ain);
    return $(af,at);
  case &Absyn::Primop_e(p,&List(e1,&List(e2,NULL))):
    let $(t1,a1) = vcgen_rexp(env,e1,ain);
    let $(t2,a2) = vcgen_rexp(env,e2,a1);
    let at = a2;
    let af = a2;
    switch p {
    case Absyn::Eq:  at = and(at,eq(t1,t2));  af = and(af,neq(t1,t2)); break;
    case Absyn::Neq: at = and(at,neq(t1,t2)); af = and(af,eq(t1,t2)); break;
    case Absyn::Lt:
      if (unsigned_comparison(e1,e2)) {
        at = and(at,ult(t1,t2));  af = and(af,ugte(t1,t2)); 
      } else {
        at = and(at,slt(t1,t2));  af = and(af,sgte(t1,t2)); 
      }
      break;
    case Absyn::Lte: 
      if (unsigned_comparison(e1,e2)) {
        at = and(at,ulte(t1,t2)); af = and(af,ugt(t1,t2)); 
      } else {
        at = and(at,slte(t1,t2)); af = and(af,sgt(t1,t2)); 
      }
      break;
    case Absyn::Gt:  
      if (unsigned_comparison(e1,e2)) {
        at = and(at,ugt(t1,t2));  af = and(af,ulte(t1,t2)); 
      } else {
        at = and(at,sgt(t1,t2));  af = and(af,slte(t1,t2)); 
      }
      break;
    case Absyn::Gte: 
      if (unsigned_comparison(e1,e2)) {
        at = and(at,ugte(t1,t2)); af = and(af,ult(t1,t2)); 
      } else {
        at = and(at,sgte(t1,t2)); af = and(af,slt(t1,t2)); 
      }
      break;
    default: break;
    }
    return $(at,af);
  default:
    let $(t,aout) = vcgen_rexp(env,e,ain);
    return $(and(aout,neq(t,zero())),and(aout,eq(t,zero())));
  }
}

static assn_t vcgen_rexps_nosave(env_t env, list_t<exp_t> es, assn_t a) {
  for (; es != NULL; es = es->tl) 
    a = vcgen_rexp(env,es->hd,a)[1];
  return a;
}

static $(list_t<term_t>*,assn_t) vcgen_rexps(env_t env, list_t<exp_t> es, assn_t a) {
  list_t<term_t> res = NULL;
  bool valid = true;
  for (; es != NULL; es = es->tl) {
    let $(t,aout) = vcgen_rexp(env,es->hd,a);
    a = aout;
    if (valid && t != NULL) {
      res = new List{(term_t)t,res};
    } else {
      valid = false;
    }
  }
  return $(valid ? new (imp_rev(res)) : NULL, a);
}

static $(term_t,assn_t) vcgen_rexp_always(env_t env, exp_t e, assn_t ain) {
  let $(topt,a) = vcgen_rexp(env,e,ain);
  return $(topt == NULL ? fresh_var() : (term_t)topt, a);
}

static $(list_t<term_t>,assn_t) vcgen_rexps_always(env_t env, list_t<exp_t> es, assn_t ain) {
  list_t<term_t> res = NULL;
  for (; es != NULL; es = es->tl) {
    let $(t,a) = vcgen_rexp_always(env,es->hd,ain);
    ain = a;
    res = new List(t,res);
  }
  return $(res,ain);
}

static vardecl_t bind2vardecl(Absyn::binding_t b) {
  switch (b) {
  case &Absyn::Global_b(vd): return vd;
  case &Absyn::Funname_b(fd): return (vardecl_t)fd->fn_vardecl;
  case &Absyn::Unresolved_b(...): Tcutil::impos("vcgen bind2vardecl");
  case &Absyn::Param_b(vd): return vd;
  case &Absyn::Local_b(vd): return vd;
  case &Absyn::Pat_b(vd): return vd;
  }
}

static $(term_opt_t,assn_t) vcgen_lexp(env_t env, exp_t e, assn_t ain) {
  switch (e->r) {
  case &Absyn::Var_e(b): 
      return $(new Var(bind2vardecl(b)),ain);
  default: return $(NULL, vcgen_rexp(env,e,ain)[1]);
  }
}

// extract the arguments, requires, and ensures clause for a function from
// its type.
static $(list_t<$(var_opt_t,tqual_t,type_t)@> args, exp_opt_t req, exp_opt_t ens, vardecl_opt_t ret_value) get_requires_and_ensures_info(Absyn::fn_info_t @fi) {
  return $(fi->args,fi->requires_clause,fi->ensures_clause,fi->return_value);
}

static $(list_t<$(var_opt_t,tqual_t,type_t)@> args, exp_opt_t req, exp_opt_t ens, vardecl_opt_t ret_value) get_requires_and_ensures(type_opt_t topt) {
  if (topt != NULL) {
    type_t t = Tcutil::pointer_elt_type((type_t)topt);
    switch (t) {
    case &Absyn::FnType(*fi): return get_requires_and_ensures_info(fi);
    default: break;
    }
  } 
  return $(NULL,NULL,NULL,NULL);
}

static void check_requires(env_t env, list_t<term_t> inputs,
                           list_t<$(var_opt_t,tqual_t,type_t)@> args,
                           assn_t a, exp_opt_t reqopt) {
  if (reqopt != NULL) {
    exp_t req = (exp_t)reqopt;
    // pretend like we're assigning the actual values to the parameter
    // values
    for (; args != NULL && inputs != NULL; args = args->tl, inputs = inputs->tl) {
      let &$(vopt,tq,t) = args->hd;
      if (vopt != NULL) {
        // have to fake up a vardecl
        Absyn::qvar_t qv = new $(Absyn::Loc_n,(Absyn::var_t)vopt);
        let vd = new Absyn::Vardecl {.sc = Absyn::Public,
                                     .name = qv,.varloc = 0,.tq = tq,
                                     .type = t,.initializer = NULL,
                                     .rgn = NULL,.attributes = NULL,
                                     .escapes = false, .is_proto=false};
          a = and(a,eq(new Var(vd),inputs->hd));
        }
    }
    // FIX? varargs.
    let $(at,_) = vcgen_test(env,(exp_t)reqopt,&true_assn);
    if (!implies(&a,&at))
      Warn::err(req->loc, "cannot prove @requires %s from %s",
                assn2string(reduce(at)), assn2string(reduce(a)));
  }
}

static term_opt_t deref_lterm(env_t env, term_opt_t lt, assn_t ain) {
  return lt;
}

static $(term_opt_t,assn_t) vcgen_rexp_nodebug(env_t env, exp_t e, assn_t ain) {
  if (Tcutil::is_const_exp(e)) return $(cnst(e),ain);
  switch (e->r) {
  case &Absyn::Const_e(c): 
    // should really be caught by the above...
    return $(new Const(e),ain);
  case &Absyn::Var_e(b): return $(new Var(bind2vardecl(b)),ain);
  case &Absyn::Primop_e(p,es):
    let $(ts,aout) = vcgen_rexps(env,es,ain);
    term_opt_t t = NULL;
    if (ts != NULL) t = primop(p,*ts);
    return $(t, aout);
  case &Absyn::AssignOp_e(e1,popt,e2):
    let $(lt,a1) = vcgen_lexp(env,e1,ain);
    let $(t2,a2) = vcgen_rexp(env,e2,a1);
    if (popt != NULL) {
      let t1 = deref_lterm(env,lt,a2);
      if (t1 == NULL || t2 == NULL) 
        t2 = NULL;
      else
        t2 = primop(popt->v,list((term_t)t1,(term_t)t2));
    }
    let a = do_assign(env,a2,lt,t2);
    return $(lt,a);
  case &Absyn::Increment_e(e,i):
    let $(lt,a1) = vcgen_lexp(env,e,ain);
    let t1 = deref_lterm(env,lt,a1);
    term_opt_t res = NULL;
    term_opt_t assn = NULL;
    switch (i) {
    case Absyn::PreInc: 
      if (t1 != NULL) assn = primop(Absyn::Plus,list((term_t)t1,one()));
      res = assn;
      break;
    case Absyn::PostInc:
      res = t1;
      if (t1 != NULL) assn = primop(Absyn::Plus,list((term_t)t1,one()));
      break;
    case Absyn::PreDec:
      if (t1 != NULL) assn = primop(Absyn::Minus,list((term_t)t1,one()));
      res = assn;
      break;
    case Absyn::PostDec:
      res = t1;
      if (t1 != NULL) assn = primop(Absyn::Minus,list((term_t)t1,one()));
      break;
    default: Tcutil::impos("vcgen vcgen_rexp increment_e");
    }
    let a = do_assign(env,a1,lt,assn);
    return $(res,a);
  case &Absyn::Conditional_e(e1,e2,e3):
    let $(at,af) = vcgen_test(env,e1,ain);
    let $(t1,at) = vcgen_rexp(env,e2,at);
    let $(t2,af) = vcgen_rexp(env,e3,af);
    if (t1 != NULL && t2 != NULL) {
      let v = fresh_var();
      at = and(at,eq(v,t1));
      af = and(af,eq(v,t2));
      return $(v,or(at,af));
    } else
      return $(NULL,or(at,af));
  case &Absyn::And_e(e1,e2):
    let $(at,af) = vcgen_test(env,e1,ain);
    let $(t,at) = vcgen_rexp(env,e2,at);
    let v = fresh_var();
    at = and(at,eq(v,t));
    af = and(af,eq(v,zero()));
    return $(v,or(at,af));
  case &Absyn::Or_e(e1,e2):
    let $(at,af) = vcgen_test(env,e1,ain);
    let $(t,af) = vcgen_rexp(env,e2,af);
    let v = fresh_var();
    at = and(at,eq(v,one()));
    af = and(af,eq(v,t));
    return $(v,or(at,af));
  case &Absyn::SeqExp_e(e1,e2):
    let $(_,a) = vcgen_rexp(env,e1,ain);
    return vcgen_rexp(env,e2,a);
  case &Absyn::FnCall_e(e,es,...):
    let $(ts,a) = vcgen_rexps_always(env,es,ain);
    let $(_,a2) = vcgen_rexp(env,e,a);
    // check @requires clause on function
    let $(args,reqopt,ensopt,ret_value) = get_requires_and_ensures(e->topt);
    check_requires(env,ts,args,a2,reqopt);
    // kill every variable that points into memory -- could refine
    // this to only those reachable from globals or the parameters.
    a2 = kill(a2);
    update_try_assn(env,a2);
    // noreturn functions don't return...
    if (Tcutil::is_noreturn_fn_type((type_t)e->topt)) a2 = &false_assn;
    if (ensopt == NULL) 
      return $(NULL,a2);
    exp_t ensures = (exp_t)ensopt;
    // add in the @ensures clause for the result
    let $(at,_) = vcgen_test(env,ensures,a2);
    if (ret_value != NULL) {
      let v = fresh_var();
      // FIX: substitute ts for formal parameters
      at = subst((vardecl_t)ret_value,v,at);
      return $(v,at);
    } 
    return $(NULL,at);
  case &Absyn::Throw_e(e,_):
    let $(_,a) = vcgen_rexp(env,e,ain);
    update_try_assn(env,a);
    return $(NULL,&false_assn);
  case &Absyn::NoInstantiate_e(e): return vcgen_rexp(env,e,ain);
  case &Absyn::Instantiate_e(e,_):  return vcgen_rexp(env,e,ain);

  case &Absyn::Cast_e(tp,e,_,c): 
    // FIX: really need to put C coercions in terms...
    let $(t,a) = vcgen_rexp(env,e,ain);
    if (c == Absyn::No_coercion)
      return $(t == NULL ? NULL : cast(tp,t),a);
    else {
      update_try_assn(env,ain); // coercion could fail
      return $(NULL,a);
    }
  case &Absyn::New_e(eopt,e):
    if (eopt != NULL)
      ain = vcgen_rexp(env,(exp_t)eopt,ain)[1];
    return $(NULL,vcgen_rexp(env,e,ain)[1]);

  // these cases should be captured by the const-expression check above.
  case &Absyn::Enum_e(...):
  case &Absyn::AnonEnum_e(...):
  case &Absyn::Sizeoftype_e(_):
  case &Absyn::Sizeofexp_e(_):
  case &Absyn::Valueof_e(_):
  case &Absyn::Offsetof_e(_,_): return $(NULL,ain);

  // These can all throw exceptions
  case &Absyn::Deref_e(e): fallthru(e);
  case &Absyn::AggrMember_e(e,...): fallthru(e);
  case &Absyn::AggrArrow_e(e,...):
    ain = vcgen_rexp(env,e,ain)[1];
    update_try_assn(env,ain);
    return $(NULL,ain);

  case &Absyn::Tagcheck_e(e,_): fallthru(e);
  case &Absyn::Address_e(e): 
    return $(NULL,vcgen_rexp(env,e,ain)[1]);

  case &Absyn::Subscript_e(e1,e2): 
    let $(t1,a1) = vcgen_rexp(env,e1,ain);
    let $(t2,a2) = vcgen_rexp(env,e2,a1);
    switch (Tcutil::compress((type_t)e1->topt)) {
    case &Absyn::TupleType(_): break;
    default:
      if (t1 != NULL) {
        update_try_assn(env,ain);
        a2 = and(a2,ult(t2,primop(Absyn::Numelts,list(t1))));
      }
    }
    return $(NULL,a2);

  case &Absyn::Datatype_e(es,...): fallthru(es);
  case &Absyn::Tuple_e(es): return $(NULL,vcgen_rexps_nosave(env,es,ain));

  case &Absyn::CompoundLit_e(_,dles):   fallthru(dles);
  case &Absyn::Array_e(dles):           fallthru(dles);
  case &Absyn::Aggregate_e(_,_,dles,_): fallthru(dles);
  case &Absyn::UnresolvedMem_e(_,dles): fallthru(dles);
  case &Absyn::AnonStruct_e(_,dles):
    for (; dles != NULL; dles = dles->tl) {
      let &$(_,e) = dles->hd;
      ain = (vcgen_rexp(env,e,ain))[1];
    }
    return $(NULL,ain);

  case &Absyn::Comprehension_e(vd,e1,e2,_): 
    // similar to a while-loop except we evaluate e1 only once.
    let $(t1,a) = vcgen_rexp(env,e1,ain);
    let t1 = (t1 == NULL) ? fresh_var() : (term_t)t1;
    let v = new Var(vd);
    // start off with index 0
    a = do_assign(env,a,v,zero());
    while (true) {
      let at = and(a,ult(v,t1));  // simulate test
      let af = and(a,ugte(v,t1));
      let $(_,abody) = vcgen_rexp(env,e2,at);  // run body and add one
      abody = do_assign(env,abody,v,primop(Absyn::Plus,list(v,one())));
      if (implies(&abody,&a)) { a = af; break; }
      a = weaken_assn(abody,a);  // widen and possibly iterate
    }
    return $(NULL,a);
  case &Absyn::ComprehensionNoinit_e(e,_,_):
    return $(NULL,vcgen_rexp(env,e,ain)[1]);
  case &Absyn::Malloc_e(mi):
    if (mi.rgn != NULL) 
      ain = vcgen_rexp(env,(exp_t)mi.rgn,ain)[1];
    return $(NULL,vcgen_rexp(env,mi.num_elts,ain)[1]);
  case &Absyn::Swap_e(e1,e2): 
    let $(lt1,a1) = vcgen_lexp(env,e1,ain);
    update_try_assn(env,a1); // could have null-exn?
    let $(lt2,a2) = vcgen_lexp(env,e2,a1);
    update_try_assn(env,a2); // could have null-exn?
    let t1 = deref_lterm(env,lt1,a2);
    let t2 = deref_lterm(env,lt2,a2);
    a2 = do_assign(env,a2,lt1,t2);
    a2 = do_assign(env,a2,lt2,t1);
    return $(NULL,a2);
  case &Absyn::StmtExp_e(s):
    let old_exp_stmt = env->shared->exp_stmt;
    env->shared->exp_stmt = new NULL;
    let aout = vcgen_stmt(env,s,ain);
    let t = *(env->shared->exp_stmt);
    env->shared->exp_stmt = old_exp_stmt;
    return $(t,aout);
  case &Absyn::Asm_e(...): return $(NULL,ain);
  case &Absyn::Extension_e(e): return vcgen_rexp(env,e,ain);
  case &Absyn::Pragma_e(s): 
    if (strcmp(s,"print_assn")) {
      let seg_str = Position::string_of_segment(e->loc);
      fprintf(stderr,"%s: current assn is %s\n",seg_str,assn2string(ain));
    }
    return $(zero(),ain);
  case &Absyn::Assert_e(e1):
    let $(at,_) = vcgen_test(env,e1,&true_assn);
    if (!implies(&ain,&at)) 
      Warn::err(e->loc, "cannot prove @assert from %s",
                assn2string(reduce(ain)));
    return $(one(),and(ain,at));
  }
}

// FIX? take into account top-level (const) variable intializers?
void vcgen_topdecls(JumpAnalysis::jump_anal_res_t tables, list_t<Absyn::decl_t> ds) {
  for (; ds != NULL; ds = ds->tl) {
    switch (ds->hd->r) {
    case &Absyn::Fn_d(fd):
      //fprintf(stderr,"Vcgen function %s\n",Absynpp::qvar2string(fd->name));
      //fprintf(stderr,"---------------------------------------\n");
      let env = initial_env(tables,fd);
      assn_t a = &true_assn;
      // put in the requires clause as an assumption.
      let $(args,reqopt,ensopt,ret_value) = get_requires_and_ensures_info(&fd->i);
      if (reqopt != NULL) {
        // hope the vards in here point to the vardecls in the fn...
        a = vcgen_test(env,(exp_t)reqopt,a)[0];
      }
      vcgen_stmt(env,fd->body,a);
      // check the requires clause
      if (ensopt != NULL) {
        exp_t ens = (exp_t)ensopt;
        let $(at,_) = vcgen_test(env,ens,&true_assn);
        let senv = env->shared;
        let res_assn_opt = senv->res_assn;
        assn_t res_assn = &false_assn;
        if (res_assn_opt != NULL) res_assn = ((assn_t)res_assn_opt);
        string_t str = "NULL";
        if (senv->res_term != NULL) str = term2string((term_t)senv->res_term);
        if (ret_value != NULL && senv->res_term) 
          res_assn = and(res_assn,eq(new Var((vardecl_t)ret_value),senv->res_term));
        if (!implies(&res_assn,&at))
          Warn::err(ens->loc, "cannot prove the @ensures clause %s from %s",
                    assn2string(reduce(at)),assn2string(reduce(res_assn)));
      }
      hash_cons_table = NULL; // collect table
      break;
    case &Absyn::Namespace_d(_,ds): fallthru(ds);
    case &Absyn::Using_d(_,ds): vcgen_topdecls(tables,ds); break;
    default: break;
    }
  }
  //fprintf(stderr,"max_paths_seen = %d\n",max_paths_seen);
}
