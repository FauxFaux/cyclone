/* Computing Strongest Post-conditions
   Copyright (C) 2003 Greg Morrisett
   This file is part of the Cyclone compiler.

   The Cyclone compiler is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   The Cyclone compiler is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with the Cyclone compiler; see the file COPYING. If not,
   write to the Free Software Foundation, Inc., 59 Temple Place -
   Suite 330, Boston, MA 02111-1307, USA. */

/* What we are doing here is computing a pre/post-condition in a forwards
   fashion for each statement and expression within a function.  The 
   assertion language is very simple: equality and inequality over
   terms, disjunction, and conjunction (no quantifiers).  The terms
   include what we consider to be "constant" expressions in Cyclone,
   primops of terms, program variables, and logical variables.  

   There's an extremely simple, essentially syntactic prover that is
   used to show implications.  There's also an extremely simple strategy
   for generating loop invariants.  The trickyness is in ensuring
   that the iterative analysis terminates.  In essence, each time
   around a loop, we're guaranteeing that we get a smaller (in terms
   of total node count) assertion.  The worst case is we fall back to "true".

   To keep the analysis simple and somewhat structured, we essentially
   punt on goto's.  More properly, whenever we hit a labelled statement,
   we reset the incoming pre-condition to "true".  This allows me to
   do purely local iteration for calculating the assertions.  To handle
   other non-local edges (e.g., break, continue, throw) we essentially
   pile up assertions on the statement and OR them in with the natural
   flow's pre-condition.  

   Also to keep the analysis simple, we punt on alias analysis.  Variables 
   have a flag indicating whether or not they escape syntactically.
   When updating an escaping variable, we essentially "kill" all 
   escaping variables.  The same happens for a function call.  This is
   *not* thread-safe.  To achieve that, we would have to kill all escaping
   things after each step. 

   We use hash-consing to try to get maximal sharing among 
   assertion nodes.  Maintaining sharing is crucial for avoiding
   an exponential space blow up.  I've experimented with lazy
   substitution as well, but this didn't seem to work that well.

   There are a lot of ways we should improve this analysis and a few
   things that need to be fixed:

   * We need to extend terms to account for casts/coercions.
   * We need to make a distinction between signed and unsigned comparisons.
   * We need to take pre/post-conditions of functions into account.
   * We need to add @assert(-) expressions so that users can write their
     own static assertions.  The hope would be that these could be used to
     find smarter loop invariants or to collapse down a big disjunction.
   * We need to have a "throttle" for controlling assertion size.  Sooner
     or later we will run into iterated if's/diamond control-flow patterns
     that will result in a zillion disjunctions.  Although we share the
     resulting assertions, the theorem prover needs some way to avoid
     crawling over the assertion as if it's a tree.

   * We should use the Pratt constraint solver where possible.
   * We should take pattern matching tests into account for a switch.
   * We shouldn't kill unique variables.
   * We should only kill "type-compatible" expressions on an update.

   * We should make the simple thm. prover a bit smarter.
   * We should perhaps try to simplify the assertions to remove
     redundancies?
   * We should add support for more predicates and relations (e.g.,
     track whether x == null, or tagcheck(x.f), or datatype tags, etc.)?
   * Could have user-defined predicates...
   * If we knew that a goto was forward, then we could deal with it...
   */
#include "vcgen.h"
#include "absynpp.h"
#include "tcutil.h"
#include "evexp.h"
#include <hashtable.h>
#include <dict.h>
#include <string.h> 
#include <cycboot.h> 

//#define VCGEN_DEBUG

namespace Vcgen;
using List;
typedef Absyn::type_t type_t;
typedef Absyn::vardecl_t vardecl_t;
typedef Absyn::vardecl_opt_t vardecl_opt_t;
typedef Absyn::exp_t exp_t;
typedef Absyn::decl_t decl_t;
typedef Absyn::stmt_t stmt_t;
typedef Absyn::stmt_opt_t stmt_opt_t;
typedef Absyn::switch_clause_t switch_clause_t;
////// Forward Declaration for Environments /////
struct Env;
typedef struct Env @env_t;

///////////////////// Terms /////////////////////
typedef datatype Term @term_t, *term_opt_t;

datatype Term {
  Const(exp_t);  // a Cyclone "constant" expression
  Var(vardecl_t);
  LogicVar(vardecl_opt_t,int);
  Primop(Absyn::primop_t,list_t<term_t>);
};

string_t term2string(term_t t) {
  switch (t) {
  case &Const(c): return Absynpp::exp2string(c);
  case &Var(vd): return Absynpp::qvar2string(vd->name);
  case &LogicVar(NULL,i): return aprintf("_X%d",i);
  case &LogicVar(vd,i): return aprintf("_%s%d",Absynpp::qvar2string(vd->name),i);
  case &Primop(p,&List{t1,&List{t2,NULL}}): 
    return aprintf("(%s%s%s)",term2string(t1),
                   Absynpp::prim2string(p),term2string(t2));
  case &Primop(p,&List{t,_}):
    return aprintf("%s(%s)",Absynpp::prim2string(p),term2string(t));
  default: Tcutil::impos("term2string primop args");
  }
}

term_t cnst(Absyn::exp_t c) { return new Const(c); }
term_t zero() {
  static term_opt_t z = NULL;
  if (z == NULL) {
    let e = Absyn::int_exp(Absyn::None,0,0);
    e->topt = Absyn::int_type(Absyn::None,Absyn::Int_sz);
    let r = cnst(e);
    z = r;
    return r;
  } else return (term_t)z;
}
term_t one() {
  static term_opt_t z = NULL;
  if (z == NULL) {
    let e = Absyn::int_exp(Absyn::None,1,0);
    e->topt = Absyn::int_type(Absyn::None,Absyn::Int_sz);
    let r = cnst(e);
    z = r;
    return r;
  } else return (term_t)z;
}
  
term_t var(vardecl_t vd) { return new Var(vd); }
term_t primop(Absyn::primop_t p, list_t<term_t,`H> ts) {
  return new Primop(p,ts);
}
term_t fresh_var() {
  static int counter = 0;
  return new LogicVar(NULL,counter++);
}

bool same_term(term_t t1, term_t t2) {
  switch $(t1,t2) {
  case $(&Const(c1),&Const(c2)): return Evexp::same_const_exp(c1,c2);
  case $(&Var(vd1),&Var(vd2)): return (vd1 == vd2);
  case $(&LogicVar(vd1,i),&LogicVar(vd2,j)): return (vd1 == vd2) && (i == j);
  case $(&Primop(p1,ts1),&Primop(p2,ts2)):
    if (p1 != p2) return false;
    for (; ts1 != NULL && ts2 != NULL; ts1=ts1->tl,ts2=ts2->tl) {
      if (!same_term(ts1->hd,ts2->hd)) return false;
    }
    if (ts2 != NULL || ts1 != NULL) return false;
    return true;
  default: return false;
  }
}

// HACK -- need to produce a proper term comparison
int termcmp(term_t t1, term_t t2) {
  if (same_term) return 0;
  return (int)t1 - (int)t2;
}

///////////////////// Assertions /////////////////////
typedef datatype Assn @assn_t;

typedef enum Primreln { Eq, Neq, Lt, Lte } prim_reln_t;

datatype Assn {
  True;
  False;
  Prim(term_t,prim_reln_t,term_t);
  And(assn_t,assn_t);
  Or(assn_t,assn_t);
};

unsigned int assn_size_loop(assn_t a, unsigned int c, list_t<assn_t,`H>@ prev){
  if (memq(*prev,a)) return c;
  *prev = new List(a,*prev);
  switch (a) {
  case &True:  return c;
  case &False: return c;
  case &Prim(...): return 1+c;
  case &And(a1,a2): fallthru(a1,a2);
  case &Or(a1,a2): 
    return assn_size_loop(a1,assn_size_loop(a2,1+c,prev),prev);
  }
}

static unsigned int max_assn_size = 0;

unsigned int assn_size(assn_t a) {
  list_t<assn_t,`H> prev = NULL;
  let c = assn_size_loop(a,0,&prev);
  if (c > max_assn_size) {
    max_assn_size = c;
    fprintf(stderr,"Max Assn Size = %d\n",max_assn_size);
  }
  return c;
}

string_t a2string(assn_t a, int prec, int@ size) {
  switch (a) {
  case &True: return "true";
  case &False: return "false";
  case &Prim(t1,p,t2):
    *size += 1;
    string_t ps;
    switch (p) {
    case Eq: ps = "=="; break;
    case Neq: ps = "!="; break;
    case Lt: ps = "<"; break;
    case Lte: ps = "<="; break;
    default: Tcutil::impos("assn2string primop");
    }
    return aprintf("%s%s%s",term2string(t1),ps,term2string(t2));
  case &Or(a1,a2): 
    *size += 1;
    if (prec <= 5)
      return aprintf("%s || %s",a2string(a1,5,size),a2string(a2,5,size));
    else 
      return aprintf("(%s || %s)",a2string(a1,5,size),a2string(a2,5,size));
  case &And(a1,a2): 
    *size += 1;
    return aprintf("%s && %s",a2string(a1,10,size),a2string(a2,10,size));
  }
}

static int tree_size = 0;

string_t assn2string(assn_t a) {
  tree_size = 0;
  return a2string(a,0,&tree_size);
}

datatype Assn.True true_assn = True;
datatype Assn.False false_assn = False;

//////////////////////////////////////////////////////////////
// hash-consing to try to preserve as much sharing as we
// can -- has a nice impact on performance (much better than
// lazy substitution), but alas, we still end up allocating a lot.  
// It would be better if we didn't have to allocate the thing 
// that want to lookup.  That could happen if we had a different 
// type for hashtable lookup (as we did with dictionaries.)

// FIX: need a good hash function...
int assnhash(datatype Assn @a) {
  switch (a) {
  case &False: return 0;
  case &True: return 1;
  case &Prim(t1,p,t2): 
    return (unsigned int)t1 ^ (unsigned int)p ^ (unsigned int)t2;
  case &And(a1,a2): return (unsigned int)a1 ^ (unsigned int)a2;
  case &Or(a1,a2): return ((unsigned int)a1 ^ (unsigned int)a2) | 1;
  }
}

int assncmp(datatype Assn @a1, datatype Assn @a2) {
  if (a1 == a2) return 0;
  switch $(a1,a2) {
  case $(&True,&True): return 0;
  case $(&True,_): return -1;
  case $(_,&True): return 1;
  case $(&False,&False): return 0;
  case $(&False,_): return -1;
  case $(_,&False): return 1;
  case $(&Or(a11,a12),&Or(a21,a22)): fallthru(a11,a12,a21,a22);
  case $(&And(a11,a12),&And(a21,a22)): 
    int c = assncmp(a11,a21);
    if (c != 0) return c;
    return assncmp(a12,a22);
  case $(&Or(_,_),_): return -1;
  case $(_,&Or(_,_)): return 1;
  case $(&And(_,_),_): return -1;
  case $(_,&And(_,_)): return 1;
  case $(&Prim(t11,p1,t12),&Prim(t21,p2,t22)):
    int c = (int)p1 - (int)p2;
    if (c != 0) return c;
    c = termcmp(t11,t21);
    if (c != 0) return c;
    return termcmp(t12,t22);
  }
}

static struct Hashtable::Table<assn_t,assn_t> *hash_cons_table = NULL;

assn_t copy_assn(datatype Assn@`r a){
  switch (a) {
  case &True: return &true_assn;
  case &False: return &false_assn;
  case &And(a1,a2): return new And(a1,a2);
  case &Or(a1,a2): return new Or(a1,a2);
  case &Prim(t1,p,t2): return new Prim(t1,p,t2);
  }
}

assn_t hash_cons(datatype Assn@`r a) {
  Hashtable::table_t h;
  if (hash_cons_table == NULL) {
    h = Hashtable::create(123, assncmp, assnhash);
    hash_cons_table = h;
  } else 
    h = (Hashtable::table_t)hash_cons_table;
  let resopt = Hashtable::lookup_other_opt(h,a,assncmp,assnhash);
  if (resopt == NULL) {
    assn_t res = copy_assn(a);
    Hashtable::insert(h,res,res);
    return res;
  } else return *resopt;
}

// try to maintain maximal sharing through hash consing.
// i tried sorting and right-associating, but that chews
// up more time than not.  
assn_t and(assn_t a1, assn_t a2) {
  if (a1 == a2) return a1;
  switch $(a1,a2) {
  case $(&True,_): return a2;
  case $(_,&True): return a1;
  case $(&False,_): return a1;
  case $(_,&False): return a2;
  default: 
    if ((int)a1 > (int)a2)
      a1 :=: a2;
    let a = And(a1,a2);
    return hash_cons(&a);
  }
}

assn_t or(assn_t a1, assn_t a2) {
  if (a1 == a2) return a1;
  switch $(a1,a2) {
  case $(&True,_): return a1;
  case $(_,&True): return a2;
  case $(&False,_): return a2;
  case $(_,&False): return a1;
  default: 
    if ((int)a1 > (int)a2)
      a1 :=: a2;
    let a = Or(a1,a2);
    return hash_cons(&a);
  }
}

assn_t prim(term_t t1, prim_reln_t p, term_t t2) {
  let ptr = Prim(t1,p,t2);
  return hash_cons(&ptr);
}

#define prim_assn(p,P) assn_t p(term_opt_t t1, term_opt_t t2) { \
  if (t1 == NULL || t2 == NULL) return &true_assn; \
  return prim((term_t)t1,P,(term_t)t2); \
}
prim_assn(eq,Eq)
prim_assn(neq,Neq)
prim_assn(lt,Lt)
prim_assn(lte,Lte)
#define gte(t1,t2) (lte(t2,t1))
#define gt(t1,t2) (lt(t2,t1))

assn_t not(assn_t a) {
  switch (a) {
  case &True: return &false_assn;
  case &False: return &true_assn;
  case &Prim(t1,pr,t2):
    switch (pr) {
    case Eq:  return neq(t1,t2);
    case Neq: return eq(t1,t2);
    case Lt:  return gte(t1,t2);
    case Lte: return gt(t1,t2);
    default: Tcutil::impos("vcgen not");
    }
  case &And(a1,a2): return or(not(a1),not(a2));
  case &Or(a1,a2): return and(not(a1),not(a2));
  }
}

////////// Implication for Assertions //////////////

// returns true when ctxt |- t1 p t2
// uses only very local, syntactic matching
bool find_ctxt(assn_t ctxt, term_t t1, prim_reln_t p1, term_t u1) {
  switch (ctxt) {
  case &False: return true;
  case &True: return false;
  case &And(a1,a2): return find_ctxt(a1,t1,p1,u1) || find_ctxt(a2,t1,p1,u1);
  case &Or(a1,a2): return find_ctxt(a1,t1,p1,u1) && find_ctxt(a2,t1,p1,u1);
  case &Prim(t2,p2,u2):
    switch $(p1,p2) {
    case $(Eq,Eq): 
    case $(Eq,Lte):
      return (same_term(t1,t2) && same_term(u1,u2) ||
              same_term(t1,u2) && same_term(u1,t2));
    case $(Lt,Neq): 
      return (same_term(t1,t2) && same_term(u1,u2) ||
              same_term(t1,u2) && same_term(u1,t2));
    case $(Lt,Lt):
    case $(Lt,Lte): 
    case $(Lte,Lte):
    case $(Neq,Neq):
      return same_term(t1,t2) && same_term(u1,u2);
    default: return false;
    }
  }
}

// returns true when ctxt |- a
// uses only very local, syntactic matching
bool simple_prove(assn_t ctxt, assn_t a) {
  if (ctxt == a) return true;
  switch (a) {
  case &True: return true;
  case &False: return false;
  case &And(a1,a2): return simple_prove(ctxt,a1) && simple_prove(ctxt,a2);
  case &Or(a1,a2): return simple_prove(ctxt,a1) || simple_prove(ctxt,a2);
  case &Prim(t1,p,t2): return find_ctxt(ctxt,t1,p,t2);
  }
}

bool constraint_prove(assn_t ctxt, assn_t a) {
  // FIX: here's where we want to use the pratt stuff.
  return false;
}

// returns true if a2 is provable from a1 (i.e., a1 |- a2)
// tries simple_prove first and then tries the constraint solver
bool implies(assn_t a1, assn_t a2) {
  return simple_prove(a1,a2) || constraint_prove(a1,a2);
}

////////// Widening for Assertions ////////////////////

// We want to find an assertion a' such that ctxt => a' and a => a'.
// (so or(ctxt,a) => a'.)  In addition, we want a' to have size less
// than or equal to a.  
assn_t weaken(assn_t ctxt, assn_t a) {
  if (implies(ctxt,a)) return a;
  switch (a) {
  case &And(a1,a2):
    let b1 = weaken(ctxt,a1);            // IH: ctxt=>b1 & a1=>b1
    let b2 = weaken(ctxt,a2);            // IH: ctxt=>b2 & a2=>b2
    if (implies(b1,b2)) return b1;
    if (implies(b2,b1)) return b2;
    return and(b1,b2);                   // ctxt => b1&b2  a1&a2=> b1&b2
  case &Or(a1,a2):
    let b1 = weaken(a2,a1);           // a1=>b1 & a2=>b1
    let b2 = weaken(a1,a2);           // a2=>b2 & a1=>b2
    let c = weaken(ctxt,and(b1,b2));  // ctxt=>c  b1&b2=>c  a1|a2=>b1&b2
    return c;
  case &True: 
  case &False: 
  case &Prim(...): return &true_assn;
  }
}

// We are given assertions A1 and A2 and would like to find
// the strongest assertion A such that A1 implies A and
// A2 implies A.  However, we would like to also ensure that
// A is "smaller" than A2.  The widen operation ensures that
// either we get back A2 or else the assertion is smaller
// (or as a technical hitch, we flip once from false to true.)
assn_t widen_assn(assn_t a1, assn_t a2) {
  return weaken(a1,a2);
}

////////// Updating an Assertion //////////////////

// substitute newx for x within t
term_t subst_term(term_t t, vardecl_t x, term_t newx) {
  switch (t) {
  case &Const(_): return t;
  case &Var(vd) && vd == x: return newx;
  case &Var(_): return t;
  case &LogicVar(_,_): return t;
  case &Primop(p,ts):
    list_t<term_t> res = NULL;
    bool change = false;
    for (let ptr = ts; ptr != NULL; ptr = ptr->tl) {
      let old_term = ptr->hd;
      let new_term = subst_term(old_term,x,newx);
      res = new List{new_term,res};
      if (new_term != old_term) change = true;
    }
    if (!change) return t;
    return new Primop(p,imp_rev(res));
  }
}

// substitute newx for x in assertion a.
assn_t subst_assn(assn_t a, vardecl_t x, term_t newx) {
  switch (a) {
  case &True:
  case &False: return a;
  case &Prim(t1,p,t2):
    let newt1 = subst_term(t1,x,newx);
    let newt2 = subst_term(t2,x,newx);
    if (newt1 == t1 && newt2 == t2) return a;
    return hash_cons(new Prim(newt1,p,newt2));
  case &And(a1,a2):
    let newa1 = subst_assn(a1,x,newx);
    let newa2 = subst_assn(a2,x,newx);
    if (newa1 == a1 && newa2 == a2) return a;
    return and(newa1,newa2);
  case &Or(a1,a2):
    let newa1 = subst_assn(a1,x,newx);
    let newa2 = subst_assn(a2,x,newx);
    if (newa1 == a1 && newa2 == a2) return a;
    return or(newa1,newa2);
  }
}

// replace all escaping vars with fresh variables.
// newvds accumulates the mapping from escaping variables to fresh terms.
term_t term_kill_vars(term_t t, list_t<$(vardecl_t,term_t)@`H,`H> @newvds) {
  switch (t) {
  case &Var(vd) && vd->escapes: 
    try {
      return assoc(*newvds,vd);
    } catch {
    case &Core::Not_found:
      let newv = fresh_var();
      *newvds = new List{new $(vd,newv),*newvds};
      return newv;
    }
  case &Primop(p,ts):
    list_t<term_t> res = NULL;
    bool change = false;
    for (let ptr = ts; ptr != NULL; ptr = ptr->tl) {
      let old_term = ptr->hd;
      let new_term = term_kill_vars(old_term,newvds);
      res = new List{new_term,res};
      if (new_term != old_term) change = true;
    }
    if (!change) return t;
    return new Primop(p,imp_rev(res));
  default: return t;
  }
}

// same as above but for assertions.
assn_t assn_kill_vars(assn_t a, list_t<$(vardecl_t,term_t)@`H,`H> @`H accum) {
  switch (a) {
  case &True:
  case &False: return a;
  case &Prim(t1,p,t2): 
    let newt1 = term_kill_vars(t1,accum);
    let newt2 = term_kill_vars(t2,accum);
    if (newt1 == t1 && newt2 == t2) return a;
    return hash_cons(new Prim(newt1,p,newt2));
  case &And(a1,a2):
    let newa1 = assn_kill_vars(a1,accum);
    let newa2 = assn_kill_vars(a2,accum);
    if (newa1 == a1 && newa2 == a2) return a;
    return and(newa1,newa2);
  case &Or(a1,a2):
    let newa1 = assn_kill_vars(a1,accum);
    let newa2 = assn_kill_vars(a2,accum);
    if (newa1 == a1 && newa2 == a2) return a;
    return or(newa1,newa2);
  }
}

// replace each escaping variable with a fresh variable -- simulates
// a write to an unknown location.
assn_t kill_mem(assn_t a) {
  list_t<$(vardecl_t,term_t)@`H,`H>@`H accum = new(NULL);
  return assn_kill_vars(a,accum);
}

term_t kill_mem_term(term_t t) {
  list_t<$(vardecl_t,term_t)@`H,`H> accum = NULL;
  return term_kill_vars(t,&accum);
}

term_t fresh_nonescvar(env_t env, vardecl_t vd);

// We are executing tgt := src
assn_t do_assign(env_t env, assn_t a, term_opt_t tgt, term_opt_t src) {
  switch (tgt) {
  case NULL: 
    // We don't know what the target is except that it's not a non-escaping
    // variable, so we must kill those references.
    return kill_mem(a);
  case &Var(vd):
    // We know what the target is -- if it escapes then we kill all 
    // escaping variables, otherwise we just kill the target vd.
    // We must make sure to also kill within the src term.
    if (vd->escapes) {
      a = kill_mem(a);
      src = (src == NULL) ? NULL : kill_mem_term(src);
    } else {
      let v2 = fresh_nonescvar(env,vd);
      a = subst_assn(a,vd,v2);
      src = (src == NULL) ? NULL : subst_term(src,vd,v2);
    }
    // Finally, add in tgt == src.
    return and(a,eq(tgt,src));
  default: Tcutil::impos("vcgen do_assign");
  }
}

///////////////////// Analysis /////////////////////

////////// Analysis Environment /////////////////////
struct SharedEnv {
  // a mapping from statements to accumulated pre-conditions and a state
  // counter table (see below)
  Hashtable::table_t<stmt_t,assn_t@> assn_table;
  // a mapping for successors in the control-flow graph (from jump_analysis)
  Hashtable::table_t<stmt_t,stmt_opt_t> succ_table;
  // the assertion accumulated for the current exception handler
  assn_t try_assn;
  // when not-null is used to record the resulting value of an expr-stmt.
  term_opt_t* exp_stmt;
  // used to record the result terms and assertions for a function
  term_opt_t  res_term;
  assn_t      res_assn;
};

typedef Dict::dict_t<vardecl_t,int> state_counter_t;

struct Env {
  struct SharedEnv @shared;
  // A clever idea from Yanling for simulating SSA:
  // For non-escaping variables, we keep a state counter so that when
  // we kill a variable on two separate paths, we retain some sharing
  // for the old values.  For instance, if we have:
  //     [x==0 && x==y] if (c) { x := 4; } else { x := 5; }
  // then we want to end up killing x with the same variable _x0 
  // upon each update so that we get on output:
  // ([_x0==0 && _x0==y && c && x == 4] ||[_x0==0 && _x0==y && !c && x == 5])
  // This will make it easier to collapse this into:
  //  [_x0==0 && _x0==y && (c && x == 4 || !c && x == 5)]
  state_counter_t state_counter;
};

static int hash_ptr(`a s) { return (int)s; }

env_t initial_env(JumpAnalysis::jump_anal_res_t tables, Absyn::fndecl_t fd) {
  let succ_table = Hashtable::lookup(tables->succ_tables,fd);
  let assn_table = Hashtable::create(57, Core::ptrcmp, hash_ptr);
  let senv =  new SharedEnv{.assn_table = assn_table,
                            .succ_table = succ_table,
                            .try_assn = &false_assn,
                            .exp_stmt = NULL,
                            .res_term = NULL,
                            .res_assn = &false_assn};
  let d = Dict::empty(Core::ptrcmp);
  return new Env { .shared = senv, .state_counter = d };
}

env_t copy_env(env_t env) {
  return new(*env);
}

int max_counter(int dummy, vardecl_t vd, int i, int j) {
  return (i < j) ? j : i;
}

void merge_env(env_t old_env, env_t new_env) {
  old_env->state_counter = Dict::union_two_c(max_counter, 0, 
                                             old_env->state_counter, 
                                             new_env->state_counter);
}

term_t fresh_nonescvar(env_t env, vardecl_t vd) {
  int res = 0;
  Dict::lookup_bool(env->state_counter,vd,&res);
  env->state_counter = Dict::insert(env->state_counter,vd,res+1);
  return new LogicVar(vd,res);
}

// each statement may have an assertion associated with it from
// other incoming edges -- we must take into account all paths.
assn_t pre_stmt_update(env_t env, stmt_t s, assn_t ain) {
  try {
    let p = Hashtable::lookup(env->shared->assn_table,s);
    let new_precondition = or(ain,*p);
    *p = new_precondition;
    return new_precondition;
  } catch {
  case &Core::Not_found: return ain;
  }
}

assn_t get_assn(env_t env, stmt_t s) {
  try { 
    return *Hashtable::lookup(env->shared->assn_table,s);
   } catch {
   case &Core::Not_found: return &false_assn;
   }
}

// this is used in situations where we loop -- note that we
// call widen() instead of or().  
assn_t loop_assn(env_t env, stmt_t s, assn_t ain) {
  // FIX? need to deal with alpha variance of logic vars and so forth?
  try {
    let aprev = Hashtable::lookup(env->shared->assn_table,s);
    ain = widen_assn(ain,*aprev);
    *aprev = ain;
  } catch {
  case &Core::Not_found:
    Hashtable::insert(env->shared->assn_table,s,new ain);
    break;
  }
  return ain;
}

// similar to pre_stmt_update but makes sure to put the
// result on the statement.
assn_t forward_assn(env_t env, stmt_t s, assn_t ain) {
  try {
    let aprev = Hashtable::lookup(env->shared->assn_table,s);
    ain = or(ain,*aprev);
    *aprev = ain;
  } catch {
  case &Core::Not_found:
    Hashtable::insert(env->shared->assn_table,s,new ain);
    break;
  }
  return ain;
}

// update the assertion associated with the current 
// exception handler.
void update_try_assn(env_t env, assn_t a) {
  env->shared->try_assn = or(env->shared->try_assn,a);
}

// update the return information for a function
void update_return(env_t env, term_opt_t t, assn_t a) {
  let shared = env->shared;
  if (shared->res_term != NULL || t != NULL) {
    let v = fresh_var();
    shared->res_assn = 
      or(and(a,eq(v,t)),and(shared->res_assn,eq(v,shared->res_term)));
  } else {
    shared->res_assn = or(a,shared->res_assn);
  }
}

// forward declarations for the analysis functions.

// Vcgen for statements.  ain is an assertion describing the state
// on input to the statement, and this returns an assertion describing 
// the output state. 
assn_t vcgen_stmt_nodebug(env_t env, stmt_t s, assn_t ain);
// Analyze a term given precondition ain and generate an optional term
// and post-condition representing the value of the expression and
// the resulting machine state.
$(term_opt_t,assn_t) vcgen_rexp_nodebug(env_t env, exp_t e, assn_t ain);
// If the term is "undefined" then we return a fresh variable.
$(term_t,assn_t) vcgen_rexp_always(env_t env, exp_t e, assn_t ain);
// Same as above, but for lhs-expressions.
$(term_opt_t,assn_t) vcgen_lexp(env_t env, exp_t e, assn_t ain);
// Analyze a test expression returning two assertions corresponding
// to the test succeeding (true-case) or failing (false-case).
$(assn_t t,assn_t f) vcgen_test(env_t env, exp_t e, assn_t ain);
// Analyze a list of expressions returning an optional list of
// terms and the output assertion.  If any of the expressions'
// is unknown, then so is the whole thing.
$(list_t<term_t>*,assn_t) vcgen_rexps(env_t env, list_t<exp_t> es, assn_t a);
// Similar to above but here we don't care what the resulting terms
// are at all.
assn_t vcgen_rexps_nosave(env_t env, list_t<exp_t> es, assn_t a);
// Folds vcgen_rexp_always across the list.
$(list_t<term_t>,assn_t) vcgen_rexps_always(env_t env, list_t<exp_t> es, assn_t ain);
// Do vcgen for all of the cases in a switch.  
assn_t vcgen_switch(env_t env, list_t<switch_clause_t> scs, assn_t ain);
// Do vcgen for a local declaration
assn_t vcgen_local_decl(env_t env, decl_t d, assn_t a);

#ifdef VCGEN_DEBUG
//#define vcgen_rexp(env,e,a) vcgen_rexp_debug(env,e,a)
#define vcgen_rexp(env,e,a) vcgen_rexp_nodebug(env,e,a)
#define vcgen_stmt(env,s,a) vcgen_stmt_debug(env,s,a)
static unsigned int indent = 0;
void print_tabs() {
  for (unsigned i = indent; i > 0; i--)
    fprintf(stderr," ");
}
string_t stmt2shortstring(stmt_t s) {
  switch (s->r) {
  case &Absyn::IfThenElse_s(e,...): 
    return aprintf("if (%s) ...",Absynpp::exp2string(e));
  case &Absyn::While_s($(e,_),_):
    return aprintf("while (%s) ...",Absynpp::exp2string(e));
  case &Absyn::For_s(e1,$(e2,_),$(e3,_),_):
    return aprintf("for (%s;%s;%s) ...",Absynpp::exp2string(e1),
                   Absynpp::exp2string(e2),Absynpp::exp2string(e3));
  case &Absyn::Switch_s(e,...): 
    return aprintf("switch (%s) ...",Absynpp::exp2string(e));
  case &Absyn::Do_s(_,$(e,_)):
    return aprintf("do ... while (%s)",Absynpp::exp2string(e));
  case &Absyn::TryCatch_s(s,...): 
    return aprintf("try %s catch ...",stmt2shortstring(s));
  default: return Absynpp::stmt2string(s);
  }
}
assn_t vcgen_stmt_debug(env_t env, stmt_t s, assn_t ain) {
  switch (s->r) {
  case &Absyn::Seq_s(_,_): 
  case &Absyn::Decl_s(...):
    //case &Absyn::Exp_s(...):
  case &Absyn::Skip_s: return vcgen_stmt_nodebug(env,s,ain);
  default:
    print_tabs();
    let str = assn2string(ain);
    fprintf(stderr,"stmt %s pre(%d/%d)=%s\n",stmt2shortstring(s),assn_size(ain),tree_size,str);
    indent += 2;
    let aout = vcgen_stmt_nodebug(env,s,ain);
    indent -= 2;
    print_tabs();
    let str = assn2string(aout);
    fprintf(stderr,"stmt %s, post(%d/%d)=%s\n",stmt2shortstring(s),assn_size(aout),tree_size,str);
    return aout;
  }
}
$(term_opt_t,assn_t) vcgen_rexp_debug(env_t env, exp_t e, assn_t ain) {
  print_tabs();
  fprintf(stderr,"exp %s, pre=%s\n",Absynpp::exp2string(e),assn2string(ain));
  indent += 2;
  let $(t,a) = vcgen_rexp_nodebug(env,e,ain);
  indent -= 2;
  print_tabs();
  fprintf(stderr,"exp %s ==> %s, post: %s\n",Absynpp::exp2string(e),
          ((t == NULL) ? "?" : term2string((term_t)t)), assn2string(ain));
  return $(t,a);
}

#else
#define vcgen_rexp(env,e,a) vcgen_rexp_nodebug(env,e,a)
#define vcgen_stmt(env,s,a) vcgen_stmt_nodebug(env,s,a)
#endif

// To simplify things, I'm treating the control-flow as if it were
// structured.  Upon reaching a labelled statement, I set the pre-
// condition to "True" which is conservative.   This lets me do
// local iteration for loops and so forth to generate invariants,
// since the only back-edges in the simplified graph are always
// part of the control constructs.  
assn_t vcgen_stmt_nodebug(env_t env, stmt_t s, assn_t ain) {
  // merge the pre-condition with any pre-recorded assertions.
  // we'll have one if there was some control-flow to this statement.
  ain = pre_stmt_update(env,s,ain);
  assn_size(ain);
  // don't bother analyzing if we can show the assertion is false
  // (effectively an unreachable state.)
  switch (ain) {
  case &False: return ain;
  default: break;
  }
  switch (s->r) {
  case &Absyn::Skip_s: return ain;
  case &Absyn::Exp_s(e): 
    let $(t,aout) = vcgen_rexp(env,e,ain);
    // a little trickery to deal with statement expressions -- we
    // record the result in the environment here.
    if (env->shared->exp_stmt != NULL) 
      *(env->shared->exp_stmt) = t;
    return aout;
  case &Absyn::Seq_s(s1,s2): return vcgen_stmt(env,s2,vcgen_stmt(env,s1,ain));
  case &Absyn::Return_s(NULL): 
    update_return(env,NULL,ain);
    return &false_assn;
  case &Absyn::Return_s(e as &_): 
    let $(t,aout) = vcgen_rexp(env,(exp_t)e,ain);
    update_return(env,t,aout);
    return &false_assn;
  case &Absyn::IfThenElse_s(e1,s1,s2):
    let $(at,af) = vcgen_test(env,e1,ain);
    let env2 = copy_env(env);
    at = vcgen_stmt(env,s1,at);
    af = vcgen_stmt(env2,s2,af);
    merge_env(env,env2);
    return or(at,af);
  case &Absyn::While_s($(e,dummy),s):
    // we're doing local iteration here -- we join with the
    // assertion on the dummy and widen each time around the loop since
    // its assertion will be updated by a continue.  We disallow
    // goto's in the analysis by essentially forcing their destination's
    // assertion to be true.
    while (true) {
      ain = loop_assn(env,dummy,ain);
      let $(at,af) = vcgen_test(env,e,ain);
      ain = vcgen_stmt(env,s,at);
      if (implies(ain,get_assn(env,dummy))) return af;
    } 
  case &Absyn::Continue_s: fallthru;
    // continue is a backwards jump in a loop, but we take
    // that into account as part of the loop iteration.
    let dest = Hashtable::lookup(env->shared->succ_table,s);
    loop_assn(env, (stmt_t)dest, ain);
    return &false_assn;
  case &Absyn::Break_s:
    // break is a forwards jump so we can do an Or.  This assertion
    // that we set on the destination will be picked up when we hit
    // that statement.  
    let dest = Hashtable::lookup(env->shared->succ_table,s);
    if (dest == NULL) 
      update_return(env,NULL,ain);
    else 
      forward_assn(env, (stmt_t)dest, ain);
    return &false_assn;
  case &Absyn::For_s(e1,$(e2,dummy2),$(e3,dummy3),s):
    let $(_,a) = vcgen_rexp(env,e2,ain);
    ain = a;
    // similar to while loop.
    while (true) {
      ain = loop_assn(env,dummy2,ain);
      let $(at,af) = vcgen_test(env,e2,ain);
      ain = vcgen_stmt(env,s,at);
      // must do pre-statement check because continue goes here
      ain = pre_stmt_update(env,dummy3,ain);
      ain = vcgen_rexp(env,e3,ain)[1];
      if (implies(ain,get_assn(env,dummy2))) return af;
    }
  case &Absyn::Do_s(s,$(e,dummy)):
    // similar to while loop
    while (true) {
      ain = vcgen_stmt(env,s,ain);
      let $(at,af) = vcgen_test(env,e,ain);
      ain = widen_assn(get_assn(env,dummy),ain);
      if (implies(ain,get_assn(env,dummy))) return af;
      loop_assn(env,dummy,ain);
    }
  case &Absyn::Switch_s(e,scs,_):
    // FIX: take into acount test of e
    // note that we do not split the state counter for a switch
    // because a fallthru might lead to problems.  if we merged
    // environments at entry points of control-flow paths, then
    // we could handle this.
    let $(t,a) = vcgen_rexp(env,e,ain);
    return vcgen_switch(env,scs,a);
  case &Absyn::Fallthru_s(_,NULL): Tcutil::impos("vcgen fallthru");
  case &Absyn::Fallthru_s(es,&dest):
    // Also a forward jump so we can do an or.
    let $(ts,a) = vcgen_rexps_always(env,es,ain);
    // initialize the pattern variables with their corresponding terms
    for (let x = dest->pat_vars->v; x != NULL; x = x->tl,ts = ts->tl) {
      let &$(vd,ve) = x->hd;
      if (vd != NULL) 
        a = do_assign(env,a,new Var(*vd),ts->hd);
    }
    forward_assn(env, dest->body, a);
    return &false_assn;
  case &Absyn::Decl_s(d,s):
    return vcgen_stmt(env,s,vcgen_local_decl(env,d,ain));
  case &Absyn::Label_s(_,s): 
    // by making the assertion True here, we're effectively losing
    // all information when we do a goto.  This is conservative, 
    // and means that I don't have to worry about non-structured
    // control-flow.
    return vcgen_stmt(env,s,&true_assn);
  case &Absyn::Goto_s(_): return &false_assn; // see above
  case &Absyn::TryCatch_s(s,scs,_):
    // save old try/catch-handler assertion
    let old_try_assn = env->shared->try_assn;
    // install new try/catch-handler assertion
    env->shared->try_assn = &false_assn;
    // run vcgen on the body -- this will update the env->shared->try_assn 
    // with assertions of any state that might throw an exn.
    ain = vcgen_stmt(env,s,ain);
    // restore the old handler's assertion.
    let new_try_assn = env->shared->try_assn;
    env->shared->try_assn = old_try_assn;
    // analyze the catch handlers and merge with the body to get
    // the final output.
    return or(ain,vcgen_switch(env,scs,new_try_assn));
  }
}

assn_t vcgen_switch(env_t env, list_t<switch_clause_t> scs, assn_t ain) {
  // note that all of the clauses should explicitly jump (via break)
  // or something else outside of the clause so the result should always
  // be false...
  assn_t res = &false_assn;
  for (; scs != NULL; scs = scs->tl) {
    let sc = scs->hd;
    let a = ain;
    for (let pvs = sc->pat_vars->v; pvs != NULL; pvs = pvs->tl) {
      let &$(vdopt,eopt) = pvs->hd;
      if (vdopt != NULL) {
        if (eopt != NULL)
          a = do_assign(env,a,new Var(*vdopt),vcgen_rexp(env,(exp_t)eopt,a)[0]);
        else 
          a = do_assign(env,a,new Var(*vdopt),fresh_var());
      }
    }
    if (sc->where_clause != NULL) 
      a = vcgen_test(env, (exp_t)sc->where_clause, a)[0];
    res = or(res,vcgen_stmt(env,sc->body,a));
  }
  return res;
}

assn_t add_vardecl(env_t env, vardecl_t vd, assn_t a) {
  // stupid C semantics means I have to put in a dummy value for vd first,
  // then run the initializer.  
  let tv = new Var(vd);
  a = do_assign(env,a,tv,fresh_var());
  if (vd->initializer != NULL) {
    let $(t,a1) = vcgen_rexp(env,(exp_t)vd->initializer,a);
    a = do_assign(env,a1,tv,t);
  }
  return a;
}

assn_t vcgen_local_decl(env_t env, decl_t d, assn_t a) {
  switch (d->r) {
  case &Absyn::Var_d(vd): return add_vardecl(env,vd,a);
  case &Absyn::Let_d(p,vds,e,_): 
    let $(_,a) = vcgen_rexp(env,e,a);
    for (let vds = vds->v; vds != NULL; vds = vds->tl) {
      let $(vdopt,eopt) = *vds->hd;
      if (vdopt != NULL) {
        if (eopt == NULL) a = add_vardecl(env,*vdopt,a);
        else {
          let $(t,a1) = vcgen_rexp(env,e,a);
          let tv = new Var(*vdopt);
          a = do_assign(env,a1,tv,t);
        }
      }
    }
    return a;
  case &Absyn::Letv_d(vds): 
    for (; vds != NULL; vds = vds->tl)
      a = add_vardecl(env,vds->hd,a);
    return a;
  case &Absyn::Region_d(_,vd,eopt): 
    if (eopt != NULL) {
      let $(t,a1) = vcgen_rexp(env,(exp_t)eopt,a);
      a = a1;
    }
    // FIX: inaccurate but okay for now.
    a = add_vardecl(env,vd,a);
    return a;
  default: return a;
  }
}

$(assn_t,assn_t) vcgen_test(env_t env, exp_t e, assn_t ain) {
  switch (e->r) {
  case &Absyn::Conditional_e(e1,e2,e3):
    let $(a1t,a1f) = vcgen_test(env,e1,ain);
    let $(a2t,a2f) = vcgen_test(env,e2,a1t);
    let $(a3t,a3f) = vcgen_test(env,e3,a1f);
    return $(or(a2t,a3t),or(a2f,a3f));
  case &Absyn::And_e(e1,e2):
    let $(a1t,a1f) = vcgen_test(env,e1,ain);
    let $(a2t,a2f) = vcgen_test(env,e2,a1t);
    return $(a2t, or(a1f,a2f));
  case &Absyn::Or_e(e1,e2):
    let $(a1t,a1f) = vcgen_test(env,e1,ain);
    let $(a2t,a2f) = vcgen_test(env,e2,a1f);
    return $(or(a1t,a2t),a2f);
  case &Absyn::SeqExp_e(e1,e2):
    let $(_,ain) = vcgen_rexp(env,e1,ain);
    return vcgen_test(env,e2,ain);
  case &Absyn::Primop_e(Absyn::Not,&List(e1,_)):
    let $(at,af) = vcgen_test(env,e1,ain);
    return $(af,at);
  case &Absyn::Primop_e(p,&List(e1,&List(e2,NULL))):
    let $(t1,a1) = vcgen_rexp(env,e1,ain);
    let $(t2,a2) = vcgen_rexp(env,e2,a1);
    let at = a2;
    let af = a2;
    switch p {
    case Absyn::Eq:  at = and(at,eq(t1,t2));  af = and(af,neq(t1,t2)); break;
    case Absyn::Neq: at = and(at,neq(t1,t2)); af = and(af,eq(t1,t2)); break;
    case Absyn::Lt:  at = and(at,lt(t1,t2));  af = and(af,gte(t1,t2)); break;
    case Absyn::Lte: at = and(at,lte(t1,t2)); af = and(af,gt(t1,t2)); break;
    case Absyn::Gt:  at = and(at,gt(t1,t2));  af = and(at,lte(t1,t2)); break;
    case Absyn::Gte: at = and(at,gte(t1,t2)); af = and(at,lt(t1,t2)); break;
    default: break;
    }
    return $(at,af);
  default:
    let $(t,aout) = vcgen_rexp(env,e,ain);
    return $(and(aout,neq(t,zero())),and(aout,eq(t,zero())));
  }
}

assn_t vcgen_rexps_nosave(env_t env, list_t<exp_t> es, assn_t a) {
  for (; es != NULL; es = es->tl) 
    a = vcgen_rexp(env,es->hd,a)[1];
  return a;
}

$(list_t<term_t>*,assn_t) vcgen_rexps(env_t env, list_t<exp_t> es, assn_t a) {
  list_t<term_t> res = NULL;
  bool valid = true;
  for (; es != NULL; es = es->tl) {
    let $(t,aout) = vcgen_rexp(env,es->hd,a);
    a = aout;
    if (valid && t != NULL) {
      res = new List{(term_t)t,res};
    } else {
      valid = false;
    }
  }
  return $(valid ? new (imp_rev(res)) : NULL, a);
}

$(term_t,assn_t) vcgen_rexp_always(env_t env, exp_t e, assn_t ain) {
  let $(topt,a) = vcgen_rexp(env,e,ain);
  return $(topt == NULL ? fresh_var() : (term_t)topt, a);
}

$(list_t<term_t>,assn_t) vcgen_rexps_always(env_t env, list_t<exp_t> es, assn_t ain) {
  list_t<term_t> res = NULL;
  for (; es != NULL; es = es->tl) {
    let $(t,a) = vcgen_rexp_always(env,es->hd,ain);
    ain = a;
    res = new List(t,res);
  }
  return $(res,ain);
}

vardecl_t bind2vardecl(Absyn::binding_t b) {
  switch (b) {
  case &Absyn::Global_b(vd): return vd;
  case &Absyn::Funname_b(fd): return (vardecl_t)fd->fn_vardecl;
  case &Absyn::Unresolved_b(...): Tcutil::impos("vcgen bind2vardecl");
  case &Absyn::Param_b(vd): return vd;
  case &Absyn::Local_b(vd): return vd;
  case &Absyn::Pat_b(vd): return vd;
  }
}

$(term_opt_t,assn_t) vcgen_lexp(env_t env, exp_t e, assn_t ain) {
  switch (e->r) {
  case &Absyn::Var_e(b): 
      return $(new Var(bind2vardecl(b)),ain);
  default: return $(NULL, vcgen_rexp(env,e,ain)[1]);
  }
}

term_opt_t deref_lterm(env_t env, term_opt_t lt, assn_t ain) {
  return lt;
}

$(term_opt_t,assn_t) vcgen_rexp_nodebug(env_t env, exp_t e, assn_t ain) {
  if (Tcutil::is_const_exp(e)) return $(new Const(e),ain);
  switch (e->r) {
  case &Absyn::Const_e(c): 
    // should really be caught by the above...
    return $(new Const(e),ain);
  case &Absyn::Var_e(b): return $(new Var(bind2vardecl(b)),ain);
  case &Absyn::Primop_e(p,es):
    let $(ts,aout) = vcgen_rexps(env,es,ain);
    term_opt_t t = NULL;
    if (ts != NULL) t = primop(p,*ts);
    return $(t, aout);
  case &Absyn::AssignOp_e(e1,popt,e2):
    let $(lt,a1) = vcgen_lexp(env,e1,ain);
    let $(t2,a2) = vcgen_rexp(env,e2,a1);
    if (popt != NULL) {
      let t1 = deref_lterm(env,lt,a2);
      if (t1 == NULL || t2 == NULL) 
        t2 = NULL;
      else
        t2 = primop(popt->v,list((term_t)t1,(term_t)t2));
    }
    let a = do_assign(env,a2,lt,t2);
    return $(lt,a);
  case &Absyn::Increment_e(e,i):
    let $(lt,a1) = vcgen_lexp(env,e,ain);
    let t1 = deref_lterm(env,lt,a1);
    term_opt_t res = NULL;
    term_opt_t assn = NULL;
    switch (i) {
    case Absyn::PreInc: 
      if (t1 != NULL) assn = new Primop(Absyn::Plus,list((term_t)t1,one()));
      res = assn;
      break;
    case Absyn::PostInc:
      res = t1;
      if (t1 != NULL) assn = new Primop(Absyn::Plus,list((term_t)t1,one()));
      break;
    case Absyn::PreDec:
      if (t1 != NULL) assn = new Primop(Absyn::Minus,list((term_t)t1,one()));
      res = assn;
      break;
    case Absyn::PostDec:
      res = t1;
      if (t1 != NULL) assn = new Primop(Absyn::Minus,list((term_t)t1,one()));
      break;
    default: Tcutil::impos("vcgen vcgen_rexp increment_e");
    }
    let a = do_assign(env,a1,lt,assn);
    return $(res,a);
  case &Absyn::Conditional_e(e1,e2,e3):
    let $(at,af) = vcgen_test(env,e1,ain);
    let $(t1,at) = vcgen_rexp(env,e2,at);
    let $(t2,af) = vcgen_rexp(env,e3,af);
    if (t1 != NULL && t2 != NULL) {
      let v = fresh_var();
      at = and(at,eq(v,t1));
      af = and(af,eq(v,t2));
      return $(v,or(at,af));
    } else
      return $(NULL,or(at,af));
  case &Absyn::And_e(e1,e2):
    let $(at,af) = vcgen_test(env,e1,ain);
    let $(t,at) = vcgen_rexp(env,e2,at);
    let v = fresh_var();
    at = and(at,eq(v,t));
    af = and(af,eq(v,zero()));
    return $(v,or(at,af));
  case &Absyn::Or_e(e1,e2):
    let $(at,af) = vcgen_test(env,e1,ain);
    let $(t,af) = vcgen_rexp(env,e2,af);
    let v = fresh_var();
    at = and(at,eq(v,one()));
    af = and(af,eq(v,t));
    return $(v,or(at,af));
  case &Absyn::SeqExp_e(e1,e2):
    let $(_,a) = vcgen_rexp(env,e1,ain);
    return vcgen_rexp(env,e2,a);
  case &Absyn::FnCall_e(e,es,...):
    ain = vcgen_rexps_nosave(env,es,ain);
    let $(_,a2) = vcgen_rexp(env,e,ain);
    // kill every variable that points into memory -- could refine
    // this to only those reachable from globals or the parameters.
    a2 = kill_mem(a2);
    // FIX: take pre- and post-condition into account
    // must update exception handler.
    update_try_assn(env,a2);
    // noreturn functions don't return...
    if (Tcutil::is_noreturn_fn_type((type_t)e->topt)) a2 = &false_assn;
    return $(NULL,a2);
  case &Absyn::Throw_e(e,_):
    let $(_,a) = vcgen_rexp(env,e,ain);
    update_try_assn(env,a);
    return $(NULL,&false_assn);
  case &Absyn::NoInstantiate_e(e): return vcgen_rexp(env,e,ain);
  case &Absyn::Instantiate_e(e,_):  return vcgen_rexp(env,e,ain);

  case &Absyn::Cast_e(t,e,_,c): 
    // FIX: really need to put C coercions in terms...
    let $(t,a) = vcgen_rexp(env,e,ain);
    if (c == Absyn::No_coercion)
      return $(t,a);
    else {
      update_try_assn(env,ain); // coercion could fail
      return $(NULL,a);
    }
  case &Absyn::New_e(eopt,e):
    if (eopt != NULL)
      ain = vcgen_rexp(env,(exp_t)eopt,ain)[1];
    return $(NULL,vcgen_rexp(env,e,ain)[1]);

  // these cases should be captured by the const-expression check above.
  case &Absyn::Enum_e(...):
  case &Absyn::AnonEnum_e(...):
  case &Absyn::Sizeoftype_e(_):
  case &Absyn::Sizeofexp_e(_):
  case &Absyn::Valueof_e(_):
  case &Absyn::Offsetof_e(_,_): return $(NULL,ain);

  // These can all throw exceptions
  case &Absyn::Deref_e(e): fallthru(e);
  case &Absyn::AggrMember_e(e,...): fallthru(e);
  case &Absyn::AggrArrow_e(e,...):
    ain = vcgen_rexp(env,e,ain)[1];
    update_try_assn(env,ain);
    return $(NULL,ain);

  case &Absyn::Tagcheck_e(e,_): fallthru(e);
  case &Absyn::Address_e(e): 
    return $(NULL,vcgen_rexp(env,e,ain)[1]);

  case &Absyn::Subscript_e(e1,e2): 
    let $(t1,a1) = vcgen_rexp(env,e1,ain);
    let $(t2,a2) = vcgen_rexp(env,e2,a1);
    switch (Tcutil::compress((type_t)e1->topt)) {
    case &Absyn::TupleType(_): break;
    default:
      if (t1 != NULL) {
        update_try_assn(env,ain);
        a2 = and(a2,lt(t2,new Primop(Absyn::Numelts,list(t1))));
      }
    }
    return $(NULL,a2);

  case &Absyn::Datatype_e(es,...): fallthru(es);
  case &Absyn::Tuple_e(es): return $(NULL,vcgen_rexps_nosave(env,es,ain));

  case &Absyn::CompoundLit_e(_,dles):   fallthru(dles);
  case &Absyn::Array_e(dles):           fallthru(dles);
  case &Absyn::Aggregate_e(_,_,dles,_): fallthru(dles);
  case &Absyn::UnresolvedMem_e(_,dles): fallthru(dles);
  case &Absyn::AnonStruct_e(_,dles):
    for (; dles != NULL; dles = dles->tl) {
      let &$(_,e) = dles->hd;
      ain = (vcgen_rexp(env,e,ain))[1];
    }
    return $(NULL,ain);

  case &Absyn::Comprehension_e(vd,e1,e2,_): 
    // similar to a while-loop except we evaluate e1 only once.
    let $(t1,a) = vcgen_rexp(env,e1,ain);
    let t1 = (t1 == NULL) ? fresh_var() : (term_t)t1;
    let v = new Var(vd);
    // start off with index 0
    a = do_assign(env,a,v,zero());
    while (true) {
      let at = and(a,lt(v,t1));  // simulate test
      let af = and(a,gte(v,t1));
      let $(_,abody) = vcgen_rexp(env,e2,at);  // run body and add one
      abody = do_assign(env,abody,v,new Primop(Absyn::Plus,list(v,one())));
      if (implies(abody,a)) { a = af; break; }
      a = widen_assn(abody,a);  // widen and possibly iterate
    }
    return $(NULL,a);
  case &Absyn::ComprehensionNoinit_e(e,_,_):
    return $(NULL,vcgen_rexp(env,e,ain)[1]);
  case &Absyn::Malloc_e(mi):
    if (mi.rgn != NULL) 
      ain = vcgen_rexp(env,(exp_t)mi.rgn,ain)[1];
    return $(NULL,vcgen_rexp(env,mi.num_elts,ain)[1]);
  case &Absyn::Swap_e(e1,e2): 
    let $(lt1,a1) = vcgen_lexp(env,e1,ain);
    update_try_assn(env,a1); // could have null-exn?
    let $(lt2,a2) = vcgen_lexp(env,e2,a1);
    update_try_assn(env,a2); // could have null-exn?
    let t1 = deref_lterm(env,lt1,a2);
    let t2 = deref_lterm(env,lt2,a2);
    a2 = do_assign(env,a2,lt1,t2);
    a2 = do_assign(env,a2,lt2,t1);
    return $(NULL,a2);
  case &Absyn::StmtExp_e(s):
    let old_exp_stmt = env->shared->exp_stmt;
    env->shared->exp_stmt = new NULL;
    let aout = vcgen_stmt(env,s,ain);
    let t = *(env->shared->exp_stmt);
    env->shared->exp_stmt = old_exp_stmt;
    return $(t,aout);
  case &Absyn::Asm_e(...): return $(NULL,ain);
  case &Absyn::Extension_e(e): return vcgen_rexp(env,e,ain);
  case &Absyn::Pragma_e(s): 
    if (strcmp(s,"print_assn")) {
      let seg_str = Position::string_of_segment(e->loc);
      fprintf(stderr,"%s: current assn is %s\n",seg_str,assn2string(ain));
    }
    return $(zero(),ain);
  }
}

// FIX? take into account top-level (const) variable intializers?
void vcgen_topdecls(JumpAnalysis::jump_anal_res_t tables, list_t<Absyn::decl_t> ds) {
  for (; ds != NULL; ds = ds->tl) {
    switch (ds->hd->r) {
    case &Absyn::Fn_d(fd):
      fprintf(stderr,"Vcgen function %s\n",Absynpp::qvar2string(fd->name));
      fprintf(stderr,"---------------------------------------\n");
      let env = initial_env(tables,fd);
      // FIX: put in pre-condition and check post-condition
      vcgen_stmt(env,fd->body,&true_assn);
      hash_cons_table = NULL; // collect table
      break;
    case &Absyn::Namespace_d(_,ds): fallthru(ds);
    case &Absyn::Using_d(_,ds): vcgen_topdecls(tables,ds); break;
    default: break;
    }
  }
}
