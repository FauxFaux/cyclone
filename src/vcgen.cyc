/* Computing Strongest Post-conditions
   Copyright (C) 2003 Greg Morrisett
   This file is part of the Cyclone compiler.

   The Cyclone compiler is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   The Cyclone compiler is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with the Cyclone compiler; see the file COPYING. If not,
   write to the Free Software Foundation, Inc., 59 Temple Place -
   Suite 330, Boston, MA 02111-1307, USA. */

/* What we are doing here is computing a pre/post-condition in a forwards
   fashion for each statement and expression within a function.  The 
   assertion language is very simple: equality and inequality over
   terms, disjunction, and conjunction (no quantifiers).  The terms
   include what we consider to be "constant" expressions in Cyclone,
   primops of terms, program variables, and logical variables.  

   There's an extremely simple, essentially syntactic prover that is
   used to show implications.  There's also an extremely simple strategy
   for generating loop invariants.  The trickyness is in ensuring
   that the iterative analysis terminates.  In essence, each time
   around a loop, we're guaranteeing that we get a smaller (in terms
   of total node count) assertion.  The worst case is we fall back to "true".

   To keep the analysis simple and somewhat structured, we essentially
   punt on goto's.  More properly, whenever we hit a labelled statement,
   we reset the incoming pre-condition to "true".  This allows me to
   do purely local iteration for calculating the assertions.  To handle
   other non-local edges (e.g., break, continue, throw) we essentially
   pile up assertions on the statement and OR them in with the natural
   flow's pre-condition.  

   Also to keep the analysis simple, we punt on alias analysis.  Variables 
   have a flag indicating whether or not they escape syntactically.
   When updating an escaping variable, we essentially "kill" all 
   escaping variables.  The same happens for a function call.  This is
   *not* thread-safe.  To achieve that, we would have to kill all escaping
   things after each step. 

   We use hash-consing to try to get maximal sharing among 
   assertion nodes.  Maintaining sharing is crucial for avoiding
   an exponential space blow up.  I've experimented with lazy
   substitution as well, but this didn't seem to work that well.

   There are a lot of ways we should improve this analysis and a few
   things that need to be fixed:

   * We need to extend terms to account for casts/coercions.
   * We need to make a distinction between signed and unsigned comparisons.
   * We need to take pre/post-conditions of functions into account.
   * We need to add @assert(-) expressions so that users can write their
     own static assertions.  The hope would be that these could be used to
     find smarter loop invariants or to collapse down a big disjunction.
   * We need to have a "throttle" for controlling assertion size.  Sooner
     or later we will run into iterated if's/diamond control-flow patterns
     that will result in a zillion disjunctions.  Although we share the
     resulting assertions, the theorem prover needs some way to avoid
     crawling over the assertion as if it's a tree.

   * We should use the Pratt constraint solver where possible.
   * We should take pattern matching tests into account for a switch.
   * We shouldn't kill unique variables.
   * We should only kill "type-compatible" expressions on an update.

   * We should make the simple thm. prover a bit smarter.
   * We should perhaps try to simplify the assertions to remove
     redundancies?
   * We should add support for more predicates and relations (e.g.,
     track whether x == null, or tagcheck(x.f), or datatype tags, etc.)?
   * Could have user-defined predicates...
   * If we knew that a goto was forward, then we could deal with it...
   */
#include "vcgen.h"
#include "absynpp.h"
#include "tcutil.h"
#include "evexp.h"
#include <hashtable.h>
#include <dict.h>
#include <string.h> 
#include <cycboot.h> 
#include <warn.h>

//#define VCGEN_DEBUG

namespace Vcgen;
using List;
typedef Absyn::type_t type_t;
typedef Absyn::vardecl_t vardecl_t;
typedef Absyn::vardecl_opt_t vardecl_opt_t;
typedef Absyn::exp_t exp_t;
typedef Absyn::decl_t decl_t;
typedef Absyn::stmt_t stmt_t;
typedef Absyn::stmt_opt_t stmt_opt_t;
typedef Absyn::switch_clause_t switch_clause_t;
////// Forward Declaration for Environments /////
struct Env;
typedef struct Env @env_t;

///////////////////// Terms /////////////////////
typedef datatype Term @term_t, *term_opt_t;

datatype Term {
  Const(exp_t);  // a Cyclone "constant" expression
  Var(vardecl_t);
  LogicVar(vardecl_opt_t,int);
  Primop(Absyn::primop_t,list_t<term_t>);
};

string_t term2string(term_t t) {
  switch (t) {
  case &Const(c): return Absynpp::exp2string(c);
  case &Var(vd): return Absynpp::qvar2string(vd->name);
  case &LogicVar(NULL,i): return aprintf("_X%d",i);
  case &LogicVar(vd,i): return aprintf("_%s%d",Absynpp::qvar2string(vd->name),i);
  case &Primop(p,&List{t1,&List{t2,NULL}}): 
    return aprintf("(%s%s%s)",term2string(t1),
                   Absynpp::prim2string(p),term2string(t2));
  case &Primop(p,&List{t,_}):
    return aprintf("%s(%s)",Absynpp::prim2string(p),term2string(t));
  default: Tcutil::impos("term2string primop args");
  }
}

static term_t cnst(Absyn::exp_t c) { return new Const(c); }
static term_t zero() {
  static term_opt_t z = NULL;
  if (z == NULL) {
    let e = Absyn::int_exp(Absyn::None,0,0);
    e->topt = Absyn::int_type(Absyn::None,Absyn::Int_sz);
    let r = cnst(e);
    z = r;
    return r;
  } else return (term_t)z;
}
static term_t one() {
  static term_opt_t z = NULL;
  if (z == NULL) {
    let e = Absyn::int_exp(Absyn::None,1,0);
    e->topt = Absyn::int_type(Absyn::None,Absyn::Int_sz);
    let r = cnst(e);
    z = r;
    return r;
  } else return (term_t)z;
}
  
static term_t var(vardecl_t vd) { return new Var(vd); }
static term_t primop(Absyn::primop_t p, list_t<term_t,`H> ts) {
  return new Primop(p,ts);
}
static term_t fresh_var() {
  static int counter = 0;
  return new LogicVar(NULL,counter++);
}

int cmp_term(term_t t1, term_t t2) {
  switch $(t1,t2) {
  case $(&Const(c1),&Const(c2)): return Evexp::exp_cmp(c1,c2);
  case $(&Const(_),_): return -1;
  case $(_,&Const(_)): return 1;
  case $(&Var(vd1),&Var(vd2)): return (int)vd1 - (int)vd2;
  case $(&Var(_),_): return -1;
  case $(_,&Var(_)): return 1;
  case $(&LogicVar(vd1,i),&LogicVar(vd2,j)): 
    if (vd1 == vd2) return (i - j);
    return (int)vd1 - (int)vd2;
  case $(&LogicVar(_,_),_): return -1;
  case $(_,&LogicVar(_,_)): return 1;
  case $(&Primop(p1,ts1),&Primop(p2,ts2)):
    if (p1 != p2) return (int)p1 - (int)p2;
    return list_cmp(cmp_term, ts1, ts2);
  }
}

bool same_term(term_t t1, term_t t2) { return cmp_term(t1,t2) == 0; }

///////////////////// Assertions /////////////////////
typedef datatype Assn @assn_t;

typedef enum Primreln { Eq, Neq, Lt, Lte } prim_reln_t;

datatype Assn {
  True;
  False;
  Prim(term_t,prim_reln_t,term_t);
  And(assn_t,assn_t);
  Or(assn_t,assn_t);
  Subst(vardecl_t x,term_t t,assn_t a); // a[t/x] -- lazy substitution
  Kill(assn_t); // replace all escaping variables with fresh logic variables
};

// inner loop for calculating the size of an assertion -- we
// take care to figure out the size as a dag and not a tree.
static unsigned int 
  assn_size_loop(assn_t a, unsigned int c, list_t<assn_t,`H>@ prev){
  if (memq(*prev,a)) return c;
  *prev = new List(a,*prev);
  switch (a) {
  case &True:  return c;
  case &False: return c;
  case &Prim(...): return 1+c;
  case &And(a1,a2): fallthru(a1,a2);
  case &Or(a1,a2): 
    return assn_size_loop(a1,assn_size_loop(a2,1+c,prev),prev);
  case &Subst(vd,t,a):
    return assn_size_loop(a,c+1,prev);
  case &Kill(a): return assn_size_loop(a,c+1,prev);
  }
}

// counter used for reporting purposes
static unsigned int max_assn_size = 0;

// calculate the size of an assertion
static unsigned int assn_size(assn_t a) {
  list_t<assn_t,`H> prev = NULL;
  let c = assn_size_loop(a,0,&prev);
  if (c > max_assn_size) {
    max_assn_size = c;
  }
  return c;
}

// calculate a string representation (and total tree node count) for an
// assertion.  the prec field (precedent) is used to avoid some parens.
static string_t a2string(assn_t a, int prec, int@ size) {
  switch (a) {
  case &True: return "true";
  case &False: return "false";
  case &Prim(t1,p,t2):
    *size += 1;
    string_t ps;
    switch (p) {
    case Eq: ps = "=="; break;
    case Neq: ps = "!="; break;
    case Lt: ps = "<"; break;
    case Lte: ps = "<="; break;
    default: Tcutil::impos("assn2string primop");
    }
    return aprintf("%s%s%s",term2string(t1),ps,term2string(t2));
  case &Or(a1,a2): 
    *size += 1;
    if (prec <= 5)
      return aprintf("%s || %s",a2string(a1,5,size),a2string(a2,5,size));
    else 
      return aprintf("(%s || %s)",a2string(a1,5,size),a2string(a2,5,size));
  case &And(a1,a2): 
    *size += 1;
    return aprintf("%s && %s",a2string(a1,10,size),a2string(a2,10,size));
  case &Subst(vd,t,a):
    *size += 1;
    return aprintf("Subst[%s:=%s](%s)",Absynpp::qvar2string(vd->name),
                   term2string(t),a2string(a,0,size));
  case &Kill(a):
    *size += 1;
    return aprintf("Kill(%s)",a2string(a,0,size));
  }
}

static int tree_size = 0;

// convert an assertion to a string.
string_t assn2string(assn_t a) {
  tree_size = 0;
  return a2string(a,0,&tree_size);
}

// assertion constants for true and false
static datatype Assn.True true_assn = True;
static datatype Assn.False false_assn = False;

//////////////////////////////////////////////////////////////
// hash-consing to try to preserve as much sharing as we
// can -- has a nice impact on performance (much better than
// lazy substitution), but alas, we still end up allocating a lot.  
// It would be better if we didn't have to allocate the thing 
// that want to lookup.  That could happen if we had a different 
// type for hashtable lookup (as we did with dictionaries.)

// FIX: need a good hash function...
static int assnhash(datatype Assn @a) {
  switch (a) {
  case &False: return 0;
  case &True: return 1;
  case &Prim(t1,p,t2): 
    return (unsigned int)t1 ^ (unsigned int)p ^ (unsigned int)t2;
  case &And(a1,a2): return (unsigned int)a1 ^ (unsigned int)a2;
  case &Or(a1,a2): return ((unsigned int)a1 ^ (unsigned int)a2) | 1;
  case &Subst(vd,t,a): return ((unsigned int)a ^ (unsigned int)vd ^
                               (unsigned int)t) | 3;
  case &Kill(a): return (unsigned int)a + 37;
  }
}

// compare two assertions for structural equality -- does not assume
// the components have been hash-consed, but probably could.
static int assncmp(datatype Assn @a1, datatype Assn @a2) {
  if (a1 == a2) return 0;
  switch $(a1,a2) {
  case $(&True,&True): return 0;
  case $(&True,_): return -1;
  case $(_,&True): return 1;
  case $(&False,&False): return 0;
  case $(&False,_): return -1;
  case $(_,&False): return 1;
  case $(&Or(a11,a12),&Or(a21,a22)): fallthru(a11,a12,a21,a22);
  case $(&And(a11,a12),&And(a21,a22)): 
    int c = assncmp(a11,a21);
    if (c != 0) return c;
    return assncmp(a12,a22);
  case $(&Or(_,_),_): return -1;
  case $(_,&Or(_,_)): return 1;
  case $(&And(_,_),_): return -1;
  case $(_,&And(_,_)): return 1;
  case $(&Prim(t11,p1,t12),&Prim(t21,p2,t22)):
    int c = (int)p1 - (int)p2;
    if (c != 0) return c;
    c = cmp_term(t11,t21);
    if (c != 0) return c;
    return cmp_term(t12,t22);
  case $(&Prim(...),_): return -1;
  case $(_,&Prim(...)): return 1;
  case $(&Kill(a1),&Kill(a2)): return assncmp(a1,a2);
  case $(&Kill(_),_): return -1;
  case $(_,&Kill(_)): return 1;
  case $(&Subst(vd1,t1,a1),&Subst(vd2,t2,a2)):
    int c = (int)vd1 - (int)vd2;
    if (c != 0) return c;
    c = cmp_term(t1,t2);
    if (c != 0) return c;
    return assncmp(a1,a2);
  }
}

// a hash-table to hold all of the assertion nodes to maximize
// sharing.  we also record whether or not a node has delayed
// substitutions or kills within it.
static struct Hashtable::Table<assn_t,$(assn_t,bool reduced)@> 
*hash_cons_table = NULL;

// lookup an assertion to see if it has delayed substitutions or
// kills with in it.  
static bool is_reduced(assn_t a) {
  let resopt = Hashtable::lookup_opt((Hashtable::table_t)hash_cons_table,a);
  if (resopt == NULL) return false;
  let &$(_,b) = *resopt;
  return b;
}

// shallow copy of an assertion from region `r to the heap and 
// simultaneously determine whether or not the assertion is
// reduced so that we can put the information in the table.
static $(assn_t,bool reduced) copy_assn(datatype Assn@`r a){
  switch (a) {
  case &True: return $(&true_assn,true);
  case &False: return $(&false_assn,false);
  case &And(a1,a2): 
    return $(new And(a1,a2),is_reduced(a1) && is_reduced(a2));
  case &Or(a1,a2): 
    return $(new Or(a1,a2),is_reduced(a1) && is_reduced(a2));
  case &Prim(t1,p,t2): return $(new Prim(t1,p,t2),true);
  case &Subst(vd1,t1,a1): return $(new Subst(vd1,t1,a1),false);
  case &Kill(a): return $(new Kill(a),false);
  }
}

// given an assertion node, look it up in the hash-table.  If it's
// not already there, then make a shallow copy and enter it (along
// with info regarding whether or not it's been reduced) into the
// hash table.
static assn_t hash_cons(datatype Assn@`r a) {
  Hashtable::table_t h;
  if (hash_cons_table == NULL) {
    h = Hashtable::create(123, assncmp, assnhash);
    hash_cons_table = h;
    // make sure true and false are in the table so we can
    // ask if they are reduced.
    Hashtable::insert(h,&true_assn,new $(&true_assn,true));
    Hashtable::insert(h,&false_assn,new $(&false_assn,true));
  } else 
    h = (Hashtable::table_t)hash_cons_table;
  let resopt = Hashtable::lookup_other_opt(h,a,assncmp,assnhash);
  if (resopt == NULL) {
    let $(res,reduced) = copy_assn(a);
    Hashtable::insert(h,res,new $(res,reduced));
    return res;
  } else {
    let &$(res,_) = *resopt;
    return res;
  }
}

// build a kill node.
static assn_t kill(assn_t a) {
  switch (a) {
  case &True: 
  case &False:
  case &Kill(_): return a; // Kill(Kill(a)) = Kill(a)
  default:
    let p = Kill(a);
    return hash_cons(&p);
  }
}

// build an and node.
static assn_t and(assn_t a1, assn_t a2) {
  if (a1 == a2) return a1;
  switch $(a1,a2) {
  case $(&True,_): return a2;
  case $(_,&True): return a1;
  case $(&False,_): return a1;
  case $(_,&False): return a2;
  case $(&Kill(a1),&Kill(a2)): 
    // And(Kill(a1),Kill(a2)) = Kill(And(a1,a2))
    return kill(and(a1,a2));
  default: 
    // Sort the two operands so that we're more likely to share.
    // Note that we could do more than this and, for instance,
    // right-associate and's but this doesn't seem to be a win.
    if ((int)a1 > (int)a2)
      a1 :=: a2;
    let a = And(a1,a2);
    return hash_cons(&a);
  }
}

// build an or-node.
static assn_t or(assn_t a1, assn_t a2) {
  if (a1 == a2) return a1;
  switch $(a1,a2) {
  case $(&True,_): return a1;
  case $(_,&True): return a2;
  case $(&False,_): return a2;
  case $(_,&False): return a1;
  case $(&Kill(a1),&Kill(a2)): 
    // Or(Kill(a1),Kill(a2)) = Kill(Or(a1,a2))
    return kill(or(a1,a2));
  default: 
    // sort the operands and hash-cons.
    if ((int)a1 > (int)a2)
      a1 :=: a2;
    let a = Or(a1,a2);
    return hash_cons(&a);
  }
}

// build a lazy substitution node.  
static assn_t subst(vardecl_t x, term_t newx, assn_t a) {
  switch (a) {
  case &True:
  case &False: return a;
  default:
    let p = Subst(x,newx,a); 
    return hash_cons(&p);
  }
}

// build a primitive relation node.
static assn_t prim(term_t t1, prim_reln_t p, term_t t2) {
  let ptr = Prim(t1,p,t2);
  return hash_cons(&ptr);
}

// some macros and functions for particular primitive relations.
#define prim_assn(p,P) static assn_t p(term_opt_t t1, term_opt_t t2) { \
  if (t1 == NULL || t2 == NULL) return &true_assn; \
  return prim((term_t)t1,P,(term_t)t2); \
}
prim_assn(eq,Eq)
prim_assn(neq,Neq)
prim_assn(lt,Lt)
prim_assn(lte,Lte)
#define gte(t1,t2) (lte(t2,t1))
#define gt(t1,t2) (lt(t2,t1))
  
////// Push Through Subst and Kill nodes ////
// These functions take care of eliminating all of the Kill and
// Subst nodes in an assertion in one pass.  It is, unfortunately,
// something that requires crawling over the tree, not just the dag.
// However, we could improve things by memoizing the results, since
// it's likely that we'll hit the same substitutions for various
// assertion nodes.  The problem is that we will generally have
// different environments built up when we run into them.

// Both reduce_term and reduce_assn take in a substitution for 
// non-escaping variables, as well as a pointer to a substitution
// for escaping variables.  We want to reduce Kill(a) to something
// like substitute fresh logic variables for each escaping variable
// in a.  We do this by accumulating a substitution for the escaping
// variables as we go.  So, the esc_subst pointer is non-NULL when
// we are under a Kill node.

// TRY: we could try using dictionaries here instead of lists.
static term_t 
reduce_term(term_t t, list_t<$(vardecl_t,term_t)@`H,`H> non_esc_subst,
            list_t<$(vardecl_t,term_t)@`H,`H> *esc_subst) {
  switch (t) {
  case &Const(_):
  case &LogicVar(...): return t;
  case &Primop(p,ts):
    list_t<term_t> res = NULL;
    bool change = false;
    for (let ptr = ts; ptr != NULL; ptr = ptr->tl) {
      let old_term = ptr->hd;
      let new_term = reduce_term(old_term,non_esc_subst,esc_subst);
      res = new List{new_term,res};
      if (new_term != old_term) change = true;
    }
    if (!change) return t;
    return new Primop(p,imp_rev(res));
  case &Var(vd):
    if (vd->escapes && esc_subst != NULL) {
      // it's an escaping variable and we're under a Kill node.
      // see if we've already assigned it a fresh variable in the esc_subst.
      let s = *esc_subst;
      for (; s != NULL; s = s->tl) {
        let $(vd2,t2) = *s->hd;
        if (vd2 == vd) return t;
      }
      // if not, then assign it a fresh variable and record it in the
      // esc_subst.
      let t = fresh_var();
      *esc_subst = new List{new $(vd,t),*esc_subst};
      return fresh_var();
    } else if (!vd->escapes) {
      // it's a non-escaping variable -- look it up in non_esc_subst.
      for (; non_esc_subst != NULL; non_esc_subst = non_esc_subst->tl) {
        let $(vd2,t2) = *non_esc_subst->hd;
        if (vd == vd2) return t2;
      }
    }
    return t;
  }
}

static assn_t 
reduce_assn(assn_t a, list_t<$(vardecl_t,term_t)@`H,`H> non_esc_subst, 
            list_t<$(vardecl_t,term_t)@`H,`H> *esc_subst) {
  switch (a) {
  case &True:
  case &False: return a;
  case &Prim(t1,p,t2):
    let newt1 = reduce_term(t1,non_esc_subst,esc_subst);
    let newt2 = reduce_term(t2,non_esc_subst,esc_subst);
    if (t1 == newt1 && t2 == newt2) return a;
    return prim(newt1,p,newt2);
  case &And(a1,a2):
    let newa1 = reduce_assn(a1,non_esc_subst,esc_subst);
    let newa2 = reduce_assn(a2,non_esc_subst,esc_subst);
    if (a1 == newa1 && a2 == newa2) return a;
    return and(newa1,newa2);
  case &Or(a1,a2):
    let newa1 = reduce_assn(a1,non_esc_subst,esc_subst);
    let newa2 = reduce_assn(a2,non_esc_subst,esc_subst);
    if (a1 == newa1 && a2 == newa2) return a;
    return or(newa1,newa2);
  case &Kill(a): 
    // start a new esc_subst for a.  not sure this is necessary
    // when esc_subst is non-null...
    list_t<$(vardecl_t,term_t)@> new_esc_subst = NULL;
    return reduce_assn(a,non_esc_subst,&new_esc_subst);
  case &Subst(vd,t,a):
    // add vd->t to the non_esc_subst
    t = reduce_term(t,non_esc_subst,esc_subst);
    non_esc_subst = new List(new $(vd,t),non_esc_subst);
    return reduce_assn(a,non_esc_subst,esc_subst);
  }
}

// get rid of all Kill and Subst nodes.
static assn_t reduce(assn_t a) {
  // check to see if we've already eliminated them.
  if (is_reduced(a)) return a;
  return reduce_assn(a,NULL,NULL);
}

// a one-shot substitution -- needed in the assignment code below.
static term_t subst_term(term_t t, vardecl_t x, term_t newx) {
  switch (t) {
  case &Const(_):
  case &LogicVar(...): return t;
  case &Primop(p,ts):
    list_t<term_t> res = NULL;
    bool change = false;
    for (let ptr = ts; ptr != NULL; ptr = ptr->tl) {
      let old_term = ptr->hd;
      let new_term = subst_term(old_term,x,newx);
      res = new List{new_term,res};
      if (new_term != old_term) change = true;
    }
    if (!change) return t;
    return new Primop(p,imp_rev(res));
  case &Var(vd):
    if (vd == x) return newx;
    return t;
  }
}

// an eager kill for terms (we don't bother to do terms lazily, only assns)
static term_t kill_mem_term(term_t t) {
  let esc_subst = NULL;
  return reduce_term(t,NULL,&esc_subst);
}

////////// Implication for Assertions //////////////

// returns true when ctxt |- t1 p t2
// uses only very local, syntactic matching.
// assumes ctxt is reduced.
static bool find_ctxt(assn_t ctxt, term_t t1, prim_reln_t p1, term_t u1) {
  switch (ctxt) {
  case &False: return true;
  case &True: return false;
  case &And(a1,a2): return find_ctxt(a1,t1,p1,u1) || find_ctxt(a2,t1,p1,u1);
  case &Or(a1,a2): return find_ctxt(a1,t1,p1,u1) && find_ctxt(a2,t1,p1,u1);
  case &Prim(t2,p2,u2):
    switch $(p2,p1) {
    case $(Eq,Eq): 
    case $(Eq,Lte):
      return (same_term(t1,t2) && same_term(u1,u2) ||
              same_term(t1,u2) && same_term(u1,t2));
    case $(Lt,Neq): 
      return (same_term(t1,t2) && same_term(u1,u2) ||
              same_term(t1,u2) && same_term(u1,t2));
    case $(Lt,Lt):
    case $(Lt,Lte): 
    case $(Lte,Lte):
    case $(Neq,Neq):
      return same_term(t1,t2) && same_term(u1,u2);
    default: return false;
    }
  default: Tcutil::impos("Vcgen::find_ctxt");
  }
}

// returns true when ctxt |- a
// uses only very local, syntactic matching.
// assumes a is reduced.
static bool simple_prove(assn_t ctxt, assn_t a) {
  if (ctxt == a) return true;
  switch (a) {
  case &True: return true;
  case &False: return false;
  case &And(a1,a2): return simple_prove(ctxt,a1) && simple_prove(ctxt,a2);
  case &Or(a1,a2): return simple_prove(ctxt,a1) || simple_prove(ctxt,a2);
  case &Prim(t1,p,t2): return find_ctxt(reduce(ctxt),t1,p,t2); 
  default: Tcutil::impos("Vcgen::simple_prove");
  }
}

static bool constraint_prove(assn_t ctxt, assn_t a) {
  // FIX: here's where we want to use the pratt stuff.
  return false;
}

// returns true if a2 is provable from a1 (i.e., a1 |- a2)
// tries simple_prove first and then tries the constraint solver
static bool implies(assn_t a1, assn_t a2) {
  return simple_prove(a1,reduce(a2)) || constraint_prove(a1,a2);
}


////////// Widening for Assertions ////////////////////

// We want to find an assertion a' such that ctxt => a' and a => a'.
// (so or(ctxt,a) => a'.)  In addition, we want a' to have size less
// than or equal to a.  
static assn_t weaken(assn_t ctxt, assn_t a) {
  a = reduce(a);
  if (implies(ctxt,a)) return a;
  switch (a) {
  case &And(a1,a2):
    let b1 = weaken(ctxt,a1);            // IH: ctxt=>b1 & a1=>b1
    let b2 = weaken(ctxt,a2);            // IH: ctxt=>b2 & a2=>b2
    if (implies(b1,b2)) return b1;
    if (implies(b2,b1)) return b2;
    return and(b1,b2);                   // ctxt => b1&b2  a1&a2=> b1&b2
  case &Or(a1,a2):
    let b1 = weaken(a2,a1);           // a1=>b1 & a2=>b1
    let b2 = weaken(a1,a2);           // a2=>b2 & a1=>b2
    let c = weaken(ctxt,and(b1,b2));  // ctxt=>c  b1&b2=>c  a1|a2=>b1&b2
    return c;
  case &True: 
  case &False: 
  case &Prim(...): return &true_assn;
  default: Tcutil::impos("Vcgen::weaken");
  }
}

// We are given assertions A1 and A2 and would like to find
// the strongest assertion A such that A1 implies A and
// A2 implies A.  However, we would like to also ensure that
// A is "smaller" than A2.  The widen operation ensures that
// either we get back A2 or else the assertion is smaller
// (or as a technical hitch, we flip once from false to true.)
static assn_t widen_assn(assn_t a1, assn_t a2) {
  return weaken(a1,a2);
}

////////// Updating an Assertion //////////////////
static term_t fresh_nonescvar(env_t env, vardecl_t vd);

// We are executing tgt := src
static assn_t do_assign(env_t env, assn_t a, term_opt_t tgt, term_opt_t src) {
  switch (tgt) {
  case NULL: 
    // We don't know what the target is except that it's not a non-escaping
    // variable, so we must kill those references.
    return kill(a);
  case &Var(vd):
    // We know what the target is -- if it escapes then we kill all 
    // escaping variables, otherwise we just kill the target vd by
    // substituting a fresh logic variable.
    // We must make sure to also kill within the src term.
    if (vd->escapes) {
      a = kill(a);
      src = (src == NULL) ? NULL : kill_mem_term(src);
    } else {
      let v2 = fresh_nonescvar(env,vd);
      a = subst(vd,v2,a);
      src = (src == NULL) ? NULL : subst_term(src,vd,v2);
    }
    // Finally, add in tgt == src.
    return and(a,eq(tgt,src));
  default: Tcutil::impos("vcgen do_assign");
  }
}

///////////////////// Analysis /////////////////////

////////// Analysis Environment /////////////////////
struct SharedEnv {
  // a mapping from statements to accumulated pre-conditions 
  Hashtable::table_t<stmt_t,assn_t@> assn_table;
  // a mapping for successors in the control-flow graph (from jump_analysis)
  Hashtable::table_t<stmt_t,stmt_opt_t> succ_table;
  // the assertion accumulated for the current exception handler
  assn_t try_assn;
  // when not-null is used to record the resulting value of an expr-stmt.
  term_opt_t* exp_stmt;
  // used to record the result terms and assertions for a function
  term_opt_t  res_term;
  assn_t      res_assn;
};

typedef Dict::dict_t<vardecl_t,int> state_counter_t;

struct Env {
  struct SharedEnv @shared;
  // A clever idea from Yanling for simulating SSA:
  // For non-escaping variables, we keep a state counter so that when
  // we kill a variable on two separate paths, we retain some sharing
  // for the old values.  For instance, if we have:
  //     [x==0 && x==y] if (c) { x := 4; } else { x := 5; }
  // then we want to end up killing x with the same variable _x0 
  // upon each update so that we get on output:
  // ([_x0==0 && _x0==y && c && x == 4] ||[_x0==0 && _x0==y && !c && x == 5])
  // This will make it easier to collapse this into:
  //  [_x0==0 && _x0==y && (c && x == 4 || !c && x == 5)]
  state_counter_t state_counter;
};

static int hash_ptr(`a s) { return (int)s; }

static env_t 
initial_env(JumpAnalysis::jump_anal_res_t tables, Absyn::fndecl_t fd) {
  let succ_table = Hashtable::lookup(tables->succ_tables,fd);
  let assn_table = Hashtable::create(57, Core::ptrcmp, hash_ptr);
  let senv =  new SharedEnv{.assn_table = assn_table,
                            .succ_table = succ_table,
                            .try_assn = &false_assn,
                            .exp_stmt = NULL,
                            .res_term = NULL,
                            .res_assn = &false_assn};
  let d = Dict::empty(Core::ptrcmp);
  return new Env { .shared = senv, .state_counter = d };
}

static env_t copy_env(env_t env) {
  return new(*env);
}

// we have to merge environments at a join-point to get the
// next in a sequence.
static int max_counter(int dummy, vardecl_t vd, int i, int j) {
  return (i < j) ? j : i;
}

static void merge_env(env_t old_env, env_t new_env) {
  old_env->state_counter = Dict::union_two_c(max_counter, 0, 
                                             old_env->state_counter, 
                                             new_env->state_counter);
}

// generate a fresh logic variable for a non-escaping variable --
// the next one in a sequence.
static term_t fresh_nonescvar(env_t env, vardecl_t vd) {
  int res = 0;
  Dict::lookup_bool(env->state_counter,vd,&res);
  env->state_counter = Dict::insert(env->state_counter,vd,res+1);
  return new LogicVar(vd,res);
}

// each statement may have an assertion associated with it from
// other incoming edges -- we must take into account all paths.
static assn_t pre_stmt_update(env_t env, stmt_t s, assn_t ain) {
  let popt = Hashtable::lookup_opt(env->shared->assn_table,s);
  if (popt != NULL) {
    assn_t @p = *popt;
    let new_precondition = or(ain,*p);
    *p = new_precondition;
    return new_precondition;
  } else 
    return ain;
}

// get the pre-condition currently associated with a statement.
static assn_t get_assn(env_t env, stmt_t s) {
  assn_t @* popt = Hashtable::lookup_opt(env->shared->assn_table,s);
  if (popt != NULL)
    return **popt;
  else
    return &false_assn;
}

// similar to pre_stmt_update except that we use widen instead of or
// since this is part of a loop back-edge.
static assn_t loop_assn(env_t env, stmt_t s, assn_t ain) {
  assn_t @* aprevopt = Hashtable::lookup_opt(env->shared->assn_table,s);
  if (aprevopt != NULL) {
    let aprev = *aprevopt;
    ain = widen_assn(ain,*aprev);
    *aprev = ain;
  } else {
    Hashtable::insert(env->shared->assn_table,s,new ain);
  }
  return ain;
}

// similar to pre_stmt_update but makes sure to put the
// result on the statement.
static assn_t forward_assn(env_t env, stmt_t s, assn_t ain) {
  assn_t@* aprevopt = Hashtable::lookup_opt(env->shared->assn_table,s);
  if (aprevopt != NULL) {
    let aprev = *aprevopt;
    ain = or(ain,*aprev);
    *aprev = ain;
  } else {
    Hashtable::insert(env->shared->assn_table,s,new ain);
  }
  return ain;
}

// update the assertion associated with the current 
// exception handler.
static void update_try_assn(env_t env, assn_t a) {
  env->shared->try_assn = or(env->shared->try_assn,a);
}

// update the return information for a function
static void update_return(env_t env, term_opt_t t, assn_t a) {
  let shared = env->shared;
  if (shared->res_term != NULL || t != NULL) {
    let v = fresh_var();
    shared->res_assn = 
      or(and(a,eq(v,t)),and(shared->res_assn,eq(v,shared->res_term)));
  } else {
    shared->res_assn = or(a,shared->res_assn);
  }
}

// forward declarations for the analysis functions.

// Vcgen for statements.  ain is an assertion describing the state
// on input to the statement, and this returns an assertion describing 
// the output state. 
static assn_t vcgen_stmt_nodebug(env_t env, stmt_t s, assn_t ain);
// Analyze a term given precondition ain and generate an optional term
// and post-condition representing the value of the expression and
// the resulting machine state.
static $(term_opt_t,assn_t) vcgen_rexp_nodebug(env_t env, exp_t e, assn_t ain);
// If the term is "undefined" then we return a fresh variable.
static $(term_t,assn_t) vcgen_rexp_always(env_t env, exp_t e, assn_t ain);
// Same as above, but for lhs-expressions.
static $(term_opt_t,assn_t) vcgen_lexp(env_t env, exp_t e, assn_t ain);
// Analyze a test expression returning two assertions corresponding
// to the test succeeding (true-case) or failing (false-case).
static $(assn_t t,assn_t f) vcgen_test(env_t env, exp_t e, assn_t ain);
// Analyze a list of expressions returning an optional list of
// terms and the output assertion.  If any of the expressions'
// is unknown, then so is the whole thing.
static $(list_t<term_t>*,assn_t) vcgen_rexps(env_t env, list_t<exp_t> es, assn_t a);
// Similar to above but here we don't care what the resulting terms
// are at all.
static assn_t vcgen_rexps_nosave(env_t env, list_t<exp_t> es, assn_t a);
// Folds vcgen_rexp_always across the list.
static $(list_t<term_t>,assn_t) vcgen_rexps_always(env_t env, list_t<exp_t> es, assn_t ain);
// Do vcgen for all of the cases in a switch.  
static assn_t vcgen_switch(env_t env, list_t<switch_clause_t> scs, assn_t ain);
// Do vcgen for a local declaration
static assn_t vcgen_local_decl(env_t env, decl_t d, assn_t a);

#ifdef VCGEN_DEBUG
//#define vcgen_rexp(env,e,a) vcgen_rexp_debug(env,e,a)
#define vcgen_rexp(env,e,a) vcgen_rexp_nodebug(env,e,a)
#define vcgen_stmt(env,s,a) vcgen_stmt_debug(env,s,a)
static unsigned int indent = 0;
static void print_tabs() {
  for (unsigned i = indent; i > 0; i--)
    fprintf(stderr," ");
}
static string_t stmt2shortstring(stmt_t s) {
  switch (s->r) {
  case &Absyn::IfThenElse_s(e,...): 
    return aprintf("if (%s) ...",Absynpp::exp2string(e));
  case &Absyn::While_s($(e,_),_):
    return aprintf("while (%s) ...",Absynpp::exp2string(e));
  case &Absyn::For_s(e1,$(e2,_),$(e3,_),_):
    return aprintf("for (%s;%s;%s) ...",Absynpp::exp2string(e1),
                   Absynpp::exp2string(e2),Absynpp::exp2string(e3));
  case &Absyn::Switch_s(e,...): 
    return aprintf("switch (%s) ...",Absynpp::exp2string(e));
  case &Absyn::Do_s(_,$(e,_)):
    return aprintf("do ... while (%s)",Absynpp::exp2string(e));
  case &Absyn::TryCatch_s(s,...): 
    return aprintf("try %s catch ...",stmt2shortstring(s));
  default: return Absynpp::stmt2string(s);
  }
}
static assn_t vcgen_stmt_debug(env_t env, stmt_t s, assn_t ain) {
  switch (s->r) {
  case &Absyn::Seq_s(_,_): 
  case &Absyn::Decl_s(...):
    //case &Absyn::Exp_s(...):
  case &Absyn::Skip_s: return vcgen_stmt_nodebug(env,s,ain);
  default:
    print_tabs();
    let str = assn2string(ain);
    fprintf(stderr,"stmt %s pre(%d/%d)=%s\n",stmt2shortstring(s),assn_size(ain),tree_size,str);
    indent += 2;
    let aout = vcgen_stmt_nodebug(env,s,ain);
    indent -= 2;
    print_tabs();
    let str = assn2string(aout);
    fprintf(stderr,"stmt %s, post(%d/%d)=%s\n",stmt2shortstring(s),assn_size(aout),tree_size,str);
    return aout;
  }
}
static $(term_opt_t,assn_t) vcgen_rexp_debug(env_t env, exp_t e, assn_t ain) {
  print_tabs();
  fprintf(stderr,"exp %s, pre=%s\n",Absynpp::exp2string(e),assn2string(ain));
  indent += 2;
  let $(t,a) = vcgen_rexp_nodebug(env,e,ain);
  indent -= 2;
  print_tabs();
  fprintf(stderr,"exp %s ==> %s, post: %s\n",Absynpp::exp2string(e),
          ((t == NULL) ? "?" : term2string((term_t)t)), assn2string(ain));
  return $(t,a);
}

#else
#define vcgen_rexp(env,e,a) vcgen_rexp_nodebug(env,e,a)
#define vcgen_stmt(env,s,a) vcgen_stmt_nodebug(env,s,a)
#endif

// To simplify things, I'm treating the control-flow as if it were
// structured.  Upon reaching a labelled statement, I set the pre-
// condition to "True" which is conservative.   This lets me do
// local iteration for loops and so forth to generate invariants,
// since the only back-edges in the simplified graph are always
// part of the control constructs.  
static assn_t vcgen_stmt_nodebug(env_t env, stmt_t s, assn_t ain) {
  // merge the pre-condition with any pre-recorded assertions.
  // we'll have one if there was some control-flow to this statement.
  ain = pre_stmt_update(env,s,ain);
  //assn_size(ain);
  // don't bother analyzing if we can show the assertion is false
  // (effectively an unreachable state.)
  switch (ain) {
  case &False: return ain;
  default: break;
  }
  switch (s->r) {
  case &Absyn::Skip_s: return ain;
  case &Absyn::Exp_s(e): 
    let $(t,aout) = vcgen_rexp(env,e,ain);
    // a little trickery to deal with statement expressions -- we
    // record the result in the environment here.
    if (env->shared->exp_stmt != NULL) 
      *(env->shared->exp_stmt) = t;
    return aout;
  case &Absyn::Seq_s(s1,s2): return vcgen_stmt(env,s2,vcgen_stmt(env,s1,ain));
  case &Absyn::Return_s(NULL): 
    update_return(env,NULL,ain);
    return &false_assn;
  case &Absyn::Return_s(e as &_): 
    let $(t,aout) = vcgen_rexp(env,(exp_t)e,ain);
    update_return(env,t,aout);
    return &false_assn;
  case &Absyn::IfThenElse_s(e1,s1,s2):
    let $(at,af) = vcgen_test(env,e1,ain);
    let env2 = copy_env(env);
    at = vcgen_stmt(env,s1,at);
    af = vcgen_stmt(env2,s2,af);
    merge_env(env,env2);
    return or(at,af);
  case &Absyn::While_s($(e,dummy),s):
    // we're doing local iteration here -- we join with the
    // assertion on the dummy and widen each time around the loop since
    // its assertion will be updated by a continue.  We disallow
    // goto's in the analysis by essentially forcing their destination's
    // assertion to be true.
    while (true) {
      ain = loop_assn(env,dummy,ain);
      let $(at,af) = vcgen_test(env,e,ain);
      ain = vcgen_stmt(env,s,at);
      if (implies(ain,get_assn(env,dummy))) return af;
    } 
  case &Absyn::Continue_s: fallthru;
    // continue is a backwards jump in a loop, but we take
    // that into account as part of the loop iteration.
    let dest = Hashtable::lookup(env->shared->succ_table,s);
    loop_assn(env, (stmt_t)dest, ain);
    return &false_assn;
  case &Absyn::Break_s:
    // break is a forwards jump so we can do an Or.  This assertion
    // that we set on the destination will be picked up when we hit
    // that statement.  
    let dest = Hashtable::lookup(env->shared->succ_table,s);
    if (dest == NULL) 
      update_return(env,NULL,ain);
    else 
      forward_assn(env, (stmt_t)dest, ain);
    return &false_assn;
  case &Absyn::For_s(e1,$(e2,dummy2),$(e3,dummy3),s):
    let $(_,a) = vcgen_rexp(env,e2,ain);
    ain = a;
    // similar to while loop.
    while (true) {
      ain = loop_assn(env,dummy2,ain);
      let $(at,af) = vcgen_test(env,e2,ain);
      ain = vcgen_stmt(env,s,at);
      // must do pre-statement check because continue goes here
      ain = pre_stmt_update(env,dummy3,ain);
      ain = vcgen_rexp(env,e3,ain)[1];
      if (implies(ain,get_assn(env,dummy2))) return af;
    }
  case &Absyn::Do_s(s,$(e,dummy)):
    // similar to while loop
    while (true) {
      ain = vcgen_stmt(env,s,ain);
      let $(at,af) = vcgen_test(env,e,ain);
      ain = widen_assn(get_assn(env,dummy),ain);
      if (implies(ain,get_assn(env,dummy))) return af;
      loop_assn(env,dummy,ain);
    }
  case &Absyn::Switch_s(e,scs,_):
    // FIX: take into acount test of e
    // note that we do not split the state counter for a switch
    // because a fallthru might lead to problems.  if we merged
    // environments at entry points of control-flow paths, then
    // we could handle this.
    let $(t,a) = vcgen_rexp(env,e,ain);
    return vcgen_switch(env,scs,a);
  case &Absyn::Fallthru_s(_,NULL): Tcutil::impos("vcgen fallthru");
  case &Absyn::Fallthru_s(es,&dest):
    // Also a forward jump so we can do an or.
    let $(ts,a) = vcgen_rexps_always(env,es,ain);
    // initialize the pattern variables with their corresponding terms
    for (let x = dest->pat_vars->v; x != NULL; x = x->tl,ts = ts->tl) {
      let &$(vd,ve) = x->hd;
      if (vd != NULL) 
        a = do_assign(env,a,new Var(*vd),ts->hd);
    }
    forward_assn(env, dest->body, a);
    return &false_assn;
  case &Absyn::Decl_s(d,s):
    return vcgen_stmt(env,s,vcgen_local_decl(env,d,ain));
  case &Absyn::Label_s(_,s): 
    // by making the assertion True here, we're effectively losing
    // all information when we do a goto.  This is conservative, 
    // and means that I don't have to worry about non-structured
    // control-flow.
    return vcgen_stmt(env,s,&true_assn);
  case &Absyn::Goto_s(_): return &false_assn; // see above
  case &Absyn::TryCatch_s(s,scs,_):
    // save old try/catch-handler assertion
    let old_try_assn = env->shared->try_assn;
    // install new try/catch-handler assertion
    env->shared->try_assn = &false_assn;
    // run vcgen on the body -- this will update the env->shared->try_assn 
    // with assertions of any state that might throw an exn.
    ain = vcgen_stmt(env,s,ain);
    // restore the old handler's assertion.
    let new_try_assn = env->shared->try_assn;
    env->shared->try_assn = old_try_assn;
    // analyze the catch handlers and merge with the body to get
    // the final output.
    return or(ain,vcgen_switch(env,scs,new_try_assn));
  }
}

static assn_t vcgen_switch(env_t env, list_t<switch_clause_t> scs, assn_t ain) {
  // note that all of the clauses should explicitly jump (via break)
  // or something else outside of the clause so the result should always
  // be false...
  assn_t res = &false_assn;
  for (; scs != NULL; scs = scs->tl) {
    let sc = scs->hd;
    let a = ain;
    for (let pvs = sc->pat_vars->v; pvs != NULL; pvs = pvs->tl) {
      let &$(vdopt,eopt) = pvs->hd;
      if (vdopt != NULL) {
        if (eopt != NULL)
          a = do_assign(env,a,new Var(*vdopt),vcgen_rexp(env,(exp_t)eopt,a)[0]);
        else 
          a = do_assign(env,a,new Var(*vdopt),fresh_var());
      }
    }
    if (sc->where_clause != NULL) 
      a = vcgen_test(env, (exp_t)sc->where_clause, a)[0];
    res = or(res,vcgen_stmt(env,sc->body,a));
  }
  return res;
}

static assn_t add_vardecl(env_t env, vardecl_t vd, assn_t a) {
  // stupid C semantics means I have to put in a dummy value for vd first,
  // then run the initializer.  
  let tv = new Var(vd);
  a = do_assign(env,a,tv,fresh_var());
  if (vd->initializer != NULL) {
    let $(t,a1) = vcgen_rexp(env,(exp_t)vd->initializer,a);
    a = do_assign(env,a1,tv,t);
  }
  return a;
}

static assn_t vcgen_local_decl(env_t env, decl_t d, assn_t a) {
  switch (d->r) {
  case &Absyn::Var_d(vd): return add_vardecl(env,vd,a);
  case &Absyn::Let_d(p,vds,e,_): 
    let $(_,a) = vcgen_rexp(env,e,a);
    for (let vds = vds->v; vds != NULL; vds = vds->tl) {
      let $(vdopt,eopt) = *vds->hd;
      if (vdopt != NULL) {
        if (eopt == NULL) a = add_vardecl(env,*vdopt,a);
        else {
          let $(t,a1) = vcgen_rexp(env,e,a);
          let tv = new Var(*vdopt);
          a = do_assign(env,a1,tv,t);
        }
      }
    }
    return a;
  case &Absyn::Letv_d(vds): 
    for (; vds != NULL; vds = vds->tl)
      a = add_vardecl(env,vds->hd,a);
    return a;
  case &Absyn::Region_d(_,vd,eopt): 
    if (eopt != NULL) {
      let $(t,a1) = vcgen_rexp(env,(exp_t)eopt,a);
      a = a1;
    }
    // FIX: inaccurate but okay for now.
    a = add_vardecl(env,vd,a);
    return a;
  default: return a;
  }
}

static $(assn_t,assn_t) vcgen_test(env_t env, exp_t e, assn_t ain) {
  switch (e->r) {
  case &Absyn::Conditional_e(e1,e2,e3):
    let $(a1t,a1f) = vcgen_test(env,e1,ain);
    let $(a2t,a2f) = vcgen_test(env,e2,a1t);
    let $(a3t,a3f) = vcgen_test(env,e3,a1f);
    return $(or(a2t,a3t),or(a2f,a3f));
  case &Absyn::And_e(e1,e2):
    let $(a1t,a1f) = vcgen_test(env,e1,ain);
    let $(a2t,a2f) = vcgen_test(env,e2,a1t);
    return $(a2t, or(a1f,a2f));
  case &Absyn::Or_e(e1,e2):
    let $(a1t,a1f) = vcgen_test(env,e1,ain);
    let $(a2t,a2f) = vcgen_test(env,e2,a1f);
    return $(or(a1t,a2t),a2f);
  case &Absyn::SeqExp_e(e1,e2):
    let $(_,ain) = vcgen_rexp(env,e1,ain);
    return vcgen_test(env,e2,ain);
  case &Absyn::Primop_e(Absyn::Not,&List(e1,_)):
    let $(at,af) = vcgen_test(env,e1,ain);
    return $(af,at);
  case &Absyn::Primop_e(p,&List(e1,&List(e2,NULL))):
    let $(t1,a1) = vcgen_rexp(env,e1,ain);
    let $(t2,a2) = vcgen_rexp(env,e2,a1);
    let at = a2;
    let af = a2;
    switch p {
    case Absyn::Eq:  at = and(at,eq(t1,t2));  af = and(af,neq(t1,t2)); break;
    case Absyn::Neq: at = and(at,neq(t1,t2)); af = and(af,eq(t1,t2)); break;
    case Absyn::Lt:  at = and(at,lt(t1,t2));  af = and(af,gte(t1,t2)); break;
    case Absyn::Lte: at = and(at,lte(t1,t2)); af = and(af,gt(t1,t2)); break;
    case Absyn::Gt:  at = and(at,gt(t1,t2));  af = and(af,lte(t1,t2)); break;
    case Absyn::Gte: at = and(at,gte(t1,t2)); af = and(af,lt(t1,t2)); break;
    default: break;
    }
    return $(at,af);
  default:
    let $(t,aout) = vcgen_rexp(env,e,ain);
    return $(and(aout,neq(t,zero())),and(aout,eq(t,zero())));
  }
}

static assn_t vcgen_rexps_nosave(env_t env, list_t<exp_t> es, assn_t a) {
  for (; es != NULL; es = es->tl) 
    a = vcgen_rexp(env,es->hd,a)[1];
  return a;
}

static $(list_t<term_t>*,assn_t) vcgen_rexps(env_t env, list_t<exp_t> es, assn_t a) {
  list_t<term_t> res = NULL;
  bool valid = true;
  for (; es != NULL; es = es->tl) {
    let $(t,aout) = vcgen_rexp(env,es->hd,a);
    a = aout;
    if (valid && t != NULL) {
      res = new List{(term_t)t,res};
    } else {
      valid = false;
    }
  }
  return $(valid ? new (imp_rev(res)) : NULL, a);
}

static $(term_t,assn_t) vcgen_rexp_always(env_t env, exp_t e, assn_t ain) {
  let $(topt,a) = vcgen_rexp(env,e,ain);
  return $(topt == NULL ? fresh_var() : (term_t)topt, a);
}

static $(list_t<term_t>,assn_t) vcgen_rexps_always(env_t env, list_t<exp_t> es, assn_t ain) {
  list_t<term_t> res = NULL;
  for (; es != NULL; es = es->tl) {
    let $(t,a) = vcgen_rexp_always(env,es->hd,ain);
    ain = a;
    res = new List(t,res);
  }
  return $(res,ain);
}

static vardecl_t bind2vardecl(Absyn::binding_t b) {
  switch (b) {
  case &Absyn::Global_b(vd): return vd;
  case &Absyn::Funname_b(fd): return (vardecl_t)fd->fn_vardecl;
  case &Absyn::Unresolved_b(...): Tcutil::impos("vcgen bind2vardecl");
  case &Absyn::Param_b(vd): return vd;
  case &Absyn::Local_b(vd): return vd;
  case &Absyn::Pat_b(vd): return vd;
  }
}

static $(term_opt_t,assn_t) vcgen_lexp(env_t env, exp_t e, assn_t ain) {
  switch (e->r) {
  case &Absyn::Var_e(b): 
      return $(new Var(bind2vardecl(b)),ain);
  default: return $(NULL, vcgen_rexp(env,e,ain)[1]);
  }
}

static term_opt_t deref_lterm(env_t env, term_opt_t lt, assn_t ain) {
  return lt;
}

static $(term_opt_t,assn_t) vcgen_rexp_nodebug(env_t env, exp_t e, assn_t ain) {
  if (Tcutil::is_const_exp(e)) return $(new Const(e),ain);
  switch (e->r) {
  case &Absyn::Const_e(c): 
    // should really be caught by the above...
    return $(new Const(e),ain);
  case &Absyn::Var_e(b): return $(new Var(bind2vardecl(b)),ain);
  case &Absyn::Primop_e(p,es):
    let $(ts,aout) = vcgen_rexps(env,es,ain);
    term_opt_t t = NULL;
    if (ts != NULL) t = primop(p,*ts);
    return $(t, aout);
  case &Absyn::AssignOp_e(e1,popt,e2):
    let $(lt,a1) = vcgen_lexp(env,e1,ain);
    let $(t2,a2) = vcgen_rexp(env,e2,a1);
    if (popt != NULL) {
      let t1 = deref_lterm(env,lt,a2);
      if (t1 == NULL || t2 == NULL) 
        t2 = NULL;
      else
        t2 = primop(popt->v,list((term_t)t1,(term_t)t2));
    }
    let a = do_assign(env,a2,lt,t2);
    return $(lt,a);
  case &Absyn::Increment_e(e,i):
    let $(lt,a1) = vcgen_lexp(env,e,ain);
    let t1 = deref_lterm(env,lt,a1);
    term_opt_t res = NULL;
    term_opt_t assn = NULL;
    switch (i) {
    case Absyn::PreInc: 
      if (t1 != NULL) assn = new Primop(Absyn::Plus,list((term_t)t1,one()));
      res = assn;
      break;
    case Absyn::PostInc:
      res = t1;
      if (t1 != NULL) assn = new Primop(Absyn::Plus,list((term_t)t1,one()));
      break;
    case Absyn::PreDec:
      if (t1 != NULL) assn = new Primop(Absyn::Minus,list((term_t)t1,one()));
      res = assn;
      break;
    case Absyn::PostDec:
      res = t1;
      if (t1 != NULL) assn = new Primop(Absyn::Minus,list((term_t)t1,one()));
      break;
    default: Tcutil::impos("vcgen vcgen_rexp increment_e");
    }
    let a = do_assign(env,a1,lt,assn);
    return $(res,a);
  case &Absyn::Conditional_e(e1,e2,e3):
    let $(at,af) = vcgen_test(env,e1,ain);
    let $(t1,at) = vcgen_rexp(env,e2,at);
    let $(t2,af) = vcgen_rexp(env,e3,af);
    if (t1 != NULL && t2 != NULL) {
      let v = fresh_var();
      at = and(at,eq(v,t1));
      af = and(af,eq(v,t2));
      return $(v,or(at,af));
    } else
      return $(NULL,or(at,af));
  case &Absyn::And_e(e1,e2):
    let $(at,af) = vcgen_test(env,e1,ain);
    let $(t,at) = vcgen_rexp(env,e2,at);
    let v = fresh_var();
    at = and(at,eq(v,t));
    af = and(af,eq(v,zero()));
    return $(v,or(at,af));
  case &Absyn::Or_e(e1,e2):
    let $(at,af) = vcgen_test(env,e1,ain);
    let $(t,af) = vcgen_rexp(env,e2,af);
    let v = fresh_var();
    at = and(at,eq(v,one()));
    af = and(af,eq(v,t));
    return $(v,or(at,af));
  case &Absyn::SeqExp_e(e1,e2):
    let $(_,a) = vcgen_rexp(env,e1,ain);
    return vcgen_rexp(env,e2,a);
  case &Absyn::FnCall_e(e,es,...):
    ain = vcgen_rexps_nosave(env,es,ain);
    let $(_,a2) = vcgen_rexp(env,e,ain);
    // kill every variable that points into memory -- could refine
    // this to only those reachable from globals or the parameters.
    a2 = kill(a2);
    // FIX: take pre- and post-condition into account
    // must update exception handler.
    update_try_assn(env,a2);
    // noreturn functions don't return...
    if (Tcutil::is_noreturn_fn_type((type_t)e->topt)) a2 = &false_assn;
    return $(NULL,a2);
  case &Absyn::Throw_e(e,_):
    let $(_,a) = vcgen_rexp(env,e,ain);
    update_try_assn(env,a);
    return $(NULL,&false_assn);
  case &Absyn::NoInstantiate_e(e): return vcgen_rexp(env,e,ain);
  case &Absyn::Instantiate_e(e,_):  return vcgen_rexp(env,e,ain);

  case &Absyn::Cast_e(t,e,_,c): 
    // FIX: really need to put C coercions in terms...
    let $(t,a) = vcgen_rexp(env,e,ain);
    if (c == Absyn::No_coercion)
      return $(t,a);
    else {
      update_try_assn(env,ain); // coercion could fail
      return $(NULL,a);
    }
  case &Absyn::New_e(eopt,e):
    if (eopt != NULL)
      ain = vcgen_rexp(env,(exp_t)eopt,ain)[1];
    return $(NULL,vcgen_rexp(env,e,ain)[1]);

  // these cases should be captured by the const-expression check above.
  case &Absyn::Enum_e(...):
  case &Absyn::AnonEnum_e(...):
  case &Absyn::Sizeoftype_e(_):
  case &Absyn::Sizeofexp_e(_):
  case &Absyn::Valueof_e(_):
  case &Absyn::Offsetof_e(_,_): return $(NULL,ain);

  // These can all throw exceptions
  case &Absyn::Deref_e(e): fallthru(e);
  case &Absyn::AggrMember_e(e,...): fallthru(e);
  case &Absyn::AggrArrow_e(e,...):
    ain = vcgen_rexp(env,e,ain)[1];
    update_try_assn(env,ain);
    return $(NULL,ain);

  case &Absyn::Tagcheck_e(e,_): fallthru(e);
  case &Absyn::Address_e(e): 
    return $(NULL,vcgen_rexp(env,e,ain)[1]);

  case &Absyn::Subscript_e(e1,e2): 
    let $(t1,a1) = vcgen_rexp(env,e1,ain);
    let $(t2,a2) = vcgen_rexp(env,e2,a1);
    switch (Tcutil::compress((type_t)e1->topt)) {
    case &Absyn::TupleType(_): break;
    default:
      if (t1 != NULL) {
        update_try_assn(env,ain);
        a2 = and(a2,lt(t2,new Primop(Absyn::Numelts,list(t1))));
      }
    }
    return $(NULL,a2);

  case &Absyn::Datatype_e(es,...): fallthru(es);
  case &Absyn::Tuple_e(es): return $(NULL,vcgen_rexps_nosave(env,es,ain));

  case &Absyn::CompoundLit_e(_,dles):   fallthru(dles);
  case &Absyn::Array_e(dles):           fallthru(dles);
  case &Absyn::Aggregate_e(_,_,dles,_): fallthru(dles);
  case &Absyn::UnresolvedMem_e(_,dles): fallthru(dles);
  case &Absyn::AnonStruct_e(_,dles):
    for (; dles != NULL; dles = dles->tl) {
      let &$(_,e) = dles->hd;
      ain = (vcgen_rexp(env,e,ain))[1];
    }
    return $(NULL,ain);

  case &Absyn::Comprehension_e(vd,e1,e2,_): 
    // similar to a while-loop except we evaluate e1 only once.
    let $(t1,a) = vcgen_rexp(env,e1,ain);
    let t1 = (t1 == NULL) ? fresh_var() : (term_t)t1;
    let v = new Var(vd);
    // start off with index 0
    a = do_assign(env,a,v,zero());
    while (true) {
      let at = and(a,lt(v,t1));  // simulate test
      let af = and(a,gte(v,t1));
      let $(_,abody) = vcgen_rexp(env,e2,at);  // run body and add one
      abody = do_assign(env,abody,v,new Primop(Absyn::Plus,list(v,one())));
      if (implies(abody,a)) { a = af; break; }
      a = widen_assn(abody,a);  // widen and possibly iterate
    }
    return $(NULL,a);
  case &Absyn::ComprehensionNoinit_e(e,_,_):
    return $(NULL,vcgen_rexp(env,e,ain)[1]);
  case &Absyn::Malloc_e(mi):
    if (mi.rgn != NULL) 
      ain = vcgen_rexp(env,(exp_t)mi.rgn,ain)[1];
    return $(NULL,vcgen_rexp(env,mi.num_elts,ain)[1]);
  case &Absyn::Swap_e(e1,e2): 
    let $(lt1,a1) = vcgen_lexp(env,e1,ain);
    update_try_assn(env,a1); // could have null-exn?
    let $(lt2,a2) = vcgen_lexp(env,e2,a1);
    update_try_assn(env,a2); // could have null-exn?
    let t1 = deref_lterm(env,lt1,a2);
    let t2 = deref_lterm(env,lt2,a2);
    a2 = do_assign(env,a2,lt1,t2);
    a2 = do_assign(env,a2,lt2,t1);
    return $(NULL,a2);
  case &Absyn::StmtExp_e(s):
    let old_exp_stmt = env->shared->exp_stmt;
    env->shared->exp_stmt = new NULL;
    let aout = vcgen_stmt(env,s,ain);
    let t = *(env->shared->exp_stmt);
    env->shared->exp_stmt = old_exp_stmt;
    return $(t,aout);
  case &Absyn::Asm_e(...): return $(NULL,ain);
  case &Absyn::Extension_e(e): return vcgen_rexp(env,e,ain);
  case &Absyn::Pragma_e(s): 
    if (strcmp(s,"print_assn")) {
      let seg_str = Position::string_of_segment(e->loc);
      fprintf(stderr,"%s: current assn is %s\n",seg_str,assn2string(ain));
    }
    return $(zero(),ain);
  case &Absyn::Assert_e(e1):
    let $(at,_) = vcgen_test(env,e1,&true_assn);
    if (!implies(ain,at)) 
      Warn::err(e->loc, "cannot prove @assert from %s",
                assn2string(ain));
    return $(one(),and(ain,at));
  }
}

// FIX? take into account top-level (const) variable intializers?
void vcgen_topdecls(JumpAnalysis::jump_anal_res_t tables, list_t<Absyn::decl_t> ds) {
  for (; ds != NULL; ds = ds->tl) {
    switch (ds->hd->r) {
    case &Absyn::Fn_d(fd):
      //fprintf(stderr,"Vcgen function %s\n",Absynpp::qvar2string(fd->name));
      //fprintf(stderr,"---------------------------------------\n");
      let env = initial_env(tables,fd);
      // FIX: put in pre-condition and check post-condition
      vcgen_stmt(env,fd->body,&true_assn);
      hash_cons_table = NULL; // collect table
      break;
    case &Absyn::Namespace_d(_,ds): fallthru(ds);
    case &Absyn::Using_d(_,ds): vcgen_topdecls(tables,ds); break;
    default: break;
    }
  }
}
