{
/* Lexer.
   Copyright (C) 2001 Greg Morrisett, AT&T
   This file is part of the Cyclone compiler.

   The Cyclone compiler is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   The Cyclone compiler is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with the Cyclone compiler; see the file COPYING. If not,
   write to the Free Software Foundation, Inc., 59 Temple Place -
   Suite 330, Boston, MA 02111-1307, USA. */

// WARNING: Because we now intern identifiers, you better never mutate them!
// WARNING: lex_init must be called for each source file!

#include <core.h>
#include <cycboot.h>
#include <list.h>
#include <lexing.h>
#include <set.h>
#include <string.h>
#include <xarray.h>
#include "parse.h"
#include <position.h>
#include <dict.h>
#include "tcutil.h"

using Core;
using List;
using Lexing;
using Parse;
using Absyn;
using Position;

void yyerror(string_t<`H> s) { 
  post_error(mk_err_parse(yylloc.first_line,s));
} 

namespace Lex {

bool compile_for_boot_r = false;

struct Trie<`r::R>;
typedef struct Trie<`r> *`r trie_t<`r>;
@tagged union TrieChildren<`r::R> {
  int Zero;
  $(int, trie_t<`r>) One;
  trie_t<`r> @{64}`r Many; // enough room for id chars and `
};
union TrieChildren<`r> Zero() { return TrieChildren{.Zero = 0}; }
union TrieChildren<`r> One(int i,trie_t<`r> t) { 
  return TrieChildren{.One = $(i,t)}; 
}
union TrieChildren<`r> Many(trie_t<`r>@{64}`r ts) {
  return TrieChildren{.Many = ts}; 
}
struct Trie<`r::R> {
  union TrieChildren<`r> children;
  int                 shared_str; // meaning depends on which trie -- see below
};

/////////////////////////////// Globals /////////////////////////////

// These must be (re-)initialized in lex_init.
static int    num_kws  = 0;
static int ?  kw_nums  = NULL;
  //static struct Xarray::Xarray<stringptr_t> * symbols  = NULL;
struct DynTrie {
  <`d::R> 
  dynregion_t<`d,`H> dyn;
  trie_t<`d>         t;
};
typedef struct DynTrie *dyn_trie_t;
struct DynTrieSymbols {
  <`d::R> 
  dynregion_t<`d,`H> dyn;
  trie_t<`d>         t;  //int field is symbol index, 0 for not there
  Xarray::xarray_t<stringptr_t,`d> symbols;
};
typedef struct DynTrieSymbols *dyn_trie_symbols_t;
typedef struct DynSymbols *dyn_symbols_t;
static dyn_trie_symbols_t ids_trie  = NULL;
static dyn_trie_t typedefs_trie = NULL;//int field true iff path is a typedef

static int comment_depth = 0;

// These needn't be set by lex_init -- they're set while finding a token.
static $(sign_t,int)        token_int = $(Signed,0);
static string_t             bogus_string   = "*bogus*";
static $(nmspace_t,var_t)   token_id_pair = $(Nmspace{.Loc_n = 0},
					      &bogus_string);

static char                 token_char   = '\000';
static string_t             token_string = "";
static qvar_t               token_qvar   = &token_id_pair;
static $(bool,string_t<`H>) token_asm = $(false,"");

static int runaway_start = 0;
static int paren_depth = 0; // used for __asm__ parsing

static void err(string_t<`H> msg,Lexbuf<`a> lb) {
  seg_t s = lexeme_start(lb);
  post_error(mk_err_lex(s,msg));
}
static void runaway_err(string_t<`H> msg,Lexbuf<`a> lb) {
  seg_t s = runaway_start;
  post_error(mk_err_lex(s,msg));
}

// ************************** RESERVED WORDS **************************
// the bool is true when the keyword is a C keyword as opposed to a
// Cyclone keyword.  
static $(string_t,short,bool) rw_array[] = {
  $("__attribute__", ATTRIBUTE, true),
  $("abstract", ABSTRACT, false),
//   $("alias", ALIAS, false),
  $("auto", AUTO, true),
  $("break", BREAK, true),
  $("calloc", CALLOC, false),
  $("case", CASE, true),
  $("catch", CATCH,true),
  $("char", CHAR, true),
  $("const", CONST, true),
  $("continue", CONTINUE, true),
  $("datatype", DATATYPE, false),
  $("default", DEFAULT, true),
  $("do", DO, true),
  $("double", DOUBLE, true),
  $("dynregion_t", DYNREGION_T, false),
  $("else", ELSE, true),
  $("enum", ENUM, true),
  $("export", EXPORT, false),
  $("extern", EXTERN, true),
  $("fallthru", FALLTHRU, false),
  $("float", FLOAT, true),
  $("for", FOR, true),
  $("goto", GOTO, true),
  $("if", IF, true),
  $("inline", INLINE, true),
  $("__inline__", INLINE, true),
  $("int", INT, true),
  $("let", LET, false),
  $("long", LONG, true),
  $("malloc", MALLOC, false),
  $("namespace", NAMESPACE, false),
  $("new", NEW, false),
  $("NOZEROTERM",NOZEROTERM_QUAL, false),
  $("NULL", NULL_kw, false),
  $("numelts", NUMELTS, false),
  $("offsetof", OFFSETOF, true),
  $("__cyclone_port_on__", PORTON, false),
  $("__cyclone_port_off__", PORTOFF, false),
  $("rcalloc", RCALLOC, false),
  $("region_t", REGION_T, false),
  $("region", REGION, false),
  $("regions", REGIONS, false),
  $("register", REGISTER, true),
  $("reset_region", RESET_REGION, false),
  $("restrict", RESTRICT, true),
  $("return", RETURN, true),
  $("rmalloc", RMALLOC, false),
  $("rnew", RNEW, false),
  $("short", SHORT, true),
  $("signed", SIGNED, true),
  $("sizeof", SIZEOF, true),
  $("static", STATIC, true),
  $("struct", STRUCT, true),
  $("switch", SWITCH, true),
  $("tagcheck", TAGCHECK, false),
  $("tag_t", TAG_T, false),
  $("throw", THROW, false),
  $("try", TRY, false),
  $("tunion", TUNION, false),
  $("typedef", TYPEDEF, true),
  $("union", UNION, true),
  $("unsigned", UNSIGNED, true),
  $("using", USING, false),
  $("valueof", VALUEOF, false),
  $("valueof_t", VALUEOF_T, false),
  $("void", VOID, true),
  $("volatile", VOLATILE, true),
  $("while", WHILE, true),
  $("xtunion", XTUNION, false),
  $("ZEROTERM", ZEROTERM_QUAL, false)
};

static int num_keywords(bool include_cyclone_keywords) {
  int sum = 0;
  for (unsigned i = 0; i < numelts(rw_array); i++)
    if (include_cyclone_keywords || rw_array[i][2]) 
      sum++;
  return sum;
}

///////////////////////// Trie manipulation ///////////////////////
static int trie_char(int c) {
  // get the legal chars into a narrow range starting at 0
  if(c >= 95) return c - 59;
  else if(c > 64) return c - 55;
  return c - 48;
}

static trie_t<`r> trie_lookup(region_t<`r> r, trie_t<`r> t, 
                              string_t buff, int offset, int len) {
  int    i    = offset;
  int    last = offset + len - 1;
  while(i <= last) {
    switch(t->children) {
    case {.Many = arr}:
      // walk down one level
      int ch = trie_char(buff[i]);
      if(arr[ch] == NULL)
	arr[ch] = rnew(r) Trie(Zero(),0);
      t = arr[ch];
      ++i;
      break;
    case {.One = $(one_ch, one_trie)}:
      // walk down one level
      if(one_ch == buff[i]) {
	t = one_trie;
      } else {
	let arr = rnew(r) {for j < 64: NULL};
	arr[trie_char(one_ch)] = one_trie;
	let ch = trie_char(buff[i]);
	arr[ch] = rnew(r) Trie(Zero(),0);
	t->children = Many(arr); 
	t = arr[ch];
      }
      ++i;
      break;
    case {.Zero = _}:
      // new string -- extend the trie
      while(i <= last) {
	let next = rnew(r) Trie(Zero(),0);
	t->children = One(buff[i++], next);
	t = next;
      }
      return t;
    }
  }
  return t;
}

static int str_index(string_t buff, int offset, int len) {
  let DynTrieSymbols{dyn,t,symbols} = *ids_trie;
  region d = open(dyn); {
    let t = trie_lookup(d, t, buff, offset, len);
    // build string if necessary and return
    if(t->shared_str == 0) {
      let newstr = new_string(len+1);
      zstrncpy((char ? @nozeroterm)newstr,buff+offset,len);
      int ans = Xarray::add_ind(symbols, new ((string_t)newstr));
      t->shared_str = ans;
    }
    return t->shared_str;
  }
}

static int str_index_lbuf(Lexbuf<`a> lbuf) {
  return str_index(lbuf->lex_buffer, 
		   lbuf->lex_start_pos,
		   lbuf->lex_curr_pos - lbuf->lex_start_pos);
}

static void insert_typedef(stringptr_t sptr) {
  let s = *sptr;
  let DynTrie{<`d> dyn, t} = *typedefs_trie;
  region d = open(dyn); {
    let t = trie_lookup(d, t, s, 0, numelts(s)-1);
    t->shared_str = true;
  }
  return;
}

static stringptr_t get_symbol(int symbol_num) {
  let DynTrieSymbols{dyn,t,symbols} = *ids_trie;
  region d = open(dyn); {
    return Xarray::get(symbols, symbol_num);
  }
}

// ************************ INTEGER CONSTANTS ************************

  // String to integer conversions.  Core::int_of_string does not handle
  // all of the cases we want: it does not handle a trailing 'u', 'U',
  // 'l', or 'L'; and in particular, it does not treat '0'['0'-'7'] as
  // an octal number.  

  // copied from Core
static int int_of_char(char c) {
  if ('0'<=c && c<='9')      return c-'0';
  else if ('a'<=c && c<='f') return 10+c-'a';
  else if ('A'<=c && c<='F') return 10+c-'A';
  else throw new Invalid_argument("string to integer conversion");
}

 
// FIX: We should really have 8-bytes to store a long literal!!!
//      That is, we and the previous version totally ignore the L!!!
static $(sign_t, int) intconst(Lexbuf<`a> lbuf, int start, int end, int base) {
  unsigned int n    = 0;
  int          end2 = lbuf->lex_curr_pos - end;
  mstring_t    buff = lbuf->lex_buffer;
  int          i    = start + lbuf->lex_start_pos;
  for(int i = start + lbuf->lex_start_pos; i < end2; ++i) {
    char c = buff[i];
    switch (c) {
        // incorrect to return as soon as we see 'u' 'U' if l isn't ignored
    case 'u': fallthru;
    case 'U': return $(Unsigned,(signed int)n); 
    case 'l': break;
    case 'L': break;
    default: n = n*base + (unsigned int)int_of_char(c); break;
    }
  }
  return $(Signed, (signed int)n);
}

// ************************* STRING CONSTANTS *************************

char string_buffer_v[]@zeroterm = {'x','x','x','x','x','x','x','x','x','x',0};
mstring_t string_buffer = (mstring_t)string_buffer_v;
int    string_pos    = 0;
void store_string_char(char c) {
  int sz = numelts(string_buffer) - 1;
  if (string_pos >= sz) {
    int newsz = sz;
    while (string_pos >= newsz) newsz = newsz * 2;
    mstring_t str = new {for i < newsz : (i < sz) ? string_buffer[i] : '\000'};
    string_buffer = str;
  }	
  string_buffer[string_pos] = c;
  ++string_pos;
}
void store_string(string_t s) {
  int sz = strlen(s);
  for (int i = 0; i < sz; i++)
    store_string_char(s[i]);
}
mstring_t get_stored_string() {
  mstring_t str = substring(string_buffer,0,string_pos);
  string_pos = 0;
  return str;
} 

// ******************* NAMESPACE, USING, AND TYPEDEF  *******************

static struct Ldecls {
  // records typedefs and namespaces declared in a scope
  Set::set_t<var_t> typedefs;
  Set::set_t<var_t> namespaces;
};
typedef struct Ldecls @ ldecls_t;

static struct Lvis {  // the King lives!
  // records the namespaces whose declarations are visible in a scope
  list_t<var_t>         current_namespace;
  list_t<list_t<var_t>> imported_namespaces;
};
typedef struct Lvis @lvis_t;

static struct Lstate {
  // lstack is the current nested scope structure,
  // decls is the global declaration mapping
  List_t<lvis_t>                     lstack; 
  Dict::dict_t<list_t<var_t>,ldecls_t> decls;
};
typedef struct Lstate @lstate_t;

static opt_t<lstate_t> lstate = NULL;

static void typedef_init() {
  let init_lvis   = new Lvis{.current_namespace=NULL,
                             .imported_namespaces=NULL};
  let init_lstack = new List(init_lvis, NULL);
  Dict::dict_t<list_t<var_t,`H>,ldecls_t> init_decls = 
    Dict::insert(Dict::empty(varlist_cmp),
                 NULL,
                 new Ldecls{.typedefs=Set::empty(zstrptrcmp),
                               .namespaces=Set::empty(zstrptrcmp)});
  lstate = new Opt(new Lstate{.lstack=init_lstack,.decls=init_decls});
}

static list_t<var_t> get_absolute_namespace(List_t<var_t,`H> ns) {
  // ns is a relative namespace, we return the absolute namespace
  var_t n = ns->hd;
  // For each enclosing scope...
  for (list_t<lvis_t> ls = lstate->v->lstack; ls != NULL; ls = ls->tl) {
    lvis_t lv = ls->hd; // ... see what namespaces are visible
    // ... and look in each such visible namespace
    list_t<list_t<var_t>> x = new List(lv->current_namespace,
                                       lv->imported_namespaces);
    for (; x != NULL; x = x->tl) {
      ldecls_t ld = Dict::lookup(lstate->v->decls,x->hd);
      // ... for namespace n
      if (Set::member(ld->namespaces,n))
        // OK, we know ns refers to x.hd+ns
        return List::append(x->hd,ns);
    }
  }
  yyerror(aprintf("undeclared namespace %s",str_sepstr(ns,"::")));
  return NULL; 
}

static void recompute_typedefs() {
  // Drop the old trie on the floor.
  let DynTrie{dyn,t} = *typedefs_trie;
  Core::free_dynregion(dyn);
  let NewRegion{<`d2> dyn2} = new_dynregion();
  region d2 = open(dyn2); {
    typedefs_trie = new DynTrie{dyn2, rnew(d2) Trie(Zero(),false)};
  }
  
 //For each enclosing scope, get the visible namespaces and add all the typedefs
  for (list_t<lvis_t> ls = lstate->v->lstack; ls != NULL; ls = ls->tl) {
    lvis_t lv = ls->hd; 
    list_t<list_t<var_t>> x = new List(lv->current_namespace, 
                                       lv->imported_namespaces);
    for (; x != NULL; x = x->tl) {
      ldecls_t ld = Dict::lookup(lstate->v->decls,x->hd);
      Set::iter(insert_typedef,ld->typedefs);
    }
  }
}

// This can stay the slow way because most identifiers are not qualified.
static bool is_typedef_in_namespace(List_t<var_t,`H> ns, var_t v) {
  list_t<var_t> ans = get_absolute_namespace(ns);
  try {
    ldecls_t ld = Dict::lookup(lstate->v->decls,ans);
    return Set::member(ld->typedefs,v);
  } catch { case &Dict::Absent:
    return false;
  }
}
static bool is_typedef(List::list_t<var_t,`H> ns, var_t v) {
  if (ns != NULL)
    return is_typedef_in_namespace((List_t<var_t,`H>)ns,v);
  // all unqualified typedefs must be in the trie 
  // look ma -- fast lookup
  let s   = *v;
  int    len = numelts(s) - 1;
  let DynTrie{dyn,t} = *typedefs_trie;
  region d = open(dyn); {
    for(int i = 0; i < len; ++i)
    switch (t->children) {
      case {.Zero = _}: return false;
      case {.One = $(one_ch, one_trie)} && one_ch != s[i]: return false;
      case {.One = $(_,      one_trie)}: t = one_trie; break;
      case {.Many = arr}:
        let next = arr[trie_char(s[i])];
        if(next == NULL)
          return false;
        t = next;
        break;
    }
    return t->shared_str;
  }
}

void enter_namespace(var_t s) {
  list_t<var_t> ns = lstate->v->lstack->hd->current_namespace;
  list_t<var_t> new_ns = List::append(ns,new List(s,NULL));
  // Push the new namespace on the stack
  lstate->v->lstack =
    new List(new Lvis{.current_namespace = new_ns,.imported_namespaces = NULL},
             lstate->v->lstack);
  // If this is the first time the new namespace has been encountered,
  // make sure it is bound in the old namespace, and add an empty
  // environment for the new namespace
  ldecls_t ld = Dict::lookup(lstate->v->decls,ns);
  if (!Set::member(ld->namespaces,s)) {
    lstate->v->decls = Dict::insert(lstate->v->decls,
				    ns,
				    new Ldecls{.typedefs = ld->typedefs,
                                               .namespaces = 
                                               Set::insert(ld->namespaces, 
                                                           s)});
    lstate->v->decls = Dict::insert(lstate->v->decls,
				    new_ns,
				    new Ldecls{.typedefs= 
                                               Set::empty(zstrptrcmp),
                                               .namespaces= 
                                               Set::empty(zstrptrcmp)
				    });

  }
  // some more typedefs may be visible
  // recompute_typedefs(); // too slow! (does repeated work)
  Set::iter(insert_typedef,Dict::lookup(lstate->v->decls,new_ns)->typedefs);
}
void leave_namespace() {
  // we never leave the outermost namespace, so the cast is okay
  lstate->v->lstack = (List_t<lvis_t>)lstate->v->lstack->tl;
  recompute_typedefs();
}
void enter_using(qvar_t q) {
  _ ns;
  switch ((*q)[0]) {
  case {.Loc_n = _}:
    ns = (List_t<stringptr_t>)(new List((*q)[1],NULL));
    break;
  case {.Rel_n = y}: fallthru(y);
  case {.C_n = y}: fallthru(y);
  case {.Abs_n = y}:
    ns = (List_t<stringptr_t>)List::append(y,new List((*q)[1],NULL));
    break;
  }

  let ans      = get_absolute_namespace(ns);
  let imported = lstate->v->lstack->hd->imported_namespaces;

  lstate->v->lstack->hd->imported_namespaces = new List(ans,imported);
  
  // some more typedefs may be visible
  // recompute_typedefs(); // too slow! (does repeated work)
  Set::iter(insert_typedef,Dict::lookup(lstate->v->decls,ans)->typedefs);
}
void leave_using() {
  let imported = lstate->v->lstack->hd->imported_namespaces;
  lstate->v->lstack->hd->imported_namespaces = imported->tl;

  // some typedefs may no longer be visible
  recompute_typedefs();
}

void register_typedef(qvar_t q) {
  // FIX: we assume that q is not in fact qualified
  let current = lstate->v->lstack->hd->current_namespace;
  let ds      = lstate->v->decls;
  let ld      = Dict::lookup(ds,current);
  let new_ld  = new Ldecls{.typedefs   = Set::insert(ld->typedefs,(*q)[1]),
                           .namespaces = ld->namespaces};
  lstate->v->decls = Dict::insert(ds,current,new_ld);

  // FIX: We're really assuming it's unqualified here -- else need to
  //      decide if the namespace-list is a visible one
  insert_typedef((*q)[1]);
}

static short process_id(Lexbuf<`a> lbuf) {
  int symbol_num = str_index_lbuf(lbuf);

  // maybe it's a keyword
  if(symbol_num <= num_kws) {
    short res = (short)kw_nums[symbol_num-1]; 
    switch (res) {
    case ZEROTERM_QUAL: 
      Tcutil::warn(yylloc.first_line,
                   "deprecated ZEROTERM, use @zeroterm"); break;
    case NOZEROTERM_QUAL: 
      Tcutil::warn(yylloc.first_line,
                   "deprecated NOZEROTERM, use @nozeroterm"); break;
    case TUNION: 
      Tcutil::warn(yylloc.first_line,
                   "deprecated tunion, use datatype"); break;
    case XTUNION: 
      Tcutil::warn(yylloc.first_line,
                   "deprecated xtunion, use @extensible datatype"); break;
    default: break;
    }
    return (short)kw_nums[symbol_num-1]; 
  }

  let s = get_symbol(symbol_num);
  token_string = *s;

  // maybe it's a typedef
  if (is_typedef(NULL,s))
    return TYPEDEF_NAME;

  // alas, it's an identifier
  return IDENTIFIER;
}

static short process_qual_id(Lexbuf<`a> lbuf) {
  int       i   = lbuf->lex_start_pos;
  int       end = lbuf->lex_curr_pos;
  mstring_t s   = lbuf->lex_buffer;

  string_t<`H> *v = NULL;
  list_t<var_t> rev_vs = NULL;

  while (i<end) {
    int start = i;
    for (; i < end && s[i] != ':'; i++) 
      ; // skip
    if (start == i) // no progress -- first char is ':'
      throw new Impossible("bad namespace");
    int vlen = i - start;
    if (v != NULL)
      rev_vs = new List((var_t)v,rev_vs);
    v = get_symbol(str_index(s, start, vlen));
    i += 2;
  }
  if (v == NULL)
    throw new Impossible("bad namespace");
  list_t<var_t> vs = List::imp_rev(rev_vs);
  // special cases:  when we have Cyc::Foo::bar or C::Foo::bar then
  // we have absolute namespaces.
  if (vs != NULL && strcmp(*vs->hd,"Cyc") == 0) {
    vs = vs->tl;
    token_qvar = new $(Abs_n(vs,false),(var_t)v);
  }
  else if (vs != NULL && strcmp(*vs->hd,"C") == 0) {
    vs = vs->tl;
    token_qvar = new $(Abs_n(vs,true),(var_t)v);
  } else 
    token_qvar = new $(Rel_n(vs),(var_t)v);
  if (is_typedef(vs,(var_t)v))
    return QUAL_TYPEDEF_NAME;
  return QUAL_IDENTIFIER;
}

// Tracking source files and line numbers

// One for each # nnn <file> that occurs in the source
struct PosInfo<`r> {
  struct PosInfo<`r>*`r next;  
  unsigned int starting_line;           // nnn
  const char ?`r filename;     // <file>
  seg_t ?`U linenumpos;        // one entry for each line, holding seg_t
  unsigned int linenumpos_offset; // next spot for inserting 
};
typedef struct PosInfo<`r>@`r pinfo_t<`r>;
typedef struct PosInfo<`r>*`r pinfo_opt_t<`r>;
// List of position info's in reverse order
static pinfo_opt_t pos_info = NULL;
// Current line number
static int linenumber = 1;

// when we see a new # nnn <file> directive, we create a new filepos entry
static pinfo_t<`r> rnew_filepos(region_t<`r> r,
                                const char ?`H filename, 
                                unsigned int starting_line, 
                                pinfo_opt_t<`r> next) {
  seg_t ?`U linenumpos = rcalloc(Core::unique_region, 10, sizeof(seg_t));
  linenumpos[0] = yylloc.first_line;
  return rnew(r) PosInfo{.next = next, .starting_line = starting_line,
                         .filename = filename,
                         .linenumpos = linenumpos,
                         .linenumpos_offset = 1};
}

// when we see a newline, we add it into the current filepos entry
static void inc_linenumber() {
  if (pos_info == NULL) throw new Impossible("empty position info!");
  pinfo_t p = (pinfo_t)pos_info;
  seg_t ?`U linenums = NULL;
  p->linenumpos :=: linenums;
  unsigned offset = p->linenumpos_offset;
  unsigned n = numelts(linenums);
  // check for enough space to insert the position
  if (offset >= n) {
    // have to grow the array -- double it and copy over old array
    seg_t ?`U newlinenums = rcalloc(Core::unique_region,n*2,sizeof(seg_t));
    for (unsigned i = 0; i < n; i++)
      newlinenums[i] = linenums[i];
    linenums :=: newlinenums;
    // free old array of positions
    Core::ufree(newlinenums);
  }
  // plug in the current position for this line number
  linenums[offset] = yylloc.first_line;
  p->linenumpos_offset = offset + 1;
  linenumber++;
  p->linenumpos :=: linenums;
}

// we've seen
static void process_directive(char ?line) {
  int i;
  char buf[100];
  const char ?filename = "";
  if (sscanf(line, "# %d \"%s", &i, buf) == 2) {
    if (compile_for_boot_r) {
      // cut out the path from the filename so the repository does not
      // have the names in it.  
      int i = strlen(buf) - 1;
      int last_slash = -1;
      while (i >= 0) {
        if (buf[i] == '/') { last_slash = i; break; };
        --i;
      }
      filename = aprintf("\"%s",buf + last_slash + 1);
    } else 
      filename = aprintf("\"%s",buf);
    if (linenumber == i && pos_info != NULL && strcmp(pos_info->filename,filename) == 0) return;
    linenumber = i;
  } else if (sscanf(line, "# %d", &i) == 1) {
    if (linenumber == i) return;
    linenumber = i;
    if (pos_info != NULL) filename = pos_info->filename;
  } else {
    linenumber++; // we don't understand it, so skip over it
    return;
  }
  pos_info = rnew_filepos(Core::heap_region, filename, 
                          linenumber, pos_info);
}

// translate an absolute character offset to a file and line number
// given position information.  If it's an invalid offset (e.g. 0)
// return $(NULL,0).
$(const char ?, unsigned int) xlate_pos(seg_t char_offset) {
  for (pinfo_opt_t p = pos_info; p != NULL; p = p->next) {
    seg_t first_char_offset = p->linenumpos[0];
    if (char_offset < first_char_offset && p->next != NULL) continue;
    // we've found the right pinfo array, but we have to find the lineno now
    // use a binary search...
    unsigned int base = 0;
    unsigned int size = p->linenumpos_offset;
    while (size > 1) {
      int half = size / 2;
      int mid = base + half;
      if (char_offset > p->linenumpos[mid]) {
        base = base + half;
        size = size - half;
      } else {
        size = half;
      }
    }
    return $(p->filename, p->starting_line + base);
  }
  return $(NULL,0);
}


// Forward declarations of lexing functions 
int token(Lexbuf<`a>);
int scan_charconst(Lexbuf<`a>);
int strng(Lexbuf<`a>);
int strng_next(Lexbuf<`a>);
int wstrng(Lexbuf<`a>);
int wstrng_next(Lexbuf<`a>);
int comment(Lexbuf<`a>);
int cyc_qual(Lexbuf<`a>);
int snarf_asm(Lexbuf<`a>);
int snarf_asm_body(Lexbuf<`a>);
} // namespace Lex

// for parser -- must not be prefixed
int yylex(Lexing::Lexbuf<Lexing::Function_lexbuf_state<FILE@>> lbuf,
          union YYSTYPE<`yy>@ yylval, YYLTYPE @yyllocptr) { 
 int ans = Lex::token(lbuf);
 yylloc.first_line = yyllocptr->first_line = lexeme_start(lbuf);
 yylloc.last_line = yyllocptr->last_line  = lexeme_end(lbuf);
 switch (ans) {
 case IDENTIFIER        : 
   *yylval = YYSTYPE{.String_tok = Lex::token_string}; break;
 case TYPEDEF_NAME      : 
   *yylval = YYSTYPE{.String_tok = Lex::token_string}; break;
 case QUAL_IDENTIFIER   : 
   *yylval = YYSTYPE{.QualId_tok = Lex::token_qvar};   break;
 case QUAL_TYPEDEF_NAME : 
   *yylval = YYSTYPE{.QualId_tok = Lex::token_qvar};   break;
 case TYPE_VAR          : 
   *yylval = YYSTYPE{.String_tok = Lex::token_string}; break;
 case INTEGER_CONSTANT  : 
   *yylval = YYSTYPE{.Int_tok = Lex::token_int};       break;
 case CHARACTER_CONSTANT: 
   *yylval = YYSTYPE{.Char_tok = Lex::token_char};     break;
 case WCHARACTER_CONSTANT:
   *yylval = YYSTYPE{.String_tok = Lex::token_string};  break;
 case FLOATING_CONSTANT : 
   *yylval = YYSTYPE{.String_tok = Lex::token_string}; break;
 case STRING            : 
   *yylval = YYSTYPE{.String_tok = Lex::token_string}; break;
 case WSTRING           : 
   *yylval = YYSTYPE{.String_tok = Lex::token_string}; break;
 case ASM               : 
   *yylval = YYSTYPE{.Asm_tok = Lex::token_asm};       break;
 default: break;
 }
 return ans;
} 

namespace Lex;
////////////////////////// LEXING RULES /////////////////////////////
}

let newline = ('\n' | '\r' | "\r\n")

rule token = parse
| "asm" { return snarf_asm(lexbuf); }
| "__asm__" { return snarf_asm(lexbuf); }
/* Identifiers, type names, and keywords */
| ['A'-'Z''a'-'z']['A'-'Z''a'-'z''0'-'9''_']*
{ return process_id(lexbuf); }
| ['_']['A'-'Z''a'-'z''0'-'9''_']+
{ return process_id(lexbuf); }
/* Qualified identifiers and type names (e.g., Foo::bar) */
| (['A'-'Z''a'-'z']['A'-'Z''a'-'z''0'-'9''_']*':'':')+
  ['A'-'Z''a'-'z''_']['A'-'Z''a'-'z''0'-'9''_']*
      { return process_qual_id(lexbuf); }
/* Type variables */
| '`'['A'-'Z''a'-'z''_']['A'-'Z''a'-'z''0'-'9''_']*
   { token_string = *(get_symbol(str_index_lbuf(lexbuf))); 
      return TYPE_VAR; }
/* Cyclone qualifiers (e.g., @zeroterm, @tagged, etc.) */
| '@' { return cyc_qual(lexbuf); }
/* Integer constants */
| '0'['x''X']['0'-'9''a'-'f''A'-'F']+((['u''U']['l''L']?)|(['l''L']['u''U']?))?
      { token_int = intconst(lexbuf,2,0,16);
        return INTEGER_CONSTANT; }
| '0'['0'-'7']*((['u''U']['l''L']?)|(['l''L']['u''U']?))?
      { token_int = intconst(lexbuf,0,0,8);
        return INTEGER_CONSTANT; }
| '0'['0'-'9']+((['u''U']['l''L']?)|(['l''L']['u''U']?))?
      /* This is really an error case according to OSI C --
         the leading 0 indicates this should be in octal. */
      /* FIX: print a warning message? */
      { token_int = intconst(lexbuf,0,0,10);
        return INTEGER_CONSTANT; }
| ['1'-'9']['0'-'9']*((['u''U']['l''L']?)|(['l''L']['u''U']?))?
      { token_int = intconst(lexbuf,0,0,10);
        return INTEGER_CONSTANT; }
/* Floating-point constants */
| ['0'-'9']+['e''E']['+''-']?['0'-'9']+['f''F''l''L']?
      { token_string = lexeme(lexbuf);
        return FLOATING_CONSTANT; }
| ((['0'-'9']+'.')|(['0'-'9']+'.'['0'-'9']+)|('.'['0'-'9']+))
  (['e''E']['+''-']?['0'-'9']+)?['f''F''l''L']?
      { token_string = lexeme(lexbuf);
        return FLOATING_CONSTANT; }
/* Operators */
| "==" { return  EQ_OP; }
| "!=" { return  NE_OP; }
| "<=" { return  LE_OP; }
| ">=" { return  GE_OP; }
| "++" { return  INC_OP; }
| "--" { return  DEC_OP; }
| "+=" { return  ADD_ASSIGN; }
| "-=" { return  SUB_ASSIGN; }
| "*=" { return  MUL_ASSIGN; }
| "/=" { return  DIV_ASSIGN; }
| "%="   { return  MOD_ASSIGN; }
| "|="   { return  OR_ASSIGN; }
| "^="   { return  XOR_ASSIGN; }
| "&="   { return  AND_ASSIGN; }
| "<<="  { return  LEFT_ASSIGN; }
| ">>="  { return  RIGHT_ASSIGN; } 
| "&&" { return  AND_OP; }
| "||" { return  OR_OP; }  
| "<<" { return  LEFT_OP; }
/* JGM: see shift_expr and relational_expr -- we pull a nasty hack there...*/
| ">>" { return  RIGHT_OP; }
| "<>" { return  LEFT_RIGHT; }
| "->" { return PTR_OP; }
| "..." { return ELLIPSIS; }
| "::" { return COLON_COLON; }
/* swap operation */
| ":=:" { return SWAP; }
/* comments, directives, whitespace, etc. */
| "#"[^ '\n' '\r']*(newline)      
  { process_directive(lexeme(lexbuf)); return token(lexbuf); }
| [' ' '\t' '\v' '\f']+           { return token(lexbuf); }
| newline                         { inc_linenumber(); return token(lexbuf); }
| "//"[^'\n' '\r']* newline       { inc_linenumber(); return token(lexbuf); }
| "/*"  { comment_depth = 1; 
	  runaway_start = lexeme_start(lexbuf); 
	  comment(lexbuf); 
	  return token(lexbuf); }
/* string constants */
| "\""
  { string_pos = 0; 
    runaway_start = lexeme_start(lexbuf);
    while (strng(lexbuf))
      /* skip */;
    token_string = get_stored_string();
    return STRING; }
/* wide string constants */
| "L\""
  { string_pos = 0; 
    runaway_start = lexeme_start(lexbuf);
    while (wstrng(lexbuf))
      /* skip */;
    token_string = get_stored_string();
    return WSTRING; }
/* wide character constants */
| "L'"
  { string_pos = 0; 
    runaway_start = lexeme_start(lexbuf);
    while (scan_charconst(lexbuf))
      /* skip */;
    token_string = get_stored_string();
    return WCHARACTER_CONSTANT; }
/* character constants */
| "'\\a'"   { token_char = '\a'; return CHARACTER_CONSTANT; }
| "'\\b'"   { token_char = '\b'; return CHARACTER_CONSTANT; }
| "'\\f'"   { token_char = '\f'; return CHARACTER_CONSTANT; }
| "'\\n'"   { token_char = '\n'; return CHARACTER_CONSTANT; }
| "'\\r'"   { token_char = '\r'; return CHARACTER_CONSTANT; }
| "'\\t'"   { token_char = '\t'; return CHARACTER_CONSTANT; }
| "'\\v'"   { token_char = '\v'; return CHARACTER_CONSTANT; }
| "'\\\\'"  { token_char = '\\'; return CHARACTER_CONSTANT; }
| "'\\''"   { token_char = '\''; return CHARACTER_CONSTANT; }
| "'\\\"'"  { token_char = '"';  return CHARACTER_CONSTANT; }
| "'\\?'"   { token_char = '?';  return CHARACTER_CONSTANT; }
/* octal character escapes */
| "'\\" ['0'-'7']['0'-'7']?['0'-'7']? "'"
            { token_char = (char)(intconst(lexbuf,2,1,8))[1];
              return CHARACTER_CONSTANT;
            }
/* hex character escapes */
| "'\\x" ['0'-'9''A'-'Z''a'-'z']+ "'"
            { token_char = (char)(intconst(lexbuf,3,1,16))[1];
              return CHARACTER_CONSTANT;
            }
| "'" [^ '\\' '\'' '\n'] "'"
    { token_char = lexeme_char(lexbuf,1);
      return CHARACTER_CONSTANT;
    }
/* End of file */
| eof { return -1; }
/* Default case */
| _   { return (int)(lexeme_char(lexbuf,0)); }

and cyc_qual = parse
/* HACK: If we see @taggedfoo then this should be lexed as '@' 'taggedfoo', not
 * '@tagged' 'foo' -- so we back up the lexer if necessary -- I don't
 * see an easier way to do this... */
  "tagged"['A'-'Z''a'-'z''0'-'9''_'] 
    { lexbuf->lex_curr_pos -= strlen("taggedZ"); return '@'; }
| "zeroterm"['A'-'Z''a'-'z''0'-'9''_'] 
    { lexbuf->lex_curr_pos -= strlen("zerotermZ"); return '@'; }
| "nozeroterm"['A'-'Z''a'-'z''0'-'9''_'] 
    { lexbuf->lex_curr_pos -= strlen("nozerotermZ"); return '@'; }
| "extensible"['A'-'Z''a'-'z''0'-'9''_'] 
    { lexbuf->lex_curr_pos -= strlen("extensibleZ"); return '@'; }
| "resetable"['A'-'Z''a'-'z''0'-'9''_'] 
    { lexbuf->lex_curr_pos -= strlen("resetableZ"); return '@'; }
| "region"['A'-'Z''a'-'z''0'-'9''_'] 
    { lexbuf->lex_curr_pos -= strlen("regionZ"); return '@'; }
| "numelts"['A'-'Z''a'-'z''0'-'9''_'] 
    { lexbuf->lex_curr_pos -= strlen("numeltsZ"); return '@'; }
| "thin"['A'-'Z''a'-'z''0'-'9''_'] 
    { lexbuf->lex_curr_pos -= strlen("thinZ"); return '@'; }
| "fat"['A'-'Z''a'-'z''0'-'9''_'] 
    { lexbuf->lex_curr_pos -= strlen("fatZ"); return '@'; }
| "notnull"['A'-'Z''a'-'z''0'-'9''_'] 
    { lexbuf->lex_curr_pos -= strlen("notnullZ"); return '@'; }
| "nullable"['A'-'Z''a'-'z''0'-'9''_'] 
    { lexbuf->lex_curr_pos -= strlen("nullableZ"); return '@'; }
| "requires"['A'-'Z''a'-'z''0'-'9''_'] 
    { lexbuf->lex_curr_pos -= strlen("requiresZ"); return '@'; }
| "tagged" { return TAGGED_QUAL; }
| "zeroterm" { return ZEROTERM_QUAL; }
| "nozeroterm" { return NOZEROTERM_QUAL; }
| "extensible" { return EXTENSIBLE_QUAL; }
| "resetable" { return RESETABLE_QUAL; }
| "region" { return REGION_QUAL; }
| "numelts" { return NUMELTS_QUAL; }
| "thin" { return THIN_QUAL; }
| "fat" { return FAT_QUAL; }
| "notnull" { return NOTNULL_QUAL; }
| "nullable" { return NULLABLE_QUAL; }
| "requires" { return REQUIRES_QUAL; }
| _ { lexbuf->lex_curr_pos -= 1; return '@'; }

and scan_charconst = parse
    "'"     { return 0; }
  /* escapes */
  | "\\a"  { store_string_char('\a'); return 1; }
  | "\\b"  { store_string_char('\b'); return 1; }
  | "\\f"  { store_string_char('\f'); return 1; }
  | "\\n"  { store_string_char('\n'); return 1; }
  | "\\r"  { store_string_char('\r'); return 1; }
  | "\\t"  { store_string_char('\t'); return 1; }
  | "\\v"  { store_string_char('\v'); return 1; }
  | "\\\\" { store_string_char('\\'); return 1; }
  | "\\'"  { store_string_char('\''); return 1; }
  | "\\\"" { store_string_char('"');  return 1; }
  | "\\?"  { store_string_char('?');  return 1; }
  /* octal character escapes */
  | "\\" ['0'-'7']['0'-'7']?['0'-'7']?
           { store_string(lexeme(lexbuf)); return 1; }
  /* hex character escapes */
  | "\\x" ['0'-'9''A'-'Z''a'-'z']+
           { store_string(lexeme(lexbuf)); return 1; }
  | [^ '\\' '\'' '\n']
           { store_string_char(lexeme_char(lexbuf,0)); return 1; }
  | newline
           { inc_linenumber(); runaway_err("wide character ends in newline",lexbuf); return 0; }
  | eof    { runaway_err("unterminated wide character",lexbuf); return 0; }
  | _      { err("bad character following backslash in wide character",lexbuf); return 1; }

/* return true when we see another string literal following, and
 * false otherwise, skipping over whitespace. */
and strng_next = parse
  "\"" { return 1; }  /* saw a next string literal */
| newline { inc_linenumber(); return strng_next(lexbuf); } /* skip whitespace */
| [' ' '\t'] { return strng_next(lexbuf); } /* skip whitespace */
/* HACK:  we've already snarfed the next character -- backup the lexer */
| _ { /* backup */ lexbuf->lex_curr_pos -= 1; return 0; } 

and strng = parse
    /* end of string -- but maybe an adjacent literal -- see strng_next */
    "\""            { return strng_next(lexbuf); }
  | "\\" newline    { inc_linenumber(); return 1; }
  | "\\a"           { store_string_char('\a'); return 1; }
  | "\\b"           { store_string_char('\b'); return 1; }
  | "\\f"           { store_string_char('\f'); return 1; }
  | "\\n"           { store_string_char('\n'); return 1; }
  | "\\r"           { store_string_char('\r'); return 1; }
  | "\\t"           { store_string_char('\t'); return 1; }
  | "\\v"           { store_string_char('\v'); return 1; }
  | "\\\\"          { store_string_char('\\'); return 1; }
  | "\\'"           { store_string_char('\''); return 1; }
  | "\\\""          { store_string_char('"');  return 1; }
  | "\\?"           { store_string_char('?');  return 1; }
  /* octal character escapes */
  | "\\" ['0'-'7']['0'-'7']?['0'-'7']?
                    { store_string_char((char)(intconst(lexbuf,1,0,8))[1]);
                      return 1;
                    }
  /* hex character escapes FIX? any length okay? */
  | "\\x" ['0'-'9''A'-'F''a'-'f']+
                    { store_string_char((char)(intconst(lexbuf,2,0,16))[1]);
                      return 1;
                    }
  | [^ '"''\\''\n']   /* NOT double quote, backslash, or newline */
                    { /* for efficiency, should have a while loop here */
                      store_string_char (lexeme_char(lexbuf,0));
		      return 1; }
  | newline         { inc_linenumber(); 
                      runaway_err("string ends in newline",lexbuf);
                      return 0;
                    }
  | eof             { runaway_err("unterminated string",lexbuf);
                      return 0;
                    }
  | _               { err("bad character following backslash in string",lexbuf);
		      return 1; }

/* return true when we see another wide string literal following, and
 * false otherwise, skipping over whitespace. */
and wstrng_next = parse
  /* Store the character sequence "\" L\"" instead of just concatenating
     the following string.  This is because concatenating might change
     the interpretation of a multibyte sequence -- we are not
     interpreting the sequence here, we leave that to the C compiler. */
  "L\"" { store_string("\" L\""); return 1; }  
| newline { inc_linenumber(); return wstrng_next(lexbuf); } /* skip whitespace */
| [' ' '\t'] { return wstrng_next(lexbuf); } /* skip whitespace */
/* HACK:  we've already snarfed the next character -- backup the lexer */
| _ { /* backup */ lexbuf->lex_curr_pos -= 1; return 0; } 

and wstrng = parse
    "\""            { return wstrng_next(lexbuf); }
  | "\\a"           { store_string("\\a"); return 1; }
  | "\\b"           { store_string("\\b"); return 1; }
  | "\\f"           { store_string("\\f"); return 1; }
  | "\\n"           { store_string("\\n"); return 1; }
  | "\\r"           { store_string("\\r"); return 1; }
  | "\\t"           { store_string("\\t"); return 1; }
  | "\\v"           { store_string("\\v"); return 1; }
  | "\\\\"          { store_string("\\\\"); return 1; }
  | "\\'"           { store_string("\\'"); return 1; }
  | "\\\""          { store_string("\\\"");  return 1; }
  | "\\?"           { store_string("\\?");  return 1; }
  /* octal character escapes */
  | "\\" ['0'-'7']['0'-'7']?['0'-'7']?
                    { store_string(lexeme(lexbuf));
                      return 1;
                    }
  /* hex character escapes */
  | "\\x" ['0'-'9''A'-'F''a'-'f']+
                    { store_string(lexeme(lexbuf));
                      return 1;
                    }
  | [^ '"''\\''\n']   /* NOT double quote, backslash, or newline */
                    { /* for efficiency, should have a while loop here */
                      store_string_char (lexeme_char(lexbuf,0));
		      return 1; }
  | newline         { inc_linenumber();
                      runaway_err("string ends in newline",lexbuf);
                      return 0;
                    }
  | eof             { runaway_err("unterminated string",lexbuf);
                      return 0;
                    }
  | _               { err("bad character following backslash in string",lexbuf);
		      return 1; }
and comment = parse
   "/*"             { ++comment_depth; return comment(lexbuf); }
 | "*/"             { --comment_depth; 
		      if (comment_depth > 0) 
			return comment(lexbuf);
		      return 0; /* return value ignored */
		    }
 | eof              { runaway_err("unterminated comment",lexbuf);
                      return 0; /* return value ignored */ 
                    }
 | '*'              { return comment(lexbuf); }
 | '/'              { return comment(lexbuf); }
 | newline          { inc_linenumber(); return comment(lexbuf); }
 | [^ '\n' '\r' '/' '*']+     { return comment(lexbuf); }

/* HACK: we're counting on there being no comments between "asm" and
   "volatile" and the first paren. */
/* FIX: not processing newlines here! */
and snarf_asm = parse
  [' ' '\t' '\v' '\f' '\n' '\r']* '(' 
  { token_asm[0] = false;
    paren_depth = 1;
    string_pos = 0;
    runaway_start = lexeme_start(lexbuf);
    while (snarf_asm_body(lexbuf)) /* skip */ ;
    token_asm[1] = get_stored_string();
    return ASM; 
  }
| [' ' '\t' '\v' '\f' '\n' '\r']+ "volatile" 
  [' ' '\t' '\v' '\f' '\n' '\r']* '(' 
  { token_asm[0] = true;
    paren_depth = 1;
    string_pos = 0;
    runaway_start = lexeme_start(lexbuf);
    while (snarf_asm_body(lexbuf)) /* skip */ ;
    token_asm[1] = get_stored_string();
    return ASM; 
  }

and snarf_asm_body = parse
   "\"" { store_string_char('"'); 
          while (strng(lexbuf)) /* skip */ ;
          store_string_char('"');
          return 1; }
| "/*" { comment_depth = 1;
         comment(lexbuf); 
         store_string_char(' ');
         return 1; }
| "#"[^ '\n' '\r']*(newline) { inc_linenumber(); 
                               store_string_char('\n'); return 1; }
| '(' { paren_depth += 1; store_string_char('('); return 1; }
| ')' { paren_depth -= 1; 
        if (paren_depth == 0) return 0;
        else {
          store_string_char(')');
          return 1;
        } }
| eof { runaway_err("unterminated asm",lexbuf); return 0; }
| newline { inc_linenumber(); store_string_char(lexeme_char(lexbuf,0)); return 1;}
| _ { store_string_char(lexeme_char(lexbuf,0)); return 1; }


{

// reset the position information -- this is done separately 
// because lex_init() gets called as soon as we're done lexing
// to free up its other data structures.  We need to hang on to
// the position information so that if we dump, it's there.
void pos_init() {
  linenumber = 1;
  pos_info = NULL;
}

void lex_init(bool include_cyclone_keywords) {
  // free any dynamic regions allocated first
  if (ids_trie != NULL) {
    let DynTrieSymbols{dyn,...} = *ids_trie;
    Core::free_dynregion(dyn);
  }
  if (typedefs_trie != NULL) {
    let DynTrie{dyn,...} = *typedefs_trie;
    Core::free_dynregion(dyn);
  }
  // Now allocate dynamic regions for the tries
  let NewRegion{id_dyn} = new_dynregion();
  region id_rgn = open(id_dyn); {
    Xarray::xarray_t<stringptr_t> symbols = 
      Xarray::rcreate(id_rgn,101,new ((string_t)""));
    // don't use first entry b/c 0 means "not a symbol"
    Xarray::add(symbols, &bogus_string);
    ids_trie = new DynTrieSymbols{id_dyn, rnew(id_rgn) Trie(Zero(),false),
                                  symbols};
  }
  let NewRegion{typedefs_dyn} = new_dynregion();
  region typedefs_rgn = open(typedefs_dyn); {
    typedefs_trie = new DynTrie{typedefs_dyn, 
                                rnew(typedefs_rgn) Trie(Zero(),false)};
  }
  num_kws       = num_keywords(include_cyclone_keywords);
  kw_nums       = new {for i < num_kws : 0};
  unsigned i = 0;
  unsigned rwsze = numelts(rw_array);
  for (unsigned j = 0; j < rwsze; j++) {
    if (include_cyclone_keywords || rw_array[j][2]) {
      let str = rw_array[j][0];
      str_index(str, 0, strlen(str));
      kw_nums[i] = rw_array[j][1];
      i++;
    }
  }
  typedef_init();
  comment_depth = 0;
}

}
