{
// WARNING: Because we now intern identifiers, you better never mutate them!!!
// Also, lex_init must be called for each source file!!!

#include "core.h"
#include "stdio.h"
#include "list.h"
#include "lexing.h"
#include "set.h"
#include "string.h"
#include "xarray.h"
#include "parse.h"
#include "position.h"
#include "dict.h"

using Core;
using Stdio;
using List;
using Lexing;
using Parse;
using Absyn;
using String;
using Position;

void yyerror(string s) { 
  post_error(mk_err_parse(segment_of_abs(yylloc.first_line,
					 yylloc.last_line), 
			  s));
} 

namespace Lex {

// Should probably put this trie thing in the library
static struct Trie;
typedef struct Trie * trie_t;
typedef trie_t @{75} trie_child_v_t; // enough room for Cyclone ids and `
typedef trie_child_v_t * trie_child_t;
static struct Trie {
  trie_child_t  children;   // null means none
  int           shared_str; // meaning depends on which trie -- see below
};

/////////////////////////////// Globals /////////////////////////////

// These must be (re-)initialized in lex_init.
static int    num_kws  = 0;
static int ?  kw_nums  = null;
static struct Xarray::xarray<stringptr> * symbols  = null;
static trie_t ids_trie      = null;//int field is symbol index, -1 for not there
static trie_t typedefs_trie = null;//int field true iff path is a typedef

static int comment_depth = 0;

// These needn't be set by lex_init -- they're set while finding a token.
static $(sign,int)      token_int_pair = $(Signed,0);
static string           bogus_string   = "*bogus*";
static $(enum Nmspace,var) token_id_pair  = $(Abs_n(null),&bogus_string);

static char             token_char     = '\000';
static string           token_string   = "";
static $(sign,int)@     token_int      = &token_int_pair;
static qvar             token_qvar     = &token_id_pair;

static int runaway_start = 0;

static void err<`a>(string msg,Lexbuf<`a> lb) {
  segment s = segment_of_abs(lexeme_start(lb),lexeme_end(lb));
  post_error(mk_err_lex (s,msg));
}
static void runaway_err<`a>(string msg,Lexbuf<`a> lb) {
  segment s = segment_of_abs(runaway_start,lexeme_start(lb));
  post_error(mk_err_lex (s,msg));
}

/************************** RESERVED WORDS **************************/

static $(string,short) rw_array[] = {
  $("abstract", ABSTRACT),
  $("auto", AUTO),
  $("break", BREAK),
  $("case", CASE),
  $("catch", CATCH),
  $("char", CHAR),
  $("codegen", CODEGEN),
  $("const", CONST),
  $("continue", CONTINUE),
  $("cut", CUT),
  $("default", DEFAULT),
  $("do", DO),
  $("double", DOUBLE),
  $("else", ELSE),
  $("enum", ENUM),
  $("extern", EXTERN),
  $("fallthru", FALLTHRU),
  $("fill", FILL),
  $("float", FLOAT),
  $("for", FOR),
  $("fprintf", FPRINTF),
  $("fscanf", FSCANF),
  $("goto", GOTO),
  $("if", IF),
  $("inline", INLINE),
  $("int", INT),
  $("let", LET),
  $("long", LONG),
  $("namespace", NAMESPACE),
  $("new", NEW),
  $("null", NULL_kw),
  $("printf", PRINTF),
  $("register", REGISTER),
  $("restrict", RESTRICT),
  $("return", RETURN),
  $("scanf", SCANF),
  $("short", SHORT),
  $("signed", SIGNED),
  $("sizeof", SIZEOF),
  $("splice", SPLICE),
  $("sscanf", SSCANF),
  $("static", STATIC),
  $("struct", STRUCT),
  $("switch", SWITCH),
  $("throw", THROW),
  $("try", TRY),
  $("typedef", TYPEDEF),
  $("union", UNION),
  $("unsigned", UNSIGNED),
  $("using", USING),
  $("void", VOID),
  $("volatile", VOLATILE),
  $("while", WHILE),
  $("xenum", XENUM),
  $("xprintf", XPRINTF)
};

///////////////////////// Trie manipulation ///////////////////////
static int str_index(string buff, int offset, int len) {
  int    i    = offset;
  int    last = offset + len - 1;
  trie_t t    = ids_trie;
  while(i <= last) {
    int ch = ((int)buff[i]) - 48; // see width of trie above
    if(t->children == null) {
      // new string, extend the trie and return
      while(i <= last) {
	t->children = 
	  (trie_child_t) new {(trie_child_v_t) new { for i < 75 : null }};
	(*(t->children))[ch] = &Trie(null,-1);
	t = (*(t->children))[ch];
	++i;
	ch = ((int)buff[i]) - 48; // see width of trie above
      }
      let newstr = new_string(len+1);
      String::zstrncpy(newstr,0,buff,offset,len);
      int ans = Xarray::add_ind((Xarray::Xarray<stringptr>)symbols, 
				new {newstr});
      t->shared_str = ans;
      return ans;
    }
    // walk down one level
    if((*(t->children))[ch] == null)
      (*(t->children))[ch] = &Trie(null,-1);
    t = (*(t->children))[ch];
    ++i;
  }
  // build string if necessary and return
  if(t->shared_str == -1) {
    let newstr = new_string(len+1);
    String::zstrncpy(newstr,0,buff,offset,len);
    int ans = Xarray::add_ind((Xarray::Xarray<stringptr>)symbols, 
			      new {newstr});
    t->shared_str = ans;
    return ans;
  }
  return t->shared_str;
}

static int str_index_lbuf<`a>(Lexbuf<`a> lbuf) {
  return str_index(lbuf->lex_buffer, 
		   lbuf->lex_start_pos,
		   lbuf->lex_curr_pos - lbuf->lex_start_pos);
}

static void insert_typedef(stringptr sptr) {
  string s = *sptr;
  int    len = s.size - 1;
  trie_t t   = typedefs_trie;
  for(int i=0; i < len; ++i) {
    int ch = ((int)s[i]) - 48;
    if(t->children == null) {
      while(i < len) {
	t->children = (trie_child_t) &$((new { for i < 75 : null }));
	(*(t->children))[ch] = &Trie(null,0);
	t = (*(t->children))[ch];
	++i;
	ch = ((int)s[i]) - 48; // see width of trie above
      }
      t->shared_str = true;
      return;
    }
    // walk down one level
    if((*(t->children))[ch] == null)
      (*(t->children))[ch] = &Trie(null,false);
    t = (*(t->children))[ch];
  }
  t->shared_str = true;
  return;
}

static stringptr get_symbol(int symbol_num) {
  return Xarray::get((Xarray::Xarray<stringptr>)symbols, symbol_num);
}

/************************ INTEGER CONSTANTS ************************/

/* String to integer conversions.  Core::int_of_string does not handle
   all of the cases we want: it does not handle a trailing 'u', 'U',
   'l', or 'L'; and in particular, it does not treat '0'['0'-'7'] as
   an octal number.  */

  // copied from Core
static int int_of_char(char c) {
  if ('0'<=c && c<='9')      return c-'0';
  else if ('a'<=c && c<='f') return 10+c-'a';
  else if ('A'<=c && c<='F') return 10+c-'A';
  else throw InvalidArg("string to integer conversion");
}

/* 
 * FIX: We should really have 8-bytes to store a long literal!!!
 *      That is, we and the previous version totally ignore the L!!!
 */
$(sign, int)@ intconst<`a>(Lexbuf<`a> lbuf, int start, int base) {
  unsigned int n    = 0;
  int          end  = lbuf->lex_curr_pos;
  string       buff = lbuf->lex_buffer;
  int          i    = start + lbuf->lex_start_pos;
  for(int i = start + lbuf->lex_start_pos; i < end; ++i) {
    char c = buff[i];
    switch (c) {
        // incorrect to return as soon as we see 'u' 'U' if l isn't ignored
    case 'u': fallthru;
    case 'U': return &$(Unsigned,(signed int)n); 
    case 'l': break;
    case 'L': break;
    default: n = n*base + (unsigned int)int_of_char(c); break;
    }
  }
  return &$(Signed, (signed int)n);
}

/*********************** CHARACTER CONSTANTS ***********************/

static char char_for_octal_code<`a>(Lexbuf<`a> lb, int start, int howmany) {
  int c = 0;
  for (int i = 0; i<howmany; i++)
    c = (8 * c) + lexeme_char(lb,start+i) - 48;
  return (char)c;
}

// FIX: shouldn't build a lexeme, but pretty rare
static char char_for_hex_code(string s, int start) {
  int c = 0; 
  int len = String::strlen(s);
  for (int i = 0; start+i<len; i++) {
    char x = s[start+i];
    if ('0'<=x && x<='9') 
      c = (16 * c) + ((int)x)-((int)'0');
    else if ('A'<=x && x<='F') 
      c = (16 * c) + ((int)x)-((int)'A');
    else if ('a'<=x && x<='f') 
      c = (16 * c) + ((int)x)-((int)'a');
    else break;
  }
  return (char)c;
}

/************************* STRING CONSTANTS *************************/

string string_buffer = "xxxxxxxxxx";
int    string_pos    = 0;
void store_string_char(char c) {
  int sz = string_buffer.size;
  if (string_pos >= sz) {
    int newsz = sz;
    while (string_pos >= newsz) newsz = newsz * 2;
    string str = new {for i < newsz : (i < sz) ? string_buffer[i] : '\000'};
    string_buffer = str;
  }	
  string_buffer[string_pos] = c;
  ++string_pos;
}
string get_stored_string () {
  string str = String::substring(string_buffer,0,string_pos);
  string_pos = 0;
  return str;
} 

/******************* NAMESPACE, USING, AND TYPEDEF  *******************/

static struct Ldecls {
  // records typedefs and namespaces declared in a scope
  Set::Set<var> typedefs;
  Set::Set<var> namespaces;
};
typedef struct Ldecls @ldecls_t;

static struct Lvis {  // the King lives!
  // records the namespaces whose declarations are visible in a scope
  list<var>       current_namespace;
  list<list<var>> imported_namespaces;
};
typedef struct Lvis @lvis;

static struct Lstate {
  // lstack is the current nested scope structure,
  // decls is the global declaration mapping
  List<lvis>                     lstack; 
  Dict::Dict<list<var>,ldecls_t> decls;
};
typedef struct Lstate @lstate_t;

static Opt_t<lstate_t> lstate = null;

static void typedef_init() {
  let init_lvis   = &Lvis{.current_namespace=null,
                          .imported_namespaces=null};
  let init_lstack = &cons(init_lvis, null);
  let init_decls  = Dict::insert(Dict::empty(varlist_cmp),
                                 null,
                                 &Ldecls{.typedefs=Set::empty(zstrptrcmp),
                                         .namespaces=Set::empty(zstrptrcmp)});
  lstate = &Opt(&Lstate{.lstack=init_lstack,
                        .decls=init_decls});
}

static list<var> get_absolute_namespace(List<var> ns) {
  // ns is a relative namespace, we return the absolute namespace
  // Invariant: ns != null -- in the type!
  var n = ns->hd;
  // For each enclosing scope...
  for (list<lvis> ls = lstate->v->lstack; ls != null; ls = ls->tl) {
    lvis lv = ls->hd; // ... see what namespaces are visible
    // ... and look in each such visible namespace
    list<list<var>> x = &cons(lv->current_namespace,lv->imported_namespaces);
    for (; x != null; x = x->tl) {
      ldecls_t ld = Dict::lookup(lstate->v->decls,x->hd);
      // ... for namespace n
      if (Set::member(ld->namespaces,n))
        // OK, we know ns refers to x.hd+ns
        return List::append(x->hd,ns);
    }
  }
  yyerror(xprintf("undeclared namespace %s",String::str_sepstr(ns,"::")));
  return null; // FIX: can we return something better here? Do we have
               // to give up and raise an exception?
}

static void recompute_typedefs() {
  // Drop the old trie on the floor.
  typedefs_trie = &Trie(null,false);
  
  // For each enclosing scope, get the visible namespaces and add all
  // of their typedefs
  for (list<lvis> ls = lstate->v->lstack; ls != null; ls = ls->tl) {
    lvis lv = ls->hd; 
    list<list<var>> x = &cons(lv->current_namespace, lv->imported_namespaces);
    for (; x != null; x = x->tl) {
      ldecls_t ld = Dict::lookup(lstate->v->decls,x->hd);
      Set::iter(insert_typedef,ld->typedefs);
    }
  }
}

// This can stay the slow way because most identifiers are not qualified.
static bool is_typedef_in_namespace(List<var> ns, var v) {
  list<var> ans = get_absolute_namespace(ns);
  try {
    ldecls_t ld = Dict::lookup(lstate->v->decls,ans);
    return Set::member(ld->typedefs,v);
  } catch { case Dict::Absent:
    return false;
  }
}
static bool is_typedef(List::list<var> ns, var v) {
  if (ns != null)
    return is_typedef_in_namespace((List<stringptr>)ns,v);
  // all unqualified typedefs must be in the trie 
  // look ma -- fast lookup
  string s   = *v;
  int    len = s.size - 1;
  trie_t t   = typedefs_trie;
  for(int i = 0; i < len; ++i)
    if(t == null || t->children == null)
      return false;
    else
      t = (*(t->children))[((int)s[i])-48];
  if(t == null)
    return false;
  return t->shared_str;
}

void enter_namespace(var s) {
  list<var> ns = lstate->v->lstack->hd->current_namespace;
  list<var> new_ns = List::append(ns,&cons(s,null));
  // Push the new namespace on the stack
  lstate->v->lstack =
    &cons(&Lvis{.current_namespace = new_ns,.imported_namespaces = null},
          lstate->v->lstack);
  // If this is the first time the new namespace has been encountered,
  // make sure it is bound in the old namespace, and add an empty
  // environment for the new namespace
  ldecls_t ld = Dict::lookup(lstate->v->decls,ns);
  if (!Set::member(ld->namespaces,s)) {
    lstate->v->decls = Dict::insert(lstate->v->decls,
				    ns,
				    &Ldecls{.typedefs = ld->typedefs,
					    .namespaces = 
					    Set::insert(ld->namespaces, s)});
    lstate->v->decls = Dict::insert(lstate->v->decls,
				    new_ns,
				    &Ldecls{.typedefs= Set::empty(zstrptrcmp),
					    .namespaces= Set::empty(zstrptrcmp)
				    });

  }
  recompute_typedefs();
}
void leave_namespace() {
  // we never leave the outermost namespace, so the cast is okay
  lstate->v->lstack = (List<lvis>)lstate->v->lstack->tl;
  recompute_typedefs();
}
void enter_using(qvar q) {
  _ ns;
  switch ((*q)[0]) {
  case Loc_n:
    ns = (List<stringptr>)&cons((*q)[1],null);
    break;
  case Rel_n(y): fallthru(y);
  case Abs_n(y):
    ns = (List<stringptr>)List::append(y,&cons((*q)[1],null));
    break;
  }

  let ans      = get_absolute_namespace(ns);
  let imported = lstate->v->lstack->hd->imported_namespaces;

  lstate->v->lstack->hd->imported_namespaces = &cons(ans,imported);
  
  // some more typedefs may be visible
  recompute_typedefs();
}
void leave_using() {
  let imported = lstate->v->lstack->hd->imported_namespaces;
  lstate->v->lstack->hd->imported_namespaces = imported->tl;

  // some typedefs may no longer be visible
  recompute_typedefs();
}

void register_typedef(qvar q) {
  // FIX: we assume that q is not in fact qualified
  let current = lstate->v->lstack->hd->current_namespace;
  let ds      = lstate->v->decls;
  let ld      = Dict::lookup(ds,current);
  let new_ld  = &Ldecls{.typedefs   = Set::insert(ld->typedefs,(*q)[1]),
                        .namespaces = ld->namespaces};
  lstate->v->decls = Dict::insert(ds,current,new_ld);

  // FIX: We're really assuming it's unqualified here -- else need to
  //      decide if the namespace-list is a visible one
  insert_typedef((*q)[1]);
}

static short process_id<`a>(Lexbuf<`a> lbuf) {
  int symbol_num = str_index_lbuf(lbuf);

  // maybe it's a keyword
  if(symbol_num < num_kws)
    return (short)kw_nums[symbol_num]; // cast should be unnecessary

  stringptr s = get_symbol(symbol_num);

  // maybe it's a typedef
  if (is_typedef(null,s)) {
    token_qvar = &$(Rel_n(null),s);
    return QUAL_TYPEDEF_NAME;
  }

  // alas, it's an identifier
  token_string = *s;
  return IDENTIFIER;
}

static short process_qual_id<`a>(Lexbuf<`a> lbuf) {
  int    i   = lbuf->lex_start_pos;
  int    end = lbuf->lex_curr_pos;
  string s   = lbuf->lex_buffer;

  list<var> rev_vs = null;

  while (i<end) {
    int start = i;
    for (; i < end && s[i] != ':'; i++) 
      ; // skip
    if (start == i) // no progress -- first char is ':'
      throw Impossible("bad namespace");
    int vlen = i - start;
    var v    = get_symbol(str_index(s, start, vlen));
    rev_vs = &cons(v,rev_vs);
    i += 2;
  }
  if (rev_vs == null)
    throw Impossible("bad namespace");
  var       v  = rev_vs->hd;
  list<var> vs = List::imp_rev(rev_vs->tl);
  token_qvar = &$(Rel_n(vs),v);
  if (is_typedef(vs,v))
    return QUAL_TYPEDEF_NAME;
  else 
    return QUAL_IDENTIFIER;
}

// Forward declarations of lexing functions 
extern int token<`a>(Lexbuf<`a>);
extern int strng<`a>(Lexbuf<`a>);
extern int comment<`a>(Lexbuf<`a>);
} // namespace Lex

// for parser -- must not be prefixed
int yylex() { 
 int ans = Lex::token(lbuf->v);
 yylloc.first_line = lexeme_start(lbuf->v);
 yylloc.last_line  = lexeme_end(lbuf->v);
 switch (ans) {
 case IDENTIFIER        : yylval = String_tok(Lex::token_string); break;
 case QUAL_IDENTIFIER   : yylval = QualId_tok(Lex::token_qvar);   break;
 case QUAL_TYPEDEF_NAME : yylval = QualId_tok(Lex::token_qvar);   break;
 case TYPE_VAR          : yylval = String_tok(Lex::token_string); break;
 case INTEGER_CONSTANT  : yylval = Int_tok(Lex::token_int);       break;
 case CHARACTER_CONSTANT: yylval = Char_tok(Lex::token_char);     break;
 case FLOATING_CONSTANT : yylval = String_tok(Lex::token_string); break;
 case STRING            : yylval = String_tok(Lex::token_string); break;
 default: break;
 }
 return ans;
} 

namespace Lex;
////////////////////////// LEXING RULES /////////////////////////////
}

let newline = ('\n' | '\r' | "\r\n")

rule token = parse
/* Identifiers, type names, and keywords */
  ['A'-'Z''a'-'z']['A'-'Z''a'-'z''0'-'9''_']*
{ return process_id(lexbuf); }
| ['_']['A'-'Z''a'-'z''0'-'9''_']+
{ return process_id (lexbuf); }
/* Qualified identifiers and type names (e.g., Foo::bar) */
| (['A'-'Z''a'-'z''_']['A'-'Z''a'-'z''0'-'9''_']*':'':')+
  ['A'-'Z''a'-'z''_']['A'-'Z''a'-'z''0'-'9''_']*
      { return process_qual_id(lexbuf); }
/* Type variables */
| '`'['A'-'Z''a'-'z''0'-'9''_']+
   { token_string = *(get_symbol(str_index_lbuf(lexbuf))); 
      return TYPE_VAR; }
/* Integer constants */
| '0'['x''X']['0'-'9''a'-'f''A'-'F']+((['u''U']['l''L']?)|(['l''L']['u''U']?))?
      { token_int = intconst(lexbuf,2,16);
        return INTEGER_CONSTANT; }
| '0'['0'-'7']*((['u''U']['l''L']?)|(['l''L']['u''U']?))?
      { token_int = intconst(lexbuf,0,8);
        return INTEGER_CONSTANT; }
| '0'['0'-'9']+((['u''U']['l''L']?)|(['l''L']['u''U']?))?
      /* This is really an error case according to OSI C --
         the leading 0 indicates this should be in octal. */
      /* FIX: print a warning message? */
      { token_int = intconst(lexbuf,0,10);
        return INTEGER_CONSTANT; }
| ['1'-'9']['0'-'9']*((['u''U']['l''L']?)|(['l''L']['u''U']?))?
      { token_int = intconst(lexbuf,0,10);
        return INTEGER_CONSTANT; }
/* Floating-point constants */
| ['0'-'9']+['e''E']['+''-']?['0'-'9']+['f''F''l''L']?
      { token_string = lexeme(lexbuf);
        return FLOATING_CONSTANT; }
| ((['0'-'9']+'.')|(['0'-'9']+'.'['0'-'9']+)|('.'['0'-'9']+))
  (['e''E']['+''-']?['0'-'9']+)?['f''F''l''L']?
      { token_string = lexeme(lexbuf);
        return FLOATING_CONSTANT; }
/* Operators */
| "==" { return  EQ_OP; }
| "!=" { return  NE_OP; }
| "<=" { return  LE_OP; }
| ">=" { return  GE_OP; }
| "++" { return  INC_OP; }
| "--" { return  DEC_OP; }
| "+=" { return  ADD_ASSIGN; }
| "-=" { return  SUB_ASSIGN; }
| "*=" { return  MUL_ASSIGN; }
| "/=" { return  DIV_ASSIGN; }
| "%="   { return  MOD_ASSIGN; }
| "|="   { return  OR_ASSIGN; }
| "^="   { return  XOR_ASSIGN; }
| "&="   { return  AND_ASSIGN; }
| "<<="  { return  LEFT_ASSIGN; }
| ">>="  { return  RIGHT_ASSIGN; } 
| "&&" { return  AND_OP; }
| "||" { return  OR_OP; }  
| "<<" { return  LEFT_OP; }
/* JGM: see shift_expr and relational_expr -- we now parse >> as two
 * separate > tokens.  */
| ">>" { return  RIGHT_OP; }
| "<>" { return  LEFT_RIGHT; }
| "->" { return PTR_OP; }
| "..." { return ELLIPSIS; }
/* comments */
| "#"[^ '\n' '\r']*(newline)      { return  token(lexbuf); }
| [' ' '\t' '\v' '\f' '\n' '\r']+     { return  token(lexbuf); }
| "//"[^'\n' '\r']* newline       { return  token(lexbuf); }
| "/*"  { comment_depth = 1; 
	  runaway_start = lexeme_start(lexbuf); 
	  comment(lexbuf); 
	  return token(lexbuf); }
/* string constants */
| "\""
  { string_pos = 0; 
    runaway_start = lexeme_start(lexbuf);
    strng(lexbuf);
    token_string = get_stored_string();
    return STRING; }
/* character constants */
| "'\\a'"   { token_char = '\a'; return CHARACTER_CONSTANT; }
| "'\\b'"   { token_char = '\b'; return CHARACTER_CONSTANT; }
| "'\\f'"   { token_char = '\f'; return CHARACTER_CONSTANT; }
| "'\\n'"   { token_char = '\n'; return CHARACTER_CONSTANT; }
| "'\\r'"   { token_char = '\r'; return CHARACTER_CONSTANT; }
| "'\\t'"   { token_char = '\t'; return CHARACTER_CONSTANT; }
| "'\\v'"   { token_char = '\v'; return CHARACTER_CONSTANT; }
| "'\\\\'"  { token_char = '\\'; return CHARACTER_CONSTANT; }
| "'\\''"   { token_char = '\''; return CHARACTER_CONSTANT; }
| "'\\\"'"  { token_char = '"';  return CHARACTER_CONSTANT; }
| "'\\?'"   { token_char = '?';  return CHARACTER_CONSTANT; }
/* octal character escapes */
| "'\\" ['0'-'7']['0'-'7']['0'-'7'] "'"
            { token_char = char_for_octal_code(lexbuf,2,3);
              return CHARACTER_CONSTANT;
            }
| "'\\" ['0'-'7']['0'-'7'] "'"
            { token_char = char_for_octal_code(lexbuf,2,2);
              return CHARACTER_CONSTANT;
            }
| "'\\" ['0'-'7'] "'"
            { token_char = char_for_octal_code(lexbuf,2,1);
              return CHARACTER_CONSTANT;
            }
/* hex character escapes */
| "'\\x" ['0'-'9''A'-'Z''a'-'z']+ "'"
            { token_char = char_for_hex_code(lexeme(lexbuf),3);
              return CHARACTER_CONSTANT;
            }
| "'" [^ '\\' '\'' '\n'] "'"
    { token_char = lexeme_char(lexbuf,1);
      return CHARACTER_CONSTANT;
    }
/* End of file */
| eof { return -1; }
/* Default case */
| _   { return (int)(lexeme_char(lexbuf,0)); }

and strng = parse
    "\"" [' ''\n''\r''\t']* "\""
  /* concatenate adjacent strings */
                    { return strng(lexbuf); }
  | "\""            { return 0; /* return value ignored */ }
  | "\\" newline    { return strng(lexbuf); }
  | "\\a"           { store_string_char('\a'); return strng(lexbuf); }
  | "\\b"           { store_string_char('\b'); return strng(lexbuf); }
  | "\\f"           { store_string_char('\f'); return strng(lexbuf); }
  | "\\n"           { store_string_char('\n'); return strng(lexbuf); }
  | "\\r"           { store_string_char('\r'); return strng(lexbuf); }
  | "\\t"           { store_string_char('\t'); return strng(lexbuf); }
  | "\\v"           { store_string_char('\v'); return strng(lexbuf); }
  | "\\\\"          { store_string_char('\\'); return strng(lexbuf); }
  | "\\'"           { store_string_char('\''); return strng(lexbuf); }
  | "\\\""          { store_string_char('"');  return strng(lexbuf); }
  | "\\?"           { store_string_char('?');  return strng(lexbuf); }
  /* octal character escapes */
  | "\\" ['0'-'7']['0'-'7']['0'-'7']
                    { store_string_char(char_for_octal_code(lexbuf,1,3));
                      return strng(lexbuf);
                    }
  | "\\" ['0'-'7']['0'-'7']
                    { store_string_char(char_for_octal_code(lexbuf,1,2));
                      return strng(lexbuf);
                    }
  | "\\" ['0'-'7']
                    { store_string_char(char_for_octal_code(lexbuf,1,1));
                      return strng(lexbuf);
                    }
  /* hex character escapes */
  | "\\x" ['0'-'9''A'-'Z''a'-'z']+
                    { store_string_char(char_for_hex_code(lexeme(lexbuf),2));
                      return strng(lexbuf);
                    }
  | [^ '"''\\''\n']   /* NOT double quote, backslash, or newline */
                    { /* for efficiency, should have a while loop here */
                      store_string_char (lexeme_char(lexbuf,0));
		      return strng(lexbuf); }
  | newline         { runaway_err("string ends in newline",lexbuf);
                      return 0; /* return value ignored */
                    }
  | eof             { runaway_err("unterminated string",lexbuf);
                      return 0; /* return value ignored */
                    }
  | _               { err("bad character following backslash in string",lexbuf);
		      return strng(lexbuf); }
and comment = parse
   "/*"             { ++comment_depth; return comment(lexbuf); }
 | "*/"             { --comment_depth; 
		      if (comment_depth > 0) 
			return comment(lexbuf);
		      return 0; /* return value ignored */
		    }
 | eof              { runaway_err("unterminated comment",lexbuf);
                      return 0; /* return value ignored */ 
                    }
 | '*'              { return comment(lexbuf); }
 | '/'              { return comment(lexbuf); }
 | [^ '/' '*']+     { return comment(lexbuf); }

{

void lex_init() {
  ids_trie      = new {Trie(null,-1)};
  typedefs_trie = new {Trie(null,false)};
  symbols       = Xarray::create(101,new{""});
  num_kws       = rw_array.size;
  kw_nums       = new {for i < num_kws : 0};
  for (int i=0; i < num_kws; ++i) {
    let str = rw_array[i][0];
    str_index(str, 0, String::strlen(str));
    kw_nums[i] = rw_array[i][1];
  }
  typedef_init();
  comment_depth = 0;
}

}
