#ifndef TCENV_H
#define TCENV_H

#include "core.h"
#include "list.h"
#include "set.h"
#include "dict.h"
#include "absyn.h"
#include "position.h"

namespace Tcenv {

using Core;
using List;
using Set;
using Dict;
using Absyn;
using Position;

// Used to tell what an ordinary identifer refers to 
extern enum Resolved {
  VarRes(binding_t); // includes unresolved variant
  StructRes(structdecl);
  EnumRes(enumdecl,enumfield);
  XenumRes(xenumdecl,enumfield);
};
typedef enum Resolved resolved_t;

// Global environments -- what's declared in a global scope 
// Warning: ordinaries should really be abstract so we can ensure that any
// lookup sets the bool field to true!
// FIX: We should tree-shake the type declarations too!
extern struct Genv {
  Set<var>               namespaces;
  Dict<var,structdecl@>  structdecls;
  Dict<var,enumdecl@>    enumdecls;
  Dict<var,xenumdecl@>   xenumdecls;
  Dict<var,typedefdecl>  typedefs; // indirection unneeded b/c no redeclaration
  Dict::Dict<var,$(resolved_t,bool)@> ordinaries; // bool for tree-shaking
  list<list<var>>        availables; // "using" namespaces
};
typedef struct Genv @genv_t;

// Local function environments
extern struct Fenv;
typedef struct Fenv @fenv_t; 

extern enum Jumpee {
  NotLoop_j;
  CaseEnd_j;
  FnEnd_j;
  Stmt_j(stmt);
};
typedef enum Jumpee jumpee_t;

// Models the nesting of the RTCG constructs 
extern enum Frames<`a> {
  Outermost(`a);
  Frame(`a,enum Frames<`a>);
  Hidden(`a,enum Frames<`a>);
};
typedef enum Frames<`a> frames<`a>;

// Type environments 
extern struct Tenv {
  list<var>               ns; // current namespace
  Dict<list<var>,genv_t>  ae; // absolute environment
  Opt_t<frames<fenv_t>>   le; // local environment, == null except in functions
};
typedef struct Tenv @tenv;

extern tenv tc_init();
extern genv_t empty_genv();
extern fenv_t new_fenv(fndecl);

extern tenv enter_ns(tenv, var);

extern list<var>         resolve_namespace(tenv,segment,list<var>);
extern resolved_t        lookup_ordinary(tenv,segment,qvar);
extern structdecl@       lookup_structdecl(tenv,segment,qvar);
extern enumdecl@         lookup_enumdecl(tenv,segment,qvar);
extern Opt_t<xenumdecl@> lookup_xenumdecl(tenv,segment,qvar);
extern typedefdecl       lookup_typedefdecl(tenv,segment,qvar);
extern structdecl@       lookup_structdecl_abs(tenv,segment,qvar);
extern enumdecl@         lookup_enumdecl_abs(tenv,segment,qvar);
extern Opt_t<xenumdecl@> lookup_xenumdecl_abs(tenv,segment,qvar);


extern typ  return_typ(tenv);

extern tenv add_local_var(segment,tenv,vardecl);
extern tenv add_pat_var  (segment,tenv,vardecl);

extern list<tvar> lookup_type_vars(tenv);
extern tenv       add_type_vars(segment,tenv,list<tvar>);

extern tenv set_in_loop(tenv te, stmt continue_dest);
extern tenv set_in_switch(tenv);
extern tenv set_fallthru(tenv te, 
			 $(list<tvar>,list<vardecl>) * pat_typ,
			 stmt body);
extern tenv clear_fallthru(tenv);
extern tenv set_next(tenv, jumpee_t);

// The next 4 all assign through their last arg
extern void process_continue(tenv,stmt,Opt_t<stmt>*);
extern void process_break   (tenv,stmt,Opt_t<stmt>*);
extern void process_goto(tenv,stmt,var,Opt_t<stmt>*);
extern $(stmt,list<tvar>,list<typ>)* process_fallthru(tenv,stmt,Opt_t<stmt>*);

extern stmt get_encloser(tenv);
extern tenv set_encloser(tenv,stmt);

extern tenv add_label(tenv, var, stmt);
extern bool all_labels_resolved(tenv);

extern tenv new_block(tenv);
extern int  curr_block(tenv);
extern typ  block_to_typ(tenv,int);
extern void check_rgn_accessible(tenv,segment,typ);

// what we synthesize when type-checking a statement or expression:
// This should be abstract, but I'm saving an allocation and a level of
// indirection -- do NOT use this representation information outside of Tcenv! 
extern struct Synth { typ type; };
typedef struct Synth synth; // no longer a pointer (only one field)
// the type of the expression (only meaningful for synth generated by exps)
extern typ synth_typ(synth);
// given a synth, imperatively set the type to t
extern synth synth_set_typ(synth s,typ t);
// synth for an exp that has this type
extern synth standard_synth(tenv, typ);
// synth we get on error in expressions (type is wild) or on throw
extern synth wild_synth(tenv);
}
#endif
