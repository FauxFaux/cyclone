/* Porting C code to Cyclone
   Copyright (C) 2001 Greg Morrisett, AT&T
   This file is part of the Cyclone compiler.

   The Cyclone compiler is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   The Cyclone compiler is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with the Cyclone compiler; see the file COPYING. If not,
   write to the Free Software Foundation, Inc., 59 Temple Place -
   Suite 330, Boston, MA 02111-1307, USA. */

/* This set of routines is meant to crawl over C code and suggest
 * a list of edits that will move the C code closer to Cyclone.
 * (The rewrite tool in cyclone/tools/rewrite can process the edits.)
 * It does this by essentially performing an ad-hoc type-inference
 * on the C code, generating a lot of sub-typing and equality
 * constraints.  It then tries to solve the constraints (in a
 * completely ad-hoc fashion) and compares the solution to
 * the original C types.  If there's a mismatch, an edit is emitted
 * corresponding to the mismatch.
 *
 * Right now, the tool tries to:
 *   * insert/remove const qualifiers where needed
 *   * change * to ? where needed
 *   * insert ZEROTERM/NOZEROTERM where needed
 *   * insert region names where needed
 *
 * The most interesting of these is the region names.  For a given
 * function f, we insert fresh constraint variables corresponding to
 * each region in f's prototype.  We then do inference on f which
 * might end up constraining those variables to be equal or subtypes
 * or equal to the Heap region.  We then generalize the constraint
 * variables.  (This is much like ML-style inference.)  We then
 * crawl over the original type, taking into account how Cyclone
 * assigns default regions for parameters and return types, and
 * emit an edit only when a generalized region variable occurs more
 * than once (or when an argument region is in the heap.)
 *
 * Currently, the inference is pretty naive and overly simple. For
 * instance, it treats all arithmetic types (int, float, char, double, etc.)
 * as a single type.  It does not properly deal with Cyclone constructs
 * so it can't really be used on Cyclone code.  For instance, it doesn't
 * deal properly with name spaces (sets them all to Loc_n) and it
 * can't process Cyclone abstract syntax additions (e.g., patterns,
 * datatypes, etc.)
 *
 * The inference is also very naive with respect to constraint representation
 * and solving.  Right now, I just have a very ad-hoc set of rules for
 * trying to simplify the constraints eagerly.
*/

#include <string.h>
#include "absynpp.h"
#include "tcutil.h"
#include "tcexp.h"
#include "tcstmt.h"
#include "evexp.h"
#include "tc.h"
#include "tcdecl.h"
#include <set.h>
#include <hashtable.h>

using Core;
using List;
using Absyn;
using Absynpp;
using Tcutil;
using Tcenv;
namespace Port;
//#define PORT_DEBUG 1

// An edit indicates a change that needs to be made
typedef struct Edit {
  seg_t loc;
  string_t old_string;
  string_t new_string;
} @edit_t;
typedef list_t<edit_t> edits_t;
// Used for sorting edits
int cmp_edit(edit_t e1, edit_t e2) {
  return (int)e1 - (int)e2;
}
static seg_t get_seg(edit_t e) {
  return e->loc;
}
int cmp_seg_t(seg_t loc1, seg_t loc2){
  return (int)(loc1-loc2);
}
int hash_seg_t(seg_t loc){
  return (int)loc;
}
typedef struct VarUsage {
  bool address_taken;
  exp_opt_t init;
  list_t<seg_t> usage_locs;
} *varusage_t;
/////////////////////////////////////////////////////////////////////
// A ctype_t is a type that we use for processing C code and is
// an approximation of Absyn's type_t
extern datatype Ctype;
typedef datatype Ctype @ctype_t;
// Unification variables
typedef struct Cvar {
  int id;
  ctype_t *eq; // when not NULL, points to equivalence class
  list_t<ctype_t> uppers; // upper bounds
  list_t<ctype_t> lowers; // lower bounds
} @cvar_t;
// Used in aggregates
typedef struct Cfield {
  ctype_t qual;
  field_name_t f;
  ctype_t type;
}@ cfield_t;
typedef list_t<cfield_t> cfields_t;
// We have the following "sub-typing" relations on ctypes:
//   Notconst <= Const
//   t <= Void  for a type t
//   Zero <= Ptr <= Arith
//   Array <= Ptr
//   Zterm <= Nozterm
datatype Ctype {
  Const_ct;     // const qualifier
  Notconst_ct;  // not-const qualifier
  Thin_ct;      // * pointers
  Fat_ct;       // ? pointers
  Void_ct;      // void
  Zero_ct;      // used for NULL and 0
  Arith_ct;     // used for int, short, char, float, double, long long, etc.
  Heap_ct;      // heap region
  Zterm_ct;  // zero-terminated array/ptr
  Nozterm_ct; // not-zero terminated
  RgnVar_ct(tvarname_t); // an explicit region var `r
  Ptr_ct(ctype_t elt, ctype_t qual, ctype_t ptr_kind, ctype_t rgn, ctype_t zt);
  Array_ct(ctype_t elt, ctype_t qual, ctype_t zt);
  // used for an aggregate that we've figured out fields are NULL when
  // we haven't defined the aggregate yet.
  KnownAggr_ct($(struct Aggrdecl @, cfields_t)@);
  // used for an aggregate that we've not yet figured out -- if eq is
  // not NULL, points to the equivalence class
  UnknownAggr_ct(cfields_t, ctype_t* eq);
  Fn_ct(ctype_t return_type, list_t<ctype_t> arg_types);
  Var_ct(cvar_t);
};
datacon(Ctype,Const_ct);
datacon(Ctype,Notconst_ct);
datacon(Ctype,Thin_ct);
datacon(Ctype,Fat_ct);
datacon(Ctype,Void_ct);
datacon(Ctype,Zero_ct);
datacon(Ctype,Arith_ct);
datacon(Ctype,Heap_ct);
datacon(Ctype,Zterm_ct);
datacon(Ctype,Nozterm_ct);

//////////////////////////////////////////////////////////////////
// Convert a ctype_t to a string
static string_t ctypes2string(bool deep, list_t<ctype_t,`H> ts);
static string_t cfields2string(bool deep, cfields_t ts);
static string_t ctype2string(bool deep, ctype_t t) {
  switch (t) {
  case &Const_ct: return "const";
  case &Notconst_ct: return "notconst";
  case &Thin_ct: return "thin";
  case &Fat_ct: return "fat";
  case &Void_ct: return "void";
  case &Zero_ct: return "zero";
  case &Arith_ct: return "arith";
  case &Heap_ct: return "heap";
  case &Zterm_ct: return "ZT";
  case &Nozterm_ct: return "NZT";
  case &RgnVar_ct(n): return aprintf("%s",*n);
  case &Ptr_ct(elt,qual,k,rgn,zt):
    return aprintf("ptr(%s,%s,%s,%s,%s)",ctype2string(deep,elt),
                   ctype2string(deep,qual),ctype2string(deep,k),
                   ctype2string(deep,rgn),ctype2string(deep,zt));
  case &Array_ct(elt,qual,zt):
    return aprintf("array(%s,%s,%s)",ctype2string(deep,elt),
                   ctype2string(deep,qual),ctype2string(deep,zt));
  case &KnownAggr_ct(&$(ad, cfs)):
    string_t s = (ad->kind == StructA) ? "struct" : "union";
    if (!deep)
      return aprintf("%s %s",s,qvar2string(ad->name));
    else
      return aprintf("%s %s {%s}",s,qvar2string(ad->name),
                     cfields2string(false,cfs));
  case &UnknownAggr_ct(cfs, &eq): return ctype2string(deep,eq);
  case &UnknownAggr_ct(cfs, _):
    return aprintf("aggr {%s}",cfields2string(deep,cfs));
  case &Fn_ct(t,ts):
    return aprintf("fn(%s)->%s",ctypes2string(deep,ts),ctype2string(deep,t));
  case &Var_ct(cv):
    if (cv->eq)
      return ctype2string(deep,*cv->eq);
    else if (!deep || (cv->uppers == NULL && cv->lowers == NULL))
      return aprintf("var(%d)",cv->id);
    else return aprintf("var([%s]<=%d<=[%s])",
                        ctypes2string(false,cv->lowers),
                        cv->id,
                        ctypes2string(false,cv->uppers));
  }
}
static stringptr_t ctype2stringptr(bool deep,ctype_t t) { return new (ctype2string(deep,t)); }
list_t<stringptr_t> sep(string_t<`H> s, list_t<stringptr_t<`H,`H>,`H> xs) {
  let sptr = new(s);
  if (xs == NULL) return xs;
  let prev = xs;
  let curr = xs->tl;
  for (; curr != NULL; prev = curr, curr = curr->tl) {
    prev->tl = new List(sptr,curr);
  }
  return xs;
}
static stringptr_t cfield2stringptr(bool deep, cfield_t f) {
  string_t s =
    aprintf("%s %s: %s",ctype2string(deep,f->qual),*f->f,ctype2string(deep,f->type));
  return new s;
}
static string_t ctypes2string(bool deep, list_t<ctype_t,`H> ts) {
  return strconcat_l(sep(",",map_c(ctype2stringptr,deep,ts)));
}
static string_t cfields2string(bool deep,cfields_t fs) {
  return strconcat_l(sep(";",map_c(cfield2stringptr,deep,fs)));
}

//////////////////////////////////////////////////////////////////
// Constructors for ctypes
static ctype_t notconst_ct() { return &Notconst_ct_val; }
static ctype_t const_ct() { return &Const_ct_val; }
static ctype_t thin_ct() { return &Thin_ct_val; }
static ctype_t fat_ct() { return &Fat_ct_val; }
static ctype_t void_ct() { return &Void_ct_val; }
static ctype_t zero_ct() { return &Zero_ct_val; }
static ctype_t arith_ct() { return &Arith_ct_val; }
static ctype_t heap_ct() { return &Heap_ct_val; }
static ctype_t zterm_ct() { return &Zterm_ct_val; }
static ctype_t nozterm_ct() { return &Nozterm_ct_val; }
static ctype_t rgnvar_ct(tvarname_t n) { return new RgnVar_ct(n); }
static ctype_t unknown_aggr_ct(cfields_t fs) {
  return new UnknownAggr_ct(fs,NULL);
}
static ctype_t known_aggr_ct($(struct Aggrdecl @`H,cfields_t fs)@`H p) {
  return new KnownAggr_ct(p);
}
static ctype_t ptr_ct(ctype_t elt, ctype_t qual, ctype_t ptr_kind, ctype_t r,
                      ctype_t zt) {
  return new Ptr_ct(elt,qual,ptr_kind,r,zt);
}
static ctype_t array_ct(ctype_t elt, ctype_t qual, ctype_t zt) {
  return new Array_ct(elt,qual,zt);
}
static ctype_t fn_ct(ctype_t return_type, list_t<ctype_t,`H> args) {
  return new Fn_ct(return_type,args);
}
static ctype_t var() {
  static int counter = 0;
  return new Var_ct(new Cvar{counter++, NULL, NULL, NULL});
}
static ctype_t new_var(`a x) {
  return var();
}
static tvarname_t new_region_var() {
  static int counter = 0;
  string_t s = aprintf("`R%d",counter++);
  return new s;
}

//////////////////////////////////////////////////////////////////
// compress out levels of indirection
static bool unifies(ctype_t t1, ctype_t t2);

static ctype_t compress_ct(ctype_t t) {
  switch (t) {
  case &Var_ct(&Cvar{_,*eqp,us,ls}):
    let eq = *eqp;
    if (eq) {
      // the variable is constrained to be equal to something else --
      // figure out it's compressed value and do path compression.
      ctype_t r = compress_ct(*eq);
      if (*eq != r) *eqp = new r;
      return r;
    }
    // try to set it equal to a bound -- we can do this when t <= L
    // and L is a lower bound for a given category, or when U <= t
    // and U is an upper bound for a given category.
    for (; ls != NULL; ls = ls->tl) {
      switch (ls->hd) {
      case &Const_ct:
      case &Nozterm_ct:
      case &Void_ct:
      case &KnownAggr_ct(_):
      case &Fn_ct(_,_):
        *eqp = new ls->hd;
        return ls->hd;
      default:
        break;
      }
    }
    for (; us != NULL; us = us->tl) {
      switch (us->hd) {
      case &Notconst_ct:
      case &Zterm_ct:
      case &Zero_ct:
      case &KnownAggr_ct(_):
      case &Fn_ct(_,_):
        *eqp = new us->hd;
        return us->hd;
      default:
        break;
      }
    }
    return t;
  case &UnknownAggr_ct(_,eq):
    // Unknown aggregates compress similarly to variables
    if (eq) return compress_ct(*eq);
    else return t;
  default:
    // no real compression to do
    return t;
  }
}

//////////////////////////////////////////////////////////////////
// Instantiate a type by replacing all RgnVar's with fresh var's
static ctype_t inst(Dict::dict_t<tvarname_t,ctype_t> @instenv, ctype_t t) {
  switch (compress_ct(t)) {
  case &Const_ct:
  case &Notconst_ct:
  case &Thin_ct:
  case &Fat_ct:
  case &Void_ct:
  case &Zero_ct:
  case &Arith_ct:
  case &Zterm_ct:
  case &Nozterm_ct:
  case &UnknownAggr_ct(_,_):
  case &KnownAggr_ct(_):
  case &Var_ct(_):
  case &Heap_ct: return t;
  case &RgnVar_ct(n):
    if (!Dict::member(*instenv,n))
      *instenv = Dict::insert(*instenv,n,var());
    return Dict::lookup(*instenv,n);
  case &Ptr_ct(t1,t2,t3,t4,zt):
    let $(nt1,nt4) = $(inst(instenv,t1),inst(instenv,t4));
    if (nt1 == t1 && nt4 == t4) return t;
    return new Ptr_ct(nt1,t2,t3,nt4,zt);
  case &Array_ct(t1,t2,zt):
    let nt1 = inst(instenv,t1);
    if (nt1 == t1) return t;
    return new Array_ct(nt1,t2,zt);
  case &Fn_ct(t1,ts):
    return new Fn_ct(inst(instenv,t1),List::map_c(inst,instenv,ts));
  }
}

ctype_t instantiate(ctype_t t) {
  return inst(new Dict::empty(strptrcmp), t);
}

// HACK: should really do full cycle detection.
// filters out t from the list of bounds -- used to eliminate
// constraints of the form t <= t.
list_t<ctype_t> filter_self(ctype_t t, list_t<ctype_t,`H> ts) {
  bool found = false;
  for (let xs = ts; xs; xs = xs->tl) {
    let t2 = compress_ct(xs->hd);
    if (t == t2) found = true;
  }
  if (!found) return ts;
  list_t<ctype_t> res = NULL;
  for (; ts != NULL; ts = ts->tl) {
    if (t == compress_ct(ts->hd)) continue;
    res = new List{ts->hd,res};
  }
  return res;
}

// Generalize a type by plugging fresh region variables in for
// each region evar we see
void generalize(bool is_rgn, ctype_t t) {
  t = compress_ct(t);
  switch (t) {
  case &Var_ct(cv):
    // Filter out self
    cv->uppers = filter_self(t,cv->uppers);
    cv->lowers = filter_self(t,cv->lowers);
    if (is_rgn) {
      // if no bounds, we can generalize it by unifying it with a fresh
      // rgnvar.
      if (cv->uppers == NULL && cv->lowers == NULL) {
        unifies(t,rgnvar_ct(new_region_var()));
        return;
      }
      // We have a bound, pick one and unify the variable with it.
      if (cv->uppers) {
        unifies(t,cv->uppers->hd);
        generalize(true,t);
      } else {
        unifies(t,cv->lowers->hd);
        generalize(true,t);
      }
    }
    return;
  case &Const_ct:
  case &Notconst_ct:
  case &Thin_ct:
  case &Fat_ct:
  case &Void_ct:
  case &Zero_ct:
  case &Arith_ct:
  case &UnknownAggr_ct(_,_):
  case &KnownAggr_ct(_):
  case &RgnVar_ct(_):
  case &Nozterm_ct:
  case &Zterm_ct:
  case &Heap_ct: return;
  case &Ptr_ct(t1,t2,t3,t4,t5):
    // NB: no need to descend into other sub-terms since we're
    // looking for region variables.
    generalize(false,t1); generalize(true,t4); break;
  case &Array_ct(t1,t2,t3):
    generalize(false,t1); generalize(false,t2); break;
  case &Fn_ct(t1,ts):
    generalize(false,t1); List::iter_c(generalize,false,ts); break;
  }
}

//////////////////////////////////////////////////////////////////
// occurs check for variables in ctypes
static bool occurs(ctype_t v, ctype_t t) {
  t = compress_ct(t);
  if (t == v) return true;
  switch (t) {
  case &Ptr_ct(t1,t2,t3,t4,t5):
    return occurs(v,t1) || occurs(v,t2) || occurs(v,t3) || occurs(v,t4) ||
      occurs(v,t5);
  case &Array_ct(t1,t2,t3):
    return occurs(v,t1) || occurs(v,t2) || occurs(v,t3);
  case &Fn_ct(t,ts):
    if (occurs(v,t)) return true;
    for (; ts; ts = ts->tl)
      if (occurs(v,ts->hd)) return true;
    return false;
  case &KnownAggr_ct(&$(_,fs)): return false;
  case &UnknownAggr_ct(fs,_):
    for (; fs; fs = fs->tl)
      if (occurs(v,fs->hd->qual) || occurs(v,fs->hd->type)) return true;
    return false;
  default: return false;
  }
}


//////////////////////////////////////////////////////////////////
// Unification of ctypes
// thrown when unification fails
datatype exn { Unify_ct };
datatype exn.Unify_ct Unify_ct_val = Unify_ct;
// prototypes for functions defined later
static bool leq(ctype_t t1, ctype_t t2);
static void unify_cts(list_t<ctype_t> t1, list_t<ctype_t> t2);
static cfields_t merge_fields(cfields_t fs1, cfields_t fs2, bool allow_subset);

static void unify_ct(ctype_t t1, ctype_t t2) {
  t1 = compress_ct(t1);
  t2 = compress_ct(t2);
  if (t1 == t2) return;
  switch ($(t1,t2)) {
  case $(&Var_ct(v1),_):
    if (!occurs(t1,t2)) {
      // we want to set v1 to t2.  Make sure that t2 is leq
      // any uper bound of v1 and geq any lower bound.
      for (let us = filter_self(t1,v1->uppers); us; us = us->tl)
        if (!leq(t2,us->hd)) throw &Unify_ct_val;
      for (let ls = filter_self(t1,v1->lowers); ls; ls = ls->tl)
        if (!leq(ls->hd,t2)) throw &Unify_ct_val;
      v1->eq = new t2;
      return;
    } else throw &Unify_ct_val;
  case $(_, &Var_ct(v1)): unify_ct(t2,t1); return;
  case $(&Ptr_ct(e1,q1,k1,r1,zt1), &Ptr_ct(e2,q2,k2,r2,zt2)):
    unify_ct(e1,e2); unify_ct(q1,q2); unify_ct(k1,k2); unify_ct(r1,r2);
    unify_ct(zt1,zt2);
    return;
  case $(&RgnVar_ct(&n1), &RgnVar_ct(&n2)):
    if (strcmp(n1,n2) != 0) throw &Unify_ct_val;
    return;
  case $(&Array_ct(e1,q1,zt1), &Array_ct(e2,q2,zt2)):
    unify_ct(e1,e2); unify_ct(q1,q2); unify_ct(zt1,zt2); return;
  case $(&Fn_ct(t1,ts1), &Fn_ct(t2,ts2)):
    unify_ct(t1,t2); unify_cts(ts1,ts2); return;
  case $(&KnownAggr_ct(p1), &KnownAggr_ct(p2)):
    if (p1 == p2) return; else throw &Unify_ct_val;
  case $(&UnknownAggr_ct(fs1,*eq1), &UnknownAggr_ct(fs2,*eq2)):
    let t = unknown_aggr_ct(merge_fields(fs1,fs2,true));
    *eq1 = *eq2 = new t;
    return;
  case $(&UnknownAggr_ct(fs1,*eq), &KnownAggr_ct(&$(ad,fs2))):
    merge_fields(fs2,fs1,false);
    *eq = new t2;
    return;
  case $(&KnownAggr_ct(&$(ad,fs2)), &UnknownAggr_ct(fs1,*eq)):
    merge_fields(fs2,fs1,false);
    *eq = new t1;
    return;
  default: throw &Unify_ct_val;
  }
}
// unify a list of types
static void unify_cts(list_t<ctype_t> t1, list_t<ctype_t> t2) {
  for (; t1 != NULL && t2 != NULL; t1 = t1->tl, t2 = t2->tl) {
    unify_ct(t1->hd,t2->hd);
  }
  if (t1 != NULL || t2 != NULL)
    throw &Unify_ct_val;
}
// Merges two sets of fields so that they are point-wise constrained.
// If allow_subset is false, then fs2 must be a subset of the fields in fs1
// Used for merging the types of fields in a aggregates during unification.
static cfields_t merge_fields(cfields_t fs1, cfields_t fs2,
                              bool allow_f1_subset_f2) {
  cfields_t common = NULL;
  for (let xs2 = fs2; xs2; xs2 = xs2->tl) {
    let f2 = xs2->hd;
    bool found = false;
    for (let xs1 = fs1; xs1; xs1 = xs1->tl) {
      let f1 = xs1->hd;
      if (strptrcmp(f1->f,f2->f) == 0) {
        common = new List{f1,common};
        unify_ct(f1->qual,f2->qual);
        unify_ct(f1->type,f2->type);
        found = true;
        break;
      }
    }
    if (!found) {
      if (allow_f1_subset_f2)
        common = new List(f2,common);
      else throw &Unify_ct_val;
    }
  }
  for (let xs1 = fs1; xs1; xs1 = xs1->tl) {
    let f1 = xs1->hd;
    bool found = false;
    for (let xs2 = fs2; xs2; xs2 = xs2->tl) {
      let f2 = xs2->hd;
      if (strptrcmp(f1->f,f2->f)) found = true;
    }
    if (!found)
      common = new List(f1,common);
  }
  return common;
}
// try to unify two types and return true upon success
static bool unifies(ctype_t t1, ctype_t t2) {
  try {
#ifdef PORT_DEBUG
    fprintf(stderr,"Unifying %s and %s\n",ctype2string(true,t1),
            ctype2string(true,t2));
#endif

    unify_ct(t1,t2);
  } catch {
  case &Unify_ct:
#ifdef PORT_DEBUG
    fprintf(stderr,"Unify failure: %s != %s\n",ctype2string(true,t1),
            ctype2string(true,t2));
#endif
    return false;
  }
  return true;
}
//////////////////////////////////////////////////////////////////
// Subtyping of C types

// Insert t into the upper bounds of v.  May end up unifying v with t.
static list_t<ctype_t> insert_upper(ctype_t v, ctype_t t,
                                    list_t<ctype_t,`H> @uppers) {
  t = compress_ct(t);
  switch (t) {
    // If t is a lower bound for a given category, then we might as well
    // set v = t.
  case &Notconst_ct:
  case &Zterm_ct:
  case &Zero_ct:
  case &Thin_ct:
  case &Fat_ct:
  case &Array_ct(_,_,_):
  case &KnownAggr_ct(_):
  case &Fn_ct(_,_):
  case &Heap_ct:
    // must null out v's upper bounds to avoid a potential loop between
    // unification and leq.
    *uppers = NULL;
    unifies(v,t);
    return *uppers;
    // If t is an upper bound for a given category, then we might as well
    // forget the constraint.
  case &Void_ct:
  case &Const_ct:
  case &Nozterm_ct:
    return *uppers;
  default: break;
  }
  // Try to merge t with some other upper bound on v.
  for (let us = *uppers; us; us = us->tl) {
    let t2 = compress_ct(us->hd);
    // if t is already an upper bound, we're done.
    if (t == t2) return *uppers;
    switch ($(t,t2)) {
      // if t is a sub-type of an upper bound, we're done.
      // Note that we've already filtered out a lot of t's that
      // might be subtypes above.
    case $(&Arith_ct,&Ptr_ct(_,_,_,_,_)):
    case $(&Arith_ct,&Zero_ct):
    case $(&Arith_ct,&Array_ct(_,_,_)):
      return *uppers;
    case $(&Ptr_ct(ta,qa,ka,ra,za), &Ptr_ct(tb,qb,kb,rb,zb)):
      // we have v <= ptr(ta,qa,ka,ra,za), ptr(tb,qb,kb,rb,zb)
      // replace with v <= ptr(tc,qc,kc,rc,zc)
      // and     tc <= ta,tb and qc <= qa,qb and kc <= ka,kb etc.
      let $(tc,qc,kc,rc,zc) = $(var(),var(),var(),var(),var());
      let p = new Ptr_ct(tc,qc,kc,rc,zc);
      leq(tc,ta); leq(tc,tb);
      leq(qc,qa); leq(qc,qb);
      leq(kc,ka); leq(kc,qb);
      leq(rc,ra); leq(rc,rb);
      leq(zc,za); leq(zc,zb);
      us->hd = p;
      return *uppers;
    default: break;
    }
  }
  return new List{t,*uppers};
}

// Same as insert_upper but we're inserting t into the list of
// lower bounds for v.
static list_t<ctype_t> insert_lower(ctype_t v, ctype_t t,
                                    list_t<ctype_t,`H> @lowers) {
  t = compress_ct(t);
  switch (t) {
  case &Const_ct:
  case &Zterm_ct:
  case &Thin_ct:
  case &Fat_ct:
  case &Void_ct:
  case &KnownAggr_ct(_):
  case &Fn_ct(_,_):
  case &RgnVar_ct(_):
    *lowers = NULL;
    unifies(v,t);
    return *lowers;
  case &Heap_ct:
  case &Notconst_ct:
  case &Nozterm_ct:
    return *lowers;
  default:
    break;
  }
  for (let ls = *lowers; ls; ls = ls->tl) {
    let t2 = compress_ct(ls->hd);
    if (t == t2) return *lowers;
    switch ($(t,t2)) {
    case $(_,&Void_ct):
    case $(&Zero_ct,&Arith_ct):
    case $(&Zero_ct,&Ptr_ct(_,_,_,_,_)):
    case $(&Ptr_ct(_,_,_,_,_),&Arith_ct):
    case $(&Array_ct(_,_,_),&Arith_ct):
      return *lowers;
    case $(&Ptr_ct(ta,qa,ka,ra,za), &Ptr_ct(tb,qb,kb,rb,zb)):
      // we have ptr(ta,qa,ka), ptr(tb,qb,kb) <= v
      // replace with ptr(tc,qc,kc) <= v
      // and     ta,tb <= tc and qa,qb <= qc and ka,kb <= kc
      let $(tc,qc,kc,rc,zc) = $(var(),var(),var(),var(),var());
      let p = new Ptr_ct(tc,qc,kc,rc,zc);
      leq(ta,tc); leq(tb,tc);
      leq(qa,qc); leq(qb,qc);
      leq(ka,kc); leq(qb,kc);
      leq(ra,rc); leq(rb,rc);
      leq(za,zc); leq(zb,zc);
      ls->hd = p;
      return *lowers;
    default: break;
    }
  }
  return new List{t,*lowers};
}


// Return true if t1 <= t2.  Really, this might fail and still return
// true, since insert_upper and insert_lower don't check for an
// inconsistency.  That's okay here since we don't have to be sound...
static bool leq(ctype_t t1, ctype_t t2) {
#ifdef PORT_DEBUG
    fprintf(stderr,"leq %s and %s\n",ctype2string(true,t1),
            ctype2string(true,t2));
#endif

  if (t1 == t2) return true;
  t1 = compress_ct(t1);
  t2 = compress_ct(t2);
  switch ($(t1,t2)) {
  case $(&Heap_ct,_): return true;
  case $(&RgnVar_ct(&n1), &RgnVar_ct(&n2)): return strcmp(n1,n2) == 0;
  case $(&RgnVar_ct(&n1), &Heap_ct): return false;
  case $(&Notconst_ct,&Const_ct): return true;
  case $(&Const_ct,&Notconst_ct): return false;
  case $(&Nozterm_ct,&Zterm_ct): return false;
  case $(&Zterm_ct,&Nozterm_ct): return true;
  case $(&Var_ct(_),&Const_ct): return true;
  case $(&Var_ct(_), &Void_ct): return true;
  case $(&Void_ct, _): return false;
  case $(&Zero_ct,&Arith_ct): return true;
  case $(&Zero_ct,&Ptr_ct(_,_,_,_,_)): return true;
  case $(&Zero_ct,&Void_ct): return true;
  case $(&Ptr_ct(_,_,_,_,_),&Arith_ct): return true;
  case $(&Ptr_ct(_,_,_,_,_),&Void_ct): return true;
  case $(&Array_ct(_,_,_),&Arith_ct): return true;
  case $(&Array_ct(_,_,_),&Void_ct): return true;
  case $(&Ptr_ct(t1,q1,k1,r1,z1), &Ptr_ct(t2,q2,k2,r2,z2)):
    return leq(t1,t2) && leq(q1,q2) && unifies(k1,k2) && leq(r1,r2) &&
      leq(z1,z2);
  case $(&Array_ct(t1,q1,z1),&Array_ct(t2,q2,z2)):
    return leq(t1,t2) && leq(q1,q2) && leq(z1,z2);
  case $(&Array_ct(t1,q1,z1),&Ptr_ct(t2,q2,k2,_,z2)):
    return leq(t1,t2) && leq(q1,q2) && unifies(&Fat_ct_val,k2) &&
      leq(z1,z2);
  case $(&Var_ct(v1),&Var_ct(v2)):
    v1->uppers = filter_self(t1,v1->uppers);
    v2->lowers = filter_self(t2,v2->lowers);
    v1->uppers = insert_upper(t1,t2,&v1->uppers);
    v2->lowers = insert_lower(t2,t1,&v2->lowers);
    return true;
  case $(&Var_ct(v1), _):
    v1->uppers = filter_self(t1,v1->uppers);
    v1->uppers = insert_upper(t1,t2,&v1->uppers);
    return true;
  case $(_, &Var_ct(v2)):
    v2->lowers = filter_self(t2,v2->lowers);
    v2->lowers = insert_lower(t2,t1,&v2->lowers);
    return true;
  default: return unifies(t1,t2);
  }
}

//////////////////////////////////////////////////////////////////
// Porting Environment
typedef struct GlobalCenv {
  // Typedefs
  Dict::dict_t<typedef_name_t, $(type_t,ctype_t)@> typedef_dict;
  // Structs
  Dict::dict_t<typedef_name_t, $(struct Aggrdecl @,cfields_t)@> struct_dict;
  // Unions
  Dict::dict_t<typedef_name_t, $(struct Aggrdecl @,cfields_t)@> union_dict;
  // Return type for a function
  ctype_t return_type;
  // These edits record (a) the ctype variable that is inserted during
  // constraint satisfaction, (b) the ctype that reflects what was
  // originally in the code, (c) the location where the ctype occurred
  // in the original code.  If, after constraint solving, (a) and (b)
  // do not unify, we emit an Edit.
  list_t<$(ctype_t,ctype_t,seg_t)@>  qualifier_edits;
  list_t<$(ctype_t,ctype_t,seg_t)@>  pointer_edits;
  list_t<$(ctype_t,ctype_t,seg_t)@>  zeroterm_edits;
  list_t<$(qvar_t, seg_t,type_t)@> vardecl_locs;
  Hashtable::table_t<seg_t, varusage_t> varusage_tab;
  // These edits are inserted directly (e.g., for regions as we process
  // a function.)
  list_t<edit_t> edits;
  bool porting; // true when we are processing unported C code, false otherwise
} @gcenv_t;

enum CPos { FnRes_pos, FnArg_pos, FnBody_pos, Toplevel_pos };
typedef enum CPos cpos_t;

typedef struct Cenv {
  // Global environment
  gcenv_t gcenv;
  // Local variables -- we need the original type so we can do promotion
  // for arrays and functions.
  Dict::dict_t<qvar_t, $(type_t,$(ctype_t,ctype_t)@,seg_t)@> var_dict;
  // Used in the type translation
  cpos_t cpos;
}@ cenv_t;

static cenv_t empty_cenv() {
  gcenv_t g = new GlobalCenv { .typedef_dict = Dict::empty(qvar_cmp),
                               .struct_dict = Dict::empty(qvar_cmp),
                               .union_dict = Dict::empty(qvar_cmp),
                               .qualifier_edits = NULL,
                               .pointer_edits = NULL,
                               .zeroterm_edits = NULL,
			       .vardecl_locs = NULL,
			       .varusage_tab = Hashtable::create(128,cmp_seg_t,hash_seg_t),
                               .edits = NULL,
                               .porting = false,
                               .return_type = void_ct() };
  return new Cenv {.gcenv = g,
                   .cpos = Toplevel_pos,
                   .var_dict = Dict::empty(qvar_cmp) };
}

// Environment Lookup
// These functions are coded so they don't fail but return some
// bogus answer when we can't find something.
static bool in_fn_arg(cenv_t env) {
  return env->cpos == FnArg_pos;
}
static bool in_fn_res(cenv_t env) {
  return env->cpos == FnRes_pos;
}
static bool in_toplevel(cenv_t env) {
  return env->cpos == Toplevel_pos;
}
static ctype_t lookup_return_type(cenv_t env) {
  return env->gcenv->return_type;
}
static type_t lookup_typedef(cenv_t env, typedef_name_t n) {
  try {
    let $(t,_) = *Dict::lookup(env->gcenv->typedef_dict,n);
    return t;
  } catch {
  case &Dict::Absent:
#ifdef PORT_DEBUG
    fprintf(stderr,"can't find typedef %s\n",qvar2string(n));
#endif
    return sint_type;
  }
}

// Get the ctype that corresponds to a typedef
static ctype_t lookup_typedef_ctype(cenv_t env, typedef_name_t n) {
  try {
    let $(_,ct) = *Dict::lookup(env->gcenv->typedef_dict,n);
    return ct;
  } catch {
  case &Dict::Absent:
#ifdef PORT_DEBUG
    fprintf(stderr,"can't find typedef %s\n",qvar2string(n));
#endif
    return var();
  }
}

// Get the aggrdecl and cfields for a struct -- if the struct
// has not been defined, then defines it (with empty fields).
static $(struct Aggrdecl @,cfields_t)@ lookup_struct_decl(cenv_t env,
                                                          typedef_name_t n){
  let popt = Dict::lookup_opt(env->gcenv->struct_dict,n);
  if (popt)
    return *popt;
  else {
    let ad = new Aggrdecl{.kind = StructA, .sc = Public, .name = n,
                          .tvs = NULL, .impl = NULL, .attributes = NULL,
                          .expected_mem_kind = false};
    $(struct Aggrdecl @,cfields_t)@ p = new $(ad,NULL);
    env->gcenv->struct_dict = Dict::insert(env->gcenv->struct_dict, n, p);
    return p;
  }
}

// Get the aggrdecl and cfields for a union -- if the union
// has not been defined, then defines it (with empty fields).
static $(struct Aggrdecl @,cfields_t)@ lookup_union_decl(cenv_t env,
                                                        typedef_name_t n) {
  let popt = Dict::lookup_opt(env->gcenv->union_dict,n);
  if (popt)
    return *popt;
  else {
    let ad = new Aggrdecl{.kind = UnionA, .sc = Public, .name = n,
                          .tvs = NULL, .impl = NULL, .attributes = NULL,
                          .expected_mem_kind = false};
    $(struct Aggrdecl @,cfields_t)@ p = new $(ad,NULL);
    env->gcenv->union_dict = Dict::insert(env->gcenv->union_dict, n, p);
    return p;
  }
}

// Look up a variable and return it's qualifier and ctype respectively
static $($(ctype_t, ctype_t),seg_t) lookup_var(cenv_t env, qvar_t x) {
  try {
    let $(_,p,loc) = *Dict::lookup(env->var_dict,x);
    return $(*p,loc);
  } catch {
  case &Dict::Absent:
#ifdef PORT_DEBUG
    fprintf(stderr,"can't find variable %s\n",qvar2string(x));
#endif
    return $($(var(),var()),0);
  }
}
static $(type_t, $(ctype_t,ctype_t)@,seg_t)@ lookup_full_var(cenv_t env, qvar_t x) {
  return Dict::lookup(env->var_dict,x);
}
// True when x has been declared, False otherwise
static bool declared_var(cenv_t env, qvar_t x) {
  return Dict::member(env->var_dict,x);
}
// True when x was declared as a function
static bool isfn(cenv_t env, qvar_t x) {
  try {
    let $(t,_,_) = *Dict::lookup(env->var_dict,x);
  LOOP: switch (t) {
  case &TypedefType(n,_,_,_): t = lookup_typedef(env,n); goto LOOP;
  case &FnType(_): return true;
  default: return false;
  }
  } catch {
  case &Dict::Absent:
#ifdef PORT_DEBUG
    fprintf(stderr,"can't find variable %s\n",qvar2string(x));
#endif
    return false;
  }
}
// True when x was declared as an array
static bool isarray(cenv_t env, qvar_t x) {
  try {
    let $(t,_,_) = *Dict::lookup(env->var_dict,x);
  LOOP: switch (t) {
  case &TypedefType(n,_,_,_): t = lookup_typedef(env,n); goto LOOP;
  case &ArrayType(_): return true;
  default: return false;
  }
  } catch {
  case &Dict::Absent:
#ifdef PORT_DEBUG
    fprintf(stderr,"can't find variable %s\n",qvar2string(x));
#endif
    return false;
  }
}

// Environment Addition and Changes

static cenv_t set_cpos(cenv_t env, cpos_t cpos) {
  return new Cenv(env->gcenv, env->var_dict, cpos);
}

// Set the return type for the current function
static void add_return_type(cenv_t env, ctype_t t) {
  env->gcenv->return_type = t;
}
// Add a variable to the environment, giving it's original parsed type,
// and its qualifier and ctype.
static cenv_t add_var(cenv_t env, qvar_t x, type_t t, ctype_t qual,
                      ctype_t ctype, seg_t loc) {
  return new Cenv{env->gcenv,
                  Dict::insert(env->var_dict,x,new $(t,new $(qual,ctype),loc)),
                  env->cpos};
}
// Add a typedef to the enviornment, giving the original parsed type and
// its ctype.
static void add_typedef(cenv_t env, typedef_name_t n, type_t t, ctype_t ct) {
  env->gcenv->typedef_dict = Dict::insert(env->gcenv->typedef_dict,
                                          n, new $(t,ct));
}
static void register_localvar_decl(cenv_t env, qvar_t x, seg_t loc, type_t type, exp_opt_t init){
  env->gcenv->vardecl_locs = new List (new $(x,loc,type), env->gcenv->vardecl_locs);
  Hashtable::insert(env->gcenv->varusage_tab, loc, new VarUsage{false, init, NULL});
}
static void register_localvar_usage(cenv_t env, seg_t declloc, seg_t useloc, bool takeaddress){
  varusage_t varusage = NULL;
  if( Hashtable::try_lookup(env->gcenv->varusage_tab, declloc, &varusage)){
    if (takeaddress) varusage->address_taken = true;
    let l = varusage->usage_locs;
    varusage->usage_locs = new List(useloc, l);
  }
}
// Register a ctype that is serving as a qualifier which might
// later change.  In particular, after constraint generation and
// simplification, if new_qual != orig_qual, we emit an edit.
static void register_const_cvar(cenv_t env, ctype_t new_qual,
                                ctype_t orig_qual, seg_t loc) {
  env->gcenv->qualifier_edits = new List(new $(new_qual,orig_qual,loc),
                                         env->gcenv->qualifier_edits);
}
// Register a ctype that is serving as a pointer kind (* or ?)
// In particular, after constraint generation and simplification,
// if new_ptr != orig_ptr, we emit an edit.
static void register_ptr_cvars(cenv_t env, ctype_t new_ptr,
                               ctype_t orig_ptr, seg_t loc) {
  env->gcenv->pointer_edits = new List(new $(new_ptr,orig_ptr,loc),
                                       env->gcenv->pointer_edits);
}

static void register_zeroterm_cvars(cenv_t env, ctype_t new_zt,
                                    ctype_t orig_zt, seg_t loc) {
  env->gcenv->zeroterm_edits = new List(new $(new_zt,orig_zt,loc),
                                        env->gcenv->zeroterm_edits);
}

// Create a "good" type for main:  int main(int, char??) which will
// end up constraining the C code.
static type_t main_type() {
  $(var_opt_t,tqual_t,type_t)@ arg1 =
    new $(NULL,empty_tqual(0),sint_type);
  $(var_opt_t,tqual_t,type_t)@ arg2 =
    new $(NULL,empty_tqual(0),
          fatptr_type(string_type(wildtyp(NULL)),wildtyp(NULL),
                      empty_tqual(0), any_bool(NULL)));
  return new FnType(FnInfo{.tvars=NULL, .effect=NULL,
                              .ret_tqual = empty_tqual(0),
                              .ret_type = sint_type,
                              .args = list(arg1,arg2), .c_varargs = false,
                              .cyc_varargs = NULL, .rgn_po = NULL,
                              .attributes = NULL, .requires_clause = NULL,
                              .requires_relns = NULL,
                              .ensures_clause = NULL,
                              .ensures_relns = NULL,.return_value = NULL});

}

static ctype_t type_to_ctype(cenv_t env, type_t t);

// set up initial environment
static cenv_t initial_cenv() {
  let e = empty_cenv();
  // enter main so that we trick it into having the right type
  e = add_var(e, new $(Loc_n,new "main"), main_type(), const_ct(),
              type_to_ctype(e, main_type()),0);
  return e;
}

// Record how many times each region variable occurs in a type --
// used to determine whether we need to spit out an explicit region
// name (i.e., when a region var occurs more than once.)
static void region_counts(Dict::dict_t<tvarname_t,int@> @cts, ctype_t t) {
  switch (compress_ct(t)) {
  case &Const_ct:
  case &Notconst_ct:
  case &Thin_ct:
  case &Fat_ct:
  case &Void_ct:
  case &Zero_ct:
  case &Arith_ct:
  case &UnknownAggr_ct(_,_):
  case &KnownAggr_ct(_):
  case &Var_ct(_):
  case &Zterm_ct:
  case &Nozterm_ct:
  case &Heap_ct: return;
  case &RgnVar_ct(n):
    if (!Dict::member(*cts,n))
      *cts = Dict::insert(*cts,n,new 0);
    let p = Dict::lookup(*cts,n);
    *p = *p + 1;
    return;
  case &Ptr_ct(t1,t2,t3,t4,zt):
    region_counts(cts,t1);
    region_counts(cts,t4);
    return;
  case &Array_ct(t1,t2,zt):
    region_counts(cts,t1);
    return;
  case &Fn_ct(t1,ts):
    region_counts(cts,t1);
    for (; ts; ts = ts->tl) region_counts(cts,ts->hd);
    return;
  }
}

// Match the original type against the ctype, looking for pointer regions.
// If the original type has an evar, where the ctype has a region var
// that is used multiple times, then record the mismatch as an edit.
// Or, if the original type has an evar where the ctype is the heap region,
// and we're in a function argument position, then record the mismatch.
static void register_rgns(cenv_t env, Dict::dict_t<tvarname_t,int@> counts,
                          bool fn_res, type_t t, ctype_t c) {
  c = compress_ct(c);
  switch ($(t, c)) {
  case $(&PointerType(PtrInfo{et,_,PtrAtts{rt,_,_,_,ploc}}),&Ptr_ct(ec,_,_,rc,_)):
    register_rgns(env, counts, fn_res, et, ec);
    let loc = ploc ? ploc->rgn_loc : 0;
    rc = compress_ct(rc);

//     switch ($(rt,rc)) {
//     case $(&Evar(_,_,_,_), &Heap_ct) && !fn_res:
//       env->gcenv->edits =
//         new List(new Edit{loc,"`H ",""}, env->gcenv->edits);
//       break;
//     case $(&Evar(_,_,_,_), &RgnVar_ct(n)):
//       let i = *Dict::lookup(counts,n);
//       if (i > 1)
//         env->gcenv->edits =
//           new List(new Edit{loc,aprintf("%s ",*n),""}, env->gcenv->edits);
//       break;
//     default: break;
//     }
    env->gcenv->edits =
      new List(new Edit{loc, "`H ", ""}, env->gcenv->edits);
    
    break;
  case $(&ArrayType(ArrayInfo{et,_,_,_,_}), &Array_ct(ec,_,_)):
    register_rgns(env, counts, fn_res, et, ec);
    break;
  case $(&FnType(FnInfo{_,_,_,rt,argst,_,_,_,_,_,_,_,_,_}), &Fn_ct(rc,argsc)):
    register_rgns(env, counts, true, rt, rc);
    for (; argst != NULL && argsc != NULL; argst=argst->tl, argsc=argsc->tl) {
      let $(_,_,at) = *argst->hd;
      let ac = argsc->hd;
      register_rgns(env, counts, false, at, ac);
    }
    break;
  default: break;
  }
}

//////////////////////////////////////////////////////////////////
// Generation of constraints by walking AST
static ctype_t gen_exp(bool takeaddress, cenv_t env, exp_t e);
static void gen_stmt(cenv_t env, stmt_t s);
static cenv_t gen_localdecl(cenv_t env, decl_t d,bool takeaddress);

// true when t is char
static bool is_char(cenv_t env, type_t t) {
  switch (t) {
  case &TypedefType(n,_,_,_):
    (*n)[0] = Loc_n;
    return is_char(env,lookup_typedef(env,n));
  case &AppType(&IntCon(_,Char_sz),_): return true;
  default: return false;
  }
}

// Convert a type to a ctype -- many shortcuts here
static ctype_t type_to_ctype(cenv_t env, type_t t) {
  switch (t) {
  case &TypedefType(n,_,_,_):
    (*n)[0] = Loc_n;
    return lookup_typedef_ctype(env,n);
  case &AppType(&VoidCon,_): return void_ct();
  case &PointerType(PtrInfo{et,tq,PtrAtts{r,n,b,zt,loc}}):
    let ptr_loc = loc ? loc->ptr_loc : 0;
    let rgn_loc = loc ? loc->rgn_loc : 0;
    let zt_loc = loc ? loc->zt_loc : 0;
    // What we do here is insert soft constraints that correspond to
    // what the user wrote down -- these soft constraints might change
    // in which case we have to change the user's annotations.
    let cet = type_to_ctype(env,et);
    ctype_t new_rgn;
    // Translate the region
    switch (r) {
    case &AppType(&HeapCon,_):
      new_rgn = heap_ct(); break;
    case &VarType(&Tvar{name,_,_}):
      new_rgn = rgnvar_ct(name); break;
    case &Evar(_,_,_,_):
      // fn arguments are in their own unique region if not otherwise
      // specified.
      if (in_fn_arg(env))
        new_rgn = rgnvar_ct(new_region_var());
      // fn results and type definitions use the heap as the default rgn
      else if (in_fn_res(env) || in_toplevel(env))
        new_rgn = heap_ct();
      else new_rgn = var();
      break;
    default:
      new_rgn = heap_ct(); break;
    }
    let orig_fat = (get_bounds_exp(fat_bound_type,b) == NULL);
    bool orig_zt;
    switch (compress(zt)) {
    case &Evar(...): orig_zt = is_char(env,et); break;
    default: orig_zt = force_type2bool(false,zt); break;
    }
    if (env->gcenv->porting) {
      let cqv = var();
      // Register the constraint variable that is used for the qualifier
      // along with the original qualifier constraint.  If a mismatch shows
      // up later, then we'll emit an edit to get the qualifier right.
      register_const_cvar(env,cqv,tq.print_const ? const_ct() : notconst_ct(),
                          tq.loc);
      // Trust the user if they make a pointer const
      if (tq.print_const) unify_ct(cqv,const_ct());
#ifdef PORT_DEBUG
      if (tq.loc == NULL)
        fprintf(stderr,"hmmm...qualifier has bad loc for type %s\n",
                typ2string(t));
#endif
      let cbv = var();
      // Register cbv and cnv as the variables that control what kind of
      // pointer this should be, using the location of the pointer.
      register_ptr_cvars(env, cbv, orig_fat ? fat_ct() : thin_ct(), ptr_loc);
      // Trust the user if they make a pointer fat
      if (orig_fat) unify_ct(cbv,fat_ct());
      let czv = var();
      // Register the zeroterm constraint variable and the original
      // zeroterm constraint.
      register_zeroterm_cvars(env, czv, orig_zt ? zterm_ct() : nozterm_ct(), zt_loc);
      // Trust the user if they explicitly wrote ZEROTERM or NOZEROTERM
      switch (compress(zt)) {
      case &Evar(...): break;
      default: 
        unify_ct(czv, force_type2bool(false,zt) ? zterm_ct() : nozterm_ct());
        break;
      }
      // Note that the type returned has unconstrained variables for
      // the qualifier, bounds, rgn, and zeroterm unless the user
      // explicitly wrote something down.
      return ptr_ct(cet,cqv,cbv,new_rgn,czv);
    } else {
      // If we're not porting (i.e., processing Cyclone prototypes)
      // then trust what the user wrote down.
      return ptr_ct(cet,tq.print_const ? const_ct() : notconst_ct(),
                    orig_fat ? fat_ct() : thin_ct(), new_rgn,
                    orig_zt ? zterm_ct() : nozterm_ct());
    }
  case &AppType(&IntCon(_,_),_):
  case &AppType(&FloatCon(_),_): return arith_ct();
  case &ArrayType(ArrayInfo{et,tq,_,zt,ztloc}):
    // Similar to the pointer case.
    let cet = type_to_ctype(env,et);
    bool orig_zt;
    switch (compress(zt)) {
    case &Evar(...): orig_zt = false; break;
    default: orig_zt = force_type2bool(false,zt); break;
    }
    if (env->gcenv->porting) {
      let cqv = var();
      register_const_cvar(env,cqv,tq.print_const ? const_ct() : notconst_ct(),
                          tq.loc);
#ifdef PORT_DEBUG
      if (tq.loc == NULL)
        fprintf(stderr,"uhm, array type %s qualifier missing location...\n",
                typ2string(t));
#endif
      let czv = var();
      register_zeroterm_cvars(env, czv, orig_zt ? zterm_ct() : nozterm_ct(), ztloc);
      // Trust the user if they explicitly wrote ZEROTERM or NOZEROTERM
      switch (compress(zt)) {
      case &Evar(...): break;
      default:
        unify_ct(czv, force_type2bool(false,zt) ? zterm_ct() : nozterm_ct());
        break;
      }
      return array_ct(cet,cqv,czv);
    } else {
      return array_ct(cet,tq.print_const ? const_ct() : notconst_ct(),
                      orig_zt ? zterm_ct() : nozterm_ct());
    }
  case &FnType(FnInfo{_,_,_,rt,args,_,_,_,_,_,_,_,_,_}):
    let crt = type_to_ctype(set_cpos(env,FnRes_pos),rt);
    let env_arg = set_cpos(env,FnArg_pos);
    list_t<ctype_t> cargs = NULL;
    for (; args != NULL; args = args->tl) {
      let $(_,tq,t) = *args->hd; // FIX: what about qualifiers?
      cargs = new List{type_to_ctype(env_arg,t),cargs};
    }
    return fn_ct(crt,List::imp_rev(cargs));
  case &AppType(&AggrCon(ai),_):
    switch (ai) {
    case {.UnknownAggr = $(StructA,n,_)}:
      (*n)[0] = Loc_n;
      let p = lookup_struct_decl(env,n);
      return known_aggr_ct(p);
    case {.UnknownAggr = $(_,n,_)}:
      (*n)[0] = Loc_n;
      let p = lookup_union_decl(env,n);
      return known_aggr_ct(p);
    case {.KnownAggr = adp}:
      let ad = *adp;
      switch (ad->kind) {
      case StructA:
        let p = lookup_struct_decl(env,ad->name);
        return known_aggr_ct(p);
      default:
        let p = lookup_union_decl(env,ad->name);
        return known_aggr_ct(p);
      }
    }
  case &AppType(&EnumCon(_,_),_): return arith_ct();
  case &AppType(&AnonEnumCon(fs),_):
    // add in an enum declaration
    for (; fs; fs = fs->tl) {
      (*fs->hd->name)[0] = Loc_n;
      env = add_var(env, fs->hd->name, sint_type, const_ct(), arith_ct(),0);
    }
    return arith_ct();
  default: return arith_ct();
  }
}

// Calculate the ctype for a primop given the ctypes of the arguments
static ctype_t gen_primop(cenv_t env, primop_t p, list_t<ctype_t> args) {
  let arg1 = compress_ct(args->hd);
  let arg2s = args->tl;
  switch (p) {
  case Plus:
    // we could have arith + arith -> arith
    //            or arith + fatptr -> fatptr
    //            or fatptr + arith -> fatptr
    let arg2 = compress_ct(arg2s->hd);
    if (leq(arg1,ptr_ct(var(),var(),fat_ct(),var(),var()))) {
      leq(arg2,arith_ct());
      return arg1;
    } else if (leq(arg2,ptr_ct(var(),var(),fat_ct(),var(),var()))) {
      leq(arg1,arith_ct());
      return arg2;
    } else {
      leq(arg1,arith_ct());
      leq(arg2,arith_ct());
      return arith_ct();
    }
  case Minus:
    // we could have arith -> arith
    //            or  arith - arith -> arith
    //            or fatptr - fatptr -> arith
    //            or fatptr - arith -> fatptr
    if (arg2s == NULL) {
      // unary Minus
      leq(arg1,arith_ct());
      return arith_ct();
    } else {
      let arg2 = compress_ct(arg2s->hd);
      if (leq(arg1,ptr_ct(var(),var(),fat_ct(),var(),var()))) {
        if (leq(arg2,ptr_ct(var(),var(),fat_ct(),var(),var())))
          return arith_ct();
        else {
          leq(arg2,arith_ct());
          return arg1;
        }
      } else {
        leq(arg1,arith_ct());
        leq(arg1,arith_ct());
        return arith_ct();
      }
    }
  case Times: case Div: case Mod: case Eq: case Neq: case Lt: case Gt:
  case Lte: case Gte: case Bitand: case Bitor: case Bitxor: case Bitlshift:
  case Bitlrshift:
    leq(arg1,arith_ct());
    leq(arg2s->hd,arith_ct());
    return arith_ct();
  case Not:
  case Bitnot:
    leq(arg1,arith_ct());
    return arith_ct();
  default: impos("Port: unknown primop");
  }
}

// generate constraints for a LHS expression and return the qualifier & type
static $(ctype_t qual,ctype_t type) gen_lhs(cenv_t env, exp_t e, bool takeaddress) {
  switch (e->r) {
  case &Var_e(b):
    let x = binding2qvar(b);
    (*x)[0] = Loc_n;
    let $(p,loc)= lookup_var(env,x);
    register_localvar_usage(env,loc,e->loc,takeaddress);
    return p;
  case &Subscript_e(e1,e2):
    let v = var();
    let q = var();
    let t1 = gen_exp(false,env, e1);
    leq(gen_exp(false,env,e2),arith_ct());
    let p = ptr_ct(v,q,fat_ct(),var(),var());
    leq(t1,p);
    return $(q,v);
  case &Deref_e(e1):
    let v = var();
    let q = var();
    let p = ptr_ct(v,q,var(),var(),var());
    leq(gen_exp(false,env,e1),p);
    return $(q,v);
  case &AggrMember_e(e1,f,...):
    let v = var();
    let q = var();
    let t1 = gen_exp(takeaddress,env, e1);
    leq(t1,unknown_aggr_ct(list(new Cfield(q,f,v))));
    return $(q,v);
  case &AggrArrow_e(e1,f,...):
    let v = var();
    let q = var();
    let t1 = gen_exp(false,env, e1);
    leq(t1,ptr_ct(unknown_aggr_ct(list(new Cfield(q,f,v))),
                               var(),var(),var(),var()));
    return $(q,v);
  default: impos(aprintf("gen_lhs: %s",exp2string(e)));
  }
}

// generate constraints for a RHS expression and return the constraint type
static ctype_t gen_exp_false(cenv_t env, exp_t e) {
  return gen_exp(false, env, e);
}
static ctype_t gen_exp(bool takeaddress,cenv_t env, exp_t e) {
  switch (e->r) {
  case &Const_e({.Char_c = $(_,_)}):
  case &Const_e({.Wchar_c = _}):
  case &Const_e({.Short_c = $(_,_)}):
  case &Const_e({.LongLong_c = $(_,_)}):
  case &Sizeoftype_e(_):
  case &Sizeofexp_e(_):
  case &Offsetof_e(_,_):
  case &Enum_e(...):
  case &AnonEnum_e(...):
  case &Const_e({.Float_c = _}):  return arith_ct();
  case &Const_e({.Int_c = $(_,0)}): return zero_ct();
  case &Const_e({.Int_c = $(_,_)}): return arith_ct();
  case &Const_e({.String_c = _}):
    return ptr_ct(arith_ct(),const_ct(),fat_ct(),heap_ct(),zterm_ct());
  case &Const_e({.Wstring_c = _}):
    return ptr_ct(arith_ct(),const_ct(),fat_ct(),heap_ct(),zterm_ct());
  case &Const_e({.Null_c = _}):  return zero_ct();
  case &Var_e(b):       
    let x = binding2qvar(b);
    (*x)[0] = Loc_n;
    let $(p,loc) = lookup_var(env,x);
    let $(_,t) = p;
    if (isfn(env,x)) {
      t = instantiate(t); // generate fresh region vars
      return ptr_ct(t,var(),var(),heap_ct(),nozterm_ct()); // promote to fn pointer
    }
    else if (isarray(env,x)) { // must promote from array to pointer type
      let elt_type = var();
      let qual = var();
      let zt = var();
      let array_type = array_ct(elt_type,qual,zt);
      unifies(t,array_type);
      let ptr_type = ptr_ct(elt_type,qual,fat_ct(),var(),zt);
      return ptr_type;
    } else {
      register_localvar_usage(env, loc, e->loc,takeaddress);
      return t;
    }
  case &Primop_e(p,es): return gen_primop(env,p,map_c(gen_exp_false,env,es));
  case &AssignOp_e(e1,popt,e2):
    let $(q,t1) = gen_lhs(env,e1,false);
    unifies(q,notconst_ct());
    let t2 = gen_exp(false,env,e2);
    if (popt) {
      struct List<ctype_t> x2 = List{t2,NULL};
      struct List<ctype_t> x1 = List{t1,&x2};
      let t3 = gen_primop(env,popt->v,&x1);
      leq(t3,t1);
      return t1;
    } else {
      leq(t2,t1);
      return t1;
    }
  case &Increment_e(e1,inc):
    let $(q,t) = gen_lhs(env,e1,false);
    unifies(q,notconst_ct());
    // could have a fatptr or an arith
    leq(t,ptr_ct(var(),var(),fat_ct(),var(),var()));
    leq(t,arith_ct());
    return t;
  case &Conditional_e(e1,e2,e3):
    let v = var();
    leq(gen_exp(false,env,e1),arith_ct());
    leq(gen_exp(false,env,e2),v);
    leq(gen_exp(false,env,e3),v);
    return v;
  case &And_e(e1,e2): fallthru(e1,e2);
  case &Or_e(e1,e2):
    leq(gen_exp(false,env,e1),arith_ct());
    leq(gen_exp(false,env,e2),arith_ct());
    return arith_ct();
  case &SeqExp_e(e1,e2):
    gen_exp(false,env,e1);
    return gen_exp(false,env,e2);
  case &FnCall_e(e1,es,...):
    let v = var();
    let t1 = gen_exp(false,env,e1);
    let ts = map_c(gen_exp_false,env,es);
    let vs = map(new_var,ts);
    unifies(t1,ptr_ct(fn_ct(v,vs),var(),var(),var(),nozterm_ct()));
    for (; ts != NULL; ts = ts->tl, vs = vs->tl) {
      leq(ts->hd,vs->hd);
    }
    return v;
  case &Assert_e(...): impos("@assert");
  case &Throw_e(...): impos("throw");
  case &Extension_e(e1): return gen_exp(false,env,e1);
  case &NoInstantiate_e(e1): return gen_exp(false,env,e1);
  case &Instantiate_e(_,_): impos("instantiate");
  case &Cast_e(t,e1,_,_):
    let t1 = type_to_ctype(env,t);
    let t2 = gen_exp(false,env,e1);
    leq(t1,t2);
    return t2;
  case &Address_e(e1):
    let $(q,t) = gen_lhs(env,e1,true);
    return ptr_ct(t,q,var(),var(),var());
  case &Subscript_e(e1,e2):
    let v = var();
    leq(gen_exp(false,env,e2),arith_ct());
    let t = gen_exp(false,env,e1);
    leq(t,ptr_ct(v,var(),fat_ct(),var(),var()));
    return v;
  case &Deref_e(e1):
    let v = var();
    leq(gen_exp(false,env,e1),ptr_ct(v,var(),var(),var(),var()));
    return v;
  case &AggrMember_e(e1,f,...):
    let v = var();
    let t = gen_exp(takeaddress,env,e1);
    leq(t, unknown_aggr_ct(list(new Cfield{var(),f,v})));
    return v;
  case &AggrArrow_e(e1,f,...):
    let v = var();
    let t = gen_exp(false,env,e1);
    leq(gen_exp(false,env,e1),ptr_ct(unknown_aggr_ct(list(new Cfield{var(),f,v})),
                               var(),var(),var(),var()));
    return v;
  case &Malloc_e(MallocInfo{_,_,topt,e1,_,_}):
    leq(gen_exp(false,env,e1),arith_ct());
    let t = (topt) ? type_to_ctype(env,*topt) : var();
    return ptr_ct(t,var(),fat_ct(),heap_ct(),var());
  case &Pragma_e(_): impos("Pragma_e");
  case &Swap_e(e1,e2): impos("Swap_e");
  case &New_e(_,_): impos("New_e");
  case &Tuple_e(_): impos("Tuple_e");
  case &CompoundLit_e(_,_): impos("CompoundLit_e");
  case &Array_e(_): impos("Array_e");
  case &Comprehension_e(_,_,_,_): impos("Comprehension_e");
  case &ComprehensionNoinit_e(...): impos("ComprehensionNoinit_e");
  case &Aggregate_e(_,_,_,_): impos("Aggregate_e");
  case &AnonStruct_e(_,_): impos("AnonStruct_e");
  case &Datatype_e(_,_,_): impos("Datatype_e");
  case &UnresolvedMem_e(_,_): impos("UnresolvedMem_e");
  case &StmtExp_e(s): impos("StmtExp_e");
  case &Valueof_e(_): impos("Valueof_e");
  case &Asm_e(...): impos("Asm_e");
  case &Tagcheck_e(...): impos("Tagcheck_e");
  }
}

// generate constraints for a statement
static void gen_stmt(cenv_t env, stmt_t s) {
  switch (s->r) {
  case &Skip_s: return;
  case &Exp_s(e): gen_exp(false,env,e); return;
  case &Seq_s(s1,s2): gen_stmt(env,s1); gen_stmt(env,s2); return;
  case &Return_s(eopt):
    let v = lookup_return_type(env);
    let t = eopt ? gen_exp(false,env,eopt) : void_ct();
    leq(t,v);
    return;
  case &IfThenElse_s(e,s1,s2):
    leq(gen_exp(false,env,e),arith_ct());
    gen_stmt(env,s1);
    gen_stmt(env,s2);
    return;
  case &While_s($(e,_),s):
    leq(gen_exp(false,env,e),arith_ct());
    gen_stmt(env,s);
    return;
  case &Break_s:
  case &Continue_s:
  case &Goto_s(_): return;
  case &For_s(e1,$(e2,_),$(e3,_),s):
    gen_exp(false,env,e1);
    leq(gen_exp(false,env,e2),arith_ct());
    gen_exp(false,env,e3);
    gen_stmt(env,s);
    return;
  case &Switch_s(e,scs,_):
    leq(gen_exp(false,env,e),arith_ct());
    for (; scs; scs = scs->tl) {
      // ignore the patterns...
      gen_stmt(env,scs->hd->body);
    }
    return;
  case &Fallthru_s(_,_): impos("fallthru");
  case &Decl_s(d,s): 
    env = gen_localdecl(env,d,false); gen_stmt(env,s); return;
  case &Label_s(_,s): gen_stmt(env,s); return;
  case &Do_s(s,$(e,_)):
    gen_stmt(env,s);
    leq(gen_exp(false,env,e),arith_ct());
    return;
  case &TryCatch_s(...): impos("try/catch");
  }
}

// generate constraints for an initializer, given the parsed type
static ctype_t gen_initializer(cenv_t env, type_t t, exp_t e) {
  switch (e->r) {
  case &UnresolvedMem_e(_,dles): fallthru(dles);
  case &Array_e(dles): fallthru(dles);
  case &CompoundLit_e(_,dles):
  LOOP:
    switch (t) {
    case &TypedefType(n,_,_,_):
      (*n)[0] = Loc_n;
      t = lookup_typedef(env,n); goto LOOP;
    case &ArrayType(ArrayInfo{et,_,_,zt,ztl}):
      let v = var();
      let q = var();
      let z = var();
      let t = type_to_ctype(env,et);
      for (; dles != 0; dles = dles->tl) {
        let $(d,e) = *dles->hd;
        if (d) impos("designators in initializers");
        let te = gen_initializer(env,et,e);
        leq(te,v);
      }
      return array_ct(v,q,z);
    case &AppType(&AggrCon({.UnknownAggr = $(StructA, n, _)}),_):
      (*n)[0] = Loc_n;
      let $(ad,_) = *lookup_struct_decl(env,n);
      if (ad == NULL) impos("struct is not yet defined");
      fallthru(ad);
    case &AppType(&AggrCon({.KnownAggr = &ad}),_):
      let fields = ad->impl->fields;
      for (; dles != 0; dles = dles->tl) {
        let $(d,e) = *dles->hd;
        if (d) impos("designators in initializers");
        let f = fields->hd;
        fields = fields->tl;
        let te = gen_initializer(env,f->type,e);
      }
      return type_to_ctype(env,t);
    default: impos("bad type for aggregate initializer");
    }
  case &Const_e({.String_c = _}):
  case &Const_e({.Wstring_c = _}):
  LOOP2:
    switch (t) {
    case &TypedefType(n,_,_,_):
      (*n)[0] = Loc_n;
      t = lookup_typedef(env,n); goto LOOP2;
    case &ArrayType(_): return array_ct(arith_ct(), const_ct(), zterm_ct());
    default: return gen_exp(false,env,e);
    }
  default: return gen_exp(false,env, e);
  }
}

// generate constraints for a local declaration
static cenv_t gen_localdecl(cenv_t env, decl_t d, bool fromglobal) {
  switch (d->r) {
  case &Var_d(vd):
    if (!fromglobal) {register_localvar_decl(env,vd->name, vd->varloc, vd->type, vd->initializer);}
    let t = var();
    ctype_t q;
    if (env->gcenv->porting) {
      q = var();
      register_const_cvar(env,q,
                          vd->tq.print_const ? const_ct() : notconst_ct(),
                          vd->tq.loc);
#ifdef PORT_DEBUG
      if (vd->tq.loc == NULL)
        fprintf(stderr,"uhm, variable %s qualifier missing location...\n",
                qvar2string(vd->name));
#endif
    } else {
      q = vd->tq.print_const ? const_ct() : notconst_ct();
    }
    (*vd->name)[0] = Loc_n;
    env = add_var(env, vd->name, vd->type, q, t,vd->varloc);
    unifies(t, type_to_ctype(env, vd->type));
    if (vd->initializer) {
      exp_t e = (exp_t)vd->initializer;
      ctype_t t2 = gen_initializer(env, vd->type, e);
      leq(t2,t);
    }
    return env;
  default: impos("non-local decl that isn't a variable");
  }
}

static $(var_opt_t,tqual_t,type_t)@ make_targ($(var_opt_t,tqual_t,type_t)@ arg){
  let $(x,q,t) = *arg;
  return new $(NULL,q,t);
}

static cenv_t gen_topdecls(cenv_t env, list_t<decl_t> ds);
// generate constraints for a top-level declaration
static cenv_t gen_topdecl(cenv_t env, decl_t d) {
  switch (d->r) {
  case &Porton_d:
    env->gcenv->porting = true;
    return env;
  case &Portoff_d:
    env->gcenv->porting = false;
    return env;
  case &Var_d(vd):
    (*vd->name)[0] = Loc_n;
#ifdef PORT_DEBUG
    fprintf(stderr,"processing var decl %s\n",qvar2string(vd->name));
#endif
    if (declared_var(env,vd->name)) {
      let $(p,loc) = lookup_var(env, vd->name);
      let $(q,t) = p;
      ctype_t q2;
      if (env->gcenv->porting && !isfn(env,vd->name)) {
        q2 = var();
        register_const_cvar(env,q2,
                            vd->tq.print_const ? const_ct():notconst_ct(),
                            vd->tq.loc);
#ifdef PORT_DEBUG
        if (vd->tq.loc == NULL)
          fprintf(stderr,"uhm, top variable %s qual missing location...\n",
                  qvar2string(vd->name));
#endif
      } else {
        q2 = vd->tq.print_const ? const_ct() : notconst_ct();
      }
      unifies(q,q2);
      unifies(t,type_to_ctype(env,vd->type));
      if (vd->initializer) {
        exp_t e = (exp_t)vd->initializer;
        leq(gen_initializer(env, vd->type, e), t);
      }
      return env;
    } else {
      return gen_localdecl(env,d,true);
    }
  case &Fn_d(fd):
#ifdef PORT_DEBUG
    fprintf(stderr,"processing fn decl %s\n",qvar2string(fd->name));
#endif
    (*fd->name)[0] = Loc_n;
    $(type_t, $(ctype_t,ctype_t)@,seg_t) *predeclared = NULL;

    if (declared_var(env,fd->name)) {
      predeclared = lookup_full_var(env,fd->name);
    }
    let rettype = fd->i.ret_type;
    let args = fd->i.args;
    let targs = map(make_targ,args);
    let fntype =
      new FnType(FnInfo{NULL,NULL,empty_tqual(0),rettype,targs,false,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL});
    // Note:  we do not set the cpos to FnRes_pos here because we want
    // to get constraint variables for the regions
    let fn_env = set_cpos(env,FnBody_pos);
    let c_rettype = type_to_ctype(fn_env, rettype);
    list_t<$(var_opt_t,type_t,ctype_t,ctype_t)@> c_args = NULL;
    list_t<ctype_t> c_arg_types = NULL;
    for (let xs = args; xs; xs = xs->tl) {
      let $(x,tq,t) = *xs->hd;
      // Note: we do not set the cpos to FnArg_pos here because we want
      // to get constraint variables for the regions
      let ct = type_to_ctype(fn_env,t);
      ctype_t tqv;
      if (env->gcenv->porting) {
        tqv = var();
        register_const_cvar(env,tqv,tq.print_const?const_ct():notconst_ct(),
                            tq.loc);
#ifdef PORT_DEBUG
        if (tq.loc == NULL)
          fprintf(stderr,"uhm, fn %s, param %s qualifier missing location.\n",
                  qvar2string(fd->name), *x);
#endif
      } else {
        tqv = tq.print_const ? const_ct() : notconst_ct();
      }
      c_args = new List{new $(x,t,tqv,ct), c_args};
      c_arg_types = new List{ct, c_arg_types};
    }
    c_args = List::imp_rev(c_args);
    c_arg_types = List::imp_rev(c_arg_types);
    let ctype = fn_ct(c_rettype, c_arg_types);
#ifdef PORT_DEBUG
    fprintf(stderr,"fntype is %s\n",ctype2string(true,ctype));
#endif
    (*fd->name)[0] = Loc_n;
    fn_env = add_var(fn_env, fd->name, fntype, const_ct(), ctype,0);
    add_return_type(fn_env,c_rettype);
    for (let xs = c_args; xs; xs = xs->tl) {
      let $(x,t,q,ct) = *xs->hd;
      fn_env = add_var(fn_env, new $(Loc_n,(_@)x), t, q, ct,0);
    }
    gen_stmt(fn_env,fd->body);
#ifdef PORT_DEBUG
    fprintf(stderr,"after body, fntype is %s\n",ctype2string(true,ctype));
#endif
    // we need to generalize the regions according to how they were used.
    generalize(false,ctype);
#ifdef PORT_DEBUG
    fprintf(stderr,"after gen, fntype is %s\n",ctype2string(true,ctype));
#endif
    // now we need to figure out if the generalized prototype differs
    // from the default and if so, record edits in the env.
    // First, collect a count of how many times each region variable occurs:
    Dict::dict_t<tvarname_t,int@> counts = Dict::empty(strptrcmp);
    region_counts(&counts, ctype);
    // Now, crawl over the original type and the ctype and figure
    // out where there are mismatches, recording the edits in the env.
    register_rgns(env, counts, true, fntype, ctype);
    env = add_var(fn_env, fd->name, fntype, const_ct(), ctype,0);
    if (predeclared) {
      // A bit tricky here -- the pre-declared function hasn't been
      // region-generalized.  So, we unify the pre-declared type with
      // an instantiation of the ctype.  That will cause pointer kind,
      // consts, etc. to propagate between them.  But then we crawl over
      // the predeclared type to generate the right region edits for it.
      // FIX: there might be more than one pre-declaration for a function.
      let $(orig_type,&$(q2,t2),_) = *predeclared;
      unifies(q2,const_ct());
      unifies(t2,instantiate(ctype));
      // Register the regions of the predeclared type
      register_rgns(env, counts, true, orig_type, ctype);
    }
    return env;
  case &Typedef_d(td):
#ifdef PORT_DEBUG
    fprintf(stderr,"processing typedef %s\n",qvar2string(td->name));
#endif
    // FIX: what about typedef qualifier?
    let t = (type_t)td->defn;
    let ct = type_to_ctype(env,t);
    (*td->name)[0] = Loc_n;
    add_typedef(env, td->name, t, ct);
    return env;
  case &Aggr_d(ad):
#ifdef PORT_DEBUG
    fprintf(stderr,"processing %s decl %s\n",
            (ad->kind == StructA) ? "struct" : "union",qvar2string(ad->name));
#endif
    let name = ad->name;
    (*ad->name)[0] = Loc_n;
    $(struct Aggrdecl @,cfields_t) @previous;
    cfields_t curr = NULL;
    switch (ad->kind) {
    case StructA:
      previous = lookup_struct_decl(env,name);
      break;
    default:
      previous = lookup_union_decl(env,name);
      break;
    }
    if (ad->impl) {
      cfields_t cf = (*previous)[1];
      for (let fields = ad->impl->fields; fields; fields = fields->tl) {
        let f = fields->hd;
        ctype_t qv;
        if (env->gcenv->porting) {
          qv = var();
          register_const_cvar(env,qv,
                              f->tq.print_const?const_ct():notconst_ct(),
                              f->tq.loc);
#ifdef PORT_DEBUG
          if (f->tq.loc == NULL)
            fprintf(stderr,"uhm, struct %s, field %s qualifier missing"
                    "location...\n", qvar2string(ad->name), *f->name);
#endif
        } else {
          qv = f->tq.print_const ? const_ct() : notconst_ct();
        }
        let ct = type_to_ctype(env,f->type);
        if (cf != NULL) {
          let Cfield{qv2,_,ct2} = *cf->hd;
          cf = cf->tl;
          unifies(qv,qv2);
          unifies(ct,ct2);
        }
        curr = new List{new Cfield{.qual = qv, .f = f->name, .type = ct},curr};
      }
      curr = List::imp_rev(curr);
      if ((*previous)[1] == NULL) {
        (*previous)[1] = curr;
      }
    }
    return env;
  case &Enum_d(ed):
#ifdef PORT_DEBUG
    fprintf(stderr,"processing enum decl %s\n",qvar2string(ed->name));
#endif
    (*ed->name)[0] = Loc_n;
    // just insert the enum's identifiers as constant arithmetic values
    if (ed->fields)
      for(let fs = ed->fields->v; fs; fs = fs->tl) {
        (*fs->hd->name)[0] = Loc_n;
        env = add_var(env, fs->hd->name, enum_type(ed->name,ed),
                      const_ct(), arith_ct(),0);
      }
    return env;
  default:
    if (env->gcenv->porting)
      fprintf(stderr,"Warning: Cyclone declaration found in code to be ported -- skipping.");
    return env;
  }
}

// Generate all constraints by crawling over a list of declarations
static cenv_t gen_topdecls(cenv_t env, list_t<decl_t> ds) {
  for (; ds; ds = ds->tl)
    env = gen_topdecl(env,ds->hd);
  return env;
}


static edits_t gen_edits(list_t<decl_t> ds) {
  // generate the constraints
  cenv_t env = gen_topdecls(initial_cenv(), ds);
  // extract the constraints that might produce edits
  let ptrs = env->gcenv->pointer_edits;
  let consts = env->gcenv->qualifier_edits;
  let zts = env->gcenv->zeroterm_edits;
  let edits = env->gcenv->edits;
  let localvars = env->gcenv->vardecl_locs;
   
  for(;localvars;localvars = localvars->tl){
    let $(var, loc, vartype) = *localvars->hd;
    let $(_,x) = *var;
    let varusage = Hashtable::lookup(env->gcenv->varusage_tab, loc);
    if (varusage->address_taken){
      if(varusage->init){
	// with init, "type x = e" => "type ?x = new e"
	edits = new List{new Edit {loc, "@", ""}, edits};
	edits = new List{new Edit {varusage->init->loc, "new ", ""}, edits};
      }
      else {
	//no init, "type x" => "type @x = malloc(sizeof(type))"
	edits = new List{new Edit {loc, aprintf("?%s = malloc(sizeof(%s))",*x,Absynpp::typ2string(vartype)), *x},edits};
      }
      let loclist = varusage->usage_locs;
      for(;loclist;loclist = loclist->tl){
	edits = new List{new Edit{loclist->hd, aprintf("(*%s)",*x), *x}, edits};
      }
    }
  }

  // force the constraints
  for (let ps = ptrs; ps; ps = ps->tl) {
    let $(new_ctype, orig_ctype, loc) = *ps->hd;
    unifies(new_ctype, orig_ctype);
  }
  for (let cs = consts; cs; cs = cs->tl) {
    let $(new_qual, old_qual, loc) = *cs->hd;
    unifies(new_qual, old_qual);
  }
  for (let zs = zts; zs; zs = zs->tl) {
    let $(new_zt, old_zt, loc) = *zs->hd;
    unifies(new_zt, old_zt);
  }

  // insert any edits for the pointers
  for (; ptrs; ptrs = ptrs->tl) {
    let $(new_ctype, orig_ctype, loc) = *ptrs->hd;
    if (!unifies(new_ctype,orig_ctype) && loc) {
      switch (compress_ct(orig_ctype)) {
      case &Thin_ct:
        edits = new List{new Edit{loc,"?","*"}, edits};
        break;
      case &Fat_ct:
        edits = new List{new Edit{loc,"*","?"}, edits};
        break;
      default: break;
      }
    }
  }
  // insert any edits for the consts
  for (; consts; consts = consts->tl) {
    let $(new_qual, old_qual, loc) = *consts->hd;
    if (!unifies(new_qual,old_qual) && loc) {
      switch (compress_ct(old_qual)) {
      case &Notconst_ct:
        edits = new List{new Edit{loc,"const ",""}, edits}; break;
      case &Const_ct:
        edits = new List{new Edit{loc,"","const "}, edits}; break;
      default: break;
      }
    }
  }
  // insert any edits for the zero-terms
  for (; zts; zts = zts->tl) {
    let $(new_zt, old_zt, loc) = *zts->hd;
    if (!unifies(new_zt,old_zt) && loc) {
      switch (compress_ct(old_zt)) {
      case &Zterm_ct:
        edits = new List{new Edit{loc,"@nozeroterm ",""}, edits}; break;
      case &Nozterm_ct:
        edits = new List{new Edit{loc,"@zeroterm ",""}, edits}; break;
      default: break;
      }
    }
  }

  // sort the edits
  edits = merge_sort(cmp_edit, edits);
  // Hack to get rid of spurious 0 location
  while (edits && edits->hd->loc == 0) {
#ifdef PORT_DEBUG
    fprintf(stderr,"found 0 location\n");
#endif
    edits = edits->tl;
  }
  return edits;
}

// given a list of declarations, emits a sorted list of edits
// which should help bring the code in line.
void port(list_t<decl_t> ds) {
  let edits = gen_edits(ds);
  let locs = map(get_seg,edits);
  Position::use_gcc_style_location = false;
  let slocs = List::imp_rev(Position::strings_of_segments(locs));
  for (; edits; edits = edits->tl, slocs = slocs->tl) {
    let Edit{loc,s1,s2} = *edits->hd;
    string_t sloc = *slocs->hd;
    printf("%s: insert `%s' for `%s'\n",sloc,s1,s2);
  }
}


