/* Name resolution
   Copyright (C) 2003 Dan Grossman, AT&T
   This file is part of the Cyclone compiler.

   The Cyclone compiler is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   The Cyclone compiler is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with the Cyclone compiler; see the file COPYING. If not,
   write to the Free Software Foundation, Inc., 59 Temple Place -
   Suite 330, Boston, MA 02111-1307, USA. */

// This pass resolves binding (variables, structs, etc.)

// We used to do it during type-check to save a deep-pass over the
// abstract syntax. Now only this pass has to worry about namespaces 
// and relative names

// The lexer also uses the namespace-management code (or will eventually)
// because we must resolve relative typedefs during parsing.

#include <string.h>
#include <dict.h>
#include <set.h>
#include "warn.h"
#include "flags.h"
#include "binding.h"
#include "cifc.h"
using List;
using Absyn;
using Warn;
namespace Binding;

typedef Dict::dict_t<`a,`b> dict_t<`a,`b>;

datatype exn {BindingError};

//////////////// Namespace Resolution ///////////////
//After years of repeating logic in the lexer and type-checker, we share it here
datatype NSDirective {
  Namespace(namespace_name_t); // absolute
  Using(namespace_name_t); // absolute
};
struct NSCtxt<`a> {
  namespace_name_t            curr_ns;    // current namespace (absolute)
  list_t<nsdirective_t>       availables; // current using/namespace stack
  dict_t<namespace_name_t,`a> ns_data;    // maps absolute names to info
};

nsctxt_t<`a> mt_nsctxt(`b env, `a mkdata(`b)) {
  let data = mkdata(env);
  return new NSCtxt{.curr_ns    = NULL,
		    .availables = new List(new Namespace(NULL),NULL),
		    .ns_data    = Dict::singleton(varlist_cmp,NULL,data)};
}
`a get_ns_data(nsctxt_t<`a> ctxt, Absyn::nmspace_t abs_ns) {
  switch (abs_ns) {
  case {.C_n  =vs}: fallthru(vs);
  case {.Abs_n=vs}: return Dict::lookup(ctxt->ns_data, vs);
  default: impos("Binding:get_ns_data: relative ns");
  }
}

// for resolution, we are simplifying the rules compared to C++ and/or
// what used to be in Tcenv:
// * current namespace trumps anything else without warning
// * else innermost using/namespace that matches trumps without warning
// Hence current-namespace "beats" a shadowed binding due to using.
// Otherwise, it's completely based on the current namespace-directive stack.
// But entering A::B does not make A available (I think it used to)!
//
// It's a bit more complicated because how we lookup a relative qvar
// depends on whether the namespace-list is empty (this has always been true)
namespace_name_t resolve_rel_ns(seg_t loc, nsctxt_t<`a> ctxt, 
				namespace_name_t rel_ns) {
  // check for result due to current namespace
  let fullname = List::append(ctxt->curr_ns,rel_ns);
  if(Dict::member(ctxt->ns_data, fullname))
    return fullname;
  for(let as = ctxt->availables; as != NULL; as = as->tl)
    switch(as->hd) {
    case &Using(ns): fallthru(ns);
    case &Namespace(ns):
      let fullname = List::append(ns,rel_ns);
      if(Dict::member(ctxt->ns_data, fullname))
	return fullname;
      break;
    }
  err2(loc,"namespace ", str_sepstr(rel_ns,"::"), " not found");
  throw new BindingError;
}
// no need to absolutize because we replace bound occurrence with reference
// to (absolutized) declaration
`b resolve_lookup(seg_t loc, nsctxt_t<`a> ctxt, qvar_t qv, `b lookup(`a,var_t)){
  let &$(ns,v) = qv;
  switch (ns) {
  case {.Rel_n = NULL}:
    try return lookup(Dict::lookup(ctxt->ns_data,ctxt->curr_ns),v);
    catch { case &Dict::Absent: break; }
    for(let as = ctxt->availables; as != NULL; as = as->tl)
      switch(as->hd) {
      case &Using(ns): fallthru(ns);
      case &Namespace(ns):
	try return lookup(Dict::lookup(ctxt->ns_data,ns),v);
	catch { case &Dict::Absent: break; }
	break;
      }
    throw new BindingError;
  case {.Rel_n = ns}: // ns not NULL.  FIX: look for multiple matches?!?
    try {
      let abs_ns = resolve_rel_ns(loc,ctxt,ns);
      return lookup(Dict::lookup(ctxt->ns_data,abs_ns),v);
    } catch { case &Dict::Absent: throw new BindingError; }
  case {.C_n   = ns}: fallthru(ns);
  case {.Abs_n = ns}: 
    try return lookup(Dict::lookup(ctxt->ns_data,ns),v);
    catch { case &Dict::Absent: throw new BindingError; }
  case {.Loc_n = _}:  impos("lookup local in global");
  }
}

void enter_ns(nsctxt_t<`a> ctxt, var_t subname, `b env, `a mkdata(`b)) {
  let ns     = ctxt->curr_ns;
  let ns2    = List::append(ns, new List(subname,NULL));
  if(!Dict::member(ctxt->ns_data, ns2))
    ctxt->ns_data = Dict::insert(ctxt->ns_data, ns2, mkdata(env));
  ctxt->curr_ns = ns2;
  ctxt->availables = new List(new Namespace(ns2), ctxt->availables);
}
void leave_ns(nsctxt_t ctxt) {
  if(ctxt->availables == NULL)
    impos("leaving topmost namespace");
  switch(ctxt->availables->hd) {
  case &Namespace(_): 
    ctxt->availables = ctxt->availables->tl;
    ctxt->curr_ns = List::rev(List::rev(ctxt->curr_ns)->tl);
    break;
  case &Using(_):
    impos("leaving using as namespace");
  }
}
namespace_name_t enter_using(seg_t loc, nsctxt_t ctxt, qvar_t usename) {
  let &$(nsl,v) = usename;
  let ns;
  switch(nsl) {
  case {.Rel_n = vs}: 
    ns = resolve_rel_ns(loc,ctxt,List::append(vs,new List(v,NULL)));
    let abs_vs = List::rev(List::rev(ns)->tl);
    (*usename)[0] = Abs_n(abs_vs,false);
    break;
  case {.Abs_n = vs}:
    ns = List::append(vs,new List(v,NULL));
    break;
  case {.Loc_n = _ }: impos("enter_using, Loc_n");
  case {.C_n   = _ }: impos("enter_using, C_n");
  }
  ctxt->availables = new List(new Using(ns), ctxt->availables);
  return ns;
}
void leave_using(nsctxt_t ctxt) { 
  if(ctxt->availables == NULL)
    impos("leaving topmost namespace as a using");
  switch(ctxt->availables->hd) {
  case &Using(_): ctxt->availables = ctxt->availables->tl; break;
  case &Namespace(_): impos("leaving namespace as using");
  }
}

// because we're not the typechecker, we do not have to merge repeated
// declarations. Instead, we just bind to the right (most recent) one.  The
// type-checker still has to build up what has been seen and merge
// repeats.  But it can do it with a flat namespace (but still have
// nested scopes -- maybe not?).  An alternative design
// would mutate the abstract-syntax with pointers to previous
// declarations with the same name, but extensible datatypes are funny.

// we still leave tree-shaking info to type-checker for now
datatype Resolved {
  VarRes(binding_t); // includes unresolved variant
  AggrRes(aggrdecl_t);
  DatatypeRes(datatypedecl_t,datatypefield_t);
  EnumRes(enumdecl_t,enumfield_t);
  AnonEnumRes(type_t,enumfield_t);
};
typedef datatype Resolved @ resolved_t;

static struct ResolveNSEnv {
  dict_t<var_t,aggrdecl_t>     aggrdecls; 
  dict_t<var_t,List_t<datatypedecl_t>> datatypedecls; // list for extensible
  dict_t<var_t,enumdecl_t>     enumdecls;
  dict_t<var_t,typedefdecl_t>  typedefs;   // we crawl through types too
  dict_t<var_t,resolved_t>     ordinaries; // all ids (vars,enums,aggrs,etc.)
};
typedef struct ResolveNSEnv@ renv_t;
// FIX: scope of types declared inside functions isn't right,
// but type-checker throws Unimplemented on it anyway
static struct Env {
  bool in_cinclude;
  bool in_cyc_override;
  nsctxt_t<renv_t> ns;
  dict_t<var_t,resolved_t>* local_vars; // NULL iff top-level
};
typedef struct Env@ env_t;

static inline bool in_cinclude(env_t env) {
  return env->in_cinclude;
}
static inline bool at_toplevel(env_t env) {
  return env->local_vars == NULL;
}
static renv_t mt_renv(bool ignore) {
  return new ResolveNSEnv{.aggrdecls     = Dict::empty(strptrcmp),
		          .datatypedecls = Dict::empty(strptrcmp),
		          .enumdecls     = Dict::empty(strptrcmp),
		          .typedefs      = Dict::empty(strptrcmp),
		          .ordinaries    = Dict::empty(strptrcmp)};
}

static aggrdecl_t lookup_aggrdecl(renv_t renv, var_t v) {
  return Dict::lookup(renv->aggrdecls,v);
}
static List_t<datatypedecl_t> lookup_datatypedecl(renv_t renv, var_t v) {
  return Dict::lookup(renv->datatypedecls,v);
}
static enumdecl_t lookup_enumdecl(renv_t renv, var_t v) {
  return Dict::lookup(renv->enumdecls,v);
}
static typedefdecl_t lookup_typedefdecl(renv_t renv, var_t v) {
  return Dict::lookup(renv->typedefs,v);
}
static resolved_t lookup_ordinary_global(renv_t renv, var_t v) {
  return Dict::lookup(renv->ordinaries,v);
}
static resolved_t lookup_ordinary(seg_t loc, env_t env, qvar_t qv) {
  let &$(nsl,v) = qv;
  switch(nsl) {
  case {.Loc_n = _}:
    if(at_toplevel(env) || !Dict::member(*env->local_vars,v))
      throw new BindingError;
    return Dict::lookup(*env->local_vars,v);
  case {.Rel_n = NULL}:
    if(!at_toplevel(env) && Dict::member(*env->local_vars,v))
      return Dict::lookup(*env->local_vars,v);
    fallthru;
  default:
    return resolve_lookup(loc, env->ns, qv, lookup_ordinary_global);
  }
}

void resolve_decl(env_t,  decl_t);
void resolve_decls(env_t, list_t<decl_t>);
void resolve_stmt(env_t,  stmt_t);
void resolve_pat(env_t,   pat_t);
void resolve_exp(env_t,   exp_t);
void resolve_type(seg_t, env_t,  type_t);
void resolve_rgnpo(seg_t, env_t, list_t<$(type_t,type_t)@>);
void resolve_scs(env_t,   list_t<switch_clause_t>);
void resolve_aggrfields(seg_t, env_t, list_t<aggrfield_t>);
static void resolve_function_stuff(seg_t loc, env_t env, fn_info_t @i);
void resolve_asm_iolist(env_t, list_t<$(string_t, exp_t)@> l);
list_t<vardecl_t> get_fun_vardecls(bool, seg_t, env_t, 
				   list_t<$(var_opt_t,tqual_t,type_t)@>, 
				   vararg_info_t*);
//void resolve_enumfields(seg_t, env_t, list_t<enumfield_t>); // FIX: DO ME

void absolutize_decl(seg_t loc, env_t env, qvar_t qv, scope_t sc) {
  switch((*qv)[0]) {
  case {.Rel_n = NULL}: 
    if(at_toplevel(env))
      (*qv)[0] = Abs_n(env->ns->curr_ns, (in_cinclude(env) || sc==ExternC));
    else
      (*qv)[0] = Loc_n;
    break;
  case Nmspace{.Loc_n = _}: break;
  case Nmspace{.Abs_n = _}: 
    if(!at_toplevel(env))
      fallthru;
    break; // happens with extensible datatypes
  default: err2(loc,"qualified names in declarations unimplemented (", qv, ")");
  }
}
// This is a kludge because we find unbound type names (e.g., a struct name)
// inside a function, but we need to give them absolute names, not
// local names.  It's really C's kludge for allowing unbound types.
void absolutize_topdecl(seg_t loc, env_t env, qvar_t qv, scope_t sc) {
  let old_locals = env->local_vars;
  env->local_vars = NULL;
  absolutize_decl(loc,env,qv,sc);
  env->local_vars = old_locals;
}

void check_warn_override(seg_t loc, env_t env, qvar_t q) {
  string_t hides_what;
  try { 
    switch (lookup_ordinary(loc,env,q)) {
    case &VarRes(b):
      if(at_toplevel(env)) // globals can be redeclared -- leave to typechecker
	return;
      switch(b) {
      case &Global_b(_):   hides_what = "global variable";  break;
      case &Local_b(_):    hides_what = "local variable";   break;
      case &Param_b(_):    hides_what = "parameter";        break;
      case &Pat_b(_):      hides_what = "pattern variable"; break;
      case &Funname_b(_):  hides_what = "function";         break;
      case &Unresolved_b(_): impos("shadowing free variable!");
      }
      break;
    case &AggrRes(...): hides_what = "struct constructor"; break;// FIX?: union?
    case &DatatypeRes(...): hides_what = "datatype constructor"; break;
    case &EnumRes(...):
    case &AnonEnumRes(...): hides_what = "enum tag"; break;
    }
    warn2(loc,"declaration hides ",hides_what);
    return;
  } catch { case &BindingError: return; }
}

void resolve_and_add_vardecl(seg_t loc, env_t env, vardecl_t vd) {
  absolutize_decl(loc,env,vd->name,vd->sc);
  let &$(decl_ns,decl_name) = vd->name;
  resolve_type(loc,env,vd->type);
  if(Flags::warn_override)
    check_warn_override(loc,env,vd->name);
  if(!at_toplevel(env))
    *env->local_vars = Dict::insert(*env->local_vars, decl_name,
				    new VarRes(new Local_b(vd)));
  else if(!env->in_cyc_override) { //leave the original binding in place
    let decl_ns_data = get_ns_data(env->ns,decl_ns);
    decl_ns_data->ordinaries = Dict::insert(decl_ns_data->ordinaries,
					    decl_name,
					    new VarRes(new Global_b(vd)));
  }
}

void resolve_stmt(env_t env, stmt_t s) { 
  switch(s->r) {
  case &Skip_s: return;
  case &Exp_s(e): resolve_exp(env,e); return;
  case &Seq_s(s1,s2): resolve_stmt(env,s1); resolve_stmt(env,s2); return;
  case &Return_s(eopt): if(eopt) resolve_exp(env,(exp_t)eopt); return;
  case &IfThenElse_s(e,s1,s2):
    resolve_exp(env,e); resolve_stmt(env,s1); resolve_stmt(env,s2); return;
  case &Do_s(s1,$(e,_)): fallthru(e,s1);
  case &While_s($(e,_),s1): resolve_exp(env,e); resolve_stmt(env,s1); return;
  case &For_s(e1,$(e2,_),$(e3,_),s1):
    resolve_exp(env,e1); resolve_exp(env,e2); resolve_exp(env,e3);
    resolve_stmt(env,s1); 
    return;
  case &Break_s:
  case &Continue_s:
  case &Goto_s(_): return;
  case &Fallthru_s(es,_): // might someday "wire" fallthru clause in this pass
    for(;es!=NULL;es=es->tl) 
      resolve_exp(env,es->hd); 
    return;
  case &Label_s(_,s1): resolve_stmt(env,s1); return;
  case &Decl_s(d,s1):
    let old_locals = *env->local_vars;
    resolve_decl(env,d);
    resolve_stmt(env,s1);
    *env->local_vars = old_locals;
    return;
  case &Switch_s(e,scs,_):    resolve_exp(env,e);   resolve_scs(env,scs);return;
  case &TryCatch_s(s1,scs,_): resolve_stmt(env,s1); resolve_scs(env,scs);return;
  }
}
void resolve_exp(env_t env, exp_t e) { 
  switch(e->r) {
  case &Var_e(*b): 
    switch(*b) {
    case &Unresolved_b(q):
      try switch (lookup_ordinary(e->loc,env,q)) {
      case &VarRes(bnd):          *b = bnd; return;
      case &DatatypeRes(tud,tuf): e->r = new Datatype_e(NULL,tud,tuf); return;
      case &EnumRes(ed,ef):       e->r = new Enum_e(ed,ef); return;
      case &AnonEnumRes(t,ef):    e->r = new AnonEnum_e(t,ef); return;
      case &AggrRes(ad): err2(e->loc,"bad occurrence of type name ", q); return;
      }
      catch { 
      case &BindingError: err2(e->loc,"undeclared identifier ", q); return;
      }
    default: return; // only happens if we re-run this pass?
    }
  case &FnCall_e(e1,es,_,*b): 
    *b = true;
    // careful: we cannot call resolve_exp(env,e1) yet!
    for(let es2 = es; es2 != NULL; es2 = es2->tl)
      resolve_exp(env,es2->hd);
    switch(e1->r) {
      case &Var_e(*b):
	switch (*b) {
	case &Unresolved_b(q):
	  try switch (lookup_ordinary(e1->loc,env,q)) {
	  case &VarRes(bnd):
	    *b = bnd; return;
	  case &AggrRes(ad):
	    let dles = NULL;
	    for(; es != NULL; es = es->tl)
	      dles = new List(new $(NULL,es->hd), dles);
	    e->r = new Aggregate_e(ad->name,NULL,imp_rev(dles),ad);
	    return;
	  case &DatatypeRes(tud,tuf):
	    if (tuf->typs == NULL)
	      // Don't allow "foo()", require "foo"
	      err2(e->loc,tuf->name," is a constant, not a function");
	    e->r = new Datatype_e(es,tud,tuf);
	    return;
	  case &AnonEnumRes(...):
	  case &EnumRes(...):
	    err2(e->loc, q," is an enum constructor, not a function"); return;
	  } catch { 
	  case &BindingError: err2(e->loc,"undeclared identifier ",q); return;
	  }
	default: return; // only happens if we re-run this pass?
	}
    default: resolve_exp(env,e1); return;
    }

  case &Aggregate_e(*tn,ts,dles,*adopt): 
    for(; dles != NULL; dles=dles->tl)
      resolve_exp(env,(*dles->hd)[1]);
    try {
      *adopt = resolve_lookup(e->loc,env->ns,*tn,lookup_aggrdecl);
      *tn = (*adopt)->name;
      return;
    } catch { case &BindingError:
      err2(e->loc,"unbound struct/union name ", *tn);
      return;
    }

  case &Comprehension_e(vd,e1,e2,_): 
    resolve_exp(env,e1);
    if(at_toplevel(env)) {
      env->local_vars = new Dict::empty(strptrcmp);
      resolve_and_add_vardecl(e->loc, env, vd);
      resolve_exp(env,e2);
      env->local_vars = NULL;
      return;
    }
    let old_locals = *env->local_vars;
    resolve_and_add_vardecl(e->loc, env, vd);
    resolve_exp(env,e2);
    *env->local_vars = old_locals;
    return;

    // this case is done by the type-checker using the expected type
  case &UnresolvedMem_e(_,dles): 
    for(; dles != NULL; dles=dles->tl)
      resolve_exp(env,(*dles->hd)[1]);
    return;

    // the rest is just recursive descent
  case &ComprehensionNoinit_e(e1,t,_):
    resolve_exp(env,e1);
    resolve_type(e->loc,env,t);
    return;

  case &Pragma_e(_):
  case &Const_e(_): return;

  case &Tuple_e(es): fallthru(es);
  case &Primop_e(_,es):
    for(; es != NULL; es = es->tl)
      resolve_exp(env,es->hd);
    return;

  case &Assert_e(e1): fallthru(e1);
  case &Extension_e(e1):  fallthru(e1);
  case &Tagcheck_e(e1,_): fallthru(e1);
  case &NoInstantiate_e(e1): fallthru(e1);
  case &Sizeofexp_e(e1): fallthru(e1);
  case &Throw_e(e1,_): fallthru(e1);
  case &Increment_e(e1,_): fallthru(e1);
  case &AggrArrow_e(e1,...): fallthru(e1);
  case &AggrMember_e(e1,...): fallthru(e1);
  case &Address_e(e1): fallthru(e1);
  case &Deref_e(e1): resolve_exp(env,e1); return;

  case &Swap_e(e1,e2): fallthru(e1,e2);
  case &SeqExp_e(e1,e2): fallthru(e1,e2);
  case &AssignOp_e(e1,_,e2): fallthru(e1,e2);
  case &Subscript_e(e1,e2): fallthru(e1,e2);
  case &And_e(e1,e2): fallthru(e1,e2);
  case &Or_e(e1,e2): resolve_exp(env,e1); resolve_exp(env,e2); return;

  case &Malloc_e(MallocInfo(_,eo,to,e1,_,_)): 
    if(eo != NULL) resolve_exp(env,(exp_t)eo);
    if(to != NULL) resolve_type(e->loc,env,*to);
    resolve_exp(env,e1);
    return; 

  case &New_e(eo,e2):
    if(eo != NULL) resolve_exp(env,(exp_t)eo);
    resolve_exp(env,e2);
    return;

  case &Conditional_e(e1,e2,e3):
    resolve_exp(env,e1); resolve_exp(env,e2); resolve_exp(env,e3); return;

  case &Instantiate_e(e1,ts):
    resolve_exp(env,e1);
    for(; ts != NULL; ts = ts->tl)
      resolve_type(e->loc,env,ts->hd);
    return;

  case &Cast_e(t,e1,_,_): 
    resolve_exp(env,e1); resolve_type(e->loc,env,t); return;

  case &StmtExp_e(s): resolve_stmt(env,s); return;

  case &Valueof_e(t): fallthru(t);
  case &Offsetof_e(t,_): fallthru(t);
  case &Sizeoftype_e(t): resolve_type(e->loc,env,t); return; 

  case &CompoundLit_e(&$(_,_,t),dles):
    resolve_type(e->loc,env,t);
    fallthru(dles);
    
  case &Array_e(dles): 
    for(; dles != NULL; dles = dles->tl)
      resolve_exp(env,(*dles->hd)[1]);
    return;

    // cases that should arise only if we run binding more than once
  case &AnonEnum_e(t,ef): resolve_type(e->loc,env,t); return;
  case &Enum_e(ed,ef): return;
  case &Datatype_e(es,tud,tuf): 
    for(; es != NULL; es = es->tl)
      resolve_exp(env,es->hd);
    return;
  case &AnonStruct_e(t,dles): // can't exist until after type-checker
    resolve_type(e->loc,env,t);
    for(; dles != NULL; dles=dles->tl)
      resolve_exp(env,(*dles->hd)[1]);
    return;
	
  case &Asm_e(v,t,o,i,c): 
    resolve_asm_iolist(env, o);
    resolve_asm_iolist(env, i);
    break;
  }
}

void resolve_asm_iolist(env_t env, list_t<$(string_t, exp_t)@> l) {
  while(l) {
    let &$(_, e) = l->hd;
    resolve_exp(env, e);
    l = l->tl;
  }
}

void resolve_scs(env_t env, list_t<switch_clause_t> scs) {
  let old_locals = *env->local_vars;
  for(; scs != NULL; scs = scs->tl) {
    let &Switch_clause(pattern,_,where_clause,body,_) = scs->hd;
    resolve_pat(env,pattern);
    if(where_clause != NULL)
      resolve_exp(env,(exp_t)where_clause);
    resolve_stmt(env,body);
    *env->local_vars = old_locals;
  }
  return;
}
void resolve_aggrfields(seg_t loc, env_t env, list_t<aggrfield_t> fs) {
  for(; fs != NULL; fs = fs->tl) {
    let &Aggrfield(fn,tq,t,width,atts,requires_clause) = fs->hd;
    resolve_type(loc,env,t);
    if(width != NULL)
      resolve_exp(env,(exp_t)width);
    if(requires_clause != NULL)
      resolve_exp(env,(exp_t)requires_clause);
  }
  return;
}

list_t<vardecl_t> get_fun_vardecls(bool need_va_name,
				   seg_t loc, env_t env, 
				   list_t<$(var_opt_t,tqual_t,type_t)@> args,
				   vararg_info_t* vai) {
  // Note: we resolve the types in resolve_function_stuff after we have
  // all the vardecls so that types can refer to parameters.
  let vds = NULL;
  for(; args != NULL; args = args->tl) {
    let &$(a,tq,t) = args->hd;
    if(a==NULL)
      continue;
    let vd = new_vardecl(0,new $((nmspace_t)Loc_n,a), t, NULL);
    vd->tq = tq;
    vds = new List(vd,vds);
  }
  if(vai != NULL) {
    let VarargInfo(v,tq,t,i) = *vai;
    if(v==NULL) {
      if(need_va_name)
	err2(loc,"missing name for vararg");
    } else {
      // HeapRegion is wrong -- changed by type-checker!
      let typ = fatptr_type(t, heap_rgn_type, tq, false_type);
      let vd = new_vardecl(0,new $((nmspace_t)Loc_n,(var_t)v), typ, NULL);
      vds = new List(vd,vds);
    }
  }
  vds = List::imp_rev(vds);
  return vds;
}

static void resolve_function_stuff(seg_t loc, env_t env, fn_info_t @i) {
  if(i->effect != NULL)
    resolve_type(loc,env,(type_t)i->effect);
  resolve_type(loc,env,i->ret_type);
  for(let args=i->args; args != NULL; args = args->tl)
    resolve_type(loc,env,(*args->hd)[2]);
  if(i->cyc_varargs != NULL)
    resolve_type(loc,env,i->cyc_varargs->type);
  resolve_rgnpo(loc,env,i->rgn_po);
  if(i->requires_clause != NULL)
    resolve_exp(env,(exp_t)i->requires_clause);
  if(i->ensures_clause != NULL) {
    // return_value is a dummy var in scope only here
    let locs = *env->local_vars;
    let v    = new "return_value";
    let vd   = new_vardecl(0,new $((nmspace_t)Loc_n, v), i->ret_type, NULL);
    i->return_value = vd;
    *env->local_vars = Dict::insert(*env->local_vars, v,
				    new VarRes(new Local_b(vd)));
    resolve_exp(env,(exp_t)i->ensures_clause);
    *env->local_vars = locs;
  }
}

// FIX: The Datatype, Datatypefield, Aggr, and Enum cases should "wire up" known
//      definitions, but this is hard to do with typedef.  The type-checker
//      uses an indirection kludge that won't work as a prepass and requires
//      thought.  So for now we just absolutize the names.
// DO ME: see above
void resolve_type(seg_t loc, env_t env, type_t t) { 
  switch(t) {
  case &AppType(&DatatypeCon(*info),targs):
    for(; targs != NULL; targs = targs->tl)
      resolve_type(loc,env,targs->hd);
    switch(*info) {
    case {.UnknownDatatype=UnknownDatatypeInfo(qv,b)}:
      try { // FIX: sort of a hack just to grab more recent when extensible
	let tud = resolve_lookup(loc,env->ns,qv,lookup_datatypedecl)->hd;
	*info = UnknownDatatype(UnknownDatatypeInfo(tud->name, b));
	return;
      } catch {case &BindingError: 
        absolutize_topdecl(loc,env,qv,Public); return;}
    case {.KnownDatatype=_}: return;
    }
  case &AppType(&DatatypeFieldCon(*info),targs):
    for(; targs != NULL; targs = targs->tl)
      resolve_type(loc,env,targs->hd);
    switch(*info) {
    case {.UnknownDatatypefield=UnknownDatatypeFieldInfo(qvd,qvf,b)}:
      // FIX?: We are doing the wrong thing in the presence of shadowing,
      //       but it is unclear we should allow field-shadowing anyway
      try 
	switch(lookup_ordinary(loc,env,qvf)) {
	case &DatatypeRes(tud,tuf):
	  let tud2 = resolve_lookup(loc,env->ns,qvd,lookup_datatypedecl)->hd;
	  if(qvar_cmp(tud->name,tud2->name) != 0) {
	    err2(loc, tuf->name, " is a variant of ", tud2->name, " not ",
		 tud->name, " (shadowing not yet implemented properly)");
	    return;
	  }
	  *info = UnknownDatatypefield(UnknownDatatypeFieldInfo(tud->name,
								tuf->name, b));
	  return;
	default: break;
	}
      catch {case &BindingError: break; }
      err2(loc, qvf, " is not a datatype field"); return;
    case {.KnownDatatypefield=_}: return;
    }

  case &AppType(&AggrCon(*info),targs): 
    for(; targs != NULL; targs = targs->tl)
      resolve_type(loc,env,targs->hd);
    switch(*info) {
    case {.UnknownAggr=$(ak,qv,bo)}:
      try {
	let ad = resolve_lookup(loc,env->ns,qv,lookup_aggrdecl);
	if(ad->kind != ak)
	  err2(loc,"struct vs. union mismatch with earlier declaration");
	if(ak==UnionA && bo != NULL && ad->impl != NULL // ???
	   && ad->impl->tagged != bo->v)
	  err2(loc,"@tagged mismatch with earlier declaration");
	*info = UnknownAggr(ak,ad->name,bo);
	return;
      } catch {case &BindingError: 
        absolutize_topdecl(loc,env,qv,Public); return;}
    case {.KnownAggr=_}: return;
    }
  case &AppType(&EnumCon(*qv,edo),_): 
    if(edo != NULL)
      return;
    try {
      let ed = resolve_lookup(loc,env->ns,*qv,lookup_enumdecl);
      *qv = ed->name;
      return;
    } catch {case &BindingError: 
      absolutize_topdecl(loc,env,*qv,Public); return;}

  case &TypedefType(*tdn,targs,*tdo,_): 
    for(; targs != NULL; targs = targs->tl)
      resolve_type(loc,env,targs->hd);
    try {
      let td = resolve_lookup(loc,env->ns,*tdn,lookup_typedefdecl);
      //      *tdo = td; // FIX: TYPEDEF PROBLEM (defn already resolved for now)
      *tdn = td->name;
      return;
    } catch {case &BindingError: break; }
    err2(loc,"unbound typdef name ",*tdn);
    return;

  case &TypeDeclType(td,*to): 
    // FIX?: notice we are hoisting in a weird way
    let old_locals = env->local_vars;
    env->local_vars = NULL;
    switch(td->r) {
    case &Aggr_td(ad): 
      resolve_decl(env, new Decl(new Aggr_d(ad),td->loc)); break;
    case &Enum_td(ed):
      resolve_decl(env, new Decl(new Enum_d(ed),td->loc)); break;
    case &Datatype_td(tud):
      resolve_decl(env, new Decl(new Datatype_d(tud),td->loc)); break;
    }
    env->local_vars = old_locals;
    return;
    // FIX: DO ME TYPEDEF PROBLEM
    // (set *to here instead of in i_check_valid_type)

    // recursive descent from here down
  case &AnonAggrType(_,fs): 
    resolve_aggrfields(loc,env,fs);
    return;
  case &AppType(&AnonEnumCon(fs),_): 
    // FIX: absolutize names? create declarations? what scope? DO ME
    //  share code with Enum_d once we are sure what this means!
    let decl_ns_data = get_ns_data(env->ns,Abs_n(env->ns->curr_ns,
                                                 in_cinclude(env)));
    for(; fs != NULL; fs = fs->tl) {
      let f = fs->hd;
      if(f->tag != NULL)
	resolve_exp(env,(exp_t)f->tag);
      decl_ns_data->ordinaries = Dict::insert(decl_ns_data->ordinaries,(*f->name)[1],new AnonEnumRes(t,f));
    }
    return; 
  case &Evar(_,to,_,_): if(to != NULL) resolve_type(loc,env,(type_t)to); return;

  case &VarType(_):
  case &AppType(_,NULL): return;
  case &AppType(c,ts):
    for(; ts != NULL; ts = ts->tl)
      resolve_type(loc,env,ts->hd);
    return;

  case &PointerType(PtrInfo(t1,_,PtrAtts(t2,_,bds,_,_))):
    resolve_type(loc,env,t1);
    resolve_type(loc,env,t2);
    resolve_type(loc,env,bds);
    return;

  case &TupleType(tqts):
    for(; tqts!=NULL; tqts=tqts->tl)
      resolve_type(loc,env,(*tqts->hd)[1]);
    return;
  case &ArrayType(ArrayInfo(t1,_,eo,_,_)):
    resolve_type(loc,env,t1);
    if(eo!=NULL) resolve_exp(env,(exp_t)eo);
    return;
  case &FnType(*i):
    // FIX?: efficiency note: we do a lot of work for the very unusual case
    //       that there's a requires/ensures clause or a parameter type that
    //       mentions a parameter name
    let vds = get_fun_vardecls(false, loc, env, i->args, i->cyc_varargs);

    let old_locals = env->local_vars; // non-NULL only for nested functions
    if(old_locals != NULL) 
      env->local_vars = new *env->local_vars; // can refer to callers' vars
    else
      env->local_vars = new Dict::empty(strptrcmp);
    for(let vds1 = vds; vds1 != NULL; vds1 = vds1->tl)
      *env->local_vars = Dict::insert(*env->local_vars,(*vds1->hd->name)[1],
				      new VarRes(new Param_b(vds1->hd)));

    resolve_function_stuff(loc, env, i);
    env->local_vars = old_locals;
    return;

  case &ValueofType(e): fallthru(e);
  case &TypeofType(e): resolve_exp(env,e); return;
  }
}

void resolve_pat(env_t env, pat_t p) { // must not be at top-level
  let &Pat(r,_,loc) = p;
  switch(r) {
  case &UnknownId_p(qv): 
    try switch(lookup_ordinary(loc,env,qv)) {
    case &VarRes(_): break; // legal shadowing, same as BindingError
    case &AggrRes(_):
      err2(loc,"struct tag used without arguments in pattern"); return;
    case &DatatypeRes(tud,tuf):
      p->r = new Datatype_p(tud,tuf,NULL,false); return;
    case &EnumRes(ed,ef):
      p->r = new Enum_p(ed,ef); return;
    case &AnonEnumRes(t,ef):
      p->r = new AnonEnum_p(t,ef); return;
    } catch { case &BindingError: break; } // a new variable
    let vd = new_vardecl(0,qv,void_type,NULL); //type set later
    resolve_and_add_vardecl(loc,env,vd);
    p->r = new Var_p(vd, new_pat(&Wild_p_val,0));
    return;

  case &UnknownCall_p(qv,ps,dots):
    for(let ps2 = ps; ps2 != NULL; ps2 = ps2->tl)
      resolve_pat(env,ps2->hd);
    try switch(lookup_ordinary(loc,env,qv)) {
    case &VarRes(_): break; 
    case &AggrRes(ad):
      let new_ps = NULL;
      for(; ps != NULL; ps = ps->tl)
	new_ps = new List(new $(NULL,ps->hd), new_ps);
      p->r = new Aggr_p(new KnownAggr(new ad),NULL,imp_rev(new_ps),dots);
      return;
    case &DatatypeRes(tud,tuf):
      p->r = new Datatype_p(tud,tuf,ps,dots); return;
    case &EnumRes(_,_):
    case &AnonEnumRes(_,_):
      err2(loc,"enum tag used with arguments in pattern"); return;
    } catch { case &BindingError: break; }
    err2(loc, qv, " is not a constructor in pattern"); return;

  case &Aggr_p(&{.UnknownAggr= $(_,n,_)} , exist_ts, dps, dots):
    for(let dps2=dps; dps2 != NULL; dps2 = dps2->tl)
      resolve_pat(env,(*dps2->hd)[1]);
    try {
      let ad = resolve_lookup(loc,env->ns,n,lookup_aggrdecl);
      p->r = new Aggr_p(new KnownAggr(new ad), exist_ts, dps, dots);
    } catch { case &BindingError: 
       err2(loc, "non-aggregate name has designator patterns"); return;
    }
    return;

  case &Wild_p: return;

  case &Reference_p(vd,p2): fallthru(vd,p2);
  case &Var_p(vd,p2): // should be impossible like cases at bottom
    resolve_pat(env,p2);
    fallthru(vd);
  case &TagInt_p(_,vd): fallthru(vd);
  case &AliasVar_p(_,vd): // in AliasVar case, type may need resolving!
    resolve_and_add_vardecl(loc,env,vd); break;

  case &Pointer_p(p2): resolve_pat(env,p2); return;
  case &Tuple_p(ps,_):
    for(; ps != NULL; ps = ps->tl)
      resolve_pat(env,ps->hd);
    break;

  case &Exp_p(e): resolve_exp(env,e); return;

  case &Null_p:
  case &Int_p(...):
  case &Char_p(...):
  case &Float_p(...): return;

  case &Aggr_p(NULL,_,dps,_): 
    // have to resolve during type-checking with topt because we have no qvar
    fallthru(dps);
  case &Aggr_p(&{.KnownAggr = _},_,dps,_):
    for(; dps != NULL; dps = dps->tl)
      resolve_pat(env,(*dps->hd)[1]);
    return;
  case &Datatype_p(_,_,ps,_):
    for(; ps != NULL; ps = ps->tl)
      resolve_pat(env,ps->hd);
    return;
  case &Enum_p(...):
  case &AnonEnum_p(...): return;
  }
}

void resolve_rgnpo(seg_t loc, env_t env, list_t<$(type_t,type_t)@> po) {
  for(; po != NULL; po = po->tl) {
    resolve_type(loc,env,(*po->hd)[0]);
    resolve_type(loc,env,(*po->hd)[1]);
  }
}

//used for Dict::iter_c(f('c var_t resolved_t), 'c env, dict<var_t resolved_t 'r>)
//adds each symbol to the export list 
void export_all_symbols($(list_t<$(seg_t, qvar_t, bool)@>@, dict_t<var_t, resolved_t>@, env_t, $(seg_t, list_t<qvar_t>)@)@ cenv,
			var_t name, resolved_t res) {
  let &$(exlist_ptr, out_dict, env, &$(wcloc, hidelist)) = cenv;
  switch(res) {
  case &VarRes(bnd):
    qvar_t qv = new $(Rel_n(NULL), name);
    if(List::mem(qvar_cmp, hidelist, qv)) {
      //      fprintf(stderr, "Skipping qvar %s because of hidelist\n", Absynpp::qvar2string(qv));
      return;
    }
    absolutize_decl(wcloc,env,qv,ExternC);
    let ex_sym = new $(wcloc, qv, false);
    *exlist_ptr = new List(ex_sym, *exlist_ptr);
    *out_dict = Dict::insert(*out_dict, name, res);
    break;
  case &EnumRes(ed, ef):
    *out_dict = Dict::insert(*out_dict, name, res);
    break;
    //the types below are exported by default ... no need to add them
  case &AggrRes(ad): 
    *out_dict = Dict::insert(*out_dict, name, res);
    break;
  case &AnonEnumRes(t, ef): 
    break;
  case &DatatypeRes(dd, df): //impos for extern C
    err(wcloc, "Unexpected binding from extern C Include");
    break;
  }
}


// FIX: return table of used binders or something, for treeshaking, which
//      we do post type-checking so we don't squash errors
// Also, why not just return a flat-list (truly nuking Namespace, Using,
// and ExternC and ExternCinclude (maybe not the last one)
// then later passes can just throw an exception on them

// FIX: need to predefine exception as in TCenv::tc_init
void resolve_decl(env_t env, decl_t d) {
  // because qualified declarations are unimplemented, every declaration
  // will go in the current namespace, but this function does not assume that
  seg_t loc = d->loc;
  switch(d->r) {

  case &Var_d(vd): 
    resolve_and_add_vardecl(loc,env,vd);
    // variable is in scope of its initializer, as in C
    // for "extern C", typechecker will reject any initializer anyway
    // for "extern C include", we have the bizarre "semantics" of looking at
    // the type but not the initializer.
    if(vd->initializer != NULL && !in_cinclude(env))
      resolve_exp(env,(exp_t)vd->initializer);
    break;

  case &Fn_d(fd): //should never be in cyc_override
    if(env->in_cyc_override) 
      err2(loc, "Function declaration not permitted within cyclone_override block");
    absolutize_decl(loc,env,fd->name,fd->sc);
    let &$(decl_ns,decl_name) = fd->name;
    let argit = fd->i.args;
    let vds = get_fun_vardecls(true, loc, env, fd->i.args, fd->i.cyc_varargs);
    fd->param_vardecls = new Core::Opt(vds);

    if(Flags::warn_override) // need to do before changing env->local_vars
      check_warn_override(loc,env,fd->name);

    let old_locals = env->local_vars; // non-NULL only for nested functions
    if(old_locals != NULL) 
      env->local_vars = new *env->local_vars; // can refer to callers' vars
    else
      env->local_vars = new Dict::empty(strptrcmp);
    for(let vds1 = vds; vds1 != NULL; vds1 = vds1->tl)
      *env->local_vars = Dict::insert(*env->local_vars,(*vds1->hd->name)[1],
				      new VarRes(new Param_b(vds1->hd)));

    resolve_function_stuff(loc, env, &fd->i);

    if(old_locals != NULL) { 
      // in scope of inner and outer function
      *old_locals = Dict::insert(*old_locals, decl_name, 
				 new VarRes(new Funname_b(fd)));
      *env->local_vars = Dict::insert(*env->local_vars, decl_name, 
				      new VarRes(new Funname_b(fd)));
    } else {
      let decl_ns_data = get_ns_data(env->ns,decl_ns);
      decl_ns_data->ordinaries = Dict::insert(decl_ns_data->ordinaries,
					      decl_name,
					      new VarRes(new Funname_b(fd)));
    }

    if(!in_cinclude(env)) // extern "C" and "C include" ignores code
      resolve_stmt(env,fd->body);

    env->local_vars = old_locals;
    break;

  case &Let_d(p,_,exp,_): // leave it to tcpat mess to set vds field
    if(at_toplevel(env)) {
      err2(loc,"let not allowed at top-level");
      break;
    }
    resolve_exp(env,exp);
    resolve_pat(env,p); // resolves patterns and adds bindings
    break;

  case &Letv_d(vds):  
    for(; vds != NULL; vds = vds->tl)
      resolve_and_add_vardecl(loc,env,vds->hd);
    break;

  case &Region_d(tv,vd,open_exp_opt): 
    if(open_exp_opt != NULL)
      resolve_exp(env,(exp_t)open_exp_opt);
    resolve_and_add_vardecl(loc,env,vd);
    break; 

  case &Typedef_d(td): // DJG: I think extern_c is always false at this stage
    if (!at_toplevel(env)) {
      err2(loc,"nested type definitions are not yet supported");
      break;
    }
    absolutize_decl(loc,env,td->name, (td->extern_c ?  ExternC : Public));
    let &$(decl_ns,decl_name) = td->name;

    let decl_ns_data = get_ns_data(env->ns,decl_ns);
    if(td->defn != NULL)
      resolve_type(loc,env,(type_t)td->defn);
    // type-checker rejects redeclared typedef, but not our concern
    if(!env->in_cyc_override) {
      decl_ns_data->typedefs = Dict::insert(decl_ns_data->typedefs,
					    decl_name, td);
    }
    break;

  case &Aggr_d(ad): 
    if (!at_toplevel(env)) {
      err2(loc,"nested type definitions are not yet supported");
      break;
    }
    absolutize_decl(loc,env,ad->name,ad->sc);
    let &$(decl_ns,decl_name) = ad->name;

    let decl_ns_data = get_ns_data(env->ns,decl_ns);
    // ignore abstract-after-concrete
    if(Dict::member(decl_ns_data->aggrdecls,decl_name) && ad->impl==NULL)
      break;
    // otherwise just add aggrdecl and constructor, and resolve fields
    if(!env->in_cyc_override) {
      decl_ns_data->aggrdecls = Dict::insert(decl_ns_data->aggrdecls,
					     decl_name, ad);
      decl_ns_data->ordinaries = Dict::insert(decl_ns_data->ordinaries,
					      decl_name, new AggrRes(ad));
    }
    if(ad->impl != NULL) {
      let &AggrdeclImpl(_,rpo,fs,_) = (struct AggrdeclImpl@)ad->impl;
      resolve_rgnpo(loc,env,rpo);
      resolve_aggrfields(loc,env,fs);
    }
    break;

  case &Enum_d(ed): 
    if (!at_toplevel(env)) {
      err2(loc,"nested type definitions are not yet supported");
      break;
    }
    absolutize_decl(loc,env,ed->name,ed->sc);
    let &$(decl_ns,decl_name) = ed->name;

    let decl_ns_data = get_ns_data(env->ns,decl_ns);
    // ignore abstract-after-concrete
    if(Dict::member(decl_ns_data->enumdecls,decl_name) && ed->fields==NULL)
      break;
    // otherwise just add enumdecl and absolutized fields.
    // type-chcecker ensures any redeclaration is redundant
    if(!env->in_cyc_override) 
      decl_ns_data->enumdecls = Dict::insert(decl_ns_data->enumdecls,
					     decl_name, ed);
    if(ed->fields != NULL)
      // tags can refer to earlier fields
      for(_ fs = ed->fields->v; fs != NULL; fs = fs->tl) {
	let f = fs->hd;
	absolutize_decl(f->loc,env,f->name,ed->sc);
	if(f->tag != NULL)
	  resolve_exp(env,(exp_t)f->tag);
	if(!env->in_cyc_override) 
	  decl_ns_data->ordinaries = Dict::insert(decl_ns_data->ordinaries,
						  (*f->name)[1], 
						  new EnumRes(ed,f));
      }
    break;

  case &Datatype_d(tud): 
    // see tc.cyc, line 876 for why we do a lookup first...
    try {
      let decls = resolve_lookup(loc,env->ns,tud->name,lookup_datatypedecl);
      let last_decl = decls->hd; // most recent is at head but doesn't matter
      if(!last_decl->is_extensible)
	throw new BindingError;
      tud->name          = last_decl->name;
      tud->is_extensible = true;
      let &$(decl_ns,decl_name) = tud->name;
      let decl_ns_data = get_ns_data(env->ns,decl_ns);
      decl_ns_data->datatypedecls = Dict::insert(decl_ns_data->datatypedecls,
						 decl_name,new List(tud,decls));
    } catch { 
    case &BindingError: 
      absolutize_topdecl(loc,env,tud->name,tud->sc); 
      let &$(decl_ns,decl_name) = tud->name;
      let decl_ns_data = get_ns_data(env->ns,decl_ns);
      // ignore abstract-after-concrete (for non-extensible)
      if(Dict::member(decl_ns_data->datatypedecls,decl_name) 
	 && tud->fields==NULL)
	break;
      decl_ns_data->datatypedecls = Dict::insert(decl_ns_data->datatypedecls,
						 decl_name,new List(tud,NULL));
      break;
    }
    // we have already added the decl, so now process fields
    let &$(decl_ns,decl_name) = tud->name;
    if(tud->fields != NULL)
      for(let fs = tud->fields->v; fs != NULL; fs = fs->tl) {
	let f = fs->hd;
	for(let tqts = f->typs; tqts != NULL; tqts = tqts->tl)
	  resolve_type(loc,env,(*tqts->hd)[1]);
	switch((*f->name)[0]) {
	case {.Rel_n = NULL}:
	  if(tud->is_extensible)
	    (*f->name)[0] = Abs_n(env->ns->curr_ns, false);
	  else
	    (*f->name)[0] = (*tud->name)[0];
	  break;
	case {.Rel_n = _}:
	  err2(f->loc,"qualified datatype field declarations not allowed");
	  return;
	case {.Abs_n = _}: break;
	default: impos("datatype field Loc_n or C_n");
	}
	let ns_data = get_ns_data(env->ns,(*f->name)[0]);
	ns_data->ordinaries = Dict::insert(ns_data->ordinaries,
					   (*f->name)[1],
					   new DatatypeRes(tud,f));
      }
    break; 

  case &Namespace_d(v,ds2):
    enter_ns(env->ns,v,true,mt_renv);
    resolve_decls(env,ds2);
    leave_ns(env->ns);
    break;
  case &Using_d(qv,ds2): // qv a parsing quirk -- it isn't a qv
    enter_using(d->loc,env->ns,qv);
    resolve_decls(env,ds2);
    leave_using(env->ns);
    break;

  case &ExternC_d(ds2): 
    let old = env->in_cinclude;
    env->in_cinclude = true;
    resolve_decls(env,ds2);
    env->in_cinclude = old;
    break;

    // for externCInclude, we warn on exported-but-not-defined
    // and only resolved the binding if it is exported
    // I don't think types can be exported, just variables and functions
    // (for extern "C" it's like "export everything")
  case &ExternCinclude_d(ds2,ovrs,*exports,hides):  //<-----need to handle wc case 
    for(let exs = *exports; exs != NULL; exs = exs->tl) {
      let &$(loc,qv,_) = exs->hd;
      absolutize_decl(loc,env,qv,ExternC);
    }
    // this is not how Greg did exports, but this makes more sense, and should
    // be equivalent when extern "C include" is not nested.  And for parsing
    // reasons, it's impossible to have namespace, using, or nested exports
    // inside an extern "C include"
    if(!at_toplevel(env)) {
      err2(loc,"extern \"C include\" not at toplevel");
      break;
    }
    let data = Dict::lookup(env->ns->ns_data,env->ns->curr_ns);
    let old_dict = data->ordinaries;
    let old = env->in_cinclude;
    env->in_cinclude = true;
    resolve_decls(env,ds2);
    env->in_cyc_override = true; //i.e don't export symbols to the dictionary
    resolve_decls(env,ovrs); //want to resolve bindings but not export new symbols -- o.w shared bindings are busted
    env->in_cyc_override = false;
    let new_dict = data->ordinaries;
    let out_dict = old_dict;
    if((*hides)[0] > 0) { //wildcard case -- export all symbols in new_dict
      if(*exports)
	err((*hides)[0], "export wildcard expects empty export list");
      env->in_cinclude = old;
      Dict::iter_c(export_all_symbols, new $(exports, &out_dict, env, hides), 
		   Dict::difference(new_dict, old_dict));
    }
    else {
      for (let exs = *exports; exs != NULL; exs = exs->tl) {
	let &$(loc,&$(_,v),_) = exs->hd;
	if(!Dict::member(new_dict,v)
	   || (Dict::member(old_dict,v) &&
	       (Dict::lookup(old_dict,v)==Dict::lookup(new_dict,v))))
	  err(loc,"%s is exported but not defined",*v);
	out_dict = Dict::insert(out_dict,v,Dict::lookup(new_dict,v));
      }
    }
    data->ordinaries = out_dict;
    env->in_cinclude = old;

    // FIX: this should go in a separate pass
    //    Cifc::user_overrides(loc,ds2,ovrs);
    break;

  case &Porton_d: // let Tc warn for now
  case &Portoff_d: 
  case &Tempeston_d:
  case &Tempestoff_d: break;
  }
}

void resolve_decls(env_t env, list_t<decl_t> tds) {
  for(; tds != NULL; tds = tds->tl)
    resolve_decl(env,tds->hd);
}

void resolve_all(list_t<Absyn::decl_t,`H> tds) {
  let env = new Env(false,false,mt_nsctxt(true,mt_renv),NULL);
  resolve_decl(env, new Decl(new Datatype_d(exn_tud()),0));
  resolve_decls(env, tds);
}
