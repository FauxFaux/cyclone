// Main file

#include "arg.h"
#include "core.h"
#include "stdio.h"
#include "list.h"
#include "string.h"
#include "dict.h"
#include "filename.h"
#include "id.h"
#include "parse.h"
#include "position.h"
#include "absyn.h"
#include "absynpp.h"
#include "absyndump.h"
#include "tcutil.h"
#include "tcenv.h"
#include "tc.h"
#include "control_flow.h"
#include "toc.h"

namespace Lex {
extern void lex_init();
}

using Core;
using Stdio;
using List;
using Arg;
using String;

#define PRINT_STAGE(s) { if (*v) fprintf(stderr,s); else if (!*q) fprintf(stderr,"."); fflush(stderr); }

static bool pp_r       = false;
static bool up_r       = false;
static bool noexpand_r = false;
static bool noshake_r  = false;
static bool tc_r       = false;
static bool toc_r      = false;
static bool v_r        = false;
static bool q_r        = false;
static bool add_cyc_namespace_r = true;

bool @ pp       = &pp_r;
bool @ up       = &up_r;
bool @ noexpand = &noexpand_r;
bool @ noshake  = &noshake_r;
bool @ tc       = &tc_r;
bool @ toc      = &toc_r;
bool @ v        = &v_r;
bool @ q        = &q_r;
bool @ add_cyc_namespace = &add_cyc_namespace_r;

static string *out_file_name_opt = null;

static void set_check_null() {
  Toc::check_for_null = true;
}

static void set_out_file_name(string s) {
  out_file_name_opt = (string *)(&$(s));
}
static list_t<stringptr> includes = null;
static void add_include(string s) {
  includes = &List((stringptr)new {s},includes);
}
static list_t<stringptr> defines = null;
static void add_define(string s) {
  defines = &List((stringptr)new {s},defines);
}

bool compile_failure = false; // for exit code (helps Makefile)

void compile_file(string filename) {

  Lex::lex_init(); // must forget typedefs, may as well flush symbols too

  string basename = Filename::chop_extension(filename);

  if (!*q||*v) fprintf(stderr,"Compiling file: %s", basename);
  if (*v) fprintf(stderr,"\n");

  // establish filenames
  string preprocfile = strconcat(basename,  ".i");

  // Run the preprocessor, by building and running a command-line
  // Pass -I and -D things onto pre-processor
  string inc_string = 
    String::str_sepstr(&List(new {""},rev(includes))," -I");
  string def_string = 
    String::str_sepstr(&List(new {""},rev(defines)), " -D");
  // check that the input file exists
  try {
    FILE @f0 = file_open(filename, "r");
    fclose(f0);
  } catch {
  default: 
    fprintf(stderr, "\nError:  can't find input file %s", filename);
    compile_failure = true;
    return;
  }
  string cmd = xprintf("gcc -x c -E -U__GNUC__ %s %s %s > %s",
                       inc_string, def_string, filename, preprocfile);
  if (*v) fprintf(stderr,"%s\n",cmd);
  if (system(string_to_Cstring(cmd)) != 0) {
    fprintf(stderr,"\nError: pre-processing failed!\n");
    compile_failure = true;
    return;
  }

  // reset front-end -- necessary for good error messages!
  Position::reset_position(preprocfile);

  // Actually process the file
  FILE @f;
  try f = file_open(preprocfile, "r");
  catch {
  default:
    fprintf(stderr, "\nError: couldn't open %s\n", preprocfile);
    compile_failure = true;
    return;
  }

  // parse
  list_t<Absyn::decl> tds = null;
  try {
    tds = Parse::parse_file(f);
  } catch {
  default:
    compile_failure = true; break;
  }
  file_close(f);
  if (compile_failure || Position::error_p()) {
    compile_failure=true;
    Stdio::remove(preprocfile);
    return;
  }
  PRINT_STAGE("Parsing completed\n");
  fflush(stderr);
  // typecheck
  if (tds != null && *tc) try {
    Absynpp::expand_typedefs = ! *noexpand;
    Tcenv::tenv te = Tcenv::tc_init();
    Tc::tc(te, add_cyc_namespace_r, tds);
    if(! *noshake)
      tds = Tc::treeshake(te,tds);
    PRINT_STAGE("Type checking completed.\n");
    if (Position::error_p()) {
      compile_failure=true;
      Stdio::remove(preprocfile);
      return;
    }
    ControlFlow::cf_check(tds);
    PRINT_STAGE("Control-flow checking completed.\n");
    if (Position::error_p()) {
      compile_failure = true;
      Stdio::remove(preprocfile);
      return;
    }
  } catch {
  case Impossible(s):
    fprintf(stderr,"\nImpossible during type-checking: %s\n", s); 
    fflush(stderr);
    compile_failure=true;
    Stdio::remove(preprocfile);
    return;
  case x:
    fprintf(stderr,"\nUncaught exception during type-checking\n"); 
    fflush(stderr);
    compile_failure=true;
    Stdio::remove(preprocfile);
    throw(x);
  }
  // translate to C
  try {
    if (*toc && !compile_failure) {
      tds = Toc::toc(tds); 
      PRINT_STAGE("Translation to C completed\n");
    }
  } catch {
  case Impossible(s):
    fprintf(stderr,"\nImpossible during translation: %s\n", s); fflush(stderr);
    compile_failure=true;
    Stdio::remove(preprocfile);
    return;
  default:
    fprintf(stderr,"\nUncaught exception during translation\n"); 
    fflush(stderr);
    compile_failure=true;
    Stdio::remove(preprocfile);
    return;
  }
  // print
  FILE @out_file;
  try {
    if (out_file_name_opt == null)
      out_file = stdout;
    else 
      out_file = file_open(*out_file_name_opt, "w");
  } catch {
  case FileOpenError(_): 
    fprintf(stderr,"\nCould not open output file: %s\n",*out_file_name_opt);
    fflush(stderr);
    Stdio::remove(preprocfile);
    compile_failure=true;
    return;
  }
  if (tds != null && !compile_failure && (*pp || *up)) {
    Absynpp::expand_typedefs = ! *noexpand;
    if (*toc) {
      fprintf(out_file, "#include \"cyc_include.h\"\n\n");
      Absynpp::qvar_to_Cids = true;
    }
    if(*pp)
      Absynpp::decllist2file(tds,out_file);
    else if(*up)
      Absyndump::dumpdecllist2file(tds,out_file);
    fflush(out_file);
    PRINT_STAGE("Printing completed\n");
    if (!(*v || *q)) fprintf(stderr,"\n"); // for "...." progress indicator
  }
  if (Position::error_p()) {
    fprintf(stderr,"COMPILATION FAILED!\n");
    fflush(stderr);
    Stdio::remove(preprocfile);
    compile_failure=true;
  } else {
    Tcutil::flush_warnings();
  }
  // I believe this duplicate file_close is the cause of the segfault -- Jeff
  // FIX: However, trying to close a file twice should not cause a segfault
  // file_close(f);
  Stdio::remove(preprocfile);
  if (out_file_name_opt != null) file_close(out_file);
  return;
}

int main() {
  $(string,spec_t,string) specs[13] = 
                {$("-nocyc",Clear_spec(add_cyc_namespace),
		   "does not add implicit namespace Cyc"),
		 $("-q",Set_spec(q),
		   "compile quietly"),
		 $("-v",Set_spec(v), 
		   "print compilation stages verbosely"),
		 $("-check_null",Unit_spec(set_check_null), 
		   "turn on null-checking in generated C code"),
		 $("-D",String_spec(add_define), 
		   "pass definition to pre-processor"),
		 $("-I",String_spec(add_include), 
		   "include directory"), 
		 $("-toc",Set_spec(toc), 
		   "translate to C"),
		 $("-tc",Set_spec(tc), 
		   "type check"),
		 $("-noremoveunused",Set_spec(noshake),
		   "don't remove externed variables that aren't used"),
		 $("-noexpandtypedefs",Set_spec(noexpand),
		   "don't expand typedefs in pretty printing"),
		 $("-up",Set_spec(up), 
		   "ugly print"),
		 $("-pp",Set_spec(pp), 
		   "pretty print"),
		 $("-o",String_spec(set_out_file_name),
		 "output file name")};
  let l1  = List(&specs[0], null);
  let l2  = List(&specs[1], &l1);
  let l3  = List(&specs[2], &l2);
  let l4  = List(&specs[3], &l3);
  let l5  = List(&specs[4], &l4);
  let l6  = List(&specs[5], &l5);
  let l7  = List(&specs[6], &l6);
  let l8  = List(&specs[7], &l7);
  let l9  = List(&specs[8], &l8);
  let l10 = List(&specs[9], &l9);
  let l11 = List(&specs[10],&l10);
  let l12 = List(&specs[11],&l11);
  let l13 = List(&specs[12],&l12);
  let options = &l13;
		 
  Arg::parse(options, compile_file, "Options:");

  return compile_failure ? 1 : 0;
}

