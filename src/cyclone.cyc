// Main file

#include "arg.h"
#include "core.h"
#include "stdio.h"
#include "list.h"
#include "string.h"
#include "dict.h"
#include "filename.h"
#include "id.h"
#include "parse.h"
#include "position.h"
#include "absyn.h"
#include "absynpp.h"
#include "absyndump.h"
#include "tcutil.h"
#include "tcenv.h"
#include "tc.h"
#include "toc.h"
#include "new_control_flow.h"

namespace Lex {
extern void lex_init();
}
using Core;
using Stdio;
using List;
using Arg;
using String;

static bool pp_r       = false;
static bool up_r       = false;
static bool noexpand_r = false;
static bool noshake_r  = false;
static bool tc_r       = false;
static bool toc_r      = false;
static bool v_r        = false;
static bool q_r        = false;
static bool add_cyc_namespace_r = true;
bool @ pp       = &pp_r;
bool @ up       = &up_r;
bool @ noexpand = &noexpand_r;
bool @ noshake  = &noshake_r;
bool @ tc       = &tc_r;
bool @ toc      = &toc_r;
bool @ v        = &v_r;
bool @ q        = &q_r;
bool @ add_cyc_namespace = &add_cyc_namespace_r;

static string *out_file_name_opt = null;
static void set_out_file_name(string s) {
  out_file_name_opt = (string *)(new s);
}
static void set_check_null() {
  Toc::check_for_null = true;
}
static list_t<stringptr> includes = null;
static void add_include(string s) {
  includes = new List(new s,includes);
}
static list_t<stringptr> defines = null;
static void add_define(string s) {
  defines = new List(new s,defines);
}

bool compile_failure = false; // for exit code (helps Makefile)

FILE * try_file_open(string filename, string mode, string msg_part) {
  try return file_open(filename,mode);
  catch {
  default:
    compile_failure = true;
    fprintf(stderr, "\nError: couldn't open %s %s\n", msg_part, filename);
    fflush(stderr);
    return null;
  }
}

list_t<Absyn::decl> do_stage(string stage_name,
			     list_t<Absyn::decl> f(`a, list_t<Absyn::decl>), 
			     `a env, list_t<Absyn::decl> tds, 
			     string preprocfile) {
  string exn_string     = "";
  string explain_string = "";
  bool other_exn = false;
  xenum exn ex = Core::Impossible(""); // definite assignment doesn't track data
  let ans = null;

  try ans = f(env,tds);
  catch {
  case Core::Impossible(s): 
    exn_string = "Exception Core::Impossible"; 
    explain_string = s; 
    break;
  case Dict::Absent:  
    exn_string = "Exception Dict::Absent"; 
    break;
  case x: 
    ex = x; 
    other_exn = true; 
    exn_string = "Uncaught exception"; 
    break;
    }
  if(Position::error_p())
    compile_failure = true;
  if(strcmp(exn_string,"") != 0) {
    compile_failure = true;
    fprintf(stderr,"\n%s thrown during %s: %s", 
	    exn_string, stage_name, explain_string);
  }
  if(compile_failure) {
    fprintf(stderr,"\nCOMPILATION FAILED!\n");
    fflush(stderr);
    Stdio::remove(preprocfile);
    if(other_exn)
      throw ex;
    return ans;
  }
  if(*v)
    fprintf(stderr,"%s completed.\n",stage_name);
  else if(!*q)
    fprintf(stderr,".");
  fflush(stderr);
  return ans;
}
list_t<Absyn::decl> do_parse(FILE @ f, list_t<Absyn::decl> ignore) {
  Lex::lex_init(); // must forget typedefs, may as well flush symbols too
  return Parse::parse_file(f);
}
list_t<Absyn::decl> do_typecheck(Tcenv::tenv te, list_t<Absyn::decl> tds) {
  Absynpp::expand_typedefs = ! *noexpand;
  Tc::tc(te,add_cyc_namespace_r && toc_r,tds); //don't add namespaces if we don't translate to C
  if(!*noshake)
    tds = Tc::treeshake(te,tds);
  return tds;
}
list_t<Absyn::decl> do_cfcheck(bool ignore, list_t<Absyn::decl> tds) {
  NewControlFlow::cf_check(tds);
  return tds;
}
list_t<Absyn::decl> do_translate(bool ignore, list_t<Absyn::decl> tds) {
  return Toc::toc(tds);
}
list_t<Absyn::decl> do_print(FILE @ out_file, list_t<Absyn::decl> tds) {
  Absynpp::expand_typedefs = ! *noexpand;
  Absynpp::decls_first = Absynpp::qvar_to_Cids = *toc;
  Absynpp::print_using_stmts = Absynpp::print_externC_stmts = ! *tc;
  // if the type-checking has already been done, then there's no need for
  // the 'Using' statements, nor for the extern "C" {...}

  if (*toc) {
    fprintf(out_file, "#include \"cyc_include.h\"\n\n");
    Absynpp::qvar_to_Cids = true;
  }
  if(*pp)
    Absynpp::decllist2file(tds,out_file);
  else if(*up)
    Absyndump::dumpdecllist2file(tds,out_file);
  fflush(out_file);
  return tds;
}

void compile_file(string filename) {

  string basename    = Filename::chop_extension(filename);
  string preprocfile = strconcat(basename, ".i");

  if (!*q||*v) fprintf(stderr,"Compiling file: %s", basename);
  if (*v) fprintf(stderr,"\n");

  // Run the preprocessor, by building and running a command-line
  // Pass -I and -D things onto pre-processor
  string inc_string = String::str_sepstr(new List(new "",
                                                  rev(includes))," -I");
  string def_string = String::str_sepstr(new List(new "",
                                                  rev(defines)), " -D");
  // check that the input file exists
  FILE * f0 = try_file_open(filename, "r", "input file");
  if(compile_failure)
    return;
  fclose((FILE @)f0);
  // actually make the command call
  string cmd = xprintf("gcc -x c -E -U__GNUC__ %s %s %s > %s",
                       inc_string, def_string, filename, preprocfile);
  if (*v) fprintf(stderr,"%s\n",cmd);
  if (system(string_to_Cstring(cmd)) != 0) {
    compile_failure = true;
    fprintf(stderr,"\nError: pre-processing failed!\n");
    return;
  }

  Position::reset_position(preprocfile); // necessary for good error messages!

  // Actually process the file
  FILE * in_file  = try_file_open(preprocfile,"r","file");
  FILE * out_file = stdout; // possibly changed below
  if(compile_failure)
    return;
  list_t<Absyn::decl> tds = null;
  if(!compile_failure) {
    tds = do_stage("parsing", do_parse, (FILE@)in_file, tds,
		   preprocfile);
    file_close((FILE@)in_file); // won't happen if exception is thrown
  }
  if(!compile_failure && tds != null && *tc)
    tds = do_stage("type checking", do_typecheck, Tcenv::tc_init(), tds,
		   preprocfile);
  if(!compile_failure && *tc)
    tds = do_stage("control-flow checking", do_cfcheck, true, tds,
		   preprocfile);
  if(!compile_failure && *toc)
    tds = do_stage("translation to C", do_translate, true, tds,
		   preprocfile);
  if(!compile_failure && out_file_name_opt != null)
    out_file = try_file_open(*out_file_name_opt, "w", "output file");
  if(!compile_failure && tds != null && (*pp || *up))
    tds = do_stage("printing", do_print, (FILE @)out_file, tds,
		   preprocfile);
  if (out_file != null && out_file != stdout) 
    file_close((FILE @)out_file); // won't happen if exception is thrown
  fprintf(stderr,"\n"); 
  if(!compile_failure)
    Tcutil::flush_warnings();
  Stdio::remove(preprocfile);
  return;
}

int main() {
  $(string,spec_t,string) specs[15] = 
    {$("-nocyc",Clear_spec(add_cyc_namespace),
       "does not add implicit namespace Cyc"),
     $("-q",Set_spec(q),
       "compile quietly"),
     $("-v",Set_spec(v), 
       "print compilation stages verbosely"),
     $("-check_null",Unit_spec(set_check_null), 
       "turn on null-checking in generated C code"),
     $("-D",String_spec(add_define), 
       "pass definition to pre-processor"),
     $("-I",String_spec(add_include), 
       "include directory"), 
     $("-toc",Set_spec(toc), 
       "translate to C"),
     $("-tc",Set_spec(tc), 
       "type check"),
     $("-noremoveunused",Set_spec(noshake),
       "don't remove externed variables that aren't used"),
     $("-noexpandtypedefs",Set_spec(noexpand),
       "don't expand typedefs in pretty printing"),
     $("-printalltvars", Set_spec(&Absynpp::print_all_tvars),
       "print all type variables (even implicit default effects)"),
     $("-printallkinds", Set_spec(&Absynpp::print_all_kinds),
       "always print kinds of type variables"),
     $("-up",Set_spec(up), 
       "ugly print"),
     $("-pp",Set_spec(pp), 
       "pretty print"),
     $("-o",String_spec(set_out_file_name),
       "Output file name")};
  let l1  = List(&specs[0], null);
  let l2  = List(&specs[1], &l1);
  let l3  = List(&specs[2], &l2);
  let l4  = List(&specs[3], &l3);
  let l5  = List(&specs[4], &l4);
  let l6  = List(&specs[5], &l5);
  let l7  = List(&specs[6], &l6);
  let l8  = List(&specs[7], &l7);
  let l9  = List(&specs[8], &l8);
  let l10 = List(&specs[9], &l9);
  let l11 = List(&specs[10],&l10);
  let l12 = List(&specs[11],&l11);
  let l13 = List(&specs[12],&l12);
  let l14 = List(&specs[13],&l13);
  let l15 = List(&specs[14],&l14);
  let options = &l15;
		 
  Arg::parse(options, compile_file, "Options:");

  return compile_failure ? 1 : 0;
}
