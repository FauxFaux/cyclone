// Main file

#include <arg.h>
#include <core.h>
#include <stdio.h>
#include <stdlib.h>
#include <list.h>
#include <string.h>
#include <dict.h>
#include <filename.h>
#include <id.h>
#include "parse.h"
#include <position.h>
#include "absyn.h"
#include "absynpp.h"
#include "absyndump.h"
#include "tcutil.h"
#include "tcenv.h"
#include "tc.h"
#include "toc.h"
#include "tovc.h"
#include "new_control_flow.h"
#include "interface.h"

namespace Lex {
  extern void lex_init();
}
using Core;
using Stdio;
using List;
using Arg;
using String;

static bool pp_r       = false;
static bool noexpand_r = false;
static bool noshake_r  = false;
static bool stop_after_cpp_r = false;
static bool parseonly_r = false;
static bool tc_r       = false;
static bool ic_r       = false;
static bool toc_r      = false;
static bool stop_after_objectfile_r = false;
static bool stop_after_asmfile_r = false;
static bool tovc_r     = false;
static bool v_r        = false;
static bool save_temps_r = false;
static bool save_c_r   = false;
static bool nogc_r   = false;
static bool add_cyc_namespace_r = true;
static bool print_full_evars_r = false;
static bool print_all_tvars_r = false;
static bool print_all_kinds_r = false;

static string_t *output_file = null;
static void set_output_file(string_t s) {
  output_file = new s;
}

static list_t<stringptr_t> cppargs = null;
static void add_cpparg(string_t s) {
  cppargs = new List(new s,cppargs);
}

static bool is_cyclone_sourcefile(string_t s) {
  let len = strlen(s);
  if (len <= 4) return false;
  else return (strcmp(s+(len-4),".cyc") == 0);
}

static list_t<stringptr_t> cyclone_exec_prefix_path = null;
static void add_cyclone_exec_prefix_path(string_t s) {
  let len = strlen(s);
  if (len <= 2) return;
  let dir = (string_t)substring(s,2,len-2);
  cyclone_exec_prefix_path = new List(new dir,cyclone_exec_prefix_path);
}

// Arguments to pass to the C compiler
static list_t<stringptr_t> ccargs = null;
static void add_ccarg(string_t s) {
  ccargs = new List(new s,ccargs);
}
static void add_ccarg2(string_t flag,string_t arg) {
  ccargs = new List(new arg, new List(new flag,ccargs));
}

// Ideally we would simply pass library args as ccargs, preserving
// their order with the other ccargs.  But if, e.g., -lm precedes
// cyclib.a, then we get a "multiple definitions of main" error, via
// libmain.c.  So, we separate out the library args from the ccargs
// so that we can force cyclib.a to appear first.
static list_t<stringptr_t> libargs = null;
static void add_libarg(string_t s) {
  libargs = new List(new s,libargs);
}

static void set_save_temps() {
  save_temps_r = true;
  add_ccarg("-save-temps");
}

static bool produce_dependencies = false;
static void set_produce_dependencies() {
  stop_after_cpp_r = true;
  produce_dependencies = true;
  add_cpparg("-M");
}

static string_t *dependencies_target = null;
static void set_dependencies_target(string_t s) {
  dependencies_target = new s;
}

static void set_stop_after_objectfile() {
  stop_after_objectfile_r = true;
  add_ccarg("-c");
}

static void set_stop_after_asmfile() {
  stop_after_asmfile_r = true;
  add_ccarg("-S");
}

// Cyclone files given on the command line
static list_t<stringptr_t> cyclone_files = null;
// Like add_ccarg but intercepts .cyc files for special handling
static void add_other(string_t s) {
  if (is_cyclone_sourcefile(s)) {
    // For processing by Cyclone
    cyclone_files = new List(new s,cyclone_files);

    // The C compiler wants the .c file, not the .cyc files
    let basename = Filename::chop_extension(s);
    let cfile    = strconcat(basename, ".c");
    add_ccarg(cfile);
  }
  else add_ccarg(s);
}

static void remove_file(string_t s) {
  if (save_temps_r) return;
  else Stdio::remove(s);
}

bool compile_failure = false; // for exit code (helps Makefile)

FILE * try_file_open(string_t filename, string_t mode, string_t msg_part) {
  try return file_open(filename,mode);
  catch {
  default:
    compile_failure = true;
    fprintf(stderr, "\nError: couldn't open %s %s\n", msg_part, filename);
    fflush(stderr);
    return null;
  }
}

list_t<Absyn::decl_t>
  do_stage(string_t stage_name,
           list_t<Absyn::decl_t> f(`a, list_t<Absyn::decl_t>),
           `a env, list_t<Absyn::decl_t> tds) {
  string_t exn_string     = "";
  string_t explain_string = "";
  bool other_exn = false;
  xtunion exn ex = new Core::Impossible(""); // definite assignment doesn't track data
  let ans = null;

  try ans = f(env,tds);
  catch {
  case &Core::Impossible(s):
    exn_string = "Exception Core::Impossible";
    explain_string = s;
    break;
  case Dict::Absent:
    exn_string = "Exception Dict::Absent";
    break;
  case &InvalidArg(s):
    exn_string = "Exception Core::InvalidArg";
    explain_string = s;
    break;
  case x:
    ex = x;
    other_exn = true;
    exn_string = "Uncaught exception";
    break;
    }
  if (Position::error_p())
    compile_failure = true;
  if (strcmp(exn_string,"") != 0) {
    compile_failure = true;
    fprintf(stderr,"\n%s thrown during %s: %s",
	    exn_string, stage_name, explain_string);
  }
  if (compile_failure) {
    fprintf(stderr,"\nCOMPILATION FAILED!\n");
    fflush(stderr);
    if (other_exn)
      throw ex;
    return ans;
  }
  else if (v_r) {
    fprintf(stderr,"%s completed.\n",stage_name);
    fflush(stderr);
    return ans;
  }
  return ans;
}

list_t<Absyn::decl_t> do_parse(FILE @ f, list_t<Absyn::decl_t> ignore) {
  Lex::lex_init(); // must forget typedefs, may as well flush symbols too
  let ans = Parse::parse_file(f);
  Lex::lex_init(); // garbage collect those big tries
  return ans;
}

list_t<Absyn::decl_t> do_typecheck(Tcenv::tenv_t te,list_t<Absyn::decl_t> tds){
  Tc::tc(te, true, tds);
  if (!noshake_r)
    tds = Tc::treeshake(te,tds);
  return tds;
}

list_t<Absyn::decl_t> do_cfcheck(bool ignore, list_t<Absyn::decl_t> tds) {
  NewControlFlow::cf_check(tds);
  return tds;
}

list_t<Absyn::decl_t> do_interface($(Tcenv::tenv_t, FILE *, FILE @) @ params, list_t<Absyn::decl_t> tds) {
  let &$(te, fi, fo) = params;
  let i1 = Interface::extract(te -> ae);
  if (fi == null) {
    Interface::save(i1, fo);
  } else {
    let i0 = Interface::parse((FILE @) fi);
    if (!Interface::is_subinterface(i0, i1, new $("written interface", "maximal interface")))
      compile_failure = true;
    else
      Interface::save(i0, fo);
  }
  return tds;
}

list_t<Absyn::decl_t> do_translate(bool ignore, list_t<Absyn::decl_t> tds) {
  return Toc::toc(tds);
}
list_t<Absyn::decl_t> do_tovc(bool ignore, list_t<Absyn::decl_t> tds) {
  return Tovc::tovc(tds);
}

list_t<Absyn::decl_t> do_print(FILE @ out_file, list_t<Absyn::decl_t> tds) {
  struct Absynpp::Params params_r;

  if (tc_r) {
    params_r = Absynpp::cyc_params_r;
  } else {
    params_r = Absynpp::c_params_r;
  }
  params_r.expand_typedefs = ! noexpand_r;
  params_r.to_VC = tovc_r;
  params_r.add_cyc_prefix = add_cyc_namespace_r;
  params_r.print_full_evars = print_full_evars_r;
  params_r.print_all_tvars = print_all_tvars_r;
  params_r.print_all_kinds = print_all_kinds_r;

  //  fprintf(out_file, "#include \"cyc_include.h\"\n\n");
  if (pp_r) {
    Absynpp::set_params(&params_r);
    Absynpp::decllist2file(tds,out_file);
  } else {
    Absyndump::set_params(&params_r);
    Absyndump::dumpdecllist2file(tds,out_file);
  }
  fflush(out_file);
  return tds;
}

// We must remember what .c files are produced so that we can remove them
// after we're done.
static list_t<stringptr_t> cfiles = null;
static void remove_cfiles() {
  if (!save_c_r)
    for (; cfiles != null; cfiles = cfiles->tl)
      remove_file(*(cfiles->hd));
}

/* Take as input a string, return the list of substrings separated by colons */
static list_t<stringptr_t> split_by_char(string_t s, char c) {
  if (s == null) return null;
  let result = null;
  let len = strlen(s);

  while (len > 0) {
    let end = strchr(s,c);
    if (end == null) {
      result = new List(new s,result);
      break;
    }
    else {
      result = new List(new ((string_t)substring(s,0,(string_t)end-s)),result);
      len -= ((string_t)end-s);
      s = end+1;
    }
  }
  return List::imp_rev(result);
}

/* FIX: once stat is ported we can use that instead */
bool file_exists(string_t file) {
  FILE *f = null;
  try f = file_open(file,"r"); catch {default: break;}
  if (f == null) return false;
  else { fclose((FILE @)f); return true; }
}

string_t *find(list_t<stringptr_t> dirs, string_t file) {
  if (file == null) return null;
  for (; dirs != null; dirs = dirs->tl) {
    let dir = *dirs->hd;
    if (dir == null || strlen(dir)==0) continue;
    string_t s = Filename::concat(dir,file);
    if (file_exists(s)) return new s;
  }
  return null;
}

string_t do_find(list_t<stringptr_t> dirs, string_t file) {
  let f = find(dirs, file);
  if (f == null) {
    fprintf(stderr,"Error: can't find internal compiler file %s", file);
    compile_failure = true;
    remove_cfiles();
    exit(1);
  }
  return *f;
}

void process_file(string_t filename) {

  let basename      = Filename::chop_extension(filename);
  let preprocfile   = strconcat(basename, ".cyp");
  let interfacefile = strconcat(basename, ".cyci");
  let interfaceobjfile = strconcat(basename, ".cycio");
  let cfile         = strconcat(basename, ".c");

  if (v_r) fprintf(stderr,"Compiling %s\n", filename);

  // Check that the input file exists
  FILE * f0 = try_file_open(filename, "r", "input file");
  if (compile_failure)
    return;
  fclose((FILE @)f0);

  // Run the preprocessor, by building and running a command-line
  // Pass -I and -D things onto preprocessor
  // FIX: let user change how/which preprocessor is invoked
  let cppargs_string = String::str_sepstr(new List(new (string_t)"",
                                                   rev(cppargs))," ");
  string_t stdinc_string = " -Ic:/cyclone/include";
  let cyclone_include_path = Stdlib::getenv("CYCLONE_INCLUDE_PATH");
  if (cyclone_include_path != null) {
    let x = split_by_char(cyclone_include_path,':');
    let s = String::str_sepstr(new List(new (string_t)"",x)," -I");
    stdinc_string = xprintf("%s%s",s,stdinc_string);
  }
  string_t ofile_string;
  if (stop_after_cpp_r) {
    if (output_file != null)
      ofile_string = xprintf(" > %s", *output_file);
    else // output to standard out
      ofile_string = "";
  }
  else ofile_string = xprintf(" > %s", preprocfile);

  string_t fixup_string;
  if (produce_dependencies)
    // Both of the below hacks can probably be eliminated when we move
    // to gcc 3.0
    if (dependencies_target == null)
      // Hack to fix up dependency output of gcc 2.95: the target of
      // the dependency produced by cpp will be something like foo.cyc.o,
      // but we want it to be foo.o.
      fixup_string = " | sed 's/^\\(.*\\)\\.cyc\\.o:/\\1.o:/'";
    else {
      // Hack to handle the -MT flag, which is not supported in gcc 2.95
      // Note, we should probably make sure any special characters in
      // *dependencies_target are escaped, but WE DON'T.
      fixup_string =
        xprintf(" | sed 's/^.*\\.cyc\\.o:/%s:/'",
                *dependencies_target);
    }
  else fixup_string = "";

  let cmd = xprintf("gcc -x c -E -U__GNUC__ -nostdinc%s%s %s%s%s",
                    cppargs_string, stdinc_string, filename,
                    fixup_string, ofile_string);

  if (v_r) fprintf(stderr,"%s\n",cmd);
  if (system(string_to_Cstring(cmd)) != 0) {
    compile_failure = true;
    fprintf(stderr,"\nError: preprocessing\n");
    return;
  }
  if (stop_after_cpp_r) return;

  // Run the stages of the Cyclone compiler
  Position::reset_position(preprocfile); // necessary for good error messages!
  FILE * in_file  = try_file_open(preprocfile,"r","file");
  if (compile_failure) return;

  list_t<Absyn::decl_t> tds = null;

  // Parsing
  try
    tds = do_stage("parsing", do_parse, (FILE@)in_file, tds);
  catch {
  case x:
    file_close((FILE@)in_file);
    //    Tcutil::flush_warnings();
    remove_file(preprocfile); // Can't remove this before warnings are flushed!
    throw x;
  }
  file_close((FILE@)in_file);
  if (compile_failure) {
    //    Tcutil::flush_warnings();
    remove_file(preprocfile); // Can't remove this before warnings are flushed!
    return;
  } 

  let te = Tcenv::tc_init(); // Must declare BEFORE the goto 
  if (parseonly_r) goto PRINTC;

  // Type checking and control-flow checking
  tds = do_stage("type checking", do_typecheck, te, tds);
  if (compile_failure) {
    //    Tcutil::flush_warnings();
    remove_file(preprocfile); // Can't remove this before warnings are flushed!
    return;
  } 
  tds = do_stage("control-flow checking", do_cfcheck, true, tds);
  if(!compile_failure)
    Tcutil::flush_warnings();
  remove_file(preprocfile); // Can't remove this before warnings are flushed!
  if (compile_failure) return;

  // Interface checking
  if (ic_r) {
    FILE *inter_file = fopen(interfacefile, "r");
    FILE *inter_objfile = try_file_open(interfaceobjfile, "w", "interface object file");
    if (inter_objfile == null) {
      compile_failure = true;
      return;
    }
    Position::reset_position(interfacefile);
    tds = do_stage("interface checking", do_interface,
                   new $(te, inter_file, (FILE@) inter_objfile), tds);
    if (inter_file != null) {
      file_close((FILE @) inter_file);
    }
    file_close((FILE @) inter_objfile);
  }

  if (tc_r) goto PRINTC;

  // Translation to C
  tds = do_stage("translation to C", do_translate, true, tds);
  if (compile_failure) return;
   if (tovc_r) tds = do_stage("post-pass to VC", do_tovc, true, tds);
   if (compile_failure) return;

 PRINTC:
  if (tds != null) {
    FILE *out_file;
    if (parseonly_r || tc_r)
      if (output_file != null)
        out_file = try_file_open(*output_file,"w","output file");
      else
        out_file = stdout;
    else if (toc_r && output_file != null)
      out_file = try_file_open(*output_file,"w","output file");
    else
      out_file = try_file_open(cfile,"w","output file");

    if (compile_failure) return;

    try
      tds = do_stage("printing", do_print, (FILE @)out_file, tds);
    catch {
    case x:
      compile_failure = true;
      file_close((FILE @)out_file);
      cfiles = new List(new ((string_t)cfile),cfiles);
      throw x;
    }
    file_close((FILE @)out_file);
    cfiles = new List(new ((string_t)cfile),cfiles);
  }
}

static string_t final_str = "<final>";
static stringptr_t final_strptr = &final_str;

static interface_t read_cycio(string_t @ n) {
  if (n == final_strptr) {
    return Interface::final();
  }
  string_t basename;
  try {
    basename = Filename::chop_extension(*n);
  } catch {
  case &InvalidArg(_): basename = *n; break;
  }
  let nf = strconcat(basename, ".cycio");
  let f = try_file_open(nf, "r", "interface object file");
  if (f == null) {
    compile_failure = true;
    remove_cfiles();
    exit(1);
  }
  Position::reset_position(nf); /* in case of parsing problems */
  //printf("reading %s\n", nf);
  let i = Interface::load((FILE@) f);
  file_close((FILE@)f);
  return i;
}

static bool is_cfile(string_t @ n) {
  return (*n)[0] != '-';
}

int main(int argc, string_t ? argv) {

  list_t<$(string_t,spec_t,string_t)@> options =
    list(new $("-v",new Set_spec(&v_r),
                 "    Print compilation stages verbosely"),
         new $("-o",new String_spec(set_output_file),
                 "    Output file name"),
         new $("-D*",new Flag_spec(add_cpparg),
                  "   Pass definition to preprocessor"),
         new $("-B*",new Flag_spec(add_cyclone_exec_prefix_path),
                  "   Add to the list of directories to search for compiler files"),
         new $("-I*",new Flag_spec(add_cpparg),
                  "   Add to the list of directories to search for include files"),
         new $("-L*",new Flag_spec(add_cpparg),
                  "   Add to the list of directories for -l"),
         new $("-l*",new Flag_spec(add_libarg),
                  "   Library file"),
         new $("-c",new Unit_spec(set_stop_after_objectfile),
                 "    Produce object file"),
         new $("-s",new Flag_spec(add_ccarg),
                 "    Remove all symbol table and relocation info from executable"),
         new $("-O",new Flag_spec(add_ccarg),
                 "    Optimize"),
         new $("-O2",new Flag_spec(add_ccarg),
                  "   Optimize"),
         new $("-O3",new Flag_spec(add_ccarg),
                  "   Optimize"),
         new $("-g",new Flag_spec(add_ccarg),
                 "    Compile for debugging"),
         new $("-p",new Flag_spec(add_ccarg),
                 "    Compile for prof"),
         new $("-pg",new Flag_spec(add_ccarg),
                  "   Compile for gprof"),
         new $("-S",new Unit_spec(set_stop_after_asmfile),
                 "    Stop after producing assembly code"),
         new $("-M",new Unit_spec(set_produce_dependencies),
                 "    Produce dependencies"),
         new $("-MG",new Flag_spec(add_cpparg),
                 "    When producing dependencies assume missing files are generated"),
         new $("-MT",new String_spec(set_dependencies_target),
                 "   Give target for dependencies"),
         new $("-E",new Set_spec(&stop_after_cpp_r),
                 "    Stop after preprocessing"),
         new $("-parseonly",new Set_spec(&parseonly_r),
               "\n"
              "        Stop after parsing"),
         new $("-tc",new Set_spec(&tc_r),
                  "   Stop after type checking"),
         new $("-toc",new Set_spec(&toc_r),
                   "  Stop after translation to C"),
         new $("-ic",new Set_spec(&ic_r),
                  "   Activate the link-checker"),
         new $("-pp",new Set_spec(&pp_r),
                  "   Pretty print"),
         new $("-up",new Clear_spec(&pp_r),
                  "   Ugly print"),
         new $("-tovc",new Set_spec(&tovc_r),
                    " Avoid gcc extensions in C output"),
         new $("-save-temps",new Unit_spec(set_save_temps),
               "\n"
              "        Don't delete temporary files"),
         new $("-save-c",new Set_spec(&save_c_r),
               "\n"
              "        Don't delete temporary C files"),
         new $("-nocyc",new Clear_spec(&add_cyc_namespace_r),
               "Don't add implicit namespace Cyc"),
         new $("-nogc",new Set_spec(&nogc_r),
               " Don't link in the garbage collector"),
         new $("-noremoveunused",new Set_spec(&noshake_r),
               "\n"
              "        Don't remove externed variables that aren't used"),
         new $("-noexpandtypedefs",new Set_spec(&noexpand_r),
               "\n"
              "        Don't expand typedefs in pretty printing"),
         new $("-printalltvars", new Set_spec(&print_all_tvars_r),
               "\n"
              "        Print all type variables (even implicit default effects)"),
         new $("-printallkinds", new Set_spec(&print_all_kinds_r),
               "\n"
               "        Always print kinds of type variables"),
         new $("-printfullevars", new Set_spec(&print_full_evars_r),
               "\n"
               "       Print full information for evars (type debugging)")
         );

  Arg::parse(options, add_other, "Options:", argv);

  for (let l = rev(cyclone_files); l != null; l = l->tl) {
    process_file(*(l->hd));
    if (compile_failure) return 1;
  }

  if (stop_after_cpp_r || parseonly_r || tc_r || toc_r) return 0;

  // If there are no files for the C compiler to process don't bother
  // to run it.
  if (ccargs == null) return 0;

  // Run the C compiler
  // First, find the files cyclib.a, gc.a, cyc_include.h
  string_t cyclone_exec_prefix = Stdlib::getenv("CYCLONE_EXEC_PREFIX");
  if (cyclone_exec_prefix != null)
    cyclone_exec_prefix_path = new List(new cyclone_exec_prefix,
                                        cyclone_exec_prefix_path);
  cyclone_exec_prefix_path = new List(new ((string_t)"c:/cyclone/bin/cyc-lib"),
                                        cyclone_exec_prefix_path);
  cyclone_exec_prefix_path = List::imp_rev(cyclone_exec_prefix_path);
  let cyc_include = do_find(cyclone_exec_prefix_path,"include/cyc_include.h");

  ccargs = rev(ccargs);
  let ccargs_string = String::str_sepstr(ccargs, " ");
  libargs = rev(libargs);
  let libargs_string = String::str_sepstr(new List(new ((string_t)""), libargs), " ");

  let stdlib;
  let stdlib_string;
  let is_not_executable =
    stop_after_asmfile_r ||
    stop_after_objectfile_r ||
    (output_file != null && Filename::check_suffix(*output_file, ".a")) ||
    (output_file != null && Filename::check_suffix(*output_file, ".lib")); 
  if (is_not_executable) {
    stdlib = null;
    stdlib_string = (string_t)"";
  } else {

    let cyclib = do_find(cyclone_exec_prefix_path,"cyclib.a");
    let gc = (nogc_r ?
              do_find(cyclone_exec_prefix_path,"nogc.a"):
              do_find(cyclone_exec_prefix_path,"gc.a"));

    stdlib = list(new cyclib /*, new gc*/);
    stdlib_string = xprintf(" %s %s", cyclib, gc);
  }

  if (ic_r) try {
    ccargs = filter(is_cfile, ccargs);
    libargs = filter(is_cfile, libargs);
    let lf = append(stdlib, append(ccargs, libargs));
    if (! is_not_executable) {
      lf = new List(final_strptr, lf);
    }

    let i = Interface::get_and_merge_list(read_cycio, lf, lf);
    if (i == null) {
      fprintf(stderr,"Error: interfaces incompatible\n");
      compile_failure = true;
      remove_cfiles();
      return 1;
    }
    if (is_not_executable) {
      if (output_file != null) {
	let output_file_io = xprintf("%s.cycio", Filename::chop_extension(*output_file));
	let f = try_file_open(output_file_io, "w", "interface object file");
	if (f == null) {
	  compile_failure = true;
	  remove_cfiles();
	  return 1;
	}
	Interface::save((interface_t) i, (FILE@)f);
	file_close((FILE@)f);
      }
    } else {
      if(!Interface::is_subinterface(Interface::empty(), (interface_t) i,
				     new $("empty interface", "global interface"))) {
	fprintf(stderr,"Error: some objects are still undefined\n");
	compile_failure = true;
	remove_cfiles();
	return 1;
      }
    }
  } catch {
  case &Core::Impossible(s):
    printf ("Exception Core::Impossible %s\n", s);
    compile_failure = true;
    remove_cfiles();
    return 1;
  case Dict::Absent:
    printf("Exception Dict::Absent\n");
    compile_failure = true;
    remove_cfiles();
    return 1;
  case &InvalidArg(s):
    printf ("Exception Core::InvalidArg %s\n", s);
    compile_failure = true;
    remove_cfiles();
    return 1;
  case _:
    printf ("Uncaught exception\n");
    compile_failure = true;
    remove_cfiles();
    return 1;
  }

  let cccmd =
    xprintf("gcc -include %s%s %s%s%s",
            cyc_include,
            (output_file==null?((string_t)""):xprintf(" -o %s",*output_file)),
            ccargs_string,
            stdlib_string,
            libargs_string);
  if (v_r) fprintf(stderr,"%s\n",cccmd);
  if (system(string_to_Cstring(cccmd)) != 0) {
    fprintf(stderr,"Error: C compiler failed\n");
    compile_failure = true;
    remove_cfiles();
    return 1;
  }
  remove_cfiles();

  return compile_failure ? 1 : 0;
}
