/* Driver for the Cyclone compiler.
   Copyright (C) 2001 Greg Morrisett, AT&T
   This file is part of the Cyclone compiler.

   The Cyclone compiler is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   The Cyclone compiler is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with the Cyclone compiler; see the file COPYING. If not,
   write to the Free Software Foundation, Inc., 59 Temple Place -
   Suite 330, Boston, MA 02111-1307, USA. */

#include <arg.h>
#include <core.h>
#include <cycboot.h>
#include <list.h>
#include <string.h>
#include <dict.h>
#include <filename.h>
#include <position.h>
#include "parse.h"
#include "absyn.h"
#include "absynpp.h"
#include "absyndump.h"
#include "tcutil.h"
#include "tcenv.h"
#include "tc.h"
#include "toc.h"
#include "tovc.h"
#include "new_control_flow.h"
#include "jump_analysis.h"
#include "interface.h"
#include "cyclone.h"

namespace Port {
  extern void port(List::list_t<Absyn::decl_t>);
}
namespace ParseErrors {
  extern bool print_state_and_token;
}
namespace Lex {
  extern bool compile_for_boot_r;
  extern void pos_init();
  extern void lex_init(bool use_cyclone_keywords);
}
namespace Toc {
  bool warn_bounds_checks;
  bool warn_all_null_deref;
}


using Cyclone;
using Core;
using List;
using Arg;
typedef Hashtable::table_t<`a,`b> table_t<`a,`b>;

static bool pp_r       = false;
bool noexpand_r = false;
static bool noshake_r  = false;
static bool stop_after_cpp_r = false;
static bool parseonly_r = false;
static bool tc_r       = false;
static bool cf_r       = false;
static bool noprint_r  = false;
static bool ic_r       = false;
static bool toc_r      = false;
static bool stop_after_objectfile_r = false;
static bool stop_after_asmfile_r = false;
static bool inline_functions_r = false;
static bool elim_se_r    = false;
static bool v_r        = false;
static bool save_temps_r = false;
static bool save_c_r   = false;
static bool nogc_r     = false;
static bool pa_r       = false;
static bool pg_r       = false;
static bool nocheck_r  = false;
static bool add_cyc_namespace_r = true;
static bool generate_line_directives_r = true;
static bool print_full_evars_r = false;
static bool print_all_tvars_r = false;
static bool print_all_kinds_r = false;
static bool print_all_effects_r = false;
static bool nocyc_setjmp_r = false;
static bool generate_interface_r = false;

// Arguments to pass to the C compiler
static list_t<stringptr_t> ccargs = NULL;
static void add_ccarg(string_t<`H> s) {
  ccargs = new List(new s,ccargs);
}

// set which c compiler to use
// (affects how attributes, 64-bit integers, etc. are translated)
// defaults to gcc
void set_c_compiler(string_t<`H> s){
  if (strcmp(s,"vc") == 0) {
    c_compiler = Vc_c;
    add_ccarg("-DVC_C");
  }
  else if (strcmp(s,"gcc") == 0) {
    c_compiler = Gcc_c;
    add_ccarg("-DGCC_C");
  }
  // else invalid compiler -- warn? throw exception? 
}


void set_port_c_code() {
  Absyn::porting_c_code = true;
  Position::max_errors = 65535; // allow a lot of errors
  save_c_r = true; // save temp files
  parseonly_r = true; // stop after parsing
}


static string_t *output_file = NULL;
static void set_output_file(string_t<`H> s) {
  output_file = new s;
}

static string_t specified_interface = NULL;
static void set_specified_interface(string_t<`H> s) {
  specified_interface = s;
}

// These strings are install_path.c, which is created by Makefile wizardry.
// We use Cstrings because we pull the same trick when bootstrapping (and
// then we don't have a Cyclone compiler yet)
extern "C" {
  extern Cstring Cdef_inc_path;
  extern Cstring Cdef_lib_path;
  extern Cstring Carch;
  extern Cstring Ccomp;
  extern Cstring Cversion;
}

static string_t cpp = "";
static void set_cpp(string_t<`H> s) {
  cpp = s;
}

static list_t<stringptr_t> cppargs = NULL;
static void add_cpparg(string_t<`H> s) {
  cppargs = new List(new s,cppargs);
}

static void add_cpp_and_ccarg(string_t<`H> s) {
  add_cpparg(s);
  add_ccarg(s);
}

static void add_iprefix(string_t<`H> s) {
  add_cpparg(aprintf("-iprefix %s",s));
}
static void add_iwithprefix(string_t<`H> s) {
  add_cpparg(aprintf("-iwithprefix %s",s));
}
static void add_iwithprefixbefore(string_t<`H> s) {
  add_cpparg(aprintf("-iwithprefixbefore %s",s));
}
static void add_isystem(string_t<`H> s) {
  add_cpparg(aprintf("-isystem %s",s));
}
static void add_idirafter(string_t<`H> s) {
  add_cpparg(aprintf("-idirafter %s",s));
}

static string_t target_arch = NULL;
static void set_target_arch(string_t<`H> s) {
//  toc_r = true;
  target_arch = s;
  add_ccarg("-b");
  add_ccarg(s);
}

static void set_many_errors() {
  Position::max_errors = 65535;
}

// Prints the version # and exits
static void print_version() {
  printf("The Cyclone compiler, version %s\n", Cstring_to_string(Cversion));
  printf("Compiled for architecture: %s CC=\"%s\"\n", 
	 Cstring_to_string(Carch), Cstring_to_string(Ccomp));
  printf("Standard library directory: %s\n",Cstring_to_string(Cdef_lib_path));
  printf("Standard include directory: %s\n",Cstring_to_string(Cdef_inc_path));
  exit(0);
}
  
static bool is_cyclone_sourcefile(string_t s) {
  let len = strlen(s);
  if (len <= 4) return false;
  else return (strcmp(s+(len-4),".cyc") == 0);
}

static list_t<stringptr_t> cyclone_exec_path = NULL;
static void add_cyclone_exec_path(string_t s) {
  let len = strlen(s);
  if (len <= 2) return;
  let dir = (string_t)substring(s,2,len-2);
  cyclone_exec_path = new List(new dir,cyclone_exec_path);
}

// Ideally we would simply pass library args as ccargs, preserving
// their order with the other ccargs.  But if, e.g., -lm precedes
// libcyc.a, then we get a "multiple definitions of main" error, via
// libmain.c.  So, we separate out the library args from the ccargs
// so that we can force libcyc.a to appear first.
static list_t<stringptr_t> libargs = NULL;
static void add_libarg(string_t<`H> s) {
  if (strcmp(s,"-lxml") == 0)
    if (!pa_r)
      add_ccarg(s);
    else
      add_ccarg("-lxml_a");
  else
    libargs = new List(new s,libargs);
}

static void add_marg(string_t<`H> s) {
  add_ccarg(s);
}

static void set_save_temps() {
  save_temps_r = true;
  add_ccarg("-save-temps");
}

static bool produce_dependencies = false;
static void set_produce_dependencies() {
  stop_after_cpp_r = true;
  produce_dependencies = true;
  add_cpparg("-M");
}

static string_t *dependencies_target = NULL;
static void set_dependencies_target(string_t<`H> s) {
  dependencies_target = new s;
}

static void set_stop_after_objectfile() {
  stop_after_objectfile_r = true;
  add_ccarg("-c");
}

static void set_nocppprecomp() {
  add_cpp_and_ccarg("-no-cpp-precomp");
}

static void clear_lineno() {
  generate_line_directives_r = false;
  set_save_temps();
}
static void set_inline_functions() {
  inline_functions_r = true;
}
static void set_elim_se() {
  elim_se_r = true;
  set_inline_functions();
}
static void set_tovc() {
  tovc_r = true;
  add_ccarg("-DCYC_ANSI_OUTPUT");
  set_elim_se();
}
static void set_noboundschecks() {
  add_ccarg("-DNO_CYC_BOUNDS_CHECKS");
}
static void set_nonullchecks() {
  add_ccarg("-DNO_CYC_NULL_CHECKS");
}
static void set_nochecks() {
  set_noboundschecks();
  set_nonullchecks();
  nocheck_r = true;
}

static void set_nocyc() {
  add_cyc_namespace_r = false;
  add_ccarg("-DNO_CYC_PREFIX");
}

static void set_pa() {
  pa_r = true;
  add_ccarg("-DCYC_REGION_PROFILE");
  add_cpparg("-DCYC_REGION_PROFILE");
}

static void set_pg() {
  pg_r = true;
  add_ccarg("-pg");
}

static void set_stop_after_asmfile() {
  stop_after_asmfile_r = true;
  add_ccarg("-S");
}

static void set_all_warnings() {
  Toc::warn_bounds_checks = true;
  Toc::warn_all_null_deref = true;
  NewControlFlow::warn_lose_unique = true;
  Tcutil::warn_alias_coerce = true;
  Tcutil::warn_region_coerce = true;
  Tc::aggressive_warn = true;
}

/* This only works enough to support cycdoc so far */
enum inputtype {
  DEFAULTINPUT,
  CYCLONEFILE
};
typedef enum inputtype inputtype_t;
static inputtype_t intype = DEFAULTINPUT;
static void set_inputtype(string_t s) {
  if (strcmp(s,"cyc") == 0)
    intype = CYCLONEFILE;
  else if (strcmp(s,"none") == 0)
    intype = DEFAULTINPUT;
  else {
    fprintf(stderr,"Input type '%s' not supported\n",s);
  }
}

string_t make_base_filename(string_t<`r> s, string_t<`r>* output_file) {
  let outdir = Filename::dirname(output_file == NULL ?  s : *output_file);
  let base = Filename::chop_extension(Filename::basename(s));
  // if outdir is empty, then just use base
  // otherwise, use outdir/base.
  // note that ""/base gets translated to /base, which is not what we wanted
  let basename = strlen(outdir) > 0 ? Filename::concat(outdir, base) : base;
  return (string_t)basename;
}


// Cyclone files given on the command line
static list_t<stringptr_t> cyclone_files = NULL;
// Like add_ccarg but intercepts .cyc files for special handling
static bool gcc_optarg = 0;
static void add_other(string_t<`H> s) {
  // for the case that we received a gcc option that has an argument
  if (gcc_optarg > 0) {
    add_ccarg(s);
    gcc_optarg--;
  }
  else if (intype == CYCLONEFILE || is_cyclone_sourcefile(s)) {
    // For processing by Cyclone
    cyclone_files = new List(new s,cyclone_files);

    // The C compiler wants the .c file, not the .cyc files
    let basename = make_base_filename(s,output_file);
    let cfile    = strconcat(basename, ".c");
    add_ccarg(cfile);
  }
  else add_ccarg(s);
}

// This handles non-Cyclone flags, simply passing them through to gcc
// We have a table of well-known flags; others are 
static bool assume_gcc_flag = true;
static bool add_other_flag(string_t<`H> s) {
  static struct { const char ?flag; int optargs; } known_gcc_flags[] = {
    { "-s", 0 },
    { "-O", 0 },
    { "-O0", 0 },
    { "-O2", 0 },
    { "-O3", 0 },
    { "-fomit-frame-pointer", 0 },
    { "-fno-builtin", 0 },
    { "-g", 0 },
    { "-pg", 0 },
    { "-p", 0 },
    { "-static", 0 }
  };
  if (assume_gcc_flag)
    add_ccarg(s);
  else {
    for (int i = 0; i<numelts(known_gcc_flags); i++) {
      if (!strcmp(known_gcc_flags[i].flag,s)) {
	add_ccarg(s);
	gcc_optarg = known_gcc_flags[i].optargs;
	break;
      }
    }
    return false;
  }
  return true;
}

static void noassume_gcc_flag() {
  assume_gcc_flag = false;
}

static void remove_file(string_t<`H> s) {
  if (save_temps_r) return;
  else remove((const char @)s);
}

/**********************************************************************/
/* Reading a specs file */

#define MAXSTRNAME 256
#define MAXSTRVALUE 4096

list_t<$(const char ?@,const char ?@)@> read_specs(const char ?file) {
  let result = NULL;
  int c; 
  int i;
  char strname[MAXSTRNAME];
  char strvalue[MAXSTRVALUE];
  FILE *spec_file = fopen((const char @)file, "r");

  if (spec_file == NULL) {
    fprintf(stderr, "Error opening spec file %s\n",file);
    fflush(stderr);
    return NULL;
  }

  while (true) { // exited by goto only
    while (true) { // get rid of leading whitespace, find '*'
      c = fgetc(spec_file);    
      if (isspace(c)) continue;
      if (c == '*') break;
      if (c != EOF) {
        fprintf(stderr,
                "Error reading spec file %s: unexpected character '%c'\n",
                file,c);
        fflush(stderr);
      }
      goto CLEANUP_AND_RETURN;
    }
  JUST_AFTER_STAR:
    i = 0;
    while (true) { // read command name up to ':'
      c = fgetc(spec_file);    
      if (c == EOF) {
        fprintf(stderr,
                "Error reading spec file %s: unexpected EOF\n",
                file);
        fflush(stderr);
        goto CLEANUP_AND_RETURN;
      } 
      if (c == ':') {
        strname[i] = 0;
        break;
      }
      strname[i] = (char)c;
      i++;
      if (i >= MAXSTRNAME) {
        fprintf(stderr,
                "Error reading spec file %s: string name too long\n",
                file);
        fflush(stderr);
        goto CLEANUP_AND_RETURN;
      }
    }
    while (true) { // skip whitespace
      c = fgetc(spec_file);
      if (isspace(c)) continue;
      break;
    } 
    if (c == '*') { // if next char is '*', then strvalue are empty
      // NB: this prevents a string value from starting with '*'
      result = new List(new $(new (const char ?)strdup(strname),
                              new (const char ?)strdup("")),result);
      goto JUST_AFTER_STAR; // continue with next command
    }
    // otherwise read strvalue
    strvalue[0] = (char)c;
    i = 1;
    while (true) { // read string up to end of line or file
      c = fgetc(spec_file);
      if (c == EOF || c == '\n' || c == '\r') { strvalue[i] = 0; break; }
      strvalue[i] = (char)c;
      i++;
      if (i >= MAXSTRVALUE) {
        fprintf(stderr,
                "Error reading spec file %s: value of %s too long\n",
                file,strname);
        fflush(stderr);
        goto CLEANUP_AND_RETURN; // this strname/option pair is dropped
      }
    }
    // TODO: perhaps we should remove whitespace from the end of the line??
    result = new List(new $(new (const char ?)strdup(strname),
                            new (const char ?)strdup(strvalue)),result);
    if (c == EOF) goto CLEANUP_AND_RETURN;
  }

 CLEANUP_AND_RETURN:
  fclose(spec_file);
  return result;
}
// After reading a specs file we might want to split a line into
// command line arguments
string_t<`H> ?`H split_specs(const char ?cmdline) {
  if (cmdline == NULL) return NULL;
  let n = strlen(cmdline);
  let l = NULL;
  char buf[MAXSTRVALUE]@nozeroterm;
  int i = 0;
  int j = 0;
  if (n > MAXSTRVALUE) goto DONE; // silently fail
  while (true) {
    // Get rid of leading spaces
    while (true) {
      if (i >= n) goto DONE;
      if (cmdline[i] == 0) goto DONE;
      if (!isspace(cmdline[i])) break;
      i++;
    }
    j = 0;
    // i points to a non-space.  Advance it to the next position
    // which is not part of this word, e.g., a non-escaped space,
    // zero terminator, or one past the end of the string; copy
    // the argument to buf.
    while (true) {
      if (i >= n) break;
      if (cmdline[i] == 0) break;
      if (isspace(cmdline[i])) break;
      if (cmdline[i] == '\\') {
        // backslash escapes next char, whatever it is
        i++;
        if (i >= n) break;
        if (cmdline[i] == 0) break;
        buf[j] = cmdline[i];
        j++;
      }
      else {
        buf[j] = cmdline[i];
        j++;
      }
      i++;
    }
    if (j < MAXSTRVALUE) // Invariant: j<=i<=MAXSTRVALUE
      buf[j] = 0;
    // extract the characters from i up to but not including j
    l = new List(new (const char ?)strdup(buf),l);
  }
 DONE:  
  l = List::imp_rev(l);
  l = new List(new "",l); // For the command, since we'll pass it to Arg::parse
  let ptrarray = List::to_array(l);
  let result = new { for k < numelts(ptrarray) : *(ptrarray[k]) };
  return result;
}

/**********************************************************************/

bool compile_failure = false; // for exit code (helps Makefile)

FILE *try_file_open(string_t filename, string_t mode, string_t msg_part) {
  try return file_open(filename,mode);
  catch {
  default:
    compile_failure = true;
    fprintf(stderr, "\nError: couldn't open %s %s\n", msg_part, filename);
    fflush(stderr);
    return NULL;
  }
}

extern "C" void CYCALLOCPROFILE_mark(const char *s);

`b do_stage(string_t stage_name, `b f(`a, list_t<Absyn::decl_t,`H>),
           `a env, list_t<Absyn::decl_t,`H> tds) {
  string_t explain_string = "";
  let ans;

  CYCALLOCPROFILE_mark(stage_name);

  try ans = f(env,tds);
  catch {
  case x:
    fprintf(stderr,"COMPILER STAGE %s\n",stage_name);
    Core::rethrow(x);
  }
  if (Position::error_p())
    compile_failure = true;
  if (compile_failure) {
    fprintf(stderr,"\nCOMPILATION FAILED!\n");
    fflush(stderr);
    return ans;
  }
  else if (v_r) {
    fprintf(stderr,"%s completed.\n",stage_name);
    fflush(stderr);
    return ans;
  }
  return ans;
}

list_t<Absyn::decl_t> do_parse(FILE @ f, list_t<Absyn::decl_t> ignore) {
  Lex::lex_init(true); // must forget typedefs, may as well flush symbols too
  Lex::pos_init();
  list_t<Absyn::decl_t> ans = NULL;
  try {
    ans = Parse::parse_file(f);
  } catch {
  case &Position::Exit: compile_failure = true; break;
  case e: rethrow(e);
  }
  Lex::lex_init(true); // garbage collect those big tries
  return ans;
}

list_t<Absyn::decl_t> do_typecheck($(region_t<`tc>,Tcenv::tenv_t<`tc>) @tcenv,
                                   list_t<Absyn::decl_t,`H> tds){
  let $(tc_rgn, te) = *tcenv;
  Tc::tc(tc_rgn, te, true, tds);
  if (!noshake_r)
    tds = Tc::treeshake(te,tds);
  return tds;
}

JumpAnalysis::jump_anal_res_t do_jumpanalysis(bool ignore, 
						 list_t<Absyn::decl_t,`H> tds) {
  return JumpAnalysis::jump_analysis(tds);
}

list_t<Absyn::decl_t> do_cfcheck(bool ignore, list_t<Absyn::decl_t,`H> tds) {
  NewControlFlow::cf_check(tds);
  return tds;
}

// do_interface [te] [if] [ifo] [decls] where [if] is the interface (cyci)
// file, and [ifo] is the cycio file for the output
list_t<Absyn::decl_t> do_interface($(Tcenv::tenv_t, FILE *`H, FILE @`H) @ params, list_t<Absyn::decl_t,`H> tds) {
  let &$(te, fi, fo) = params;
  let i1 = Interface::extract(te -> ae);
  if (fi == NULL) {
    Interface::save(i1, fo);
  } else {
    let i0 = Interface::parse(fi);
    if (!Interface::is_subinterface(i0, i1, new $("written interface", "maximal interface")))
      compile_failure = true;
    else
      Interface::save(i0, fo);
  }
  return tds;
}

list_t<Absyn::decl_t> 
do_translate(table_t<Absyn::fndecl_t,table_t<Absyn::stmt_t,int>> pops, 
	     list_t<Absyn::decl_t> tds) {
  return Toc::toc(pops,tds);
}
list_t<Absyn::decl_t> do_tovc(bool ignore, list_t<Absyn::decl_t> tds) {
  Tovc::elim_array_initializers = tovc_r;
  return Tovc::tovc(tds);
}

static string_t cyc_setjmp = NULL;
/* The absolute file name of cyc_include.h */
static string_t cyc_include = NULL;

static void set_cyc_include(string_t<`H> f) {
  cyc_include = f;
}

/* return 1 on error, 0 on no error */
int copy_internal_file(string_t file, FILE @out_file) {
  // FIX: would be better to use open, stat, and read but we don't
  // have all those functions in the library yet.
  if (file == NULL) {
    fprintf(stderr,"Internal error: copy_internal_file called with NULL\n");
    return 1;
  }
  let file_f = try_file_open(file,"r","internal compiler file");
  if (file_f == NULL) return 1;
  size_t n_read = 1024;
  size_t n_written;
  char buf[1024] = { for i < 1024 : 0 }; // init to avoid warning
  while (n_read == 1024) {
    n_read = fread(buf,1,1024,file_f);
    if (n_read != 1024 && !(feof(file_f))) {
      compile_failure = true;
      fprintf(stderr, "\nError: problem copying %s\n",file);
      fflush(stderr);
      return 1;
    }
    n_written = fwrite(buf,1,n_read,out_file);
    if (n_read != n_written) {
      compile_failure = true;
      fprintf(stderr, "\nError: problem copying %s\n",file);
      fflush(stderr);
      return 1;
    }
  }
  fclose(file_f);
  return 0;
}


list_t<Absyn::decl_t> do_print(FILE @`H out_file, list_t<Absyn::decl_t,`H> tds) {
  let params_r = tc_r ? Absynpp::cyc_params_r : Absynpp::c_params_r;
  params_r.expand_typedefs = ! noexpand_r;
  params_r.to_VC = tovc_r;
  params_r.add_cyc_prefix = add_cyc_namespace_r;
  params_r.generate_line_directives = generate_line_directives_r;
  params_r.print_full_evars = print_full_evars_r;
  params_r.print_all_tvars = print_all_tvars_r;
  params_r.print_all_kinds = print_all_kinds_r;
  params_r.print_all_effects = print_all_effects_r;

  if (inline_functions_r)
    fprintf(out_file,"#define _INLINE_FUNCTIONS\n");

  // Copy cyc_setjmp.h and cyc_include.h to out_file.
  if (!parseonly_r && !tc_r && !cf_r) {
    if (!nocyc_setjmp_r) {
      if (Lex::compile_for_boot_r)
        fprintf(out_file,"#include <setjmp.h>\n");
      else if (copy_internal_file(cyc_setjmp,out_file)) return tds;
    }
    if (copy_internal_file(cyc_include,out_file)) return tds;
  }
  if (pp_r) {
    Absynpp::set_params(&params_r);
    Absynpp::decllist2file(tds,out_file);
  } else {
    Absyndump::set_params(&params_r);
    Absyndump::dumpdecllist2file(tds,out_file);
  }
  fflush(out_file);
  return tds;
}

// We must remember what .c files are produced so that we can remove them
// after we're done.
static list_t<stringptr_t> cfiles = NULL;
static void remove_cfiles() {
  if (!save_c_r)
    for (; cfiles != NULL; cfiles = cfiles->tl)
      remove_file(*(cfiles->hd));
}

// Take as input a string, return the list of substrings separated by colons
static list_t<stringptr_t> split_by_char(string_t<`H> s, char c) {
  if (s == NULL) return NULL;
  let result = NULL;
  let len = strlen(s);

  while (len > 0) {
    let end = strchr(s,c);
    if (end == NULL) {
      result = new List(new s,result);
      break;
    }
    else {
      result = new List(new ((string_t)substring(s,0,(string_t)end-s)),result);
      len -= ((string_t)end-s);
      s = end+1;
    }
  }
  return List::imp_rev(result);
}

/* FIX: once stat is ported we can use that instead */
static bool file_exists(string_t file) {
  FILE *f = NULL;
  try f = file_open(file,"r"); catch {default: break;}
  if (f == NULL) return false;
  else { fclose(f); return true; }
}

/* Prints out a list of string pointers */
static string_t sprint_list(list_t<stringptr_t>dirs) {
  string_t tmp = "";
  for (; dirs != NULL; dirs = dirs->tl) {
    let dir = *dirs->hd;
    if (dir == NULL || strlen(dir)==0) continue;
    dir = strconcat(dir,":");
    tmp = strconcat(dir,tmp);
  }
  return tmp;
}

/* Looks for the file in the list of directories.  The order
   of the list matters---it returns the first file it finds. */
static string_t *find(list_t<stringptr_t> dirs, string_t file) {
  if (file == NULL) return NULL;
  for (; dirs != NULL; dirs = dirs->tl) {
    let dir = *dirs->hd;
    if (dir == NULL || strlen(dir)==0) continue;
    string_t s = Filename::concat(dir,file);
    if (file_exists(s)) return new s;
  }
  return NULL;
}

static string_t do_find(list_t<stringptr_t> dirs, string_t file) {
  let f = find(dirs, file);
  if (f == NULL) {
    compile_failure = true;
    remove_cfiles();
    fprintf(stderr,"Error: can't find internal compiler file %s in path %s\n", 
            file, sprint_list(dirs));
    fflush(stderr);
    throw new Core::Failure
      (aprintf("Error: can't find internal compiler file %s in path %s\n", 
	       file, sprint_list(dirs)));
  }
  return *f;
}

/* Given: dirs=[d1,d2,..,dn]
   Return:     [d1/subdir,d2/subdir,..,dn/subdir] */
static list_t<const char ?`H@`H>
add_subdir(list_t<const char ?`H@`H> dirs, const char ?subdir) {
  let l = NULL;
  for (; dirs != NULL; dirs = dirs->tl) {
    l = new List(new (const char ?)Filename::concat(*dirs->hd,subdir),l);
  }
  l = List::imp_rev(l);
  return l;
}

/* Given: dirs=[d1,d2,..,dn]
   Return:     [d1,d1/subdir,d2,d2/subdir,..,dn,dn/subdir] */
static list_t<const char ?`H@`H>
also_subdir(list_t<const char ?`H@`H> dirs, const char ?subdir) {
  let l = NULL;
  for (; dirs != NULL; dirs = dirs->tl) {
    l = new List(dirs->hd,l);
    l = new List(new (const char ?)Filename::concat(*dirs->hd,subdir),l);
  }
  l = List::imp_rev(l);
  return l;
}

/* Is a character special to /bin/sh (except for single quote)? */
static bool is_other_special(char c) {
  switch (c) {
  case '\\':
  case '"': 
  case ';': 
  case '&': 
  case '(': 
  case ')': 
  case '|': 
  case '^': 
  case '<': 
  case '>': 
  // JGM: I'm commenting this out because we shouldn't be quoting
  // arguments like -idirafter.
  // case ' ': 
  case '\n': 
  case '\t': return true;
  default: return false;
  }
}

/* Escape any characters special to /bin/sh */
static string_t sh_escape_string(string_t<`H> s) {
  let len = strlen(s);

  /* Count the number of single quotes and other special chars in s */
  let single_quotes = 0;
  let other_special = 0;
  for (int i = 0; i < len; i++) {
    let c = s[i];
    if (c == '\'') single_quotes++;
    else if (is_other_special(c)) other_special++;
  }

  /* No special chars to escape */
  if (single_quotes == 0 && other_special == 0)
    return s;

  /* No single quotes, we can just single quote s */
  if (single_quotes == 0)
    return strconcat_l(list(new "'",new (string_t)s, new "'"));

  /* We'll quote all special chars by prefixing with a backslash */
  let len2 = len + single_quotes + other_special;
  mstring_t s2 = new {for i < len2+1 : '\0'}; // add trailing NUL
  let i = 0;
  let j = 0;
  for (; i < len; i++) {
    let c = s[i];
    if (c == '\'' || is_other_special(c))
      s2[j++] = '\\';
    s2[j++] = c;
  }
  return s2;
}
static stringptr_t sh_escape_stringptr(stringptr_t<`H,`H> sp) {
  return new sh_escape_string(*sp);
}

static void process_file(string_t<`H> filename) {

  let basename = make_base_filename(filename, output_file);
  let preprocfile   = strconcat(basename, ".cyp");
  let interfacefile = (specified_interface != NULL) ? 
                        specified_interface : strconcat(basename, ".cyci");
  let interfaceobjfile = strconcat(basename, ".cycio");
  let cfile         = strconcat(basename, ".c");

  if (v_r) fprintf(stderr,"Compiling %s\n", filename);

  // Check that the input file exists
  FILE * f0 = try_file_open(filename, "r", "input file");
  if (compile_failure || !f0)
    return;
  fclose(f0);

  // Run the preprocessor, by building and running a command-line
  // Pass -I and -D things onto preprocessor.
  let cppargs_string =
    str_sepstr(new List(new (string_t)"",
                        List::map(sh_escape_stringptr,rev(cppargs))),
               " ");
  // About the cyclone include path---this path is specified with the
  // following order (where the earlier in the order, the first place we look
  // for the file):
  // 1) command line arguments (with -I and -B)
  // 2) environment var (CYCLONE_INCLUDE_PATH)
  // 3) hardwired in the build (by setting def_inc_path and def_lib_path)
  string_t def_inc_path = Cstring_to_string(Cdef_inc_path);
  let stdinc_dirs = add_subdir(cyclone_exec_path,target_arch);
  stdinc_dirs = add_subdir(stdinc_dirs,"include");
  if (strlen(def_inc_path) > 0) {
    stdinc_dirs = new List(new def_inc_path, stdinc_dirs);
  }
  let cyclone_include_path = getenv("CYCLONE_INCLUDE_PATH");
  if (cyclone_include_path != NULL) {
    stdinc_dirs = List::append(split_by_char(cyclone_include_path,':'),
                               stdinc_dirs);
  }
  string_t stdinc_string =
    str_sepstr(new List(new (string_t)"",
                        List::map(sh_escape_stringptr,stdinc_dirs)),
               " -I");
  string_t ofile_string;
  if (stop_after_cpp_r) {
    if (output_file != NULL)
      ofile_string = aprintf(" > %s", *output_file);
    else // output to standard out
      ofile_string = "";
  }
  else ofile_string = aprintf(" > %s", sh_escape_string(preprocfile));

  string_t fixup_string;
  if (produce_dependencies)
    // Both of the below hacks can probably be eliminated when we move
    // to gcc 3.0
    if (dependencies_target == NULL)
      // Hack to fix up dependency output of gcc 2.95: the target of
      // the dependency produced by cpp will be something like foo.cyc.o,
      // but we want it to be foo.o.
      fixup_string = " | sed 's/^\\(.*\\)\\.cyc\\.o:/\\1.o:/'";
    else {
      // Hack to handle the -MT flag, which is not supported in gcc 2.95
      // Note, we should probably make sure any special characters in
      // *dependencies_target are escaped, but WE DON'T.
      fixup_string =
        aprintf(" | sed 's/^.*\\.cyc\\.o:/%s:/'",
                *dependencies_target);
    }
  else fixup_string = "";

  let cmd = aprintf("%s %s%s %s%s%s",
	            cpp,
                    cppargs_string, stdinc_string,
                    sh_escape_string(filename),
                    fixup_string, ofile_string);

  if (v_r) fprintf(stderr,"%s\n",cmd);
  if (system((const char @)cmd) != 0) {
    compile_failure = true;
    fprintf(stderr,"\nError: preprocessing\n");
    if (!stop_after_cpp_r) remove_file(preprocfile);
    return;
  }
  if (stop_after_cpp_r) return;

  // Run the stages of the Cyclone compiler
  Position::reset_position(preprocfile); // necessary for good error messages!
  FILE * in_file  = try_file_open(preprocfile,"r","file");
  if (compile_failure) return;

  list_t<Absyn::decl_t> tds = NULL;

  // Parsing
  try
    tds = do_stage("parsing", do_parse, (FILE@)in_file, tds);
  catch {
  case x:
    file_close((FILE@)in_file);
    remove_file(preprocfile); // Can't flush warnings after removal
    Core::rethrow(x);
  }
  file_close(in_file);
  if (compile_failure) {
    remove_file(preprocfile); // Can't flush warnings after removal
    return;
  } 

  if (Absyn::porting_c_code) {
    Port::port(tds);
    return;
  }

  let jump_tables;
  region tc_rgn; {
    let te = Tcenv::tc_init(tc_rgn); // Must declare BEFORE the goto 
    if (parseonly_r) goto PRINTC;

    // Type checking and control-flow checking
    let tc_env = $(tc_rgn, te);
    tds = do_stage("type checking", do_typecheck, &tc_env, tds);

    if (compile_failure) {
      remove_file(preprocfile); // Can't flush warnings after removal
      return;
    } 

    jump_tables = do_stage("jump checking",do_jumpanalysis,true,tds);
    if (compile_failure) {
      remove_file(preprocfile); // Can't flush warnings after removal
      return;
    } 
    
    if (tc_r) goto PRINTC;
    tds = do_stage("control-flow checking", do_cfcheck, true, tds);
    if (compile_failure) {
      remove_file(preprocfile); // Can't flush warnings after removal
      return;
    } 
    
    // Generate interface file
    if (generate_interface_r) {
      FILE *inter_file = try_file_open((const char @)interfacefile, "w","interface file");
      if (inter_file == NULL) {
        compile_failure = true; return;
      }
      Absyndump::set_params(&Absynpp::cyci_params_r);
      Absyndump::dump_interface(tds, inter_file);
      fclose(inter_file);
      Absynpp::set_params(&Absynpp::tc_params_r);
    }

    // Interface checking
    if (ic_r) {
      FILE *inter_file = fopen((const char @)interfacefile, "r");
      FILE *inter_objfile = try_file_open(interfaceobjfile, "w", "interface object file");
      if (inter_objfile == NULL) {
        compile_failure = true;
        return;
      }
      Position::reset_position(interfacefile);
      let int_env = $(te, inter_file, (FILE@)inter_objfile);
      tds = do_stage("interface checking", do_interface, &int_env, tds);
      if (inter_file != NULL) 
        file_close(inter_file);
      file_close(inter_objfile);
    }
  }
  if (cf_r) goto PRINTC;

  // Translation to C
  tds = do_stage("translation to C",do_translate, jump_tables->pop_tables, tds);
  if (compile_failure) {
    remove_file(preprocfile); // Can't flush warnings after removal
    return;
  } 

  if (!compile_failure)
    Tcutil::flush_warnings();
  remove_file(preprocfile);
  if (compile_failure) return;
  if (tovc_r || elim_se_r)
    // FIX: the tovc functions should be renamed, some things
    // (lifting out statement expressions) are useful even if
    // we aren't using VC
    tds = do_stage("post-pass to VC", do_tovc, true, tds);
  if (compile_failure) return;


  // jcheney: we should make a (empty) .c file even if the .cyc file produced no decls
  /*PRINTC:
    if (tds != NULL) */
 PRINTC: {
  FILE *out_file;
  if (parseonly_r || tc_r || cf_r)
    if (output_file != NULL)
      out_file = try_file_open(*output_file,"w","output file");
    else
      out_file = stdout;
  else if (toc_r && output_file != NULL)
    out_file = try_file_open(*output_file,"w","output file");
  else
    out_file = try_file_open(cfile,"w","output file");
  
  if (compile_failure || !out_file) return;
  
  try
    if (!noprint_r)
      tds = do_stage("printing", do_print, out_file, tds);
  catch {
  case x:
    compile_failure = true;
    file_close(out_file);
    cfiles = new List(new ((string_t)cfile),cfiles);
    Core::rethrow(x);
  }
  file_close(out_file);
  cfiles = new List(new ((string_t)cfile),cfiles); 
  }
}

static string_t final_str = "<final>";
static stringptr_t final_strptr = &final_str;

static interface_t read_cycio(string_t<`H> @ n) {
  if (n == final_strptr) {
    return Interface::final();
  }
  string_t basename;
  try {
    basename = Filename::chop_extension(*n);
  } catch {
  case &Invalid_argument(_): basename = *n; break;
  }
  let nf = strconcat(basename, ".cycio");
  let f = try_file_open(nf, "rb", "interface object file");
  if (f == NULL) {
    compile_failure = true;
    remove_cfiles();
    exit(1);
  }
  Position::reset_position(nf); /* in case of parsing problems */
  //printf("reading %s\n", nf);
  let i = Interface::load(f);
  file_close(f);
  return i;
}

static bool is_cfile(string_t @ n) {
  return (*n)[0] != '-';
}

extern "C" void GC_blacklist_warn_clear();
//extern "C" int GC_dont_gc;

///////////////////////////////////////////////////////////////////
// table of compiler options
///////////////////////////////////////////////////////////////////
using Arg {
  typedef $(string_t flag, bool isprefix, string_t argdesc, spec_t spec, 
            string_t description) option_t;

  extern void print_options();

#define make_option(opt,flag,isprefix,argdesc,spec,spec_arg,description) \
  datatype Spec.spec opt##_spec = spec(spec_arg); \
  option_t opt##_tuple = $(flag,isprefix,argdesc,&opt##_spec,description); \
  struct List<option_t@`H,`H> opt = {&opt##_tuple,NULL}

  make_option(opt1,"-v",false,"",Set_spec,&v_r,
              "print compilation stages verbosely");
  make_option(opt2,"--version",false,"",
              Unit_spec,print_version,
              "Print version information and exit");
  make_option(opt3,"-o",false," <file>",
              String_spec,set_output_file,
              "Set the output file name to <file>");
  make_option(opt4,"-D",true,"<name>[=<value>]",
              Flag_spec,add_cpparg,
              "Pass definition to preprocessor");
  make_option(opt5,"-B",true,"<file>",
              Flag_spec,add_cyclone_exec_path,
              "Add to the list of directories to search for compiler files");
  make_option(opt6,"-I",true,"<dir>",
              Flag_spec,add_cpparg,
              "Add to the list of directories to search for include files");
  make_option(opt7,"-L",true,"<dir>",
              Flag_spec,add_ccarg,
              "Add to the list of directories for -l");
  make_option(opt8,"-l",true,"<libname>",
              Flag_spec,add_libarg,
              "Library file");
  make_option(opt9,"-m",true,"<option>",
              Flag_spec,add_marg,
              "GCC specific: pass machine-dependent flag on to gcc");
  make_option(opt10,"-c",false,"",
              Unit_spec,set_stop_after_objectfile,
              "Produce an object file instead of an executable; do not link");
  make_option(opt11,"-x",false," <language>",
              String_spec,set_inputtype,
              "Specify <language> for the following input files");
  make_option(opt12,"-pa",false,"",
              Unit_spec,set_pa,
              "Compile for profiling with aprof");
  make_option(opt13,"-S",false,"",
              Unit_spec,set_stop_after_asmfile,
              "Stop after producing assembly code");
  make_option(opt14,"-M",false,"",
              Unit_spec,set_produce_dependencies,
              "Produce dependencies");
  make_option(opt15,"-MG",false,"",
              Flag_spec,add_cpparg,
              "When producing dependencies assume that missing "
              "files are generated");
  make_option(opt16,"-MT",false," <target>",
              String_spec,set_dependencies_target,
              "Give target for dependencies");
  make_option(opt17,"-b",false,"<machine>",
              String_spec,set_target_arch,
              "Set target machine");
  make_option(opt18,"-Wlose-unique",false,"",
              Set_spec,&NewControlFlow::warn_lose_unique,
              "Try to warn when a unique pointer might get lost");
  make_option(opt19,"-Woverride",false,"",
              Set_spec,&Tcenv::warn_override,
              "Warn when a local variable overrides an existing variable");
  make_option(opt20,"-Wall",false,"",
              Unit_spec,set_all_warnings,
              "Turn on all warnings");
  make_option(opt21,"-E",false,"",
              Set_spec,&stop_after_cpp_r,
              "Stop after preprocessing");
  make_option(opt22,"-stopafter-parse",false,"",
              Set_spec,&parseonly_r,
              "Stop after parsing");
  make_option(opt23,"-stopafter-tc",false,"",
              Set_spec,&tc_r,
              "Stop after type checking");
  make_option(opt24,"-noprint",false,"",
              Set_spec,&noprint_r,
              "Do not print output (when stopping early)");
  make_option(opt25,"-stopafter-cf",false,"",
              Set_spec,&cf_r,
              "Stop after control-flow checking");
  make_option(opt26,"-stopafter-toc",false,"",
              Set_spec,&toc_r,
              "Stop after translation to C");
  make_option(opt27,"-ic",false,"",
              Set_spec,&ic_r,
              "Activate the link-checker");
  make_option(opt28,"-pp",false,"",
              Set_spec,&pp_r,
              "Pretty print the C code that Cyclone generates");
  make_option(opt29,"-up",false,"",
              Clear_spec,&pp_r,
              "Ugly print the C code that Cyclone generates (default)");
  make_option(opt30,"-elim-statement-expressions",false,"",
              Set_spec,&elim_se_r,
              "Avoid statement expressions in C output"
              " (implies --inline-checks)");
  make_option(opt31,"-no-elim-statement-expressions",false,"",
              Clear_spec,&elim_se_r,
              "Do not avoid statement expressions in C output");
  make_option(opt32,"-un-gcc",false,"",
              Unit_spec,set_tovc,
              "Avoid gcc extensions in C output (except for attributes)");
  make_option(opt33,"-c-comp",false," <compiler>",
              String_spec,set_c_compiler,
              "Produce C output for the given compiler");
  make_option(opt34,"-save-temps",false,"",
              Unit_spec,set_save_temps,
              "Don't delete temporary files");
  make_option(opt35,"-save-c",false,"",
              Set_spec,&save_c_r,
              "Don't delete temporary C files");
  make_option(opt36,"--nolineno",false,"",
              Unit_spec,clear_lineno,
              "Don't generate line numbers for debugging (automatic with -pp)");
  make_option(opt37,"--nochecks",false,"",
              Unit_spec,set_nochecks,
              "Disable bounds/null checks");
  make_option(opt38,"--nonullchecks",false,"",
              Unit_spec,set_nonullchecks,
              "Disable null checks");
  make_option(opt39,"--noboundschecks",false,"",
              Unit_spec,set_noboundschecks,
              "Disable bounds checks");
  make_option(opt40,"--inline-checks",false,"",
              Unit_spec,set_inline_functions,
              "Inline bounds checks instead of #define");
  make_option(opt41,"-use-cpp",false,"<path>",
              String_spec,set_cpp,
              "Indicate which preprocessor to use");
  make_option(opt42,"-no-cpp-precomp",false,"",
              Unit_spec,set_nocppprecomp,
              "Don't do smart preprocessing (mac only)");
  make_option(opt43,"-nocyc",false,"",
              Unit_spec,set_nocyc,
              "Don't add implicit namespace Cyc");
  make_option(opt44,"-nogc",false,"",
              Set_spec,&nogc_r,
              "Don't link in the garbage collector");
  make_option(opt45,"-noremoveunused",false,"",
              Set_spec,&noshake_r,
              "Don't remove externed variables that aren't used");
  make_option(opt46,"-noexpandtypedefs",false,"",
              Set_spec,&noexpand_r,
              "Don't expand typedefs in pretty printing");
  make_option(opt47,"-printalltvars",false,"",
              Set_spec,&print_all_tvars_r,
              "Print all type variables (even implicit default effects)");
  make_option(opt48,"-printallkinds",false,"",
              Set_spec,&print_all_kinds_r,
              "Always print kinds of type variables");
  make_option(opt49,"-printfullevars",false,"",
              Set_spec,&print_full_evars_r,
              "Print full information for evars (type debugging)");
  make_option(opt50,"-printalleffects",false,"",
              Set_spec,&print_all_effects_r,
              "Print effects for functions (type debugging)");
  make_option(opt51,"-nocyc_setjmp",false,"",
              Set_spec,&nocyc_setjmp_r,
              "Do not use compiler special file cyc_setjmp.h");
  make_option(opt52,"-compile-for-boot",false,"",
              Set_spec,&Lex::compile_for_boot_r,
              "Compile using the special boot library instead of the standard library");
  make_option(opt53,"-CI",false," <file>",
              String_spec,set_cyc_include,
              "Set cyc_include.h to be <file>");
  make_option(opt54,"-warnboundschecks", false, "",
              Set_spec,&Toc::warn_bounds_checks,
              "Warn when bounds checks can't be eliminated");
  make_option(opt55,"-warnnullchecks", false, "",
              Set_spec,&Toc::warn_all_null_deref,
              "Warn when any null check can't be eliminated");
  make_option(opt56,"-warnaliascoercion", false, "",
              Set_spec,&Tcutil::warn_alias_coerce,
              "Warn when any alias coercion is inserted");
  make_option(opt57,"-warnregioncoerce", false, "",
              Set_spec,&Tcutil::warn_region_coerce,
              "Warn when any region coercion is inserted");
  make_option(opt58,"-noregister", false, "",
              Set_spec,&Parse::no_register,
              "Treat register storage class as public");
  make_option(opt59,"-detailedlocation", false, "",
              Clear_spec,&Position::use_gcc_style_location,
              "Try to give more detailed location information for errors");
  make_option(opt60,"-port", false, "",
              Unit_spec,set_port_c_code,
              "Suggest how to port C code to Cyclone");
  make_option(opt61,"-noregions", false, "",
              Set_spec,&Absyn::no_regions,
              "Generate code that doesn't use regions");
  make_option(opt62,"-iprefix",false,"<prefix>", 
              String_spec,add_iprefix,
              "Specify <prefix> as the prefix for subsequent -iwithprefix options");
  make_option(opt63,"-iwithprefix",false,"<dir>",
              String_spec,add_iwithprefix,
              "Add <prefix>/<dir> to the second include path.");
  make_option(opt64,"-iwithprefixbefore",false,"<dir>",
              String_spec,add_iwithprefixbefore,
              "Add <prefix>/<dir> to the main include path.");
  make_option(opt65,"-isystem",false,"<dir>",
              String_spec,add_isystem,
              "Add <dir> to the beginning of the second include path and treat it as a\nsystem directory.");
  make_option(opt66,"-idirafter",false,"<dir>",
              String_spec,add_idirafter,
              "Add the directory to the second include path.");
  make_option(opt67,"--geninterface",false,"",
              Set_spec,&generate_interface_r,
              "Generate interface files");
  make_option(opt68,"--interface",false," <file>",
              String_spec,set_specified_interface,
              "Set the interface file to be <file>.");
  make_option(opt69,"--manyerrors",false, "",
              Unit_spec,set_many_errors,
              "don't stop after only a few errors.");
  make_option(opt70,"--parsestate",false, "",
              Set_spec,&ParseErrors::print_state_and_token,
              "print the parse state and token on a syntax error");
  make_option(opt71,"-known-gcc-flags-only",false,"",
              Unit_spec,noassume_gcc_flag,
              "do not assume that unknown flags should be passed to gcc");
  make_option(opt72,"-help",false,"",
              Unit_spec,print_options,
              "print out the available options");
  make_option(opt73,"-usage",false,"",
              Unit_spec,print_options,
              "print out the available options");

  struct List<option_t@`H,`H>@`H global_options[] = {
            &opt1, &opt2, &opt3, &opt4, &opt5, &opt6, &opt7, &opt8, &opt9, 
    &opt10,&opt11,&opt12,&opt13,&opt14,&opt15,&opt16,&opt17,&opt18,&opt19, 
    &opt20,&opt21,&opt22,&opt23,&opt24,&opt25,&opt26,&opt27,&opt28,&opt29, 
    &opt30,&opt31,&opt32,&opt33,&opt34,&opt35,&opt36,&opt37,&opt38,&opt39, 
    &opt40,&opt41,&opt42,&opt43,&opt44,&opt45,&opt46,&opt47,&opt48,&opt49, 
    &opt50,&opt51,&opt52,&opt53,&opt54,&opt55,&opt56,&opt57,&opt58,&opt59, 
    &opt60,&opt61,&opt62,&opt63,&opt64,&opt65,&opt66,&opt67,&opt68,&opt69, 
    &opt70,&opt71,&opt72,&opt73
  };

  void print_options() {
    Arg::usage(global_options[0],"<program.cyc>");
  }
}

int main(int argc, string_t<`H> ?`H argv) {
  //  GC_dont_gc = true;
  /* Don't print garbage collector warnings about allocations of 
     blacklisted blocks.  This turns up on OS X and possibly other
     BSD systems (??) */
  GC_blacklist_warn_clear();

  let cyclone_arch_path;
  string_t def_lib_path;
  string_t comp = Cstring_to_string(Ccomp);

  // parse the command-line arguments
  region r; {
    // partition the arguments into (-B and -b) and others
    let bindices = new {for i<argc: false};
    let numbindices = 0;
    int i,j,k;
    for (i = 1; i<argc; i++) { //NB arg 0 is the command
      if (strncmp("-B",argv[i],2) == 0) {
        bindices[i] = true;
        numbindices++;
      }
      else if (strcmp("-b",argv[i]) == 0) {
        bindices[i] = true;
        numbindices++;
        i++; if (i>=argc) break;
        bindices[i] = true;
        numbindices++;
      }
    }

    // FIX: have to heap allocate these because that's what Arg::parse wants
    // FIX: maybe we should expose an Arg function to take args
    //   one at a time, that would let us avoid the nonsense with argv[0]
    let bargs = new { for n<numbindices+1 : (string_t)NULL };
    let otherargs = new { for n<argc-numbindices : (string_t)NULL };
    bargs[0] = otherargs[0] = argv[0];
    for (i = j = k = 1; i<argc; i++) {
      if (bindices[i]) bargs[j++] = argv[i];
      else otherargs[k++] = argv[i];
    }

    // initialize the global options list tails
    for (int i = 1; i < numelts(global_options); i++) {
      global_options[i-1]->tl = global_options[i];
    }
    Arg::speclist_t<`H,`H> options = global_options[0];

  string_t optstring = "Options:";
  Arg::current = 0;
  Arg::parse(options, add_other, add_other_flag, optstring, bargs);
  // Having processed -B and -b, we can now construct the exec-path
  // and arch-path
  if (target_arch == NULL) target_arch = Cstring_to_string(Carch);
  // The Cyclone exec-path is a list of directories where special
  // files (cyc_include.h, specs files, etc.) might be kept.
  // It is specified with the following order (where the earlier in
  // the order, the first place we look for the file):
  // 1) command line arguments (with -B)
  // 2) environment var (with CYCLONE_EXEC_PREFIX)
  // 3) hardwired in the build (by setting lib_path)
  string_t cyclone_exec_prefix = getenv("CYCLONE_EXEC_PREFIX");
  if (cyclone_exec_prefix != NULL)
    cyclone_exec_path = new List(new cyclone_exec_prefix, cyclone_exec_path);
  def_lib_path = Cstring_to_string(Cdef_lib_path);
  if (strlen(def_lib_path) > 0)
    cyclone_exec_path =
     new List(new (const char ?)Filename::concat(def_lib_path, "cyc-lib"),
              cyclone_exec_path);
  cyclone_exec_path = List::imp_rev(cyclone_exec_path);
  cyclone_arch_path = also_subdir(cyclone_exec_path, target_arch);

  // Now we find the specs file and see if it has any default arguments
  // for Cyclone (which will override defaults given here)
  // NB: we chose "cycspecs" as the name of the specs file instead of
  // the usual "specs" because if "specs" is used, gcc uses its own
  // default file "specs" and not ours.
  let specs_file = do_find(cyclone_arch_path,"cycspecs");
  if (v_r) fprintf(stderr,"Reading from specs file %s\n",specs_file);
  let specs = read_specs(specs_file);
  let args_from_specs_file = NULL;
  try {
    let cyclone_args = *List::assoc_cmp(strptrcmp, specs, new "cyclone");
    args_from_specs_file = split_specs(cyclone_args);
  } catch {
  case &Not_found: break;
  }
  if (args_from_specs_file != NULL) {
    Arg::current = 0;
    Arg::parse(options, add_other, add_other_flag, optstring, args_from_specs_file);
  }
  // Finally parse the other command-line arguments
  Arg::current = 0;
  Arg::parse(options, add_other, add_other_flag, optstring, otherargs);
  if (strcmp(cpp,"") == 0) {
    // If cpp string is not explicitly set, use the default.
    // NB the -w suppresses preprocessor warnings.  It's needed
    // because sometimes cpp complains about macros being redefined,
    // typically when cross-compiling; but I can't figure out exactly
    // when or why this happens.  For example, on
    // powerpc-apple-rhapsody,
    //   echo | gcc - -E -D__SIZE_TYPE__
    // complains about redefining __SIZE_TYPE__, however,
    //   echo | gcc - -E -dM
    // does not show that __SIZE_TYPE__ is ever defined.  This
    // results in warnings when compiling i686-unknown-linux on
    // powerpc-apple-rhapsody, since linux uses __SIZE_TYPE__.
    // NB we use the -E flag unless the -M flag has been used.  If
    // -E and -M are used together in some versions of gcc, we get a
    // compiler error, cpp0: too many filenames.
    let dash_E = (produce_dependencies ? "" : " -E");
    set_cpp(aprintf("%s -w -x c%s -specs %s", comp, dash_E, specs_file));
  }
  } // end region r
  if (cyclone_files == NULL && ccargs == NULL) {
    fprintf(stderr,"missing file\n");
    exit(1);
  }
  
  // Find the files cyc_setjmp.h and cyc_include.h, needed to produce
  // the .c output.
  /* The absolute file name is kept in a global variable */
  /* don't bother if we won't translate to C or if set explicitly */
  if (!stop_after_cpp_r && !nocyc_setjmp_r)
    cyc_setjmp = do_find(cyclone_arch_path,"cyc_setjmp.h");
  if (!stop_after_cpp_r && strlen(cyc_include) == 0)
    cyc_include = do_find(cyclone_exec_path,"cyc_include.h");

  /* Process each .cyc file */
  for (let l = rev(cyclone_files); l != NULL; l = l->tl) {
    process_file(*(l->hd));
    if (compile_failure) return 1;
  }

  if (stop_after_cpp_r || parseonly_r || tc_r || toc_r) return 0;

  // If there are no files for the C compiler to process don't bother
  // to run it.
  // FIX: this is no longer a good check, as we add_ccargs -L stuff;
  //  we should keep a separate list of c_files
  if (ccargs == NULL) return 0;

  // Run the C compiler
  add_ccarg(strconcat("-L",def_lib_path));

  ccargs = rev(ccargs);
  let ccargs_string = str_sepstr(List::map(sh_escape_stringptr,ccargs), " ");
  libargs = rev(libargs);
  let libargs_string = str_sepstr(new List(new "",
					   List::map(sh_escape_stringptr,libargs)), " ");

  let stdlib;
  let stdlib_string;
  let is_not_executable =
    stop_after_asmfile_r ||
    stop_after_objectfile_r ||
    (output_file != NULL && Filename::check_suffix(*output_file, ".a")) ||
    (output_file != NULL && Filename::check_suffix(*output_file, ".lib")); 
  if (is_not_executable) {
    stdlib = NULL;
    stdlib_string = (string_t)"";
  } else {

    // FIX: -g should get different versions of the libraries?
    string_t libcyc_flag;
    string_t nogc_filename;
    string_t runtime_filename;
    string_t gc_filename; 
    if(pa_r) {
      libcyc_flag = "-lcyc_a";
      nogc_filename = "nogc_a.a";
      runtime_filename = "runtime_cyc_a.o";
    } else if(nocheck_r) {
      libcyc_flag = "-lcyc_nocheck";
      nogc_filename = "nogc.a";
      runtime_filename = "runtime_cyc.o";
    } else if(pg_r) {
      libcyc_flag = "-lcyc_pg";
      runtime_filename = "runtime_cyc_pg.o";
      nogc_filename = "nogc_pg.a";
    } else if(Lex::compile_for_boot_r) {
      // FIX: all the above cases should take compile_for_boot into account
      libcyc_flag = "-lcycboot";
      nogc_filename = "nogc.a";
      runtime_filename = "runtime_cyc.o";
    } else {
      libcyc_flag = "-lcyc";
      nogc_filename = "nogc.a";
      runtime_filename = "runtime_cyc.o";
    }
    gc_filename = "gc.a";

    let gc = (nogc_r ?
              do_find(cyclone_arch_path,nogc_filename):
              do_find(cyclone_arch_path,gc_filename));
    let runtime = do_find(cyclone_arch_path,runtime_filename);

    // FIX: temporarily removed from interface check below
    //stdlib = list(new libcyc_flag);
    stdlib = NULL;
    stdlib_string = aprintf(" %s %s %s", runtime, libcyc_flag, gc);
  }

  if (ic_r) try {
    ccargs = filter(is_cfile, ccargs);
    libargs = filter(is_cfile, libargs);
    let lf = append(stdlib, append(ccargs, libargs));
    if (! is_not_executable) {
      lf = new List(final_strptr, lf);
    }

    let i = Interface::get_and_merge_list(read_cycio, lf, lf);
    if (i == NULL) {
      fprintf(stderr,"Error: interfaces incompatible\n");
      compile_failure = true;
      remove_cfiles();
      return 1;
    }
    if (is_not_executable) {
      if (output_file != NULL) {
	let output_file_io = aprintf("%s.cycio", Filename::chop_extension(*output_file));
	let f = try_file_open(output_file_io, "wb", "interface object file");
	if (f == NULL) {
	  compile_failure = true;
	  remove_cfiles();
	  return 1;
	}
	Interface::save(i, f);
	file_close(f);
      }
    } else {
      if(!Interface::is_subinterface(Interface::empty(), i,
				     new $("empty interface", "global interface"))) {
	fprintf(stderr,"Error: some objects are still undefined\n");
	compile_failure = true;
	remove_cfiles();
	return 1;
      }
    }
  } catch { 
  case e: 
    fprintf(stderr,"INTERNAL COMPILER FAILURE:  exception %s from around %s:%d thrown.\n  Please send bug report to cyclone-bugs-l@lists.cs.cornell.edu",Core::get_exn_name(e),Core::get_exn_filename(),Core::get_exn_lineno());
    compile_failure = true;
    remove_cfiles();
    return 1;
  }

  string_t outfile_str = "";
  if (output_file != NULL)
    outfile_str = aprintf(" -o %s",sh_escape_string(*output_file));

  let cccmd =
    aprintf("%s %s%s %s%s",comp,ccargs_string,outfile_str,stdlib_string,
            libargs_string);
  if (v_r) { fprintf(stderr,"%s\n",cccmd); fflush(stderr); }
  if (system((const char @)cccmd) != 0) {
    fprintf(stderr,"Error: C compiler failed\n");
    compile_failure = true;
    remove_cfiles();
    return 1;
  }
  remove_cfiles();

  return compile_failure ? 1 : 0;
}
