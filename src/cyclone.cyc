/* Driver for the Cyclone compiler.
   Copyright (C) 2001 Greg Morrisett, AT&T
   This file is part of the Cyclone compiler.

   The Cyclone compiler is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   The Cyclone compiler is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with the Cyclone compiler; see the file COPYING. If not,
   write to the Free Software Foundation, Inc., 59 Temple Place -
   Suite 330, Boston, MA 02111-1307, USA. */

#include <arg.h>
#include <string.h>
#include <filename.h>
#include "parse.h"
#include "absynpp.h"
#include "absyndump.h"
#include "binding.h"
#include "tcutil.h"
#include "tc.h"
#include "toc.h"
#include "remove_aggregates.h"
#include "toseqc.h"
#include "tovc.h"
#include "new_control_flow.h"
#include "insert_checks.h"
#include "interface.h"
#include "warn.h"
#include "specsfile.h"
#include "cyclone.h"
namespace Port {
  extern void port(List::list_t<Absyn::decl_t>);
}
namespace ParseErrors {
  extern bool print_state_and_token;
}
namespace Lex {
  extern bool compile_for_boot_r;
  extern void pos_init();
  extern void lex_init(bool use_cyclone_keywords);
}

using Cyclone;
using Core;
using List;
using Arg;
typedef Hashtable::table_t<`a,`b> table_t<`a,`b>;

static bool pp_r       = false;
bool noexpand_r = false;
static bool noshake_r  = false;
static bool stop_after_cpp_r = false;
static bool parseonly_r = false;
static bool tc_r       = false;
static bool cf_r       = false;
static bool noprint_r  = false;
static bool ic_r       = false;
static bool toc_r      = false;
static bool stop_after_objectfile_r = false;
static bool stop_after_asmfile_r = false;
static bool inline_functions_r = false;
static bool elim_se_r    = false;
static bool v_r        = false;
static bool save_temps_r = false;
static bool save_c_r   = false;
static bool nogc_r     = false;
static bool pa_r       = false;
static bool pg_r       = false;
static bool nocheck_r  = false;
static bool add_cyc_namespace_r = true;
static bool generate_line_directives_r = true;
static bool print_full_evars_r = false;
static bool print_all_tvars_r = false;
static bool print_all_kinds_r = false;
static bool print_all_effects_r = false;
static bool nocyc_setjmp_r = false;
static bool generate_interface_r = false;
static bool toseqc_r = true;

// Arguments to pass to the C compiler
static list_t<stringptr_t> ccargs = NULL;
static void add_ccarg(string_t<`H> s) {
  ccargs = new List(new s,ccargs);
}

// set which C compiler to use
// (affects how attributes, 64-bit integers, etc. are translated)
// defaults to gcc
void set_c_compiler(string_t<`H> s){
  if (strcmp(s,"vc") == 0) {
    c_compiler = Vc_c;
    add_ccarg("-DVC_C");
  }
  else if (strcmp(s,"gcc") == 0) {
    c_compiler = Gcc_c;
    add_ccarg("-DGCC_C");
  }
  // else invalid compiler -- warn? throw exception?
}

void set_port_c_code() {
  Absyn::porting_c_code = true;
  Position::max_errors = 65535; // allow a lot of errors
  save_c_r = true; // save temp files
  parseonly_r = true; // stop after parsing
}

static string_t *output_file = NULL;
static void set_output_file(string_t<`H> s) {
  output_file = new s;
}

static string_t specified_interface = NULL;
static void set_specified_interface(string_t<`H> s) {
  specified_interface = s;
}

// These strings are install_path.c, which is created by Makefile wizardry.
// We use Cstrings because we pull the same trick when bootstrapping (and
// then we don't have a Cyclone compiler yet)
// Given these settings we can get the cycspecs file which has other settings
extern "C" {
  extern Cstring Cdef_lib_path;
  extern Cstring Carch;
  extern Cstring Cversion;
}

static string_t cpp = "";
static void set_cpp(string_t<`H> s) {
  cpp = s;
}

static list_t<stringptr_t> cppargs = NULL;
static void add_cpparg(string_t<`H> s) {
  cppargs = new List(new s,cppargs);
}

static void add_cpp_and_ccarg(string_t<`H> s) {
  add_cpparg(s);
  add_ccarg(s);
}

static void add_iprefix(string_t<`H> s) {
  add_cpparg(aprintf("-iprefix %s",s));
}
static void add_iwithprefix(string_t<`H> s) {
  add_cpparg(aprintf("-iwithprefix %s",s));
}
static void add_iwithprefixbefore(string_t<`H> s) {
  add_cpparg(aprintf("-iwithprefixbefore %s",s));
}
static void add_isystem(string_t<`H> s) {
  add_cpparg(aprintf("-isystem %s",s));
}
static void add_idirafter(string_t<`H> s) {
  add_cpparg(aprintf("-idirafter %s",s));
}

static void set_many_errors() {
  Position::max_errors = 65535;
}

static const char ?def_inc_path = "_see_cycspecs_file_";

// Prints the version # and exits
static void print_version() {
  printf("The Cyclone compiler, version %s\n", Cversion);
  printf("Compiled for architecture: %s\n", Carch);
  printf("Standard library directory: %s\n",Cdef_lib_path);
  // FIX: should read the cycspecs file first to print the right thing here
  printf("Standard include directory: %s\n",def_inc_path);
  exit(0);
}

static bool is_cyclone_sourcefile(string_t s) {
  let len = strlen(s);
  if (len <= 4) return false;
  else return (strcmp(s+(len-4),".cyc") == 0);
}

// Ideally we would simply pass library args as ccargs, preserving
// their order with the other ccargs.  But if, e.g., -lm precedes
// libcyc.a, then we get a "multiple definitions of main" error, via
// libmain.c.  So, we separate out the library args from the ccargs
// so that we can force libcyc.a to appear first.
//
// We treat Cyclone libraries differently from C libraries.  As a hack,
// we place any library that begins with prefix "cyc" in the ccargs,
// otherwise in the libargs.  Should probably change the XML library
// to begin with the cyc prefix.
static list_t<stringptr_t> libargs = NULL;
static void add_libarg(string_t<`H> s) {
  if (strcmp(s,"-lxml") == 0)
    if (!pa_r)
      add_ccarg(s);
    else
      add_ccarg("-lxml_a");
  else if (strncmp(s,"-lcyc",5) == 0)
    add_ccarg(s);
  else
    libargs = new List(new s,libargs);
}

static void add_marg(string_t<`H> s) {
  add_ccarg(s);
}

static void set_save_temps() {
  save_temps_r = true;
  add_ccarg("-save-temps");
}

static bool produce_dependencies = false;
static void set_produce_dependencies() {
  stop_after_cpp_r = true;
  produce_dependencies = true;
  add_cpparg("-M");
}

static string_t *dependencies_target = NULL;
static void set_dependencies_target(string_t<`H> s) {
  dependencies_target = new s;
}

static void set_stop_after_objectfile() {
  stop_after_objectfile_r = true;
  add_ccarg("-c");
}

static void set_nocppprecomp() {
  add_cpp_and_ccarg("-no-cpp-precomp");
}

static void clear_lineno() {
  generate_line_directives_r = false;
  set_save_temps();
}
static void set_inline_functions() {
  inline_functions_r = true;
}
static void set_elim_se() {
  elim_se_r = true;
  set_inline_functions();
}
static void set_tovc() {
  tovc_r = true;
  add_ccarg("-DCYC_ANSI_OUTPUT");
  set_elim_se();
}
static void set_notoseqc() {
  toseqc_r = false;
}
static void set_noboundschecks() {
  add_ccarg("-DNO_CYC_BOUNDS_CHECKS");
}
static void set_nonullchecks() {
  add_ccarg("-DNO_CYC_NULL_CHECKS");
}
static void set_nochecks() {
  set_noboundschecks();
  set_nonullchecks();
  nocheck_r = true;
}

static void set_nocyc() {
  add_cyc_namespace_r = false;
  add_ccarg("-DNO_CYC_PREFIX");
}

static void set_pa() {
  pa_r = true;
  add_ccarg("-DCYC_REGION_PROFILE");
  add_cpparg("-DCYC_REGION_PROFILE");
}

static void set_pg() {
  pg_r = true;
  add_ccarg("-pg");
}

static void set_stop_after_asmfile() {
  stop_after_asmfile_r = true;
  add_ccarg("-S");
}

static void set_all_warnings() {
  InsertChecks::warn_bounds_checks = true;
  InsertChecks::warn_all_null_deref = true;
  NewControlFlow::warn_lose_unique = true;
  Tcutil::warn_alias_coerce = true;
  Tcutil::warn_region_coerce = true;
  Tc::aggressive_warn = true;
  Binding::warn_override = true;
}

// This only works enough to support cycdoc so far
enum inputtype {
  DEFAULTINPUT,
  CYCLONEFILE
};
typedef enum inputtype inputtype_t;
static inputtype_t intype = DEFAULTINPUT;
static void set_inputtype(string_t s) {
  if (strcmp(s,"cyc") == 0)
    intype = CYCLONEFILE;
  else if (strcmp(s,"none") == 0)
    intype = DEFAULTINPUT;
  else
    fprintf(stderr,"Input type '%s' not supported\n",s);
}

string_t make_base_filename(string_t<`r> s, string_t<`r>* output_file) {
  let outdir = Filename::dirname(output_file == NULL ?  s : *output_file);
  let base = Filename::chop_extension(Filename::basename(s));
  // if outdir is empty, then just use base
  // otherwise, use outdir/base.
  // note that ""/base gets translated to /base, which is not what we wanted
  let basename = strlen(outdir) > 0 ? Filename::concat(outdir, base) : base;
  return (string_t)basename;
}


// Cyclone files given on the command line
static list_t<stringptr_t> cyclone_files = NULL;
// Like add_ccarg but intercepts .cyc files for special handling
static bool gcc_optarg = 0;
static void add_other(string_t<`H> s) {
  // for the case that we received a gcc option that has an argument
  if (gcc_optarg > 0) {
    add_ccarg(s);
    gcc_optarg--;
  }
  else if (intype == CYCLONEFILE || is_cyclone_sourcefile(s)) {
    // For processing by Cyclone
    cyclone_files = new List(new s,cyclone_files);

    // The C compiler wants the .c file, not the .cyc files
    // MWH: We set the C file relative to the input file directory,
    // rather than the output directory, because we may not have seen
    // the -o argument yet ...
    let basename = make_base_filename(s,NULL);
    let cfile    = strconcat(basename, ".c");
    add_ccarg(cfile);
  }
  else add_ccarg(s);
}

// This handles non-Cyclone flags, simply passing them through to gcc
// We have a table of well-known flags; others are
static bool assume_gcc_flag = true;
static bool add_other_flag(string_t<`H> s) {
  static struct { const char ?flag; int optargs; } known_gcc_flags[] = {
    { "-s", 0 },
    { "-O", 0 },
    { "-O0", 0 },
    { "-O2", 0 },
    { "-O3", 0 },
    { "-fomit-frame-pointer", 0 },
    { "-fno-builtin", 0 },
    { "-g", 0 },
    { "-p", 0 },
    { "-static", 0 }
  };
  if (assume_gcc_flag)
    add_ccarg(s);
  else {
    for (int i = 0; i<numelts(known_gcc_flags); i++) {
      if (!strcmp(known_gcc_flags[i].flag,s)) {
	add_ccarg(s);
	gcc_optarg = known_gcc_flags[i].optargs;
	break;
      }
    }
    return false;
  }
  return true;
}

static void noassume_gcc_flag() {
  assume_gcc_flag = false;
}

static void remove_file(string_t<`H> s) {
  if (save_temps_r) return;
  else remove((const char @)s);
}

////********************************************************************

bool compile_failure = false; // for exit code (helps Makefile)

FILE *try_file_open(string_t filename, string_t mode, string_t msg_part) {
  try return file_open(filename,mode);
  catch {
  default:
    compile_failure = true;
    fprintf(stderr, "\nError: couldn't open %s %s\n", msg_part, filename);
    fflush(stderr);
    return NULL;
  }
}

extern "C" void CYCALLOCPROFILE_mark(const char *s);

`b do_stage(string_t stage_name, list_t<Absyn::decl_t,`H> tds,
	    `b f(`a, list_t<Absyn::decl_t,`H>), `a env,
	    void on_fail(`c), `c failenv) {
  CYCALLOCPROFILE_mark(stage_name);

  let ans;
  try ans = f(env,tds);
  catch {
  case x:
    // Only throw the exception if it wasn't the result of a cascading error
    if (Position::error_p()) {
      compile_failure = true;
      on_fail(failenv);
      fprintf(stderr,"\nCOMPILATION FAILED!\n");
      fflush(stderr);
    }
    else {
      fprintf(stderr,"COMPILER STAGE %s\n",stage_name);
      on_fail(failenv);
    }
    Core::rethrow(x);
    break;
  }
  if (Position::error_p())
    compile_failure = true;
  if (compile_failure) {
    on_fail(failenv);
    fprintf(stderr,"\nCOMPILATION FAILED!\n");
    fflush(stderr);
    return ans;
  }
  else if (v_r) {
    fprintf(stderr,"%s completed.\n",stage_name);
    fflush(stderr);
    return ans;
  }
  return ans;
}

static void ignore(`a x) {}
static void remove_fileptr(mstringptr_t<`H> s) { remove_file(*s); }

list_t<Absyn::decl_t> do_parse(FILE @ f, list_t<Absyn::decl_t,`H> ignore) {
  Lex::lex_init(true); // must forget typedefs, may as well flush symbols too
  Lex::pos_init();
  list_t<Absyn::decl_t> ans = NULL;
  try {
    ans = Parse::parse_file(f);
    file_close(f);
  } catch {
  case &Parse::Exit: file_close(f); compile_failure = true; break;
  case e: file_close(f); rethrow(e);
  }
  Lex::lex_init(true); // garbage collect those big tries
  return ans;
}

bool do_binding(bool ignore, list_t<Absyn::decl_t,`H> tds) {
  Binding::resolve_all(tds);
  return true;
}

list_t<Absyn::decl_t> do_typecheck(Tcenv::tenv_t te,
				   list_t<Absyn::decl_t,`H> tds){
  Tc::tc(te, true, tds);
  if (!noshake_r)
    tds = Tc::treeshake(te,tds);
  return tds;
}

JumpAnalysis::jump_anal_res_t do_jumpanalysis(bool ignore,
					      list_t<Absyn::decl_t,`H> tds) {
  return JumpAnalysis::jump_analysis(tds);
}

list_t<Absyn::decl_t> do_cfcheck(JumpAnalysis::jump_anal_res_t tables,
				 list_t<Absyn::decl_t,`H> tds) {
  NewControlFlow::cf_check(tables,tds);
  return tds;
}

bool do_insert_checks(bool ignore, list_t<Absyn::decl_t,`H> tds) {
  InsertChecks::insert_checks(tds);
  return true;
}

// do_interface [te] [if] [ifo] [decls] where [if] is the interface (cyci)
// file, and [ifo] is the cycio file for the output
list_t<Absyn::decl_t> do_interface($(Tcenv::tenv_t, FILE *`H, FILE @`H)@ params,
				   list_t<Absyn::decl_t,`H> tds) {
  let &$(te, fi, fo) = params;
  let i1 = Interface::extract(te->ae, tds);
  if (fi == NULL) {
    Interface::save(i1, fo);
  } else {
    let i0 = Interface::parse(fi);
    if (!Interface::is_subinterface(i0, i1, new $("written interface", "maximal interface")))
      compile_failure = true;
    else
      Interface::save(i0, fo);
  }
  return tds;
}
void interface_fail($(Tcenv::tenv_t, FILE *`H, FILE @`H)@ params) {
  let &$(_, fi, fo) = params;
  if(fi != NULL)
    file_close(fi);
  file_close(fo);
}

list_t<Absyn::decl_t>
do_translate(table_t<Absyn::fndecl_t,table_t<Absyn::stmt_t,int>> pops,
	     list_t<Absyn::decl_t> tds) {
  return Toc::toc(pops,tds);
}
list_t<Absyn::decl_t> do_removeaggrs(bool ignore,list_t<Absyn::decl_t,`H> tds) {
  return RemoveAggrs::remove_aggrs(tds);
}

list_t<Absyn::decl_t> do_toseqc(bool ignore, list_t<Absyn::decl_t,`H> tds) {
  return Toseqc::toseqc(tds);
}
list_t<Absyn::decl_t> do_tovc(bool ignore, list_t<Absyn::decl_t> tds) {
  Tovc::elim_array_initializers = tovc_r;
  return Tovc::tovc(tds);
}

static string_t cyc_setjmp = NULL;
/* The absolute file name of cyc_include.h */
static string_t cyc_include = NULL;

static void set_cyc_include(string_t<`H> f) {
  cyc_include = f;
}

/* return 1 on error, 0 on no error */
int copy_internal_file(string_t file, FILE @out_file) {
  // FIX: would be better to use open, stat, and read but we don't
  // have all those functions in the library yet.
  if (file == NULL) {
    fprintf(stderr,"Internal error: copy_internal_file called with NULL\n");
    return 1;
  }
  let file_f = try_file_open(file,"r","internal compiler file");
  if (file_f == NULL) return 1;
  size_t n_read = 1024;
  size_t n_written;
  char buf[1024] = { for i < 1024 : 0 }; // init to avoid warning
  while (n_read == 1024) {
    n_read = fread(buf,1,1024,file_f);
    if (n_read != 1024 && !(feof(file_f))) {
      compile_failure = true;
      fprintf(stderr, "\nError: problem copying %s\n",file);
      fflush(stderr);
      return 1;
    }
    n_written = fwrite(buf,1,n_read,out_file);
    if (n_read != n_written) {
      compile_failure = true;
      fprintf(stderr, "\nError: problem copying %s\n",file);
      fflush(stderr);
      return 1;
    }
  }
  fclose(file_f);
  return 0;
}

// We must remember what .c files are produced so that we can remove them
// after we're done.
static list_t<mstringptr_t> cfiles = NULL;
static void remove_cfiles() {
  if (!save_c_r)
    for (; cfiles != NULL; cfiles = cfiles->tl)
      remove_file(*(cfiles->hd));
}
static void find_fail(string_t file) {
  compile_failure = true;
  remove_cfiles();
  throw new Core::Failure(aprintf("Error: can't find internal compiler file %s\n", file));
}
static string_t find_in_arch_path(string_t s) {
  let r = Specsfile::find_in_arch_path(s);
  if (!r) find_fail(s);
  return r;
}
static string_t find_in_exec_path(string_t s) {
  let r = Specsfile::find_in_exec_path(s);
  if (!r) find_fail(s);
  return r;
}

list_t<Absyn::decl_t> do_print($(FILE@`H,mstring_t<`H>) @env,
			       list_t<Absyn::decl_t,`H> tds) {
  let &$(out_file,cfile) = env;
    let params_r = tc_r ? Absynpp::cyc_params_r : Absynpp::c_params_r;
  params_r.expand_typedefs = ! noexpand_r;
  params_r.to_VC = tovc_r;
  params_r.add_cyc_prefix = add_cyc_namespace_r;
  params_r.generate_line_directives = generate_line_directives_r;
  params_r.print_full_evars = print_full_evars_r;
  params_r.print_all_tvars = print_all_tvars_r;
  params_r.print_all_kinds = print_all_kinds_r;
  params_r.print_all_effects = print_all_effects_r;

  if (inline_functions_r)
    fprintf(out_file,"#define _INLINE_FUNCTIONS\n");

  // Copy cyc_setjmp.h and cyc_include.h to out_file.
  if (!parseonly_r && !tc_r && !cf_r) {
    if (!nocyc_setjmp_r) {
      if (Lex::compile_for_boot_r)
        fprintf(out_file,"#include <setjmp.h>\n");
      else if (copy_internal_file(cyc_setjmp,out_file)) return tds;
    }
    if (copy_internal_file(cyc_include,out_file)) return tds;
  }
  if (pp_r) {
    Absynpp::set_params(&params_r);
    Absynpp::decllist2file(tds,out_file);
  } else {
    Absyndump::set_params(&params_r);
    Absyndump::dumpdecllist2file(tds,out_file);
  }
  fflush(out_file);
  file_close(out_file);
  cfiles = new List(new cfile,cfiles);
  return tds;
}
void print_fail($(FILE@`H,mstring_t<`H>) @env) {
  let &$(out_file,cfile) = env;
  file_close(out_file);
  cfiles = new List(new strdup(cfile),cfiles);
}

// Take as input a string, return the list of substrings separated by colons
static list_t<stringptr_t> split_by_char(string_t<`H> s, char c) {
  if (s == NULL) return NULL;
  let result = NULL;
  let len = strlen(s);

  while (len > 0) {
    let end = strchr(s,c);
    if (end == NULL) {
      result = new List(new s,result);
      break;
    }
    else {
      result = new List(new ((string_t)substring(s,0,(string_t)end-s)),result);
      len -= ((string_t)end-s);
      s = end+1;
    }
  }
  return List::imp_rev(result);
}

/* Given: dirs=[d1,d2,..,dn]
   Return:     [d1/subdir,d2/subdir,..,dn/subdir] */
static list_t<const char ?`H@`H>
add_subdir(list_t<const char ?`H@`H> dirs, const char ?subdir) {
  let l = NULL;
  for (; dirs != NULL; dirs = dirs->tl) {
    l = new List(new (const char ?)Filename::concat(*dirs->hd,subdir),l);
  }
  l = List::imp_rev(l);
  return l;
}

/* Is a character special to /bin/sh (except for single quote)? */
static bool is_other_special(char c) {
  switch (c) {
  case '\\':
  case '"':
  case ';':
  case '&':
  case '(':
  case ')':
  case '|':
  case '^':
  case '<':
  case '>':
  // JGM: I'm commenting this out because we shouldn't be quoting
  // arguments like -idirafter.
  // case ' ':
  case '\n':
  case '\t': return true;
  default: return false;
  }
}

/* Escape any characters special to /bin/sh */
static string_t sh_escape_string(string_t<`H> s) {
  let len = strlen(s);

  /* Count the number of single quotes and other special chars in s */
  let single_quotes = 0;
  let other_special = 0;
  for (int i = 0; i < len; i++) {
    let c = s[i];
    if (c == '\'') single_quotes++;
    else if (is_other_special(c)) other_special++;
  }

  /* No special chars to escape */
  if (single_quotes == 0 && other_special == 0)
    return s;

  /* No single quotes, we can just single quote s */
  if (single_quotes == 0)
    return strconcat_l(list(new "'",new (string_t)s, new "'"));

  /* We'll quote all special chars by prefixing with a backslash */
  let len2 = len + single_quotes + other_special;
  mstring_t s2 = new {for i < len2+1 : '\0'}; // add trailing NUL
  let i = 0;
  let j = 0;
  for (; i < len; i++) {
    let c = s[i];
    if (c == '\'' || is_other_special(c))
      s2[j++] = '\\';
    s2[j++] = c;
  }
  return s2;
}
static stringptr_t sh_escape_stringptr(stringptr_t<`H,`H> sp) {
  return new sh_escape_string(*sp);
}

static void process_file(string_t<`H> filename) {

  let basename = make_base_filename(filename, output_file);
  let preprocfile = strconcat(basename, ".cyp");
  let interfacefile = (specified_interface != NULL) ?
                        specified_interface : strconcat(basename, ".cyci");
  let interfaceobjfile = strconcat(basename, ".cycio");
  // MWH: we do the c file relative to the input file, rather than the
  // output file as for the rest, because setting the ccargs earlier
  // may not have seen the -o option at that time
  let cfile = strconcat(make_base_filename(filename,NULL), ".c");
  let preprocfileptr = new preprocfile;

  if (v_r) fprintf(stderr,"Compiling %s\n", filename);

  // Check that the input file exists
  FILE * f0 = try_file_open(filename, "r", "input file");
  if (compile_failure || !f0)
    return;
  fclose(f0);

  // Run the preprocessor, by building and running a command-line
  // Pass -I and -D things onto preprocessor.
  let cppargs_string =
    str_sepstr(new List(new (string_t)"",
                        List::map(sh_escape_stringptr,rev(cppargs))),
               " ");
  // About the cyclone include path---this path is specified with the
  // following order (where the earlier in the order, the first place we look
  // for the file):
  // 1) command line arguments (with -I and -B)
  // 2) environment var (CYCLONE_INCLUDE_PATH)
  // 3) hardwired in the build (by setting def_inc_path and def_lib_path)
  let stdinc_dirs = add_subdir(Specsfile::cyclone_exec_path,Specsfile::target_arch);
  stdinc_dirs = add_subdir(stdinc_dirs,"include");
  if (strlen(def_inc_path) > 0) {
    stdinc_dirs = new List(new def_inc_path, stdinc_dirs);
  }
  let cyclone_include_path = getenv("CYCLONE_INCLUDE_PATH");
  if (cyclone_include_path != NULL) {
    stdinc_dirs = List::append(split_by_char(cyclone_include_path,':'),
                               stdinc_dirs);
  }
  string_t stdinc_string =
    str_sepstr(new List(new (string_t)"",
                        List::map(sh_escape_stringptr,stdinc_dirs)),
               " -I");
  string_t ofile_string;
  if (stop_after_cpp_r) {
    if (output_file != NULL)
      ofile_string = aprintf(" > %s", *output_file);
    else // output to standard out
      ofile_string = "";
  }
  else ofile_string = aprintf(" > %s", sh_escape_string(preprocfile));

  string_t fixup_string;
  if (produce_dependencies)
    // Both of the below hacks can probably be eliminated when we move
    // to gcc 3.0
    if (dependencies_target == NULL)
      // Hack to fix up dependency output of gcc 2.95: the target of
      // the dependency produced by cpp will be something like foo.cyc.o,
      // but we want it to be foo.o.
      fixup_string = " | sed 's/^\\(.*\\)\\.cyc\\.o:/\\1.o:/'";
    else {
      // Hack to handle the -MT flag, which is not supported in gcc 2.95
      // Note, we should probably make sure any special characters in
      // *dependencies_target are escaped, but WE DON'T.
      fixup_string =
        aprintf(" | sed 's/^.*\\.cyc\\.o:/%s:/'",
                *dependencies_target);
    }
  else fixup_string = "";

  let cmd = aprintf("%s %s%s %s%s%s",
	            cpp,
                    cppargs_string, stdinc_string,
                    sh_escape_string(filename),
                    fixup_string, ofile_string);

  if (v_r) fprintf(stderr,"%s\n",cmd);
  if (system((const char @)cmd) != 0) {
    compile_failure = true;
    fprintf(stderr,"\nError: preprocessing\n");
    if (!stop_after_cpp_r) remove_file(preprocfile);
    return;
  }
  if (stop_after_cpp_r) return;

  // Run the stages of the Cyclone compiler
  Position::reset_position(preprocfile); // necessary for good error messages!
  FILE * in_file  = try_file_open(preprocfile,"r","file");
  if (compile_failure) return;

  list_t<Absyn::decl_t> tds = NULL;

  // Parsing
  tds = do_stage("parsing", tds, do_parse, (FILE@)in_file,
		 remove_fileptr, preprocfileptr);
  if(compile_failure) return;

  if (Absyn::porting_c_code) {
    Port::port(tds);
    return;
  }
  // Binding resolution
  do_stage("binding", tds, do_binding, true, remove_fileptr, preprocfileptr);
  if(compile_failure) return;

  let jump_tables;
  { let te = Tcenv::tc_init(); // Must declare BEFORE the goto

    if (parseonly_r) goto PRINTC;

    // Type checking
    tds = do_stage("type checking", tds, do_typecheck, te,
		   remove_fileptr, preprocfileptr);
    if(compile_failure) return;

    // Jump analysis
    jump_tables = do_stage("jump checking", tds, do_jumpanalysis, true,
			   remove_fileptr, preprocfileptr);
    if(compile_failure) return;

    // Control-flow checking
    if (tc_r) goto PRINTC;
    do_stage("control-flow checking", tds, do_cfcheck, jump_tables,
	     remove_fileptr, preprocfileptr);
    if (compile_failure) return;
    do_stage("check insertion", tds, do_insert_checks, true,
	     remove_fileptr, preprocfileptr);
    if (compile_failure) return;
    
    // Generate interface file
    if (generate_interface_r) {
      FILE *inter_file = try_file_open((const char @)interfacefile,"w","interface file");
      if (inter_file == NULL) {
        compile_failure = true;
	return;
      }
      Absyndump::set_params(&Absynpp::cyci_params_r);
      Absyndump::dump_interface(tds, inter_file);
      fclose(inter_file);
      Absynpp::set_params(&Absynpp::tc_params_r);
    }

    // Interface checking
    if (ic_r) {
      FILE *inter_file = fopen((const char @)interfacefile, "r");
      FILE *inter_objfile = try_file_open(interfaceobjfile, "w", "interface object file");
      if (inter_objfile == NULL) {
        compile_failure = true;
        return;
      }
      Position::reset_position(interfacefile);
      let int_env = $(te, inter_file, (FILE@)inter_objfile);
      tds = do_stage("interface checking", tds, do_interface, &int_env,
		     interface_fail, &int_env);
    }
  }
  if (cf_r) goto PRINTC;

  // Translation to C
  tds = do_stage("translation to C",tds, do_translate, jump_tables->pop_tables,
		 remove_fileptr, preprocfileptr);
  // Removal of aggregates (necessary for comprehensions and to avoid GCC bug)
  tds = do_stage("aggregate removal",tds,do_removeaggrs,true,ignore,true);
  if (compile_failure) return;

  // Translation to left-to-right evaluation order
  if (toseqc_r)
    tds = do_stage("post-pass to L-to-R evaluation order", tds, do_toseqc, 
		   true, ignore, true);
  // Clean up state common to last three passes
  Toc::finish();

  if (compile_failure) return;
 
 // removal of gcc extensions (tovc is an antiquated name)
  if (tovc_r || elim_se_r)
    tds = do_stage("post-pass to VC", tds, do_tovc, true, ignore, true);
  if (compile_failure) return;

  Warn::flush_warnings(); // cannot do after preprocfile is removed
  remove_file(preprocfile);

  // jcheney: we make a (empty) .c file even if the .cyc file produced no decls
 PRINTC: {
  FILE *out_file;
  if (parseonly_r || tc_r || cf_r)
    if (output_file != NULL)
      out_file = try_file_open(*output_file,"w","output file");
    else
      out_file = stdout;
  else if (toc_r && output_file != NULL)
    out_file = try_file_open(*output_file,"w","output file");
  else
    out_file = try_file_open(cfile,"w","output file");

  if (compile_failure || !out_file) return;

  if (!noprint_r) {
    let env = new $((FILE@)out_file,cfile);
    tds = do_stage("printing", tds, do_print, env, print_fail, env);
  }
  }
}

static string_t final_str = "<final>";
static stringptr_t final_strptr = &final_str;

static interface_t read_cycio(string_t<`H> @ n) {
  if (n == final_strptr) {
    return Interface::final();
  }
  string_t basename;
  try basename = Filename::chop_extension(*n);
  catch { case &Invalid_argument(_): basename = *n; break;}

  let nf = strconcat(basename, ".cycio");
  let f = try_file_open(nf, "rb", "interface object file");
  if (f == NULL) {
    compile_failure = true;
    remove_cfiles();
    exit(1);
  }
  Position::reset_position(nf); /* in case of parsing problems */
  //printf("reading %s\n", nf);
  let i = Interface::load(f);
  file_close(f);
  return i;
}

static bool is_cfile(string_t @ n) {
  return (*n)[0] != '-';
}

extern "C" void GC_blacklist_warn_clear();
//extern "C" int GC_dont_gc;

///////////////////////////////////////////////////////////////////
// table of compiler options
///////////////////////////////////////////////////////////////////
using Arg {
  typedef $(string_t flag, bool isprefix, string_t argdesc, spec_t spec,
            string_t description) option_t;

  extern void print_options();

#define make_option(opt,flag,isprefix,argdesc,spec,spec_arg,description) \
  datatype Spec.spec opt##_spec = spec(spec_arg); \
  option_t opt##_tuple = $(flag,isprefix,argdesc,&opt##_spec,description); \
  struct List<option_t@`H,`H> opt = {&opt##_tuple,NULL}

  make_option(opt1,"-v",false,"",Set_spec,&v_r,
              "print compilation stages verbosely");
  make_option(opt2,"--version",false,"",
              Unit_spec,print_version,
              "Print version information and exit");
  make_option(opt3,"-o",false," <file>",
              String_spec,set_output_file,
              "Set the output file name to <file>");
  make_option(opt4,"-D",true,"<name>[=<value>]",
              Flag_spec,add_cpparg,
              "Pass definition to preprocessor");
  make_option(opt5,"-B",true,"<file>",
              Flag_spec,Specsfile::add_cyclone_exec_path,
              "Add to the list of directories to search for compiler files");
  make_option(opt6,"-I",true,"<dir>",
              Flag_spec,add_cpparg,
              "Add to the list of directories to search for include files");
  make_option(opt7,"-L",true,"<dir>",
              Flag_spec,add_ccarg,
              "Add to the list of directories for -l");
  make_option(opt8,"-l",true,"<libname>",
              Flag_spec,add_libarg,
              "Library file");
  make_option(opt9,"-m",true,"<option>",
              Flag_spec,add_marg,
              "GCC specific: pass machine-dependent flag on to gcc");
  make_option(opt10,"-c",false,"",
              Unit_spec,set_stop_after_objectfile,
              "Produce an object file instead of an executable; do not link");
  make_option(opt11,"-x",false," <language>",
              String_spec,set_inputtype,
              "Specify <language> for the following input files");
  make_option(opt12,"-pa",false,"",
              Unit_spec,set_pa,
              "Compile for profiling with aprof");
  make_option(opt13,"-S",false,"",
              Unit_spec,set_stop_after_asmfile,
              "Stop after producing assembly code");
  make_option(opt14,"-M",false,"",
              Unit_spec,set_produce_dependencies,
              "Produce dependencies");
  make_option(opt15,"-MG",false,"",
              Flag_spec,add_cpparg,
              "When producing dependencies assume that missing "
              "files are generated");
  make_option(opt16,"-MT",false," <target>",
              String_spec,set_dependencies_target,
              "Give target for dependencies");
  make_option(opt17,"-b",false,"<machine>",
              String_spec,Specsfile::set_target_arch,
              "Set target machine");
  make_option(opt18,"-Wlose-unique",false,"",
              Set_spec,&NewControlFlow::warn_lose_unique,
              "Try to warn when a unique pointer might get lost");
  make_option(opt19,"-Woverride",false,"",
              Set_spec,&Binding::warn_override,
              "Warn when a local variable overrides an existing variable");
  make_option(opt20,"-Wall",false,"",
              Unit_spec,set_all_warnings,
              "Turn on all warnings");
  make_option(opt21,"-E",false,"",
              Set_spec,&stop_after_cpp_r,
              "Stop after preprocessing");
  make_option(opt22,"-stopafter-parse",false,"",
              Set_spec,&parseonly_r,
              "Stop after parsing");
  make_option(opt23,"-stopafter-tc",false,"",
              Set_spec,&tc_r,
              "Stop after type checking");
  make_option(opt24,"-noprint",false,"",
              Set_spec,&noprint_r,
              "Do not print output (when stopping early)");
  make_option(opt25,"-stopafter-cf",false,"",
              Set_spec,&cf_r,
              "Stop after control-flow checking");
  make_option(opt26,"-stopafter-toc",false,"",
              Set_spec,&toc_r,
              "Stop after translation to C");
  make_option(opt27,"-ic",false,"",
              Set_spec,&ic_r,
              "Activate the link-checker");
  make_option(opt28,"-pp",false,"",
              Set_spec,&pp_r,
              "Pretty print the C code that Cyclone generates");
  make_option(opt29,"-up",false,"",
              Clear_spec,&pp_r,
              "Ugly print the C code that Cyclone generates (default)");
  make_option(opt30,"-elim-statement-expressions",false,"",
              Set_spec,&elim_se_r,
              "Avoid statement expressions in C output"
              " (implies --inline-checks)");
  make_option(opt31,"-no-elim-statement-expressions",false,"",
              Clear_spec,&elim_se_r,
              "Do not avoid statement expressions in C output");
  make_option(opt32,"-un-gcc",false,"",
              Unit_spec,set_tovc,
              "Avoid gcc extensions in C output (except for attributes)");
  make_option(opt33,"-c-comp",false," <compiler>",
              String_spec,set_c_compiler,
              "Produce C output for the given compiler");
  make_option(opt34,"-save-temps",false,"",
              Unit_spec,set_save_temps,
              "Don't delete temporary files");
  make_option(opt35,"-save-c",false,"",
              Set_spec,&save_c_r,
              "Don't delete temporary C files");
  make_option(opt36,"--nolineno",false,"",
              Unit_spec,clear_lineno,
              "Don't generate line numbers for debugging (automatic with -pp)");
  make_option(opt37,"--nochecks",false,"",
              Unit_spec,set_nochecks,
              "Disable bounds/null checks");
  make_option(opt38,"--nonullchecks",false,"",
              Unit_spec,set_nonullchecks,
              "Disable null checks");
  make_option(opt39,"--noboundschecks",false,"",
              Unit_spec,set_noboundschecks,
              "Disable bounds checks");
  make_option(opt40,"--inline-checks",false,"",
              Unit_spec,set_inline_functions,
              "Inline bounds checks instead of #define");
  make_option(opt41,"-use-cpp",false,"<path>",
              String_spec,set_cpp,
              "Indicate which preprocessor to use");
  make_option(opt42,"-no-cpp-precomp",false,"",
              Unit_spec,set_nocppprecomp,
              "Don't do smart preprocessing (mac only)");
  make_option(opt43,"-nocyc",false,"",
              Unit_spec,set_nocyc,
              "Don't add implicit namespace Cyc");
  make_option(opt44,"-nogc",false,"",
              Set_spec,&nogc_r,
              "Don't link in the garbage collector");
  make_option(opt45,"-noremoveunused",false,"",
              Set_spec,&noshake_r,
              "Don't remove externed variables that aren't used");
  make_option(opt46,"-noexpandtypedefs",false,"",
              Set_spec,&noexpand_r,
              "Don't expand typedefs in pretty printing");
  make_option(opt47,"-printalltvars",false,"",
              Set_spec,&print_all_tvars_r,
              "Print all type variables (even implicit default effects)");
  make_option(opt48,"-printallkinds",false,"",
              Set_spec,&print_all_kinds_r,
              "Always print kinds of type variables");
  make_option(opt49,"-printfullevars",false,"",
              Set_spec,&print_full_evars_r,
              "Print full information for evars (type debugging)");
  make_option(opt50,"-printalleffects",false,"",
              Set_spec,&print_all_effects_r,
              "Print effects for functions (type debugging)");
  make_option(opt51,"-nocyc_setjmp",false,"",
              Set_spec,&nocyc_setjmp_r,
              "Do not use compiler special file cyc_setjmp.h");
  make_option(opt52,"-compile-for-boot",false,"",
              Set_spec,&Lex::compile_for_boot_r,
              "Compile using the special boot library instead of the standard library");
  make_option(opt53,"-CI",false," <file>",
              String_spec,set_cyc_include,
              "Set cyc_include.h to be <file>");
  make_option(opt54,"-warnboundschecks", false, "",
              Set_spec,&InsertChecks::warn_bounds_checks,
              "Warn when bounds checks can't be eliminated");
  make_option(opt55,"-warnnullchecks", false, "",
              Set_spec,&InsertChecks::warn_all_null_deref,
              "Warn when any null check can't be eliminated");
  make_option(opt56,"-warnaliascoercion", false, "",
              Set_spec,&Tcutil::warn_alias_coerce,
              "Warn when any alias coercion is inserted");
  make_option(opt57,"-warnregioncoerce", false, "",
              Set_spec,&Tcutil::warn_region_coerce,
              "Warn when any region coercion is inserted");
  make_option(opt58,"-noregister", false, "",
              Set_spec,&Parse::no_register,
              "Treat register storage class as public");
  make_option(opt59,"-detailedlocation", false, "",
              Clear_spec,&Position::use_gcc_style_location,
              "Try to give more detailed location information for errors");
  make_option(opt60,"-port", false, "",
              Unit_spec,set_port_c_code,
              "Suggest how to port C code to Cyclone");
  make_option(opt61,"-noregions", false, "",
              Set_spec,&Absyn::no_regions,
              "Generate code that doesn't use regions");
  make_option(opt62,"-iprefix",false,"<prefix>",
              String_spec,add_iprefix,
              "Specify <prefix> as the prefix for subsequent -iwithprefix options");
  make_option(opt63,"-iwithprefix",false,"<dir>",
              String_spec,add_iwithprefix,
              "Add <prefix>/<dir> to the second include path.");
  make_option(opt64,"-iwithprefixbefore",false,"<dir>",
              String_spec,add_iwithprefixbefore,
              "Add <prefix>/<dir> to the main include path.");
  make_option(opt65,"-isystem",false,"<dir>",
              String_spec,add_isystem,
              "Add <dir> to the beginning of the second include path and treat it as a\nsystem directory.");
  make_option(opt66,"-idirafter",false,"<dir>",
              String_spec,add_idirafter,
              "Add the directory to the second include path.");
  make_option(opt67,"--geninterface",false,"",
              Set_spec,&generate_interface_r,
              "Generate interface files");
  make_option(opt68,"--interface",false," <file>",
              String_spec,set_specified_interface,
              "Set the interface file to be <file>.");
  make_option(opt69,"--manyerrors",false, "",
              Unit_spec,set_many_errors,
              "don't stop after only a few errors.");
  make_option(opt70,"--parsestate",false, "",
              Set_spec,&ParseErrors::print_state_and_token,
              "print the parse state and token on a syntax error");
  make_option(opt71,"-known-gcc-flags-only",false,"",
              Unit_spec,noassume_gcc_flag,
              "do not assume that unknown flags should be passed to gcc");
  make_option(opt72,"-help",false,"",
              Unit_spec,print_options,
              "print out the available options");
  make_option(opt73,"-usage",false,"",
              Unit_spec,print_options,
              "print out the available options");
  make_option(opt74,"-no-seq-c",false,"",
              Unit_spec,set_notoseqc,
              "Do not force left-to-right evaluation order of generated code (unsafe)");
  make_option(opt75,"-pg",false,"",
              Unit_spec,set_pg,
              "Compile for profiling with gprof");

  struct List<option_t@`H,`H>@`H global_options[] = {
            &opt1, &opt2, &opt3, &opt4, &opt5, &opt6, &opt7, &opt8, &opt9,
    &opt10,&opt11,&opt12,&opt13,&opt14,&opt15,&opt16,&opt17,&opt18,&opt19,
    &opt20,&opt21,&opt22,&opt23,&opt24,&opt25,&opt26,&opt27,&opt28,&opt29,
    &opt30,&opt31,&opt32,&opt74,&opt75,&opt33,&opt34,&opt35,&opt36,&opt37,&opt38,&opt39,
    &opt40,&opt41,&opt42,&opt43,&opt44,&opt45,&opt46,&opt47,&opt48,&opt49,
    &opt50,&opt51,&opt52,&opt53,&opt54,&opt55,&opt56,&opt57,&opt58,&opt59,
    &opt60,&opt61,&opt62,&opt63,&opt64,&opt65,&opt66,&opt67,&opt68,&opt69,
    &opt70,&opt71,&opt72,&opt73
  };

  void print_options() {
    Arg::usage(global_options[0],"<program.cyc>");
  }
}

int main(int argc, string_t<`H> ?`H argv) {
  /* Don't print garbage collector warnings about allocations of
     blacklisted blocks.  This turns up on OS X and possibly other BSD
     systems (??) */
  GC_blacklist_warn_clear();

  /* parse the command-line arguments */
  string_t optstring = "Options:";
  // initialize the global options list tails
  for (int i = 1; i < numelts(global_options); i++) {
    global_options[i-1]->tl = global_options[i];
  }
  Arg::speclist_t<`H,`H> options = global_options[0];
  // Process the -b and -B arguments
  let otherargs = Specsfile::parse_b(options, add_other, add_other_flag, optstring, argv);
  // Now we find the specs file and see if it has any default arguments
  // for Cyclone (which will override defaults given here)
  // NB: we chose "cycspecs" as the name of the specs file instead of
  // the usual "specs" because if "specs" is used, gcc uses its own
  // default file "specs" and not ours.
  let specs_file = find_in_arch_path("cycspecs");
  if (v_r) fprintf(stderr,"Reading from specs file %s\n",specs_file);
  let specs = Specsfile::read_specs(specs_file);

  let args_from_specs_file = Specsfile::split_specs(Specsfile::get_spec(specs,"cyclone"));
  if (args_from_specs_file != NULL) {
    Arg::current = 0;
    Arg::parse(options, add_other, add_other_flag, optstring, args_from_specs_file);
  }
  let target_cflags = Specsfile::get_spec(specs,"cyclone_target_cflags");
  let cyclone_cc = Specsfile::get_spec(specs,"cyclone_cc");
  let target_libs = Specsfile::get_spec(specs,"cyclone_target_libs");
  if (!target_libs) target_libs = "";
  if (!cyclone_cc) cyclone_cc = "gcc";
  def_inc_path = Specsfile::get_spec(specs,"cyclone_inc_path");

  // Finally parse the other command-line arguments
  Arg::current = 0;
  Arg::parse(options, add_other, add_other_flag, optstring, otherargs);
  if (strcmp(cpp,"") == 0) {
    // If cpp string is not explicitly set, use the default.
    // NB the -w suppresses preprocessor warnings.  It's needed
    // because sometimes cpp complains about macros being redefined,
    // typically when cross-compiling; but I can't figure out exactly
    // when or why this happens.  For example, on
    // powerpc-apple-rhapsody,
    //   echo | gcc - -E -D__SIZE_TYPE__
    // complains about redefining __SIZE_TYPE__, however,
    //   echo | gcc - -E -dM
    // does not show that __SIZE_TYPE__ is ever defined.  This
    // results in warnings when compiling i686-unknown-linux on
    // powerpc-apple-rhapsody, since linux uses __SIZE_TYPE__.
    // NB we use the -E flag unless the -M flag has been used.  If
    // -E and -M are used together in some versions of gcc, we get a
    // compiler error, cpp0: too many filenames.
    let dash_E = (produce_dependencies ? "" : " -E");
    set_cpp(aprintf("%s %s -w -x c%s -specs %s",
                    cyclone_cc,
                    target_cflags, dash_E, specs_file));
  }
  if (cyclone_files == NULL && ccargs == NULL) {
    fprintf(stderr,"missing file\n");
    exit(1);
  }

  // Find the files cyc_setjmp.h and cyc_include.h, needed to produce
  // the .c output.
  /* The absolute file name is kept in a global variable */
  /* don't bother if we won't translate to C or if set explicitly */
  if (!stop_after_cpp_r && !nocyc_setjmp_r)
    cyc_setjmp = find_in_arch_path("cyc_setjmp.h");
  if (!stop_after_cpp_r && strlen(cyc_include) == 0)
    cyc_include = find_in_exec_path("cyc_include.h");

  /* Process each .cyc file */
  try {
    for (let l = rev(cyclone_files); l != NULL; l = l->tl) {
      process_file(*(l->hd));
      if (compile_failure) return 1;
    }
  } catch {
  case x:
    if (compile_failure) return 1;
    else Core::rethrow(x);
  }

  if (stop_after_cpp_r || parseonly_r || tc_r || toc_r) return 0;

  // If there are no files for the C compiler to process don't bother
  // to run it.
  // FIX: this is no longer a good check, as we add_ccargs -L stuff;
  //  we should keep a separate list of c_files
  if (ccargs == NULL) return 0;

  // Run the C compiler
  if (Specsfile::target_arch && Specsfile::cyclone_exec_path)
    add_ccarg(str_sepstr(new List(new "",
                                  add_subdir(Specsfile::cyclone_exec_path,
                                             Specsfile::target_arch)), " -L"));
  add_ccarg(strconcat("-L",Specsfile::def_lib_path));

  ccargs = rev(ccargs);
  let ccargs_string = str_sepstr(List::map(sh_escape_stringptr,ccargs), " ");
  libargs = rev(libargs);
  let libargs_string = str_sepstr(new List(new "",
					   List::map(sh_escape_stringptr,libargs)), " ");

  let stdlib;
  let stdlib_string;
  let is_not_executable =
    stop_after_asmfile_r ||
    stop_after_objectfile_r ||
    (output_file != NULL && Filename::check_suffix(*output_file, ".a")) ||
    (output_file != NULL && Filename::check_suffix(*output_file, ".lib"));
  if (is_not_executable) {
    stdlib = NULL;
    stdlib_string = (string_t)"";
  } else {
    // FIX: -g should get different versions of the libraries?
    string_t libcyc_flag;
    string_t nogc_filename;
    string_t runtime_filename;
    string_t gc_filename;
    if(pa_r) {
      libcyc_flag = "-lcyc_a";
      nogc_filename = "nogc_a.a";
      runtime_filename = "runtime_cyc_a.a";
    } else if(nocheck_r) {
      libcyc_flag = "-lcyc_nocheck";
      nogc_filename = "nogc.a";
      runtime_filename = "runtime_cyc.a";
    } else if(pg_r) {
      libcyc_flag = "-lcyc_pg";
      runtime_filename = "runtime_cyc_pg.a";
      nogc_filename = "nogc_pg.a";
    } else if(Lex::compile_for_boot_r) {
      // FIX: all the above cases should take compile_for_boot into account
      libcyc_flag = "-lcycboot";
      nogc_filename = "nogc.a";
      runtime_filename = "runtime_cyc.a";
    } else {
      libcyc_flag = "-lcyc";
      nogc_filename = "nogc.a";
      runtime_filename = "runtime_cyc.a";
    }
    gc_filename = "gc.a";

    let gc = (nogc_r ? find_in_arch_path(nogc_filename): find_in_arch_path(gc_filename));
    let runtime = find_in_arch_path(runtime_filename);

    // FIX: temporarily removed from interface check below
    stdlib = NULL;     //stdlib = list(new libcyc_flag);
    stdlib_string = aprintf(" %s %s %s %s ", libcyc_flag, runtime, gc, target_libs);
    
  }

  if (ic_r) try {
    ccargs = filter(is_cfile, ccargs);
    libargs = filter(is_cfile, libargs);
    let lf = append(stdlib, append(ccargs, libargs));
    if (! is_not_executable) {
      lf = new List(final_strptr, lf);
    }

    let i = Interface::get_and_merge_list(read_cycio, lf, lf);
    if (i == NULL) {
      fprintf(stderr,"Error: interfaces incompatible\n");
      compile_failure = true;
      remove_cfiles();
      return 1;
    }
    if (is_not_executable) {
      if (output_file != NULL) {
	let output_file_io = aprintf("%s.cycio", Filename::chop_extension(*output_file));
	let f = try_file_open(output_file_io, "wb", "interface object file");
	if (f == NULL) {
	  compile_failure = true;
	  remove_cfiles();
	  return 1;
	}
	Interface::save(i, f);
	file_close(f);
      }
    } else {
      if(!Interface::is_subinterface(Interface::empty(), i,
				     new $("empty interface", "global interface"))) {
	fprintf(stderr,"Error: some objects are still undefined\n");
	compile_failure = true;
	remove_cfiles();
	return 1;
      }
    }
  } catch {
  case e:
    fprintf(stderr,"INTERNAL COMPILER FAILURE:  exception %s from around %s:%d thrown.\n  Please send bug report to cyclone-bugs-l@lists.cs.cornell.edu",Core::get_exn_name(e),Core::get_exn_filename(),Core::get_exn_lineno());
    compile_failure = true;
    remove_cfiles();
    return 1;
  }

  string_t outfile_str = "";
  if (output_file != NULL)
    outfile_str = aprintf(" -o %s",sh_escape_string(*output_file));

  let cccmd =
    aprintf("%s %s %s%s %s%s",
            cyclone_cc, target_cflags,
            ccargs_string, outfile_str,
            stdlib_string, libargs_string);
  if (v_r) { fprintf(stderr,"%s\n",cccmd); fflush(stderr); }
  if (system((const char @)cccmd) != 0) {
    fprintf(stderr,"Error: C compiler failed\n");
    compile_failure = true;
    remove_cfiles();
    return 1;
  }
  remove_cfiles();

  return compile_failure ? 1 : 0;
}
