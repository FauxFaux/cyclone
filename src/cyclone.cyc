// Main file

#include <arg.h>
#include <core.h>
#include <stdio.h>
#include <stdlib.h>
#include <list.h>
#include <string.h>
#include <dict.h>
#include <filename.h>
#include <id.h>
#include "parse.h"
#include <position.h>
#include "absyn.h"
#include "absynpp.h"
#include "absyndump.h"
#include "tcutil.h"
#include "tcenv.h"
#include "tc.h"
#include "toc.h"
#include "tovc.h"
#include "new_control_flow.h"
#include "interface.h"

namespace Lex {
extern void lex_init();
}
using Core;
using Stdio;
using List;
using Arg;
using String;

static bool pp_r       = false;
static bool noexpand_r = false;
static bool noshake_r  = false;
static bool stop_after_cpp_r = false;
static bool parseonly_r = false;
static bool tc_r       = false;
static bool ic_r       = false;
static bool toc_r      = false;
static bool stop_after_objectfile_r = false;
static bool tovc_r     = false;
static bool v_r        = false;
static bool save_temps_r = false;
static bool save_c_r   = false;
static bool add_cyc_namespace_r = true;

static string_t *output_file = null;
static void set_output_file(string_t s) {
  output_file = new s;
}

static list_t<stringptr_t> cppargs = null;
static void add_cpparg(string_t s) {
  cppargs = new List(new s,cppargs);
}

static bool is_cyclone_sourcefile(string_t s) {
  let len = strlen(s);
  if (len <= 4) return false;
  else return (strcmp(s+(len-4),".cyc") == 0);
}

static list_t<stringptr_t> cyclone_exec_prefix_path = null;
static void add_cyclone_exec_prefix_path(string_t s) {
  let len = strlen(s);
  if (len <= 2) return;
  let dir = (string_t)substring(s,2,len-2);
  cyclone_exec_prefix_path = new List(new dir,cyclone_exec_prefix_path);
}

// Arguments to pass to the C compiler
static list_t<stringptr_t> ccargs = null;
static void add_ccarg(string_t s) {
  ccargs = new List(new s,ccargs);
}
static void add_ccarg2(string_t flag,string_t arg) {
  ccargs = new List(new arg, new List(new flag,ccargs));
}

// Ideally we would simply pass library args as ccargs, preserving
// their order with the other ccargs.  But if, e.g., -lm precedes
// cyclib.a, then we get a "multiple definitions of main" error, via
// libmain.c.  So, we separate out the library args from the ccargs
// so that we can force cyclib.a to appear first.
static list_t<stringptr_t> libargs = null;
static void add_libarg(string_t s) {
  libargs = new List(new s,libargs);
}

static void set_save_temps() {
  save_temps_r = true;
  add_ccarg("-save-temps");
}

static void set_produce_dependencies() {
  stop_after_cpp_r = true;
  add_cpparg("-M");
}

static void set_stop_after_objectfile() {
  stop_after_objectfile_r = true;
  add_ccarg("-c");
}

// Cyclone files given on the command line
static list_t<stringptr_t> cyclone_files = null;
// Like add_ccarg but intercepts .cyc files for special handling
static void add_other(string_t s) {
  if (is_cyclone_sourcefile(s)) {
    // For processing by Cyclone
    cyclone_files = new List(new s,cyclone_files);

    // The C compiler wants the .c file, not the .cyc files
    let basename = Filename::chop_extension(s);
    let cfile    = strconcat(basename, ".c");
    add_ccarg(cfile);
  }
  else add_ccarg(s);
}

static void remove_file(string_t s) {
  if (save_temps_r) return;
  else Stdio::remove(s);
}

bool compile_failure = false; // for exit code (helps Makefile)

FILE * try_file_open(string_t filename, string_t mode, string_t msg_part) {
  try return file_open(filename,mode);
  catch {
  default:
    compile_failure = true;
    fprintf(stderr, "\nError: couldn't open %s %s\n", msg_part, filename);
    fflush(stderr);
    return null;
  }
}

list_t<Absyn::decl_t>
  do_stage(string_t stage_name,
           list_t<Absyn::decl_t> f(`a, list_t<Absyn::decl_t>),
           `a env, list_t<Absyn::decl_t> tds) {
  string_t exn_string     = "";
  string_t explain_string = "";
  bool other_exn = false;
  xtunion exn ex = new Core::Impossible(""); // definite assignment doesn't track data
  let ans = null;

  try ans = f(env,tds);
  catch {
  case &Core::Impossible(s):
    exn_string = "Exception Core::Impossible";
    explain_string = s;
    break;
  case Dict::Absent:
    exn_string = "Exception Dict::Absent";
    break;
  case x:
    ex = x;
    other_exn = true;
    exn_string = "Uncaught exception";
    break;
    }
  if (Position::error_p())
    compile_failure = true;
  if (strcmp(exn_string,"") != 0) {
    compile_failure = true;
    fprintf(stderr,"\n%s thrown during %s: %s",
	    exn_string, stage_name, explain_string);
  }
  if (compile_failure) {
    fprintf(stderr,"\nCOMPILATION FAILED!\n");
    fflush(stderr);
    if (other_exn)
      throw ex;
    return ans;
  }
  else if (v_r) {
    fprintf(stderr,"%s completed.\n",stage_name);
    fflush(stderr);
    return ans;
  }
  return ans;
}

list_t<Absyn::decl_t> do_parse(FILE @ f, list_t<Absyn::decl_t> ignore) {
  Lex::lex_init(); // must forget typedefs, may as well flush symbols too
  let ans = Parse::parse_file(f);
  Lex::lex_init(); // garbage collect those big tries
  return ans;
}

list_t<Absyn::decl_t> do_typecheck(Tcenv::tenv_t te,list_t<Absyn::decl_t> tds){
  Absynpp::expand_typedefs = ! noexpand_r;
  add_cyc_namespace_r = add_cyc_namespace_r && !tc_r; //don't add namespaces if we don't translate to C
  if (add_cyc_namespace_r)
    Absyn::file_typ();
  else
    Absyn::file_typ_nocyc();
  Tc::tc(te, add_cyc_namespace_r, true, tds);
  if (!noshake_r)
    tds = Tc::treeshake(te,tds);
  return tds;
}

list_t<Absyn::decl_t> do_cfcheck(bool ignore, list_t<Absyn::decl_t> tds) {
  NewControlFlow::cf_check(tds);
  return tds;
}

list_t<Absyn::decl_t> do_interface($(Tcenv::tenv_t, FILE @) @ params, list_t<Absyn::decl_t> tds) {
  let te = (*params)[0];
  let f = (*params)[1];

  let i = Interface::extract(te -> ae);
  Interface::print(i, f);

  return tds;
}

list_t<Absyn::decl_t> do_translate(bool ignore, list_t<Absyn::decl_t> tds) {
  return Toc::toc(tds);
}
list_t<Absyn::decl_t> do_tovc(bool ignore, list_t<Absyn::decl_t> tds) {
  return Tovc::tovc(tds);
}

list_t<Absyn::decl_t> do_print(FILE @ out_file, list_t<Absyn::decl_t> tds) {
  Absynpp::expand_typedefs = ! noexpand_r;
  Absynpp::decls_first = Absynpp::qvar_to_Cids = ! tc_r;
  Absynpp::to_VC = tovc_r;

  //  fprintf(out_file, "#include \"cyc_include.h\"\n\n");
  if (pp_r)
    Absynpp::decllist2file(tds,out_file);
  else
    Absyndump::dumpdecllist2file(tds,out_file);
  fflush(out_file);
  return tds;
}

// We must remember what .c files are produced so that we can remove them
// after we're done.
static list_t<stringptr_t> cfiles = null;
static void remove_cfiles() {
  if (!save_c_r)
    for (; cfiles != null; cfiles = cfiles->tl)
      remove_file(*(cfiles->hd));
}

/* Take as input a string, return the list of substrings separated by colons */
static list_t<stringptr_t> split_by_char(string_t s, char c) {
  if (s == null) return null;
  let result = null;
  let len = strlen(s);

  while (len > 0) {
    let end = strchr(s,c);
    if (end == null) {
      result = new List(new s,result);
      break;
    }
    else {
      result = new List(new ((string_t)substring(s,0,(string_t)end-s)),result);
      len -= ((string_t)end-s);
      s = end+1;
    }
  }
  return List::imp_rev(result);
}

/* FIX: once stat is ported we can use that instead */
bool file_exists(string_t file) {
  FILE *f = null;
  try f = file_open(file,"r"); catch {default: break;}
  if (f == null) return false;
  else { fclose((FILE @)f); return true; }
}

string_t *find(list_t<stringptr_t> dirs, string_t file) {
  if (file == null) return null;
  for (; dirs != null; dirs = dirs->tl) {
    let dir = *dirs->hd;
    if (dir == null || strlen(dir)==0) continue;
    string_t s = Filename::concat(dir,file);
    if (file_exists(s)) return new s;
  }
  return null;
}

void process_file(string_t filename) {

  let basename      = Filename::chop_extension(filename);
  let preprocfile   = strconcat(basename, ".cyp");
  let interfacefile = strconcat(basename, ".cyci");
  let cfile         = strconcat(basename, ".c");

  if (v_r) fprintf(stderr,"Compiling %s\n", filename);

  // Check that the input file exists
  FILE * f0 = try_file_open(filename, "r", "input file");
  if (compile_failure)
    return;
  fclose((FILE @)f0);

  // Run the preprocessor, by building and running a command-line
  // Pass -I and -D things onto preprocessor
  // FIX: let user change how/which preprocessor is invoked
  let cppargs_string = String::str_sepstr(new List(new (string_t)"",
                                                   rev(cppargs))," ");
  string_t stdinc_string = " -Ic:/cyclone/include";
  let cyclone_include_path = Stdlib::getenv("CYCLONE_INCLUDE_PATH");
  if (cyclone_include_path != null) {
    let x = split_by_char(cyclone_include_path,':');
    let s = String::str_sepstr(new List(new (string_t)"",x)," -I");
    stdinc_string = xprintf("%s%s",s,stdinc_string);
  }
  string_t ofile_string;
  if (stop_after_cpp_r) {
    if (output_file != null)
      ofile_string = xprintf(" -o %s", *output_file);
    else // output to standard out
      ofile_string = "";
  }
  else ofile_string = xprintf(" -o %s", preprocfile);

  let cmd = xprintf("gcc -x c -E -U__GNUC__ -nostdinc%s%s%s %s",
                    cppargs_string, stdinc_string, ofile_string, filename);

  if (v_r) fprintf(stderr,"%s\n",cmd);
  if (system(string_to_Cstring(cmd)) != 0) {
    compile_failure = true;
    fprintf(stderr,"\nError: preprocessing\n");
    return;
  }
  if (stop_after_cpp_r) return;

  // Run the stages of the Cyclone compiler
  Position::reset_position(preprocfile); // necessary for good error messages!
  // Set up for printing Cyclone
  Absynpp::print_using_stmts = Absynpp::print_externC_stmts = true;
  FILE * in_file  = try_file_open(preprocfile,"r","file");
  if (compile_failure) return;

  list_t<Absyn::decl_t> tds = null;

  // Parsing
  try
    tds = do_stage("parsing", do_parse, (FILE@)in_file, tds);
  catch {
  case x:
    file_close((FILE@)in_file);
    //    Tcutil::flush_warnings();
    remove_file(preprocfile); // Can't remove this before warnings are flushed!
    throw x;
  }
  file_close((FILE@)in_file);
  if (compile_failure) {
    //    Tcutil::flush_warnings();
    remove_file(preprocfile); // Can't remove this before warnings are flushed!
    return;
  } 

  let te = Tcenv::tc_init(); // Must declare BEFORE the goto 
  if (parseonly_r) goto PRINTC;

  // Type checking and control-flow checking
  tds = do_stage("type checking", do_typecheck, te, tds);
  if (compile_failure) {
    //    Tcutil::flush_warnings();
    remove_file(preprocfile); // Can't remove this before warnings are flushed!
    return;
  } 
  tds = do_stage("control-flow checking", do_cfcheck, true, tds);
  if(!compile_failure)
    Tcutil::flush_warnings();
  remove_file(preprocfile); // Can't remove this before warnings are flushed!
  if (compile_failure) return;
  // Once the type-checking has been done, there's no need for
  // the 'Using' statements, nor for the extern "C" {...}
  Absynpp::print_using_stmts = Absynpp::print_externC_stmts = false;

  // Interface checking
  if (ic_r) {
    FILE *inter_file;
    inter_file = try_file_open(interfacefile, "w", "interface file");
    if (compile_failure) return;
    // Position::reset_position(interfacefile);
    tds = do_stage("interface checking", do_interface,
                   new $(te, (FILE @) inter_file), tds);
    if (inter_file != null) file_close((FILE @) inter_file);
    if (compile_failure) return;
  }

  if (tc_r) goto PRINTC;

  // Translation to C
  tds = do_stage("translation to C", do_translate, true, tds);
  if (compile_failure) return;
  if (tovc_r) tds = do_stage("post-pass to VC", do_tovc, true, tds);
  if (compile_failure) return;

 PRINTC:
  if (tds != null) {
    FILE *out_file;

    if (parseonly_r || tc_r)
      if (output_file != null)
        out_file = try_file_open(*output_file,"w","output file");
      else
        out_file = stdout;
    else if (toc_r && output_file != null)
      out_file = try_file_open(*output_file,"w","output file");
    else
      out_file = try_file_open(cfile,"w","output file");

    if (compile_failure) return;

    try
      tds = do_stage("printing", do_print, (FILE @)out_file, tds);
    catch {
    case x:
      compile_failure = true;
      file_close((FILE @)out_file);
      cfiles = new List(new ((string_t)cfile),cfiles);
      throw x;
    }
    file_close((FILE @)out_file);
    cfiles = new List(new ((string_t)cfile),cfiles);
  }
}

int main(int argc, string_t ? argv) {

  list_t<$(string_t,spec_t,string_t)@> options =
    list(new $("-v",new Set_spec(&v_r),
                 "    Print compilation stages verbosely"),
         new $("-o",new String_spec(set_output_file),
                 "    Output file name"),
         new $("-D*",new Flag_spec(add_cpparg),
                  "   Pass definition to preprocessor"),
         new $("-B*",new Flag_spec(add_cyclone_exec_prefix_path),
                  "   Add to the list of directories to search for compiler files"),
         new $("-I*",new Flag_spec(add_cpparg),
                  "   Add to the list of directories to search for include files"),
         new $("-L*",new Flag_spec(add_cpparg),
                  "   Add to the list of directories for -l"),
         new $("-l*",new Flag_spec(add_libarg),
                  "   Library file"),
         new $("-c",new Unit_spec(set_stop_after_objectfile),
                 "    Produce object file"),
         new $("-O",new Flag_spec(add_ccarg),
                 "    Optimize"),
         new $("-O2",new Flag_spec(add_ccarg),
                  "   Optimize"),
         new $("-O3",new Flag_spec(add_ccarg),
                  "   Optimize"),
         new $("-g",new Flag_spec(add_ccarg),
                 "    Compile for debugging"),
         new $("-p",new Flag_spec(add_ccarg),
                 "    Compile for prof"),
         new $("-pg",new Flag_spec(add_ccarg),
                  "   Compile for gprof"),
         new $("-S",new Flag_spec(add_ccarg),
                 "    Stop after producing assembly code"),
         new $("-M",new Unit_spec(set_produce_dependencies),
                 "    Produce dependencies"),
         new $("-E",new Set_spec(&stop_after_cpp_r),
                 "    Stop after preprocessing"),
         new $("-parseonly",new Set_spec(&parseonly_r),
               "\n"
              "        Stop after parsing"),
         new $("-tc",new Set_spec(&tc_r),
                  "   Stop after type checking"),
         new $("-toc",new Set_spec(&toc_r),
                   "  Stop after translation to C"),
         new $("-ic",new Set_spec(&ic_r),
                  "   Interface check"),
         new $("-pp",new Set_spec(&pp_r),
                  "   Pretty print"),
         new $("-up",new Clear_spec(&pp_r),
                  "   Ugly print"),
         new $("-tovc",new Set_spec(&tovc_r),
                    " Avoid gcc extensions in C output"),
         new $("-save-temps",new Unit_spec(set_save_temps),
               "\n"
              "        Don't delete temporary files"),
         new $("-save-c",new Set_spec(&save_c_r),
               "\n"
              "        Don't delete temporary C files"),
         new $("-nocyc",new Clear_spec(&add_cyc_namespace_r),
               "Don't add implicit namespace Cyc"),
         new $("-noremoveunused",new Set_spec(&noshake_r),
               "\n"
              "        Don't remove externed variables that aren't used"),
         new $("-noexpandtypedefs",new Set_spec(&noexpand_r),
               "\n"
              "        Don't expand typedefs in pretty printing"),
         new $("-printalltvars", new Set_spec(&Absynpp::print_all_tvars),
               "\n"
              "        Print all type variables (even implicit default effects)"),
         new $("-printallkinds", new Set_spec(&Absynpp::print_all_kinds),
               "\n"
               "        Always print kinds of type variables"),
         new $("-printfullevars", new Set_spec(&Absynpp::print_full_evars),
               "\n"
               "       Print full information for evars (type debugging)")
         );

  Arg::parse(options, add_other, "Options:", argv);

  for (let l = rev(cyclone_files); l != null; l = l->tl) {
    process_file(*(l->hd));
    if (compile_failure) return 1;
  }

  if (stop_after_cpp_r || parseonly_r || tc_r || toc_r) return 0;

  // If there are no files for the C compiler to process don't bother
  // to run it.
  if (ccargs == null) return 0;

  // Run the C compiler
  // First, find the files cyclib.a, gc.a, cyc_include.h
  string_t cyclone_exec_prefix = Stdlib::getenv("CYCLONE_EXEC_PREFIX");
  if (cyclone_exec_prefix != null)
    cyclone_exec_prefix_path = new List(new cyclone_exec_prefix,
                                        cyclone_exec_prefix_path);
  cyclone_exec_prefix_path = new List(new ((string_t)"c:/cyclone/bin/cyc-lib"),
                                        cyclone_exec_prefix_path);
  cyclone_exec_prefix_path = List::imp_rev(cyclone_exec_prefix_path);
  let cyc_include = find(cyclone_exec_prefix_path,"include/cyc_include.h");
  if (cyc_include == null) {
    fprintf(stderr,"Error: can't find internal compiler file cyc_include.h");
    compile_failure = true;
    remove_cfiles();
    return 1;
  }

  let ccargs_string = String::str_sepstr(rev(ccargs), " ");
  let libargs_string = String::str_sepstr(new List(new ((string_t)""),rev(libargs)), " ");
  let stdlib_string;
  if (stop_after_objectfile_r)
    stdlib_string = (string_t)"";
  else {
    let cyclib = find(cyclone_exec_prefix_path,"cyclib.a");
    let gc = find(cyclone_exec_prefix_path,"gc.a");
    if (cyclib == null) {
      fprintf(stderr,"Error: can't find internal compiler file cyclib.a");
      compile_failure = true;
      remove_cfiles();
      return 1;
    }
    if (gc == null) {
      fprintf(stderr,"Error: can't find internal compiler file gc.a");
      compile_failure = true;
      remove_cfiles();
      return 1;
    }
    stdlib_string = xprintf(" %s %s",*cyclib,*gc);
  }
  let cccmd =
    xprintf("gcc -include %s%s %s%s%s",
            *cyc_include,
            (output_file==null?((string_t)""):xprintf(" -o %s",*output_file)),
            ccargs_string,
            stdlib_string,
            libargs_string);
  if (v_r) fprintf(stderr,"%s\n",cccmd);
  if (system(string_to_Cstring(cccmd)) != 0) {
    fprintf(stderr,"Error: C compiler failed\n");
    compile_failure = true;
    remove_cfiles();
    return 1;
  }
  remove_cfiles();

  return compile_failure ? 1 : 0;
}
