/* Driver for the Cyclone compiler.
   Copyright (C) 2001 Greg Morrisett, AT&T
   This file is part of the Cyclone compiler.

   The Cyclone compiler is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   The Cyclone compiler is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with the Cyclone compiler; see the file COPYING. If not,
   write to the Free Software Foundation, Inc., 59 Temple Place -
   Suite 330, Boston, MA 02111-1307, USA. */

#include <arg.h>
#include <core.h>
#include <stdio.h>
#include <stdlib.h>
#include <list.h>
#include <string.h>
#include <dict.h>
#include <filename.h>
#include "parse.h"
#include <position.h>
#include "absyn.h"
#include "absynpp.h"
#include "absyndump.h"
#include "tcutil.h"
#include "tcenv.h"
#include "tc.h"
#include "toc.h"
#include "tovc.h"
#include "new_control_flow.h"
#include "interface.h"
#include "version.h" /* this should always be last in the includes */

namespace Lex {
  extern void lex_init();
}
using Core;
using List;
using Arg;

static bool pp_r       = false;
static bool noexpand_r = false;
static bool noshake_r  = false;
static bool stop_after_cpp_r = false;
static bool parseonly_r = false;
static bool tc_r       = false;
static bool ic_r       = false;
static bool toc_r      = false;
static bool stop_after_objectfile_r = false;
static bool stop_after_asmfile_r = false;
static bool tovc_r     = false;
static bool v_r        = false;
static bool save_temps_r = false;
static bool save_c_r   = false;
static bool nogc_r     = false;
static bool pa_r       = false;
static bool nocheck_r  = false;
static bool add_cyc_namespace_r = true;
static bool generate_line_directives_r = false;
static bool print_full_evars_r = false;
static bool print_all_tvars_r = false;
static bool print_all_kinds_r = false;


static string_t *output_file = NULL;
static void set_output_file(string_t<`H> s) {
  output_file = new s;
}

// This will cause the variables def_inc_path and def_lib_path
// to be defined in cyc_include.h
extern "C" {
  extern Cstring Cdef_inc_path;
  extern Cstring Cdef_lib_path;
  extern Cstring Carch;
  extern Cstring Ccomp;
}

static string_t cpp = "";
static void set_cpp(string_t<`H> s) {
  cpp = s;
}

static list_t<stringptr_t> cppargs = NULL;
static void add_cpparg(string_t<`H> s) {
  cppargs = new List(new s,cppargs);
}

// Prints the version # and exits
static void print_version() {
  printf("The Cyclone compiler, version %s\n", version);
  printf("Compiled for architecture: %s CC=\"%s\"\n", 
	 Cstring_to_string(Carch), Cstring_to_string(Ccomp));
  printf("Standard library directory: %s\n",Cstring_to_string(Cdef_lib_path));
  printf("Standard include directory: %s\n", Cstring_to_string(Cdef_inc_path));
  exit(0);
}
  
static bool is_cyclone_sourcefile(string_t s) {
  let len = strlen(s);
  if (len <= 4) return false;
  else return (strcmp(s+(len-4),".cyc") == 0);
}

// Arguments to pass to the C compiler
static list_t<stringptr_t> ccargs = NULL;
static void add_ccarg(string_t<`H> s) {
  ccargs = new List(new s,ccargs);
}

static list_t<stringptr_t> cyclone_lib_path = NULL;
static void add_cyclone_lib_path(string_t s) {
  let len = strlen(s);
  if (len <= 2) return;
  let dir = (string_t)substring(s,2,len-2);
  cyclone_lib_path = new List(new dir,cyclone_lib_path);
}

// Ideally we would simply pass library args as ccargs, preserving
// their order with the other ccargs.  But if, e.g., -lm precedes
// libcyc.a, then we get a "multiple definitions of main" error, via
// libmain.c.  So, we separate out the library args from the ccargs
// so that we can force libcyc.a to appear first.
static list_t<stringptr_t> libargs = NULL;
static void add_libarg(string_t<`H> s) {
  if (strcmp(s,"-lxml") == 0)
    add_ccarg(s);
  else
    libargs = new List(new s,libargs);
}

static void set_save_temps() {
  save_temps_r = true;
  add_ccarg("-save-temps");
}

static bool produce_dependencies = false;
static void set_produce_dependencies() {
  stop_after_cpp_r = true;
  produce_dependencies = true;
  add_cpparg("-M");
}

static string_t *dependencies_target = NULL;
static void set_dependencies_target(string_t<`H> s) {
  dependencies_target = new s;
}

static void set_stop_after_objectfile() {
  stop_after_objectfile_r = true;
  add_ccarg("-c");
}

static void set_nocppprecomp() {
  add_cpparg("-no-cpp-precomp");
  add_ccarg("-no-cpp-precomp");
}

static void set_lineno() {
  generate_line_directives_r = true;
  set_save_temps();
}

static void set_noboundschecks() {
  add_ccarg("-DNO_CYC_BOUNDS_CHECKS");
}
static void set_nonullchecks() {
  add_ccarg("-DNO_CYC_NULL_CHECKS");
}
static void set_nochecks() {
  set_noboundschecks();
  set_nonullchecks();
  nocheck_r = true;
}

static void set_nocyc() {
  add_cyc_namespace_r = false;
  add_ccarg("-DNO_CYC_PREFIX");
}

static void set_pa() {
  pa_r = true;
  add_ccarg("-DCYC_REGION_PROFILE");
}

static void set_stop_after_asmfile() {
  stop_after_asmfile_r = true;
  add_ccarg("-S");
}

/* This only works enough to support cycdoc so far */
tunion inputtype {
  DEFAULTINPUT;
  CYCLONEFILE;
};
typedef tunion inputtype inputtype_t;
static inputtype_t intype = DEFAULTINPUT;
static void set_inputtype(string_t s) {
  if (strcmp(s,"cyc") == 0)
    intype = CYCLONEFILE;
  else if (strcmp(s,"none") == 0)
    intype = DEFAULTINPUT;
  else {
    fprintf(stderr,"Input type '%s' not supported\n",s);
  }
}

// Cyclone files given on the command line
static list_t<stringptr_t> cyclone_files = NULL;
// Like add_ccarg but intercepts .cyc files for special handling
static void add_other(string_t<`H> s) {
  if (intype == CYCLONEFILE || is_cyclone_sourcefile(s)) {
    // For processing by Cyclone
    cyclone_files = new List(new s,cyclone_files);

    // The C compiler wants the .c file, not the .cyc files
    let basename = 
      Filename::chop_extension(output_file==NULL ? s : *output_file);
    let cfile    = strconcat(basename, ".c");
    add_ccarg(cfile);
  }
  else add_ccarg(s);
}

static void remove_file(string_t<`H> s) {
  if (save_temps_r) return;
  else remove(s);
}

bool compile_failure = false; // for exit code (helps Makefile)

FILE * try_file_open(string_t filename, string_t mode, string_t msg_part) {
  try return file_open(filename,mode);
  catch {
  default:
    compile_failure = true;
    fprintf(stderr, "\nError: couldn't open %s %s\n", msg_part, filename);
    fflush(stderr);
    return NULL;
  }
}

list_t<Absyn::decl_t>
  do_stage(string_t stage_name,
           list_t<Absyn::decl_t,`H> f(`a, list_t<Absyn::decl_t,`H>),
           `a env, list_t<Absyn::decl_t,`H> tds) {
  string_t exn_string     = "";
  string_t explain_string = "";
  bool other_exn = false;
  xtunion exn ex = new Core::Impossible(""); // definite assignment doesn't track data
  let ans = NULL;

  try ans = f(env,tds);
  catch {
  case &Core::Impossible(s):
    exn_string = "Exception Core::Impossible";
    explain_string = s;
    break;
  case Dict::Absent:
    exn_string = "Exception Dict::Absent";
    break;
  case &Invalid_argument(s):
    exn_string = "Exception Core::Invalid_argument";
    explain_string = s;
    break;
  case &Core::Failure(s):
    exn_string = "Exception Core::Failure";
    explain_string = s;
    break;
  case x:
    ex = x;
    other_exn = true;
    exn_string = "Uncaught exception";
    break;
    }
  if (Position::error_p())
    compile_failure = true;
  if (strcmp(exn_string,"") != 0) {
    compile_failure = true;
    fprintf(stderr,"\n%s thrown during %s: %s",
	    exn_string, stage_name, explain_string);
  }
  if (compile_failure) {
    fprintf(stderr,"\nCOMPILATION FAILED!\n");
    fflush(stderr);
    if (other_exn)
      throw ex;
    return ans;
  }
  else if (v_r) {
    fprintf(stderr,"%s completed.\n",stage_name);
    fflush(stderr);
    return ans;
  }
  return ans;
}

list_t<Absyn::decl_t> do_parse(FILE @ f, list_t<Absyn::decl_t> ignore) {
  Lex::lex_init(); // must forget typedefs, may as well flush symbols too
  let ans = Parse::parse_file(f);
  Lex::lex_init(); // garbage collect those big tries
  return ans;
}

list_t<Absyn::decl_t> do_typecheck(Tcenv::tenv_t te,list_t<Absyn::decl_t,`H> tds){
  Tc::tc(te, true, tds);
  if (!noshake_r)
    tds = Tc::treeshake(te,tds);
  return tds;
}

list_t<Absyn::decl_t> do_cfcheck(bool ignore, list_t<Absyn::decl_t,`H> tds) {
  NewControlFlow::cf_check(tds);
  return tds;
}

list_t<Absyn::decl_t> do_interface($(Tcenv::tenv_t, FILE *`H, FILE @`H) @`H params, list_t<Absyn::decl_t,`H> tds) {
  let &$(te, fi, fo) = params;
  let i1 = Interface::extract(te -> ae);
  if (fi == NULL) {
    Interface::save(i1, fo);
  } else {
    let i0 = Interface::parse((FILE @) fi);
    if (!Interface::is_subinterface(i0, i1, new $("written interface", "maximal interface")))
      compile_failure = true;
    else
      Interface::save(i0, fo);
  }
  return tds;
}

list_t<Absyn::decl_t> do_translate(bool ignore, list_t<Absyn::decl_t> tds) {
  return Toc::toc(tds);
}
list_t<Absyn::decl_t> do_tovc(bool ignore, list_t<Absyn::decl_t> tds) {
  return Tovc::tovc(tds);
}

/* The absolute file name of cyc_include.h */
static string_t cyc_include = "";

list_t<Absyn::decl_t> do_print(FILE @ out_file, list_t<Absyn::decl_t,`H> tds) {
  struct Absynpp::Params params_r;

  if (tc_r) {
    params_r = Absynpp::cyc_params_r;
  } else {
    params_r = Absynpp::c_params_r;
  }
  params_r.expand_typedefs = ! noexpand_r;
  params_r.to_VC = tovc_r;
  params_r.add_cyc_prefix = add_cyc_namespace_r;
  params_r.generate_line_directives = generate_line_directives_r;
  params_r.print_full_evars = print_full_evars_r;
  params_r.print_all_tvars = print_all_tvars_r;
  params_r.print_all_kinds = print_all_kinds_r;

  //  fprintf(out_file, "#include \"cyc_include.h\"\n\n");
  /* Copy cyc_include.h to out_file. */
  /* FIX: would be better to use open, stat, and read but we don't
     have all those functions in the library yet. */
  let cyc_include_f = try_file_open(cyc_include,"r","internal compiler file");
  if (cyc_include_f == NULL) return tds;
  let cyc_include_fnotnull = (FILE@)cyc_include_f;
  size_t n_read = 1024;
  size_t n_written;
  char buf[1024] = { for i < 1024 : 0 }; // init to avoid warning
  while (n_read == 1024) {
    n_read = fread(buf,1,1024,cyc_include_fnotnull);
    if (n_read != 1024 && !(feof(cyc_include_fnotnull))) {
      compile_failure = true;
      fprintf(stderr, "\nError: problem copying cyc_include.h\n");
      fflush(stderr);
      return tds;
    }
    n_written = fwrite(buf,1,n_read,out_file);
    if (n_read != n_written) {
      compile_failure = true;
      fprintf(stderr, "\nError: problem copying cyc_include.h\n");
      fflush(stderr);
      return tds;
    }
  }
  fclose(cyc_include_fnotnull);
  
  if (pp_r) {
    Absynpp::set_params(&params_r);
    Absynpp::decllist2file(tds,out_file);
  } else {
    Absyndump::set_params(&params_r);
    Absyndump::dumpdecllist2file(tds,out_file);
  }
  fflush(out_file);
  return tds;
}

// We must remember what .c files are produced so that we can remove them
// after we're done.
static list_t<stringptr_t> cfiles = NULL;
static void remove_cfiles() {
  if (!save_c_r)
    for (; cfiles != NULL; cfiles = cfiles->tl)
      remove_file(*(cfiles->hd));
}

/* Take as input a string, return the list of substrings separated by colons */
static list_t<stringptr_t> split_by_char(string_t<`H> s, char c) {
  if (s == NULL) return NULL;
  let result = NULL;
  let len = strlen(s);

  while (len > 0) {
    let end = strchr(s,c);
    if (end == NULL) {
      result = new List(new s,result);
      break;
    }
    else {
      result = new List(new ((string_t)substring(s,0,(string_t)end-s)),result);
      len -= ((string_t)end-s);
      s = end+1;
    }
  }
  return List::imp_rev(result);
}

/* FIX: once stat is ported we can use that instead */
static bool file_exists(string_t file) {
  FILE *f = NULL;
  try f = file_open(file,"r"); catch {default: break;}
  if (f == NULL) return false;
  else { fclose((FILE @)f); return true; }
}

/* Prints out a list of string pointers */
static string_t sprint_list(list_t<stringptr_t>dirs) {
  string_t tmp = "";
  for (; dirs != NULL; dirs = dirs->tl) {
    let dir = *dirs->hd;
    if (dir == NULL || strlen(dir)==0) continue;
    dir = strconcat(dir,":");
    tmp = strconcat(dir,tmp);
  }
  return tmp;
}

/* Looks for the file in the list of directories.  The order
   of the list matters---it returns the first file it finds. */
static string_t *find(list_t<stringptr_t> dirs, string_t file) {
  if (file == NULL) return NULL;
  for (; dirs != NULL; dirs = dirs->tl) {
    let dir = *dirs->hd;
    if (dir == NULL || strlen(dir)==0) continue;
    string_t s = Filename::concat(dir,file);
    if (file_exists(s)) return new s;
  }
  return NULL;
}

static string_t do_find(list_t<stringptr_t> dirs, string_t file) {
  let f = find(dirs, file);
  if (f == NULL) {
    fprintf(stderr,"Error: can't find internal compiler file %s in path %s\n", 
	    file, sprint_list(dirs));
    compile_failure = true;
    remove_cfiles();
    exit(1);
  }
  return *f;
}

/* Is a character special to /bin/sh (except for single quote)? */
static bool is_other_special(char c) {
  switch (c) {
  case '\\':
  case '"': 
  case ';': 
  case '&': 
  case '(': 
  case ')': 
  case '|': 
  case '^': 
  case '<': 
  case '>': 
  case ' ': 
  case '\n': 
  case '\t': return true;
  default: return false;
  }
}

/* Escape any characters special to /bin/sh */
static string_t sh_escape_string(string_t<`H> s) {
  let len = strlen(s);

  /* Count the number of single quotes and other special chars in s */
  let single_quotes = 0;
  let other_special = 0;
  for (int i = 0; i < len; i++) {
    let c = s[i];
    if (c == '\'') single_quotes++;
    else if (is_other_special(c)) other_special++;
  }

  /* No special chars to escape */
  if (single_quotes == 0 && other_special == 0)
    return s;

  /* No single quotes, we can just single quote s */
  if (single_quotes == 0)
    return strconcat_l(list(new "'",new (string_t)s, new "'"));

  /* We'll quote all special chars by prefixing with a backslash */
  let len2 = len + single_quotes + other_special;
  let s2 = new {for i < len2+1 : '\0'}; // add trailing NUL
  let i = 0;
  let j = 0;
  for (; i < len; i++) {
    let c = s[i];
    if (c == '\'' || is_other_special(c))
      s2[j++] = '\\';
    s2[j++] = c;
  }
  return s2;
}
static stringptr_t sh_escape_stringptr(stringptr_t<`H,`H> sp) {
  return new sh_escape_string(*sp);
}

static void process_file(string_t<`H> filename) {

  let basename = 
    Filename::chop_extension(output_file==NULL ? filename : *output_file);
  let preprocfile   = strconcat(basename, ".cyp");
  let interfacefile = strconcat(basename, ".cyci");
  let interfaceobjfile = strconcat(basename, ".cycio");
  let cfile         = strconcat(basename, ".c");

  if (v_r) fprintf(stderr,"Compiling %s\n", filename);

  // Check that the input file exists
  FILE * f0 = try_file_open(filename, "r", "input file");
  if (compile_failure)
    return;
  fclose((FILE @)f0);

  // Run the preprocessor, by building and running a command-line
  // Pass -I and -D things onto preprocessor
  let cppargs_string =
    str_sepstr(new List(new (string_t)"",
                                List::map(sh_escape_stringptr,rev(cppargs))),
                       " ");
  // About the cyclone include path---this path is specified with the
  // following order (where the earlier in the order, the first place we look
  // for the file):
  // 1) command line arguments (with -I)
  // 2) environment var (with CYCLONE_INCLUDE_PATH)
  // 3) hardwired in the build (by setting def_inc_path)
  string_t stdinc_string;
  string_t def_inc_path = Cstring_to_string(Cdef_inc_path);
  if (strlen(def_inc_path) > 0)
    stdinc_string = aprintf(" -I%s",def_inc_path);
  else
    stdinc_string = "";
  let cyclone_include_path = getenv("CYCLONE_INCLUDE_PATH");
  if (cyclone_include_path != NULL) {
    let x = split_by_char(cyclone_include_path,':');
    let s = str_sepstr(new List(new (string_t)"",
                                        List::map(sh_escape_stringptr,x)),
                               " -I");
    stdinc_string = aprintf("%s%s",s,stdinc_string);
  }
  string_t ofile_string;
  if (stop_after_cpp_r) {
    if (output_file != NULL)
      ofile_string = aprintf(" > %s", *output_file);
    else // output to standard out
      ofile_string = "";
  }
  else ofile_string = aprintf(" > %s", sh_escape_string(preprocfile));

  string_t fixup_string;
  if (produce_dependencies)
    // Both of the below hacks can probably be eliminated when we move
    // to gcc 3.0
    if (dependencies_target == NULL)
      // Hack to fix up dependency output of gcc 2.95: the target of
      // the dependency produced by cpp will be something like foo.cyc.o,
      // but we want it to be foo.o.
      fixup_string = " | sed 's/^\\(.*\\)\\.cyc\\.o:/\\1.o:/'";
    else {
      // Hack to handle the -MT flag, which is not supported in gcc 2.95
      // Note, we should probably make sure any special characters in
      // *dependencies_target are escaped, but WE DON'T.
      fixup_string =
        aprintf(" | sed 's/^.*\\.cyc\\.o:/%s:/'",
                *dependencies_target);
    }
  else fixup_string = "";

  let cmd = aprintf("%s %s%s %s%s%s",
	            cpp, cppargs_string, stdinc_string,
                    sh_escape_string(filename),
                    fixup_string, ofile_string);

  if (v_r) fprintf(stderr,"%s\n",cmd);
  if (system(cmd) != 0) {
    compile_failure = true;
    fprintf(stderr,"\nError: preprocessing\n");
    return;
  }
  if (stop_after_cpp_r) return;

  // Run the stages of the Cyclone compiler
  Position::reset_position(preprocfile); // necessary for good error messages!
  FILE * in_file  = try_file_open(preprocfile,"r","file");
  if (compile_failure) return;

  list_t<Absyn::decl_t> tds = NULL;

  // Parsing
  try
    tds = do_stage("parsing", do_parse, (FILE@)in_file, tds);
  catch {
  case x:
    file_close((FILE@)in_file);
    remove_file(preprocfile); // Can't flush warnings after removal
    throw x;
  }
  file_close((FILE@)in_file);
  if (compile_failure) {
    remove_file(preprocfile); // Can't flush warnings after removal
    return;
  } 

  let te = Tcenv::tc_init(); // Must declare BEFORE the goto 
  if (parseonly_r) goto PRINTC;

  // Type checking and control-flow checking
  tds = do_stage("type checking", do_typecheck, te, tds);
  if (compile_failure) {
    remove_file(preprocfile); // Can't flush warnings after removal
    return;
  } 
  tds = do_stage("control-flow checking", do_cfcheck, true, tds);
  if (compile_failure) {
    remove_file(preprocfile); // Can't flush warnings after removal
    return;
  } 

  // Interface checking
  if (ic_r) {
    FILE *inter_file = fopen(interfacefile, "r");
    FILE *inter_objfile = try_file_open(interfaceobjfile, "w", "interface object file");
    if (inter_objfile == NULL) {
      compile_failure = true;
      return;
    }
    Position::reset_position(interfacefile);
    tds = do_stage("interface checking", do_interface,
                   new $(te, inter_file, (FILE@) inter_objfile), tds);
    if (inter_file != NULL) {
      file_close((FILE @) inter_file);
    }
    file_close((FILE @) inter_objfile);
  }

  if (tc_r) goto PRINTC;

  // Translation to C
  tds = do_stage("translation to C", do_translate, true, tds);
  if (compile_failure) {
    remove_file(preprocfile); // Can't flush warnings after removal
    return;
  } 
  if (!compile_failure)
    Tcutil::flush_warnings();
  remove_file(preprocfile);
  if(compile_failure) return;
  if (tovc_r) tds = do_stage("post-pass to VC", do_tovc, true, tds);
  if (compile_failure) return;

  // jcheney: we should make a (empty) .c file even if the .cyc file produced no decls
  /*PRINTC:
    if (tds != NULL) */
 PRINTC: {
  FILE *out_file;
  if (parseonly_r || tc_r)
    if (output_file != NULL)
      out_file = try_file_open(*output_file,"w","output file");
    else
      out_file = stdout;
  else if (toc_r && output_file != NULL)
    out_file = try_file_open(*output_file,"w","output file");
  else
    out_file = try_file_open(cfile,"w","output file");
  
  if (compile_failure) return;
  
  try
    tds = do_stage("printing", do_print, (FILE @)out_file, tds);
  catch {
  case x:
    compile_failure = true;
    file_close((FILE @)out_file);
    cfiles = new List(new ((string_t)cfile),cfiles);
    throw x;
  }
  file_close((FILE @)out_file);
  cfiles = new List(new ((string_t)cfile),cfiles); 
  }
}

static string_t final_str = "<final>";
static stringptr_t final_strptr = &final_str;

static interface_t read_cycio(string_t<`H> @ n) {
  if (n == final_strptr) {
    return Interface::final();
  }
  string_t basename;
  try {
    basename = Filename::chop_extension(*n);
  } catch {
  case &Invalid_argument(_): basename = *n; break;
  }
  let nf = strconcat(basename, ".cycio");
  let f = try_file_open(nf, "r", "interface object file");
  if (f == NULL) {
    compile_failure = true;
    remove_cfiles();
    exit(1);
  }
  Position::reset_position(nf); /* in case of parsing problems */
  //printf("reading %s\n", nf);
  let i = Interface::load((FILE@) f);
  file_close((FILE@)f);
  return i;
}

static bool is_cfile(string_t @ n) {
  return (*n)[0] != '-';
}

int main(int argc, string_t<`H> ?`H argv) {

  // set default preprocessor before overwriting with argument processing
  string_t comp = Cstring_to_string(Ccomp);
  set_cpp(strconcat(comp," -x c -E -U__GNUC__ -nostdinc"));

  // now parse the arguments
  Arg::speclist_t<`H,`H> options =
    list(new $("-v",false,"",
               new Set_spec(&v_r),
               "Print compilation stages verbosely"),
	 new $("--version",false,"",
	       new Unit_spec(print_version),
               "Print version number and exit"),
	 new $("-o",false," <file>",
               new String_spec(set_output_file),
               "Set the output file name to <file>"),
         new $("-D",true,"<name>[=<value>]",
               new Flag_spec(add_cpparg),
               "Pass definition to preprocessor"),
         new $("-B",true,"<file>",
               new Flag_spec(add_cyclone_lib_path),
               "Add to the list of directories to search for compiler files"),
         new $("-I",true,"<dir>",
               new Flag_spec(add_cpparg),
               "Add to the list of directories to search for include files"),
         new $("-L",true,"<dir>",
               new Flag_spec(add_cpparg),
               "Add to the list of directories for -l"),
         new $("-l",true,"<file>",
               new Flag_spec(add_libarg),
               "Library file"),
         new $("-c",false,"",
               new Unit_spec(set_stop_after_objectfile),
               "Produce an object file instead of an executable; do not link"),
	 new $("-x",false," <language>",
               new String_spec(set_inputtype),
               "Specify <language> for the following input files"),
         new $("-s",false,"",
               new Flag_spec(add_ccarg),
               "Remove all symbol table and relocation info from executable"),
         new $("-O0",false,"",
               new Flag_spec(add_ccarg),
               "Don't optimize"),
         new $("-O",false,"",
               new Flag_spec(add_ccarg),
               "Optimize"),
         new $("-O2",false,"",
               new Flag_spec(add_ccarg),
               "A higher level of optimization"),
         new $("-O3",false,"",
               new Flag_spec(add_ccarg),
               "Even more optimization"),
         new $("-g",false,"",
               new Flag_spec(add_ccarg),
               "Compile for debugging"),
         new $("-p",false,"",
               new Flag_spec(add_ccarg),
               "Compile for profiling with prof"),
         new $("-pg",false,"",
               new Flag_spec(add_ccarg),
               "Compile for profiling with gprof"),
         new $("-pa",false,"",
               new Unit_spec(set_pa),
               "Compile for profiling with aprof"),
         new $("-S",false,"",
               new Unit_spec(set_stop_after_asmfile),
               "Stop after producing assembly code"),
         new $("-M",false,"",
               new Unit_spec(set_produce_dependencies),
               "Produce dependencies"),
         new $("-MG",false,"",
               new Flag_spec(add_cpparg),
               "When producing dependencies assume that missing "
               "files are generated"),
         new $("-MT",false," <target>",
               new String_spec(set_dependencies_target),
               "Give target for dependencies"),
         new $("-E",false,"",
               new Set_spec(&stop_after_cpp_r),
               "Stop after preprocessing"),
         new $("-stopafter-parse",false,"",
               new Set_spec(&parseonly_r),
               "Stop after parsing"),
         new $("-stopafter-tc",false,"",
               new Set_spec(&tc_r),
               "Stop after type checking"),
         new $("-stopafter-toc",false,"",
               new Set_spec(&toc_r),
               "Stop after translation to C"),
         new $("-ic",false,"",
               new Set_spec(&ic_r),
               "Activate the link-checker"),
         new $("-pp",false,"",
               new Set_spec(&pp_r),
               "Pretty print"),
         new $("-up",false,"",
               new Clear_spec(&pp_r),
               "Ugly print"),
         new $("-tovc",false,"",
               new Set_spec(&tovc_r),
               "Avoid gcc extensions in C output"),
         new $("-save-temps",false,"",
               new Unit_spec(set_save_temps),
               "Don't delete temporary files"),
         new $("-save-c",false,"",
               new Set_spec(&save_c_r),
               "Don't delete temporary C files"),
         new $("--lineno",false,"",
               new Unit_spec(set_lineno),
               "Generate line numbers for debugging"),
         new $("--nochecks",false,"",
               new Unit_spec(set_nochecks),
               "Disable bounds/null checks"),
         new $("--nonullchecks",false,"",
               new Unit_spec(set_nonullchecks),
               "Disable null checks"),
         new $("--noboundschecks",false,"",
               new Unit_spec(set_noboundschecks),
               "Disable bounds checks"),
         new $("-use-cpp",false,"<path>",
               new String_spec(set_cpp),
               "Indicate which preprocessor to use"),
         new $("-no-cpp-precomp",false,"",
               new Unit_spec(set_nocppprecomp),
               "Don't do smart preprocessing (mac only)"),
         new $("-nocyc",false,"",
               new Unit_spec(set_nocyc),
               "Don't add implicit namespace Cyc"),
         new $("-nogc",false,"",
               new Set_spec(&nogc_r),
               "Don't link in the garbage collector"),
         new $("-noremoveunused",false,"",
               new Set_spec(&noshake_r),
               "Don't remove externed variables that aren't used"),
         new $("-noexpandtypedefs",false,"",
               new Set_spec(&noexpand_r),
               "Don't expand typedefs in pretty printing"),
         new $("-printalltvars",false,"",
               new Set_spec(&print_all_tvars_r),
               "Print all type variables (even implicit default effects)"),
         new $("-printallkinds",false,"",
               new Set_spec(&print_all_kinds_r),
               "Always print kinds of type variables"),
         new $("-printfullevars",false,"",
               new Set_spec(&print_full_evars_r),
               "Print full information for evars (type debugging)")
         );

  Arg::parse(options, add_other, "Options:", argv);

  // Find the file cyc_include.h, needed to produce the .c output.
  // The Cyclone lib-path is specified with the following order (where
  // the earlier in the order, the first place we look for the file):
  // 1) command line arguments (with -B)
  // 2) environment var (with CYCLONE_EXEC_PREFIX)
  // 3) hardwired in the build (by setting lib_path)
  string_t cyclone_exec_prefix = getenv("CYCLONE_EXEC_PREFIX");
  if (cyclone_exec_prefix != NULL)
    cyclone_lib_path = new List(new cyclone_exec_prefix, cyclone_lib_path);
  string_t def_lib_path = Cstring_to_string(Cdef_lib_path);
  if (strlen(def_lib_path) > 0)
    cyclone_lib_path = new List(new def_lib_path, cyclone_lib_path);
  /* Look for other cyclone libraries during linking */
  if (cyclone_lib_path != NULL)
    add_ccarg(strconcat("-L",*cyclone_lib_path->hd));
  cyclone_lib_path = List::imp_rev(cyclone_lib_path);
  /* The absolute file name is kept in a global variable */
  cyc_include = do_find(cyclone_lib_path,"include/cyc_include.h");

  for (let l = rev(cyclone_files); l != NULL; l = l->tl) {
    process_file(*(l->hd));
    if (compile_failure) return 1;
  }

  if (stop_after_cpp_r || parseonly_r || tc_r || toc_r) return 0;

  // If there are no files for the C compiler to process don't bother
  // to run it.
  if (ccargs == NULL) return 0;

  // Run the C compiler
  // First, find the files libcyc.a, gc.a

  ccargs = rev(ccargs);
  let ccargs_string = str_sepstr(List::map(sh_escape_stringptr,ccargs), " ");
  libargs = rev(libargs);
  let libargs_string = str_sepstr(new List(new ((string_t)""),
					   List::map(sh_escape_stringptr,libargs)), " ");

  let stdlib;
  let stdlib_string;
  let is_not_executable =
    stop_after_asmfile_r ||
    stop_after_objectfile_r ||
    (output_file != NULL && Filename::check_suffix(*output_file, ".a")) ||
    (output_file != NULL && Filename::check_suffix(*output_file, ".lib")); 
  if (is_not_executable) {
    stdlib = NULL;
    stdlib_string = (string_t)"";
  } else {

    // FIX: -pg should get different versions of the libraries?
    //      What about -g?
    string_t libcyc_filename;
    string_t nogc_filename;
    string_t gc_filename; 
    if(pa_r) {
      libcyc_filename = "libcyc_a.a";
      nogc_filename = "nogc_a.a";
    } else if(nocheck_r) {
      libcyc_filename = "libcyc_nocheck.a";
      nogc_filename = "nogc_nocheck.a";
    } else {
      libcyc_filename = "libcyc.a";
      nogc_filename = "nogc.a";
    }
    gc_filename = "gc.a";
 
    let libcyc = do_find(cyclone_lib_path,libcyc_filename);
    let gc = (nogc_r ?
              do_find(cyclone_lib_path,nogc_filename):
              do_find(cyclone_lib_path,gc_filename));

    stdlib = list(new libcyc);
    stdlib_string = aprintf(" %s %s", libcyc, gc);
  }

  if (ic_r) try {
    ccargs = filter(is_cfile, ccargs);
    libargs = filter(is_cfile, libargs);
    let lf = append(stdlib, append(ccargs, libargs));
    if (! is_not_executable) {
      lf = new List(final_strptr, lf);
    }

    let i = Interface::get_and_merge_list(read_cycio, lf, lf);
    if (i == NULL) {
      fprintf(stderr,"Error: interfaces incompatible\n");
      compile_failure = true;
      remove_cfiles();
      return 1;
    }
    if (is_not_executable) {
      if (output_file != NULL) {
	let output_file_io = aprintf("%s.cycio", Filename::chop_extension(*output_file));
	let f = try_file_open(output_file_io, "w", "interface object file");
	if (f == NULL) {
	  compile_failure = true;
	  remove_cfiles();
	  return 1;
	}
	Interface::save((interface_t) i, (FILE@)f);
	file_close((FILE@)f);
      }
    } else {
      if(!Interface::is_subinterface(Interface::empty(), (interface_t) i,
				     new $("empty interface", "global interface"))) {
	fprintf(stderr,"Error: some objects are still undefined\n");
	compile_failure = true;
	remove_cfiles();
	return 1;
      }
    }
  } catch {
  case &Core::Failure(s):
    printf ("Exception Core::Failure %s\n", s);
    compile_failure = true;
    remove_cfiles();
    return 1;
  case &Core::Impossible(s):
    printf ("Exception Core::Impossible %s\n", s);
    compile_failure = true;
    remove_cfiles();
    return 1;
  case Dict::Absent:
    printf("Exception Dict::Absent\n");
    compile_failure = true;
    remove_cfiles();
    return 1;
  case &Invalid_argument(s):
    printf ("Exception Core::Invalid_argument %s\n", s);
    compile_failure = true;
    remove_cfiles();
    return 1;
  case _:
    printf ("Uncaught exception\n");
    compile_failure = true;
    remove_cfiles();
    return 1;
  }

  let cccmd =
    aprintf("%s %s %s%s%s",
	    comp,
            (output_file==NULL?((string_t)""):aprintf(" -o %s",sh_escape_string(*output_file))),
            ccargs_string,
	    stdlib_string,
            libargs_string);
  if (v_r) fprintf(stderr,"%s\n",cccmd);
  if (system(cccmd) != 0) {
    fprintf(stderr,"Error: C compiler failed\n");
    compile_failure = true;
    remove_cfiles();
    return 1;
  }
  remove_cfiles();

  return compile_failure ? 1 : 0;
}
