/* Type checking for statements.
   Copyright (C) 2001 Greg Morrisett, AT&T
   This file is part of the Cyclone compiler.

   The Cyclone compiler is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   The Cyclone compiler is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with the Cyclone compiler; see the file COPYING. If not,
   write to the Free Software Foundation, Inc., 59 Temple Place -
   Suite 330, Boston, MA 02111-1307, USA. */


#include <core.h>
#include <list.h>
#include <position.h>
#include "absyn.h"
#include "absynpp.h"
#include "tcutil.h"
#include "tcenv.h"
#include "tcexp.h"
#include "tcpat.h"
#include "new_control_flow.h"
#include "tcstmt.h"
#include "evexp.h"
#include <stdio.h>

namespace Tcstmt;

using Core;
using List;
using Position;
using Absyn;
using Absynpp;
using Tcutil;
using Tcenv;
using Tcexp;
using Tcpat;

static void decorate_stmt(tenv_t te, stmt_t s) {
  NewControlFlow::set_encloser(s, get_encloser(te));
  s->try_depth = get_try_depth(te);
}

// used to type-check Let_d, switch clauses, and catch clauses
static void pattern_synth(seg_t loc, tenv_t te, list_t<tvar_t> tvs,
			  list_t<vardecl_t> vs, stmt_t s, exp_opt_t where_opt,
			  bool new_block) {
  tenv_t te2 = add_type_vars(loc,te,tvs);
  if(new_block)
    te2 = Tcenv::new_block(loc,te2);
  let ropt = new Opt(Tcenv::curr_rgn(te2));
  for(let vs2 = vs; vs2 != NULL; vs2 = vs2->tl) {
    te2 = add_pat_var(loc, te2, vs2->hd);
    vs2->hd->rgn = ropt;
  }

  if(where_opt != NULL)
    tcTest(te2,(exp_t)where_opt,"switch clause guard");

  if(vs != NULL)
    te2 = set_encloser(te2,s); // for substatements inside of s
  tcStmt(te2,s,false); // pattern vars are in a different region from body ??
  // The encloser of s is not s, so reset it properly.
  if(vs != NULL)
    NewControlFlow::set_encloser(s,get_encloser(te));
}

// Check the declarations of a forarray statement.  The declarations
// should be of the form: 
//    t@`r const x = y+e    or
//    t@`r const x = y      or
//    t@`r const x = &y[e]
// Returns a list of the array variables used in the definitions (e.g., y)
// so that we can check the tests involve these variables.
$(tenv_t, list_t<qvar_t>) check_forarray_decls(tenv_t te, seg_t loc, 
                                               list_t<vardecl_t> decls) {
  impos("check_forarray_decls");
  return $(te,NULL);
}


// new_block is a kludge because we he abstract syntax doesn't group the
// local declarations in a block, but the region rules do.  (That is,
// adjacent declarations are in the same region.  Those at the beginning
// of a function are in the same region as the parameters.
// Case variables are in new regions, but let variables follow the adjacency
// rules.  We may revisit some of these semi-arbitrary decisions.)
// Note: With these adjacency rules, you can't just throw skip statements in
//       anywhere because they end regions.
void tcStmt(tenv_t te, stmt_t s0, bool new_block) {
  
  decorate_stmt(te,s0);

  switch (s0->r) {

  case Skip_s: return;

  case &Exp_s(e): tcExp(te,NULL,e); return;

  case &Seq_s(s1,s2):
    let te2 = set_next(te,new Stmt_j(s2));
    tcStmt(te2,s1,true); // pass new_block in case of weird associativity??
    // JGM: try to treat sequences as "tail-calls" to avoid a deep stack.
    // (Of course, this depends on the parser's associativity.)
    while (true)
      switch (s2->r) {
      case &Seq_s(s3,s4):
	decorate_stmt(te,s2);
	te2 = set_next(te,new Stmt_j(s4));
	tcStmt(te2,s3,true);
	s2  = s4;
	continue;
      default: goto seq_end; // break out of loop
      }
  seq_end:
    tcStmt(te,s2,true);
    return;

  case &Return_s(eopt):
    type_t t = return_typ(te);
    if (eopt == NULL) {
      switch (compress(t)) {
      case VoidType: break;
      default:
	terr(s0->loc,"must return a value of type %s",typ2string(t));
        break;
      }
    } else {
      exp_t e = (exp_t)eopt;
      tcExp(te,&t,e);
      if (!coerce_arg(te,e,t)) {
	terr(s0->loc, "returns value of type %s but requires %s",
             typ2string(e->topt->v), typ2string(t));
        explain_failure();
      }
      /*
      switch (compress(t)) {
      case VoidType: terr(s0->loc,"function returns void expression"); break;
      default: break;
      }
      */
    }
    return;

  case &IfThenElse_s(e,s1,s2):
    tcTest(te,e,"if statement"); // passing string causes allocation :-(
    tcStmt(te,s1,true);
    tcStmt(te,s2,true);
    return;

  case &While_s($(e,cont_s),s):
    decorate_stmt(te,cont_s);
    tcTest(te,e,"while loop");
    tcStmt(set_in_loop(te,cont_s),s,true);
    return;

  case &For_s(e1,$(e2,guard_s),$(e3,cont_s),s):
    decorate_stmt(te,guard_s);
    decorate_stmt(te,cont_s);
    tcExp(te,NULL,e1);
    tcTest(te,e2,"for loop");
    te = set_in_loop(te,cont_s);
    tcStmt(te,s,true);
    tcExp(te,NULL,e3); // ??? what does a break/continue in e3 mean ???
    return;

  case &ForArray_s(ForArrayInfo{decls, $(e2,guard_s), $(e3,cont_s), s}):
    impos("ForArray_s");
    return;
    /*
    decorate_stmt(te,guard_s);
    decorate_stmt(te,cont_s);
    let $(te,used_ptrs) = check_forarray_decls(te,s0->loc,decls);
    tcTest(te,e2,"forarray loop");
    let cmp_ops = check_forarray_test(te,loc,decls,used_ptrs,e2);
    te = set_in_loop(te,cont_s);
    tcStmt(te,s,true);
    // hack -- we make the declared pointer variables mutable here
    // so that e3 can update it.
    for (_ d = decls; d != NULL; d = d->tl) 
      d->tq.q_const = false;
    tcExp(te,NULL,e3); // ??? what does a break/continue in e3 mean ???
    check_forarray_delta(te,loc,decls,cmp_ops,e3);
    */
  case &Do_s(s,$(e,cont_s)):
    decorate_stmt(te,cont_s);
    tcStmt(set_in_loop(te,cont_s),s,true);
    tcTest(te,e,"do loop");
    return;

    // In the next 4 cases, the function call assigns through sopt
    // We leave the work to Tcenv b/c it has all the control information
  case &Break_s(*sopt):    process_break(te,s0,sopt);    return;
  case &Continue_s(*sopt): process_continue(te,s0,sopt); return;
  case &Goto_s(l,*sopt):   process_goto(te,s0,l,sopt);   return;

  case &Fallthru_s(es,*clauseopt):
    let trip_opt = process_fallthru(te,s0,clauseopt);
    if(trip_opt == NULL) {
      terr(s0->loc,"fallthru not in a non-last case");
      return;
    }
    let &$(_,tvs,ts) = (_@)(trip_opt);
    list_t<$(tvar_t,type_t)@> instantiation = 
      List::map_c(make_inst_var,lookup_type_vars(te),tvs);
    ts = List::map_c(substitute,instantiation,ts);
    for(; ts != NULL && es != NULL; ts = ts->tl, es = es->tl) {
      tcExp(te,NULL,es->hd);
      if(!coerce_arg(te,es->hd,ts->hd)) {
	terr(s0->loc, "fallthru argument has type %s "
             "but pattern variable has type %s",
             typ2string(es->hd->topt->v), typ2string(ts->hd));
        explain_failure();
      }
    }
    if (es != NULL)
      terr(s0->loc, "too many arguments to explicit fallthru");
    if (ts != NULL)
      terr(s0->loc, "too few arguments to explicit fallthru");
    return;

  // Note: NewControlFlow requires we add the label with s, not s0 !!
  //       (That way, we can use switch_clause bodies and stmtExp stmt's
  //       as enclosers and get the right behavior!!!)
  case &Label_s(l,s): 
    // Note that we set new_block to false because we're explicitly creating
    // a new named block here.
    tcStmt(Tcenv::new_named_block(s0->loc,add_label(te,l,s),
                                  new Tvar(new ((string_t)aprintf("`%s",*l)),new_tvar_id(),
                                           new Eq_kb(RgnKind))),s,false); 
    return;

  case &Switch_s(e,scs0):
    tcExp(te,NULL,e);
    let t = e->topt->v;
    // type-check the cases in reverse order, a fallthru therefore transfers
    // control to the case most recently type-checked. For the last case,
    // fallthru is not allowed.
    te = set_in_switch(te);
    te = clear_fallthru(te);
    for (_ scs = List::rev(scs0); scs != NULL; scs = scs->tl) {
      let p = scs->hd->pattern;
      // FIX: can pass region if e is an lvalue
      let $(new_tvs,vds) = tcPat(te,p,&t,NULL);
      if (!unify(p->topt->v,t)) {
	terr(scs->hd->loc, "switch on type %s, but case expects type %s",
             typ2string(t), typ2string(p->topt->v));
        explain_failure();
      }
      else
	check_pat_regions(te,p);
      scs->hd->pat_vars = new Opt(vds);
      // type-checking the body will type-check any explicit fallthrus.
      pattern_synth(scs->hd->loc, te, new_tvs, vds, scs->hd->body,
		    scs->hd->where_clause, true);
      te = set_fallthru(te, new_tvs, vds, scs->hd);
    }
    check_switch_exhaustive(s0->loc,scs0);
    return;

  case &SwitchC_s(e,scsC):
    // translate to switch after evaluating the case expressions (which must
    // be constant)
    // FIX: not right for e an enum type b/c we produce int patterns
    let scs = NULL;
    for(; scsC !=NULL; scsC = scsC->tl) {
      let &SwitchC_clause(e1,body1,loc1) = scsC->hd;
      _ pat;
      if(e1 != NULL) {
	tcExp(te,NULL,(exp_t)e1);
	pat = new_pat(new Int_p(Signed,Evexp::eval_const_uint_exp((exp_t)e1)),
		      e1->loc);
      } else
	pat = new_pat(Wild_p, loc1);
      scs = new List(new Switch_clause(pat, NULL, NULL, body1, loc1), scs);
    }
    s0->r = switch_stmt(e, imp_rev(scs), NULL)->r;
    tcStmt(te, s0, new_block);
    return;

  case &TryCatch_s(s,scs0):
    // This is a KLUDGE so that we have a next statement that is not
    // outside of the handler, eg. for try while(b) break; catch ...
    // We have to do this b/c the translation to C uses the destinations
    // to pop handlers.
    s->r = seq_stmt(new_stmt(s->r,s->loc), skip_stmt(s->loc), s->loc)->r;

    // must set encloser b/c cannot goto into a handler.
    tcStmt(set_encloser(enter_try(te),s0),s,true);

    // similar to Switch_s -- check the patterns in reverse order:
    te = set_in_switch(te);
    te = clear_fallthru(te);
    for (let scs = List::rev(scs0); scs != NULL; scs = scs->tl) {
      let p       = scs->hd->pattern;
      let $(new_tvs,x) = tcPat(te,p,&exn_typ,NULL);
      if (!unify(p->topt->v,exn_typ))
        terr(scs->hd->loc, "expected xtunion exn but found %s",
             typ2string(p->topt->v));
      else
	check_pat_regions(te,p);
      scs->hd->pat_vars = new Opt(x);
      // type-checking the body will type-check any explicit fallthrus
      pattern_synth(scs->hd->loc, te, new_tvs, x, scs->hd->body,
		    scs->hd->where_clause, true);
      te = set_fallthru(te, new_tvs, x, scs->hd);
    }
    check_catch_overlap(s0->loc,scs0);
    return;

  case &Decl_s(d,s):
    string_t unimp_msg_part;

    if(new_block)
      te = Tcenv::new_block(s0->loc,te);

    switch (d->r) {
    case &Var_d(vd):
      let &Vardecl(sc,&$(nsl,x),tq,t,initializer,*rgn_ptr,atts,_) = vd;
      let curr_bl = Tcenv::curr_rgn(te);
      bool is_local;
      switch (sc) {
      case Static: 
      case Extern: 
      case ExternC: is_local = false; break;
      case Abstract: 
        terr(d->loc,"bad abstract scope for local variable"); 
        fallthru;
      case Public: is_local = true; break;
      }
        
      *rgn_ptr = is_local ? new Opt(curr_bl) : new Opt(HeapRgn); // side effect
      switch (nsl) {
      case Loc_n: break;
      case &Rel_n(NULL):
        (*vd->name)[0] = Loc_n;
        break;
      case &Abs_n(y): throw impos("tcstmt: Abs_n declaration");
      default:
        terr(d->loc, "cannot declare a qualified local variable");
        break;
      }
      // if it's an array or string, fill in the size on the type
      switch (compress(t)) {
      case &ArrayType(telt,tq,NULL) && vd->initializer != NULL:
        switch (vd->initializer->r) {
          case &Const_e(&String_c(s)):
          t = vd->type = new ArrayType(telt,tq,uint_exp(s.size,NULL));
          break;
	  case &Comprehension_e(_,e,_):
	  // FIX: copy e here!
	  t = vd->type = new ArrayType(telt,tq,e); break;
          case &UnresolvedMem_e(_,es): fallthru(es);
          case &Array_e(es):
          t = vd->type = 
            new ArrayType(telt,tq,uint_exp(List::length(es),NULL));
          break;
          default: break;
        }
        break;
      default: break;
      }
      
      // type safety demands static variables are closed (like globals)
      // (the error message may be confusing b/c it *looks* like tyvars
      //  are in scope)
      let bound_vars = (!is_local) ? NULL : lookup_type_vars(te);
      let allow_evars = (!is_local) ? false : true;
      check_type(s0->loc,te,bound_vars,MemKind,allow_evars,t);
      let te2 = add_local_var(s->loc,te,vd);
      if (sc == Extern || sc == ExternC)
        terr(d->loc,"local extern declarations not yet supported");
      //      if (sc == Static && !supports_default(t) && initializer == NULL)
      //        terr(d->loc,"static local declaration requires an initializer");
      if (initializer != NULL) {
        tcExpInitializer(te2,&t,(exp_t)initializer);
	// te is only used by is_const_exp for globals and function names
	if(!is_local && !is_const_exp(te,(exp_t)initializer))
	  terr(d->loc, "initializer needs to be a constant expression");
        if (!coerce_assign(te2,(exp_t)initializer,t)) {
	  terr(d->loc, "%s declared with type \n%s\n but initialized with type \n%s",
               *x, typ2string(t), typ2string(initializer->topt->v));
          explain_failure();
        }
      }
      tcStmt(set_encloser(te2,s0),s,false);
      return;

    case &Let_d(p,*vds,*topt_ref,e,*exhaust):
      let topt = *topt_ref;
      tcExpInitializer(te,NULL,e);
      *topt_ref = e->topt; // side effect
       //FIX: can pass region if e an lvalue
      let $(new_tvs,x) = tcPat(te,p,&e->topt->v,NULL);
      *vds = new Opt(x);
      if (topt != NULL && !unify(p->topt->v,topt->v))
        terr(d->loc,"type of pattern does not match declared type");
      if (!unify(p->topt->v,e->topt->v)) {
	terr(d->loc,"pattern type %s does not match definition type %s",
             typ2string(p->topt->v),typ2string(e->topt->v));
        explain_failure();
      }
      else
	check_pat_regions(te,p);
      *exhaust = check_let_pat_exhaustive(p->loc,p); // side effect
      pattern_synth(s0->loc, te, new_tvs, x, s, NULL, false);
      return;

    case &Letv_d(vds):
      let curr_bl = Tcenv::curr_rgn(te);
      let te2 = te;
      for (; vds != NULL; vds = vds->tl) {
        let vd = vds->hd;
        let &Vardecl(_,&$(nsl,_),_,t,_,*rgn_ptr,_,_) = vd;
        *rgn_ptr = new Opt(curr_bl); // side effect
        switch (nsl) {
        case Loc_n: break;
        case &Rel_n(NULL):
          (*vd->name)[0] = Loc_n;
          break;
        case &Abs_n(y): throw impos("tcstmt: Abs_n declaration");
        default:
          terr(d->loc, "cannot declare a qualified local variable");
          break;
        }
        check_type(s0->loc,te2,lookup_type_vars(te2),MemKind,true,t);
        te2 = add_local_var(s->loc,te2,vd);
      }
      tcStmt(set_encloser(te2,s0),s,false);
      return;

    case &Namespace_d(n,tds): unimp_msg_part = "namespace"; break;
    case &Using_d(q,tds):     unimp_msg_part = "using";     break; //FIX: allow
    case &Fn_d(_):            unimp_msg_part = "function";  break;
    case &Struct_d(_):        unimp_msg_part = "struct";    break;
    case &Union_d(_):         unimp_msg_part = "union";     break;
    case &Tunion_d(_):        unimp_msg_part = "[x]tunion"; break;
    case &Enum_d(_):          unimp_msg_part = "enum";   break;
    case &Typedef_d(_):       unimp_msg_part = "typedef";   break;
    case &ExternC_d(_):       unimp_msg_part = "extern \"C\""; break;
    }
    throw impos("tcStmt: nested %s declarations unimplemented",unimp_msg_part);

  case &Region_s(tv,vd,s):
    // Same KLUDGE as with TryCatch_s -- we need a next statement that is
    // not outside of the handler.
    s->r = seq_stmt(new_stmt(s->r,s->loc), skip_stmt(s->loc), s->loc)->r;
    if (new_block)
      te = Tcenv::new_block(s0->loc,te);
    let &Vardecl(_,_,_,t,_,*rgn_ptr,_,_) = vd;
    let curr_bl = Tcenv::curr_rgn(te);
    type_t rgn_typ = new VarType(tv);
    *rgn_ptr = new Opt(curr_bl); // side effect
    te = add_type_vars(s0->loc,te,new List(tv,NULL));
    check_type(s0->loc,te,lookup_type_vars(te),BoxKind,true,t);
    te = add_region(te, rgn_typ);
    if (!unify(t,new RgnHandleType(rgn_typ)))
      impos("region stmt: type of region handle is wrong!");
    tcStmt(set_encloser(add_local_var(s->loc,enter_try(te),vd),s0),s,false);
    return;

  case &Cut_s(s):    throw impos("tcStmt: cut is not implemented");    // FIX
  case &Splice_s(s): throw impos("tcStmt: splice is not implemented"); // FIX
  }
}
