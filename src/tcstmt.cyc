/* Type checking for statements.
   Copyright (C) 2001 Greg Morrisett, AT&T
   This file is part of the Cyclone compiler.

   The Cyclone compiler is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   The Cyclone compiler is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with the Cyclone compiler; see the file COPYING. If not,
   write to the Free Software Foundation, Inc., 59 Temple Place -
   Suite 330, Boston, MA 02111-1307, USA. */

#include <core.h>
#include <list.h>
#include <position.h>
#include "absyn.h"
#include "absynpp.h"
#include "tcutil.h"
#include "tcenv.h"
#include "tcexp.h"
#include "tcpat.h"
#include "new_control_flow.h"
#include "tcstmt.h"
#include "evexp.h"
#include "toc.h" // for no_regions flag
#include <cycboot.h>

#ifdef NO_PATHS
#define UNIQUE_ERR_MSG "Cannot consume paths; do swap instead"
#else
#define UNIQUE_ERR_MSG "Cannot consume non-unique paths; do swap instead"
#endif

using Core;
using List;
using Position;
using Absyn;
using Absynpp;
using Tcutil;
using Tcenv;
using Tcexp;
using Tcpat;

namespace Tcstmt;

// we're trying to simplify the situation where we have x++
// and want to rewrite it to ++x.  This can be done in any
// context where we don't care about the value of x++.  This is
// important for pointer ops because x++ is fairly expensive.
static void simplify_unused_result_exp(exp_t e) {
  switch (e->r) {
  case &Increment_e(e1,PostInc):
    e->r = new Increment_e(e1,PreInc); break;
  case &Increment_e(e1,PostDec):
    e->r = new Increment_e(e1,PreDec); break;
  default: break;
  }
}
  
static void decorate_stmt(tenv_t te, stmt_t s) {
  NewControlFlow::set_encloser(s, get_encloser(te));
  s->try_depth = get_try_depth(te);
}

// used to type-check Let_d, switch clauses, and catch clauses
static void pattern_synth(seg_t loc, tenv_t te, tcpat_result_t pat_res,
			  stmt_t s, exp_opt_t where_opt, bool new_block) {
  let TcPatResult(p,vs) = pat_res;
  let tvs = (p==NULL) ? NULL : (*p)[0];
  let bds = (p==NULL) ? NULL : (*p)[1];
  TEMP_RGN(te,r) {
    tenv_t te2 = add_type_vars(r,loc,te,tvs);
    te2 = new_outlives_constraints(r,te2,bds,loc);
    if(new_block)
      te2 = Tcenv::new_block(r,loc,te2);
    let ropt = new Opt(Tcenv::curr_rgn(te2));
    for(let vs2 = vs; vs2 != NULL; vs2 = vs2->tl) {
      te2 = add_pat_var(r,loc, te2, vs2->hd);
      vs2->hd->rgn = ropt;
    }
    if(where_opt != NULL)
      tcTest(te2,(exp_t)where_opt,"switch clause guard");

    if(vs != NULL)
      te2 = set_encloser(r,te2,s); // for substatements inside of s
    tcStmt(te2,s,false); // pattern vars are in a different region from body ??
    // The encloser of s is not s, so reset it properly.
  }
  if(vs != NULL)
    NewControlFlow::set_encloser(s,get_encloser(te));
}

static list_t<`b,`r> cmap_c(region_t<`r> r,`b f(`c,`a), `c env, clist_t<`a> x)
{
  if (x == NULL) return NULL;
  else return rnew(r) List(f(env,x->hd),cmap_c(r,f,env,x->tl));
}

// add a region equality between r1 and r2 for the duration of checking
// this statement
static void tcStmtRefine(tenv_t te, stmt_t s0,
			 type_t r1, type_t r2,
			 bool new_block) {
  TEMP_RGN(te,r) {
    $(tvar_t,kindbound_t) * tk = NULL;
    let te2 = add_region_equality(r,te,r1,r2,&tk,s0->loc);
    tcStmt(te2,s0,new_block);
    if (tk != NULL)
      (*tk)[0]->kind = (*tk)[1];
  }
}

// new_block is a kludge because we he abstract syntax doesn't group the
// local declarations in a block, but the region rules do.  (That is,
// adjacent declarations are in the same region.  Those at the beginning
// of a function are in the same region as the parameters.
// Case variables are in new regions, but let variables follow the adjacency
// rules.  We may revisit some of these semi-arbitrary decisions.)
// Note: With these adjacency rules, you can't just throw skip statements in
//       anywhere because they end regions.
void tcStmt(tenv_t te, stmt_t s0, bool new_block) {
  
  decorate_stmt(te,s0);

  switch (s0->r) {

  case &Skip_s: return;

  case &Exp_s(e): 
    tcExp(te,NULL,e); 
    if (!Tcexp::in_stmt_exp)
      simplify_unused_result_exp(e);
    return;

  case &Seq_s(s1,s2):
    TEMP_RGN(te, r) {
      let te2 = set_next(r, te,new Stmt_j(s2));
      tcStmt(te2,s1,true); // pass new_block in case of weird associativity??
    }
    tcStmt(te,s2,true);
    return;
    /*
    // JGM: try to treat sequences as "tail-calls" to avoid a deep stack.
    // (Of course, this depends on the parser's associativity.)
    while (true)
      switch (s2->r) {
      case &Seq_s(s3,s4):
	decorate_stmt(te,s2);
	te2 = set_next(te,new Stmt_j(s4));
	tcStmt(te2,s3,true);
	s2  = s4;
	continue;
      default: goto seq_end; // break out of loop
      }
  seq_end:
    tcStmt(te,s2,true);
    return;
    */

  case &Return_s(eopt):
    type_t t = return_typ(te);
    if (eopt == NULL) {
      switch (compress(t)) {
      case &VoidType: break;
      case &FloatType(_):
      case &IntType(_,_):
	warn(s0->loc,"should return a value of type %s",typ2string(t));
        break;
      default:
	terr(s0->loc,"must return a value of type %s",typ2string(t));
        break;
      }
    } else {
      // don't introduce alias expressions here; would be useless
      bool bogus = false;
      exp_t e = (exp_t)eopt;
      tcExp(te,&t,e);
      if (!coerce_arg(te,e,t,&bogus)) {
        terr(s0->loc, "returns value of type %s but requires %s",
             typ2string(e->topt->v), typ2string(t));
        explain_failure();
      }
      TEMP_RGN(te, temp) {
        if (is_noalias_pointer_or_aggr(temp,t) && !is_noalias_path(temp,e))
          terr(e->loc,UNIQUE_ERR_MSG);
      }
    }
    return;

  case &IfThenElse_s(e,s1,s2):
    let TestEnv(eq,isT) = tcTest(te,e,"if statement"); 
    switch (eq) {
    case &$(r1,r2):
      if (isT) {
	tcStmtRefine(te,s1,r1,r2,true);
	tcStmt(te,s2,true);
      }
      else {
	tcStmt(te,s1,true);
	tcStmtRefine(te,s2,r1,r2,true);
      }
      break;
    default:
      tcStmt(te,s1,true);
      tcStmt(te,s2,true);
      break;
    }
    return;

  case &While_s($(e,cont_s),s):
    decorate_stmt(te,cont_s);
    tcTest(te,e,"while loop");
    TEMP_RGN(te, r) {
      tcStmt(set_in_loop(r,te,cont_s),s,true);
    }
    return;

  case &For_s(e1,$(e2,guard_s),$(e3,cont_s),s):
    decorate_stmt(te,guard_s);
    decorate_stmt(te,cont_s);
    tcExp(te,NULL,e1);
    tcTest(te,e2,"for loop");
    TEMP_RGN(te, r) {
      let te = set_in_loop(r,te,cont_s);
      tcStmt(te,s,true);
      tcExp(te,NULL,e3); // ??? what does a break/continue in e3 mean ???
      simplify_unused_result_exp(e3);
    }
    return;

  case &Do_s(s,$(e,cont_s)):
    decorate_stmt(te,cont_s);
    TEMP_RGN(te,r) {
      tcStmt(set_in_loop(r,te,cont_s),s,true);
    }
    tcTest(te,e,"do loop");
    return;

    // In the next 4 cases, the function call assigns through sopt
    // We leave the work to Tcenv b/c it has all the control information
  case &Break_s(*sopt):    process_break(te,s0,sopt);    return;
  case &Continue_s(*sopt): process_continue(te,s0,sopt); return;
  case &Goto_s(l,*sopt):   process_goto(te,s0,l,sopt);   return;

  case &Fallthru_s(es,*clauseopt):
    let trip_opt = process_fallthru(te,s0,clauseopt);
    if(trip_opt == NULL) {
      terr(s0->loc,"fallthru not in a non-last case");
      return;
    }
    let tvs = (*trip_opt)[1];
    let ts_orig = (*trip_opt)[2];
    list_t<$(tvar_t,type_t)@> instantiation = 
      List::map_c(make_inst_var,lookup_type_vars(te),tvs);
    let ts = cmap_c(heap_region,substitute,instantiation,ts_orig);
    for(; ts != NULL && es != NULL; ts = ts->tl, es = es->tl) {
      // don't introduce alias expression here, would be useless
      bool bogus = false;
      tcExp(te,NULL,es->hd);
      if(!coerce_arg(te,es->hd,ts->hd,&bogus)) {
	terr(s0->loc, "fallthru argument has type %s "
             "but pattern variable has type %s",
             typ2string(es->hd->topt->v), typ2string(ts->hd));
        explain_failure();
      }
      TEMP_RGN(te, temp) {
        if (is_noalias_pointer_or_aggr(temp,ts->hd) &&
            !is_noalias_path(temp,es->hd))
          terr(es->hd->loc,UNIQUE_ERR_MSG);
      }
    }
    if (es != NULL)
      terr(s0->loc, "too many arguments to explicit fallthru");
    if (ts != NULL)
      terr(s0->loc, "too few arguments to explicit fallthru");
    return;

  // Note: NewControlFlow requires we add the label with s, not s0 !!
  //       (That way, we can use switch_clause bodies and stmtExp stmt's
  //       as enclosers and get the right behavior!!!)
  case &Label_s(l,s): 
    // Note that we set new_block to false because we're explicitly creating
    // a new named block here.
    TEMP_RGN(te,r) {
      tcStmt(Tcenv::new_named_block(r,s0->loc,add_label(te,l,s),
                                    new Tvar(new ((string_t)aprintf("`%s",*l)),
                                             new_tvar_id(),
                                             kind_to_bound(&rk))),s,false); 
    }
    return;

  case &Switch_s(e,scs0):
    tcExp(te,NULL,e);
    let t = e->topt->v;
    // type-check the cases in reverse order, a fallthru therefore transfers
    // control to the case most recently type-checked. For the last case,
    // fallthru is not allowed.
    TEMP_RGN(te,r) {
      if (is_noalias_pointer_or_aggr(r,t) && !is_noalias_path(r,e))
        terr(e->loc,UNIQUE_ERR_MSG);
      let te = set_in_switch(r,te);
      te = clear_fallthru(r,te);
      for (_ scs = List::rev(scs0); scs != NULL; scs = scs->tl) {
        let p = scs->hd->pattern;
        let pat_res = tcPat(te,p,&t);
        let new_tvs = pat_res.tvars_and_bounds_opt==NULL ? NULL 
          : (*pat_res.tvars_and_bounds_opt)[0];
        if (!unify(p->topt->v,t)) { // allow silent_castable?
          terr(scs->hd->loc, "switch on type %s, but case expects type %s",
               typ2string(t), typ2string(p->topt->v));
          explain_failure();
        }
        else
          check_pat_regions(te,p);
        scs->hd->pat_vars = new Opt(pat_res.patvars);
        // type-checking the body will type-check any explicit fallthrus.
        pattern_synth(scs->hd->loc, te, pat_res, scs->hd->body,
                      scs->hd->where_clause, true);
        if(pat_res.tvars_and_bounds_opt != NULL
           && (*pat_res.tvars_and_bounds_opt)[1] != NULL)
          te = clear_fallthru(r,te);
        else
          te = set_fallthru(r,te, new_tvs, pat_res.patvars, scs->hd);
      }
    }
    check_switch_exhaustive(s0->loc,te,scs0);
    return;

  case &TryCatch_s(s,scs0):
    // This is a KLUDGE so that we have a next statement that is not
    // outside of the handler, eg. for try while(b) break; catch ...
    // We have to do this b/c the translation to C uses the destinations
    // to pop handlers.  We cannot call seq_stmt b/c it optimizes skips away.
    s->r = new_stmt(new Seq_s(new_stmt(s->r,s->loc), skip_stmt(s->loc)),
		    s->loc)->r;

    // must set encloser b/c cannot goto into a handler.
    TEMP_RGN(te,r) {
      tcStmt(set_encloser(r,enter_try(r,te),s0),s,true);
    }

    TEMP_RGN(te,r2) {
      // similar to Switch_s -- check the patterns in reverse order:
      let te = set_in_switch(r2,te);
      te = clear_fallthru(r2,te);
      for (let scs = List::rev(scs0); scs != NULL; scs = scs->tl) {
        let p = scs->hd->pattern;
        let exception_type = exn_typ();
        let pat_res = tcPat(te,p,&exception_type);
        let new_tvs = pat_res.tvars_and_bounds_opt==NULL ? NULL 
          : (*pat_res.tvars_and_bounds_opt)[0];
        if (!unify(p->topt->v,exception_type))
          terr(scs->hd->loc, "expected datatype exn but found %s",
               typ2string(p->topt->v));
        else
          check_pat_regions(te,p);
        scs->hd->pat_vars = new Opt(pat_res.patvars);
        // type-checking the body will type-check any explicit fallthrus
        pattern_synth(scs->hd->loc, te, pat_res, scs->hd->body,
                      scs->hd->where_clause, true);
        if(pat_res.tvars_and_bounds_opt != NULL
           && (*pat_res.tvars_and_bounds_opt)[1] != NULL)
          te = clear_fallthru(r2,te);
        else
          te = set_fallthru(r2, te, new_tvs, pat_res.patvars, scs->hd);
      }
    }
    check_catch_overlap(s0->loc,te,scs0);
    return;

  case &Decl_s(d,s):
    string_t unimp_msg_part;
    TEMP_RGN(te, decl_rgn) {
      tenv_t<_,/*`decl_rgn*/ _> te2;
      if(new_block)
        te2 = Tcenv::new_block(decl_rgn,s0->loc,te);
      else 
        te2 = Tcenv::copy_tenv(decl_rgn,te);
      let te = te2;
      switch (d->r) {
      case &Var_d(vd):
        let &Vardecl(sc,&$(nsl,x),tq,t,initializer,*rgn_ptr,atts,_) = vd;
        let curr_bl = Tcenv::curr_rgn(te);
        bool is_local;
        switch (sc) {
        case Static: 
        case Extern: 
        case ExternC: is_local = false; break;
        case Abstract: 
          terr(d->loc,"bad abstract scope for local variable"); 
          fallthru;
        case Register: 
        case Public: is_local = true; break;
        }
        // side effect
        *rgn_ptr = is_local ? new Opt(curr_bl) : new Opt(&HeapRgn_val); 
        switch (nsl) {
        case {.Loc_n = _}: break;
        case {.Rel_n = NULL}:
          (*vd->name)[0] = Loc_n;
          break;
        case {.C_n = y}: throw impos("tcstmt: C_n declaration");
        case {.Abs_n = y}: throw impos("tcstmt: Abs_n declaration");
        default:
          terr(d->loc, "cannot declare a qualified local variable");
          break;
        }
        // if it's an array or string, fill in the size on the type
        switch (compress(t)) {
        case &ArrayType(ArrayInfo{telt,tq,NULL,zt,ztl}) && vd->initializer != NULL:
          switch (vd->initializer->r) {
            case &Const_e({.String_c = s}):
            t = vd->type = array_typ(telt,tq,uint_exp(numelts(s),NULL),zt,ztl);
            break;
            case &Const_e({.Wstring_c = s}): /* FIX: need correct size, not 1 */
            t = vd->type = array_typ(telt,tq,uint_exp(1,NULL),zt,ztl);
            break;
            case &Comprehension_e(_,e,_,_):
            // FIX: copy e here!  
            t = vd->type = array_typ(telt,tq,e,zt,ztl); 
            break;
            case &UnresolvedMem_e(_,es): fallthru(es);
            case &Array_e(es):
            t = vd->type = array_typ(telt,tq,uint_exp(List::length(es),NULL),
                                     zt,ztl);
            break;
            default: break;
          }
          break;
        default: break;
        }
      
        // type safety demands static variables are closed (like globals)
        // (the error message may be confusing b/c it *looks* like tyvars
        //  are in scope)
        let bound_vars = (!is_local) ? NULL : lookup_type_vars(te);
        let allow_evars = (!is_local) ? false : true;
        check_type(s0->loc,te,bound_vars,&tmk,allow_evars,t);
        vd->tq.real_const = extract_const_from_typedef(s0->loc,
                                                       vd->tq.print_const,t);
        let te2 = add_local_var(decl_rgn,s->loc,te,vd);
        if (sc == Extern || sc == ExternC)
          terr(d->loc,"local extern declarations not yet supported");
        //     if (sc == Static && !supports_default(t) && initializer == NULL)
        //     terr(d->loc,"static local declaration requires an initializer");
        if (initializer != NULL) {
          tcExpInitializer(te2,&t,(exp_t)initializer);
          // te is only used by is_const_exp for globals and function names
          if(!is_local && !is_const_exp(te,(exp_t)initializer))
            terr(d->loc, "initializer needs to be a constant expression");
          if (!coerce_assign(te2,(exp_t)initializer,t)) {
            let varstr = *x;
            let tstr = typ2string(t);
            let estr = typ2string(initializer->topt->v);
            if (numelts(varstr) + numelts(tstr) + numelts(estr) + 50 < 80)
              terr(d->loc, "%s declared with type %s but initialized "
                   "with type %s.",varstr, tstr, estr);                   
            else if (numelts(varstr) + numelts(tstr) + 25 < 80 &&
                     numelts(estr) + 25 < 80)
              terr(d->loc, "%s declared with type %s\n but initialized "
                   "with type %s.",varstr, tstr, estr);
            else 
              terr(d->loc, "%s declared with type \n%s\n but initialized "
                   "with type \n%s.",varstr, tstr, estr);
            unify(t,initializer->topt->v);
            explain_failure();
          }
        }
        tcStmt(set_encloser(decl_rgn,te2,s0),s,false);
        return;

      case &Let_d(p,*vds,e):
        tcExpInitializer(te,NULL,e);
        //FIX: can pass region if e an lvalue
        let pat_res = tcPat(te,p,&e->topt->v);
        *vds = new Opt(pat_res.patvars);
        if (!unify(p->topt->v,e->topt->v)
            && !coerce_assign(te,e,p->topt->v)) {
          terr(d->loc,"pattern type %s does not match definition type %s",
               typ2string(p->topt->v),typ2string(e->topt->v));
          unify(p->topt->v,e->topt->v);
          explain_failure();
        }
        else
          check_pat_regions(te,p);
        check_let_pat_exhaustive(p->loc,te,p);
        pattern_synth(s0->loc, te, pat_res, s, NULL, false);
        return;

      case &Letv_d(vds):
        let curr_bl = Tcenv::curr_rgn(te);
        let te2 = te;
        for (; vds != NULL; vds = vds->tl) {
          let vd = vds->hd;
          let &Vardecl(_,&$(nsl,_),_,t,_,*rgn_ptr,_,_) = vd;
          *rgn_ptr = new Opt(curr_bl); // side effect
          switch (nsl) {
          case {.Loc_n = _}: break;
          case {.Rel_n = NULL}:
            (*vd->name)[0] = Loc_n;
            break;
          case {.Abs_n = y}: throw impos("tcstmt: Abs_n declaration");
          default:
            terr(d->loc, "cannot declare a qualified local variable");
            break;
          }
          check_type(s0->loc,te2,lookup_type_vars(te2),&tmk,true,t);
          te2 = add_local_var(decl_rgn,s->loc,te2,vd);
        }
        tcStmt(set_encloser(decl_rgn,te2,s0),s,false);
        return;

      case &Region_d(tv,vd,resetable,open_opt):
        // Same KLUDGE as with TryCatch_s -- we need a next statement that is
        // not outside of the handler.
        s->r = new_stmt(new Seq_s(new_stmt(s->r,s->loc), skip_stmt(s->loc)),
                        s->loc)->r;
        let te2 = te;
        let &Vardecl(_,_,_,*t,_,*rgn_ptr,_,_) = vd;
        let curr_bl = Tcenv::curr_rgn(te);
        *rgn_ptr = new Opt(curr_bl); // side effect
        type_t rgn_typ;
        if (open_opt != NULL) {
          exp_t open_exp = (exp_t)open_opt;
          let tenv_tvs = lookup_type_vars(te);
          rgn_typ = new_evar(&rko,new Opt(tenv_tvs));
          type_t rgn2_typ = new_evar(&rko,new Opt(tenv_tvs));
          type_t expected = new DynRgnType(rgn_typ,rgn2_typ);
          *t = new RgnHandleType(rgn_typ);
          if (!unify(tcExp(te,&expected,open_exp), expected)) {
            terr(open_exp->loc,"expecting %s but found %s",
                 typ2string(expected),
                 typ2string(open_exp->topt->v));
          }
          // check that we have access to rgn2
          check_rgn_accessible(te,open_exp->loc,rgn2_typ);
          // FIX: should signal an error if rgn1 is accessible...
          te2 = add_region(decl_rgn, te2, rgn_typ, false, true);
        } else {
          rgn_typ = new VarType(tv);
          te2 = add_type_vars(decl_rgn,s0->loc,te2,new List(tv,NULL));
          te2 = add_region(decl_rgn, te2, rgn_typ, resetable, true);
        }
        check_type(s0->loc,te,lookup_type_vars(te2),&bk,true,*t);
        if (!unify(*t,new RgnHandleType(rgn_typ)))
          impos("region stmt: type of region handle is wrong!");
        // we don't push a handler when regions are turned off so we
        // only want to enter_try when regions are on.
        if (!no_regions) {
          te2 = enter_try(decl_rgn,te2);
        }
        tcStmt(set_encloser(decl_rgn,add_local_var(decl_rgn,s->loc,te2,vd),s0),s,false);
        return;

        // alias <tv> vd = e in s1
      case &Alias_d(e,tv,vd):
        TEMP_RGN(te, r) {
          // establish tv as a reasonable region variable
          //       te2 = Tcenv::new_block(r,s0->loc,te2); // ??
          tenv_t te2 = add_type_vars(r,s0->loc,te,rlist(r,tv));
          te2 = add_region(r, te2, new VarType(tv), false, true);
          
          // now check e (could include a cast that uses tv)
          tcExpInitializer(te2,NULL,e);

          // can only alias pointer types
          if (!is_pointer_type(e->topt->v)) {
            terr(e->loc,"%s is not a pointer type",
                 Absynpp::typ2string(e->topt->v));
            return;
          }

          // create the local variable
          vd->type = copy_type(e->topt->v);
          check_type(e->loc,te,lookup_type_vars(te2),&mk,true,vd->type);
          vd->rgn = new Opt(Tcenv::curr_rgn(te2));
          te2 = add_local_var(r,s0->loc, te2, vd);
          te2 = set_encloser(r,te2,s); // for substatements inside of s

          // check the body
	  let tvs = lookup_type_vars(te2);
          tcStmt(te2,s,false);
        }
        NewControlFlow::set_encloser(s0,get_encloser(te));
        return;

      case &Fn_d(fd): 
        // FIX: much of this code is the same as in Tc::tcFndecl
        let curr_bl = Tcenv::curr_rgn(te);
        if (fd->sc != Public)
          terr(d->loc,"bad storage class for inner function");
        // reject explicitly qualified name
        switch ((*fd->name)[0]) {
        case {.Rel_n = NULL}: break;
        case {.Abs_n = y}: impos("tc: Abs_n in tcStmt var decl");
        default: terr(d->loc,"explicit namespace not allowed on inner function declaration");
        }
        (*fd->name)[0] = Loc_n;
        check_fndecl_valid_type(d->loc,te,fd);
        type_t t = fndecl2typ(fd);
        fd->attributes = transfer_fn_type_atts(t,fd->attributes);
        // check packed and aligned don't show up
        for (_ atts = fd->attributes; atts; atts = atts->tl)
          switch (atts->hd) {
          case &Packed_att: case &Aligned_att(_):
            terr(d->loc,"bad attribute %s for function",
                 attribute2string(atts->hd));
            break;
          default: break;
          }
        vardecl_t vd = new Vardecl {fd->sc, fd->name, const_tqual(NULL), 
                                    at_typ(t,curr_bl,empty_tqual(NULL), 
                                           false_conref),
                                    NULL, new Opt(curr_bl), NULL, false};
        fd->fn_vardecl = vd;
        te = add_local_var(decl_rgn,d->loc,te,vd);
        fenv_t old_fenv = (fenv_t)te->le;
        te->le = nested_fenv(d->loc,old_fenv,fd);
        tcStmt(te,fd->body,false);
        check_delayed_effects(te);
        check_delayed_constraints(te);
        if (!all_labels_resolved(te))
          terr(d->loc,"function has goto statements to undefined labels");
        te->le = old_fenv;
        tcStmt(set_encloser(decl_rgn,te,s0),s,false);
        return;
      case &Namespace_d(n,tds): unimp_msg_part = "namespace"; break;
      case &Using_d(q,tds):     unimp_msg_part = "using";     break; //FIX: allow
      case &Aggr_d(_):          unimp_msg_part = "type";      break;
      case &Datatype_d(_):        unimp_msg_part = "datatype"; break;
      case &Enum_d(_):          unimp_msg_part = "enum";   break;
      case &Typedef_d(_):       unimp_msg_part = "typedef";   break;
      case &ExternC_d(_):       unimp_msg_part = "extern \"C\""; break;
      case &ExternCinclude_d(_,_):
        unimp_msg_part = "extern \"C include\""; break;
      case &Porton_d:          unimp_msg_part = "__cyclone_port_on__"; break;
      case &Portoff_d:         unimp_msg_part = "__cyclone_port_off__"; break;
      }
    }
    throw impos("tcStmt: nested %s declarations unimplemented",unimp_msg_part);

  case &ResetRegion_s(e):
    // check that e is an intuitionistic region_t<`r> 
    type_t rgn_type = new_evar(&rko,lookup_opt_type_vars(te));
    type_t etype = new RgnHandleType(rgn_type);
    if (!unify(tcExp(te,&etype,e),etype))
      terr(e->loc, "expecting region_t but found %s", typ2string(e->topt->v));
    // check that `r is resetable
    check_rgn_resetable(te,s0->loc,rgn_type);
    return;

  }
}
