
#include "core.h"
#include "list.h"
#include "set.h"
#include "dict.h"
#include "string.h"
#include "absyn.h"
#include "tcutil.h"

#define CF_FLOWINFO_CYC
#include "cf_flowinfo.h"

using Absyn;
using List;
namespace CfFlowInfo;

// Note that everything is persistent in the functional data structure sense.
// Note we're careful to avoid allocation when replacing something with itself.

////////////////////////// Shared Constants //////////////////////////
static tunion InitState.UnknownIS unknownis_unes_noneil = UnknownIS(Unesc,NoneIL);
static tunion InitState.UnknownIS unknownis_unes_thisil = UnknownIS(Unesc,ThisIL);
static tunion InitState.UnknownIS unknownis_unes_allil = UnknownIS(Unesc,AllIL);
static tunion InitState.UnknownIS unknownis_esc_noneil = UnknownIS(Esc,NoneIL);
static tunion InitState.UnknownIS unknownis_esc_thisil = UnknownIS(Esc,ThisIL);
static tunion InitState.UnknownIS unknownis_esc_allil = UnknownIS(Esc,AllIL);

static tunion PathInfo.LeafPI leaf_unesc_none_v = LeafPI(&unknownis_unes_noneil);
static tunion PathInfo.LeafPI leaf_unesc_this_v = LeafPI(&unknownis_unes_thisil);
static tunion PathInfo.LeafPI leaf_unesc_all_v = LeafPI(&unknownis_unes_allil);
static tunion PathInfo.LeafPI leaf_esc_none_v = LeafPI(&unknownis_esc_noneil);
static tunion PathInfo.LeafPI leaf_esc_this_v = LeafPI(&unknownis_esc_thisil);
static tunion PathInfo.LeafPI leaf_esc_all_v = LeafPI(&unknownis_esc_allil);
path_info_t leaf_unesc_none = &leaf_unesc_none_v;
path_info_t leaf_unesc_this = &leaf_unesc_this_v;
path_info_t leaf_unesc_all  = &leaf_unesc_all_v;
path_info_t leaf_esc_none   = &leaf_esc_none_v;
path_info_t leaf_esc_this   = &leaf_esc_this_v;
path_info_t leaf_esc_all    = &leaf_esc_all_v;

path_info_t mkLeafPI(escaped_t esc, init_level_t il) {
  switch ($(esc,il)) {
  case $(Unesc, NoneIL): return leaf_unesc_none;
  case $(Unesc, ThisIL): return leaf_unesc_this;
  case $(Unesc, AllIL):  return leaf_unesc_all;
  case $(Esc,   NoneIL): return leaf_esc_none;
  case $(Esc,   ThisIL): return leaf_esc_this;
  case $(Esc,   AllIL):  return leaf_esc_all;
  }
}

//////////////////////////// Utilities ///////////////////////////////
int local_root_cmp(local_root_t r1, local_root_t r2) {
  if(r1 == r2)
    return 0;
  switch ($(r1,r2)) {
  case $(&VarRoot(_), &MallocPt(_)): return 1;
  case $(&MallocPt(_),&VarRoot(_)):  return -1;
  case $(&VarRoot(x), &VarRoot(y)):  return Core::ptrcmp(x,y);
  case $(&MallocPt(x),&MallocPt(y)): return Core::ptrcmp(x,y);
  }
}
int field_cmp(field_t f1, field_t f2) {
  if(f1 == f2)
    return 0;
  switch($(f1,f2)) {
  case $(&StructF(_), &TupleF(_)):  return 1;
  case $(&TupleF(_),  &StructF(_)): return -1;
  case $(&StructF(x), &StructF(y)): return Core::ptrcmp(x,y);
  case $(&TupleF(x),  &TupleF(y)):  return x-y;
  }
}
int place_cmp(place_t p1, place_t p2) {
  if(p1 == p2)
    return 0;
  int i = local_root_cmp(p1->root,p2->root);
  if(i != 0)
    return i;
  return list_cmp(field_cmp,p1->fields,p2->fields);
}

// Note: We don't have to worry about instantiating polymorphic struct fields
//       b/c they can't be instantiated with aggregates.
//   (If we ever have memory kinds, then we either need to figure out field's
//    instantiated types or not allow partial initialization of such fields.)
// Note: We could memoize answers here, but it doesn't seem important.
// Note: When tunionfields can be partially initialized, we'll need to support
//       that too.
path_info_t typ_to_unesc_none_pinfo(type_t t) {
  switch(Tcutil::compress(t)) {
  case &TupleType(tqts):
    let d = Dict::empty(Core::intcmp);
    for(int i=0; tqts != null; tqts = tqts->tl, ++i) {
      let &$(_,t2) = tqts->hd;
      d = Dict::insert(d, i, typ_to_unesc_none_pinfo(t2));
    }
    return new TuplePI(d);
  case &StructType(_,_, & &Structdecl(_,_,_,&Core::Opt(fs),_)):
    let d = Dict::empty(String::zstrptrcmp);
    for(; fs != null; fs = fs->tl) {
      let &Structfield{n,_,t2,_,_} = fs->hd;
      // don't insert the field if the name is empty -- it's a bit field
      if (String::strcmp(*n,"") != 0)
        d = Dict::insert(d, n, typ_to_unesc_none_pinfo(t2));
    }
    return new StructPI(d);
  default: 
    return leaf_unesc_none;
  }
}

////////////////////////// Path Info Dict Interpretation //////////////////////

path_info_t lookup_place(pinfo_dict_t<local_root_t> d, place_t place) {
  let &Place(root,fields) = place;
  let ans = Dict::lookup(d,root);
  for(; fields != null; fields = fields->tl)
    switch($(ans,fields->hd)) {
    case $(&TuplePI(d2), &TupleF(i)):  ans = Dict::lookup(d2,i); break;
    case $(&StructPI(d2),&StructF(n)): ans = Dict::lookup(d2,n); break;
    default: throw new Core::Impossible("bad lookup_place");
    }
  return ans;
}
// Note: we don't check for pointer-equal here -- the caller can do that.
// Note: we always do one more Dict::lookup and function call than necessary.
path_info_t insert_place_rec(path_info_t insert_path,
			     list_t<field_t> fields, 
			     path_info_t pinfo){
  if(fields == null)
    return pinfo;
  switch($(insert_path,fields)) {
  case $(&TuplePI(d), &List(&TupleF(i), tl)): 
    let next_path = Dict::lookup(d,i);
    return 
      new TuplePI(Dict::insert(d, i, insert_place_rec(next_path,tl,pinfo)));
  case $(&StructPI(d),&List(&StructF(n),tl)):
    let next_path = Dict::lookup(d,n);
    return 
      new StructPI(Dict::insert(d, n, insert_place_rec(next_path,tl,pinfo)));
  default: 
    throw new Core::Impossible("bad insert_place");
  }
}
pinfo_dict_t<local_root_t> insert_place(pinfo_dict_t<local_root_t> d, 
					place_t place, path_info_t pinfo) {
  let &Place(r,fields) = place;
  return Dict::insert(d, r, insert_place_rec(Dict::lookup(d,r), fields, pinfo));
}

// Note: must detect cycles in the MustPointTo graph or we won't terminate.
bool isAllInit_pinfo($(pinfo_dict_t<local_root_t>,list_t<place_t>)@`r env,
		     path_info_t path);
bool isAllInit_is ($(pinfo_dict_t<local_root_t>,list_t<place_t>)@`r env,
		   init_state_t state) {
  switch(state) {
  case &UnknownIS(_,AllIL): return true;
  case &UnknownIS(_,_):     return false;
  case &MustPointTo(place):
    let &$(d,*seen) = env;
    if (List::mem(place_cmp, *seen, place))
      return true;
    *seen = new{List(place,*seen)};
    return isAllInit_pinfo(env,lookup_place(d,place));
  }
}
bool isAllInit_f($(pinfo_dict_t<local_root_t>,list_t<place_t>)@`r env, `a a,
		 path_info_t path) {
  return isAllInit_pinfo(env,path);
}
bool isAllInit_pinfo($(pinfo_dict_t<local_root_t>,list_t<place_t>)@`r env,
	       path_info_t path) {
  switch(path) {
  case &LeafPI(is):   return isAllInit_is(env,is);
  case &TuplePI(d2):  return Dict::forall_c(isAllInit_f,env,d2);
  case &StructPI(d2): return Dict::forall_c(isAllInit_f,env,d2);
  }
}

bool isAllInit(pinfo_dict_t<local_root_t> pinfo_dict, path_info_t pinfo) {
  let isInitEnv = $(pinfo_dict,null);
  return isAllInit_pinfo(&isInitEnv, pinfo);
}

// Note: The map_c calls do a lot of unnecessary allocation.
path_info_t pinfo_getplaces_esc($(pinfo_dict_t<local_root_t>,
				  Set::set_t<place_t>@`r1) @`r2 env,
				path_info_t pinfo) {
  let &$(rootd,places_ptr) = env;
  switch(pinfo) {
  case &LeafPI(&MustPointTo(place)): 
    *places_ptr = Set::insert(*places_ptr, place); 
    if(isAllInit(rootd,lookup_place(rootd,place)))
      return mkLeafPI(Esc,AllIL);
    return mkLeafPI(Esc,ThisIL);
  case &LeafPI(&UnknownIS(_,il)): 
    return mkLeafPI(Esc,il);
  case &TuplePI(d):  
    return new TuplePI(Dict::map_c(pinfo_getplaces_esc, env, d));
  case &StructPI(d): 
    return new StructPI(Dict::map_c(pinfo_getplaces_esc, env, d));
  }
}
void pinfo_getplaces(Set::set_t<place_t> @`r places_ptr, `a a, 
		     path_info_t pinfo){
  switch(pinfo) {
  case &LeafPI(&UnknownIS(_,_)):     
    return;
  case &LeafPI(&MustPointTo(place)): 
    *places_ptr = Set::insert(*places_ptr, place); 
    return;
  case &TuplePI(d):  
    Dict::iter_c(pinfo_getplaces, places_ptr, d);  
    return;
  case &StructPI(d): 
    Dict::iter_c(pinfo_getplaces, places_ptr, d);  
    return;
  }
}

// note: this terminates because we thread the dictionary.
// note: we need to catch not in the dict b/c of how join_flow uses this code.
pinfo_dict_t<local_root_t> escape_these(Set::set_t<place_t> places, 
					pinfo_dict_t<local_root_t> d) {
  while(!Set::is_empty(places)) {
    let place = Set::choose(places);
    places = Set::delete(places,place);
    path_info_t place_old_pinfo;
    try place_old_pinfo = lookup_place(d,place);
    catch { case &Dict::Absent: continue; }
    let places_env = $(d,&places);
    let place_new_pinfo = pinfo_getplaces_esc(&places_env, place_old_pinfo);
    if(place_old_pinfo != place_new_pinfo) 
      d = insert_place(d, place, place_new_pinfo);
  }
  return d;
}

static Set::set_t<place_t> * empty_place_set_ptr = null; 
// only things pointed to escape
pinfo_dict_t<local_root_t> escape_pointsto(path_info_t pinfo,
					   pinfo_dict_t<local_root_t> d) {
  if(empty_place_set_ptr == null)
    empty_place_set_ptr = new{Set::empty(place_cmp)};

  let places = *empty_place_set_ptr;
  pinfo_getplaces(&places, 0, pinfo);

  return escape_these(places,d);
}

// To do: try to avoid allocation here
path_info_t assign_unknown_dict(init_level_t level, path_info_t pinfo) {
  switch(pinfo) {
  case &LeafPI(&UnknownIS(Esc,_)): return mkLeafPI(Esc,   level);
  case &LeafPI(_):                return mkLeafPI(Unesc, level);
  case &TuplePI(d):  
    return new TuplePI(Dict::map_c(assign_unknown_dict, level, d));
  case &StructPI(d): 
    return new StructPI(Dict::map_c(assign_unknown_dict, level, d));
  }
}
//////////////////////////// Joins  and Lessthan ///////////////////////////////

struct JoinEnv<`r::R> {
  pinfo_dict_t<local_root_t> d1;
  pinfo_dict_t<local_root_t> d2;
  Set::set_t<place_t>@`r places;
};
typedef struct JoinEnv<`r1> @`r2 join_env_t<`r1,`r2>;

// WARNING: If this changes, make sure initstate_lessthan_approx still works.
escaped_t join_escape(escaped_t esc1, escaped_t esc2) {
  switch ($(esc1,esc2)) {
  case $(Esc,_): fallthru;
  case $(_,Esc): return Esc;
  default:       return Unesc;
  }
}
// WARNING: If this changes, make sure initstate_lessthan_approx still works.
init_level_t join_initlevel(init_level_t il1, init_level_t il2) {
  switch ($(il1,il2)) {
  case $(NoneIL,_): fallthru;
  case $(_,NoneIL): return NoneIL;
  case $(ThisIL,_): fallthru;
  case $(_,ThisIL): return ThisIL;
  default:          return AllIL;
  }
}

// note: There is another reasonable policy for losing an alias to AllInit:
//   still make the result ThisInit and **don't** lose the aliases downstream.
//   I imagine the default should be AllInit and los downstream with a pragma
//   in the source to get the other behavior (if anyone actually cares).
//   Note that the two policies are incomparable.
path_info_t join_initstate(join_env_t<`r1,`r2> env,
			   init_state_t state1, 
			   init_state_t state2) {
  switch($(state1,state2)) {
  case $(&UnknownIS(esc1,il1),&UnknownIS(esc2,il2)): 
    return mkLeafPI(join_escape(esc1,esc2), join_initlevel(il1,il2));

  case $(&UnknownIS(esc1,il1),&MustPointTo(place2)):
    // note: esc1 is irrelevant in the sense that place2 and downstream
    //       escapes b/c we no longer know all the pointers to it.
    let isInitEnv = $(env->d2,null);
    if(il1==(init_level_t)AllIL && isAllInit_pinfo(&isInitEnv,lookup_place(env->d2,place2))) {
      *(env->places) = Set::insert(*(env->places), place2);
      return mkLeafPI(esc1,il1);
    }
    return mkLeafPI(esc1, join_initlevel(il1, ThisIL));

  case $(&MustPointTo(place1),&UnknownIS(esc2,il2)):
    // note: esc2 is irrelevant in the sense that place2 and downstream
    //       escapes b/c we no longer know all the pointers to it.
    let isInitEnv = $(env->d1,null);
    if(il2==(init_level_t)AllIL && isAllInit_pinfo(&isInitEnv,lookup_place(env->d1,place1))) {
      *(env->places) = Set::insert(*(env->places), place1);
      return mkLeafPI(esc2,il2);
    }
    return mkLeafPI(esc2, join_initlevel(ThisIL, il2));

  case $(&MustPointTo(place1),&MustPointTo(place2)):
    if(place_cmp(place1,place2) == 0) return new LeafPI(state1);
    let isInitEnv1 = $(env->d1,null);
    let isInitEnv2 = $(env->d2,null);
    if(isAllInit_pinfo(&isInitEnv1, lookup_place(env->d1,place1))
       && isAllInit_pinfo(&isInitEnv2, lookup_place(env->d2,place2))) {
      *(env->places) = Set::insert(*(env->places), place1);
      *(env->places) = Set::insert(*(env->places), place2);
      return mkLeafPI(Unesc,AllIL);
    }
    return mkLeafPI(Unesc,ThisIL);
  }
}

// we could try to do more to avoid allocation, but we do is easy
// and gets most of the possible sharing, I think.
path_info_t join_pathinfo(join_env_t<`r1,`r2> env,
			  path_info_t pinfo1, path_info_t pinfo2) {
  if(pinfo1 == pinfo2) return pinfo1;
  switch($(pinfo1,pinfo2)) {
  case $(&LeafPI(is1),&LeafPI(is2)):
    if(is1 == is2) return pinfo1;
    return join_initstate(env,is1,is2);
  case $(&TuplePI(d1),&TuplePI(d2)):
    if (d1 == d2) return pinfo1;
    return new TuplePI(Dict::intersect_c(join_pathinfo,env,d1,d2));
  case $(&StructPI(d1),&StructPI(d2)):
    if (d1 == d2) return pinfo1;
    return new StructPI(Dict::intersect_c(join_pathinfo,env,d1,d2));
  default: throw new Core::Impossible("join_pathinfo");
  }
}
flow_info_t join_flow(flow_info_t f1, flow_info_t f2) { 
  if(empty_place_set_ptr == null)
    empty_place_set_ptr = new{Set::empty(place_cmp)};

  if(f1 == f2) return f1;
  switch($(f1,f2)) {
  case $(BottomFL,_): return f2;
  case $(_,BottomFL): return f1;
  case $(&InitsFL(d1),&InitsFL(d2)):
    if(d1 == d2) return f1;
    let places  = *empty_place_set_ptr;
    let joinenv = JoinEnv(d1,d2,&places);
    let outdict = Dict::intersect_c(join_pathinfo,&joinenv,d1,d2);
    return new InitsFL(escape_these(places,outdict));
  }
}

// WARNING: This is where we cheat ("approx") for performance (see below).
bool initstate_lessthan_approx(init_state_t state1, init_state_t state2) {
  switch ($(state1,state2)) {
  case $(&UnknownIS(esc1,il1),&UnknownIS(esc2,il2)): 
    return (join_escape(esc1,esc2)==esc2) && (join_initlevel(il1,il2)==il2);
  case $(&MustPointTo(place1),&MustPointTo(place2)):
    return place_cmp(place1,place2) == 0; // APPROXIMATE
  default: 
    return false; // APPROXIMATE
  }
}
bool pinfo_lessthan_approx(`a ignore, path_info_t pinfo1, path_info_t pinfo2) {
  if(pinfo1 == pinfo2) return true;
  switch ($(pinfo1,pinfo2)) {
  case $(&LeafPI(s1),&LeafPI(s2)):
    return (s1 == s2) || initstate_lessthan_approx(s1,s2);
  case $(&TuplePI(d1),&TuplePI(d2)):
    return (d1 == d2) || Dict::forall_intersect(pinfo_lessthan_approx,d1,d2);
  case $(&StructPI(d1),&StructPI(d2)):
    return (d1 == d2) || Dict::forall_intersect(pinfo_lessthan_approx,d1,d2);
  default: throw new Core::Impossible("pinfo_lessthan");
  }
}

// WARNING: We assume anything not in the intersection is IRRELEVANT.
// WARNING: We might return false even when f1 < f2, but that's okay b/c
//  that will just cause clients to take joins and we always return true
//  when the two flows are equal.  That's what the approx means.
// (As a result of the approx, we don't have to allocate here.)
bool flow_lessthan_approx(flow_info_t f1, flow_info_t f2) {
  if(f1 == f2) return true;
  switch($(f1,f2)) {
  case $(BottomFL,_): return true;
  case $(_,BottomFL): return false;
  case $(&InitsFL(d1),&InitsFL(d2)):
    if(d1 == d2) return true;
    return Dict::forall_intersect(pinfo_lessthan_approx, d1, d2);
  }
}
