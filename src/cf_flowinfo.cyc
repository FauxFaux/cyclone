/* Utilities for control flow analysis.
   Copyright (C) 2001 Dan Grossman, Greg Morrisett
   This file is part of the Cyclone compiler.

   The Cyclone compiler is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   The Cyclone compiler is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with the Cyclone compiler; see the file COPYING. If not,
   write to the Free Software Foundation, Inc., 59 Temple Place -
   Suite 330, Boston, MA 02111-1307, USA. */
#include <core.h>
#include <list.h>
#include <set.h>
#include <dict.h>
#include <string.h>
#include "absyn.h"
#include "tcutil.h"
#include "absynpp.h"
#include "evexp.h"

#define CF_FLOWINFO_CYC
#include "cf_flowinfo.h"
using Absyn;
using List;
using Absynpp;
namespace CfFlowInfo;

#ifdef COARSE_REGIONS
#define ANAL_RGN(ae,x) let x = (ae)->r;
#else
#define ANAL_RGN(ae,x) region x;
#endif

datacon(Absyn::AbsynAnnot,IsZero);
datacon(KillRgn,UniqueRgn_k);

absLval_t<`r> PlaceL(place_t<`r,`r> x) {
  return AbsLVal{.PlaceL = x};
}
absLval_t<`r> UnknownL() {
  return AbsLVal{.UnknownL = 0};
}
flow_t<`r> BottomFL() { return FlowInfo{.BottomFL = 0}; }
flow_t<`r> ReachableFL(flowdict_t<`r> fd,relns_t<`r> r) {
  return FlowInfo{.ReachableFL = $(fd,r) };
}

////////////////////////// Shared Constants //////////////////////////
int place_cmp(place_t p1, place_t p2);
int root_cmp(root_t r1, root_t r2);
flow_env_t<`r> new_flow_env(region_t<`r> r) {
  static datatype Raw_exp.Const_e dummy_rawexp = Const_e(Cnst{.Null_c = 0});
  static struct Exp dummy_exp = Exp(NULL,&dummy_rawexp,NULL,&EmptyAnnot_val);
  return rnew(r) 
    FlowEnv { .r = r,
              .zero = rnew(r) Zero,
              .notzeroall = rnew (r) NotZeroAll,
              .notzerothis = rnew (r) NotZeroThis,
              .unknown_none = rnew(r) UnknownR(NoneIL),
              .unknown_this = rnew(r) UnknownR(ThisIL),
              .unknown_all  = rnew(r) UnknownR(AllIL),
              .esc_none = rnew(r) Esc(NoneIL),
              .esc_this = rnew(r) Esc(ThisIL),
              .esc_all = rnew(r) Esc(AllIL),
              .mt_flowdict = Dict::rempty(r,root_cmp),
              .mt_place_set = Dict::rempty(r,place_cmp),
              .dummy_place = rnew(r) Place(rnew(r) MallocPt(&dummy_exp,&VoidType_val),NULL)
            };
}

// updates the given set if not NULL.  Returns true if the place
// is already in the set.
bool update_place_set(dict_set_t<`a,`r> *set, `a place, Position::seg_t loc) {
  if (set != NULL) {
    // see if there's already an entry here
    if (Dict::member(*set,place))
      return true;
    else
      *set = Dict::insert(*set, place, loc);
  }
  return false;
}

// creates a string to identify the given place in error messages
string_t place_err_string(place_t place) {
  let Place{root,fields} = *place;
  switch (root) {
  case &VarRoot(vd): 
    if (fields == NULL)
      return Absynpp::qvar2string(vd->name);
    else
      return aprintf("reachable from %s", Absynpp::qvar2string(vd->name));
  default: Tcutil::impos("error locations not for VarRoots");
  }  
}

// checks for conflicts when merging consumed sets
static Position::seg_t combine_consume_f(`b env,
					 `a place,
					 Position::seg_t loc1,
					 Position::seg_t loc2) {
  return loc1;
}

// updates the given set if not NULL.  Returns true if the place
// is already in the set.
place_set_t<`r> union_place_set(place_set_t<`r> s1, place_set_t<`r> s2, 
                                bool disjoint) {
//    DEBUG_PRINT("**union_place_set:\n");
//    DEBUG_PRINT("  s1= ");
//    print_place_set(s1);
//    DEBUG_PRINT("\n  s2= ");
//    print_place_set(s2);
  let env = 0;
  let res = Dict::union_two_c(combine_consume_f,&env,s1,s2);
//    DEBUG_PRINT("\n  res= ");
//    print_place_set(res);
//    DEBUG_PRINT("\n");
  return res;
}

bool place_set_subset(dict_set_t<`a,`r> s1, dict_set_t<`a,`r> s2) {
  if ((int)s1.t == (int)s2.t) return true;
  try {
    region temp; { 
      Iter::iter_t<_,`temp> iter = Dict::make_iter(temp,s1);
      let elem = *Dict::rchoose(temp,s1);
      while(Iter::next(iter,&elem)) {
	let place = elem[0];
	if (!Dict::member(s2,place)) {
// 	  DEBUG_PRINT("could not find ");
// 	  DEBUG_PRINT_F(print_place,place);
// 	  DEBUG_PRINT("  in s2\n");
	  return false;
	}
      }
      return true;
    }
  } catch {
  case Absent: // only if rchoose fails, which means s1 is empty
    return true;
  }
}

bool place_set_equals(dict_set_t<`a,`r> s1, dict_set_t<`a,`r> s2) {
  return place_set_subset(s1,s2) && place_set_subset(s2,s1);
}

//////////////////////////// Utilities ///////////////////////////////

int get_field_index_fs(list_t<aggrfield_t> fs, field_name_t f) {
  int n = 0;
  for (; fs; fs = fs->tl) {
    let f2 = fs->hd->name;
    if (strptrcmp(f2,f) == 0) return n;
    n = n+1;
  }
  throw new Core::Impossible(aprintf("get_field_index_fs failed: %s",*f));
}

int get_field_index(type_t t, field_name_t f) {
  switch (Tcutil::compress(t)) {
  case &AggrType(AggrInfo(info,_)):
    let fs = get_known_aggrdecl(info)->impl->fields;
    fallthru(fs);
  case &AnonAggrType(_,fs):
    return get_field_index_fs(fs, f);
  default: 
    throw new Core::Impossible(aprintf("get_field_index failed: %s",
                                       Absynpp::typ2string(t)));
  }
}

int root_cmp(root_t r1, root_t r2) {
  if(((int)r1) == ((int)r2))
    return 0;
  switch ($(r1,r2)) {
  case $(&VarRoot(vd1),&VarRoot(vd2)): return vd1 - vd2;
  case $(&VarRoot(_),_): return -1;
  case $(_,&VarRoot(_)): return 1;
  case $(&MallocPt(e1,_),&MallocPt(e2,_)): return e1 - e2;
  case $(&MallocPt(_,_),_): return -1;
  case $(_,&MallocPt(_,_)): return 1;
  case $(&InitParam(i1,_), &InitParam(i2,_)): return i1-i2;
  }
}

static int intlist_cmp(List::list_t<int> list1,
		       List::list_t<int> list2) {
  return list_cmp(Core::intcmp,list1,list2);
}

int place_cmp(place_t p1, place_t p2) {
  if(((int)p1) == ((int)p2))
    return 0;
  let Place{root1,fields1} = *p1;
  let Place{root2,fields2} = *p2;
  int i = root_cmp(root1,root2);
  if(i != 0)
    return i;
  return intlist_cmp(fields1,fields2);
}

// for debugging
static mstringptr_t place2string(place_t p) {
  list_t<mstringptr_t> sl = NULL;
  let Place{root,fields} = *p;
  switch(root) {
  case &VarRoot(vd): sl = new List(new aprintf("%s",*(*vd->name)[1]),sl); break;
  case &MallocPt(e,_):  sl = new List(new aprintf("mpt%d",(int)e),sl); break;
  case &InitParam(i,_): sl = new List(new aprintf("param%d",i),sl); break;
  }
  for(; fields != NULL; fields = fields->tl)
    sl = new List(new aprintf("%d", fields->hd), sl);
  let ans = new aprintf("%s","");
  for(; sl != NULL; sl = sl->tl)
    *ans = aprintf("%s.%s", *sl->hd, *ans);
  return ans;
}

// Note: We don't have to worry about instantiating polymorphic struct fields
//       b/c they can't be instantiated with aggregates.
// BUT that means fields instantiated with int still must be initialized.
// Sorry, but it's a pain.
// Also, not sure why enums aren't bits_only.
//   (If we ever have memory kinds, then we either need to figure out field's
//    instantiated types or not allow partial initialization of such fields.)
// Note: We could memoize answers here.

// forward declaration
static absRval_t<`r> i_typ_to_absrval(flow_env_t<`r> fenv,
                                      bool allow_zeroterm,
				      bool no_init_bits_only,
                                      type_t t, absRval_t<`r> leafval);

aggrdict_t<`r> aggrfields_to_aggrdict(flow_env_t<`r> fenv,
                                      list_t<struct Aggrfield@> fs, 
				      bool no_init_bits_only,
                                      absRval_t<`r> leafval) {
  // we treat bitfields as if always initialized -- those are fields with
  // names that are of size 1 ("\0").
  unsigned sz = List::length(fs);
  aggrdict_t<`r> d = rnew(fenv->r) { for i < sz: fenv->unknown_all };
  for(int i = 0; i < sz; i++, fs = fs->tl) {
    let &Aggrfield(n,_,t2,_,_) = fs->hd;
    if(numelts(*n) != 1) 
      d[i] = i_typ_to_absrval(fenv, false, no_init_bits_only, t2,leafval);
  }
  return d;
}

// do a substitution on an aggregate field
static struct Aggrfield@`t 
  substitute_field($(region_t<`t>,
                     list_t<$(tvar_t,type_t)@`t,`t>)@ env,
                   struct Aggrfield@ f) {
  let &$(t,inst) = env;
  let new_typ = Tcutil::rsubstitute(t,inst,f->type);
  return rnew(t) Aggrfield{f->name,f->tq,new_typ,f->width,f->attributes};
}

// this is the same as aggrfields_to_aggrdict, except that it
// performs a type substitution.
static aggrdict_t<`r> substitute_aggrfields_to_aggrdict(flow_env_t<`r> fenv,
                                                        list_t<tvar_t> tvs,
                                                        list_t<type_t> targs,
                                                        list_t<aggrfield_t> fs,
							bool no_init_bits_only,
                                                        absRval_t<`r> leafval){
  region temp;
  list_t<$(tvar_t,type_t)@`temp,`temp> inst = List::rzip(temp,temp,tvs,targs);
  let env = $(temp,inst);
  list_t<struct Aggrfield@`temp,`temp> subs_fs = rmap_c(temp,substitute_field,&env,fs);
  return aggrfields_to_aggrdict(fenv,subs_fs,no_init_bits_only,leafval);
}

static absRval_t<`r> i_typ_to_absrval(flow_env_t<`r> fenv,
                                      bool allow_zeroterm,
				      bool no_init_bits_only,
                                      type_t t, absRval_t<`r> leafval) {
  if(is_nontagged_union_type(t))
    return fenv->unknown_all;

  switch(Tcutil::compress(t)) {
  case &DatatypeFieldType(DatatypeFieldInfo({.KnownDatatypefield=$(_,tuf)},_)):
    if(tuf->typs == NULL)
      return leafval;
    fallthru(tuf->typs);
  case &TupleType(tqts):
    unsigned sz = List::length(tqts);
    // we use *bogus* for all of the field names since they're looked up
    // by index, not name.  Avoids creating the field names...
    aggrdict_t d = rnew(fenv->r) { for i < sz : fenv->unknown_all };
    for (int i = 0; i < sz; i++) { 
      d[i] = i_typ_to_absrval(fenv,false,no_init_bits_only,(*tqts->hd)[1],leafval);
      tqts = tqts->tl;
    }
    return rnew(fenv->r) Aggregate(UnionRInfo(false,-1),d);
  case &AggrType(AggrInfo(info,targs)):
    let ad = get_known_aggrdecl(info);
    if(ad->impl==NULL)
      break;
    let fields = ad->impl->fields;
    if (targs == NULL) fallthru(ad->kind,fields);
    return rnew(fenv->r) 
      Aggregate(UnionRInfo(ad->kind==UnionA,-1),substitute_aggrfields_to_aggrdict(fenv,ad->tvs,targs,fields,ad->kind==UnionA,leafval));
  case &AnonAggrType(k,fs):
    DEBUG_PRINT("typ_to_absrval: type=%s, leaf_val=",
		Absynpp::typ2string(t));
    DEBUG_PRINT_F(print_absrval,leafval);
    return rnew(fenv->r) Aggregate(UnionRInfo(k==UnionA,-1),aggrfields_to_aggrdict(fenv,fs,k==UnionA,leafval));
  case &ArrayType(ArrayInfo{et,_,_,zeroterm,_}) && conref_def(false,zeroterm):
    // special case for zero-terminated arrays of bits-only things -- 
    // here, we initialize them at translation by putting a 0 in at the end.
    return (allow_zeroterm && !no_init_bits_only && Tcutil::bits_only(et)) ? fenv->unknown_all : leafval;
  case &TagType(t): return leafval;
  case &PointerType(PtrInfo{_,_,PtrAtts{_,nbl,_,_,_}}) && !conref_def(false,nbl):
    switch(leafval) {
    case &UnknownR(ThisIL): return fenv->notzerothis;
    case &UnknownR(AllIL): return fenv->notzeroall;
    default: break;
    }
    break;
  default: break;
  }
  
  return (!no_init_bits_only && Tcutil::bits_only(t)) ? fenv->unknown_all : leafval;
}

absRval_t<`r> typ_to_absrval(flow_env_t<`r> fenv, type_t t, bool no_init_bits_only, absRval_t<`r> leafval) {
  return i_typ_to_absrval(fenv, true, no_init_bits_only, t, leafval);
}

bool is_unique_consumed(exp_t e, int env_iteration, absRval_t<`r> r, bool @needs_unconsume) {
  switch (r) {
  case &Consumed(consumer,iteration,r):
    if (consumer==e && iteration==env_iteration) {
      *needs_unconsume = true;
      return false;
    }
    return true;
  case &Aggregate(_,d):
    let sz = numelts(d);
    for (int i=0; i<sz; i++) {
      if (is_unique_consumed(e,env_iteration,d[i],needs_unconsume))
	return true;
    }
    return false;
  default: return false;
  }
}  

absRval_t<`r> make_unique_unconsumed(flow_env_t<`r> fenv, absRval_t<`r> r) {
  switch (r) {
  case &Consumed(consumer,iteration,r):
    return r;
  case &Aggregate(uinfo,d):
    let sz = numelts(d);
    bool change = false;
    aggrdict_t d2 = rnew(fenv->r) { for i < sz : d[i] };
    for (int i=0; i<sz; i++) {
      d2[i] = make_unique_unconsumed(fenv,d[i]);
      if (d2[i] != d[i])
	change = true;
    }
    if (change)
      return rnew(fenv->r) Aggregate(uinfo,d2);
    else return r;
  default: return r;
  }  
}

absRval_t<`r> make_unique_consumed(flow_env_t<`r> fenv, type_t t, exp_t consumer, int iteration, absRval_t<`r> r) {
  if (Tcutil::is_noalias_pointer(t)) 
    return rnew(fenv->r) Consumed(consumer,iteration,r);
  switch $(Tcutil::compress(t),r) {
  case $(&TupleType(tqts),&Aggregate(b,d)):
    let sz = numelts(d);
    aggrdict_t d2 = rnew(fenv->r) { for i < sz : fenv->unknown_all };
    for (int i = 0; i < sz; i++) {
      d2[i] = make_unique_consumed(fenv,(*tqts->hd)[1],consumer,iteration,d[i]);
      tqts = tqts->tl;
    }
    return rnew(fenv->r) Aggregate(b,d2);
  case $(&AggrType(AggrInfo(info,_)),&Aggregate(b,d)):
    let ad = get_known_aggrdecl(info);
    if (ad->impl == NULL) return r;
    fallthru(ad->kind,ad->impl->fields,b,d);
  case $(&AnonAggrType(k,fs),&Aggregate(b,d)):
    aggrdict_t d2 = rnew(fenv->r) { for i < numelts(d) : d[i] };
    unsigned sz = List::length(fs);
    for (int i = 0; i < sz; i++, fs = fs->tl) {
      let &Aggrfield(n,_,t2,_,_) = fs->hd;
      if (numelts(*n) != 1)
        d2[i] = make_unique_consumed(fenv,t2,consumer,iteration,d[i]);
    }
    return rnew(fenv->r) Aggregate(b,d2);
  default: return r;
  }
}

static bool 
prefix_of_member(place_t<`r2,`r3> place,
                 Dict::dict_t<place_t<`r2,`r3>,Position::seg_t,`r4> set) {
  region r; {
    let elem = $(place,NULL);
    Iter::iter_t<_,`r> iter = Dict::make_iter(r,set);
    while(Iter::next(iter,&elem)) {
      let place2 = elem[0];
      let Place{root1,fs1} = *place;
      let Place{root2,fs2} = *place2;
      if(root_cmp(root1, root2) != 0)
        continue;
      for(; fs1 != NULL && fs2 != NULL; fs1 = fs1->tl, fs2 = fs2->tl)
        if (fs1->hd != fs2->hd) break;
      if(fs1 == NULL)
        return true;
    }
    return false;
  }
}

//////////////////////// Managing Escapes ///////////////////////////

// Note: This would be a great place to delay an idempotent genregion
//       because we often won't have any places! (Also would want to pick
//       a very small initial region size.)
static struct EscPile<`rplace::R,`rplaceptr::R,`rpile::R> {
  region_t<`rpile>       rgn;
  list_t<place_t<`rplace,`rplaceptr>,`rpile> places;
};
typedef struct EscPile<`r3,`r4,`r1> @`r2 escpile_t<`r3,`r4,`r1,`r2>;

static void add_place(escpile_t<`r,`r2,`rpile> pile, place_t<`r,`r2> place) {
  // we expect lots of inserts and short lists, so we don't bother to sort
  // we check for repeats to avoid a very unlikely exponential blowup
  if(!List::mem(place_cmp, pile->places, place))
    pile->places = rnew(pile->rgn) List(place, pile->places);
}
static void add_places(escpile_t<`r,`r> pile, absRval_t<`r> r) {
  switch(r) {
  case &Consumed(_,_,r): add_places(pile,r); return;
  case &AddressOf(p): add_place(pile, p); return;
  case &Aggregate(b,d): 
    for (int i = 0; i < numelts(d); i++) 
      add_places(pile, d[i]);
    return;
  default: return;
  }
}

// return the result of recursively updating (functionally) the leaves
// of [old_val] to be [new_val].
// WARNING: do not use this to clobber with an Esc unless that's the point!
static absRval_t<`r> insert_place_inner(region_t<`r> r, absRval_t<`r> new_val,
                                        absRval_t<`r> old_val) {
  switch(old_val) {
  case &Aggregate(UnionRInfo(is_union,_),d): 
    aggrdict_t d2 = rnew(r) { for i < numelts(d) : 
                              insert_place_inner(r,new_val,d[i]) };
    // we eliminate the distinction as to which field was last
    // written since we're changing the values of things
    return rnew(r) Aggregate(UnionRInfo(is_union,-1),d2);
  default: return new_val;
  }
}

// functionally update the entry in dictionary [d] at index [n] with
// [rval]; return the same dictionary if [rval] is the same as the old value.
static aggrdict_t<`r> aggr_dict_insert(region_t<`r> r, aggrdict_t<`r> d, 
                                       int n, absRval_t<`r> rval) {
  let old_rval = d[n];
  if (old_rval == rval) return d;
  aggrdict_t res = rnew(r) {for i < numelts(d) : d[i]};
  res[n] = rval;
  return res;
}

// performs functional update of [old_val] with [new_val].  When
// processing an aggregate, it will recursively iterate over the
// fields [fs], functionally updating entries in the aggregate
// dictionary [d] as it unwinds, avoiding changes if pointer equality
// is maintained.  
static absRval_t<`r> insert_place_outer(region_t<`r> r,
                                        list_t<int> fs,
                                        absRval_t<`r> old_val, 
                                        absRval_t<`r> new_val) {
  if(fs==NULL) 
    return insert_place_inner(r,new_val,old_val);
  switch($(fs,old_val)) {
  case $(&List(hd,tl),&Aggregate(UnionRInfo(is_union,_),d)):
    let new_child = insert_place_outer(r,tl,d[hd],new_val);
    let new_d = aggr_dict_insert(r, d, hd,new_child);
    if (new_d == d) return old_val;
    else return rnew(r) Aggregate(UnionRInfo(is_union,-1),new_d);
  default: throw new Core::Impossible("bad insert place");
  }
}
// Note: this terminates because we thread the dictionary.
// Note: we need to catch not in the dict b/c of how join_flow uses this code?
// Note: we should only be escaping leaves now -- never Aggregate!
// Note: There's a quadratic behavior here that won't be a problem in practice.
static flowdict_t<`r> escape_these(flow_env_t<`r> fenv,
                                   escpile_t<`r,`r> pile, 
                                   place_set_t<`r> * all_changed,
                                   flowdict_t<`r> d) {
  while(pile->places != NULL) {
    let place = pile->places->hd;
    pile->places = pile->places->tl;
    update_place_set(all_changed,place,NULL);
    absRval_t oldval, newval;
    try oldval = lookup_place(d,place); 
    catch { case &Dict::Absent: continue; }
    switch(initlevel(fenv,d,oldval)) {
    case AllIL:  newval = fenv->esc_all;  break;
    case ThisIL: newval = fenv->esc_this; break;
    case NoneIL: newval = fenv->esc_none; break;
    }
    add_places(pile, oldval);
    let Place{root,fields} = *place;
    d = Dict::insert(d,root,
		     insert_place_outer(fenv->r,
                                        fields,
					Dict::lookup(d,root),
					newval));
  }
  return d;
}

////////////////////////// Flow Gets and (functional) Sets ///////////////////

// We must detect cycles in the MustPointTo graph or we won't terminate.
// We heap-allocate the seen list b/c we expect it to be very very short.
static struct InitlevelEnv<`r::R,`e::R> {
  region_t<`e> e;
  flowdict_t<`r> d;
  list_t<place_t<`r,`r>,`e> seen;
};
static initlevel_t initlevel_approx(absRval_t r) {
  switch(r) {
  case &UnknownR(il): return il;
  case &Esc(il):      return il;
  case &Zero:
  case &NotZeroAll:    return AllIL;
  case &NotZeroThis:   return ThisIL;
  case &Consumed(_,_,r): return NoneIL;
  default: throw new Core::Impossible("initlevel_approx");
  }
}
static initlevel_t initlevel_rec(struct InitlevelEnv<`r,`e> @ env, 
				 absRval_t<`r> r, initlevel_t acc) {
  initlevel_t this_ans;
  if(acc == NoneIL) return NoneIL;
  switch(r) {
  case &Aggregate(UnionRInfo{.is_union = true, .fieldnum = f }, d): // union case
    // if one of the members is AllIL then we're okay; if we know the
    // field, then it better be the known field that's initialized
    let sz = numelts(d);
    this_ans = NoneIL;
    if (f == -1) {
      for (int i = 0; i < sz; i++) {
	if (initlevel_rec(env,d[i],AllIL) == AllIL) {
	  this_ans = AllIL;
	  break;
	}
      }
    }
    else if (initlevel_rec(env,d[f],AllIL) == AllIL)
      this_ans = AllIL;
    break;
  case &Aggregate(UnionRInfo{.is_union = false, ...},d): // struct case -- they all have to be init'd
    let sz = numelts(d);
    this_ans = AllIL;
    for (int i = 0; i < sz; i++) 
      this_ans = initlevel_rec(env,d[i],this_ans);
    break;
  case &AddressOf(p): 
    if(List::mem(place_cmp, env->seen, p))
      this_ans = AllIL;
    else {
      env->seen = rnew(env->e) List(p, env->seen);
      this_ans  = initlevel_rec(env,lookup_place(env->d,p),AllIL);
      env->seen = env->seen->tl;
      if(this_ans == NoneIL)
	this_ans = ThisIL;
    }
    break;
  default: this_ans = initlevel_approx(r);
  }
  if(this_ans == NoneIL) return NoneIL;
  if(this_ans == ThisIL || acc == ThisIL) return ThisIL;
  return AllIL;
}
initlevel_t initlevel(flow_env_t env, flowdict_t<`r> d, absRval_t<`r> r) {
  ANAL_RGN(env,env_rgn) {
    let env = InitlevelEnv(env_rgn,d,NULL);
    return initlevel_rec(&env,r,AllIL);
  }
}

absRval_t<`r> lookup_place(flowdict_t<`r> d, place_t<`r,`r> place) {
  let Place{root,fields} = *place;
  let ans = Dict::lookup(d,root);
  for(; fields != NULL; fields = fields->tl)
    switch($(ans,fields->hd)) {
    case $(&Aggregate(is_union,d2), fname): 
      ans = d2[fname];
      break;
    default: 
      DEBUG_PRINT("found bad lookup place ");
      DEBUG_PRINT_F(print_absrval,ans);
      DEBUG_PRINT("\n");
      throw new Core::Impossible("bad lookup_place");
    }
  return ans;
}

static bool is_rval_unescaped(absRval_t rval) {
  switch(rval) {
  case &Esc(_):       return false;
  case &Consumed(_,_,r): return is_rval_unescaped(rval);
  case &Aggregate(UnionRInfo(is_union,field_no),d): 
    if (is_union && field_no != -1)
      return !is_rval_unescaped(d[field_no]);
    else {
      unsigned sz = numelts(d);
      for (int i = 0; i < sz; i++) 
	if (!is_rval_unescaped(d[i])) return false;
      return true;
    }
  default:            return true;
  }
}
bool is_unescaped(flowdict_t<`r> d, place_t<`r,`r> place) {
  return is_rval_unescaped(lookup_place(d,place));
}

// only things pointed to escape
flowdict_t<`r> escape_deref(flow_env_t<`r> fenv, flowdict_t<`r> d, place_set_t<`r> * all_changed, absRval_t<`r> r) {
  ANAL_RGN(fenv, rgn) {
    escpile_t pile = rnew(rgn) EscPile(rgn,NULL);
    add_places(pile, r);
    return escape_these(fenv, pile, all_changed, d);
  }
}

static struct AssignEnv<`r::R,`r2::R> {
  flow_env_t<`r2>   fenv;
  escpile_t<`r2,`r2,`r,`r> pile;
  flowdict_t<`r2>   d;
  Position::seg_t  loc;
};
static absRval_t<`r2> assign_place_inner(struct AssignEnv<`r,`r2> @ env, 
                                         absRval_t<`r2> oldval, 
                                         absRval_t<`r2> newval) {
  // assignments to escaped places must be fully-init because other aliases
  // might assume fully-init.  Always causes place to be added for same reason.
  switch($(oldval,newval)) {
  case $(&Esc(_), &AddressOf(p)): add_place(env->pile,p); fallthru;
  case $(&Esc(_), _):
    if(initlevel(env->fenv,env->d,newval) != AllIL)
      Tcutil::terr(env->loc, "assignment puts possibly-uninitialized data in "
		   "an escaped location");
    return env->fenv->esc_all;
  case $(&Aggregate(is_union1,d1), &Aggregate(is_union2,d2)):
    aggrdict_t new_d = 
      rnew(env->fenv->r) {for i < numelts(d1) : assign_place_inner(env,d1[i],d2[i]) };
    // try to preserve sharing by returning one of the original arrays
    // if there was no change
    bool change = false;
    for (int i = 0; i < numelts(d1); i++)
      if (new_d[i] != d1[i]) {
        change = true; break;
      }
    if (!change)
      return oldval;
    change = false;
    for (int i = 0; i < numelts(d1); i++)
      if (new_d[i] != d2[i]) {
        change = true; break;
      }
    if (!change)
      return newval;
    return rnew(env->fenv->r) Aggregate(is_union1,new_d);
  case $(_, &Esc(il)): // we already know we don't have an escaped location
    switch(il) {
    case NoneIL: return env->fenv->unknown_none;
    case ThisIL: return env->fenv->unknown_this;
    case AllIL:  return env->fenv->unknown_all;
    }
  default: return newval;
  }
}
static absRval_t<`r2> assign_place_outer(struct AssignEnv<`r,`r2> @ env, 
                                         list_t<int> fs,
                                         absRval_t<`r2> oldval, 
                                         absRval_t<`r2> newval) {
  if(fs == NULL) return assign_place_inner(env,oldval,newval);
  switch($(fs,oldval)) {
  case $(&List(hd,tl),&Aggregate(UnionRInfo(is_union,fldnum),d)):
    let new_child = assign_place_outer(env,tl,d[hd],newval);
    let new_child_agg = aggr_dict_insert(env->fenv->r, d, hd, new_child);
    if (new_child_agg == d && (!is_union || fldnum == hd)) return oldval;
    return rnew(env->fenv->r) Aggregate(UnionRInfo(is_union,hd),new_child_agg);
  default: throw new Core::Impossible("bad assign place");
  }
}
flowdict_t<`r> assign_place(flow_env_t<`r> fenv,
                            Position::seg_t loc, flowdict_t<`r> d,
                            place_set_t<`r> * all_changed, 
                            place_t<`r,`r> place, 
                            absRval_t<`r> r) {
  update_place_set(all_changed,place,NULL);
  ANAL_RGN(fenv, rgn) {
    let &Place{root,fs} = place;
    struct AssignEnv/*<`rgn>*/ env = AssignEnv(fenv, rnew(rgn) EscPile(rgn,NULL), d, loc);
    absRval_t newval= assign_place_outer(&env,fs,Dict::lookup(d,root),r);
    return escape_these(fenv, env.pile, all_changed, Dict::insert(d, root, newval));
  }
}

/////////////////// Join, After, and Lessthan ///////////////////////////////
static struct JoinEnv<`r::R,`r2::R> {
  flow_env_t<`r2> fenv;
  escpile_t<`r2,`r2,`r,`r> pile;
  flowdict_t<`r2>  d1;
  flowdict_t<`r2>  d2;
};
typedef struct JoinEnv<`r1,`r2> @`r3 joinenv_t<`r1,`r2,`r3>;
static enum WhoIsChanged { Neither, One, Two }; // if both changed, take join
static struct AfterEnv<`r::R,`r2::R> {
  struct JoinEnv<`r,`r2> joinenv;
  place_set_t<`r2> chg1; // should region-allocate!
  place_set_t<`r2> chg2; // should region-allocate!
  place_t<`r2,`r2> curr_place; // a pain to stack-allocate, but should!
  list_t<int,`r2> @`r last_field_cell;
  enum WhoIsChanged changed;
};
typedef struct AfterEnv<`r1,`r3> @`r2 afterenv_t<`r1,`r2,`r3>;

static bool absRval_lessthan_approx(`a ignore, absRval_t<`r> r1, absRval_t<`r> r2);

// note: There is another reasonable policy for losing an alias to AllInit:
//   (when destination unescaped!)
//   still make the result ThisInit and **don't** lose the aliases downstream.
//   I imagine the default should be AllInit and lose downstream with a pragma
//   in the source to get the other behavior (if anyone actually cares).
//   Note that the two policies are incomparable in what they accept.
// note: we don't have to record changes because anything changed would
//       have to have already been added as a change by r1 or r2!
static absRval_t<`r> join_absRval(joinenv_t<`r2,`r> env,`a a,absRval_t<`r> r1,absRval_t<`r> r2) {
  if(r1==r2) return r1;
  let rgn = env->fenv->r;

  switch($(r1,r2)) { // only break when the answer should be Unknown or Esc!

  case $(&Consumed(e1,i1,r1),&Consumed(e2,i2,r2)):
    if (e1 == e2 && i1 == i2) 
      return rnew(rgn) Consumed(e1,i1,join_absRval(env,a,r1,r2));
    switch (r1) {
    case &AddressOf(p): add_place(env->pile,p); break;
    default: break;
    }
    switch (r2) {
    case &AddressOf(p): add_place(env->pile,p); break;
    default: break;
    }
    break;
  case $(&Consumed(e1,i1,r1),_): 
    return rnew(rgn) Consumed(e1,i1,join_absRval(env,a,r1,r2));
  case $(_,&Consumed(e2,i2,r2)): 
    return rnew(rgn) Consumed(e2,i2,join_absRval(env,a,r1,r2));

  case $(&AddressOf(p1), &AddressOf(p2)):
    if(place_cmp(p1,p2)==0) return r1;
    add_place(env->pile,p1);
    add_place(env->pile,p2);
    break;

  case $(&AddressOf(p), &NotZeroThis): fallthru(p);
  case $(&NotZeroThis, &AddressOf(p)): 
    add_place(env->pile,p);
    return env->fenv->notzerothis;

  case $(&AddressOf(p), &NotZeroAll): 
    add_place(env->pile,p);
    switch (initlevel(env->fenv,env->d1,r1)) {
    case AllIL: return env->fenv->notzeroall;
    default: return env->fenv->notzerothis;
    }
  case $(&NotZeroAll, &AddressOf(p)):
    add_place(env->pile,p);
    switch (initlevel(env->fenv,env->d2,r2)) {
    case AllIL: return env->fenv->notzeroall;
    default: return env->fenv->notzerothis;
    }
    
  case $(&AddressOf(p), _): add_place(env->pile,p); break;
  case $(_, &AddressOf(p)): add_place(env->pile,p); break;


  case $(&NotZeroAll,  &NotZeroThis):
  case $(&NotZeroThis, &NotZeroAll): return env->fenv->notzerothis;

  case $(&Aggregate(UnionRInfo(is_union1,field_no1),d1), &Aggregate(UnionRInfo(is_union2,field_no2),d2)):
    aggrdict_t new_d = 
      rnew(rgn) {for i < numelts(d1) : join_absRval(env,0,d1[i],d2[i]) };

    // try to preserve sharing by returning one of the original arrays
    // if there was no change
    bool change = false;
    for (int i = 0; i < numelts(d1); i++)
      if (new_d[i] != d1[i]) {
        change = true; break;
      }
    if (!change) {
      if (!is_union1) return r1;
      new_d = d1;
    }
    else {
      change = false;
      for (int i = 0; i < numelts(d1); i++)
	if (new_d[i] != d2[i]) {
	  change = true; break;
	}
      if (!change) {
	if (!is_union1) return r2;
	new_d = d2;
      }
    }
    return rnew(rgn) Aggregate(UnionRInfo(is_union1,field_no1 == field_no2 ? field_no1 : -1),new_d);
    
  default: break;
  }
  initlevel_t il1 = initlevel(env->fenv,env->d1,r1);
  initlevel_t il2 = initlevel(env->fenv,env->d2,r2);
  switch($(r1,r2)) {
  case $(&Esc(_),_):
  case $(_,&Esc(_)):
    switch($(il1,il2)) {
    case $(_,NoneIL): case $(NoneIL,_): return env->fenv->esc_none;
    case $(_,ThisIL): case $(ThisIL,_): return env->fenv->esc_this;
    default: return env->fenv->esc_all;
    }
  default:
    switch($(il1,il2)) {
    case $(_,NoneIL): case $(NoneIL,_): return env->fenv->unknown_none;
    case $(_,ThisIL): case $(ThisIL,_): return env->fenv->unknown_this;
    default: return env->fenv->unknown_all;
    }
  }
}

reln_op_t EqualConst(unsigned int i) {return RelnOp{.EqualConst = i};}
reln_op_t LessVar(Absyn::vardecl_t v,Absyn::type_t t) {
  return RelnOp{.LessVar = $(v,t)};
}
reln_op_t LessNumelts(Absyn::vardecl_t v) {return RelnOp{.LessNumelts=v};}
reln_op_t LessConst(unsigned int i) { return RelnOp{.LessConst = i};}
reln_op_t LessEqConst(unsigned int i) { return RelnOp{.LessEqConst = i};}
reln_op_t LessEqNumelts(Absyn::vardecl_t v) {
  return RelnOp{.LessEqNumelts=v};
}


static bool same_relop(reln_op_t r1,reln_op_t r2) {
  switch ($(r1,r2)) {
  case $({.EqualConst = c1},{.EqualConst = c2}): return c1 == c2;
  case $({.LessVar = $(v1,_)},{.LessVar = $(v2,_)}):    return v1 == v2;
  case $({.LessNumelts = v1},{.LessNumelts = v2}):   return v1 == v2;
  case $({.LessConst = c1},{.LessConst = c2}):  return c1 == c2;
  case $({.LessEqConst = c1},{.LessEqConst = c2}):  return c1 == c2;
  case $({.LessEqNumelts = v1},{.LessEqNumelts = v2}): return v1 == v2;
  default: return false;
  }
}
static relns_t<`r> join_relns(region_t<`r> r, relns_t<`r> r1s, relns_t<`r> r2s){
  if (r1s == r2s) return r1s;
  //  fprintf(stderr,"join on ["); print_relns(r1s); 
  //  fprintf(stderr,"] and ["); print_relns(r2s); fprintf(stderr,"]\n");
  list_t<reln_t> res = NULL;
  bool diff = false;
  for (let r1s = r1s; r1s != NULL; r1s = r1s->tl) {
    let r1 = r1s->hd;
    bool found = false;
    for (let r2s = r2s; r2s != NULL; r2s = r2s->tl) {
      let r2 = r2s->hd;
      if (r1 == r2 || ((r1->vd == r2->vd) && same_relop(r1->rop,r2->rop))) {
        res = rnew(r) List(r1,res);
        found = true;
        break;
      }
    }
    if (!found) diff = true;
  }
  if (!diff) res = r1s;
  //  fprintf(stderr,"result ["); print_relns(res); fprintf(stderr,"]\n");
  return res;
}

flow_t<`r> join_flow(flow_env_t<`r> fenv,
                     place_set_t<`r>* all_changed, flow_t<`r> f1, flow_t<`r> f2){
  // if(f1 == f2) return f1;
  switch($(f1,f2)) {
  case $({.BottomFL = _},_): return f2;
  case $(_,{.BottomFL = _}): return f1;
  case $({.ReachableFL = $(d1,r1)}, {.ReachableFL = $(d2,r2)}):
    // A lot of computation to avoid allocation, but profiling suggests
    // that's the right thing to do.
    if(d1.t == d2.t && r1 == r2) return f1;
    if(flow_lessthan_approx(f1,f2)) return f2;
    if(flow_lessthan_approx(f2,f1)) return f1;
    ANAL_RGN(fenv, rgn) {
      let env     = JoinEnv(fenv, rnew(rgn) EscPile(rgn,NULL),d1,d2);
      let outdict = Dict::intersect_c(join_absRval,&env,d1,d2);
      let r       = join_relns(fenv->r,r1,r2);
      return ReachableFL(escape_these(fenv, env.pile, all_changed, outdict),r);
    }
  }
}

$(flow_t<`r>,absRval_t<`r>) 
join_flow_and_rval(flow_env_t<`r> fenv,
                   place_set_t<`r>* all_changed,
                   $(flow_t<`r>,absRval_t<`r>) pr1,
                   $(flow_t<`r>,absRval_t<`r>) pr2) {
  // possibly wasteful because it could do the escape shtuff twice
  // and it can because of && and || using 0 which abstracts to Zero. Sigh.
  let $(f1,r1) = pr1;
  let $(f2,r2) = pr2;
  flow_t outflow = join_flow(fenv,all_changed,f1,f2);
  switch($(f1,f2,outflow)) {
  case $({.BottomFL = _},_,_): return $(outflow,r2);
  case $(_,{.BottomFL = _},_): return $(outflow,r1);
  case $({.ReachableFL = $(d1,_)},{.ReachableFL = $(d2,_)}, 
	 {.ReachableFL = $(outd,relns)}):
    if(absRval_lessthan_approx(0,r1,r2)) return $(outflow,r2);
    if(absRval_lessthan_approx(0,r2,r1)) return $(outflow,r1);
    ANAL_RGN(fenv, rgn) {
      let env  = JoinEnv(fenv, rnew(rgn) EscPile(rgn,NULL),d1,d2);
      let outr = join_absRval(&env,0,r1,r2);
      return $(ReachableFL(escape_these(fenv, env.pile,all_changed,outd),
                           relns), outr);
    }
  default: throw new Core::Impossible("join_flow_and_rval: BottomFL outflow");
  }
}

static absRval_t<`r> after_absRval_d(afterenv_t<`r1,`r2,`r>,int,absRval_t<`r>,absRval_t<`r>);
static absRval_t<`r> after_absRval(afterenv_t<`r1,`r2,`r> env, absRval_t<`r> r1, absRval_t<`r> r2) {
  bool changed1 = env->changed == One || Dict::member(env->chg1,env->curr_place);
  bool changed2 = env->changed == Two || Dict::member(env->chg2,env->curr_place);
  if(changed1 && changed2) 
    return join_absRval(&env->joinenv, 0, r1, r2);
  // checking for "is a contained object changed in the other pinfo" is
  // quadratic because we'll do it "all the way down", but in practice
  // "all the way down" is small.
  if(changed1) {
    if(!prefix_of_member(env->curr_place, env->chg2))
      return r1;
    env->changed = One;
  }
  if(changed2) {
    if(!prefix_of_member(env->curr_place, env->chg1))
      return r2;
    env->changed = Two;
  }

  // neither one change, but they are not pointer equal.  Thus we assume
  // that they point to things that have changed.
  switch($(r1,r2)) {
  case $(&Consumed(...),_):
  case $(_,&Consumed(...)): return join_absRval(&env->joinenv, 0, r1, r2);
  case $(&Aggregate(is_union1,d1),&Aggregate(is_union2,d2)):
    aggrdict_t new_d = 
      rnew(env->joinenv.fenv->r) 
        {for i < numelts(d1) : after_absRval_d(env,i,d1[i],d2[i]) };
                                                         
    // try to preserve sharing by returning one of the original arrays
    // if there was no change
    bool change = false;
    for (int i = 0; i < numelts(d1); i++)
      if (new_d[i] != d1[i]) {
        change = true; break;
      }
    if (!change)
      return r1;
    change = false;
    for (int i = 0; i < numelts(d1); i++)
      if (new_d[i] != d2[i]) {
        change = true; break;
      }
    if (!change)
      return r2;
    return rnew(env->joinenv.fenv->r) Aggregate(is_union1,new_d);
  default: 
    DEBUG_PRINT("after_absRval, rvalues are ");
    DEBUG_PRINT_F(print_absrval,r1);
    DEBUG_PRINT(" and ");
    DEBUG_PRINT_F(print_absrval,r2);
    DEBUG_PRINT("\n");
    throw new Core::Impossible("after_absRval -- non-aggregates!");
  }
}
static absRval_t<`r> 
after_absRval_d(afterenv_t<`r1,`r2,`r> env, int key, 
                absRval_t<`r> r1, absRval_t<`r> r2) {
  if(r1 == r2) return r1;
  let old_last_field = env->last_field_cell; 
  let old_changed    = env->changed;
  *env->last_field_cell = rnew(env->joinenv.fenv->r) List(key,NULL);
  env->last_field_cell  = &(*env->last_field_cell)->tl;
  let ans = after_absRval(env,r1,r2);
  env->last_field_cell        = old_last_field;
  (*env->last_field_cell)->tl = NULL;
  env->changed                = old_changed;
  return ans;
}
static absRval_t<`r> after_root(afterenv_t<`r1,`r2,`r> env, root_t<`r> root,
                                absRval_t<`r> r1, absRval_t<`r> r2) {
  if(r1 == r2) return r1;
  *env->curr_place     = Place(root,NULL);
  env->last_field_cell = &env->curr_place->fields;
  env->changed         = Neither;
  return after_absRval(env, r1, r2);
}
// FIX: region-allocate chg1 and chg2
flow_t<`r> after_flow(flow_env_t<`r> fenv,
                      place_set_t<`r>* all_changed, 
                      flow_t<`r> f1, flow_t<`r> f2,
                      place_set_t<`r> chg1, place_set_t<`r> chg2) {

  //if(f1 == f2) return f1;
  switch($(f1,f2)) {
  case $({.BottomFL = _},_): 
  case $(_,{.BottomFL = _}): return BottomFL();
  case $({.ReachableFL = $(d1,r1)},{.ReachableFL = $(d2,r2)}):
    if(d1.t == d2.t && r1 == r2) return f1;
    // Should think about ways to avoid allocation here: (curr_place and
    // cut-off in presence of changes)
    ANAL_RGN(fenv, rgn) {
      let curr_place = fenv->dummy_place;
      let env  = AfterEnv(JoinEnv(fenv, rnew(rgn) EscPile(rgn,NULL), d1, d2), 
			  chg1, chg2, 
			  curr_place, &curr_place->fields,
			  Neither);
      let new_d = Dict::union_two_c(after_root,&env,d1,d2);
      let new_r = join_relns(fenv->r,r1,r2);
      return ReachableFL(escape_these(fenv,env.joinenv.pile,all_changed,new_d),
                         new_r);
    }
  }
}

// WARNING: This is where we cheat ("approx") for performance.
static bool absRval_lessthan_approx(`a::B ignore, absRval_t<`r> r1, absRval_t<`r> r2) {
  if(r1 == r2) return true;

  switch ($(r1,r2)) {
  case $(&AddressOf(p1), &AddressOf(p2)): return place_cmp(p1,p2)==0;
  case $(&AddressOf(_),_):
  case $(_,&AddressOf(_)): return false;
  case $(&Aggregate(is_union1,d1), &Aggregate(is_union2,d2)):
    if (d1 == d2) return true;
    for (int i = 0; i < numelts(d1); i++) 
      if (!absRval_lessthan_approx(0,d1[i],d2[i])) return false;
    return true;
  case $(&NotZeroAll, &NotZeroThis): return true;
  case $(_, &NotZeroThis): return false;
  case $(_, &Zero): 
  case $(_, &NotZeroAll): return false;
  case $(&Esc(_),&Esc(_)): break;
  case $(&Esc(_),_): return false;
  default: break;
  }
  switch($(initlevel_approx(r1), initlevel_approx(r2))) {
  case $(AllIL,AllIL): return true;
  case $(_,NoneIL): return true;
  case $(NoneIL,_): return false;
  case $(_,ThisIL): return true;
  case $(ThisIL,_): return false;
  }
}

static bool relns_approx(relns_t<`r> r2s, relns_t<`r> r1s) {
  if (r1s == r2s) return true;
  //fprintf(stderr,"approx on ["); print_relns(r1s); 
  //fprintf(stderr,"] and ["); print_relns(r2s); fprintf(stderr,"]");
  for (; r1s != NULL; r1s = r1s->tl) {
    let r1 = r1s->hd;
    bool found = false;
    for (let r2s = r2s; r2s != NULL; r2s = r2s->tl) {
      let r2 = r2s->hd;
      if (r1 == r2 || ((r1->vd == r2->vd) && same_relop(r1->rop,r2->rop))) {
        found = true;
        break;
      }
    }
    if (!found)
      return false; 
  }
  return true;
}

// WARNING: We assume anything not in the intersection is IRRELEVANT.
// WARNING: We might return false even when f1 < f2, but that's okay b/c
//  that will just cause clients to take joins/afters and we always return true
//  when the two flows are equal.  That's what the approx means.
// (As a result of the approx, we don't have to allocate here.)
bool flow_lessthan_approx(flow_t<`r> f1, flow_t<`r> f2) {
  //if(f1 == f2) return true;
  switch($(f1,f2)) {
  case $({.BottomFL = _},_): return true;
  case $(_,{.BottomFL = _}): return false;
  case $({.ReachableFL = $(d1,r1)},{.ReachableFL = $(d2,r2)}):
    if(d1.t == d2.t && r1 == r2) return true;
    return Dict::forall_intersect(absRval_lessthan_approx,d1,d2) &&
      relns_approx(r1,r2);
  }
}

relns_t<`r> reln_kill_var(region_t<`r> rgn, relns_t<`r> rs, vardecl_t v) {
  relns_t p;
  bool found = false;
  for (p = rs; !found && p != NULL; p = p->tl) {
    let r = p->hd;
    if (r->vd == v) { found = true; break; }
    switch (r->rop) {
    case {.LessVar = $(v2,_)}:   fallthru(v2);
    case {.LessNumelts = v2}:  fallthru(v2);
    case {.LessEqNumelts = v2}: if(v==v2) found = true; break;
    default: break;
    }
  }
  if (!found) return rs;

  let new_rs = NULL;
  for (p = rs; p != NULL; p = p->tl) {
    let r = p->hd;
    if (r->vd != v) {
      switch (r->rop) {
      case {.LessVar = $(v2,_)}:   fallthru(v2);
      case {.LessNumelts = v2}:  fallthru(v2);
      case {.LessEqNumelts = v2}: if (v == v2) continue; break;
      default: break;
      }
      new_rs = rnew(rgn) List(r,new_rs);
    }
  }
  return new_rs;
}

relns_t<`r> reln_kill_exp(region_t<`r> rgn, relns_t<`r> r, exp_t e) {
  switch (e->r) {
  case &Var_e(_,&Global_b(vd)): fallthru(vd);
  case &Var_e(_,&Param_b(vd)):  fallthru(vd);
  case &Var_e(_,&Local_b(vd)):  fallthru(vd);
  case &Var_e(_,&Pat_b(vd)):
    if (!vd->escapes)
      return reln_kill_var(rgn, r, vd);
    break;
  default: break;
  }
  return r;
}

reln_t<`r2> copy_reln(region_t<`r2> r2, reln_t r) {
  return rnew(r2)(*r);
}

relns_t<`r2> copy_relns(region_t<`r2> r2, relns_t<`r> relns) {
  return List::rmap_c(r2,copy_reln,r2,relns);
}

bool same_relns(relns_t r1, relns_t r2) {
  for (; r1 != NULL && r2 != NULL; r1 = r1->tl, r2 = r2->tl) {
    let x1 = r1->hd;
    let x2 = r2->hd;
    if (x1->vd != x2->vd || !same_relop(x1->rop,x2->rop)) return false;
  }
  if (r1 != NULL || r2 != NULL) return false;
  else return true;
}

relns_t<`r> reln_assign_var(region_t<`r> rgn, relns_t<`r> r, vardecl_t v, exp_t e) {
  //fprintf(stderr,"assigning %s to %s: \n", Absynpp::qvar2string(v->name),
  //        Absynpp::exp2string(e));
  if (v->escapes) return r;
  // even if v isn't an integral type, it might be an array in which case
  // we need to kill it.
  r = reln_kill_var(rgn, r, v);
  // if e is malloc(n*sizeof(t)) or a calloc(n,sizeof(t)) 
  // then we can add n <= numelts(v).  Note that we can't easily
  // do this for comprehensions (i.e., rnew(e1) {for i < n : e2})
  // because e1 or e2 could modify n.  
  switch (e->r) {
  case &Malloc_e(MallocInfo{_,_,_,e2,true}):
    malloc_loop:
    switch (e2->r) {
    case &Cast_e(_,e3,_,_): e2 = e3; goto malloc_loop;
    case &Var_e(_,&Pat_b(n)): fallthru(n);
    case &Var_e(_,&Local_b(n)): fallthru(n);
    case &Var_e(_,&Param_b(n)): fallthru(n);
    case &Var_e(_,&Global_b(n)): 
      if (n->escapes) return r;
      return rnew(rgn) List(rnew(rgn) Reln{n,LessEqNumelts(v)},r);
    default: return r;
    }
  default: break;
  }
  // otherwise ignore any situations where we have a non-integral type
  switch (Tcutil::compress(v->type)) {
  case &IntType(_,_): break;
  default: 
    return r;
  }
  // ignore if e isn't numelts(y) or a constant
  
 loop:
  switch (e->r) {
  case &Cast_e(_,e1,_,_): e = e1; goto loop;
  case &Const_e({.Int_c = $(_,i)}): 
    return rnew(rgn) List(rnew(rgn) Reln(v,EqualConst(i)),r);
  case &Primop_e(Mod, &List(_,&List(e2,_))):
    // FIX: is this safe?  what if e modifies v2?
    // when we have x = e % numelts(v2), add x < numelts(v2)
    switch (e2->r) {
    case &Primop_e(Size, &List(e3,_)):
      switch (e3->r) {
      case &Var_e(_,&Global_b(v2)): fallthru(v2);
      case &Var_e(_,&Local_b(v2)):  fallthru(v2);
      case &Var_e(_,&Param_b(v2)):  fallthru(v2);
      case &Var_e(_,&Pat_b(v2)):
        if (v2->escapes) return r;
        return rnew(rgn) List(rnew(rgn) Reln(v,LessNumelts(v2)),r);
      default: break;
      }
      break;
    default: break;
    }
    break;
  case &Primop_e(Size,&List(e2,_)):
    switch (e2->r) {
    case &Var_e(_,&Global_b(v2)): fallthru(v2);
    case &Var_e(_,&Local_b(v2)):  fallthru(v2);
    case &Var_e(_,&Param_b(v2)):  fallthru(v2);
    case &Var_e(_,&Pat_b(v2)):
      if (v2->escapes) return r;
      return rnew(rgn) List(rnew(rgn) Reln(v,LessEqNumelts(v2)),r);
    default: break;
    }
    break;
  default: break;
  }
  return r;
}

relns_t<`r> reln_assign_exp(region_t<`r> rgn, relns_t<`r> r, exp_t e1, exp_t e2) {
  switch (e1->r) {
  case &Var_e(_,&Global_b(vd)): fallthru(vd);
  case &Var_e(_,&Param_b(vd)):  fallthru(vd);
  case &Var_e(_,&Local_b(vd)):  fallthru(vd);
  case &Var_e(_,&Pat_b(vd)):
    if (!vd->escapes)
      return reln_assign_var(rgn, r, vd, e2);
    break;
  default: break;
  }
  return r;
}

static void print_reln(reln_t r) {
  fprintf(stderr,"%s",qvar2string(r->vd->name));
  switch (r->rop) {
  case {.EqualConst = c}: fprintf(stderr,"==%d",c); break;
  case {.LessVar = $(vd,_)}:   fprintf(stderr,"<%s",qvar2string(vd->name)); break;
  case {.LessNumelts = vd}:  fprintf(stderr,"<numelts(%s)",qvar2string(vd->name)); break;
  case {.LessConst = c}:  fprintf(stderr,"<%d",c); break;
  case {.LessEqConst = c}:  fprintf(stderr,"<=%d",c); break;
  case {.LessEqNumelts = vd}: fprintf(stderr,"<=numelts(%s)",qvar2string(vd->name));break;
  }
}
void print_relns(relns_t r) {
  for (; r != NULL; r = r->tl) {
    print_reln(r->hd);
    if (r->tl != NULL) fprintf(stderr,",");
  }
}

void print_initlevel(initlevel_t il) {
  switch (il) {
  case NoneIL: fprintf(stderr,"uninitialized"); break;
  case ThisIL: fprintf(stderr,"this-initialized"); break;
  case AllIL: fprintf(stderr,"all-initialized"); break;
  }
}

void print_root(root_t root) {
  switch (root) {
  case &VarRoot(vd): 
    fprintf(stderr,"Root(%s)",Absynpp::qvar2string(vd->name)); break;
  case &MallocPt(e,t):
    fprintf(stderr,"MallocPt(%s,%s)",
	    Absynpp::exp2string(e),Absynpp::typ2string(t)); break;
  case &InitParam(_,_):
    fprintf(stderr,"InitParam(_,_)"); break;
  }
}

void print_place(place_t p) {
  print_root(p->root);
  let x = p->fields;
  while (x != NULL) {
    fprintf(stderr,".%d",x->hd);
    x = x->tl;
  }
  fprintf(stderr," ");
}

void print_list(List::list_t<`a> x, void (@pr)(`a)) {
  let first = true;
  while (x != NULL) {
    if (!first) { fprintf(stderr,", "); first = false; }
    pr(x->hd);
    x = x->tl;
  }
  fprintf(stderr,"\n");
}

void print_dict_set(dict_set_t<`a> p, void (@pr)(`a)) {
  region r; {
    try {
      Iter::iter_t<_,`r> iter = Dict::make_iter(r,p);
      let elem = *Dict::rchoose(r,p);
      bool first = true;
      fprintf(stderr,"{ ");
      while(Iter::next(iter,&elem)) {
	let p = elem[0];
	if (!first) {
	  fprintf(stderr,", ");
	  first = false;
	}
	pr(p);
      }
      fprintf(stderr,"}\n");
    } catch {
    case Absent:
      fprintf(stderr,"{ }\n");
      return;
    }
  }
}

void print_absrval(absRval_t rval) {
  switch (rval) {
  case &Zero: fprintf(stderr,"Zero"); break;
  case &NotZeroAll: fprintf(stderr,"NotZeroAll"); break;
  case &NotZeroThis: fprintf(stderr,"NotZeroThis"); break;
  case &UnknownR(il): fprintf(stderr,"Unknown("); print_initlevel(il);
    fprintf(stderr,")"); break;
  case &Esc(il): fprintf(stderr,"Esc("); print_initlevel(il);
    fprintf(stderr,")"); break;
  case &AddressOf(p): fprintf(stderr,"AddrOf("); print_place(p); 
    fprintf(stderr,")"); break;
  case &Aggregate(UnionRInfo(is_union,f),d): 
    if (is_union) {
      fprintf(stderr,"AggrUnion{");
      if (f != -1)
	fprintf(stderr,"tag == %d;",f);
    }
    else fprintf(stderr,"AggrStruct{");
    for (int i = 0; i < numelts(d); i++) {
      print_absrval(d[i]);
      if (i+1 < numelts(d)) fprintf(stderr,",");
    }
    fprintf(stderr,"}");
    break;
  case &Consumed(e,i,r):
    fprintf(stderr,"[Consumed(%s,%d,",Absynpp::exp2string(e),i);
    print_absrval(r); fprintf(stderr,"]");
  }
}

static void print_flow_mapping(root_t root, absRval_t rval) {
  fprintf(stderr,"    ");
  print_root(root);
  fprintf(stderr," --> ");
  print_absrval(rval);
  fprintf(stderr,"\n");
}

void print_flowdict(flowdict_t d) {
  Dict::iter(print_flow_mapping,d);
}

void print_flow(flow_t f) {
  switch (f) {
  case {.BottomFL = _}: fprintf(stderr,"  BottomFL\n"); break;
  case {.ReachableFL = $(fd,_)}:
    fprintf(stderr,"  ReachableFL:\n");
    print_flowdict(fd);
    fprintf(stderr,"\n");
    break;
  }
}

// returns true when t contains the region rgn with a few exceptions:
//  * doesn't count rgn in function types
//  * doesn't count rgn in region_t types (i.e., handles)
// We don't care about functions -- they're only callable if their 
// effects are covered by the capability and in the absence of closures,
// can't have any dangling pointers into rgn.  Region handles aren't
// "killed" when we reset a region and in fact we need them to ensure
// that we can allocate stuff in the region.  
bool contains_region(killrgn_t rgn, type_t t) {
  switch (Tcutil::compress(t)) {
  case &VoidType: // these cases can't contain rgn
  case &IntType(_,_):    
  case &FloatType:        
  case &DoubleType(_):   
  case &EnumType(_,_):   
  case &AnonEnumType(_): 
  case &TagType(_):      
  case &HeapRgn:
  case &Evar(_,_,_,_): return false; // because of compress above
  case &UniqueRgn:
    switch (rgn) {
    case &UniqueRgn_k: return true;
    default: return false;
    }
  case &VarType(tv): 
    switch (rgn) {
    case &UniqueRgn_k: return false;
    case &Region_k(rgn): return tvar_cmp(tv,rgn) == 0;
    }
    // for parameterized types, we just look to see if rgn shows up 
    // in the parameters -- this is overly aggressive since the regions
    // might not actually get used or may only get used in a handle or
    // in a function.  But it beats substituting and descending.
    //
    // Note also that we don't descend into the definitions of datatypes,
    // structs, typedefs, etc. because they must be closed w.r.t. all regions
    // except the heap.  
  case &DatatypeType(DatatypeInfo{_,targs}): fallthru(targs);
  case &TypedefType(_,targs,_,_):    fallthru(targs);
  case &AggrType(AggrInfo{_,targs}): fallthru(targs);
  case &DatatypeFieldType(DatatypeFieldInfo{_,targs}): fallthru(targs);
  case &JoinEff(targs): 
    return List::exists_c(contains_region,rgn,targs);
  case &PointerType(PtrInfo{t2,_,PtrAtts(r,_,_,_,_)}):
    return contains_region(rgn,r) || contains_region(rgn,t2);
  case &FnType(_): return false;
  case &TupleType(tqs):
    for (; tqs != NULL; tqs = tqs->tl)
      if (contains_region(rgn,(*tqs->hd)[1])) return true;
    return false;
  case &AnonAggrType(_,fds):
    for (; fds != NULL; fds = fds->tl) 
      if (contains_region(rgn,fds->hd->type)) return true;
    return false;
  case &ArrayType(ArrayInfo{t2,_,_,_,_}): fallthru(t2);
  case &AccessEff(t2):     fallthru(t2);
  case &RgnsEff(t2):       return contains_region(rgn,t2);
  case &DynRgnType(t1,t2): 
    return contains_region(rgn,t1) || contains_region(rgn,t2);
  // careful: we don't want to kill any region handles to the region in
  // question.
  case &RgnHandleType(t2): return false;
  case &ValueofType(_): return false;
  }
}

// used by kill_flowdict_region below
static void kill_root($(flow_env_t<`r>, flowdict_t<`r>,killrgn_t)@ env, root_t<`r> root, absRval_t<`r> rval) {
  let &$(fenv,*fd,rgn) = env;
  switch (root) {
  case &VarRoot(vd): 
    // if the variable's type contains the region
    if (contains_region(rgn,vd->type))
      // set it to uninitialized in the new dictionary
      rval = typ_to_absrval(fenv, vd->type, false,fenv->unknown_none);
    *fd = Dict::insert(*fd,root,rval);
    break;
  case &MallocPt(_,t): 
    // if the result of the malloc's type does not contain the region
    if (!contains_region(rgn,t))
      // insert the mapping into the new dictionary
      *fd = Dict::insert(*fd,root,rval);
    break;
  case &InitParam(_,_):
    // when we have interprocedural resettable, this could be a problem?!
    break;
  }
}

// "kill" all roots in the flowdict that have rgn in their type
static flowdict_t<`r> 
kill_flowdict_region(flow_env_t<`r> fenv, flowdict_t<`r> fd, type_t rgn) {
  switch (Tcutil::compress(rgn)) {
  case &VarType(tv): 
    datatype KillRgn.Region_k v = Region_k(tv);
    datatype KillRgn @v2 = &v;
    $(flow_env_t,flowdict_t,killrgn_t) env = $(fenv,fenv->mt_flowdict,v2);
    Dict::iter_c(kill_root,&env,fd);
    return env[1];
    
  case &UniqueRgn: 
    $(flow_env_t,flowdict_t,killrgn_t) env = $(fenv,fenv->mt_flowdict,&UniqueRgn_k_val);
    Dict::iter_c(kill_root,&env,fd);
    return env[1];

  default: throw new Core::Impossible("kill_flowdict_region");
  }
}

// "kill" all relations in the flow analysis that involve the given region
static relns_t<`r> kill_relns_region(relns_t<`r> relns, type_t rgn) {
  // FIX: too conservative
  return NULL;
}

// the region rgn has been reset -- produce an outflow where the 
// roots involving rgn are now uninitialized.
flow_t<`r> kill_flow_region(flow_env_t<`r> fenv, flow_t<`r> f, type_t rgn) {
  switch (f) {
  case {.BottomFL = _}: return f;
  case {.ReachableFL = $(fd,r)}: 
    let fd2 = kill_flowdict_region(fenv,fd,rgn);
    let r2 = kill_relns_region(r,rgn);
    // FIX: deal with killing consumed values?
    return ReachableFL(fd2,r2);
  }
}
