#include "assndef.h"
#include <list.h>

using AssnDef;
using List;

namespace PrattProver;

// FIX: 32-bit dependency!
#define MAXINT  (2147483647)
//#define MININT  (-2147483648)
#define MININT (-MAXINT-1)
#define MAXUINT (0xFFFFFFFF)

///////////////////////// Constraint Solving ///////////////////////////
//
// This is a simple constraint solver that can determine the satisfiability
// of the conjunction of a set of constraints of the form (t1 - t2 <= c).
//
// We use a variation of the Pratt algorithm here where we keep track of a 
// signed distance and an unsigned distance between terms 
// and find the minimal length signed and unsigned paths between any 
// two terms.  If we ever get a negative-length cycle, then the constraints 
// are inconsistent.  
//
// We represent a conjunction of constraints as a sparse matrix of
// the distances.  We consider distance(i,j) == 0 implicitly, and
// otherwise, if (i,j) are not in the graph, the distance is infinite.
//
// To deal with an entire assertion, we must collect a set of graphs.
// representing alternative states.  This effectively converts the 
// assertion to DNF which is an exponential blowup.  To avoid the blowup,
// we aggressively prune inconsistent graphs.  

// Forward declaration -- represents an equivalence class for terms
// (and also a row within a graph.)
struct Node;
typedef struct Node node_t;


// An entry in the sparse matrix -- records the target node of the
// edge and the distance as a (signed) integer.
typedef struct Distance {
  struct Distance *next;
  node_t @target;
  int    dist;
} distance_t;


// Represents a row within a graph.
struct Node {
  node_t     *next;
  term_t      rep;
  distance_t *unsigned_distances;
  distance_t *signed_distances;
};

// A graph is essentially a pair of sparse matrices of 
// (node_t,node_t)->distance.  We represent the matrices by having
// a node row for each term.
typedef struct Graph {
  struct Graph *next;
  node_t       *rows;  // we keep the rows sorted by rep order
} graph_t;

static unsigned num_graphs(graph_t *gs) {
  unsigned c = 0;
  for (; gs != NULL; gs = gs->next)
    ++c;
  return c;
}

// An empty graph represents the proposition "true".
static graph_t@ true_graph() { return new Graph{NULL,NULL}; }

// Print out a graph.
void print_graph(graph_t @g) {
  fprintf(stderr,"{");
  if (g->rows == NULL) fprintf(stderr,"<true>");
  else {
    for (let rs = g->rows; rs != NULL; rs = rs->next) {
      let &Node{_,rep,uds,sds} = (node_t@)rs;
      for (; uds != NULL; uds = uds->next)
        fprintf(stderr,"%s - %s U<= %d\n ",term2string(rep),
                term2string(uds->target->rep),uds->dist);
      for (; sds != NULL; sds = sds->next) 
        fprintf(stderr,"%s - %s S<= %d\n ",term2string(rep),
                term2string(sds->target->rep),sds->dist);
    }
  }
  fprintf(stderr,"}\n");
}

// Print out a list of graphs.
void print_graphs(graph_t *g) {
  fprintf(stderr,"Graphs:-----------\n");
  if (g == NULL) fprintf(stderr,"<false>\n");
  else {
    for (; g != NULL; g = g->next) print_graph(g);
  }
  fprintf(stderr,"------------------\n");
}

// forward declarations
static node_t *term2node_opt(graph_t @g, term_t t);
static bool set_distance(graph_t @g, term_t s, term_t t, int dist, bool is_signed);
static bool add_constraint(graph_t @g, term_t t1, prim_reln_t p, term_t t2);
static bool add_eq(graph_t @g, term_t t1, term_t t2);
static bool add_difference_const(graph_t @g, term_t t1, term_t t2, unsigned c);

// check term to see if its type reveals its numelts is known and if so,
// add the information to the graph.  similarly, check if term's type
// is tag_t<valueof(e)> and if so, add term == e and if term is unsigned, 
// then add term >= 0.  Finally, if term = t + c, then add edges
// term -c-> t and t -(-c)-> term.  
static int add_type_info(graph_t @g, term_t term) {
  switch (term) {
  case &Binop(Absyn::Plus, t, &Uint(c),_):
    // we have:    term = t + c
    // add         term <= t+c && t+c <= term, both signed and unsigned.
    if (!add_difference_const(g,term,t,c)) return false;
    break;
  case &Unop(Absyn::Numelts, x, _):
    // add term s< MAXINT and term u< MAXINT and 0 u<= term
    if (!set_distance(g, term, zero(), MAXINT-1, true) ||
        !set_distance(g, term, zero(), MAXINT-1, false) ||
        !set_distance(g, zero(), term, 0, false)) return false;
    break;
  default: break;
  }
  let topt = get_term_type(term);
  if (topt != NULL) {
    type_t t = (type_t)topt;
    let eopt = Tcutil::get_type_bound(t);
    if (eopt != NULL) {
      term_t t1 = unop(Absyn::Numelts, term, Absyn::uint_type);
      // sigh -- must get rid of a cast to int/long
      exp_t e = (exp_t)eopt;
    loop:
      switch (e->r) {
      case &Absyn::Cast_e(tp2,e2,...):
        switch (Absyn::compress(tp2)) {
        case &Absyn::AppType(&Absyn::IntCon(_,s),_):
          if (s == Absyn::Int_sz || s == Absyn::Long_sz) {
            e = e2; goto loop;
          }
          break;
        default: break;
        }
        break;
      default: break;
      }
      term_t t2 = cnst((exp_t)e);
      if (!add_constraint(g, t2, ULte, t1)) return false;
      if (!add_constraint(g, t2, SLte, t1)) return false;
    }
    switch (Absyn::compress(t)) {
    case &Absyn::AppType(&Absyn::IntCon(Absyn::Unsigned,_),_):
      if (!add_constraint(g, zero(), ULte, term)) return false;
      break;
    case &Absyn::AppType(&Absyn::TagCon,&List{v,_}):
      switch (Absyn::compress(v)) {
      case &Absyn::ValueofType(e): add_eq(g,term,cnst(e)); break;
      case v2: 
        if (!add_eq(g,term,cnst(Absyn::valueof_exp(v2,0)))) return false; 
        break;
      }
      break;
    default: break;
    }
  }
  return true;
}

// Given a term, look up its row and if not found, then add the term 
// to the graph.  Keep things sorted by term order.
static node_t *term2node_opt(graph_t @g, term_t t) {
  // first see if we can find it directly.
  node_t *@prev = &g->rows;
  for (let r = g->rows; r != NULL; r = r->next) {
    int c = cmp_term(t,r->rep);
    if (c == 0) return r;
    if (c > 1) break;
    prev = &r->next;
  }
  // term not directly found -- insert it in the graph.  
  let n = new Node{*prev, t, NULL, NULL};
  *prev = n;
  if (!add_type_info(g,t)) return NULL;
  return n;
}

static node_t @term2node(graph_t @g, term_t t) {
  return (node_t @)term2node_opt(g,t);
}

// Given a pair of nodes, look up their distance (if any) -- return
// NULL if no distance is found.  Special case when source and target
// are the same -- we always return a distance of zero.
static int *lookup_dist(node_t @`H source, node_t @`H target, bool is_signed) {
  static int zero = 0;
  if (source == target) return &zero;
  distance_t *ds = is_signed ? source->signed_distances : 
    source->unsigned_distances;
  for (; ds != NULL; ds = ds->next) 
    if (ds->target == target) return &ds->dist;
  return NULL;
}

// returns true iff t --0--> r and r --0--> t
// or else          r --c--> zero and zero --(-c)--> r and
//                  t --c--> zero and zero --(-c)--> t and
static bool eq_nodes(node_t @`H r, node_t @`H t, bool is_signed) {
  let rt_dist = lookup_dist(r,t,is_signed);
  let tr_dist = lookup_dist(t,r,is_signed);
  return (rt_dist != NULL && *rt_dist == 0 &&
          tr_dist != NULL && *tr_dist == 0);
}

static bool equal_nodes(node_t @`H s, node_t @`H r) {
  return eq_nodes(s,r,false) || eq_nodes(s,r,true);
}

// Append two lists of graphs, representing a disjunction
static graph_t *graph_append(graph_t *`H g1, graph_t *`H g2) {
  if (g1 == NULL) return g2;
  if (g2 == NULL) return g1;
  graph_t @p = g1;
  for (let x = p->next; x != NULL; p = x, x = p->next) /* skip */ ;
  p->next = g2;
  return g1;
}

typedef $(bool, int) overflow_info_t;

typedef enum Operator{
  PLUS,
  MINUS,
} operator_t;


//checking if the sum or difference of two signed integers overflowed
//assuming size of intger as sizeofint (32), assumming the highest bit
//as the sign bit.
#define sizeofint 32;
static overflow_info_t is_signed_overflow(int c1, operator_t op,int c2){
  switch (op){
  case PLUS:
    let sum = c1 + c2;
    if ((~(c1 ^ c2) & (sum ^ c1)) >> 31){
      //overflow happened
      if (sum > 0) return $(true, MININT); //an underflow
      else return $(true, MAXINT); //an overflow
    } else return $(false, sum); //no overflow
  case MINUS:
    let dif = c1 - c2;
    if (((c1^c2) & (c1 ^ dif)) >> 31){
      //overflow happened
      if (dif > 0) return $(true, MININT); //an underflow
      else return $(true, MAXINT); //an overflow
    } else return $(false, dif); //no overflow
  default:
    Tcutil::impos("Pratt_Prover: bad operator in overflow check");
  }
}

//checking if the difference of two unsigned integers 
//could be correctly represented by a signed integer
//assuming size of (u/s)intger as sizeofint (32), assumming the highest bit
//as the sign bit.
static overflow_info_t 
is_unsigned_overflow(unsigned c1, operator_t op,unsigned c2){
  switch (op){
  case MINUS:
    int dif = c1 - c2;
    if (((c1^c2) & (~(c1 ^ dif))) >> 31){
      //overflow happened
      if (dif > 0) return $(true, MININT); //an underflow
      else return $(true, MAXINT); //an overflow
    } else return $(false, dif); //no overflow
  default:
    Tcutil::impos("Pratt_Prover: bad operator in overflow check");
  }
}

// assumes source and target do not have a distance between them in the
// graph.  inserts a new distance reflecting source - target <= d.
static void new_distance(node_t @`H source, node_t @`H target, bool is_signed, int d) {
  let dist = new Distance{NULL,target,d};
  if (is_signed) {
    dist->next = source->signed_distances;
    source->signed_distances = dist;
  } else {
    dist->next = source->unsigned_distances;
    source->unsigned_distances = dist;
  }
}

// Tries to set the distance between two terms it and jt to dist, and
// update the shortest paths between any two nodes in the graph.  Returns
// true iff the resulting graph is consistent with this new constraint.  
// Care must be taken when computing shortest paths to ensure that we
// don't end up with an overflow or underflow.
static bool set_dist(graph_t @g, node_t @`H i, node_t @`H j, int dist, bool is_signed) {
  // equivalent terms are always at distance 0.
  if (i == j && dist != 0) return false;
  let ij_dist = lookup_dist(i, j, is_signed);
  // if we already have a shorter parth, then this constraint is redundant
  if (ij_dist != NULL && *ij_dist < dist) return true;
  let ji_dist = lookup_dist(j, i, is_signed);
  // if  j --n--> i --dist--> j  and n+dist is negative, contradiction.
  if (ji_dist != NULL) {
    let $(overflow,sum) = is_signed_overflow(*ji_dist, PLUS, dist);
    if (sum < 0) return false; // overflow or not, there is a negative loop 
    // the edge will create a very positive loop and the weight of the loop
    // will overflow, so we will have to ignore the edge.
    else if (overflow && sum > 0) return true;
    // all other cases, proceed by adding the edge into the graph and
    // update the shortest paths.
  }
  for (let k = g->rows; k != NULL; k = k->next) {
    let ki_dist = lookup_dist(k, i, is_signed);
    if (ki_dist == NULL) continue; // no new path through ij
    for (let l = g->rows; l != NULL; l = l->next) {
      // skip nodes equal to k
      if (k == l) continue;
      let kl_dist = lookup_dist(k, l, is_signed);
      // if kl_dist is already MININT, no need to update.
      if (kl_dist != NULL && *kl_dist == (int)MININT) continue;
      let jl_dist = lookup_dist(j, l, is_signed);
      if (jl_dist == NULL) continue; // no new path through i->j
      // computing w(kj) = w(ki) + w(ij)
      $(bool,int) final_sum;
      let $(of1,sum1) = is_signed_overflow(*ki_dist, PLUS, dist);
      if (!of1) { // computing w(kl) = w(kj) + w(jl)
        final_sum = is_signed_overflow(sum1, PLUS, *jl_dist);
      } else {
        // now we know that ki_dist, ij_dist have the same sign
        // that's the only way the sum can cause overflow
        let $(of1,sum1) = is_signed_overflow(*ki_dist, PLUS, *jl_dist);
        if (!of1) {
          // FIX?  original code had sum here...
          final_sum = is_signed_overflow(sum1, PLUS, dist);
        } else {
          // now we know that ki_dist, ij_dist, jl_dist have the same sign
          // that's the only way both of1's are true.  If dist < 0 then
          // it must be an underflow, and if > 0 it must be an overflow.
          final_sum = $(true, dist < 0 ? MININT : MAXINT);
        }
      }
      let $(final_overflow,sum) = final_sum;
      // either there is no overflow in computing the sums, or there is
      // an underflow, so the true_sum < MININT
      if (!final_overflow || sum < 0) {
        // same node should always be at distance 0 from itself
        if (k == l && sum != 0) return false;
        // old k->l distance is infinite -- try adding a new edge.
        else if (kl_dist == NULL) new_distance(k,l,is_signed,sum);
        // old k->l distance is greater than new dist -- update edge.
        else if (*kl_dist > sum) *kl_dist = sum;
      }
    }
  }
  return true;
}

// same as above but maps terms to nodes first.
static bool set_distance(graph_t @g, term_t it, term_t jt, int dist, bool is_signed) {
  let iopt = term2node_opt(g,it);
  let jopt = term2node_opt(g,jt);
  if (iopt == NULL || jopt == NULL) return false;
  let i = (node_t@)iopt;
  let j = (node_t@)jopt;
  //fprintf(stderr,"calling set_dist on graph\n");
  //print_graph(g);
  return set_dist(g,i,j,dist,is_signed);
}

// Used in copy_graphs below to copy a set of edges from one graph to another.
static distance_t *copy_distances(graph_t @newg, distance_t *ds) {
  distance_t *res = NULL;
  for (; ds != NULL; ds = ds->next) {
    let t = ds->target->rep;
    res = new Distance{res,term2node(newg,t),ds->dist};
  }
  return res;
}

// Reverse a list of nodes in place.
static node_t *revnodes(node_t *`H n) {
  if (n == NULL) return NULL;
  node_t *first = n;
  node_t *second = n->next;
  n->next = NULL;
  while (second != NULL) {
    node_t *temp = second->next;
    second->next = first;
    first = second;
    second = temp;
  }
  return first;
}

// Produce a copy of the list of graphs.
static graph_t *copy_graphs(graph_t *gopt) {
  if (gopt == NULL) return NULL;
  let g = (graph_t@)gopt;
  graph_t @newg = new Graph{.next = copy_graphs(g->next), .rows = NULL};
  // insert a row for each term
  node_t *newrs = NULL;
  for (let rs = g->rows; rs != NULL; rs = rs->next) {
    newrs = new Node{newrs,rs->rep,NULL,NULL};
  }
  newrs = revnodes(newrs);
  newg->rows = newrs;
  // process each row again adding in distance edges
  for (let rs = g->rows; rs != NULL; rs = rs->next, newrs=newrs->next){
    newrs->unsigned_distances = copy_distances(newg,rs->unsigned_distances);
    newrs->signed_distances = copy_distances(newg,rs->unsigned_distances);
  }
  return newg;
}

// when ok, the term t is equal to the value i in the graph g.
static $(bool ok, unsigned i) find_eq_const(graph_t @g, node_t @`H n) {
  let z = term2node(g,zero());
  let n2z_s = lookup_dist(n,z,true);
  if (n2z_s != NULL) {
    let z2n_s = lookup_dist(z,n,true);
    if (z2n_s != NULL && *n2z_s == -(*z2n_s)) return $(true,*n2z_s);
  }
  let n2z_u = lookup_dist(n,z,false);
  if (n2z_u != NULL) {
    let z2n_u = lookup_dist(z,n,false);
    if (z2n_u != NULL && *n2z_u == -(*z2n_u)) return $(true,*n2z_u);
  }
  return $(false,0xbad);
}

// If we have two nodes with representatives of the form Prim(p,[t11,...,tn1])
// and Prim(p,[t12,...,tn2]) and the sub-terms ti1 and ti2 map to equivalent
// nodes, then we should equate these two terms.  We're relying on the fact
// that the rows are sorted in term order so that leaves are processed before
// compound terms.
static bool congruence_close_graph(graph_t @g) {
  for (let rs = g->rows; rs != NULL; rs = rs->next) {
    switch (rs->rep) {
    case &Binop(p1,t11,t12,tp1):
      let n11 = term2node_opt(g,t11);
      let n12 = term2node_opt(g,t12);
      if (n11 == NULL || n12 == NULL) return false;
      // first see if t1 == c1 for some constant c1 
      let $(ok1,c1) = find_eq_const(g,n11);
      // if so, make t == c1 p t2
      if (ok1 && !add_eq(g,rs->rep,binop(p1,uint(c1),t12,tp1))) return false;
      // now do the same for t12
      let $(ok2,c2) = find_eq_const(g,n12);
      if (ok2 && !add_eq(g,rs->rep,binop(p1,t11,uint(c2),tp1))) return false;
      // if their both constants, we can add t == c1 p c2
      if (ok1 && ok2 && !add_eq(g,rs->rep,binop(p1,uint(c1),uint(c2),tp1))) 
        return false;
      // search for other binops that may be structurally equal
      for (let ts = rs->next; ts != NULL; ts = ts->next) {
        switch (ts->rep) {
        case &Binop(p2,t21,t22,_) && p1 == p2:
          let n12 = term2node_opt(g,t12);
          let n22 = term2node_opt(g,t22);
          if (n12 == NULL || n22 == NULL) return false;
          if (equal_nodes(n12,n22) && !add_eq(g,rs->rep,ts->rep)) return false;
          break;
        default: break;
        }
      }
      break;
    case &Unop(p1,t1,tp1):
      let n1 = term2node_opt(g,t1);
      if (n1 == NULL) return false;
      // first see if t1 == c1 for some constant c1 
      let $(ok1,c1) = find_eq_const(g,n1);
      // if so, make t == c1 p t2
      if (ok1 && !add_eq(g,rs->rep,unop(p1,uint(c1),tp1))) return false;
      // search for other unops that may be structurally equal
      for (let ts = rs->next; ts != NULL; ts = ts->next) {
        switch (ts->rep) {
        case &Unop(p2,t2,_) && p1 == p2:
          let n2 = term2node_opt(g,t2);
          if (n2 == NULL) return false;
          if (equal_nodes(n1,n2) && !add_eq(g,rs->rep,ts->rep)) return false;
          break;
        default: break;
        }
      }
      break;
    case &Cast(tp1,t1):
      let n1 = term2node_opt(g,t1);
      if (n1 == NULL) return false;
      // first see if t1 == c1 for some constant c1 
      let $(ok1,c1) = find_eq_const(g,n1);
      // if so, make t == c1 p t2
      if (ok1 && !add_eq(g,rs->rep,cast(tp1,uint(c1)))) return false;
      // search for other casts that may be structurally equal
      for (let ts = rs->next; ts != NULL; ts = ts->next) {
        switch (ts->rep) {
        case &Cast(tp2,t2):
          if (Tcutil::typecmp(tp1,tp2) == 0) {
            let n2 = term2node_opt(g,t2);
            if (n2 == NULL) return false;
            if (equal_nodes(n1,n2) && !add_eq(g,rs->rep,ts->rep)) return false;
          } 
          break;
        default: break;
        }
      }
      break;
    default: break;
    }
  }
  return true;
}

// run congruence closure on a set of graphs and weed out the disjuncts
static graph_t *congruence_close_graphs(graph_t *`H gs) {
  graph_t *prev = NULL;
  for (let g = gs; g != NULL; g = g->next) {
    if (!congruence_close_graph(g)) {
      if (prev == NULL) {
        gs = g->next;
      } else {
        prev->next = g->next;
      }
    } else {
      prev = g;
    }
  }
  return gs;
}

// convert a primitive assertion to a constraint and add it to the graph.
// returns true if the resulting graph remains consistent, false otherwise.
// This does not deal with equality constraints -- those should've already
// been eliminated.
static bool add_constraint(graph_t @g, term_t t1, prim_reln_t p, term_t t2) {
  switch $(t1,t2) {
  case $(&Uint(c1),&Uint(c2)):
    switch (p) {
    case ULt: return (c1 < c2);
    case ULte: return (c1 <= c2);
    case SLt: return ((int)c1) < ((int)c2);
    case SLte: return ((int)c1) <= ((int)c2);
    default: Tcutil::impos("Vcgen: found bad primop in add_constraint");
    }
  case $(_,&Uint(c2)):
    // we have t1 p c2 -- add constraints of the form t1 - Zero p c2
    switch (p) {
    case ULt: 
      //no unsigned integer t could satisfy t u< 0
      if (c2 == 0) return false;
      c2 = c2 - 1; 
      fallthru;
    case ULte:
      // must check that c2 can be represented by an int.
      if (c2 <= (unsigned)MAXINT) {
	if (!set_distance(g,t1,zero(),(int)c2,false)) return false;
	// since t1 U<= c2 U<= MAXINT, we know t1 S<= c2 as well!
	return set_distance(g,t1,zero(),(int)c2,true);
      } else {// t u<= c2, and (int)c2 s< 0
	int *c1 = lookup_dist(term2node(g, t1), term2node(g,zero()), true);
	if (c1 != NULL && *c1 <= -1){
	  return set_distance(g, t1, zero(), (int)c2, true);
	}
      }
      return true;
    case SLt: 
      //no signed integer t could satisfy t s< MININT
      if (c2 == MININT) return false;
      c2 = c2 - 1;
      fallthru;
    case SLte:
      // the value of (int)c2 should be representable by an integer.
      if (!set_distance(g,t1,zero(),(int)c2,true)) return false;
      if ((int)c2 > 0){
	// 0 - t s<= c1  impies t >= -c1
	int *c1 = lookup_dist(term2node(g,zero()), term2node(g,t1), true);
	if (c1 != NULL && *c1 <= 0) // then t >= -c1 >= 0, so t>=0
	  // 0 <= t s<= c2, then t u<= c2
	  return set_distance(g, t1, zero(), (int)c2, false);
      }
      return true;
    default: Tcutil::impos("Vcgen: found bad primop in add_constraint");
    }
  case $(&Uint(c1),_):
    // we have c1 p t2 -- add constraints of the form zero - t2 p -c1
    switch (p) {
    case ULt: 
      //no unsigned integer t could be greater than the biggest unsigned
      if (c1 == MAXUINT) return false;
      c1 = c1 + 1;
      fallthru;
    case ULte:
      //c1 u<= t2
      if (c1 > MAXINT) {
	//MAXINT u< c1 u<= t u<= MAXUINT, 
	// (int)c1 s<= t s<= -1
	if (!set_distance(g, t2, zero(), -1, true)) return false;
	int k = -((int)c1);
	if (k > 0){
	  if (!set_distance(g, zero(), t2, k, true)) return false;
	}
      }
      if (c1 <= MAXINT + 1u){
	//-c1 can be representable by a signed int
	int k = -((int)c1);
	return set_distance(g,zero(),t2,k,false);
      }
      return true;
    case SLt: 
      //no signed integer could be greater than the biggest signed int
      if (c1 == MAXINT) return false;
      c1 = c1 + 1;
      fallthru;
    case SLte:
      // MININT s<= t doesn't provide much information
      if (c1 == MININT) return true;
      else{
	int k = -((int)c1);
	if ((int)c1 >=0){
	  //0 s<= c1 s<= t2
	  if (!set_distance(g, zero(), t2, k, false)) return false;
	}
	return set_distance(g,zero(),t2,k,true);
      }
    default: Tcutil::impos("Vcgen: found bad primop in add_constraint");
    }
  default: break;
  }
  // nothing special about the terms -- have to add them as standard
  // sort of constraints.
  switch (p) {
  case ULt:
    // add t1 - t2 U<= -1
    return set_distance(g,t1,t2,-1,false);
  case ULte:
    // add t1 - t2 U<= 0
    return set_distance(g,t1,t2,0,false);
  case SLt:
    return set_distance(g,t1,t2,-1,true);
  case SLte: 
    // add t1 - t2 S<= 0
    return set_distance(g,t1,t2,0,true);
  default: Tcutil::impos("Vcgen:found bad primop in add_constraint");
  }
}

// we have t1 - t2 == c:  we can safely add
//     t1 ---c----> t2  to the signed edges.
// we can also add
//     t2 --(-c)--> t1  to the signed edges when c != MININT
// we can also add
//     t1 ---c----> t2  to the unsigned edges when c < MAXINT
// we can also add
//     t2 --(-c)--> t1  to the unsigned edges when c < MAXINT
static bool add_difference_const(graph_t @g, term_t t1, term_t t2, unsigned c){
  if (!set_distance(g, t1, t2, (int)c, true)) return false;
  if (c != (unsigned)MININT && !set_distance(g, t2, t1, -((int)c), true))
    return false;
  if (c < (unsigned)MAXINT && !set_distance(g, t1, t2, (int)c, false))
    return false;
  if (c < (unsigned)MAXINT && !set_distance(g, t2, t1, -((int)c), false))
    return false;
  return true;
}

// try to set t1 == t2
static bool add_eq(graph_t @g, term_t t1, term_t t2) {
  if (t1 == t2) return true;
  switch $(t1,t2) {
  case $(&Uint(c1),&Uint(c2)) && c1 != c2: return false;
  case $(&Binop(Absyn::Plus,t,&Uint(c1),_),&Uint(c2)): fallthru(c2,t,c1);
  case $(&Uint(c1),&Binop(Absyn::Plus,t,&Uint(c2),_)): 
    // we have c1 = t+c2   -- same as zero+c1 = t+c2
    fallthru(zero(),c1,t,c2);
  case $(&Binop(Absyn::Plus,ta,&Uint(c1),_),&Binop(Absyn::Plus,tb,&Uint(c2),_)):
    // we have ta+c1 == tb+c2  which simplifies to
    //         ta - tb = c2-c1
    // we have ta+c1 == tb+c2  -- simplify to ta == tb+c  where c == (c2-c1)
    return add_difference_const(g, ta, tb, c2-c1);
  case $(&Binop(Absyn::Minus,ta,tb,_),&Uint(c)): fallthru(c,ta,tb);
  case $(&Uint(c),&Binop(Absyn::Minus,ta,tb,_)):
    // we have ta - tb == c
    return add_difference_const(g, ta, tb, c);
  case $(t,&Uint(c)): fallthru(c,t);
  case $(&Uint(c),t): 
    // we have t == c which simplifies to t - zero == c
    return add_difference_const(g, t, zero(), c);
  default: 
    return 
      add_constraint(g, t1, ULte, t2) &&
      add_constraint(g, t2, ULte, t1) &&
      add_constraint(g, t1, SLte, t2) &&
      add_constraint(g, t2, SLte, t1);
  }
}

datatype exn { TooLarge };
datatype exn.TooLarge too_large = TooLarge;

//FIX: add a way for the user to control this.
unsigned int max_paths = 33;
unsigned int max_paths_seen = 0;

// given a set of graphs gs representing A1 or A2 or ... or An
// and given assertion a, compute the set of graphs representing
// (A1 or A2 ... or An) and a.  This is written with explicit
// tail-calls to be as fast as possible.  If we end up with two
// many disjuncts, then we throw an exception to back out of the
// whole thing.  
//
// JGM: what we should probably do is delay pushing in the Or nodes
// until we've gotten all of the And, Prim, True, and False nodes
// pushed into the graphs.  That way we're more likely to hit an
// inconsistency early.
static graph_t *cgraph(graph_t *`H gs, assn_t a) {
 LOOP:
  //fprintf(stderr,"inserting assertion %s into \n",assn2string(a));
  //print_graphs(gs);
  if (gs == NULL) return gs; // already inconsistent
  switch (a) {
  case &True: break;         // gs and true == gs
  case &False: gs = NULL; break; // gs and false == false
  case &And(a1,a2): 
    gs = cgraph(gs,a1);  // gs and (a1 and a2) == (gs and a1) and a2
    a = a2;
    goto LOOP;
  case &Or(a1,a2):
    unsigned int n = num_graphs(gs);
    if (max_paths_seen < n) max_paths_seen = n;
    // too many disjuncts -- give up.  
    if (n >= max_paths) {
      throw &too_large; // could just set gs = true_graph(); 
    }
    // must copy the graphs since we mutate them in place
    graph_t *gs1 = gs;
    graph_t *gs2 = copy_graphs(gs);
    // compute (gs and a1)
    gs1 = cgraph(gs1,a1);
    // try to weed out graphs through congruence closure
    gs1 = congruence_close_graphs(gs1);
    // compute (gs and a2)
    gs2 = cgraph(gs2,a2);
    // try to weed out graphs through congruence closure
    gs2 = congruence_close_graphs(gs2);
    // return (gs and a1) or (gs and a2)
    gs = graph_append(gs1,gs2);
    break;
  case &Prim(t1,Neq,t2): 
    // must handle neq specially as t1 < t2 or t2 < t1 (both signed
    // and unsigned.)
    a = and(or(slt(t1,t2),slt(t2,t1)),or(ult(t1,t2),ult(t2,t1)));
    goto LOOP;
    //case &Prim(t1,Eq,t2):
    // explode t1 == t2 into t1 <= t2 and t2 <= t1 (both signed and unsigned)
    //a = and(and(and(slte(t1,t2),slte(t2,t1)),ulte(t1,t2)),ulte(t2,t1));
    //goto LOOP;
  case &Prim(t1,p,t2):
    // add the primitive relation to each graph, pruning out the
    // inconsistent ones.
    graph_t *prev = NULL;
    for (let g = gs; g != NULL; g = g->next) {
      bool res;
      if (p == Eq) 
        res = add_eq(g,t1,t2);
      else
        res = add_constraint(g,t1,p,t2);
      if (!res) {
        if (prev == NULL) {
          gs = g->next;
        } else {
          prev->next = g->next;
        }
      } else {
        prev = g;
      }
    }
    //fprintf(stderr,"after inserting primitive assn %s, graphs are\n",
    //        assn2string(a));
    //print_graphs(gs);
    break;
  default: 
    // reduce any substitutions or negations and go around the loop.
    a = reduce(a);
    goto LOOP;
  }
  return gs;
}

// check to see if an assertion is consistent using the constraint solver.
// if it returns false, then the assertion is definitely inconsistent.
// if it returns true, then the assertion might be consistent.
static bool consistent(assn_t a) {
  try {
    // start with just an empty graph (true) and then add in assertion a
    graph_t *gs = cgraph(true_graph(),a);
    // run congruence closure to weed out graphs
    gs = congruence_close_graphs(gs);
    // if we get back an empty list of disjuncts (false) then
    // the graph is not consistent.
    //if (gs != NULL) {
    //  fprintf(stderr,"resulting graphs are:\n");
    //  print_graphs(gs);
    //}
    return (gs != NULL);
  } catch {
    // if the graph has too many paths in it, we'll end up here.
    // we must conservatively assume that the assertion is consistent.
  case &TooLarge: return true;
  }
}

// see if ctxt |- a by trying to prove that ctxt and not(a) is inconsistent.
bool constraint_prove(assn_t ctxt, assn_t a) {
  assn_t b = and(ctxt,not(a));
  //wangyl DEBUGGING:
  //fprintf(stderr, "##### trying to prove: ######\n");
  //fprintf(stderr, "%s ###=>### %s\n", assn2string(ctxt), assn2string(a));
  return !consistent(b);
}
