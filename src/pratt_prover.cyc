/* Pratt's Difference-Constraint Solving Algorithm for Assertions.
   Copyright (C) 2001 Greg Morrisett, Yanling Wang, AT&T
   This file is part of the Cyclone compiler.

   The Cyclone compiler is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   The Cyclone compiler is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with the Cyclone compiler; see the file COPYING. If not,
   write to the Free Software Foundation, Inc., 59 Temple Place -
   Suite 330, Boston, MA 02111-1307, USA. */
#include "assndef.h"
#include <list.h>

using AssnDef;
using List;

namespace PrattProver;

// FIX: 32-bit dependency!
#define MAXINT (0x7FFFFFFF)
#define MININT (-MAXINT-1)
#define MAXUINT (0xFFFFFFFF)


/**********************************************************************
This is a simple constraint solver that can (conservatibely) determine 
the unsatisfiability of a quantifier-free assertion, where the primitive
assertions involve signed and unsigned int terms and [in]equations.
The solver is based on Pratt's difference constraint algorithm, but
has been suitably adapted to deal with modular arithmetic.  

The algorithm that we use here is roughly as follows:

(1) We (conceptually) compute the DNF of an assertion A, yielding
    A1 || A2 || ... || An  where the Ai's are conjunctions of 
    primitive relations.  

(2) For each Ai, we build two distance graphs representing the signed and 
    unsigned distances between terms respectively.

(3) We then close the graph by computing the shortest path from each 
    term to another, and by performing congruence closure w.r.t. the 
    uninterpreted functions (e.g., numelts).  We also attempt to "break" 
    terms involving addition of a constant (e.t., x+3) by adding edges 
    x+3 ---(-3)---> x. However, we must be careful in doing this due to the
    issues described below.  We use the information in the graph to try to 
    prove that over/underflow cannot happen, in which case the edges are 
    safe to add.  
     
(4) Finally, if we detect a cycle in one of the graphs 
       t --c0--> t1 --c1--> t2 --c2--> ... --> tn --cn--> t
    and the sum of the ci's is negative, then we have a contradiction since 
    this would imply t - t < 0.  We can thus determine that Ai is false.

(5) If all of the graphs are found to be inconsistent, then we know A is false.

In practice, we incrementally convert the assertion to graphs and try to 
prune inconsistent graphs as early as possible.  This avoids building graphs 
proportional to the DNF which could be exponential in the size of A.
This conversion is done in an accumulator style, where we are threading 
through a list of graphs representing a disjunction.  That is, we compute 
A && (G1 || ... || Gn).  If A is a primitive relation or conjunction, we 
distribute it across all the graphs.  If A is a disjunction, (A1 || A2), 
then we clone the list of graphs and compute Ai && (G1 || ... || Gn) and 
A2 && (G1 || ... || Gn), appending the resulting lists of graphs that
remain consistent.

We currently perform the all-paths closure in a graph each time we add a 
primitive constraint.  We currently perform the other closure operations when 
we hit a disjunction (or at the end).  These allow us to prune graphs 
relatively frequently and thus keep the space overheads reasonable.  It is 
not clear how often we should do closure, since on the one hand, they are 
relatively expensive passes, but on the other hand, they help to eliminate 
whole graphs which not only saves space, but also avoids work down
the line.

The graphs are represented as sparse matrices with an implicit diagonal of 
0, and where non-existent entries represent infinite upper bounds on 
distance.  

Notes on invariants:
--------------------
Terms of type int or unsigned int represent machine words (i.e., values
in the range [0..2^32-1].)  Care must be taken when interpreting the
operations and the tests to avoid confusion with integers (Z).  For
example, t1 S<= t2 does not imply t1+1 S<= t2+1.  

We define u : Env -> Term -> Z and s : Env -> Term -> Z as interpretation 
functions mapping terms (of integral type) to integers as follows, where
Env : Var -> [0..2^32-1].

  u[Uint(i)]e = i
  u[Var(x)]e  = e(x)
  u[Binop(Plus,t1,t2,_)]e = (u[t1] + u[t2]) % 2^32
  u[Binop(Minus,t1,t2,_)]e = (u[t1] - u[t2]) % 2^32
  u[Binop(Times,t1,t2,_)]e = u[t1] * u[t2]) % 2^32

  s[t]e = u[t] - 2^31

Then the interpretations of the primitive relations U<=, S<=, and == 
are defined as:
    [t1 U<= t2]e iff u[t1]e <= u[t2]e
    [t1 S<= t2]e iff s[t1]e <= s[t2]e
    [t1 == t2]e  iff u[t1]e = u[t2]e

We will leave the environment e implicit in what follows.

Our graph tracks *mathematical* distances between terms.  
In particular, an unsigned edge t1 ---i---> t2  represents
the fact that u[t1] - u[t2] <= i and a signed edge 
t1 ---i---> t2 represents s[t1] - s[t2] <= i.  Note that
ideally, we would use an integer (bignum) to represent the distance i, 
but to save space and time, we only put edges in that can be 
represented by a machine int, at the loss of some completeness.
Furthermore, when propagating distance information, we must check 
for over or under flow.  

It is important to note that equalities and inequalities in the
assertions (which describe machine words, arithmetic, and relations)
do not directly translate to these distance edges.  For example,
suppose we have the assertion x - y == c.  It is tempting to
think we can add x --c--> y and y -(-c)-> x to the unsigned graph.
However, [x - y == c] does not imply y - x <= -c.  Picking x to be
1 and y to be 2, we have (1 - 2) % 2^32 = -1 % 2^32 = 2^32 - 1.
Yet while 1 - 2 <= 2^32-1, it is not the case that 2 - 1 <= 1 - 2^32.
In general, we can only add the y -(-c)-> x edge when x is truly
greater than y (and of course c and -c fit within an int.)

The functions break_term() and break_term_in_graph() encapsulate the 
logic necessary for determining when it is safe to add these edges.
Because they depend upon whether or not a term may overflow (or underflow), 
and this information may only become apparent later on (e.g., we discover 
that x is actually 5, so x-2 does not underflow) we must do the
term breaking as part of the closure process.
*/

//
// Forward declaration -- represents an equivalence class for terms
// (and also a row within a graph.)
struct Node;
typedef struct Node node_t;


// An entry in the sparse matrix -- records the target node of the
// edge and the distance as a (signed) integer.  It is important to
typedef struct Distance {
  struct Distance *next;
  node_t @target;
  int    dist;
} distance_t;


// Represents a row within a graph.
struct Node {
  node_t     *next; // next row in graph
  term_t      rep;  // term this node represents
  bool        broken_as_signed   : 1; // whether we have broken out any
  bool        broken_as_unsigned : 1; // constants (see below)
  distance_t *unsigned_distances;     // distance edges with this node's term
  distance_t *signed_distances;       // as the source
};

// A graph is essentially a pair of sparse matrices of 
// (node_t,node_t)->distance.  We represent the matrices by having
// a node row for each term.
typedef struct Graph {
  struct Graph *next;
  node_t       *rows;  // we keep the rows sorted by rep order
} graph_t;

static unsigned num_graphs(graph_t *gs) {
  unsigned c = 0;
  for (; gs != NULL; gs = gs->next)
    ++c;
  return c;
}

// An empty graph represents the proposition "true".
static graph_t@ true_graph() { return new Graph{NULL,NULL}; }

// Print out a graph.
void print_graph(graph_t @g) {
  fprintf(stderr,"{");
  if (g->rows == NULL) fprintf(stderr,"<true>");
  else {
    for (let rs = g->rows; rs != NULL; rs = rs->next) {
      let &Node{_,rep,_,_,uds,sds} = (node_t@)rs;
      for (; uds != NULL; uds = uds->next)
        fprintf(stderr,"%s - %s U<= %d\n ",term2string(rep),
                term2string(uds->target->rep),uds->dist);
      for (; sds != NULL; sds = sds->next) 
        fprintf(stderr,"%s - %s S<= %d\n ",term2string(rep),
                term2string(sds->target->rep),sds->dist);
    }
  }
  fprintf(stderr,"}\n");
}

// Print out a list of graphs.
void print_graphs(graph_t *g) {
  fprintf(stderr,"Graphs:-----------\n");
  if (g == NULL) fprintf(stderr,"<false>\n");
  else {
    for (; g != NULL; g = g->next) print_graph(g);
  }
  fprintf(stderr,"------------------\n");
}

// This exception is thrown when we discover that a graph is inconsistent.
datatype exn { Inconsistent };
datatype exn.Inconsistent inconsistent = Inconsistent;

// forward declarations
static node_t @term2node(graph_t @g, term_t t);
static void set_distance(graph_t @g, term_t s, term_t t, int dist, bool is_signed);
static void add_constraint(graph_t @g, term_t t1, prim_reln_t p, term_t t2);
static void add_eq(graph_t @g, term_t t1, term_t t2);
static $(bool,unsigned) term_is_const(graph_t @g, term_t t);

// Depending upon the type of a term, we can sometimes add extra
// information to a graph.  For instance, if t : int@{42} then we
// can add numelts(t) <= 42, and if t : tag_t<valueof(e)> then
// we can add t == e.  
static void add_type_info(graph_t @g, term_t term) {
  //for all terms t, we should know that:
  // s[t] - 0 <= MAXINT
  // 0 - u[t] <= 0
  set_distance(g,term,zero(),MAXINT,true);
  set_distance(g,zero(),term,0,false);
  switch (term) {
  case &Unop(Absyn::Numelts,x,_):
    // add term s< MAXINT and term u< MAXINT and 0 u<= term
    set_distance(g,term,zero(),MAXINT-1,true);
    set_distance(g,term,zero(),MAXINT-1,false);
    set_distance(g,zero(),term,0,false);
    break;
  default: break;
  }
  let topt = get_term_type(term);
  if (topt != NULL) {
    type_t t = (type_t)topt;
    let eopt = Tcutil::get_type_bound(t);
    if (eopt != NULL) {
      term_t t1 = unop(Absyn::Numelts,term,Absyn::uint_type);
      // sigh -- must get rid of a cast to int/long
      exp_t e = (exp_t)eopt;
    loop:
      switch (e->r) {
      case &Absyn::Cast_e(tp2,e2,...):
        switch (Absyn::compress(tp2)) {
        case &Absyn::AppType(&Absyn::IntCon(_,s),_):
          if (s == Absyn::Int_sz || s == Absyn::Long_sz) {
            e = e2; goto loop;
          }
          break;
        default: break;
        }
        break;
      default: break;
      }
      term_t t2 = cnst((exp_t)e);
      add_constraint(g,t2,ULte,t1);
      add_constraint(g,t2,SLte,t1);
    }
    switch (Absyn::compress(t)) {
    case &Absyn::AppType(&Absyn::IntCon(Absyn::Unsigned,_),_):
      add_constraint(g,zero(),ULte,term);
      break;
    case &Absyn::AppType(&Absyn::TagCon,&List{v,_}):
      switch (Absyn::compress(v)) {
      case &Absyn::ValueofType(e): add_eq(g,term,cnst(e)); break;
      case v2: 
        add_eq(g,term,cnst(Absyn::valueof_exp(v2,0)));
        break;
      }
      break;
    default: break;
    }
  }
}

// Given a term, look up its row and if not found, then add the term 
// to the graph.  Keep things sorted by term order.
static node_t @term2node(graph_t @g, term_t t) {
  // first see if we can find it directly.
  node_t *@prev = &g->rows;
  for (let r = g->rows; r != NULL; r = r->next) {
    int c = cmp_term(t,r->rep);
    if (c == 0) return r;
    if (c > 1) break;
    prev = &r->next;
  }
  // term not directly found -- insert it in the graph.  
  node_t @n;
  switch (t){
  case &Binop(Absyn::Plus,t1,&Uint(c2),_):
    n = new Node{*prev,t,false,false,NULL,NULL};
    break;
  default:
    n = new Node{*prev,t,true,true,NULL,NULL};
    break;
  }
  *prev = n;
  add_type_info(g,t);
  return n;
}

// Given a pair of nodes, look up their distance (if any) -- return
// NULL if no distance is found.  Special case when source and target
// are the same -- we always return a distance of zero.  Care should
// be taken not to update the zero!
static int *lookup_dist(node_t @`H source, node_t @`H target, bool is_signed) {
  static int zero = 0;
  if (source == target) return &zero;
  distance_t *ds = is_signed ? source->signed_distances : 
    source->unsigned_distances;
  for (; ds != NULL; ds = ds->next) 
    if (ds->target == target) return &ds->dist;
  return NULL;
}

// returns true iff t --0--> r and r --0--> t
// or else          r --c--> zero and zero --(-c)--> r and
//                  t --c--> zero and zero --(-c)--> t and
static bool eq_nodes(node_t @`H r, node_t @`H t, bool is_signed) {
  let rt_dist = lookup_dist(r,t,is_signed);
  let tr_dist = lookup_dist(t,r,is_signed);
  return (rt_dist != NULL && *rt_dist == 0 &&
          tr_dist != NULL && *tr_dist == 0);
}

static bool equal_nodes(node_t @`H s, node_t @`H r) {
  return eq_nodes(s,r,false) || eq_nodes(s,r,true);
}

static bool equal_terms(graph_t @g, term_t t1, term_t t2){
  let $(ok1,c1) = term_is_const(g,t1);
  let $(ok2,c2) = term_is_const(g,t2);
  if (ok1 && ok2 && c1 == c2) return true;
  let n1 = term2node(g,t1);
  let n2 = term2node(g,t2);
  if (equal_nodes(n1,n2)) return true;
  switch $(t1,t2){
  case $(&Unop(p11,t11,_),&Unop(p21,t21,_)) && p11 == p21:
    return equal_terms(g,t11,t21);
  case $(&Binop(p11,t11,t12,_),&Binop(p21,t21,t22,_)) && p11 == p21:
    return equal_terms(g,t11,t21) && equal_terms(g,t12,t22);
  case $(&Cast(tp1,t11),&Cast(tp2,t21)):
    return (Tcutil::typecmp(tp1,tp2) == 0 ) && equal_terms(g,t11,t21);
  default:
    return false;
  }
  return false;
}

// Append two lists of graphs, representing a disjunction
static graph_t *graph_append(graph_t *`H g1, graph_t *`H g2) {
  if (g1 == NULL) return g2;
  if (g2 == NULL) return g1;
  graph_t @p = g1;
  for (let x = p->next; x != NULL; p = x,x = p->next) /* skip */ ;
  p->next = g2;
  return g1;
}

//checking if the sum or difference of two signed integers overflowed
//assuming size of intger as sizeofint (32),assumming the highest bit
//as the sign bit.
#define sizeofint 32;
static $(bool, int) is_signed_overflow(int c1, int c2){
  int sum = c1 + c2;
  if ((~(c1 ^ c2) & (sum ^ c1)) >> 31){
    //overflow happened
    if (sum > 0) return $(true,-1); //an underflow
    else return $(true,1); //an overflow
  } 
  else return $(false,sum); //no overflow
}

// assumes source and target do not have a distance between them in the
// graph.  inserts a new distance reflecting source - target <= d.
static void new_distance(node_t @`H source, node_t @`H target, bool is_signed, int d) {
  let dist = new Distance{NULL,target,d};
  if (is_signed) {
    dist->next = source->signed_distances;
    source->signed_distances = dist;
  } else {
    dist->next = source->unsigned_distances;
    source->unsigned_distances = dist;
  }
}

// Tries to set the distance between two terms it and jt to dist, and
// update the shortest paths between any two nodes in the graph.  Returns
// normally iff the resulting graph is consistent with this new constraint,
// and throws Inconsistent otherwise.  
// Care must be taken when computing shortest paths to ensure that we
// don't end up with an overflow or underflow.
static void set_dist(graph_t @g, node_t @`H i, node_t @`H j, int dist, bool is_signed) {
  // equivalent terms are always at distance 0.
  if (i == j && dist < 0) throw(&inconsistent);
  if (i == j && dist > 0) return;
  let ij_dist = lookup_dist(i,j,is_signed);
  // if we already have a shorter parth, then this constraint is redundant
  if (ij_dist != NULL && *ij_dist < dist) return;
  let ji_dist = lookup_dist(j,i,is_signed);
  // if  j --n--> i --dist--> j  and n+dist is negative, contradiction.
  if (ji_dist != NULL) {
    let $(overflow,sum) = is_signed_overflow(*ji_dist,dist);
    if (sum < 0) throw(&inconsistent); // there is a negative loop 
  }
  for (let k = g->rows; k != NULL; k = k->next) {
    let ki_dist = lookup_dist(k,i,is_signed);
    if (ki_dist == NULL) continue; // no new path through ij
    for (let l = g->rows; l != NULL; l = l->next) {
      // skip nodes equal to k
      if (k == l) continue;
      let kl_dist = lookup_dist(k,l,is_signed);
      // if kl_dist is already MININT, no need to update.
      if (kl_dist != NULL && *kl_dist == MININT) continue;
      let jl_dist = lookup_dist(j,l,is_signed);
      if (jl_dist == NULL) continue; // no new path through i->j
      // computing w(kj) = w(ki) + w(ij)
      $(bool,int) final_sum;
      let $(of1,sum1) = is_signed_overflow(*ki_dist,dist);
      if (!of1) { // computing w(kl) = w(kj) + w(jl)
        final_sum = is_signed_overflow(sum1,*jl_dist);
      } else {
        // now we know that ki_dist, ij_dist have the same sign
        // that's the only way the sum can cause overflow
        let $(of1,sum1) = is_signed_overflow(*ki_dist,*jl_dist);
        if (!of1) {
          // FIX?  original code had sum here...
          final_sum = is_signed_overflow(sum1,dist);
        } else {
          // now we know that ki_dist, ij_dist, jl_dist have the same sign
          // that's the only way both of1's are true.  If dist < 0 then
          // it must be an underflow, and if > 0 it must be an overflow.
          final_sum = $(true,dist < 0 ? -1 : 1);
        }
      }
      let $(final_overflow,sum) = final_sum;
      // either there is no overflow in computing the sums, or there is
      // an underflow, so the true_sum < MININT
      if (!final_overflow) {
        // old k->l distance is infinite -- try adding a new edge.
        if (kl_dist == NULL) new_distance(k,l,is_signed,sum);
        // old k->l distance is greater than new dist -- update edge.
        else if (*kl_dist > sum) *kl_dist = sum;
      } else if (sum < 0) {//underflow happened
	if (kl_dist == NULL) new_distance(k,l,is_signed,MININT);
	else *kl_dist = MININT;
      }
    }
  }
}

// same as above but maps terms to nodes first.
static void set_distance(graph_t @g, term_t it, term_t jt, int dist, bool is_signed) {
  let i = term2node(g,it);
  let j = term2node(g,jt);
  set_dist(g,i,j,dist,is_signed);
}

// Used in copy_graphs below to copy a set of edges from one graph to another.
static distance_t *copy_distances(graph_t @newg, distance_t *ds) {
  distance_t *res = NULL;
  for (; ds != NULL; ds = ds->next) {
    let t = ds->target->rep;
    res = new Distance{res,term2node(newg,t),ds->dist};
  }
  return res;
}

// Reverse a list of nodes in place.
static node_t *revnodes(node_t *`H n) {
  if (n == NULL) return NULL;
  node_t *first = n;
  node_t *second = n->next;
  n->next = NULL;
  while (second != NULL) {
    node_t *temp = second->next;
    second->next = first;
    first = second;
    second = temp;
  }
  return first;
}

// Produce a copy of the list of graphs.
static graph_t *copy_graphs(graph_t *gopt) {
  if (gopt == NULL) return NULL;
  let g = (graph_t@)gopt;
  graph_t @newg = new Graph{.next = copy_graphs(g->next),.rows = NULL};
  // insert a row for each term
  node_t *newrs = NULL;
  for (let rs = g->rows; rs != NULL; rs = rs->next) {
    newrs = new Node{newrs,rs->rep,rs->broken_as_signed,
		     rs->broken_as_unsigned,NULL,NULL};
  }
  newrs = revnodes(newrs);
  newg->rows = newrs;
  // process each row again adding in distance edges
  for (let rs = g->rows; rs != NULL; rs = rs->next, newrs=newrs->next){
    newrs->unsigned_distances = copy_distances(newg,rs->unsigned_distances);
    newrs->signed_distances = copy_distances(newg,rs->unsigned_distances);
  }
  return newg;
}

// Applies f to each of the graphs in gs.  If f throws Inconsistent,
// then the graph is removed from the list gs (imperatively).  
// Returns the resulting list of graphs.
static graph_t *app_graphs(void (@f)(`env,graph_t @`H), `env e, graph_t *`H gs) {
  graph_t *prev = NULL;
  for (let g = gs; g != NULL; g = g->next) {
    try {
      f(e,g);
      prev = g;
    } catch {
    case &Inconsistent:
      if (prev == NULL) {
        gs = g->next;
      } else {
        prev->next = g->next;
      }
      break;
    }
  }
  return gs;
}

static bool is_relation(Absyn::primop_t p){
  switch (p){
  case Absyn::Gt:
  case Absyn::Lt:
  case Absyn::Gte:
  case Absyn::Lte: return true;
  default: return false;
  }
}

static unsigned eval_binop(Absyn::primop_t p, unsigned c1, unsigned c2){
  switch (p){
  case Absyn::Plus: return c1 + c2;
  case Absyn::Times: return c1 * c2;
  case Absyn::Minus: return c1 - c2;
  case Absyn::Div: return c1/c2;  /* FIX: c2 == 0? */
  case Absyn::Mod: return c1 % c2; /* FIX: c2 == 0? */
  case Absyn::Eq: return c1 == c2;
  case Absyn::Neq: return c1 != c2;
  case Absyn::Bitand: return c1 & c2;
  case Absyn::Bitor: return c1 | c2;
  case Absyn::Bitxor: return c1 ^ c2;
  case Absyn::Bitlshift: return c1 << c2;
  case Absyn::Bitlrshift: return c1 >> c2;
  default: Tcutil::impos(aprintf("Invalid binop %s during constant evaluation", Absynpp::prim2string(p)));
  }
  return 0;
}

static unsigned eval_unop(Absyn::primop_t p, unsigned c){
  switch (p){
  case Absyn::Not: return !c;
  case Absyn::Bitnot: return ~c;
  case Absyn::Plus: return c;
  case Absyn::Minus: return -c;
  default: Tcutil::impos(aprintf("Invalid unop %s during constant evaluation", Absynpp::prim2string(p)));
  }
  return 0;;
}
// when ok, the term t is equal to the value i in the graph g.
static $(bool ok, unsigned i) term_is_const(graph_t @g, term_t t) {
  switch(t){
  case &Uint(c): return $(true,c);
  case &Binop(Absyn::Plus,t1,t2,topt):
    let $(ok1,c1) = term_is_const(g,t1);
    if (ok1) add_eq(g,t,binop(Absyn::Plus,t2,uint(c1),topt));
    let $(ok2,c2) = term_is_const(g,t2);
    if (ok2) add_eq(g,t,binop(Absyn::Plus,t1,uint(c2),topt));
    break;
  case &Binop(p, t1, t2, topt):
    if (is_relation(p)) break;
    let $(ok1,c1) = term_is_const(g,t1);
    let $(ok2,c2) = term_is_const(g,t2);
    if (ok1 && ok2) add_eq(g,t,uint(eval_binop(p,c1,c2)));
    break;
  case &Unop(p, t1, topt):
    if (p == Absyn::Numelts) break;
    let $(ok1, c1) = term_is_const(g,t1);
    if (ok1) add_eq(g,t,uint(eval_unop(p,c1)));
    break;
  default: break;
  }
  let n = term2node(g,t);
  let z = term2node(g,zero());
  let n2z_s = lookup_dist(n,z,true);
  if (n2z_s != NULL) {
    let z2n_s = lookup_dist(z,n,true);
    if (z2n_s != NULL && *n2z_s == -(*z2n_s)) return $(true,*n2z_s);
  }
  let n2z_u = lookup_dist(n,z,false);
  if (n2z_u != NULL) {
    let z2n_u = lookup_dist(z,n,false);
    if (z2n_u != NULL && *n2z_u == -(*z2n_u)) return $(true,*n2z_u);
  }
  return $(false,0xbad);
}

// If we have two nodes with representatives of the form Prim(p,[t11,...,tn1])
// and Prim(p,[t12,...,tn2]) and the sub-terms ti1 and ti2 map to equivalent
// nodes, then we should equate these two terms.  We're relying on the fact
// that the rows are sorted in term order so that leaves are processed before
// compound terms.

// FIX: sub-terms might not be in the graph as node if they never occured
// in any comparisons. Do we want to add those sub-terms in?
static void congruence_close_graph(int dummy, graph_t @g) {
  for (let rs = g->rows; rs != NULL; rs = rs->next) {
    for (let ts = g->rows; ts != NULL; ts = ts->next){
      switch $(rs->rep,ts->rep){
      case $(&Binop(p1,t11,t12,_),&Binop(p2,t21,t22,_)) && p1 == p2:
        if (!equal_terms(g,t11,t21)) break;
        if (!equal_terms(g,t12,t22)) break;
        add_eq(g,rs->rep,ts->rep);
        break;
      case $(&Unop(p1,t1,_),&Unop(p2,t2,_)) && p1 == p2:
        if (!equal_terms(g,t1,t2)) break;
        add_eq(g,rs->rep,ts->rep);
        break;
      case $(&Cast(tp1,t1),&Cast(tp2,t2)):
        if (Tcutil::typecmp(tp1,tp2) == 0) {
          if (!equal_terms(g,t1,t2)) break;
          add_eq(g,rs->rep,ts->rep);
        }
        break;
      default: break;
      }
    }
  }
}

// run congruence closure on a set of graphs and weed out the disjuncts
static graph_t *congruence_close_graphs(graph_t *`H gs) {
  return app_graphs(congruence_close_graph,0,gs);
}


//find out if s[t] = s[t1+c2] =? s[t1] + c2
static $(bool, term_t, int) break_term(graph_t @g, term_t t, bool is_signed){
  switch (t){
  case &Binop(Absyn::Plus,t1,&Uint(c2),_):
    if ((int)c2 >= 0){
      // want to show that s[t1]+c2 not overflowing, i.e., s[t1] <= MAXINT-c2
      let dist = lookup_dist(term2node(g,t1),term2node(g,zero()),true);
      if (is_signed){
	if (dist != NULL && *dist <= MAXINT- (int)c2){
	  return $(true,t1,(int)c2);
	}
      } else {
	if (dist != NULL) return $(true,t1,(int)c2);
      }
    } else {// int(c2) < 0
      // want to show that s[t1]+c2 not underflowing, i.e., 0-s[t1] <= c2-MININT
      let dist = lookup_dist(term2node(g,zero()),term2node(g,t1),true);
      if (is_signed){
	if (dist != NULL && *dist <= (int)(c2-MININT)){
	  return $(true,t1,(int)c2);
	}
      } else {
	if (dist != NULL) return $(true,t1,(int)c2);
      }
    }
    break;
  default:
    break;
  }
  return $(false,t,0);  
}

static void break_term_in_graph(int dummy, graph_t @g){
  for(let rs = g->rows; rs != NULL; rs = rs->next){
    if (!rs->broken_as_signed){
      let $(ok,t1,c1) = break_term(g,rs->rep,true);
      if (ok){
	rs->broken_as_signed = true;
	set_distance(g,rs->rep,t1,c1,true);
	if ((unsigned)c1 != MININT)
	  set_distance(g,t1,rs->rep,-c1,true);
      }
    }
    if (!rs->broken_as_unsigned){
      let $(ok,t1,c1) = break_term(g,rs->rep,false);
      if (ok){
	rs->broken_as_unsigned = true;
	set_distance(g,rs->rep,t1,c1,false);
	if ((unsigned)c1 != MININT)
	  set_distance(g,t1,rs->rep,-c1,false);
      }
    }
    let $(ok,c1) = term_is_const(g,rs->rep);
    // we know that rs->rep == c, we try to solve subpart of rs->rep;
    if (ok){
      switch (rs->rep){
      case &Binop(Absyn::Plus,t1,&Uint(c2),_):
	rs->broken_as_signed = true;
	rs->broken_as_unsigned = true;
	add_eq(g,t1,uint(c1-c2));
	break;
      default:
	break;
      }
    }
  }
}

static graph_t *break_term_in_graphs(graph_t *`H gs){
  return app_graphs(break_term_in_graph, 0, gs);
}

// convert a primitive assertion to a constraint and add it to the graph.
// returns true if the resulting graph remains consistent, false otherwise.
// This does not deal with equality constraints -- those should've already
// been eliminated.
static void add_constraint(graph_t @g, term_t t1, prim_reln_t p, term_t t2) {
  switch $(t1,t2) {
  case $(&Uint(c1),&Uint(c2)):
    switch (p) {
    case ULt: if (c1 < c2) return; break;
    case ULte: if (c1 <= c2) return; break;
    case SLt: if (((int)c1) < ((int)c2)) return; break;
    case SLte: if (((int)c1) <= ((int)c2)) return; break;
    default: Tcutil::impos("Vcgen: found bad primop in add_constraint");
    }
    throw &inconsistent; 
  case $(_,&Uint(c2)):
    // we have t1 p c2 
    switch (p) {
    case ULt: 
      //no unsigned integer t could satisfy t u< 0
      if (c2 == 0) throw &inconsistent;
      c2 = c2 - 1; 
      fallthru;
    case ULte:
      // must check that c2 can be represented by an int.
      if (c2 <= MAXINT){
	// we know that  u[t1]-0 u< c2 and s[t1]-0 < c2
	set_distance(g,t1,zero(),(int)c2,false);
      }
      return;
    case SLt: 
      //no signed integer t could satisfy t s< MININT
      if (c2 == MININT) throw &inconsistent;
      c2 = c2 - 1;
      fallthru;
    case SLte:
      // the value of (int)c2 should be representable by an integer.
      set_distance(g,t1,zero(),(int)c2,true);
      return;
    default: Tcutil::impos("Vcgen: found bad primop in add_constraint");
    }
  case $(&Uint(c1),_):
    // we have c1 p t2
    switch (p) {
    case ULt: 
      //no unsigned integer t could be greater than the biggest unsigned
      if (c1 == MAXUINT) throw &inconsistent;
      c1 = c1 + 1;
      fallthru;
    case ULte:
      //u[c1] <= u[t2] => 0 - u[t2] <= -u[c1]
      if (c1 > MAXINT) {
	//-u[c1] can't be represented by an integer, but we know that
	//0-u[t2] <= -u[c1] <= MININT
	set_distance(g,zero(),t2,-MAXINT,false);
      }
      else { 
	//-u[c1] could be represented by an integer
	//0 - u[t2] <= -u[c1]
	set_distance(g,zero(),t2,-((int)c1),false);
      }
      return;
    case SLt: 
      //no signed integer could be greater than the biggest signed int
      if (c1 == MAXINT) throw &inconsistent;
      c1 = c1 + 1;
      fallthru;
    case SLte:
      // 0 - s[t2] <= -s[c1], -s[c1] could not represented by int
      // when c1 == MININT
      if (c1 == MININT) return;
      return set_distance(g,zero(),t2,-((int)c1),true);
    default: Tcutil::impos("Vcgen: found bad primop in add_constraint");
    }
  default: break;
  }
  // nothing special about the terms -- have to add them as standard
  // sort of constraints.
  switch (p) {
  case ULt:
    // u[t1] < u[t2] => u[t1] - u[t2] <= -1
    return set_distance(g,t1,t2,-1,false);
  case ULte:
    // u[t1] <= u[t2] => u[t1] - u[t2] <= 0
    return set_distance(g,t1,t2,0,false);
  case SLt:
    // s[t1] < s[t2] => s[t1] - s[t2] <= -1
    return set_distance(g,t1,t2,-1,true);
  case SLte: 
    // s[t1] <= s[t2] => s[t1] - s[t2] <= 0
    return set_distance(g,t1,t2,0,true);
  default: Tcutil::impos("Vcgen:found bad primop in add_constraint");
  }
}

// try to set t1 == t2
static void add_eq(graph_t @g, term_t t1, term_t t2) {
  if (t1 == t2) return;
  add_constraint(g,t1,ULte,t2);
  add_constraint(g,t2,ULte,t1);
  add_constraint(g,t1,SLte,t2);
  add_constraint(g,t2,SLte,t1);
}

static void add_prim($(term_t,prim_reln_t,term_t)@ p, graph_t @`H g) {
  let $(t1,p,t2) = *p;
  if (p == Eq) 
    add_eq(g,t1,t2);
  else
    add_constraint(g,t1,p,t2);
}

datatype exn { TooLarge };
datatype exn.TooLarge too_large = TooLarge;

//FIX: add a way for the user to control this.
unsigned int max_paths = 33;
unsigned int max_paths_seen = 0;

// given a set of graphs gs representing A1 or A2 or ... or An
// and given assertion a, compute the set of graphs representing
// (A1 or A2 ... or An) and a.  This is written with explicit
// tail-calls to be as fast as possible.  If we end up with two
// many disjuncts, then we throw an exception to back out of the
// whole thing.  
//
// JGM: what we should probably do is delay pushing in the Or nodes
// until we've gotten all of the And, Prim, True, and False nodes
// pushed into the graphs.  That way we're more likely to hit an
// inconsistency early.
static graph_t *cgraph(graph_t *`H gs, assn_t a) {
 LOOP:
  //fprintf(stderr,"inserting assertion %s into \n",assn2string(a));
  //print_graphs(gs);
  if (gs == NULL) return gs; // already inconsistent
  switch (a) {
  case &True: break;         // gs and true == gs
  case &False: gs = NULL; break; // gs and false == false
  case &And(a1,a2): 
    gs = cgraph(gs,a1);  // gs and (a1 and a2) == (gs and a1) and a2
    a = a2;
    goto LOOP;
  case &Or(a1,a2):
    unsigned int n = num_graphs(gs);
    if (max_paths_seen < n) max_paths_seen = n;
    // too many disjuncts -- give up.  
    if (n >= max_paths) {
      throw &too_large; // could just set gs = true_graph(); 
    }
    // must copy the graphs since we mutate them in place
    graph_t *gs1 = gs;
    graph_t *gs2 = copy_graphs(gs);
    // compute (gs and a1)
    gs1 = cgraph(gs1,a1);
    gs1 = break_term_in_graphs(gs1);
    // try to weed out graphs through congruence closure
    gs1 = congruence_close_graphs(gs1);
    // compute (gs and a2)
    gs2 = cgraph(gs2,a2);
    gs2 = break_term_in_graphs(gs2); 
    // try to weed out graphs through congruence closure
    gs2 = congruence_close_graphs(gs2);
    // return (gs and a1) or (gs and a2)
    gs = graph_append(gs1,gs2);
    break;
  case &Prim(t1,Neq,t2): 
    // must handle neq specially as t1 < t2 or t2 < t1 (both signed
    // and unsigned.)
    a = and(or(slt(t1,t2),slt(t2,t1)),or(ult(t1,t2),ult(t2,t1)));
    goto LOOP;
    //case &Prim(t1,Eq,t2):
    // explode t1 == t2 into t1 <= t2 and t2 <= t1 (both signed and unsigned)
    //a = and(and(and(slte(t1,t2),slte(t2,t1)),ulte(t1,t2)),ulte(t2,t1));
    //goto LOOP;
  case &Prim(t1,p,t2):
    // add the primitive relation to each graph, pruning out the
    // inconsistent ones.
    let env = $(t1,p,t2);
    gs = app_graphs(add_prim,&env,gs);
    //fprintf(stderr,"after inserting primitive assn %s, graphs are\n",
    //        assn2string(a));
    //print_graphs(gs);
    break;
  default: 
    // reduce any substitutions or negations and go around the loop.
    a = reduce(a);
    goto LOOP;
  }
  return gs;
}

// check to see if an assertion is consistent using the constraint solver.
// if it returns false, then the assertion is definitely inconsistent.
// if it returns true, then the assertion might be consistent.
static bool consistent(assn_t a) {
  try {
    // start with just an empty graph (true) and then add in assertion a
    graph_t *gs = cgraph(true_graph(),a);
    // run congruence closure to weed out graphs
    gs = congruence_close_graphs(gs);
    gs = break_term_in_graphs(gs);
    // if we get back an empty list of disjuncts (false) then
    // the graph is not consistent.
    return (gs != NULL);
  } catch {
    // if the graph has too many paths in it, we'll end up here.
    // we must conservatively assume that the assertion is consistent.
  case &TooLarge: return true;
  }
}

// see if ctxt |- a by trying to prove that ctxt and not(a) is inconsistent.
bool constraint_prove(assn_t ctxt, assn_t a) {
  assn_t b = and(ctxt,not(a));
  return !consistent(b);
}
