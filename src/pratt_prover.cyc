/* Pratt's Difference-Constraint Solving Algorithm for Assertions.
   Copyright (C) 2001 Greg Morrisett, Yanling Wang, AT&T
   This file is part of the Cyclone compiler.

   The Cyclone compiler is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   The Cyclone compiler is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with the Cyclone compiler; see the file COPYING. If not,
   write to the Free Software Foundation, Inc., 59 Temple Place -
   Suite 330, Boston, MA 02111-1307, USA. */
#include "assndef.h"
#include "tcutil.h"
#include "warn.h"
#include "absynpp.h"
#include "flags.h"
#include <hashtable.h>
#include <list.h>
#include <set.h>
#include <dict.h>
#include <xarray.h>

namespace Hashtable {
  extern `b*`r lookup_ptr_opt(table_t<`a,`b,`r> t, `a key);
}

using AssnDef;
using List;

namespace PrattProver;

// FIX: 32-bit dependency!
#define MAXINT (0x7FFFFFFF)
#define MININT (-MAXINT-1)
#define MAXUINT (0xFFFFFFFF)
//#define PROVER_DEBUG

/**********************************************************************
This is a simple constraint solver that can (conservatively) determine 
the unsatisfiability of a quantifier-free assertion, where the primitive
assertions involve signed and unsigned int terms and [in]equations.
The solver is based on Pratt's difference constraint algorithm, but
has been suitably adapted to deal with modular arithmetic.  

The algorithm that we use here is roughly as follows:

   (1) We (conceptually) compute the DNF of an assertion A, yielding
    A1 || A2 || ... || An  where the Ai's are conjunctions of 
    primitive relations.  

   (2) For each Ai, we build two distance graphs representing the difference
    between signed and unsigned terms.

   (3) We then close the graph by computing the shortest path from each 
    term to another, and by performing congruence closure w.r.t. the 
    uninterpreted functions (e.g., numelts).  We also attempt to "break"
    terms involving addition of a constant (e.t., x+3) by adding edges 
    x+3 ---(-3)---> x. However, we must be careful in doing this due to the
    issues described below.  We use the information in the graph to try to 
    prove that over/underflow cannot happen, in which case the edges are 
    safe to add.  
     
   (4) Finally, if we detect a cycle in one of the graphs 
       t --c0--> t1 --c1--> t2 --c2--> ... --> tn --cn--> t
    and the sum of the ci's is negative, then we have a contradiction since 
    this would imply t - t < 0.  We can thus determine that Ai is false.

   (5) If all of the graphs are found to be inconsistent, then we know A is false.

In practice, we incrementally convert the assertion to graphs and try to 
prune inconsistent graphs as early as possible.  This avoids building graphs 
proportional to the DNF which could be exponential in the size of A.
This conversion is done in an accumulator style, where we are threading 
through a list of graphs representing a disjunction.  That is, we compute 
A && (G1 || ... || Gn).  If A is a primitive relation or conjunction, we 
distribute it across all the graphs.  If A is a disjunction, (A1 || A2), 
then we clone the list of graphs and compute Ai && (G1 || ... || Gn) and 
A2 && (G1 || ... || Gn), appending the resulting lists of graphs that
remain consistent.

We currently perform the all-paths closure in a graph each time we add a 
primitive constraint.  We currently perform the other closure operations when 
we hit a disjunction (or at the end).  These allow us to prune graphs 
relatively frequently and thus keep the space overheads reasonable.  It is 
not clear how often we should do closure, since on the one hand, they are 
relatively expensive passes, but on the other hand, they help to eliminate 
whole graphs which not only saves space, but also avoids work down
the line.

The graphs are represented as sparse matrices with an implicit diagonal of 
0, and where non-existent entries represent infinite upper bounds on 
distance.  

Notes on invariants:
--------------------
Terms of type int or unsigned int represent machine words (i.e., values
in the range [0..2^32-1].)  Care must be taken when interpreting the
operations and the tests to avoid confusion with integers (Z).  For
example, t1 S<= t2 does not imply t1+1 S<= t2+1.  

We define u : Env -> Term -> Z and s : Env -> Term -> Z as interpretation 
functions mapping terms (of integral type) to integers as follows, where
Env : Var -> [0..2^32-1].

  u[Uint(i)]e = i
  u[Var(x)]e  = e(x)
  u[Binop(Plus,t1,t2,_)]e = (u[t1] + u[t2]) % 2^32
  u[Binop(Minus,t1,t2,_)]e = (u[t1] - u[t2]) % 2^32
  u[Binop(Times,t1,t2,_)]e = u[t1] * u[t2]) % 2^32

  s[t]e = u[t] - 2^31

Then the interpretations of the primitive relations U<=, S<=, and == 
are defined as:
    [t1 U<= t2]e iff u[t1]e <= u[t2]e
    [t1 S<= t2]e iff s[t1]e <= s[t2]e
    [t1 == t2]e  iff u[t1]e = u[t2]e

We will leave the environment e implicit in what follows.

Our graph tracks *mathematical* distances between terms.  
In particular, an unsigned edge t1 ---i---> t2  represents
the fact that u[t1] - u[t2] <= i and a signed edge 
t1 ---i---> t2 represents s[t1] - s[t2] <= i.  Note that
ideally, we would use an integer (bignum) to represent the distance i, 
but to save space and time, we only put edges in that can be 
represented by a machine int, at the loss of some completeness.
Furthermore, when propagating distance information, we must check 
for over or under flow.  

It is important to note that equalities and inequalities in the
assertions (which describe machine words, arithmetic, and relations)
do not directly translate to these distance edges.  For example,
suppose we have the assertion x - y == c.  It is tempting to
think we can add x --c--> y and y -(-c)-> x to the unsigned graph.
However, [x - y == c] does not imply y - x <= -c.  Picking x to be
1 and y to be 2, we have (1 - 2) % 2^32 = -1 % 2^32 = 2^32 - 1.
Yet while 1 - 2 <= 2^32-1, it is not the case that 2 - 1 <= 1 - 2^32.
In general, we can only add the y -(-c)-> x edge when x is truly
greater than y (and of course c and -c fit within an int.)

The functions break_term() and break_term_in_graph() encapsulate the 
logic necessary for determining when it is safe to add these edges.
Because they depend upon whether or not a term may overflow (or underflow), 
and this information may only become apparent later on (e.g., we discover 
that x is actually 5, so x-2 does not underflow) we must do the
term breaking as part of the closure process.
*********************************************************************/

//
// Forward declaration -- represents an equivalence class for terms
// (and also a row within a graph.)
struct Node;
typedef struct Node node_t;


// An entry in the sparse matrix -- records the target node of the
// edge and the distance as a (signed) integer.  It is important to
typedef struct Distance {
  struct Distance *next;
  node_t @target;
  int    dist;
} distance_t;


// shortest path information from some source s to this node
@tagged union ShortestPathInfo{
  int Infinity;  // the distance from s to this node is infinity, int unused
  int Shortest;  // the final shortest distance from s to this node
  int Current;   // the current distance from s to this node
};
typedef union ShortestPathInfo shortestpathinfo_t;
shortestpathinfo_t infinity = {.Infinity = 0};

// Represents a row within a graph.
struct Node {
  node_t     *next; // next row in graph
  term_t      rep;  // term this node represents
  bool        broken_as_signed   : 1; // whether we have broken out any
  bool        broken_as_unsigned : 1; // constants (see below)
  distance_t *unsigned_distances;     // distance edges with this node's term
  distance_t *signed_distances;       // as the source
  int signeddistFromS;                // used in the shortest path algorithms to record 
  int unsigneddistFromS;              // distance from the source S to this node
  shortestpathinfo_t shortest_path_info;
};

typedef Hashtable::table_t<term_t,node_t@> term_node_map_t;

// A graph is essentially a pair of sparse matrices of 
// (node_t,node_t)->distance.  We represent the matrices by having
// a node row for each term.
typedef struct Graph {
  struct Graph *next;
  node_t       *rows;  // we keep the rows sorted by rep order
  term_node_map_t map; // quick lookup of node for a term
  bool         changed;
} graph_t;

static unsigned num_graphs(graph_t *`H gs) {
  unsigned c = 0;
  for (; gs != NULL; gs = gs->next)
    ++c;
  return c;
}

static term_node_map_t empty_map(unsigned n) {
  return Hashtable::create(n,Core::ptrcmp,termhash);
  // Hashtable::create(n,termcmp,termhash);
}
  
// An empty graph represents the proposition "true".
static graph_t@ true_graph() { 
  return new Graph{NULL,NULL,empty_map(17),false}; 
}

static int constraints_added = 0;
static int graphs_copied = 0;
static int max_lookup = 0;
static int already_seen_hits = 0;

static void print_shortestpathinfo(shortestpathinfo_t info){
  switch (info){
  case {.Infinity=_}: 
    fprintf(stderr,"not reachable from s\n");
    break;
  case {.Shortest = d}: 
    fprintf(stderr,"shortest distance from s is %d\n",d);
    break;
  case {.Current = d}: 
    fprintf(stderr,"current distance from s is %d\n",d);  
    break;
  }
  return;
}
// Print out a graph.
void print_graph(graph_t @g) {
  fprintf(stderr,"{");
  if (g->rows == NULL) fprintf(stderr,"<true>");
  else {
    for (let rs = g->rows; rs != NULL; rs = rs->next) {
      let &Node{_,rep,_,_,uds,sds,_,_,_} = (node_t@)rs;
      let s = term2string(rep);
      fprintf(stderr,"row %s:",s);
      if (uds == NULL) fprintf(stderr,"\n");
      print_shortestpathinfo(rs->shortest_path_info);
      fprintf(stderr,"unsigned shortest dist from S: %d\n",
	      rs->unsigneddistFromS);
      fprintf(stderr,"signed shortest dist from S: %d\n",
	      rs->signeddistFromS);
      for (; uds != NULL; uds = uds->next)
        fprintf(stderr,"  %s - %s U<= %d\n ",s,
                term2string(uds->target->rep),uds->dist);
      for (; sds != NULL; sds = sds->next) 
        fprintf(stderr,"  %s - %s S<= %d\n ",s,
                term2string(sds->target->rep),sds->dist);
    }
  }
  fprintf(stderr,"}\n");
}

// Print out a list of graphs.
void print_graphs(graph_t *`H g) {
  fprintf(stderr,"Graphs:-----------\n");
  if (g == NULL) fprintf(stderr,"<false>\n");
  else {
    for (int i=0; g != NULL;i++, g = g->next){
      fprintf(stderr, "graph %d:\n",i);
      print_graph(g);
    }
  }
  fprintf(stderr,"------------------\n");
}

// This exception is thrown when we discover that a graph is inconsistent.
datatype exn { Inconsistent };
datatype exn.Inconsistent inconsistent = Inconsistent;

// forward declarations
static node_t @term2node(graph_t @`r g, term_t t);
static void set_distance(graph_t @g, term_t s, term_t t, unsigned dist, bool is_signed);
static void add_constraint(graph_t @g, term_t t1, prim_reln_t p, term_t t2);
static void add_eq(graph_t @g, term_t t1, term_t t2);
static $(bool,unsigned,term_opt_t) subst_term_with_const(graph_t @g, term_t t);
static int *lookup_dist(node_t @`H source, node_t @`H target, bool is_signed);

static exp_t strip_cast(exp_t e) {
 LOOP:
  switch (e->r) {
  case &Absyn::Cast_e(tp2,e2,...):
    switch (Absyn::compress(tp2)) {
    case &Absyn::AppType(&Absyn::IntCon(_,s),_):
      if (s == Absyn::Int_sz || s == Absyn::Long_sz) {
        e = e2; goto LOOP;
      }
      break;
    default: break;
    }
    break;
  default: break;
  }
  return e;
}

// Depending upon the type of a term, we can sometimes add extra
// information to a graph.  For instance, if t : int@{42} then we
// can add numelts(t) <= 42, and if t : tag_t<valueof(e)> then
// we can add t == e.  
static void add_type_info(graph_t @g, term_t term) {
  //for all terms t, we should know that:
  // s[t] - 0 <= MAXINT
  // 0 - u[t] <= 0
  let z = zero();
  set_distance(g,term,z,MAXINT,true);
  set_distance(g,z,term,0,false);
  switch (term) {
  case &Unop(Absyn::Numelts,x,_):
    // add term s< MAXINT and term u< MAXINT and 0 u<= term
    set_distance(g,term,z,MAXINT-1,false);
    // also add x as a node to pick up any constant bounds information
    term2node(g, x);
    break;
  case &Alloc(_,n,_,_):
    // an allocation node -- we know it's not null and that the numelts is n
    add_constraint(g,z,ULt,term); // not null
    add_constraint(g,numelts_term(term),ULte,n);
    break;
  case &Addr(vd,_):
    // the address of a variable -- we know it's not null
    add_constraint(g,z,ULt,term);
    break;
  default: break;
  }
  let topt = get_term_type(term);
  if (topt != NULL) {
    type_t t = (type_t)topt;
    let eopt = Tcutil::get_type_bound(t);
    if (eopt != NULL && Tcutil::is_const_exp((exp_t)eopt)) {
      term_t t1 = numelts_term(term);
      // sigh -- must get rid of a cast to int/long
      exp_t e = strip_cast((exp_t)eopt);
      term_t t2 = cnst((exp_t)e);
      // FIX -- if the term is a * type, then we need to say something
      // like ((term == 0) ==> numelts(term) == 0) && 
      //      ((term != 0) ==> numelts(term) <= t2)
      if (!Tcutil::is_nullable_pointer_type(t,false)) {
        add_constraint(g,t2,ULte,t1);
        add_constraint(g,t2,SLte,t1);
        add_constraint(g,z,ULt,term);
      }
    }
    switch (Absyn::compress(t)) {
    case &Absyn::AppType(&Absyn::IntCon(Absyn::Unsigned,_),_):
      add_constraint(g,z,ULte,term);
      break;
    case &Absyn::AppType(&Absyn::TagCon,&List{v,_}):
      switch (Absyn::compress(v)) {
      case &Absyn::ValueofType(e): add_eq(g,term,cnst(e)); break;
      case v2: 
        add_eq(g,term,cnst(Absyn::valueof_exp(v2,0)));
        break;
      }
      break;
    default: break;
    }
  }
}

// Given a term, look up its row and if not found, then add the term 
// to the graph.  Keep things sorted by term order.
static node_t @term2node(graph_t @`r g, term_t t) {
  // first see if we can find it directly.
  let nopt = Hashtable::lookup_ptr_opt(g->map, t);
  if (nopt != NULL) return *nopt;
  // couldn't find it -- insert it...
  node_t * @ `H+`r prev = &g->rows;
  for (let r = g->rows; r != NULL; r = r->next) {
    //++count;
    //if (count > max_lookup) max_lookup = count;
    node_t@ n = (node_t @)r;
    let rep = n->rep;
    let c = termcmp(t,rep);
    if (c > 1) break;
    if (c == 0) {
      Hashtable::insert(g->map,t,n);
      return n;
    }
    prev = &n->next;
  }
  node_t @n;
  switch (t){
  case &Binop(Absyn::Plus,t1,&Uint(c2,_),_):
    n = new Node{*prev,t,false,false,NULL,NULL,0,0,infinity};
    break;
  default:
    n = new Node{*prev,t,true,true,NULL,NULL,0,0,infinity};
    break;
  }
  Hashtable::insert(g->map,t,n);
  *prev = n;
  add_type_info(g,t);
  return n;
}

// Given a pair of nodes, look up their distance (if any) -- return
// NULL if no distance is found.  Special case when source and target
// are the same -- we always return a distance of zero.  Care should
// be taken not to update the zero!
static int *lookup_dist(node_t @`H source, node_t @`H target, bool is_signed) {
  static int zero = 0;
  if (source == target) return &zero;
  distance_t *ds = is_signed ? source->signed_distances : 
    source->unsigned_distances;
  for (; ds != NULL; ds = ds->next)
    if (ds->target == target) return &ds->dist;
  return NULL;
}

// returns true iff t --0--> r and r --0--> t
// or else          r --c--> zero and zero --(-c)--> r and
//                  t --c--> zero and zero --(-c)--> t and
static bool eq_nodes(node_t @`H r, node_t @`H t, bool is_signed) {
  if (r == t) return true;
  let rt_dist = lookup_dist(r,t,is_signed);
  let tr_dist = lookup_dist(t,r,is_signed);
  return (rt_dist != NULL && *rt_dist == 0 &&
          tr_dist != NULL && *tr_dist == 0);
}

static bool equal_nodes(node_t @`H s, node_t @`H r) {
  return eq_nodes(s,r,false) || eq_nodes(s,r,true);
}

static bool equal_terms(graph_t @g, term_t t1, term_t t2){
  if (t1 == t2) return true;
  let $(ok1,c1,_) = subst_term_with_const(g,t1);
  let $(ok2,c2,_) = subst_term_with_const(g,t2);
  if (ok1 && ok2 && c1 == c2) return true;
  let n1 = term2node(g,t1);
  let n2 = term2node(g,t2);
  if (equal_nodes(n1,n2)) return true;
  switch $(t1,t2){
  case $(&Unop(p11,t11,_),&Unop(p21,t21,_)) && p11 == p21:
    return equal_terms(g,t11,t21);
  case $(&Binop(p11,t11,t12,_),&Binop(p21,t21,t22,_)) && p11 == p21:
    return equal_terms(g,t11,t21) && equal_terms(g,t12,t22);
  case $(&Cast(tp1,t11),&Cast(tp2,t21)):
    return (Tcutil::typecmp(tp1,tp2) == 0 ) && equal_terms(g,t11,t21);
  case $(&Select(t11,t12,_),&Select(t21,t22,_)):
    return equal_terms(g,t11,t21) && equal_terms(g,t12,t22);
  case $(&Update(t11,t12,t13),&Update(t21,t22,t23)):
    return equal_terms(g,t11,t21) && 
      equal_terms(g,t12,t22) && equal_terms(g,t13,t23);
  case $(&Proj(t1,i1,_),&Proj(t2,i2,_)):
    return (i1 == i2) && equal_terms(g,t1,t2);
  case $(&AggrUpdate(t1,i1,v1),&AggrUpdate(t2,i2,v2)):
    return (i1 == i2) && equal_terms(g,t1,t2) && equal_terms(g,v1,v2);
  case $(&Aggr(is_union1,tag1,ts1,_),&Aggr(is_union2,tag2,ts2,_)):
    for (; ts1 != NULL && ts2 != NULL; ts1 = ts1->tl, ts2=ts2->tl)
      if (!equal_terms(g,ts1->hd,ts2->hd)) return false;
    return (tag1 == tag2 && is_union1 == is_union2);
  case $(&Tagof(t1),&Tagof(t2)):
    return equal_terms(g,t1,t2);
  default:
    return false;
  }
  return false;
}

// Append two lists of graphs, representing a disjunction
static graph_t *graph_append(graph_t *`H g1, graph_t *`H g2) {
  if (g1 == NULL) return g2;
  if (g2 == NULL) return g1;
  graph_t @p = g1;
  for (let x = p->next; x != NULL; p = x,x = p->next) /* skip */ ;
  p->next = g2;
  return g1;
}

//checking if the sum or difference of two signed integers overflowed
//assuming size of intger as sizeofint (32),assumming the highest bit
//as the sign bit.
#define sizeofint 32;
static inline $(bool, int) is_signed_overflow(int c1, int c2){
  int sum = c1 + c2;
  if ((~(c1 ^ c2) & (sum ^ c1)) >> 31){
    //overflow happened
    if (sum > 0) return $(true,-1); //an underflow
    else return $(true,1); //an overflow
  } 
  else return $(false,sum); //no overflow
}

// assumes source and target do not have a distance between them in the
// graph.  inserts a new distance reflecting source - target <= d.
static void new_distance(node_t @`H source, node_t @`H target, bool is_signed, int d) {
  let dist = new Distance{NULL,target,d};
  if (is_signed) {
    dist->next = source->signed_distances;
    source->signed_distances = dist;
  } else {
    dist->next = source->unsigned_distances;
    source->unsigned_distances = dist;
  }
}

// Tries to set the distance between two terms it and jt to dist, and
// update the shortest paths between any two nodes in the graph.  Returns
// normally iff the resulting graph is consistent with this new constraint,
// and throws Inconsistent otherwise.  
// Care must be taken when computing shortest paths to ensure that we
// don't end up with an overflow or underflow.
/***************************************************************************
static void set_dist(graph_t @g, node_t @`H i, node_t @`H j, int dist, bool is_signed) {
  // equivalent terms are always at distance 0.
  if (i == j && dist < 0) throw(&inconsistent);
  if (i == j && dist > 0) return;
  let ij_dist = lookup_dist(i,j,is_signed);
  // if we already have a shorter path, then this constraint is redundant
  if (ij_dist != NULL && *ij_dist < dist) return;
  let ji_dist = lookup_dist(j,i,is_signed);
  // if  j --n--> i --dist--> j  and n+dist is negative, contradiction.
  if (ji_dist != NULL) {
    let $(_,sum) = is_signed_overflow(*ji_dist,dist);
    if (sum < 0) throw(&inconsistent); // there is a negative loop 
  }
  for (let k = g->rows; k != NULL; k = k->next) {
    let ki_dist = lookup_dist(k,i,is_signed);
    if (ki_dist == NULL) continue; // no new path through ij
    let ds = is_signed ? j->signed_distances : j->unsigned_distances;
    // we're going to iterate through the j edges (ds), but must be sure
    // to include the "phantom" j->j edge.  So we sort of fake this out
    // for the first iteration of the loop.  See the CONTINUE label for
    // how we pull off the next target.  
    let l = j;
    static int z = 0;
    let jl_dist = &z;
    while (true) {
      {
      // skip nodes equal to k
      if (k == l) goto CONTINUE;
      let kl_dist = lookup_dist(k,l,is_signed);
      // if kl_dist is already MININT, no need to update.
      if (kl_dist != NULL && (unsigned)*kl_dist == MININT) goto CONTINUE;
      // computing w(kj) = w(ki) + w(ij)
      $(bool,int) final_sum;
      let $(of1,sum1) = is_signed_overflow(*ki_dist,dist);
      if (!of1) { // computing w(kl) = w(kj) + w(jl)
        final_sum = is_signed_overflow(sum1,*jl_dist);
      } else {
        // now we know that ki_dist, ij_dist have the same sign
        // that's the only way the sum can cause overflow
        let $(of1,sum1) = is_signed_overflow(*ki_dist,*jl_dist);
        if (!of1) {
          // FIX?  original code had sum here...
          final_sum = is_signed_overflow(sum1,dist);
        } else {
          // now we know that ki_dist, ij_dist, jl_dist have the same sign
          // that's the only way both of1's are true.  If dist < 0 then
          // it must be an underflow, and if > 0 it must be an overflow.
          final_sum = $(true,dist < 0 ? -1 : 1);
        }
      }
      let $(final_overflow,sum) = final_sum;
      // either there is no overflow in computing the sums, or there is
      // an underflow, so the true_sum < MININT
      if (!final_overflow) {
        // old k->l distance is infinite -- try adding a new edge.
        if (kl_dist == NULL) new_distance(k,l,is_signed,sum);
        // old k->l distance is greater than new dist -- update edge.
        else if (*kl_dist > sum) {
	  *kl_dist = sum;
	}
      } else if (sum < 0) {//underflow happened
	if (kl_dist == NULL) new_distance(k,l,is_signed,MININT);
	else {
	  *kl_dist = MININT;
	}
      }
      }
    CONTINUE:
      if (ds == NULL) break;
      l = ds->target;
      jl_dist = &ds->dist;
      ds = ds->next;
    }
  }
}
**********************************************************************/

static inline void set_dist(graph_t @g, node_t @`H i, node_t @`H j, int dist, bool is_signed) {
#ifdef PROVER_DEBUG
  fprintf(stderr,"adding %s dist: %s --> %s (%d)\n",
	  is_signed?"signed":"unsigned",
	  term2string(i->rep),term2string(j->rep),dist);
#endif  
  // equivalent terms are always at distance 0.
  if (i == j) {
    if (dist < 0 || (unsigned)dist == MININT) throw(&inconsistent);
    if (dist > 0) return;
  }
  let ij_dist = lookup_dist(i,j,is_signed);
  // if we already have a shorter path, then this constraint is redundant
  // otherwise, we update the weight for this edge if the edge existed
  // or add this new edge if the edge did not exist
  // we also set a mark saying that the graph changed
  // testing if the new edge weight will cause a negative cycle
  if (ij_dist != NULL) {
    if ((unsigned)*ij_dist == MININT) return;
    if ((unsigned)dist != MININT && *ij_dist < dist) return;
    *ij_dist = dist;
  } else {
    new_distance(i,j,is_signed,dist);
  }
  g->changed = true;
  let ji_dist = lookup_dist(j,i,is_signed);
  if(ji_dist != NULL){
    let $(overflow,sum)=is_signed_overflow(*ji_dist,dist);
      if (sum < 0) {
#ifdef PROVER_DEBUG
	fprintf(stderr,"inconsistency found in set_dist\n");
#endif
	throw &inconsistent;
      }
  }
  return;
}

// computing all pair shortest paths using the naive set dist
// algorithm we had before
/******************************************************************
static void naive_all_pair_shortest_paths(int dummy, graph_t @g){
#ifdef PROVER_DEBUG
  fprintf(stderr,"using naive algorithm to compute shortest path\n");
#endif
  int n = 0;
  for(let node = g->rows; node != NULL; node = node->next){
    n++;
  }
  for(int m = 0; m < n; m++){
    for(let node = g->rows; node != NULL; node = node->next){
      for(let dists = node->unsigned_distances; dists != NULL; dists = dists->next){
	for(let target_dists = dists->target->unsigned_distances; 
	    target_dists != NULL; target_dists = target_dists->next){
	  let $(overflow,sum) = is_signed_overflow(dists->dist,target_dists->dist);
	  if (!overflow)
	    set_dist(g,node,target_dists->target,sum,false);
	  else if (sum < 0) //underflow
	    set_dist(g,node,target_dists->target,MININT,false);
	}
      }
      for(let dists = node->signed_distances; dists != NULL; dists = dists->next){
	for(let target_dists = dists->target->signed_distances; 
	    target_dists != NULL; target_dists = target_dists->next){
	  let $(overflow,sum) = is_signed_overflow(dists->dist,target_dists->dist);
	  if (!overflow)
	    set_dist(g,node,target_dists->target,sum,true);
	  else if (sum < 0) //underflow
	    set_dist(g,node,target_dists->target,MININT,true);
	}
      }
    }
  }
  return;
}
********************************************************************/
static int num_of_nodes(graph_t @g){
  int n = 0;
  for(let node = g->rows; node != NULL; node = node->next){
    n++;
  }
  return n;
}

// Given a graph with negative weight, throws Inconsistent when
// the algorithm detects a negative weight cycle.
// the idea is to use bellman-ford algorithm for single-source
// shortest path algorithm.
// we add an extra node S to the graph, and add edges with weight 0
// from S to all the nodes in the graph.  then we compute the
// shortest path from S to all the nodes in the graph,
// if there is a negative cycle in the graph, it should be reachable
// from S and bellman-ford algorithm will be able to detect it
static void bellman_ford(int dummy,graph_t @g){
#ifdef PROVER_DEBUG
  fprintf(stderr,"bellman-ford algorithm\n");
#endif
  int n = num_of_nodes(g);
  // initialize the path weight from the added source (S)
  for(let node = g->rows; node != NULL; node = node->next){
    node->signeddistFromS = 0;
    node->unsigneddistFromS = 0;
  }
  
  // so the number of elements in the graph is n;
  // we are using bellman_ford algorithm
  for(let i = 0; i < n; i++){
    // the inner two loops traverse all the edges in the graph
    for(let node = g->rows; node != NULL; node = node->next){
      int du_unsigned = node->unsigneddistFromS;
      for(let dists = node->unsigned_distances; dists != NULL; dists = dists->next){
	int uv_unsigned = dists->dist;
	int dv_unsigned = dists->target->unsigneddistFromS;
	// dv_unsigned is already the smallest we can keep track of, 
	// so we won't make any progress here.
	if ((unsigned)dv_unsigned == MININT) continue;
	let $(overflow, sum) = is_signed_overflow(du_unsigned, uv_unsigned);
	// no overflow, and du+uv < dv, relax dv
	if (!overflow && (unsigned)dv_unsigned != MININT && sum < dv_unsigned) dists->target->unsigneddistFromS = sum;
	// underflow happened, du + uv <= MININT, 
	if (overflow && sum < 0) dists->target->unsigneddistFromS = MININT;
      }
      int du_signed = node->signeddistFromS;
      for(let dists = node->signed_distances; dists != NULL; dists = dists->next){
	int uv_signed = dists->dist;
	int dv_signed = dists->target->signeddistFromS;
	// dv_signed is already the smallest we can keep track of,
	// so we won't make any progress here.
	if ((unsigned)dv_signed == MININT) continue;
	let $(overflow, sum) = is_signed_overflow(du_signed, uv_signed);
	// no overflow, and du+uv < dv, relax dv
	if (!overflow && (unsigned)dv_signed != MININT && sum < dv_signed) dists->target->signeddistFromS = sum;
	// underflow happened, du + uv <= MININT, 
	if (overflow && sum < 0) dists->target->signeddistFromS = MININT;
      }
    }
  }
  // now we have computed the shortest path from S to u
  // in the graph with at most n+1 nodes
  // if this is still not the shortest path from S to u
  // then there is a negative cycle reachable from S
  for(let node = g->rows; node != NULL; node = node->next){
    int du_unsigned = node->unsigneddistFromS;
    for(let dists = node->unsigned_distances; dists != NULL; dists = dists->next){
      int uv_unsigned = dists->dist;
      int dv_unsigned = dists->target->unsigneddistFromS;
      // dv_unsigned is already the smallest we can keep track of, 
      // so we do not conclude inconsistency here.
      if ((unsigned)dv_unsigned == MININT) continue; 
      let $(overflow, sum) = is_signed_overflow(du_unsigned,uv_unsigned);
      // there is a shorter path
      if (!overflow && sum < dv_unsigned || overflow && sum < 0){
#ifdef PROVER_DEBUG
	fprintf(stderr,"inconsistency found in bellman-ford\n");
#endif
	throw &inconsistent;
      }
    }
    int du_signed = node->signeddistFromS;
    for(let dists = node->signed_distances; dists != NULL; dists = dists->next){
      int uv_signed = dists->dist;
      int dv_signed = dists->target->signeddistFromS;
      // dv_signed is already the smallest we can keep track of,
      // so we do not conclude inconsistency here.
      if ((unsigned)dv_signed == MININT) continue;
      let $(overflow, sum) = is_signed_overflow(du_signed, uv_signed);
      if (!overflow && sum < dv_signed || overflow && sum<0){
#ifdef PROVER_DEBUG
	fprintf(stderr,"inconsistency found in bellman-ford\n");
#endif
	throw &inconsistent;
      }
    }
  }
  return;
}


// initialize the distant set from source s for dijkstra algorithm
// everything is unreachable from s except s itself.
static void initialize_dist_set(node_t @s, graph_t @g){
  for(let node = g->rows; node != NULL; node = node->next){
    if (node == s) node->shortest_path_info = ShortestPathInfo{.Current = 0};
    else node->shortest_path_info = infinity;
  }
  return;
}


// find the node with the smallest shortest distance
// ignore those nodes that are already removed from 
// the set with a final shortest path
// if there is no more available nodes with a finite distance
// return NULL
static node_t * extract_min(graph_t @g){
  node_t *current_shortest_node = NULL;
  for(let node = g->rows; node != NULL; node = node->next){
    switch (node->shortest_path_info){
    case {.Infinity = _}: break;
    case {.Shortest = _}: break;
    case {.Current = d_new}: 
      if (current_shortest_node == NULL) current_shortest_node = node;
      else {
	switch (current_shortest_node->shortest_path_info){
	case {.Current = d_old}:
	  if (d_new <= d_old) current_shortest_node = node;
	  break;
	default:
	  Warn::impos(aprintf("current_shortest_node should always be NULL or &Current(d)\n"));
	}
      }
      break;
    }
  }
  return current_shortest_node;
}

static void relaxation(node_t @u, graph_t @g, bool is_signed){
  distance_t *dists;
  int su;
  switch(u->shortest_path_info){
  case {.Shortest = d}: su = d; break;
  default:
    Warn::impos(aprintf("current_shortest_node should always containe &Shortest(d)\n"));
    break;
  }
  if (is_signed) dists = u->signed_distances;
  else dists = u->unsigned_distances;
  for(; dists != NULL; dists = dists->next){
    switch (dists->target->shortest_path_info){
    case {.Shortest = _}: break; // already has the final shortest path, no action
    case {.Current = sv}: 
      int uv = dists->dist;
      let $(overflow,sum) = is_signed_overflow(su,uv);
      if (!overflow && sum < sv) dists->target->shortest_path_info = ShortestPathInfo{.Current = sum};
      break;
    case {.Infinity = _}:
      int uv = dists->dist;
      let $(overflow,sum) = is_signed_overflow(su,uv);
      if (!overflow) dists->target->shortest_path_info = ShortestPathInfo{.Current = sum};
      break;
    }
  }
  return;
}

// we finished computing the shortest distance from s to all nodes,
// d(s,v) is stored in v->shortest_path_info
// now we put this information into the s->dist
static void set_shortest_dist_from_s(node_t @`H s, graph_t @`H g, bool is_signed){
  for(let node = g->rows; node != NULL; node = node->next){
    switch (node->shortest_path_info){
    case {.Shortest = d}: set_dist(g,s,node,d,is_signed); break;
    default: break;
    }
  }
}
// compute single-source shortest path from s to
// all nodes in a graph g with no negative weight edges
static void dijkstra(node_t @`H s, graph_t @`H g){
#ifdef PROVER_DEBUG
  fprintf(stderr,"dijkstra algorithm\n");
#endif  

  // first compute the shortest unsigned distance from s to all other vertices
  initialize_dist_set(s,g);
  while(true){
    let current_shortest_node = extract_min(g);
    // no more nodes reachable from source, can and the algorithm
    if (current_shortest_node == NULL) break;
    else {
      switch(current_shortest_node->shortest_path_info){
      case {.Current = d}: 
	// extracted the min, now set the node info to Done
	current_shortest_node->shortest_path_info = ShortestPathInfo{.Shortest = d};
	break;
      default:
	Warn::impos(aprintf("current_shortest_node should always contain &Current(d)\n"));
	break;
      }
    }
    relaxation(current_shortest_node,g,false);
  }
  set_shortest_dist_from_s(s,g,false);

  // then compute the shortest signed distance from s to all other vertices
  initialize_dist_set(s,g);
  while(true){
    let current_shortest_node = extract_min(g);
    // no more nodes reachable from source, can and the algorithm
    if (current_shortest_node == NULL) break;
    else {
      switch(current_shortest_node->shortest_path_info){
      case {.Current = d}: 
	// extracted the min, now set the node info to Done
	current_shortest_node->shortest_path_info = ShortestPathInfo{.Shortest = d};
	break;
      default:
	Warn::impos(aprintf("current_shortest_node should always contain &Current(d)\n"));
	break;
      }
    }
    relaxation(current_shortest_node,g,true);
  }
  set_shortest_dist_from_s(s,g,true);
  return;
}

// compute all-pair shortest paths for a graph with negative weight
// 1) calls bellman-ford to see if there is any negative cycle
// 2) change the weight of all edges so that they are nonegative
// 3) calls dijkstra for each vertex to compute all-pair shortest paths
// 4) change the weight back so that the represent the original
//    weight value
// see Corman90 26.3 Johnson's algorithm
static void johnson(int dummy, graph_t @`H g){
#ifdef PROVER_DEBUG
  fprintf(stderr,"johnson algorithm\n");
#endif
  // there is no new edges added to the graph since
  // the last shortest path computation
  if (!g->changed) return;
  // bellman ford to test if there is any negative weight cycle 
  // could really omit this step because we've already run bellman_ford before
  // calling johnson
#ifdef PROVER_DEBUG
  fprintf(stderr,"******************* run bellman_ford****************\n");
  print_graph(g);
#endif
  bellman_ford(0,g); 
#ifdef PROVER_DEBUG
  fprintf(stderr,"******************* done bellman_ford****************\n");
  print_graph(g);
#endif
  // no inconsistency thrown so there is no negative weight cycle
  // reweighs all the edges in the garph to make their weight nonnegative
  for(let node = g->rows; node != NULL; node = node->next){
    int du_unsigned = node->unsigneddistFromS;
    distance_t *pre_dists, *dists;
    for(pre_dists = NULL, dists = node->unsigned_distances;
	dists != NULL; pre_dists = dists,dists = dists->next){
      int uv_unsigned = dists->dist;
      int dv_unsigned = dists->target->unsigneddistFromS;
      // since after bellmanford, dx_unsigned is the shortest path,
      // so uv_unsigned + du_unsigned >= dv_unsigned
      // this ensures the new weight to be non negative
      dists->dist = uv_unsigned + du_unsigned - dv_unsigned;
      // overflow happens, the weight is too big
      if (dists->dist < 0) {
	// the weight is too big to be represented as signed int,
	// we have to remove the edge. 
	if (pre_dists == NULL) 
	  node->unsigned_distances = dists->next;
	else
	  pre_dists->next = dists->next;
      }
    }
    int du_signed = node->signeddistFromS;
    for(pre_dists = NULL, dists = node->signed_distances; 
	dists != NULL; pre_dists = dists, dists = dists->next){
      int uv_signed = dists->dist;
      int dv_signed = dists->target->signeddistFromS;
      // same argument as for the unsigned weight
      dists->dist = uv_signed + du_signed - dv_signed;
      // overflow happens, the weight is too big
      if (dists->dist < 0) {
	dists->dist = 0;
	if (pre_dists == NULL) 
	  node->signed_distances = dists->next;
	else
	  pre_dists->next = dists->next;
      }

    }
  }
#ifdef PROVER_DEBUG
  fprintf(stderr,"*************adjusted weight****************\n");
  print_graphs(g);
#endif
  
  // now for each vertex, we run dijkstra to calculate shortest path
  // this is OK because now all weights are nonnegative
  for(let node = g->rows; node != NULL; node = node->next){
    dijkstra(node,g);
  }
#ifdef PROVER_DEBUG
  fprintf(stderr,"*************done dijkstra****************\n");
  print_graphs(g);
#endif
  
  // now recover the original weight (possibily negative) for
  // distance between two vertices
  for(let node = g->rows; node != NULL; node = node->next){
    int du_unsigned = node->unsigneddistFromS;
    for(let dists = node->unsigned_distances; dists != NULL; dists = dists->next){
      int uv_unsigned = dists->dist;
      int dv_unsigned = dists->target->unsigneddistFromS;
      dists->dist = uv_unsigned + dv_unsigned - du_unsigned;
    }
    int du_signed = node->signeddistFromS;
    for(let dists = node->signed_distances; dists != NULL; dists = dists->next){
      int uv_signed = dists->dist;
      int dv_signed = dists->target->signeddistFromS;
      // same argument as for the unsigned weight
      dists->dist = uv_signed + dv_signed - du_signed;
    }
  }

#ifdef PROVER_DEBUG
  fprintf(stderr,"no inconsistency from johnson\n");
#endif
  return;
}
// same as above but maps terms to nodes first.
static void set_distance(graph_t @g, term_t it, term_t jt, unsigned dist, bool is_signed) {
  let i = term2node(g,it);
  let j = term2node(g,jt);
  set_dist(g,i,j,dist,is_signed);
}

// Used in copy_graphs below to copy a set of edges from one graph to another.
static distance_t *copy_distances(graph_t @newg, distance_t *`r _ds) {
  distance_t *res = NULL;
  distance_t *`r+`H ds = _ds;
  for (; ds != NULL; ds = ds->next) {
    let t = ds->target->rep;
    res = new Distance{res,term2node(newg,t),ds->dist};
  }
  return res;
}

// Reverse a list of nodes in place.
static node_t *revnodes(node_t *`H n) {
  if (n == NULL) return NULL;
  node_t *first = n;
  node_t *second = n->next;
  n->next = NULL;
  while (second != NULL) {
    node_t *temp = second->next;
    second->next = first;
    first = second;
    second = temp;
  }
  return first;
}

// Produce a copy of the list of graphs.
static graph_t *copy_graphs(graph_t *`r _gopt) {
  graph_t *res = NULL;
  graph_t *`r+`H gopt = _gopt;
  for (; gopt != NULL; gopt = gopt->next) {
    ++graphs_copied;
    let g = (graph_t@)gopt;
    //let b = Hashtable::num_buckets(g->map);
    graph_t @newg = new Graph{.next = res,.rows = NULL,.map=empty_map(17),
                              .changed=g->changed};
    res = newg;
    // insert a row for each term
    node_t *newrs = NULL;
    for (let rs = g->rows; rs != NULL; rs = rs->next) {
      newrs = new Node{newrs,rs->rep,rs->broken_as_signed,
                       rs->broken_as_unsigned,NULL,NULL,0,0,infinity};
      Hashtable::insert(newg->map,rs->rep,newrs);
    }
    newrs = revnodes(newrs);
    newg->rows = newrs;
    // process each row again adding in distance edges
    for (let rs = g->rows; rs != NULL; rs = rs->next, newrs=newrs->next){
      newrs->unsigned_distances = copy_distances(newg,rs->unsigned_distances);
      newrs->signed_distances = copy_distances(newg,rs->unsigned_distances);
    }
  }
  return res;
}

// used to control iteration
static bool graphs_change = false;

// Applies f to each of the graphs in gs.  If f throws Inconsistent,
// then the graph is removed from the list gs (imperatively).  
// Returns the resulting list of graphs.
static graph_t *app_graphs(void (@f)(`env,graph_t @`H), `env e, graph_t *`H gs) {
  graph_t *prev = NULL;
  for (let g = gs; g != NULL; g = g->next) {
    try {
      f(e,g);
      prev = g;
    } catch {
    case &Inconsistent:
      graphs_change = true;
      if (prev == NULL) {
        gs = g->next;
      } else {
        prev->next = g->next;
      }
      break;
    }
  }
  return gs;
}

static bool is_relation(Absyn::primop_t p){
  switch (p){
  case Absyn::Gt:
  case Absyn::Lt:
  case Absyn::Gte:
  case Absyn::Lte: return true;
  default: return false;
  }
}

static unsigned eval_binop(Absyn::primop_t p, unsigned c1, unsigned c2){
  // wangyl: FIX??  here we are assuming that all operations are performed
  // on 32 bit words, and their type (whether sighed/unsigned) would not
  // change the result of the operation.
  switch (p){
  case Absyn::Plus: return c1 + c2;
  case Absyn::Times: return c1 * c2;
  case Absyn::Minus: return c1 - c2;
  case Absyn::Div: return c1/c2;  /* FIX: c2 == 0? */
  case Absyn::Mod: return c1 % c2; /* FIX: c2 == 0? */
  case Absyn::Eq: return c1 == c2;
  case Absyn::Neq: return c1 != c2;
  case Absyn::Bitand: return c1 & c2;
  case Absyn::Bitor: return c1 | c2;
  case Absyn::Bitxor: return c1 ^ c2;
  case Absyn::Bitlshift: return c1 << c2;
  case Absyn::Bitlrshift: return c1 >> c2;
  default: Warn::impos(aprintf("Invalid binop %s during constant evaluation", Absynpp::prim2string(p)));
  }
  return 0;
}

static unsigned eval_unop(Absyn::primop_t p, unsigned c){
  switch (p){
  case Absyn::Not: return !c;
  case Absyn::Bitnot: return ~c;
  case Absyn::Plus: return c;
  case Absyn::Minus: return -c;
  default: Warn::impos(aprintf("Invalid unop %s during constant evaluation", Absynpp::prim2string(p)));
  }
  return 0;
}

static $(bool, unsigned int) eq_node_const(node_t @`H n, node_t @`H z, bool is_signed){
  let n2z = lookup_dist(n,z,is_signed);
  let z2n = lookup_dist(z,n,is_signed);
  if (n2z != NULL && z2n != NULL && *z2n == *n2z) return $(true, *n2z);
  return $(false,0xBAD);
}

// return $(true,c) if n -- c --> z and z -- (-c) --> n
// where either both edges are unsigned or both are signed
static $(bool, unsigned int) equal_node_const(node_t @`H n, node_t @`H z){
  let $(ok, c) = eq_node_const(n,z,true);
  if (!ok) return eq_node_const(n,z,false);
  else return $(ok,c);
}

// when ok, the term t is equal to the value i in the graph g.
static $(bool, unsigned,term_opt_t) subst_term_with_const(graph_t @g, term_t t) {
  term_opt_t newterm = NULL;
  switch(t){
  case &Uint(c,_): return $(true,c,NULL);
  case &Binop(p,t1,t2,topt):
    // wangyl: for relations, since we are not keeping track of 
    // whether we are comparing between signed or unsigned here
    // so we can't actually evaluate it correctly
    if (is_relation(p)) break;
    let $(ok1,c1,nt1) = subst_term_with_const(g,t1);
    let $(ok2,c2,nt2) = subst_term_with_const(g,t2);
    // t1(or t2) was partially substituted with constant 
    // and is equivalent to a new term.
    if (nt1 != NULL){
      newterm = binop(p,nt1,t2,topt);
      add_eq(g,t,newterm);
    }
    if (nt2 != NULL){
      newterm = binop(p,t1,nt2,topt);
      add_eq(g,t,newterm);
    }
    if (ok1) {
      newterm = binop(p,uint(c1),t2,topt);
      add_eq(g,t,newterm);
    }
    if (ok2) {
      newterm = binop(p,t1,uint(c2),topt);
      add_eq(g,t,newterm);
    }
    if (ok1 && ok2) {
      return $(true,eval_binop(p,c1,c2),NULL);
    }
    break;
  case &Unop(p,t1,topt):
    if (p == Absyn::Numelts) break;
    let $(ok1,c1,_) = subst_term_with_const(g,t1);
    if (ok1) {
      add_eq(g,t,uint(eval_unop(p,c1)));
      return $(true,eval_unop(p,c1),NULL);
    }
    break;
  default: break;
  }
  if (t == newterm) newterm = NULL;
  let n_node = term2node(g,t);
  let z_node = term2node(g,zero());
  let $(ok, c) = equal_node_const(n_node,z_node);
  if (ok) return $(true,c,newterm);
  return $(false,0xbad,newterm);
}

// JGM: this is just too expensive to run this naively, so I'm
// not using it now.  
static void congruence_close_graph(int dummy, graph_t @g) {
  for (let rs = g->rows; rs != NULL; rs = rs->next) {
    let t = rs->rep;
    switch (t) {
    case &Unop(p,t1,type):
      let t1node = term2node(g,t1);
      for (let ts = g->rows; ts != NULL; ts = ts->next)
        if (t1node != ts && equal_nodes(ts,t1node)) 
          add_eq(g,t,unop(p,ts->rep,type));
      break;
    case &Proj(t1,i,type):
      let t1node = term2node(g,t1);
      for (let ts = g->rows; ts != NULL; ts = ts->next)
        if (t1node != ts && equal_nodes(ts,t1node)) 
          add_eq(g,t,proj(ts->rep,i,type));
      break;
    case &Binop(p,t1,t2,type):
      // FIX:  really ought to have an inner loop to get all combinations
      // of terms in the graph...
      let t1node = term2node(g,t1);
      let t2node = term2node(g,t2);
      for (let ts = g->rows; ts != NULL; ts = ts->next) {
        if (t1node != ts && equal_nodes(ts,t1node)) 
          add_eq(g,t,binop(p,ts->rep,t2,type));
        if (t2node != ts && equal_nodes(ts,t2node))
          add_eq(g,t,binop(p,t1,ts->rep,type));
      }
      break;
    case &Select(t1,t2,type):
      // FIX:  really ought to have an inner loop to get all combinations
      // of terms in the graph...
      let t1node = term2node(g,t1);
      let t2node = term2node(g,t2);
      for (let ts = g->rows; ts != NULL; ts = ts->next) {
        if (t1node != ts && equal_nodes(ts,t1node)) 
          add_eq(g,t,select(ts->rep,t2,type));
        if (t2node != ts && equal_nodes(ts,t2node))
          add_eq(g,t,select(t1,ts->rep,type));
      }
      break;
    case &Update(t1,t2,t3):
      // FIX:  really ought to have two inner loops to get all combinations
      // of terms in the graph...
      let t1node = term2node(g,t1);
      let t2node = term2node(g,t2);
      let t3node = term2node(g,t3);
      for (let ts = g->rows; ts != NULL; ts = ts->next) {
        if (t1node != ts && equal_nodes(ts,t1node)) 
          add_eq(g,t,update(ts->rep,t2,t3));
        if (t2node != ts && equal_nodes(ts,t2node))
          add_eq(g,t,update(t1,ts->rep,t3));
        if (t3node != ts && equal_nodes(ts,t3node))
          add_eq(g,t,update(t1,t2,ts->rep));
      }
      break;
    default: break;
    }
  }
}

// Not currently used because too expensive
static graph_t *congruence_close_graphs(graph_t *`H gs) {
  return app_graphs(congruence_close_graph,0,gs);
}


// try to perform gaussian elimination on the given matrix -- not
// the smartest implementation, but simple.
static void simplify_matrix(unsigned Rows, unsigned Columns,int ??M) {
  for (unsigned c = 0; c < Columns; c++) {
    // try to find a row with a non-zero element in column c and swap it
    // with row c.
    unsigned r;
    for (r = 0; r < Rows; r++) {
      if (M[r][c] != 0) break;
    }
    // if we didn't find a row for that term, skip it.
    if (r >= Rows) continue;
    // now in M[r] we should have {0,0,0,...,i_c,i_c+1,...,i_c+n}
    // we want to subtract the right multiple from all other rows.
    for (unsigned r2 = 0; r2 < Rows; r2++) {
      if (r2 == r || M[r2][c] == 0) continue;
      let kr2 = M[r2][c];
      let kr = M[r][c];
      // row r2 := kr*(row r2) - kr2*(row r)
      for (unsigned i = 0; i < Columns + 1; i++) 
        M[r2][i] = (kr*M[r2][i]) - (kr2*M[r][i]);
    }
  }
}

// print out a matrix
static void print_matrix(unsigned R, unsigned C, Xarray::xarray_t<term_t> ts,
                         int ??M) {
  for (unsigned i = 0; i < R; ++i) {
    bool found_column = false;
    for (unsigned j = 0; j < C; ++j) {
      let v = M[i][j];
      if (v == 0) continue;
      if (found_column) fprintf(stderr," + ");
      found_column = true;
      fprintf(stderr,"%d*%s",v,term2string(Xarray::get(ts,j)));
    }
    if (!found_column) fprintf(stderr,"0");
    fprintf(stderr," == %d\n",M[i][C]);
  }
}

// print out the polynomial representation of a term
static void print_poly(list_t<$(int,term_t)@> ts, unsigned c) {
  if (ts == NULL) fprintf(stderr,"0");
  else {
    for (; ts != NULL; ts = ts->tl) {
      let $(i,t) = *ts->hd;
      fprintf(stderr,"%d*%s",i,term2string(t));
      if (ts->tl != NULL) fprintf(stderr," + ");
    }
  }
  fprintf(stderr," == %d\n",-c);
}

// Extract a set of equations for the terms in the graph, reduce them
// to their polynomial form, and then try to solve the equations using
// gaussian elimination.  Then add the resulting equations back to the
// graph.
// static void gaussian_terms(int unused, graph_t @g) {
//   // for each terms T1 == T2, compute polynomials T1 = P1+c1 and T2 = P2+c2
//   // and place in P1-P2 + c1-c2 == 0 in the list S, representing a row in a 
//   // matrix.  While we're doing this, assign each primitive term in the
//   // polynomials an index.
//   list_t<$(list_t<$(int,term_t)@>,unsigned int)@> S = NULL;
//   Hashtable::table_t<term_t,int> term_index = 
//     Hashtable::create(33,termcmp,termhash);
//   Xarray::xarray_t<term_t> index_term = Xarray::create_empty();
//   unsigned int Cols = 0;
//   unsigned int Rows = 0;
//   for (let rs = g->rows; rs != NULL; rs = rs->next) {
//     for (let ts = rs->next; ts != NULL; ts = ts->next) 
//       if (eq_nodes(rs,ts,false)) {
// //         //fprintf(stderr,"adding %s == %s to matrix\n",term2string(rs->rep),
// //         //        term2string(ts->rep));
// //         let $(r_terms,r_c) = term2poly(rs->rep);
// //         //fprintf(stderr,"poly1: "); print_poly(r_terms,r_c);
// //         let $(t_terms,t_c) = term2poly(ts->rep);
// //         //fprintf(stderr,"poly2: "); print_poly(t_terms,t_c);
// //         let terms = merge_poly(r_terms,-1,t_terms);
// //         // add each primitive term to the hashtable
// 	let $(terms,c) = AssnDef::flatten_plus(minus(rs->rep,ts->rep,NULL));
//         for (let x = terms; x != NULL; x=x->tl) {
//           let $(_,t) = *x->hd;
//           let iopt = Hashtable::lookup_opt(term_index,t);
//           if (iopt == NULL) {
//             Hashtable::insert(term_index,t,Cols);
//             Xarray::add(index_term,t);
//             Cols++;
//           }
//         }
//         Rows++;
//         //print_poly(terms,c);
//         S = new List{new $(terms,c),S};
//       }
//   }
//   // we want to convert the sparse matrix to a dense one to simplify
//   // processing.
//   int ?? M = new {for i < Rows : new {for j < Cols+1 : 0}};
//   for (unsigned int r = 0; r < Rows; S = S->tl, ++r) {
//     let $(its,c) = *S->hd;
//     let row = M[r];
//     row[Cols] = c;
//     for (; its != NULL; its = its->tl) {
//       let $(v,t) = *its->hd;
//       let column = Hashtable::lookup(term_index,t);
//       row[column] = v;
//     }
//   }

//   // DEBUGGING:
//   // print mapping from primitive terms to indices
//   //fprintf(stderr,"Initial matrix:\n"); fflush(stderr);
//   //print_matrix(Rows,Cols,index_term,M);

//   // try to solve for the primitive terms
//   simplify_matrix(Rows,Cols,M);

//   //fprintf(stderr,"After simplification matrix:\n"); fflush(stderr);
//   //print_matrix(Rows,Cols,index_term,M);

//   simplify_matrix(Rows,Cols,M);

//   // add the resulting equations to the graph
//   for (unsigned r = 0; r < Rows; ++r) {
//     let row = M[r];
//     let c = uint(-row[Cols]);
//     let t = uint(0);
//     // add in all of the positive values first
//     for (unsigned j = 0; j < Cols; ++j) {
//       let v = row[j];
//       if (v > 0) {
//         let term = Xarray::get(index_term,j);
//         for (; v != 0; v--)
//           t = plus(t,term,Absyn::uint_type);
//       }
//     }
//     // add all of the negative values to c
//     for (unsigned j = 0; j < Cols; ++j) {
//       let v = row[j];
//       if (v < 0) {
//         let term = Xarray::get(index_term,j);
//         for (; v != 0; v++)
//           c = plus(c,term,Absyn::uint_type);
//       }
//     }
//     //fprintf(stderr,"adding equation %s = %s\n",term2string(t),term2string(c));
//     add_eq(g,t,c);
//   }
// }

// static graph_t *gaussian_graphs(graph_t *`H gs) {
//   //bool old_graphs_change = graphs_change;
//   //graphs_change = false;
//   gs = app_graphs(gaussian_terms,0,gs);
//   //if (graphs_change) {
//   //  fprintf(stderr,"gaussian_graphs eliminated graph\n");
//   //}
//   //graphs_change = graphs_change || old_graphs_change;
//   return gs;
// }

// JGM: I've renamed this "equality_close" instead of "congruence_close"
// since we don't really generate all of the congruent terms...
// If we have two nodes with representatives of the form Prim(p,[t11,...,tn1])
// and Prim(p,[t12,...,tn2]) and the sub-terms ti1 and ti2 map to equivalent
// nodes, then we should equate these two terms.  We're relying on the fact
// that the rows are sorted in term order so that leaves are processed before
// compound terms.

// FIX: for a given term (e.g., Unop(p,t)) we want to find all of the
// terms t' equivalent to t and add the constraint Unop(p,t) = Unop(p,t').
// This code only *unifies* existing terms.  The right thing to do is
// to generate equivalence classes on existing nodes (essentially what's
// going on here in a very ineffecient way) and then make a pass over
// the equivalence classes, generating the congruences.  
static void equality_close_graph(int dummy, graph_t @g) {
  for (let rs = g->rows; rs != NULL; rs = rs->next) {
    let rep1 = rs->rep;
    switch (rep1) {
    case &Binop(p1,t11,t12,_):
      for (let ts = rs->next; ts != NULL; ts = ts->next) 
        switch (ts->rep) {
        case &Binop(p2,t21,t22,_) && p1 == p2:
          if (equal_terms(g,t11,t21) && equal_terms(g,t12,t22))
            add_eq(g,rep1,ts->rep);
          continue;
        default: continue;
        }
      break;
    case &Unop(p1,t1,_):
      for (let ts = rs->next; ts != NULL; ts = ts->next)
        switch (ts->rep) {
        case &Unop(p2,t2,_) && p1 == p2:
          if (equal_terms(g,t1,t2)) add_eq(g,rep1,ts->rep); continue;
        default: continue;
        }
      break;
    case &Cast(tp1,t1):
      for (let ts = rs->next; ts != NULL; ts = ts->next)
        switch (ts->rep) {
        case &Cast(tp2,t2):
          if (Tcutil::typecmp(tp1,tp2) == 0 && equal_terms(g,t1,t2)) 
            add_eq(g,rep1,ts->rep); 
          continue;
        default: continue;
        }
      break;
    case &Select(t11,t12,_):
      for (let ts = rs->next; ts != NULL; ts = ts->next) 
        switch (ts->rep) {
        case &Select(t21,t22,_):
          if (equal_terms(g,t11,t21) && equal_terms(g,t12,t22))
            add_eq(g,rep1,ts->rep);
          continue;
        default: continue;
        }
      break;
    case &Update(t11,t12,t13):
      for (let ts = rs->next; ts != NULL; ts = ts->next) 
        switch (ts->rep) {
        case &Update(t21,t22,t23):
          if (equal_terms(g,t11,t21) && equal_terms(g,t12,t22) && 
              equal_terms(g,t13,t23))
            add_eq(g,rep1,ts->rep);
          continue;
        default: continue;
        }
      break;
    case &Proj(t1,i1,_):
      for (let ts = rs->next; ts != NULL; ts = ts->next)
        switch (ts->rep) {
        case &Proj(t2,i2,_):
          if (i1 == i2 && equal_terms(g,t1,t2)) add_eq(g,rep1,ts->rep); 
          continue;
        default: continue;
        }
      break;
    case &AggrUpdate(t11,i1,t12):
      for (let ts = rs->next; ts != NULL; ts = ts->next) 
        switch (ts->rep) {
        case &AggrUpdate(t21,i2,t22) && i1 == i2:
          if (equal_terms(g,t11,t21) && equal_terms(g,t12,t22))
            add_eq(g,rep1,ts->rep);
          continue;
        default: continue;
        }
      break;
    case &Aggr(is_union1,tag1,ts1,_):
      for (let ts = rs->next; ts != NULL; ts = ts->next)
        switch (ts->rep) {
        case &Aggr(is_union2,tag2,ts2,_) && tag1 == tag2:
          for (; ts1 != NULL && ts2 != NULL; ts1=ts1->tl, ts2=ts2->tl) 
            if (!equal_terms(g,ts1->hd,ts2->hd)) break;
          if (ts1 == ts2 && is_union1 == is_union2) add_eq(g,rep1,ts->rep);
          continue;
        default: continue;
        }
      break;
    case &Tagof(t1):
      for (let ts = rs->next; ts != NULL; ts = ts->next)
        switch (ts->rep) {
        case &Tagof(t2): 
          if (equal_terms(g,t1,t2)) add_eq(g,rep1,ts->rep);
          continue;
        default: continue;
        }
      break;
    default: break;
    }
  }
}

// run equality closure on a set of graphs and weed out the disjuncts
static graph_t *equality_close_graphs(graph_t *`H gs) {
  return app_graphs(equality_close_graph,0,gs);
}

//find out if s[t] = s[t1+c2] =? s[t1] + c2
static $(bool, term_t, int) break_term(graph_t @g, term_t t, bool is_signed){
  switch (t){
  case &Binop(Absyn::Plus,t1,&Uint(c2,_),_):
    if ((int)c2 >= 0){
      if (is_signed){
	let dist = lookup_dist(term2node(g,t1),term2node(g,zero()),true);
	// want to show that s[t1]+c2 not overflowing, i.e., s[t1] <= MAXINT-c2
	if (dist != NULL && *dist <= MAXINT- (int)c2){
	  return $(true,t1,(int)c2);
	}
      } else {
	// want to show that u[t1]+c2 not overflowing, i.e., u[t1] <= MAXINT
	let dist = lookup_dist(term2node(g,t1),term2node(g,zero()),false);
	if (dist != NULL) {
	  return $(true,t1,(int)c2);
	}
      }
    } else {// int(c2) < 0
      if (is_signed){
	// want to show that s[t1]+c2 not underflowing, i.e., 0-s[t1] <= c2-MININT
	let dist = lookup_dist(term2node(g,zero()),term2node(g,t1),true);
	if (dist != NULL && *dist <= (int)(c2-MININT)){
	  return $(true,t1,(int)c2);
	}
      } else {
	// want to show that u[t1]+c2 does not underflow, i.e.u[t1] >= -c2
	let dist = lookup_dist(term2node(g,zero()), term2node(g,t1),false);
	if (dist != NULL && *dist <=(int)c2) {
	  return $(true,t1,(int)c2);
	}
      }
    }
    break;
  default:
    break;
  }
  return $(false,t,0);  
}

static void break_term_in_graph(int dummy, graph_t @g){
  for(let rs = g->rows; rs != NULL; rs = rs->next){
    if (!rs->broken_as_signed){
      let $(ok,t1,c1) = break_term(g,rs->rep,true);
      if (ok){
	rs->broken_as_signed = true;
	set_distance(g,rs->rep,t1,c1,true);
	if ((unsigned)c1 != MININT)
	  set_distance(g,t1,rs->rep,-c1,true);
      }
    }
    if (!rs->broken_as_unsigned){
      let $(ok,t1,c1) = break_term(g,rs->rep,false);
      if (ok){
	rs->broken_as_unsigned = true;
	set_distance(g,rs->rep,t1,c1,false);
	if ((unsigned)c1 != MININT)
	  set_distance(g,t1,rs->rep,-c1,false);
      }
    }
    let $(ok,c1,_) = subst_term_with_const(g,rs->rep);
    // we know that rs->rep == c, we try to solve subpart of rs->rep;
    if (ok){
      switch (rs->rep){
      case &Binop(Absyn::Plus,t1,&Uint(c2,_),_):
	rs->broken_as_signed = true;
	rs->broken_as_unsigned = true;
	add_eq(g,t1,uint(c1-c2));
	break;
      default:
 	break;
      }
    }
  }
}

static graph_t *break_term_in_graphs(graph_t *`H gs){
  return app_graphs(break_term_in_graph, 0, gs);
}


// given a node t in graph g
// return -1 if s[t] < 0 or u[t] > MAXINT
// return 1 if s[t] >= 0 or u[t] <= MAXINT
// return 0 if unknown
static int range_of_term(graph_t @g, node_t @`H t){
  node_t @zero_node = term2node(g,zero());
  // 0 - u[t] <= MININT, so u[t] > MAXINT
  let dist = lookup_dist(zero_node,t,false);
  if (dist != NULL && (unsigned) *dist == MININT)
    return 1;
  // u[t] - 0 <= MAXINT, so u[t] <= MAXINT
  let dist = lookup_dist(t,zero_node,false);
  if (dist != NULL && (unsigned) *dist <= MAXINT)
    return -1;
  // 0 - s[t] <= 0, so s[t] >= 0
  let dist = lookup_dist(zero_node,t,true);
  if (dist != NULL && *dist <= 0) 
    return 1;
  // s[t] - 0 <= -1 so s[t] < 0
  let dist = lookup_dist(t,zero_node,true);
  if (dist != NULL && *dist <= -1)
    return -1;
  // don't know enough information to determine t's range
  return 0;
}

// if we know that src u<= MAXINT or src s>= 0
// and that        tgt u<= MAXINT or tgt s>= 0
// then u[src] - u[tgt] <= c if and only if
//      s[src] - s[tgt] <= c
// if we know that src u> MAXINT or src s< 0
// and that        tgt u> MAXINT or tgt s< 0
// then u[src] - u[tgt] <= c if and only if
//      s[src] - s[tgt] <= c
static void associate_ud_sd_in_graph(int dummy, graph_t @g){
  int range_of_src, range_of_tgt;
  for(let rs = g->rows; rs != NULL; rs = rs->next){
    range_of_src = range_of_term(g,rs);
    if (range_of_src != 0){
      for(let uds = rs->unsigned_distances; uds != NULL; uds = uds->next){
	range_of_tgt = range_of_term(g,uds->target);
	if (range_of_src == range_of_tgt){
	  set_distance(g,rs->rep,uds->target->rep,uds->dist,true);
	}
      }
      for(let sds = rs->signed_distances; sds != NULL; sds = sds->next){
	range_of_tgt = range_of_term(g,sds->target);
	if (range_of_src == range_of_tgt){
	  set_distance(g,rs->rep,sds->target->rep,sds->dist,false);
	}
      }
    }
  }
  return;
}

static graph_t *associate_ud_sd_in_graphs(graph_t *`H gs){
  return app_graphs(associate_ud_sd_in_graph,0,gs);
}
// convert a primitive assertion to a constraint and add it to the graph.
// throws &inconsistent if the resulting graph is inconsistent.
// This does not deal with equality constraints -- those should've already
// been eliminated.
static void add_constraint(graph_t @g, term_t t1, prim_reln_t p, term_t t2) {
  ++constraints_added;
  switch $(t1,t2) {
  case $(&Uint(c1,_),&Uint(c2,_)):
    switch (p) {
    case ULt: if (c1 < c2) return; break;
    case ULte: if (c1 <= c2) return; break;
    case SLt: if (((int)c1) < ((int)c2)) return; break;
    case SLte: if (((int)c1) <= ((int)c2)) return; break;
    default: Warn::impos("Vcgen: found bad primop in add_constraint");
    }
#ifdef PROVER_DEBUG
    fprintf(stderr,"inconsistency found in comparing two constants\n");
#endif PROVER_DEBUG
    throw &inconsistent;
  case $(_,&Uint(c2,_)):
    // we have t1 p c2 
    switch (p) {
    case ULt: 
      //no unsigned integer t could satisfy t u< 0
      if (c2 == 0){
#ifdef PROVER_DEBUG
	fprintf(stderr,"inconsistency: add constraint x u< 0 \n");
#endif PROVER_DEBUG
	throw &inconsistent;
      }
      c2 = c2 - 1; 
      fallthru;
    case ULte:
      // must check that c2 can be represented by an int.
      if (c2 <= (unsigned)MAXINT){
	// we know that  u[t1]-0 u< c2 and s[t1]-0 < c2
	set_distance(g,t1,zero(),(int)c2,false);
      }
      return;
    case SLt: 
      //no signed integer t could satisfy t s< MININT
      if (c2 == MININT){
#ifdef PROVER_DEBUG
	fprintf(stderr,"inconsistency: add constraint x s< MININT \n");
#endif PROVER_DEBUG
	throw &inconsistent;
      }
      c2 = c2 - 1;
      fallthru;
    case SLte:
      // the value of (int)c2 should be representable by an integer.
      set_distance(g,t1,zero(),(int)c2,true);
      return;
    default: Warn::impos("Vcgen: found bad primop in add_constraint");
    }
  case $(&Uint(c1,_),_):
    // we have c1 p t2
    switch (p) {
    case ULt: 
      //no unsigned integer t could be greater than the biggest unsigned
      if (c1 == MAXUINT){
#ifdef PROVER_DEBUG
	fprintf(stderr,"inconsistency: add constraint MAXUINT u< x \n");
#endif PROVER_DEBUG
	throw &inconsistent;
      }
      c1 = c1 + 1;
      fallthru;
    case ULte:
      //u[c1] <= u[t2] => 0 - u[t2] <= -u[c1]
      if (c1 > MAXINT) {
	//-u[c1] can't be represented by an integer, but we know that
	//0-u[t2] <= -u[c1] <= MININT
	set_distance(g,zero(),t2,MININT,false);
      }
      else { 
	//-u[c1] could be represented by an integer
	//0 - u[t2] <= -u[c1]
	set_distance(g,zero(),t2,-((int)c1),false);
      }
      return;
    case SLt: 
      //no signed integer could be greater than the biggest signed int
      if (c1 == MAXINT){
#ifdef PROVER_DEBUG
	fprintf(stderr,"inconsistency: add constraint MAXINT s< x \n");
#endif PROVER_DEBUG
	throw &inconsistent;
      }
      c1 = c1 + 1;
      fallthru;
    case SLte:
      // 0 - s[t2] <= -s[c1], -s[c1] could not represented by int
      // when c1 == MININT
      if (c1 == MININT) return;
      return set_distance(g,zero(),t2,-((int)c1),true);
    default: Warn::impos("Vcgen: found bad primop in add_constraint");
    }
  default: break;
  }
  // nothing special about the terms -- have to add them as standard
  // sort of constraints.
  switch (p) {
  case ULt:
    // u[t1] < u[t2] => u[t1] - u[t2] <= -1
    return set_distance(g,t1,t2,-1,false);
  case ULte:
    // u[t1] <= u[t2] => u[t1] - u[t2] <= 0
    return set_distance(g,t1,t2,0,false);
  case SLt:
    // s[t1] < s[t2] => s[t1] - s[t2] <= -1
    return set_distance(g,t1,t2,-1,true);
  case SLte: 
    // s[t1] <= s[t2] => s[t1] - s[t2] <= 0
    return set_distance(g,t1,t2,0,true);
  default: Warn::impos("Vcgen:found bad primop in add_constraint");
  }
}

// try to set t1 == t2
static void add_eq(graph_t @g, term_t t1, term_t t2) {
  if (t1 == t2) return;
  add_constraint(g,t1,ULte,t2);
  add_constraint(g,t2,ULte,t1);
  add_constraint(g,t1,SLte,t2);
  add_constraint(g,t2,SLte,t1);
}

static void add_prim($(term_t,prim_reln_t,term_t)@ p, graph_t @`H g) {
  let $(t1,p,t2) = *p;
  if (p == Eq) 
    add_eq(g,t1,t2);
  else
    add_constraint(g,t1,p,t2);
}

// given a term (presumably of pointer type), try to split it into
// a base pointer term plus offset.  Worst case is you get $(t,0)
// back.  This also tries to factor out additions and subtractions
// of common terms by converting the term to a polynomial representation.
// So, for instance, if you have (p + numelts(p)) - (numelts(p) - j)
// you should get out p + j.  However, it's likely to get confused
// if we have a pointer subtraction in here...
// static $(term_t base, term_t offset) find_ptr_base(term_t t) {
//   let $(ts,c) = flatten_plus(t);
//   //fprintf(stderr,"term %s splits into polynomial 0x%x",term2string(t),c);
//   //for (let us=ts; us!=NULL; us=us->tl) {
//   //  let $(i,u) = *us->hd;
//   //  fprintf(stderr," + %d*%s",i,term2string(u));
//   //}
//   //fprintf(stderr,"\n");
//   term_t base = zero();
//   term_t offset = uint(c);
//   bool found_base = false;
//   for (; ts != NULL; ts=ts->tl) {
//     let $(i,s) = *ts->hd;
//     let stype = get_term_type(s);
//     if (i > 0 && stype != NULL && Tcutil::is_pointer_type((type_t)stype)) {
//       // if we have two potential base pointers, then we're not sure
//       // how things line up so be conservative and don't split.
//       if (found_base) return $(t,zero());
//       //fprintf(stderr,"type of %s is %s\n",term2string(s),Absynpp::typ2string((type_t)stype));
//       found_base = true;
//       base = s;
//       i = i - 1;
//     }
//     if (i > 0) {
//       for (let j = 0; j < i; j++) offset = plus(offset,s,Absyn::uint_type);
//     } else if (i < 0) {
//       for (let j = 0; j > i; j--) offset = minus(offset,s,Absyn::uint_type);
//     }
//   }
//   if (!found_base) return $(t,zero());
//   return $(base,offset);
// }

// The semantics of Okderef(t) is as follows:
//    Okderef(t) U<= 0  iff All t1,t2.t!=t1+t2 || t2 U>= numelts(t1)
// In other words, Okderef(t) is true (i.e., non-zero) when there's
// some way to break t into a base pointer t1 and offset t2 such that 
// t2 U< numelts(t1), and thus is false (i.e., zero) when there's
// no way to break it into terms such as this.  
//
// In the closure pass below, we look for Okderef(t) terms in the
// graph such that Okderef(t) U<= 0 and t=t1+t2 where t1 is a pointer-type,
// indicating that we think it's not okay to dereference t1+t2.  We
// then add a constraint t2 U>= numelts(t1) hoping to achieve a
// contradiction.  
// static void constrain_okderef(int unused, graph_t @`H g) {
//   let zn = term2node(g,zero());
//   for (let rs = g->rows; rs != NULL; rs = rs->next) {
//     switch (rs->rep) {
//     case &Okderef(t2):
//       //fprintf(stderr,"found okderef(%s)\n",term2string(t2));
//       let dist = lookup_dist(rs, zn, false);
//       if (dist == NULL || *dist != 0) {
//         //string_t s = dist ? (string_t)aprintf("%d",*dist) : "<inf>";
//         //fprintf(stderr,"okderef(%s) - 0 != 0, rather %s\n",term2string(t2),s);
//         continue;
//       }
//       //fprintf(stderr,"okderef(%s) - 0 == 0\n",term2string(t2));
//       let t2node = term2node(g,t2);
//       // find any t3 == t2 and try to do the following:
//       for (let ts = g->rows; ts != NULL; ts = ts->next) {
//         if (eq_nodes(t2node,ts,false)) {
//           let $(base,offset) = find_ptr_base(ts->rep);
//           //fprintf(stderr,"splitting %s == %s into %s + %s\n",
//           //        term2string(t2),term2string(ts->rep),
//           //        term2string(base),term2string(offset));
//           //fprintf(stderr,"adding constraint numelts(%s) U<= %s\n",
//           //        term2string(base),term2string(offset));
//           add_constraint(g, numelts_term(base), ULte, offset);
//           //fprintf(stderr,"no inconsistency\n");
//         }
//       }
//       break;
//     default: break;
//     }
//   }
// }

// static graph_t *constrain_okderefs(graph_t *`H gs) {
//   bool old_graphs_change = graphs_change;
//   graphs_change = false;
//   gs = app_graphs(constrain_okderef,0,gs);
//   //if (graphs_change) {
//   //  fprintf(stderr,"constrain_okderefs eliminated graph\n");
//   //}
//   graphs_change = graphs_change || old_graphs_change;
//   return gs;
// }

datatype exn { TooLarge };
datatype exn.TooLarge too_large = TooLarge;

//FIX: add a way for the user to control this.
unsigned int max_paths = 17;
unsigned int max_paths_seen = 0;

// given a set of graphs gs representing A1 or A2 or ... or An
// and given assertion a, compute the set of graphs representing
// (A1 or A2 ... or An) and a.  This is written with explicit
// tail-calls to be as fast as possible.  If we end up with two
// many disjuncts, then we throw an exception to back out of the
// whole thing.  
//
// JGM: what we should probably do is delay pushing in the Or nodes
// until we've gotten all of the And, Prim, True, and False nodes
// pushed into the graphs.  That way we're more likely to hit an
// inconsistency early.
static graph_t *cgraph(graph_t *`H gs, Set::set_t<assn_t,`H> @already_seen,
                       assn_t a, unsigned *total_paths) {
 LOOP:
  if (gs == NULL) return gs; // already inconsistent
  //fprintf(stderr,"inserting assertion %s into \n",assn2string(a));
  //print_graphs(gs);
  // if we've already added in this assertion, return the graphs
  if (Set::member(*already_seen,a)) {++already_seen_hits; return gs;}
  *already_seen = Set::insert(*already_seen,a);
  switch (a) {
  case &True: break;         // gs and true == gs
  case &False: gs = NULL; break; // gs and false == false
  case &And(a1,a2): 
    gs = cgraph(gs,already_seen,a2,total_paths);// gs and (a1 and a2) == (gs and a2) and a1
    a = a1;
    goto LOOP;
  case &Or(a1,a2):
    let n = num_graphs(gs);
    if (*total_paths > max_paths){
      throw &too_large;
    }
    // fprintf(stderr, "num_graphs(gs) = %d, total_paths = %d\n", n, *total_paths);
    // must copy the graphs since we mutate them in place
    *total_paths = *total_paths + n;
    gs = app_graphs(johnson,0,gs);
    graph_t *gs1 = gs;
    graph_t *gs2 = copy_graphs(gs);
    let already_seen1 = *already_seen;
    let already_seen2 = *already_seen;
    // compute (gs and a1)
    gs1 = cgraph(gs1,&already_seen1,a1,total_paths);
    gs1 = associate_ud_sd_in_graphs(gs1);
    gs1 = break_term_in_graphs(gs1);
    // try to weed out graphs through equality closure
    gs1 = equality_close_graphs(gs1);
    gs1 = associate_ud_sd_in_graphs(gs1);
    // at this point, we're splitting so increase the or-depth
    // compute (gs and a2)
    gs2 = cgraph(gs2,&already_seen2,a2,total_paths);
    gs2 = associate_ud_sd_in_graphs(gs2);
    gs2 = break_term_in_graphs(gs2); 
    // try to weed out graphs through equality closure
    gs2 = equality_close_graphs(gs2);
    gs2 = associate_ud_sd_in_graphs(gs2);
    // return (gs and a1) or (gs and a2)
    *already_seen = Set::intersect(already_seen1,already_seen2);
    gs = graph_append(gs1,gs2);
    break;
  case &Prim(&Uint(0,_),Neq,t2): fallthru(t2);
  case &Prim(t1,Neq,&Uint(0,_)):
    // when doing an unsigned or pointer comparison against 0, we know
    // that 0 < t1.  So use this instead of introducing a disjunction.
    type_opt_t topt = AssnDef::get_term_type(t1);
    if (topt == NULL || Tcutil::is_signed_type((type_t)topt))
      fallthru(t1,zero());
    a = ult(zero(),t1);
    goto LOOP;
  case &Prim(t1,Neq,t2): 
    // must handle neq specially as t1 < t2 or t2 < t1 (both signed
    // and unsigned.)
    a = and(or(slt(t1,t2),slt(t2,t1)),or(ult(t1,t2),ult(t2,t1)));
    goto LOOP;
    //case &Prim(t1,Eq,t2):
    // explode t1 == t2 into t1 <= t2 and t2 <= t1 (both signed and unsigned)
    //a = and(and(and(slte(t1,t2),slte(t2,t1)),ulte(t1,t2)),ulte(t2,t1));
    //goto LOOP;
  case &Prim(t1,p,t2):
    // add the primitive relation to each graph, pruning out the
    // inconsistent ones.
    let env = $(t1,p,t2);
    gs = app_graphs(add_prim,&env,gs);
    break;
  }
  return gs;
}

static Set::set_t<term_t> get_pointer_terms(term_t t,Set::set_t<term_t,`H> s) {
 LOOP:
  let topt = get_term_type(t);
  if (topt != NULL && Tcutil::is_nullable_pointer_type((type_t)topt,false)
      && Tcutil::get_type_bound((type_t)topt) != NULL)
    s = Set::insert(s,t);
  switch (t) {
  case &Cast(_,t1): t = t1; goto LOOP;
  case &Unop(_,t1,_): t = t1; goto LOOP;
  case &Binop(_,t1,t2,_): 
    s = get_pointer_terms(t1,s);
    t = t2; goto LOOP;
  default: break;
  }
  return s;
}

static Set::set_t<term_t> 
get_graph_pointer_terms(graph_t *`r _g,Set::set_t<term_t,`H> s) {
  graph_t *`r+`H g=_g;
  for (; g != NULL; g = g->next) 
    for (let rs = g->rows; rs != NULL; rs = rs->next) 
      s = get_pointer_terms(rs->rep,s);
  return s;
}

static void add_ptr_info($(term_t t,term_t,term_t bnd)@env, graph_t@`H g) {
  let $(t,tnumelts,bnd) = *env;
  // check to see if 0 u< t -- i.e., 0 - t u<= -1
  let dist = lookup_dist(term2node(g,zero()),term2node(g,t),false);
  if (dist != 0 && *dist <= -1) {
    add_constraint(g,bnd,ULte,tnumelts);
    add_constraint(g,bnd,SLte,tnumelts);
  }
}

static graph_t *add_ptr_type_info(term_t t, graph_t *`H gs) {
  type_t type = (type_t)get_term_type(t);
  exp_t e = strip_cast((exp_t)Tcutil::get_type_bound(type));
  term_t bnd = cnst(e);
  term_t tnumelts = numelts_term(t);
  let env = $(t,tnumelts,bnd);
  return app_graphs(add_ptr_info,&env,gs);
}

// certain bits of type information are best expressed as explicit
// assertions.  For instance, when t : int*{c}, then we would like
// to add or(t == 0, c <= numelts(t)).  So we add these facts to the
// assertion explicitly before converting it to the graph representation.
static graph_t *add_type_assns(graph_t *`H gs) {
  Set::set_t<term_t> ptrs = get_graph_pointer_terms(gs,Set::empty(termcmp));
  return Set::fold(add_ptr_type_info,ptrs,gs);
}

// if c < numelts(x) then 0 < numelts(x+k) for all k < c.
static void add_numelts_info(int dummy, graph_t @`H g) {
  let zeronode = term2node(g,zero());
  // look for terms of the form numelts(x+k)
  for (let n = g->rows; n != NULL; n = n->next) {
    switch (n->rep) {
    case &Unop(Absyn::Numelts,&Binop(Absyn::Plus,x,&Uint(uk,_),_),_):
      int k = (int)uk;
      if (k > 0) {
        // look for terms of the form numelts(x)
        let numelts_x = numelts_term(x);
        let n_numelts_x = term2node(g,numelts_x);
        // c < numelts(x) same as zero() - numelts(x) U<= -(c+1)
        let dist_opt = lookup_dist(zeronode, n_numelts_x, false);
        if (dist_opt != NULL) {
          int j = *dist_opt;
          // at this point, we know -numelts(x) U<= j so numelts(x) >= -j
          int negj = -j;
          // if negj > 0 then we know numelts(x) > negj-1
          if (negj > 0) {
            int c = negj-1;
            // if k<=c then (c-k) < numelts(x+k)
            if (k <= c) {
              //fprintf(stderr,"fired: %d U< %s\n",c-k,term2string(n->rep));
              add_constraint(g,uint(c-k),ULt,n->rep);
            }
          }
        }
      }
      break;
    default: break;
    }
  }
}

static graph_t *add_numelts_info_graphs(graph_t *`H gs) {
  return app_graphs(add_numelts_info,0,gs);
}

static bool paths_exhausted = false;

// check to see if an assertion is consistent using the constraint solver.
// if it returns false, then the assertion is definitely inconsistent.
// if it returns true, then the assertion might be consistent.
static bool consistent(assn_t a) {
  //fprintf(stderr,"checking consistency of: \n");
  //fprintf(stderr,"%s",AssnDef::dag2string(a));
  
  try {
    // start with just an empty graph (true) and then add in assertion a
    paths_exhausted = false;
    constraints_added = 0;
    graphs_copied = 0;
    max_lookup = 0;
    already_seen_hits = 0;
    assn_set_t already_seen = Set::empty(assncmp);
    unsigned total_paths = 1;
    graph_t *gs = cgraph(true_graph(),&already_seen,a,&total_paths);

    //fprintf(stderr,"constraints added = %d\n",constraints_added);
    //fprintf(stderr,"graphs_copied = %d\n",graphs_copied);
    //fprintf(stderr,"max_lookup = %d\n",max_lookup);
    //fprintf(stderr,"already_seen_hits = %d\n",already_seen_hits);
    // run closure passes to weed out graphs
    graphs_change = true;
    while (graphs_change && gs != NULL) {
      gs = app_graphs(johnson,0,gs);
      graphs_change = false;
      gs = associate_ud_sd_in_graphs(gs);
      gs = add_type_assns(gs);
      gs = add_numelts_info_graphs(gs);
      gs = equality_close_graphs(gs);
      //      gs = gaussian_graphs(gs);
      //      gs = constrain_okderefs(gs);
      gs = break_term_in_graphs(gs);
      gs = associate_ud_sd_in_graphs(gs);
    }
    //if (gs != NULL) {
    //  fprintf(stderr,"final graphs:\n");
    //  print_graphs(gs);
    //}
    // if we get back an empty list of disjuncts (false) then
    // the graph is not consistent.
    return (gs != NULL);
  } catch {
    // if the graph has too many paths in it, we'll end up here.
    // we must conservatively assume that the assertion is consistent.
  case &TooLarge: 
    paths_exhausted = true;
    return true;
  }
}

// see if ctxt |- a by trying to prove that ctxt and not(a) is inconsistent.
bool constraint_prove(assn_t ctxt, assn_t a) {
  assn_t b = and(ctxt,not(a));
  let res = !consistent(b);
  if (!res && Flags::print_unprovable) {
    fprintf(stderr,"unable to prove inconsistency of \n");
    fprintf(stderr,"%s",assn2dag(b));
    if (paths_exhausted) {
      fprintf(stderr,"(paths exhausted)");
    } 
    fprintf(stderr,"\n");
  }
  return res;
}
