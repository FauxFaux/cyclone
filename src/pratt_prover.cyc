#include "assndef.h"
#include <list.h>

using AssnDef;
using List;

namespace PrattProver;

// FIX: 32-bit dependency!
#define MAXINT  (2147483647)
//#define MININT  (-2147483648)
#define MININT (-MAXINT-1)
#define MAXUINT (0xFFFFFFFF)

/* Not quite right yet -- when we lookup a term Prim(p,[t1,...,tn]),
we should lookup a *node* of the form PrimNode(p,[N1,...,Nn]).  
Furthermore, when we unify two nodes N1 == N2, then we should
collapse any nodes that end up being the same.  For instance,
if we unify N1 and N2, then we should also equate PrimNode(Numelts,[N1])
and PrimNode(Numelts,[N2]). */

///////////////////////// Constraint Solving ///////////////////////////
//
// This is a simple constraint solver that can determine the satisfiability
// of the conjunction of a set of constraints of the form (t1 - t2 <= c).
//
// We use a variation of the Pratt algorithm here where we keep track of a 
// signed distance and an unsigned distance between equivalence classes of 
// terms and find the minimal length signed and unsigned paths between any 
// two terms.  If we ever get a negative-length cycle, then the constraints 
// are inconsistent.  
//
// We represent a conjunction of constraints as a sparse matrix of
// the distances.  We consider distance(i,j) == 0 implicitly, and
// otherwise, if (i,j) are not in the graph, the distance is infinite.
//
// We deal with equality specially -- terms can be unified into an equivalence
// class (essentially a forwarding pointer to a representative term for the
// class.)  
//
// To deal with an entire assertion, we must collect a set of graphs.
// representing alternative states.  This effectively converts the 
// assertion to DNF which is an exponential blowup.  To avoid the blowup,
// we aggressively prune inconsistent graphs.  

// Forward declaration -- represents an equivalence class for terms
// (and also a row within a graph.)
struct Node;
typedef struct Node node_t;


// An entry in the sparse matrix -- records the target node of the
// edge and the distance as a (signed) integer.
typedef struct Distance {
  struct Distance *next;
  node_t @target;
  int    dist;
} distance_t;


// Represents an equivalence class for terms, and is used as a row
// within a graph.  If equiv_class is NULL, then this node represents 
// an equivalence class of terms.  If the equiv_class is non-NULL, then 
// we should always follow the pointer to get to the equiv_class, doing 
// path compression along the way.  
struct Node {
  node_t     *next;
  node_t     *equiv_class;
  term_t      rep;
  distance_t *unsigned_distances;
  distance_t *signed_distances;
};

// A graph is essentially a pair of sparse matrices of 
// (node_t,node_t)->distance.  We represent the matrices by having
// a node row for each term, but only those term-nodes with a NULL
// equiv_class are actually in the matrices.  The other nodes (with
// non-NULL equiv_class members) are kept so that we can lookup the
// appropriate node associated with a term.
typedef struct Graph {
  struct Graph *next;
  node_t       *rows;
} graph_t;

static unsigned num_graphs(graph_t *gs) {
  unsigned c = 0;
  for (; gs != NULL; gs = gs->next)
    ++c;
  return c;
}

// An empty graph represents the proposition "true".
static graph_t@ true_graph() { return new Graph{NULL,NULL}; }

// Given a node, look up its equivalence class and do path compression.
static node_t @compress(node_t @`H n) {
  let e = n->equiv_class;
  if (e == NULL) return n;
  let parent = compress(e);
  n->equiv_class = parent;
  return parent;
}

// Print out a graph.
void print_graph(graph_t @g) {
  fprintf(stderr,"{");
  if (g->rows == NULL) fprintf(stderr,"<true>");
  else {
    for (let rs = g->rows; rs != NULL; rs = rs->next) {
      let &Node{_,equiv_class,rep,uds,sds} = (node_t@)rs;
      if (equiv_class != NULL) {
        let p = compress(equiv_class)->rep;
        fprintf(stderr,"%s == %s\n ",term2string(rep),term2string(p));
      } else {
        for (; uds != NULL; uds = uds->next)
          fprintf(stderr,"%s - %s U<= %d\n ",term2string(rep),
                  term2string(compress(uds->target)->rep),uds->dist);
        for (; sds != NULL; sds = sds->next) 
          fprintf(stderr,"%s - %s S<= %d\n ",term2string(rep),
                  term2string(compress(sds->target)->rep),sds->dist);
      }
    }
  }
  fprintf(stderr,"}\n");
}

// Print out a list of graphs.
void print_graphs(graph_t *g) {
  fprintf(stderr,"Graphs:-----------\n");
  if (g == NULL) fprintf(stderr,"<false>\n");
  else {
    for (; g != NULL; g = g->next) print_graph(g);
  }
  fprintf(stderr,"------------------\n");
}

// forward declarations
static node_t *term2node_opt(graph_t @g, term_t t);
static bool set_distance(graph_t @g, term_t s, term_t t, int dist, bool is_signed);
static bool add_constraint(graph_t @g, term_t t1, prim_reln_t p, term_t t2);
static bool add_eq(graph_t @g, term_t t1, term_t t2);

// check term to see if its type reveals its numelts is known and if so,
// add the information to the graph.  similarly, check if term's type
// is tag_t<valueof(e)> and if so, add term == e and if term is unsigned, 
// then add term >= 0
static int add_type_info(graph_t @g, term_t term) {
  switch (term) {
  case &Unop(Absyn::Numelts, x, _):
    // add term s< MAXINT and term u< MAXINT and 0 u<= term
    if (!set_distance(g, term, zero(), MAXINT-1, true) ||
        !set_distance(g, term, zero(), MAXINT-1, false) ||
        !set_distance(g, zero(), term, 0, false)) return false;
    break;
  default: break;
  }
  let topt = get_term_type(term);
  if (topt != NULL) {
    type_t t = (type_t)topt;
    let eopt = Tcutil::get_type_bound(t);
    if (eopt != NULL) {
      term_t t1 = unop(Absyn::Numelts, term, Absyn::uint_type);
      // sigh -- must get rid of a cast to int/long
      exp_t e = (exp_t)eopt;
    loop:
      switch (e->r) {
      case &Absyn::Cast_e(tp2,e2,...):
        switch (Absyn::compress(tp2)) {
        case &Absyn::AppType(&Absyn::IntCon(_,s),_):
          if (s == Absyn::Int_sz || s == Absyn::Long_sz) {
            e = e2; goto loop;
          }
          break;
        default: break;
        }
        break;
      default: break;
      }
      term_t t2 = cnst((exp_t)e);
      if (!add_constraint(g, t2, ULte, t1)) return false;
      if (!add_constraint(g, t2, SLte, t1)) return false;
    }
    switch (Absyn::compress(t)) {
    case &Absyn::AppType(&Absyn::IntCon(Absyn::Unsigned,_),_):
      if (!add_constraint(g, zero(), ULte, term)) return false;
      break;
    case &Absyn::AppType(&Absyn::TagCon,&List{v,_}):
      switch (Absyn::compress(v)) {
      case &Absyn::ValueofType(e): add_eq(g,term,cnst(e)); break;
      case v2: 
        if (!add_eq(g,term,cnst(Absyn::valueof_exp(v2,0)))) return false; 
        break;
      }
      break;
    default: break;
    }
  }
  return true;
}

// After adding a term to the graph, we want to see if we can equate
// it to any other term in the graph that is congruent.  
static node_t *find_equiv_term(graph_t @g, node_t @`H n) {
  let t = n->rep;
  switch (t) {
  case &Binop(p,t1,t2,tp):
    let n1 = term2node_opt(g,t1);
    let n2 = term2node_opt(g,t2);
    if (n1 == NULL || n2 == NULL) return NULL;
    if (t1 != n1->rep || t2 != n2->rep) {
      let newt = binop(p,n1->rep,n2->rep,tp);
      for (let r = g->rows; r != NULL; r = r->next) {
        if (cmp_term(newt,r->rep) == 0) {
          let m = compress(r);
          if (m != n) n->equiv_class = m;
          break;
        }
      }
    }
    break;
  case &Unop(p,t1,tp):
    let n1 = term2node_opt(g,t1);
    if (n1 == NULL) return NULL;
    if (t1 != n1->rep) {
      let newt = unop(p,n1->rep,tp);
      for (let r = g->rows; r != NULL; r = r->next) {
        if (cmp_term(newt,r->rep) == 0) {
          let m = compress(r);
          if (m != n) n->equiv_class = m;
          break;
        }
      }
    }
    break;
  case &Cast(tp,t1):
    let n1 = term2node_opt(g,t1);
    if (n1 == NULL) return NULL;
    if (t1 != n1->rep) {
      let newt = cast(tp,n1->rep);
      for (let r = g->rows; r != NULL; r = r->next) {
        if (cmp_term(newt,r->rep) == 0) {
          let m = compress(r);
          if (m != n) n->equiv_class = m;
          break;
        }
      }
    }
    break;
  default: 
    break;
  }
  return compress(n);
} 

// Given a term, look up its equivalence class node and if not found,
// then add the term to the graph.
static node_t *term2node_opt(graph_t @g, term_t t) {
  // first see if we can find it directly.
  for (let r = g->rows; r != NULL; r = r->next) {
    if (cmp_term(t,r->rep) == 0) return compress(r);
  }
  // term not directly found -- insert it in the graph.  
  let n = new Node{g->rows, NULL, t, NULL, NULL};
  g->rows = n;
  // try to find an equivalent term via congruence.
  n = find_equiv_term(g,n);
  if (n == NULL) return NULL;
  // add in any type information.
  if (!add_type_info(g,t)) return NULL;
  return n;
}

static node_t @term2node(graph_t @g, term_t t) {
  return (node_t @)term2node_opt(g,t);
}

// Given a pair of nodes, look up their distance (if any) -- return
// NULL if no distance is found.  Special case when source and target
// are the same -- we always return a distance of zero.
static int *lookup_dist(node_t @`H source, node_t @`H target, bool is_signed) {
  static int zero = 0;
  source = compress(source);
  target = compress(target);
  if (source == target) return &zero;
  distance_t *ds = is_signed ? source->signed_distances : 
    source->unsigned_distances;
  for (; ds != NULL; ds = ds->next) 
    if (ds->target == target) return &ds->dist;
  return NULL;
}

// Same as above, but also delete the distance edge from the source -- used
// when unifying terms.  Also, this assumes that source and target are not
// equal and that they represent their equivalence classes.
static int *lookup_and_delete_dist(node_t @`H source, node_t @`H target, bool is_signed) {
  distance_t *@dsp = is_signed ? &source->signed_distances : 
    &source->unsigned_distances;
  for (let ds = *dsp; ds != NULL; ds = ds->next) {
    if (ds->target == target) {
      *dsp = ds->next;
      return &ds->dist;
    }
    dsp = &ds->next;
  }
  return NULL;
}

// Append two lists of graphs, representing a disjunction
static graph_t *graph_append(graph_t *`H g1, graph_t *`H g2) {
  if (g1 == NULL) return g2;
  if (g2 == NULL) return g1;
  graph_t @p = g1;
  for (let x = p->next; x != NULL; p = x, x = p->next) /* skip */ ;
  p->next = g2;
  return g1;
}

typedef $(bool, int) overflow_info_t;

typedef enum Operator{
  PLUS,
  MINUS,
} operator_t;


//checking if the sum or difference of two signed integers overflowed
//assuming size of intger as sizeofint (32), assumming the highest bit
//as the sign bit.
#define sizeofint 32;
static overflow_info_t is_signed_overflow(int c1, operator_t op,int c2){
  switch (op){
  case PLUS:
    let sum = c1 + c2;
    if ((~(c1 ^ c2) & (sum ^ c1)) >> 31){
      //overflow happened
      if (sum > 0) return $(true, MININT); //an underflow
      else return $(true, MAXINT); //an overflow
    } else return $(false, sum); //no overflow
  case MINUS:
    let dif = c1 - c2;
    if (((c1^c2) & (c1 ^ dif)) >> 31){
      //overflow happened
      if (dif > 0) return $(true, MININT); //an underflow
      else return $(true, MAXINT); //an overflow
    } else return $(false, dif); //no overflow
  default:
    Tcutil::impos("Pratt_Prover: bad operator in overflow check");
  }
}

//checking if the difference of two unsigned integers 
//could be correctly represented by a signed integer
//assuming size of (u/s)intger as sizeofint (32), assumming the highest bit
//as the sign bit.
static overflow_info_t 
is_unsigned_overflow(unsigned c1, operator_t op,unsigned c2){
  switch (op){
  case MINUS:
    int dif = c1 - c2;
    if (((c1^c2) & (~(c1 ^ dif))) >> 31){
      //overflow happened
      if (dif > 0) return $(true, MININT); //an underflow
      else return $(true, MAXINT); //an overflow
    } else return $(false, dif); //no overflow
  default:
    Tcutil::impos("Pratt_Prover: bad operator in overflow check");
  }
}

// assumes source and target do not have a distance between them in the
// graph.  inserts a new distance reflecting source - target <= d.
static void new_distance(node_t @`H source, node_t @`H target, bool is_signed, int d) {
  let dist = new Distance{NULL,target,d};
  if (is_signed) {
    dist->next = source->signed_distances;
    source->signed_distances = dist;
  } else {
    dist->next = source->unsigned_distances;
    source->unsigned_distances = dist;
  }
}

// Tries to set the distance between two terms it and jt to dist, and
// update the shortest paths between any two nodes in the graph.  Returns
// true iff the resulting graph is consistent with this new constraint.  
// Care must be taken when computing shortest paths to ensure that we
// don't end up with an overflow or underflow.
static bool set_dist(graph_t @g, node_t @`H i, node_t @`H j, int dist, bool is_signed) {
  // equivalent terms are always at distance 0.
  if (i == j && dist != 0) return false;
  let ij_dist = lookup_dist(i, j, is_signed);
  // if we already have a shorter parth, then this constraint is redundant
  if (ij_dist != NULL && *ij_dist < dist) return true;
  let ji_dist = lookup_dist(j, i, is_signed);
  // if  j --n--> i --dist--> j  and n+dist is negative, contradiction.
  if (ji_dist != NULL) {
    let $(overflow,sum) = is_signed_overflow(*ji_dist, PLUS, dist);
    if (sum < 0) return false; // overflow or not, there is a negative loop 
    // the edge will create a very positive loop and the weight of the loop
    // will overflow, so we will have to ignore the edge.
    else if (overflow && sum > 0) return true;
    // all other cases, proceed by adding the edge into the graph and
    // update the shortest paths.
  }
  for (let k = g->rows; k != NULL; k = k->next) {
    // skip nodes that aren't the representative of the equiv class
    if (k->equiv_class != NULL) continue;
    let ki_dist = lookup_dist(k, i, is_signed);
    if (ki_dist == NULL) continue; // no new path through ij
    for (let l = g->rows; l != NULL; l = l->next) {
      // skip nodes that aren't the representatives of the equiv class
      // and any node equal to k
      if (k == l || l->equiv_class != NULL) continue;
      let kl_dist = lookup_dist(k, l, is_signed);
      // if kl_dist is already MININT, no need to update.
      if (kl_dist != NULL && *kl_dist == (int)MININT) continue;
      let jl_dist = lookup_dist(j, l, is_signed);
      if (jl_dist == NULL) continue; // no new path through i->j
      // computing w(kj) = w(ki) + w(ij)
      $(bool,int) final_sum;
      let $(of1,sum1) = is_signed_overflow(*ki_dist, PLUS, dist);
      if (!of1) { // computing w(kl) = w(kj) + w(jl)
        final_sum = is_signed_overflow(sum1, PLUS, *jl_dist);
      } else {
        // now we know that ki_dist, ij_dist have the same sign
        // that's the only way the sum can cause overflow
        let $(of1,sum1) = is_signed_overflow(*ki_dist, PLUS, *jl_dist);
        if (!of1) {
          // FIX?  original code had sum here...
          final_sum = is_signed_overflow(sum1, PLUS, dist);
        } else {
          // now we know that ki_dist, ij_dist, jl_dist have the same sign
          // that's the only way both of1's are true.  If dist < 0 then
          // it must be an underflow, and if > 0 it must be an overflow.
          final_sum = $(true, dist < 0 ? MININT : MAXINT);
        }
      }
      let $(final_overflow,sum) = final_sum;
      // either there is no overflow in computing the sums, or there is
      // an underflow, so the true_sum < MININT
      if (!final_overflow || sum < 0) {
        // same node should always be at distance 0 from itself
        if (k == l && sum != 0) return false;
        // old k->l distance is infinite -- try adding a new edge.
        else if (kl_dist == NULL) new_distance(k,l,is_signed,sum);
        // old k->l distance is greater than new dist -- update edge.
        else if (*kl_dist > sum) *kl_dist = sum;
      }
    }
  }
  return true;
}

// same as above but maps terms to nodes first.
static bool set_distance(graph_t @g, term_t it, term_t jt, int dist, bool is_signed) {
  let iopt = term2node_opt(g,it);
  let jopt = term2node_opt(g,jt);
  if (iopt == NULL || jopt == NULL) return false;
  let i = (node_t@)iopt;
  let j = (node_t@)jopt;
  //fprintf(stderr,"calling set_dist on graph\n");
  //print_graph(g);
  return set_dist(g,i,j,dist,is_signed);
}

// Used in copy_graphs below to copy a set of edges from one graph to another.
static distance_t *copy_distances(graph_t @newg, distance_t *ds) {
  distance_t *res = NULL;
  for (; ds != NULL; ds = ds->next) {
    let t = compress(ds->target)->rep;
    res = new Distance{res,term2node(newg,t),ds->dist};
  }
  return res;
}

// Reverse a list of nodes in place.
static node_t *revnodes(node_t *`H n) {
  if (n == NULL) return NULL;
  node_t *first = n;
  node_t *second = n->next;
  n->next = NULL;
  while (second != NULL) {
    node_t *temp = second->next;
    second->next = first;
    first = second;
    second = temp;
  }
  return first;
}

// Produce a copy of the list of graphs -- care must be taken to get the
// sharing right in order to preserve equivalence classes and edges.
static graph_t *copy_graphs(graph_t *gopt) {
  if (gopt == NULL) return NULL;
  let g = (graph_t@)gopt;
  graph_t @newg = new Graph{.next = copy_graphs(g->next), .rows = NULL};
  // insert a row for each term
  node_t *newrs = NULL;
  for (let rs = g->rows; rs != NULL; rs = rs->next) {
    newrs = new Node{newrs,NULL,rs->rep,NULL,NULL};
  }
  newrs = revnodes(newrs);
  newg->rows = newrs;
  // process each row again, setting equivalence class pointers and
  // adding in distance edges.
  for (let rs = g->rows; rs != NULL; rs = rs->next, newrs=newrs->next){
    if (rs->equiv_class != NULL) 
      // In this case, r doesn't represent the equivalence class, so
      // find r's equivalence class in g, then look up the corresponding 
      // node in newg and set newr's equiv_class pointer to it.
      newrs->equiv_class = term2node(newg,compress(rs)->rep);
    else {
      // In this csae, r represents an equivalence class, so copy all of 
      // the distance edges.
      newrs->unsigned_distances = copy_distances(newg,rs->unsigned_distances);
      newrs->signed_distances = copy_distances(newg,rs->unsigned_distances);
    }
  }
  return newg;
}

// Try to merge two nodes into a single equivalence class within the 
// graph g, returning false if the resulting graph has an inconsistency
// and true otherwise.
static bool unify_nodes(graph_t @g, node_t @`H n1, node_t @`H n2) {
  n1 = compress(n1);
  n2 = compress(n2);
  if (n1 == n2) return true;
  node_t @source, @target;

  // try to pick a good candidate for the representative of the equivalence
  // class -- a constant is best.
  switch $(n1->rep, n2->rep) {
  case $(&Uint(i1),&Uint(i2)): if (i1 != i2) return false; fallthru;
  case $(_,&Uint(_)): 
  case $(&Var(_),_):
  case $(&LogicVar(...),_):
    source = n1;
    target = n2;
    break;
  default:
    source = n2;
    target = n1;
    break;
  }

  // add all of the source edges to the target.
  for (let sds = source->signed_distances; sds != NULL; sds = sds->next) 
    if (!set_dist(g, target, sds->target, sds->dist, true)) return false;
  // might as well nuke out the source edges as well.
  source->signed_distances = NULL;
  for (let uds = source->unsigned_distances; uds != NULL; uds = uds->next) 
    if (!set_dist(g, target, uds->target, uds->dist, false)) return false;
  source->unsigned_distances = NULL;

  // Now we need to get rid of the source column.  So we look at each
  // row r to see if there is an edge r--d-->source, and if so, delete that
  // edge and add in r--d-->target.  
  for (let r = g->rows; r != NULL; r = r->next) {
    // skip source row or non-equivalence-class row
    if (r == source || r->equiv_class != NULL) continue;
    // Process the signed edges first:
    // See if there is an edge from r-->target
    let rt_signed = lookup_dist(r,target,true);
    // If not, we don't have to do anything since source will now point to
    // target.  Otherwise, we have to lookup and delete any r->source edge,
    // adding it back in to point to target.
    if (rt_signed != NULL) {
      let rs_signed = lookup_and_delete_dist(r,source,true);
      if (rs_signed != NULL && (rt_signed == NULL || *rt_signed > *rs_signed))
        if (!set_dist(g, r, target, *rs_signed, true)) return false;
    }
    // Process the unsigned edges:
    let rt_unsigned = lookup_dist(r,target,false);
    if (rt_unsigned != NULL) {
      let rs_unsigned = lookup_and_delete_dist(r,source,false);
      if (rs_unsigned != NULL && (rt_unsigned == NULL || *rt_unsigned > *rs_unsigned))
        if (!set_dist(g, r, target, *rs_unsigned, false)) return false;
    }
  }
  // finally, set the source's equivalence class to be the target. 
  // subsequent lookups should now find the target.
  source->equiv_class = target;
  return true;
}

// If we have two nodes with representatives of the form Prim(p,[t11,...,tn1])
// and Prim(p,[t12,...,tn2]) and the sub-terms ti1 and ti2 map to equivalent
// nodes, then these equivalence classes should be collapsed.
//
// This is a truly horrible implementation -- worst case is cubic.  That
// could be reduced to quadratic by processing the nodes in a bottom up
// fashion.  I wish there was a more incremental solution.
static bool congruence_close_graph(graph_t @g) {
  bool changed = true;
  while (changed) {
    changed = false;
    for (let rs = g->rows; rs != NULL; rs = rs->next) {
      let rs_class = compress(rs);
      for (let ts = rs->next; ts != NULL; ts = ts->next) {
        let ts_class = compress(ts);
        if (rs_class == ts_class) continue;
        switch $(rs->rep,ts->rep) {
        case $(&Binop(p1,t11,t12,_),&Binop(p2,t21,t22,_)) && p1 == p2:
          let n11 = term2node_opt(g,t11);
          let n21 = term2node_opt(g,t21);
          if (n11 == NULL || n21 == NULL) return false;
          if (n11 != n21) break;
          let n12 = term2node_opt(g,t12);
          let n22 = term2node_opt(g,t22);
          if (n12 == NULL || n22 == NULL) return false;
          if (n12 != n22) break;
          if (!unify_nodes(g,rs,ts)) return false;
          break;
        case $(&Unop(p1,t1,_),&Unop(p2,t2,_)) && p1 == p2:
          let n1 = term2node_opt(g,t1);
          let n2 = term2node_opt(g,t2);
          if (n1 == NULL || n2 == NULL) return false;
          if (n1 != n2) break;
          if (!unify_nodes(g,rs,ts)) return false;
          break;
        case $(&Cast(tp1,t1),&Cast(tp2,t2)):
          if (Tcutil::typecmp(tp1,tp2) == 0) {
            let n1 = term2node_opt(g,t1);
            let n2 = term2node_opt(g,t2);
            if (n1 == NULL || n2 == NULL) return false;
            if (n1 == n2) {
              changed = true;
              if (!unify_nodes(g,rs,ts)) return false;
            }
          }
          break;
        default: break;
        }
      }
    }
  }
  return true;
}

// used in break_term and elsewhere to try to evaluate a term to a constant
static $(unsigned int,bool) eval_term(term_t t) {
  switch (t) {
  case &Uint(i): return $(i, true);
  case &Const(e): return Evexp::eval_const_uint_exp(e);
  default: return $(0,false);
  }
}

// break up a compound term that involves addition/subtraction of a constant
static $(term_t, int) break_term(graph_t @g, bool is_signed, term_t t){
  int c = 0;
  unsigned cu = 0u;
  term_t res = t;
  switch (t) {
  case &Binop(Absyn::Plus,t1,&Uint(c2),_):
    res = t1;
    c = (int)c2;
    cu = (unsigned int)c2;
    break;
  default:
    return $(t, 0);
  }
  //now we have t = res + c;
  //check if value_s(res) + value_s(c) overflow or underflow
  if (is_signed){
    if (c == 0) return $(res, 0); //no over/underflow
    else if (c > 0){
      // only overflow could possibily happen
      let dist = lookup_dist(term2node(g, res), term2node(g,zero()), true);
      if (dist == NULL || *dist > MAXINT - c){
	return $(t, 0);
      }else {// dist->length <= MAXINT-c, so value_s(t) + value_s(c) in bound
	return $(res, c);
      }
    } else {//c < 0 
      let dist = lookup_dist(term2node(g,zero()), term2node(g,res), true);
      if (dist == NULL || *dist > c - MININT){
	return $(t, 0);
      }else {
	//dist->length <= c - MININT
	// 0-v(res) <= dist->length  <= c - MININT
	// then v(res) + c >= MININT, no underflow here
	return $(res, c);
      }
    }
  } else {//is unsigned
    let dist = lookup_dist(term2node(g, res), term2node(g,zero()), false);
    if (dist == NULL) return $(t,0);
    if (*dist <=0) return $(res, cu);
    if (*dist > 0 && (unsigned)(*dist) <= MAXUINT - cu)
      return $(res, cu);
  }
  return $(t, 0);
}

// convert a primitive assertion to a constraint and add it to the graph.
// returns true if the resulting graph remains consistent, false otherwise.
// This does not deal with equality constraints -- those should've already
// been eliminated.
static bool add_constraint(graph_t @g, term_t t1, prim_reln_t p, term_t t2) {
  switch $(t1,t2) {
  case $(&Uint(c1),&Uint(c2)):
    switch (p) {
    case ULt: return (c1 < c2);
    case ULte: return (c1 <= c2);
    case SLt: return ((int)c1) < ((int)c2);
    case SLte: return ((int)c1) <= ((int)c2);
    default: Tcutil::impos("Vcgen: found bad primop in add_constraint");
    }
  case $(_,&Uint(c2)):
    // we have t1 p c2 -- add constraints of the form t1 - Zero p c2
    switch (p) {
    case ULt: 
      //no unsigned integer t could satisfy t u< 0
      if (c2 == 0) return false;
      c2 = c2 - 1; 
      fallthru;
    case ULte:
      // must check that c2 can be represented by an int.
      if (c2 <= (unsigned)MAXINT) {
	if (!set_distance(g,t1,zero(),(int)c2,false)) return false;
	// since t1 U<= c2 U<= MAXINT, we know t1 S<= c2 as well!
	return set_distance(g,t1,zero(),(int)c2,true);
      } else {// t u<= c2, and (int)c2 s< 0
	int *c1 = lookup_dist(term2node(g, t1), term2node(g,zero()), true);
	if (c1 != NULL && *c1 <= -1){
	  return set_distance(g, t1, zero(), (int)c2, true);
	}
      }
      return true;
    case SLt: 
      //no signed integer t could satisfy t s< MININT
      if (c2 == MININT) return false;
      c2 = c2 - 1;
      fallthru;
    case SLte:
      // the value of (int)c2 should be representable by an integer.
      if (!set_distance(g,t1,zero(),(int)c2,true)) return false;
      if ((int)c2 > 0){
	// 0 - t s<= c1  impies t >= -c1
	int *c1 = lookup_dist(term2node(g,zero()), term2node(g,t1), true);
	if (c1 != NULL && *c1 <= 0) // then t >= -c1 >= 0, so t>=0
	  // 0 <= t s<= c2, then t u<= c2
	  return set_distance(g, t1, zero(), (int)c2, false);
      }
      return true;
    default: Tcutil::impos("Vcgen: found bad primop in add_constraint");
    }
  case $(&Uint(c1),_):
    // we have c1 p t2 -- add constraints of the form zero - t2 p -c1
    switch (p) {
    case ULt: 
      //no unsigned integer t could be greater than the biggest unsigned
      if (c1 == MAXUINT) return false;
      c1 = c1 + 1;
      fallthru;
    case ULte:
      //c1 u<= t2
      if (c1 > MAXINT) {
	//MAXINT u< c1 u<= t u<= MAXUINT, 
	// (int)c1 s<= t s<= -1
	if (!set_distance(g, t2, zero(), -1, true)) return false;
	int k = -((int)c1);
	if (k > 0){
	  if (!set_distance(g, zero(), t2, k, true)) return false;
	}
      }
      if (c1 <= MAXINT + 1u){
	//-c1 can be representable by a signed int
	int k = -((int)c1);
	return set_distance(g,zero(),t2,k,false);
      }
      return true;
    case SLt: 
      //no signed integer could be greater than the biggest signed int
      if (c1 == MAXINT) return false;
      c1 = c1 + 1;
      fallthru;
    case SLte:
      // MININT s<= t doesn't provide much information
      if (c1 == MININT) return true;
      else{
	int k = -((int)c1);
	if ((int)c1 >=0){
	  //0 s<= c1 s<= t2
	  if (!set_distance(g, zero(), t2, k, false)) return false;
	}
	return set_distance(g,zero(),t2,k,true);
      }
    default: Tcutil::impos("Vcgen: found bad primop in add_constraint");
    }
  default: break;
  }
  // nothing special about the terms -- have to add them as standard
  // sort of constraints.
  // given t1 p t2, we want to find out if 
  // v(t1) = v(t1')+c1, v(t2)=v(t2')+c2
  switch (p) {
  case ULt:
    // add t1 - t2 U<= -1
    let $(tt1, c1) = break_term(g, false, t1);
    let $(tt2, c2) = break_term(g, false, t2);
    let $(of, dist) = is_unsigned_overflow((unsigned)c2, MINUS, (unsigned)c1);
    if (!of) {
      let $(of, dist) = is_unsigned_overflow((unsigned)dist, MINUS, 1u);
      if (!of){
	if (!set_distance(g, tt1, tt2, dist, false))
	  return false;
      }
    }
    return set_distance(g,t1,t2,-1,false);
  case ULte:
    // add t1 - t2 U<= 0
    let $(tt1, c1) = break_term(g, false, t1);
    let $(tt2, c2) = break_term(g, false, t2);
    let $(of, dist) = is_unsigned_overflow((unsigned)c2, MINUS, (unsigned)c1);
    if (!of){
      //      fprintf(stderr, "break terms into %s - %s <= %d\n",
      //	      term2string(tt1), term2string(tt2), dist);
      if (!set_distance(g, tt1, tt2, dist, false))
	return false;
    }
    return set_distance(g,t1,t2,0,false);
  case SLt:
    let $(tt1, c1) = break_term(g, true, t1);
    let $(tt2, c2) = break_term(g, true, t2);
    let $(of, dist) = is_signed_overflow((int)c2, MINUS, (int)c1);
    if (!of) {
      let $(of, dist) = is_signed_overflow((int)dist, MINUS, 1);
      if (!of){
	if (!set_distance(g, tt1, tt2, dist, true))
	  return false;
      }
    }
    return set_distance(g,t1,t2,-1,true);
  case SLte: 
    // add t1 - t2 S<= 0
    let $(tt1, c1) = break_term(g, true,t1);
    let $(tt2, c2) = break_term(g, true,t2);
    let $(of, dist) = is_signed_overflow(c2, MINUS, c1);
    if (!of){
      if(!set_distance(g, tt1, tt2, dist, true))
	return false;
    }
    return set_distance(g,t1,t2,0,true);
  default: Tcutil::impos("Vcgen:found bad primop in add_constraint");
  }
}

static bool add_eq(graph_t @g, term_t t1, term_t t2) {
  let n1 = term2node_opt(g,t1);
  let n2 = term2node_opt(g,t2);
  if (n1 == NULL || n2 == NULL) return false;
  return 
    // FIX: we shouldn't have to add these edges...
    unify_nodes(g,n1,n2) &&
    add_constraint(g, t1, ULte, t2) &&
    add_constraint(g, t2, ULte, t1) &&
    add_constraint(g, t1, SLte, t2) &&
    add_constraint(g, t2, SLte, t1);
}

datatype exn { TooLarge };
datatype exn.TooLarge too_large = TooLarge;

//FIX: add a way for the user to control this.
unsigned int max_paths = 33;
unsigned int max_paths_seen = 0;

// given a set of graphs gs representing A1 or A2 or ... or An
// and given assertion a, compute the set of graphs representing
// (A1 or A2 ... or An) and a.  This is written with explicit
// tail-calls to be as fast as possible.  If we end up with two
// many disjuncts, then we throw an exception to back out of the
// whole thing.  
//
// JGM: what we should probably do is delay pushing in the Or nodes
// until we've gotten all of the And, Prim, True, and False nodes
// pushed into the graphs.  That way we're more likely to hit an
// inconsistency early.
static graph_t *cgraph(graph_t *`H gs, assn_t a) {
 LOOP:
  //fprintf(stderr,"inserting assertion %s into \n",assn2string(a));
  //print_graphs(gs);
  if (gs == NULL) return gs; // already inconsistent
  switch (a) {
  case &True: break;         // gs and true == gs
  case &False: gs = NULL; break; // gs and false == false
  case &And(a1,a2): 
    gs = cgraph(gs,a1);  // gs and (a1 and a2) == (gs and a1) and a2
    a = a2;
    goto LOOP;
  case &Or(a1,a2):
    unsigned int n = num_graphs(gs);
    if (max_paths_seen < n) max_paths_seen = n;
    // too many disjuncts -- give up.  
    if (n >= max_paths) {
      throw &too_large; // could just set gs = true_graph(); 
    }
    // must copy the graphs since we mutate them in place
    graph_t *gs1 = gs;
    graph_t *gs2 = copy_graphs(gs);
    // compute (gs and a1)
    gs1 = cgraph(gs1,a1);
    // compute (gs and a2)
    gs2 = cgraph(gs2,a2);
    // return (gs and a1) or (gs and a2)
    gs = graph_append(gs1,gs2);
    break;
  case &Prim(t1,Neq,t2): 
    // must handle neq specially as t1 < t2 or t2 < t1 (both signed
    // and unsigned.)
    a = and(or(slt(t1,t2),slt(t2,t1)),or(ult(t1,t2),ult(t2,t1)));
    goto LOOP;
    //case &Prim(t1,Eq,t2):
    // explode t1 == t2 into t1 <= t2 and t2 <= t1 (both signed and unsigned)
    //a = and(and(and(slte(t1,t2),slte(t2,t1)),ulte(t1,t2)),ulte(t2,t1));
    //goto LOOP;
  case &Prim(t1,p,t2):
    // add the primitive relation to each graph, pruning out the
    // inconsistent ones.
    graph_t *prev = NULL;
    for (let g = gs; g != NULL; g = g->next) {
      bool res;
      if (p == Eq) 
        res = add_eq(g,t1,t2);
      else
        res = add_constraint(g,t1,p,t2);
      if (!res) {
        if (prev == NULL) {
          gs = g->next;
        } else {
          prev->next = g->next;
        }
      } else {
        prev = g;
      }
    }
    //fprintf(stderr,"after inserting primitive assn %s, graphs are\n",
    //        assn2string(a));
    //print_graphs(gs);
    break;
  default: 
    // reduce any substitutions or negations and go around the loop.
    a = reduce(a);
    goto LOOP;
  }
  return gs;
}

// check to see if an assertion is consistent using the constraint solver.
// if it returns false, then the assertion is definitely inconsistent.
// if it returns true, then the assertion might be consistent.
static bool consistent(assn_t a) {
  try {
    // start with just an empty graph (true) and then add in a
    graph_t *gs = cgraph(true_graph(),a);
    // if we get back an empty list of disjuncts (false) then
    // the graph is not consistent.
    /*
    if (gs != NULL) {
      fprintf(stderr,"resulting graphs are:\n");
      print_graphs(gs);
      fprintf(stderr,"\nTrying congruence closure...\n");
      graph_t *prev = NULL;
      for (graph_t *g = gs; g != NULL; g = g->next) {
        if (!congruence_close_graph((graph_t@)g)) {
          if (prev == NULL) {
            gs = g->next;
          } else {
            prev->next = g->next;
          }
        } else {
          prev = g;
        }
      }
      fprintf(stderr,"After congruence closure:\n");
      print_graphs(gs);
    }
    */
    return (gs != NULL);
  } catch {
    // if the graph has too many paths in it, we'll end up here.
    // we must conservatively assume that the assertion is consistent.
  case &TooLarge: return true;
  }
}

// see if ctxt |- a by trying to prove that ctxt and not(a) is inconsistent.
bool constraint_prove(assn_t ctxt, assn_t a) {
  assn_t b = and(ctxt,not(a));
  //wangyl DEBUGGING:
  //fprintf(stderr, "##### trying to prove: ######\n");
  //fprintf(stderr, "%s ###=>### %s\n", assn2string(ctxt), assn2string(a));
  return !consistent(b);
}
