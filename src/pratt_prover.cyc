#include "assndef.h"
#include <list.h>

using AssnDef;
using List;

namespace PrattProver;
//////////////////// Constraint Solving //////////////////
// We use a variation of the Pratt algorithm here where we keep
// track of a signed distance and an unsigned distance between terms 
// and find the minimal length signed and unsigned paths between any 
// two terms.  If we ever get a negative-length cycle,
// then the constraints are inconsistent.  
//
// We represent a conjunction of constraints as a sparse matrix of
// the distances.  We consider distance(i,j) == 0 implicitly, and
// otherwise, if (i,j) are not in the graph, the distance is infinite.
//
// To deal with an entire assertion, we must collect a set of graphs.
// representing alternative states.  This effectively converts the 
// assertion to DNF which is an exponential blowup.  To avoid running
// out of time or memory, we limit the blowup according to the
// variable max_paths.

// The edges in the graph record both signed and unsigned distance
// values, but only one of them may be valid, or both of them may
// be valid.
typedef enum DistanceInfo { 
  Unsigned_valid = 1,
  Signed_valid = 2,
  Both_valid = 3,
} distance_info_t;

typedef struct Dist{
  int length;
  assn_t_nullable prim; //to record a single edge shortest path's origin
} dist_t;
typedef struct Distance {
  struct Distance *next;  // ptr to next entry in sparse matrix
  term_t target;
  distance_info_t dinfo;  // whether unsigned_dist or signed_dist are valid.
  dist_t    unsigned_dist;
  dist_t    signed_dist;
} *distance_t;

typedef struct Row {
  struct Row *next;
  term_t source;
  distance_t distance;
} *row_t;


typedef struct Graph {
  struct Graph *next;    // ptr to next graph in disjunction
  row_t rows;
} graph_t;

// print out a set of graphs
static void print_graphs(graph_t* gs) {
  fprintf(stderr,"Graphs:\n");
  for (; gs != NULL; gs = gs->next) {
    fprintf(stderr,"\t{");
    for (let ns = gs->rows; ns != NULL; ns = ns->next) {
      let t1 = ns->source;
      for (let ds = ns->distance; ds != NULL; ds = ds->next) {
        let t2 = ds->target;
        if (ds->dinfo == Both_valid) {
          fprintf(stderr,"%s - %s U<= %d, %s - %s S<= %d",term2string(t1),
                  term2string(t2),ds->unsigned_dist.length,term2string(t1),
                  term2string(t2),ds->signed_dist.length);
        } else if (ds->dinfo == Signed_valid) {
          fprintf(stderr,"%s - %s S<= %d",term2string(t1),
                  term2string(t2),ds->signed_dist.length);
        } else {
          fprintf(stderr,"%s - %s U<= %d",term2string(t1),
                  term2string(t2),ds->unsigned_dist.length);
        }
        if (ds->next != NULL) fprintf(stderr,",");
      }
      fprintf(stderr,"}\n");
    }
  }
}

// determine the number of graphs
static unsigned int num_graphs(graph_t *`H gs) {
  unsigned n = 0;
  for (; gs != NULL; gs = gs->next)
    ++n;
  return n;
}

// represents "true" -- a singleton graph with no edges (everything
// is infinitely far apart.)
static graph_t @true_graph() { return new Graph{NULL,NULL};}

// used in copying of graphs
static distance_t copy_distance(distance_t ds) {
  distance_t res = NULL;
  for (; ds != NULL; ds = ds->next) {
    let newds = new *ds;
    newds->next = res;
    res = newds;
  }
  return res;
}

static row_t copy_rows(row_t ns) {
  row_t res = NULL;
  for (; ns != NULL; ns = ns->next) {
    res = new Row{.next = res, 
		  .source = ns->source, 
		  .distance=copy_distance(ns->distance)};
  }
  return res;
}

// copies a whole set of graphs -- used when we have a disjunction
static graph_t *copy_graph(graph_t * g) {
  graph_t *res = NULL;
  for (; g != NULL; g = g->next) {
    res = new Graph{res,copy_rows(g->rows)};
  }
  return res;
}

// appends two sets of graphs -- could be smarter and try to remove
// duplicates...
static graph_t *graph_append(graph_t *`H g1, graph_t *`H g2) {
  if (g1 == NULL) return g2;
  if (g2 == NULL) return g1;
  graph_t @p = g1;
  for (let x = p->next; x != NULL; p = x, x=p->next) /* skip */ ;
  p->next = g2;
  return g1;
}

// add a row to a single graph if not already present
static void add_node(graph_t @g, term_t n) {
  for (let ns = g->rows; ns != NULL; ns = ns->next) {
    if (cmp_term(ns->source,n) == 0) return;
  }
  g->rows = new Row{g->rows,n,NULL};
}

static row_t lookup_row(graph_t @g, term_t i) {
  for (let ns = g->rows; ns != NULL; ns = ns->next)
    if (cmp_term(i,ns->source) == 0) return ns;
  return NULL;
}

static distance_t lookup_col(row_t n, term_t j) {
  for (let ds = n->distance; ds != NULL; ds = ds->next)
    if (cmp_term(j,ds->target) == 0) return ds;
  return NULL;
}

// lookup the distance between i and j in the row -- returns NULL
// if the distance is infinite.
static dist_t* lookup_distance(row_t i, bool is_signed, term_t j) {
  static dist_t zero = Dist{0, NULL};
  if (cmp_term(i->source,j) == 0) 
    return &zero; // same term always at distance 0
  let ds = lookup_col(i,j);
  if (ds != NULL) {
    if (is_signed && (ds->dinfo & Signed_valid))
      return &ds->signed_dist;
    else if (!is_signed && (ds->dinfo & Unsigned_valid))
      return &ds->unsigned_dist;
    else
      return NULL;
  } else 
    return NULL;
}

// Assumes the signed or unsigned edge is not already in the graph,
// but that the nodes are already added in the graph.
// Inserts the edge as appropriate.  Must look through the Distance
// list to see if there's already an entry for i and j and update
// it instead of adding a new Distance node.
static void insert_distance(row_t i, bool is_signed, term_t j, int dist,assn_t_nullable origin) {
  if (cmp_term(i->source,j) == 0) return; // same term always at distance 0
  let ds = lookup_col(i,j);
  if (ds != NULL) {
    if (is_signed) { 
      ds->dinfo |= Signed_valid;
      ds->signed_dist.length = dist;
      ds->signed_dist.prim = origin;
    } else {
      ds->dinfo |= Unsigned_valid;
      ds->unsigned_dist.length = dist;
      ds->unsigned_dist.prim = origin;
    }
    return;
  }
  dist_t d = Dist{.length = dist, .prim = origin};
  i->distance = new Distance{i->distance,j,is_signed ? Signed_valid : Unsigned_valid,d,d};
}

// FIX: 32-bit dependency!
#define MAXINT  (2147483647)
#define MININT  (-2147483648)

//returns $(false, c1+c2) if there is no overflow in computing c1+c2
//returns $(true, MAXINT) if there is overflow (c1+c2 > MAXINT)
//returns $(true, MININT) if there is underflow (c1+c2 < MININT)
static $(bool, int) is_sum_overflow(int c1, int c2){
  let sum = c1 + c2;
  //c1 and c2 has the same sign, but sum has a different sign, 
  if ((~(c1 ^ c2) & (sum ^ c1)) >> 31){
    if (sum >> 31) return $(true, (int)MAXINT);
    else return $(true, (int)MININT);
  }
  return $(false, c1+c2);
}

// add an edge to a graph and close it off to find shortest paths.
// returns true if the resulting graph remains consistent and false
// otherwise.
// FIX: MUST WORRY ABOUT OVERFLOW ISSUES
// wangyl: here we are using signed integer to represent weight of
// the edges in the graph, we need to check if any overflow happens
// while computing shoterst path of all pairs and looking for negative
// weight cycles.
static bool add_edge(graph_t @g, bool is_signed, term_t i, term_t j, int dist, assn_t_nullable origin){
  add_node(g,i);
  add_node(g,j);
  dist_t* ij_dist = lookup_distance(lookup_row(g,i),is_signed,j);
  // if we already have a shorter path, then this constraint is redundant
  if (ij_dist != NULL && ij_dist->length < dist) 
    return true;
  dist_t* ji_dist = lookup_distance(lookup_row(g,j),is_signed,i);
  // if  j -n-> i -dist-> j  and n+dist is negative, we have a contradiction.
  // FIX -- distance could overflow
  if (ji_dist != NULL){
    int sum = ji_dist->length + dist;
    if(( ~((ji_dist->length) ^ dist) & (sum ^ dist)) >> 31){
      // overflow happened, the two operands have the same sign while the sum
      // has a different sign bit from the operand
      if (dist >> 31){
	//both operands are negative, then the sum is actually negative, the 
	//graph is inconsistent with the new edge.
	return false;
      }
      //both operands are positive, the sum should be positive
      //even if it overflowed to look like negative
      else return true; 
    }else{
      // no overflow, so just check the sum as we used to.
      if (sum < 0)
	return false; 
    }
  }

  // update shortest path for each pair of nodes
  let jrow = lookup_row(g,j);
  bool overflow;
  for (let ks = g->rows; ks != NULL; ks = ks->next) {
    let k = ks->source;
    let ki_dist = lookup_distance(ks,is_signed,i);
    if (ki_dist == NULL) continue;//no new path through ij
    for (let ls = g->rows; ls != NULL; ls = ls->next) {
      let l = ls->source;
      let kl_dist = lookup_distance(ks,is_signed,l);
      //if kl_dist is the smallest, no need to update.
      if (kl_dist != NULL && kl_dist->length == (int)MININT) continue;

      let jl_dist = lookup_distance(jrow,is_signed,l);
      if (jl_dist == NULL) continue;//no new path through ij

      overflow = false;
      int sum1, sum2;
      int new_dist;
      if((ki_dist->length ^ dist) >> 31){
	//two operands with different signs, no overflow;
	sum1 = ki_dist->length+dist;
	sum2 = jl_dist->length;
      }else if ((dist ^ jl_dist->length) >> 31){
	//two operands with different signs, no overflow;
	sum1 = dist + jl_dist->length;
	sum2 = ki_dist->length;
      }else{
	// *ki_dist, dist and jl_dist all have the same sign
	//might overflow here, need to check:
	sum1 = ki_dist->length+dist;
	if ((sum1 ^ dist) >>31) overflow = true;
	sum2 = jl_dist->length;
      }
      //positive overflow, has to throw out the edge.
      if (overflow && sum1 < 0) continue;
      //negative overflow, could assign MININT;
      if (overflow && sum1 >= 0) {
	insert_distance(ks, is_signed, l, (int)MININT, NULL);
	continue;
      }
      new_dist = sum1 + sum2;
      if ((sum1 ^ sum2) >> 31){
	//sum1 and sum2 have different signs, no overflow here
	//nothing needs to be done
	overflow = false;
      }else {
	//sum1 and sum2 have the same sign, might overflow here
	if (sum1 < 0 && new_dist > 0){
	  //underflow happened, 
	  //new dist is less than MININT
	  new_dist = (int)MININT;
	  overflow = false;
	}else if (sum1 > 0 && new_dist < 0){
	  overflow = true;
	  //new dist is bigger than MAXINT, overflow happened
	}
      }
      if (kl_dist == NULL){
	if (!overflow) {
	  //when distance is too big to be represented by int,
	  //just throw out the edge.
	  insert_distance(ks,is_signed,l,new_dist, NULL);
	}
      } else if (kl_dist->length > new_dist && !overflow) {
	//when the distance is too small to be represented by int,
	//it 's actually sound to replace it with an edge with
	//greater weight to get a distance representable by int
	kl_dist->length = new_dist;
	//the shortest path is not simple edge any more
	kl_dist->prim = NULL;
      }
    }
  }
  return true;
}

static $(unsigned int,bool) eval_term(term_t t) {
  switch (t) {
  case &Const(e): return Evexp::eval_const_uint_exp(e);
  default: return $(0,false);
  }
}


// convert a primitive assertion to a constraint and add it to the graph.
// returns true if the resulting graph remains consistent, false otherwise.
static bool add_constraint(graph_t @g, term_t t1, prim_reln_t p, term_t t2) {
  // first see if t1 or t2 is a constant as we can put in better
  // constraints then.
  let $(c1,okay1) = eval_term(t1);
  let $(c2,okay2) = eval_term(t2);
  let origin = AssnDef::prim(t1, p, t2);

  // FIX: NOT SURE IF ANY OF THIS IS RIGHT -- MUST WORRY ABOUT
  // OVERFLOW ISSUES!
  if (okay1 && okay2) {
    // we have c1 p c2 -- reduce to true or false immediately.
    switch (p) {
    case ULt: return (c1 < c2);
    case SLt: return ((int)c1) < ((int)c2);
    case ULte: return (c1 <= c2);
    case SLte: return ((int)c1) <= ((int)c2);
    default: Tcutil::impos("Vcgen: found bad primop in add_constraint");
    }
  } else if (okay2) {
    // we have t1 p c2 -- add constraints of the form t1 - Zero p c2
    switch (p) {
    case ULt: 
      c2 = c2 - 1; 
      fallthru;
    case ULte:
      // must check that c2 can be represented by an int.
      if (c2 <= (unsigned)MAXINT) {
	if (!add_edge(g,false,t1,zero(),(int)c2, origin)) return false;
	// since t1 U<= c2 U<= MAXINT, we know t1 S<= c2 as well!
	return add_edge(g,true,t1,zero(),(int)c2, NULL);
      }
      break;
    case SLt: 
      c2 = c2 - 1;
      fallthru;
    case SLte:
      if (!add_edge(g,true,t1,zero(),(int)c2, origin)) return false;
      // if c2 is positive then t1 S<= c2 implies t1 U<= c2
      //      if (c2 <= (unsigned)MAXINT)
      //	return add_edge(g,false,t1,zero(),(int)c2, NULL);
      // above conclusion is not true
      else return true;
    default: Tcutil::impos("Vcgen: found bad primop in add_constraint");
    }
  } else if (okay1) {
    // we have c1 p t2 -- add constraints of the form zero - t2 p -c1
    // FIX:  NOT CHECKING FOR OVERFLOW ISSUES HERE.
    switch (p) {
    case ULt: 
      c1 = c1 + 1;
      fallthru;
    case ULte:
      int k = -((int)c1);
      return add_edge(g,false,zero(),t2,k, origin);
    case SLt: 
      c1 = c1 + 1;
      fallthru;
    case SLte:
      int k = -((int)c1);
      return add_edge(g,true,zero(),t2,k, origin);
    default: Tcutil::impos("Vcgen: found bad primop in add_constraint");
    }
  }
  // nothing special about the terms -- have to add them as standard
  // sort of constraints.
  switch (p) {
  case ULt:
    // add t1 - t2 U<= -1
    return add_edge(g,false,t1,t2,-1, origin);
  case ULte:
    // add t1 - t2 U<= 0
    return add_edge(g,false,t1,t2,0, origin);
  case SLt:
    // add t1 - t2 S<= -1
    return add_edge(g,true,t1,t2,-1, origin);
  case SLte: 
    // add t1 - t2 S<= 0
    return add_edge(g,true,t1,t2,0, origin);
  default: Tcutil::impos("Vcgen:found bad primop in add_constraint");
  }
}

datatype exn { TooLarge };
datatype exn.TooLarge too_large = TooLarge;

//FIX: add a way for the user to control this.
unsigned int max_paths = 17;
unsigned int max_paths_seen = 0;

// given a set of graphs gs representing A1 or A2 or ... or An
// and given assertion a, compute the set of graphs representing
// (A1 or A2 ... or An) and a.  This is written with explicit
// tail-calls to be as fast as possible.  If we end up with two
// many disjuncts, then we throw an exception to back out of the
// whole thing.  
static graph_t *cgraph(graph_t *`H gs, assn_t a) {
 LOOP:
  //fprintf(stderr,"inserting assertion %s into \n",assn2string(a));
  //print_graphs(gs);
  if (gs == NULL) return gs; // already inconsistent
  switch (a) {
  case &True: break;         // gs and true == gs
  case &False: gs = NULL; break; // gs and false == false
  case &And(a1,a2): 
    gs = cgraph(gs,a2);  // gs and (a1 and a2) == (gs and a2) and a1
    a = a1;
    goto LOOP;
  case &Or(a1,a2):
    unsigned int n = num_graphs(gs);
    if (max_paths_seen < n) max_paths_seen = n;
    // too many disjuncts -- give up.  
    if (n >= max_paths) throw &too_large; // could just set gs = true_graph(); 
    // must copy the graphs since we mutate them in place
    graph_t *gs1 = gs;
    graph_t *gs2 = copy_graph(gs);
    // compute (gs and a1)
    gs1 = cgraph(gs1,a1);
    // compute (gs and a2)
    gs2 = cgraph(gs2,a2);
    // return (gs and a1) or (gs and a2)
    gs = graph_append(gs1,gs2);
    break;
  case &Prim(t1,Neq,t2): 
    // must handle neq specially as t1 < t2 or t2 < t1 (both signed
    // and unsigned.)
    a = and(or(slt(t1,t2),slt(t2,t1)),or(ult(t1,t2),ult(t2,t1)));
    goto LOOP;
  case &Prim(t1,Eq,t2):
    // explode t1 == t2 into t1 <= t2 and t2 <= t1 (both signed and unsigned)
    a = and(and(and(slte(t1,t2),slte(t2,t1)),ulte(t1,t2)),ulte(t2,t1));
    goto LOOP;
  case &Prim(t1,p,t2):
    // add the primitive relation to each graph, pruning out the
    // inconsistent ones.
    graph_t *prev = NULL;
    for (let g = gs; g != NULL; g = g->next) {
      if (!add_constraint(g,t1,p,t2)) {
        if (prev == NULL) {
          gs = g->next;
        } else {
          prev->next = g->next;
        }
      } else {
        prev = g;
      }
    }
    break;
  default: 
    // reduce any substitutions and go around the loop.
    a = reduce(a);
    goto LOOP;
  }
  // return the set of graphs
  return gs;
}

// check to see if an assertion is consistent using the constraint solver.
// if it returns false, then the assertion is definitely inconsistent.
// if it returns true, then the assertion might be consistent.
static bool consistent(assn_t a) {
  try {
    // start with just an empty graph (true) and then add in a
    graph_t ?gs = cgraph(true_graph(),a);
    // if we get back an empty list of disjuncts (false) then
    // the graph is not consistent.
    return (gs != NULL);
  } catch {
    // if the graph has too many paths in it, we'll end up here.
    // we must conservatively assume that the assertion is consistent.
  case &TooLarge: return true;
  }
}

// see if ctxt |- a by trying to prove that ctxt and not(a) is inconsistent.
bool constraint_prove(assn_t ctxt, assn_t a) {
  assn_t b = and(ctxt,not(a));
  return !consistent(b);
}

static row_t lookup_row_in_rows(row_t r, term_t i){
  for(; r != NULL; r = r->next){
    if (cmp_term(i, r->source) == 0) return r;
  }
  return NULL;
}

static row_t or2rows(row_t g1, row_t g2){
  row_t res = NULL;
  for(; g1 != NULL; g1 = g1->next){
    let r = lookup_row_in_rows(g2, g1->source);
    if (r != NULL){
      /* copy the row, but null the distance */
      let newrow = new *g1;
      newrow->next = res;
      res = newrow;
      res->distance = NULL;
      /* now merge the distance from two graphs */
      for (let d = g1->distance; d != NULL; d = d->next){
	distance_t dist_res = NULL;
	if (d -> dinfo & Signed_valid){
	  let d1 = d->signed_dist.length;
	  let d2_ptr = lookup_distance(r, true, d->target);
	  if (d2_ptr != NULL){
	    let d2 = d2_ptr->length;
	    let newd = d1 > d2 ? d->signed_dist:*d2_ptr;
	    dist_res = new Distance{.target = d->target, 
				    .next=res->distance, 
				    .dinfo = Signed_valid,
				    .unsigned_dist = Dist{0, NULL},
				    .signed_dist = newd};
	  }
	}
	if (d -> dinfo & Unsigned_valid){
	  let d1 = d->unsigned_dist.length;
	  let d2_ptr = lookup_distance(r, false, d->target);
	  if (d2_ptr != NULL){
	    let d2 = d2_ptr->length;
	    let newd = d1 > d2 ? d->unsigned_dist: *d2_ptr;
	    if (dist_res != NULL){
	      dist_res->unsigned_dist = newd;
	      dist_res->dinfo = Both_valid;
	    }else{
	      dist_res = new Distance{.target = d->target,
				      .next = res->distance,
				      .dinfo = Unsigned_valid,
				      .unsigned_dist = newd,
				      .signed_dist = Dist{0, NULL}};
	    }
	  }
	}
	if (dist_res != NULL){
	  res->distance = dist_res;
	}
      }
    }
  }
  return res;
}

term_t int2term(bool is_signed, int c){
  let s = is_signed?Absyn::Signed : Absyn::Unsigned;
  let e = Absyn::int_exp(s, c, 0);
  e->topt = Absyn::int_type(s, Absyn::Int_sz);
  return cnst(e);
}
assn_t edge2assn(term_t source, term_t target, int weight, bool is_signed){
  let s = is_signed ? SLte : ULte;
  let s1 = is_signed? SLt: ULt;
  assn_t result = &AssnDef::true_assn;
  if (source == zero()){
    result = prim(int2term(is_signed, -weight), s, target);
  }else if( target == zero()){
    result = prim(source, s, int2term(is_signed, weight));
  }else{
    switch (weight){
    case 0: result = prim(source, s, target); break;
    case -1: result = prim(source, s1, target); break;
    default: 
      //currently, the prim of the form t1 <= t2 + c where c!=0, or 1
      //is not going to get any extra benefit when being turned into edges
      //      fprintf(stderr, "## %s <= %s + (%d)\n", 
      //	      term2string(source),term2string(target), weight); 
      break;
    }
  }
  return result;
}


assn_t row2assn(row_t r){
  assn_t a = &AssnDef::true_assn;
  for( ;r!= NULL; r = r->next){
    for(let d = r->distance; d!=NULL; d=d->next){
      if (d->dinfo & Signed_valid){
	if (d->signed_dist.prim != NULL){
	  a = and(a, (assn_t)d->signed_dist.prim);
	}else{
	  a = and(a, edge2assn(r->source, d->target, d->signed_dist.length, true));
	}
      }
      if (d->dinfo & Unsigned_valid){
	if (d->unsigned_dist.prim != NULL){
	  a = and(a, (assn_t)d->unsigned_dist.prim);
	}else{
	  a = and(a, edge2assn(r->source, d->target, d->unsigned_dist.length, false));
	}
      }
    }
  }
  return a;
}
assn_t merge_assn(assn_t a1, assn_t a2){
    //turn a1 or a2 to DNF normal form, represented by a set of graphs
  let g = cgraph(true_graph(), or(a1,a2));
  if (g == NULL) return &AssnDef::false_assn;

  let row = g->rows;
  for(let row1 = g->next; row1 != NULL; row1 = row1->next){
    row = or2rows(row, row1->rows);
  }

  return row2assn(row);
}
