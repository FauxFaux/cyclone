#include "assndef.h"
#include <list.h>

using AssnDef;
using List;

namespace PrattProver;

// FIX: 32-bit dependency!
#define MAXINT (0x7FFFFFFF)
#define MININT (-MAXINT-1)
#define MAXUINT (0xFFFFFFFF)

///////////////////////// Constraint Solving ///////////////////////////
//
// This is a simple constraint solver that can determine the satisfiability
// of the conjunction of a set of constraints of the form (t1 - t2 <= c).
//
// We use a variation of the Pratt algorithm here where we keep track of a 
// signed distance and an unsigned distance between terms 
// and find the minimal length signed and unsigned paths between any 
// two terms.  If we ever get a negative-length cycle, then the constraints 
// are inconsistent.  
//
// We represent a conjunction of constraints as a sparse matrix of
// the distances.  We consider distance(i,j) == 0 implicitly, and
// otherwise, if (i,j) are not in the graph, the distance is infinite.
//
// To deal with an entire assertion, we must collect a set of graphs.
// representing alternative states.  This effectively converts the 
// assertion to DNF which is an exponential blowup.  To avoid the blowup,
// we aggressively prune inconsistent graphs.  

// Forward declaration -- represents an equivalence class for terms
// (and also a row within a graph.)
struct Node;
typedef struct Node node_t;


// An entry in the sparse matrix -- records the target node of the
// edge and the distance as a (signed) integer.
typedef struct Distance {
  struct Distance *next;
  node_t @target;
  int    dist;
} distance_t;


// Represents a row within a graph.
struct Node {
  node_t     *next;
  term_t      rep;
  bool        broken_as_signed;
  bool        broken_as_unsigned;
  distance_t *unsigned_distances;
  distance_t *signed_distances;
};

// A graph is essentially a pair of sparse matrices of 
// (node_t,node_t)->distance.  We represent the matrices by having
// a node row for each term.
typedef struct Graph {
  struct Graph *next;
  node_t       *rows;  // we keep the rows sorted by rep order
} graph_t;

static unsigned num_graphs(graph_t *gs) {
  unsigned c = 0;
  for (; gs != NULL; gs = gs->next)
    ++c;
  return c;
}

// An empty graph represents the proposition "true".
static graph_t@ true_graph() { return new Graph{NULL,NULL}; }

// Print out a graph.
void print_graph(graph_t @g) {
  fprintf(stderr,"{");
  if (g->rows == NULL) fprintf(stderr,"<true>");
  else {
    for (let rs = g->rows; rs != NULL; rs = rs->next) {
      let &Node{_,rep,_,_,uds,sds} = (node_t@)rs;
      for (; uds != NULL; uds = uds->next)
        fprintf(stderr,"%s - %s U<= %d\n ",term2string(rep),
                term2string(uds->target->rep),uds->dist);
      for (; sds != NULL; sds = sds->next) 
        fprintf(stderr,"%s - %s S<= %d\n ",term2string(rep),
                term2string(sds->target->rep),sds->dist);
    }
  }
  fprintf(stderr,"}\n");
}

// Print out a list of graphs.
void print_graphs(graph_t *g) {
  fprintf(stderr,"Graphs:-----------\n");
  if (g == NULL) fprintf(stderr,"<false>\n");
  else {
    for (; g != NULL; g = g->next) print_graph(g);
  }
  fprintf(stderr,"------------------\n");
}

// forward declarations
static node_t *term2node_opt(graph_t @g, term_t t);
static bool set_distance(graph_t @g, term_t s, term_t t, int dist, bool is_signed);
static bool add_constraint(graph_t @g, term_t t1, prim_reln_t p, term_t t2);
static bool add_eq(graph_t @g, term_t t1, term_t t2);
static bool break_term_in_graph(graph_t @g);
static $(bool,unsigned) term_is_const(graph_t @g, term_t t);
// check term to see if its type reveals its numelts is known and if so,
// add the information to the graph.  similarly, check if term's type
// is tag_t<valueof(e)> and if so, add term == e and if term is unsigned, 
// then add term >= 0.  Finally, if term = t + c, then add edges
// term -c-> t and t -(-c)-> term.  
static int add_type_info(graph_t @g, term_t term) {
  //for all terms t, we should know that:
  // s[t] - 0 <= MAXINT
  // 0 - u[t] <= 0
  if (!set_distance(g,term,zero(),MAXINT,true) ||
      !set_distance(g,zero(),term,0,false)) return false;
  switch (term) {
  case &Unop(Absyn::Numelts,x,_):
    // add term s< MAXINT and term u< MAXINT and 0 u<= term
    if (!set_distance(g,term,zero(),MAXINT-1,true) ||
        !set_distance(g,term,zero(),MAXINT-1,false) ||
        !set_distance(g,zero(),term,0,false)) return false;
    break;
  default: break;
  }
  let topt = get_term_type(term);
  if (topt != NULL) {
    type_t t = (type_t)topt;
    let eopt = Tcutil::get_type_bound(t);
    if (eopt != NULL) {
      term_t t1 = unop(Absyn::Numelts,term,Absyn::uint_type);
      // sigh -- must get rid of a cast to int/long
      exp_t e = (exp_t)eopt;
    loop:
      switch (e->r) {
      case &Absyn::Cast_e(tp2,e2,...):
        switch (Absyn::compress(tp2)) {
        case &Absyn::AppType(&Absyn::IntCon(_,s),_):
          if (s == Absyn::Int_sz || s == Absyn::Long_sz) {
            e = e2; goto loop;
          }
          break;
        default: break;
        }
        break;
      default: break;
      }
      term_t t2 = cnst((exp_t)e);
      if (!add_constraint(g,t2,ULte,t1)) return false;
      if (!add_constraint(g,t2,SLte,t1)) return false;
    }
    switch (Absyn::compress(t)) {
    case &Absyn::AppType(&Absyn::IntCon(Absyn::Unsigned,_),_):
      if (!add_constraint(g,zero(),ULte,term)) return false;
      break;
    case &Absyn::AppType(&Absyn::TagCon,&List{v,_}):
      switch (Absyn::compress(v)) {
      case &Absyn::ValueofType(e): add_eq(g,term,cnst(e)); break;
      case v2: 
        if (!add_eq(g,term,cnst(Absyn::valueof_exp(v2,0)))) return false; 
        break;
      }
      break;
    default: break;
    }
  }
  return true;
}

// Given a term, look up its row and if not found, then add the term 
// to the graph.  Keep things sorted by term order.
static node_t *term2node_opt(graph_t @g, term_t t) {
  // first see if we can find it directly.
  node_t *@prev = &g->rows;
  for (let r = g->rows; r != NULL; r = r->next) {
    int c = cmp_term(t,r->rep);
    if (c == 0) return r;
    if (c > 1) break;
    prev = &r->next;
  }
  // term not directly found -- insert it in the graph.  
  node_t *n;
  switch (t){
  case &Binop(Absyn::Plus,t1,&Uint(c2),_):
    n = new Node{*prev,t,false,false,NULL,NULL};
    break;
  default:
    n = new Node{*prev,t,true,true,NULL,NULL};
    break;
  }
  *prev = n;
  if (!add_type_info(g,t)) return NULL;
  return n;
}

static node_t @term2node(graph_t @g, term_t t) {
  return (node_t @)term2node_opt(g,t);
}

// Given a pair of nodes, look up their distance (if any) -- return
// NULL if no distance is found.  Special case when source and target
// are the same -- we always return a distance of zero.
static int *lookup_dist(node_t @`H source, node_t @`H target, bool is_signed) {
  static int zero = 0;
  if (source == target) return &zero;
  distance_t *ds = is_signed ? source->signed_distances : 
    source->unsigned_distances;
  for (; ds != NULL; ds = ds->next) 
    if (ds->target == target) return &ds->dist;
  return NULL;
}

// returns true iff t --0--> r and r --0--> t
// or else          r --c--> zero and zero --(-c)--> r and
//                  t --c--> zero and zero --(-c)--> t and
static bool eq_nodes(node_t @`H r, node_t @`H t, bool is_signed) {
  let rt_dist = lookup_dist(r,t,is_signed);
  let tr_dist = lookup_dist(t,r,is_signed);
  return (rt_dist != NULL && *rt_dist == 0 &&
          tr_dist != NULL && *tr_dist == 0);
}

static bool equal_nodes(node_t @`H s, node_t @`H r) {
  return eq_nodes(s,r,false) || eq_nodes(s,r,true);
}

static bool equal_terms(graph_t @g, term_t t1, term_t t2){
  let $(ok1,c1) = term_is_const(g,t1);
  let $(ok2,c2) = term_is_const(g,t2);
  if (ok1 && ok2 && c1 == c2) return true;
  let n1 = term2node(g,t1);
  let n2 = term2node(g,t2);
  if (equal_nodes(n1,n2)) return true;
  switch $(t1,t2){
  case $(&Unop(p11,t11,_),&Unop(p21,t21,_)) && p11 == p21:
    return equal_terms(g,t11,t21);
  case $(&Binop(p11,t11,t12,_),&Binop(p21,t21,t22,_)) && p11 == p21:
    return equal_terms(g,t11,t21) && equal_terms(g,t12,t22);
  case $(&Cast(tp1,t11),&Cast(tp2,t21)):
    return (Tcutil::typecmp(tp1,tp2) == 0 ) && equal_terms(g,t11,t21);
  default:
    return false;
  }
  return false;
}

// Append two lists of graphs, representing a disjunction
static graph_t *graph_append(graph_t *`H g1, graph_t *`H g2) {
  if (g1 == NULL) return g2;
  if (g2 == NULL) return g1;
  graph_t @p = g1;
  for (let x = p->next; x != NULL; p = x,x = p->next) /* skip */ ;
  p->next = g2;
  return g1;
}

//checking if the sum or difference of two signed integers overflowed
//assuming size of intger as sizeofint (32),assumming the highest bit
//as the sign bit.
#define sizeofint 32;
static $(bool, int) is_signed_overflow(int c1, int c2){
  int sum = c1 + c2;
  if ((~(c1 ^ c2) & (sum ^ c1)) >> 31){
    //overflow happened
    if (sum > 0) return $(true,-1); //an underflow
    else return $(true,1); //an overflow
  } 
  else return $(false,sum); //no overflow
}

// assumes source and target do not have a distance between them in the
// graph.  inserts a new distance reflecting source - target <= d.
static void new_distance(node_t @`H source, node_t @`H target, bool is_signed, int d) {
  let dist = new Distance{NULL,target,d};
  if (is_signed) {
    dist->next = source->signed_distances;
    source->signed_distances = dist;
  } else {
    dist->next = source->unsigned_distances;
    source->unsigned_distances = dist;
  }
}

// Tries to set the distance between two terms it and jt to dist, and
// update the shortest paths between any two nodes in the graph.  Returns
// true iff the resulting graph is consistent with this new constraint.  
// Care must be taken when computing shortest paths to ensure that we
// don't end up with an overflow or underflow.
static bool set_dist(graph_t @g, node_t @`H i, node_t @`H j, int dist, bool is_signed) {
  // equivalent terms are always at distance 0.
  if (i == j && dist < 0) return false;
  if (i == j && dist > 0) return true;
  let ij_dist = lookup_dist(i,j,is_signed);
  // if we already have a shorter parth, then this constraint is redundant
  if (ij_dist != NULL && *ij_dist < dist) return true;
  let ji_dist = lookup_dist(j,i,is_signed);
  // if  j --n--> i --dist--> j  and n+dist is negative, contradiction.
  if (ji_dist != NULL) {
    let $(overflow,sum) = is_signed_overflow(*ji_dist,dist);
    if (sum < 0) return false; // there is a negative loop 
  }
  for (let k = g->rows; k != NULL; k = k->next) {
    let ki_dist = lookup_dist(k,i,is_signed);
    if (ki_dist == NULL) continue; // no new path through ij
    for (let l = g->rows; l != NULL; l = l->next) {
      // skip nodes equal to k
      if (k == l) continue;
      let kl_dist = lookup_dist(k,l,is_signed);
      // if kl_dist is already MININT, no need to update.
      if (kl_dist != NULL && *kl_dist == MININT) continue;
      let jl_dist = lookup_dist(j,l,is_signed);
      if (jl_dist == NULL) continue; // no new path through i->j
      // computing w(kj) = w(ki) + w(ij)
      $(bool,int) final_sum;
      let $(of1,sum1) = is_signed_overflow(*ki_dist,dist);
      if (!of1) { // computing w(kl) = w(kj) + w(jl)
        final_sum = is_signed_overflow(sum1,*jl_dist);
      } else {
        // now we know that ki_dist, ij_dist have the same sign
        // that's the only way the sum can cause overflow
        let $(of1,sum1) = is_signed_overflow(*ki_dist,*jl_dist);
        if (!of1) {
          // FIX?  original code had sum here...
          final_sum = is_signed_overflow(sum1,dist);
        } else {
          // now we know that ki_dist, ij_dist, jl_dist have the same sign
          // that's the only way both of1's are true.  If dist < 0 then
          // it must be an underflow, and if > 0 it must be an overflow.
          final_sum = $(true,dist < 0 ? -1 : 1);
        }
      }
      let $(final_overflow,sum) = final_sum;
      // either there is no overflow in computing the sums, or there is
      // an underflow, so the true_sum < MININT
      if (!final_overflow) {
        // old k->l distance is infinite -- try adding a new edge.
        if (kl_dist == NULL) new_distance(k,l,is_signed,sum);
        // old k->l distance is greater than new dist -- update edge.
        else if (*kl_dist > sum) *kl_dist = sum;
      } else if (sum < 0) {//underflow happened
	if (kl_dist == NULL) new_distance(k,l,is_signed,MININT);
	else *kl_dist = MININT;
      }
    }
  }
  return true;
}

// same as above but maps terms to nodes first.
static bool set_distance(graph_t @g, term_t it, term_t jt, int dist, bool is_signed) {
  let iopt = term2node_opt(g,it);
  let jopt = term2node_opt(g,jt);
  if (iopt == NULL || jopt == NULL) return false;
  let i = (node_t@)iopt;
  let j = (node_t@)jopt;
  //fprintf(stderr,"calling set_dist on graph\n");
  //print_graph(g);
  if (!set_dist(g,i,j,dist,is_signed)) return false;
  return true;
}

// Used in copy_graphs below to copy a set of edges from one graph to another.
static distance_t *copy_distances(graph_t @newg, distance_t *ds) {
  distance_t *res = NULL;
  for (; ds != NULL; ds = ds->next) {
    let t = ds->target->rep;
    res = new Distance{res,term2node(newg,t),ds->dist};
  }
  return res;
}

// Reverse a list of nodes in place.
static node_t *revnodes(node_t *`H n) {
  if (n == NULL) return NULL;
  node_t *first = n;
  node_t *second = n->next;
  n->next = NULL;
  while (second != NULL) {
    node_t *temp = second->next;
    second->next = first;
    first = second;
    second = temp;
  }
  return first;
}

// Produce a copy of the list of graphs.
static graph_t *copy_graphs(graph_t *gopt) {
  if (gopt == NULL) return NULL;
  let g = (graph_t@)gopt;
  graph_t @newg = new Graph{.next = copy_graphs(g->next), .rows = NULL};
  // insert a row for each term
  node_t *newrs = NULL;
  for (let rs = g->rows; rs != NULL; rs = rs->next) {
    newrs = new Node{newrs,rs->rep,rs->broken_as_signed,
		     rs->broken_as_unsigned,NULL,NULL};
  }
  newrs = revnodes(newrs);
  newg->rows = newrs;
  // process each row again adding in distance edges
  for (let rs = g->rows; rs != NULL; rs = rs->next, newrs=newrs->next){
    newrs->unsigned_distances = copy_distances(newg,rs->unsigned_distances);
    newrs->signed_distances = copy_distances(newg,rs->unsigned_distances);
  }
  return newg;
}

// FIX: Make sure that Times, Div, Mod, Bitlshift, Bitlrshift
// will do the same thing for both signed, unsigned integers
// otherwise, we might want to mark the op with types.
// or just ignore their values.
static  unsigned eval_binop(Absyn::primop_t p, unsigned i1, unsigned i2){
  switch (p){
  case Absyn::Plus: return i1 + i2;
  case Absyn::Times: return i1 * i2;
  case Absyn::Minus: return i1 - i2;
  case Absyn::Div: return i1 / i2;
  case Absyn::Mod: return i1 % i2;
  case Absyn::Bitand: return i1 & i2;
  case Absyn::Bitor: return i1 | i2;
  case Absyn::Bitlshift: return i1 << i2;
  case Absyn::Bitlrshift: return i1 >> i2;
  default:
    Tcutil::impos("Vcgen: found bad primop in eval_binop");
  }
}

static unsigned eval_unop(Absyn::primop_t p, unsigned i ){
  switch (p){
  case Absyn::Not: return !i;
  case Absyn::Bitnot: return ~i;
  case Absyn::Minus: return -i;
  default:
    Tcutil::impos("Vcgen: found bad primop in add_constraint");
  }
}
// when ok, the term t is equal to the value i in the graph g.
static $(bool ok, unsigned i) term_is_const(graph_t @g, term_t t) {
  switch(t){
  case &Uint(c): return $(true,c);
  case &Binop(Absyn::Plus,t1,t2,topt):
    let $(ok1,c1) = term_is_const(g,t1);
    if (ok1) add_eq(g,t,binop(Absyn::Plus,t2,uint(c1),topt));
    let $(ok2,c2) = term_is_const(g,t2);
    if (ok2) add_eq(g,t,binop(Absyn::Plus,t1,uint(c2),topt));
    break;
  default: break;
  }
  let n = term2node_opt(g,t);
  if (n != NULL){
    let z = term2node(g,zero());
    let n2z_s = lookup_dist(n,z,true);
    if (n2z_s != NULL) {
      let z2n_s = lookup_dist(z,n,true);
      if (z2n_s != NULL && *n2z_s == -(*z2n_s)) return $(true,*n2z_s);
    }
    let n2z_u = lookup_dist(n,z,false);
    if (n2z_u != NULL) {
      let z2n_u = lookup_dist(z,n,false);
      if (z2n_u != NULL && *n2z_u == -(*z2n_u)) return $(true,*n2z_u);
    }
  }
  return $(false,0xbad);
}

// If we have two nodes with representatives of the form Prim(p,[t11,...,tn1])
// and Prim(p,[t12,...,tn2]) and the sub-terms ti1 and ti2 map to equivalent
// nodes, then we should equate these two terms.  We're relying on the fact
// that the rows are sorted in term order so that leaves are processed before
// compound terms.

// FIX: sub-terms might not be in the graph as node if they never occured
// in any comparisons. Do we want to add those sub-terms in?
static bool congruence_close_graph(graph_t @g) {
  for (let rs = g->rows; rs != NULL; rs = rs->next) {
    for (let ts = g->rows; ts != NULL; ts = ts->next){
      switch $(rs->rep,ts->rep){
      case $(&Binop(p1,t11,t12,_),&Binop(p2,t21,t22,_)) && p1 == p2:
        if (!equal_terms(g,t11,t21)) break;
        if (!equal_terms(g,t12,t22)) break;
        if (!add_eq(g,rs->rep,ts->rep)) return false;
        break;
      case $(&Unop(p1,t1,_),&Unop(p2,t2,_)) && p1 == p2:
        if (!equal_terms(g,t1,t2)) break;
        if (!add_eq(g,rs->rep,ts->rep)) return false;
        break;
      case $(&Cast(tp1,t1),&Cast(tp2,t2)):
        if (Tcutil::typecmp(tp1,tp2) == 0) {
          if (!equal_terms(g,t1,t2)) break;
          if (!add_eq(g,rs->rep,ts->rep)) return false;
        }
        break;
      default: break;
      }
    }
  }
  return true;
}

// run congruence closure on a set of graphs and weed out the disjuncts
static graph_t *congruence_close_graphs(graph_t *`H gs) {
  graph_t *prev = NULL;
  for (let g = gs; g != NULL; g = g->next) {
    if (!congruence_close_graph(g)) {
      if (prev == NULL) {
        gs = g->next;
      } else {
        prev->next = g->next;
      }
    } else {
      prev = g;
    }
  }
  return gs;
}


//find out if s[t] = s[t1+c2] =? s[t1] + c2
static $(bool, term_t, int) break_term(graph_t @g, term_t t, bool is_signed){
  switch (t){
  case &Binop(Absyn::Plus,t1,&Uint(c2),_):
    if ((int)c2 >= 0){
      // want to show that s[t1]+c2 not overflowing, i.e., s[t1] <= MAXINT-c2
      let dist = lookup_dist(term2node(g,t1),term2node(g,zero()),true);
      if (is_signed){
	if (dist != NULL && *dist <= MAXINT- (int)c2){
	  return $(true,t1,(int)c2);
	}
      } else {
	if (dist != NULL) return $(true,t1,(int)c2);
      }
    } else {// int(c2) < 0
      // want to show that s[t1]+c2 not underflowing, i.e., 0-s[t1] <= c2-MININT
      let dist = lookup_dist(term2node(g,zero()),term2node(g,t1),true);
      if (is_signed){
	if (dist != NULL && *dist <= (int)(c2-MININT)){
	  return $(true,t1,(int)c2);
	}
      } else {
	if (dist != NULL) return $(true,t1,(int)c2);
      }
    }
    break;
  default:
    break;
  }
  return $(false,t,0);  
}

static bool break_term_in_graph(graph_t @g){
  for(let rs = g->rows; rs != NULL; rs = rs->next){
    if (!rs->broken_as_signed){
      let $(ok,t1,c1) = break_term(g,rs->rep,true);
      if (ok){
	rs->broken_as_signed = true;
	if (!set_distance(g,rs->rep,t1,c1,true)) return false;
	if ((unsigned)c1 != MININT)
	  if (!set_distance(g,t1,rs->rep,-c1,true)) return false;
      }
    }
    if (!rs->broken_as_unsigned){
      let $(ok,t1,c1) = break_term(g,rs->rep,false);
      if (ok){
	rs->broken_as_unsigned = true;
	if (!set_distance(g,rs->rep,t1,c1,false)) return false;
	if ((unsigned)c1 != MININT)
	  if (!set_distance(g,t1,rs->rep,-c1,false)) return false;
      }
    }
    let $(ok,c1) = term_is_const(g,rs->rep);
    // we know that rs->rep == c, we try to solve subpart of rs->rep;
    if (ok){
      switch (rs->rep){
      case &Binop(Absyn::Plus,t1,&Uint(c2),_):
	rs->broken_as_signed = true;
	rs->broken_as_unsigned = true;
	if (!add_eq(g,t1,uint(c1-c2))) return false;
	break;
      default:
	break;
      }
    }
  }
  return true;
}

static graph_t *break_term_in_graphs(graph_t *`H gs){
  graph_t *prev = NULL;
  for (let g = gs; g != NULL; g = g->next) {
    if (!break_term_in_graph(g)) {
      if (prev == NULL) {
        gs = g->next;
      } else {
        prev->next = g->next;
      }
    } else {
      prev = g;
    }
  }
  return gs;
}
// convert a primitive assertion to a constraint and add it to the graph.
// returns true if the resulting graph remains consistent, false otherwise.
// This does not deal with equality constraints -- those should've already
// been eliminated.
static bool add_constraint(graph_t @g, term_t t1, prim_reln_t p, term_t t2) {
  switch $(t1,t2) {
  case $(&Uint(c1),&Uint(c2)):
    switch (p) {
    case ULt: return (c1 < c2);
    case ULte: return (c1 <= c2);
    case SLt: return ((int)c1) < ((int)c2);
    case SLte: return ((int)c1) <= ((int)c2);
    default: Tcutil::impos("Vcgen: found bad primop in add_constraint");
    }
  case $(_,&Uint(c2)):
    // we have t1 p c2 
    switch (p) {
    case ULt: 
      //no unsigned integer t could satisfy t u< 0
      if (c2 == 0) return false;
      c2 = c2 - 1; 
      fallthru;
    case ULte:
      // must check that c2 can be represented by an int.
      if (c2 <= MAXINT){
	// we know that  u[t1]-0 u< c2 and s[t1]-0 < c2
	return set_distance(g,t1,zero(),(int)c2,false);
      }
      return true;
    case SLt: 
      //no signed integer t could satisfy t s< MININT
      if (c2 == MININT) return false;
      c2 = c2 - 1;
      fallthru;
    case SLte:
      // the value of (int)c2 should be representable by an integer.
      return set_distance(g,t1,zero(),(int)c2,true);
    default: Tcutil::impos("Vcgen: found bad primop in add_constraint");
    }
  case $(&Uint(c1),_):
    // we have c1 p t2
    switch (p) {
    case ULt: 
      //no unsigned integer t could be greater than the biggest unsigned
      if (c1 == MAXUINT) return false;
      c1 = c1 + 1;
      fallthru;
    case ULte:
      //u[c1] <= u[t2] => 0 - u[t2] <= -u[c1]
      if (c1 > MAXINT) {
	//-u[c1] can't be represented by an integer, but we know that
	//0-u[t2] <= -u[c1] <= MININT
	return set_distance(g,zero(),t2,-MAXINT,false);
      }
      else { 
	//-u[c1] could be represented by an integer
	//0 - u[t2] <= -u[c1]
	return set_distance(g,zero(),t2,-((int)c1),false);
      }
      return true;
    case SLt: 
      //no signed integer could be greater than the biggest signed int
      if (c1 == MAXINT) return false;
      c1 = c1 + 1;
      fallthru;
    case SLte:
      // 0 - s[t2] <= -s[c1], -s[c1] could not represented by int
      // when c1 == MININT
      if (c1 == MININT) return true;
      return set_distance(g,zero(),t2,-((int)c1),true);
    default: Tcutil::impos("Vcgen: found bad primop in add_constraint");
    }
  default: break;
  }
  // nothing special about the terms -- have to add them as standard
  // sort of constraints.
  switch (p) {
  case ULt:
    // u[t1] < u[t2] => u[t1] - u[t2] <= -1
    return set_distance(g,t1,t2,-1,false);
  case ULte:
    // u[t1] <= u[t2] => u[t1] - u[t2] <= 0
    return set_distance(g,t1,t2,0,false);
  case SLt:
    // s[t1] < s[t2] => s[t1] - s[t2] <= -1
    return set_distance(g,t1,t2,-1,true);
  case SLte: 
    // s[t1] <= s[t2] => s[t1] - s[t2] <= 0
    return set_distance(g,t1,t2,0,true);
  default: Tcutil::impos("Vcgen:found bad primop in add_constraint");
  }
}

// try to set t1 == t2
static bool add_eq(graph_t @g, term_t t1, term_t t2) {
  if (t1 == t2) return true;
  return 
    add_constraint(g,t1,ULte,t2) &&
    add_constraint(g,t2,ULte,t1) &&
    add_constraint(g,t1,SLte,t2) &&
    add_constraint(g,t2,SLte,t1);
}

datatype exn { TooLarge };
datatype exn.TooLarge too_large = TooLarge;

//FIX: add a way for the user to control this.
unsigned int max_paths = 33;
unsigned int max_paths_seen = 0;

// given a set of graphs gs representing A1 or A2 or ... or An
// and given assertion a, compute the set of graphs representing
// (A1 or A2 ... or An) and a.  This is written with explicit
// tail-calls to be as fast as possible.  If we end up with two
// many disjuncts, then we throw an exception to back out of the
// whole thing.  
//
// JGM: what we should probably do is delay pushing in the Or nodes
// until we've gotten all of the And, Prim, True, and False nodes
// pushed into the graphs.  That way we're more likely to hit an
// inconsistency early.
static graph_t *cgraph(graph_t *`H gs, assn_t a) {
 LOOP:
  //fprintf(stderr,"inserting assertion %s into \n",assn2string(a));
  //print_graphs(gs);
  if (gs == NULL) return gs; // already inconsistent
  switch (a) {
  case &True: break;         // gs and true == gs
  case &False: gs = NULL; break; // gs and false == false
  case &And(a1,a2): 
    gs = cgraph(gs,a1);  // gs and (a1 and a2) == (gs and a1) and a2
    a = a2;
    goto LOOP;
  case &Or(a1,a2):
    unsigned int n = num_graphs(gs);
    if (max_paths_seen < n) max_paths_seen = n;
    // too many disjuncts -- give up.  
    if (n >= max_paths) {
      throw &too_large; // could just set gs = true_graph(); 
    }
    // must copy the graphs since we mutate them in place
    graph_t *gs1 = gs;
    graph_t *gs2 = copy_graphs(gs);
    // compute (gs and a1)
    gs1 = cgraph(gs1,a1);
    gs1 = break_term_in_graphs(gs1);
    // try to weed out graphs through congruence closure
    gs1 = congruence_close_graphs(gs1);
    // compute (gs and a2)
    gs2 = cgraph(gs2,a2);
    gs2 = break_term_in_graphs(gs2); 
    // try to weed out graphs through congruence closure
    gs2 = congruence_close_graphs(gs2);
    // return (gs and a1) or (gs and a2)
    gs = graph_append(gs1,gs2);
    break;
  case &Prim(t1,Neq,t2): 
    // must handle neq specially as t1 < t2 or t2 < t1 (both signed
    // and unsigned.)
    a = and(or(slt(t1,t2),slt(t2,t1)),or(ult(t1,t2),ult(t2,t1)));
    goto LOOP;
    //case &Prim(t1,Eq,t2):
    // explode t1 == t2 into t1 <= t2 and t2 <= t1 (both signed and unsigned)
    //a = and(and(and(slte(t1,t2),slte(t2,t1)),ulte(t1,t2)),ulte(t2,t1));
    //goto LOOP;
  case &Prim(t1,p,t2):
    // add the primitive relation to each graph, pruning out the
    // inconsistent ones.
    graph_t *prev = NULL;
    for (let g = gs; g != NULL; g = g->next) {
      bool res;
      if (p == Eq) 
        res = add_eq(g,t1,t2);
      else
        res = add_constraint(g,t1,p,t2);
      if (!res) {
        if (prev == NULL) {
          gs = g->next;
        } else {
          prev->next = g->next;
        }
      } else {
        prev = g;
      }
    }
    //fprintf(stderr,"after inserting primitive assn %s, graphs are\n",
    //        assn2string(a));
    //print_graphs(gs);
    break;
  default: 
    // reduce any substitutions or negations and go around the loop.
    a = reduce(a);
    goto LOOP;
  }
  return gs;
}

// check to see if an assertion is consistent using the constraint solver.
// if it returns false, then the assertion is definitely inconsistent.
// if it returns true, then the assertion might be consistent.
static bool consistent(assn_t a) {
  try {
    // start with just an empty graph (true) and then add in assertion a
    graph_t *gs = cgraph(true_graph(),a);
    // run congruence closure to weed out graphs
    gs = congruence_close_graphs(gs);
    gs = break_term_in_graphs(gs);
    // if we get back an empty list of disjuncts (false) then
    // the graph is not consistent.
    return (gs != NULL);
  } catch {
    // if the graph has too many paths in it, we'll end up here.
    // we must conservatively assume that the assertion is consistent.
  case &TooLarge: return true;
  }
}

// see if ctxt |- a by trying to prove that ctxt and not(a) is inconsistent.
bool constraint_prove(assn_t ctxt, assn_t a) {
  assn_t b = and(ctxt,not(a));
  return !consistent(b);
}
