#include "assndef.h"
#include <list.h>

using AssnDef;
using List;

namespace PrattProver;
//////////////////// Constraint Solving //////////////////
// We use a variation of the Pratt algorithm here where we keep
// track of a signed distance and an unsigned distance between terms 
// and find the minimal length signed and unsigned paths between any 
// two terms.  If we ever get a negative-length cycle,
// then the constraints are inconsistent.  
//
// We represent a conjunction of constraints as a sparse matrix of
// the distances.  We consider distance(i,j) == 0 implicitly, and
// otherwise, if (i,j) are not in the graph, the distance is infinite.
//
// To deal with an entire assertion, we must collect a set of graphs.
// representing alternative states.  This effectively converts the 
// assertion to DNF which is an exponential blowup.  To avoid running
// out of time or memory, we limit the blowup according to the
// variable max_paths.

// The edges in the graph record both signed and unsigned distance
// values, but only one of them may be valid, or both of them may
// be valid.
typedef enum DistanceInfo { 
  Unsigned_valid = 1,
  Signed_valid = 2,
  Both_valid = 3,
} distance_info_t;

typedef struct Dist{
  int length;
  assn_t_nullable prim; //to record a single edge shortest path's origin
} dist_t;
typedef struct Distance {
  struct Distance *next;  // ptr to next entry in sparse matrix
  term_t target;
  distance_info_t dinfo;  // whether unsigned_dist or signed_dist are valid.
  dist_t    unsigned_dist;
  dist_t    signed_dist;
} *distance_t;

typedef struct Row {
  struct Row *next;
  term_t source;
  distance_t distance;
} *row_t;


typedef struct Graph {
  struct Graph *next;    // ptr to next graph in disjunction
  row_t rows;
} graph_t;


// FIX: 32-bit dependency!
#define MAXINT  (2147483647)
//#define MININT  (-2147483648)
#define MININT (-MAXINT-1)
#define MAXUINT (0xFFFFFFFF)

// print out a set of graphs
static void print_graphs(graph_t* gs) {
  fprintf(stderr,"Graphs:\n");
  for (; gs != NULL; gs = gs->next) {
    fprintf(stderr,"\t{");
    for (let ns = gs->rows; ns != NULL; ns = ns->next) {
      let t1 = ns->source;
      for (let ds = ns->distance; ds != NULL; ds = ds->next) {
        let t2 = ds->target;
        if (ds->dinfo == Both_valid) {
          fprintf(stderr,"%s - %s U<= %d, %s - %s S<= %d",term2string(t1),
                  term2string(t2),ds->unsigned_dist.length,term2string(t1),
                  term2string(t2),ds->signed_dist.length);
        } else if (ds->dinfo == Signed_valid) {
          fprintf(stderr,"%s - %s S<= %d",term2string(t1),
                  term2string(t2),ds->signed_dist.length);
        } else {
          fprintf(stderr,"%s - %s U<= %d",term2string(t1),
                  term2string(t2),ds->unsigned_dist.length);
        }
        if (ds->next != NULL) fprintf(stderr,",");
      }
      fprintf(stderr,"}\n");
    }
  }
}

// determine the number of graphs
static unsigned int num_graphs(graph_t *`H gs) {
  unsigned n = 0;
  for (; gs != NULL; gs = gs->next)
    ++n;
  return n;
}

// represents "true" -- a singleton graph with no edges (everything
// is infinitely far apart.)
static graph_t @true_graph() { return new Graph{NULL,NULL};}

// used in copying of graphs
static distance_t copy_distance(distance_t ds) {
  distance_t res = NULL;
  for (; ds != NULL; ds = ds->next) {
    let newds = new *ds;
    newds->next = res;
    res = newds;
  }
  return res;
}

static row_t copy_rows(row_t ns) {
  row_t res = NULL;
  for (; ns != NULL; ns = ns->next) {
    res = new Row{.next = res, 
		  .source = ns->source, 
		  .distance=copy_distance(ns->distance)};
  }
  return res;
}

// copies a whole set of graphs -- used when we have a disjunction
static graph_t *copy_graph(graph_t * g) {
  graph_t *res = NULL;
  for (; g != NULL; g = g->next) {
    res = new Graph{res,copy_rows(g->rows)};
  }
  return res;
}

// appends two sets of graphs -- could be smarter and try to remove
// duplicates...
static graph_t *graph_append(graph_t *`H g1, graph_t *`H g2) {
  if (g1 == NULL) return g2;
  if (g2 == NULL) return g1;
  graph_t @p = g1;
  for (let x = p->next; x != NULL; p = x, x=p->next) /* skip */ ;
  p->next = g2;
  return g1;
}

static bool add_edge(graph_t @, bool, term_t, term_t, int, assn_t_nullable);
static bool add_constraint(graph_t @g, term_t t1, prim_reln_t p, term_t t2);

type_opt_t get_term_type(term_t t) {
  switch (t) {
  case &Const(e): return e->topt;
  case &Var(vd): return vd->type;
  case &LogicVar(_,_,topt): return topt;
  case &Primop(...): // fix -- could get info out here
    return NULL;
  case &Cast(type,_): return type;
  }
}

static void add_node(graph_t @g, term_t n);

static void add_eq(graph_t @g, term_t t1, term_t t2) {
  add_node(g,t2);
  //fprintf(stderr,"adding %s = %s to graph\n",term2string(t1),term2string(t2));
  add_constraint(g, t1, ULte, t2);
  add_constraint(g, t1, SLte, t2);
  add_constraint(g, t2, ULte, t1);
  add_constraint(g, t2, SLte, t1);
}

// check n to see if its type reveals its numelts is known and if so,
// add the information to the graph.  similarly, check if n's type
// is tag_t<valueof(e)> and if so, add n == e.
static void add_type_info(graph_t @g, term_t n) {
  let topt = get_term_type(n);
  if (topt != NULL) {
    type_t t = (type_t)topt;
    let eopt = Tcutil::get_type_bound(t);
    if (eopt != NULL) {
      term_t t1 = primop(Absyn::Numelts, list(n));
      // sigh -- must get rid of a cast to int/long
      exp_t e = (exp_t)eopt;
    loop:
      switch (e->r) {
      case &Absyn::Cast_e(tp2,e2,...):
        switch (Absyn::compress(tp2)) {
        case &Absyn::AppType(&Absyn::IntCon(_,s),_):
          if (s == Absyn::Int_sz || s == Absyn::Long_sz) {
            e = e2; goto loop;
          }
          break;
        default: break;
        }
        break;
      default: break;
      }
      term_t t2 = cnst((exp_t)e);
      add_eq(g,t1,t2);
    }
    switch (Absyn::compress(t)) {
    case &Absyn::AppType(&Absyn::TagCon,&List{v,_}):
      switch (Absyn::compress(v)) {
      case &Absyn::ValueofType(e): add_eq(g,n,cnst(e)); break;
      case v2: add_eq(g,n,cnst(Absyn::valueof_exp(v2,0))); break;
      }
      break;
    default: break;
    }
  }
}

// add a row to a single graph if not already present
static void add_node(graph_t @g, term_t n) {
  for (let ns = g->rows; ns != NULL; ns = ns->next) {
    if (cmp_term(ns->source,n) == 0) return;
  }
  g->rows = new Row{g->rows,n,NULL};
  // if n is numelts(x) then add n <s MAXINT and n <u MAXINT
  switch (n){
  case &Primop(Absyn::Numelts, &List(x,_)):
    add_edge(g, false, n, zero(), MAXINT-1, NULL);
    add_edge(g, true, n, zero(), MAXINT-1, NULL);
    // if x has type T*{e}, then add numelts(n) == e.
    add_type_info(g,x);
    break;
  default:
    add_type_info(g,n);
    break;
  }
}

static row_t lookup_row(graph_t @g, term_t i) {
  for (let ns = g->rows; ns != NULL; ns = ns->next)
    if (cmp_term(i,ns->source) == 0) return ns;
  return NULL;
}

static distance_t lookup_col(row_t n, term_t j) {
  for (let ds = n->distance; ds != NULL; ds = ds->next)
    if (cmp_term(j,ds->target) == 0) return ds;
  return NULL;
}

// lookup the distance between i and j in the row -- returns NULL
// if the distance is infinite.
static dist_t* lookup_distance(row_t i, bool is_signed, term_t j) {
  static dist_t zero = Dist{0, NULL};
  if (i == NULL) return NULL;
  if (cmp_term(i->source,j) == 0) 
    return &zero; // same term always at distance 0
  let ds = lookup_col(i,j);
  if (ds != NULL) {
    if (is_signed && (ds->dinfo & Signed_valid))
      return &ds->signed_dist;
    else if (!is_signed && (ds->dinfo & Unsigned_valid))
      return &ds->unsigned_dist;
    else
      return NULL;
  } else 
    return NULL;
}

// Assumes the signed or unsigned edge is not already in the graph,
// but that the nodes are already added in the graph.
// Inserts the edge as appropriate.  Must look through the Distance
// list to see if there's already an entry for i and j and update
// it instead of adding a new Distance node.
static void insert_distance(row_t i, bool is_signed, term_t j, int dist,assn_t_nullable origin) {
  if (cmp_term(i->source,j) == 0) return; // same term always at distance 0
  let ds = lookup_col(i,j);
  if (ds != NULL) {
    if (is_signed) { 
      ds->dinfo |= Signed_valid;
      ds->signed_dist.length = dist;
      ds->signed_dist.prim = origin;
    } else {
      ds->dinfo |= Unsigned_valid;
      ds->unsigned_dist.length = dist;
      ds->unsigned_dist.prim = origin;
    }
    return;
  }
  dist_t d = Dist{.length = dist, .prim = origin};
  i->distance = new Distance{i->distance,j,is_signed ? Signed_valid : Unsigned_valid,d,d};
}



typedef $(bool, int) overflow_info_t;

typedef enum Operator{
  PLUS,
  MINUS,
} operator_t;


//checking if the sum or difference of two signed integers overflowed
//assuming size of intger as sizeofint (32), assumming the highest bit
//as the sign bit.
#define sizeofint 32;
static overflow_info_t is_overflow(int c1, operator_t op,int c2){
  switch (op){
  case PLUS:
    let sum = c1 + c2;
    if ((~(c1 ^ c2) & (sum ^ c1)) >> 31){
      //overflow happened
      if (sum > 0) return $(true, MININT); //an underflow
      else return $(true, MAXINT); //an overflow
    } else return $(false, sum); //no overflow
  case MINUS:
    let dif = c1 - c2;
    if (((c1^c2) & (c1 ^ dif)) >> 31){
      //overflow happened
      if (dif > 0) return $(true, MININT); //an underflow
      else return $(true, MAXINT); //an overflow
    } else return $(false, dif); //no overflow
  default:
    Tcutil::impos("Pratt_Prover: bad operator in overflow check");
  }
}

// add an edge to a graph and close it off to find shortest paths.
// returns true if the resulting graph remains consistent and false
// otherwise.
// FIX: MUST WORRY ABOUT OVERFLOW ISSUES
// wangyl: here we are using signed integer to represent weight of
// the edges in the graph, we need to check if any overflow happens
// while computing shoterst path of all pairs and looking for negative
// weight cycles.
static bool add_edge(graph_t @g, bool is_signed, term_t i, term_t j, int dist, assn_t_nullable origin){
  add_node(g,i);
  add_node(g,j);
  dist_t* ij_dist = lookup_distance(lookup_row(g,i),is_signed,j);
  // if we already have a shorter path, then this constraint is redundant
  if (ij_dist != NULL && ij_dist->length < dist) 
    return true;
  dist_t* ji_dist = lookup_distance(lookup_row(g,j),is_signed,i);
  // if  j -n-> i -dist-> j  and n+dist is negative, we have a contradiction.
  if (ji_dist != NULL){
    let $(overflow, sum) = is_overflow(ji_dist->length, PLUS, dist);
    if (sum < 0){
      //underflowed or not, there is a negative loop indeed
      return false;
    }else if (overflow && sum > 0){
      //the edge will create a very positive loop and the 
      //weight of the loop will overflow, so we will have to 
      //ignore the edge (by not adding it)
      return true;
    }
    //all other cases, proceed by adding the edge into the graph.
  }

  // adding a new edge, update shortest path
  let jrow = lookup_row(g,j);
  for (let ks = g->rows; ks != NULL; ks = ks->next) {
    let k = ks->source;
    let ki_dist = lookup_distance(ks,is_signed,i);
    if (ki_dist == NULL) continue;//no new path through ij
    for (let ls = g->rows; ls != NULL; ls = ls->next) {
      let l = ls->source;
      let kl_dist = lookup_distance(ks,is_signed,l);
      //if kl_dist is the smallest, no need to update.
      if (kl_dist != NULL && kl_dist->length == (int)MININT) continue;

      let jl_dist = lookup_distance(jrow,is_signed,l);
      if (jl_dist == NULL) continue;//no new path through ij

      // computing w(kj) = w(ki) + w(ij)
      bool final;
      int sum;
      let $(of1, sum1) = is_overflow(ki_dist->length, PLUS, dist);
      if (!of1){
	//computing w(kl) = w(kj) + w(jl)
	let $(of2, sum2) = is_overflow(sum1, PLUS, jl_dist->length);
	final = of2;
	sum = sum2;
      }else {
	//now we know that ki_dist, ij_dist have the same sign
	//that's the only way the sum can cause overflow
	let $(of1, sum1) = is_overflow(ki_dist->length, PLUS, jl_dist->length);
	if (!of1){
	  let $(of2, sum2) = is_overflow(sum1, PLUS, dist);
	  final = of2;
	  sum = sum;
	}else {
	  //now we know that ki_dist, ij_dist, jl_dist have the same sign
	  //that's the only way both of1's are true
	  final = true;
	  if (dist < 0){
	    //it's an underflow, because everything is negative
	    sum = MININT;
	  }else{
	    //it's an overflow, everything is too big 
	    sum = MAXINT;
	  }
	}
      }
      if (!final || (sum < 0)){
	//either ther is no overflow in computing the sums,
	//or there is an underflow, so the true_sum < MININT
	if ((kl_dist == NULL) || (kl_dist->length > sum))
	  insert_distance(ks,is_signed,l,sum, NULL);
      }
    }
  }
  return true;
}

static $(unsigned int,bool) eval_term(term_t t) {
  switch (t) {
  case &Const(e): return Evexp::eval_const_uint_exp(e);
  default: return $(0,false);
  }
}


// convert a primitive assertion to a constraint and add it to the graph.
// returns true if the resulting graph remains consistent, false otherwise.
static bool add_constraint(graph_t @g, term_t t1, prim_reln_t p, term_t t2) {
  // first see if t1 or t2 is a constant as we can put in better
  // constraints then.
  let $(c1,okay1) = eval_term(t1);
  let $(c2,okay2) = eval_term(t2);
  let origin = AssnDef::prim(t1, p, t2);
  // FIX: NOT SURE IF ANY OF THIS IS RIGHT -- MUST WORRY ABOUT
  // OVERFLOW ISSUES!
  if (okay1 && okay2) {
    // we have c1 p c2 -- reduce to true or false immediately.
    switch (p) {
    case ULt: return (c1 < c2);
    case SLt: return ((int)c1) < ((int)c2);
    case ULte: return (c1 <= c2);
    case SLte: return ((int)c1) <= ((int)c2);
    default: Tcutil::impos("Vcgen: found bad primop in add_constraint");
    }
  } else if (okay2) {
    // we have t1 p c2 -- add constraints of the form t1 - Zero p c2
    switch (p) {
    case ULt: 
      //no unsigned integer t could satisfy t u< 0
      if (c2 == 0) return false;
      c2 = c2 - 1; 
      fallthru;
    case ULte:
      // must check that c2 can be represented by an int.
      if (c2 <= (unsigned)MAXINT) {
	if (!add_edge(g,false,t1,zero(),(int)c2, origin)) return false;
	// since t1 U<= c2 U<= MAXINT, we know t1 S<= c2 as well!
	return add_edge(g,true,t1,zero(),(int)c2, NULL);
      } else {// t u<= c2, and (int)c2 s< 0
	dist_t *c1 = lookup_distance(lookup_row(g, t1), true, zero());
	if (c1 != NULL && c1->length <= -1){
	  return add_edge(g, true, t1, zero(), (int)c2, NULL);
	}
      }
      return true;
    case SLt: 
      //no signed integer t could satisfy t s< MININT
      if (c2 == MININT) return false;
      c2 = c2 - 1;
      fallthru;
    case SLte:
      // the value of (int)c2 should be representable by an integer.
      if (!add_edge(g,true,t1,zero(),(int)c2, origin)) return false;
      if ((int)c2 > 0){
	// 0 - t s<= c1  impies t >= -c1
	dist_t * c1 = lookup_distance(lookup_row(g, zero()), true, t1);
	if (c1 != NULL && c1->length <= 0) // then t >= -c1 >= 0, so t>=0
	  // 0 <= t s<= c2, then t u<= c2
	  return add_edge(g, false, t1, zero(), (int)c2, NULL);
      }
      return true;
    default: Tcutil::impos("Vcgen: found bad primop in add_constraint");
    }
  } else if (okay1) {
    // we have c1 p t2 -- add constraints of the form zero - t2 p -c1
    switch (p) {
    case ULt: 
      //no unsigned integer t could be greater than the biggest unsigned
      if (c1 == MAXUINT) return false;
      c1 = c1 + 1;
      fallthru;
    case ULte:
      //c1 u<= t2
      if (c1 > MAXINT) {
	//MAXINT u< c1 u<= t u<= MAXUINT, 
	// (int)c1 s<= t s<= -1
	if (!add_edge(g, true, t2, zero(), -1, NULL)) return false;
	int k = -((int)c1);
	if (k > 0){
	  if (!add_edge(g, true, zero(), t2, k, NULL)) return false;
	}
      }
      if (c1 <= MAXINT + 1u){
	//-c1 can be representable by a signed int
	int k = -((int)c1);
	return add_edge(g,false,zero(),t2,k, origin);
      }
      return true;
    case SLt: 
      //no signed integer could be greater than the biggest signed int
      if (c1 == MAXINT) return false;
      c1 = c1 + 1;
      fallthru;
    case SLte:
      // MININT s<= t doesn't provide much information
      if (c1 == MININT) return true;
      else{
	int k = -((int)c1);
	if ((int)c1 >=0){
	  //0 s<= c1 s<= t2
	  if (!add_edge(g, false, zero(), t2, k, NULL)) return false;
	}
	return add_edge(g,true,zero(),t2,k, origin);
      }
    default: Tcutil::impos("Vcgen: found bad primop in add_constraint");
    }
  }
  // nothing special about the terms -- have to add them as standard
  // sort of constraints.
  switch (p) {
  case ULt:
    // add t1 - t2 U<= -1
    return add_edge(g,false,t1,t2,-1, origin);
  case ULte:
    // add t1 - t2 U<= 0
    return add_edge(g,false,t1,t2,0, origin);
  case SLt:
    // add t1 - t2 S<= -1
    return add_edge(g,true,t1,t2,-1, origin);
  case SLte: 
    // add t1 - t2 S<= 0
    return add_edge(g,true,t1,t2,0, origin);
  default: Tcutil::impos("Vcgen:found bad primop in add_constraint");
  }
}

datatype exn { TooLarge };
datatype exn.TooLarge too_large = TooLarge;

//FIX: add a way for the user to control this.
unsigned int max_paths = 17;
unsigned int max_paths_seen = 0;
unsigned int max_parallel_assn = 4;

// given a set of graphs gs representing A1 or A2 or ... or An
// and given assertion a, compute the set of graphs representing
// (A1 or A2 ... or An) and a.  This is written with explicit
// tail-calls to be as fast as possible.  If we end up with two
// many disjuncts, then we throw an exception to back out of the
// whole thing.  
static graph_t *cgraph(graph_t *`H gs, assn_t a) {
 LOOP:
  //fprintf(stderr,"inserting assertion %s into \n",assn2string(a));
  //print_graphs(gs);
  if (gs == NULL) return gs; // already inconsistent
  switch (a) {
  case &True: break;         // gs and true == gs
  case &False: gs = NULL; break; // gs and false == false
  case &And(a1,a2): 
    gs = cgraph(gs,a1);  // gs and (a1 and a2) == (gs and a1) and a2
    a = a2;
    goto LOOP;
  case &Or(a1,a2):
    unsigned int n = num_graphs(gs);
    if (max_paths_seen < n) max_paths_seen = n;
    // too many disjuncts -- give up.  
    if (n >= max_paths) throw &too_large; // could just set gs = true_graph(); 
    // must copy the graphs since we mutate them in place
    graph_t *gs1 = gs;
    graph_t *gs2 = copy_graph(gs);
    // compute (gs and a1)
    gs1 = cgraph(gs1,a1);
    // compute (gs and a2)
    gs2 = cgraph(gs2,a2);
    // return (gs and a1) or (gs and a2)
    gs = graph_append(gs1,gs2);
    break;
  case &Prim(t1,Neq,t2): 
    // must handle neq specially as t1 < t2 or t2 < t1 (both signed
    // and unsigned.)
    a = and(or(slt(t1,t2),slt(t2,t1)),or(ult(t1,t2),ult(t2,t1)));
    goto LOOP;
  case &Prim(t1,Eq,t2):
    // explode t1 == t2 into t1 <= t2 and t2 <= t1 (both signed and unsigned)
    a = and(and(and(slte(t1,t2),slte(t2,t1)),ulte(t1,t2)),ulte(t2,t1));
    goto LOOP;
  case &Prim(t1,p,t2):
    // add the primitive relation to each graph, pruning out the
    // inconsistent ones.
    graph_t *prev = NULL;
    for (let g = gs; g != NULL; g = g->next) {
      if (!add_constraint(g,t1,p,t2)) {
        if (prev == NULL) {
          gs = g->next;
        } else {
          prev->next = g->next;
        }
      } else {
        prev = g;
      }
    }
    break;
  default: 
    // reduce any substitutions and go around the loop.
    a = reduce(a);
    goto LOOP;
  }
  // return the set of graphs
  return gs;
}

// check to see if an assertion is consistent using the constraint solver.
// if it returns false, then the assertion is definitely inconsistent.
// if it returns true, then the assertion might be consistent.
static bool consistent(assn_t a) {
  try {
    // start with just an empty graph (true) and then add in a
    graph_t ?gs = cgraph(true_graph(),a);
    // if we get back an empty list of disjuncts (false) then
    // the graph is not consistent.
    return (gs != NULL);
  } catch {
    // if the graph has too many paths in it, we'll end up here.
    // we must conservatively assume that the assertion is consistent.
  case &TooLarge: return true;
  }
}

// see if ctxt |- a by trying to prove that ctxt and not(a) is inconsistent.
bool constraint_prove(assn_t ctxt, assn_t a) {
  assn_t b = and(ctxt,not(a));
  //wangyl DEBUGGING:
  //fprintf(stderr, "##### trying to prove: ######\n");
  //fprintf(stderr, "%s ###=>### %s\n", assn2string(ctxt), assn2string(a));
  return !consistent(b);
}

static row_t lookup_row_in_rows(row_t r, term_t i){
  for(; r != NULL; r = r->next){
    if (cmp_term(i, r->source) == 0) return r;
  }
  return NULL;
}

static row_t or2rows(row_t g1, row_t g2){
  row_t res = NULL;
  for(; g1 != NULL; g1 = g1->next){
    let r = lookup_row_in_rows(g2, g1->source);
    if (r != NULL){
      /* copy the row, but null the distance */
      let newrow = new *g1;
      newrow->next = res;
      res = newrow;
      res->distance = NULL;
      /* now merge the distance from two graphs */
      for (let d = g1->distance; d != NULL; d = d->next){
	distance_t dist_res = NULL;
	if (d -> dinfo & Signed_valid){
	  let d1 = d->signed_dist.length;
	  let d2_ptr = lookup_distance(r, true, d->target);
	  if (d2_ptr != NULL){
	    let d2 = d2_ptr->length;
	    let newd = d1 > d2 ? d->signed_dist:*d2_ptr;
	    dist_res = new Distance{.target = d->target, 
				    .next=res->distance, 
				    .dinfo = Signed_valid,
				    .unsigned_dist = Dist{0, NULL},
				    .signed_dist = newd};
	  }
	}
	if (d -> dinfo & Unsigned_valid){
	  let d1 = d->unsigned_dist.length;
	  let d2_ptr = lookup_distance(r, false, d->target);
	  if (d2_ptr != NULL){
	    let d2 = d2_ptr->length;
	    let newd = d1 > d2 ? d->unsigned_dist: *d2_ptr;
	    if (dist_res != NULL){
	      dist_res->unsigned_dist = newd;
	      dist_res->dinfo = Both_valid;
	    }else{
	      dist_res = new Distance{.target = d->target,
				      .next = res->distance,
				      .dinfo = Unsigned_valid,
				      .unsigned_dist = newd,
				      .signed_dist = Dist{0, NULL}};
	    }
	  }
	}
	if (dist_res != NULL){
	  res->distance = dist_res;
	}
      }
    }
  }
  return res;
}

term_t int2term(bool is_signed, int c){
  let s = is_signed?Absyn::Signed : Absyn::Unsigned;
  let e = Absyn::int_exp(s, c, 0);
  e->topt = Absyn::int_type(s, Absyn::Int_sz);
  return cnst(e);
}

assn_t edge2assn(term_t source, term_t target, int weight, bool is_signed){
  let s = is_signed ? SLte : ULte;
  let s1 = is_signed? SLt: ULt;
  assn_t result = &AssnDef::true_assn;
  if (source == zero()){
    result = prim(int2term(is_signed, -weight), s, target);
  }else if( target == zero()){
    result = prim(source, s, int2term(is_signed, weight));
  }else{
    switch (weight){
    case 0: result = prim(source, s, target); break;
    case -1: result = prim(source, s1, target); break;
    default: 
      //currently, the prim of the form t1 <= t2 + c where c!=0, or 1
      //is not going to get any extra benefit when being turned into edges
      //      fprintf(stderr, "## %s <= %s + (%d)\n", 
      //	      term2string(source),term2string(target), weight); 
      break;
    }
  }
  return result;
}


assn_t row2assn(row_t r){
  assn_t a = &AssnDef::true_assn;
  for( ;r!= NULL; r = r->next){
    for(let d = r->distance; d!=NULL; d=d->next){
      if (d->dinfo & Signed_valid){
	if (d->signed_dist.prim != NULL){
	  a = and(a, (assn_t)d->signed_dist.prim);
	}else{
	  a = and(a, edge2assn(r->source, d->target, d->signed_dist.length, true));
	}
      }
      if (d->dinfo & Unsigned_valid){
	if (d->unsigned_dist.prim != NULL){
	  a = and(a, (assn_t)d->unsigned_dist.prim);
	}else{
	  a = and(a, edge2assn(r->source, d->target, d->unsigned_dist.length, false));
	}
      }
    }
  }
  return a;
}

assn_t merge_assn(assn_t a1, assn_t a2){
  //turn a1 or a2 to DNF normal form, represented by a set of graphs
  let g = cgraph(true_graph(), or(a1,a2));
  if (g == NULL) return &false_assn;
  if (num_graphs(g) > max_parallel_assn){
    let row = g->rows;
    for(let row1 = g->next; row1 != NULL; row1 = row1->next){
      row = or2rows(row, row1->rows);
    }
    return row2assn(row);
  }else{
    return or(a1, a2);
  }
}
