/* Abstract syntax.
   Copyright (C) 2001 Greg Morrisett, AT&T
   This file is part of the Cyclone compiler.

   The Cyclone compiler is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   The Cyclone compiler is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with the Cyclone compiler; see the file COPYING. If not,
   write to the Free Software Foundation, Inc., 59 Temple Place -
   Suite 330, Boston, MA 02111-1307, USA. */

// we define ABSYN_CYC to avoid re-declaring the abstract syntax -- see
// absyn.h
#define ABSYN_CYC 
#include "absyn.h"
#include "absynrep.h"
#include "positionrep.h"
#include <string.h>
#include <stdio.h>
#include "tcutil.h"
#include <marshal.h>
using Core;
using List;
using Position;
namespace Absyn {

// return a negative, zero, or positive int according to whether the
// first string list is less than, equal to, or greater than the
// second 
static int zstrlist_cmp(list_t<stringptr_t<`H,`H>,`r> ss1,list_t<stringptr_t<`H,`H>,`r> ss2){
  return list_cmp(zstrptrcmp,ss1,ss2);
}
int varlist_cmp(list_t<var_t,`r> vs1, list_t<var_t,`r> vs2) {
  return zstrlist_cmp(vs1,vs2);
}
int qvar_cmp(qvar_t q1, qvar_t q2) {
  let n1 = (*q1)[0];
  let n2 = (*q2)[0];
  switch ($(n1,n2)) {
  case $(Loc_n,    Loc_n):     break;
  case $(&Rel_n(x1),&Rel_n(x2)): fallthru(x1,x2);
  case $(&Abs_n(x1),&Abs_n(x2)):
    int i = zstrlist_cmp(x1,x2);
    if (i != 0) return i;
    break;
  // we arbitrarily decide that Loc_n < Rel_n < Abs_n
  case $(Loc_n,_): return -1;
  case $(_,Loc_n): return 1;
  case $(&Rel_n(_),_): return -1;
  case $(_,&Rel_n(_)): return 1;
  }
  return zstrptrcmp((*q1)[1],(*q2)[1]);
}
// WARNING: Ignores the kinds.
int tvar_cmp(tvar_t tv1, tvar_t tv2) {
  int i = zstrptrcmp(tv1->name,tv2->name);
  if (i != 0) return i;
  if (tv1->identity == tv2->identity) return 0;
  if (tv1->identity != NULL && tv2->identity != NULL) 
    return (*tv1->identity) - (*tv2->identity);
  else if (tv1->identity == NULL) return -1;
  else return 1;
}

tunion Nmspace.Rel_n rel_ns_null_value = Rel_n(NULL);
tunion Nmspace       rel_ns_null       = &rel_ns_null_value;

bool is_qvar_qualified(qvar_t qv) {
  switch((*qv)[0]) {
  case &Rel_n(NULL):
  case &Abs_n(NULL):
  case Loc_n: return false;
  default:    return true;
  }
}

static int new_type_counter = 0;

type_t new_evar(opt_t<kind_t,`H> k, opt_t<list_t<tvar_t,`H>,`H> env) {
  return new Evar(k,NULL,new_type_counter++,env);
}
static struct Opt<kind_t> mk = {MemKind};
type_t wildtyp(opt_t<list_t<tvar_t,`H>,`H> tenv) {
  return new_evar(&mk,tenv); 
}

tqual_t combine_tqual(tqual_t x,tqual_t y) { 
  return Tqual(x.q_const    || y.q_const,
	       x.q_volatile || y.q_volatile,
	       x.q_restrict || y.q_restrict);
}

// FIX: fit in an int (with bitfields) rather than doing allocation
tqual_t empty_tqual() { return Tqual(false,false,false); }
tqual_t const_tqual() { return Tqual{.q_const = true,
                                        .q_volatile = false,
                                        .q_restrict = false}; }

//////////////////////////// Constraints /////////////////////////
conref_t<`a> new_conref(`a x) {
  return new Conref{.v = new Eq_constr(x)};
}
conref_t<`a> empty_conref() {
  return new Conref{.v = No_constr};
}
// just to avoid some unnecessary allocation:
static tunion Constraint.Eq_constr<bool> true_constraint = Eq_constr(true);
static tunion Constraint.Eq_constr<bool> false_constraint = Eq_constr(false);
struct Conref<bool> true_conref_v  = Conref(&true_constraint);
struct Conref<bool> false_conref_v = Conref(&false_constraint);
conref_t<bool> true_conref  = &true_conref_v;
conref_t<bool> false_conref = &false_conref_v;

// compress a conref
conref_t<`a> compress_conref(conref_t<`a> x) {
  switch (x->v) {
  case No_constr:    return x;
  case &Eq_constr(_): return x;
  case &Forward_constr(*y):
    let z = compress_conref(*y);
    *y = z;
    return z;
  }
}

`a conref_val(conref_t<`a> x) {
  switch (compress_conref(x)->v) {
  case &Eq_constr(v): return v;
  default:
    return Tcutil::impos("conref_val");
  }
}

`a conref_def(`a y, conref_t<`a> x) {
  switch (compress_conref(x)->v) {
  case &Eq_constr(v): return v;
  default: return y;
  }
}

kindbound_t compress_kb(kindbound_t k) {
  switch (k) {
  case &Eq_kb(_): return k;
  case &Unknown_kb(NULL): return k;
  case &Less_kb(NULL,_): return k;
  case &Unknown_kb(&Opt(*k2)): fallthru(k2);
  case &Less_kb(&Opt(*k2),_): 
    *k2 = compress_kb(*k2);
    return *k2;
  }
}

kind_t force_kb(kindbound_t kb) {
  switch (compress_kb(kb)) {
  case &Eq_kb(k): return k;
  case &Unknown_kb(*f): fallthru(f,BoxKind);
  case &Less_kb(*f,k):
    *f = new Opt(new Eq_kb(k)); return k;
  }
}

//////////////////////////// Types ///////////////////////////////
// unsigned types
static tunion Type.IntType uchar_tt  = IntType(Unsigned,B1);
static tunion Type.IntType ushort_tt = IntType(Unsigned,B2);
static tunion Type.IntType uint_tt   = IntType(Unsigned,B4);
static tunion Type.IntType ulong_tt  = IntType(Unsigned,B4);
static tunion Type.IntType ulonglong_tt  = IntType(Unsigned,B8);

type_t uchar_t  = &uchar_tt;
type_t ushort_t = &ushort_tt;
type_t uint_t   = &uint_tt;
type_t ulong_t  = &ulong_tt;
type_t ulonglong_t  = &ulonglong_tt;
// signed types
static tunion Type.IntType schar_tt  = IntType(Signed,B1);
static tunion Type.IntType sshort_tt = IntType(Signed,B2);
static tunion Type.IntType sint_tt   = IntType(Signed,B4);
static tunion Type.IntType slong_tt  = IntType(Signed,B4);
static tunion Type.IntType slonglong_tt  = IntType(Signed,B8);

type_t schar_t  = &schar_tt;
type_t sshort_t = &sshort_tt;
type_t sint_t   = &sint_tt;
type_t slong_t  = &slong_tt;
type_t slonglong_t = &slonglong_tt;
// float, double
type_t float_t  = FloatType;
type_t double_t(bool b) {
  return new DoubleType(b);
}
// exceptions
static tunion Nmspace.Abs_n abs_null = Abs_n(NULL);
static string_t exn_str = "exn";
static $(nmspace_t,var_t) exn_name_v = $((nmspace_t)&abs_null,&exn_str);
qvar_t exn_name   = &exn_name_v;

#define MAKE_BUILTIN_EXN(str)\
  static string_t            str##_str   = #str;\
  static $(nmspace_t, var_t) str##_pr    = $((nmspace_t)&abs_null, &str##_str);\
  qvar_t                     str##_name  = &str##_pr;\
  static struct Tunionfield  str##_tuf_v = Tunionfield(&str##_pr,\
				 		       NULL,NULL,NULL,Extern);\
  tunionfield_t              str##_tuf   = &str##_tuf_v

MAKE_BUILTIN_EXN(Null_Exception);
MAKE_BUILTIN_EXN(Array_bounds);
MAKE_BUILTIN_EXN(Match_Exception);
MAKE_BUILTIN_EXN(Bad_alloc);
#undef MAKE_BUILTIN_EXN

static struct List<tunionfield_t,`H> exn_l0 = List(&Null_Exception_tuf_v, NULL);
static struct List<tunionfield_t,`H> exn_l1 = List(&Array_bounds_tuf_v,   &exn_l0);
static struct List<tunionfield_t,`H> exn_l2 = List(&Match_Exception_tuf_v,&exn_l1);
static struct List<tunionfield_t,`H> exn_l3 = List(&Bad_alloc_tuf_v,      &exn_l2);

static struct Opt<list_t<tunionfield_t>> exn_ol = Opt(&exn_l3);
static struct Tuniondecl exn_tud_v = Tuniondecl(Extern, &exn_name_v, NULL,
						&exn_ol, true);
tuniondecl_t exn_tud = &exn_tud_v;

static tunion TunionInfoU.KnownTunion exn_tinfou = KnownTunion(&exn_tud);
static tunion Type.TunionType exn_typ_tt =
                  TunionType(TunionInfo(&exn_tinfou,NULL,HeapRgn));
type_t exn_typ = &exn_typ_tt;

// tunion PrintArg and tunion ScanfArg qvars
static string_t printarg_str = "PrintArg";
static string_t scanfarg_str = "ScanfArg";
static string_t cyc_str = "Cyc";
static string_t std_str = "Std";
static struct List<var_t,`H> std_list = {&std_str, NULL};
static tunion Nmspace.Abs_n std_namespace = Abs_n(&std_list);
static $(nmspace_t,var_t) tunion_print_arg_qvar_p = 
  $((tunion Nmspace)&std_namespace, &printarg_str);
static $(nmspace_t,var_t) tunion_scanf_arg_qvar_p = 
  $((tunion Nmspace)&std_namespace, &scanfarg_str);
qvar_t tunion_print_arg_qvar = &tunion_print_arg_qvar_p;
qvar_t tunion_scanf_arg_qvar = &tunion_scanf_arg_qvar_p;

// string
static opt_t<type_t> string_t_opt = NULL;
type_t string_typ(type_t rgn) {
  if (rgn != HeapRgn)
    return starb_typ(uchar_t,rgn,empty_tqual(),Unknown_b);
  else {
    if (string_t_opt == NULL) {
      type_t t = starb_typ(uchar_t,HeapRgn,empty_tqual(),Unknown_b);
      string_t_opt = new Opt(t);
    }
    return string_t_opt->v;
  }
}
static opt_t<type_t> const_string_t_opt = NULL;
type_t const_string_typ(type_t rgn) {
  if (rgn != HeapRgn)
    return starb_typ(uchar_t,rgn,const_tqual(),Unknown_b);
  else {
    if (const_string_t_opt == NULL) {
      type_t t = starb_typ(uchar_t,HeapRgn,const_tqual(),Unknown_b);
      const_string_t_opt = new Opt(t);
    }
    return const_string_t_opt->v;
  }
}
// pointers

// a static &Upper_b(&Exp(NULL,&Const_e(&Int_c(Unsigned,1)),NULL))
static tunion Cnst.Int_c      one_intc  = Int_c(Unsigned,1);
static tunion Raw_exp.Const_e one_b_raw = Const_e(&one_intc);
struct Exp exp_unsigned_one_v = {NULL,&one_b_raw,NULL,EmptyAnnot};
exp_t exp_unsigned_one = &exp_unsigned_one_v;
static tunion Bounds.Upper_b one_bt = Upper_b(&exp_unsigned_one_v);
tunion Bounds bounds_one = &one_bt;

type_t starb_typ(type_t t, type_t r, tqual_t tq, bounds_t b) {
  return new PointerType(PtrInfo {.elt_typ = t, .rgn_typ = r,
                                     .nullable = true_conref, .tq = tq, 
                                     .bounds = new_conref(b)});
}
type_t atb_typ(type_t t, type_t r, tqual_t tq, bounds_t b) {
  return 
    new PointerType(PtrInfo {
      .elt_typ = t, .rgn_typ = r, .nullable = false_conref, .tq = tq, 
	 .bounds = new_conref(b)});
}
type_t star_typ(type_t t, type_t r, tqual_t tq) { 
  return starb_typ(t, r, tq, bounds_one);
}
type_t cstar_typ(type_t t, tqual_t tq) { 
  return starb_typ(t, HeapRgn, tq, bounds_one);
}
type_t at_typ(type_t t, type_t r, tqual_t tq) {
  return atb_typ(t, r, tq, bounds_one);
}
type_t tagged_typ(type_t t, type_t r, tqual_t tq) {
  return 
    new PointerType(PtrInfo {
      .elt_typ = t, .rgn_typ = r, .nullable = true_conref, .tq = tq,
	 .bounds = new_conref(Unknown_b) });
}

// FILE
static opt_t<type_t> file_t_opt = NULL;

// Maybe someday we'll allow FILE objects to live somewhere other than
// in the heap (by making the runtime interface more flexible).  
// If so, we'll need a rgn_t argument.
static string_t sf_str = "__sFILE";
static stringptr_t sf = &sf_str;
static string_t st_str = "Std";
static stringptr_t st = &st_str;

type_t file_typ() {
  if(file_t_opt == NULL) {
    typedef_name_t file_t_name = new $(new Abs_n(list(st)), sf);
    structdecl_t sd = new Structdecl(Abstract,new Opt(file_t_name),NULL,
				     NULL,NULL);
    type_t file_struct_typ = new StructType(file_t_name, NULL, new {sd});
    file_t_opt = new Opt(at_typ(file_struct_typ, HeapRgn, empty_tqual()));
  }
  return file_t_opt->v;
}

static opt_t<type_t> void_star_t_opt = NULL;
type_t void_star_typ() {
  if (void_star_t_opt == NULL)
    void_star_t_opt = new Opt(star_typ(VoidType, HeapRgn, empty_tqual()));
  return void_star_t_opt->v;
}
opt_t<type_t> void_star_typ_opt() {
  if (void_star_t_opt == NULL)
    void_star_t_opt = new Opt(star_typ(VoidType, HeapRgn, empty_tqual()));
  return void_star_t_opt;
}
static tunion Type.JoinEff empty_eff = JoinEff(NULL);
type_t empty_effect = &empty_eff;

// structs and unions
// WARNING: currently only Toc calls these, so we don't need to set
//          the structdecl field.  Beware using them anywhere else!
// (Probably we should require setting the third field even in Toc.)
type_t strct(var_t name) {
  return new StructType(new $(rel_ns_null, name),NULL,NULL);
}
type_t union_typ(var_t name) {
  return new UnionType(new $(rel_ns_null, name),NULL,NULL);
}
type_t strctq(qvar_t name) {
  return new StructType(name,NULL,NULL);
}
type_t unionq_typ(qvar_t name) {
  return new UnionType(name,NULL,NULL);
}

///////////////////////// Expressions //////////////////////////////
exp_t new_exp(raw_exp_t r, seg_t loc) {
  return new Exp{.topt=NULL, .r=r, .loc=loc, .annot=EmptyAnnot};
}
exp_t New_exp(exp_opt_t rgn_handle, exp_t e, seg_t loc) {
  return new_exp(new New_e(rgn_handle,e), loc);
}
exp_t copy_exp(exp_t e) {
  return new Exp{.topt=e->topt, .r=e->r, .loc=e->loc, .annot=EmptyAnnot};
}
exp_t const_exp(cnst_t c, seg_t loc) { return new_exp(new Const_e(c), loc); }
exp_t null_exp(seg_t loc) { return new_exp(new Const_e(Null_c), loc); }
exp_t int_exp(sign_t s,int i,seg_t seg) { 
  return const_exp(new Int_c(s,i),seg);
}
exp_t signed_int_exp(int i,    seg_t loc) {return int_exp(Signed,i,loc);}
exp_t uint_exp(unsigned int i, seg_t loc) {return int_exp(Unsigned,i,loc);}
exp_t bool_exp(bool b, seg_t loc) { return signed_int_exp(b ? 1 : 0, loc); }
exp_t true_exp(seg_t loc)  { return bool_exp(true, loc); }
exp_t false_exp(seg_t loc) { return bool_exp(false, loc); }
exp_t char_exp(char c, seg_t loc) {
  return const_exp(new Char_c(Unsigned,c),loc);
}
exp_t float_exp(string_t<`H> f, seg_t loc) { return const_exp(new Float_c(f),loc);  }
exp_t string_exp(string_t<`H> s, seg_t loc){ return const_exp(new String_c(s),loc); }

// This should only be used after type checking.
// Right now it's only used in Toc and is the only source of Unresolved_b.
exp_t var_exp(qvar_t q, seg_t loc) {
  return new_exp(new Var_e(q,Unresolved_b), loc);
}
exp_t varb_exp(qvar_t q, binding_t b, seg_t loc) {
  return new_exp(new Var_e(q, b), loc);
}
exp_t unknownid_exp(qvar_t q, seg_t loc) { 
  return new_exp(new UnknownId_e(q), loc); 
}
exp_t primop_exp(primop_t p, list_t<exp_t,`H> es, seg_t loc) {
  return new_exp(new Primop_e(p,es),loc);
}
exp_t prim1_exp(primop_t p, exp_t e, seg_t loc) {
  return primop_exp(p, new List(e,NULL), loc);
}
exp_t prim2_exp(primop_t p, exp_t e1, exp_t e2, seg_t loc) {
  return primop_exp(p, new List(e1,new List(e2,NULL)), loc);
}
exp_t add_exp(exp_t e1,exp_t e2,seg_t loc)   {return prim2_exp(Plus,e1,e2,loc);}
exp_t times_exp(exp_t e1,exp_t e2,seg_t loc){return prim2_exp(Times,e1,e2,loc);}
exp_t divide_exp(exp_t e1,exp_t e2,seg_t loc){return prim2_exp(Div,e1,e2,loc);}
exp_t eq_exp(exp_t e1,  exp_t e2, seg_t loc) {return prim2_exp(Eq,e1,e2,loc);}
exp_t neq_exp(exp_t e1, exp_t e2, seg_t loc) {return prim2_exp(Neq,e1,e2,loc);}
exp_t gt_exp(exp_t e1,  exp_t e2, seg_t loc) {return prim2_exp(Gt,e1,e2,loc);}
exp_t lt_exp(exp_t e1,  exp_t e2, seg_t loc) {return prim2_exp(Lt,e1,e2,loc);}
exp_t gte_exp(exp_t e1, exp_t e2, seg_t loc) {return prim2_exp(Gte,e1,e2,loc);}
exp_t lte_exp(exp_t e1, exp_t e2, seg_t loc) {return prim2_exp(Lte,e1,e2,loc);}

exp_t assignop_exp(exp_t e1, opt_t<primop_t,`H> popt, exp_t e2, seg_t loc) {
  return new_exp(new AssignOp_e(e1,popt,e2),loc);
}
exp_t assign_exp(exp_t e1, exp_t e2, seg_t loc) {
  return assignop_exp(e1,NULL,e2,loc);
}
exp_t increment_exp(exp_t e,incrementor_t i,seg_t loc) {
  return new_exp(new Increment_e(e,i),loc);
}
exp_t post_inc_exp(exp_t e,seg_t loc){return increment_exp(e,PostInc,loc);}
exp_t pre_inc_exp(exp_t e, seg_t loc){return increment_exp(e,PreInc,loc);}
exp_t pre_dec_exp(exp_t e, seg_t loc){return increment_exp(e,PreDec,loc);}
exp_t post_dec_exp(exp_t e,seg_t loc){return increment_exp(e,PostDec,loc);}
exp_t conditional_exp(exp_t e1,exp_t e2,exp_t e3,seg_t loc) {
  return new_exp(new Conditional_e(e1,e2,e3), loc);
}
exp_t and_exp(exp_t e1, exp_t e2, seg_t loc) {
  return conditional_exp(e1,e2,false_exp(loc), loc);
}
exp_t or_exp(exp_t e1, exp_t e2, seg_t loc) {
  return conditional_exp(e1,true_exp(loc),e2, loc);
}
exp_t seq_exp(exp_t e1, exp_t e2, seg_t loc) {
  return new_exp(new SeqExp_e(e1,e2), loc);
}
exp_t unknowncall_exp(exp_t e, list_t<exp_t,`H> es, seg_t loc) {
  return new_exp(new UnknownCall_e(e,es), loc);
}
exp_t fncall_exp(exp_t e, list_t<exp_t,`H> es, seg_t loc) {
  return new_exp(new FnCall_e(e,es,NULL), loc);
}
exp_t noinstantiate_exp(exp_t e, seg_t loc) {
  return new_exp(new NoInstantiate_e(e), loc);
}
exp_t instantiate_exp(exp_t e, list_t<type_t,`H> ts, seg_t loc) {
  return new_exp(new Instantiate_e(e,ts), loc);
}
exp_t cast_exp(type_t t, exp_t e, seg_t loc) { 
  return new_exp(new Cast_e(t,e), loc);
}
exp_t throw_exp(exp_t e,   seg_t loc) { return new_exp(new Throw_e(e), loc); }
exp_t address_exp(exp_t e, seg_t loc) { return new_exp(new Address_e(e), loc); }
exp_t sizeoftyp_exp(type_t t, seg_t loc) { 
  return new_exp(new Sizeoftyp_e(t), loc); 
}
exp_t sizeofexp_exp(exp_t e, seg_t loc) { 
  return new_exp(new Sizeofexp_e(e), loc); 
}
exp_t offsetof_exp(type_t t, offsetof_field_t of, seg_t loc) {
  return new_exp(new Offsetof_e(t,of), loc);
}
exp_t gentyp_exp(list_t<tvar_t,`H> tvs, type_t t, seg_t loc) { 
  return new_exp(new Gentyp_e(tvs,t), loc); 
}
exp_t deref_exp(exp_t e,   seg_t loc) { return new_exp(new Deref_e(e), loc); }
exp_t structmember_exp(exp_t e, field_name_t n, seg_t loc) {
  return new_exp(new StructMember_e(e,n), loc); 
}
exp_t structarrow_exp(exp_t e, field_name_t n, seg_t loc) {
  return new_exp(new StructArrow_e(e,n), loc); 
}
exp_t arrow_exp(exp_t e, field_name_t n, seg_t loc) {
  return deref_exp(structmember_exp(e, n, loc), loc);
}
exp_t subscript_exp(exp_t e1, exp_t e2, seg_t loc) {
  return new_exp(new Subscript_e(e1,e2), loc); 
}
exp_t tuple_exp(list_t<exp_t,`H> es, seg_t loc) {
  return new_exp(new Tuple_e(es), loc); 
}
exp_t stmt_exp(stmt_t s,seg_t loc) { return new_exp(new StmtExp_e(s), loc); }

exp_t match_exn_exp(seg_t loc) { 
  return var_exp(Match_Exception_name, loc); 
}

exp_t array_exp(list_t<exp_t,`H> es, seg_t loc) {
  // FIX:  this doesn't work let dles = NULL;
  list_t<$(list_t<designator_t,`H>,exp_t)@`H> dles = NULL;
  for (; es != NULL; es = es->tl)
    dles = new List(new $(NULL,es->hd),dles);
  dles = List::imp_rev(dles);
  return new_exp(new Array_e(dles),loc);
}
exp_t unresolvedmem_exp(opt_t<typedef_name_t,`H> n,
                        list_t<$(list_t<designator_t,`H>,exp_t)@`H,`H> dles,
                        seg_t loc) {
  return new_exp(new UnresolvedMem_e(n,dles),loc);
}
///////////////////////// Statements ///////////////////////////////
stmt_t new_stmt(raw_stmt_t s, seg_t loc) { 
  return new Stmt{.r=s, .loc=loc, .non_local_preds=NULL, .try_depth = 0,
                     .annot=EmptyAnnot }; }
stmt_t skip_stmt(seg_t loc) { return new_stmt(Skip_s, loc); }
stmt_t exp_stmt(exp_t e,seg_t loc) { return new_stmt(new Exp_s(e),loc); }
stmt_t seq_stmts(list_t<stmt_t,`r> ss, seg_t loc) {
  if (ss == NULL) return skip_stmt(loc);
  else if (ss->tl == NULL) return ss->hd;
  else return seq_stmt(ss->hd,seq_stmts(ss->tl,loc),loc);
}
stmt_t return_stmt(exp_opt_t e,seg_t loc) { 
  return new_stmt(new Return_s(e),loc); 
}
stmt_t ifthenelse_stmt(exp_t e,stmt_t s1,stmt_t s2,seg_t loc) {
  return new_stmt(new IfThenElse_s(e,s1,s2),loc);
}
stmt_t while_stmt(exp_t e,stmt_t s,seg_t loc) { 
  return new_stmt(new While_s($(e,skip_stmt(e->loc)),s), loc);
}
stmt_t break_stmt   (seg_t loc) { return new_stmt(new Break_s(NULL), loc); }
stmt_t continue_stmt(seg_t loc) { return new_stmt(new Continue_s(NULL), loc); }
stmt_t for_stmt(exp_t e1,exp_t e2,exp_t e3,stmt_t s,seg_t loc) {
  return new_stmt(new For_s(e1,$(e2,skip_stmt(e3->loc)),
                            $(e3,skip_stmt(e3->loc)),s),
		  loc);
}
stmt_t switch_stmt(exp_t e, list_t<switch_clause_t,`H> scs, seg_t loc) {
  return new_stmt(new Switch_s(e,scs), loc);
}
stmt_t seq_stmt(stmt_t s1, stmt_t s2, seg_t loc) { 
  switch (s1->r) {
  case Skip_s: return s2;
  default:     return new_stmt(new Seq_s(s1,s2), loc); 
  }
}
stmt_t fallthru_stmt(list_t<exp_t,`H> el, seg_t loc) { 
  return new_stmt(new Fallthru_s(el,NULL), loc); 
}
stmt_t decl_stmt(decl_t d, stmt_t s, seg_t loc) {
  return new_stmt(new Decl_s(d,s), loc);
}
stmt_t declare_stmt(qvar_t x, type_t t, exp_opt_t init, stmt_t s, seg_t loc) {
  decl_t d = new_decl(new Var_d(new_vardecl(x,t,init)),loc);
  return new_stmt(new Decl_s(d,s),loc);
}
stmt_t cut_stmt   (stmt_t s, seg_t loc) { return new_stmt(new Cut_s(s),   loc);}
stmt_t splice_stmt(stmt_t s, seg_t loc) { return new_stmt(new Splice_s(s),loc);}
stmt_t label_stmt(var_t v, stmt_t s, seg_t loc) {
  return new_stmt(new Label_s(v,s), loc);
}
stmt_t do_stmt(stmt_t s, exp_t e, seg_t loc) {
  return new_stmt(new Do_s(s,$(e,skip_stmt(e->loc))), loc);
}
stmt_t trycatch_stmt(stmt_t s, list_t<switch_clause_t,`H> scs, seg_t loc) {
  return new_stmt(new TryCatch_s(s,scs), loc);
}
stmt_t goto_stmt(var_t lab, seg_t loc) {
  return new_stmt(new Goto_s(lab,NULL), loc);
}
stmt_t assign_stmt(exp_t e1, exp_t e2, seg_t loc) {
  return exp_stmt(assign_exp(e1,e2,loc),loc);
}
stmt_t forarray_stmt(list_t<vardecl_t,`H> d,exp_t e1,exp_t e2,stmt_t s,seg_t loc) {
  return new_stmt(new ForArray_s(ForArrayInfo{d,$(e1,skip_stmt(e1->loc)),
                                                $(e2,skip_stmt(e2->loc)),s}),
                  loc);
}
/////////////////////////// Patterns //////////////////////////////
pat_t new_pat(raw_pat_t p, seg_t s) { return new Pat(p,NULL,s); }

////////////////////////// Declarations ///////////////////////////
decl_t new_decl(raw_decl_t r, seg_t loc) { return new Decl{.r=r, .loc=loc}; }
decl_t let_decl(pat_t p, opt_t<type_t,`H> t_opt, exp_t e, seg_t loc) {
  return new_decl(new Let_d(p,NULL,t_opt,e,false),loc);
}
decl_t letv_decl(list_t<vardecl_t,`H> vds, seg_t loc) {
  return new_decl(new Letv_d(vds),loc);
}
vardecl_t new_vardecl(qvar_t x, type_t t, exp_opt_t init) {
  return new Vardecl{.sc=Public, .name=x, .tq=empty_tqual(),
                        .type=t, .initializer=init, .rgn=NULL, 
                        .attributes=NULL};
}
vardecl_t static_vardecl(qvar_t x, type_t t, exp_opt_t init) {
  return new Vardecl{.sc=Static, .name=x, .tq=empty_tqual(),
                        .type=t, .initializer=init, .rgn=NULL,
                        .attributes=NULL};
}
decl_t struct_decl(scope_t s,opt_t<typedef_name_t,`H> n,list_t<tvar_t,`H> ts,
                   opt_t<list_t<structfield_t,`H>,`H> fs, attributes_t atts,
                   seg_t loc) {
  return new_decl(new Struct_d(new Structdecl {.sc=s,.name=n,
                                                  .tvs=ts,.fields=fs,
                                                  .attributes = atts}),loc);
}
decl_t union_decl(scope_t s,opt_t<typedef_name_t,`H> n,list_t<tvar_t,`H> ts,
                  opt_t<list_t<structfield_t,`H>,`H> fs, attributes_t atts,
                  seg_t loc) {
  return new_decl(new Union_d(new Uniondecl {.sc=s,.name=n,.tvs=ts,.fields=fs,
                                                .attributes = atts}),loc);
}
decl_t tunion_decl(scope_t s, typedef_name_t n, list_t<tvar_t,`H> ts,
		   opt_t<list_t<tunionfield_t,`H>,`H> fs, 
                   bool is_xtunion, seg_t loc){
  return new_decl(new Tunion_d(new Tuniondecl(s,n,ts,fs,is_xtunion)),loc);
}

// We treat function types in argument or return position as an
// abbreviation for a non-nullable pointer to a function, that is,
//   int f(void g())(float)
// is the same as
//   int (@f(void (@g)()))(float)
// We do this by constructing every function type using function_typ,
// rather than mucking with the typechecker/unifier/etc.
static
 $(opt_t<var_t>,tqual_t,type_t)@ expand_arg($(opt_t<var_t,`H>,tqual_t,type_t)@ a) {
  return new $((*a)[0],(*a)[1],pointer_expand((*a)[2]));
}

type_t function_typ(list_t<tvar_t,`H> tvs, opt_t<type_t,`H> eff_typ, 
                    type_t ret_typ, 
                    list_t<$(opt_t<var_t,`H>,tqual_t,type_t)@`H,`H> args, 
                    bool c_varargs, vararg_info_t *`H cyc_varargs,
                    list_t<$(type_t,type_t)@`H,`H> rgn_po,
                    attributes_t atts) {
  return new FnType(FnInfo{.tvars = tvs, .ret_typ = pointer_expand(ret_typ),
                              .effect = eff_typ, 
                              .args = List::map(expand_arg,args), 
                              .c_varargs = c_varargs, 
                              .cyc_varargs = cyc_varargs,
                              .rgn_po = rgn_po,
                              .attributes=atts});
}
type_t pointer_expand(type_t t) {
  switch (Tcutil::compress(t)) {
  case &FnType(_): return at_typ(t,HeapRgn,empty_tqual());
  default: return t;
  }
}

// According to Harbison and Steele these are the lvalues of C:
//
//    exp      where
//    ---------------------------
//    name     name is a variable -- and not a function name or array!
//    e[k]
//    (e)      e is an lvalue
//    e.name   e is an lvalue
//    e->name
//    *e
// (We may have more in Cyclone...)

// must be called after the expression is type-checked.
bool is_lvalue(exp_t e) {
  switch (e->r) {
    // shouldn't allow assignment to function names or arrays
  case &Var_e(_,&Funname_b(_)): return false;
  case &Var_e(_,&Global_b(vd)): fallthru(vd);
  case &Var_e(_,&Local_b(vd)):
    switch (Tcutil::compress(vd->type)) {
    case &ArrayType(_,_,_): return false;
    default: return true; 
    }
  case &Var_e(_,_):           return true;
  case &Subscript_e(e1,e2):   return true;
  case &StructMember_e(e1,f): return is_lvalue(e1);
  case &StructArrow_e(e1,f):  return true;
  case &Deref_e(e1):          return true;
  case &Instantiate_e(e1,_):  return is_lvalue(e1);
  case &NoInstantiate_e(e1):  return is_lvalue(e1);
  default:                    return false;
  }
}

struct Structfield * lookup_field(list_t<structfield_t,`H> fields, var_t v) {
  for(_ fs = fields; fs != NULL; fs = fs->tl) {
    let f = fs->hd;
    if (zstrptrcmp(f->name,v) == 0)
      return f;
  }
  return NULL;
}

struct Structfield * lookup_struct_field(structdecl_t sd, var_t v) {
  return (sd->fields == NULL) ? NULL : lookup_field(sd->fields->v,v);
}
struct Structfield * lookup_union_field(uniondecl_t ud, var_t v) {
  return (ud->fields == NULL) ? NULL : lookup_field(ud->fields->v,v);
}

$(tqual_t,type_t) * lookup_tuple_field(list_t<$(tqual_t,type_t)@`H,`H> ts, 
                                       int i) {
  for(; i != 0; --i) {
    if(ts == NULL)
      return NULL;
    ts = ts->tl;
  }
  if(ts == NULL)
    return NULL;
  return ts->hd;
}

string_t attribute2string(attribute_t a) {
  switch (a) {
  case &Regparm_att(i): return aprintf("regparm(%d)",i);
  case Stdcall_att: return "stdcall";
  case Cdecl_att: return "cdecl";
  case Fastcall_att: return "fastcall";
  case Noreturn_att: return "noreturn";
  case Const_att: return "const";
  case &Aligned_att(i): 
    if (i == -1) return "aligned";
    else return aprintf("aligned(%d)",i);
  case Packed_att: return "packed";
  case &Section_att(s): return aprintf("section(\"%s\")",s);
  case Nocommon_att: return "nocommon";
  case Shared_att: return "shared";
  case Unused_att: return "unused";
  case Weak_att: return "weak";
  case Dllimport_att: return "dllimport";
  case Dllexport_att: return "dllexport";
  case No_instrument_function_att: return "no_instrument_function";
  case Constructor_att: return "constructor";
  case Destructor_att: return "destructor";
  case No_check_memory_usage_att: return "no_check_memory_usage";
  case &Format_att(Printf_ft,n,m): 
    return aprintf("format(printf,%u,%u)",n,m);
  case &Format_att(Scanf_ft,n,m):
    return aprintf("format(scanf,%u,%u)",n,m);
  }
}

// returns true when a is an attribute for function types
bool fntype_att(attribute_t a) {
  switch (a) {
  case &Regparm_att(_):    
  case Fastcall_att:       
  case Stdcall_att:        
  case Cdecl_att:          
  case Noreturn_att:       
  case &Format_att(_,_,_): 
  case Const_att:          return true;
  default: return false;
  }
}

// cache strings used for field names f0,f1,f2,...
static string_t f0 = "f0";
static stringptr_t field_names_v[1] = {&f0};
static stringptr_t ?field_names = field_names_v;
stringptr_t fieldname(int i) {
  unsigned int fsz = field_names.size;
  if (i >= fsz) {
    field_names = 
      new {for j < i+1 : 
	   (j < fsz) ? field_names[j] : new (string_t)aprintf("f%d",j)};
  }
  return field_names[i];
}

  void print_decls(list_t<decl_t> decls) {
    Marshal::print_type(decls_rep,&decls);
    printf("\n");
  }
  
}


using Typerep;
typestruct_t decls_rep = __gen(list_t<Absyn::decl_t>);
