// we define ABSYN_CYC to avoid re-declaring the abstract syntax -- see
// absyn.h
#define ABSYN_CYC 
#include "absyn.h"
#include "string.h"
#include "tcutil.h"

using Core;
using List;
using String;
using Position;
namespace Absyn;

// FIX: file_typ, void_star_typ, etc. don't take into account that
// the -nocyc flag may be enabled.

// return a negative, zero, or positive int according to whether the
// first string list is less than, equal to, or greater than the
// second 
static int zstrlist_cmp(list_t<stringptr> ss1,list_t<stringptr> ss2) {
  return list_cmp(zstrptrcmp,ss1,ss2);
}
int varlist_cmp(list_t<var> vs1, list_t<var> vs2) {
  return zstrlist_cmp(vs1,vs2);
}
int qvar_cmp(qvar q1, qvar q2) {
  let n1 = (*q1)[0];
  let n2 = (*q2)[0];
  switch ($(n1,n2)) {
  case $(Loc_n,    Loc_n):     break;
  case $(Rel_n(x1),Rel_n(x2)): fallthru(x1,x2);
  case $(Abs_n(x1),Abs_n(x2)):
    int i = zstrlist_cmp(x1,x2);
    if (i != 0) return i;
    break;
  // we arbitrarily decide that Loc_n < Rel_n < Abs_n
  case $(Loc_n,_): return -1;
  case $(_,Loc_n): return 1;
  case $(Rel_n(_),_): return -1;
  case $(_,Rel_n(_)): return 1;
  }
  return zstrptrcmp((*q1)[1],(*q2)[1]);
}
// WARNING: Ignores the kinds.
int tvar_cmp(tvar tv1, tvar tv2) {
  return String::zstrptrcmp(tv1->name,tv2->name);
}

static int new_type_counter = 0;

typ new_evar(kind_t k) {
  return Evar(k,null,new_type_counter++);
}
typ wildtyp() {
  return new_evar(MemKind); 
}

tqual combine_tqual(tqual x,tqual y) { 
  return &Tqual(x->q_const    || y->q_const,
		x->q_volatile || y->q_volatile,
		x->q_restrict || y->q_restrict);
}

tqual empty_tqual() { return &Tqual(false,false,false); }

bool is_format_prim(primop p) {
  switch (p) {
  case Printf:  return true;
  case Fprintf: return true;
  case Xprintf: return true; 
  case Scanf:   return true; 
  case Fscanf:  return true; 
  case Sscanf:  return true; 
  default:      return false;
  }
}

//////////////////////////// Constraints /////////////////////////
conref<`a> new_conref(`a x) {
  return &Conref{.v = Eq_constr(x)};
}
conref<`a> empty_conref() {
  return &Conref{.v = No_constr};
}
// just to avoid some unnecessary allocation:
struct Conref<bool> true_conref_v  = Conref(Eq_constr(true));
struct Conref<bool> false_conref_v = Conref(Eq_constr(false));
conref<bool> true_conref  = &true_conref_v;
conref<bool> false_conref = &false_conref_v;

// compress a conref
conref<`a> compress_conref(conref<`a> x) {
  switch (x->v) {
  case No_constr:    return x;
  case Eq_constr(_): return x;
  case Forward_constr(*y):
    let z = compress_conref(*y);
    *y = z;
    return z;
  }
}

`a conref_val(conref<`a> x) {
  switch (compress_conref(x)->v) {
  case Eq_constr(v): return v;
  default:
    return Tcutil::impos("conref_val");
  }
}

//////////////////////////// Types ///////////////////////////////
// unsigned types
typ uchar_t  = IntType(Unsigned,B1);
typ ushort_t = IntType(Unsigned,B2);
typ uint_t   = IntType(Unsigned,B4);
typ ulong_t  = IntType(Unsigned,B8);
// signed types
typ schar_t  = IntType(Signed,B1);
typ sshort_t = IntType(Signed,B2);
typ sint_t   = IntType(Signed,B4);
typ slong_t  = IntType(Signed,B8);
// float, double
typ float_t  = FloatType;
typ double_t = DoubleType;
// exceptions
static string exn_string = "exn";
static $(enum Nmspace,var) exn_name_v = $(Abs_n(null),&exn_string);
qvar exn_name   = &exn_name_v;
static struct Xenumdecl exn_xed_v  = Xenumdecl(Extern,&exn_name_v,null);
xenumdecl               exn_xed    = &exn_xed_v;
typ                     exn_typ    = XenumType(&exn_name_v,&exn_xed);
// string
static opt_t<typ> string_t_opt = null;
typ string_typ(typ rgn) {
  if (string_t_opt == null) {
    typ t = starb_typ(uchar_t,rgn,empty_tqual(),Unknown_b);
    string_t_opt = &Opt(t);
  }
  return string_t_opt->v;
}
// pointers

typ starb_typ(typ t, typ r, tqual tq, bounds_t b) {
  return PointerType(PtrInfo {.elt_typ = t, .rgn_typ = r,
				 .nullable = true_conref, .tq = tq, 
				 .bounds = new_conref(b)});
}
typ atb_typ(typ t, typ r, tqual tq, bounds_t b) {
  return 
    PointerType(PtrInfo {
      .elt_typ = t, .rgn_typ = r, .nullable = false_conref, .tq = tq, 
	 .bounds = new_conref(b)});
}
typ star_typ(typ t, typ r, tqual tq) { 
  return starb_typ(t, r, tq, Upper_b(signed_int_exp(1,null)));
}
typ cstar_typ(typ t, tqual tq) { 
  return starb_typ(t, HeapRgn, tq, Upper_b(signed_int_exp(1,null)));
}
typ at_typ(typ t, typ r, tqual tq) {
  return atb_typ(t, r, tq, Upper_b(signed_int_exp(1,null)));
}
typ tagged_typ(typ t, typ r, tqual tq) {
  return 
    PointerType(PtrInfo {
      .elt_typ = t, .rgn_typ = r, .nullable = true_conref, .tq = tq,
	 .bounds = new_conref(Unknown_b) });
}

// FILE
static opt_t<typ> file_t_opt = null;
// Maybe someday we'll allow FILE objects to live somewhere other than
// in the heap (by making the runtime interface more flexible).  
// If so, we'll need a rgn_t argument.
static string sf_str = "__sFILE";
static stringptr sf = &sf_str;
static string cyc_str = "Cyc";
static stringptr cyc = &cyc_str;
static string st_str = "Stdio";
static stringptr st = &st_str;

typ file_typ() {
  if (file_t_opt == null) {
    // struct Cyc::Stdio::__sFILE *
    typedef_name_t file_t_name = 
      new {$(Abs_n((list_t<var>)&List(cyc,&List(st,null))), sf)};
    structdecl sd = &Structdecl(Abstract,&Opt(file_t_name),null, null,null);
    typ file_struct_typ = StructType(file_t_name, null, new {sd});
    file_t_opt = &Opt(at_typ(file_struct_typ, HeapRgn, empty_tqual()));
  }
  return file_t_opt->v;
}

static opt_t<typ> void_star_t_opt = null;
typ void_star_typ() {
  if (void_star_t_opt == null)
    void_star_t_opt = &Opt(star_typ(VoidType, HeapRgn, empty_tqual()));
  return void_star_t_opt->v;
}

// structs
// WARNING: currently only Toc calls these, so we don't need to set
//          the structdecl field.  Beware using them anywhere else!
// (Probably we should require setting the third field even in Toc.)
typ strct(var name) {
  return StructType(new {$(Abs_n(null),name)},null,null);
}
typ strctq(qvar name) {
  return StructType(name,null,null);
}

///////////////////////// Expressions //////////////////////////////
exp new_exp(raw_exp_t r, seg_t loc) {
  return &Exp{.topt=null, .r=r, .loc=loc};
}
exp copy_exp(exp e) {
  return &Exp{.topt=e->topt, .r=e->r, .loc=e->loc};
}
exp const_exp(cnst_t c, seg_t loc) { return new_exp(Const_e(c), loc); }
exp null_exp(seg_t loc) { return new_exp(Const_e(Null_c), loc); }
exp int_exp(sign_t s,int i,seg_t seg) { 
  return const_exp(Int_c(s,i),seg);
}
exp signed_int_exp(int i,    seg_t loc) {return int_exp(Signed,i,loc);}
exp uint_exp(unsigned int i, seg_t loc) {return int_exp(Unsigned,i,loc);}
exp bool_exp(bool b, seg_t loc) { return signed_int_exp(b ? 1 : 0, loc); }
exp true_exp(seg_t loc)  { return bool_exp(true, loc); }
exp false_exp(seg_t loc) { return bool_exp(false, loc); }
exp char_exp(char c, seg_t loc)    {return const_exp(Char_c(Unsigned,c),loc);}
exp float_exp(string f, seg_t loc) {return const_exp(Float_c(f),loc);}
exp string_exp(bool heap_allocate, string s, seg_t loc){
  return const_exp(String_c(heap_allocate,s),loc);
}

// This should only be used after type checking.
// Right now it's only used in Toc and is the only source of Unresolved_b.
exp var_exp(qvar q, seg_t loc) {
  return new_exp(Var_e(q,Unresolved_b), loc);
}
exp varb_exp(qvar q, binding_t b, seg_t loc) {
  return new_exp(Var_e(q, b), loc);
}
exp unknownid_exp(qvar q, seg_t loc) { 
  return new_exp(UnknownId_e(q), loc); 
}
exp primop_exp(primop p, list_t<exp> es, seg_t loc) {
  return new_exp(Primop_e(p,es),loc);
}
exp prim1_exp(primop p, exp e, seg_t loc) {
  return primop_exp(p, &List(e,null), loc);
}
exp prim2_exp(primop p, exp e1, exp e2, seg_t loc) {
  return primop_exp(p, &List(e1,&List(e2,null)), loc);
}
exp add_exp(exp e1,exp e2,seg_t loc){return prim2_exp(Plus, e1, e2, loc);}
exp subtract_exp(exp e1,exp e2,seg_t loc) {
  return prim2_exp(Minus, e1, e2, loc);
}
exp times_exp(exp e1,exp e2,seg_t loc){return prim2_exp(Times, e1, e2, loc);}
exp divide_exp(exp e1,exp e2,seg_t loc){return prim2_exp(Div, e1, e2, loc);}
exp eq_exp(exp e1,  exp e2, seg_t loc) {return prim2_exp(Eq,  e1, e2, loc);}
exp neq_exp(exp e1, exp e2, seg_t loc) {return prim2_exp(Neq, e1, e2, loc);}
exp gt_exp(exp e1,  exp e2, seg_t loc) {return prim2_exp(Gt,  e1, e2, loc);}
exp lt_exp(exp e1,  exp e2, seg_t loc) {return prim2_exp(Lt,  e1, e2, loc);}
exp gte_exp(exp e1, exp e2, seg_t loc) {return prim2_exp(Gte, e1, e2, loc);}
exp lte_exp(exp e1, exp e2, seg_t loc) {return prim2_exp(Lte, e1, e2, loc);}
exp assignop_exp(exp e1, opt_t<primop> popt, exp e2, seg_t loc) {
  return new_exp(AssignOp_e(e1,popt,e2),loc);
}
exp assign_exp(exp e1, exp e2, seg_t loc) {
  return assignop_exp(e1,null,e2,loc);
}
exp post_inc_exp(exp e,seg_t loc){return new_exp(Increment_e(e,PostInc),loc);}
exp pre_inc_exp(exp e, seg_t loc){return new_exp(Increment_e(e,PreInc),loc);}
exp pre_dec_exp(exp e, seg_t loc){return new_exp(Increment_e(e,PreDec),loc);}
exp post_dec_exp(exp e,seg_t loc){return new_exp(Increment_e(e,PostDec),loc);}
exp conditional_exp(exp e1,exp e2,exp e3,seg_t loc) {
  return new_exp(Conditional_e(e1,e2,e3), loc);
}
exp and_exp(exp e1, exp e2, seg_t loc) {
  return conditional_exp(e1,e2,false_exp(loc), loc);
}
exp or_exp(exp e1, exp e2, seg_t loc) {
  return conditional_exp(e1,true_exp(loc),e2, loc);
}
exp seq_exp(exp e1, exp e2, seg_t loc) {
  return new_exp(SeqExp_e(e1,e2), loc);
}
exp unknowncall_exp(exp e, list_t<exp> es, seg_t loc) {
  return new_exp(UnknownCall_e(e,es), loc);
}
exp fncall_exp(exp e, list_t<exp> es, seg_t loc) {
  return new_exp(FnCall_e(e,es), loc);
}
exp noinstantiate_exp(exp e, seg_t loc) {
  return new_exp(NoInstantiate_e(e), loc);
}
exp instantiate_exp(exp e, list_t<typ> ts, seg_t loc) {
  return new_exp(Instantiate_e(e,ts), loc);
}
exp cast_exp(typ t, exp e, seg_t loc) { 
  return new_exp(Cast_e(t,e), loc);
}
exp throw_exp(exp e,   seg_t loc) { return new_exp(Throw_e(e), loc); }
exp address_exp(exp e, seg_t loc) { return new_exp(Address_e(e), loc); }
exp sizeof_exp(typ t,  seg_t loc) { return new_exp(Sizeof_e(t), loc); }
exp deref_exp(exp e,   seg_t loc) { return new_exp(Deref_e(e), loc); }
exp structmember_exp(exp e, field_name n, seg_t loc) {
  return new_exp(StructMember_e(e,n), loc); 
}
exp structarrow_exp(exp e, field_name n, seg_t loc) {
  return new_exp(StructArrow_e(e,n), loc); 
}
exp arrow_exp(exp e, field_name n, seg_t loc) {
  return deref_exp(structmember_exp(e, n, loc), loc);
}
exp subscript_exp(exp e1, exp e2, seg_t loc) {
  return new_exp(Subscript_e(e1,e2), loc); 
}
exp tuple_exp(list_t<exp> es, seg_t loc) {
  return new_exp(Tuple_e(es), loc); 
}
exp stmt_exp(stmt s,seg_t loc) { return new_exp(StmtExp_e(s), loc); }

static string ne_str = "Null_Exception";
static stringptr ne = &ne_str;
exp null_pointer_exn_exp(seg_t loc) { 
  return var_exp(&$(Abs_n(null),ne), loc); 
}
exp array_exp(bool heap_allocate, list_t<exp> es, seg_t loc) {
  let dles = null;
  for (; es != null; es = es->tl)
    dles = &List(&$(null,es->hd),dles);
  dles = List::imp_rev(dles);
  return new_exp(Array_e(heap_allocate,dles),loc);
}
exp unresolvedmem_exp(opt_t<typedef_name_t> n,
                      list_t<$(list_t<designator>,exp)@> dles,seg_t loc) {
  return new_exp(UnresolvedMem_e(n,dles),loc);
}
///////////////////////// Statements ///////////////////////////////
stmt new_stmt(raw_stmt_t s, seg_t loc) { 
  return &Stmt{.r=s, .loc=loc, .non_local_preds=null, .try_depth = 0,
	       .annot=EmptyAnnot }; }
stmt skip_stmt(seg_t loc) { return new_stmt(Skip_s, loc); }
stmt exp_stmt(exp e,seg_t loc) { return new_stmt(Exp_s(e),loc); }
stmt seq_stmts(list_t<stmt> ss, seg_t loc) {
  if (ss == null) return skip_stmt(loc);
  else if (ss->tl == null) return ss->hd;
  else return seq_stmt(ss->hd,seq_stmts(ss->tl,loc),loc);
}
stmt return_stmt(exp_opt e,seg_t loc) { 
  return new_stmt(Return_s(e),loc); 
}
stmt ifthenelse_stmt(exp e,stmt s1,stmt s2,seg_t loc) {
  return new_stmt(IfThenElse_s(e,s1,s2),loc);
}
stmt while_stmt(exp e,stmt s,seg_t loc) { 
  return new_stmt(While_s($(e,skip_stmt(e->loc)),s), loc);
}
stmt break_stmt   (seg_t loc) { return new_stmt(Break_s(null), loc); }
stmt continue_stmt(seg_t loc) { return new_stmt(Continue_s(null), loc); }
stmt for_stmt(exp e1,exp e2,exp e3,stmt s,seg_t loc) {
  return new_stmt(For_s(e1,$(e2,skip_stmt(e3->loc)),$(e3,skip_stmt(e3->loc)),s),
		  loc);
}
stmt switch_stmt(exp e, list_t<switch_clause> scs, seg_t loc) {
  return new_stmt(Switch_s(e,scs), loc);
}
stmt seq_stmt(stmt s1, stmt s2, seg_t loc) { 
  switch (s1->r) {
  case Skip_s: return s2;
  default:     return new_stmt(Seq_s(s1,s2), loc); 
  }
}
stmt fallthru_stmt(list_t<exp> el, seg_t loc) { 
  return new_stmt(Fallthru_s(el,null), loc); 
}
stmt decl_stmt(decl d, stmt s, seg_t loc) {
  return new_stmt(Decl_s(d,s), loc);
}
stmt declare_stmt(qvar x, typ t, exp_opt init, stmt s, seg_t loc) {
  decl d = new_decl(Var_d(new_vardecl(x,t,init)),loc);
  return new_stmt(Decl_s(d,s),loc);
}
stmt cut_stmt   (stmt s, seg_t loc) { return new_stmt(Cut_s(s),    loc); }
stmt splice_stmt(stmt s, seg_t loc) { return new_stmt(Splice_s(s), loc); }
stmt label_stmt(var v, stmt s, seg_t loc) {
  return new_stmt(Label_s(v,s), loc);
}
stmt do_stmt(stmt s, exp e, seg_t loc) {
  return new_stmt(Do_s(s,$(e,skip_stmt(e->loc))), loc);
}
stmt trycatch_stmt(stmt s, list_t<switch_clause> scs, seg_t loc) {
  return new_stmt(TryCatch_s(s,scs), loc);
}
stmt goto_stmt(var lab, seg_t loc) {
  return new_stmt(Goto_s(lab,null), loc);
}
stmt assign_stmt(exp e1, exp e2, seg_t loc) {
  return exp_stmt(assign_exp(e1,e2,loc),loc);
}
/////////////////////////// Patterns //////////////////////////////
pat new_pat(raw_pat_t p, seg_t s) { return &Pat(p,null,s); }

////////////////////////// Declarations ///////////////////////////
decl new_decl(raw_decl r, seg_t loc) { return &Decl{.r=r, .loc=loc}; }
decl let_decl(pat p, opt_t<typ> t_opt, exp e, seg_t loc) {
  return new_decl(Let_d(p,null,t_opt,e,false),loc);
}
vardecl new_vardecl(qvar x, typ t, exp_opt init) {
  return &Vardecl{.sc=Public, .name=x, .tq=empty_tqual(),
		  .type=t, .initializer=init, .shadow=0, .region=null, 
                  .attributes=null};
}
vardecl static_vardecl(qvar x, typ t, exp_opt init) {
  return &Vardecl{.sc=Static, .name=x, .tq=empty_tqual(),
	          .type=t, .initializer=init, .shadow=0, .region=null,
                  .attributes=null};
}
decl struct_decl(scope s,opt_t<typedef_name_t> n,list_t<tvar> ts,
		 opt_t<list_t<structfield_t>> fs, attributes_t atts,
                 seg_t loc) {
  return new_decl(Struct_d(&Structdecl {.sc=s,.name=n,.tvs=ts,.fields=fs,
                                        .attributes = atts}),loc);
}
decl enum_decl(scope s,opt_t<typedef_name_t> n,list_t<tvar> ts,
	       opt_t<list_t<enumfield>> fs,seg_t loc) {
  return new_decl(Enum_d(&Enumdecl{.sc=s, .name=n, .tvs=ts, .fields=fs}),loc);
}
decl xenum_decl(scope s,typedef_name_t n,list_t<enumfield> fs,seg_t loc) {
 return new_decl(Xenum_d(&Xenumdecl{.sc=s, .name=n, .fields=fs}),loc);
}

// We treat function types in argument or return position as an
// abbreviation for a non-nullable pointer to a function, that is,
//   int f(void g())(float)
// is the same as
//   int (@f(void (@g)()))(float)
// We do this by constructing every function type using function_typ,
// rather than mucking with the typechecker/unifier/etc.
static $(opt_t<var>,tqual,typ)@ expand_arg($(opt_t<var>,tqual,typ)@ a) {
  return &$((*a)[0],(*a)[1],pointer_expand((*a)[2]));
}

typ function_typ(list_t<tvar> tvs, opt_t<typ> eff_typ, typ ret_typ, 
                 list_t<$(opt_t<var>,tqual,typ)@> args, bool varargs,
                 attributes_t atts) {
  return FnType(FnInfo{.tvars = tvs, .ret_typ = pointer_expand(ret_typ),
                       .effect = eff_typ, .args = List::map(expand_arg,args), 
                       .varargs = varargs, .attributes=atts});
}
typ pointer_expand(typ t) {
  //  switch (compress(t)) {
  switch (t) {
  case FnType(_): return at_typ(t,HeapRgn,empty_tqual());
// Disabled for now because it is incompatible with C
//  case ArrayType*(_,_,ak): 
//    return
//      (ak == TaggedArray) ? t : nonnullableptr_typ(t,empty_tqual());
//  case TypedefType*(n,_,_): 
//    return impos(sprintf("pointer_expand: typedef %s", qvar2string(n)));
  default: return t;
  }
}

// According to Harbison and Steele these are the lvalues of C:
//
//    exp      where
//    ---------------------------
//    name     name is a variable -- and not a function name or array!
//    e[k]
//    (e)      e is an lvalue
//    e.name   e is an lvalue
//    e->name
//    *e
//
// (We may have more in Cyclone...)

// must be called after the expression is type-checked.
bool is_lvalue(exp e) {
  switch (e->r) {
    // shouldn't allow assignment to function names or arrays
  case Var_e(_,Funname_b(_)): return false;
  case Var_e(_,Global_b(vd)): fallthru(vd);
  case Var_e(_,Local_b(vd)):
    switch (Tcutil::compress(vd->type)) {
    case ArrayType(_,_,_): return false;
    default: return true; 
    }
  case Var_e(_,_): return true;
  case Subscript_e(e1,e2):    return true;
  case StructMember_e(e1,f):  return is_lvalue(e1);
  case StructArrow_e(e1,f):   return true;
  case Deref_e(e1):           return true;
    //  case Instantiate(e1,_): return is_lvalue(e1);
    //  case NoInstantiate(e1): return is_lvalue(e1);
  default:                    return false;
  }
}

struct Structfield * lookup_struct_field(structdecl sd, var v) {
  if (sd->fields == null) 
    return null;
  for(_ fs = sd->fields->v; fs != null; fs = fs->tl) {
    let f = fs->hd;
    if (String::zstrptrcmp(f->name,v) == 0)
      return f;
  }
  return null;
}

$(tqual,typ) * lookup_tuple_field(list_t<$(tqual,typ)@> ts, int i) {
  for(; i != 0; --i) {
    if(ts == null)
      return null;
    ts = ts->tl;
  }
  if(ts == null)
    return null;
  return ts->hd;
}

string attribute2string(attribute_t a) {
  switch (a) {
  case Regparm_att(i): return xprintf("regparm(%d)",i);
  case Stdcall_att: return "stdcall";
  case Cdecl_att: return "cdecl";
  case Noreturn_att: return "noreturn";
  case Const_att: return "const";
  case Aligned_att(i): 
    if (i == -1) return "aligned";
    else return xprintf("aligned(%d)",i);
  case Packed_att: return "packed";
  case Section_att(s): return xprintf("section(\"%s\")",s);
  case Nocommon_att: return "nocommon";
  case Shared_att: return "shared";
  case Unused_att: return "unused";
  case Weak_att: return "weak";
  case Dllimport_att: return "dllimport";
  case Dllexport_att: return "dllexport";
  case No_instrument_function_att: return "no_instrument_function";
  case Constructor_att: return "constructor";
  case Destructor_att: return "destructor";
  case No_check_memory_usage_att: return "no_check_memory_usage";
  }
}
