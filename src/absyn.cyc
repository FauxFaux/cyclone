/* Abstract syntax.
   Copyright (C) 2001 Greg Morrisett, AT&T
   This file is part of the Cyclone compiler.

   The Cyclone compiler is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   The Cyclone compiler is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with the Cyclone compiler; see the file COPYING. If not,
   write to the Free Software Foundation, Inc., 59 Temple Place -
   Suite 330, Boston, MA 02111-1307, USA. */

// we define ABSYN_CYC to avoid redeclaring the abstract syntax -- see absyn.h
#define ABSYN_CYC 
#include "absyn.h"
#include <string.h>
#include <cycboot.h>
#include "tcutil.h"
#include "cyclone.h"
using Core;
using List;
using Position;

//FJS -- hack this in here until we create a file such as flags.cyc
namespace Cyclone{ 
  bool tovc_r = false;

  enum C_Compilers c_compiler = Gcc_c;
}
using Cyclone; 


namespace Absyn {

// return a negative, zero, or positive int according to whether the
// first string list is less than, equal to, or greater than the second 
static int strlist_cmp(list_t<stringptr_t> ss1, list_t<stringptr_t> ss2) {
  for (; ss1 != NULL; ss1 = ss1->tl) {
    if (ss2 == NULL) return 1;
    int i = strptrcmp(ss1->hd,ss2->hd);
    if (i != 0) return i;
    ss2 = ss2->tl;
  }
  if (ss2 != NULL) return -1;
  return 0;
}
int varlist_cmp(list_t<var_t> vs1, list_t<var_t> vs2) {
  if((int)vs1==(int)vs2) return 0;
  return strlist_cmp(vs1,vs2);
}
int qvar_cmp(qvar_t q1, qvar_t q2) {
  if (q1 == q2) return 0;
  let &$(n1,v1) = q1;
  let &$(n2,v2) = q2;
  int i = strptrcmp(v1,v2);
  if (i != 0) return i;
  switch ($(n1,n2)) {
  case $({.Loc_n = _},{.Loc_n = _}): return 0;
  case $({.Rel_n = x1},{.Rel_n = x2}): return strlist_cmp(x1,x2);
  case $({.Abs_n = x1},{.Abs_n = x2}): return strlist_cmp(x1,x2);
  case $({.C_n = x1},{.C_n = x2}): return strlist_cmp(x1,x2);
  // we arbitrarily decide that Loc_n < Rel_n < Abs_n < C_n
  case $({.Loc_n = _},_): return -1;
  case $(_,{.Loc_n = _}): return 1;
  case $({.Rel_n = _},_): return -1;
  case $(_,{.Rel_n = _}): return 1;
  case $({.Abs_n = _},_): return -1;
  case $(_,{.Abs_n = _}): return 1; 
  }
}
// WARNING: Ignores the kinds.
int tvar_cmp(tvar_t tv1, tvar_t tv2) {
  int i = strptrcmp(tv1->name,tv2->name);
  if (i != 0) return i;
  return (tv1->identity) - (tv2->identity);
}
  
nmspace_t Loc_n = Nmspace{.Loc_n = 0};
nmspace_t Abs_n(list_t<var_t,`H> x, bool C_scope) { 
  if (C_scope)
    return Nmspace{.C_n = x};
  else 
    return Nmspace{.Abs_n = x}; 
}
nmspace_t Rel_n(list_t<var_t,`H> x) { return Nmspace{.Rel_n = x}; }
nmspace_t rel_ns_null       = Nmspace{.Rel_n = NULL};

bool is_qvar_qualified(qvar_t qv) {
  switch((*qv)[0]) {
  case {.Rel_n = NULL}:
  case {.Abs_n = NULL}:
  case {.Loc_n = _}: return false;
  default:    return true;
  }
}

static int new_type_counter = 0;

type_t new_evar(opt_t<kind_t,`H> k, opt_t<list_t<tvar_t,`H>,`H> env) {
  return new Evar(k,NULL,new_type_counter++,env);
}
type_t wildtyp(opt_t<list_t<tvar_t,`H>,`H> tenv) {
  return new_evar(&Tcutil::tmko,tenv); 
}

tqual_t combine_tqual(tqual_t x,tqual_t y) { 
  return Tqual(x.print_const || y.print_const,
	       x.q_volatile || y.q_volatile,
	       x.q_restrict || y.q_restrict,
               x.real_const || y.real_const,
               segment_join(x.loc,y.loc));
}

tqual_t empty_tqual(seg_t loc) { return Tqual(false,false,false,false,loc); }
tqual_t const_tqual(seg_t loc) { return Tqual(true, false,false,true,loc); }

datacon(AbsynAnnot, EmptyAnnot);

// a static &Upper_b(&Exp(NULL,&Const_e(&Int_c(Unsigned,1)),NULL))
  //static datatype Cnst.Int_c      one_intc  = Int_c(Unsigned,1);
static datatype Raw_exp.Const_e one_b_raw = 
Const_e(Cnst{.Int_c=$(Unsigned,1)});
struct Exp exp_unsigned_one_v = {NULL,&one_b_raw,0,&EmptyAnnot_val};
exp_t exp_unsigned_one = &exp_unsigned_one_v;
static datatype Bounds.Upper_b one_bt = Upper_b(&exp_unsigned_one_v);
datatype Bounds @bounds_one = &one_bt;

union DatatypeInfoU UnknownDatatype(struct UnknownDatatypeInfo udi) {
  return DatatypeInfoU{.UnknownDatatype = udi};
}
extern union DatatypeInfoU KnownDatatype(datatypedecl_t@`H d) {
  return DatatypeInfoU{.KnownDatatype = d};
}
union DatatypeFieldInfoU UnknownDatatypefield(struct UnknownDatatypeFieldInfo s) {
  return DatatypeFieldInfoU{.UnknownDatatypefield = s};
}
union DatatypeFieldInfoU KnownDatatypefield(datatypedecl_t dd, datatypefield_t df) {
  return DatatypeFieldInfoU{.KnownDatatypefield = $(dd,df)};
}
union AggrInfoU UnknownAggr(aggr_kind_t ak,typedef_name_t n,opt_t<bool,`H> tagged) {
  return AggrInfoU{.UnknownAggr = $(ak,n,tagged)};
}
union AggrInfoU KnownAggr(aggrdecl_t@`H ad) {
  return AggrInfoU{.KnownAggr = ad};
}
//////////////////////////// Constraints /////////////////////////
conref_t<`a> new_conref(`a x) { return new Constraint{.Eq_constr = x};}
conref_t<`a> empty_conref()   { return new Constraint{.No_constr = 0};}

#define MAKE_EQ_CONSTR(str,type,val)\
  static union Constraint<type> str##_v = {.Eq_constr = val};\
  conref_t<type> str = &str##_v

datacon(Bounds,DynEither_b);

MAKE_EQ_CONSTR(true_conref,bool,true);
MAKE_EQ_CONSTR(false_conref,bool,false);
MAKE_EQ_CONSTR(bounds_one_conref,bounds_t,&one_bt);
MAKE_EQ_CONSTR(bounds_dyneither_conref,bounds_t,&DynEither_b_val);
#undef MAKE_EQ_CONSTR

// compress a conref
conref_t<`a> compress_conref(conref_t<`a> x) {
  switch (x) {
  case &Constraint{.No_constr = _}:
  case &Constraint{.Eq_constr = _}: return x;
  case &Constraint{.Forward_constr = y}:
    let z = compress_conref(y);
    x->Forward_constr = z;
    return z;
  }
}

`a conref_val(conref_t<`a> x) {
  switch (compress_conref(x)) {
  case &Constraint{.Eq_constr = v}: return v;
  default: Tcutil::impos("conref_val");
  }
}

`a conref_def(`a y, conref_t<`a> x) {
  switch (x) {
  case &Constraint{.Eq_constr = v}: return v;
  case &Constraint{.No_constr = _}: return y;
  default: return conref_def(y,compress_conref(x));
  }
}

`a conref_constr(`a y, conref_t<`a> x) {
  x = compress_conref(x);
  switch (x) {
  case &Constraint{.Eq_constr = v}: return v;
  default: x->Eq_constr = y; return y;
  }
}

kindbound_t compress_kb(kindbound_t k) {
  switch (k) {
  case &Eq_kb(_): 
  case &Unknown_kb(NULL):
  case &Less_kb(NULL,_): return k;
  case &Unknown_kb(&Opt(*k2)): fallthru(k2);
  case &Less_kb(&Opt(*k2),_): 
    *k2 = compress_kb(*k2);
    return *k2;
  }
}

kind_t force_kb(kindbound_t kb) {
  switch (compress_kb(kb)) {
  case &Eq_kb(k): return k;
  case &Unknown_kb(*f): fallthru(f,&Tcutil::bk);
  case &Less_kb(*f,k):
    *f = new Opt(Tcutil::kind_to_bound(k)); 
    return k;
  }
}

//////////////////////////// Types ///////////////////////////////
datacon(Type,HeapRgn);
datacon(Type,UniqueRgn);
datacon(Type,RefCntRgn);
datacon(Type,VoidType);

// unsigned types
static datatype Type.IntType char_tt      = IntType(None,Char_sz);
static datatype Type.IntType uchar_tt     = IntType(Unsigned,Char_sz);
static datatype Type.IntType ushort_tt    = IntType(Unsigned,Short_sz);
static datatype Type.IntType uint_tt      = IntType(Unsigned,Int_sz);
static datatype Type.IntType ulong_tt     = IntType(Unsigned,Long_sz);
static datatype Type.IntType ulonglong_tt = IntType(Unsigned,LongLong_sz);
type_t char_typ      = &char_tt;
type_t uchar_typ     = &uchar_tt;
type_t ushort_typ    = &ushort_tt;
type_t uint_typ      = &uint_tt;
type_t ulong_typ     = &ulong_tt;
type_t ulonglong_typ = &ulonglong_tt;
// signed types
static datatype Type.IntType schar_tt     = IntType(Signed,Char_sz);
static datatype Type.IntType sshort_tt    = IntType(Signed,Short_sz);
static datatype Type.IntType sint_tt      = IntType(Signed,Int_sz);
static datatype Type.IntType slong_tt     = IntType(Signed,Long_sz);
static datatype Type.IntType slonglong_tt = IntType(Signed,LongLong_sz);
type_t schar_typ     = &schar_tt;
type_t sshort_typ    = &sshort_tt;
type_t sint_typ      = &sint_tt;
type_t slong_typ     = &slong_tt;
type_t slonglong_typ = &slonglong_tt;
// no sign
static datatype Type.IntType nshort_tt    = IntType(None,Short_sz);
static datatype Type.IntType nint_tt      = IntType(None,Int_sz);
static datatype Type.IntType nlong_tt     = IntType(None,Long_sz);
static datatype Type.IntType nlonglong_tt = IntType(None,LongLong_sz);
type_t nshort_typ    = &nshort_tt;
type_t nint_typ      = &nint_tt;
type_t nlong_typ     = &nlong_tt;
type_t nlonglong_typ = &nlonglong_tt;

type_t int_typ(sign_t sn, size_of_t sz) {
  switch (sn) {
  case Signed:
    switch (sz) {
    case Char_sz: return schar_typ;
    case Short_sz: return sshort_typ;
    case Int_sz: return sint_typ;
    case Long_sz: return slong_typ;
    case LongLong_sz: return slonglong_typ;
    }
  case Unsigned:
    switch (sz) {
    case Char_sz: return uchar_typ;
    case Short_sz: return ushort_typ;
    case Int_sz: return uint_typ;
    case Long_sz: return ulong_typ;
    case LongLong_sz: return ulonglong_typ;
    }
  case None:
    switch (sz) {
    case Char_sz: return char_typ;
    case Short_sz: return nshort_typ;
    case Int_sz: return nint_typ;
    case Long_sz: return nlong_typ;
    case LongLong_sz: return nlonglong_typ;
    }
  }
}
// float, double, long double
type_t float_typ(int i) {
  static datatype Type.FloatType fl = FloatType(0);
  static datatype Type.FloatType db = FloatType(1);
  static datatype Type.FloatType ldb = FloatType(2);
  if (i==0) return &fl;
  if (i==1) return &db;
  return &ldb;
}
// wide characters
// from install_path.c
extern "C" {
  extern int Wchar_t_unsigned;
  extern int Sizeof_wchar_t;
}
type_t wchar_typ() {
  switch (Sizeof_wchar_t) {
  case 1:
    /* This is a problem case.  If wchar_t is declared to be
       char instead of unsigned char or signed char in the
       header files, then
         wchar_t x[] = L"abc";
       won't typecheck, because wchar_t will be filled in by
       just char and the type of the initializer will be
       signed or unsigned char.  Since we have a sign None
       as well as Signed and Unsigned, this won't work. */
    return (Wchar_t_unsigned?uchar_typ:schar_typ);
  case 2: return (Wchar_t_unsigned?ushort_typ:sshort_typ);
  default:
    /* FIX: We're assuming 4 is the max size */
    return (Wchar_t_unsigned?uint_typ:sint_typ);
  }
}
// exceptions
static string_t exn_str = "exn";
static $(nmspace_t,var_t) exn_name_v = $(Nmspace{.Abs_n = NULL},&exn_str);
qvar_t exn_name   = &exn_name_v;

#define MAKE_BUILTIN_EXN(str)\
  static string_t            str##_str   = #str;\
  static $(nmspace_t, var_t) str##_pr    = $(Nmspace{.Abs_n=NULL},&str##_str);\
  qvar_t                     str##_name  = &str##_pr;\
  static struct Datatypefield  str##_tuf_v = Datatypefield(&str##_pr,\
				 		       NULL,0,Extern);\
  datatypefield_t              str##_tuf   = &str##_tuf_v

MAKE_BUILTIN_EXN(Null_Exception);
MAKE_BUILTIN_EXN(Array_bounds);
MAKE_BUILTIN_EXN(Match_Exception);
MAKE_BUILTIN_EXN(Bad_alloc);
#undef MAKE_BUILTIN_EXN

static struct List<datatypefield_t> exn_l0 = List(&Null_Exception_tuf_v, NULL);
static struct List<datatypefield_t> exn_l1 = List(&Array_bounds_tuf_v,   &exn_l0);
static struct List<datatypefield_t> exn_l2 = List(&Match_Exception_tuf_v,&exn_l1);
static struct List<datatypefield_t> exn_l3 = List(&Bad_alloc_tuf_v,      &exn_l2);

static struct Opt<list_t<datatypefield_t>> exn_ol = Opt(&exn_l3);
static struct Datatypedecl exn_tud_v = Datatypedecl(Extern, &exn_name_v, NULL,
                                                    &exn_ol, true);
datatypedecl_t exn_tud = &exn_tud_v;

  //static datatype DatatypeInfoU.KnownDatatype exn_tinfou = KnownDatatype(&exn_tud);
static datatype Type.DatatypeType exn_typ_tt =
                  DatatypeType(DatatypeInfo(DatatypeInfoU{.KnownDatatype=&exn_tud},NULL));
type_t exn_typ() {
  static opt_t<type_t> exn_type_val = NULL;
  if (exn_type_val == NULL) {
    exn_type_val = new Opt(at_typ(&exn_typ_tt, &HeapRgn_val, 
                                  empty_tqual(0), false_conref));
  }
  return exn_type_val->v;
}

// datatype PrintArg and datatype ScanfArg qvars
static string_t printarg_str = "PrintArg";
static string_t scanfarg_str = "ScanfArg";
static $(nmspace_t,var_t) datatype_print_arg_qvar_p = 
  $(Nmspace{.Abs_n = NULL}, &printarg_str);
static $(nmspace_t,var_t) datatype_scanf_arg_qvar_p = 
  $(Nmspace{.Abs_n = NULL}, &scanfarg_str);
qvar_t datatype_print_arg_qvar = &datatype_print_arg_qvar_p;
qvar_t datatype_scanf_arg_qvar = &datatype_scanf_arg_qvar_p;

// unique region qvar.  We need this so that code generation properly
// attributes an allocation to the unique region.  This way, when
// doing dynamic region profiling we correctly tally the stuff stored
// in the unique region
// FIX: must correspond with def in core.h; should have just one def
static string_t uniquergn_str = "unique_region";
static string_t Core_str = "Core";
static struct List<var_t> uniquergn_nmspace =
  List((var_t)&Core_str,(list_t<var_t,`H>)NULL);
static $(nmspace_t,var_t) uniquergn_qvar_p = 
  $(Nmspace{.Abs_n = &uniquergn_nmspace }, &uniquergn_str);
qvar_t uniquergn_qvar = &uniquergn_qvar_p;

static datatype Type.RgnHandleType uniquergn_typ = 
  RgnHandleType(&UniqueRgn_val);

static struct Vardecl uniquergn_var_d =
  Vardecl(Extern,&uniquergn_qvar_p,Tqual(false,false,false,false,0),
	  &uniquergn_typ, NULL, NULL, NULL, false);
static datatype Binding.Global_b uniquergn_bind_p = Global_b(&uniquergn_var_d);

static datatype Raw_exp.Var_e uniquergn_exp_r =
  Var_e(&uniquergn_qvar_p,&uniquergn_bind_p);

static struct Exp uniquergn_exp_p =
  Exp(&uniquergn_typ, &uniquergn_exp_r, 0, &EmptyAnnot_val);

exp_t uniquergn_exp = &uniquergn_exp_p;

// string
static type_t* string_t_opt = NULL;
type_t string_typ(type_t rgn) {
  switch (Tcutil::compress(rgn)) {
  case &HeapRgn:
    if (string_t_opt == NULL) {
      type_t t = starb_typ(char_typ,&HeapRgn_val,empty_tqual(0),
                           &DynEither_b_val,true_conref);
      string_t_opt = new t;
    }
    return *string_t_opt;
  default:
    return starb_typ(char_typ,rgn,empty_tqual(0),&DynEither_b_val,true_conref);
  }
}
static type_t* const_string_t_opt = NULL;
type_t const_string_typ(type_t rgn) {
  switch (Tcutil::compress(rgn)) {
  case &HeapRgn:
    if (const_string_t_opt == NULL) {
      type_t t = starb_typ(char_typ,&HeapRgn_val,const_tqual(0),
                           &DynEither_b_val,true_conref);
      const_string_t_opt = new t;
    }
    return *const_string_t_opt;
  default:
    return starb_typ(char_typ,rgn,const_tqual(0),&DynEither_b_val,true_conref);
  }
}
// pointers

type_t starb_typ(type_t t, type_t r, tqual_t tq, bounds_t b, 
                 conref_t<bool> zeroterm) {
  return new PointerType(PtrInfo {.elt_typ = t, .elt_tq = tq,
				  PtrAtts{.rgn = r, .nullable = true_conref, 
					  .bounds = new_conref(b),
					  .zero_term = zeroterm, 
                                          .ptrloc=NULL}});
}
type_t atb_typ(type_t t, type_t r, tqual_t tq, bounds_t b,
	       conref_t<bool> zeroterm) {
  return new PointerType(PtrInfo {.elt_typ = t, .elt_tq = tq,
				  PtrAtts{.rgn = r, .nullable = false_conref, 
					  .bounds = new_conref(b),
					  .zero_term = zeroterm, 
                                          .ptrloc=NULL}});
}

type_t star_typ(type_t t, type_t r, tqual_t tq, conref_t<bool> zeroterm) { 
  return new PointerType(PtrInfo {.elt_typ = t, .elt_tq = tq,
				  PtrAtts{.rgn = r, .nullable = true_conref, 
					  .bounds = bounds_one_conref,
					  .zero_term = zeroterm, 
                                          .ptrloc=NULL}});
}
type_t cstar_typ(type_t t, tqual_t tq) { 
  return new PointerType(PtrInfo {.elt_typ = t, .elt_tq = tq,
				  PtrAtts{.rgn = &HeapRgn_val, 
					  .nullable = true_conref, 
					  .bounds = bounds_one_conref,
					  .zero_term = false_conref,
                                          .ptrloc=NULL}});
}
type_t at_typ(type_t t, type_t r, tqual_t tq, conref_t<bool> zeroterm) {
  return new PointerType(PtrInfo {.elt_typ = t, .elt_tq = tq,
				  PtrAtts{.rgn = r, .nullable = false_conref, 
					  .bounds = bounds_one_conref,
					  .zero_term = zeroterm, 
                                          .ptrloc=NULL}});
}
type_t dyneither_typ(type_t t, type_t r, tqual_t tq, conref_t<bool> zeroterm) {
  return new PointerType(PtrInfo {.elt_typ = t, .elt_tq = tq,
				  PtrAtts{.rgn = r, .nullable = true_conref, 
					  .bounds = bounds_dyneither_conref,
					  .zero_term = zeroterm, 
                                          .ptrloc=NULL}});
}

type_t array_typ(type_t elt_type, tqual_t tq, exp_opt_t num_elts, 
                 conref_t<bool> zero_term, seg_t ztloc) {
  return new ArrayType(ArrayInfo{elt_type,tq,num_elts,zero_term,ztloc});
}

// FILE

// Maybe someday we'll allow FILE objects to live somewhere other than
// in the heap (by making the runtime interface more flexible).  
// If so, we'll need a rgn_t argument.
type_t file_typ() {
  static type_t* file_t_opt = NULL;
  static string_t sf_str = "__sFILE";
  static stringptr_t sf = &sf_str;

  if(file_t_opt == NULL) {
    typedef_name_t file_t_name = new $(Abs_n(NULL,false), sf);
    aggrdecl_t sd = new Aggrdecl(StructA,Abstract,file_t_name,NULL,NULL,NULL);
    type_t file_struct_typ = new AggrType(AggrInfo(KnownAggr(new sd),NULL));
    file_t_opt = new at_typ(file_struct_typ,&HeapRgn_val,empty_tqual(0),
                            false_conref);
  }
  return *file_t_opt;
}

type_t void_star_typ() {
  static type_t* void_star_t_opt = NULL;

  if (void_star_t_opt == NULL)
    void_star_t_opt = new star_typ(&VoidType_val,&HeapRgn_val,
                                   empty_tqual(0),false_conref);
  return *void_star_t_opt;
}
static datatype Type.JoinEff empty_eff = JoinEff(NULL);
type_t empty_effect = &empty_eff;

// structs and unions
// WARNING: currently only Toc calls these, so we don't need to set
//          the aggrdecl field.  Beware using them anywhere else!
// (Probably we should require setting the third field even in Toc.)
type_t aggr_typ(aggr_kind_t k, var_t name) {
  return new AggrType(AggrInfo(UnknownAggr(k, new $(rel_ns_null,name), NULL),
			       NULL));
}
type_t strct(var_t name)     { return aggr_typ(StructA,name); }
type_t union_typ(var_t name) { return aggr_typ(UnionA,name);  }

type_t strctq(qvar_t name) {
  return new AggrType(AggrInfo(UnknownAggr(StructA,name,NULL), NULL));
}
type_t unionq_typ(qvar_t name) {
  return new AggrType(AggrInfo(UnknownAggr(UnionA,name,NULL), NULL));
}
///////////////////////// Constants //////////////////////////////
cnst_t Null_c = Cnst{.Null_c = 0};
cnst_t Char_c(sign_t sn,char c) {return Cnst{.Char_c = $(sn,c)};}
cnst_t Wchar_c(string_t<`H> s)  {return Cnst{.Wchar_c = s};}
cnst_t Short_c(sign_t sn,short s) {return Cnst{.Short_c = $(sn,s)};}
cnst_t Int_c(sign_t sn,int i) {return Cnst{.Int_c = $(sn,i)};}
cnst_t LongLong_c(sign_t sn,long long l) {return Cnst{.LongLong_c = $(sn,l)};}
cnst_t Float_c(string_t<`H> s,int i) {return Cnst{.Float_c = $(s,i)};}
cnst_t String_c(string_t<`H> s) {return Cnst{.String_c = s};}
cnst_t Wstring_c(string_t<`H> s) {return Cnst{.Wstring_c = s};}

///////////////////////// Expressions //////////////////////////////
exp_t new_exp(raw_exp_t r, seg_t loc) {
  return new Exp{.topt=NULL, .r=r, .loc=loc, .annot=&EmptyAnnot_val};
}
exp_t New_exp(exp_opt_t rgn_handle, exp_t e, seg_t loc) {
  return new_exp(new New_e(rgn_handle,e), loc);
}
exp_t copy_exp(exp_t e) {
  return new *e;
}
exp_t const_exp(cnst_t c, seg_t loc) { 
  return new_exp(new Const_e(c), loc); 
}
exp_t null_exp(seg_t loc) { 
  static datatype Raw_exp.Const_e null_const = Const_e(Cnst{.Null_c = 0});
  return new_exp(&null_const, loc); 
}
exp_t int_exp(sign_t s,int i,seg_t seg) {return const_exp(Int_c(s,i),seg);}
exp_t signed_int_exp(int i, seg_t loc) {
  static datatype Raw_exp.Const_e szero = Const_e(Cnst{.Int_c = $(Signed,0)});
  static datatype Raw_exp.Const_e sone = Const_e(Cnst{.Int_c = $(Signed,1)});
  if (i == 0) return new_exp(&szero, loc);
  else if (i == 1) return new_exp(&sone, loc);
  return int_exp(Signed,i,loc);
}
exp_t uint_exp(unsigned int i, seg_t loc) {
  static datatype Raw_exp.Const_e uzero = Const_e(Cnst{.Int_c =$(Unsigned,0)});
  static datatype Raw_exp.Const_e uone = Const_e(Cnst{.Int_c = $(Unsigned,1)});
  if (i == 0) return new_exp(&uzero, loc);
  else if (i == 1) return new_exp(&uone,loc);
  else return int_exp(Unsigned,i,loc);
}
exp_t bool_exp(bool b, seg_t loc) { return signed_int_exp(b ? 1 : 0, loc); }
exp_t true_exp(seg_t loc)  { return bool_exp(true, loc); }
exp_t false_exp(seg_t loc) { return bool_exp(false, loc); }
exp_t char_exp(char c, seg_t loc) {
  return const_exp(Char_c(None,c),loc);
}
exp_t wchar_exp(string_t<`H> s, seg_t loc) {
  return const_exp(Wchar_c(s),loc);
}
exp_t float_exp(string_t<`H> f, int i, seg_t loc) { return const_exp(Float_c(f,i),loc);  }
exp_t string_exp(string_t<`H> s, seg_t loc){ return const_exp(String_c(s),loc); }
exp_t wstring_exp(string_t<`H> s, seg_t loc){ return const_exp(Wstring_c(s),loc); }

datacon(Binding,Unresolved_b);

// This should only be used after type checking.
exp_t var_exp(qvar_t q, seg_t loc) {
  return new_exp(new Var_e(q,&Unresolved_b_val), loc);
}
exp_t varb_exp(qvar_t q, binding_t b, seg_t loc) {
  return new_exp(new Var_e(q, b), loc);
}
// Used for unresolved variables now
exp_t unknownid_exp(qvar_t q, seg_t loc) { 
  return new_exp(new Var_e(q,&Unresolved_b_val), loc);
}
exp_t primop_exp(primop_t p, list_t<exp_t,`H> es, seg_t loc) {
  return new_exp(new Primop_e(p,es),loc);
}
exp_t prim1_exp(primop_t p, exp_t e, seg_t loc) {
  return primop_exp(p, new List(e,NULL), loc);
}
exp_t prim2_exp(primop_t p, exp_t e1, exp_t e2, seg_t loc) {
  return primop_exp(p, new List(e1,new List(e2,NULL)), loc);
}
exp_t swap_exp(exp_t e1, exp_t e2, seg_t loc) {
  return new_exp(new Swap_e(e1,e2),loc);
}
exp_t add_exp(exp_t e1,exp_t e2,seg_t loc)   {return prim2_exp(Plus,e1,e2,loc);}
exp_t times_exp(exp_t e1,exp_t e2,seg_t loc){return prim2_exp(Times,e1,e2,loc);}
exp_t divide_exp(exp_t e1,exp_t e2,seg_t loc){return prim2_exp(Div,e1,e2,loc);}
exp_t eq_exp(exp_t e1,  exp_t e2, seg_t loc) {return prim2_exp(Eq,e1,e2,loc);}
exp_t neq_exp(exp_t e1, exp_t e2, seg_t loc) {return prim2_exp(Neq,e1,e2,loc);}
exp_t gt_exp(exp_t e1,  exp_t e2, seg_t loc) {return prim2_exp(Gt,e1,e2,loc);}
exp_t lt_exp(exp_t e1,  exp_t e2, seg_t loc) {return prim2_exp(Lt,e1,e2,loc);}
exp_t gte_exp(exp_t e1, exp_t e2, seg_t loc) {return prim2_exp(Gte,e1,e2,loc);}
exp_t lte_exp(exp_t e1, exp_t e2, seg_t loc) {return prim2_exp(Lte,e1,e2,loc);}

exp_t assignop_exp(exp_t e1, opt_t<primop_t,`H> popt, exp_t e2, seg_t loc) {
  return new_exp(new AssignOp_e(e1,popt,e2),loc);
}
exp_t assign_exp(exp_t e1, exp_t e2, seg_t loc) {
  return assignop_exp(e1,NULL,e2,loc);
}
exp_t increment_exp(exp_t e,incrementor_t i,seg_t loc) {
  return new_exp(new Increment_e(e,i),loc);
}
exp_t post_inc_exp(exp_t e,seg_t loc){return increment_exp(e,PostInc,loc);}
exp_t pre_inc_exp(exp_t e, seg_t loc){return increment_exp(e,PreInc,loc);}
exp_t pre_dec_exp(exp_t e, seg_t loc){return increment_exp(e,PreDec,loc);}
exp_t post_dec_exp(exp_t e,seg_t loc){return increment_exp(e,PostDec,loc);}
exp_t conditional_exp(exp_t e1,exp_t e2,exp_t e3,seg_t loc) {
  return new_exp(new Conditional_e(e1,e2,e3), loc);
}
exp_t and_exp(exp_t e1, exp_t e2, seg_t loc) {
  return new_exp(new And_e(e1,e2), loc);
}
exp_t or_exp(exp_t e1, exp_t e2, seg_t loc) {
  return new_exp(new Or_e(e1,e2), loc);
}
exp_t seq_exp(exp_t e1, exp_t e2, seg_t loc) {
  return new_exp(new SeqExp_e(e1,e2), loc);
}
exp_t unknowncall_exp(exp_t e, list_t<exp_t,`H> es, seg_t loc) {
  return new_exp(new FnCall_e(e,es,NULL,false), loc);
}
exp_t fncall_exp(exp_t e, list_t<exp_t,`H> es, seg_t loc) {
  return new_exp(new FnCall_e(e,es,NULL,true), loc);
}
exp_t noinstantiate_exp(exp_t e, seg_t loc) {
  return new_exp(new NoInstantiate_e(e), loc);
}
exp_t instantiate_exp(exp_t e, list_t<type_t,`H> ts, seg_t loc) {
  return new_exp(new Instantiate_e(e,ts), loc);
}
exp_t cast_exp(type_t t, exp_t e, bool user_cast, coercion_t c, seg_t loc) { 
  return new_exp(new Cast_e(t,e,user_cast,c), loc);
}
exp_t throw_exp(exp_t e, seg_t loc) { return new_exp(new Throw_e(e),   loc); }
exp_t address_exp(exp_t e, seg_t loc) { return new_exp(new Address_e(e), loc); }
exp_t sizeoftyp_exp(type_t t, seg_t loc) {
  return new_exp(new Sizeoftyp_e(t), loc); 
}
exp_t sizeofexp_exp(exp_t e, seg_t loc) { 
  return new_exp(new Sizeofexp_e(e), loc); 
}
exp_t offsetof_exp(type_t t, list_t<offsetof_field_t,`H> ofs, seg_t loc) {
  return new_exp(new Offsetof_e(t,ofs), loc);
}
exp_t deref_exp(exp_t e,   seg_t loc) { return new_exp(new Deref_e(e), loc); }
exp_t aggrmember_exp(exp_t e, field_name_t n, seg_t loc) {
  return new_exp(new AggrMember_e(e,n,false,false), loc); 
}
exp_t aggrarrow_exp(exp_t e, field_name_t n, seg_t loc) {
  return new_exp(new AggrArrow_e(e,n,false,false), loc); 
}
exp_t subscript_exp(exp_t e1, exp_t e2, seg_t loc) {
  return new_exp(new Subscript_e(e1,e2), loc); 
}
exp_t tuple_exp(list_t<exp_t,`H> es, seg_t loc) {
  return new_exp(new Tuple_e(es), loc); 
}
exp_t stmt_exp(stmt_t s,seg_t loc) { return new_exp(new StmtExp_e(s), loc); }

exp_t match_exn_exp(seg_t loc) { 
  return var_exp(Match_Exception_name, loc); 
}

exp_t valueof_exp(type_t t, seg_t loc) {
  return new_exp(new Valueof_e(t), loc);
}
exp_t asm_exp(bool volatile_kw, string_t<`H> body, seg_t loc) {
  return new_exp(new Asm_e(volatile_kw,body),loc);
}

exp_t array_exp(list_t<exp_t,`H> es, seg_t loc) {
  // FIX:  this doesn't work let dles = NULL;
  list_t<$(list_t<designator_t,`H>,exp_t)@`H> dles = NULL;
  for (; es != NULL; es = es->tl)
    dles = new List(new $(NULL,es->hd),dles);
  dles = List::imp_rev(dles);
  return new_exp(new Array_e(dles),loc);
}
exp_t unresolvedmem_exp(opt_t<typedef_name_t,`H> n,
                        list_t<$(list_t<designator_t,`H>,exp_t)@`H,`H> dles,
                        seg_t loc) {
  return new_exp(new UnresolvedMem_e(n,dles),loc);
}
///////////////////////// Statements ///////////////////////////////
stmt_t new_stmt(raw_stmt_t s, seg_t loc) { 
  return new Stmt{.r=s, .loc=loc, .non_local_preds=NULL, .try_depth=0,
                  .annot=&EmptyAnnot_val }; 
}
datatype Raw_stmt.Skip_s Skip_s_val = Skip_s;
stmt_t skip_stmt(seg_t loc) { return new_stmt(&Skip_s_val, loc); }
stmt_t exp_stmt(exp_t e,seg_t loc) { return new_stmt(new Exp_s(e),loc); }
stmt_t seq_stmts(list_t<stmt_t> ss, seg_t loc) {
  if (ss == NULL) return skip_stmt(loc);
  else if (ss->tl == NULL) return ss->hd;
  else return seq_stmt(ss->hd,seq_stmts(ss->tl,loc),loc);
}
stmt_t return_stmt(exp_opt_t e,seg_t loc) { 
  return new_stmt(new Return_s(e),loc); 
}
stmt_t ifthenelse_stmt(exp_t e,stmt_t s1,stmt_t s2,seg_t loc) {
  return new_stmt(new IfThenElse_s(e,s1,s2),loc);
}
stmt_t while_stmt(exp_t e,stmt_t s,seg_t loc) { 
  return new_stmt(new While_s($(e,skip_stmt(e->loc)),s), loc);
}
stmt_t break_stmt   (seg_t loc) { return new_stmt(new Break_s(NULL), loc); }
stmt_t continue_stmt(seg_t loc) { return new_stmt(new Continue_s(NULL), loc); }
stmt_t for_stmt(exp_t e1,exp_t e2,exp_t e3,stmt_t s,seg_t loc) {
  return new_stmt(new For_s(e1,$(e2,skip_stmt(e3->loc)),
                            $(e3,skip_stmt(e3->loc)),s),
		  loc);
}
stmt_t switch_stmt(exp_t e, list_t<switch_clause_t,`H> scs, seg_t loc) {
  return new_stmt(new Switch_s(e,scs), loc);
}
stmt_t seq_stmt(stmt_t s1, stmt_t s2, seg_t loc) { 
  switch ($(s1->r,s2->r)) {
  case $(&Skip_s,_): return s2;
  case $(_,&Skip_s): return s1;
  default: return new_stmt(new Seq_s(s1,s2), loc); 
  }
}
stmt_t fallthru_stmt(list_t<exp_t,`H> el, seg_t loc) { 
  return new_stmt(new Fallthru_s(el,NULL), loc); 
}
stmt_t decl_stmt(decl_t d, stmt_t s, seg_t loc) {
  return new_stmt(new Decl_s(d,s), loc);
}
stmt_t declare_stmt(qvar_t x, type_t t, exp_opt_t init, stmt_t s, seg_t loc) {
  decl_t d = new_decl(new Var_d(new_vardecl(x,t,init)),loc);
  return new_stmt(new Decl_s(d,s),loc);
}
stmt_t label_stmt(var_t v, stmt_t s, seg_t loc) {
  return new_stmt(new Label_s(v,s), loc);
}
stmt_t do_stmt(stmt_t s, exp_t e, seg_t loc) {
  return new_stmt(new Do_s(s,$(e,skip_stmt(e->loc))), loc);
}
stmt_t trycatch_stmt(stmt_t s, list_t<switch_clause_t,`H> scs, seg_t loc) {
  return new_stmt(new TryCatch_s(s,scs), loc);
}
stmt_t goto_stmt(var_t lab, seg_t loc) {
  return new_stmt(new Goto_s(lab,NULL), loc);
}
stmt_t assign_stmt(exp_t e1, exp_t e2, seg_t loc) {
  return exp_stmt(assign_exp(e1,e2,loc),loc);
}
/////////////////////////// Patterns //////////////////////////////
pat_t new_pat(raw_pat_t p, seg_t s) { return new Pat(p,NULL,s); }
pat_t exp_pat(exp_t e) { return new_pat(new Exp_p(e),e->loc); }
datatype Raw_pat.Wild_p Wild_p_val = Wild_p;
datatype Raw_pat.Null_p Null_p_val = Null_p;

////////////////////////// Declarations ///////////////////////////
decl_t new_decl(raw_decl_t r, seg_t loc) { return new Decl{.r=r, .loc=loc}; }
decl_t let_decl(pat_t p, exp_t e, seg_t loc) {
  return new_decl(new Let_d(p,NULL,e),loc);
}
decl_t letv_decl(list_t<vardecl_t,`H> vds, seg_t loc) {
  return new_decl(new Letv_d(vds),loc);
}
decl_t region_decl(tvar_t tv,vardecl_t vd,bool resetable,exp_opt_t eo,seg_t loc) {
  return new_decl(new Region_d(tv,vd,resetable,eo),loc);
}
decl_t alias_decl(tvar_t tv,vardecl_t vd,seg_t loc) {
  return new_decl(new Alias_d(tv,vd),loc);
}

vardecl_t new_vardecl(qvar_t x, type_t t, exp_opt_t init) {
  return new Vardecl{.sc=Public, .name=x, .tq=empty_tqual(0),
                        .type=t, .initializer=init, .rgn=NULL, 
                        .attributes=NULL, .escapes=false};
}
vardecl_t static_vardecl(qvar_t x, type_t t, exp_opt_t init) {
  return new Vardecl{.sc=Static, .name=x, .tq=empty_tqual(0),
                        .type=t, .initializer=init, .rgn=NULL,
                        .attributes=NULL, .escapes=false};
}
struct AggrdeclImpl @ aggrdecl_impl(list_t<tvar_t,`H> exists,
				    list_t<$(type_t,type_t)@`H,`H> po,
				    list_t<aggrfield_t,`H> fs, 
                                    bool tagged) {
  return new AggrdeclImpl{.exist_vars=exists, .rgn_po=po, 
                          .fields=fs, .tagged = tagged};
}
decl_t aggr_decl(aggr_kind_t k, scope_t s, typedef_name_t n,
		 list_t<tvar_t,`H> ts, struct AggrdeclImpl *`H i,
		 attributes_t atts, seg_t loc) {
  return new_decl(new Aggr_d(new Aggrdecl {.kind = k, .sc=s, .name=n, .tvs=ts,
					   .impl=i, .attributes = atts}),
		  loc);
}
type_decl_t aggr_tdecl(aggr_kind_t k, scope_t s, typedef_name_t n,
		 list_t<tvar_t,`H> ts, struct AggrdeclImpl *`H i,
		 attributes_t atts, seg_t loc) {
  return new TypeDecl(new Aggr_td(new Aggrdecl {.kind = k, .sc=s, .name=n, 
                                                .tvs=ts, .impl=i, 
                                                   .attributes = atts}),loc);
}
decl_t struct_decl(scope_t s,typedef_name_t n,
		   list_t<tvar_t,`H> ts, struct AggrdeclImpl *`H i,
                   attributes_t atts, seg_t loc) {
  return aggr_decl(StructA,s,n,ts,i,atts,loc);
}
decl_t union_decl(scope_t s,typedef_name_t n,
		  list_t<tvar_t,`H> ts, struct AggrdeclImpl *`H i,
		  attributes_t atts, seg_t loc) {
  return aggr_decl(UnionA,s,n,ts,i,atts,loc);
}
decl_t datatype_decl(scope_t s, typedef_name_t n, list_t<tvar_t,`H> ts,
		   opt_t<list_t<datatypefield_t,`H>,`H> fs, 
                   bool is_extensible, seg_t loc){
  return new_decl(new Datatype_d(new Datatypedecl(s,n,ts,fs,is_extensible)),
                  loc);
}
type_decl_t datatype_tdecl(scope_t s, typedef_name_t n, list_t<tvar_t,`H> ts,
                           opt_t<list_t<datatypefield_t,`H>,`H> fs, 
                           bool is_extensible, seg_t loc){
  return new TypeDecl(new Datatype_td(new Datatypedecl(s,n,ts,fs,
                                                       is_extensible)),
                      loc);
}

// We treat function types in argument or return position as an
// abbreviation for a non-nullable pointer to a function, that is,
//   int f(void g())(float)
// is the same as
//   int (@f(void (@g)()))(float)
// We do this by constructing every function type using function_typ,
// rather than mucking with the typechecker/unifier/etc.
static void expand_arg($(var_opt_t,tqual_t,type_t)@ a) {
  let t = (*a)[2];
  let t_new = pointer_expand(t,true);
  if (t != t_new) 
    (*a)[2] = t_new;
}

type_t function_typ(list_t<tvar_t,`H> tvs, type_opt_t eff_typ, 
                    tqual_t ret_tqual,
                    type_t ret_typ, 
                    list_t<$(var_opt_t,tqual_t,type_t)@`H,`H> args, 
                    bool c_varargs, vararg_info_t *`H cyc_varargs,
                    list_t<$(type_t,type_t)@`H,`H> rgn_po,
                    attributes_t atts) {
  List::iter(expand_arg,args);
  return new FnType(FnInfo{.tvars = tvs, 
                              .ret_tqual = ret_tqual,
                              .ret_typ = pointer_expand(ret_typ,false),
                              .effect = eff_typ, 
                              .args = args, 
                              .c_varargs = c_varargs, 
                              .cyc_varargs = cyc_varargs,
                              .rgn_po = rgn_po,
                              .attributes=atts});
}
// MWH: use RgnKind here rather than TopRgnKind for fresh evars;
//   function pointers can't be unique at the moment
type_t pointer_expand(type_t t,bool fresh_evar) {
  switch (Tcutil::compress(t)) {
  case &FnType(_): return at_typ(t,
                                 fresh_evar ? 
				 new_evar(new Opt(&Tcutil::rk),
					  NULL) : &HeapRgn_val,
                                 empty_tqual(0),false_conref);
  default: return t;
  }
}

// These are the lvalues of C:
//    exp      where
//    ---------------------------
//    name     name is a variable -- and not a function name or array!
//    e[k]
//    (e)      e is an lvalue
//    e.name   e is an lvalue
//    e->name
//    *e

// must be called after the expression is type-checked.
bool is_lvalue(exp_t e) {
  switch (e->r) {
    // shouldn't allow assignment to function names or arrays
  case &Var_e(_,&Funname_b(_)): return false;
  case &Var_e(_,&Global_b(vd)): fallthru(vd);
  case &Var_e(_,&Local_b(vd)):
    switch (Tcutil::compress(vd->type)) {
    case &ArrayType(_): return false;
    default: return true; 
    }
  case &Var_e(...):    
  case &AggrArrow_e(...):   
  case &Deref_e(...):           
  case &Subscript_e(...):    return true;
  case &AggrMember_e(e1,...):  return is_lvalue(e1);
  case &Instantiate_e(e1,...): return is_lvalue(e1);
  case &NoInstantiate_e(e1): return is_lvalue(e1);
  default:                   return false;
  }
}

struct Aggrfield * lookup_field(list_t<aggrfield_t> fields, var_t v) {
  for(let fs = fields; fs != NULL; fs = fs->tl)
    if (strptrcmp(fs->hd->name,v) == 0)
      return fs->hd;
  return NULL;
}
struct Aggrfield * lookup_decl_field(aggrdecl_t ad, var_t v) {
  return (ad->impl == NULL) ? NULL : lookup_field(ad->impl->fields,v);
}

$(tqual_t,type_t) * lookup_tuple_field(list_t<$(tqual_t,type_t)@`H> ts, int i) {
  for(; i != 0; --i) {
    if(ts == NULL)
      return NULL;
    ts = ts->tl;
  }
  if(ts == NULL)
    return NULL;
  return ts->hd;
}

datacon(Attribute,Stdcall_att);      
datacon(Attribute,Cdecl_att);        
datacon(Attribute,Fastcall_att);
datacon(Attribute,Noreturn_att);     
datacon(Attribute,Const_att);
datacon(Attribute,Packed_att);
datacon(Attribute,Nocommon_att);
datacon(Attribute,Shared_att);
datacon(Attribute,Unused_att);
datacon(Attribute,Weak_att);
datacon(Attribute,Dllimport_att);
datacon(Attribute,Dllexport_att);
datacon(Attribute,No_instrument_function_att);
datacon(Attribute,Constructor_att);
datacon(Attribute,Destructor_att);
datacon(Attribute,No_check_memory_usage_att);
datacon(Attribute,Pure_att);

string_t attribute2string(attribute_t a) {
  switch (a) {
  case &Regparm_att(i): return aprintf("regparm(%d)",i);
  case &Stdcall_att: return "stdcall";
  case &Cdecl_att: return "cdecl";
  case &Fastcall_att: return "fastcall";
  case &Noreturn_att: return "noreturn";
  case &Const_att: return "const";
  case &Aligned_att(i): 
    if (i == -1) return "aligned";
    else /* return aprintf("aligned(%d)",i);*/
      switch(c_compiler){
      case Gcc_c: return aprintf("aligned(%d)",i);
      case Vc_c:  return aprintf("align(%d)",i);
      }
  case &Packed_att: return "packed";
  case &Section_att(s): return aprintf("section(\"%s\")",s);
  case &Nocommon_att: return "nocommon";
  case &Shared_att: return "shared";
  case &Unused_att: return "unused";
  case &Weak_att: return "weak";
  case &Dllimport_att: return "dllimport";
  case &Dllexport_att: return "dllexport";
  case &No_instrument_function_att: return "no_instrument_function";
  case &Constructor_att: return "constructor";
  case &Destructor_att: return "destructor";
  case &No_check_memory_usage_att: return "no_check_memory_usage";
  case &Format_att(Printf_ft,n,m): return aprintf("format(printf,%u,%u)",n,m);
  case &Format_att(Scanf_ft,n,m):  return aprintf("format(scanf,%u,%u)", n,m);
  case &Initializes_att(n): return aprintf("initializes(%d)",n);
  case &Noliveunique_att(n): return aprintf("noliveunique(%d)",n);
  case &Noconsume_att(n): return aprintf("noconsume(%d)",n);
  case &Pure_att: return "pure";
  case &Mode_att(s): return aprintf("__mode__(\"%s\")",s); 
 }
}

// returns true when a is an attribute for function types
bool fntype_att(attribute_t a) {
  switch (a) {
  case &Regparm_att(i):    
  case &Fastcall_att:       
  case &Stdcall_att:        
  case &Cdecl_att:          
  case &Noreturn_att:       
  case &Pure_att:
  case &Format_att(...):
  case &Const_att:
  case &Noliveunique_att(_):
  case &Initializes_att(_):
  case &Noconsume_att(_): return true;
  default: return false;
  }
}

// cache strings used for field names f0,f1,f2,...
static string_t f0 = "f0";
static stringptr_t field_names_v[1] = {&f0};
static stringptr_t ?field_names = field_names_v;
stringptr_t fieldname(int i) {
  unsigned int fsz = numelts(field_names);
  if (i >= fsz)
    field_names = 
      new {for j < i+1 : 
	   (j < fsz) ? field_names[j] : new (string_t)aprintf("f%d",j)};
  return field_names[i];
}

$(aggr_kind_t,qvar_t) aggr_kinded_name(union AggrInfoU info) {
  switch(info) {
  case {.UnknownAggr = $(ak,n,_)}: return $(ak,n);
  case {.KnownAggr = &&Aggrdecl(k,_,n,_,_,_)}: return $(k,n);
  }
}
aggrdecl_t get_known_aggrdecl(union AggrInfoU info) {
  switch(info) {
  case {.UnknownAggr = _ }: Tcutil::impos("unchecked aggrdecl");
  case {.KnownAggr = &ad}: return ad;
  }
}
bool is_union_type(type_t t) {
  switch(Tcutil::compress(t)) {
  case &AnonAggrType(UnionA,_):     return true;
  case &AggrType(AggrInfo(info,_)): return aggr_kinded_name(info)[0]==UnionA;
  default: return false;
  }
}
bool is_nontagged_nonrequire_union_type(type_t t) {
  switch(Tcutil::compress(t)) {
  case &AnonAggrType(UnionA,fs):     
    if (fs == NULL) return true;
    return (fs->hd->requires_clause == NULL);
  case &AggrType(AggrInfo(info,_)): 
    switch (info) {
    case {.KnownAggr = &ad}: 
      if (ad->kind != UnionA) return false;
      let impl = ad->impl;
      if (impl->tagged) return false;
      let fields = impl->fields;
      if (fields == NULL) return true;
      return (fields->hd->requires_clause == NULL);
    case {.UnknownAggr = $(k,_,NULL)}: return k == UnionA;
    case {.UnknownAggr = $(k,_,&Opt(b))}: return k == UnionA && !b;
    }
  default: return false;
  }
}
bool is_require_union_type(type_t t) {
  switch(Tcutil::compress(t)) {
  case &AnonAggrType(UnionA,fs):     
    if (fs == NULL) return false;
    return (fs->hd->requires_clause != NULL);
  case &AggrType(AggrInfo(info,_)): 
    switch (info) {
    case {.KnownAggr = &ad}: 
      if (ad->kind != UnionA) return false;
      let impl = ad->impl;
      if (impl->tagged) return false;
      let fields = impl->fields;
      if (fields == NULL) return false;
      return (fields->hd->requires_clause != NULL);
    case {.UnknownAggr = $(k,_,NULL)}: return false;
    case {.UnknownAggr = $(k,_,&Opt(b))}: return false;
    }
  default: return false;
  }
}
bool is_aggr_type(type_t t) {
  switch(Tcutil::compress(t)) {
  case &DatatypeType(_):
  case &DatatypeFieldType(_):
  case &TupleType(_):
  case &AggrType(_):
  case &AnonAggrType(_,_): return true;
  default: return false;
  }
}

datacon(Raw_decl,Porton_d);
datacon(Raw_decl,Portoff_d);

  /*
  void print_decls(list_t<decl_t> decls) {
    Marshal::print_type(decls_rep,&decls);
    printf("\n");
  }
  */

bool porting_c_code = false;
bool no_regions = false;
  
}
/*
using Typerep;
typestruct_t decls_rep = __gen(list_t<Absyn::decl_t>);
*/
