/* Type environments.

   An identifier can have at most one binding in each of the following:

   1) namespaces (after "namespace" or "using")
   2) structure tags (after "struct")
   3) union tags (after "union")
   4) structure or union members (after "." or "->")
   5) enum tags (after "enum")
   6) xenum tags (after "xenum")
   7) labels (after "goto", before ":")
   8) typedef names (in types)
   9) ordinary identifiers (the catch-all case)

   The ordinary identifiers include structure tags and enum and xenum
   constructors.

   The environment data structures below follow from this directly.
   Note that labels can only appear inside of functions, so they don't
   appear in global environments.  And structure and union members
   must be resolved on a per-structure/per-union basis (e.g., two
   structs can have members with the same names) so their bindings
   don't belong in our environments.

   Also, we don't currently implement union.
*/

/* During type checking we keep two parallel environments.  One is
   accessed by absolute name, the other by local name.  We need these
   two environments because what is defined in a namespace is
   different from what is available in the namespace.  E.g.,

      extern int z;
      namespace Foo {
        int x;
        namespace Bar {
          int y = x;
        }
      }

   Here x is available in the inner namespace Bar but not defined
   there.  The absolute namespace will have entries for ::z, ::Foo::x,
   ::Foo::Bar, and ::Foo::Bar::y.  The relative namespace just after
   the definition of y will have entries for x, y, and z.
*/

#include "core.h"
#include "list.h"
#include "dict.h"
#include "set.h"
#include "dict.h"
#include "position.h"
#include "absyn.h"
#include "tcenv.h"
#include "tcutil.h"
#include "string.h"
#include "absynpp.h"

namespace Tcenv;

using Core;
using List;
using Set;
using Dict;
using Position;
using Absyn;
using Tcutil;

xenum exn {Env_error};

`a env_err<`a>(string msg) {
  fprintf(cyc_stdout,"Error: %s\n",msg);
  fflush(cyc_stdout);
  throw Env_error();
}

/////////////////////////// Type Definitions /////////////////////////////////

// Type environments 
struct Tenv {
  list<var>            ns; // current namespace
  Dict<list<var>,genv> ae; // absolute environment
  Opt_t<frames<fenv>>  le; // local environment == null, except in functions
};

// Global environments -- what's declared in a global scope 
struct Genv {
  Set<var>              namespaces;
  Dict<var,structdecl>  structdecls;
  Dict<var,enumdecl>    enumdecls;
  Dict<var,xenumdecl>   xenumdecls;
  Dict<var,typedefdecl> typedefs;
  Dict<var,resolved_t>  ordinaries;
  list<list<var>>       availables; // "using" namespaces
};

// Used to tell what an ordinary identifer refers to 
enum Resolved {
  VarRes(binding_t); // includes unresolved variant
  StructRes(structdecl);
  EnumRes(enumdecl,enumfield);
  XenumRes(xenumdecl,enumfield);
};

// Models the nesting of the RTCG constructs 
enum Frames<`a> {
  Outermost(`a);
  Frame(`a,enum Frames<`a>);
  Hidden(`a,enum Frames<`a>);
};

enum Unassigned {
  Always(Set<var>);  // unassigned after expression
  Boolean(Set<var>,Set<var>); // unassigned when true, when false
};

enum Jumpee { 
  NotAllowed_j;
  FnEnd_j;
  Stmt_j(stmt);
};

static struct CtrlEnv {
  jumpee_t continue_stmt;
  jumpee_t break_stmt;
  $(stmt, list<tvar>, list<typ>) * fallthru_stmt; // null => not allowed
  jumpee_t next_stmt; // needed to calculate break_stmt
  // The next_stmt field needs to be correct only when we might enter
  // a loop or switch. (i.e. when we call set_in_loop or set_in_switch)
};
typedef struct CtrlEnv @ ctrl_env_t;

// This part is shared throughout type-checking of a function.
// Hence mutations are seen by all subsequent type-checking, which is easier
// than threading labels which must be function-wide unique anyway.
static struct SharedFenv {
  typ                   return_typ;
  Dict<var,stmt>        seen_labels;
  Dict<var,list<stmt>>  needed_labels; // FIX: check empty when done!
};  

// Local function environments 
struct Fenv {
  struct SharedFenv @   shared;
  list<tvar>            type_vars; // type variables that can occur free
  Dict<var,binding_t>   locals;    // binding will be Param_b, Local_b, or Pat_b
  stmt                  encloser;  // nearest stmt with a binder or a try
  ctrl_env_t            ctrl_env;
};

//////////////////////// Top-level Environment Manipulation //////////////////

tenv tc_init() {
  // Initialize globals
  empty_var_set    = &Opt(Set::empty(String::zstrcmp));

  // Set up initial environment so that xenum exn is defined
  string exn_v  = "exn";
  let    xed    = &Xenumdecl{.sc=Extern, .name=&$(null,exn_v), .fields=null};
  let    ge     = empty_genv();
  let    top_ns = null;
  ge->xenumdecls = Dict::insert(ge->xenumdecls, exn_v, xed);
  let ae = Dict::insert(Dict::empty(varlist_cmp), top_ns, ge);
  return &Tenv(top_ns,ae,null);
}


// lookup functions 
static list<var> outer_namespace(list<var> ns) {
  if (ns == null) 
    return env_err("Tcenv::outer_namespace");
  return List::rev(List::rev(ns)->tl);
}

// FIX: never actually returns null
static $(list<var>,`a) * scoped_lookup<`a>(tenv te, segment loc, 
					   `a lookup(genv,var), var v) {
  list<var> cns = te->ns; // current namespace
  int num_results = 0;
  $(list<var>,`a) * result = null; // def assignment too dumb
  while (true) {
    genv ge = Dict::lookup(te->ae,cns);
    // Check available namespaces
    for (let nss = ge->availables; nss != null; nss = nss->tl) {
      genv ge2 = Dict::lookup(te->ae,nss->hd);
      try {
	result = &$(nss->hd,lookup(ge2,v));
	++num_results;
      } catch { case Dict::Absent: break; /* ignore */}
    }
    // Check current namespace
    try {
      result = &$(cns,lookup(ge,v));
      ++num_results;
    } catch { case Dict::Absent: break; /* ignore */ }

    if(num_results > 1) 
      Tcutil::terr(loc,xprintf("%s is ambiguous-",v));
    if(num_results > 0)
      return result;

    if (cns == null) 
      throw Dict::Absent();
    // v is not defined in current namespace, look in next outer
    cns = outer_namespace(cns);
  }
}

static resolved_t lookup_ordinary_global_f(genv ge,var v) {
  return Dict::lookup(ge->ordinaries,v);
}
static resolved_t lookup_ordinary_global(tenv te,segment loc,qvar q) {
  let &$(nsl,v) = q;
  try {
    if (nsl == null)
      return scoped_lookup(te, loc, lookup_ordinary_global_f, v)[1];
    genv ge = lookup_namespace(te,loc,nsl);
    return Dict::lookup(ge->ordinaries,v);
  } catch { case Dict::Absent: return VarRes(Unresolved_b); }
}

// Lookup a namespace relative to the current namespace
genv lookup_namespace(tenv te, segment loc, list<var> ns) {
  return Dict::lookup(te->ae, resolve_namespace(te,loc,ns));
}

list<var> resolve_namespace(tenv te, segment loc, list<var> ns) {
  if (ns == null)
    // null means the current namespace
    return te->ns;
  list<var> cns = te->ns; // current namespace
  list<list<var>> result = null;
  while (true) {
    genv ge = Dict::lookup(te->ae,cns);
    // Check namespaces that have been made available
    for (let nss = ge->availables; nss != null; nss = nss->tl) {
      genv ge2 = Dict::lookup(te->ae,nss->hd);
      if (Set::member(ge2->namespaces, ns->hd))
        result = &cons(List::append(cns,ns),result);
    }
    // Check current namespace
    if (Set::member(ge->namespaces, ns->hd))
      result = &cons(List::append(cns,ns),result);
    if (result != null) {
      if (result->tl != null)
        Tcutil::terr(loc,xprintf("%s is ambiguous_",ns->hd));
      return result->hd;
    }
    if (cns == null)
      throw Dict::Absent();
    // ns->hd is not defined in current namespace, look in next outer
    cns = outer_namespace(cns);
  }
}

static structdecl lookup_structdecl_f(genv ge,var v) {
  return Dict::lookup(ge->structdecls,v);
}
structdecl lookup_structdecl(tenv te,segment loc,qvar q) {
  let &$(nsl,v) = q;
  if (nsl == null)
    return scoped_lookup(te, loc, lookup_structdecl_f, v)[1];
  genv ge = lookup_namespace(te,loc,nsl);
  return Dict::lookup(ge->structdecls,v);
}

static enumdecl lookup_enumdecl_f(genv ge,var v) {
  return Dict::lookup(ge->enumdecls,v);
}
enumdecl lookup_enumdecl(tenv te,segment loc,qvar q) {
  let &$(nsl,v) = q;
  if (nsl == null)
    return scoped_lookup(te, loc, lookup_enumdecl_f, v)[1];
  genv ge = lookup_namespace(te,loc,nsl);
  return Dict::lookup(ge->enumdecls,v);
}

static xenumdecl lookup_xenumdecl_f(genv ge,var v) {
  return Dict::lookup(ge->xenumdecls,v);
}

// DAN: some functionality from tcXenumdecl has moved to here.
Opt_t<xenumdecl> lookup_xenumdecl(tenv te,segment loc,qvar q) {
  let &$(nsl,v) = q;
  if (nsl == null)
    // unqualified name, okay to fail -- that just means we have a new xenum
    try return &Opt(scoped_lookup(te, loc, lookup_xenumdecl_f, v)[1]);
    catch { case Dict::Absent: return null; }
  // qualified name, it's an error if the namespace is bad or the
  // xenum doesn't already exist.  In either case, we'll raise
  // Dict::Absent, so we give a more descriptive message for the
  // former.
  genv ge;
  try ge = lookup_namespace(te,loc,nsl);
  catch { 
  case Dict::Absent: 
    Tcutil::terr(loc,"bad qualified name for xenum"); 
    throw Dict::Absent();
  }
  return &Opt(Dict::lookup(ge->xenumdecls,v));
}


static typedefdecl lookup_typedefdecl_f(genv ge,var v) {
  return Dict::lookup(ge->typedefs,v);
}
typedefdecl lookup_typedefdecl(tenv te, segment loc, qvar q) {
  let &$(nsl,v) = q;
  if (nsl == null) 
    return scoped_lookup(te, loc, lookup_typedefdecl_f, v)[1];
  genv ge = lookup_namespace(te,loc,nsl);
  return Dict::lookup(ge->typedefs,v);
}

genv empty_genv() { 
  return &Genv{.namespaces  = empty_var_set->v,
               .structdecls = Dict::empty(String::zstrcmp),
               .enumdecls   = Dict::empty(String::zstrcmp),
               .xenumdecls  = Dict::empty(String::zstrcmp),
               .typedefs    = Dict::empty(String::zstrcmp),
               .ordinaries  = Dict::empty(String::zstrcmp),
               .availables  = null};
}

////////////////////////////// Frames Manipulation //////////////////////////

`a get_visible<`a>(frames<`a> f) {
  while(true)
    switch (f) {
    case Outermost(x): return x;
    case Frame(x,_):   return x;
    case Hidden(x,y):  f = y; break;
    }
}

frames<`a> put_visible<`a>(frames<`a> f, `a x) {
  switch (f) {
  case Outermost(x2): return Outermost(x);
  case Frame(x2,f2):  return Frame(x,f2);
  case Hidden(x2,f2): return Hidden(x2,put_visible(f2,x));
  }
}

frames<`a> apply_to_visible<`a>(`a g(`a), frames<`a> f) {
  return put_visible(f,g(get_visible(f)));
}

frames<`b> map_frames<`a,`b>(`b g(`a), frames<`a> f) {
  switch (f) {
  case Outermost(x): return Outermost(g(x));
  case Frame(x,f2):  return Frame(g(x),map_frames(g,f2));
  case Hidden(x,f2): return Hidden(g(x),map_frames(g,f2));
  }
}

fenv get_fenv(tenv te) {
  if (te->le == null) throw Env_error();
  return get_visible(te->le->v);
}

tenv put_fenv(tenv te, fenv fe) {
  if (te->le == null) throw Env_error();
  return &Tenv(te->ns, te->ae, &Opt(put_visible(te->le->v,fe)));
}

//////////////////// Function Environment Manipulation //////////////////////

typ return_typ(tenv te) {
  if (te->le == null) env_err("Tcenv: unexpected return_typ");
  return get_fenv(te)->shared->return_typ;
}

list<tvar> lookup_type_vars(tenv te) {
  if (te->le == null) return null;
  return get_fenv(te)->type_vars;
}

// FIX: common fast case for tvs == null
tenv add_type_vars(segment loc,tenv te,list<tvar> tvs) {
  list<tvar> new_tvs = List::append(tvs,lookup_type_vars(te));
  Tcutil::check_unique_tvars(loc,new_tvs);
  let fe  = get_fenv(te);
  let fe2 = &Fenv(fe->shared,
		  new_tvs,
		  fe->locals, fe->encloser, fe->ctrl_env);
  return put_fenv(te,fe2);
}

// FIX: This can cause clashes with other programmer variables!!!!
static int shadow_ctr = 1;

tenv add_local_var(segment loc, tenv te, vardecl vd) {
  if(te->le == null) env_err("Tcenv: unexpected add_local_var");
  let fe = get_fenv(te);
  let v  = vd->name[1];
  if(Dict::member(fe->locals,v))
    vd->shadow = ++shadow_ctr;
  let fe2 = &Fenv(fe->shared, fe->type_vars,
		  Dict::insert(fe->locals,v,Local_b(vd)),
		  fe->encloser, fe->ctrl_env);
  return put_fenv(te,fe2);
}

// assume uniqueness has been checked elsewhere
tenv add_pat_var(segment loc, tenv te, vardecl vd) {
  if(te->le == null) env_err("Tcenv: unexpected add_param_var");
  let fe = get_fenv(te);
  let v  = vd->name[1];
  if(Dict::member(fe->locals,v))
    vd->shadow = ++shadow_ctr;
  fenv fe2 = &Fenv(fe->shared, fe->type_vars,
		   Dict::insert(fe->locals,v,Pat_b(vd)),
                   fe->encloser, fe->ctrl_env);
  return put_fenv(te,fe2);
}

resolved_t lookup_ordinary(tenv te,segment loc,qvar q) {
  let &$(nsl,v) = q;
  if (nsl != null || te->le == null)
    return lookup_ordinary_global(te,loc,q);
  let fe = get_fenv(te);
  try return VarRes(Dict::lookup(fe->locals,v));
  catch {case Dict::Absent: return lookup_ordinary_global(te,loc,q);}
}

bool process_continue(tenv te, stmt s) {
  if (te->le == null) env_err("Tcenv: unexpected process_continue");
  let fe = get_fenv(te);
  switch (fe->ctrl_env->continue_stmt) {
  case NotAllowed_j: return false;
  case FnEnd_j:      return true; // impossible in source language actually
  case Stmt_j(s2):
    s2->non_local_preds = &cons(s,s2->non_local_preds);
    switch (s->r) {
    case Continue_s(*so): *so = &Opt(s2); return true;
    default: 
      return env_err("Tcenv: process_continue given a non-continue");
    }
  }
}
bool process_break(tenv te, stmt s) {
  if (te->le == null) env_err("Tcenv: unexpected process_break");
  fenv fe = get_fenv(te);
  switch (fe->ctrl_env->break_stmt) {
  case NotAllowed_j: return false;
  case FnEnd_j:      return true; 
  case Stmt_j(s2):
    s2->non_local_preds = &cons(s,s2->non_local_preds);
    switch (s->r) {
    case Break_s(*so): *so = &Opt(s2); return true;
    default: return env_err("Tcenv: process_continue given a non-break");
    }
  }
}
void process_goto(tenv te, stmt s) {
  if (te->le == null) env_err("Tcenv: unexpected process_goto");
  switch (s->r) {
  case Goto_s(l,*so): 
    fenv fe = get_fenv(te);
    let needed = fe->shared->needed_labels;
    let sopt   = Dict::lookup_opt(fe->shared->seen_labels, l);
    if(sopt == null) {
      let slopt = Dict::lookup_opt(needed, l);
      if(slopt == null)
	slopt = &Opt(null);
      fe->shared->needed_labels = Dict::insert(needed, l, &cons(s,slopt->v));
    } else {
      *so = sopt;
      sopt->v->non_local_preds = &cons(s, sopt->v->non_local_preds);
    }
    break;
  default: env_err("Tcenv: process_continue given a non-goto"); break;
  }
}
$(stmt,list<tvar>,list<typ>)* process_fallthru(tenv te, stmt s) {
  if (te->le == null) env_err("Tcenv: unexpected process_fallthru");
  switch (s->r) {
  case Fallthru_s(es,*so):
    fenv fe = get_fenv(te);
    let ans = fe->ctrl_env->fallthru_stmt;
    if(ans != null) {
      ans[0]->non_local_preds = &cons(s, ans[0]->non_local_preds);
      *so = &Opt(ans[0]);
    }
    return ans;
  default: return env_err("Tcenv: process_fallthru given a non-fallthru");
  }
}
tenv set_fallthru(tenv te, $(list<tvar>,list<vardecl>) * pat_typ, stmt body) {
  if(te->le == null) env_err("Tcenv: unexpected set_fallthru");
  let ft_typ = null;
  for(let vds = pat_typ[1]; vds!=null; vds=vds->tl)
    ft_typ = &cons(vds->hd->type,ft_typ);
  ft_typ = List::imp_rev(ft_typ);
  let fe  = get_fenv(te);
  let c   = fe->ctrl_env;
  let fe2 = &Fenv(fe->shared, fe->type_vars, fe->locals, fe->encloser,
		  &CtrlEnv(c->continue_stmt, c->break_stmt,
			   &$(body,pat_typ[0],ft_typ),
			   c->next_stmt));
  return put_fenv(te,fe2);
}

// fallthru is illegal in the last case
tenv clear_fallthru(tenv te) {
  if(te->le == null) env_err("Tcenv: unexpected clear_fallthru");
  let fe  = get_fenv(te);
  let c   = fe->ctrl_env;
  let fe2 = &Fenv(fe->shared, fe->type_vars, fe->locals, fe->encloser,
		  &CtrlEnv(c->continue_stmt, c->break_stmt,
			   null,
			   c->next_stmt));
  return put_fenv(te,fe2);
}

tenv set_in_loop(tenv te, stmt continue_dest) {
  if (te->le == null) env_err("Tcenv: unexpected set_in_loop");
  let fe  = get_fenv(te);
  let fe2 = &Fenv(fe->shared, fe->type_vars, fe->locals, fe->encloser,
		  &CtrlEnv(Stmt_j(continue_dest),
			   fe->ctrl_env->next_stmt, // break goes to next
			   fe->ctrl_env->fallthru_stmt,
			   Stmt_j(continue_dest))); // next starts same as cont
  return put_fenv(te,fe2);
}

// each non-last case must also call set_fallthru, here we just 
// change the break destination
tenv set_in_switch(tenv te) {
  if (te->le == null) env_err("Tcenv: unexpected set_in_switch");
  let fe  = get_fenv(te);
  let fe2 = &Fenv(fe->shared, fe->type_vars, fe->locals, fe->encloser,
		  &CtrlEnv(fe->ctrl_env->continue_stmt,
			   fe->ctrl_env->next_stmt, // break goes to next
			   fe->ctrl_env->fallthru_stmt,
			   fe->ctrl_env->next_stmt));
  return put_fenv(te,fe2);
}

tenv set_next(tenv te, jumpee_t j) {
  let fe  = get_fenv(te);
  let fe2 = &Fenv(fe->shared, fe->type_vars, fe->locals, fe->encloser,
		  &CtrlEnv(fe->ctrl_env->continue_stmt,
			   fe->ctrl_env->break_stmt, 
			   fe->ctrl_env->fallthru_stmt,
			   j));
  return put_fenv(te,fe2);
}

tenv add_label(tenv te, var v, stmt s) {
  if (te->le == null) env_err("Tcenv: unexpected add_label");
  let fe     = get_fenv(te);
  let needed = fe->shared->needed_labels;
  let sl_opt = Dict::lookup_opt(needed, v);
  if(sl_opt != null) {
    fe->shared->needed_labels = Dict::delete(needed, v);
    // backpatching
    let sl = sl_opt->v;
    s->non_local_preds = sl; 
    for(; sl != null; sl = sl->tl)
      switch (sl->hd->r) {
      case Goto_s(_,*so): *so = &Opt(s); break;
      default: env_err("Tcenv: add_label backpatching of non-goto"); break;
      }
  }
  if(Dict::member(fe->shared->seen_labels, v))
    Tcutil::terr(s->loc, xprintf("Repeated label: %s", v));
  fe->shared->seen_labels = Dict::insert(fe->shared->seen_labels, v, s);
  return te;
}

bool all_labels_resolved(tenv te) {
  return Dict::is_empty(get_fenv(te)->shared->needed_labels);
}

stmt get_encloser(tenv te) {
  if (te->le == null) env_err("Tcenv: unexpected get_encloser");
  let fe = get_fenv(te);
  return fe->encloser;
}

tenv set_encloser(tenv te, stmt s) {
  if (te->le == null) env_err("Tcenv: unexpected set_encloser");
  let fe  = get_fenv(te);
  let fe2 = &Fenv(fe->shared, fe->type_vars, fe->locals, 
		  s,
		  fe->ctrl_env);
  return put_fenv(te,fe2);
}

fenv new_fenv(fndecl fd) {
  let locals = Dict::empty(String::zstrcmp);
  for(let args = fd->args; args != null; args = args->tl)
    locals = Dict::insert(locals, args->hd[0], Param_b(args->hd));
  return &Fenv{.shared        = &SharedFenv(fd->ret_type,
					    Dict::empty(String::zstrcmp),
					    Dict::empty(String::zstrcmp)),
 	       .type_vars     = fd->tvs, // assumed unique
	       .locals        = locals,  // assumed unique
	       .encloser      = fd->body, // careful -- self loop at top!!!
	       .ctrl_env      = &CtrlEnv(NotAllowed_j,
					 NotAllowed_j,
					 null,
					 FnEnd_j)};
}

///////////////////////////// Synthesis (CHANGING SOON) //////////////////////

struct Synth { typ type; };

typ synth_typ(synth s) {
  return s->type;
}

synth synth_set_typ(synth s, typ t) {
  s->type = t;
  return s;
}

tenv layer_synth(tenv te, synth syn) { return te; }

$(tenv,tenv) bool_layer_synth(tenv te, synth syn) { return $(te,te); }

synth standard_synth(tenv te, typ t) { return &Synth(t); }

// useful for error expressions
synth wild_synth(tenv te) {
  return standard_synth(te,wildtyp());
}

// synth we get for more statements -- standard_synth with void type
synth skip_synth(tenv te) { return standard_synth(te, VoidType); }

// synth we get upon return or continue
synth empty_synth(tenv te) { return wild_synth(te); }

// synth we get upon a break, goto, or throw 
synth forward_jump_synth(tenv te) { return wild_synth(te); }

// synth we get for sequencing.  
synth seq_synth(synth s1, synth s2) { return &Synth(s2->type); }

// synth we get upon join of two if statements or switch cases etc.
synth join_synth(synth s1, synth s2) { return &Synth(s1->type); }

synth switch_bottom(synth s) { return &Synth(s->type); }

synth loop_synth(synth e, synth s) { return &Synth(VoidType); }

// an explicit fallthru -- similar to forward jump
synth fallthru_synth(tenv te) { return &Synth(VoidType); }

// add the set v to both edges of the synth
synth add_var_synth(Set<var> v, synth s) { return &Synth(s->type); }

// remove v from the fallthru edge of the synth
synth initialize_var_synth(synth s, var v) { return &Synth(s->type); }
