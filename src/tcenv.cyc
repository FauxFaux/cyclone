/* Type environments.
   Copyright (C) 2001 Greg Morrisett, AT&T
   This file is part of the Cyclone compiler.

   The Cyclone compiler is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   The Cyclone compiler is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with the Cyclone compiler; see the file COPYING. If not,
   write to the Free Software Foundation, Inc., 59 Temple Place -
   Suite 330, Boston, MA 02111-1307, USA. */

/* An identifier can have at most one binding in each of the following:
   1) namespaces (after "namespace" or "using")
   2) structure tags (after "struct")
   3) union tags (after "union")
   4) structure or union members (after "." or "->")
   5) datatype tags (after "datatype")
   7) labels (after "goto", before ":")
   8) typedef names (in types)
   9) ordinary identifiers (the catch-all case)

   The ordinary identifiers include structure tags and datatype constructors.

   The environment data structures below follow from this directly.
   Structure and union members must be resolved on a
   per-structure/per-union basis (e.g., two structs can have members
   with the same names) so their bindings don't belong in our environments.
*/
#include <string.h>
#include "rgnorder.h"
#include "tcutil.h"
#include "warn.h"
#include "kinds.h"
#include "tcenv.h"
#include "currgn.h"
using Core;
using List;
using Absyn;
using Tcutil;
using RgnOrder;
namespace Tcenv;

datatype exn {Env_error};
datacon(exn,Env_error);

`a env_err(string_t msg) __attribute__((noreturn)) {
  throw &Env_error_val;
}

/////////////////////////// Type Definitions /////////////////////////////////

// Type environments
struct Tenv {
  list_t<var_t>  ns; // current namespace
  genv_t         ae; // absolute identifiers -- now 5 big dicts
  struct Fenv *  le; // local environment
  bool allow_valueof : 1;     // controls whether we allow valueof(T) in an expr
  bool in_extern_c_include : 1;
  bool in_tempest : 1;
  bool tempest_generalize : 1;
  bool in_extern_c_inc_repeat : 1;
};

// Global environments -- what's declared in a global scope
struct Genv {
  Dict::dict_t<qvar_t,aggrdecl_t@> aggrdecls;
  Dict::dict_t<qvar_t,datatypedecl_t@> datatypedecls;
  Dict::dict_t<qvar_t,enumdecl_t@>   enumdecls;
  // no indirection b/c no redeclaration
  Dict::dict_t<qvar_t,typedefdecl_t> typedefs;
  // bool for tree-shaking, binding_t for interface.cyc (FIX)
  Dict::dict_t<qvar_t,$(binding_t,bool)@> ordinaries;
};

typedef $(switch_clause_t, list_t<tvar_t>, list_t<type_t>) const * ftclause_t;

// This part is shared throughout type-checking of a function.
// Hence mutations are seen by all subsequent type-checking, which is easier
// than threading labels which must be function-wide unique anyway.
static struct SharedFenv {
  type_t   return_typ;
  list_t<$(type_t,type_t,rgn_po_t,seg_t)@> delayed_effect_checks;
  list_t<$(rgn_po_t,list_t<$(type_t,type_t)@>,seg_t)@> delayed_constraint_checks;
};

// flags for local function environments
struct FenvFlags {
  enum NewStatus in_new;
  bool in_notreadctxt : 1; // true when in an exp that might read
  bool in_lhs : 1;         // true when we're in a lhs exp
  bool abstract_ok : 1;    // true when an expression can be abstract
  bool in_stmt_exp : 1;    // true when in a statement-expression ({ s })
};

// Local function environments -- local variables are already bound
abstract struct Fenv {
  struct SharedFenv @ shared;
  list_t<tvar_t>      type_vars; //type variables that can occur free
  rgn_po_t            region_order; // partial order on region variables
  ftclause_t          ctrl_env;
  type_t              capability;
  type_t              curr_rgn;   // current block's region
  type_t              curr_lifo_rgn; // top of LIFO region stack
  type_t              curr_pool_rgn; // top of autorelease pool stack
  struct FenvFlags    flags;
};

//////////////////////// Top-level Environment Manipulation //////////////////
tenv_t tc_init() {
  // Set up initial environment so that datatype exn, etc. is defined
  let ae = new Genv{.aggrdecls     = Dict::empty(qvar_cmp),
		    .datatypedecls = Dict::empty(qvar_cmp),
		    .enumdecls     = Dict::empty(qvar_cmp),
		    .typedefs      = Dict::empty(qvar_cmp),
		    .ordinaries    = Dict::empty(qvar_cmp)};
  ae->datatypedecls = Dict::insert(ae->datatypedecls, exn_name, new exn_tud());
  return new Tenv(NULL,ae,NULL,false,false,false,false,false);
}
binding_t lookup_ordinary_global(tenv_t te,seg_t loc,qvar_t q,bool is_use) {
  let ans = Dict::lookup(te->ae->ordinaries, q);
  if(is_use)
    (*ans)[1] = true;
  return (*ans)[0];
}
aggrdecl_t @ lookup_aggrdecl(tenv_t te,seg_t loc,qvar_t q) {
  return Dict::lookup(te->ae->aggrdecls, q);
}
datatypedecl_t @ lookup_datatypedecl(tenv_t te,seg_t loc,qvar_t q) {
  return Dict::lookup(te->ae->datatypedecls, q);
}
datatypedecl_t@*`r lookup_xdatatypedecl(region_t<`r> r, tenv_t te,seg_t loc,qvar_t q) {
  return rnew(r) Dict::lookup(te->ae->datatypedecls, q);
}
enumdecl_t @lookup_enumdecl(tenv_t te, seg_t loc, qvar_t q) {
  return Dict::lookup(te->ae->enumdecls, q);
}
typedefdecl_t lookup_typedefdecl(tenv_t te, seg_t loc, qvar_t q) {
  return Dict::lookup(te->ae->typedefs, q);
}

//////////////////// Function Environment Manipulation //////////////////////

static fenv_t get_fenv(tenv_t te, const char ?err_msg) {
  let le = te->le;
  if (le == NULL) env_err(err_msg);
  return le;
}
static tenv_t put_fenv(tenv_t te, fenv_t fe) {
  if (te->le == NULL) env_err("put_fenv"); // DJG: unnecessary but okay
  let ans = new *te;
  ans->le = fe;
  return ans;
}
static tenv_t put_emptyfenv(tenv_t te) {
  let ans = new *te;
  ans->le = NULL;
  return ans;
}

type_t return_typ(tenv_t te) {
  return get_fenv(te,"return_typ")->shared->return_typ;
}

list_t<tvar_t> lookup_type_vars(tenv_t te) {
  let le = te->le;
  if(te->le == NULL) return NULL;
  return le->type_vars;
}
opt_t<list_t<tvar_t>> lookup_opt_type_vars(tenv_t te) {
  return new Opt(lookup_type_vars(te));
}

tenv_t add_type_vars(seg_t loc,tenv_t te, list_t<tvar_t> tvs) {
  let fe = new *get_fenv(te,"add_type_vars");
  add_tvar_identities(tvs);
  let new_tvs = append(tvs,fe->type_vars);
  check_unique_tvars(loc,new_tvs); // DJG: wasteful, old were unique
  fe->type_vars = new_tvs;
  return put_fenv(te,fe);
}

tenv_t set_new_status(enum NewStatus status, tenv_t te){
  let le = te->le;
  if(le == NULL) return put_emptyfenv(te);
  let ans = new *le;
  ans->flags.in_new = status;
  return put_fenv(te,ans);
}
enum NewStatus new_status(tenv_t te) {
  let le = te->le;
  if (le == NULL) return NoneNew;
  return le->flags.in_new;
}
bool abstract_val_ok(tenv_t te) {
  let le = te->le;
  if (le == NULL) return false;
  return le->flags.abstract_ok;
}
tenv_t enter_abstract_val_ok(tenv_t te){
  let le = te->le;
  if(le == NULL) return put_emptyfenv(te);
  let ans = new *le;
  ans->flags.abstract_ok = true;
  return put_fenv(te,ans);
}
tenv_t clear_abstract_val_ok(tenv_t te) {
  let le = te->le;
  if(le == NULL) return put_emptyfenv(te);
  let ans = new *le;
  ans->flags.abstract_ok = false;
  return put_fenv(te,ans);
}
tenv_t enter_notreadctxt(tenv_t te){
  let le = te->le;
  if(le == NULL) return put_emptyfenv(te);
  let ans = new *le;
  ans->flags.in_notreadctxt = true;
  return put_fenv(te,ans);
}
tenv_t clear_notreadctxt(tenv_t te) {
  let le = te->le;
  if(le == NULL) return put_emptyfenv(te);
  let ans = new *le;
  ans->flags.in_notreadctxt = false;
  return put_fenv(te,ans);
}
bool in_notreadctxt(tenv_t te) {
  let le = te->le;
  if (le == NULL) return false;
  return le->flags.in_notreadctxt;
}
tenv_t enter_lhs(tenv_t te){
  let le = te->le;
  if(le == NULL) return put_emptyfenv(te);
  let ans = new *le;
  ans->flags.in_lhs = true;
  return put_fenv(te,ans);
}
tenv_t clear_lhs(tenv_t te) {
  let le = te->le;
  if(le == NULL) return put_emptyfenv(te);
  let ans = new *le;
  ans->flags.in_lhs = false;
  return put_fenv(te,ans);
}
bool in_lhs(tenv_t te) {
  let le = te->le;
  if (le == NULL) return false;
  return le->flags.in_lhs;
}
tenv_t enter_stmt_exp(tenv_t te) {
  let le = te->le;
  if(le == NULL) return put_emptyfenv(te);
  let ans = new *le;
  ans->flags.in_stmt_exp = true;
  return put_fenv(te,ans);
}
bool in_stmt_exp(tenv_t te) {
  let le = te->le;
  if (le == NULL) return false;
  return le->flags.in_stmt_exp;
}

// do not stop setting clauseopt -- JumpAnalysis needs it!
$(switch_clause_t,list_t<tvar_t>,list_t<type_t>)const* const
process_fallthru(tenv_t te,stmt_t s, switch_clause_t *@ clauseopt){
  let ans = get_fenv(te,"process_fallthru")->ctrl_env;
  if(ans != NULL)
    *clauseopt = new (*ans)[0];
  return ans;
}

tenv_t set_fallthru(tenv_t te, list_t<tvar_t,`H> new_tvs, list_t<vardecl_t> vds,
		    switch_clause_t clause) {
  list_t<type_t> ft_typ = NULL;
  for(; vds!=NULL; vds=vds->tl)
    ft_typ = new List(vds->hd->type,ft_typ);
  let new_ctrl_env = new $(clause,new_tvs,imp_rev(ft_typ));
  let new_fe = new *get_fenv(te,"set_fallthru");
  new_fe->ctrl_env = new_ctrl_env;
  return put_fenv(te,new_fe);
}
// fallthru is illegal in the last case
tenv_t clear_fallthru(tenv_t te) {
  fenv_t fe = new *get_fenv(te,"clear_fallthru");
  fe->ctrl_env = NULL;
  return put_fenv(te,fe);
}

tenv_t allow_valueof(tenv_t te) {
  let fe = (te->le==NULL) ? NULL : new *te->le;
  let ans = new *te;
  ans->allow_valueof = true;
  return ans;
}
tenv_t enter_extern_c_include(tenv_t te) {
  let fe = (te->le==NULL) ? NULL : new *te->le;
  let ans = new *te;
  ans->in_extern_c_include = true;
  return ans;
}  
tenv_t enter_tempest(tenv_t te) {
  let fe = (te->le==NULL) ? NULL : new *te->le;
  let ans = new *te;
  ans->in_tempest = true;
  return ans;
}
tenv_t clear_tempest(tenv_t te) {
  let fe = (te->le==NULL) ? NULL : new *te->le;
  let ans = new *te;
  ans->in_tempest = false;
  return ans;
}
bool in_tempest(tenv_t te) {
  return te->in_tempest;
}
tenv_t add_region(tenv_t te, type_t rgn, bool opened, bool lifo) {
  let ans = new *get_fenv(te,"add_region");
  let region_order = ans->region_order;
  switch (compress(rgn)) {
  case &VarType(x): region_order = add_youngest(region_order, x, opened); break;
  default: break;
  }
  ans->region_order = region_order;
  ans->capability   = join_eff(new List(access_eff(rgn),
					new List(ans->capability,NULL)));
  // FIX: add || opened to support dynamic regions
  if (lifo) ans->curr_lifo_rgn = rgn;
  return put_fenv(te,ans);
}
tenv_t add_pool(tenv_t te, type_t poolrgn) {
  // AUTOFIX: how to do outlives here?  Should pools outlive regular
  // regions, and vice versa?
  let ans = new *get_fenv(te,"add_pool");
  ans->capability   = join_eff(new List(access_eff(poolrgn),
					new List(ans->capability,NULL)));
  ans->curr_pool_rgn = poolrgn;
  return put_fenv(te,ans);  
}

tenv_t new_named_block(seg_t loc, tenv_t te, tvar_t block_rgn) {
  let ans = new *get_fenv(te,"new_named_block");
  let block_typ = new VarType(block_rgn);
  ans->type_vars = new List(block_rgn, ans->type_vars);
  check_unique_tvars(loc, ans->type_vars); // DJG: FIX -- very wasteful
  ans->region_order = add_youngest(ans->region_order, block_rgn, false);
  ans->capability = join_eff(new List(access_eff(block_typ), 
					 new List(ans->capability,NULL)));
  ans->curr_rgn = block_typ;
  return put_fenv(te,ans);
}

static datatype KindBound.Eq_kb rgn_kb = Eq_kb(&Kinds::rk);

tenv_t new_block(seg_t loc, tenv_t te) {
  tvar_t t = new_tvar(&rgn_kb);
  add_tvar_identity(t);
  return new_named_block(loc, te, t);
}

tenv_t new_outlives_constraints(tenv_t te, list_t<$(type_t,type_t)@> cs,
				seg_t loc) {
  let ans = new *get_fenv(te,"new_outlives_constraints");
  for(; cs != NULL; cs = cs->tl)
    ans->region_order =
      add_outlives_constraint(ans->region_order,(*cs->hd)[0],(*cs->hd)[1], loc);
  return put_fenv(te,ans);
}

tenv_t add_region_equality(tenv_t te, type_t r1, type_t r2,
			   $(tvar_t,kindbound_t) * @oldtv,
			   seg_t loc) {
  // we add outlives constraints and refine the kind of the type variable
  r1 = compress(r1);
  r2 = compress(r2);
  let r1k = type_kind(r1);
  let r2k = type_kind(r2);

  // first do kind refinement
  bool r1_le_r2 = Kinds::kind_leq(r1k,r2k);
  bool r2_le_r1 = Kinds::kind_leq(r2k,r1k);
  if (!r1_le_r2 && !r2_le_r1) {
    Warn::err2(loc,"Cannot compare region handles for ",r1," and ",r2,
	       "\n  kinds ",r1k," and ",r2k," are not compatible");
    return new_outlives_constraints(te,NULL,loc);
  }
  else if (r1_le_r2 && !r2_le_r1)
    *oldtv = new Kinds::swap_kind(r2,Kinds::kind_to_bound(r1k));
  else if (!r1_le_r2 && r2_le_r1)
    *oldtv = new Kinds::swap_kind(r1,Kinds::kind_to_bound(r2k));

  // now update the outlives constraints
  let bds = NULL;
  if (r1 != heap_rgn_type && r1 != unique_rgn_type && r1 != refcnt_rgn_type)
    bds = new List(new $(access_eff(r1),r2),bds);
  if (r2 != heap_rgn_type && r2 != unique_rgn_type && r2 != refcnt_rgn_type)
    bds = new List(new $(access_eff(r2),r1),bds);
  return new_outlives_constraints(te,bds,loc);
}

type_t curr_rgn(tenv_t te) {
  let le = te->le;
  if (le == NULL) return heap_rgn_type;
  return le->curr_rgn;
}
type_t curr_lifo_rgn(tenv_t te) {
  let le = te->le;
  if (le == NULL) return heap_rgn_type;
  return le->curr_lifo_rgn;
}
type_t curr_pool_rgn(tenv_t te) {
  let le = te->le;
  if (le == NULL) return heap_rgn_type;
  return le->curr_pool_rgn;
}
rgn_po_opt_t curr_rgnpo(tenv_t te) {
  let le = te->le;
  if(le == NULL) return NULL;
  return le->region_order;
}

// Check that rgn_typ is currently accessible:  the heap region is always
// accessible, and a region variable r is accessible if it appears in the
// capability or outlives something in the capability.
void check_rgn_accessible(tenv_t te, seg_t loc, type_t rgn) {
  fenv_t fe = get_fenv(te,"check_rgn_accessible");
  if (region_in_effect(false, rgn, fe->capability) ||
      region_in_effect(true, rgn, fe->capability))
    return;
  if(eff_outlives_eff(fe->region_order,access_eff(rgn),fe->capability))
    return;
  Warn::err2(loc, "Expression accesses unavailable region ", rgn);
}

// check that region rt_a outlives region rt_b using the partial order in
// the environment.  Assumes that rt_a <> rt_b.
// Note: inefficient allocation here!
bool region_outlives(tenv_t te, type_t rt_a, type_t rt_b) {
  return rgn_outlives_rgn(curr_rgnpo(te),rt_a,rt_b);
}

// Check that a function call's effect is contained in the current capability.
// Do not constrain evars -- delay the check instead.
void check_effect_accessible(tenv_t te, seg_t loc, type_t eff) {
  let &Fenv{.capability = capability, .region_order = ro,
            .shared = shared, ...} = get_fenv(te,"check_effect_accessible");
  if(subset_effect(false, eff, capability))
    return;
  if(eff_outlives_eff(ro, eff, capability))
    return;
  shared->delayed_effect_checks =
    new List (new $(capability,eff,ro,loc), shared->delayed_effect_checks);
}
void check_delayed_effects(tenv_t te) {
  let checks =
    get_fenv(te,"check_delayed_constraints")->shared->delayed_effect_checks;
  for(; checks != NULL; checks = checks->tl) {
    let &$(capability,eff,rgn_order,loc) = checks->hd;
    if(subset_effect(true, eff, capability))
      continue;
    if(eff_outlives_eff(rgn_order, eff, capability))
      continue;
    Warn::err2(loc, "Capability \n",capability,
	       "\ndoes not cover function's effect\n",eff);
  }
}

// Check that a function call's region partial order is compatible
// with the current region partial order
// Do not constrain evars -- delay the check instead.
// FIX: better error message!
void check_rgn_partial_order(tenv_t te, seg_t loc,
                             list_t<$(type_t,type_t)@`H,`H> po) {
  let le = te->le;
  if(le == NULL) {
    // not sure this could ever fail
    for(; po != NULL; po=po->tl)
      if((!subset_effect(true, (*po->hd)[0], empty_effect))
	 || !subset_effect(true, access_eff((*po->hd)[1]), empty_effect))
	Warn::err2(loc,"the required region ordering is not satisfied here");
    return;
  }
  let &Fenv{.region_order = ro, .shared = shared, ...} = (fenv_t)le;
  if(!satisfies_constraints(ro,po,heap_rgn_type,false))
    shared->delayed_constraint_checks =
      new List(new $(ro,po,loc), shared->delayed_constraint_checks);
}

void check_delayed_constraints(tenv_t te) {
  let checks = 
    get_fenv(te,"check_delayed_constraints")->shared->delayed_constraint_checks;
  for(; checks != NULL; checks = checks->tl) {
    let &$(rgn_order,po,loc) = checks->hd;
    if(!satisfies_constraints(rgn_order,po,heap_rgn_type,true))
      Warn::err2(loc,"the required region ordering is not satisfied here");
  }
}

static struct SharedFenv @`H new_shared_fenv(type_t ret) {
  return new SharedFenv{.return_typ = ret,
			.delayed_effect_checks = NULL,
			.delayed_constraint_checks = NULL };
}

fenv_t new_fenv(seg_t loc, fndecl_t fd) {
  tvar_t rgn0 =
    new Tvar(new ((string_t)aprintf("`%s",*(*fd->name)[1])),
             new_tvar_id(), &rgn_kb);
//   let $(tvs1,cap,ret_t,f_rgn_po) = CurRgn::add_curr_tvar(fd);
  let $(tvs1,cap,ret_t,f_rgn_po) = $(new List(CurRgn::curr_rgn_tvar(),
				       new List(CurRgn::curr_poolrgn_tvar(),fd->i.tvars)),
				     join_eff(new List(access_eff(CurRgn::curr_rgn_type()),
					      new List(access_eff(CurRgn::curr_poolrgn_type()),
					      new List((type_t)fd->i.effect,NULL)))),
				     fd->i.ret_type,fd->i.rgn_po);
  let tvs = new List(rgn0,tvs1);
  Tcutil::check_unique_tvars(loc,tvs);
  let rgn_po = initial_fn_po(tvs1,f_rgn_po,cap,rgn0,loc);
  type_t param_rgn = new VarType(rgn0);
  for(let vds = fd->param_vardecls->v; vds != NULL; vds = vds->tl) 
    vds->hd->rgn = param_rgn;
  if (fd->i.cyc_varargs != NULL) {
    let VarargInfo(n,tq,t,i) = *fd->i.cyc_varargs;
    // name-resolution did not set param_rgn for the cyc_varargs array
    for(let vds = fd->param_vardecls->v; vds != NULL; vds = vds->tl) {
      let vd = vds->hd;
      if(strptrcmp((*vd->name)[1], (var_t)n)==0) {
	vd->type = fatptr_type(t, param_rgn, tq, false_type, false_type);
	break;
      }
    }
  }
  return new
    Fenv{.shared = new_shared_fenv(ret_t),
         .type_vars     = tvs,
         .region_order  = rgn_po,
         .ctrl_env      = NULL,
         .capability    = join_eff(new List(access_eff(param_rgn),
					    new List(cap,NULL))),
         .curr_rgn      = param_rgn,
	 .curr_lifo_rgn = CurRgn::curr_rgn_type(),
	 .curr_pool_rgn = CurRgn::curr_poolrgn_type(),
	 .flags         = FenvFlags{NoneNew,false,false,false,false}
       };
}

fenv_t nested_fenv(seg_t loc, fenv_t old_fenv, fndecl_t fd) {
  let &Fenv{.region_order = rgn_po,
            .type_vars = type_vars, .shared = shared, ...} = old_fenv;
  tvar_t rgn0 =
    new Tvar(new ((string_t)aprintf("`%s",*(*fd->name)[1])),
             new_tvar_id(), &rgn_kb);
  for (let tvars = fd->i.tvars; tvars != NULL; tvars = tvars->tl) {
    let &Kind(k,a) = Kinds::tvar_kind(tvars->hd,&Kinds::bk);
    if (k == RgnKind)
      if (a == Aliasable)
	rgn_po = add_unordered(rgn_po, tvars->hd);
      else
	Warn::impos2("non-intuitionistic tvar in nested_fenv");
  }
  rgn_po = add_youngest(rgn_po, rgn0, false);
  for(let po2 = fd->i.rgn_po; po2 != NULL; po2=po2->tl)
    rgn_po = add_outlives_constraint(rgn_po,(*po2->hd)[0],(*po2->hd)[1],loc);
  let tvs = new List(rgn0,append(fd->i.tvars,type_vars));
  check_unique_tvars(loc,tvs);
  type_t param_rgn = new VarType(rgn0);
  for(let vds = fd->param_vardecls->v; vds != NULL; vds = vds->tl)
    vds->hd->rgn = param_rgn;
  if (fd->i.cyc_varargs != NULL) {
    let VarargInfo(n,tq,t,i) = *fd->i.cyc_varargs;
    // name-resolution did not set param_rgn for the cyc_varargs array
    for(let vds = fd->param_vardecls->v; vds != NULL; vds = vds->tl) {
      let vd = vds->hd;
      if(strptrcmp((*vd->name)[1], (var_t)n)==0) {
	vd->type = fatptr_type(t, param_rgn, tq, false_type, false_type);
	break;
      }
    }
  }
  return new
    Fenv{.shared = new_shared_fenv(fd->i.ret_type),
         .type_vars   = tvs,
         .region_order = rgn_po,
         .ctrl_env    = NULL,
         .capability  = join_eff(new List(access_eff(param_rgn),
					  new List((type_t)fd->i.effect,NULL))),
         .curr_rgn    = param_rgn,
	 .curr_lifo_rgn = CurRgn::curr_rgn_type(),
	 .curr_pool_rgn = CurRgn::curr_poolrgn_type(),
	 .flags       = FenvFlags{NoneNew,false,false,false,false}
       };
}

fenv_t bogus_fenv(type_t ret_type,
		  list_t<$(var_opt_t,tqual_t,type_t)@> args) {
  tvar_t rgn0 = new Tvar(new "bogus", new_tvar_id(), &rgn_kb);
  let tvs = new List(rgn0,NULL);
  let rgn_po = initial_fn_po(NULL,NULL,join_eff(NULL),rgn0,0);
  type_t param_rgn = new VarType(rgn0);
  return new
    Fenv{.shared = new_shared_fenv(ret_type),
         .type_vars   = tvs,
         .region_order = rgn_po,
         .ctrl_env    = NULL,
         .capability  = join_eff(new List(access_eff(param_rgn),NULL)),
         .curr_rgn    = param_rgn,
	 .curr_lifo_rgn = CurRgn::curr_rgn_type(),
	 .curr_pool_rgn = CurRgn::curr_poolrgn_type(),
	 .flags       = FenvFlags{NoneNew,false,false,false,false}
       };
}

tenv_t copy_tenv_dicts(tenv_t te) {
  let ans = new *te;
  ans->ae = new *te->ae;
  ans->ae->aggrdecls = Dict::copy(te->ae->aggrdecls);
  ans->ae->enumdecls = Dict::copy(te->ae->enumdecls);
  ans->ae->datatypedecls = Dict::copy(te->ae->datatypedecls);
  ans->ae->typedefs = Dict::copy(te->ae->typedefs);
  ans->ae->ordinaries = Dict::copy(te->ae->ordinaries);
  ans->le = NULL; 
  return ans;
}
