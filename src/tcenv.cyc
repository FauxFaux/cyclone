/* Type environments.

   An identifier can have at most one binding in each of the following:

   1) namespaces (after "namespace" or "using")
   2) structure tags (after "struct")
   3) union tags (after "union")
   4) structure or union members (after "." or "->")
   5) enum tags (after "enum")
   6) xenum tags (after "xenum")
   7) labels (after "goto", before ":")
   8) typedef names (in types)
   9) ordinary identifiers (the catch-all case)

   The ordinary identifiers include structure tags and enum and xenum
   constructors.

   The environment data structures below follow from this directly.
   Note that labels can only appear inside of functions, so they don't
   appear in global environments.  And structure and union members
   must be resolved on a per-structure/per-union basis (e.g., two
   structs can have members with the same names) so their bindings
   don't belong in our environments.

   Also, we don't currently implement union.
*/

/* During type checking we keep two parallel environments.  One is
   accessed by absolute name, the other by local name.  We need these
   two environments because what is defined in a namespace is
   different from what is available in the namespace.  E.g.,

      extern int z;
      namespace Foo {
        int x;
        namespace Bar {
          int y = x;
        }
      }

   Here x is available in the inner namespace Bar but not defined
   there.  The absolute namespace will have entries for ::z, ::Foo::x,
   ::Foo::Bar, and ::Foo::Bar::y.  The relative namespace just after
   the definition of y will have entries for x, y, and z.
*/

#include "core.h"
#include "stdio.h"
#include "list.h"
#include "dict.h"
#include "set.h"
#include "dict.h"
#include "slowdict.h"
#include "position.h"
#include "string.h"
#include "absynpp.h"
#include "absyn.h"
#include "tcutil.h"
#include "tcenv.h"


namespace Tcenv;

using Core;
using Stdio;
using List;
using Set;
using Position;
using Absyn;
using Tcutil;
using Absynpp;

xenum exn {Env_error};

`a env_err(string msg) {
  fprintf(stderr,"Error: %s\n",msg);
  fflush(stderr);
  throw Env_error;
}

/////////////////////////// Type Definitions /////////////////////////////////

// Type environments
struct Tenv {
  list_t<var>                    ns; // current namespace
  Dict::dict_t<list_t<var>,genv_t> ae; // absolute environment
  opt_t<frames<fenv_t>>        le; // is null except in functions
};

// Global environments -- what's declared in a global scope
struct Genv {
  set_t<var>                    namespaces;
  Dict::dict_t<var,structdecl@> structdecls;
  Dict::dict_t<var,enumdecl@>   enumdecls;
  Dict::dict_t<var,xenumdecl@>  xenumdecls;
  Dict::dict_t<var,typedefdecl> typedefs; // no indirection b/c no redeclaration
  Dict::dict_t<var,$(resolved_t,bool)@> ordinaries; // bool for tree-shaking
  list_t<list_t<var>>             availables; // abs. names of "using" namespaces
};

// Used to tell what an ordinary identifer refers to
enum Resolved {
  VarRes(binding_t); // includes unresolved variant
  StructRes(structdecl);
  EnumRes(enumdecl,enumfield);
  XenumRes(xenumdecl,enumfield);
};

// Models the nesting of the RTCG constructs
enum Frames<`a> {
  Outermost(`a);
  Frame(`a,enum Frames<`a>);
  Hidden(`a,enum Frames<`a>);
};

enum Jumpee {
  NotLoop_j;
  CaseEnd_j;
  FnEnd_j;
  Stmt_j(stmt);
};

static struct CtrlEnv {
  jumpee_t continue_stmt;
  jumpee_t break_stmt;
             // null => not allowed
  $(switch_clause, list_t<tvar>, list_t<typ>) * fallthru_clause; 
  jumpee_t next_stmt; // needed to calculate break_stmt
  // The next_stmt field needs to be correct only when we might enter
  // a loop or switch. (i.e. when we call set_in_loop or set_in_switch)
};
typedef struct CtrlEnv @ ctrl_env_t;

// This part is shared throughout type-checking of a function.
// Hence mutations are seen by all subsequent type-checking, which is easier
// than threading labels which must be function-wide unique anyway.
static struct SharedFenv {
  typ                            return_typ;
  Dict::dict_t<var,stmt>           seen_labels;
  SlowDict::dict_t<var,list_t<stmt>> needed_labels;  // FIX: check empty when done!
};

// Local function environments -- this is getting a bit out of hand, no?
struct Fenv {
  struct SharedFenv @   shared;
  list_t<tvar>            type_vars; // type variables that can occur free
  Dict::dict_t<var,binding_t> locals;// binding will be Param_b, Local_b, or Pat_b
  stmt                  encloser;  // nearest stmt with a binder or a try
  ctrl_env_t            ctrl_env;
  typ                   capability; // current capability -- 
  typ                   curr_rgn;   // current block's region
};

//////////////////////// Top-level Environment Manipulation //////////////////

tenv tc_init() {
  // Initialize globals
  empty_var_set = &Opt(Set::empty(String::zstrptrcmp));

  // Set up initial environment so that xenum exn is defined
  // Note: Absyn::exn_xed must be fresh for each file b/c fields gets mutated!!
  // In turn, we need to reset exn_typ!!
  let ge     = empty_genv();
  let top_ns = null;
  exn_xed = new {Xenumdecl(Extern, exn_name, null)};
  exn_typ = XenumType(exn_name, &exn_xed);
  ge->xenumdecls = Dict::insert(ge->xenumdecls, (*exn_name)[1], &exn_xed);
  let ae = Dict::insert(Dict::empty(varlist_cmp), top_ns, ge);
  return &Tenv(top_ns,ae,null);
}

// Lookup a namespace relative to the current namespace
static genv_t lookup_namespace(tenv te, seg_t loc,
                               var n, list_t<var> ns) {
  return Dict::lookup(te->ae, resolve_namespace(te,loc,n,ns));
}

// lookup functions
static list_t<var> outer_namespace(list_t<var> ns) {
  if (ns == null)
    return env_err("Tcenv::outer_namespace");
  return List::rev(List::rev(ns)->tl);
}

// FIX: We should eagerly detect repeats by having one big dict
// that we recompute on namespace and using boundaries
static void check_repeat(tenv_t te, seg_t loc, `a lookup(genv_t,var),
			     var v, list_t<list_t<var>> nss) {
  for(; nss != null; nss = nss->tl) {
    genv_t ge2 = Dict::lookup(te->ae,nss->hd);
    try {
      lookup(ge2,v);
      Tcutil::terr(loc,xprintf("%s is ambiguous",*v));
    } catch { case Dict::Absent: break; }
  }
  return;
}

static `a scoped_lookup(tenv_t te, seg_t loc, `a lookup(genv_t,var), var v){
  list_t<var> cns = te->ns; // current namespace
  `a result; // def assignment too dumb
  while (true) {
    genv_t ge = Dict::lookup(te->ae,cns);
    // Check current namespace
    try {
      result = lookup(ge,v);
      check_repeat(te, loc, lookup, v, ge->availables);
      return result;
    } catch { case Dict::Absent: break; }
    // Check available namespaces
    for (let nss = ge->availables; nss != null; nss = nss->tl) {
      genv_t ge2 = Dict::lookup(te->ae,nss->hd);
      try {
	result = lookup(ge2,v);
	check_repeat(te, loc, lookup, v, nss->tl);
	return result;
      } catch { case Dict::Absent: break; }
    }
    if (cns == null)
      throw Dict::Absent;
    // v is not defined in current namespace, look in next outer
    cns = outer_namespace(cns);
  }
}

static resolved_t lookup_ordinary_global_f(genv_t ge,var v) {
  $(resolved_t,bool)@ ans = Dict::lookup(ge->ordinaries,v);
  (*ans)[1] = true;
  return (*ans)[0];
}
static resolved_t lookup_ordinary_global(tenv te,seg_t loc,qvar q) {
  let &$(nsl,v) = q;
  switch (nsl) {
  case Loc_n: fallthru;
  case Rel_n(null):
    return scoped_lookup(te, loc, lookup_ordinary_global_f, v);
  case Rel_n(&List(x,y)):
    let ge = lookup_namespace(te,loc,x,y);
    return lookup_ordinary_global_f(ge,v);
  case Abs_n(y):
    return lookup_ordinary_global_f(Dict::lookup(te->ae,y),v);
  }
}

// Return the absolute name of relative namespace &List(n,ns)
list_t<var> resolve_namespace(tenv te, seg_t loc,
                            var n, list_t<var> ns) {
  let cns = te->ns; // current namespace
  let possible_results = null;
  while (true) {
    let ge = Dict::lookup(te->ae,cns);
    // Check namespaces that have been made available
    for (let nss = ge->availables; nss != null; nss = nss->tl) {
      genv_t ge2 = Dict::lookup(te->ae,nss->hd);
      if (Set::member(ge2->namespaces, n))
        possible_results = &List(List::append(cns,&List(n,ns)),
                                 possible_results);
    }
    // Check current namespace
    if (Set::member(ge->namespaces, n))
      possible_results = &List(List::append(cns,&List(n,ns)),
                               possible_results);
    // Is this right? We check for ambiguity between the current namespace
    // and used namespaces in the current scope, but not outer namespaces.
    // Seems inconsistent.
    if (possible_results != null) {
      if (possible_results->tl != null)
        Tcutil::terr(loc,xprintf("%s is ambiguous",*(n)));
      return possible_results->hd;
    }
    if (cns == null)
      throw Dict::Absent;
    // n is not defined in current namespace, look in next outer
    cns = outer_namespace(cns);
  }
}

// The absolute versions aren't being used right now, but it's
// important to think about whether they are correct in certain contexts.

static structdecl @ lookup_structdecl_f(genv_t ge,var v) {
  return Dict::lookup(ge->structdecls,v);
}
structdecl @ lookup_structdecl(tenv te,seg_t loc,qvar q) {
  let &$(nsl,v) = q;
  switch (nsl) {
  case Loc_n: fallthru;
  case Rel_n(null):
    return scoped_lookup(te, loc, lookup_structdecl_f, v);
  case Abs_n(y):
    let ge = Dict::lookup(te->ae,y);
    return Dict::lookup(ge->structdecls,v);
  case Rel_n(&List(x,y)):
    let ge = lookup_namespace(te,loc,x,y);
    return Dict::lookup(ge->structdecls,v);
  }
}
//structdecl @ lookup_structdecl_abs(tenv te, seg_t loc,qvar q) {
//  return Dict::lookup(Dict::lookup(te->ae,(*q)[0])->structdecls, (*q)[1]);
//}

static enumdecl @ lookup_enumdecl_f(genv_t ge,var v) {
  return Dict::lookup(ge->enumdecls,v);
}
enumdecl @ lookup_enumdecl(tenv te,seg_t loc,qvar q) {
  let &$(nsl,v) = q;
  switch (nsl) {
  case Loc_n: fallthru;
  case Rel_n(null):
    return scoped_lookup(te, loc, lookup_enumdecl_f, v);
  case Rel_n(&List(x,y)):
    let ge = lookup_namespace(te,loc,x,y);
    return Dict::lookup(ge->enumdecls,v);
  case Abs_n(y):
    let ge = Dict::lookup(te->ae,y);
    return Dict::lookup(ge->enumdecls,v);
  }
}
//enumdecl @ lookup_enumdecl_abs(tenv te, seg_t loc,qvar q) {
//  return Dict::lookup(Dict::lookup(te->ae,(*q)[0])->enumdecls, (*q)[1]);
//}

static xenumdecl @ lookup_xenumdecl_f(genv_t ge,var v) {
  return Dict::lookup(ge->xenumdecls,v);
}

// DAN: some functionality from tcXenumdecl has moved to here.
opt_t<xenumdecl@> lookup_xenumdecl(tenv te,seg_t loc,qvar q) {
  let &$(nsl,v) = q;
  switch (nsl) {
  case Rel_n(null):
    // unqualified name, okay to fail -- that just means we have a new xenum
    try return &Opt(scoped_lookup(te, loc, lookup_xenumdecl_f, v));
    catch { case Dict::Absent: return null; }
  case Loc_n: // impossible case
    terr(loc,"lookup_xenumdecl: impossible");
    return null;
  case Rel_n(&List(x,y)):
    // qualified name, it's an error if the namespace is bad or the
    // xenum doesn't already exist.  In either case, we'll raise
    // Dict::Absent, so we give a more descriptive message for the
    // former.
    genv_t ge;
    try ge = lookup_namespace(te,loc,x,y);
    catch {
    case Dict::Absent:
      Tcutil::terr(loc,"bad qualified name for xenum");
      throw Dict::Absent;
    }
    return &Opt(Dict::lookup(ge->xenumdecls,v));
  case Abs_n(y):
    genv_t ge = Dict::lookup(te->ae,y);
    return &Opt(Dict::lookup(ge->xenumdecls,v));
  }
}
//// FIX: We probably need some of the lenience of lookup_xenumdecl here too.
////      I would add it, but I think xenums are still generally sorta busted.
//opt_t<xenumdecl@> lookup_xenumdecl_abs(tenv te, seg_t loc,qvar q) {
//  return &Opt(Dict::lookup(Dict::lookup(te->ae,(*q)[0])->xenumdecls, (*q)[1]));
//}

static typedefdecl lookup_typedefdecl_f(genv_t ge,var v) {
  return Dict::lookup(ge->typedefs,v);
}
typedefdecl lookup_typedefdecl(tenv te, seg_t loc, qvar q) {
  let &$(nsl,v) = q;
  switch (nsl) {
  case Loc_n: fallthru;
  case Rel_n(null):
    return scoped_lookup(te, loc, lookup_typedefdecl_f, v);
  case Rel_n(&List(x,y)):
    let ge = lookup_namespace(te,loc,x,y);
    return Dict::lookup(ge->typedefs,v);
  case Abs_n(y):
    let ge = Dict::lookup(te->ae,y);
    return Dict::lookup(ge->typedefs,v);
  }
}

genv_t empty_genv() {
  return &Genv{.namespaces  = empty_var_set->v,
               .structdecls = Dict::empty(String::zstrptrcmp),
               .enumdecls   = Dict::empty(String::zstrptrcmp),
               .xenumdecls  = Dict::empty(String::zstrptrcmp),
               .typedefs    = Dict::empty(String::zstrptrcmp),
               .ordinaries  = Dict::empty(String::zstrptrcmp),
               .availables  = null};
}

////////////////////////////// Frames Manipulation //////////////////////////

`a get_visible(frames<`a> f) {
  while(true)
    switch (f) {
    case Outermost(x): return x;
    case Frame(x,_):   return x;
    case Hidden(x,y):  f = y; break;
    }
}

frames<`a> put_visible(frames<`a> f, `a x) {
  switch (f) {
  case Outermost(x2): return Outermost(x);
  case Frame(x2,f2):  return Frame(x,f2);
  case Hidden(x2,f2): return Hidden(x2,put_visible(f2,x));
  }
}

frames<`a> apply_to_visible(`a g(`a), frames<`a> f) {
  return put_visible(f,g(get_visible(f)));
}

frames<`b> map_frames(`b g(`a), frames<`a> f) {
  switch (f) {
  case Outermost(x): return Outermost(g(x));
  case Frame(x,f2):  return Frame(g(x),map_frames(g,f2));
  case Hidden(x,f2): return Hidden(g(x),map_frames(g,f2));
  }
}

fenv_t get_fenv(tenv te) {
  if (te->le == null) throw Env_error;
  return get_visible(te->le->v);
}

tenv put_fenv(tenv te, fenv_t fe) {
  if (te->le == null) throw Env_error;
  return &Tenv(te->ns, te->ae, &Opt(put_visible(te->le->v,fe)));
}

//////////////////// Function Environment Manipulation //////////////////////

static fenv_t copy_fenv_old_ctrl(fenv_t f) {
  return &Fenv(f->shared, f->type_vars, f->locals, f->encloser, f->ctrl_env,
	       f->capability, f->curr_rgn);
}
static fenv_t copy_fenv_new_ctrl(fenv_t f) {
  // WARNING: fallthru_clause shared with old
  ctrl_env_t c = f->ctrl_env;
  return &Fenv(f->shared, f->type_vars, f->locals, f->encloser,
	       &CtrlEnv(c->continue_stmt, c->break_stmt, c->fallthru_clause,
			c->next_stmt),
	       f->capability, f->curr_rgn);
}

typ return_typ(tenv te) {
  if(te->le == null) env_err("Tcenv: unexpected return_typ");
  return get_fenv(te)->shared->return_typ;
}

list_t<tvar> lookup_type_vars(tenv te) {
  if(te->le == null) return null;
  return get_fenv(te)->type_vars;
}

tenv add_type_vars(seg_t loc,tenv te,list_t<tvar> tvs) {
  if(te->le == null) env_err("Tcenv: unexpected add_type_vars");
  let fe      = copy_fenv_old_ctrl(get_fenv(te));
  let new_tvs = List::append(tvs,fe->type_vars);
  Tcutil::check_unique_tvars(loc,new_tvs);
  fe->type_vars = new_tvs;
  return put_fenv(te,fe);
}

// FIX: This can cause clashes with other programmer variables!!!!
static int shadow_ctr = 1;

tenv add_local_var(seg_t loc, tenv te, vardecl vd) {
  if(te->le == null) env_err("Tcenv: unexpected add_local_var");
  let fe = copy_fenv_old_ctrl(get_fenv(te));
  let v  = (*vd->name)[1];
  switch ((*vd->name)[0]) {
  case Loc_n: break;
  default:
    // This is a fail-safe.
    // Maybe we should just clobber with Loc_n?
    throw Impossible("add_local_var: called with Rel_n");
    break;
  }
  if(Dict::member(fe->locals,v))
    vd->shadow = ++shadow_ctr;
  fe->locals = Dict::insert(fe->locals,v,Local_b(vd));
  return put_fenv(te,fe);
}

// assume uniqueness has been checked elsewhere
tenv add_pat_var(seg_t loc, tenv te, vardecl vd) {
  if(te->le == null) env_err("Tcenv: unexpected add_pat_var");
  let fe = copy_fenv_old_ctrl(get_fenv(te));
  let v  = (*vd->name)[1];
  if(Dict::member(fe->locals,v))
    vd->shadow = ++shadow_ctr;
  fe->locals = Dict::insert(fe->locals,v,Pat_b(vd));
  return put_fenv(te,fe);
}

resolved_t lookup_ordinary(tenv te,seg_t loc,qvar q) {
  let &$(nsl,v) = q;
  switch (nsl) {
  case Loc_n:
    if (te->le == null) { throw Dict::Absent; }
    else fallthru;
  case Rel_n(null) && te->le != null:
    let fe = get_fenv(te);
    // NB a local overrides any global, without an ambiguity warning
    try return VarRes(Dict::lookup(fe->locals,v));
    catch {case Dict::Absent: return lookup_ordinary_global(te,loc,q);}
  default:
    try return lookup_ordinary_global(te,loc,q);    
    catch {
    case Dict::Absent: 
      terr(loc,xprintf("unbound identifer: %s", Absynpp::qvar2string(q)));
      return VarRes(Unresolved_b);
    }
  }
}

void process_continue(tenv te, stmt s, stmt_opt @sopt) {
  if (te->le == null) env_err("Tcenv: unexpected process_continue");
  switch (get_fenv(te)->ctrl_env->continue_stmt) {
  case Stmt_j(s2):
    s2->non_local_preds = &List(s,s2->non_local_preds);
    *sopt = s2;
    return;
  case NotLoop_j: terr(s->loc, "continue not in a loop");     return;
  case CaseEnd_j: env_err("Tcenv: continue dest is CaseEnd"); return;
  case FnEnd_j:   env_err("Tcenv: continue dest is CaseEnd"); return;
  }
}
void process_break(tenv te, stmt s, stmt_opt @sopt) {
  if (te->le == null) env_err("Tcenv: unexpected process_break");
  fenv_t fe = get_fenv(te);
  switch (fe->ctrl_env->break_stmt) {
  case Stmt_j(s2):
    s2->non_local_preds = &List(s,s2->non_local_preds);
    *sopt = s2;
    return;
  case NotLoop_j:
    terr(s->loc, "break not in a loop or switch");
    return;
  case FnEnd_j:
    // Note doing this here is more conservative than in control-flow.
    // Eg: while(true) if(false) break; else return 0;
    // But it's a pain to do in control flow because there is no stmt dest
    if(fe->shared->return_typ != VoidType)
      terr(s->loc, "break causes function not to return a value");
    return;
  case CaseEnd_j:
    // Analogous comment to previous case applies.
    terr(s->loc, "break causes outer switch clause to implicitly fallthru");
    return;
  }
}
void process_goto(tenv te, stmt s, var l, stmt_opt @sopt) {
  if (te->le == null) env_err("Tcenv: unexpected process_goto");
  fenv_t fe    = get_fenv(te);
  let      sopt2 = Dict::lookup_opt(fe->shared->seen_labels, l);
  if(sopt2 == null) {
    let needed = fe->shared->needed_labels;
    let slopt  = SlowDict::lookup_opt(needed, l);
    if(slopt == null)
      slopt = &Opt(null);
    fe->shared->needed_labels = SlowDict::insert(needed,l,&List(s,slopt->v));
  } else {
    sopt2->v->non_local_preds = &List(s, sopt2->v->non_local_preds);
    *sopt = sopt2->v;
  }
}
$(switch_clause,list_t<tvar>,list_t<typ>)* 
process_fallthru(tenv te,stmt s, switch_clause *@ clauseopt){
  if (te->le == null) env_err("Tcenv: unexpected process_fallthru");
  let fe  = get_fenv(te);
  let ans = fe->ctrl_env->fallthru_clause;
  if(ans != null) {
    (*ans)[0]->body->non_local_preds = 
      &List(s, (*ans)[0]->body->non_local_preds);
    *clauseopt = new{(*ans)[0]};
  }
  return ans;
}

tenv set_fallthru(tenv te, $(list_t<tvar>,list_t<vardecl>) * pat_typ, 
		  switch_clause clause) {
  if(te->le == null) env_err("Tcenv: unexpected set_fallthru");
  let ft_typ = null;
  for(let vds = (*pat_typ)[1]; vds!=null; vds=vds->tl)
    ft_typ = &List(vds->hd->type,ft_typ);
  ft_typ = List::imp_rev(ft_typ);
  fenv_t fe = copy_fenv_new_ctrl(get_fenv(te));
  fe->ctrl_env->fallthru_clause = &$(clause,(*pat_typ)[0],ft_typ);
  return put_fenv(te,fe);
}
// fallthru is illegal in the last case
tenv clear_fallthru(tenv te) {
  if(te->le == null) env_err("Tcenv: unexpected clear_fallthru");
  fenv_t fe = copy_fenv_new_ctrl(get_fenv(te));
  fe->ctrl_env->fallthru_clause = null;
  return put_fenv(te,fe);
}

tenv set_in_loop(tenv te, stmt continue_dest) {
  if (te->le == null) env_err("Tcenv: unexpected set_in_loop");
  fenv_t fe = copy_fenv_new_ctrl(get_fenv(te));
  fe->ctrl_env->continue_stmt = Stmt_j(continue_dest);
  fe->ctrl_env->break_stmt    = fe->ctrl_env->next_stmt; // break goes to next
  fe->ctrl_env->next_stmt     = Stmt_j(continue_dest);   // next starts as cont
  return put_fenv(te,fe);
}

// each non-last case must also call set_fallthru, here we just
// change the break destination
tenv set_in_switch(tenv te) {
  if (te->le == null) env_err("Tcenv: unexpected set_in_switch");
  fenv_t fe  = copy_fenv_new_ctrl(get_fenv(te));
  fe->ctrl_env->break_stmt = fe->ctrl_env->next_stmt; // break goes to next
  fe->ctrl_env->next_stmt  = CaseEnd_j; // prevent nested break to fallthru
  return put_fenv(te,fe);
}

tenv set_next(tenv te, jumpee_t j) {
  if (te->le == null) env_err("Tcenv: unexpected set_next");
  fenv_t fe = copy_fenv_new_ctrl(get_fenv(te));
  fe->ctrl_env->next_stmt = j;
  return put_fenv(te,fe);
}

tenv add_label(tenv te, var v, stmt s) {
  if (te->le == null) env_err("Tcenv: unexpected add_label");
  let fe     = get_fenv(te);
  let needed = fe->shared->needed_labels;
  let sl_opt = SlowDict::lookup_opt(needed, v);
  if(sl_opt != null) {
    fe->shared->needed_labels = SlowDict::delete(needed, v);
    // backpatching
    let sl = sl_opt->v;
    s->non_local_preds = sl;
    for(; sl != null; sl = sl->tl)
      switch (sl->hd->r) {
      case Goto_s(_,*so): *so = s; break;
      default: env_err("Tcenv: add_label backpatching of non-goto"); break;
      }
  }
  if(Dict::member(fe->shared->seen_labels, v))
    Tcutil::terr(s->loc, xprintf("Repeated label: %s", *v));
  fe->shared->seen_labels = Dict::insert(fe->shared->seen_labels, v, s);
  return te;
}

bool all_labels_resolved(tenv te) {
  return SlowDict::is_empty(get_fenv(te)->shared->needed_labels);
}

stmt get_encloser(tenv te) {
  if (te->le == null) env_err("Tcenv: unexpected get_encloser");
  return get_fenv(te)->encloser;
}
tenv set_encloser(tenv te, stmt s) {
  if (te->le == null) env_err("Tcenv: unexpected set_encloser");
  fenv_t fe  = copy_fenv_old_ctrl(get_fenv(te));
  fe->encloser = s;
  return put_fenv(te,fe);
}

// We're entering a new block, so add a new region
// FIX:  we need to be able to specify the name of the region
// explicitly somehow...
tenv new_block(tenv te) {
  if (te->le == null) env_err("Tcenv: unexpected new_block");
  fenv_t fe = copy_fenv_old_ctrl(get_fenv(te));
  tvar block_rgn = new_tvar(RgnKind);
  typ block_typ = VarType(block_rgn);
  // NOTE:  no need to check uniqueness since the variable is gensymed
  fe->type_vars = &List(block_rgn, fe->type_vars);
  fe->capability = JoinEff(&List(AccessEff(block_typ), 
                                 &List(fe->capability,null)));
  fe->curr_rgn = block_typ;
  return put_fenv(te,fe);
}

typ curr_rgn(tenv te) {
  if (te->le == null) return HeapRgn; 
  return get_fenv(te)->curr_rgn;
}

// Check that rgn_typ is currently accessible:  the heap region is always
// accessible, and a region variable r is accessible iff it appears in the
// list of available regions.
void check_rgn_accessible(tenv te, seg_t loc, typ rgn) {
  if (te->le != null) {
    typ capability = get_fenv(te)->capability;
    if (region_in_effect(false, rgn, capability) ||
        region_in_effect(true, rgn, capability)) return;
  }
  terr(loc, xprintf("Expression accesses unavailable region %s",
                    typ2string(rgn)));
}

// Check that a function call's effect is contained in the current
// capability.
void check_effect_accessible(tenv te, seg_t loc, typ eff) {
  typ capability;
  if (te->le == null) 
    capability = JoinEff(null);
  else {
    let fenv = get_fenv(te);
    capability = fenv->capability;
  }
  // for function calls, we drive the slack in the function's effect to 
  // the empty effect
  if (!subset_effect(true, eff, capability))
    terr(loc, xprintf("Capability %s does not cover function's effect %s",
                      typ2string(capability), typ2string(eff)));
}

fenv_t new_fenv(fndecl fd) {
  let locals = Dict::empty(String::zstrptrcmp);
  // FIX:  the user may need to get their hands on the region name
  // but if it's gensym'd, they can't.  
  tvar rgn0 = new_tvar(RgnKind);
  typ param_rgn = VarType(rgn0);
  let vds = null;
  for(let args = fd->args; args != null; args = args->tl) {
    let vd = new{Vardecl(Public, 
			       new{$(Loc_n,(*args->hd)[0])},
			       (*args->hd)[1],
			       (*args->hd)[2],
			       null, 0, new{Opt(param_rgn)})};
    vds = new{List(vd, vds)};
    locals = Dict::insert(locals, (*args->hd)[0], Param_b(vd));
  }
  fd->param_vardecls = new{Opt(vds)};
  return &Fenv{.shared      = 
                  &SharedFenv{.return_typ = fd->ret_type,
			      .seen_labels = Dict::empty(String::zstrptrcmp),
			      .needed_labels = 
			        SlowDict::empty(String::zstrptrcmp)
		             },
 	       .type_vars   = &List(rgn0,fd->tvs), // assumed unique
	       .locals      = locals,  // assumed unique
	       .encloser    = fd->body, // careful -- self loop at top!!!
	       .ctrl_env    = &CtrlEnv(NotLoop_j, NotLoop_j, null, FnEnd_j),
               .capability  = JoinEff(&List(AccessEff(param_rgn),
                                            &List(fd->effect->v,null))),
               .curr_rgn    = param_rgn
              };
}
