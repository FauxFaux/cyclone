/* Type environments.
   Copyright (C) 2001 Greg Morrisett, AT&T
   This file is part of the Cyclone compiler.

   The Cyclone compiler is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   The Cyclone compiler is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with the Cyclone compiler; see the file COPYING. If not,
   write to the Free Software Foundation, Inc., 59 Temple Place -
   Suite 330, Boston, MA 02111-1307, USA. */


/* An identifier can have at most one binding in each of the following:

   1) namespaces (after "namespace" or "using")
   2) structure tags (after "struct")
   3) union tags (after "union")
   4) structure or union members (after "." or "->")
   5) datatype tags (after "datatype")
   7) labels (after "goto", before ":")
   8) typedef names (in types)
   9) ordinary identifiers (the catch-all case)

   The ordinary identifiers include structure tags and datatype
   constructors.

   The environment data structures below follow from this directly.
   Note that labels can only appear inside of functions, so they don't
   appear in global environments.  And structure and union members
   must be resolved on a per-structure/per-union basis (e.g., two
   structs can have members with the same names) so their bindings
   don't belong in our environments.
*/

/* During type checking we keep two parallel environments.  One is
   accessed by absolute name, the other by local name.  We need these
   two environments because what is defined in a namespace is
   different from what is available in the namespace.  E.g.,

      extern int z;
      namespace Foo {
        int x;
        namespace Bar {
          int y = x;
        }
      }

   Here x is available in the inner namespace Bar but not defined
   there.  The absolute namespace will have entries for ::z, ::Foo::x,
   ::Foo::Bar, and ::Foo::Bar::y.  The relative namespace just after
   the definition of y will have entries for x, y, and z.
*/

#include <core.h>
#include <cycboot.h>
#include <list.h>
#include <dict.h>
#include <set.h>
#include <dict.h>
#include <slowdict.h>
#include <position.h>
#include <string.h>
#include "absynpp.h"
#include "absyn.h"
#include "tcutil.h"
#include "tcenv.h"
#include "rgnorder.h"

using Core;
using List;
using Set;
using Position;
using Absyn;
using Tcutil;
using Absynpp;
using RgnOrder;
namespace Tcenv;

bool warn_override = false;

datatype exn {Env_error};
datacon(exn,Env_error);

`a env_err(string_t msg) __attribute__((noreturn)) {
  //fprintf(stderr,"Internal error in tcenv: %s\n",msg);
  //fflush(stderr);
  throw &Env_error_val;
}


/////////////////////////// Type Definitions /////////////////////////////////

// Type environments
struct Tenv<`g::R,`l::R> {
  list_t<var_t>    ns;  // current namespace
  Dict::dict_t<list_t<var_t,`H>,genv_t<`g>,`g> ae; // absolute identifiers
  struct Fenv<`l> *`l le; // local environment
  bool allow_valueof;   // controls whether we allow valueof(T) in an expr
  bool in_extern_c_include;
};
// Region notes:  we leave ns heap-allocated because this gets
// plugged into all of the variables in the AST.  Similarly, the
// ae domain takes a heap-allocated list because it's used to lookup
// namespaces.

// Global environments -- what's declared in a global scope
struct Genv<`g::R> {
  region_t<`g> grgn;   // region for allocating globals
  set_t<var_t,`g>                   namespaces;
  Dict::dict_t<var_t,aggrdecl_t@,`g> aggrdecls;
  Dict::dict_t<var_t,datatypedecl_t@,`g> datatypedecls;
  Dict::dict_t<var_t,enumdecl_t@,`g>   enumdecls;
  // no indirection b/c no redeclaration
  Dict::dict_t<var_t,typedefdecl_t,`g> typedefs;
  // bool for tree-shaking
  Dict::dict_t<var_t,$(resolved_t,bool)@`g,`g> ordinaries;
  // abs. names of "using" namespaces
  list_t<list_t<var_t>,`g> availables;
};
// Region notes:  the @ pointers for aggrdecl_t, datatypedecl_t,
// and enumdecl_t show up in the abstract syntax, so we make them
// heap pointers.  The list_t<var_t> in availables is heap-allocated
// because we look them up in the ae environment of the tenv.

// Used to tell what an ordinary identifer refers to
datatype Resolved {
  VarRes(binding_t); // includes unresolved variant
  AggrRes(aggrdecl_t);
  DatatypeRes(datatypedecl_t,datatypefield_t);
  EnumRes(enumdecl_t,enumfield_t);
  AnonEnumRes(type_t,enumfield_t);
};

typedef $(switch_clause_t, list_t<tvar_t>, clist_t<type_t,`r>) const *`r
ftclause_t<`r>;

static struct CtrlEnv<`r::R> {
  ftclause_t<`r> fallthru_clause;
};
typedef struct CtrlEnv<`r> @`r2 ctrl_env_t<`r,`r2>;
// This part is shared throughout type-checking of a function.
// Hence mutations are seen by all subsequent type-checking, which is easier
// than threading labels which must be function-wide unique anyway.
static struct SharedFenv<`f::R> {
  region_t<`f>  frgn;
  type_t                              return_typ;
  list_t<$(type_t,type_t,rgn_po_t<`f>,seg_t)@`f,`f> delayed_effect_checks;
  list_t<$(rgn_po_t<`f>,list_t<$(type_t,type_t)@>,seg_t)@`f,`f> delayed_constraint_checks;
};
// Region notes:  needed_labels has a heap-list in the co-domain because
// these get attached to abstract syntax.  The list<$(type,type)@> pair in
// delayed_constraint_checks is heap-allocated because it comes from the
// abstract syntax.

// Local variable bindings are just kept in a linked list -- the
// tail is declared const so as to get deep region sub-typing
// which allows us to share local environments.
struct Bindings<`r::R> {
  var_t v;
  binding_t b;
  struct Bindings<`r> const *`r const tl;
};
typedef struct Bindings<`r> const *`r const bindings_t<`r>;
typedef struct Bindings<`r> const *`r bnds_t<`r>;

// flags for local function environments
struct FenvFlags {
  bool in_notreadctxt; // true when in an exp that might read
  bool in_lhs;         // true when we're in a lhs exp
  bool in_new;         // true when we're in a new expression
  bool abstract_ok;    // true when an expression can be abstract
};

// Local function environments -- this is getting a bit out of hand, no?
abstract struct Fenv<`r::R> {
  <`f::R,`c::R> : {`f} > `r, {`c} > `r
  struct SharedFenv<`f> @`f shared;
  list_t<tvar_t>      type_vars; //type variables that can occur free
  rgn_po_t<`f>        region_order; // partial order on region variables
  bindings_t<`r>      locals;
  stmt_t              encloser;  // nearest stmt with a binder or a try
  ctrl_env_t<`c,`r>   ctrl_env;
  type_t              capability;
  type_t              curr_rgn;   // current block's region
  struct FenvFlags    flags;
  region_t<`r>        fnrgn;
};
// Region notes:  the shared part of the function environment has its
// own region `f, and the ctrl part of the function environment has its
// own region `c since these things want to share across distinct,
// but nested fenvs.  The type_vars are heap-allocated because we put
// them in abstract syntax (specifically evars).  I haven't messed with
// the region_order yet, but presumably some of it can be region-allocated.


//////////////////////// Lookup a local binding /////////////////////////////
datatype exn { NoBinding; };
datacon(exn,NoBinding);

// lookup a binding, throwing NoBinding on failure.
binding_t lookup_binding(bnds_t bs, var_t v) {
  for (; bs; bs = bs->tl) {
    if (strptrcmp(v,bs->v) == 0) return bs->b;
  }
  throw &NoBinding_val;
}

//////////////////////// Top-level Environment Manipulation //////////////////

genv_t<`r> empty_genv(region_t<`r> r) {
  return rnew(r) Genv{.grgn        = r,
                      .namespaces  = Set::rempty(r,strptrcmp),
                      .aggrdecls   = Dict::rempty(r,strptrcmp),
                      .datatypedecls = Dict::rempty(r,strptrcmp),
                      .enumdecls   = Dict::rempty(r,strptrcmp),
		      .typedefs    = Dict::rempty(r,strptrcmp),
                      .ordinaries  = Dict::rempty(r,strptrcmp),
		      .availables  = NULL};
}

tenv_t<`r,`r> tc_init(region_t<`r> r) {
  // Initialize globals
  empty_var_set = new Opt(Set::empty(strptrcmp));
  // Set up initial environment so that datatype exn, etc. is defined
  let ge     = empty_genv(r);
  ge->datatypedecls = Dict::insert(ge->datatypedecls, (*exn_name)[1], new exn_tud);
  for (let tufs = exn_tud->fields->v; tufs != NULL; tufs = tufs->tl)
    ge->ordinaries = Dict::insert(ge->ordinaries, (*tufs->hd->name)[1],
                                  rnew(r)
                                  $(new DatatypeRes(exn_tud,tufs->hd),true));

  Dict::dict_t<list_t<var_t,`H>,genv_t<`r>,`r> ae =
    Dict::insert(Dict::rempty(r,varlist_cmp), NULL, ge);
  return rnew(r) Tenv(NULL,ae,NULL,false,false);
}

// Lookup a namespace relative to the current namespace
static genv_t<`r> lookup_namespace(tenv_t<`r> te, seg_t loc,
                                   var_t n, list_t<var_t,`H> ns) {
  return Dict::lookup(te->ae, resolve_namespace(te,loc,n,ns));
}

// lookup functions
static list_t<var_t> outer_namespace(list_t<var_t> ns) {
  if (ns == NULL)
    return env_err("outer_namespace");
  return List::rev(List::rev(ns)->tl);
}

static bool same_namespace(list_t<var_t,`H> n1, list_t<var_t,`H> n2) {
  if (n1 == n2) return true;
  for (; n1 != NULL; n1 = n1->tl) {
    if (n2 == NULL) return false;
    if (strptrcmp(n1->hd,n2->hd) != 0) return false;
    n2 = n2->tl;
  }
  if (n2 != NULL) return false;
  return true;
}

// FIX: We should eagerly detect repeats by having one big dict
// that we recompute on namespace and using boundaries
static void check_repeat(tenv_t<`r> te, seg_t loc,
                         `a lookup(genv_t<`r>,var_t,bool),
			 var_t v,
			 list_t<var_t,`H> cns,
			 list_t<list_t<var_t,`H>,`g> nss) {
  for(; nss != NULL; nss = nss->tl)
    if (!same_namespace(cns,nss->hd)) {
      genv_t ge2 = Dict::lookup(te->ae,nss->hd);
      try {
	lookup(ge2,v,false);
	Tcutil::terr(loc,"%s is ambiguous",*v);
      } catch { case &Dict::Absent: break; }
    }
  return;
}

static `a scoped_lookup(tenv_t<`g,`r> te,seg_t loc,`a lookup(genv_t<`g>,var_t,bool),var_t v, bool is_use){
  list_t<var_t> cns = te->ns; // current namespace
  while (true) {
    genv_t ge = Dict::lookup(te->ae,cns);
    // Check current namespace
    try {
      `a result = lookup(ge,v,is_use);
      check_repeat(te, loc, lookup, v, cns, ge->availables);
      return result;
    } catch { case &Dict::Absent: break; }
    // Check available namespaces
    for (let nss = ge->availables; nss != NULL; nss = nss->tl) {
      genv_t ge2 = Dict::lookup(te->ae,nss->hd);
      try {
	`a result = lookup(ge2,v,is_use);
	check_repeat(te, loc, lookup, v, nss->hd, nss->tl);
	return result;
      } catch { case &Dict::Absent: break; }
    }
    if (cns == NULL)
      throw new Dict::Absent;
    // v is not defined in current namespace, look in next outer
    cns = outer_namespace(cns);
  }
}

static resolved_t lookup_ordinary_global_f(genv_t ge,var_t v,bool is_use) {
  let ord = ge->ordinaries;
  $(resolved_t,bool)@ ans = Dict::lookup(ord,v);
  if (is_use)
    (*ans)[1] = true;
  return (*ans)[0];
}
static resolved_t lookup_ordinary_global(tenv_t te,seg_t loc,qvar_t q,bool is_use) {
  let &$(nsl,v) = q;
  switch (nsl) {
  case {.Loc_n = _}: fallthru;
  case {.Rel_n = NULL}:
    return scoped_lookup(te, loc, lookup_ordinary_global_f, v, is_use);
  case {.Rel_n = &List(x,y)}:
    let ge = lookup_namespace(te,loc,x,y);
    return lookup_ordinary_global_f(ge,v,is_use);
  case {.C_n = y}: fallthru(y);
  case {.Abs_n = y}:
    return lookup_ordinary_global_f(Dict::lookup(te->ae,y),v,is_use);
  }
}

// Return the absolute name of relative namespace &List(n,ns)
list_t<var_t> resolve_namespace(tenv_t te, seg_t loc,
                                var_t n, list_t<var_t,`H> ns) {
  let cns = te->ns; // current namespace
  TEMP_RGN(te,temp) {
    let possible_results = NULL;
    while (true) {
      let ge = Dict::lookup(te->ae,cns);
      let ge_av = ge->availables;
      let ge_ns = ge->namespaces;
      // Check namespaces that have been made available
      for (let nss = ge_av; nss != NULL; nss = nss->tl) {
        let ge2_ns = Dict::lookup(te->ae,nss->hd)->namespaces;
        if (Set::member(ge2_ns, n))
          possible_results = rnew(temp) List(List::append(cns,new List(n,ns)),
                                             possible_results);
      }
      // Check current namespace
      if (Set::member(ge_ns, n))
        possible_results = rnew(temp) List(List::append(cns,new List(n,ns)),
                                           possible_results);
      // Is this right? We check for ambiguity between the current namespace
      // and used namespaces in the current scope, but not outer namespaces.
      // Seems inconsistent.
      if (possible_results != NULL) {
        if (possible_results->tl != NULL)
          Tcutil::terr(loc,"%s is ambiguous",*(n));
        return possible_results->hd;
      }
      if (cns == NULL)
        throw new Dict::Absent;
      // n is not defined in current namespace, look in next outer
      cns = outer_namespace(cns);
    }
  }
}

// The absolute versions aren't being used right now, but it's
// important to think about whether they are correct in certain contexts.

static aggrdecl_t @ lookup_aggrdecl_f(genv_t ge,var_t v,bool ignore) {
  let ag = ge->aggrdecls;
  return Dict::lookup(ag,v);
}
aggrdecl_t @ lookup_aggrdecl(tenv_t te,seg_t loc,qvar_t q) {
  let &$(nsl,v) = q;
  switch (nsl) {
  case {.Loc_n = _}: fallthru;
  case {.Rel_n = NULL}:
    return scoped_lookup(te, loc, lookup_aggrdecl_f, v, false);
  case {.C_n = y}: fallthru(y);
  case {.Abs_n = y}:
    let ads = Dict::lookup(te->ae,y)->aggrdecls;
    return Dict::lookup(ads,v);
  case {.Rel_n = &List(x,y)}:
    let ads = lookup_namespace(te,loc,x,y)->aggrdecls;
    return Dict::lookup(ads,v);
  }
}

static datatypedecl_t @ lookup_datatypedecl_f(genv_t ge,var_t v,bool ignore) {
  let tds = ge->datatypedecls;
  return Dict::lookup(tds,v);
}
datatypedecl_t @ lookup_datatypedecl(tenv_t te,seg_t loc,qvar_t q) {
  let &$(nsl,v) = q;
  switch (nsl) {
  case {.Loc_n = _}: fallthru;
  case {.Rel_n = NULL}:
    return scoped_lookup(te, loc, lookup_datatypedecl_f, v, false);
  case {.Rel_n = &List(x,y)}:
    let tds = lookup_namespace(te,loc,x,y)->datatypedecls;
    return Dict::lookup(tds,v);
  case {.C_n = y}: fallthru(y);
  case {.Abs_n = y}:
    let tds = Dict::lookup(te->ae,y)->datatypedecls;
    return Dict::lookup(tds,v);
  }
}

static datatypedecl_t @ lookup_xdatatypedecl_f(genv_t ge,var_t v,bool ignore) {
  return Dict::lookup(ge->datatypedecls,v);
}

// DAN: some functionality from tcXDatatypedecl has moved to here.
datatypedecl_t@*`r lookup_xdatatypedecl(region_t<`r> r, tenv_t te,seg_t loc,qvar_t q) {
  let &$(nsl,v) = q;
  switch (nsl) {
  case {.Rel_n = NULL}:
    // unqualified name, okay to fail -- that just means we have a new xdatatype
    try return rnew(r) scoped_lookup(te, loc, lookup_xdatatypedecl_f, v,false);
    catch { case &Dict::Absent: return NULL; }
  case {.Loc_n = _}: // impossible case
    Tcutil::impos("lookup_xdatatypedecl: impossible");
    return NULL;
  case {.Rel_n = &List(x,y)}:
    // qualified name, it's an error if the namespace is bad or the
    // xdatatype doesn't already exist.  In either case, we'll raise
    // Dict::Absent, so we give a more descriptive message for the
    // former.
    genv_t ge;
    try ge = lookup_namespace(te,loc,x,y);
    catch {
    case &Dict::Absent:
      Tcutil::terr(loc,"bad qualified name for @extensible datatype");
      throw new Dict::Absent;
    }
    let tds = ge->datatypedecls;
    return rnew(r) Dict::lookup(tds,v);
  case {.C_n = y}: fallthru(y);
  case {.Abs_n = y}:
    let tds = Dict::lookup(te->ae,y)->datatypedecls;
    return rnew(r) Dict::lookup(tds,v);
  }
}

static enumdecl_t @lookup_enumdecl_f(genv_t ge, var_t v,bool ignore) {
  let eds = ge->enumdecls;
  return Dict::lookup(eds,v);
}
enumdecl_t @lookup_enumdecl(tenv_t te, seg_t loc, qvar_t q) {
  let &$(nsl,v) = q;
  switch (nsl) {
  case {.Loc_n = _}:
  case {.Rel_n = NULL}:
    return scoped_lookup(te, loc, lookup_enumdecl_f, v, false);
  case {.Rel_n = &List(x,y)}:
    let eds = lookup_namespace(te,loc,x,y)->enumdecls;
    return Dict::lookup(eds,v);
  case {.C_n = y}: fallthru(y);
  case {.Abs_n = y}:
    let eds = Dict::lookup(te->ae,y)->enumdecls;
    return Dict::lookup(eds,v);
  }
}

static typedefdecl_t lookup_typedefdecl_f(genv_t ge,var_t v,bool ignore) {
  let tds = ge->typedefs;
  return Dict::lookup(tds,v);
}
typedefdecl_t lookup_typedefdecl(tenv_t te, seg_t loc, qvar_t q) {
  let &$(nsl,v) = q;
  switch (nsl) {
  case {.Loc_n = _}:
  case {.Rel_n = NULL}:
    return scoped_lookup(te, loc, lookup_typedefdecl_f, v, false);
  case {.Rel_n = &List(x,y)}:
    let tds = lookup_namespace(te,loc,x,y)->typedefs;
    return Dict::lookup(tds,v);
  case {.C_n = y}: fallthru(y);
  case {.Abs_n = y}:
    let tds = Dict::lookup(te->ae,y)->typedefs;
    return Dict::lookup(tds,v);
  }
}

//////////////////// Function Environment Manipulation //////////////////////

static fenv_t<`r> get_fenv(tenv_t<`g,`r> te, const char ?err_msg) {
  let le = te->le;
  if (le == NULL) env_err(err_msg);
  return (fenv_t)le;
}

region_t<`r> get_fnrgn(tenv_t<`g,`r> te) {
  let le = te->le;
  if (le != NULL) {
    let &Fenv{<`f,`c> .fnrgn=f,...} = (fenv_t)le;
    return f;
  }
  return (region_t<`r>)Core::heap_region;
}

static tenv_t<`g,`l> put_fenv(region_t<`l> l, tenv_t<`g,`l2> te, fenv_t<`l> fe) {
  if (te->le == NULL) env_err("put_fenv");
  return rnew(l) Tenv(te->ns, te->ae, fe, te->allow_valueof, te->in_extern_c_include);
}

static tenv_t<`g,`l> put_emptyfenv(region_t<`l> l,tenv_t<`g,`l2> te) {
  return rnew(l) Tenv(te->ns, te->ae, NULL, te->allow_valueof, te->in_extern_c_include);
}

static fenv_t<`l> copy_fenv_old_ctrl(region_t<`l> l, fenv_t<`l2> f : {`l2}>`l)
{
  let Fenv{<`f,`c> shared,type_vars,region_order,locals,encloser,ctrl_env,
              capability,curr_rgn,flags,frgn} = *f;
  return rnew(l) Fenv{shared,type_vars,region_order,(bnds_t<`l>)locals,
                        encloser,ctrl_env,capability,curr_rgn,flags,l};

}
static fenv_t<`l> copy_fenv_new_ctrl(region_t<`l> l, fenv_t<`l2> f : {`l2}>`l)
{
  let Fenv{<`f,`c> shared,type_vars,region_order,locals,encloser,ctrl_env,
              capability,curr_rgn,flags,_} = *f;
  // WARNING: fallthru_clause shared with old
  let CtrlEnv{fallthru_clause} = *ctrl_env;
  let new_ctrl_env =
    rnew(l) CtrlEnv{fallthru_clause};
  return rnew(l) Fenv{shared,type_vars,region_order,(bnds_t<`l>)locals,
                      encloser,new_ctrl_env,capability,curr_rgn,
                      flags,l};
}


type_t return_typ(tenv_t te) {
  let &Fenv{<`f,`c> .shared = s,...} = get_fenv(te,"return_typ");
  let SharedFenv{.return_typ = rt, ...} = *s;
  return rt;
}

list_t<tvar_t> lookup_type_vars(tenv_t te) {
  let le = te->le;
  if(te->le == NULL) return NULL;
  let Fenv{<`f,`c> .type_vars = ts,...} = *le;
  return ts;
}

opt_t<list_t<tvar_t>> lookup_opt_type_vars(tenv_t te) {
  return new Opt(lookup_type_vars(te));
}

tenv_t<`g,`r> add_type_vars(region_t<`r> r, seg_t loc,tenv_t<`g,`r2> te,
                            list_t<tvar_t> tvs : {`r2} > `r) {
  let &Fenv{<`f,`c> shared,type_vars,region_order,locals,encloser,ctrl_env,
              capability,curr_rgn,flags,_} =
    get_fenv(te,"add_type_vars");

  add_tvar_identities(tvs);
  let new_tvs = List::append(tvs,type_vars);
  Tcutil::check_unique_tvars(loc,new_tvs);
  let fe = rnew(r) Fenv(shared,new_tvs,region_order,(bnds_t<`r>)locals,
                        encloser,ctrl_env,capability,curr_rgn,flags,r);
  return put_fenv(r,te,fe);
}

tenv_t<`g,`r> copy_tenv(region_t<`r> r, tenv_t<`g,`r2> te : {`r2} > `r) {
  let le = te->le;
  if (le == NULL) {
    return put_emptyfenv(r,te);
  } else {
    fenv_t<`r> fe = copy_fenv_old_ctrl(r, le);
    return put_fenv(r,te,fe);
  }
}

tenv_t<`g,`r> add_local_var(region_t<`r> r, seg_t loc, tenv_t<`g,`r2> te, vardecl_t vd : {`r2} > `r) {
  //let fe = copy_fenv_old_ctrl(r,get_fenv(te,"add_local_var"));
  let v  = (*vd->name)[1];
  switch ((*vd->name)[0]) {
  case {.Loc_n = _}: break;
  default:
    // This is a fail-safe. Maybe we should just clobber with Loc_n?
    throw new Impossible("add_local_var: called with Rel_n");
  }
  if (Tcenv::warn_override)
    try {
      switch(lookup_ordinary(r,te,loc,vd->name,true))
      {
      case &VarRes(&Local_b(_)):  Tcutil::warn(loc,"declaration hides local"); break;
      case &VarRes(&Global_b(_)): Tcutil::warn(loc,"declaration hides global"); break;
      case &VarRes(&Pat_b(_)):    Tcutil::warn(loc,"declaration hides pattern variable"); break;
      case &VarRes(&Param_b(_)):  Tcutil::warn(loc,"declaration hides parameter"); break;
      default: break;
      }
    } catch { case &Dict::Absent: break; }
  let &Fenv{<`f,`c> shared,type_vars,region_order,locals,encloser,ctrl_env,
              capability,curr_rgn,flags,_} =
    get_fenv(te,"add_local_var");
  let b = new Local_b(vd);
  let new_locals = rnew(r) Bindings{v,b,(bnds_t<`r>)locals};
  let fe = rnew(r) Fenv(shared,type_vars,region_order,new_locals,
                        encloser,ctrl_env,capability,curr_rgn,flags,r);
  return put_fenv(r,te,fe);
}

tenv_t<`g,`r> set_new_status(region_t<`r> r,enum NewStatus status,
			     tenv_t<`g,`r2> te : {`r2}>`r){
  let le = te->le;
  if(le == NULL) return put_emptyfenv(r,te);
  let Fenv{<`f,`c> shared,type_vars,region_order,locals,encloser,ctrl_env,
              capability,curr_rgn,
	      FenvFlags{in_notreadctxt,lhs,_,absok},_} = *le;
  let fe = rnew(r) Fenv(shared,type_vars,region_order,(bnds_t<`r>)locals,
                        encloser,ctrl_env,capability,curr_rgn,
			FenvFlags{in_notreadctxt,lhs,status,absok},r);
  return put_fenv(r,te,fe);
}

enum NewStatus new_status(tenv_t te) {
  let le = te->le;
  if (le == NULL) return NoneNew;
  let &Fenv{<`f,`c> .flags=FenvFlags{.in_new = inn,...},...} = (fenv_t)le;
  return inn;
}

bool abstract_val_ok(tenv_t te) {
  let le = te->le;
  if (le == NULL) return false;
  let &Fenv{<`f,`c> .flags=FenvFlags{.abstract_ok = aok,...},...} = (fenv_t)le;
  return aok;
}

tenv_t<`g,`r> enter_abstract_val_ok(region_t<`r> r,
				    tenv_t<`g,`r2> te : {`r2}>`r){
  let le = te->le;
  if(le == NULL) return put_emptyfenv(r,te);
  let Fenv{<`f,`c> shared,type_vars,region_order,locals,encloser,ctrl_env,
              capability,curr_rgn,
	      FenvFlags{in_notreadctxt,lhs,innew,_},_} = *le;
  let fe = rnew(r) Fenv(shared,type_vars,region_order,(bnds_t<`r>)locals,
                        encloser,ctrl_env,capability,curr_rgn,
			FenvFlags{in_notreadctxt,lhs,innew,true},r);
  return put_fenv(r,te,fe);
}

tenv_t<`g,`r> clear_abstract_val_ok(region_t<`r> r,
				    tenv_t<`g,`r2> te : {`r2}>`r){
  let le = te->le;
  if(le == NULL) return put_emptyfenv(r,te);
  let Fenv{<`f,`c> shared,type_vars,region_order,locals,encloser,ctrl_env,
              capability,curr_rgn,
	      FenvFlags{in_notreadctxt,lhs,innew,_},_} = *le;
  let fe = rnew(r) Fenv(shared,type_vars,region_order,(bnds_t<`r>)locals,
                        encloser,ctrl_env,capability,curr_rgn,
			FenvFlags{in_notreadctxt,lhs,innew,false},r);
  return put_fenv(r,te,fe);
}

tenv_t<`g,`r> enter_notreadctxt(region_t<`r> r,tenv_t<`g,`r2> te : {`r2}>`r){
  let le = te->le;
  if(le == NULL) return put_emptyfenv(r,te);
  let Fenv{<`f,`c> shared,type_vars,region_order,locals,encloser,ctrl_env,
              capability,curr_rgn,
	      FenvFlags{_,lhs,innew,absok},_} = *le;
  let fe = rnew(r) Fenv(shared,type_vars,region_order,(bnds_t<`r>)locals,
                        encloser,ctrl_env,capability,curr_rgn,
			FenvFlags{true,lhs,innew,absok},r);
  return put_fenv(r,te,fe);
}

tenv_t<`g,`r> clear_notreadctxt(region_t<`r> r,tenv_t<`g,`r2> te : {`r2}>`r) {
  let le = te->le;
  if(le == NULL) return put_emptyfenv(r,te);
  let Fenv{<`f,`c> shared,type_vars,region_order,locals,encloser,ctrl_env,
              capability,curr_rgn,
	      FenvFlags{_,lhs,innew,absok},_} = *le;
  let fe = rnew(r) Fenv(shared,type_vars,region_order,(bnds_t<`r>)locals,
                        encloser,ctrl_env,capability,curr_rgn,
			FenvFlags{false,lhs,innew,absok},r);
  return put_fenv(r,te,fe);
}

bool in_notreadctxt(tenv_t te) {
  let le = te->le;
  if (le == NULL) return false;
  let &Fenv{<`f,`c> .flags=FenvFlags{.in_notreadctxt = nr,...},...}=(fenv_t)le;
  return nr;
}

tenv_t<`g,`r> enter_lhs(region_t<`r> r,tenv_t<`g,`r2> te : {`r2}>`r){
  let le = te->le;
  if(le == NULL) return put_emptyfenv(r,te);
  let Fenv{<`f,`c> shared,type_vars,region_order,locals,encloser,ctrl_env,
              capability,curr_rgn,
	      FenvFlags{in_notreadctxt,_,innew,absok},_} = *le;
  let fe = rnew(r) Fenv(shared,type_vars,region_order,(bnds_t<`r>)locals,
                        encloser,ctrl_env,capability,curr_rgn,
			FenvFlags{in_notreadctxt,true,innew,absok},r);
  return put_fenv(r,te,fe);
}

tenv_t<`g,`r> clear_lhs(region_t<`r> r,tenv_t<`g,`r2> te : {`r2}>`r) {
  let le = te->le;
  if(le == NULL) return put_emptyfenv(r,te);
  let Fenv{<`f,`c> shared,type_vars,region_order,locals,encloser,ctrl_env,
              capability,curr_rgn,
	      FenvFlags{in_notreadctxt,_,innew,absok},_} = *le;
  let fe = rnew(r) Fenv(shared,type_vars,region_order,(bnds_t<`r>)locals,
                        encloser,ctrl_env,capability,curr_rgn,
			FenvFlags{in_notreadctxt,false,innew,absok},r);
  return put_fenv(r,te,fe);
}

bool in_lhs(tenv_t te) {
  let le = te->le;
  if (le == NULL) return false;
  let &Fenv{<`f,`c> .flags=FenvFlags{.in_lhs = lhs,...},...} = (fenv_t)le;
  return lhs;
}

// assume uniqueness has been checked elsewhere
tenv_t<`g,`r> add_pat_var(region_t<`r> r, seg_t loc, tenv_t<`g,`r2> te,
                          vardecl_t vd : {`r2} > `r) {
  if (Tcenv::warn_override)
    try {
      switch(lookup_ordinary(r,te,loc,vd->name,true)) {
      case &VarRes(&Local_b(_)):  
	Tcutil::warn(loc,"pattern variable hides local"); break;
      case &VarRes(&Global_b(_)): 
	Tcutil::warn(loc,"pattern variable hides global"); break;
      case &VarRes(&Pat_b(_)):    
	Tcutil::warn(loc,"pattern variable hides pattern variable"); break;
      case &VarRes(&Param_b(_)):  
	Tcutil::warn(loc,"pattern variable hides parameter"); break;
      default: break;
      }
    } catch { case &Dict::Absent: break; }
  let v  = (*vd->name)[1];
  let &Fenv{<`f,`c> shared,type_vars,region_order,locals,encloser,ctrl_env,
	      capability,curr_rgn,flags,_} =
    get_fenv(te,"add_pat_var");
  let b = new Pat_b(vd);
  let new_locals = rnew(r) Bindings{v,b,(bnds_t<`r>)locals};
  let fe = rnew(r) Fenv(shared,type_vars,region_order,new_locals,
                        encloser,ctrl_env,capability,curr_rgn,flags,r);
  return put_fenv(r,te,fe);
}

resolved_t<`r> lookup_ordinary(region_t<`r> r, tenv_t te,seg_t loc,qvar_t q,bool is_use) {
  let le = te->le;
  let &$(nsl,v) = q;
  switch (nsl) {
  case {.Loc_n = _}:
    if (le == NULL) throw new Dict::Absent;
    fallthru;
  case {.Rel_n = NULL} && le != NULL:
    let &Fenv{<`f,`c> .locals = locals,...} = (fenv_t)le;
    // NB a local overrides any global, without an ambiguity warning
    try {
      return rnew(r) VarRes(lookup_binding(locals,v));
    } catch {case &NoBinding: return lookup_ordinary_global(te,loc,q,is_use);}
  default:
    try return lookup_ordinary_global(te,loc,q,is_use);
    catch {case &Dict::Absent:
      // Print out the error message elsewhere.
      // terr(loc,"unbound identifier: %s", Absynpp::qvar2string(q));
      return rnew(r) VarRes(&Unresolved_b_val);
    }
  }
}

// do not stop setting clauseopt -- JumpAnalysis needs it!
$(switch_clause_t,list_t<tvar_t>,clist_t<type_t,`r>)const*`r const
process_fallthru(tenv_t<`g,`r> te,stmt_t s, switch_clause_t *@ clauseopt){
  let &Fenv{<`f,`c> .ctrl_env=ctrl_env,...} = get_fenv(te,"process_fallthru");
  let ans = ($(_,_,clist_t<_,`r>)const *`r)ctrl_env->fallthru_clause;
  if(ans != NULL) {
    *clauseopt = new (*ans)[0];
  }
  return ans;
}

tenv_t<`g,`r> set_fallthru(region_t<`r> r, tenv_t<`g,`r2> te,
                           list_t<tvar_t,`H> new_tvs,
                           list_t<vardecl_t> vds,
                           switch_clause_t clause : {`r2} > `r) {
  let &Fenv{<`f,`c> shared,type_vars,region_order,locals,encloser,ctrl_env,
              capability,curr_rgn,flags,_} =
    get_fenv(te,"set_fallthru");
  let &CtrlEnv{fc} = ctrl_env;
  list_t<type_t,`c> ft_typ = NULL;
  for(; vds!=NULL; vds=vds->tl)
    ft_typ = new List(vds->hd->type,ft_typ);
  let cft_typ = List::imp_rev(ft_typ);
  let new_ctrl_env =
    rnew(r) CtrlEnv{new $(clause,new_tvs,cft_typ)};
  let new_fe = rnew(r) Fenv{shared,type_vars,region_order,
                            (bnds_t<`r>)locals,
                            encloser,new_ctrl_env,capability,curr_rgn,
                            flags,r};
  return put_fenv(r,te,new_fe);
}
// fallthru is illegal in the last case
tenv_t<`g,`r> clear_fallthru(region_t<`r> r, tenv_t<`g,`r2> te : {`r2} > `r) {
  fenv_t fe = copy_fenv_new_ctrl(r,get_fenv(te,"clear_fallthru"));
  let &Fenv{<`f,`c> .ctrl_env = ctrl_env,...} = fe;
  ctrl_env->fallthru_clause = NULL;
  return put_fenv(r,te,fe);
}

stmt_t get_encloser(tenv_t te) {
  let &Fenv{<`f,`c> .encloser = encloser, ...} = get_fenv(te,"get_encloser");
  return encloser;
}

tenv_t<`g,`r2> allow_valueof(region_t<`r2> r2, tenv_t<`g,`r> te : {`r} > `r2) {
  if (te->le == NULL)
    return rnew(r2) Tenv(te->ns, te->ae, NULL, true,te->in_extern_c_include);
  let Fenv{<`f,`c> s,t,r,l,e,ce,cp,cr,flags,_} = *te->le;
  let fe = rnew(r2) Fenv{s,t,r,(bnds_t<`r2>)l,e,ce,cp,cr,flags,r2};
  return rnew(r2) Tenv(te->ns, te->ae, fe, true,te->in_extern_c_include);
}

tenv_t<`g,`r2> enter_extern_c_include(region_t<`r2> r2, tenv_t<`g,`r> te : {`r} > `r2) {
  if (te->le == NULL)
    return rnew(r2) Tenv(te->ns, te->ae, NULL, te->allow_valueof, true);
  let Fenv{<`f,`c> s,t,r,l,e,ce,cp,cr,flags,_} = *te->le;
  let fe = rnew(r2) Fenv{s,t,r,(bnds_t<`r2>)l,e,ce,cp,cr,flags,r2};
  return rnew(r2) Tenv(te->ns, te->ae, fe, te->allow_valueof, true);
}

tenv_t<`g,`r> set_encloser(region_t<`r> r, tenv_t<`g,`r2> te, stmt_t s :
                           {`r2} > `r) {
  let Fenv{<`f,`c> shared,type_vars,region_order,locals,encloser,ctrl_env,
              capability,curr_rgn,flags,_} =
    *get_fenv(te,"set_encloser");
  let fe =
    rnew(r) Fenv{shared,type_vars,region_order,(bnds_t<`r>)locals,
                 s,ctrl_env,capability,curr_rgn,flags,r};
  return put_fenv(r,te,fe);
}

tenv_t<`g,`r> add_region(region_t<`r> r, tenv_t<`g,`r2> te, type_t rgn,
                         bool resetable, bool opened : {`r2} > `r) {

  let Fenv{<`f,`c> shared,type_vars,region_order,locals,encloser,ctrl_env,
              capability,curr_rgn,flags,_} =
    *get_fenv(te,"add_region");
  switch (compress(rgn)) {
  case &VarType(x): 
    region_order = add_youngest(shared->frgn, region_order, x, 
                                resetable, opened);
    break;
  default: break;
  }
  capability = new JoinEff(new List(new AccessEff(rgn),
                                    new List(capability,NULL)));
  let fe =
    rnew(r) Fenv{shared,type_vars,region_order,(bnds_t<`r>)locals,
                 encloser,ctrl_env,capability,curr_rgn,flags,r};
  return put_fenv(r,te,fe);
}

tenv_t<`g,`r> new_named_block(region_t<`r> r, seg_t loc, tenv_t<`g,`r2> te,
                              tvar_t block_rgn : {`r2} > `r) {
  let Fenv{<`f,`c> shared,type_vars,region_order,locals,encloser,ctrl_env,
              capability,curr_rgn,flags,_} =
    *get_fenv(te,"new_named_block");

  fenv_t fe = copy_fenv_old_ctrl(r,get_fenv(te,"new_block"));
  type_t block_typ = new VarType(block_rgn);
  type_vars = new List(block_rgn, type_vars);
  Tcutil::check_unique_tvars(loc, type_vars);
  region_order = add_youngest(shared->frgn, region_order, block_rgn, false, false);
  capability = new JoinEff(new List(new AccessEff(block_typ), new List(capability,NULL)));
  curr_rgn = block_typ;
  let fe =
    rnew(r) Fenv{shared,type_vars,region_order,(bnds_t<`r>)locals,
                 encloser,ctrl_env,capability,curr_rgn,flags,r};
  return put_fenv(r,te,fe);
}

static datatype KindBound.Eq_kb rgn_kb = Eq_kb(&Tcutil::rk);

tenv_t<`g,`r> new_block(region_t<`r> r, seg_t loc, tenv_t<`g,`r2> te
                        : {`r2} > `r) {
  tvar_t t = new_tvar(&rgn_kb);
  add_tvar_identity(t);
  return new_named_block(r, loc, te, t);
}


tenv_t<`g,`r> new_outlives_constraints(region_t<`r> r, tenv_t<`g,`r2> te,
                                       list_t<$(type_t,type_t)@> cs,
				       seg_t loc
                                       : {`r2} > `r) {
  let Fenv{<`f,`c> shared,type_vars,region_order,locals,encloser,ctrl_env,
              capability,curr_rgn,flags,_} =
    *get_fenv(te,"new_outlives_constraints");
  for(; cs != NULL; cs = cs->tl)
    region_order =
      add_outlives_constraint(shared->frgn,
                              region_order,(*cs->hd)[0],(*cs->hd)[1],
			      loc);
  let fe =
    rnew(r) Fenv{shared,type_vars,region_order,(bnds_t<`r>)locals,
                 encloser,ctrl_env,capability,curr_rgn,flags,r};
  return put_fenv(r,te,fe);
}

tenv_t<`g,`r> add_region_equality(region_t<`r> r, tenv_t<`g,`r2> te,
				  type_t r1, type_t r2,
				  $(tvar_t,kindbound_t) *`r @oldtv,
				  seg_t loc
				  : {`r2} > `r) {

  // we add outlives constraints and also refine the kind of
  // the type variable
  let r1 = compress(r1);
  let r2 = compress(r2);
  let r1k = typ_kind(r1);
  let r2k = typ_kind(r2);

  // first do kind refinement
  bool r1_le_r2 = kind_leq(r1k,r2k);
  bool r2_le_r1 = kind_leq(r2k,r1k);
  if (!r1_le_r2 && !r2_le_r1) {
    terr(loc,"Cannot compare region handles for %s and %s\n  kinds %s and %s are not compatible\n",
	 typ2string(r1),typ2string(r2),kind2string(r1k),kind2string(r2k));
    return new_outlives_constraints(r,te,NULL,loc);
  }
  else if (r1_le_r2 && !r2_le_r1) {
    let $(tv,kb) = swap_kind(r2,kind_to_bound(r1k));
    *oldtv = rnew (r) $(tv,kb);
  }
  else if (!r1_le_r2 && r2_le_r1) {
    let $(tv,kb) = swap_kind(r1,kind_to_bound(r2k));
    *oldtv = rnew (r) $(tv,kb);
  }

  // now update the outlives constraints
  let r = Tcenv::get_fnrgn(te);
  let bds = NULL;
  if (r1 != &HeapRgn_val && r1 != &UniqueRgn_val && r1 != &RefCntRgn_val) {
    type_t eff1 = new AccessEff(r1);
    bds = rnew (r) List::List(rnew (r) $(eff1,r2),bds);
  }
  if (r2 != &HeapRgn_val && r2 != &UniqueRgn_val && r2 != &RefCntRgn_val) {
    type_t eff2 = new AccessEff(r2);
    bds = rnew (r) List::List(rnew (r) $(eff2,r1),bds);
  }

  return new_outlives_constraints((region_t<`r>)r,te,bds,loc);
}

type_t curr_rgn(tenv_t te) {
  let le = te->le;
  if (le == NULL) return &HeapRgn_val;
  fenv_t fe = le;
  let &Fenv{<`f,`c> .curr_rgn = c, ...} = fe;
  return c;
}

// Check that rgn_typ is currently accessible:  the heap region is always
// accessible, and a region variable r is accessible if it appears in the
// capability or outlives something in the capability.
void check_rgn_accessible(tenv_t te, seg_t loc, type_t rgn) {
  fenv_t fe = get_fenv(te,"check_rgn_accessible");
  let &Fenv{<`f,`c> .capability = capability, .region_order = ro, ...} = fe;
  if (region_in_effect(false, rgn, capability) ||
      region_in_effect(true, rgn, capability))
    return;
  if(eff_outlives_eff(ro,new AccessEff(rgn),capability))
    return;
  terr(loc, "Expression accesses unavailable region %s", typ2string(rgn));
}

// Check to see if a region is accessible and resetable
void check_rgn_resetable(tenv_t te, seg_t loc, type_t rgn) {
  check_rgn_accessible(te,loc,rgn);
  let &Fenv{<`f,`c> .region_order = ro, ...} =
    get_fenv(te,"check_rgn_resetable");
  switch (compress(rgn)) {
  case &VarType(r):
    if(!RgnOrder::is_region_resetable(ro,r))
      terr(loc, "Region %s is not resetable", typ2string(rgn));
    return;
  default: impos("check_rgn_resetable");
  }
}

// check that region rt_a outlives region rt_b using the partial order in
// the environment.  Assumes that rt_a <> rt_b.
// Note: inefficient allocation here!
bool region_outlives(tenv_t te, type_t rt_a, type_t rt_b) {
  let le = te->le;
  rt_a = compress(rt_a);
  rt_b = compress(rt_b);
  // When typechecking a toplevel declaration:
  if(le==NULL)
    switch (rt_a) {
    case &RefCntRgn: return rt_b != &UniqueRgn_val;
    case &UniqueRgn: return rt_b != &RefCntRgn_val;
    case &HeapRgn: return rt_b == &HeapRgn_val;
    default: return false;
    }
  // When typechecking a function body:
  fenv_t fe = le;
  let &Fenv{<`f,`c> .region_order = ro, ...} = fe;
  let res = effect_outlives(ro,new AccessEff(rt_a),rt_b);
//    fprintf(stderr,"region_outlives: %s outlves %s = %s\n",
//  	  typ2string(rt_a),typ2string(rt_b),res ? "true" : "false");
//    print_region_po(ro);
  return res;
}

// Check that a function call's effect is contained in the current capability.
// Do not constrain evars -- delay the check instead.
void check_effect_accessible(tenv_t te, seg_t loc, type_t eff) {
  let &Fenv{<`f,`c> .capability = capability, .region_order = ro,
               .shared = shared, ...} = get_fenv(te,"check_effect_accessible");
  if(subset_effect(false, eff, capability))
    return;
  if(eff_outlives_eff(ro, eff, capability))
    return;
  region_t<`f> frgn = shared->frgn;
  shared->delayed_effect_checks =
    rnew(frgn) List(rnew(frgn) $(capability,eff,ro,loc),
                    shared->delayed_effect_checks);
}
void check_delayed_effects(tenv_t te) {
  let &Fenv{<`f,`c> .shared = shared, ...} =
    get_fenv(te,"check_delayed_effects");
  let checks = shared->delayed_effect_checks;
  for(; checks != NULL; checks = checks->tl) {
    let &$(capability,eff,rgn_order,loc) = checks->hd;
    if(subset_effect(true, eff, capability))
      continue;
    if(eff_outlives_eff(rgn_order, eff, capability))
      continue;
    terr(loc, "Capability \n%s\ndoes not cover function's effect\n%s",
       typ2string(capability), typ2string(eff));
  }
}

// Check that a function call's region partial order is compatible
// with the current region partial order
// Do not constrain evars -- delay the check instead.
// FIX: better error message!
void check_rgn_partial_order(tenv_t te, seg_t loc,
                             list_t<$(type_t,type_t)@`H,`H> po) {
  let le = te->le;
  if(le == NULL) {
    // not sure this could ever fail
    for(; po != NULL; po=po->tl)
      if((!subset_effect(true, (*po->hd)[0], empty_effect))
	 || !subset_effect(true, new AccessEff((*po->hd)[1]), empty_effect))
	terr(loc,"the required region ordering is not satisfied here");
    return;
  }
  let &Fenv{<`f,`c> .region_order = ro, .shared = shared, ...} = (fenv_t)le;
  if(!satisfies_constraints(ro,po,&HeapRgn_val,false))
    shared->delayed_constraint_checks =
      rnew(shared->frgn) List(rnew(shared->frgn) $(ro,po,loc),
                              shared->delayed_constraint_checks);
}

void check_delayed_constraints(tenv_t te) {
  let &Fenv{<`f,`c> .shared = shared,...} =
    get_fenv(te,"check_delayed_constraints");
  let checks = shared->delayed_constraint_checks;
  for(; checks != NULL; checks = checks->tl) {
    let &$(rgn_order,po,loc) = checks->hd;
    if(!satisfies_constraints(rgn_order,po,&HeapRgn_val,true))
      terr(loc,"the required region ordering is not satisfied here");
  }
}

fenv_t<`r> new_fenv(region_t<`r> r, seg_t loc, fndecl_t fd) {
  bnds_t<`r> locals = NULL;
  tvar_t rgn0 =
    new Tvar(new ((string_t)aprintf("`%s",*(*fd->name)[1])),
             new_tvar_id(), &rgn_kb);
  let tvs = new List(rgn0,fd->tvs);
  Tcutil::check_unique_tvars(loc,tvs);
//   fprintf(stderr,"checking fn %s\n",qvar2string(fd->name));
  let rgn_po = initial_fn_po(r, fd->tvs,fd->rgn_po,
                             (type_t)fd->effect,rgn0,loc);
  type_t param_rgn = new VarType(rgn0);
  let vds = NULL;
  for(let args = fd->args; args != NULL; args = args->tl) {
    let vd = new{Vardecl{.sc = Public,
			 .name = new $((nmspace_t)Loc_n,(*args->hd)[0]),
			 .tq = (*args->hd)[1],
			 .type = (*args->hd)[2],
			 .initializer = NULL,
                         .rgn = param_rgn,
                         .attributes = NULL, .escapes = false}};
    vds = new{List(vd, vds)};
    let b = new Param_b(vd);
    let var = (*args->hd)[0];
    locals = rnew(r) Bindings{var, b, locals};
  }
  if (fd->cyc_varargs != NULL) {
    let VarargInfo{nopt,tq,t,i} = *fd->cyc_varargs;
    if (nopt != NULL) {
      let typ = dyneither_typ(t, param_rgn, tq, false_conref);
      let vd = new{Vardecl{.sc = Public,
                           .name = new $((nmspace_t)Loc_n,(var_t)nopt),
                           .tq = empty_tqual(0),
                           .type = typ,
                           .initializer = NULL,
                           .rgn = param_rgn,
                           .attributes = NULL, .escapes = false}};
      vds = new List(vd,vds);
      let b = new Param_b(vd);
      let var = (var_t)nopt;
      locals = rnew(r) Bindings{var, b, locals};
    }
    else terr(loc,"missing name for varargs");
  }
  fd->param_vardecls = new{Opt(imp_rev(vds))};
  return rnew(r)
    Fenv{.shared = rnew(r) SharedFenv{
                     .frgn = r,
                     .return_typ = fd->ret_type,
		     .delayed_effect_checks = NULL,
		     .delayed_constraint_checks = NULL
                   },
         .type_vars   = tvs,
         .region_order = rgn_po,
         .locals      = locals,  // assumed unique
         .encloser    = fd->body, // careful -- self loop at top!!!
         .ctrl_env    = rnew(r) CtrlEnv(NULL),
         .capability  = new JoinEff(new List(new AccessEff(param_rgn),
                                             new List((type_t)fd->effect,NULL))),
         .curr_rgn    = param_rgn,
	 .flags       = FenvFlags{false,false,false,false},
         .fnrgn       = r
       };
}

fenv_t<`r> bogus_fenv(region_t<`r> r, type_t ret_type,
                      list_t<$(var_opt_t,tqual_t,type_t)@> args) {
  
  bnds_t<`r> locals = NULL;
  tvar_t rgn0 = new Tvar(new "bogus", new_tvar_id(), &rgn_kb);
  let tvs = new List(rgn0,NULL);
  let rgn_po = initial_fn_po(r,NULL,NULL,new JoinEff(NULL),rgn0,0);
  type_t param_rgn = new VarType(rgn0);
  let vds = NULL;
  for(; args != NULL; args = args->tl) {
    let $(vopt,tq,t) = *args->hd;
    if (vopt != NULL) {
      let vd = new{Vardecl{.sc = Public,
                           .name = new $((nmspace_t)Loc_n,vopt),
                           .tq = tq,
                           .type = t,
                           .initializer = NULL,
                           .rgn = param_rgn,
                           .attributes = NULL, .escapes = false}};
      vds = new{List(vd, vds)};
      let b = new Param_b(vd);
      let var = vopt;
      locals = rnew(r) Bindings{var, b, locals};
    }
  }
  return rnew(r)
    Fenv{.shared = rnew(r) SharedFenv{
                     .frgn = r,
                     .return_typ = ret_type,
		     .delayed_effect_checks = NULL,
		     .delayed_constraint_checks = NULL
                   },
         .type_vars   = tvs,
         .region_order = rgn_po,
         .locals      = locals,  // assumed unique
         .encloser    = skip_stmt(0),
         .ctrl_env    = rnew(r) CtrlEnv(NULL),
         .capability  = new JoinEff(new List(new AccessEff(param_rgn),NULL)),
         .curr_rgn    = param_rgn,
	 .flags       = FenvFlags{false,false,false,false},
         .fnrgn       = r
       };
}

fenv_t<`r> nested_fenv(seg_t loc, fenv_t<`r> old_fenv, fndecl_t fd) {
  let &Fenv{<`f,`c> .locals = old_locals, .region_order = rgn_po,
               .type_vars = type_vars, .shared = shared, .fnrgn = fr, ...} = old_fenv;
  let r = shared->frgn;
  let locals = (bnds_t<`r>)old_locals;
  tvar_t rgn0 =
    new Tvar(new ((string_t)aprintf("`%s",*(*fd->name)[1])),
             new_tvar_id(), &rgn_kb);
  // add in all of the region vars
  for (let tvars = fd->tvs; tvars != NULL; tvars = tvars->tl) {
    let &Kind(k,a) = tvar_kind(tvars->hd,&bk);
    if (k == RgnKind)
      if (a == Aliasable)
	rgn_po = add_youngest(r, rgn_po, tvars->hd, false, false);
      else
	impos("non-intuitionistic tvar in nested_fenv");
  }
  rgn_po = add_youngest(r, rgn_po, rgn0, false, false);
  let tvs = new List(rgn0,List::append(fd->tvs,type_vars));
  Tcutil::check_unique_tvars(loc,tvs);
  type_t param_rgn = new VarType(rgn0);
  let vds = NULL;
  for(let args = fd->args; args != NULL; args = args->tl) {
    let vd = new{Vardecl{.sc = Public,
			 .name = new $((nmspace_t)Loc_n,(*args->hd)[0]),
			 .tq = (*args->hd)[1],
			 .type = (*args->hd)[2],
			 .initializer = NULL,
                         .rgn = param_rgn,
                         .attributes = NULL, .escapes = false}};
    vds = new{List(vd, vds)};
    let b = new Param_b(vd);
    let var = (*args->hd)[0];
    locals = rnew(r) Bindings{var, b, locals};
  }
  if (fd->cyc_varargs != NULL) {
    let VarargInfo{nopt,tq,t,i} = *fd->cyc_varargs;
    if (nopt != NULL) {
      let typ = dyneither_typ(t, param_rgn, tq, false_conref);
      let vd = new{Vardecl{.sc = Public,
                           .name = new $((nmspace_t)Loc_n,(var_t)nopt),
                           .tq = empty_tqual(0),
                           .type = typ,
                           .initializer = NULL,
                           .rgn = param_rgn,
                           .attributes = NULL, .escapes = false}};
      vds = new List(vd,vds);
      let var = (var_t)nopt;
      let b = new Param_b(vd);
      locals = rnew(r) Bindings{var, b, locals};
    }
    else terr(loc,"missing name for varargs");
  }
  fd->param_vardecls = new{Opt(imp_rev(vds))};
  return rnew(r)
    Fenv{.shared = rnew(r) SharedFenv{
                     .frgn = r,
                     .return_typ = fd->ret_type,
		     .delayed_effect_checks = NULL,
		     .delayed_constraint_checks = NULL
                   },
         .type_vars   = tvs,
         .region_order = rgn_po,
         .locals      = locals,  // assumed unique
         .encloser    = fd->body, // careful -- self loop at top!!!
         .ctrl_env    = rnew(r) CtrlEnv(NULL),
         .capability  = new JoinEff(new List(new AccessEff(param_rgn),
                                             new List((type_t)fd->effect,NULL))),
         .curr_rgn    = param_rgn,
	 .flags       = FenvFlags{false,false,false,false},
         .fnrgn       = fr
       };
}
