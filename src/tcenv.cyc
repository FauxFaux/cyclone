/* Type environments.
   Copyright (C) 2001 Greg Morrisett, AT&T
   This file is part of the Cyclone compiler.

   The Cyclone compiler is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   The Cyclone compiler is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with the Cyclone compiler; see the file COPYING. If not,
   write to the Free Software Foundation, Inc., 59 Temple Place -
   Suite 330, Boston, MA 02111-1307, USA. */

/* An identifier can have at most one binding in each of the following:
   1) namespaces (after "namespace" or "using")
   2) structure tags (after "struct")
   3) union tags (after "union")
   4) structure or union members (after "." or "->")
   5) datatype tags (after "datatype")
   7) labels (after "goto", before ":")
   8) typedef names (in types)
   9) ordinary identifiers (the catch-all case)

   The ordinary identifiers include structure tags and datatype constructors.

   The environment data structures below follow from this directly.
   Structure and union members must be resolved on a
   per-structure/per-union basis (e.g., two structs can have members
   with the same names) so their bindings don't belong in our environments.
*/
#include <string.h>
#include "absynpp.h"
#include "tcutil.h"
#include "rgnorder.h"
using Core;
using List;
using Absyn;
using Tcutil;
using Absynpp;
using RgnOrder;
namespace Tcenv;

datatype exn {Env_error};
datacon(exn,Env_error);

`a env_err(string_t msg) __attribute__((noreturn)) {
  throw &Env_error_val;
}

/////////////////////////// Type Definitions /////////////////////////////////

// Type environments
struct Tenv {
  list_t<var_t>  ns; // current namespace
  genv_t         ae; // absolute identifiers -- now 5 big dicts
  struct Fenv *  le; // local environment
  bool allow_valueof;     // controls whether we allow valueof(T) in an expr
  bool in_extern_c_include;
};

// Global environments -- what's declared in a global scope
struct Genv {
  Dict::dict_t<qvar_t,aggrdecl_t@> aggrdecls;
  Dict::dict_t<qvar_t,datatypedecl_t@> datatypedecls;
  Dict::dict_t<qvar_t,enumdecl_t@>   enumdecls;
  // no indirection b/c no redeclaration
  Dict::dict_t<qvar_t,typedefdecl_t> typedefs;
  // bool for tree-shaking, binding_t for interface.cyc (FIX)
  Dict::dict_t<qvar_t,$(binding_t,bool)@> ordinaries;
};

typedef $(switch_clause_t, list_t<tvar_t>, list_t<type_t,`r>) const *`r
ftclause_t<`r>;

// This part is shared throughout type-checking of a function.
// Hence mutations are seen by all subsequent type-checking, which is easier
// than threading labels which must be function-wide unique anyway.
static struct SharedFenv {
  type_t   return_typ;
  list_t<$(type_t,type_t,rgn_po_t,seg_t)@> delayed_effect_checks;
  list_t<$(rgn_po_t,list_t<$(type_t,type_t)@>,seg_t)@> delayed_constraint_checks;
};

// flags for local function environments
struct FenvFlags {
  bool in_notreadctxt; // true when in an exp that might read
  bool in_lhs;         // true when we're in a lhs exp
  bool in_new;         // true when we're in a new expression
  bool abstract_ok;    // true when an expression can be abstract
};

// Local function environments -- local variables are already bound
abstract struct Fenv {
  struct SharedFenv @ shared;
  list_t<tvar_t>      type_vars; //type variables that can occur free
  rgn_po_t            region_order; // partial order on region variables
  ftclause_t          ctrl_env;
  type_t              capability;
  type_t              curr_rgn;   // current block's region
  struct FenvFlags    flags;
};

//////////////////////// Top-level Environment Manipulation //////////////////
tenv_t tc_init() {
  // Set up initial environment so that datatype exn, etc. is defined
  let ae = new Genv{.aggrdecls     = Dict::empty(qvar_cmp),
		    .datatypedecls = Dict::empty(qvar_cmp),
		    .enumdecls     = Dict::empty(qvar_cmp),
		    .typedefs      = Dict::empty(qvar_cmp),
		    .ordinaries    = Dict::empty(qvar_cmp)};
  ae->datatypedecls = Dict::insert(ae->datatypedecls, exn_name, new exn_tud);
  return new Tenv(NULL,ae,NULL,false,false);
}
binding_t lookup_ordinary_global(tenv_t te,seg_t loc,qvar_t q,bool is_use) {
  let ans = Dict::lookup(te->ae->ordinaries, q);
  if(is_use)
    (*ans)[1] = true;
  return (*ans)[0];
}
aggrdecl_t @ lookup_aggrdecl(tenv_t te,seg_t loc,qvar_t q) {
  return Dict::lookup(te->ae->aggrdecls, q);
}
datatypedecl_t @ lookup_datatypedecl(tenv_t te,seg_t loc,qvar_t q) {
  return Dict::lookup(te->ae->datatypedecls, q);
}
datatypedecl_t@*`r lookup_xdatatypedecl(region_t<`r> r, tenv_t te,seg_t loc,qvar_t q) {
  return rnew(r) Dict::lookup(te->ae->datatypedecls, q);
}
enumdecl_t @lookup_enumdecl(tenv_t te, seg_t loc, qvar_t q) {
  return Dict::lookup(te->ae->enumdecls, q);
}
typedefdecl_t lookup_typedefdecl(tenv_t te, seg_t loc, qvar_t q) {
  return Dict::lookup(te->ae->typedefs, q);
}

//////////////////// Function Environment Manipulation //////////////////////

static fenv_t get_fenv(tenv_t te, const char ?err_msg) {
  let le = te->le;
  if (le == NULL) env_err(err_msg);
  return (fenv_t)le;
}

static tenv_t put_fenv(tenv_t te, fenv_t fe) {
  if (te->le == NULL) env_err("put_fenv"); // DJG: unnecessary but okay
  let ans = new *te;
  ans->le = fe;
  return ans;
}

static tenv_t put_emptyfenv(tenv_t te) {
  let ans = new *te;
  ans->le = NULL;
  return ans;
}

type_t return_typ(tenv_t te) {
  return get_fenv(te,"return_typ")->shared->return_typ;
}

list_t<tvar_t> lookup_type_vars(tenv_t te) {
  let le = te->le;
  if(te->le == NULL) return NULL;
  return le->type_vars;
}

opt_t<list_t<tvar_t>> lookup_opt_type_vars(tenv_t te) {
  return new Opt(lookup_type_vars(te));
}

tenv_t add_type_vars(seg_t loc,tenv_t te, list_t<tvar_t> tvs) {
  let fe = new *get_fenv(te,"add_type_vars");
  add_tvar_identities(tvs);
  let new_tvs = List::append(tvs,fe->type_vars);
  check_unique_tvars(loc,new_tvs); // DJG: wasteful, old were unique
  fe->type_vars = new_tvs;
  return put_fenv(te,fe);
}

tenv_t copy_tenv(tenv_t te) {
  let le = te->le;
  if (le == NULL)
    return put_emptyfenv(te);
  else
    return put_fenv(te,new *le);
}

tenv_t set_new_status(enum NewStatus status, tenv_t te){
  let le = te->le;
  if(le == NULL) return put_emptyfenv(te);
  let ans = new *le;
  ans->flags.in_new = status;
  return put_fenv(te,ans);
}
enum NewStatus new_status(tenv_t te) {
  let le = te->le;
  if (le == NULL) return NoneNew;
  return le->flags.in_new;
}
bool abstract_val_ok(tenv_t te) {
  let le = te->le;
  if (le == NULL) return false;
  return le->flags.abstract_ok;
}
tenv_t enter_abstract_val_ok(tenv_t te){
  let le = te->le;
  if(le == NULL) return put_emptyfenv(te);
  let ans = new *le;
  ans->flags.abstract_ok = true;
  return put_fenv(te,ans);
}
tenv_t clear_abstract_val_ok(tenv_t te) {
  let le = te->le;
  if(le == NULL) return put_emptyfenv(te);
  let ans = new *le;
  ans->flags.abstract_ok = false;
  return put_fenv(te,ans);
}
tenv_t enter_notreadctxt(tenv_t te){
  let le = te->le;
  if(le == NULL) return put_emptyfenv(te);
  let ans = new *le;
  ans->flags.in_notreadctxt = true;
  return put_fenv(te,ans);
}
tenv_t clear_notreadctxt(tenv_t te) {
  let le = te->le;
  if(le == NULL) return put_emptyfenv(te);
  let ans = new *le;
  ans->flags.in_notreadctxt = false;
  return put_fenv(te,ans);
}
bool in_notreadctxt(tenv_t te) {
  let le = te->le;
  if (le == NULL) return false;
  return le->flags.in_notreadctxt;
}
tenv_t enter_lhs(tenv_t te){
  let le = te->le;
  if(le == NULL) return put_emptyfenv(te);
  let ans = new *le;
  ans->flags.in_lhs = true;
  return put_fenv(te,ans);
}
tenv_t clear_lhs(tenv_t te) {
  let le = te->le;
  if(le == NULL) return put_emptyfenv(te);
  let ans = new *le;
  ans->flags.in_lhs = false;
  return put_fenv(te,ans);
}
bool in_lhs(tenv_t te) {
  let le = te->le;
  if (le == NULL) return false;
  return le->flags.in_lhs;
}

// do not stop setting clauseopt -- JumpAnalysis needs it!
$(switch_clause_t,list_t<tvar_t>,list_t<type_t>)const* const
process_fallthru(tenv_t te,stmt_t s, switch_clause_t *@ clauseopt){
  let ans = get_fenv(te,"process_fallthru")->ctrl_env;
  if(ans != NULL)
    *clauseopt = new (*ans)[0];
  return ans;
}

tenv_t set_fallthru(tenv_t te, list_t<tvar_t,`H> new_tvs, list_t<vardecl_t> vds,
		    switch_clause_t clause) {
  list_t<type_t> ft_typ = NULL;
  for(; vds!=NULL; vds=vds->tl)
    ft_typ = new List(vds->hd->type,ft_typ);
  let new_ctrl_env = new $(clause,new_tvs,List::imp_rev(ft_typ));
  let new_fe = new *get_fenv(te,"set_fallthru");
  new_fe->ctrl_env = new_ctrl_env;
  return put_fenv(te,new_fe);
}
// fallthru is illegal in the last case
tenv_t clear_fallthru(tenv_t te) {
  fenv_t fe = new *get_fenv(te,"clear_fallthru");
  fe->ctrl_env = NULL;
  return put_fenv(te,fe);
}

tenv_t allow_valueof(tenv_t te) {
  let fe = (te->le==NULL) ? NULL : new *te->le;
  let ans = new *te;
  ans->allow_valueof = true;
  return ans;
}
tenv_t enter_extern_c_include(tenv_t te) {
  let fe = (te->le==NULL) ? NULL : new *te->le;
  let ans = new *te;
  ans->in_extern_c_include = true;
  return ans;
}  

tenv_t add_region(tenv_t te, type_t rgn, bool opened) {
  let ans = new *get_fenv(te,"add_region");
  let region_order = ans->region_order;
  switch (compress(rgn)) {
  case &VarType(x): 
    region_order = add_youngest(heap_region,region_order, x, opened);
    break;
  default: break;
  }
  ans->region_order = region_order;
  ans->capability   = new JoinEff(new List(new AccessEff(rgn),
					   new List(ans->capability,NULL)));
  return put_fenv(te,ans);
}

tenv_t new_named_block(seg_t loc, tenv_t te, tvar_t block_rgn) {
  let ans = new *get_fenv(te,"new_named_block");
  let block_typ = new VarType(block_rgn);
  ans->type_vars = new List(block_rgn, ans->type_vars);
  check_unique_tvars(loc, ans->type_vars); // DJG: FIX -- very wasteful
  ans->region_order = add_youngest(heap_region, ans->region_order, 
				   block_rgn, false);
  ans->capability = new JoinEff(new List(new AccessEff(block_typ), 
					 new List(ans->capability,NULL)));
  ans->curr_rgn = block_typ;
  return put_fenv(te,ans);
}

static datatype KindBound.Eq_kb rgn_kb = Eq_kb(&rk);

tenv_t new_block(seg_t loc, tenv_t te) {
  tvar_t t = new_tvar(&rgn_kb);
  add_tvar_identity(t);
  return new_named_block(loc, te, t);
}

tenv_t new_outlives_constraints(tenv_t te, list_t<$(type_t,type_t)@> cs,
				seg_t loc) {
  let ans = new *get_fenv(te,"new_outlives_constraints");
  for(; cs != NULL; cs = cs->tl)
    ans->region_order =
      add_outlives_constraint(heap_region,
                              ans->region_order,(*cs->hd)[0],(*cs->hd)[1], loc);
  return put_fenv(te,ans);
}

tenv_t add_region_equality(tenv_t te, type_t r1, type_t r2,
			   $(tvar_t,kindbound_t) * @oldtv,
			   seg_t loc) {
  // we add outlives constraints and refine the kind of the type variable
  let r1 = compress(r1);
  let r2 = compress(r2);
  let r1k = typ_kind(r1);
  let r2k = typ_kind(r2);

  // first do kind refinement
  bool r1_le_r2 = kind_leq(r1k,r2k);
  bool r2_le_r1 = kind_leq(r2k,r1k);
  if (!r1_le_r2 && !r2_le_r1) {
    terr(loc,"Cannot compare region handles for %s and %s\n  kinds %s and %s are not compatible\n",
	 typ2string(r1),typ2string(r2),kind2string(r1k),kind2string(r2k));
    return new_outlives_constraints(te,NULL,loc);
  }
  else if (r1_le_r2 && !r2_le_r1)
    *oldtv = new swap_kind(r2,kind_to_bound(r1k));
  else if (!r1_le_r2 && r2_le_r1)
    *oldtv = new swap_kind(r1,kind_to_bound(r2k));

  // now update the outlives constraints
  let bds = NULL;
  if (r1 != &HeapRgn_val && r1 != &UniqueRgn_val && r1 != &RefCntRgn_val) {
    type_t eff1 = new AccessEff(r1);
    bds = new List::List(new $(eff1,r2),bds);
  }
  if (r2 != &HeapRgn_val && r2 != &UniqueRgn_val && r2 != &RefCntRgn_val) {
    type_t eff2 = new AccessEff(r2);
    bds = new List::List(new $(eff2,r1),bds);
  }
  return new_outlives_constraints(te,bds,loc);
}

type_t curr_rgn(tenv_t te) {
  let le = te->le;
  if (le == NULL) return &HeapRgn_val;
  return le->curr_rgn;
}

// Check that rgn_typ is currently accessible:  the heap region is always
// accessible, and a region variable r is accessible if it appears in the
// capability or outlives something in the capability.
void check_rgn_accessible(tenv_t te, seg_t loc, type_t rgn) {
  fenv_t fe = get_fenv(te,"check_rgn_accessible");
  let &Fenv{.capability = capability, .region_order = ro, ...} = fe;
  if (region_in_effect(false, rgn, capability) ||
      region_in_effect(true, rgn, capability))
    return;
  if(eff_outlives_eff(ro,new AccessEff(rgn),capability))
    return;
  terr(loc, "Expression accesses unavailable region %s", typ2string(rgn));
}

// check that region rt_a outlives region rt_b using the partial order in
// the environment.  Assumes that rt_a <> rt_b.
// Note: inefficient allocation here!
bool region_outlives(tenv_t te, type_t rt_a, type_t rt_b) {
  let le = te->le;
  rt_a = compress(rt_a);
  rt_b = compress(rt_b);
  // When typechecking a toplevel declaration:
  if(le==NULL)
    switch (rt_a) {
    case &RefCntRgn: return rt_b != &UniqueRgn_val;
    case &UniqueRgn: return rt_b != &RefCntRgn_val;
    case &HeapRgn:   return rt_b == &HeapRgn_val;
    default: return false;
    }
  // When typechecking a function body:
  let res = effect_outlives(le->region_order,new AccessEff(rt_a),rt_b);
//    fprintf(stderr,"region_outlives: %s outlves %s = %s\n",
//  	  typ2string(rt_a),typ2string(rt_b),res ? "true" : "false");
//    print_region_po(ro);
  return res;
}

// Check that a function call's effect is contained in the current capability.
// Do not constrain evars -- delay the check instead.
void check_effect_accessible(tenv_t te, seg_t loc, type_t eff) {
  let &Fenv{.capability = capability, .region_order = ro,
            .shared = shared, ...} = get_fenv(te,"check_effect_accessible");
  if(subset_effect(false, eff, capability))
    return;
  if(eff_outlives_eff(ro, eff, capability))
    return;
  shared->delayed_effect_checks =
    new List (new $(capability,eff,ro,loc), shared->delayed_effect_checks);
}
void check_delayed_effects(tenv_t te) {
  let checks =
    get_fenv(te,"check_delayed_constraints")->shared->delayed_effect_checks;
  for(; checks != NULL; checks = checks->tl) {
    let &$(capability,eff,rgn_order,loc) = checks->hd;
    if(subset_effect(true, eff, capability))
      continue;
    if(eff_outlives_eff(rgn_order, eff, capability))
      continue;
    terr(loc, "Capability \n%s\ndoes not cover function's effect\n%s",
       typ2string(capability), typ2string(eff));
  }
}

// Check that a function call's region partial order is compatible
// with the current region partial order
// Do not constrain evars -- delay the check instead.
// FIX: better error message!
void check_rgn_partial_order(tenv_t te, seg_t loc,
                             list_t<$(type_t,type_t)@`H,`H> po) {
  let le = te->le;
  if(le == NULL) {
    // not sure this could ever fail
    for(; po != NULL; po=po->tl)
      if((!subset_effect(true, (*po->hd)[0], empty_effect))
	 || !subset_effect(true, new AccessEff((*po->hd)[1]), empty_effect))
	terr(loc,"the required region ordering is not satisfied here");
    return;
  }
  let &Fenv{.region_order = ro, .shared = shared, ...} = (fenv_t)le;
  if(!satisfies_constraints(ro,po,&HeapRgn_val,false))
    shared->delayed_constraint_checks =
      new List(new $(ro,po,loc), shared->delayed_constraint_checks);
}

void check_delayed_constraints(tenv_t te) {
  let checks = 
    get_fenv(te,"check_delayed_constraints")->shared->delayed_constraint_checks;
  for(; checks != NULL; checks = checks->tl) {
    let &$(rgn_order,po,loc) = checks->hd;
    if(!satisfies_constraints(rgn_order,po,&HeapRgn_val,true))
      terr(loc,"the required region ordering is not satisfied here");
  }
}

static struct SharedFenv @`H new_shared_fenv(type_t ret) {
  return new SharedFenv{.return_typ = ret,
			.delayed_effect_checks = NULL,
			.delayed_constraint_checks = NULL };
}

fenv_t new_fenv(seg_t loc, fndecl_t fd) {
  tvar_t rgn0 =
    new Tvar(new ((string_t)aprintf("`%s",*(*fd->name)[1])),
             new_tvar_id(), &rgn_kb);
  let tvs = new List(rgn0,fd->tvs);
  Tcutil::check_unique_tvars(loc,tvs);
//   fprintf(stderr,"checking fn %s\n",qvar2string(fd->name));
  let rgn_po = initial_fn_po(heap_region, fd->tvs,fd->rgn_po,
                             (type_t)fd->effect,rgn0,loc);
  type_t param_rgn = new VarType(rgn0);
  for(let vds = fd->param_vardecls->v; vds != NULL; vds = vds->tl) 
    vds->hd->rgn = param_rgn;
  if (fd->cyc_varargs != NULL) {
    let VarargInfo(n,tq,t,i) = *fd->cyc_varargs;
    // name-resolution did not set param_rgn for the cyc_varargs array
    for(let vds = fd->param_vardecls->v; vds != NULL; vds = vds->tl) {
      let vd = vds->hd;
      if(strptrcmp((*vd->name)[1], (var_t)n)==0) {
	vd->type = dyneither_typ(t, param_rgn, tq, false_conref);
	break;
      }
    }
  }
  return new
    Fenv{.shared = new_shared_fenv(fd->ret_type),
         .type_vars   = tvs,
         .region_order = rgn_po,
         .ctrl_env    = NULL,
         .capability  = new JoinEff(new List(new AccessEff(param_rgn),
                                             new List((type_t)fd->effect,NULL))),
         .curr_rgn    = param_rgn,
	 .flags       = FenvFlags{false,false,false,false}
       };
}

fenv_t nested_fenv(seg_t loc, fenv_t old_fenv, fndecl_t fd) {
  let &Fenv{.region_order = rgn_po,
            .type_vars = type_vars, .shared = shared, ...} = old_fenv;
  let r = heap_region;
  tvar_t rgn0 =
    new Tvar(new ((string_t)aprintf("`%s",*(*fd->name)[1])),
             new_tvar_id(), &rgn_kb);
  for (let tvars = fd->tvs; tvars != NULL; tvars = tvars->tl) {
    let &Kind(k,a) = tvar_kind(tvars->hd,&bk);
    if (k == RgnKind)
      if (a == Aliasable)
	rgn_po = add_unordered(r, rgn_po, tvars->hd);
      else
	impos("non-intuitionistic tvar in nested_fenv");
  }
  rgn_po = add_youngest(r, rgn_po, rgn0, false);
  for(let po2 = fd->rgn_po; po2 != NULL; po2=po2->tl)
    rgn_po = add_outlives_constraint(r,rgn_po,(*po2->hd)[0],(*po2->hd)[1],loc);
  let tvs = new List(rgn0,List::append(fd->tvs,type_vars));
  check_unique_tvars(loc,tvs);
  type_t param_rgn = new VarType(rgn0);
  for(let vds = fd->param_vardecls->v; vds != NULL; vds = vds->tl)
    vds->hd->rgn = param_rgn;
  if (fd->cyc_varargs != NULL) {
    let VarargInfo(n,tq,t,i) = *fd->cyc_varargs;
    // name-resolution did not set param_rgn for the cyc_varargs array
    for(let vds = fd->param_vardecls->v; vds != NULL; vds = vds->tl) {
      let vd = vds->hd;
      if(strptrcmp((*vd->name)[1], (var_t)n)==0) {
	vd->type = dyneither_typ(t, param_rgn, tq, false_conref);
	break;
      }
    }
  }
  return new
    Fenv{.shared = new_shared_fenv(fd->ret_type),
         .type_vars   = tvs,
         .region_order = rgn_po,
         .ctrl_env    = NULL,
         .capability  = new JoinEff(new List(new AccessEff(param_rgn),
                                             new List((type_t)fd->effect,NULL))),
         .curr_rgn    = param_rgn,
	 .flags       = FenvFlags{false,false,false,false}
       };
}

fenv_t bogus_fenv(type_t ret_type,
		  list_t<$(var_opt_t,tqual_t,type_t)@> args) {
  tvar_t rgn0 = new Tvar(new "bogus", new_tvar_id(), &rgn_kb);
  let tvs = new List(rgn0,NULL);
  let rgn_po = initial_fn_po(heap_region,NULL,NULL,new JoinEff(NULL),rgn0,0);
  type_t param_rgn = new VarType(rgn0);
  return new
    Fenv{.shared = new_shared_fenv(ret_type),
         .type_vars   = tvs,
         .region_order = rgn_po,
         .ctrl_env    = NULL,
         .capability  = new JoinEff(new List(new AccessEff(param_rgn),NULL)),
         .curr_rgn    = param_rgn,
	 .flags       = FenvFlags{false,false,false,false}
       };
}
