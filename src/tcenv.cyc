/* Type environments.
   Copyright (C) 2001 Greg Morrisett, AT&T
   This file is part of the Cyclone compiler.

   The Cyclone compiler is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   The Cyclone compiler is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with the Cyclone compiler; see the file COPYING. If not,
   write to the Free Software Foundation, Inc., 59 Temple Place -
   Suite 330, Boston, MA 02111-1307, USA. */


/* An identifier can have at most one binding in each of the following:

   1) namespaces (after "namespace" or "using")
   2) structure tags (after "struct")
   3) union tags (after "union")
   4) structure or union members (after "." or "->")
   5) datatype tags (after "datatype")
   7) labels (after "goto", before ":")
   8) typedef names (in types)
   9) ordinary identifiers (the catch-all case)

   The ordinary identifiers include structure tags and datatype
   constructors.

   The environment data structures below follow from this directly.
   Note that labels can only appear inside of functions, so they don't
   appear in global environments.  And structure and union members
   must be resolved on a per-structure/per-union basis (e.g., two
   structs can have members with the same names) so their bindings
   don't belong in our environments.
*/

/* During type checking we keep two parallel environments.  One is
   accessed by absolute name, the other by local name.  We need these
   two environments because what is defined in a namespace is
   different from what is available in the namespace.  E.g.,

      extern int z;
      namespace Foo {
        int x;
        namespace Bar {
          int y = x;
        }
      }

   Here x is available in the inner namespace Bar but not defined
   there.  The absolute namespace will have entries for ::z, ::Foo::x,
   ::Foo::Bar, and ::Foo::Bar::y.  The relative namespace just after
   the definition of y will have entries for x, y, and z.
*/

#include <core.h>
#include <cycboot.h>
#include <list.h>
#include <dict.h>
#include <set.h>
#include <dict.h>
#include <slowdict.h>
#include <position.h>
#include <string.h>
#include "absynpp.h"
#include "absyn.h"
#include "tcutil.h"
#include "tcenv.h"
#include "rgnorder.h"

using Core;
using List;
using Set;
using Position;
using Absyn;
using Tcutil;
using Absynpp;
using RgnOrder;
namespace Tcenv;

datatype exn {Env_error};
datacon(exn,Env_error);

`a env_err(string_t msg) __attribute__((noreturn)) {
  fprintf(stderr,"Internal error in tcenv: %s\n",msg);
  fflush(stderr);
  throw &Env_error_val;
}


/////////////////////////// Type Definitions /////////////////////////////////

// Type environments
struct Tenv<`g::R,`l::R> {
  list_t<var_t>    ns;  // current namespace
  Dict::dict_t<list_t<var_t,`H>,genv_t<`g>,`g> ae; // absolute identifiers
  struct Fenv<`l> *`l le; // local environment
  bool allow_valueof;   // controls whether we allow valueof(T) in an expr
};
// Region notes:  we leave ns heap-allocated because this gets
// plugged into all of the variables in the AST.  Similarly, the
// ae domain takes a heap-allocated list because it's used to lookup
// namespaces.  

// Global environments -- what's declared in a global scope
struct Genv<`g::R> {
  region_t<`g> grgn;   // region for allocating globals
  set_t<var_t,`g>                   namespaces;
  Dict::dict_t<var_t,aggrdecl_t@,`g> aggrdecls;
  Dict::dict_t<var_t,datatypedecl_t@,`g> datatypedecls;
  Dict::dict_t<var_t,enumdecl_t@,`g>   enumdecls;
  // no indirection b/c no redeclaration
  Dict::dict_t<var_t,typedefdecl_t,`g> typedefs; 
  // bool for tree-shaking
  Dict::dict_t<var_t,$(resolved_t,bool)@`g,`g> ordinaries;
  // abs. names of "using" namespaces 
  list_t<list_t<var_t>,`g> availables; 
};
// Region notes:  the @ pointers for aggrdecl_t, datatypedecl_t,
// and enumdecl_t show up in the abstract syntax, so we make them
// heap pointers.  The list_t<var_t> in availables is heap-allocated
// because we look them up in the ae environment of the tenv.

// Used to tell what an ordinary identifer refers to
datatype Resolved {
  VarRes(binding_t); // includes unresolved variant
  AggrRes(aggrdecl_t);
  DatatypeRes(datatypedecl_t,datatypefield_t);
  EnumRes(enumdecl_t,enumfield_t);
  AnonEnumRes(type_t,enumfield_t);
};

datatype Jumpee {
  NotLoop_j;
  CaseEnd_j;
  FnEnd_j;
  Stmt_j(stmt_t);
};
datacon(Jumpee,NotLoop_j);
datacon(Jumpee,CaseEnd_j);
datacon(Jumpee,FnEnd_j);


typedef $(switch_clause_t, list_t<tvar_t>, clist_t<type_t,`r>)*`r 
ftclause_t<`r>;

static struct CtrlEnv<`r::R> {
  region_t<`r> ctrl_rgn;
  jumpee_t<`r> continue_stmt;
  jumpee_t<`r> break_stmt;
             // NULL => not allowed
  ftclause_t<`r> fallthru_clause; 
  jumpee_t<`r> next_stmt; // needed to calculate break_stmt
  int      try_depth;
  // The next_stmt field needs to be correct only when we might enter
  // a loop or switch. (i.e. when we call set_in_loop or set_in_switch)
};
typedef struct CtrlEnv<`r> @`r2 ctrl_env_t<`r,`r2>;
// Region notes:  we need to allocate the fallthru_clause occasionally hence
// the need for the ctrl_rgn.  We have to use clist to get the right subtyping.

// This part is shared throughout type-checking of a function.
// Hence mutations are seen by all subsequent type-checking, which is easier
// than threading labels which must be function-wide unique anyway.
static struct SharedFenv<`f::R> {
  region_t<`f>  frgn;
  type_t                              return_typ;
  Dict::dict_t<var_t,stmt_t,`f>       seen_labels;
  Dict::dict_t<var_t,list_t<stmt_t,`H>,`f> needed_labels;
  list_t<$(type_t,type_t,rgn_po_t<`f>,seg_t)@`f,`f> delayed_effect_checks;
  list_t<$(rgn_po_t<`f>,list_t<$(type_t,type_t)@>,seg_t)@`f,`f> delayed_constraint_checks;
};
// Region notes:  needed_labels has a heap-list in the co-domain because
// these get attached to abstract syntax.  The list<$(type,type)@> pair in
// delayed_constraint_checks is heap-allocated because it comes from the
// abstract syntax.  

// Local variable bindings are just kept in a linked list -- the
// tail is declared const so as to get deep region sub-typing
// which allows us to share local environments.
struct Bindings<`r::R> {
  var_t v;
  binding_t b;
  struct Bindings<`r> *`r const tl;
};
typedef struct Bindings<`r> *`r const bindings_t<`r>;

// Local function environments -- this is getting a bit out of hand, no?
abstract struct Fenv<`r::R> {
  <`f::R,`c::R> : {`f} > `r, {`c} > `r
  struct SharedFenv<`f> @`f shared;
  list_t<tvar_t>      type_vars; //type variables that can occur free
  rgn_po_t<`f>        region_order; // partial order on region variables 
  bindings_t<`r>      locals;
  stmt_t              encloser;  // nearest stmt with a binder or a try
  ctrl_env_t<`c,`r>   ctrl_env;
  type_t              capability; 
  type_t              curr_rgn;   // current block's region
  bool                in_notreadctxt; // true when in an exp that might read
  region_t<`r>        fnrgn;
};
// Region notes:  the shared part of the function environment has its
// own region `f, and the ctrl part of the function environment has its
// own region `c since these things want to share across distinct,
// but nested fenvs.  The type_vars are heap-allocated because we put
// them in abstract syntax (specifically evars).  I haven't messed with
// the region_order yet, but presumably some of it can be region-allocated.


//////////////////////// Lookup a local binding /////////////////////////////
datatype exn { NoBinding; };
datacon(exn,NoBinding);

// lookup a binding, throwing NoBinding on failure.
binding_t lookup_binding(bindings_t bs, var_t v) {
  for (; bs; bs = bs->tl) {
    if (strptrcmp(v,bs->v) == 0) return bs->b;
  }
  throw &NoBinding_val;
}

//////////////////////// Top-level Environment Manipulation //////////////////

genv_t<`r> empty_genv(region_t<`r> r) {
  return rnew(r) Genv{.grgn        = r,
                      .namespaces  = Set::rempty(r,strptrcmp),
                      .aggrdecls   = Dict::rempty(r,strptrcmp),
                      .datatypedecls = Dict::rempty(r,strptrcmp),
                      .enumdecls   = Dict::rempty(r,strptrcmp),
		      .typedefs    = Dict::rempty(r,strptrcmp),
                      .ordinaries  = Dict::rempty(r,strptrcmp),
		      .availables  = NULL};
}

tenv_t<`r,`r> tc_init(region_t<`r> r) {
  // Initialize globals
  empty_var_set = new Opt(Set::empty(strptrcmp));
  // Set up initial environment so that datatype exn, etc. is defined
  let ge     = empty_genv(r);
  ge->datatypedecls = Dict::insert(ge->datatypedecls, (*exn_name)[1], new exn_tud);
  for (let tufs = exn_tud->fields->v; tufs != NULL; tufs = tufs->tl)
    ge->ordinaries = Dict::insert(ge->ordinaries, (*tufs->hd->name)[1],
                                  rnew(r) 
                                  $(new DatatypeRes(exn_tud,tufs->hd),true));
  
  Dict::dict_t<list_t<var_t,`H>,genv_t<`r>,`r> ae = 
    Dict::insert(Dict::rempty(r,varlist_cmp), NULL, ge);
  return rnew(r) Tenv(NULL,ae,NULL,false);
}

// Lookup a namespace relative to the current namespace
static genv_t<`r> lookup_namespace(tenv_t<`r> te, seg_t loc,
                                   var_t n, list_t<var_t,`H> ns) {
  return Dict::lookup(te->ae, resolve_namespace(te,loc,n,ns));
}

// lookup functions
static list_t<var_t> outer_namespace(list_t<var_t> ns) {
  if (ns == NULL)
    return env_err("outer_namespace");
  return List::rev(List::rev(ns)->tl);
}

static bool same_namespace(list_t<var_t,`H> n1, list_t<var_t,`H> n2) {
  if (n1 == n2) return true;
  for (; n1 != NULL; n1 = n1->tl) {
    if (n2 == NULL) return false;
    if (strptrcmp(n1->hd,n2->hd) != 0) return false;
    n2 = n2->tl;
  }
  if (n2 != NULL) return false;
  return true;
}

// FIX: We should eagerly detect repeats by having one big dict
// that we recompute on namespace and using boundaries
static void check_repeat(tenv_t<`r> te, seg_t loc, 
                         `a lookup(genv_t<`r>,var_t),
			 var_t v, 
			 list_t<var_t,`H> cns,
			 list_t<list_t<var_t,`H>,`g> nss) {
  for(; nss != NULL; nss = nss->tl)
    if (!same_namespace(cns,nss->hd)) {
      genv_t ge2 = Dict::lookup(te->ae,nss->hd);
      try {
	lookup(ge2,v);
	Tcutil::terr(loc,"%s is ambiguous",*v);
      } catch { case &Dict::Absent: break; }
    }
  return;
}

static `a scoped_lookup(tenv_t<`g,`r> te,seg_t loc,`a lookup(genv_t<`g>,var_t),var_t v){
  list_t<var_t> cns = te->ns; // current namespace
  while (true) {
    genv_t ge = Dict::lookup(te->ae,cns);
    // Check current namespace
    try {
      `a result = lookup(ge,v);
      check_repeat(te, loc, lookup, v, cns, ge->availables);
      return result;
    } catch { case &Dict::Absent: break; }
    // Check available namespaces
    for (let nss = ge->availables; nss != NULL; nss = nss->tl) {
      genv_t ge2 = Dict::lookup(te->ae,nss->hd);
      try {
	`a result = lookup(ge2,v);
	check_repeat(te, loc, lookup, v, nss->hd, nss->tl);
	return result;
      } catch { case &Dict::Absent: break; }
    }
    if (cns == NULL)
      throw new Dict::Absent;
    // v is not defined in current namespace, look in next outer
    cns = outer_namespace(cns);
  }
}

static resolved_t lookup_ordinary_global_f(genv_t ge,var_t v) {
  let ord = ge->ordinaries;
  $(resolved_t,bool)@ ans = Dict::lookup(ord,v);
  (*ans)[1] = true;
  return (*ans)[0];
}
static resolved_t lookup_ordinary_global(tenv_t te,seg_t loc,qvar_t q) {
  let &$(nsl,v) = q;
  switch (nsl) {
  case {.Loc_n = _}: fallthru;
  case {.Rel_n = NULL}:
    return scoped_lookup(te, loc, lookup_ordinary_global_f, v);
  case {.Rel_n = &List(x,y)}:
    let ge = lookup_namespace(te,loc,x,y);
    return lookup_ordinary_global_f(ge,v);
  case {.Abs_n = y}:
    return lookup_ordinary_global_f(Dict::lookup(te->ae,y),v);
  }
}

// Return the absolute name of relative namespace &List(n,ns)
list_t<var_t> resolve_namespace(tenv_t te, seg_t loc,
                                var_t n, list_t<var_t,`H> ns) {
  let cns = te->ns; // current namespace
  TEMP_RGN(te,temp) {
    let possible_results = NULL;
    while (true) {
      let ge = Dict::lookup(te->ae,cns);
      let ge_av = ge->availables;
      let ge_ns = ge->namespaces;
      // Check namespaces that have been made available
      for (let nss = ge_av; nss != NULL; nss = nss->tl) {
        let ge2_ns = Dict::lookup(te->ae,nss->hd)->namespaces;
        if (Set::member(ge2_ns, n))
          possible_results = rnew(temp) List(List::append(cns,new List(n,ns)),
                                             possible_results);
      }
      // Check current namespace
      if (Set::member(ge_ns, n))
        possible_results = rnew(temp) List(List::append(cns,new List(n,ns)),
                                           possible_results);
      // Is this right? We check for ambiguity between the current namespace
      // and used namespaces in the current scope, but not outer namespaces.
      // Seems inconsistent.
      if (possible_results != NULL) {
        if (possible_results->tl != NULL)
          Tcutil::terr(loc,"%s is ambiguous",*(n));
        return possible_results->hd;
      }
      if (cns == NULL)
        throw new Dict::Absent;
      // n is not defined in current namespace, look in next outer
      cns = outer_namespace(cns);
    }
  }
}

// The absolute versions aren't being used right now, but it's
// important to think about whether they are correct in certain contexts.

static aggrdecl_t @ lookup_aggrdecl_f(genv_t ge,var_t v) {
  let ag = ge->aggrdecls;
  return Dict::lookup(ag,v);
}
aggrdecl_t @ lookup_aggrdecl(tenv_t te,seg_t loc,qvar_t q) {
  let &$(nsl,v) = q;
  switch (nsl) {
  case {.Loc_n = _}: fallthru;
  case {.Rel_n = NULL}:
    return scoped_lookup(te, loc, lookup_aggrdecl_f, v);
  case {.Abs_n = y}:
    let ads = Dict::lookup(te->ae,y)->aggrdecls;
    return Dict::lookup(ads,v);
  case {.Rel_n = &List(x,y)}:
    let ads = lookup_namespace(te,loc,x,y)->aggrdecls;
    return Dict::lookup(ads,v);
  }
}

static datatypedecl_t @ lookup_datatypedecl_f(genv_t ge,var_t v) {
  let tds = ge->datatypedecls;
  return Dict::lookup(tds,v);
}
datatypedecl_t @ lookup_datatypedecl(tenv_t te,seg_t loc,qvar_t q) {
  let &$(nsl,v) = q;
  switch (nsl) {
  case {.Loc_n = _}: fallthru;
  case {.Rel_n = NULL}:
    return scoped_lookup(te, loc, lookup_datatypedecl_f, v);
  case {.Rel_n = &List(x,y)}:
    let tds = lookup_namespace(te,loc,x,y)->datatypedecls;
    return Dict::lookup(tds,v);
  case {.Abs_n = y}:
    let tds = Dict::lookup(te->ae,y)->datatypedecls;
    return Dict::lookup(tds,v);
  }
}

static datatypedecl_t @ lookup_xdatatypedecl_f(genv_t ge,var_t v) {
  return Dict::lookup(ge->datatypedecls,v);
}

// DAN: some functionality from tcXDatatypedecl has moved to here.
datatypedecl_t@*`r lookup_xdatatypedecl(region_t<`r> r, tenv_t te,seg_t loc,qvar_t q) {
  let &$(nsl,v) = q;
  switch (nsl) {
  case {.Rel_n = NULL}:
    // unqualified name, okay to fail -- that just means we have a new xdatatype
    try return rnew(r) scoped_lookup(te, loc, lookup_xdatatypedecl_f, v);
    catch { case &Dict::Absent: return NULL; }
  case {.Loc_n = _}: // impossible case
    terr(loc,"lookup_xdatatypedecl: impossible");
    return NULL;
  case {.Rel_n = &List(x,y)}:
    // qualified name, it's an error if the namespace is bad or the
    // xdatatype doesn't already exist.  In either case, we'll raise
    // Dict::Absent, so we give a more descriptive message for the
    // former.
    genv_t ge;
    try ge = lookup_namespace(te,loc,x,y);
    catch {
    case &Dict::Absent:
      Tcutil::terr(loc,"bad qualified name for @extensible datatype");
      throw new Dict::Absent;
    }
    let tds = ge->datatypedecls;
    return rnew(r) Dict::lookup(tds,v);
  case {.Abs_n = y}:
    let tds = Dict::lookup(te->ae,y)->datatypedecls;
    return rnew(r) Dict::lookup(tds,v);
  }
}

static enumdecl_t @lookup_enumdecl_f(genv_t ge, var_t v) {
  let eds = ge->enumdecls;
  return Dict::lookup(eds,v);
}
enumdecl_t @lookup_enumdecl(tenv_t te, seg_t loc, qvar_t q) {
  let &$(nsl,v) = q;
  switch (nsl) {
  case {.Loc_n = _}:
  case {.Rel_n = NULL}:
    return scoped_lookup(te, loc, lookup_enumdecl_f, v);
  case {.Rel_n = &List(x,y)}:
    let eds = lookup_namespace(te,loc,x,y)->enumdecls;
    return Dict::lookup(eds,v);
  case {.Abs_n = y}:
    let eds = Dict::lookup(te->ae,y)->enumdecls;
    return Dict::lookup(eds,v);
  }
}

static typedefdecl_t lookup_typedefdecl_f(genv_t ge,var_t v) {
  let tds = ge->typedefs;
  return Dict::lookup(tds,v);
}
typedefdecl_t lookup_typedefdecl(tenv_t te, seg_t loc, qvar_t q) {
  let &$(nsl,v) = q;
  switch (nsl) {
  case {.Loc_n = _}:
  case {.Rel_n = NULL}:
    return scoped_lookup(te, loc, lookup_typedefdecl_f, v);
  case {.Rel_n = &List(x,y)}:
    let tds = lookup_namespace(te,loc,x,y)->typedefs;
    return Dict::lookup(tds,v);
  case {.Abs_n = y}:
    let tds = Dict::lookup(te->ae,y)->typedefs;
    return Dict::lookup(tds,v);
  }
}

//////////////////// Function Environment Manipulation //////////////////////

static fenv_t<`r> get_fenv(tenv_t<`g,`r> te, const char ?err_msg) {
  let le = te->le;
  if (te == NULL) env_err(err_msg);
  return (fenv_t)le;
}

region_t<`r> coerce_heap_region() {
  return (region_t<`r>)Core::heap_region;
}

region_t<`r> get_fnrgn(tenv_t<`g,`r> te) {
  let le = te->le;
  if (le != NULL) {
    let &Fenv{<`f,`c> .fnrgn=f,...} = (fenv_t)le;
    return f;
  } 
  return coerce_heap_region();
}

static tenv_t<`g,`l> put_fenv(region_t<`l> l, tenv_t<`g,`l2> te, fenv_t<`l> fe) {
  if (te->le == NULL) env_err("put_fenv");
  return rnew(l) Tenv(te->ns, te->ae, fe, te->allow_valueof);
}

static tenv_t<`g,`l> put_emptyfenv(region_t<`l> l,tenv_t<`g,`l2> te) {
  return rnew(l) Tenv(te->ns, te->ae, NULL, te->allow_valueof);
}

static fenv_t<`l> copy_fenv_old_ctrl(region_t<`l> l, fenv_t<`l2> f : {`l2}>`l)
{
  let Fenv{<`f,`c> shared,type_vars,region_order,locals,encloser,ctrl_env,
              capability,curr_rgn,in_notreadctxt,frgn} = *f;
  return rnew(l) Fenv{shared,type_vars,region_order,(bindings_t<`l>)locals,
                        encloser,ctrl_env,capability,curr_rgn,
                        in_notreadctxt,l};
                        
}
static fenv_t<`l> copy_fenv_new_ctrl(region_t<`l> l, fenv_t<`l2> f : {`l2}>`l)
{
  let Fenv{<`f,`c> shared,type_vars,region_order,locals,encloser,ctrl_env,
              capability,curr_rgn,in_notreadctxt,_} = *f;
  // WARNING: fallthru_clause shared with old
  let CtrlEnv{cr,c_stmt,b_stmt,fallthru_clause,n_stmt,try_depth} = *ctrl_env;
  let new_ctrl_env = 
    rnew(l) CtrlEnv{cr,c_stmt,b_stmt,fallthru_clause,n_stmt,try_depth};
  return rnew(l) Fenv{shared,type_vars,region_order,(bindings_t<`l>)locals,
                        encloser,new_ctrl_env,capability,curr_rgn,
                        in_notreadctxt,l};
                        
}


type_t return_typ(tenv_t te) {
  let &Fenv{<`f,`c> .shared = s,...} = get_fenv(te,"return_typ");
  let SharedFenv{.return_typ = rt, ...} = *s;
  return rt;
}

list_t<tvar_t> lookup_type_vars(tenv_t te) {
  let le = te->le;
  if(te->le == NULL) return NULL;
  let Fenv{<`f,`c> .type_vars = ts,...} = *le;
  return ts;
}

opt_t<list_t<tvar_t>> lookup_opt_type_vars(tenv_t te) {
  return new Opt(lookup_type_vars(te));
}

tenv_t<`g,`r> add_type_vars(region_t<`r> r, seg_t loc,tenv_t<`g,`r2> te,
                            list_t<tvar_t> tvs : {`r2} > `r) {
  let &Fenv{<`f,`c> shared,type_vars,region_order,locals,encloser,ctrl_env,
              capability,curr_rgn,in_notreadctxt,_} = 
    get_fenv(te,"add_type_vars");  

  add_tvar_identities(tvs);
  let new_tvs = List::append(tvs,type_vars);
  Tcutil::check_unique_tvars(loc,new_tvs);
  let fe = rnew(r) Fenv(shared,new_tvs,region_order,(bindings_t<`r>)locals,
                        encloser,ctrl_env,capability,curr_rgn,in_notreadctxt,
                        r);
  return put_fenv(r,te,fe);
}

tenv_t<`g,`r> copy_tenv(region_t<`r> r, tenv_t<`g,`r2> te : {`r2} > `r) {
  let le = te->le;
  if (le == NULL) {
    return put_emptyfenv(r,te);
  } else {
    fenv_t<`r> fe = copy_fenv_old_ctrl(r, le);
    return put_fenv(r,te,fe);
  }
}

tenv_t<`g,`r> add_local_var(region_t<`r> r, seg_t loc, tenv_t<`g,`r2> te, vardecl_t vd : {`r2} > `r) {
  //let fe = copy_fenv_old_ctrl(r,get_fenv(te,"add_local_var"));
  let v  = (*vd->name)[1];
  switch ((*vd->name)[0]) {
  case {.Loc_n = _}: break;
  default:
    // This is a fail-safe. Maybe we should just clobber with Loc_n?
    throw new Impossible("add_local_var: called with Rel_n");
  }
  let &Fenv{<`f,`c> shared,type_vars,region_order,locals,encloser,ctrl_env,
              capability,curr_rgn,in_notreadctxt,_} = 
    get_fenv(te,"add_local_var");  
  let new_locals = rnew(r) Bindings{v,new Local_b(vd),(bindings_t<`r>)locals}; 
  let fe = rnew(r) Fenv(shared,type_vars,region_order,new_locals,
                        encloser,ctrl_env,capability,curr_rgn,in_notreadctxt,
                        r);
  return put_fenv(r,te,fe);
}

tenv_t<`g,`r> enter_notreadctxt(region_t<`r> r,tenv_t<`g,`r2> te : {`r2}>`r){
  let le = te->le;
  if(le == NULL) return put_emptyfenv(r,te);
  let Fenv{<`f,`c> shared,type_vars,region_order,locals,encloser,ctrl_env,
              capability,curr_rgn,in_notreadctxt,_} = *le;
  let fe = rnew(r) Fenv(shared,type_vars,region_order,(bindings_t<`r>)locals,
                        encloser,ctrl_env,capability,curr_rgn,true,r);
  return put_fenv(r,te,fe);
}

tenv_t<`g,`r> clear_notreadctxt(region_t<`r> r,tenv_t<`g,`r2> te : {`r2}>`r) {
  let le = te->le;
  if(le == NULL) return put_emptyfenv(r,te);
  let Fenv{<`f,`c> shared,type_vars,region_order,locals,encloser,ctrl_env,
              capability,curr_rgn,in_notreadctxt,_} = *le;
  let fe = rnew(r) Fenv(shared,type_vars,region_order,(bindings_t<`r>)locals,
                        encloser,ctrl_env,capability,curr_rgn,false,r);
  return put_fenv(r,te,fe);
}

bool in_notreadctxt(tenv_t te) {
  let le = te->le;
  if (le == NULL) return false;
  let &Fenv{<`f,`c> .in_notreadctxt = nr,...} = (fenv_t)le;
  return nr;
}

// assume uniqueness has been checked elsewhere
tenv_t<`g,`r> add_pat_var(region_t<`r> r, seg_t loc, tenv_t<`g,`r2> te, 
                          vardecl_t vd : {`r2} > `r) {
  let v  = (*vd->name)[1];
  let &Fenv{<`f,`c> shared,type_vars,region_order,locals,encloser,ctrl_env,
              capability,curr_rgn,in_notreadctxt,_} = 
    get_fenv(te,"add_pat_var");  
  let new_locals = rnew(r) Bindings{v,new Pat_b(vd),(bindings_t<`r>)locals}; 
  let fe = rnew(r) Fenv(shared,type_vars,region_order,new_locals,
                        encloser,ctrl_env,capability,curr_rgn,in_notreadctxt,r);
  return put_fenv(r,te,fe);
}

resolved_t<`r> lookup_ordinary(region_t<`r> r, tenv_t te,seg_t loc,qvar_t q) {
  let le = te->le;
  let &$(nsl,v) = q;
  switch (nsl) {
  case {.Loc_n = _}:
    if (le == NULL) throw new Dict::Absent;
    fallthru;
  case {.Rel_n = NULL} && le != NULL:
    let &Fenv{<`f,`c> .locals = locals,...} = (fenv_t)le;
    // NB a local overrides any global, without an ambiguity warning
    try return rnew(r) VarRes(lookup_binding(locals,v));
    catch {case &NoBinding: return lookup_ordinary_global(te,loc,q);}
  default:
    try return lookup_ordinary_global(te,loc,q);    
    catch {case &Dict::Absent: 
      // Print out the error message elsewhere.
      // terr(loc,"unbound identifier: %s", Absynpp::qvar2string(q));
      return rnew(r) VarRes(&Unresolved_b_val);
    }
  }
}

void process_continue(tenv_t te, stmt_t s, stmt_opt_t @sopt) {
  let &Fenv{<`f,`c> .ctrl_env = ctrl_env, ...} = 
    get_fenv(te,"process_continue");
  switch (ctrl_env->continue_stmt) {
  case &Stmt_j(s2):
    s2->non_local_preds = new List(s,s2->non_local_preds);
    *sopt = s2;
    return;
  case &NotLoop_j: terr(s->loc, "continue not in a loop"); return;
  case &CaseEnd_j: 
  case &FnEnd_j:   env_err("bad continue destination");
  }
}
void process_break(tenv_t te, stmt_t s, stmt_opt_t @sopt) {
  let &Fenv{<`f,`c> .ctrl_env = ctrl_env, .shared = shared, ...} = 
    get_fenv(te,"process_break");
  switch (ctrl_env->break_stmt) {
  case &Stmt_j(s2):
    s2->non_local_preds = new List(s,s2->non_local_preds);
    *sopt = s2;
    return;
  case &NotLoop_j:
    terr(s->loc, "break not in a loop or switch");
    return;
  case &FnEnd_j:
    // Note doing this here is more conservative than in control-flow.
    // Eg: while(true) if(false) break; else return 0;
    // But it's a pain to do in control flow because there is no stmt dest
    if(shared->return_typ != (type_t)&VoidType_val)
      terr(s->loc, "break causes function not to return a value");
    return;
  case &CaseEnd_j:
    // Analogous comment to previous case applies.
    terr(s->loc, "break causes outer switch clause to implicitly fallthru");
    return;
  }
}
void process_goto(tenv_t te, stmt_t s, var_t l, stmt_opt_t @sopt) {
  let &Fenv{<`f,`c> .shared = shared, ...} = get_fenv(te,"process_goto");
  stmt_t* sopt2 = Dict::lookup_opt(shared->seen_labels,l);
  if(sopt2 == NULL) {
    let needed = shared->needed_labels;
    list_t<stmt_t,`H>* slopt = Dict::lookup_opt(needed,l);
    region_t<`f> frgn = shared->frgn;
    if(slopt == NULL)
      slopt = rnew(frgn) NULL;
    list_t<stmt_t,`H> new_needed = new List(s,*slopt);
    shared->needed_labels = Dict::insert(needed,l,new_needed);
  } else {
    stmt_t s = *sopt2;
    s->non_local_preds = new List(s, s->non_local_preds);
    *sopt = s;
  }
}

$(switch_clause_t,list_t<tvar_t>,clist_t<type_t,`r>)*`r const
process_fallthru(tenv_t<`g,`r> te,stmt_t s, switch_clause_t *@ clauseopt){
  let &Fenv{<`f,`c> .ctrl_env=ctrl_env,...} = get_fenv(te,"process_fallthru");
  let ans = ($(_,_,clist_t<_,`r>)*`r const)ctrl_env->fallthru_clause;
  if(ans != NULL) {
    (*ans)[0]->body->non_local_preds = 
      new List(s, (*ans)[0]->body->non_local_preds);
    *clauseopt = new (*ans)[0];
  }
  return ans;
}

tenv_t<`g,`r> set_fallthru(region_t<`r> r, tenv_t<`g,`r2> te, 
                           list_t<tvar_t,`H> new_tvs, 
                           list_t<vardecl_t> vds, 
                           switch_clause_t clause : {`r2} > `r) {
  let &Fenv{<`f,`c> shared,type_vars,region_order,locals,encloser,ctrl_env,
              capability,curr_rgn,in_notreadctxt,_} =get_fenv(te,"set_fallthru");
  let &CtrlEnv{cr,c_stmt,b_stmt,fc,n_stmt,try_depth} = ctrl_env;
  list_t<type_t,`c> ft_typ = NULL;
  for(; vds!=NULL; vds=vds->tl)
    ft_typ = rnew(cr) List(vds->hd->type,ft_typ);
  let cft_typ = (clist_t<_,`c>)List::imp_rev(ft_typ);
  let new_ctrl_env = 
    rnew(r) CtrlEnv{cr,c_stmt,b_stmt,rnew(cr) $(clause,new_tvs,cft_typ),
                    n_stmt,try_depth};
  let new_fe = rnew(r) Fenv{shared,type_vars,region_order,
                            (bindings_t<`r>)locals,
                            encloser,new_ctrl_env,capability,curr_rgn,
                            in_notreadctxt,r};
  return put_fenv(r,te,new_fe);
}
// fallthru is illegal in the last case
tenv_t<`g,`r> clear_fallthru(region_t<`r> r, tenv_t<`g,`r2> te : {`r2} > `r) {
  fenv_t fe = copy_fenv_new_ctrl(r,get_fenv(te,"clear_fallthru"));
  let &Fenv{<`f,`c> .ctrl_env = ctrl_env,...} = fe;
  ctrl_env->fallthru_clause = NULL;
  return put_fenv(r,te,fe);
}

tenv_t<`g,`r> set_in_loop(region_t<`r> r, tenv_t<`g,`r2> te, 
                          stmt_t continue_dest : {`r2} > `r) {
  let &Fenv{<`f,`c> shared,type_vars,region_order,locals,encloser,ctrl_env,
            capability,curr_rgn,in_notreadctxt,_} = get_fenv(te,"set_in_loop");
  ctrl_env_t<`r,`r> new_cenv = 
    rnew(r) CtrlEnv{.ctrl_rgn = r,
                    .continue_stmt = rnew(r) Stmt_j(continue_dest),
                    .break_stmt = ctrl_env->next_stmt,
                    .next_stmt = rnew(r) Stmt_j(continue_dest),
                    .fallthru_clause = 
                       (ftclause_t<`r>)ctrl_env->fallthru_clause,
                    .try_depth = ctrl_env->try_depth};
  fenv_t<`r> new_fenv = 
    rnew(r) Fenv{shared,type_vars,region_order,(bindings_t<`r>)locals,
                   encloser,new_cenv,capability,curr_rgn,in_notreadctxt,r};
  return put_fenv(r,te,new_fenv);
}

tenv_t<`g,`r> enter_try(region_t<`r> r, tenv_t<`g,`r2> te : {`r2} > `r) {
  fenv_t fe = copy_fenv_new_ctrl(r,get_fenv(te,"enter_try"));
  let &Fenv{<`f,`c> .ctrl_env = ctrl_env,...} = fe;
  ++ctrl_env->try_depth;
  return put_fenv(r,te,fe);
}
int get_try_depth(tenv_t te) {
  let &Fenv{<`f,`c> .ctrl_env = ctrl_env,...} = get_fenv(te,"get_try_depth");
  return ctrl_env->try_depth;
}

// each non-last case must also call set_fallthru, here we just
// change the break destination
tenv_t<`g,`r> set_in_switch(region_t<`r> r, tenv_t<`g,`r2> te : {`r2}>`r) {
  fenv_t fe  = copy_fenv_new_ctrl(r,get_fenv(te,"set_in_switch"));
  let &Fenv{<`f,`c> .ctrl_env = ctrl_env,...} = fe;
  ctrl_env->break_stmt = ctrl_env->next_stmt; // break goes to next
  ctrl_env->next_stmt  = &CaseEnd_j_val; // prevent nested break to fallthru
  return put_fenv(r,te,fe);
}

tenv_t<`g,`r> set_next(region_t<`r> r, tenv_t<`g,`r2> te, jumpee_t<`r> j
                       : {`r2} > `r) {
  let Fenv{<`f,`c> shared,type_vars,region_order,locals,encloser,ctrl_env,
              capability,curr_rgn,in_notreadctxt,_} = *get_fenv(te,"set_next");
  ctrl_env_t<`r,`r> new_cenv = 
    rnew(r) CtrlEnv{.ctrl_rgn = r,
                    .continue_stmt = ctrl_env->continue_stmt,
                    .break_stmt = ctrl_env->break_stmt,
                    .next_stmt = j,
                    .fallthru_clause = 
                       (ftclause_t<`r>)ctrl_env->fallthru_clause,
                    .try_depth = ctrl_env->try_depth};
  fenv_t<`r> new_fenv = 
    rnew(r) Fenv{shared,type_vars,region_order,(bindings_t<`r>)locals,
                   encloser,new_cenv,capability,curr_rgn,in_notreadctxt,r};
  return put_fenv(r,te,new_fenv);
}

tenv_t<`g,`r> add_label(tenv_t<`g,`r> te, var_t v, stmt_t s) {
  let &Fenv{<`f,`c> .shared = shared, ...} = get_fenv(te,"add_label");
  Dict::dict_t<var_t,list_t<stmt_t,`H>,`f> needed = shared->needed_labels;
  list_t<stmt_t,`H>* sl_opt = Dict::lookup_opt(needed, v);
  region_t<`f> frgn = shared->frgn;
  if(sl_opt != NULL) {
    shared->needed_labels = Dict::rdelete(frgn, needed, v);
    // backpatching
    let sl = *sl_opt;
    s->non_local_preds = sl;
    for(; sl != NULL; sl = sl->tl)
      switch (sl->hd->r) {
      case &Goto_s(_,*so): *so = s; break;
      default: env_err("Tcenv: add_label backpatching of non-goto"); break;
      }
  }
  if(Dict::member(shared->seen_labels, v))
    Tcutil::terr(s->loc, "Repeated label: %s", *v);
  shared->seen_labels = Dict::insert(shared->seen_labels, v, s);
  return te;
}

bool all_labels_resolved(tenv_t te) {
  let &Fenv{<`f,`c> .shared = shared,...} = get_fenv(te,"all_labels_resolved");
  return Dict::is_empty(shared->needed_labels);
}

stmt_t get_encloser(tenv_t te) {
  let &Fenv{<`f,`c> .encloser = encloser, ...} = get_fenv(te,"get_encloser");
  return encloser;
}

tenv_t<`g,`r2> allow_valueof(region_t<`r2> r2, tenv_t<`g,`r> te : {`r} > `r2) {
  if (te->le == NULL)
    return rnew(r2) Tenv(te->ns, te->ae, NULL, true);
  let Fenv{<`f,`c> s,t,r,l,e,ce,cp,cr,i,_} = *te->le;
  let fe = rnew(r2) Fenv{s,t,r,(bindings_t<`r2>)l,e,ce,cp,cr,i,r2};
  return rnew(r2) Tenv(te->ns, te->ae, fe, true);
}

tenv_t<`g,`r> set_encloser(region_t<`r> r, tenv_t<`g,`r2> te, stmt_t s : 
                           {`r2} > `r) {
  let Fenv{<`f,`c> shared,type_vars,region_order,locals,encloser,ctrl_env,
              capability,curr_rgn,in_notreadctxt,_} = 
    *get_fenv(te,"set_encloser");
  let fe = 
    rnew(r) Fenv{shared,type_vars,region_order,(bindings_t<`r>)locals,
                 s,ctrl_env,capability,curr_rgn,in_notreadctxt,r};
  return put_fenv(r,te,fe);
}

tenv_t<`g,`r> add_region(region_t<`r> r, tenv_t<`g,`r2> te, type_t rgn, 
                         bool resetable, bool opened : {`r2} > `r) {
                         
  tvar_t tv;
  switch (compress(rgn)) {
  case &VarType(x): tv = x; break;
  default: tv = env_err("bad add region"); break;
  }
  let Fenv{<`f,`c> shared,type_vars,region_order,locals,encloser,ctrl_env,
              capability,curr_rgn,in_notreadctxt,_} = 
    *get_fenv(te,"add_region");
  region_order = add_youngest(shared->frgn, region_order, tv, resetable, opened);
  capability = new JoinEff(new List(new AccessEff(rgn),
                                    new List(capability,NULL)));
  let fe = 
    rnew(r) Fenv{shared,type_vars,region_order,(bindings_t<`r>)locals,
                 encloser,ctrl_env,capability,curr_rgn,in_notreadctxt,r};
  return put_fenv(r,te,fe);
}

tenv_t<`g,`r> new_named_block(region_t<`r> r, seg_t loc, tenv_t<`g,`r2> te,
                              tvar_t block_rgn : {`r2} > `r) {
  let Fenv{<`f,`c> shared,type_vars,region_order,locals,encloser,ctrl_env,
              capability,curr_rgn,in_notreadctxt,_} = 
    *get_fenv(te,"new_named_block");

  fenv_t fe = copy_fenv_old_ctrl(r,get_fenv(te,"new_block"));
  type_t block_typ = new VarType(block_rgn);
  type_vars = new List(block_rgn, type_vars);
  Tcutil::check_unique_tvars(loc, type_vars);
  region_order = add_youngest(shared->frgn, region_order, block_rgn, false, false);
  capability = new JoinEff(new List(new AccessEff(block_typ), new List(capability,NULL)));
  curr_rgn = block_typ;
  let fe = 
    rnew(r) Fenv{shared,type_vars,region_order,(bindings_t<`r>)locals,
                 encloser,ctrl_env,capability,curr_rgn,in_notreadctxt,r};
  return put_fenv(r,te,fe);
}

static datatype KindBound.Eq_kb rgn_kb = Eq_kb(RgnKind);

tenv_t<`g,`r> new_block(region_t<`r> r, seg_t loc, tenv_t<`g,`r2> te 
                        : {`r2} > `r) {
  tvar_t t = new_tvar(&rgn_kb);
  add_tvar_identity(t);
  return new_named_block(r, loc, te, t);
}


tenv_t<`g,`r> new_outlives_constraints(region_t<`r> r, tenv_t<`g,`r2> te, 
                                       list_t<$(type_t,type_t)@> cs,
				       seg_t loc
                                       : {`r2} > `r) {
  let Fenv{<`f,`c> shared,type_vars,region_order,locals,encloser,ctrl_env,
              capability,curr_rgn,in_notreadctxt,_} = 
    *get_fenv(te,"new_outlives_constraints");
  for(; cs != NULL; cs = cs->tl)
    region_order = 
      add_outlives_constraint(shared->frgn, 
                              region_order,(*cs->hd)[0],(*cs->hd)[1],
			      loc);
  let fe = 
    rnew(r) Fenv{shared,type_vars,region_order,(bindings_t<`r>)locals,
                 encloser,ctrl_env,capability,curr_rgn,in_notreadctxt,r};
  return put_fenv(r,te,fe);
}

tenv_t<`g,`r> add_region_equality(region_t<`r> r, tenv_t<`g,`r2> te, 
				  type_t r1, type_t r2, 
				  $(tvar_t,kindbound_t) *`r @oldtv,
				  seg_t loc
				  : {`r2} > `r) {

  // we add outlives constraints and also refine the kind of
  // the type variable
  let r1 = compress(r1);
  let r2 = compress(r2);
  let r1k = typ_kind(r1);
  let r2k = typ_kind(r2);

  // first do kind refinement
  bool r1_le_r2 = kind_leq(r1k,r2k);
  bool r2_le_r1 = kind_leq(r2k,r1k);
  if (!r1_le_r2 && !r2_le_r1) {
    terr(loc,"Cannot compare region handles for %s and %s\n  kinds %s and %s are not compatible\n",
	 typ2string(r1),typ2string(r2),kind2string(r1k),kind2string(r2k));
    return new_outlives_constraints(r,te,NULL,loc);
  }
  else if (r1_le_r2 && !r2_le_r1) {
    let $(tv,kb) = swap_kind(r2,kind_to_bound(r1k));
    *oldtv = rnew (r) $(tv,kb);
  }
  else if (!r1_le_r2 && r2_le_r1) {
    let $(tv,kb) = swap_kind(r1,kind_to_bound(r2k));
    *oldtv = rnew (r) $(tv,kb);
  }
      
  // now update the outlives constraints
  let r = Tcenv::get_fnrgn(te);
  let bds = NULL;
  if (r1 != &HeapRgn_val && r1 != &UniqueRgn_val) {
    type_t eff1 = new AccessEff(r1);
    bds = rnew (r) List::List(rnew (r) $(eff1,r2),bds);
  }
  if (r2 != &HeapRgn_val && r2 != &UniqueRgn_val) {
    type_t eff2 = new AccessEff(r2);
    bds = rnew (r) List::List(rnew (r) $(eff2,r1),bds);
  }
 
  return new_outlives_constraints((region_t<`r>)r,te,bds,loc);
}

type_t curr_rgn(tenv_t te) {
  let le = te->le;
  if (le == NULL) return &HeapRgn_val; 
  fenv_t fe = le;
  let &Fenv{<`f,`c> .curr_rgn = c, ...} = fe;
  return c;
}

// Check that rgn_typ is currently accessible:  the heap region is always
// accessible, and a region variable r is accessible if it appears in the
// capability or outlives something in the capability.
void check_rgn_accessible(tenv_t te, seg_t loc, type_t rgn) {
  fenv_t fe = get_fenv(te,"check_rgn_accessible");
  let &Fenv{<`f,`c> .capability = capability, .region_order = ro, ...} = fe;
  if (region_in_effect(false, rgn, capability) ||
      region_in_effect(true, rgn, capability)) 
    return;
  if(eff_outlives_eff(ro,new AccessEff(rgn),capability))
    return;
  terr(loc, "Expression accesses unavailable region %s", typ2string(rgn));
}

// Check to see if a region is accessible and resetable
void check_rgn_resetable(tenv_t te, seg_t loc, type_t rgn) {
  check_rgn_accessible(te,loc,rgn);
  let &Fenv{<`f,`c> .region_order = ro, ...} = 
    get_fenv(te,"check_rgn_resetable");
  switch (compress(rgn)) {
  case &VarType(r):
    if(!RgnOrder::is_region_resetable(ro,r))
      terr(loc, "Region %s is not resetable", typ2string(rgn));
    return;
  default:
    impos("check_rgn_resetable");
  }
}

// check that region rt_a outlives region rt_b using the partial order in
// the environment.  Assumes that rt_a <> rt_b.
// Note: inefficient allocation here!
bool region_outlives(tenv_t te, type_t rt_a, type_t rt_b) {
  let le = te->le;
  rt_a = compress(rt_a);
  rt_b = compress(rt_b);
  // When typechecking a toplevel declaration:
  if(le==NULL)
    return rt_a==&UniqueRgn_val || (rt_a==&HeapRgn_val && rt_b != &UniqueRgn_val);
  // When typechecking a function body:
  fenv_t fe = le;
  let &Fenv{<`f,`c> .region_order = ro, ...} = fe;
  let res = effect_outlives(ro,new AccessEff(rt_a),rt_b);
//    fprintf(stderr,"region_outlives: %s outlves %s = %s\n",
//  	  typ2string(rt_a),typ2string(rt_b),res ? "true" : "false");
//    print_region_po(ro);
  return res;
}

// Check that a function call's effect is contained in the current capability.
// Do not constrain evars -- delay the check instead.
void check_effect_accessible(tenv_t te, seg_t loc, type_t eff) {
  let &Fenv{<`f,`c> .capability = capability, .region_order = ro, 
               .shared = shared, ...} = get_fenv(te,"check_effect_accessible");
  if(subset_effect(false, eff, capability))
    return;
  if(eff_outlives_eff(ro, eff, capability)) 
    return;
  region_t<`f> frgn = shared->frgn;
  shared->delayed_effect_checks = 
    rnew(frgn) List(rnew(frgn) $(capability,eff,ro,loc), 
                    shared->delayed_effect_checks);
}
void check_delayed_effects(tenv_t te) {
  let &Fenv{<`f,`c> .shared = shared, ...} = 
    get_fenv(te,"check_delayed_effects");
  let checks = shared->delayed_effect_checks;
  for(; checks != NULL; checks = checks->tl) {
    let &$(capability,eff,rgn_order,loc) = checks->hd;
    if(subset_effect(true, eff, capability))
      continue;
    if(eff_outlives_eff(rgn_order, eff, capability))
      continue;
    terr(loc, "Capability \n%s\ndoes not cover function's effect\n%s",
       typ2string(capability), typ2string(eff));
  }
}

// Check that a function call's region partial order is compatible
// with the current region partial order
// Do not constrain evars -- delay the check instead.
// FIX: better error message!
void check_rgn_partial_order(tenv_t te, seg_t loc, 
                             list_t<$(type_t,type_t)@`H,`H> po) {
  let le = te->le;
  if(le == NULL) {
    // not sure this could ever fail
    for(; po != NULL; po=po->tl)
      if((!subset_effect(true, (*po->hd)[0], empty_effect))
	 || !subset_effect(true, new AccessEff((*po->hd)[1]), empty_effect))
	terr(loc,"the required region ordering is not satisfied here");
    return;
  }
  let &Fenv{<`f,`c> .region_order = ro, .shared = shared, ...} = (fenv_t)le;
  if(!satisfies_constraints(ro,po,&HeapRgn_val,false))
    shared->delayed_constraint_checks = 
      rnew(shared->frgn) List(rnew(shared->frgn) $(ro,po,loc),
                              shared->delayed_constraint_checks);
}

void check_delayed_constraints(tenv_t te) {
  let &Fenv{<`f,`c> .shared = shared,...} = 
    get_fenv(te,"check_delayed_constraints");
  let checks = shared->delayed_constraint_checks;
  for(; checks != NULL; checks = checks->tl) {
    let &$(rgn_order,po,loc) = checks->hd;
    if(!satisfies_constraints(rgn_order,po,&HeapRgn_val,true))
      terr(loc,"the required region ordering is not satisfied here");
  }
}

fenv_t<`r> new_fenv(region_t<`r> r, seg_t loc, fndecl_t fd) {
  bindings_t<`r> locals = NULL;
  tvar_t rgn0 = 
    new Tvar(new ((string_t)aprintf("`%s",*(*fd->name)[1])),
             new_tvar_id(), &rgn_kb);
  let tvs = new List(rgn0,fd->tvs);
  Tcutil::check_unique_tvars(loc,tvs);
//   fprintf(stderr,"checking fn %s\n",qvar2string(fd->name));
  let rgn_po = initial_fn_po(r, fd->tvs,fd->rgn_po,fd->effect->v,rgn0,loc);
  type_t param_rgn = new VarType(rgn0);
  opt_t<type_t> param_rgn_opt = new Opt(param_rgn);
  let vds = NULL;
  for(let args = fd->args; args != NULL; args = args->tl) {
    let vd = new{Vardecl{.sc = Public, 
			 .name = new $((nmspace_t)Loc_n,(*args->hd)[0]),
			 .tq = (*args->hd)[1],
			 .type = (*args->hd)[2],
			 .initializer = NULL, 
                         .rgn = param_rgn_opt,
                         .attributes = NULL, .escapes = false}};
    vds = new{List(vd, vds)};
    locals = rnew(r) Bindings{(*args->hd)[0], new Param_b(vd), locals};
  }
  if (fd->cyc_varargs != NULL) {
    let VarargInfo{nopt,tq,t,i} = *fd->cyc_varargs;
    if (nopt != NULL) {
      let typ = dyneither_typ(t, param_rgn, tq, false_conref);
      let vd = new{Vardecl{.sc = Public,
                           .name = new $((nmspace_t)Loc_n,nopt->v),
                           .tq = empty_tqual(NULL),
                           .type = typ,
                           .initializer = NULL,
                           .rgn = param_rgn_opt,
                           .attributes = NULL, .escapes = false}};
      vds = new List(vd,vds);
      locals = rnew(r) Bindings{nopt->v, new Param_b(vd), locals};
    } 
    else terr(loc,"missing name for varargs");
  }
  fd->param_vardecls = new{Opt(imp_rev(vds))};
  return rnew(r) 
    Fenv{.shared = rnew(r) SharedFenv{
                     .frgn = r,
                     .return_typ = fd->ret_type,
                     .seen_labels = Dict::rempty(r,strptrcmp),
                     .needed_labels = Dict::rempty(r,strptrcmp),
		     .delayed_effect_checks = NULL,
		     .delayed_constraint_checks = NULL
                   },
         .type_vars   = tvs,
         .region_order = rgn_po,
         .locals      = locals,  // assumed unique
         .encloser    = fd->body, // careful -- self loop at top!!!
         .ctrl_env    = rnew(r) CtrlEnv(r, &NotLoop_j_val, &NotLoop_j_val, NULL, &FnEnd_j_val, 0),
         .capability  = new JoinEff(new List(new AccessEff(param_rgn),
                                             new List(fd->effect->v,NULL))),
         .curr_rgn    = param_rgn,
         .in_notreadctxt = false, 
         .fnrgn       = r
       };
}

fenv_t<`r> nested_fenv(seg_t loc, fenv_t<`r> old_fenv, fndecl_t fd) {
  let &Fenv{<`f,`c> .locals = old_locals, .region_order = rgn_po, 
               .type_vars = type_vars, .shared = shared, .fnrgn = fr, ...} = old_fenv;
  let r = shared->frgn;
  let locals = (bindings_t<`r>)old_locals;
  tvar_t rgn0 = 
    new Tvar(new ((string_t)aprintf("`%s",*(*fd->name)[1])),
             new_tvar_id(), &rgn_kb);
  // add in all of the region vars
  for (let tvars = fd->tvs; tvars != NULL; tvars = tvars->tl)
    if (tvar_kind(tvars->hd,BoxKind) == RgnKind)
      rgn_po = add_youngest(r, rgn_po, tvars->hd, false, false);
    else if (tvar_kind(tvars->hd,BoxKind) == UniqueRgnKind ||
	     tvar_kind(tvars->hd,BoxKind) == TopRgnKind)
      Tcutil::impos("non-intuitionistic tvar in nested_fenv");
  rgn_po = add_youngest(r, rgn_po, rgn0, false, false);
  let tvs = new List(rgn0,List::append(fd->tvs,type_vars));
  Tcutil::check_unique_tvars(loc,tvs);
  type_t param_rgn = new VarType(rgn0);
  opt_t<type_t> param_rgn_opt = new Opt(param_rgn);
  let vds = NULL;
  for(let args = fd->args; args != NULL; args = args->tl) {
    let vd = new{Vardecl{.sc = Public, 
			 .name = new $((nmspace_t)Loc_n,(*args->hd)[0]),
			 .tq = (*args->hd)[1],
			 .type = (*args->hd)[2],
			 .initializer = NULL, 
                         .rgn = param_rgn_opt,
                         .attributes = NULL, .escapes = false}};
    vds = new{List(vd, vds)};
    locals = rnew(r) Bindings{(*args->hd)[0], new Param_b(vd), locals};
  }
  if (fd->cyc_varargs != NULL) {
    let VarargInfo{nopt,tq,t,i} = *fd->cyc_varargs;
    if (nopt != NULL) {
      let typ = dyneither_typ(t, param_rgn, tq, false_conref);
      let vd = new{Vardecl{.sc = Public,
                           .name = new $((nmspace_t)Loc_n,nopt->v),
                           .tq = empty_tqual(NULL),
                           .type = typ,
                           .initializer = NULL,
                           .rgn = param_rgn_opt,
                           .attributes = NULL, .escapes = false}};
      vds = new List(vd,vds);
      locals = rnew(r) Bindings{nopt->v, new Param_b(vd), locals};
    } 
    else terr(loc,"missing name for varargs");
  }
  fd->param_vardecls = new{Opt(imp_rev(vds))};
  return rnew(r) 
    Fenv{.shared = rnew(r) SharedFenv{
                     .frgn = r,
                     .return_typ = fd->ret_type,
                     .seen_labels = Dict::rempty(r,strptrcmp),
                     .needed_labels = Dict::rempty(r,strptrcmp),
		     .delayed_effect_checks = NULL,
		     .delayed_constraint_checks = NULL
                   },
         .type_vars   = tvs,
         .region_order = rgn_po,
         .locals      = locals,  // assumed unique
         .encloser    = fd->body, // careful -- self loop at top!!!
         .ctrl_env    = rnew(r) CtrlEnv(r, &NotLoop_j_val, &NotLoop_j_val, NULL, &FnEnd_j_val, 0),
         .capability  = new JoinEff(new List(new AccessEff(param_rgn),
                                             new List(fd->effect->v,NULL))),
         .curr_rgn    = param_rgn,
         .in_notreadctxt = false,
         .fnrgn       = fr
       };
}
