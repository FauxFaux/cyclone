/* Type environments.
   Copyright (C) 2001 Greg Morrisett, AT&T
   This file is part of the Cyclone compiler.

   The Cyclone compiler is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   The Cyclone compiler is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with the Cyclone compiler; see the file COPYING. If not,
   write to the Free Software Foundation, Inc., 59 Temple Place -
   Suite 330, Boston, MA 02111-1307, USA. */


/* An identifier can have at most one binding in each of the following:

   1) namespaces (after "namespace" or "using")
   2) structure tags (after "struct")
   3) union tags (after "union")
   4) structure or union members (after "." or "->")
   5) tunion tags (after "tunion")
   7) labels (after "goto", before ":")
   8) typedef names (in types)
   9) ordinary identifiers (the catch-all case)

   The ordinary identifiers include structure tags and tunion
   constructors.

   The environment data structures below follow from this directly.
   Note that labels can only appear inside of functions, so they don't
   appear in global environments.  And structure and union members
   must be resolved on a per-structure/per-union basis (e.g., two
   structs can have members with the same names) so their bindings
   don't belong in our environments.
*/

/* During type checking we keep two parallel environments.  One is
   accessed by absolute name, the other by local name.  We need these
   two environments because what is defined in a namespace is
   different from what is available in the namespace.  E.g.,

      extern int z;
      namespace Foo {
        int x;
        namespace Bar {
          int y = x;
        }
      }

   Here x is available in the inner namespace Bar but not defined
   there.  The absolute namespace will have entries for ::z, ::Foo::x,
   ::Foo::Bar, and ::Foo::Bar::y.  The relative namespace just after
   the definition of y will have entries for x, y, and z.
*/

#include <core.h>
#include <stdio.h>
#include <list.h>
#include <dict.h>
#include <set.h>
#include <dict.h>
#include <slowdict.h>
#include <position.h>
#include <string.h>
#include "absynpp.h"
#include "absyn.h"
#include "tcutil.h"
#include "tcenv.h"

namespace Tcenv;

using Core;
using List;
using Set;
using Position;
using Absyn;
using Tcutil;
using Absynpp;

xtunion exn {Env_error};

`a env_err(string_t msg) {
  fprintf(stderr,"Error: %s\n",msg);
  fflush(stderr);
  throw Env_error;
}

/////////////////////////// Type Definitions /////////////////////////////////

// Type environments
struct Tenv {
  list_t<var_t>                      ns; // current namespace
  Dict::dict_t<list_t<var_t>,genv_t> ae; // absolute environment
  opt_t<frames_t<fenv_t>>            le; // is NULL except in functions
};

// Global environments -- what's declared in a global scope
struct Genv {
  set_t<var_t>                      namespaces;
  Dict::dict_t<var_t,structdecl_t@> structdecls;
  Dict::dict_t<var_t,uniondecl_t@>  uniondecls;
  Dict::dict_t<var_t,tuniondecl_t@> tuniondecls;
  Dict::dict_t<var_t,enumdecl_t@>   enumdecls;
  Dict::dict_t<var_t,typedefdecl_t> typedefs; // no indirection b/c no redeclaration
  Dict::dict_t<var_t,$(resolved_t,bool)@> ordinaries; // bool for tree-shaking
  list_t<list_t<var_t>> availables; // abs. names of "using" namespaces
};

// Used to tell what an ordinary identifer refers to
tunion Resolved {
  VarRes(binding_t); // includes unresolved variant
  StructRes(structdecl_t);
  TunionRes(tuniondecl_t,tunionfield_t);
  EnumRes(enumdecl_t,enumfield_t);
};

// Models the nesting of the RTCG constructs
tunion Frames<`a> {
  Outermost(`a);
  Frame(`a,tunion Frames<`a>);
  Hidden(`a,tunion Frames<`a>);
};

tunion Jumpee {
  NotLoop_j;
  CaseEnd_j;
  FnEnd_j;
  Stmt_j(stmt_t);
};

static struct CtrlEnv {
  jumpee_t continue_stmt;
  jumpee_t break_stmt;
             // NULL => not allowed
  $(switch_clause_t, list_t<tvar_t>, list_t<type_t>) * fallthru_clause; 
  jumpee_t next_stmt; // needed to calculate break_stmt
  int      try_depth;
  // The next_stmt field needs to be correct only when we might enter
  // a loop or switch. (i.e. when we call set_in_loop or set_in_switch)
};
typedef struct CtrlEnv @ ctrl_env_t;

// This part is shared throughout type-checking of a function.
// Hence mutations are seen by all subsequent type-checking, which is easier
// than threading labels which must be function-wide unique anyway.
static struct SharedFenv {
  type_t                             return_typ;
  Dict::dict_t<var_t,stmt_t>         seen_labels;
  SlowDict::dict_t<var_t,list_t<stmt_t>> needed_labels;
};

// Encodes partial order for region lifetimes
static struct RgnPO {
  tvar_t tvar;
  list_t<struct RgnPO @> ancestors;
};
typedef list_t<struct RgnPO @> rgn_po_t;

// Local function environments -- this is getting a bit out of hand, no?
abstract struct Fenv {
  struct SharedFenv @      shared;
  list_t<tvar_t>           type_vars; //type variables that can occur free
  rgn_po_t                 region_order; // partial order on region variables 
  Dict::dict_t<var_t,binding_t> locals;//binding one of Param_b, Local_b, Pat_b
  stmt_t                   encloser;  // nearest stmt with a binder or a try
  ctrl_env_t               ctrl_env;
  type_t                   capability; 
  type_t                   curr_rgn;   // current block's region
};

//////////////////////// Top-level Environment Manipulation //////////////////

tenv_t tc_init() {
  // Initialize globals
  empty_var_set = new Opt(Set::empty(zstrptrcmp));
  // Set up initial environment so that xtunion exn, etc. is defined
  let ge     = empty_genv();
  let top_ns = NULL;
  ge->tuniondecls = 
    Dict::insert(ge->tuniondecls, (*exn_name)[1], 
		 &exn_tud);
  ge->ordinaries = 
    Dict::insert(ge->ordinaries, (*null_pointer_exn_name)[1],
		 new $(new TunionRes(exn_tud, null_pointer_exn_tuf), true));
  ge->ordinaries = 
    Dict::insert(ge->ordinaries, (*match_exn_name)[1],
		 new $(new TunionRes(exn_tud, match_exn_tuf), true));
  Dict::dict_t<list_t<var_t,`H>,genv_t,`H> ae = 
    Dict::insert(Dict::empty(varlist_cmp), top_ns, ge);
  return new Tenv(top_ns,ae,NULL);
}

// Lookup a namespace relative to the current namespace
static genv_t lookup_namespace(tenv_t te, seg_t loc,
                               var_t n, list_t<var_t,`H> ns) {
  return Dict::lookup(te->ae, resolve_namespace(te,loc,n,ns));
}

// lookup functions
static list_t<var_t> outer_namespace(list_t<var_t> ns) {
  if (ns == NULL)
    return env_err("Tcenv::outer_namespace");
  return List::rev(List::rev(ns)->tl);
}

static bool same_namespace(list_t<var_t,`H> n1, list_t<var_t,`H> n2) {
  if (n1 == n2) return true;
  for (; n1 != NULL; n1 = n1->tl) {
    if (n2 == NULL) return false;
    if (zstrptrcmp(n1->hd,n2->hd) != 0) return false;
    n2 = n2->tl;
  }
  if (n2 != NULL) return false;
  return true;
}

// FIX: We should eagerly detect repeats by having one big dict
// that we recompute on namespace and using boundaries
static void check_repeat(tenv_t te, seg_t loc, `a lookup(genv_t,var_t),
			 var_t v, 
			 list_t<var_t,`H> cns,
			 list_t<list_t<var_t,`H>,`H> nss) {
  for(; nss != NULL; nss = nss->tl) {
    if (!same_namespace(cns,nss->hd)) {
      genv_t ge2 = Dict::lookup(te->ae,nss->hd);
      try {
	lookup(ge2,v);
	Tcutil::terr(loc,"%s is ambiguous",*v);
      } catch { case Dict::Absent: break; }
    }
  }
  return;
}

static `a scoped_lookup(tenv_t te,seg_t loc,`a lookup(genv_t,var_t),var_t v){
  list_t<var_t> cns = te->ns; // current namespace
  while (true) {
    genv_t ge = Dict::lookup(te->ae,cns);
    // Check current namespace
    try {
      `a result = lookup(ge,v);
      check_repeat(te, loc, lookup, v, cns, ge->availables);
      return result;
    } catch { case Dict::Absent: break; }
    // Check available namespaces
    for (let nss = ge->availables; nss != NULL; nss = nss->tl) {
      genv_t ge2 = Dict::lookup(te->ae,nss->hd);
      try {
	`a result = lookup(ge2,v);
	check_repeat(te, loc, lookup, v, nss->hd, nss->tl);
	return result;
      } catch { case Dict::Absent: break; }
    }
    if (cns == NULL)
      throw Dict::Absent;
    // v is not defined in current namespace, look in next outer
    cns = outer_namespace(cns);
  }
}

static resolved_t lookup_ordinary_global_f(genv_t ge,var_t v) {
  $(resolved_t,bool)@ ans = Dict::lookup(ge->ordinaries,v);
  (*ans)[1] = true;
  return (*ans)[0];
}
static resolved_t lookup_ordinary_global(tenv_t te,seg_t loc,qvar_t q) {
  let &$(nsl,v) = q;
  switch (nsl) {
  case Loc_n: fallthru;
  case &Rel_n(NULL):
    return scoped_lookup(te, loc, lookup_ordinary_global_f, v);
  case &Rel_n(&List(x,y)):
    let ge = lookup_namespace(te,loc,x,y);
    return lookup_ordinary_global_f(ge,v);
  case &Abs_n(y):
    return lookup_ordinary_global_f(Dict::lookup(te->ae,y),v);
  }
}

// Return the absolute name of relative namespace &List(n,ns)
list_t<var_t> resolve_namespace(tenv_t te, seg_t loc,
                                var_t n, list_t<var_t,`H> ns) {
  let cns = te->ns; // current namespace
  let possible_results = NULL;
  while (true) {
    let ge = Dict::lookup(te->ae,cns);
    // Check namespaces that have been made available
    for (let nss = ge->availables; nss != NULL; nss = nss->tl) {
      genv_t ge2 = Dict::lookup(te->ae,nss->hd);
      if (Set::member(ge2->namespaces, n))
        possible_results = new List(List::append(cns,new List(n,ns)),
                                    possible_results);
    }
    // Check current namespace
    if (Set::member(ge->namespaces, n))
      possible_results = new List(List::append(cns,new List(n,ns)),
                                  possible_results);
    // Is this right? We check for ambiguity between the current namespace
    // and used namespaces in the current scope, but not outer namespaces.
    // Seems inconsistent.
    if (possible_results != NULL) {
      if (possible_results->tl != NULL)
        Tcutil::terr(loc,"%s is ambiguous",*(n));
      return possible_results->hd;
    }
    if (cns == NULL)
      throw Dict::Absent;
    // n is not defined in current namespace, look in next outer
    cns = outer_namespace(cns);
  }
}

// The absolute versions aren't being used right now, but it's
// important to think about whether they are correct in certain contexts.

static structdecl_t @ lookup_structdecl_f(genv_t ge,var_t v) {
  return Dict::lookup(ge->structdecls,v);
}
structdecl_t @ lookup_structdecl(tenv_t te,seg_t loc,qvar_t q) {
  let &$(nsl,v) = q;
  switch (nsl) {
  case Loc_n: fallthru;
  case &Rel_n(NULL):
    return scoped_lookup(te, loc, lookup_structdecl_f, v);
  case &Abs_n(y):
    let ge = Dict::lookup(te->ae,y);
    return Dict::lookup(ge->structdecls,v);
  case &Rel_n(&List(x,y)):
    let ge = lookup_namespace(te,loc,x,y);
    return Dict::lookup(ge->structdecls,v);
  }
}

static uniondecl_t @ lookup_uniondecl_f(genv_t ge,var_t v) {
  return Dict::lookup(ge->uniondecls,v);
}
uniondecl_t @ lookup_uniondecl(tenv_t te,seg_t loc,qvar_t q) {
  let &$(nsl,v) = q;
  switch (nsl) {
  case Loc_n: fallthru;
  case &Rel_n(NULL):
    return scoped_lookup(te, loc, lookup_uniondecl_f, v);
  case &Abs_n(y):
    let ge = Dict::lookup(te->ae,y);
    return Dict::lookup(ge->uniondecls,v);
  case &Rel_n(&List(x,y)):
    let ge = lookup_namespace(te,loc,x,y);
    return Dict::lookup(ge->uniondecls,v);
  }
}

static tuniondecl_t @ lookup_tuniondecl_f(genv_t ge,var_t v) {
  return Dict::lookup(ge->tuniondecls,v);
}
tuniondecl_t @ lookup_tuniondecl(tenv_t te,seg_t loc,qvar_t q) {
  let &$(nsl,v) = q;
  switch (nsl) {
  case Loc_n: fallthru;
  case &Rel_n(NULL):
    return scoped_lookup(te, loc, lookup_tuniondecl_f, v);
  case &Rel_n(&List(x,y)):
    let ge = lookup_namespace(te,loc,x,y);
    return Dict::lookup(ge->tuniondecls,v);
  case &Abs_n(y):
    let ge = Dict::lookup(te->ae,y);
    return Dict::lookup(ge->tuniondecls,v);
  }
}

static tuniondecl_t @ lookup_xtuniondecl_f(genv_t ge,var_t v) {
  return Dict::lookup(ge->tuniondecls,v);
}

// DAN: some functionality from tcXTuniondecl has moved to here.
opt_t<tuniondecl_t@> lookup_xtuniondecl(tenv_t te,seg_t loc,qvar_t q) {
  let &$(nsl,v) = q;
  switch (nsl) {
  case &Rel_n(NULL):
    // unqualified name, okay to fail -- that just means we have a new xtunion
    try return new Opt(scoped_lookup(te, loc, lookup_xtuniondecl_f, v));
    catch { case Dict::Absent: return NULL; }
  case Loc_n: // impossible case
    terr(loc,"lookup_xtuniondecl: impossible");
    return NULL;
  case &Rel_n(&List(x,y)):
    // qualified name, it's an error if the namespace is bad or the
    // xtunion doesn't already exist.  In either case, we'll raise
    // Dict::Absent, so we give a more descriptive message for the
    // former.
    genv_t ge;
    try ge = lookup_namespace(te,loc,x,y);
    catch {
    case Dict::Absent:
      Tcutil::terr(loc,"bad qualified name for xtunion");
      throw Dict::Absent;
    }
    return new Opt(Dict::lookup(ge->tuniondecls,v));
  case &Abs_n(y):
    genv_t ge = Dict::lookup(te->ae,y);
    return new Opt(Dict::lookup(ge->tuniondecls,v));
  }
}
//// FIX: We probably need some of the lenience of lookup_xtuniondecl here too.
////     I would add it, but I think xtunions are still generally sorta busted.
//opt_t<xtuniondecl_t@> lookup_xtuniondecl_abs(tenv te, seg_t loc,qvar q) {
//  return &Opt(Dict::lookup(Dict::lookup(te->ae,(*q)[0])->tuniondecls, (*q)[1]));
//}

static enumdecl_t @lookup_enumdecl_f(genv_t ge, var_t v) {
  return Dict::lookup(ge->enumdecls,v);
}

enumdecl_t @lookup_enumdecl(tenv_t te, seg_t loc, qvar_t q) {
  let &$(nsl,v) = q;
  switch (nsl) {
  case Loc_n: fallthru;
  case &Rel_n(NULL):
    return scoped_lookup(te, loc, lookup_enumdecl_f, v);
  case &Rel_n(&List(x,y)):
    let ge = lookup_namespace(te,loc,x,y);
    return Dict::lookup(ge->enumdecls,v);
  case &Abs_n(y):
    let ge = Dict::lookup(te->ae,y);
    return Dict::lookup(ge->enumdecls,v);
  }
}

static typedefdecl_t lookup_typedefdecl_f(genv_t ge,var_t v) {
  return Dict::lookup(ge->typedefs,v);
}
typedefdecl_t lookup_typedefdecl(tenv_t te, seg_t loc, qvar_t q) {
  let &$(nsl,v) = q;
  switch (nsl) {
  case Loc_n: fallthru;
  case &Rel_n(NULL):
    return scoped_lookup(te, loc, lookup_typedefdecl_f, v);
  case &Rel_n(&List(x,y)):
    let ge = lookup_namespace(te,loc,x,y);
    return Dict::lookup(ge->typedefs,v);
  case &Abs_n(y):
    let ge = Dict::lookup(te->ae,y);
    return Dict::lookup(ge->typedefs,v);
  }
}

genv_t empty_genv() {
  return new 
    Genv{.namespaces  = empty_var_set->v,
            .structdecls   = Dict::empty(zstrptrcmp),
            .uniondecls    = Dict::empty(zstrptrcmp),
            .tuniondecls   = Dict::empty(zstrptrcmp),
            .enumdecls     = Dict::empty(zstrptrcmp),
            .typedefs      = Dict::empty(zstrptrcmp),
            .ordinaries    = Dict::empty(zstrptrcmp),
            .availables    = NULL};
}

////////////////////////////// Frames Manipulation //////////////////////////

`a get_visible(frames_t<`a> f) {
  while(true)
    switch (f) {
    case &Outermost(x): return x;
    case &Frame(x,_):   return x;
    case &Hidden(x,y):  f = y; break;
    }
}

frames_t<`a> put_visible(frames_t<`a> f, `a x) {
  switch (f) {
  case &Outermost(x2): return new Outermost(x);
  case &Frame(x2,f2):  return new Frame(x,f2);
  case &Hidden(x2,f2): return new Hidden(x2,put_visible(f2,x));
  }
}

frames_t<`a> apply_to_visible(`a g(`a), frames_t<`a> f) {
  return put_visible(f,g(get_visible(f)));
}

frames_t<`b> map_frames(`b g(`a), frames_t<`a> f) {
  switch (f) {
  case &Outermost(x): return new Outermost(g(x));
  case &Frame(x,f2):  return new Frame(g(x),map_frames(g,f2));
  case &Hidden(x,f2): return new Hidden(g(x),map_frames(g,f2));
  }
}

fenv_t get_fenv(tenv_t te) {
  if (te->le == NULL) throw Env_error;
  return get_visible(te->le->v);
}

tenv_t put_fenv(tenv_t te, fenv_t fe) {
  if (te->le == NULL) throw Env_error;
  return new Tenv(te->ns, te->ae, new Opt(put_visible(te->le->v,fe)));
}

////////////////////////////// Region Partial Orders ////////////////////////

// is region r reachable from the list of ancestors?
static bool region_ancestor(rgn_po_t ancestors, tvar_t r) {
  // look in immediate ancestors
  for (_ a = ancestors; a != NULL; a = a->tl)
    if (tvar_cmp(a->hd->tvar,r) == 0) return true;
  // look in ancestors ancestors
  for (_ a = ancestors; a != NULL; a = a->tl)
    if (region_ancestor(a->hd->ancestors,r)) return true;
  return false;
}

static struct RgnPO @find_region_in_po(rgn_po_t po, tvar_t r) {
  for (; po != NULL; po = po->tl) {
    if (tvar_cmp(po->hd->tvar,r) == 0) return po->hd;
  }
  return env_err(aprintf("can't find region variable %s in po",
                         typ2string(new VarType(r))));
}

// does r1 outlive r2?
static bool check_region_outlives(rgn_po_t po, tvar_t r1, tvar_t r2) {
  rgn_po_t r2_ancestors;
  while (po != NULL && tvar_cmp(po->hd->tvar, r2) != 0) po=po->tl;
  if (po == NULL) return false;
  return region_ancestor(po->hd->ancestors,r1);
}

// given the list of type-variables for a function, build the initial
// partial order for the region variables.  The po should have each
// region being incomparable (i.e., have an empty set of ancestors.)
// then add in the partial order given and check that it's consistent
// and that there are no circularities.  
static rgn_po_t initial_region_po(seg_t loc, list_t<tvar_t> tvs,
                                  list_t<$(type_t,type_t)@> po) {
  rgn_po_t result = NULL;
  for (; tvs != NULL; tvs = tvs->tl) {
    tvar_t tv = tvs->hd;
    if (tvar_kind(tv) == RgnKind) {
      result = new List(new RgnPO{.tvar=tv, .ancestors=NULL},result);
    }
  }
  for (; po != NULL; po = po->tl) {
    switch (*(po->hd)) {
    case $(HeapRgn,_): break; // every region is implicitly a descendant of `H
    case $(&VarType(r1),&VarType(r2)):
      // r2 has r1 as an ancestor.  Make sure that r1 and r2 aren't the
      // same region, and that r1 doesn't have r2 as an ancestor.
      if (tvar_cmp(r1,r2) == 0 || check_region_outlives(result,r2,r1))
        terr(loc,"bad region lifetime assertion (circularity):%s < %s",
             typ2string(new VarType(r1)), 
             typ2string(new VarType(r2)));
      else {
        // go find r1's po entry and add it to r2's po entry
        let r1 = find_region_in_po(result,r1);
        let r2 = find_region_in_po(result,r2);
        r2->ancestors = new List(r1,r2->ancestors);
      }
      break;
    case $(t1,t2):
      terr(loc,"bad region lifetime assertion:: %s < %s",
           typ2string(t1), typ2string(t2));
      break;
    }
  }
  return result;
}

// add a new region variable to the given partial order.  All previously
// declared regions are ancestors.
static rgn_po_t add_region_po(rgn_po_t po, tvar_t tv) {
  return new List(new RgnPO{.tvar = tv, .ancestors = po}, po);
}

//////////////////// Function Environment Manipulation //////////////////////

static fenv_t copy_fenv_old_ctrl(fenv_t f) {
  return new Fenv(f->shared, f->type_vars, f->region_order,
                  f->locals, f->encloser, f->ctrl_env,
                  f->capability, f->curr_rgn);
}
static fenv_t copy_fenv_new_ctrl(fenv_t f) {
  // WARNING: fallthru_clause shared with old
  ctrl_env_t c = f->ctrl_env;
  return new Fenv(f->shared, f->type_vars, f->region_order, 
                  f->locals, f->encloser,
                  new CtrlEnv(c->continue_stmt, c->break_stmt, 
                              c->fallthru_clause,
                              c->next_stmt, c->try_depth),
                  f->capability, f->curr_rgn);
}

type_t return_typ(tenv_t te) {
  if(te->le == NULL) env_err("Tcenv: unexpected return_typ");
  return get_fenv(te)->shared->return_typ;
}

list_t<tvar_t> lookup_type_vars(tenv_t te) {
  if(te->le == NULL) return NULL;
  return get_fenv(te)->type_vars;
}

tenv_t add_type_vars(seg_t loc,tenv_t te,list_t<tvar_t> tvs) {
  if(te->le == NULL) env_err("Tcenv: unexpected add_type_vars");
  let fe      = copy_fenv_old_ctrl(get_fenv(te));
  // add unique identities to the type variables;
  add_tvar_identities(tvs);
  let new_tvs = List::append(tvs,fe->type_vars);
  Tcutil::check_unique_tvars(loc,new_tvs);
  fe->type_vars = new_tvs;
  return put_fenv(te,fe);
}

tenv_t add_local_var(seg_t loc, tenv_t te, vardecl_t vd) {
  if(te->le == NULL) env_err("Tcenv: unexpected add_local_var");
  let fe = copy_fenv_old_ctrl(get_fenv(te));
  let v  = (*vd->name)[1];
  switch ((*vd->name)[0]) {
  case Loc_n: break;
  default:
    // This is a fail-safe.
    // Maybe we should just clobber with Loc_n?
    throw new Impossible("add_local_var: called with Rel_n");
    break;
  }
  fe->locals = Dict::insert(fe->locals,v,new Local_b(vd));
  return put_fenv(te,fe);
}

// assume uniqueness has been checked elsewhere
tenv_t add_pat_var(seg_t loc, tenv_t te, vardecl_t vd) {
  if(te->le == NULL) env_err("Tcenv: unexpected add_pat_var");
  let fe = copy_fenv_old_ctrl(get_fenv(te));
  let v  = (*vd->name)[1];
  fe->locals = Dict::insert(fe->locals,v,new Pat_b(vd));
  return put_fenv(te,fe);
}

resolved_t lookup_ordinary(tenv_t te,seg_t loc,qvar_t q) {
  let &$(nsl,v) = q;
  switch (nsl) {
  case Loc_n:
    if (te->le == NULL) { throw Dict::Absent; }
    else fallthru;
  case &Rel_n(NULL) && te->le != NULL:
    let fe = get_fenv(te);
    // NB a local overrides any global, without an ambiguity warning
    try return new VarRes(Dict::lookup(fe->locals,v));
    catch {case Dict::Absent: return lookup_ordinary_global(te,loc,q);}
  default:
    try return lookup_ordinary_global(te,loc,q);    
    catch {
    case Dict::Absent: 
      terr(loc,"unbound identifier: %s", Absynpp::qvar2string(q));
      return new VarRes(Unresolved_b);
    }
  }
}

void process_continue(tenv_t te, stmt_t s, stmt_opt_t @sopt) {
  if (te->le == NULL) env_err("Tcenv: unexpected process_continue");
  switch (get_fenv(te)->ctrl_env->continue_stmt) {
  case &Stmt_j(s2):
    s2->non_local_preds = new List(s,s2->non_local_preds);
    *sopt = s2;
    return;
  case NotLoop_j: terr(s->loc, "continue not in a loop");     return;
  case CaseEnd_j: env_err("Tcenv: continue dest is CaseEnd"); return;
  case FnEnd_j:   env_err("Tcenv: continue dest is CaseEnd"); return;
  }
}
void process_break(tenv_t te, stmt_t s, stmt_opt_t @sopt) {
  if (te->le == NULL) env_err("Tcenv: unexpected process_break");
  fenv_t fe = get_fenv(te);
  switch (fe->ctrl_env->break_stmt) {
  case &Stmt_j(s2):
    s2->non_local_preds = new List(s,s2->non_local_preds);
    *sopt = s2;
    return;
  case NotLoop_j:
    terr(s->loc, "break not in a loop or switch");
    return;
  case FnEnd_j:
    // Note doing this here is more conservative than in control-flow.
    // Eg: while(true) if(false) break; else return 0;
    // But it's a pain to do in control flow because there is no stmt dest
    if(fe->shared->return_typ != (type_t)VoidType)
      terr(s->loc, "break causes function not to return a value");
    return;
  case CaseEnd_j:
    // Analogous comment to previous case applies.
    terr(s->loc, "break causes outer switch clause to implicitly fallthru");
    return;
  }
}
void process_goto(tenv_t te, stmt_t s, var_t l, stmt_opt_t @sopt) {
  if (te->le == NULL) env_err("Tcenv: unexpected process_goto");
  fenv_t fe    = get_fenv(te);
  let    sopt2 = Dict::lookup_opt(fe->shared->seen_labels, l);
  if(sopt2 == NULL) {
    let needed = fe->shared->needed_labels;
    let slopt  = SlowDict::lookup_opt(needed, l);
    if(slopt == NULL)
      slopt = new Opt(NULL);
    fe->shared->needed_labels = SlowDict::insert(needed,l,new List(s,slopt->v));
  } else {
    sopt2->v->non_local_preds = new List(s, sopt2->v->non_local_preds);
    *sopt = sopt2->v;
  }
}
$(switch_clause_t,list_t<tvar_t>,list_t<type_t>)* 
process_fallthru(tenv_t te,stmt_t s, switch_clause_t *@ clauseopt){
  if (te->le == NULL) env_err("Tcenv: unexpected process_fallthru");
  let fe  = get_fenv(te);
  let ans = fe->ctrl_env->fallthru_clause;
  if(ans != NULL) {
    (*ans)[0]->body->non_local_preds = 
      new List(s, (*ans)[0]->body->non_local_preds);
    *clauseopt = new{(*ans)[0]};
  }
  return ans;
}

tenv_t set_fallthru(tenv_t te, list_t<tvar_t,`H> new_tvs, 
                    list_t<vardecl_t> vds, 
		    switch_clause_t clause) {
  if(te->le == NULL) env_err("Tcenv: unexpected set_fallthru");
  let ft_typ = NULL;
  for(; vds!=NULL; vds=vds->tl)
    ft_typ = new List(vds->hd->type,ft_typ);
  ft_typ = List::imp_rev(ft_typ);
  fenv_t fe = copy_fenv_new_ctrl(get_fenv(te));
  fe->ctrl_env->fallthru_clause = new $(clause,new_tvs,ft_typ);
  return put_fenv(te,fe);
}
// fallthru is illegal in the last case
tenv_t clear_fallthru(tenv_t te) {
  if(te->le == NULL) env_err("Tcenv: unexpected clear_fallthru");
  fenv_t fe = copy_fenv_new_ctrl(get_fenv(te));
  fe->ctrl_env->fallthru_clause = NULL;
  return put_fenv(te,fe);
}

tenv_t set_in_loop(tenv_t te, stmt_t continue_dest) {
  if (te->le == NULL) env_err("Tcenv: unexpected set_in_loop");
  fenv_t fe = copy_fenv_new_ctrl(get_fenv(te));
  fe->ctrl_env->continue_stmt = new Stmt_j(continue_dest);
  fe->ctrl_env->break_stmt    = fe->ctrl_env->next_stmt; // break goes to next
  fe->ctrl_env->next_stmt     = new Stmt_j(continue_dest);   // next starts as cont
  return put_fenv(te,fe);
}

tenv_t enter_try(tenv_t te) {
  if (te->le == NULL) env_err("Tcenv: unexpected enter_try");
  fenv_t fe = copy_fenv_new_ctrl(get_fenv(te));
  ++fe->ctrl_env->try_depth;
  return put_fenv(te,fe);
}
int get_try_depth(tenv_t te) {
  if (te->le == NULL) env_err("Tcenv: unexpected get_try_depth");
  return get_fenv(te)->ctrl_env->try_depth;
}

// each non-last case must also call set_fallthru, here we just
// change the break destination
tenv_t set_in_switch(tenv_t te) {
  if (te->le == NULL) env_err("Tcenv: unexpected set_in_switch");
  fenv_t fe  = copy_fenv_new_ctrl(get_fenv(te));
  fe->ctrl_env->break_stmt = fe->ctrl_env->next_stmt; // break goes to next
  fe->ctrl_env->next_stmt  = CaseEnd_j; // prevent nested break to fallthru
  return put_fenv(te,fe);
}

tenv_t set_next(tenv_t te, jumpee_t j) {
  if (te->le == NULL) env_err("Tcenv: unexpected set_next");
  fenv_t fe = copy_fenv_new_ctrl(get_fenv(te));
  fe->ctrl_env->next_stmt = j;
  return put_fenv(te,fe);
}

tenv_t add_label(tenv_t te, var_t v, stmt_t s) {
  if (te->le == NULL) env_err("Tcenv: unexpected add_label");
  let fe     = get_fenv(te);
  let needed = fe->shared->needed_labels;
  let sl_opt = SlowDict::lookup_opt(needed, v);
  if(sl_opt != NULL) {
    fe->shared->needed_labels = SlowDict::delete(needed, v);
    // backpatching
    let sl = sl_opt->v;
    s->non_local_preds = sl;
    for(; sl != NULL; sl = sl->tl)
      switch (sl->hd->r) {
      case &Goto_s(_,*so): *so = s; break;
      default: env_err("Tcenv: add_label backpatching of non-goto"); break;
      }
  }
  if(Dict::member(fe->shared->seen_labels, v))
    Tcutil::terr(s->loc, "Repeated label: %s", *v);
  fe->shared->seen_labels = Dict::insert(fe->shared->seen_labels, v, s);
  return te;
}

bool all_labels_resolved(tenv_t te) {
  return SlowDict::is_empty(get_fenv(te)->shared->needed_labels);
}

stmt_t get_encloser(tenv_t te) {
  if (te->le == NULL) env_err("Tcenv: unexpected get_encloser");
  return get_fenv(te)->encloser;
}
tenv_t set_encloser(tenv_t te, stmt_t s) {
  if (te->le == NULL) env_err("Tcenv: unexpected set_encloser");
  fenv_t fe  = copy_fenv_old_ctrl(get_fenv(te));
  fe->encloser = s;
  return put_fenv(te,fe);
}

tenv_t add_region(tenv_t te, type_t r) {
  if (te->le == NULL) env_err("Tcenv::add_region: unexpected add_region");
  fenv_t fe = copy_fenv_old_ctrl(get_fenv(te));
  tvar_t tv;
  switch (compress(r)) {
  case &VarType(x): tv = x; break;
  default: tv = env_err("bad add region"); break;
  }
  fe->region_order = add_region_po(fe->region_order, tv);
  fe->capability = new JoinEff(new List(new AccessEff(r),
                                        new List(fe->capability,NULL)));
  return put_fenv(te,fe);
}

tenv_t new_named_block(seg_t loc, tenv_t te, tvar_t block_rgn) {
  if (te->le == NULL) env_err("Tcenv: unexpected new_block");
  fenv_t fe = copy_fenv_old_ctrl(get_fenv(te));
  type_t block_typ = new VarType(block_rgn);
  fe->type_vars = new List(block_rgn, fe->type_vars);
  Tcutil::check_unique_tvars(loc,fe->type_vars);
  fe->region_order = add_region_po(fe->region_order, block_rgn);
  fe->capability = new JoinEff(new List(new AccessEff(block_typ), 
                                        new List(fe->capability,NULL)));
  fe->curr_rgn = block_typ;
  return put_fenv(te,fe);
}

tenv_t new_block(seg_t loc, tenv_t te) {
  tvar_t t = new_tvar(RgnKind);
  add_tvar_identity(t);
  return new_named_block(loc, te, t);
}

type_t curr_rgn(tenv_t te) {
  if (te->le == NULL) return HeapRgn; 
  return get_fenv(te)->curr_rgn;
}

// Check that rgn_typ is currently accessible:  the heap region is always
// accessible, and a region variable r is accessible iff it appears in the
// capability.
void check_rgn_accessible(tenv_t te, seg_t loc, type_t rgn) {
  if (te->le != NULL) {
    type_t capability = get_fenv(te)->capability;
    if (region_in_effect(false, rgn, capability) ||
        region_in_effect(true, rgn, capability)) return;
  }
  terr(loc, "Expression accesses unavailable region %s", typ2string(rgn));
                    
}

// check that region rt_a outlives region rt_b using the partial order in
// the environment.  Assumes that rt_a <> rt_b.
bool region_outlives(tenv_t te, type_t rt_a, type_t rt_b) {
  rt_a = compress(rt_a);
  rt_b = compress(rt_b);
  if (rt_a == HeapRgn) return true;
  if (te->le != NULL) {
    switch ($(rt_a,rt_b)) {
    case $(&VarType(va), &VarType(vb)):
      return check_region_outlives(get_fenv(te)->region_order, va, vb);
    default: return false;
    }
  }
  return false;
}

// Check that a function call's effect is contained in the current
// capability.
void check_effect_accessible(tenv_t te, seg_t loc, type_t eff) {
  type_t capability;
  if (te->le == NULL) 
    capability = new JoinEff(NULL);
  else {
    let fenv = get_fenv(te);
    capability = fenv->capability;
  }
  // for function calls, we drive the slack in the function's effect to 
  // the empty effect
  if (!subset_effect(true, eff, capability))
    terr(loc, "Capability %s does not cover function's effect %s",
         typ2string(capability), typ2string(eff));
}

// Check that a function call's region partial order is compatible
// with the current region partial order
void check_rgn_partial_order(tenv_t te, seg_t loc, 
                             list_t<$(type_t,type_t)@> po) {
  for (; po != NULL; po = po->tl) {
    let &$(r1,r2) = po->hd;
    if (!region_outlives(te, r1, r2))
      terr(loc, "function requires that region %s outlive %s",
           typ2string(r1),typ2string(r2));
  }
}

fenv_t new_fenv(seg_t loc, fndecl_t fd) {
  Dict::dict_t<var_t,binding_t> locals = Dict::empty(zstrptrcmp);
  tvar_t rgn0 = 
    new Tvar(new ((string_t)aprintf("`%s",*(*fd->name)[1])),
             new_tvar_id(),
             new_conref(RgnKind));
  let tvs = new List(rgn0,fd->tvs);
  Tcutil::check_unique_tvars(loc,tvs);
  let rgn_po = add_region_po(initial_region_po(loc,fd->tvs,fd->rgn_po),rgn0);
  type_t param_rgn = new VarType(rgn0);
  let vds = NULL;
  for(let args = fd->args; args != NULL; args = args->tl) {
    let vd = new{Vardecl{.sc = Public, 
			 .name = new $((nmspace_t)Loc_n,(*args->hd)[0]),
			 .tq = (*args->hd)[1],
			 .type = (*args->hd)[2],
			 .initializer = NULL, 
                         .rgn = new Opt(param_rgn), 
                         .attributes = NULL}};
    vds = new{List(vd, vds)};
    locals = Dict::insert(locals, (*args->hd)[0], new Param_b(vd));
  }
  if (fd->cyc_varargs != NULL) {
    let VarargInfo{nopt,tq,t,i} = *fd->cyc_varargs;
    if (nopt != NULL) {
      let typ = tagged_typ(t, param_rgn, tq);
      let vd = new{Vardecl{.sc = Public,
                           .name = new $((nmspace_t)Loc_n,nopt->v),
                           .tq = empty_tqual(),
                           .type = typ,
                           .initializer = NULL,
                           .rgn = new Opt(param_rgn),
                           .attributes = NULL}};
      vds = new List(vd,vds);
      locals = Dict::insert(locals, nopt->v, new Param_b(vd));
    } 
    else terr(loc,"missing name for varargs");
  }
  fd->param_vardecls = new{Opt(vds)};
  return new 
    Fenv{.shared = new SharedFenv{
                     .return_typ = fd->ret_type,
                     .seen_labels = Dict::empty(zstrptrcmp),
                     .needed_labels = 
                       SlowDict::empty(zstrptrcmp)
                   },
         .type_vars   = tvs,
         .region_order = rgn_po,
         .locals      = locals,  // assumed unique
         .encloser    = fd->body, // careful -- self loop at top!!!
         .ctrl_env    = new CtrlEnv(NotLoop_j, NotLoop_j, NULL, FnEnd_j, 0),
         .capability  = new JoinEff(new List(new AccessEff(param_rgn),
                                             new List(fd->effect->v,NULL))),
         .curr_rgn    = param_rgn
       };
}
