/* Type checking for top-level declarations */

#include "core.h"
#include "string.h"
#include "list.h"
#include "absyn.h"
#include "absynpp.h"
#include "tcutil.h"
#include "tcenv.h"
#include "tcexp.h"
#include "tcstmt.h"
#include "evexp.h"
#include "tc.h"

namespace Tc;

using Absyn;
using Absynpp;
using Tcutil;
using Tcenv;
using Tcexp;
using Tcstmt;
using Evexp;
using List;
using Core;

// check that the scope for a redeclaration of a type is okay
static void redecl_err(segment loc, string t, string v,
		       string new_sc, string old_sc) {
  terr(loc, xprintf("redeclaration of %s %s cannot be %s "
		    "when earlier definition is %s",
		    t, v, new_sc, old_sc));
}
static scope scope_redecl_okay<`a>(scope s1, Opt_t<`a> fields1,
                                   scope s2, Opt_t<`a> fields2,
                                   segment loc, string t, string v) {
  switch ($(s1,s2)) {
  case $(Static,  Static): break;
  case $(_,       Static): redecl_err(loc, t, v, "non-static", "static"); break;
  case $(Static,  Public): redecl_err(loc, t, v, "static",     "public"); break;
  case $(Abstract,Public): redecl_err(loc, t, v, "abstract",   "public"); break;
  case $(_,       Public): s1 = Public; break;
  case $(Static,  Extern): redecl_err(loc, t, v, "static",     "extern"); break;
  case $(Abstract,Extern) && fields2 != null: 
    redecl_err(loc,t,v, "abstract", "transparent"); break;
  case $(_,       Extern): break;
  case $(Static,Abstract): redecl_err(loc, t, v, "static", "abstract"); break;
  case $(Public,Abstract): redecl_err(loc, t, v, "public", "abstract"); break;
  case $(Extern,Abstract) && fields1 != null: 
    redecl_err(loc,t,v, "[extern] transparent", "abstract"); break;
  case $(_,     Abstract): s1 = Abstract; break;
  }
  return s1;
}

// check that an enumfield in a redeclaration matches the previous declaration
// We only check [1] of the qvars b/c qualified field names aren't allowed (?)
static void field_redecl_okay(enumfield f1, enumfield f2,
			      list<$(tvar,typ)@> inst, tenv te, 
			      string t, string v) {
  segment loc = f1->loc;
  // must have same name
  if (String::zstrcmp(f1->name[1],f2->name[1]) != 0)
    terr(loc,xprintf("redeclaration of %s %s: field name mismatch %s != %s",
		     t, v, f1->name[1], f2->name[1]));
  // must have same tag
  if ((f1->tag == null && f2->tag != null) ||
      (f1->tag != null && f2->tag == null) ||
      (f1->tag != null && f2->tag != null &&
       eval_const_uint_exp(f1->tag->v) !=
       eval_const_uint_exp(f2->tag->v))) {
    terr(loc,xprintf("redeclaration of %s %s: tag mismatch for field %s",
		     t, v, f1->name[1]));
  }
  _ tvs1 = f1->tvs;
  _ tvs2 = f2->tvs;
  if (List::length(tvs1) != List::length(tvs2))
    terr(loc,xprintf("redeclaration of %s %s, field %s: type parameter number "
		     "mismatch", t, v, f1->name[1]));
  for (; tvs1 != null; tvs1 = tvs1->tl, tvs2 = tvs2->tl)
    inst = &cons(&$(tvs2->hd,VarType(tvs1->hd)),inst);
  // must have same number of types
  _ typs1 = f1->typs;
  _ typs2 = f2->typs;
  if (List::length(typs1) != List::length(typs2))
    terr(loc,xprintf("redeclaration of %s %s, field %s: parameter number "
		     "mismatch", t, v, f1->name[1]));
  // for all types
  for (; typs1 != null; typs1 = typs1->tl, typs2 = typs2->tl) {
     // must have same qualifier
    if (!equal_tqual(typs1->hd[0],typs2->hd[0]))
      terr(loc,xprintf("redeclaration of %s %s, field %s: parameter qualifier",
		       t, v, f1->name[1]));
    typ subst_t2 = substitute(inst,typs2->hd[1]);
    // and be the same type FIX: (?) is unification appropriate here?
    if (!unify(typs1->hd[1],subst_t2))
      terr(loc,xprintf("redeclaration of %s %s, field %s: parameter type "
		       "mismatch %s != %s",
		       t, v, f1->name[1],
		       typ2string(typs1->hd[1]), typ2string(subst_t2)));
  }
}

//Note: must be called after check_valid_type.  So we shouldn't
//      find an unconstrained Evar or a Typedef or such.
static bool ok_field_type(segment loc, tenv te, typ t) {
  switch (compress(t)) {
  case VarType(&$(_,RgnKind)):  throw Impossible("Region var in ok_field_type");
  case VarType(&$(_,BoxPKind)): return true;
  case VarType(&$(_,BoxUKind)): return false; // FIX at some point
  case VarType(&$(_,_)):        return false;

  case FnType(_,_,_,_):  return false;
  case RgnHandleType(_): return false; // FIX at some point
  case UnionType:        return false;

    // hmm, maybe void fields should be rejected
  case VoidType:             return true;
  case IntType(_,_,_):       return true;
  case FloatType(_):         return true;
  case DoubleType(_):        return true;
  case ArrayType(_,_,_):     return true;
  case PointerType(_,_,_,_): return true;
  case EnumType(_,_,_):      return true;
  case XenumType(_,_):       return true;

  case TupleType(tq_ts):
    for (; tq_ts != null; tq_ts = tq_ts->tl) 
      if(!ok_field_type(loc, te, tq_ts->hd[1]))
	return false;
    return true;
  case StructType(tdnopt,_,sdp):
    if (tdnopt == null) 
      return false;
      // Every structdecl entered in te already has ok fields,
      // so we only need to check whether the struct is abstract.
      // NB, check_valid_type is called before this, so tdn is
      // an absolute name.
    return (*sdp)->fields != null;

  case Evar(_,_,_):        throw Impossible("Evar in ok_field_type");
  case TypedefType(_,_,_): throw Impossible("Typedef in ok_field_type");
  case HeapRgnType:        throw Impossible("HeapRgnType in ok_field_type");
  }    
}

static void var_redecl_okay(genv ge, segment loc, var name, typ t, scope sc) {
  switch (Dict::lookup_opt(ge->ordinaries,name)) {
  case &Opt(VarRes(Global_b(vd))):
    // at most one non-extern
    if(sc != Extern && vd->sc != Extern) 
      terr(loc,xprintf("redeclaration of %s",name));
    // all must be at the same type
    if (!unify(vd->type,t))
      // FIX: should the test be unification?
      // FIX: we should also check the tqual
      terr(loc,xprintf("redeclaration of %s at a different type: %s != %s",
		       name, typ2string(t), typ2string(vd->type)));
    break;
  default: break;
  }
}

static void tcVardecl(tenv te, genv ge, segment loc, vardecl vd) {
  var   v  = vd->name[1]; 
  typ   t  = vd->type;
  scope sc = vd->sc;

  // reject explicitly qualified name
  if(vd->name[0] != null) {
    terr(loc,"qualified declarations are not implemented"); // FIX
    return;
  }
  // expand to qualified name
  vd->name[0] = te->ns;
  // reject ill-formed type
  check_valid_type(loc,te,null,t);
  // check for redeclaration
  var_redecl_okay(ge,loc,v,t,sc);
  // if extern, make sure it has no initializer
  if (sc == Extern) {
    if(vd->initializer != null) 
      terr(loc,"extern declaration should not have initializer");
  } else {
    // compute default initializer, if necessary
    exp e;
    if(vd->initializer == null) {
      e = default_initializer(te,t,loc);
      vd->initializer = &Opt(e);
    } else
      e = vd->initializer->v;
    // type-check the initializer
    let t2 = synth_typ(tcExp(te,&Opt(t),e));
    if (!coerce_assign(te,e,t)) 
      terr(loc,
	   xprintf("%s is declared with type %s but initialized with type %s",
		   qvar2string(vd->name), typ2string(t), typ2string(t2)));
    // reject non-constant initializers
    if (!is_const_exp(te,e))
      terr(loc,"initializer is not a constant expression");
  }
  // add to environment
  ge->ordinaries = Dict::insert(ge->ordinaries, v, VarRes(Global_b(vd)));
}

static void tcFndecl(tenv te, genv ge, segment loc, fndecl fd) {
  var   v  = fd->name[1];
  typ   t  = fndecl2typ(fd);
  scope sc = fd->sc;

  // reject explicitly qualified name
  if(fd->name[0] != null) {
    terr(loc,"qualified declarations are not implemented"); // FIX
    return;
  }
  // expand to qualified name
  fd->name[0] = te->ns;
  // reject ill-formed type
  check_fndecl_valid_type(loc,te,fd);
  // check for redeclaration
  var_redecl_okay(ge, loc, v, t, sc);
  // due to recursion, add function to environment before checking body
  ge->ordinaries = Dict::insert(ge->ordinaries, v, VarRes(Funname_b(fd)));
  // DAN: Here is where I'm assuming the te can be imperatively screwed with
  //      while we're dealing with top-level stuff (though it's not too hard
  //      to undo that assumption)
  te->le = &Opt(Outermost(new_fenv(fd)));
  // check the body, then get rid of local environment
  tcStmt(te,fd->body);
  // check for undefined labels FIX: get better error message
  if(!all_labels_resolved(te))
    terr(loc,"function has goto statements to undefined labels");

  te->le = null;
}

static void tcTypedefdecl(tenv te, genv ge, segment loc, typedefdecl td) {
  var v = td->name[1];
  // reject explicitly qualified name
  if (td->name[0] != null) {
    terr(loc,"qualified declarations are not implemented"); // FIX
    return;
  }
  // check for redeclaration (never allowed, apparently)
  if (Dict::member(ge->typedefs,v)) {
    terr(loc,xprintf("redeclaration of typedef %s",v));
    return;
  }
  // expand to qualified name
  td->name[0] = te->ns;
  // reject ill-formed type
  check_unique_tvars(loc,td->tvs);
  check_valid_type(loc,te,td->tvs,td->defn);
  // add to environment
  ge->typedefs = Dict::insert(ge->typedefs,v,td);
}

// FIX: For now, all instantiations must be packable.
//      Better is to have a decl field recording packability assuming
//      packable fields.  Better yet is packable polymorphism.
static void tcStructdecl(tenv te, genv ge, segment loc, structdecl sd) {
  // reject anonymous top-level
  if (sd->name == null) { 
    terr(loc,"anonymous structs are not allowed at top level");
    return;
  }
  var        v   = sd->name->v[1];
  list<tvar> tvs = sd->tvs;
  // reject explicitly qualified name
  if (sd->name->v[0] != null) {
    terr(loc,"qualified declarations are not implemented"); // FIX
    return;
  }
  // expand to qualified name
  sd->name->v[0] = te->ns;
  // reject ill-formed type 
  check_unique_tvars(loc,tvs);

  // redeclarations have to be handled differently
  switch (Dict::lookup_opt(ge->structdecls,v)) {
  case null: 
    // add the declaration to the environment, then go check the fields
    ge->structdecls = Dict::insert(ge->structdecls, v, &$(sd));
    if(sd->fields == null) {
      for(; tvs != null; tvs = tvs->tl)
	switch(tvs->hd[1]) {
	case UnresolvedKind: tvs->hd[1] = BoxPKind; break;
	default: break;
	}
      return;
    }
    break;

  case &Opt(sdp): // a redeclaration 
    let sd2  = *sdp;
    let tvs2 = sd2->tvs;
    // reject if type-arity is different
    if(List::length(tvs) != List::length(tvs2))
      terr(loc,xprintf("redeclaration of struct %s "
		       "has a different number of type parameters", v));
    // reject if scopes are inconsistent
    sd->sc = scope_redecl_okay(sd->sc, sd->fields, sd2->sc, sd2->fields,
			       loc, "struct", v);
    // now things really depend on which declarations have fields
    switch ($(sd->fields, sd2->fields)) {
    case $(null,null): return;
    case $(_,   null): *sdp = sd; break; // go check the fields below
    case $(null,_):    sd->fields = sd2->fields; sd->tvs = tvs; return;
    case $(_,   _):
      // both declare fields, so they must agree (with renaming w.r.t. tyvars)
      list <$(tvar,typ)@> inst = null;
      for(_ tvs0 = tvs; tvs0 != null; tvs0 = tvs0->tl, tvs2 = tvs2->tl)
	inst = &cons(&$(tvs2->hd,VarType(tvs0->hd)), inst);
      // check each field under the map
      _ f1s = sd->fields->v;
      _ f2s = sd2->fields->v;
      for(; f1s != null && f2s != null; f1s = f1s->tl, f2s = f2s->tl) {
	let &$(fn1,tq1,t1) = f1s->hd;
	let &$(fn2,tq2,t2) = f2s->hd;
	// names, qualifiers, and types all must agree
	if (String::zstrcmp(fn1,fn2) != 0)
	  terr(loc, xprintf("redeclaration of struct %s: field name mismatch "
			    "%s != %s", v, fn1, fn2));
	if (!equal_tqual(tq1,tq2))
	  terr(loc, xprintf("redeclaration of struct %s: qualifier mismatch on "
			    "field %s", v, fn1));
	// important side-effects on t1
	check_valid_type(loc, te, tvs, t1);
	typ subst_t2 = substitute(inst,t2);
	if(!unify(t1,subst_t2)) // FIX: unify definitely seems wrong here
	  terr(loc,xprintf("redeclaration of struct %s: type mismatch on field "
			   "%s: %s != %s",
			   v, fn1, typ2string(t1), typ2string(subst_t2)));
      }
      // check for field-number mismatch
      if (f2s != null)
	terr(loc,xprintf("redeclaration of struct %s is missing field %s", 
			 v, f2s->hd[0]));
      if (f1s != null)
	terr(loc,xprintf("redeclaration of struct %s has extra field %s", 
			 v, f1s->hd[0]));
      return;
    }
    break;
  }
  // This is the first declaration with fields, so check the fields
  // may not be the first declaration, so must not overwrite the dict
  // entry!
  // for the sake of recursive fields, make name abstract in body
  let sdp = Dict::lookup(ge->structdecls, v);
  *sdp = &Structdecl(sd->sc, sd->name, tvs, null); 
  // check fields, rejecting ill-formed types, bad fields, and duplicates
  list<field_name> prev_fields = null;
  for (let fs = sd->fields->v; fs != null; fs = fs->tl) {
    let &$(fn,tq,t) = fs->hd;
    if (List::mem(String::zstrcmp,prev_fields,fn))
	terr(loc,xprintf("duplicate field %s in struct",fn));
    prev_fields = &cons(fn,prev_fields);
    check_valid_type(loc,te,tvs,t);
    if (!ok_field_type(loc,te,t))
      terr(loc,xprintf("fields of type %s are not allowed",typ2string(t)));
    // FIX: check for consistent tquals?
  }
  // add the constructor to the environment
  ge->ordinaries = Dict::insert(ge->ordinaries,  v, StructRes(sd));
  // undo our clobbering with the abstract version
  *sdp = sd;
}

// FIX: for now, ensure all instantiations are packable (see comments
//      with tcStructdecl)
static void tcEnumdecl(tenv te, genv ge, segment loc, enumdecl ed) {
  // reject anonymous top-level
  if (ed->name == null) {
    terr(loc,"anonymous enums are not allowed at top level");
    return;
  }
  var        v   = ed->name->v[1];
  list<tvar> tvs = ed->tvs;
  // reject explicitly qualified name
  if (ed->name->v[0] != null) {
    terr(loc,"qualified declarations are not implemented"); // FIX
    return;
  }
  // expand to qualified name
  ed->name->v[0] = te->ns;
  // reject ill-formed type
  check_unique_tvars(loc,tvs);

  // redeclarations have to be handled differently
  // check for redeclaration
  switch (Dict::lookup_opt(ge->enumdecls, v)) {
  case null: 
    // add the declaration to the environment, then go check the fields
    ge->enumdecls = Dict::insert(ge->enumdecls, v, &$(ed));
    if(ed->fields == null) {
      for(; tvs != null; tvs = tvs->tl)
	switch(tvs->hd[1]) {
	case UnresolvedKind: tvs->hd[1] = BoxPKind; break;
	default: break;
	}
      return;
    }
    break;

  case &Opt(edp):
    _ ed2  = *edp;
    _ tvs2 = ed2->tvs;
    // reject if type-arity is different
    if(List::length(tvs) != List::length(tvs2))
      terr(loc,xprintf("redeclaration of enum %s "
		       "has a different number of type parameters", v));
    // reject if scopes are different
    ed->sc = scope_redecl_okay(ed->sc, ed->fields, ed2->sc, ed2->fields,
			       loc, "enum", v);
    // now things really depend on which declarations have fields
    switch ($(ed->fields, ed2->fields)) {
    case $(null,null): return;
    case $(_,   null): *edp = ed; break; // go check the fields below
    case $(null,_):    ed->fields = ed2->fields; ed->tvs = tvs2; return;
    case $(_,   _):
      // both declare fields, so they must agree (with renaming w.r.t. tyvars)
      list<$(tvar,typ)@> inst = null;
      for(_ tvs0 = tvs; tvs0 != null; tvs0 = tvs0->tl, tvs2 = tvs2->tl)
	inst = &cons(&$(tvs2->hd,VarType(tvs0->hd)), inst);
      // check each field under the map
      _ f1s = ed->fields->v;
      _ f2s = ed2->fields->v;
      // the types in f1 haven't been checked yet, which does important
      // side effects
      
      for (; f1s != null && f2s != null; f1s = f1s->tl, f2s = f2s->tl) {
	f1s->hd->name[0] = te->ns;
	// check f1s->hd types for the important side effects
	list<tvar> alltvs = List::append(tvs, f1s->hd->tvs);
	check_unique_tvars(f1s->hd->loc,alltvs);
	for(_ typs = f1s->hd->typs; typs != null; typs = typs->tl)
	  check_valid_type(f1s->hd->loc,te,alltvs,typs->hd[1]);
	// now we can check against previous definition of field
	field_redecl_okay(f1s->hd, f2s->hd, inst, te, "enum", v);
      }
      // check for field-number mismatch
      if (f1s != null)
	terr(loc,xprintf("redeclaration of enum %s has extra field %s",
			 v, f1s->hd->name[1]));
      if (f2s != null)
	terr(loc,xprintf("redeclaration of enum %s is missing field %s",
			 v, f2s->hd->name[1]));
      return;
    }
    break;
  }
  // This is the first declaration with variants, so check the variants
  // may not be the first declaration, so must not overwrite the dict
  // entry!
  // for the sake of recursive fields, make name abstract in body
  let edp = Dict::lookup(ge->enumdecls, v);
  *edp = &Enumdecl(ed->sc, ed->name, tvs, null);
  // check variants, rejecting ill-formed types, non-constant tags,
  // repeated tyvars (why?), and duplicate field names
  // finally, add variants
  list<field_name> prev_fields = null;
  for(let fs = ed->fields->v; fs != null; fs = fs->tl) {
    let f = fs->hd;
    if (List::mem(String::zstrcmp,prev_fields,f->name[1])) 
      terr(f->loc,xprintf("duplicate field name %s",f->name[1]));
    prev_fields = &cons(f->name[1],prev_fields);
    if (f->tag != null) 
      eval_const_uint_exp(f->tag->v); 
    list<tvar> alltvs = List::append(tvs,f->tvs);
    check_unique_tvars(loc,alltvs);
    for (list<$(tqual,typ)@> typs = f->typs; typs != null; typs=typs->tl)
      check_valid_type(f->loc,te,alltvs,typs->hd[1]);
    // FIX: check valid tquals?
    f->name[0] = te->ns;
    ge->ordinaries = Dict::insert(ge->ordinaries, f->name[1], EnumRes(ed,f));
  }
  // add the decl to the environment -- must be after variant-checking
  // (where we added an abstract version)
  ge->enumdecls = Dict::insert(ge->enumdecls, v, &$(ed));
  // undo our clobbering with the abstract version
  *edp = ed;
}

// FIX: ensure the types are packable (see comment with tcStructdecl).
static void tcXenumdecl(tenv te, genv ge, segment loc, xenumdecl xd) {
  var v = xd->name[1];
  Opt_t<xenumdecl@> xd2o;
  try xd2o = lookup_xenumdecl(te,loc,xd->name);
  catch { case Dict::Absent:
    terr(loc, xprintf("qualified xenum declaration %s is not an existing xenum",
		      qvar2string(xd->name)));
    return;
  }
  // expand to qualified name, if not already qualified
  if(xd->name[0] == null)
    xd->name[0] = te->ns;
  // if we're a new xenum, then make a fresh "already there" xenumdecl
  //       and add it to the environment
  // if we're not new, compare scopes
  if(xd2o == null) {
    xenumdecl @ x = &$(&Xenumdecl{.sc=xd->sc, .name=xd->name, .fields=null});
    xd2o = &Opt(x);
    ge->xenumdecls = Dict::insert(ge->xenumdecls, v, x);
  } else {
    let x = *(xd2o->v);
    x->sc = scope_redecl_okay(xd->sc, &Opt(0), x->sc, &Opt(0), loc, "xenum", v);
  }
  // now check that we can add each "field" by ensuring that 
  // duplicates are the same.  Note that fields are qualified by the current
  // namespace if implicit, not the namespace of the xenum
  // Notice that we're "hoisting" the fields into the earlier definition,
  // if there is one we know about.
  xenumdecl xd_result = *(xd2o->v);
  for(list<enumfield> fs = xd->fields; fs != null; fs = fs->tl) {
    enumfield f = fs->hd;
    // expand field name if not explicitly qualified
    if(f->name[0] == null)
      f->name[0] = te->ns;
    // reject if there is an ill-formed type
    list<tvar>tvs = f->tvs;
    check_unique_tvars(loc,tvs);
    for(let typs = f->typs; typs != null; typs = typs->tl)
      check_valid_type(f->loc,te,tvs,typs->hd[1]);
    // notice we now allow duplicates, they just have to have the same type
    // also, we can be totally re-ordered from a different declaration
    bool dup = false;
    for(let prev_fs = xd_result->fields; prev_fs!=null; prev_fs = prev_fs->tl) {
      let prev = prev_fs->hd;
      if(qvar_cmp(f->name, prev->name)==0) {
	field_redecl_okay(prev, f, null, te, "xenum", v);
	// do not add the duplicate to the result:
	dup = true;
	break;
      }
    }
    if(dup)
      continue;
    // no duplicate, so add to the result
    xd_result->fields = &cons(f, xd_result->fields);
    // notice we allow adding to another namespace via qualified field
    genv ge_f;
    try ge_f = Dict::lookup(te->ae, f->name[0]);
    catch { case Dict::Absent:
      terr(f->loc, xprintf("bad namespace for xenum field %s",
			   qvar2string(f->name)));
      return;
    }
    ge_f->ordinaries = Dict::insert(ge_f->ordinaries, f->name[1],
				    XenumRes(xd_result, f));
  }
}

// Typecheck a list, ds, of declarations in environment te.
// As a side effect, all declarations and variable references are made
// absolute, and "namespace" and "using" go away.
void tc(tenv te, list<decl> ds0) {

  for (let ds = ds0; ds != null; ds = ds->tl) {
    decl    d   = ds->hd;
    segment loc = d->loc;
    genv    ge  = Dict::lookup(te->ae,te->ns); // no longer a copy!!!

    switch (d->r) {
    case Let_d(_,_,_,_): // FIX
      terr(loc,"top level let-declarations are not implemented");
      break;
    case Union_d: // FIX
      terr(loc,"union is not implemented");
      break;
    case Var_d(vd):     tcVardecl(te,ge,loc,vd);     break;
    case Fn_d(fd):      tcFndecl(te,ge,loc,fd);      break;
    case Typedef_d(td): tcTypedefdecl(te,ge,loc,td); break;
    case Struct_d(sd):  tcStructdecl(te,ge,loc,sd);  break;
    case Enum_d(ed):    tcEnumdecl(te,ge,loc,ed);    break;
    case Xenum_d(xd):   tcXenumdecl(te,ge,loc,xd);   break;

    case Namespace_d(v,ds2):
      // DAN: This case is much more imperative than it used to be.
      let ns  = te->ns;
      let ns2 = List::append(ns,&cons(v,null));
      // Make sure namespace v has been declared in the current namespace
      if (!Set::member(ge->namespaces,v)) {
        ge->namespaces = Set::insert(ge->namespaces,v);
	te->ae = Dict::insert(te->ae, ns2, empty_genv());
      }
      // Do the nested declarations then restore the namespace
      te->ns = ns2;
      tc(te,ds2);
      te->ns = ns;
      break;
      
    case Using_d(&$(nsl,v),ds2):
      // DAN: We're more imperative here too.
      let ns2 = resolve_namespace(te,loc,List::append(nsl,&cons(v,null)));
      ge->availables = &cons(ns2,ge->availables);
      tc(te,ds2);
      ge->availables = ge->availables->tl;
      break;
    }
  }
}
