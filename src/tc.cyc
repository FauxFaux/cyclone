/* Type checking for top-level declarations
   Copyright (C) 2001 Greg Morrisett, AT&T
   This file is part of the Cyclone compiler.

   The Cyclone compiler is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   The Cyclone compiler is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with the Cyclone compiler; see the file COPYING. If not,
   write to the Free Software Foundation, Inc., 59 Temple Place -
   Suite 330, Boston, MA 02111-1307, USA. */

#include <core.h>
#include <string.h>
#include <list.h>
#include <position.h>
#include "absyn.h"
#include "absynpp.h"
#include "tcutil.h"
#include "tcenv.h"
#include "tcexp.h"
#include "tcstmt.h"
#include "evexp.h"
#include "tc.h"
#include <stdio.h>
#include "tcdecl.h"
#include "tcgenrep.h"
using Core;
using List;
using Position;
using Absyn;
using Absynpp;
using Tcutil;
using Tcenv;
using Tcgenrep;

namespace Tc;

// used for the error messages of tcdecl
static string_t tc_msg_c = "";
static string_t * tc_msg = &tc_msg_c;

// Transfer any function type attributes from the given list to the
// function type.  
static attributes_t transfer_fn_type_atts(type_t t, attributes_t atts) {
  switch (compress(t)) {
  case &FnType(FnInfo{_,_,_,_,_,_,_,*fnatts}):
    let res_atts = NULL;
    for (; atts != NULL; atts = atts->tl) {
      if (fntype_att(atts->hd))
        *fnatts = new List(atts->hd,*fnatts); 
      else
        res_atts = new List(atts->hd,res_atts); 
    }
    return res_atts;
  default: return impos("transfer_fn_type_atts"); 
  }
}

static void tcVardecl(tenv_t te, genv_t ge, seg_t loc, vardecl_t vd, bool check_var_init) {
  var_t   v  = (*vd->name)[1];
#ifdef DEBUG
  fprintf(stderr,"type-checking vardecl_t %s",*v); 
  fflush(stderr);
#endif
  type_t  t  = vd->type;
  scope_t sc = vd->sc;
  attributes_t atts = vd->attributes;
  vd->escapes = true; // top-level variables all "escape" except for arrays --
  // see below

  // reject explicitly qualified name
  switch ((*vd->name)[0]) {
  case &Rel_n(NULL): break;
  case &Abs_n(NULL): break; // allowed for top-level constants
  default:
    terr(loc,"qualified variable declarations are not implemented (%s)",qvar2string(vd->name)); // FIX
    return;
  }
  // expand to qualified name
  (*vd->name)[0] = new Abs_n(te->ns);
  // if it's an array or string, fill in the size on the type
  switch (compress(t)) {
  case &ArrayType(telt,tq,NULL) && vd->initializer != NULL:
    switch (vd->initializer->r) {
      case &Const_e(&String_c(s)):
      t = vd->type = new ArrayType(telt,tq,uint_exp(s.size,NULL));
      break;
      case &Comprehension_e(_,e,_):
      // FIX: need to copy e here!
      t = vd->type = new ArrayType(telt,tq,e); 
      break;
      case &UnresolvedMem_e(_,es): fallthru(es);
      case &Array_e(es):
      t = vd->type = new ArrayType(telt,tq,uint_exp(List::length(es),NULL));
      break;
      default: break;
    }
    break;
  default: break;
  }
  // reject ill-formed type
  check_valid_toplevel_type(loc,te,t);
  // top-level arrays don't escape because they can't be assigned to, so
  // their sizes do not change over time.
  switch (compress(t)) {
  case &ArrayType(_,_,_): vd->escapes = false; break;
  default: break;
  }
  if (is_function_type(t)) {
    // move any function type attributes into the function's type
    atts = transfer_fn_type_atts(t,atts);
  }
  // if extern, make sure it has no initializer
  if (sc == Extern || sc == ExternC) {
    if(vd->initializer != NULL)
      terr(loc,"extern declaration should not have initializer");
  } else if (!is_function_type(t)) {
    // we skip over function types -- these are function protypes.
    // otherwise, we compute default initializer, if necessary
    // first check that the attributes are okay
    for (; atts != NULL; atts = atts->tl)
      switch (atts->hd) {
      case &Aligned_att(_):
        // GCC doesn't allow variables to be packed
        // case Packed_att:     continue;
      case &Section_att(_):
      case Nocommon_att:   
      case Shared_att:     
      case Unused_att:     
      case Weak_att:       
      case Dllimport_att:  
      case Dllexport_att:  continue;
      default:
        terr(loc,"bad attribute %s for variable %s",
             attribute2string(atts->hd), qvar2string(vd->name));
        break;
      }

    if(vd->initializer == NULL) {
      if (check_var_init && !supports_default(t))
        terr(loc,"initializer required for variable %s of type %s",
             qvar2string(vd->name), typ2string(t));
    } else {
      let e = (exp_t)vd->initializer;
      // type-check the initializer
      let t2 = Tcexp::tcExpInitializer(te,&t,e);
      if (!coerce_assign(te,e,t)) {
        terr(loc,"%s is declared with type \n%s\n but initialized with type \n%s",
             qvar2string(vd->name), typ2string(t), typ2string(t2));
        explain_failure();
      }
      // reject non-constant initializers
      if (!Tcutil::is_const_exp(te,e))
        terr(loc,"initializer is not a constant expression");
    }
  } else {
    // it is a function type -- check that the attributes are okay
    for (; atts != NULL; atts = atts->tl) {
      switch (atts->hd) {
      // these attributes should be in the function's type
      case &Regparm_att(_):
      case Stdcall_att:   
      case Cdecl_att:     
      case Fastcall_att: 
      case Noreturn_att: 
      case &Format_att(_,_,_): fallthru;
      case Const_att:
        impos("tcVardecl: fn type attributes in function var decl");
        break;
      // C doesn't allow these attributes on functions
      case &Aligned_att(_):
      case Packed_att:
        terr(loc,"bad attribute %s in function declaration",
             attribute2string(atts->hd));
        break;
      default: continue;
      }
    }
  }

  // update the environment
  try {
    let ans = Dict::lookup(ge->ordinaries, v);
    switch ((*ans)[0]) {
    case &VarRes(b0):
      let b1 = new Global_b(vd);
      let b = Tcdecl::merge_binding(b0, b1, loc, tc_msg);
      if (b == Unresolved_b) break; // error in merging
      if (b == b0 && (*ans)[1]) break; // no need to reinsert the entry
      // otherwise make the update
      ge->ordinaries = Dict::insert(ge->ordinaries, v,
				    new $(new VarRes(b), true));
      break;
    case &StructRes(_):
      // warn(loc,"variable declaration shadows previous struct declaration");
      break;
    case &TunionRes(_,_): 
      warn(loc,"variable declaration shadows previous [x]tunion constructor");
      break;
    case &AnonEnumRes(_,_): 
    case &EnumRes(_,_): 
      warn(loc,"variable declaration shadows previous enum tag");
      break;
    }
  } catch {
  case Dict::Absent:
    ge->ordinaries = Dict::insert(ge->ordinaries, v,
				  new $(new VarRes(new Global_b(vd)), false));
    break;
  }
}

static void tcFndecl(tenv_t te, genv_t ge, seg_t loc, fndecl_t fd) {
  var_t   v  = (*fd->name)[1];
#ifdef DEBUG
  fprintf(stderr,"type-checking fndecl %s",*v);
  fflush(stderr);
#endif
  scope_t sc = fd->sc;

  // reject explicitly qualified name
  switch ((*fd->name)[0]) {
  case &Rel_n(NULL): break;
  case &Abs_n(y):
    throw new Impossible("tc: Abs_n in tcFndecl");
  default:
    terr(loc,"qualified function declarations are not implemented (%s)",qvar2string(fd->name)); // FIX
    return;
  }
  // expand to qualified name
  (*fd->name)[0] = new Abs_n(te->ns);
  // reject ill-formed type
  check_fndecl_valid_type(loc,te,fd);
  // check for redeclaration
  type_t t = fndecl2typ(fd);
  // move any function type attributes into the function's type
  fd->attributes = transfer_fn_type_atts(t,fd->attributes);
  // check that packed and aligned don't show up in the attributes
  for (_ atts = fd->attributes; atts != NULL; atts = atts->tl) {
    switch (atts->hd) {
    case Packed_att: fallthru;
    case &Aligned_att(_): 
      terr(loc,"bad attribute %s for function",attribute2string(atts->hd));
      break;
    default: break;
    }
  }

  // due to recursion, add function to environment before checking body
  try {
    let ans = Dict::lookup(ge->ordinaries, v);
    switch ((*ans)[0]) {
    case &VarRes(b0):
      let b1 = new Funname_b(fd);
      let b = Tcdecl::merge_binding(b0, b1, loc, tc_msg);
      if (b == Unresolved_b) break; // error in merging
      if (b == b0 && (*ans)[1]) break; // no need to reinsert the entry
      // otherwise make the update
      ge->ordinaries = Dict::insert(ge->ordinaries, v,
				    new $(new VarRes(b), true));
      break;
    case &StructRes(_):
      // warn(loc,"function declaration shadows previous struct declaration");
      break;
    case &TunionRes(_,_): 
      warn(loc,"function declaration shadows previous [x]tunion constructor");
      break;
    case &AnonEnumRes(_,_):
    case &EnumRes(_,_): 
      warn(loc,"function declaration shadows previous enum tag");
      break;
    }
  } catch {
  case Dict::Absent:
    ge->ordinaries = Dict::insert(ge->ordinaries, v,
				  new $(new VarRes(new Funname_b(fd)), false));
    break;
  }

  // DAN: Here is where I'm assuming the te can be imperatively screwed with
  //      while we're dealing with top-level stuff (though it's not too hard
  //      to undo that assumption)
  te->le = new Opt(new Outermost(new_fenv(loc,fd)));
  // check the body, then get rid of local environment
  Tcstmt::tcStmt(te,fd->body,false);
  // check for undefined labels FIX: get better error message
  if(!all_labels_resolved(te))
    terr(loc,"function has goto statements to undefined labels");

  te->le = NULL;
}

static void tcTypedefdecl(tenv_t te, genv_t ge, seg_t loc, typedefdecl_t td) {
  var_t v = (*td->name)[1];
#ifdef DEBUG
  fprintf(stderr,"type-checking typedefdecl %s",*v);
  fflush(stderr);
#endif
  // reject explicitly qualified name
  switch ((*td->name)[0]) {
  case &Rel_n(NULL): break;
  case &Abs_n(NULL): break; // allowed for top-level constants
  default:
    terr(loc,"qualified typedef declarations are not implemented (%s)",qvar2string(td->name)); // FIX
    return;
  }
  // check for redeclaration (never allowed, apparently)
  if (Dict::member(ge->typedefs,v)) {
    terr(loc,"redeclaration of typedef %s",*v);
    return;
  }
  // expand to qualified name
  (*td->name)[0] = new Abs_n(te->ns);
  // reject ill-formed type
  check_unique_tvars(loc,td->tvs);
  add_tvar_identities(td->tvs);
  check_type(loc,te,td->tvs,AnyKind,false,td->defn);
  // add to environment
  ge->typedefs = Dict::insert(ge->typedefs,v,td);
}

static void tcStructFields(tenv_t te, genv_t ge, seg_t loc, 
                           string_t obj,
			   list_t<structfield_t> fields, 
                           list_t<tvar_t,`H> tvs) {
  // check fields, rejecting ill-formed types, bad fields, and duplicates
  // (unless the field name is empty)
  region uprev_rgn {
    list_t<field_name_t, `uprev_rgn> prev_fields = NULL;

    for (let fs = fields; fs != NULL; fs = fs->tl) {
      let &Structfield(fn,tq,t,width,atts) = fs->hd;
      
      if (List::mem(zstrptrcmp,prev_fields,fn))
	terr(loc, "duplicate field %s in %s", *fn, obj);
      // add the field to previous fields only if it's not an empty name
      // (empty names arise for bitfield padding.)
      if (strcmp(*fn,"") != 0)
	prev_fields = rnew(uprev_rgn) List(fn,prev_fields);

      check_type(loc,te,tvs,MemKind,false,t);

      // if width is non-NULL then t must be of integral type
      check_bitfield(loc, te, t, width, fn);
      // FIX : check for consistent tquals
    }
  }
}

static void tcStructOrUniondecl(tenv_t te, genv_t ge, string_t obj, seg_t loc, structdecl_t sd) {
  let v = (*sd->name->v)[1];
#ifdef DEBUG
  fprintf(stderr,"type-checking %sdecl %s",obj,*v);
  fflush(stderr);
#endif
  // reject anonymous top-level
  if (sd->name == NULL) {
    terr(loc, "anonymous %ss are not allowed at top level", obj);
    return;
  }

  // only allow packed and aligned attributes
  for (_ atts = sd->attributes; atts != NULL; atts = atts->tl) {
    switch (atts->hd) {
    case Packed_att: continue;
    case &Aligned_att(_): continue;
    default: terr(loc,"bad attribute %s in %s %s definition",
                  attribute2string(atts->hd), obj, *v);
    break;
    }
  }

  // disallow MemKinds and set unconstrained kinds to BoxKind
  for(_ tvs = sd->tvs; tvs != NULL; tvs = tvs->tl) {
    switch (compress_kb(tvs->hd->kind)) {
    case &Unknown_kb(*f): fallthru(f);
    case &Less_kb(*f,MemKind): fallthru(f);
    case &Less_kb(*f,AnyKind):
      *f = new Opt(new Eq_kb(BoxKind)); continue;
    case &Eq_kb(MemKind):
      terr(loc,"%s %s attempts to abstract type variable %s of kind M", 
           obj, *v, *tvs->hd->name); continue;
    default: continue;
    }
  }

  // reject explicitly qualified name
  switch ((*sd->name->v)[0]) {
  case &Rel_n(NULL): break;
  case &Abs_n(NULL): break; // allowed for top-level constants
  default:
    terr(loc,"qualified struct declarations are not implemented (%s)",qvar2string(sd->name->v)); // FIX
    return;
  }

  // expand to qualified name
  (*sd->name->v)[0] = new Abs_n(te->ns);

  // reject ill-formed type
  check_unique_tvars(loc, sd->tvs);
  // give the bound type variables identities
  add_tvar_identities(sd->tvs);

}

void tcStructdecl(tenv_t te, genv_t ge, seg_t loc, structdecl_t sd) {
  let v = (*sd->name->v)[1];
  let obj = "struct";

  tcStructOrUniondecl(te, ge, obj, loc, sd);

  let tvs = sd->tvs;

  // check the fields and update the environment
  // may not be the first declaration, so must not overwrite the dict entry!
  switch ($(sd->fields, Dict::lookup_opt(ge->structdecls, v))) {
  case $(NULL, NULL):
    // insert sd in the environment
    ge->structdecls = Dict::insert(ge->structdecls, v, new sd);
    break;
  case $(&Opt(fs), NULL):
    // for the sake of recursive fields, make name abstract in body
    let sdp = new (new Structdecl(Extern, sd->name, tvs, NULL, NULL));
    ge->structdecls = Dict::insert(ge->structdecls, v, sdp);
    
    tcStructFields(te, ge, loc, obj, fs, tvs);

    *sdp = sd; //insert sd in the environment
    break;
  case $(&Opt(fs), &Opt(sdp)):
    let sd0 = *sdp;
    // for the sake of recursive fields, make name abstract in body
    *sdp = new Structdecl(Extern, sd->name, tvs, NULL, NULL);
    
    tcStructFields(te, ge, loc, obj, fs, tvs);

    *sdp = sd0; // restore the previous declaration and go update the environment
    fallthru(sdp);
  case $(NULL, &Opt(sdp)):
    // try to merge the declarations
    let sd2 = Tcdecl::merge_structdecl(*sdp, sd, loc, tc_msg);
    
    if (sd2 == NULL)
      return; // error in redeclaration
    else {
      *sdp = (structdecl_t) sd2; // make the update

      sd = (structdecl_t) sd2; // update sd so that we add the right constructor below
      break;
    }
  }
  // add the constructor to the environment
  ge->ordinaries = Dict::insert(ge->ordinaries,  v,
				  new $(new StructRes(sd), true));
}

void tcUniondecl(tenv_t te, genv_t ge, seg_t loc, uniondecl_t ud) {
  let v = (*ud->name->v)[1];
  let obj = "union";

  tcStructOrUniondecl(te, ge, obj, loc, (structdecl_t) ud);

  let tvs = ud->tvs;

  // check the fields and update the environment
  // may not be the first declaration, so must not overwrite the dict entry!
  switch ($(ud->fields, Dict::lookup_opt(ge->uniondecls, v))) {
  case $(NULL, NULL):
    // insert ud in the environment
    ge->uniondecls = Dict::insert(ge->uniondecls, v, new ud);
    break;
  case $(&Opt(fs), NULL):
    // for the sake of recursive fields, make name abstract in body
    let udp = new (new Uniondecl(Extern, ud->name, tvs, NULL, ud->attributes));
    ge->uniondecls = Dict::insert(ge->uniondecls, v, udp);
    
    tcStructFields(te, ge, loc, obj, fs, tvs);
    // must check that fields are bits-only
    for (_ f = fs; f != NULL; f = f->tl) {
      if (!bits_only(f->hd->type))
        terr(loc,"field %s of union %s has type %s which "
             "is not `bits-only'",*f->hd->name,*v,
             typ2string(f->hd->type));
    }

    *udp = ud; //insert ud in the environment
    break;
  case $(&Opt(fs), &Opt(udp)):
    let ud0 = *udp;
    // for the sake of recursive fields, make name abstract in body
    *udp = new Uniondecl(Extern, ud->name, tvs, NULL, ud->attributes);
    
    tcStructFields(te, ge, loc, obj, fs, tvs);

    *udp = ud0; // restore the previous declaration and go update the environment
    fallthru(udp);
  case $(NULL, &Opt(udp)):
    // try to merge the declarations
    let ud2 = Tcdecl::merge_uniondecl(*udp, ud, loc, tc_msg);
    
    if (ud2 == NULL)
      return; // error in redeclaration
    else {
      *udp = (uniondecl_t) ud2; // make the update
      break;
    }
  }
}

static list_t<tunionfield_t> tcTunionFields(tenv_t te, genv_t ge, 
                                            seg_t loc,
					    string_t obj, 
                                            bool is_xtunion,
					    qvar_t name,
					    list_t<tunionfield_t,`H> fields,
					    list_t<tvar_t,`H> tvs,
					    tuniondecl_t tudres) {
  // check variants, rejecting ill-formed types,
  // repeated tyvars
  for(let fs = fields; fs != NULL; fs = fs->tl) {
    let f = fs->hd;

    for (_ tvs = f->tvs; tvs != NULL; tvs = tvs->tl) {
      let tv = tvs->hd;
      switch (compress_kb(tv->kind)) {
      case &Eq_kb(MemKind):
        terr(f->loc,"field %s abstracts type variable of kind M", 
             *(*f->name)[1]); break;
      case &Unknown_kb(*f): fallthru(f);
      case &Less_kb(*f,MemKind): fallthru(f);
      case &Less_kb(*f,AnyKind): 
        *f = new Opt(new Eq_kb(BoxKind)); break;
      default: break;
      }
    }

    list_t<tvar_t> alltvs = List::append(tvs,f->tvs);
    check_unique_tvars(loc,alltvs);
    // give the bound type variables identities
    add_tvar_identities(f->tvs);

    for (_ typs = f->typs; typs != NULL; typs=typs->tl) {
      check_type(f->loc, te, alltvs, MemKind, false, (*typs->hd)[1]);
    }

    switch((*f->name)[0]) {
    case &Rel_n(NULL): 
      if(is_xtunion)
	(*f->name)[0] = new Abs_n(te->ns);
      else
	(*f->name)[0] = (*name)[0];
      break;
    case &Rel_n(_): 
      terr(f->loc, "qualified tunionfield declarations are not allowed (%s)",qvar2string(f->name)); //FIX ?
      break;
    case &Abs_n(_): break;
    case Loc_n:
      throw new Impossible("tcTunionFields: Loc_n");
      break;
    }
  }

  list_t<tunionfield_t,`H> fields2;  
  if(is_xtunion) {
    // for xtunions sort the fields (trying to merge the duplicates)
    let res = true;
    let fs = Tcdecl::sort_xtunion_fields(fields, &res, (*name)[1], loc, tc_msg);
    if (res)
      fields2 = fs;
    else
      fields2 = NULL; // should it be fs anyway ?
  } else region uprev_rgn { 
    // for tunions, check there's no duplicate field
    list_t<var_t, `uprev_rgn> prev_fields = NULL;
    for (_ fs = fields; fs != NULL; fs = fs-> tl) {
      let f = fs->hd;
      if (List::mem(zstrptrcmp, prev_fields, (*f->name)[1]))
	terr(f->loc,"duplicate field name %s in %s", *((*f->name)[1]), obj);
      else
	prev_fields = rnew(uprev_rgn) List((*f->name)[1], prev_fields);
      // erase the scope of the field (which has no meaning)
      if (f->sc != Public) {
	warn(loc, "ignoring scope of field %s", *((*f->name)[1]));
	f->sc = Public;
      }
    }
    fields2 = fields;
  }
  
  // finally add the variants
  // (for xtunion, only the new fields; this is important because tudres
  // may not define the old ones or the tvars may not be the same)
  for(let fs = fields; fs != NULL; fs = fs->tl) {
    let f = fs->hd;
    ge->ordinaries = Dict::insert(ge->ordinaries, (*f->name)[1],
                                  new $(new TunionRes(tudres,f), true));
  }

  return fields2;
}

void tcTuniondecl(tenv_t te, genv_t ge, seg_t loc, tuniondecl_t tud) {
  var_t v = (*tud->name)[1];
  string_t obj;
  if (tud->is_xtunion) {
    obj = "xtunion";
  } else {
    obj = "tunion";
  }
#ifdef DEBUG
  fprintf(stderr,"type-checking %sdecl %s\n",obj,*v);
  fflush(stderr);
#endif
  list_t<tvar_t> tvs = tud->tvs;
  // disallow MemKinds and set unconstrained kinds to BoxKind
  for(_ tvs2 = tvs; tvs2 != NULL; tvs2 = tvs2->tl) {
    switch (compress_kb(tvs2->hd->kind)) {
    case &Unknown_kb(*f): fallthru(f);
    case &Less_kb(*f,MemKind): fallthru(f);
    case &Less_kb(*f,AnyKind): 
      *f = new Opt(new Eq_kb(BoxKind)); break;
    case &Eq_kb(MemKind):
      terr(loc,"%s %s attempts to abstract type "
           "variable %s of kind M",obj,*v,*tvs2->hd->name); break;
    default: break;
    }
  }
  // reject ill-formed type
  check_unique_tvars(loc,tvs);
  // give the bound type variables identities
  add_tvar_identities(tvs);

  // determine [x]tunion type's qualified name
  // set ge_decl to the namespace where the declaration 'lives'
  // (for xtunions it may be different from ge)
  opt_t<tuniondecl_t@> tud_opt;
  if(tud->is_xtunion) {
    try tud_opt = lookup_xtuniondecl(te,loc,tud->name);
    catch {
    case Dict::Absent:
      terr(loc,"qualified xtunion declaration %s is not an existing xtunion",
           qvar2string(tud->name));
      return;
    }
    if (tud_opt != NULL) {
      tud->name = (*(tud_opt->v))->name;
    } else {
      (*tud->name)[0] = new Abs_n(te->ns); 
    }
  } else {
    switch ((*tud->name)[0]) {
    case &Rel_n(NULL): (*tud->name)[0] = new Abs_n(te->ns); break;
    case &Abs_n(_): fallthru;
    default:
      terr(loc,"qualified tunion declarations are not implemented (%s)",qvar2string(tud->name)); // FIX
      return;
    }
    tud_opt = Dict::lookup_opt(ge->tuniondecls, v);
  }

  // check the fields and update the environment
  // may not be the first declaration, so must not overwrite the dict entry!
  switch ($(tud->fields, tud_opt)) {
  case $(NULL, NULL):
    // insert tud in the environment
    ge->tuniondecls = Dict::insert(ge->tuniondecls, v, new tud);
    break;
  case $(&Opt(*fs), NULL):
    // for the sake of recursive fields, make name abstract in body
    let tudp = new (new Tuniondecl(Extern, tud->name, tvs, NULL, tud->is_xtunion));
    ge->tuniondecls = Dict::insert(ge->tuniondecls, v, tudp);
   
    // check the fields (and sort them if this is a xtunion)
    *fs = tcTunionFields(te, ge, loc, obj, tud->is_xtunion, tud->name, *fs, tvs, tud);

    *tudp = tud; //insert tud in the environment
    break;
  case $(&Opt(*fs), &Opt(tudp)):
    let tud0 = *tudp;
    // for the sake of recursive fields, make name abstract in body
    *tudp = new Tuniondecl(Extern, tud->name, tvs, NULL, tud->is_xtunion);
    
    // check the fields (and sort them if this is a xtunion)
    *fs = tcTunionFields(te, ge, loc, obj, tud->is_xtunion, tud->name, *fs, tvs, tud);

    *tudp = tud0; // restore the previous declaration and go update the environment
    fallthru(tudp);
  case $(NULL, &Opt(tudp)):
    // try to merge the declarations
    let tud2 = Tcdecl::merge_tuniondecl(*tudp, tud, loc, tc_msg);
    if (tud2 == NULL)
      return; // error in redeclaration
    else {
      *tudp = (tuniondecl_t) tud2; // make the update
      break;
    }
  } 

}

void tcEnumdecl(tenv_t te, genv_t ge, seg_t loc, enumdecl_t ed) {
  var_t v = (*ed->name)[1];
#ifdef DEBUG
  fprintf(stderr,"type-checking enumdecl %s",*v);
  fflush(stderr);
#endif
  // reject explicitly qualified name
  switch ((*ed->name)[0]) {
  case &Rel_n(NULL): break;
  case &Abs_n(NULL): break; // allowed for top-level constants
  default:
    terr(loc,"qualified enum declarations are not implemented (%s)",qvar2string(ed->name)); // FIX
    return;
  }
  // expand to qualified name
  (*ed->name)[0] = new Abs_n(te->ns);

  // check the fields.
  if (ed->fields != NULL) region uprev_rgn {
    list_t<field_name_t, `uprev_rgn> prev_fields = NULL;
    unsigned int tag_count = 0;
    for (_ fs = ed->fields->v; fs != NULL; fs = fs->tl) {
      let f = fs->hd;
      
      if (List::mem(zstrptrcmp,prev_fields,(*f->name)[1]))
	terr(f->loc,"duplicate field name %s",*((*f->name)[1]));
      else
	prev_fields = rnew(uprev_rgn) List((*f->name)[1],prev_fields);
      
      if (f->tag == NULL)
	f->tag = uint_exp(tag_count, f->loc);
      else if (!Tcutil::is_const_exp(te,(exp_t)f->tag))
	terr(loc,"enum %s, field %s: expression is not constant",
             *v,*(*f->name)[1]);
      
      unsigned int t1 = Evexp::eval_const_uint_exp((exp_t)f->tag);
      tag_count = t1+1;
      
      (*f->name)[0] = new Abs_n(te->ns);
    }
  }

  // update the environment
  try {
    let edp = Dict::lookup(ge->enumdecls, v);
    let ed2 = Tcdecl::merge_enumdecl(*edp, ed, loc, tc_msg);
    if (ed2 == NULL) return;
    *edp = (enumdecl_t) ed2; // if there's no error, make the update
  } catch {
  case Dict::Absent:
    let edp = new ed;
    ge->enumdecls = Dict::insert(ge->enumdecls, v, edp);
    break;
  }

  if (ed->fields != NULL) {
    for (_ fs = ed->fields->v; fs != NULL; fs = fs->tl) {
      let f = fs->hd;
      ge->ordinaries = Dict::insert(ge->ordinaries, (*f->name)[1],
				    new $(new EnumRes(ed,f), true));
    }
  }
}

static bool okay_externC(seg_t loc, scope_t sc) {
  switch (sc) {
  case Static:
    warn(loc,"static declaration nested within extern \"C\"");
    return false;
  case Abstract:
    warn(loc,"abstract declaration nested within extern \"C\"");
    return false;
  case Public: return true;
  case Extern:
    // warn(loc,"converting extern declaration to extern \"C\"");
    return true;
  case ExternC:
    warn(loc,"nested extern \"C\" declaration");
    return true;
  }
}

// Typecheck a list, ds, of declarations in environment te.
// As a side effect, all declarations and variable references are made
// absolute, so later passes just recurse through namespace and using
// New: a second pass shakes out unnecessary vardecls.
// FIX: shake out type definitions too.
static void tc_decls(tenv_t te, list_t<decl_t,`H> ds0, bool in_externC, bool check_var_init) {

  genv_t ge = Dict::lookup(te->ae,te->ns); // no longer a copy!!!
  list_t<decl_t,`H> last = NULL;
  
  // FIX: Add dict to some environment so that typerep declarations get reused
  typerep_dict_t dict = empty_typerep_dict();
  
  for (let ds = ds0; ds != NULL; last = ds, ds = ds->tl) {
    decl_t d   = ds->hd;
    seg_t  loc = d->loc;

    switch (d->r) {
    case &Let_d(_,_,_,_,_): 
    case &Letv_d(_): // FIX
      terr(loc,"top level let-declarations are not implemented");
      break;
    case &Var_d(vd):
      if (in_externC && okay_externC(d->loc,vd->sc))
	vd->sc = ExternC;
      if (vd->initializer != NULL) {
	switch (vd->initializer->r) {
	case &Gentyp_e(_,t):
	  /* FIX: should pass in a dictionary and use that throughout
	     typechecking to share generated declarations */
	  let $(dict2,ds2,e) = tcGenrep(te,ge,loc,t,dict);
	  dict = dict2;
	  /* typecheck the generated declarations */
	  tc_decls(te,ds2,in_externC,check_var_init);
	  /* replace the gentype expression with the generated one */
	  vd->initializer = e;
	  //printf("%s\n",decllist2string(List::list(d)));
	  /* then typecheck the vardecl */
	  tcVardecl(te,ge,loc,vd,check_var_init);
	  /* splice in the new declarations */
	  /* this is tricky! */
	  //	  printf("==============BEFORE=================\n%s\n====================BEFORE=====================\n",decllist2string(ds0));
	  if(ds2 != NULL) {
	    if (last != NULL) {
	      imp_append(ds2,ds);
	      last->tl = ds2;
	    }
	    else {
	      struct List<decl_t,`H> tmp = List{.hd = ds->hd, .tl = ds->tl};
	      ds->hd = ds2->hd;
	      ds->tl = ds2->tl;
	      ds2->hd = tmp.hd;
	      ds2->tl = tmp.tl;
	      imp_append(ds,ds2);
	    }
	  }
	  /* continue the loop */
	  //printf("==============AFTER=================\n%s\n====================AFTER=====================\n",decllist2string(ds0));
	  continue;
	default:
	  break;
	}
      }
      // catches the non gen() cases
      tcVardecl(te,ge,loc,vd,check_var_init);
      break;
    case &Fn_d(fd):
      if (in_externC && okay_externC(d->loc,fd->sc))
	fd->sc = ExternC;
      tcFndecl(te,ge,loc,fd);
      break;
    case &Typedef_d(td):
      tcTypedefdecl(te,ge,loc,td);
      break;
    case &Struct_d(sd):
      if (in_externC && okay_externC(d->loc,sd->sc))
	sd->sc = ExternC;
      tcStructdecl(te,ge,loc,sd);
      break;
    case &Union_d(ud):
      if (in_externC && okay_externC(d->loc,ud->sc))
        ud->sc = ExternC;
      tcUniondecl(te,ge,loc,ud);
      break;
    case &Tunion_d(tud):
      if (in_externC && okay_externC(d->loc,tud->sc))
	tud->sc = ExternC;
      tcTuniondecl(te,ge,loc,tud);
      break;

    case &Enum_d(ed):
      if (in_externC && okay_externC(d->loc,ed->sc))
        ed->sc = ExternC;
      tcEnumdecl(te,ge,loc,ed);
      break;

    case &Namespace_d(v,ds2):
      // DAN: This case is much more imperative than it used to be.
      let ns  = te->ns;
      let ns2 = List::append(ns,new List(v,NULL));
      // Make sure namespace v has been declared in the current namespace
      if (!Set::member(ge->namespaces,v)) {
        ge->namespaces = Set::insert(ge->namespaces,v);
	te->ae = Dict::insert(te->ae, ns2, empty_genv());
      }
      // Do the nested declarations then restore the namespace
      te->ns = ns2;
      tc_decls(te,ds2,in_externC,check_var_init);
      te->ns = ns;
      break;

    case &Using_d(&$(nsl,v),ds2):
      // DAN: We're more imperative here too.
      var_t first;
      list_t<var_t> rest;
      switch (nsl) {
      case Loc_n:       
      case &Rel_n(NULL):
      case &Abs_n(NULL):
        first = v; rest = NULL; break;
      case &Rel_n(&List(x,y)): fallthru(x,y);
      case &Abs_n(&List(x,y)):
        first = x; rest = List::append(y,new List(v,NULL)); break;
      }
      let ns2 = resolve_namespace(te,loc,first,rest);
      ge->availables = new List(ns2,ge->availables);
      tc_decls(te,ds2,in_externC,check_var_init);
      ge->availables = ge->availables->tl;
      break;

    case &ExternC_d(ds2):
      tc_decls(te,ds2,true,check_var_init);
      break;
    }
  }
}

void tc(tenv_t te, bool check_var_init, list_t<decl_t,`H> ds) {
  set_params(&tc_params_r);
  tc_decls(te,ds,false,check_var_init);
}

// for tree-shaking (so we don't include the world)
// Note: We must shake after all type-checking or we'll be too eager.
// Note: All names should now be absolute.

// We recompute the global environment and delete what's not needed anymore
// all would be far easier if Dict has a delete function :-)

// for each namespace, we have the environment and a list of what has to be removed in it
typedef Dict::dict_t<list_t<var_t>, $(genv_t, Set::set_t<var_t>) @> treeshake_env_t;

static bool vardecl_needed(treeshake_env_t env, decl_t d);

static list_t<decl_t> treeshake_f(treeshake_env_t env, list_t<decl_t> ds) {
  return List::filter_c(vardecl_needed, env, ds);
}

static bool vardecl_needed(treeshake_env_t env, decl_t d) {
  switch(d->r) {
  case &Var_d(vd):
    // get rid of externs that are never referenced
    if(vd->sc != Extern)
      return true;
    let &$(nsl,name) = vd->name;
    list_t<var_t> ns;
    switch (nsl) {
    case Loc_n:    ns = NULL; break;
    case &Rel_n(y): ns = y; break;
    case &Abs_n(y): ns = y; break;
    }
    let nsenv = Dict::lookup(env,ns);
    let ge = (*nsenv)[0];
    let needed = (*Dict::lookup(ge->ordinaries,name))[1];
    if (! needed) {
      (*nsenv)[1] = Set::insert((*nsenv)[1], name); // we'll remove it later from ge->ordinaries
    }
    return needed;
  case &Using_d(_,*ds2p): fallthru(ds2p);
  case &Namespace_d(_,*ds2p):
    *ds2p = treeshake_f(env,*ds2p);
    return true;
  default: return true;
  }
}

// Mathieu : all this would be really nicer if we had local functions...
static bool treeshake_remove_f(Set::set_t<var_t> set, var_t x, _ y) {
  return !Set::member(set, x);
}

static void treeshake_remove(list_t<var_t> ns, 
			     $(genv_t, Set::set_t<var_t>) @ nsenv) {
  let &$(ge,set) = nsenv;
  ge->ordinaries = Dict::filter_c(treeshake_remove_f, set, ge->ordinaries);
}
			     			     
static $(genv_t, Set::set_t<var_t>)@ treeshake_make_env_f(genv_t ge) {
  return new $(ge, Set::empty(strptrcmp));
}

list_t<decl_t> treeshake(tenv_t te, list_t<decl_t> ds) {
  let env = Dict::map(treeshake_make_env_f, te->ae);
  let ds1 = treeshake_f(env, ds);
  Dict::iter(treeshake_remove, env); // update the global environment
  return ds1;
}
