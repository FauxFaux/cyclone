/* Type checking for top-level declarations */

#include "core.h"
#include "string.h"
#include "list.h"
#include "position.h"
#include "absyn.h"
#include "absynpp.h"
#include "tcutil.h"
#include "tcenv.h"
#include "tcexp.h"
#include "tcstmt.h"
#include "evexp.h"
#include "tc.h"
#include "stdio.h"
using Core;
using List;
using Position;
using Absyn;
using Absynpp;
using Tcutil;
using Tcenv;
using Stdio;

namespace Tc;

// check that the scope for a redeclaration of a type is okay
static void redecl_err(segment loc, string t, stringptr v,
		       string new_sc, string old_sc) {
  terr(loc, xprintf("redeclaration of %s %s cannot be %s "
		    "when earlier definition is %s",
		    t, *v, new_sc, old_sc));
}
static scope scope_redecl_okay<`a>(scope s1, Opt_t<`a> fields1,
                                   scope s2, Opt_t<`a> fields2,
                                   segment loc, string t, stringptr v) {
  switch ($(s1,s2)) {
  case $(ExternC, ExternC): break;
  case $(_,       ExternC):
    redecl_err(loc, t, v, "non-extern \"C\"", "extern \"C\""); break;
  case $(Static,  Static): break;
  case $(_,       Static): redecl_err(loc, t, v, "non-static", "static"); break;
  case $(Static,  Public): redecl_err(loc, t, v, "static",     "public"); break;
  case $(Abstract,Public): redecl_err(loc, t, v, "abstract",   "public"); break;
  case $(_,       Public): s1 = Public; break;
  case $(Static,  Extern): redecl_err(loc, t, v, "static",     "extern"); break;
  case $(Abstract,Extern) && fields2 != null:
    redecl_err(loc,t,v, "abstract", "transparent"); break;
  case $(_,       Extern): break;
  case $(Static,Abstract): redecl_err(loc, t, v, "static", "abstract"); break;
  case $(Public,Abstract): redecl_err(loc, t, v, "public", "abstract"); break;
  case $(Extern,Abstract) && fields1 != null:
    redecl_err(loc,t,v, "[extern] transparent", "abstract"); break;
  case $(_,     Abstract): s1 = Abstract; break;
  }
  return s1;
}

// check that an enumfield in a redeclaration matches the previous declaration
// We only check [1] of the qvars b/c qualified field names aren't allowed (?)
static void field_redecl_okay(enumfield f1, enumfield f2,
			      list<$(tvar,typ)@> inst, tenv te,
			      string t, stringptr v) {

  segment loc = f1->loc;
  // must have same name
  if (String::zstrptrcmp((*f1->name)[1],(*f2->name)[1]) != 0)
    terr(loc,xprintf("redeclaration of %s %s: field name mismatch %s != %s",
		     t, *v, *((*f1->name)[1]),
		     *((*f2->name)[1])));
  // must have same tag
  if ((f1->tag == null && f2->tag != null) ||
      (f1->tag != null && f2->tag == null) ||
      (f1->tag != null && f2->tag != null &&
       Evexp::eval_const_uint_exp((exp)f1->tag) !=
       Evexp::eval_const_uint_exp((exp)f2->tag))) {
    terr(loc,xprintf("redeclaration of %s %s: tag mismatch for field %s",
		     t, *v, *((*f1->name)[1])));
  }
  let tvs1 = f1->tvs;
  let tvs2 = f2->tvs;
  if (List::length(tvs1) != List::length(tvs2))
    terr(loc,xprintf("redeclaration of %s %s, field %s: type parameter number "
		     "mismatch", t, *v, *((*f1->name)[1])));
  for (; tvs1 != null; tvs1 = tvs1->tl, tvs2 = tvs2->tl)
    inst = &cons(&$(tvs2->hd,VarType(tvs1->hd)),inst);
  // must have same number of types
  let typs1 = f1->typs;
  let typs2 = f2->typs;
  if (List::length(typs1) != List::length(typs2))
    terr(loc,xprintf("redeclaration of %s %s, field %s: parameter number "
		     "mismatch", t, *v, *((*f1->name)[1])));
  // for all types
  for (; typs1 != null; typs1 = typs1->tl, typs2 = typs2->tl) {
     // must have same qualifier
    if (!equal_tqual((*typs1->hd)[0],(*typs2->hd)[0]))
      terr(loc,xprintf("redeclaration of %s %s, field %s: parameter qualifier",
		       t, *v, *((*f1->name)[1])));
    typ subst_t2 = substitute(inst,(*typs2->hd)[1]);
    // and be the same type FIX: (?) is unification appropriate here?
    if (!unify((*typs1->hd)[1],subst_t2))
      terr(loc,xprintf("redeclaration of %s %s, field %s: parameter type "
		       "mismatch %s != %s",
		       t, *v, *((*f1->name)[1]),
		       typ2string((*typs1->hd)[1]), typ2string(subst_t2)));
  }
}

//Note: must be called after check_valid_type.  So we shouldn't
//      find an unconstrained Evar or a Typedef or such.
static bool ok_field_type(segment loc, tenv te, typ t) {
  switch (compress(t)) {
  case VarType(&$(_,RgnKind)):  throw Impossible("Region var in ok_field_type");
  case VarType(&$(_,BoxPKind)): return true;
  case VarType(&$(_,BoxUKind)): return false; // FIX at some point
  case VarType(&$(_,_)):        return false;

  case FnType(_,_,_,_):  return false;
  case RgnHandleType(_): return false; // FIX at some point
  case UnionType:        return false;

    // hmm, maybe void fields should be rejected
  case VoidType:             return true;
  case IntType(_,_):         return true;
  case FloatType:            return true;
  case DoubleType:           return true;
  case ArrayType(_,_,_):     return true;
  case PointerType(_):       return true;
  case EnumType(_,_,_):      return true;
  case XenumType(_,_):       return true;

  case TupleType(tq_ts):
    for (; tq_ts != null; tq_ts = tq_ts->tl)
      if(!ok_field_type(loc, te, (*tq_ts->hd)[1]))
	return false;
    return true;
  case StructType(tdnopt,_,sdp):
    if (tdnopt == null)
      return false;
      // Every structdecl entered in te already has ok fields,
      // so we only need to check whether the struct is abstract.
      // NB, check_valid_type is called before this, so tdn is
      // an absolute name.
    return (*sdp)->fields != null;

  case Evar(_,_,_):        throw Impossible("Evar in ok_field_type");
  case TypedefType(_,_,_): throw Impossible("Typedef in ok_field_type");
  case HeapRgnType:        throw Impossible("HeapRgnType in ok_field_type");
  }
}

// FIX:  we should really check that static or public function prototypes
// are eventually declared.  However, C will catch this for us, so I'm
// not bothering to do this now.

// now returns whether there is a redeclaration or not -- needed for treeshaking
static bool var_redecl_okay(genv_t ge, segment loc, var name, typ t, scope sc) {
  Opt_t<$(resolved_t,bool)@> ans = Dict::lookup_opt(ge->ordinaries,name);
  if(ans == null)
    return false;
  (*ans->v)[1] = true; // this is very important or we'd shake out too much
  switch ((*ans->v)[0]) {
  case VarRes(Global_b(vd)):
    if (sc == Static && vd->sc != Static)
      warn(loc,
           xprintf("static declaration of %s follows non-static declaration",
                   *name));
    if (vd->sc == Static && sc != Static)
      warn(loc,
	   xprintf("non-static declaration of %s follows static declaration",
		   *name));
    if ((vd->sc == ExternC && sc != ExternC) ||
	(vd->sc != ExternC && sc == ExternC))
      terr(loc,xprintf("incompatible redeclaration of %s",*name));
    // either they must both be static, both public, or at most one non-extern
    else if ((sc != Extern && vd->sc != Extern) &&
	!(sc == Static && vd->sc == Static) &&
	!(sc == Public && vd->sc == Public))
      terr(loc,xprintf("incompatible redeclaration of %s",*name));
    // all must be at the same type
    if (!unify(vd->type,t))
      // FIX: should the test be unification?
      // FIX: we should also check the tqual
      terr(loc,xprintf("redeclaration of %s at a different type: %s != %s",
		       *name, typ2string(t), typ2string(vd->type)));
    break;
  default: break;
  }
  return true;
}

static bool is_function_type(typ t) {
  switch (compress(t)) {
  case FnType(_,_,_,_): return true;
  default: return false;
  }
}

static void tcVardecl(tenv te, genv_t ge, segment loc, vardecl vd) {
  var   v  = (*vd->name)[1];
  typ   t  = vd->type;
  scope sc = vd->sc;

  // reject explicitly qualified name
  switch ((*vd->name)[0]) {
  case Rel_n(null): break;
  case Abs_n(null): break; // allowed for top-level constants
  default:
    terr(loc,"qualified declarations are not implemented"); // FIX
    return;
  }
  // expand to qualified name
  (*vd->name)[0] = Abs_n(te->ns);
  // reject ill-formed type
  check_valid_type(loc,te,null,t);
  // check for redeclaration
  bool is_redecl = var_redecl_okay(ge,loc,v,t,sc);
  // if extern, make sure it has no initializer
  if (sc == Extern || sc == ExternC) {
    if(vd->initializer != null)
      terr(loc,"extern declaration should not have initializer");
  } else if (!is_function_type(t)) {
    // we skip over function types -- these are function protypes.
    // otherwise, we compute default initializer, if necessary
    exp e;
    if(vd->initializer == null) {
      e = default_initializer(te,t,loc);
      vd->initializer = e;
    } else {
      e = (exp)vd->initializer;
      // special case for t[] -- fill in the size for the user
      switch (compress(t)) {
      case ArrayType(telt,tq,sz):
	if (Evexp::eval_const_uint_exp(sz) == 0) {
	  switch (e->r) {
	  case Const_e(String_c(_,s)):
	    t = vd->type = ArrayType(telt,tq,uint_exp(s.size,null));
	    break;
	  case UnresolvedMem_e(_,es): fallthru(es);
	  case Array_e(_,es):
	    t = vd->type = ArrayType(telt,tq,uint_exp(List::length(es),null));
	    break;
	  default: break;
	  }
	}
	break;
      default: break;
      }
    }
    // type-check the initializer
    let t2 = Tcexp::tcExpInitializer(te,&t,e);
    if (!coerce_assign(te,e,t))
      terr(loc,
	   xprintf("%s is declared with type %s but initialized with type %s",
		   qvar2string(vd->name), typ2string(t), typ2string(t2)));
    // reject non-constant initializers
    if (!Tcexp::is_const_exp(te,e))
      terr(loc,"initializer is not a constant expression");
  }
  // add to environment
  ge->ordinaries = Dict::insert(ge->ordinaries, v,
				&$(VarRes(Global_b(vd)),is_redecl));
}

static void tcFndecl(tenv te, genv_t ge, segment loc, fndecl fd) {
  var   v  = (*fd->name)[1];
  typ   t  = fndecl2typ(fd);
  scope sc = fd->sc;

  // reject explicitly qualified name
  switch ((*fd->name)[0]) {
  case Rel_n(null): break;
  case Abs_n(y):
    throw Impossible("tc: Abs_n in tcFndecl");
  default:
    terr(loc,"qualified declarations are not implemented"); // FIX
    return;
  }
  // expand to qualified name
  (*fd->name)[0] = Abs_n(te->ns);
  // reject ill-formed type
  check_fndecl_valid_type(loc,te,fd);
  // check for redeclaration
  bool is_redecl = var_redecl_okay(ge, loc, v, t, sc);
  // due to recursion, add function to environment before checking body
  ge->ordinaries = Dict::insert(ge->ordinaries, v,
				&$(VarRes(Funname_b(fd)),is_redecl));
  // DAN: Here is where I'm assuming the te can be imperatively screwed with
  //      while we're dealing with top-level stuff (though it's not too hard
  //      to undo that assumption)
  te->le = &Opt(Outermost(new_fenv(fd)));
  // check the body, then get rid of local environment
  Tcstmt::tcStmt(te,fd->body,false);
  // check for undefined labels FIX: get better error message
  if(!all_labels_resolved(te))
    terr(loc,"function has goto statements to undefined labels");

  te->le = null;
}

static void tcTypedefdecl(tenv te, genv_t ge, segment loc, typedefdecl td) {
  var v = (*td->name)[1];
  // reject explicitly qualified name
  switch ((*td->name)[0]) {
  case Rel_n(null): break;
  case Abs_n(null): break; // allowed for top-level constants
  default:
    terr(loc,"qualified declarations are not implemented"); // FIX
    return;
  }
  // check for redeclaration (never allowed, apparently)
  if (Dict::member(ge->typedefs,v)) {
    terr(loc,xprintf("redeclaration of typedef %s",*v));
    return;
  }
  // expand to qualified name
  (*td->name)[0] = Abs_n(te->ns);
  // reject ill-formed type
  check_unique_tvars(loc,td->tvs);
  check_valid_type(loc,te,td->tvs,td->defn);
  // add to environment
  ge->typedefs = Dict::insert(ge->typedefs,v,td);
}

// FIX: For now, all instantiations must be packable.
//      Better is to have a decl field recording packability assuming
//      packable fields.  Better yet is packable polymorphism.
static void tcStructdecl(tenv te, genv_t ge, segment loc, structdecl sd) {
  // reject anonymous top-level
  if (sd->name == null) {
    terr(loc,"anonymous structs are not allowed at top level");
    return;
  }
  var        v   = (*sd->name->v)[1];
  list<tvar> tvs = sd->tvs;
  // reject explicitly qualified name
  switch ((*sd->name->v)[0]) {
  case Rel_n(null): break;
  case Abs_n(null): break; // allowed for top-level constants
  default:
    terr(loc,"qualified declarations are not implemented"); // FIX
    return;
  }
  // expand to qualified name
  (*sd->name->v)[0] = Abs_n(te->ns);
  // reject ill-formed type
  check_unique_tvars(loc,tvs);

  // redeclarations have to be handled differently
  switch (Dict::lookup_opt(ge->structdecls,v)) {
  case null:
    // add the declaration to the environment, then go check the fields
    ge->structdecls = Dict::insert(ge->structdecls, v, (structdecl@)(&$(sd)));
    if(sd->fields == null) {
      for(; tvs != null; tvs = tvs->tl)
	switch((*tvs->hd)[1]) {
	case UnresolvedKind: (*tvs->hd)[1] = BoxPKind; break;
	default: break;
	}
      return;
    }
    break;

  case &Opt(sdp): // a redeclaration
    let sd2  = *sdp;
    let tvs2 = sd2->tvs;
    // reject if type-arity is different
    if(List::length(tvs) != List::length(tvs2))
      terr(loc,xprintf("redeclaration of struct %s "
		       "has a different number of type parameters", *v));
    // reject if scopes are inconsistent
    sd->sc = scope_redecl_okay(sd->sc, sd->fields, sd2->sc, sd2->fields,
			       loc, "struct", v);
    // now things really depend on which declarations have fields
    switch ($(sd->fields, sd2->fields)) {
    case $(null,null): return;
    case $(_,   null): *sdp = sd; break; // go check the fields below
    case $(null,_):    sd->fields = sd2->fields; sd->tvs = tvs; return;
    case $(_,   _):
      // both declare fields, so they must agree (with renaming w.r.t. tyvars)
      list <$(tvar,typ)@> inst = null;
      for(let tvs0 = tvs; tvs0 != null; tvs0 = tvs0->tl, tvs2 = tvs2->tl)
	inst = &cons(&$(tvs2->hd,VarType(tvs0->hd)), inst);
      // check each field under the map
      let f1s = sd->fields->v;
      let f2s = sd2->fields->v;
      for(; f1s != null && f2s != null; f1s = f1s->tl, f2s = f2s->tl) {
	let &$(fn1,tq1,t1) = f1s->hd;
	let &$(fn2,tq2,t2) = f2s->hd;
	// names, qualifiers, and types all must agree
	if (String::zstrptrcmp(fn1,fn2) != 0)
	  terr(loc, xprintf("redeclaration of struct %s: field name mismatch "
			    "%s != %s", *v, *fn1, *fn2));
	if (!equal_tqual(tq1,tq2))
	  terr(loc, xprintf("redeclaration of struct %s: qualifier mismatch on"
			    " field %s", *v, *fn1));
	// important side-effects on t1
	check_valid_type(loc, te, tvs, t1);
	typ subst_t2 = substitute(inst,t2);
	if(!unify(t1,subst_t2)) // FIX: unify definitely seems wrong here
	  terr(loc,xprintf("redeclaration of struct %s: type mismatch on field"
			   " %s: %s != %s", *v, *fn1,
			   typ2string(t1), typ2string(subst_t2)));
      }
      // check for field-number mismatch
      if (f2s != null)
	terr(loc,xprintf("redeclaration of struct %s is missing field %s",
			 *v, *((*f2s->hd)[0])));
      if (f1s != null)
	terr(loc,xprintf("redeclaration of struct %s has extra field %s",
			 *v, *((*f1s->hd)[0])));
      return;
    }
    break;
  }
  // This is the first declaration with fields, so check the fields
  // may not be the first declaration, so must not overwrite the dict
  // entry!
  // for the sake of recursive fields, make name abstract in body
  let sdp = Dict::lookup(ge->structdecls, v);
  *sdp = &Structdecl(sd->sc, sd->name, tvs, null);
  // check fields, rejecting ill-formed types, bad fields, and duplicates
  list<field_name> prev_fields = null;
  for (let fs = sd->fields->v; fs != null; fs = fs->tl) {
    let &$(fn,tq,t) = fs->hd;
    if (List::mem(String::zstrptrcmp,prev_fields,fn))
	terr(loc,xprintf("duplicate field %s in struct",*fn));
    prev_fields = &cons(fn,prev_fields);
    check_valid_type(loc,te,tvs,t);
    if (!ok_field_type(loc,te,t))
      terr(loc,xprintf("fields of type %s are not allowed",typ2string(t)));
    // FIX: check for consistent tquals?
  }
  // add the constructor to the environment
  ge->ordinaries = Dict::insert(ge->ordinaries,  v,
				&$(StructRes(sd), true));
  // undo our clobbering with the abstract version
  *sdp = sd;
}

// FIX: for now, ensure all instantiations are packable (see comments
//      with tcStructdecl)
static void tcEnumdecl(tenv te, genv_t ge, segment loc, enumdecl ed) {
  // reject anonymous top-level
  if (ed->name == null) {
    terr(loc,"anonymous enums are not allowed at top level");
    return;
  }
  var        v   = (*ed->name->v)[1];
  list<tvar> tvs = ed->tvs;
  // reject explicitly qualified name
  switch ((*ed->name->v)[0]) {
  case Rel_n(null): break;
  case Abs_n(null): break; // allowed for top-level constants
  default:
    terr(loc,"qualified declarations are not implemented"); // FIX
    return;
  }
  // expand to qualified name
  (*ed->name->v)[0] = Abs_n(te->ns);
  // reject ill-formed type
  check_unique_tvars(loc,tvs);

  // redeclarations have to be handled differently
  // check for redeclaration
  switch (Dict::lookup_opt(ge->enumdecls, v)) {
  case null:
    // add the declaration to the environment, then go check the fields
    ge->enumdecls = Dict::insert(ge->enumdecls, v, (enumdecl@)(&$(ed)));
    if(ed->fields == null) {
      for(; tvs != null; tvs = tvs->tl)
	switch((*tvs->hd)[1]) {
	case UnresolvedKind: (*tvs->hd)[1] = BoxPKind; break;
	default: break;
	}
      return;
    }
    break;

  case &Opt(edp):
    let ed2  = *edp;
    let tvs2 = ed2->tvs;
    // reject if type-arity is different
    if(List::length(tvs) != List::length(tvs2))
      terr(loc,xprintf("redeclaration of enum %s "
		       "has a different number of type parameters", *v));
    // reject if scopes are different
    ed->sc = scope_redecl_okay(ed->sc, ed->fields, ed2->sc, ed2->fields,
			       loc, "enum", v);
    // now things really depend on which declarations have fields
    switch ($(ed->fields, ed2->fields)) {
    case $(null,null): return;
    case $(_,   null): *edp = ed; break; // go check the fields below
    case $(null,_):    ed->fields = ed2->fields; ed->tvs = tvs2; return;
    case $(_,   _):
      // both declare fields, so they must agree (with renaming w.r.t. tyvars)
      list<$(tvar,typ)@> inst = null;
      for(let tvs0 = tvs; tvs0 != null; tvs0 = tvs0->tl, tvs2 = tvs2->tl)
	inst = &cons(&$(tvs2->hd,VarType(tvs0->hd)), inst);
      // check each field under the map
      let f1s = ed->fields->v;
      let f2s = ed2->fields->v;
      // the types in f1 haven't been checked yet, which does important
      // side effects

      for (; f1s != null && f2s != null; f1s = f1s->tl, f2s = f2s->tl) {
	(*f1s->hd->name)[0] = Abs_n(te->ns);
	// check f1s->hd types for the important side effects
	list<tvar> alltvs = List::append(tvs, f1s->hd->tvs);
	check_unique_tvars(f1s->hd->loc,alltvs);
	for(let typs = f1s->hd->typs; typs != null; typs = typs->tl) {
	  let t = (*typs->hd)[1];
	  check_valid_type(f1s->hd->loc,te,alltvs,t);
	}
	// now we can check against previous definition of field
	field_redecl_okay(f1s->hd, f2s->hd, inst, te, "enum", v);
      }
      // check for field-number mismatch
      if (f1s != null)
	terr(loc,xprintf("redeclaration of enum %s has extra field %s",
			 *v, *((*f1s->hd->name)[1])));
      if (f2s != null)
	terr(loc,xprintf("redeclaration of enum %s is missing field %s",
			 *v, *((*f2s->hd->name)[1])));
      return;
    }
    break;
  }
  // This is the first declaration with variants, so check the variants
  // may not be the first declaration, so must not overwrite the dict
  // entry!
  // for the sake of recursive fields, make name abstract in body
  let edp = Dict::lookup(ge->enumdecls, v);
  *edp = &Enumdecl(ed->sc, ed->name, tvs, null);
  // check variants, rejecting ill-formed types, non-constant tags,
  // repeated tyvars (why?), and duplicate field names
  // finally, add variants
  list<field_name> prev_fields = null;
  for(let fs = ed->fields->v; fs != null; fs = fs->tl) {
    let f = fs->hd;
    if (List::mem(String::zstrptrcmp,prev_fields,(*f->name)[1]))
      terr(f->loc,xprintf("duplicate field name %s",*((*f->name)[1])));
    prev_fields = &cons((*f->name)[1],prev_fields);
    if (f->tag != null)
      Evexp::eval_const_uint_exp((exp)f->tag);
    list<tvar> alltvs = List::append(tvs,f->tvs);
    check_unique_tvars(loc,alltvs);
    for (list<$(tqual,typ)@> typs = f->typs; typs != null; typs=typs->tl) {
      let t = (*typs->hd)[1];
      check_valid_type(f->loc,te,alltvs,t);
    }
    // FIX: check valid tquals?
    (*f->name)[0] = Abs_n(te->ns);
    ge->ordinaries = Dict::insert(ge->ordinaries, (*f->name)[1],
				  &$(EnumRes(ed,f), true));
  }
  // add the decl to the environment -- must be after variant-checking
  // (where we added an abstract version)
  ge->enumdecls = Dict::insert(ge->enumdecls, v, (enumdecl@)(&$(ed)));
  // undo our clobbering with the abstract version
  *edp = ed;
}

// FIX: ensure the types are packable (see comment with tcStructdecl).
static void tcXenumdecl(tenv te, genv_t ge, segment loc, xenumdecl xd) {
  var v = (*xd->name)[1];
  Opt_t<xenumdecl@> xd2o;
  try xd2o = lookup_xenumdecl(te,loc,xd->name);
  catch { case Dict::Absent:
    terr(loc,
         xprintf("qualified xenum declaration %s is not an existing xenum",
                 qvar2string(xd->name)));
    return;
  }
  // expand to qualified name, if not already qualified
  switch ((*xd->name)[0]) {
  case Loc_n:
    throw Impossible("tcXenumdecl: Loc_n");
  case Rel_n(null):
    (*xd->name)[0] = Abs_n(te->ns);
    break;
  case Rel_n(_):
    throw Impossible("tcXenumdecl: Rel_n non-null");
  case Abs_n(_):
    throw Impossible("tcXenumdecl: Abs_n");
  }
  // if we're a new xenum, then make a fresh "already there" xenumdecl
  //       and add it to the environment
  // if we're not new, compare scopes
  if(xd2o == null) {
    xenumdecl @ x = (xenumdecl@)(&$(&Xenumdecl{.sc=xd->sc,
                                               .name=xd->name,
					       .fields=null}));
    xd2o = &Opt(x);
    ge->xenumdecls = Dict::insert(ge->xenumdecls, v, x);
  } else {
    let x = *(xd2o->v);
    x->sc = scope_redecl_okay(xd->sc, &Opt(0), x->sc, &Opt(0), loc, "xenum", v);
  }
  // now check that we can add each "field" by ensuring that
  // duplicates are the same.  Note that fields are qualified by the current
  // namespace if implicit, not the namespace of the xenum
  // Notice that we're "hoisting" the fields into the earlier definition,
  // if there is one we know about.
  xenumdecl xd_result = *(xd2o->v);
  for(list<enumfield> fs = xd->fields; fs != null; fs = fs->tl) {
    enumfield f = fs->hd;
    // expand field name if not explicitly qualified
    switch ((*f->name)[0]) {
    case Rel_n(null): (*f->name)[0] = Abs_n(te->ns); break;
    case Rel_n(_): fallthru;
    case Abs_n(_):
      terr(loc,"qualified declarations are not allowed\n");
      break;
    case Loc_n:
      throw Impossible("tcXenumdecl: Loc_n");
      break;
    }
    // reject if there is an ill-formed type
    list<tvar>tvs = f->tvs;
    check_unique_tvars(loc,tvs);
    for(let typs = f->typs; typs != null; typs = typs->tl) {
      let t = (*typs->hd)[1];
      check_valid_type(f->loc,te,tvs,t);
    }
    // notice we now allow duplicates, they just have to have the same type
    // also, we can be totally re-ordered from a different declaration
    bool dup = false;
    for(let prev_fs = xd_result->fields; prev_fs!=null; prev_fs = prev_fs->tl){
      let prev = prev_fs->hd;
      if(qvar_cmp(f->name, prev->name)==0) {
	field_redecl_okay(prev, f, null, te, "xenum", v);
	// do not add the duplicate to the result:
	dup = true;
	break;
      }
    }
    if(dup)
      continue;
    // no duplicate, so add to the result
    xd_result->fields = &cons(f, xd_result->fields);
    // notice we allow adding to another namespace via qualified field
    genv_t ge_f;
    list<var> ns_f;
    switch ((*f->name)[0]) {
    case Abs_n(y): ns_f = y; break;
    case Loc_n: fallthru;
    case Rel_n(_):
      throw Impossible("tcXenumdecl: Rel_n or Loc_n");
      break;
    }
    try ge_f = Dict::lookup(te->ae, ns_f);
    catch { case Dict::Absent:
      terr(f->loc, xprintf("bad namespace for xenum field %s",
			   qvar2string(f->name)));
      return;
    }
    ge_f->ordinaries = Dict::insert(ge_f->ordinaries, (*f->name)[1],
				    &$(XenumRes(xd_result, f), true));
  }
}

static bool okay_externC(segment loc, scope sc) {
  switch (sc) {
  case Static:
    warn(loc,"static declaration nested within extern \"C\"");
    return false;
  case Abstract:
    warn(loc,"abstract declaration nested within extern \"C\"");
    return false;
  case Public: return true;
  case Extern:
    // warn(loc,"converting extern declaration to extern \"C\"");
    return true;
  case ExternC:
    warn(loc,"nested extern \"C\" declaration");
    return true;
  }
}

// Typecheck a list, ds, of declarations in environment te.
// As a side effect, all declarations and variable references are made
// absolute, so later passes just recurse through namespace and using
// New: a second pass shakes out unnecessary vardecls.
// FIX: shake out type definitions too.
static void tc_decls(tenv te, list<decl> ds0, bool in_externC) {

  genv_t ge = Dict::lookup(te->ae,te->ns); // no longer a copy!!!

  for (let ds = ds0; ds != null; ds = ds->tl) {
    decl    d   = ds->hd;
    segment loc = d->loc;

    switch (d->r) {
    case Let_d(_,_,_,_,_): // FIX
      terr(loc,"top level let-declarations are not implemented");
      break;
    case Union_d: // FIX
      terr(loc,"union is not implemented");
      break;
    case Var_d(vd):
      if (in_externC && okay_externC(d->loc,vd->sc))
	vd->sc = ExternC;
      tcVardecl(te,ge,loc,vd);
      break;
    case Fn_d(fd):
      if (in_externC && okay_externC(d->loc,fd->sc))
	fd->sc = ExternC;
      tcFndecl(te,ge,loc,fd);
      break;
    case Typedef_d(td):
      tcTypedefdecl(te,ge,loc,td);
      break;
    case Struct_d(sd):
      if (in_externC && okay_externC(d->loc,sd->sc))
	sd->sc = ExternC;
      tcStructdecl(te,ge,loc,sd);
      break;
    case Enum_d(ed):
      if (in_externC && okay_externC(d->loc,ed->sc))
	ed->sc = ExternC;
      tcEnumdecl(te,ge,loc,ed);
      break;
    case Xenum_d(xd):
      if (in_externC && okay_externC(d->loc,xd->sc))
	xd->sc = ExternC;
      tcXenumdecl(te,ge,loc,xd);
      break;

    case Namespace_d(v,ds2):
      // DAN: This case is much more imperative than it used to be.
      let ns  = te->ns;
      let ns2 = List::append(ns,&cons(v,null));
      // Make sure namespace v has been declared in the current namespace
      if (!Set::member(ge->namespaces,v)) {
        ge->namespaces = Set::insert(ge->namespaces,v);
	te->ae = Dict::insert(te->ae, ns2, empty_genv());
      }
      // Do the nested declarations then restore the namespace
      te->ns = ns2;
      tc_decls(te,ds2,in_externC);
      te->ns = ns;
      break;

    case Using_d(&$(nsl,v),ds2):
      // DAN: We're more imperative here too.
      var       first;
      list<var> rest;
      switch (nsl) {
      case Loc_n: fallthru;
      case Rel_n(null): fallthru;
      case Abs_n(null):
        first = v; rest = null; break;
      case Rel_n(&cons(x,y)): fallthru(x,y);
      case Abs_n(&cons(x,y)):
        first = x; rest = List::append(y,&cons(v,null)); break;
      }
      let ns2 = resolve_namespace(te,loc,first,rest);
      ge->availables = &cons(ns2,ge->availables);
      tc_decls(te,ds2,in_externC);
      ge->availables = ge->availables->tl;
      break;

    case ExternC_d(ds2):
      tc_decls(te,ds2,true);
      break;
    }
  }
}

static string cyc_string = "Cyc";
static stringptr cyc_ns = &cyc_string;

void tc(tenv te, bool add_cyc_namespace, list<decl> ds) {
  if (add_cyc_namespace)
    // wrap an implicit "namespace Cyc" around the declarations
    ds = &cons(&Decl{Namespace_d(cyc_ns,ds),null},null);

  tc_decls(te,ds,false);
}

// for tree-shaking (so we don't include the world)
// Note: We must shake after all type-checking or we'll be too eager.
// Note: All names should now be absolute.
static bool vardecl_needed(tenv te, decl d) {
  switch(d->r) {
  case Var_d(vd):
    // get rid of externs that are never referenced
    if(vd->sc != Extern)
      return true;
    let &$(nsl,name) = vd->name;
    list<var> ns;
    switch (nsl) {
    case Loc_n:    ns = null; break;
    case Rel_n(y): ns = y; break;
    case Abs_n(y): ns = y; break;
    }
    let ge = Dict::lookup(te->ae,ns);
    return (*Dict::lookup(ge->ordinaries,name))[1];
  case Using_d(_,*ds2p): fallthru(ds2p);
  case Namespace_d(_,*ds2p):
    *ds2p = treeshake(te,*ds2p);
    return true;
  default: return true;
  }
}

list<decl> treeshake(tenv te, list<decl> ds) {
  return List::filter_c(vardecl_needed,te,ds);
}
