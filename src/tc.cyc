/* Type checking for top-level declarations */

#include "core.h"
#include "string.h"
#include "list.h"
#include "position.h"
#include "absyn.h"
#include "absynpp.h"
#include "tcutil.h"
#include "tcenv.h"
#include "tcexp.h"
#include "tcstmt.h"
#include "evexp.h"
#include "tc.h"
#include "stdio.h"
#include "tcdecl.h"
using Core;
using List;
using Position;
using Absyn;
using Absynpp;
using Tcutil;
using Tcenv;
using Stdio;

namespace Tc;

// used for the error messages of tcdecl
static string tc_msg_c = "";
static string * tc_msg = &tc_msg_c;

// Transfer any function type attributes from the given list to the
// function type.  
static attributes_t transfer_fn_type_atts(type_t t, attributes_t atts) {
  switch (compress(t)) {
  case &FnType(FnInfo{_,_,_,_,_,_,*fnatts}):
    let res_atts = null;
    for (; atts != null; atts = atts->tl) {
      switch (atts->hd) {
      case &Regparm_att(_): fallthru;
      case Stdcall_att:    fallthru;
      case Cdecl_att:      fallthru;
      case Fastcall_att:   fallthru;
      case Noreturn_att:   fallthru;
      case Const_att:
        *fnatts = new List(atts->hd,*fnatts); continue;
      default:
        res_atts = new List(atts->hd,res_atts); continue;
      }
    }
    return res_atts;
  default: return impos("transfer_fn_type_atts"); 
  }
}

static void tcVardecl(tenv_t te, genv_t ge, seg_t loc, vardecl_t vd, bool check_var_init) {
  var_t   v  = (*vd->name)[1];
#ifdef DEBUG
  fprintf(stderr,"type-checking vardecl_t %s",*v); 
  fflush(stderr);
#endif
  type_t  t  = vd->type;
  scope_t sc = vd->sc;
  attributes_t atts = vd->attributes;

  // reject explicitly qualified name
  switch ((*vd->name)[0]) {
  case &Rel_n(null): break;
  case &Abs_n(null): break; // allowed for top-level constants
  default:
    terr(loc,"qualified declarations are not implemented"); // FIX
    return;
  }
  // expand to qualified name
  (*vd->name)[0] = new Abs_n(te->ns);
  // if it's an array or string, fill in the size on the type
  switch (compress(t)) {
  case &ArrayType(telt,tq,null) && vd->initializer != null:
    switch (vd->initializer->r) {
    case &Const_e(&String_c(s)):
      t = vd->type = new ArrayType(telt,tq,uint_exp(s.size,null));
      break;
    case &UnresolvedMem_e(_,es): fallthru(es);
    case &Array_e(es):
      t = vd->type = new ArrayType(telt,tq,uint_exp(List::length(es),null));
      break;
    default: break;
    }
    break;
  default: break;
  }
  // reject ill-formed type
  check_valid_toplevel_type(loc,te,t);
  if (is_function_type(t)) {
    // move any function type attributes into the function's type
    atts = transfer_fn_type_atts(t,atts);
  }
  // if extern, make sure it has no initializer
  if (sc == Extern || sc == ExternC) {
    if(vd->initializer != null)
      terr(loc,"extern declaration should not have initializer");
  } else if (!is_function_type(t)) {
    // we skip over function types -- these are function protypes.
    // otherwise, we compute default initializer, if necessary
    // first check that the attributes are okay
    for (; atts != null; atts = atts->tl) {
      switch (atts->hd) {
      case &Aligned_att(_): continue;
        // GCC doesn't allow variables to be packed
        // case Packed_att:     continue;
      case &Section_att(_): continue;
      case Nocommon_att:   continue;
      case Shared_att:     continue;
      case Unused_att:     continue;
      case Weak_att:       continue;
      case Dllimport_att:  continue;
      case Dllexport_att:  continue;
      default:
        terr(loc,xprintf("bad attribute %s for variable %s",
                         attribute2string(atts->hd), qvar2string(vd->name)));
        break;
      }
    }

    if(vd->initializer == null) {
      if (check_var_init && !supports_default(t))
        terr(loc,xprintf("initializer required for variable %s of type %s",
                         qvar2string(vd->name), typ2string(t)));
    } else {
      let e = (exp_t)vd->initializer;
      // type-check the initializer
      let t2 = Tcexp::tcExpInitializer(te,&t,e);
      if (!coerce_assign(te,e,t))
        terr(loc,
             xprintf("%s is declared with type %s but initialized with type %s",
                     qvar2string(vd->name), typ2string(t), typ2string(t2)));
      // reject non-constant initializers
      if (!Tcutil::is_const_exp(te,e))
        terr(loc,"initializer is not a constant expression");
    }
  } else {
    // it is a function type -- check that the attributes are okay
    for (; atts != null; atts = atts->tl) {
      switch (atts->hd) {
      // these attributes should be in the function's type
      case &Regparm_att(_): fallthru;
      case Stdcall_att:    fallthru;
      case Cdecl_att:      fallthru;
      case Fastcall_att:   fallthru;
      case Noreturn_att:   fallthru;
      case Const_att:
        impos("tcVardecl: fn type attributes in function var decl");
        break;
      // C doesn't allow these attributes on functions
      case &Aligned_att(_): fallthru;
      case Packed_att:
        terr(loc,xprintf("bad attribute %s in function declaration",
                         attribute2string(atts->hd)));
        break;
      default: continue;
      }
    }
  }

  // update the environment
  try {
    let ans = Dict::lookup(ge->ordinaries, v);
    switch ((*ans)[0]) {
    case &VarRes(b0):
      let b1 = new Global_b(vd);
      let b = Tcdecl::merge_binding(b0, b1, loc, tc_msg);
      if (b == Unresolved_b) break; // error in merging
      if (b == b0 && (*ans)[1]) break; // no need to reinsert the entry
      // otherwise make the update
      ge->ordinaries = Dict::insert(ge->ordinaries, v,
				    new $(new VarRes(b), true));
      break;
    default:
      impos("tcVardecl: a variable is being declared with a wrong name");
      break;
    }
  } catch {
  case Dict::Absent:
    ge->ordinaries = Dict::insert(ge->ordinaries, v,
				  new $(new VarRes(new Global_b(vd)), false));
    break;
  }
}

static void tcFndecl(tenv_t te, genv_t ge, seg_t loc, fndecl_t fd) {
  var_t   v  = (*fd->name)[1];
#ifdef DEBUG
  fprintf(stderr,"type-checking fndecl %s",*v);
  fflush(stderr);
#endif
  scope_t sc = fd->sc;

  // reject explicitly qualified name
  switch ((*fd->name)[0]) {
  case &Rel_n(null): break;
  case &Abs_n(y):
    throw new Impossible("tc: Abs_n in tcFndecl");
  default:
    terr(loc,"qualified declarations are not implemented"); // FIX
    return;
  }
  // expand to qualified name
  (*fd->name)[0] = new Abs_n(te->ns);
  // reject ill-formed type
  check_fndecl_valid_type(loc,te,fd);
  // check for redeclaration
  type_t t = fndecl2typ(fd);
  // check that packed and aligned don't show up in the attributes
  for (_ atts = fd->attributes; atts != null; atts = atts->tl) {
    switch (atts->hd) {
    case Packed_att: fallthru;
    case &Aligned_att(_): 
      terr(loc,xprintf("bad attribute %s for function",
                       attribute2string(atts->hd)));
      break;
    default: break;
    }
  }

  // due to recursion, add function to environment before checking body
  try {
    let ans = Dict::lookup(ge->ordinaries, v);
    switch ((*ans)[0]) {
    case &VarRes(b0):
      let b1 = new Funname_b(fd);
      let b = Tcdecl::merge_binding(b0, b1, loc, tc_msg);
      if (b == Unresolved_b) break; // error in merging
      if (b == b0 && (*ans)[1]) break; // no need to reinsert the entry
      // otherwise make the update
      ge->ordinaries = Dict::insert(ge->ordinaries, v,
				    new $(new VarRes(b), true));
      break;
    default:
      impos("tcFndecl: a variable is being declared with a wrong name");
      break;
    }
  } catch {
  case Dict::Absent:
    ge->ordinaries = Dict::insert(ge->ordinaries, v,
				  new $(new VarRes(new Funname_b(fd)), false));
    break;
  }

  // DAN: Here is where I'm assuming the te can be imperatively screwed with
  //      while we're dealing with top-level stuff (though it's not too hard
  //      to undo that assumption)
  te->le = new Opt(new Outermost(new_fenv(loc,fd)));
  // check the body, then get rid of local environment
  Tcstmt::tcStmt(te,fd->body,false);
  // check for undefined labels FIX: get better error message
  if(!all_labels_resolved(te))
    terr(loc,"function has goto statements to undefined labels");

  te->le = null;
}

static void tcTypedefdecl(tenv_t te, genv_t ge, seg_t loc, typedefdecl_t td) {
  var_t v = (*td->name)[1];
#ifdef DEBUG
  fprintf(stderr,"type-checking typedefdecl %s",*v);
  fflush(stderr);
#endif
  // reject explicitly qualified name
  switch ((*td->name)[0]) {
  case &Rel_n(null): break;
  case &Abs_n(null): break; // allowed for top-level constants
  default:
    terr(loc,"qualified declarations are not implemented"); // FIX
    return;
  }
  // check for redeclaration (never allowed, apparently)
  if (Dict::member(ge->typedefs,v)) {
    terr(loc,xprintf("redeclaration of typedef %s",*v));
    return;
  }
  // expand to qualified name
  (*td->name)[0] = new Abs_n(te->ns);
  // reject ill-formed type
  check_unique_tvars(loc,td->tvs);
  check_type(loc,te,td->tvs,AnyKind,td->defn);
  // add to environment
  ge->typedefs = Dict::insert(ge->typedefs,v,td);
}

static void tcStructFields(tenv_t te, genv_t ge, seg_t loc, string obj,
			   list_t<structfield_t> fields, list_t<tvar_t> tvs) {
  // check fields, rejecting ill-formed types, bad fields, and duplicates
  // (unless the field name is empty)
  region uprev_rgn {
    glist_t<field_name_t, `uprev_rgn> prev_fields = null;

    for (let fs = fields; fs != null; fs = fs->tl) {
      let &Structfield(fn,tq,t,width,atts) = fs->hd;
      
      if (List::mem(String::zstrptrcmp,prev_fields,fn))
	terr(loc, xprintf("duplicate field %s in %s", *fn, obj));
      // add the field to previous fields only if it's not an empty name
      // (empty names arise for bitfield padding.)
      if (String::strcmp(*fn,"") != 0)
	prev_fields = rnew(uprev_rgn) List(fn,prev_fields);
      
      check_type(loc,te,tvs,MemKind,t);

      // if width is non-null then t must be of integral type
      if (width != null) {
	unsigned int w = 0;
	if (!Tcutil::is_const_exp(te,width->v))
	  terr(loc,xprintf("bitfield %s does not have constant width",*fn));
	else w = Evexp::eval_const_uint_exp(width->v);
	switch (compress(t)) {
	case &IntType(_,b): 
	  switch (b) {
	  case B1:
	    if (w > 8) terr(loc,"bitfield larger than type");
	    break;
	  case B2:
	    if (w > 16) terr(loc,"bitfield larger than type");
	    break;
	  case B4:
	    if (w > 32) terr(loc,"bitfield larger than type");
	    break;
	  case B8:
	    if (w > 64) terr(loc,"bitfield larger than type");
	    break;
	  }
	  break;
	default: 
	  terr(loc,xprintf("bitfield %s must have integral type but "
			   "has type %s",*fn,typ2string(t)));
	  break;
	}
      }

      // FIX : check for consistent tquals
    }
  }
}

static void tcStructOrUniondecl(tenv_t te, genv_t ge, string obj, seg_t loc, structdecl_t sd) {
  let v = (*sd->name->v)[1];
#ifdef DEBUG
  fprintf(stderr,"type-checking %sdecl %s",obj,*v);
  fflush(stderr);
#endif
  // reject anonymous top-level
  if (sd->name == null) {
    terr(loc, xprintf("anonymous %ss are not allowed at top level", obj));
    return;
  }

  // only allow packed and aligned attributes
  for (_ atts = sd->attributes; atts != null; atts = atts->tl) {
    switch (atts->hd) {
    case Packed_att: continue;
    case &Aligned_att(_): continue;
    default: terr(loc,xprintf("bad attribute %s in %s %s definition",
                              attribute2string(atts->hd), obj, *v));
    break;
    }
  }

  // disallow MemKinds and set unconstrained kinds to BoxKind
  for(_ tvs = sd->tvs; tvs != null; tvs = tvs->tl) {
    let c = compress_conref(tvs->hd->kind);
    switch (c->v) {
    case No_constr:
      c->v = new Eq_constr((kind_t)BoxKind); continue;
    case &Eq_constr(MemKind):
      terr(loc,xprintf("%s %s attempts to abstract type "
                       "variable %s of kind M", obj, *v,
                       *tvs->hd->name)); continue;
    default: continue;
    }
  }

  // reject explicitly qualified name
  switch ((*sd->name->v)[0]) {
  case &Rel_n(null): break;
  case &Abs_n(null): break; // allowed for top-level constants
  default:
    terr(loc,"qualified declarations are not implemented"); // FIX
    return;
  }

  // expand to qualified name
  (*sd->name->v)[0] = new Abs_n(te->ns);

  // reject ill-formed type
  check_unique_tvars(loc, sd->tvs);
}

static void tcStructdecl(tenv_t te, genv_t ge, seg_t loc, structdecl_t sd) {
  let v = (*sd->name->v)[1];
  string obj = "struct";

  tcStructOrUniondecl(te, ge, obj, loc, sd);

  let tvs = sd->tvs;

  // check the fields and update the environment
  // may not be the first declaration, so must not overwrite the dict entry!
  switch ($(sd->fields, Dict::lookup_opt(ge->structdecls, v))) {
  case $(null, null):
    // insert sd in the environment
    ge->structdecls = Dict::insert(ge->structdecls, v, new sd);
    break;
  case $(&Opt(fs), null):
    // for the sake of recursive fields, make name abstract in body
    let sdp = new (new Structdecl(Extern, sd->name, tvs, null, null));
    ge->structdecls = Dict::insert(ge->structdecls, v, sdp);
    
    tcStructFields(te, ge, loc, obj, fs, tvs);

    *sdp = sd; //insert sd in the environment
    break;
  case $(&Opt(fs), &Opt(sdp)):
    let sd0 = *sdp;
    // for the sake of recursive fields, make name abstract in body
    *sdp = new Structdecl(Extern, sd->name, tvs, null, null);
    
    tcStructFields(te, ge, loc, obj, fs, tvs);

    *sdp = sd0; // restore the previous declaration and go update the environment
    fallthru(sdp);
  case $(null, &Opt(sdp)):
    // try to merge the declarations
    let sd2 = Tcdecl::merge_structdecl(*sdp, sd, loc, tc_msg);
    
    if (sd2 == null)
      return; // error in redeclaration
    else {
      *sdp = (structdecl_t) sd2; // make the update

      sd = (structdecl_t) sd2; // update sd so that we add the right constructor below
      break;
    }
  }

  // add the constructor to the environment
  ge->ordinaries = Dict::insert(ge->ordinaries,  v,
				  new $(new StructRes(sd), true));
}

static void tcUniondecl(tenv_t te, genv_t ge, seg_t loc, uniondecl_t ud) {
  let v = (*ud->name->v)[1];
  string obj = "union";

  tcStructOrUniondecl(te, ge, obj, loc, (structdecl_t) ud);

  let tvs = ud->tvs;

  // check the fields and update the environment
  // may not be the first declaration, so must not overwrite the dict entry!
  switch ($(ud->fields, Dict::lookup_opt(ge->uniondecls, v))) {
  case $(null, null):
    // insert ud in the environment
    ge->uniondecls = Dict::insert(ge->uniondecls, v, new ud);
    break;
  case $(&Opt(fs), null):
    // for the sake of recursive fields, make name abstract in body
    let udp = new (new Uniondecl(Extern, ud->name, tvs, null, ud->attributes));
    ge->uniondecls = Dict::insert(ge->uniondecls, v, udp);
    
    tcStructFields(te, ge, loc, obj, fs, tvs);

    *udp = ud; //insert ud in the environment
    break;
  case $(&Opt(fs), &Opt(udp)):
    let ud0 = *udp;
    // for the sake of recursive fields, make name abstract in body
    *udp = new Uniondecl(Extern, ud->name, tvs, null, ud->attributes);
    
    tcStructFields(te, ge, loc, obj, fs, tvs);

    *udp = ud0; // restore the previous declaration and go update the environment
    fallthru(udp);
  case $(null, &Opt(udp)):
    // try to merge the declarations
    let ud2 = Tcdecl::merge_uniondecl(*udp, ud, loc, tc_msg);
    
    if (ud2 == null)
      return; // error in redeclaration
    else {
      *udp = (uniondecl_t) ud2; // make the update
      break;
    }
  }
}

static list_t<tunionfield_t> tcTunionFields(tenv_t te, genv_t ge, seg_t loc,
					    string obj, bool is_xtunion,
					    qvar_t name,
					    list_t<tunionfield_t> fields,
					    list_t<tvar_t> tvs,
					    tuniondecl_t tudres) {
  // check variants, rejecting ill-formed types,
  // repeated tyvars
  for(let fs = fields; fs != null; fs = fs->tl) {
    let f = fs->hd;

    for (_ tvs = f->tvs; tvs != null; tvs = tvs->tl) {
      let tv = tvs->hd;
      let c = compress_conref(tv->kind);
      switch (c->v) {
      case No_constr: c->v = new Eq_constr((kind_t)BoxKind); break;
      case &Eq_constr(MemKind): 
        terr(f->loc,xprintf("field %s abstracts type variable of "
			    "kind M", *(*f->name)[1])); break;
      default: break;
      }
    }

    list_t<tvar_t> alltvs = List::append(tvs,f->tvs);
    check_unique_tvars(loc,alltvs);

    for (_ typs = f->typs; typs != null; typs=typs->tl) {
      check_type(f->loc, te, alltvs, MemKind, (*typs->hd)[1]);
    }

    switch((*f->name)[0]) {
    case &Rel_n(null): 
      if(is_xtunion)
	(*f->name)[0] = new Abs_n(te->ns);
      else
	(*f->name)[0] = (*name)[0];
      break;
    case &Rel_n(_): 
      terr(f->loc, "qualified declarations are not allowed"); //FIX ?
      break;
    case &Abs_n(_): break;
    case Loc_n:
      throw new Impossible("tcTunionFields: Loc_n");
      break;
    }
  }

  _ fields2;  
  if(is_xtunion) {
    // for xtunions sort the fields (trying to merge the duplicates)
    let res = true;
    let fs = Tcdecl::sort_xtunion_fields(fields, &res, (*name)[1], loc, tc_msg);
    if (res)
      fields2 = fs;
    else
      fields2 = null; // should it be fs anyway ?
  } else region uprev_rgn { 
    // for tunions, check there's no duplicate field
    glist_t<var_t, `uprev_rgn> prev_fields = null;
    for (_ fs = fields; fs != null; fs = fs-> tl) {
      let f = fs->hd;
      if (List::mem(String::zstrptrcmp, prev_fields, (*f->name)[1]))
	terr(f->loc,xprintf("duplicate field name %s in %s", *((*f->name)[1]), obj));
      else
	prev_fields = rnew(uprev_rgn) List((*f->name)[1], prev_fields);
      // erase the scope of the field (which has no meaning)
      if (f->sc != Public) {
	warn(loc, xprintf("ignoring scope of field %s", *((*f->name)[1])));
	f->sc = Public;
      }
    }
    fields2 = fields;
  }
  
  // finally add the variants
  // (for xtunion, only the new fields; this is important because tudres
  // may not define the old ones or the tvars may not be the same)
  for(let fs = fields; fs != null; fs = fs->tl) {
    let f = fs->hd;
    ge->ordinaries = Dict::insert(ge->ordinaries, (*f->name)[1],
                                  new $(new TunionRes(tudres,f), true));
  }

  return fields2;
}

static void tcTuniondecl(tenv_t te, genv_t ge, seg_t loc, tuniondecl_t tud) {
  var_t v = (*tud->name)[1];
  string obj;
  if (tud->is_xtunion) {
    obj = "xtunion";
  } else {
    obj = "tunion";
  }
#ifdef DEBUG
  fprintf(stderr,"type-checking %sdecl %s",obj,*v);
  fflush(stderr);
#endif

  list_t<tvar_t> tvs = tud->tvs;
  // disallow MemKinds and set unconstrained kinds to BoxKind
  for(_ tvs2 = tvs; tvs2 != null; tvs2 = tvs2->tl) {
    conref_t<kind_t> c = compress_conref(tvs2->hd->kind);
    switch (c->v) {
    case No_constr: c->v = new Eq_constr((kind_t)BoxKind); break;
    case &Eq_constr(MemKind): 
      terr(loc,xprintf("%s %s attempts to abstract type "
                       "variable %s of kind M",obj,*v,*tvs2->hd->name)); break;
    default: break;
    }
  }
  // reject ill-formed type
  check_unique_tvars(loc,tvs);

  // determine [x]tunion type's qualified name
  // set ge_decl to the namespace where the declaration 'lives'
  // (for xtunions it may be different from ge)
  opt_t<tuniondecl_t@> tud_opt;
  if(tud->is_xtunion) {
    try tud_opt = lookup_xtuniondecl(te,loc,tud->name);
    catch {
    case Dict::Absent:
      terr(loc,
	   xprintf("qualified xtunion declaration %s is not an existing xtunion",
		   qvar2string(tud->name)));
      return;
    }
    if (tud_opt != null) {
      tud->name = (*(tud_opt->v))->name;
    } else {
      (*tud->name)[0] = new Abs_n(te->ns); 
    }
  } else {
    switch ((*tud->name)[0]) {
    case &Rel_n(null): (*tud->name)[0] = new Abs_n(te->ns); break;
    case &Abs_n(_): fallthru;
    default:
      terr(loc,"qualified declarations are not implemented"); // FIX
      return;
    }
    tud_opt = Dict::lookup_opt(ge->tuniondecls, v);
  }

  // check the fields and update the environment
  // may not be the first declaration, so must not overwrite the dict entry!
  switch ($(tud->fields, tud_opt)) {
  case $(null, null):
    // insert tud in the environment
    ge->tuniondecls = Dict::insert(ge->tuniondecls, v, new tud);
    break;
  case $(&Opt(*fs), null):
    // for the sake of recursive fields, make name abstract in body
    let tudp = new (new Tuniondecl(Extern, tud->name, tvs, null, tud->is_xtunion));
    ge->tuniondecls = Dict::insert(ge->tuniondecls, v, tudp);
    
    // check the fields (and sort them if this is a xtunion)
    *fs = tcTunionFields(te, ge, loc, obj, tud->is_xtunion, tud->name, *fs, tvs, tud);

    *tudp = tud; //insert tud in the environment
    break;
  case $(&Opt(*fs), &Opt(tudp)):
    let tud0 = *tudp;
    // for the sake of recursive fields, make name abstract in body
    *tudp = new Tuniondecl(Extern, tud->name, tvs, null, tud->is_xtunion);
    
    // check the fields (and sort them if this is a xtunion)
    *fs = tcTunionFields(te, ge, loc, obj, tud->is_xtunion, tud->name, *fs, tvs, tud);

    *tudp = tud0; // restore the previous declaration and go update the environment
    fallthru(tudp);
  case $(null, &Opt(tudp)):
    // try to merge the declarations
    let tud2 = Tcdecl::merge_tuniondecl(*tudp, tud, loc, tc_msg);
    
    if (tud2 == null)
      return; // error in redeclaration
    else {
      *tudp = (tuniondecl_t) tud2; // make the update
      break;
    }
  } 
}

static void tcEnumdecl(tenv_t te, genv_t ge, seg_t loc, enumdecl_t ed) {
  var_t v = (*ed->name)[1];
#ifdef DEBUG
  fprintf(stderr,"type-checking enumdecl %s",*v);
  fflush(stderr);
#endif
  // reject explicitly qualified name
  switch ((*ed->name)[0]) {
  case &Rel_n(null): break;
  case &Abs_n(null): break; // allowed for top-level constants
  default:
    terr(loc,"qualified declarations are not implemented"); // FIX
    return;
  }
  // expand to qualified name
  (*ed->name)[0] = new Abs_n(te->ns);

  // check the fields.
  if (ed->fields != null) region uprev_rgn {
    glist_t<field_name_t, `uprev_rgn> prev_fields = null;
    unsigned int tag_count = 0;
    for (_ fs = ed->fields->v; fs != null; fs = fs->tl) {
      let f = fs->hd;
      
      if (List::mem(String::zstrptrcmp,prev_fields,(*f->name)[1]))
	terr(f->loc,xprintf("duplicate field name %s",*((*f->name)[1])));
      else
	prev_fields = rnew(uprev_rgn) List((*f->name)[1],prev_fields);
      
      if (f->tag == null)
	f->tag = uint_exp(tag_count, f->loc);
      else if (!Tcutil::is_const_exp(te,(exp_t)f->tag))
	terr(loc,xprintf("enum %s, field %s: expression is not constant",
			 *v,*(*f->name)[1]));
      
      unsigned int t1 = Evexp::eval_const_uint_exp((exp_t)f->tag);
      tag_count = t1+1;
      
      (*f->name)[0] = new Abs_n(te->ns);
    }
  }

  // update the environment
  try {
    let edp = Dict::lookup(ge->enumdecls, v);
    let ed2 = Tcdecl::merge_enumdecl(*edp, ed, loc, tc_msg);
    if (ed2 == null) return;
    *edp = (enumdecl_t) ed2; // if there's no error, make the update
  } catch {
  case Dict::Absent:
    let edp = new ed;
    ge->enumdecls = Dict::insert(ge->enumdecls, v, edp);
    break;
  }

  if (ed->fields != null) {
    for (_ fs = ed->fields->v; fs != null; fs = fs->tl) {
      let f = fs->hd;
      ge->ordinaries = Dict::insert(ge->ordinaries, (*f->name)[1],
				    new $(new EnumRes(ed,f), true));
    }
  }
}

static bool okay_externC(seg_t loc, scope_t sc) {
  switch (sc) {
  case Static:
    warn(loc,"static declaration nested within extern \"C\"");
    return false;
  case Abstract:
    warn(loc,"abstract declaration nested within extern \"C\"");
    return false;
  case Public: return true;
  case Extern:
    // warn(loc,"converting extern declaration to extern \"C\"");
    return true;
  case ExternC:
    warn(loc,"nested extern \"C\" declaration");
    return true;
  }
}

// Typecheck a list, ds, of declarations in environment te.
// As a side effect, all declarations and variable references are made
// absolute, so later passes just recurse through namespace and using
// New: a second pass shakes out unnecessary vardecls.
// FIX: shake out type definitions too.
static void tc_decls(tenv_t te, list_t<decl_t> ds0, bool in_externC, bool check_var_init) {

  genv_t ge = Dict::lookup(te->ae,te->ns); // no longer a copy!!!

  for (let ds = ds0; ds != null; ds = ds->tl) {
    decl_t    d   = ds->hd;
    seg_t loc = d->loc;

    switch (d->r) {
    case &Let_d(_,_,_,_,_): // FIX
      terr(loc,"top level let-declarations are not implemented");
      break;
    case &Letv_d(_): // FIX
      terr(loc,"top level let-declarations are not implemented");
      break;
    case &Var_d(vd):
      if (in_externC && okay_externC(d->loc,vd->sc))
	vd->sc = ExternC;
      tcVardecl(te,ge,loc,vd,check_var_init);
      break;
    case &Fn_d(fd):
      if (in_externC && okay_externC(d->loc,fd->sc))
	fd->sc = ExternC;
      tcFndecl(te,ge,loc,fd);
      break;
    case &Typedef_d(td):
      tcTypedefdecl(te,ge,loc,td);
      break;
    case &Struct_d(sd):
      if (in_externC && okay_externC(d->loc,sd->sc))
	sd->sc = ExternC;
      tcStructdecl(te,ge,loc,sd);
      break;
    case &Union_d(ud):
      if (in_externC && okay_externC(d->loc,ud->sc))
        ud->sc = ExternC;
      tcUniondecl(te,ge,loc,ud);
      break;
    case &Tunion_d(tud):
      if (in_externC && okay_externC(d->loc,tud->sc))
	tud->sc = ExternC;
      tcTuniondecl(te,ge,loc,tud);
      break;

    case &Enum_d(ed):
      if (in_externC && okay_externC(d->loc,ed->sc))
        ed->sc = ExternC;
      tcEnumdecl(te,ge,loc,ed);
      break;

    case &Namespace_d(v,ds2):
      // DAN: This case is much more imperative than it used to be.
      let ns  = te->ns;
      let ns2 = List::append(ns,new List(v,null));
      // Make sure namespace v has been declared in the current namespace
      if (!Set::member(ge->namespaces,v)) {
        ge->namespaces = Set::insert(ge->namespaces,v);
	te->ae = Dict::insert(te->ae, ns2, empty_genv());
      }
      // Do the nested declarations then restore the namespace
      te->ns = ns2;
      tc_decls(te,ds2,in_externC,check_var_init);
      te->ns = ns;
      break;

    case &Using_d(&$(nsl,v),ds2):
      // DAN: We're more imperative here too.
      var_t first;
      list_t<var_t> rest;
      switch (nsl) {
      case Loc_n:       fallthru;
      case &Rel_n(null): fallthru;
      case &Abs_n(null):
        first = v; rest = null; break;
      case &Rel_n(&List(x,y)): fallthru(x,y);
      case &Abs_n(&List(x,y)):
        first = x; rest = List::append(y,new List(v,null)); break;
      }
      let ns2 = resolve_namespace(te,loc,first,rest);
      ge->availables = new List(ns2,ge->availables);
      tc_decls(te,ds2,in_externC,check_var_init);
      ge->availables = ge->availables->tl;
      break;

    case &ExternC_d(ds2):
      tc_decls(te,ds2,true,check_var_init);
      break;
    }
  }
}

static string cyc_string = "Cyc";
static stringptr cyc_ns = &cyc_string;

void tc(tenv_t te, bool add_cyc_namespace, bool check_var_init, list_t<decl_t> ds) {
  if (add_cyc_namespace)
    // wrap an implicit "namespace Cyc" around the declarations
    ds = new List(new Decl{new Namespace_d(cyc_ns,ds),null},null);

  tc_decls(te,ds,false,check_var_init);
}

// for tree-shaking (so we don't include the world)
// Note: We must shake after all type-checking or we'll be too eager.
// Note: All names should now be absolute.

// We recompute the global environment and delete what's not needed anymore
// all would be far easier if Dict has a delete function :-)

// for each namespace, we have the environment and a list of what has to be removed in it
typedef Dict::dict_t<list_t<var_t>, $(genv_t, Set::set_t<var_t>) @> treeshake_env_t;

static bool vardecl_needed(treeshake_env_t env, decl_t d);

static list_t<decl_t> treeshake_f(treeshake_env_t env, list_t<decl_t> ds) {
  return List::filter_c(vardecl_needed, env, ds);
}

static bool vardecl_needed(treeshake_env_t env, decl_t d) {
  switch(d->r) {
  case &Var_d(vd):
    // get rid of externs that are never referenced
    if(vd->sc != Extern)
      return true;
    let &$(nsl,name) = vd->name;
    list_t<var_t> ns;
    switch (nsl) {
    case Loc_n:    ns = null; break;
    case &Rel_n(y): ns = y; break;
    case &Abs_n(y): ns = y; break;
    }
    let nsenv = Dict::lookup(env,ns);
    let ge = (*nsenv)[0];
    let needed = (*Dict::lookup(ge->ordinaries,name))[1];
    if (! needed) {
      (*nsenv)[1] = Set::insert((*nsenv)[1], name); // we'll remove it later from ge->ordinaries
    }
    return needed;
  case &Using_d(_,*ds2p): fallthru(ds2p);
  case &Namespace_d(_,*ds2p):
    *ds2p = treeshake_f(env,*ds2p);
    return true;
  default: return true;
  }
}

// Mathieu : all this would be really nicer if we had local functions...
static bool treeshake_remove_f(Set::set_t<var_t> set, var_t x, _ y) {
  return !Set::member(set, x);
}

static void treeshake_remove(list_t<var_t> ns, 
			     $(genv_t, Set::set_t<var_t>) @ nsenv) {
  let ge = (*nsenv)[0];
  let set = (*nsenv)[1];
  ge->ordinaries = Dict::filter_c(treeshake_remove_f, set, ge->ordinaries);
}
			     			     
static $(genv_t, Set::set_t<var_t>)@ treeshake_make_env_f(genv_t ge) {
  return new $(ge, Set::empty(String::strptrcmp));
}

list_t<decl_t> treeshake(tenv_t te, list_t<decl_t> ds) {
  let env = Dict::map(treeshake_make_env_f, te->ae);
  let ds1 = treeshake_f(env, ds);
  
  Dict::iter(treeshake_remove, env); // update the global environment

  return ds1;
}
