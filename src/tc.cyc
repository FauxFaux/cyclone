/* Type checking for top-level declarations
   Copyright (C) 2001 Greg Morrisett, AT&T
   This file is part of the Cyclone compiler.

   The Cyclone compiler is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   The Cyclone compiler is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with the Cyclone compiler; see the file COPYING. If not,
   write to the Free Software Foundation, Inc., 59 Temple Place -
   Suite 330, Boston, MA 02111-1307, USA. */

#include <core.h>
#include <string.h>
#include <list.h>
#include <position.h>
#include "absyn.h"
#include "absynpp.h"
#include "tcutil.h"
#include "tcenv.h"
#include "tcexp.h"
#include "tcstmt.h"
#include "evexp.h"
#include "tc.h"
#include <stdio.h>
#include "tcdecl.h"
#include "tcgenrep.h"
using Core;
using List;
using Position;
using Absyn;
using Absynpp;
using Tcutil;
using Tcenv;

namespace Tc;

// used for the error messages of tcdecl
static string_t tc_msg_c = "";
static string_t * tc_msg = &tc_msg_c;

static bool export_member(qvar_t x, list_t<$(seg_t,qvar_t,bool)@> exports) {
  for (; exports != NULL; exports = exports->tl) {
    let p = exports->hd;
    if (qvar_cmp(x,(*p)[1]) == 0) {
      // set the flag associated with the export to record that the
      // declaration is present and return true
      (*p)[2] = true;
      return true;
    }
  }
  return false;
}

static void tcVardecl(tenv_t te, genv_t ge, seg_t loc, 
		      vardecl_t vd, bool check_var_init, 
                      bool ignore_init,
                      list_t<$(seg_t,qvar_t,bool)@>* exports) {
  let &Vardecl(sc,&$(ns,v),_,t,initializer,_,atts,_) = vd;
#ifdef DEBUG
  fprintf(stderr,"type-checking vardecl_t %s, type %s\n",*v, 
          typ2string(vd->type)); fflush(stderr);
#endif

  // reject explicitly qualified name FIX: prevents re-type-checking
  switch (ns) {
  case Rel_n(NULL): 
  case Abs_n(NULL): break; // allowed for top-level constants
  default:
    terr(loc,"qualified variable declarations are not implemented (%s)",
	 qvar2string(vd->name)); // FIX
    return;
  }
  // expand to qualified name
  (*vd->name)[0] = Abs_n(te->ns);
  // if it's an array or string, fill in the size on the type
  switch (compress(t)) {
  case &ArrayType(ArrayInfo{telt,tq,NULL,zt,ztl}) && initializer != NULL:
    switch (initializer->r) {
      case &Const_e(String_c(s)):
      t = vd->type = array_typ(telt,tq,uint_exp(numelts(s),NULL),zt,ztl);
      break;
      case &Comprehension_e(_,e,_,_):
      // FIX: need to copy e here!
      t = vd->type = array_typ(telt,tq,e,zt,ztl); 
      break;
      case &UnresolvedMem_e(_,es): fallthru(es);
      case &Array_e(es):
      t = vd->type = array_typ(telt,tq,uint_exp(List::length(es),NULL),zt,ztl);
      break;
      default: break;
    }
    break;
  default: break;
  }
  // reject ill-formed type
  check_valid_toplevel_type(loc,te,t);
  
  vd->tq.real_const = extract_const_from_typedef(loc,vd->tq.print_const,t);
  // top-level arrays don't escape because they can't be assigned to, so
  // their sizes do not change over time. All other globals escape.
  switch (compress(t)) {
  case &ArrayType(_): vd->escapes = false; break;
  default: vd->escapes = true; break;
  }
  // move any function type attributes into the function's type
  if (is_function_type(t))
    atts = transfer_fn_type_atts(t,atts);
  // if extern, make sure it has no initializer
  if (sc == Extern || sc == ExternC) {
    if(initializer != NULL)
      terr(loc,"extern declaration should not have initializer");
  } else if (!is_function_type(t)) {
    // we skip over function types -- these are function prototypes.
    // otherwise, we compute default initializer, if necessary
    // first check that the attributes are okay
    for (; atts != NULL; atts = atts->tl)
      switch (atts->hd) {
      case &Aligned_att(_):
        // GCC doesn't allow variables to be packed
        // case Packed_att:     continue;
      case &Section_att(_):
      case Nocommon_att:   
      case Shared_att:     
      case Unused_att:     
      case Weak_att:       
      case Dllimport_att:  
      case Dllexport_att: continue;
      default:
        terr(loc,"bad attribute %s for variable %s",
             attribute2string(atts->hd), qvar2string(vd->name));
        break;
      }

    if(initializer == NULL || ignore_init) {
      if (check_var_init && !supports_default(t))
        terr(loc,"initializer required for variable %s of type %s",
             qvar2string(vd->name), typ2string(t));
    } else {
      let e = (exp_t)initializer;
      // type-check the initializer
      let t2 = Tcexp::tcExpInitializer(te,&t,e);
      if (!coerce_assign(te,e,t)) {
        terr(loc,"%s declared with type \n%s\n but initialized with type \n%s",
             qvar2string(vd->name), typ2string(t), typ2string(t2));
        explain_failure();
      }
      // reject non-constant initializers
      if (!Tcutil::is_const_exp(te,e))
        terr(loc,"initializer is not a constant expression");
    }
  } else {
    // it is a function type -- check that the attributes are okay
    for (; atts != NULL; atts = atts->tl)
      switch (atts->hd) {
      // these attributes should be in the function's type
      case &Regparm_att(_):
      case Stdcall_att:   
      case Cdecl_att:     
      case Fastcall_att: 
      case Noreturn_att: 
      case &Format_att(_,_,_):
      case &Initializes_att(_):
      case Pure_att:
      case Const_att: impos("tcVardecl: fn type atts in function var decl");
      // C doesn't allow these attributes on functions
      case &Aligned_att(_):
      case Packed_att:
        terr(loc,"bad attribute %s in function declaration",
	     attribute2string(atts->hd));
        break;
      default: continue;
      }
  }

  // update the environment
  try {
    let ans = Dict::lookup(ge->ordinaries, v);
    switch ((*ans)[0]) {
    case &VarRes(b0):
      let b1 = new Global_b(vd);
      let b = Tcdecl::merge_binding(b0, b1, loc, tc_msg);
      if (b == Unresolved_b) return; // error in merging
      if (b == b0 && (*ans)[1]) return; // no need to reinsert the entry
      // otherwise make the update if the variable is exported
      if (exports == NULL || export_member(vd->name,*exports)) 
        ge->ordinaries = Dict::insert(ge->ordinaries, v,
                                      new $(new VarRes(b), true));
      return;
    case &AggrRes(_): 
      warn(loc,"variable declaration shadows previous struct declaration");
      break;
    case &DatatypeRes(_,_): 
      warn(loc,"variable declaration shadows previous datatype constructor");
      break;
    case &AnonEnumRes(_,_): 
    case &EnumRes(_,_): 
      warn(loc,"variable declaration shadows previous enum tag");
      break;
    }
  } catch { case Dict::Absent: break; }
  if (exports == NULL || export_member(vd->name,*exports)) 
    ge->ordinaries = Dict::insert(ge->ordinaries, v,
                                  new $(new VarRes(new Global_b(vd)), false));
}

static bool is_main(qvar_t n) {
  let &$(nms,v) = n;
  switch (nms) {
  case Abs_n(NULL):
    return (strcmp(*v,"main") == 0);
  default: return false;
  }
}

static void tcFndecl(tenv_t te, genv_t ge, seg_t loc, fndecl_t fd,
                     bool ignore_body, 
                     list_t<$(seg_t,qvar_t,bool)@>* exports) {
  var_t   v  = (*fd->name)[1];
#ifdef DEBUG
  fprintf(stderr,"type-checking fndecl %s",*v); fflush(stderr);
#endif
  if(fd->sc == ExternC && !ignore_body)
    terr(loc,"extern \"C\" functions cannot be implemented in Cyclone");

  // reject explicitly qualified name
  switch ((*fd->name)[0]) {
  case Rel_n(NULL): break;
  case Abs_n(y): impos("tc: Abs_n in tcFndecl");
  default: terr(loc,"qualified function declarations are not implemented (%s)",
		qvar2string(fd->name)); // FIX
    return;
  }
  // expand to qualified name
  (*fd->name)[0] = Abs_n(te->ns);
  // reject ill-formed type
  check_fndecl_valid_type(loc,te,fd);
  // check for redeclaration
  type_t t = fndecl2typ(fd);

  // move any function type attributes into the function's type
  fd->attributes = transfer_fn_type_atts(t,fd->attributes);
  // check that packed and aligned don't show up in the attributes
  for (_ atts = fd->attributes; atts != NULL; atts = atts->tl)
    switch (atts->hd) {
    case Packed_att:
    case &Aligned_att(_): 
      terr(loc,"bad attribute %s for function",attribute2string(atts->hd));
      break;
    default: break;
    }

  // due to recursion, add function to environment before checking body
  try {
    let ans = Dict::lookup(ge->ordinaries, v);
    switch ((*ans)[0]) {
    case &VarRes(b0):
      let b1 = new Funname_b(fd);
      let b = Tcdecl::merge_binding(b0, b1, loc, tc_msg);
      if (b == Unresolved_b) break; // error in merging
      if (b == b0 && (*ans)[1]) break; // no need to reinsert the entry
      // otherwise make the update if the function is exported
      if (exports == NULL || export_member(fd->name,*exports))
        ge->ordinaries = Dict::insert(ge->ordinaries, v,
                                      new $(new VarRes(b), true));
      break;
    case &AggrRes(_):
      warn(loc,"function declaration shadows previous type declaration");
      break;
    case &DatatypeRes(_,_): 
      warn(loc,"function declaration shadows previous datatype constructor");
      break;
    case &AnonEnumRes(_,_):
    case &EnumRes(_,_): 
      warn(loc,"function declaration shadows previous enum tag");
      break;
    }
  } catch { case Dict::Absent:
    if (exports == NULL || export_member(fd->name,*exports))
      ge->ordinaries = Dict::insert(ge->ordinaries, v,
                                    new $(new VarRes(new Funname_b(fd)), false));
    break;
  }

  // ignore C bodies 
  if (ignore_body) return;

  // DAN: Here is where I'm assuming the te can be imperatively screwed with
  //      while we're dealing with top-level stuff (though it's not too hard
  //      to undo that assumption)
  region fnrgn; {
    let fenv = new_fenv(fnrgn,loc,fd);
    let te = rnew(fnrgn) Tenv{te->ns, te->ae, fenv, false};
    // check the body, then get rid of local environment
    Tcstmt::tcStmt(te,fd->body,false);
    // we've delayed checking some capabilities and constraints so that inference
    // works a bit better, and now it's time to check them:
    check_delayed_effects(te);
    check_delayed_constraints(te);

    // check for undefined labels FIX: get better error message
    if(!all_labels_resolved(te))
      terr(loc,"function has goto statements to undefined labels");
  }
  // look for main and check that it has a good type
  if (is_main(fd->name)) {
    // result type should be int
    switch (compress(fd->ret_type)) {
    case VoidType: warn(loc,"main declared with return type void"); break;
    case &IntType(_,B4): break;
    default: 
      terr(loc,"main declared with return type %s instead of int or void",
	   typ2string(fd->ret_type)); 
      break;
    }
    if (fd->c_varargs || fd->cyc_varargs != NULL)
      terr(loc,"main declared with varargs");
    let args = fd->args;
    if (args != NULL) {
      let &$(_,_,t1) = args->hd;
      switch (compress(t1)) {
      case &IntType(_,B4): break;
      default:
        terr(loc,"main declared with first argument of type %s instead of int",
             typ2string(t1));
        break;
      }
      args = args->tl;
      if (args != NULL) {
        let &$(_,_,t2) = args->hd;
        args = args->tl;
        if (args != NULL)
          terr(loc,"main declared with too many arguments");
        opt_t<list_t<tvar_t>> tvs = new Opt(fd->tvs);
        if (!unify(t2,dyneither_typ(string_typ(new_evar(new Opt(RgnKind),tvs)),
                                     new_evar(new Opt(RgnKind),tvs),
                                     empty_tqual(NULL),empty_conref())) &&
            !unify(t2,dyneither_typ(const_string_typ(new_evar(new Opt(RgnKind),
                                                               tvs)),
                                     new_evar(new Opt(RgnKind),tvs),
                                     empty_tqual(NULL),empty_conref())) &&
            !unify(t2,dyneither_typ(string_typ(new_evar(new Opt(RgnKind),tvs)),
                                     new_evar(new Opt(RgnKind),tvs),
                                     const_tqual(NULL),empty_conref())) &&
            !unify(t2,dyneither_typ(const_string_typ(new_evar(new Opt(RgnKind),
                                                               tvs)),
                                     new_evar(new Opt(RgnKind),tvs),
                                     const_tqual(NULL),empty_conref()))) {
          terr(loc,"second argument of main has type %s instead of char??",
               typ2string(t2));
        }
      }
    }
  }
}

static void tcTypedefdecl(tenv_t te, genv_t ge, seg_t loc, typedefdecl_t td) {
  var_t v = (*td->name)[1];
#ifdef DEBUG
  fprintf(stderr,"type-checking typedefdecl %s",*v);
  fflush(stderr);
#endif
  // reject explicitly qualified name
  switch ((*td->name)[0]) {
  case Rel_n(NULL): 
  case Abs_n(NULL): break; // allowed for top-level constants
  default:
    terr(loc,"qualified typedef declarations are not implemented (%s)",qvar2string(td->name)); // FIX
    return;
  }
  // check for redeclaration (never allowed, apparently)
  if (Dict::member(ge->typedefs,v)) {
    terr(loc,"redeclaration of typedef %s",*v);
    return;
  }
  // expand to qualified name
  (*td->name)[0] = Abs_n(te->ns);
  // reject ill-formed type
  check_unique_tvars(loc,td->tvs);
  add_tvar_identities(td->tvs);
  if (td->defn != NULL) {
    check_type(loc,te,td->tvs,AnyKind,false,td->defn->v);
    td->tq.real_const = 
      extract_const_from_typedef(loc,td->tq.print_const,td->defn->v);
    // FIX: check that attributes are okay for this kind of type
  } 
  // run through and constrain the kinds of unconstrained tvs to boxkind
  for (_ tvs = td->tvs; tvs != NULL; tvs = tvs->tl)
    switch (compress_kb(tvs->hd->kind)) {
    case &Unknown_kb(*f): 
      if (td->defn != NULL)
        warn(loc,"type variable %s is not used in typedef definition",
             *tvs->hd->name);
      *f = new Opt(kind_to_bound(BoxKind)); break;
    case &Less_kb(*f,k):
      *f = new Opt(kind_to_bound(k)); break;
    default: continue;
    }
  
  // add to environment
  ge->typedefs = Dict::insert(ge->typedefs,v,td);
}

static void tcAggrImpl(tenv_t te, genv_t ge, seg_t loc, list_t<tvar_t,`H> tvs,
		       list_t<$(type_t,type_t)@> rpo, 
		       list_t<aggrfield_t> fields) {
  // check fields, rejecting ill-formed types, bad fields, and duplicates
  // (unless the field name is empty)
  region uprev_rgn; {
    // FIX?: forbid effect variables (but they're going away)
    for(; rpo != NULL; rpo = rpo->tl) {
      let &$(e,r) = rpo->hd;
      check_type(loc,te,tvs,EffKind,false,e);
      check_type(loc,te,tvs,TopRgnKind,false,r); 
   }

    list_t<field_name_t, `uprev_rgn> prev_fields = NULL;

    for (let fs = fields; fs != NULL; fs = fs->tl) {
      let &Aggrfield(fn,tq,t,width,atts) = fs->hd;
      
      if (List::mem(strptrcmp,prev_fields,fn))
	terr(loc, "duplicate field %s", *fn);
      // add the field to previous fields only if it's not an empty name
      // (empty names arise for bitfield padding.)
      if (strcmp(*fn,"") != 0)
	prev_fields = rnew(uprev_rgn) List(fn,prev_fields);

      check_type(loc,te,tvs,MemKind,false,t);

      fs->hd->tq.real_const = extract_const_from_typedef(loc,fs->hd->tq.print_const,t);

      // if width is non-NULL then t must be of integral type
      check_bitfield(loc, te, t, width, fn);
      // FIX : check for consistent tquals
    }
  }
}

void tcAggrdecl(tenv_t te, genv_t ge, seg_t loc, aggrdecl_t ad) {
  let v = (*ad->name)[1];
#ifdef DEBUG
  fprintf(stderr,"type-checking type decl %s\n",*v);
  fflush(stderr);
#endif
  // allow only packed and aligned attributes
  for (_ atts = ad->attributes; atts != NULL; atts = atts->tl)
    switch (atts->hd) {
    case Packed_att: 
    case &Aligned_att(_): continue;
    default: 
      terr(loc,"bad attribute %s in  %s definition",
	   attribute2string(atts->hd), *v);
      break;
    }
  
  // disallow MemKinds and set unconstrained kinds to BoxKind
  let tvs = ad->tvs;
  for(_ tvs2 = tvs; tvs2 != NULL; tvs2 = tvs2->tl)
    switch (compress_kb(tvs2->hd->kind)) {
    case &Unknown_kb(*f):      fallthru(f);
    case &Less_kb(*f,MemKind): fallthru(f);
    case &Less_kb(*f,AnyKind):
      *f = new Opt(kind_to_bound(BoxKind)); continue;
    case &Eq_kb(MemKind):
      terr(loc,"type %s attempts to abstract type variable %s of kind M", 
           *v, *tvs2->hd->name); continue;
    default: continue;
    }

  // reject explicitly qualified name
  switch ((*ad->name)[0]) {
  case Rel_n(NULL): 
  case Abs_n(NULL): break; // allowed for top-level constants
  default: 
    terr(loc,"qualified struct declarations are not implemented (%s)",
	 qvar2string(ad->name)); // FIX
    return;
  }
  // expand to qualified name
  (*ad->name)[0] = Abs_n(te->ns);

  // reject ill-formed type
  check_unique_tvars(loc, ad->tvs);
  // give the bound type variables identities
  add_tvar_identities(ad->tvs);

  // check the fields and update the environment
  // may not be the first declaration, so must not overwrite the dict entry!
  switch ($(ad->impl, Dict::lookup_opt(ge->aggrdecls, v))) {
  case $(NULL, NULL):
    // insert ad in the environment
    ge->aggrdecls = Dict::insert(ge->aggrdecls, v, new ad);
    break;
  case $(&AggrdeclImpl(exist_vars,rgn_po,fs,tagged), NULL):
    // FIX: check rgn_po for well-formed!
    // for the sake of recursive fields, make name abstract in body
    let adp = new (new Aggrdecl(ad->kind, Extern, ad->name, tvs,
				NULL, ad->attributes));
    ge->aggrdecls = Dict::insert(ge->aggrdecls, v, adp);

    // reject ill-formed type
    check_unique_tvars(loc, exist_vars);
    // give the bound type variables identities
    add_tvar_identities(exist_vars);
    // disallow MemKinds and set unconstrained kinds to BoxKind
    for (_ tvs2 = exist_vars; tvs2 != NULL; tvs2 = tvs2->tl) {
      switch (compress_kb(tvs2->hd->kind)) {
      case &Unknown_kb(*f):      fallthru(f);
      case &Less_kb(*f,MemKind): fallthru(f);
      case &Less_kb(*f,AnyKind):
        *f = new Opt(kind_to_bound(BoxKind)); continue;
      case &Eq_kb(MemKind):
        terr(loc,"type %s attempts to abstract type variable %s of kind M", 
             *v, *tvs2->hd->name); continue;
      default: continue;
      }
    }
    // reject struct with @tagged qualifier
    if (tagged && (ad->kind == StructA))
      terr(loc,"@tagged qualifier is only allowed on union declarations");
    tcAggrImpl(te, ge, loc, append(tvs,exist_vars), rgn_po, fs);

    if(ad->kind == UnionA && !tagged)
      // warn when fields of unions are not bits-only -- these can
      // only be written and not read.
      for (_ f = fs; f != NULL; f = f->tl)
	if (!bits_only(f->hd->type))
	  warn(loc,"member %s of union %s has type %s which is not `bits-only' so it can only be written and not read",
	       *f->hd->name,*v, typ2string(f->hd->type));

    *adp = ad; //insert ad in the environment
    break;
  case $(&AggrdeclImpl(exist_vars,rgn_po,fs,tagged), &adp):
    // FIX: check rgn_po!!! (just need to be closed (and no > `a ??))
    if(ad->kind != (*adp)->kind)
      terr(loc,"cannot reuse struct names for unions and vice-versa");
    let ad0 = *adp;
    // for the sake of recursive fields, make name abstract in body
    *adp = new Aggrdecl(ad->kind, Extern, ad->name, tvs, 
			NULL, ad->attributes);

    // reject ill-formed type
    check_unique_tvars(loc, exist_vars);
    // give the bound type variables identities
    add_tvar_identities(exist_vars);
    // reject struct with @tagged qualifier
    if (tagged && (ad->kind == StructA))
      terr(loc,"@tagged qualifier is only allowed on union declarations");
    tcAggrImpl(te, ge, loc, append(tvs,exist_vars), rgn_po, fs);
    
    *adp = ad0;// restore the previous declaration and go update the environment
    fallthru(adp);
  case $(NULL, &adp):
    // try to merge the declarations
    let ad2 = Tcdecl::merge_aggrdecl(*adp, ad, loc, tc_msg);
    
    if (ad2 == NULL)
      return; // error in redeclaration
    else {
      *adp = (aggrdecl_t)ad2; // make the update
      ad = (aggrdecl_t)ad2; // update ad so we add the right constructor below
      break;
    }
  }
  // add the constructor to the environment
  ge->ordinaries = Dict::insert(ge->ordinaries,  v,
				  new $(new AggrRes(ad), true));
}

static list_t<datatypefield_t> tcDatatypeFields(tenv_t te, genv_t ge, 
                                            seg_t loc,
					    string_t obj, 
                                            bool is_extensible,
					    qvar_t name,
					    list_t<datatypefield_t,`H> fields,
					    list_t<tvar_t,`H> tvs,
					    datatypedecl_t tudres) {
  // check variants, rejecting ill-formed types and repeated tyvars
  for(let fs = fields; fs != NULL; fs = fs->tl) {
    let f = fs->hd;

    for (_ typs = f->typs; typs != NULL; typs=typs->tl) {
      check_type(f->loc, te, tvs, MemKind, false, (*typs->hd)[1]);
      // make sure no no-alias fields in non-flat datatype
      TEMP_RGN(te, temp) {
        if (!tudres->is_flat && is_noalias_pointer_or_aggr(temp,(*typs->hd)[1]))
          terr(f->loc, 
               "noalias pointers in non-flat datatypes are not allowed (%s)",
               qvar2string(f->name)); //FIX ?      
      }
      (*typs->hd)[0].real_const = 
        extract_const_from_typedef(f->loc,(*typs->hd)[0].print_const,
                                   (*typs->hd)[1]);
    }

    switch((*f->name)[0]) {
    case Rel_n(NULL): 
      if(is_extensible)
	(*f->name)[0] = Abs_n(te->ns);
      else
	(*f->name)[0] = (*name)[0];
      break;
    case Rel_n(_): 
      terr(f->loc, "qualified datatypefield declarations are not allowed (%s)",
	   qvar2string(f->name)); //FIX ?
      break;
    case Abs_n(_): break;
    case Loc_n: impos("tcDatatypeFields: Loc_n");
    }
  }

  list_t<datatypefield_t,`H> fields2;  
  if(is_extensible) {
    // for xdatatypes sort the fields (trying to merge the duplicates)
    let res = true;
    let fs = Tcdecl::sort_xdatatype_fields(fields, &res, (*name)[1], loc, tc_msg);
    if (res)
      fields2 = fs;
    else
      fields2 = NULL; // should it be fs anyway ?
  } else {
    region uprev_rgn; 
    // for datatypes, check there's no duplicate field
    list_t<var_t, `uprev_rgn> prev_fields = NULL;
    for (_ fs = fields; fs != NULL; fs = fs-> tl) {
      let f = fs->hd;
      if (List::mem(strptrcmp, prev_fields, (*f->name)[1]))
	terr(f->loc,"duplicate field name %s in %s", *((*f->name)[1]), obj);
      else
	prev_fields = rnew(uprev_rgn) List((*f->name)[1], prev_fields);
      // erase the scope of the field (which has no meaning)
      if (f->sc != Public) {
	warn(loc, "ignoring scope of field %s", *((*f->name)[1]));
	f->sc = Public;
      }
    }
    fields2 = fields;
  }
  
  // finally add the variants
  // (for xdatatype, only the new fields; this is important because tudres
  // may not define the old ones or the tvars may not be the same)
  for(let fs = fields; fs != NULL; fs = fs->tl) {
    let f = fs->hd;
    ge->ordinaries = Dict::insert(ge->ordinaries, (*f->name)[1],
                                  new $(new DatatypeRes(tudres,f), true));
  }

  return fields2;
}

void tcDatatypedecl(tenv_t te, genv_t ge, seg_t loc, datatypedecl_t tud) {
  var_t v = (*tud->name)[1];
  string_t obj = tud->is_extensible ? "@extensible datatype" : "datatype";
#ifdef DEBUG
  fprintf(stderr,"type-checking %sdecl %s\n",obj,*v);
  fflush(stderr);
#endif
  list_t<tvar_t> tvs = tud->tvs;
  // disallow MemKinds and set unconstrained kinds to BoxKind
  for(_ tvs2 = tvs; tvs2 != NULL; tvs2 = tvs2->tl) {
    switch (compress_kb(tvs2->hd->kind)) {
    case &Unknown_kb(*f): fallthru(f);
    case &Less_kb(*f,MemKind): fallthru(f);
    case &Less_kb(*f,AnyKind): 
      *f = new Opt(kind_to_bound(BoxKind)); break;
    case &Less_kb(*f,TopRgnKind):
      *f = new Opt(kind_to_bound(RgnKind)); break;
    case &Eq_kb(TopRgnKind):
      if (!tud->is_flat)
	terr(loc,"%s %s attempts to abstract type "
	     "variable %s of kind TR",obj,*v,*tvs2->hd->name); break;
    case &Less_kb(*f,UniquepRgnKind): fallthru;
    case &Eq_kb(UniqueRgnKind):
      if (!tud->is_flat)
	terr(loc,"%s %s attempts to abstract type "
	     "variable %s of kind UR",obj,*v,*tvs2->hd->name); break;
    case &Eq_kb(MemKind):
      terr(loc,"%s %s attempts to abstract type "
           "variable %s of kind M",obj,*v,*tvs2->hd->name); break;
    default: break;
    }
  }
  // reject ill-formed type
  check_unique_tvars(loc,tvs);
  // give the bound type variables identities
  add_tvar_identities(tvs);

  // determine datatype type's qualified name
  // set ge_decl to the namespace where the declaration 'lives'
  // (for @extensible datatype it may be different from ge)
  region temp; {
    datatypedecl_t@*`temp tud_opt;
    // JGM: we first look up the datatype as if it's @extensible.  If we
    // don't find an extensible definition for it, and this definition 
    // does not say it's extensible, then we treat it as a normal datatype.
    // This has a good and bad effect:  the good effect is that you can
    // naturally extend an existing extensible datatype (e.g., exn) without
    // having to write @extensible all the time.  The bad news is that
    // you can't shadow an extensible datatype that is reachable in the
    // current namespace.  But oh well...
    try {
      tud_opt = lookup_xdatatypedecl(temp,te,loc,tud->name);
      if (tud_opt == NULL && !tud->is_extensible) throw Dict::Absent;
      if (tud_opt != NULL) {
        tud->name = (*(*tud_opt))->name;
      } else {
        (*tud->name)[0] = Abs_n(te->ns); 
      }
    } catch {
    case Dict::Absent:
      switch ((*tud->name)[0]) {
      case Rel_n(NULL): (*tud->name)[0] = Abs_n(te->ns); break;
      case Abs_n(_): fallthru;
      default:
        terr(loc,"qualified (non-extensible) datatype declarations are not implemented (%s)",
             qvar2string(tud->name)); // FIX
        return;
      }
      let tdopt = Dict::lookup_opt(ge->datatypedecls, v);
      tud_opt = tdopt ? rnew(temp)(*tdopt) : NULL;
      break;
    }
    
    // check the fields and update the environment
    // may not be the first declaration, so must not overwrite the dict entry!
    switch ($(tud->fields, tud_opt)) {
    case $(NULL, NULL):
      // insert tud in the environment
      ge->datatypedecls = Dict::insert(ge->datatypedecls, v, new tud);
      break;
    case $(&Opt(*fs), NULL):
      // for the sake of recursive fields, make name abstract in body
      let tudp = new (new Datatypedecl(Extern,tud->name,tvs,NULL,
                                       tud->is_extensible,tud->is_flat));
      ge->datatypedecls = Dict::insert(ge->datatypedecls, v, tudp);
   
      // check the fields (and sort them if this is a @extensible datatype)
      *fs = tcDatatypeFields(te,ge,loc,obj,tud->is_extensible,tud->name,*fs,tvs,tud);

      *tudp = tud; //insert tud in the environment
      break;
    case $(&Opt(*fs), &tudp):
      let tud0 = *tudp;
      // a previous declaration said this was extensible -- so change the
      // current declaration to pretend like it's extensible.
      if (!tud->is_extensible && tud0 && tud0->is_extensible)
        tud->is_extensible = true;
      // for the sake of recursive fields, make name abstract in body
      *tudp = new Datatypedecl(Extern, tud->name, tvs, NULL, 
                               tud->is_extensible, tud->is_flat);
      
      // check the fields (and sort them if this is a @extensible datatype)
      *fs = tcDatatypeFields(te,ge,loc,obj,tud->is_extensible,
                             tud->name,*fs,tvs,tud);

      *tudp = tud0; // restore previous declaration and go update the environment
      fallthru(tudp);
    case $(NULL, &tudp):
      // try to merge the declarations
      let tud2 = Tcdecl::merge_datatypedecl(*tudp, tud, loc, tc_msg);
      if (tud2 == NULL)
        return; // error in redeclaration
      else {
        *tudp = (datatypedecl_t) tud2; // make the update
        break;
      }
    } 
  }
}

void tcEnumdecl(tenv_t te, genv_t ge, seg_t loc, enumdecl_t ed) {
  var_t v = (*ed->name)[1];
#ifdef DEBUG
  fprintf(stderr,"type-checking enumdecl %s",*v);
  fflush(stderr);
#endif
  // reject explicitly qualified name
  switch ((*ed->name)[0]) {
  case Rel_n(NULL): 
  case Abs_n(NULL): break; // allowed for top-level constants
  default:
    terr(loc,"qualified enum declarations are not implemented (%s)",
	 qvar2string(ed->name)); // FIX
    return;
  }
  // expand to qualified name
  (*ed->name)[0] = Abs_n(te->ns);

  // check the fields.
  if (ed->fields != NULL) { region uprev_rgn; {
    list_t<field_name_t, `uprev_rgn> prev_fields = NULL;
    unsigned int tag_count = 0;
    for (_ fs = ed->fields->v; fs != NULL; fs = fs->tl) {
      let f = fs->hd;
      
      if (List::mem(strptrcmp,prev_fields,(*f->name)[1]))
	terr(f->loc,"duplicate field name %s",*((*f->name)[1]));
      else
	prev_fields = rnew(uprev_rgn) List((*f->name)[1],prev_fields);
      
      if (f->tag == NULL)
	f->tag = uint_exp(tag_count, f->loc);
      else if (!Tcutil::is_const_exp(te,(exp_t)f->tag))
	terr(loc,"enum %s, field %s: expression is not constant",
             *v,*(*f->name)[1]);
      
      // FIX? I'm just being lazy here, but who wants a sizeof in their tag?
      let $(t1,known) = Evexp::eval_const_uint_exp((exp_t)f->tag);
      if(!known)
	terr(loc,"Cyclone enum tags cannot use sizeof or offsetof");
      tag_count = t1+1;
      
      (*f->name)[0] = Abs_n(te->ns);
    }
  }}

  // update the environment
  try {
    let edp = Dict::lookup(ge->enumdecls, v);
    let ed2 = Tcdecl::merge_enumdecl(*edp, ed, loc, tc_msg);
    if (ed2 == NULL) return;
    *edp = (enumdecl_t) ed2; // if there's no error, make the update
  } catch { case Dict::Absent:
    let edp = new ed;
    ge->enumdecls = Dict::insert(ge->enumdecls, v, edp);
    break;
  }

  if (ed->fields != NULL)
    for (_ fs = ed->fields->v; fs != NULL; fs = fs->tl) {
      let f = fs->hd;
      ge->ordinaries = Dict::insert(ge->ordinaries, (*f->name)[1],
				    new $(new EnumRes(ed,f), true));
    }
}

static bool okay_externC(seg_t loc, scope_t sc) {
  switch (sc) {
  case Static:
    warn(loc,"static declaration nested within extern \"C\"");
    return false;
  case Abstract:
    warn(loc,"abstract declaration nested within extern \"C\"");
    return false;
  case Public:
  case Register: 
  case Extern: return true;
  case ExternC:
    warn(loc,"nested extern \"C\" declaration");
    return true;
  }
}

static void resolve_export_namespace(tenv_t te, $(seg_t,qvar_t,bool)@ exp) {
  let $(loc,q,_) = *exp;
  let &$(ns,v) = q;
  switch (ns) {
  case Rel_n(NULL):
  case Abs_n(NULL): break;
  default:
    terr(loc,"qualified export variables are not implemented (%s)",
         qvar2string(q));
    return;
  }
  // expand to qualified name
  (*q)[0] = Abs_n(te->ns);
}

// Typecheck a list, ds, of declarations in environment te.
// As a side effect, all declarations and variable references are made
// absolute, so later passes just recurse through namespace and using
// New: a second pass shakes out unnecessary vardecls.
// FIX: shake out type definitions too.
static void tc_decls(tenv_t<`g> te, list_t<decl_t,`H> ds0, 
		     bool in_externC, 
                     bool in_externCinclude,
                     bool check_var_init,
                     region_t<`g> grgn,
                     list_t<$(seg_t,qvar_t,bool)@`H,`H>* exports) {

  genv_t ge = Dict::lookup(te->ae,te->ns); // no longer a copy!!!
  list_t<decl_t,`H> last = NULL;
  
  // FIX: Add dict to some environment so that typerep declarations get reused
  Tcgenrep::typerep_dict_t dict = Tcgenrep::empty_typerep_dict();
  
  for (let ds = ds0; ds != NULL; last = ds, ds = ds->tl) {
    decl_t d   = ds->hd;
    seg_t  loc = d->loc;

    switch (d->r) {
    case &Let_d(_,_,_): 
    case &Letv_d(_): // FIX
      terr(loc,"top level let-declarations are not implemented");
      break;
    case &Region_d(...):
      terr(loc,"top level region declarations are not implemented");
      break;
    case &Alias_d(...):
      terr(loc,"top level alias declarations are not implemented");
      break;
    case &Var_d(vd):
      if (in_externC && okay_externC(d->loc,vd->sc))
	vd->sc = ExternC;
      if (vd->initializer != NULL) {
	switch (vd->initializer->r) {
	case &Gentyp_e(_,t):
	  /* FIX: should pass in a dictionary and use that throughout
	     typechecking to share generated declarations */
	  let $(dict2,ds2,e) = Tcgenrep::tcGenrep(te,ge,loc,t,dict);
	  dict = dict2;
	  /* typecheck the generated declarations */
	  tc_decls(te,ds2,in_externC,in_externCinclude,check_var_init,grgn,exports);
	  /* replace the gentype expression with the generated one */
	  vd->initializer = e;
	  //printf("%s\n",decllist2string(List::list(d)));
	  /* then typecheck the vardecl */
	  tcVardecl(te,ge,loc,vd,check_var_init,in_externCinclude,exports);
	  /* splice in the new declarations */
	  /* this is tricky! */
	  //	  printf("==============BEFORE=================\n%s\n====================BEFORE=====================\n",decllist2string(ds0));
	  if(ds2 != NULL) {
	    if (last != NULL) {
	      imp_append(ds2,ds);
	      last->tl = ds2;
	    }
	    else {
	      struct List<decl_t,`H> tmp = List{.hd = ds->hd, .tl = ds->tl};
	      ds->hd = ds2->hd;
	      ds->tl = ds2->tl;
	      ds2->hd = tmp.hd;
	      ds2->tl = tmp.tl;
	      imp_append(ds,ds2);
	    }
	  }
	  /* continue the loop */
	  //printf("==============AFTER=================\n%s\n====================AFTER=====================\n",decllist2string(ds0));
	  continue;
	default: break;
	}
      }
      // catches the non gen() cases
      tcVardecl(te,ge,loc,vd,check_var_init,in_externCinclude,exports);
      break;
    case &Fn_d(fd):
      if (in_externC && okay_externC(d->loc,fd->sc))
	fd->sc = ExternC;
      tcFndecl(te,ge,loc,fd,in_externCinclude,exports);
      break;
    case &Typedef_d(td):
      tcTypedefdecl(te,ge,loc,td);
      break;
    case &Aggr_d(ad):
      if (in_externC && okay_externC(d->loc,ad->sc))
	ad->sc = ExternC;
      tcAggrdecl(te,ge,loc,ad);
      break;
    case &Datatype_d(tud):
      if (in_externC && okay_externC(d->loc,tud->sc))
	tud->sc = ExternC;
      tcDatatypedecl(te,ge,loc,tud);
      break;
    case &Enum_d(ed):
      if (in_externC && okay_externC(d->loc,ed->sc))
        ed->sc = ExternC;
      tcEnumdecl(te,ge,loc,ed);
      break;
    case Porton_d:
      warn(d->loc,"spurious __cyclone_port_on__");
      break;
    case Portoff_d:
      break;
    case &Namespace_d(v,ds2):
      // DAN: This case is much more imperative than it used to be.
      let ns  = te->ns;
      let ns2 = List::append(ns,new List(v,NULL));

      // Make sure namespace v has been declared in the current namespace
      if (!Set::member(ge->namespaces,v)) {
        ge->namespaces = Set::rinsert(grgn,ge->namespaces,v);
        te->ae = Dict::insert(te->ae, ns2, empty_genv(grgn));
      } 
      // Do the nested declarations then restore the namespace
      te->ns = ns2;
      tc_decls(te,ds2,in_externC,in_externCinclude,check_var_init,grgn,exports);
      te->ns = ns;
      break;

    case &Using_d(&$(nsl,v),ds2):
      // DAN: We're more imperative here too.
      var_t first;
      list_t<var_t> rest;
      switch (nsl) {
      case Loc_n:       
      case Rel_n(NULL):
      case Abs_n(NULL):
        first = v; rest = NULL; break;
      case Rel_n(&List(x,y)): fallthru(x,y);
      case Abs_n(&List(x,y)):
        first = x; rest = List::append(y,new List(v,NULL)); break;
      }
      let ns2 = resolve_namespace(te,loc,first,rest);
      ge->availables = new List(ns2,ge->availables);
      tc_decls(te,ds2,in_externC,in_externCinclude,check_var_init,grgn,exports);
      ge->availables = ge->availables->tl;
      break;

    case &ExternC_d(ds2):
      tc_decls(te,ds2,true,in_externCinclude,check_var_init,grgn,exports);
      break;

    case &ExternCinclude_d(ds2,exports2):
      List::iter_c(resolve_export_namespace,te,exports2);
      list_t<$(seg_t,qvar_t,bool)@> newexs = 
        List::append(exports2,exports ? *exports : NULL);
      tc_decls(te,ds2,true,true,check_var_init,grgn,&newexs);
      // check that all of the exports were actually present
      for (; exports2 != NULL; exports2 = exports2->tl) {
        let exp = exports2->hd;
        if (!(*exp)[2])
          warn((*exp)[0],"%s is exported but not defined",
               qvar2string((*exp)[1]));
      }
      break;
    }
  }
}

void tc(region_t<`g> g, tenv_t<`g> te, bool check_var_init, 
        list_t<decl_t,`H> ds) {
  set_params(&tc_params_r);
  tc_decls(te,ds,false,false,check_var_init,g,NULL);
}

// for tree-shaking (so we don't include the world)
// Note: We must shake after all type-checking or we'll be too eager.
// Note: All names should now be absolute.

// We recompute the global environment and delete what's not needed anymore
// all would be far easier if Dict has a delete function :-)

// for each namespace, we have the environment and a list of what to remove
static struct TreeshakeEnv<`r::R,`g::R> {
  region_t<`r> rgn;
  bool         in_cinclude;
  Dict::dict_t<list_t<var_t>, $(genv_t<`g>, Set::set_t<var_t,`r>) @`r, `r> nsdict;
};  
typedef struct TreeshakeEnv<`r,`g> @`r2 treeshake_env_t<`r,`r2,`g>;

static bool vardecl_needed(treeshake_env_t env, decl_t d);

static list_t<decl_t> treeshake_f(treeshake_env_t env, list_t<decl_t> ds) {
  return List::filter_c(vardecl_needed, env, ds);
}

static bool vardecl_needed(treeshake_env_t env, decl_t d) {
  switch(d->r) {
  case &Var_d(vd):
    // get rid of externs that are never referenced
    if(env->in_cinclude || (vd->sc != Extern && vd->sc != ExternC))
      return true;
    let &$(nsl,name) = vd->name;
    list_t<var_t> ns;
    switch (nsl) {
    case Loc_n:     ns = NULL; break;
    case Rel_n(y): ns = y;    break;
    case Abs_n(y): ns = y;    break;
    }
    let nsenv = Dict::lookup(env->nsdict,ns);
    let ge = (*nsenv)[0];
    let needed = (*Dict::lookup(ge->ordinaries,name))[1];
    if (! needed) // we'll remove it later from ge->ordinaries
      (*nsenv)[1] = Set::rinsert(env->rgn, (*nsenv)[1], name); 
    return needed;
  case &ExternC_d(*ds2p): fallthru(ds2p);
  case &Using_d(_,*ds2p): fallthru(ds2p);
  case &Namespace_d(_,*ds2p):
    *ds2p = treeshake_f(env,*ds2p);
    return true;
  case &ExternCinclude_d(*ds2p,_): 
    bool in_cinclude = env->in_cinclude;
    env->in_cinclude = true;
    *ds2p = treeshake_f(env,*ds2p);
    env->in_cinclude = in_cinclude;
    return true;
  default: return true;
  }
}

static bool treeshake_remove_f(Set::set_t<var_t> set, var_t x, `a y) {
  return !Set::member(set, x);
}

static $(genv_t<`g>, Set::set_t<var_t,`r>)@`r 
treeshake_make_env_f(region_t<`r> rgn, genv_t<`g> ge) {
  return rnew (rgn) $(ge, Set::rempty(rgn, strptrcmp));
}

list_t<decl_t> treeshake(tenv_t<`g,_> te, list_t<decl_t> ds) {
  region rgn; {
    let env = TreeshakeEnv(rgn, false,
                           Dict::rmap_c(rgn,treeshake_make_env_f,rgn,te->ae));
    let ds1 = treeshake_f(&env, ds);
    if(Dict::is_empty(env.nsdict))
      return ds1; // shouldn't be possible
    // update the global environment
    let iter = Dict::make_iter(Core::heap_region,env.nsdict);
    let pr = *Dict::rchoose(rgn,env.nsdict);
    while(Iter::next(iter,&pr)) {
      let $(_,&$(ge,set)) = pr;
      ge->ordinaries = Dict::rfilter_c(ge->grgn, treeshake_remove_f, set, ge->ordinaries);
    }
    return ds1;
  }
}
