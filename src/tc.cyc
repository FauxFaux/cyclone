/* Type checking for top-level declarations
   Copyright (C) 2001 Greg Morrisett, AT&T
   This file is part of the Cyclone compiler.

   The Cyclone compiler is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   The Cyclone compiler is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with the Cyclone compiler; see the file COPYING. If not,
   write to the Free Software Foundation, Inc., 59 Temple Place -
   Suite 330, Boston, MA 02111-1307, USA. */
#include <string.h>
#include "absynpp.h"
#include "warn.h"
#include "flags.h"
#include "unify.h"
#include "tcutil.h"
#include "kinds.h"
#include "attributes.h"
#include "tctyp.h"
#include "tcexp.h"
#include "tcstmt.h"
#include "evexp.h"
#include "tcdecl.h"
#include "callgraph.h"
#include "relations-ap.h"
#include "tc.h"
#include "cifc.h"
#include "toc.h"
using Core;
using List;
using Absyn;
using Tctyp;
using Tcutil;
using Tcenv;
namespace Tc;

// used for the error messages of tcdecl
static string_t tc_msg_c = "";
static string_t * tc_msg = &tc_msg_c;

static bool export_member(qvar_t x, list_t<$(seg_t,qvar_t,bool)@> exports) {
  for (; exports != NULL; exports = exports->tl) {
    let p = exports->hd;
    if (!qvar_cmp(x,(*p)[1]) == 0) 
      continue;
    // set the flag associated with the export to record that the
    // declaration is present and return true
    (*p)[2] = true;
    return true;
  }
  return false;
}

static void tcVardecl(tenv_t te, seg_t loc, vardecl_t vd, bool check_var_init, 
                      bool in_cinclude, list_t<$(seg_t,qvar_t,bool)@>* exports){
  let &Vardecl(sc,q,_,_,t,initializer,_,atts,_,*is_proto) = vd;
#ifdef DEBUG
  fprintf(stderr,"type-checking vardecl_t %s, type %s\n",*((*q)[1]), 
          Absynpp::typ2string(vd->type)); fflush(stderr);
#endif

  // if it's an array or string, fill in the size on the type
  switch (compress(t)) {
  case &ArrayType(ArrayInfo{telt,tq,NULL,zt,ztl}) && initializer != NULL:
    switch (initializer->r) {
    case &Const_e({.String_c = s}):
      t = vd->type = array_type(telt,tq,uint_exp(numelts(s),0),zt,ztl); break;
    case &Const_e({.Wstring_c = s}): /* FIX: need correct size, not 1 */
      t = vd->type = array_type(telt,tq,uint_exp(1,0),zt,ztl); break;
    case &Comprehension_e(_,e,_,_): fallthru(e);
    case &ComprehensionNoinit_e(e,_,_): // FIX: need to copy e here!
      t = vd->type = array_type(telt,tq,e,zt,ztl); break;
    case &UnresolvedMem_e(_,es): fallthru(es);
    case &Array_e(es):
      t = vd->type = array_type(telt,tq,uint_exp(List::length(es),0),zt,ztl);
      break;
    default: break;
    }
    break;
  default: break;
  }
  // reject ill-formed type
  check_valid_toplevel_type(loc,te,t);
  
  vd->tq.real_const = extract_const_from_typedef(loc,vd->tq.print_const,t);
  // top-level arrays don't escape because they can't be assigned to, so
  // their sizes do not change over time. All other globals escape.
  vd->escapes = !is_array_type(t);
  // move any function type attributes into the function's type
  if (is_function_type(t)) {
    *is_proto = false; //by default this is extern -- if we say a decl later, we flip this flag
    atts = Atts::transfer_fn_type_atts(t,atts);
    Atts::fnTypeAttsOK(loc, t);
  }
  // if extern, make sure it has no initializer
  if (sc == Extern || sc == ExternC) {
    if(initializer != NULL && !in_cinclude)
      Warn::err2(loc,"extern declaration should not have initializer");
  } else if (!is_function_type(t)) {
    // we skip over function types -- these are function prototypes.
    // otherwise, we compute default initializer, if necessary
    // first check that the attributes are okay
    Atts::check_variable_atts(loc,vd,atts);
    if(initializer == NULL || in_cinclude) {
      if (check_var_init && !in_cinclude && !zeroable_type(t))
        Warn::err2(loc,"initializer required for variable ",vd," of type ",t);
    } else {
      // type-check the initializer
      // have to look out for an Env_error when the expression
      // is not a valid-toplevel one.
      try {
        let t2 = Tcexp::tcExpInitializer(te,&t,initializer);
        if (!coerce_assign(curr_rgnpo(te),initializer,t)) {
          let s0 = Absynpp::qvar2string(vd->name);
          let s1 = " declared with type ";
          let s2 = Absynpp::typ2string(t);
          let s3 = " but initialized with type ";
          let s4 = Absynpp::typ2string(t2);
          if (strlen(s0)+strlen(s1)+strlen(s2)+strlen(s3)+strlen(s4) > 70)
            Warn::err(loc,"%s%s\n\t%s\n%s\n\t%s",s0,s1,s2,s3,s4);
          else 
            Warn::err(loc,"%s%s%s%s%s",s0,s1,s2,s3,s4);
          Unify::explain_failure();
        }
        // reject non-constant initializers
        if (!Tcutil::is_const_exp(initializer))
          Warn::err2(loc,"initializer is not a constant expression");
      } catch { case &Tcenv::Env_error: 
        Warn::err2(loc,"initializer is not a constant expression"); break;
      }
    }
  } else // it is a function type
    Atts::check_fndecl_atts(loc,atts,false);

  // update the environment
  try {
    let ans = Dict::lookup(te->ae->ordinaries, q);
    let b0 = (*ans)[0];
    let b1 = new Global_b(vd);
    let b = Tcdecl::merge_binding(b0, b1, loc, tc_msg);
    if (b == NULL) return; // error in merging
    // make the update if the variable is exported
    if (exports == NULL || export_member(vd->name,*exports)) 
      if (b != b0 || (*ans)[1]) 
	// no need to reinsert the entry 
	te->ae->ordinaries = Dict::insert(te->ae->ordinaries, 
					  q, new $(b,(*ans)[1]));
    return;
  } catch { case &Dict::Absent: break; }
  if (exports == NULL || export_member(vd->name,*exports))
    te->ae->ordinaries = Dict::insert(te->ae->ordinaries, q,
				      new $(new Global_b(vd), false));
}

static bool is_main(qvar_t n) {
  let &$(nms,v) = n;
  switch (nms) {
  case {.Abs_n = NULL}: return (strcmp(*v,"main") == 0);
  default: return false;
  }
}

static void tcFndecl(tenv_t te, seg_t loc, fndecl_t fd,
                     list_t<$(seg_t,qvar_t,bool)@>* exports) {
  qvar_t q = fd->name;
#ifdef DEBUG
  fprintf(stderr,"type-checking fndecl %s\n",*((*q)[1])); fflush(stderr);
#endif
  if(fd->sc == ExternC && !te->in_extern_c_include)
    Warn::err2(loc,"extern \"C\" functions cannot be implemented in Cyclone");

  // check that packed and aligned don't show up in the attributes
  Atts::check_fndecl_atts(loc,fd->i.attributes,true);

  // reject ill-formed type
  if(te->in_extern_c_inc_repeat)
    fd->cached_type = NULL;
  check_fndecl_valid_type(loc,te,fd);
  type_t t = fndecl2type(fd);
  // move any function type attributes into the function's type
  bool nothrow = List::mem(Atts::attribute_cmp,
			   fd->i.attributes,
			   &Atts::No_throw_att_val);
  fd->i.attributes = Atts::transfer_fn_type_atts(t,fd->i.attributes);
  Atts::fnTypeAttsOK(loc, t);
  
  // due to recursion, add function to environment before checking body
  try {
    let ans = Dict::lookup(te->ae->ordinaries, q);
    let b0 = (*ans)[0];
    let b1 = new Funname_b(fd);
    let b = Tcdecl::merge_binding(b0, b1, loc, tc_msg);
    if (b != NULL) // NULL implies error in merging (error reported already)
      // make the update if the function is exported
      if (exports == NULL || export_member(q,*exports))
	if (!(b == b0 && (*ans)[1])) // no need to reinsert the entry
	  te->ae->ordinaries = Dict::insert(te->ae->ordinaries, 
					    q, new $(b, (*ans)[1]));
  } catch { case &Dict::Absent:
    if (exports == NULL || export_member(fd->name,*exports))
      te->ae->ordinaries = Dict::insert(te->ae->ordinaries, q,
					new $(new Funname_b(fd), false));
    break;
  }

  // ignore C bodies 
  if (te->in_extern_c_include) return;

  // DAN: Here is where I'm assuming the te can be imperatively screwed with
  //      while we're dealing with top-level stuff (though it's not too hard
  //      to undo that assumption)
  let fenv = new_fenv(loc,fd);
  let te = new Tenv{te->ns, te->ae, fenv, false, false, te->in_tempest, te->tempest_generalize, false};
  // check the body, then get rid of local environment
  Tcstmt::tcStmt(te,fd->body,false);
  // we delayed checking some capabilities and constraints so that inference
  // works a bit better, and now it's time to check them:
  check_delayed_effects(te);
  check_delayed_constraints(te);
  // for tempest code, we now have to generalize the type.
  if (te->in_tempest) {
    te->tempest_generalize = true;
    check_fndecl_valid_type(loc,te,fd);
    te->tempest_generalize = false;
  }
  if(nothrow && !Tcstmt::ensure_no_throw_stmt(fd->body))
    Warn::err2(loc, "Function ", fd->name, " has attribute no_throw but may throw an exception");
  // look for main and check that it has a good type
  if (is_main(q)) {
    // result type should be int
    switch (compress(fd->i.ret_type)) {
    case &AppType(&VoidCon,_): 
      Warn::warn2(loc,"main declared with return type void"); break;
    case &AppType(&IntCon(_,Int_sz),_):
    case &AppType(&IntCon(_,Long_sz),_): break;
    default: Warn::err2(loc,"main declared with return type ",fd->i.ret_type,
			" instead of int or void");
    }
    if (fd->i.c_varargs || fd->i.cyc_varargs != NULL)
      Warn::err2(loc,"main declared with varargs");
    let args = fd->i.args;
    if (args != NULL) {
      let &$(_,_,t1) = args->hd;
      switch (compress(t1)) {
      case &AppType(&IntCon(_,Int_sz),_):
      case &AppType(&IntCon(_,Long_sz),_): break;
      default: Warn::err2(loc,"main declared with first argument of type ",t1,
			  " instead of int");
      }
      args = args->tl;
      if (args != NULL) {
        let &$(_,_,t2) = args->hd;
        args = args->tl;
        if (args != NULL)
          Warn::err2(loc,"main declared with too many arguments");
        opt_t<list_t<tvar_t>> tvs = new Opt(fd->i.tvars);
        if (!Unify::unify(t2,fatptr_type(string_type(new_evar(new Opt(&Kinds::rk),tvs)),
                                     new_evar(new Opt(&Kinds::rk),tvs),
                                     empty_tqual(0),any_bool(tvs->v),false_type)) &&
            !Unify::unify(t2,fatptr_type(const_string_type(new_evar(new Opt(&Kinds::rk),
                                                               tvs)),
                                     new_evar(new Opt(&Kinds::rk),tvs),
                                     empty_tqual(0),any_bool(tvs->v),false_type)) &&
            !Unify::unify(t2,fatptr_type(string_type(new_evar(new Opt(&Kinds::rk),tvs)),
                                     new_evar(new Opt(&Kinds::rk),tvs),
                                     const_tqual(0),any_bool(tvs->v),false_type)) &&
            !Unify::unify(t2,fatptr_type(const_string_type(new_evar(new Opt(&Kinds::rk),
                                                               tvs)),
                                     new_evar(new Opt(&Kinds::rk),tvs),
                                     const_tqual(0),any_bool(tvs->v),false_type))) {
          Warn::err2(loc,"second argument of main has type ",t2,
		     " instead of char??");
        }
      }
    }
  }
}

static void tcTypedefdecl(tenv_t te, seg_t loc, typedefdecl_t td) {
  qvar_t q = td->name;
#ifdef DEBUG
  fprintf(stderr,"type-checking typedefdecl %s",*((*q)[1])); fflush(stderr);
#endif
  // check for redeclaration (never allowed, apparently)
  if (Dict::member(te->ae->typedefs,q)) {
    Warn::err2(loc,"redeclaration of typedef ",q);
    return;
  }
  // reject ill-formed type
  check_unique_tvars(loc,td->tvs);
  add_tvar_identities(td->tvs);
  if (td->defn != NULL) {
    check_type(loc,te,td->tvs,&Kinds::tak,false,true,(type_t)td->defn);
    td->tq.real_const = 
      extract_const_from_typedef(loc,td->tq.print_const,(type_t)td->defn);
    // FIX: check that attributes are okay for this kind of type
  } 
  // run through and constrain the kinds of unconstrained tvs
  for (_ tvs = td->tvs; tvs != NULL; tvs = tvs->tl)
    switch (Kinds::compress_kb(tvs->hd->kind)) {
    case &Unknown_kb(*f): 
      if (td->defn != NULL)
        Warn::warn2(loc,"type variable ",tvs->hd, " is not used in typedef");
      *f = new Opt(Kinds::kind_to_bound(&Kinds::tbk)); break;
    case &Less_kb(*f,k):
      // treat region kinds specially; unconstrained region kinds
      //   should be made Aliasable
//       if (k->kind == RgnKind && k->aliasqual == Top)
// 	*f = new Opt(kind_to_bound(new Kind(RgnKind,Aliasable)));
//       else
	*f = new Opt(Kinds::kind_to_bound(k));
      break;
    default: continue;
    }
  // add to environment
  te->ae->typedefs = Dict::insert(te->ae->typedefs,q,td);
}

static void tcAggrImpl(tenv_t te, seg_t loc, 
                       aggr_kind_t str_or_union,
                       list_t<tvar_t,`H> tvs,
		       list_t<$(type_t,type_t)@> rpo, 
		       list_t<aggrfield_t> fields) {
  // check fields, rejecting ill-formed types, bad fields, and duplicates
  // (unless the field name is empty)
  region uprev_rgn; 
  // FIX?: forbid effect variables (but they're going away)
  for(; rpo != NULL; rpo = rpo->tl) {
    let &$(e,r) = rpo->hd;
    check_type(loc,te,tvs,&Kinds::ek,false,false,e);
    check_type(loc,te,tvs,&Kinds::trk,false,false,r); 
  }

  list_t<field_name_t, `uprev_rgn> prev_fields = NULL;
  list_t<Relations::relns_t<`uprev_rgn>,`uprev_rgn> prev_relations = NULL;

  for (let fs = fields; fs != NULL; fs = fs->tl) {
    let &Aggrfield(fn,tq,t,width,atts,requires_clause) = fs->hd;
    //NKS -- check atts here
    if (List::mem(strptrcmp,prev_fields,fn))
      Warn::err2(loc, "duplicate member ", *fn);
    // add the field to previous fields only if it's not an empty name
    // (empty names arise for bitfield padding.)
    if (strcmp(*fn,"") != 0)
      prev_fields = rnew(uprev_rgn) List(fn,prev_fields);

    kind_t field_kind = &Kinds::tmk;
    // FIX:  we can get ill-founded cycles of the form
    // struct Foo<`a::A> { struct Foo<`a> x; } here, and
    // it can cut across multiple definitions...  
    if (str_or_union == UnionA || 
	(fs->tl == NULL && str_or_union == StructA)) 
      field_kind = &Kinds::tak; // we allow abstract kind for the last field
    check_type(loc,te,tvs,field_kind,false,false,t);

    fs->hd->tq.real_const = extract_const_from_typedef(loc,fs->hd->tq.print_const,t);

    // if width is non-NULL then t must be of integral type
    check_bitfield(loc, t, width, fn);
    // FIX : check for consistent tquals
    if (requires_clause) {
      if (str_or_union != UnionA)
	Warn::err2(loc,"@requires clauses are allowed only on union members");
      let te2 = allow_valueof(te);
      Tcexp::tcExp(te2,NULL,requires_clause);
      if (!is_integral(requires_clause))
	Warn::err2(requires_clause->loc,
		   "@requires clause has type ",(type_t)requires_clause->topt,
		   " instead of integral type");
      else {
	check_type(requires_clause->loc,te,tvs,&Kinds::ik,false,false,new ValueofType(requires_clause));
        // convert the requires expression to a CNF formula
	let relns = Relations::exp2relns(uprev_rgn,requires_clause);

	// warn if the relations aren't consistent
	if (!Relations::consistent_relations(relns))
	  Warn::err2(requires_clause->loc,"@requires clause may be unsatisfiable");

	// run through all of the previous formulae and see if
	// this one is consistent with those.  If so, there may
	// be an overlap and we must reject.
	for (let p = prev_relations; p != NULL; p = p->tl)
	  if (Relations::consistent_relations(rappend(uprev_rgn,relns,p->hd)))
	    Warn::err2(requires_clause->loc,
		       "@requires clause may overlap with previous clauses");
	prev_relations = rnew(uprev_rgn) List(relns,prev_relations);
      }
    } else /* no requires clause */
      if (prev_relations != NULL)
	Warn::err2(loc,"if one field has a @requires clause, they all must");
  }
}

static void rule_out_memkind(seg_t loc, qvar_t n, list_t<tvar_t> tvs,
			     bool constrain_top_kind) {
  for(_ tvs2 = tvs; tvs2 != NULL; tvs2 = tvs2->tl)
    switch (Kinds::compress_kb(tvs2->hd->kind)) {
    case &Unknown_kb(*f):
      *f = new Opt(Kinds::kind_to_bound(&Kinds::bk)); continue;
    case &Less_kb(*f,&Kind(MemKind,a)):
      if (constrain_top_kind && a == Top)
	*f = new Opt(Kinds::kind_to_bound(new Kind(BoxKind,Aliasable)));
      else
	*f = new Opt(Kinds::kind_to_bound(new Kind(BoxKind,a)));
      continue;
    case &Less_kb(*f,&Kind(BoxKind,Top)) && constrain_top_kind:
      *f = new Opt(Kinds::kind_to_bound(new Kind(BoxKind,Aliasable)));
      continue;
    case &Less_kb(*f,k): 
      *f = new Opt(Kinds::kind_to_bound(k)); continue;
    case &Eq_kb(&Kind(MemKind,a)):
      Warn::err2(loc,"type ",n," attempts to abstract type variable ",
		 tvs2->hd," of kind ",new Kind(MemKind,a)); 
      continue;
    default: continue;
    }
}
static void rule_out_mem_and_unique(seg_t loc, qvar_t q, list_t<tvar_t> tvs) {
  for(_ tvs2 = tvs; tvs2 != NULL; tvs2 = tvs2->tl) {
    switch (Kinds::compress_kb(tvs2->hd->kind)) {
    case &Unknown_kb(*f): fallthru(f);
//     case &Less_kb(*f,&Kind(BoxKind,Top)): fallthru(f);
    case &Less_kb(*f,&Kind(MemKind,Top)): fallthru(f);
    case &Less_kb(*f,&Kind(MemKind,Aliasable)): 
      *f = new Opt(Kinds::kind_to_bound(&Kinds::bk)); break;
    case &Less_kb(*f,&Kind(AnyKind,Top)): fallthru(f);
    case &Less_kb(*f,&Kind(AnyKind,Aliasable)): 
      *f = new Opt(Kinds::kind_to_bound(&Kinds::ak)); break;
    case &Less_kb(*f,&Kind(RgnKind,Top)):
      *f = new Opt(Kinds::kind_to_bound(&Kinds::rk)); break;
    case &Eq_kb(&Kind(RgnKind,Top)):
      Warn::err2(loc,"type ",q," attempts to abstract type variable ",
		 tvs2->hd," of kind TR"); break;
    case &Less_kb(*f,&Kind(k,Unique)): fallthru(k);
    case &Eq_kb(&Kind(k,Unique)):
      Warn::err2(loc,"type ",q," attempts to abstract type variable ",
		 tvs2->hd," of kind ",new Kind(k,Unique)); break;
    case &Eq_kb(&Kind(MemKind,a)):
      Warn::err2(loc,"type ",q," attempts to abstract type variable ",
		 tvs2->hd," of kind ",new Kind(MemKind,a)); break;
    default: break;
    }
  }
}


void tcAggrdecl(tenv_t te, seg_t loc, aggrdecl_t ad) {
  let q = ad->name;
#ifdef DEBUG
  fprintf(stderr,"type-checking type decl %s\n",*((*q)[1])); fflush(stderr);
#endif
  // allow only packed and aligned attributes
  Atts::check_field_atts(loc,(*q)[1],ad->attributes);
  
  let tvs = ad->tvs;

  // reject ill-formed type
  check_unique_tvars(loc, ad->tvs);
  add_tvar_identities(ad->tvs);

  // check the fields and update the environment
  // may not be the first declaration, so must not overwrite the dict entry!
  switch ($(ad->impl, Dict::lookup_opt(te->ae->aggrdecls, q))) {
  case $(NULL, NULL):
    // insert ad in the environment
    rule_out_memkind(loc,q,tvs,false);
    // FIX: ignores @tagged qualifier which may be on struct!
    te->ae->aggrdecls = Dict::insert(te->ae->aggrdecls, q, new ad);
    break;
  case $(&AggrdeclImpl(exist_vars,rgn_po,fs,tagged), NULL):
    // FIX: check rgn_po for well-formed!
    // for the sake of recursive fields, make name abstract in body
    let adp = new (new Aggrdecl(ad->kind, Extern, ad->name, tvs,
				NULL, ad->attributes, false));
    te->ae->aggrdecls = Dict::insert(te->ae->aggrdecls, q, adp);

    // reject ill-formed type
    // FIX: should be distinct from tvs but these already have
    // identities so they will never compare the same.
    check_unique_tvars(loc, exist_vars);
    add_tvar_identities(exist_vars);
    // disallow MemKinds and set unconstrained kinds to BoxKind
    // reject struct with @tagged qualifier
    if (tagged && (ad->kind == StructA))
      Warn::err2(loc,"@tagged is allowed only on union declarations");
    tcAggrImpl(te, loc, ad->kind, append(tvs,exist_vars), rgn_po, fs);

    rule_out_memkind(loc, q, tvs, false);
    // we constrain existential variables to be Aliasable if
    //   they have not yet been fixed
    rule_out_memkind(loc, q, exist_vars, true);

    if(ad->kind == UnionA && !tagged)
      // warn when fields of unions are not bits-only -- these can
      // only be written and not read.
      for (_ f = fs; f != NULL; f = f->tl)
	if (Flags::tc_aggressive_warn &&
            !is_bits_only_type(f->hd->type) && f->hd->requires_clause == NULL)
	  Warn::warn2(loc,"member ",*f->hd->name," of union ",q," has type ",
		      f->hd->type," so it can only be written and not read");
    *adp = ad; //insert ad in the environment
    break;
  case $(&AggrdeclImpl(exist_vars,rgn_po,fs,tagged), &adp):
    // FIX: check rgn_po!!! (just need to be closed (and no > `a ??))
    if(ad->kind != (*adp)->kind)
      Warn::err2(loc,"cannot reuse struct names for unions and vice-versa");

    let ad0 = *adp;
    // for the sake of recursive fields, make name abstract in body
    *adp = new Aggrdecl(ad->kind, Extern, ad->name, tvs,
			NULL, ad->attributes, false);

    // reject ill-formed type
    // FIX: should be distinct from tvs but these already have
    // identities so they will never compare the same.
    check_unique_tvars(loc, exist_vars);
    add_tvar_identities(exist_vars);
    // reject struct with @tagged qualifier
    if (tagged && (ad->kind == StructA))
      Warn::err2(loc,"@tagged is allowed only on union declarations");
    tcAggrImpl(te, loc, ad->kind, append(tvs,exist_vars), rgn_po, fs);

    *adp = ad0;// restore the previous declaration and go update the environment
    fallthru(adp);
  case $(NULL, &adp):
    // try to merge the declarations
    let ad2 = Tcdecl::merge_aggrdecl(*adp, ad, loc, tc_msg);
    if (ad2 == NULL)
      return; // error in redeclaration
    rule_out_memkind(loc, q, tvs, false);
    // we constrain existential variables to be Aliasable if
    //   they have not yet been fixed
    if (ad->impl != NULL) 
      rule_out_memkind(loc, q, ad->impl->exist_vars, true);
    *adp = ad2; // make the update
  }
}

static list_t<datatypefield_t> tcDatatypeFields(tenv_t te, seg_t loc,
					    string_t<`H> obj, 
                                            bool is_extensible,
					    qvar_t name,
					    list_t<datatypefield_t,`H> fields,
					    list_t<tvar_t,`H> tvs,
					    datatypedecl_t tudres) {
  // check variants, rejecting ill-formed types and repeated tyvars
  for(let fs = fields; fs != NULL; fs = fs->tl) {
    let f = fs->hd;
    for (_ typs = f->typs; typs != NULL; typs=typs->tl) {
      check_type(f->loc, te, tvs, &Kinds::tmk, false, false, (*typs->hd)[1]);
      // make sure no no-alias fields in datatype
      if (is_noalias_pointer_or_aggr((*typs->hd)[1]))
	Warn::err2(f->loc, "noalias pointers in datatypes are not allowed: ",
		   f->name); // FIX ?
      (*typs->hd)[0].real_const = 
        extract_const_from_typedef(f->loc,(*typs->hd)[0].print_const,
                                   (*typs->hd)[1]);
    }
  }

  if(is_extensible) {
    // for xdatatypes sort the fields (trying to merge the duplicates)
    let res = true;
    let fs = Tcdecl::sort_xdatatype_fields(fields, &res, (*name)[1], loc, tc_msg);
    return res ? fs : NULL; // should be fs always??
  } 
  region uprev_rgn; 
  // for datatypes, check there's no duplicate field
  list_t<var_t, `uprev_rgn> prev_fields = NULL;
  for (_ fs = fields; fs != NULL; fs = fs-> tl) {
    let f = fs->hd;
    if (List::mem(strptrcmp, prev_fields, (*f->name)[1]))
      Warn::err2(f->loc,"duplicate field ",f->name," in ", obj);
    else
      prev_fields = rnew(uprev_rgn) List((*f->name)[1], prev_fields);
    // erase the scope of the field (which has no meaning)
    if (f->sc != Public) {
      Warn::warn2(loc, "ignoring scope of field ", f->name);
      f->sc = Public;
    }
  }
  return fields;
}

void tcDatatypedecl(tenv_t te, seg_t loc, datatypedecl_t tud) {
  qvar_t q = tud->name;
  string_t obj = tud->is_extensible ? "@extensible datatype" : "datatype";
#ifdef DEBUG
  fprintf(stderr,"type-checking %sdecl %s\n",obj,*((*q)[1])); fflush(stderr);
#endif
  list_t<tvar_t> tvs = tud->tvs;
  // disallow MemKinds and set unconstrained kinds to BoxKind
  // reject ill-formed type
  check_unique_tvars(loc,tvs);
  add_tvar_identities(tvs);

  // determine datatype type's qualified name
  // set ge_decl to the namespace where the declaration 'lives'
  // (for @extensible datatype it may be different from ge)
  datatypedecl_t@* tud_opt;
    // JGM: we first look up the datatype as if it's @extensible.  If we
    // don't find an extensible definition for it, and this definition 
    // does not say it's extensible, then we treat it as a normal datatype.
    // This has a good and bad effect:  the good effect is that you can
    // naturally extend an existing extensible datatype (e.g., exn) without
    // having to write @extensible all the time.  The bad news is that
    // you can't shadow an extensible datatype that is reachable in the
    // current namespace.  But oh well...
    // FIX: necessary now that we have binding pass?
  try {
    tud_opt = lookup_xdatatypedecl(heap_region,te,loc,tud->name);
    if (tud_opt == NULL && !tud->is_extensible) throw new Dict::Absent;
    if (tud_opt != NULL)
      tud->name = (*(*tud_opt))->name;
    else
      (*tud->name)[0] = Abs_n(te->ns, false); 
  } catch { case &Dict::Absent:
    let tdopt = Dict::lookup_opt(te->ae->datatypedecls, q);
    tud_opt = tdopt ? new (*tdopt) : NULL;
    break;
  }
    
  // check the fields and update the environment
  // may not be the first declaration, so must not overwrite the dict entry!
  switch ($(tud->fields, tud_opt)) {
  case $(NULL, NULL):
    // insert tud in the environment
    rule_out_mem_and_unique(loc,q,tvs);
    te->ae->datatypedecls = Dict::insert(te->ae->datatypedecls, q, new tud);
    break;
  case $(&Opt(*fs), NULL):
    // for the sake of recursive fields, make name abstract in body
    let tudp = new (new Datatypedecl(Extern,tud->name,tvs,NULL,
				     tud->is_extensible));
    te->ae->datatypedecls = Dict::insert(te->ae->datatypedecls, q, tudp);
    
    // check the fields (and sort them if this is a @extensible datatype)
    *fs = tcDatatypeFields(te,loc,obj,tud->is_extensible,tud->name,*fs,tvs,tud);
    rule_out_mem_and_unique(loc,q,tvs);
    *tudp = tud; //insert tud in the environment
    break;
  case $(&Opt(*fs), &tudp):
    let tud0 = *tudp;
    // a previous declaration said this was extensible -- so change the
    // current declaration to pretend like it's extensible.
    if (!tud->is_extensible && tud0 && tud0->is_extensible)
      tud->is_extensible = true;
    // for the sake of recursive fields, make name abstract in body
    *tudp = new Datatypedecl(Extern, tud->name, tvs, NULL, 
			     tud->is_extensible);
    
    // check the fields (and sort them if this is a @extensible datatype)
    *fs = tcDatatypeFields(te,loc,obj,tud->is_extensible,
			   tud->name,*fs,tvs,tud);

    *tudp = tud0; // restore previous declaration and go update the environment
    fallthru(tudp);
  
  case $(NULL, &tudp):
    // try to merge the declarations
    let tud2 = Tcdecl::merge_datatypedecl(*tudp, tud, loc, tc_msg);
    rule_out_mem_and_unique(loc,q,tvs);
    if (tud2 != NULL) // else error in redeclaration
      *tudp = tud2; // make the update
    break;
  } 
}

void tcEnumdecl(tenv_t te, seg_t loc, enumdecl_t ed) {
  qvar_t q = ed->name;
#ifdef DEBUG
  fprintf(stderr,"type-checking enumdecl %s",*((*q)[1])); fflush(stderr);
#endif
  // check the fields.
  if (ed->fields != NULL) { 
    region uprev_rgn;
    list_t<field_name_t, `uprev_rgn> prev_fields = NULL;
    unsigned int tag_count = 0;
    for (_ fs = ed->fields->v; fs != NULL; fs = fs->tl) {
      let f = fs->hd;
      // check for duplicate fields
      if (List::mem(strptrcmp,prev_fields,(*f->name)[1]))
	Warn::err2(f->loc,"duplicate enum constructor ",f->name);
      else
	prev_fields = rnew(uprev_rgn) List((*f->name)[1],prev_fields);
      // check for shadowing of global variables
      if (Dict::lookup_opt(te->ae->ordinaries,f->name) != NULL)
	Warn::err2(f->loc,"enum field name ",f->name," shadows global name");
      if (f->tag == NULL)
	f->tag = uint_exp(tag_count++, f->loc);
      // allow non-const exprs for now; will be caught below
      else if (Tcutil::is_const_exp((exp_t)f->tag)) {
	let $(t1,known) = Evexp::eval_const_uint_exp((exp_t)f->tag);
	if(known) 
	  tag_count = t1+1;
      }
    }
  }

  // update the environment
  try {
    let edp = Dict::lookup(te->ae->enumdecls, q);
    let ed2 = Tcdecl::merge_enumdecl(*edp, ed, loc, tc_msg);
    if (ed2 == NULL) return;
    *edp = ed2; // if there's no error, make the update
  } catch { case &Dict::Absent:
    let edp = new ed;
    te->ae->enumdecls = Dict::insert(te->ae->enumdecls, q, edp);
    break;
  }

  // Now make sure that the fields are constant expressions;
  if (ed->fields != NULL)
    for (_ fs = ed->fields->v; fs != NULL; fs = fs->tl) {
      let f = fs->hd;
      Tcexp::tcExp(te,NULL,(exp_t)f->tag); // substitute if poss
      if (!Tcutil::is_const_exp((exp_t)f->tag))
	Warn::err2(loc,"enum ",q,", field ",f->name,
		   ": expression is not constant");
    }
}

static bool okay_externC(seg_t loc, scope_t sc, bool in_include, bool in_inc_rep) {
  switch (sc) {
  case Static:
    if(!in_include)
      Warn::warn2(loc,"static declaration within extern \"C\"");
    return false;
  case Abstract:
    Warn::warn2(loc,"abstract declaration within extern \"C\"");
    return false;
  case Public:
  case Register: 
  case Extern: return true;
  case ExternC:
  default: 
    if(!in_inc_rep)
      Warn::warn2(loc,"nested extern \"C\" declaration");
    return true;
  }
}

static void set_scopes(list_t<decl_t> ovrs, scope_t sc) {
  for(; ovrs != NULL; ovrs=ovrs->tl)
    switch(ovrs->hd->r) {
    case &Var_d(vd):        vd->sc = sc; break;
    case &Fn_d(fd):         fd->sc = sc; break;
    case &Aggr_d(ad):       ad->sc = sc; break;
    case &Datatype_d(tud): tud->sc = sc; break;
    case &Enum_d(ed):       ed->sc = sc; break;
    default: break; //no scope attr.
    }
}

// Typecheck a list, ds, of declarations in environment te.
// As a side effect, all declarations and variable references are made
// absolute, so later passes just recurse through namespace and using
// New: a second pass shakes out unnecessary vardecls.
// FIX: shake out type definitions too.
static void tc_decls(tenv_t te, list_t<decl_t,`H> ds0, 
		     bool in_externC, 
                     bool check_var_init,
                     list_t<$(seg_t,qvar_t,bool)@`H,`H>* exports) {
  for (let ds = ds0; ds != NULL; ds = ds->tl) {
    decl_t d   = ds->hd;
    seg_t  loc = d->loc;
    switch (d->r) {
    case &Let_d(...): 
    case &Letv_d(_): // FIX -- error will be in Binding pass
      Warn::err2(loc,"top level let-declarations are not implemented"); break;
    case &Region_d(...):
      Warn::err2(loc,"top level region declarations are not implemented");break;
    case &Var_d(vd):
      if (in_externC && okay_externC(d->loc,vd->sc,te->in_extern_c_include,te->in_extern_c_inc_repeat))
        vd->sc = ExternC;
      tcVardecl(te,loc,vd,check_var_init,te->in_extern_c_include,exports);
      break;
    case &Fn_d(fd):
      if (in_externC && okay_externC(d->loc,fd->sc,te->in_extern_c_include,te->in_extern_c_inc_repeat))
	fd->sc = ExternC;
      if(te->in_extern_c_include)
	fd->orig_scope = ExternC;
      tcFndecl(te,loc,fd,exports);
      break;
    case &Typedef_d(td):
      td->extern_c = te->in_extern_c_include;
      // FIX: if we ever end up with a TypeDeclType inside a type
      // then it should be entered into the current namespace, unless
      // it's occurring within in_externC code.  
      tcTypedefdecl(te,loc,td);
      break;
    case &Aggr_d(ad):
      if (in_externC &&  okay_externC(d->loc,ad->sc,te->in_extern_c_include, te->in_extern_c_inc_repeat))
	ad->sc = ExternC;
      tcAggrdecl(te,loc,ad);
      break;
    case &Datatype_d(tud):
      if (in_externC && okay_externC(d->loc,tud->sc,te->in_extern_c_include,te->in_extern_c_inc_repeat))
	tud->sc = ExternC;
      tcDatatypedecl(te,loc,tud);
      break;
    case &Enum_d(ed):
      if (in_externC && okay_externC(d->loc,ed->sc,te->in_extern_c_include,te->in_extern_c_inc_repeat))
        ed->sc = ExternC;
      tcEnumdecl(te,loc,ed);
      break;
    case &Porton_d: Warn::warn2(d->loc,"spurious __cyclone_port_on__"); break;
    case &Portoff_d: break;
    case &Tempeston_d:  te = enter_tempest(te); break;
    case &Tempestoff_d: te = clear_tempest(te); break;
    case &Namespace_d(v,ds2):
      // Do the nested declarations then restore the namespace
      let ns  = te->ns;
      te->ns = List::append(ns,new List(v,NULL));
      tc_decls(te,ds2,in_externC,check_var_init,exports);
      te->ns = ns;
      break;

    case &Using_d(_,ds2): // binding phase takes care of using
      tc_decls(te,ds2,in_externC,check_var_init,exports); break;

    case &ExternC_d(ds2):
      tc_decls(te,ds2,true,check_var_init,exports); break;

      // FIX: there's a simpler way to do this that does not require remembering
      // to mutate bools other places.  (See binding.)
    case &ExternCinclude_d(*ds2,ovrs,exports2,wc): 
      if(ovrs) {
	let tecpy = copy_tenv_dicts(te);
	tecpy->in_extern_c_include = true;
	tc_decls(tecpy,*ds2,true,check_var_init,NULL);
	Toc::init(); // bleach: (for typ_to_c)
	set_scopes(ovrs, ExternC); //ow scope mismatch warnings -- ovrs are not typechecked independently
	Cifc::user_overrides(d->loc, tecpy, ds2, ovrs);
	Toc::finish();
      }	
      list_t<$(seg_t,qvar_t,bool)@> newexs = 
	List::append(exports2,exports ? *exports : NULL);
      let te2 = enter_extern_c_include(te);
      te2->in_extern_c_inc_repeat = (ovrs != NULL);
      tc_decls(te2,*ds2,true,check_var_init,&newexs);
      
      // check that all of the exports were actually present
      for (; exports2 != NULL; exports2 = exports2->tl) {
	let exp = exports2->hd;
	if (!(*exp)[2])
	  Warn::warn2((*exp)[0],(*exp)[1]," is exported but not defined");
      }
      break;
    }
  }
}

void tc(tenv_t te, bool check_var_init, list_t<decl_t,`H> ds) {
  Absynpp::set_params(&Absynpp::tc_params_r);
  let cg = Callgraph::compute_callgraph(ds);
  //fprintf(stderr,"Callgraph:\n");
  //Callgraph::print_callgraph(stderr, cg);
  let scc = Graph::scc(cg);
  //fprintf(stderr,"Connected components:\n");
  //Callgraph::print_callgraph(stderr, scc);
  tc_decls(te,ds,false,check_var_init,NULL);
}

// for tree-shaking (so we don't include the world)
// Note: We must shake after all type-checking or we'll be too eager.
// Note: We used to recompute genv, but this seems pointless (only
//       interface.cyc uses it and it should not care about unused stuff),
//       so now we just trim the actual abstract syntax

// We recompute the global environment and delete what's not needed anymore
// all would be far easier if Dict has a delete function

static struct TreeshakeEnv<`g> {
  bool in_cinclude;
  Dict::dict_t<qvar_t,$(binding_t,bool)@`g,`g> ordinaries;
};  
typedef struct TreeshakeEnv<`g> @`r2 treeshake_env_t<`r2,`g>;

static bool vardecl_needed(treeshake_env_t, decl_t);

static list_t<decl_t> treeshake_f(treeshake_env_t env, list_t<decl_t> ds) {
  return List::filter_c(vardecl_needed, env, ds);
}

static bool is_extern(vardecl_t vd) {
  if(vd->sc == Extern || vd->sc == ExternC)
    return true;
  switch(compress(vd->type)) {
  case &FnType(...):  return true;
  default: return false;
  }
}

static bool vardecl_needed(treeshake_env_t env, decl_t d) {
  switch(d->r) {
  case &Var_d(vd):
    // get rid of externs that are never referenced
    if (env->in_cinclude || !is_extern(vd) ||
	!qvar_cmp(vd->name,uniquergn_qvar()))
      return true;
    return (*Dict::lookup(env->ordinaries,vd->name))[1];
  case &ExternC_d(*ds2p): fallthru(ds2p);
  case &Using_d(_,*ds2p): fallthru(ds2p);
  case &Namespace_d(_,*ds2p): *ds2p = treeshake_f(env,*ds2p); return true;
  case &ExternCinclude_d(*ds2p,...): 
    bool in_cinclude = env->in_cinclude;
    env->in_cinclude = true;
    *ds2p = treeshake_f(env,*ds2p);
    env->in_cinclude = in_cinclude;
    return true;
  default: return true;
  }
}

list_t<decl_t> treeshake(tenv_t te, list_t<decl_t> ds) {
  let env = TreeshakeEnv(false, te->ae->ordinaries);
  return treeshake_f(&env, ds);
}
