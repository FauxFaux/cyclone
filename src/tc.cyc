/* Type checking for top-level declarations */

#include "core.h"
#include "string.h"
#include "list.h"
#include "position.h"
#include "absyn.h"
#include "absynpp.h"
#include "tcutil.h"
#include "tcenv.h"
#include "tcexp.h"
#include "tcstmt.h"
#include "evexp.h"
#include "tc.h"
#include "stdio.h"
using Core;
using List;
using Position;
using Absyn;
using Absynpp;
using Tcutil;
using Tcenv;
using Stdio;

namespace Tc;

// check that the scope for a redeclaration of a type is okay
static void redecl_err(seg_t loc, string t, stringptr v,
		       string new_sc, string old_sc) {
  terr(loc, xprintf("redeclaration of %s %s cannot be %s "
		    "when earlier definition is %s",
		    t, *v, new_sc, old_sc));
}
static scope_t scope_redecl_okay(scope_t s1, opt_t<`a> fields1,
                               scope_t s2, opt_t<`a> fields2,
                               seg_t loc, string t, stringptr v) {
  switch ($(s1,s2)) {
  case $(ExternC, ExternC): break;
  case $(_,       ExternC):
    redecl_err(loc, t, v, "non-extern \"C\"", "extern \"C\""); break;
  case $(Static,  Static): break;
  case $(_,       Static): redecl_err(loc, t, v, "non-static", "static"); break;
  case $(Static,  Public): redecl_err(loc, t, v, "static",     "public"); break;
  case $(Abstract,Public): redecl_err(loc, t, v, "abstract",   "public"); break;
  case $(_,       Public): s1 = Public; break;
  case $(Static,  Extern): redecl_err(loc, t, v, "static",     "extern"); break;
  case $(Abstract,Extern) && fields2 != null:
    redecl_err(loc,t,v, "abstract", "transparent"); break;
  case $(_,       Extern): break;
  case $(Static,Abstract): redecl_err(loc, t, v, "static", "abstract"); break;
  case $(Public,Abstract): redecl_err(loc, t, v, "public", "abstract"); break;
  case $(Extern,Abstract) && fields1 != null:
    redecl_err(loc,t,v, "[extern] transparent", "abstract"); break;
  case $(_,     Abstract): s1 = Abstract; break;
  }
  return s1;
}

// check that an tunionfield in a redeclaration matches the previous 
// declaration.  We only check [1] of the qvars b/c qualified field names 
// aren't allowed (?)
static void field_redecl_okay(tunionfield_t f1, tunionfield_t f2,
			      list_t<$(tvar_t,type_t)@> inst, tenv_t te,
			      string t, stringptr v) {

  seg_t loc = f1->loc;
  // must have same name
  if (String::zstrptrcmp((*f1->name)[1],(*f2->name)[1]) != 0)
    terr(loc,xprintf("redeclaration of %s %s: field name mismatch %s != %s",
		     t, *v, *((*f1->name)[1]),
		     *((*f2->name)[1])));
  let tvs1 = f1->tvs;
  let tvs2 = f2->tvs;
  if (List::length(tvs1) != List::length(tvs2))
    terr(loc,xprintf("redeclaration of %s %s, field %s: type parameter number "
		     "mismatch", t, *v, *((*f1->name)[1])));
  for (; tvs1 != null; tvs1 = tvs1->tl, tvs2 = tvs2->tl)
    inst = new List(new $(tvs2->hd,new VarType(tvs1->hd)),inst);
  // must have same number of types
  let typs1 = f1->typs;
  let typs2 = f2->typs;
  if (List::length(typs1) != List::length(typs2))
    terr(loc,xprintf("redeclaration of %s %s, field %s: parameter number "
		     "mismatch", t, *v, *((*f1->name)[1])));
  // for all types
  for (; typs1 != null; typs1 = typs1->tl, typs2 = typs2->tl) {
     // must have same qualifier
    if (!equal_tqual((*typs1->hd)[0],(*typs2->hd)[0]))
      terr(loc,xprintf("redeclaration of %s %s, field %s: parameter qualifier",
		       t, *v, *((*f1->name)[1])));
    type_t subst_t2 = substitute(inst,(*typs2->hd)[1]);
    // and be the same type FIX: (?) is unification appropriate here?
    if (!unify((*typs1->hd)[1],subst_t2))
      terr(loc,xprintf("redeclaration of %s %s, field %s: parameter type "
		       "mismatch %s != %s",
		       t, *v, *((*f1->name)[1]),
		       typ2string((*typs1->hd)[1]), typ2string(subst_t2)));
  }
}

// FIX:  we should really check that static or public function prototypes
// are eventually declared.  However, C will catch this for us, so I'm
// not bothering to do this now.

// now returns whether there is a redeclaration or not -- needed for treeshaking
static bool var_redecl_okay(genv_t ge, seg_t loc, var_t name, type_t t, 
                            scope_t sc, attributes_t atts) {
  opt_t<$(resolved_t,bool)@> ans = Dict::lookup_opt(ge->ordinaries,name);
  if(ans == null)
    return false;
  (*ans->v)[1] = true; // this is very important or we'd shake out too much
  switch ((*ans->v)[0]) {
  case &VarRes(&Global_b(vd)):
    if (sc == Static && vd->sc != Static)
      warn(loc,
           xprintf("static declaration of %s follows non-static declaration",
                   *name));
    if (vd->sc == Static && sc != Static)
      warn(loc,
	   xprintf("non-static declaration of %s follows static declaration",
		   *name));
    if ((vd->sc == ExternC && sc != ExternC) ||
	(vd->sc != ExternC && sc == ExternC))
      terr(loc,xprintf("incompatible redeclaration of %s",*name));
    // either they must both be static, both public, or at most one non-extern
    else if ((sc != Extern && vd->sc != Extern) &&
	!(sc == Static && vd->sc == Static) &&
	!(sc == Public && vd->sc == Public))
      terr(loc,xprintf("incompatible redeclaration of %s",*name));
    // all must be at the same type
    if (!unify(vd->type,t))
      // FIX: should the test be unification?
      // FIX: we should also check the tqual
      terr(loc,xprintf("redeclaration of %s at a different type: %s != %s",
		       *name, typ2string(t), typ2string(vd->type)));
    if (!same_atts(atts, vd->attributes))
      terr(loc,xprintf("redeclaration of %s with different attributes",*name));
    break;
  case &VarRes(&Funname_b(fd)): terr(loc,xprintf("redefinition of function %s", *name)); break;
    // FIX : print the location of the previous definition (as gcc)
  default: break;
  }
  return true;
}

// Transfer any function type attributes from the given list to the
// function type.  
static attributes_t transfer_fn_type_atts(type_t t, attributes_t atts) {
  switch (compress(t)) {
  case &FnType(FnInfo{_,_,_,_,_,*fnatts}):
    let res_atts = null;
    for (; atts != null; atts = atts->tl) {
      switch (atts->hd) {
      case &Regparm_att(_): fallthru;
      case Stdcall_att:    fallthru;
      case Cdecl_att:      fallthru;
      case Noreturn_att:   fallthru;
      case Const_att:
        *fnatts = new List(atts->hd,*fnatts); continue;
      default:
        res_atts = new List(atts->hd,res_atts); continue;
      }
    }
    return res_atts;
  default: return impos("transfer_fn_type_atts"); 
  }
}

static void tcVardecl(tenv_t te, genv_t ge, seg_t loc, vardecl_t vd) {
  var_t   v  = (*vd->name)[1];
#ifdef DEBUG
  fprintf(stderr,"type-checking vardecl_t %s",*v); 
  fflush(stderr);
#endif
  type_t   t  = vd->type;
  scope_t sc = vd->sc;
  attributes_t atts = vd->attributes;

  // reject explicitly qualified name
  switch ((*vd->name)[0]) {
  case &Rel_n(null): break;
  case &Abs_n(null): break; // allowed for top-level constants
  default:
    terr(loc,"qualified declarations are not implemented"); // FIX
    return;
  }
  // expand to qualified name
  (*vd->name)[0] = new Abs_n(te->ns);
  // if it's an array or string, fill in the size on the type
  switch (compress(t)) {
  case &ArrayType(telt,tq,null) && vd->initializer != null:
    switch (vd->initializer->r) {
    case &Const_e(&String_c(s)):
      t = vd->type = new ArrayType(telt,tq,uint_exp(s.size,null));
      break;
    case &UnresolvedMem_e(_,es): fallthru(es);
    case &Array_e(es):
      t = vd->type = new ArrayType(telt,tq,uint_exp(List::length(es),null));
      break;
    default: break;
    }
    break;
  default: break;
  }
  // reject ill-formed type
  check_valid_toplevel_type(loc,te,t);
  if (is_function_type(t)) {
    // move any function type attributes into the function's type
    atts = transfer_fn_type_atts(t,atts);
  }
  // check for redeclaration
  bool is_redecl = var_redecl_okay(ge,loc,v,t,sc,atts);
  // if extern, make sure it has no initializer
  if (sc == Extern || sc == ExternC) {
    if(vd->initializer != null)
      terr(loc,"extern declaration should not have initializer");
  } else if (!is_function_type(t)) {
    // we skip over function types -- these are function protypes.
    // otherwise, we compute default initializer, if necessary
    // first check that the attributes are okay
    for (; atts != null; atts = atts->tl) {
      switch (atts->hd) {
      case &Aligned_att(_): continue;
        // GCC doesn't allow variables to be packed
        // case Packed_att:     continue;
      case &Section_att(_): continue;
      case Nocommon_att:   continue;
      case Shared_att:     continue;
      case Unused_att:     continue;
      case Weak_att:       continue;
      case Dllimport_att:  continue;
      case Dllexport_att:  continue;
      default:
        terr(loc,xprintf("bad attribute %s for variable %s",
                         attribute2string(atts->hd), qvar2string(vd->name)));
        break;
      }
    }
    exp_t e;
    if(vd->initializer == null) {
      e = default_initializer(te,t,loc);
      vd->initializer = e;
    } else {
      e = (exp_t)vd->initializer;
    }
    // type-check the initializer
    let t2 = Tcexp::tcExpInitializer(te,&t,e);
    if (!coerce_assign(te,e,t))
      terr(loc,
	   xprintf("%s is declared with type %s but initialized with type %s",
		   qvar2string(vd->name), typ2string(t), typ2string(t2)));
    // reject non-constant initializers
    if (!Tcutil::is_const_exp(te,e))
      terr(loc,"initializer is not a constant expression");
  } else {
    // it is a function type -- check that the attributes are okay
    for (; atts != null; atts = atts->tl) {
      switch (atts->hd) {
      // these attributes should be in the function's type
      case &Regparm_att(_): fallthru;
      case Stdcall_att:    fallthru;
      case Cdecl_att:      fallthru;
      case Noreturn_att:   fallthru;
      case Const_att:
        impos("tcVardecl: fn type attributes in function var decl");
        break;
      // C doesn't allow these attributes on functions
      case &Aligned_att(_): fallthru;
      case Packed_att:
        terr(loc,xprintf("bad attribute %s in function declaration",
                         attribute2string(atts->hd)));
        break;
      default: continue;
      }
    }
  }
  // add to environment
  ge->ordinaries = Dict::insert(ge->ordinaries, v,
				new $(new VarRes(new Global_b(vd)),is_redecl));
}

static void tcFndecl(tenv_t te, genv_t ge, seg_t loc, fndecl_t fd) {
  var_t   v  = (*fd->name)[1];
#ifdef DEBUG
  fprintf(stderr,"type-checking fndecl %s",*v);
  fflush(stderr);
#endif
  scope_t sc = fd->sc;

  // reject explicitly qualified name
  switch ((*fd->name)[0]) {
  case &Rel_n(null): break;
  case &Abs_n(y):
    throw new Impossible("tc: Abs_n in tcFndecl");
  default:
    terr(loc,"qualified declarations are not implemented"); // FIX
    return;
  }
  // expand to qualified name
  (*fd->name)[0] = new Abs_n(te->ns);
  // reject ill-formed type
  check_fndecl_valid_type(loc,te,fd);
  // check for redeclaration
  type_t t = fndecl2typ(fd);
  bool is_redecl = var_redecl_okay(ge, loc, v, t, sc, fd->attributes);
  // check that packed and aligned don't show up in the attributes
  for (_ atts = fd->attributes; atts != null; atts = atts->tl) {
    switch (atts->hd) {
    case Packed_att: fallthru;
    case &Aligned_att(_): 
      terr(loc,xprintf("bad attribute %s for function",
                       attribute2string(atts->hd)));
      break;
    default: break;
    }
  }
  // due to recursion, add function to environment before checking body
  ge->ordinaries = Dict::insert(ge->ordinaries, v,
				new $(new VarRes(new Funname_b(fd)),
                                      is_redecl));
  // DAN: Here is where I'm assuming the te can be imperatively screwed with
  //      while we're dealing with top-level stuff (though it's not too hard
  //      to undo that assumption)
  te->le = new Opt(new Outermost(new_fenv(loc,fd)));
  // check the body, then get rid of local environment
  Tcstmt::tcStmt(te,fd->body,false);
  // check for undefined labels FIX: get better error message
  if(!all_labels_resolved(te))
    terr(loc,"function has goto statements to undefined labels");

  te->le = null;
}

static void tcTypedefdecl(tenv_t te, genv_t ge, seg_t loc, typedefdecl_t td) {
  var_t v = (*td->name)[1];
#ifdef DEBUG
  fprintf(stderr,"type-checking typedefdecl %s",*v);
  fflush(stderr);
#endif
  // reject explicitly qualified name
  switch ((*td->name)[0]) {
  case &Rel_n(null): break;
  case &Abs_n(null): break; // allowed for top-level constants
  default:
    terr(loc,"qualified declarations are not implemented"); // FIX
    return;
  }
  // check for redeclaration (never allowed, apparently)
  if (Dict::member(ge->typedefs,v)) {
    terr(loc,xprintf("redeclaration of typedef %s",*v));
    return;
  }
  // expand to qualified name
  (*td->name)[0] = new Abs_n(te->ns);
  // reject ill-formed type
  check_unique_tvars(loc,td->tvs);
  check_type(loc,te,td->tvs,AnyKind,td->defn);
  // add to environment
  ge->typedefs = Dict::insert(ge->typedefs,v,td);
}

static void tcStructdecl(tenv_t te, genv_t ge, seg_t loc, structdecl_t sd) {
  // reject anonymous top-level
  if (sd->name == null) {
    terr(loc,"anonymous structs are not allowed at top level");
    return;
  }
  var_t        v   = (*sd->name->v)[1];
#ifdef DEBUG
  fprintf(stderr,"type-checking structdecl %s",*v);
  fflush(stderr);
#endif
  // only allow packed and aligned attributes
  for (_ atts = sd->attributes; atts != null; atts = atts->tl) {
    switch (atts->hd) {
    case Packed_att: continue;
    case &Aligned_att(_): continue;
    default: terr(loc,xprintf("bad attribute %s in struct %s definition",
                              attribute2string(atts->hd), *v));
    break;
    }
  }
  // disallow MemKinds and set unconstrained kinds to BoxKind
  for(_ tvs2 = sd->tvs; tvs2 != null; tvs2 = tvs2->tl) {
    let c = compress_conref(tvs2->hd->kind);
    switch (c->v) {
    case No_constr:
      c->v = new Eq_constr((kind_t)BoxKind); continue;
    case &Eq_constr(MemKind):
      terr(loc,xprintf("struct %s attempts to abstract type "
                       "variable %s of kind M",*v,
                       *tvs2->hd->name)); continue;
    default: continue;
    }
  }
  list_t<tvar_t> tvs = sd->tvs;
  // reject explicitly qualified name
  switch ((*sd->name->v)[0]) {
  case &Rel_n(null): break;
  case &Abs_n(null): break; // allowed for top-level constants
  default:
    terr(loc,"qualified declarations are not implemented"); // FIX
    return;
  }
  // expand to qualified name
  (*sd->name->v)[0] = new Abs_n(te->ns);
  // reject ill-formed type
  check_unique_tvars(loc,tvs);

  // redeclarations have to be handled differently
  switch (Dict::lookup_opt(ge->structdecls,v)) {
  case null:
    // add the declaration to the environment, then go check the fields
    ge->structdecls = Dict::insert(ge->structdecls, v, new sd);
    if(sd->fields == null) {
      return;
    }
    break;

  case &Opt(sdp): // a redeclaration
    let sd2  = *sdp;
    let tvs2 = sd2->tvs;
    // reject if different number of type variables or different kinds
    if(List::length(tvs) != List::length(tvs2))
      terr(loc,xprintf("redeclaration of struct %s "
		       "has a different number of type parameters", *v));
    let x1 = tvs;
    let x2 = tvs2;
    for (; x1 != null; x1 = x1->tl, x2=x2->tl) {
      let c1 = compress_conref(x1->hd->kind);
      let c2 = compress_conref(x2->hd->kind);
      // if the kind of the type variable is unconstrained, then set it to
      // the kind of in the previous declaration.
      if (c1->v == (constraint_t<kind_t>)No_constr && c1 != c2)
        c1->v = new Forward_constr(c2);
      // check that the kinds are the same
      if (conref_val(c1) != conref_val(c2))
        terr(loc,xprintf("redeclaration of struct %s has a different kind "
                         "(%s) for type parameter %s (%s)", *v, 
                         ckind2string(c1), *x1->hd->name, ckind2string(c2)));
    }
    // reject if scopes are inconsistent
    sd->sc = scope_redecl_okay(sd->sc, sd->fields, sd2->sc, sd2->fields,
			       loc, "struct", v);
    // now things really depend on which declarations have fields
    switch ($(sd->fields, sd2->fields)) {
    case $(null,null): return;
    case $(_,   null): *sdp = sd; break; // go check the fields below
    case $(null,_):    sd->fields = sd2->fields; sd->tvs = tvs; return;
    case $(_,   _):
      // both declare fields, so they must agree (with renaming w.r.t. tyvars)
      list_t<$(tvar_t,type_t)@> inst = null;
      for(let tvs0 = tvs; tvs0 != null; tvs0 = tvs0->tl, tvs2 = tvs2->tl)
	inst = new List(new $(tvs2->hd,new VarType(tvs0->hd)), inst);
      // check that attributes are the same
      if (!same_atts(sd->attributes, sd2->attributes)) 
        terr(loc,xprintf("redeclaration of struct %s has different attributes",
                         *v));
      // check each field under the map
      let f1s = sd->fields->v;
      let f2s = sd2->fields->v;
      for(; f1s != null && f2s != null; f1s = f1s->tl, f2s = f2s->tl) {
	let &Structfield(fn1,tq1,t1,width1,atts1) = f1s->hd;
	let &Structfield(fn2,tq2,t2,width2,atts2) = f2s->hd;
	// names, qualifiers, types, widths, and attributes all must agree
	if (String::zstrptrcmp(fn1,fn2) != 0)
	  terr(loc, xprintf("redeclaration of struct %s: field name mismatch "
			    "%s != %s", *v, *fn1, *fn2));
        if (!same_atts(atts1,atts2))
	  terr(loc, xprintf("redeclaration of struct %s: attribute mismatch on"
			    " field %s", *v, *fn1));
	if (!equal_tqual(tq1,tq2))
	  terr(loc, xprintf("redeclaration of struct %s: qualifier mismatch on"
			    " field %s", *v, *fn1));
        if (width1 != null && !Tcutil::is_const_exp(te,width1->v))
          terr(loc, xprintf("redeclaration of struct %s: bad bitfield %s",
                            *v, *fn1));
        else if ((width1 != null && width2 != null && 
                  Evexp::eval_const_uint_exp(width1->v) != 
                  Evexp::eval_const_uint_exp(width2->v)) ||
                 width1 != width2)
          terr(loc, xprintf("redeclaration of struct %s: bitfield mismatch on"
                            " field %s", *v, *fn1));
	// important side-effects on t1
	check_type(loc, te, tvs, MemKind, t1);
	type_t subst_t2 = substitute(inst,t2);
	if(!unify(t1,subst_t2)) // FIX: unify definitely seems wrong here
	  terr(loc,xprintf("redeclaration of struct %s: type mismatch on field"
			   " %s: %s != %s", *v, *fn1,
			   typ2string(t1), typ2string(subst_t2)));
      }
      // check for field-number mismatch
      if (f2s != null)
	terr(loc,xprintf("redeclaration of struct %s is missing field %s",
			 *v, *(f2s->hd->name)));
      if (f1s != null)
	terr(loc,xprintf("redeclaration of struct %s has extra field %s",
			 *v, *(f1s->hd->name)));
      return;
    }
    break;
  }
  // This is the first declaration with fields, so check the fields
  // may not be the first declaration, so must not overwrite the dict
  // entry!
  // for the sake of recursive fields, make name abstract in body
  let sdp = Dict::lookup(ge->structdecls, v);
  *sdp = new Structdecl(sd->sc, sd->name, tvs, null, null);
  // check fields, rejecting ill-formed types, bad fields, and duplicates
  // (unless the field name is empty)
  list_t<field_name_t> prev_fields = null;
  for (let fs = sd->fields->v; fs != null; fs = fs->tl) {
    let &Structfield(fn,tq,t,width,atts) = fs->hd;
    if (List::mem(String::zstrptrcmp,prev_fields,fn))
	terr(loc,xprintf("duplicate field %s in struct",*fn));
    // add the field to previous fields only if it's not an empty name
    // (empty names arise for bitfield padding.)
    if (String::strcmp(*fn,"") != 0)
      prev_fields = new List(fn,prev_fields);
    check_type(loc,te,tvs,MemKind,t);
    // if width is non-null then t must be of integral type
    if (width != null) {
      unsigned int w = 0;
      if (!Tcutil::is_const_exp(te,width->v))
        terr(loc,xprintf("bitfield %s does not have constant width",*fn));
      else w = Evexp::eval_const_uint_exp(width->v);
      switch (compress(t)) {
      case &IntType(_,b): 
        switch (b) {
        case B1:
          if (w > 8) terr(loc,"bitfield larger than type");
          break;
        case B2:
          if (w > 16) terr(loc,"bitfield larger than type");
          break;
        case B4:
          if (w > 32) terr(loc,"bitfield larger than type");
          break;
        case B8:
          if (w > 64) terr(loc,"bitfield larger than type");
          break;
        }
        break;
      default: 
        terr(loc,xprintf("bitfield %s must have integral type but "
                         "has type %s",*fn,typ2string(t)));
        break;
      }
    }
    // check that we have only packed or aligned attributes
    for (; atts != null; atts = atts->tl) {
      switch (atts->hd) {
      case Packed_att: continue;
      case &Aligned_att(_): continue;
      default: terr(loc,xprintf("bad attribute %s in struct %s, member %s",
                                attribute2string(atts->hd), *v, *fn));
      break;
                                
      }
    }
    // FIX: check for consistent tquals?
  }
  // add the constructor to the environment
  ge->ordinaries = Dict::insert(ge->ordinaries,  v,
				new $(new StructRes(sd), true));
  // undo our clobbering with the abstract version
  *sdp = sd;
}

// FIX: this code is almost exactly the same as tcStructdecl
static void tcUniondecl(tenv_t te, genv_t ge, seg_t loc, uniondecl_t ud) {
  // reject anonymous top-level
  if (ud->name == null) {
    terr(loc,"anonymous unions are not allowed at top level");
    return;
  }
  var_t v = (*ud->name->v)[1];
#ifdef DEBUG
  fprintf(stderr,"type-checking uniondecl %s",*v);
  fflush(stderr);
#endif
  // only allow packed and aligned attributes
  for (_ atts = ud->attributes; atts != null; atts = atts->tl) {
    switch (atts->hd) {
    case Packed_att: continue;
    case &Aligned_att(_): continue;
    default: terr(loc,xprintf("bad attribute %s in union %s definition",
                              attribute2string(atts->hd), *v));
    break;
    }
  }
  // disallow MemKinds and set unconstrained kinds to BoxKind
  for(_ tvs2 = ud->tvs; tvs2 != null; tvs2 = tvs2->tl) {
    let c = compress_conref(tvs2->hd->kind);
    switch (c->v) {
    case No_constr:
      c->v = new Eq_constr((kind_t)BoxKind); continue;
    case &Eq_constr(MemKind):
      terr(loc,xprintf("union %s attempts to abstract type "
                       "variable %s of kind M",*v,
                       *tvs2->hd->name)); continue;
    default: continue;
    }
  }
  list_t<tvar_t> tvs = ud->tvs;
  // reject explicitly qualified name
  switch ((*ud->name->v)[0]) {
  case &Rel_n(null): break;
  case &Abs_n(null): break; // allowed for top-level constants
  default:
    terr(loc,"qualified declarations are not implemented"); // FIX
    return;
  }
  // expand to qualified name
  (*ud->name->v)[0] = new Abs_n(te->ns);
  // reject ill-formed type
  check_unique_tvars(loc,tvs);

  // redeclarations have to be handled differently
  switch (Dict::lookup_opt(ge->uniondecls,v)) {
  case null:
    // add the declaration to the environment, then go check the fields
    ge->uniondecls = Dict::insert(ge->uniondecls, v, new ud);
    if(ud->fields == null) {
      return;
    }
    break;

  case &Opt(udp): // a redeclaration
    let ud2  = *udp;
    let tvs2 = ud2->tvs;
    // reject if different number of type variables or different kinds
    if(List::length(tvs) != List::length(tvs2))
      terr(loc,xprintf("redeclaration of union %s "
		       "has a different number of type parameters", *v));
    let x1 = tvs;
    let x2 = tvs2;
    for (; x1 != null; x1 = x1->tl, x2=x2->tl) {
      let c1 = compress_conref(x1->hd->kind);
      let c2 = compress_conref(x2->hd->kind);
      // if the kind of the type variable is unconstrained, then set it to
      // the kind of in the previous declaration.
      if (c1->v == (constraint_t<kind_t>)No_constr && c1 != c2)
        c1->v = new Forward_constr(c2);
      // check that the kinds are the same
      if (conref_val(c1) != conref_val(c2))
        terr(loc,xprintf("redeclaration of union %s has a different kind "
                         "(%s) for type parameter %s (%s)", *v, 
                         ckind2string(c1), *x1->hd->name, ckind2string(c2)));
    }
    // reject if scopes are inconsistent
    ud->sc = scope_redecl_okay(ud->sc, ud->fields, ud2->sc, ud2->fields,
			       loc, "union", v);
    // now things really depend on which declarations have fields
    switch ($(ud->fields, ud2->fields)) {
    case $(null,null): return;
    case $(_,   null): *udp = ud; break; // go check the fields below
    case $(null,_):    ud->fields = ud2->fields; ud->tvs = tvs; return;
    case $(_,   _):
      // both declare fields, so they must agree (with renaming w.r.t. tyvars)
      list_t<$(tvar_t,type_t)@> inst = null;
      for(let tvs0 = tvs; tvs0 != null; tvs0 = tvs0->tl, tvs2 = tvs2->tl)
	inst = new List(new $(tvs2->hd,new VarType(tvs0->hd)), inst);
      // check that attributes are the same
      if (!same_atts(ud->attributes, ud2->attributes)) 
        terr(loc,xprintf("redeclaration of union %s has different attributes",
                         *v));
      // check each field under the map
      let f1s = ud->fields->v;
      let f2s = ud2->fields->v;
      for(; f1s != null && f2s != null; f1s = f1s->tl, f2s = f2s->tl) {
	let &Structfield(fn1,tq1,t1,width1,atts1) = f1s->hd;
	let &Structfield(fn2,tq2,t2,width2,atts2) = f2s->hd;
	// names, qualifiers, types, and attributes all must agree
	if (String::zstrptrcmp(fn1,fn2) != 0)
	  terr(loc, xprintf("redeclaration of union %s: field name mismatch "
			    "%s != %s", *v, *fn1, *fn2));
        if (!same_atts(atts1,atts2))
	  terr(loc, xprintf("redeclaration of union %s: attribute mismatch on"
			    " field %s", *v, *fn1));
	if (!equal_tqual(tq1,tq2))
	  terr(loc, xprintf("redeclaration of union %s: qualifier mismatch on"
			    " field %s", *v, *fn1));
        if (width1 != null && !Tcutil::is_const_exp(te,width1->v))
          terr(loc, xprintf("redeclaration of struct %s: bad bitfield %s",
                            *v, *fn1));
        else if ((width1 != null && width2 != null && 
                  Evexp::eval_const_uint_exp(width1->v) != 
                  Evexp::eval_const_uint_exp(width2->v)) ||
                 width1 != width2)
          terr(loc, xprintf("redeclaration of struct %s: bitfield mismatch on"
                            " field %s", *v, *fn1));
	// important side-effects on t1
	check_type(loc, te, tvs, MemKind, t1);
	type_t subst_t2 = substitute(inst,t2);
	if(!unify(t1,subst_t2)) // FIX: unify definitely seems wrong here
	  terr(loc,xprintf("redeclaration of union %s: type mismatch on field"
			   " %s: %s != %s", *v, *fn1,
			   typ2string(t1), typ2string(subst_t2)));
      }
      // check for field-number mismatch
      if (f2s != null)
	terr(loc,xprintf("redeclaration of union %s is missing field %s",
			 *v, *(f2s->hd->name)));
      if (f1s != null)
	terr(loc,xprintf("redeclaration of union %s has extra field %s",
			 *v, *(f1s->hd->name)));
      return;
    }
    break;
  }
  // This is the first declaration with fields, so check the fields
  // may not be the first declaration, so must not overwrite the dict
  // entry!
  // for the sake of recursive fields, make name abstract in body
  let udp = Dict::lookup(ge->uniondecls, v);
  *udp = new Uniondecl(ud->sc, ud->name, tvs, null, null);
  // check fields, rejecting ill-formed types, bad fields, and duplicates
  list_t<field_name_t> prev_fields = null;
  list_t<type_t> prev_types = null;
  for (let fs = ud->fields->v; fs != null; fs = fs->tl) {
    let &Structfield(fn,tq,t,width,atts) = fs->hd;
    if (List::mem(String::zstrptrcmp,prev_fields,fn))
	terr(loc,xprintf("duplicate field %s in union",*fn));
    prev_fields = new List(fn,prev_fields);
    check_type(loc,te,tvs,MemKind,t);
    // if width is non-null then t must be of integral type
    if (width != null) {
      unsigned int w = 0;
      if (!Tcutil::is_const_exp(te,width->v))
        terr(loc,xprintf("bitfield %s does not have constant width",*fn));
      else w = Evexp::eval_const_uint_exp(width->v);
      switch (compress(t)) {
      case &IntType(_,b): 
        switch (b) {
        case B1:
          if (w > 8) terr(loc,"bitfield larger than type");
          break;
        case B2:
          if (w > 16) terr(loc,"bitfield larger than type");
          break;
        case B4:
          if (w > 32) terr(loc,"bitfield larger than type");
          break;
        case B8:
          if (w > 64) terr(loc,"bitfield larger than type");
          break;
        }
        break;
      default: 
        terr(loc,xprintf("bitfield %s must have integral type but "
                         "has type %s",*fn,typ2string(t)));
        break;
      }
    }
    // check that the type t only consists of "bits" -- later we may
    // want to allow a more permissive form of unions.
    if (!bits_only(t))
      terr(loc,xprintf("%s has a type that is possibly incompatible with "
                       "other members of union %s",*fn,*v));
    // check that we have only packed or aligned attributes
    for (; atts != null; atts = atts->tl) {
      switch (atts->hd) {
      case Packed_att: continue;
      case &Aligned_att(_): continue;
      default: terr(loc,xprintf("bad attribute %s in union %s, member %s",
                                attribute2string(atts->hd), *v, *fn));
      break;
                                
      }
    }
    // FIX: check for consistent tquals?
  }
  // undo our clobbering with the abstract version
  *udp = ud;
}


static void tcTuniondecl(tenv_t te, genv_t ge, seg_t loc, tuniondecl_t ed) {
  // reject anonymous top-level
  if (ed->name == null) {
    terr(loc,"anonymous tunions are not allowed");
    return;
  }
  var_t        v   = (*ed->name->v)[1];
#ifdef DEBUG
  fprintf(stderr,"type-checking tuniondecl %s",*v);
  fflush(stderr);
#endif
  list_t<tvar_t> tvs = ed->tvs;
  // disallow MemKinds and set unconstrained kinds to BoxKind
  for(_ tvs2 = tvs; tvs2 != null; tvs2 = tvs2->tl) {
    conref_t<kind_t> c = compress_conref(tvs2->hd->kind);
    switch (c->v) {
    case No_constr: c->v = new Eq_constr((kind_t)BoxKind); break;
    case &Eq_constr(MemKind): 
      terr(loc,xprintf("tunion %s attempts to abstract type "
                       "variable %s of kind M",*v,*tvs2->hd->name)); break;
    default: break;
    }
  }
  // reject explicitly qualified name
  switch ((*ed->name->v)[0]) {
  case &Rel_n(null): break;
  case &Abs_n(null): break; // allowed for top-level constants
  default:
    terr(loc,"qualified declarations are not implemented"); // FIX
    return;
  }
  // expand to qualified name
  (*ed->name->v)[0] = new Abs_n(te->ns);
  // reject ill-formed type
  check_unique_tvars(loc,tvs);

  // redeclarations have to be handled differently
  // check for redeclaration
  switch (Dict::lookup_opt(ge->tuniondecls, v)) {
  case null:
    // add the declaration to the environment, then go check the fields
    ge->tuniondecls = Dict::insert(ge->tuniondecls, v, new ed);
    if(ed->fields == null) {
      return;
    }
    break;

  case &Opt(edp):
    let ed2  = *edp;
    let tvs2 = ed2->tvs;
    // reject if type-arity is different or kinds are different
    if(List::length(tvs) != List::length(tvs2))
      terr(loc,xprintf("redeclaration of tunion %s "
		       "has a different number of type parameters", *v));
    let x1 = tvs;
    let x2 = tvs2;
    for (; x1 != null; x1 = x1->tl, x2=x2->tl) {
      let c1 = compress_conref(x1->hd->kind);
      let c2 = compress_conref(x2->hd->kind);
      if (c1->v == (constraint_t<kind_t>)No_constr && c1 != c2)
        c1->v = new Forward_constr(c2);
      if (conref_val(c1)  != conref_val(c2))
        terr(loc,xprintf("redeclaration of tunion %s has a different kind "
                         "(%s) for type parameter %s (%s)", *v, 
                         ckind2string(c1), *x1->hd->name, ckind2string(c2)));
    }

    // reject if scopes are different
    ed->sc = scope_redecl_okay(ed->sc, ed->fields, ed2->sc, ed2->fields,
			       loc, "tunion", v);
    // now things really depend on which declarations have fields
    switch ($(ed->fields, ed2->fields)) {
    case $(null,null): return;
    case $(_,   null): *edp = ed; break; // go check the fields below
    case $(null,_):    ed->fields = ed2->fields; ed->tvs = tvs2; return;
    case $(_,   _):
      // both declare fields, so they must agree (with renaming w.r.t. tyvars)
      // FIX: check the kinds match up?
      list_t<$(tvar_t,type_t)@> inst = null;
      for(let tvs0 = tvs; tvs0 != null; tvs0 = tvs0->tl, tvs2 = tvs2->tl)
	inst = new List(new $(tvs2->hd,new VarType(tvs0->hd)), inst);
      // check each field under the map
      let f1s = ed->fields->v;
      let f2s = ed2->fields->v;
      // the types in f1 haven't been checked yet, which does important
      // side effects

      for (; f1s != null && f2s != null; f1s = f1s->tl, f2s = f2s->tl) {
	(*f1s->hd->name)[0] = new Abs_n(te->ns);
	// check f1s->hd types for the important side effects
	list_t<tvar_t> alltvs = List::append(tvs, f1s->hd->tvs);
	check_unique_tvars(f1s->hd->loc,alltvs);
	for(let typs = f1s->hd->typs; typs != null; typs = typs->tl) {
          let t = (*typs->hd)[1];
	  check_type(f1s->hd->loc,te,alltvs,MemKind,t);
	}
	// now we can check against previous definition of field
	field_redecl_okay(f1s->hd, f2s->hd, inst, te, "tunion", v);
      }
      // check for field-number mismatch
      if (f1s != null)
	terr(loc,xprintf("redeclaration of tunion %s has extra field %s",
			 *v, *((*f1s->hd->name)[1])));
      if (f2s != null)
	terr(loc,xprintf("redeclaration of tunion %s is missing field %s",
			 *v, *((*f2s->hd->name)[1])));
      return;
    }
    break;
  }
  // This is the first declaration with variants, so check the variants
  // may not be the first declaration, so must not overwrite the dict
  // entry!
  // for the sake of recursive fields, make name abstract in body
  let edp = Dict::lookup(ge->tuniondecls, v);
  *edp = new Tuniondecl(ed->sc, ed->name, tvs, null);
  // check variants, rejecting ill-formed types, non-constant tags,
  // repeated tyvars (why?), and duplicate field names
  // finally, add variants
  list_t<field_name_t> prev_fields = null;
  for(let fs = ed->fields->v; fs != null; fs = fs->tl) {
    let f = fs->hd;
    if (List::mem(String::zstrptrcmp,prev_fields,(*f->name)[1]))
      terr(f->loc,xprintf("duplicate field name %s",*((*f->name)[1])));
    prev_fields = new List((*f->name)[1],prev_fields);
    for (_ tvs = f->tvs; tvs != null; tvs = tvs->tl) {
      let tv = tvs->hd;
      let c = compress_conref(tv->kind);
      switch (c->v) {
      case No_constr: c->v = new Eq_constr((kind_t)BoxKind); break;
      case &Eq_constr(MemKind): 
        terr(loc,xprintf("field %s abstracts type variable of "
                         "kind M", *(*f->name)[1])); break;
      // FIX:  should we allow existentials over regions or effects?
      default: break;
      }
    }
    list_t<tvar_t> alltvs = List::append(tvs,f->tvs);
    check_unique_tvars(loc,alltvs);
    for (list_t<$(tqual_t,type_t)@> typs = f->typs; typs != null; typs=typs->tl) {
      let t = (*typs->hd)[1];
      check_type(f->loc,te,alltvs,MemKind,t);
    }
    // FIX: check valid tquals?
    (*f->name)[0] = new Abs_n(te->ns);
    ge->ordinaries = Dict::insert(ge->ordinaries, (*f->name)[1],
				  new $(new TunionRes(ed,f), true));
  }
  // add the decl to the environment -- must be after variant-checking
  // (where we added an abstract version)
  ge->tuniondecls = Dict::insert(ge->tuniondecls, v, new ed);
  // undo our clobbering with the abstract version
  *edp = ed;
}

static void tcXTuniondecl(tenv_t te, genv_t ge, seg_t loc, xtuniondecl_t xd) {
  var_t v = (*xd->name)[1];
#ifdef DEBUG
  fprintf(stderr,"type-checking xtuniondecl %s",*v);
  fflush(stderr);
#endif
  opt_t<xtuniondecl_t@> xd2o;
  try xd2o = lookup_xtuniondecl(te,loc,xd->name);
  catch { case &Dict::Absent:
    terr(loc,
         xprintf("qualified xtunion declaration %s is not an existing xtunion",
                 qvar2string(xd->name)));
    return;
  }
  // expand to qualified name, if not already qualified
  switch ((*xd->name)[0]) {
  case Loc_n:
    throw new Impossible("tcXTuniondecl: Loc_n");
  case &Rel_n(null):
    (*xd->name)[0] = new Abs_n(te->ns);
    break;
  case &Rel_n(_):
    throw new Impossible("tcXTuniondecl: Rel_n non-null");
  case &Abs_n(_):
    throw new Impossible("tcXTuniondecl: Abs_n");
  }
  // if we're a new xtunion, then make a fresh "already there" xtuniondecl
  //       and add it to the environment
  // if we're not new, compare scopes
  if(xd2o == null) {
    xtuniondecl_t @ x = 
      (xtuniondecl_t@)(new $(new XTuniondecl{.sc=xd->sc,
                                             .name=xd->name,
                                             .fields=null}));
    xd2o = new Opt(x);
    ge->xtuniondecls = Dict::insert(ge->xtuniondecls, v, x);
  } else {
    let x = *(xd2o->v);
    x->sc = scope_redecl_okay(xd->sc, new Opt(0), 
                              x->sc, new Opt(0), loc, "xtunion", v);
  }
  // now check that we can add each "field" by ensuring that
  // duplicates are the same.  Note that fields are qualified by the current
  // namespace if implicit, not the namespace of the xtunion
  // Notice that we're "hoisting" the fields into the earlier definition,
  // if there is one we know about.
  xtuniondecl_t xd_result = *(xd2o->v);
  for(list_t<tunionfield_t> fs = xd->fields; fs != null; fs = fs->tl) {
    tunionfield_t f = fs->hd;
    // expand field name if not explicitly qualified
    switch ((*f->name)[0]) {
    case &Rel_n(null): (*f->name)[0] = new Abs_n(te->ns); break;
    case &Rel_n(_): fallthru;
    case &Abs_n(_):
      terr(loc,"qualified declarations are not allowed\n");
      break;
    case Loc_n:
      throw new Impossible("tcXtuniondecl: Loc_n");
      break;
    }
    // reject if there is an ill-formed type
    for (_ tvs = f->tvs; tvs != null; tvs = tvs->tl) {
      let tv = tvs->hd;
      let c = compress_conref(tv->kind);
      switch (c->v) {
      case No_constr: c->v = new Eq_constr((kind_t)BoxKind); break;
      case &Eq_constr(MemKind): 
        terr(loc,xprintf("field %s abstracts type variable of "
                         "kind M", *(*f->name)[1])); break;
      // FIX: should we allow existentials over regions and effects?
      default: break;
      }
    }
    list_t<tvar_t>tvs = f->tvs;
    check_unique_tvars(loc,tvs);
    for(let typs = f->typs; typs != null; typs = typs->tl) {
      let t = (*typs->hd)[1];
      check_type(f->loc,te,tvs,MemKind,t);
    }
    // notice we now allow duplicates, they just have to have the same type
    // also, we can be totally re-ordered from a different declaration
    bool dup = false;
    for(let prev_fs = xd_result->fields; prev_fs!=null; prev_fs = prev_fs->tl){
      let prev = prev_fs->hd;
      if(qvar_cmp(f->name, prev->name)==0) {
	field_redecl_okay(prev, f, null, te, "xtunion", v);
	// do not add the duplicate to the result:
	dup = true;
	break;
      }
    }
    if(dup)
      continue;
    // no duplicate, so add to the result
    xd_result->fields = new List(f, xd_result->fields);
    // notice we allow adding to another namespace via qualified field
    genv_t ge_f;
    list_t<var_t> ns_f;
    switch ((*f->name)[0]) {
    case &Abs_n(y): ns_f = y; break;
    case Loc_n: fallthru;
    case &Rel_n(_):
      throw new Impossible("tcXTuniondecl: Rel_n or Loc_n");
      break;
    }
    try ge_f = Dict::lookup(te->ae, ns_f);
    catch { case &Dict::Absent:
      terr(f->loc, xprintf("bad namespace for xtunion field %s",
			   qvar2string(f->name)));
      return;
    }
    ge_f->ordinaries = Dict::insert(ge_f->ordinaries, (*f->name)[1],
				    new $(new XTunionRes(xd_result, f), true));
  }
}

static void tcEnumdecl(tenv_t te, genv_t ge, seg_t loc, enumdecl_t ed) {
  var_t v = (*ed->name)[1];
#ifdef DEBUG
  fprintf(stderr,"type-checking enumdecl %s",*v);
  fflush(stderr);
#endif
  // reject explicitly qualified name
  switch ((*ed->name)[0]) {
  case &Rel_n(null): break;
  case &Abs_n(null): break; // allowed for top-level constants
  default:
    terr(loc,"qualified declarations are not implemented"); // FIX
    return;
  }
  // expand to qualified name
  (*ed->name)[0] = new Abs_n(te->ns);
  switch (Dict::lookup_opt(ge->enumdecls, v)) {
  case null:
    // go check the fields
    ge->enumdecls = Dict::insert(ge->enumdecls, v, new ed);
    break;
  case &Opt(edp):
    let ed2 = *edp;
    // reject if scopes are different
    ed->sc = scope_redecl_okay(ed->sc, null, ed2->sc, null, loc, "enum", v);
    let f1s = ed->fields;
    let f2s = ed2->fields;
    unsigned int tag_count = 0;
    for (; f1s != null && f2s != null; f1s = f1s->tl, f2s = f2s->tl) {
      let &Enumfield{n1,*tag1p,loc1} = f1s->hd;
      let &Enumfield{n2,tag2,loc2} = f2s->hd;
      (*n1)[0] = new Abs_n(te->ns);
      // names and tags must agree
      if (String::zstrptrcmp((*n1)[1],(*n2)[1]) != 0)
        terr(loc, xprintf("redeclaration of enum %s: field name mismatch "
                          "%s != %s", *v, *(*n1)[1], *(*n2)[1]));
      if (*tag1p == null)
        *tag1p = uint_exp(tag_count,loc1);
      else if (!Tcutil::is_const_exp(te,(exp_t)*tag1p))
        terr(loc,xprintf("redeclaration of enum %s, field %s: " 
                         "expression is not constant",*v,*(*n1)[1]));
      unsigned int t1 = Evexp::eval_const_uint_exp((exp_t)*tag1p);
      tag_count = t1 + 1;
      if (t1 != Evexp::eval_const_uint_exp((exp_t)tag2))
        terr(loc,xprintf("redeclaration of enum %s, field %s, value mismatch",
                         *v,*(*n1)[1]));
    }
    return;
  }
  // This is the first declaration so check that it's well-formed.
  list_t<field_name_t> prev_fields = null;
  unsigned int tag_count = 0;
  for (_ fs = ed->fields; fs != null; fs = fs->tl) {
    let f = fs->hd;
    if (List::mem(String::zstrptrcmp,prev_fields,(*f->name)[1]))
      terr(f->loc,xprintf("duplicate field name %s",*((*f->name)[1])));
    prev_fields = new List((*f->name)[1],prev_fields);
    if (f->tag == null)
      f->tag = uint_exp(tag_count,f->loc);
    else if (!Tcutil::is_const_exp(te,(exp_t)f->tag))
      terr(loc,xprintf("enum %s, field %s: expression is not constant",
                       *v,*(*f->name)[1]));
    unsigned int t1 = Evexp::eval_const_uint_exp((exp_t)f->tag);
    tag_count = t1+1;
    (*f->name)[0] = new Abs_n(te->ns);
    ge->ordinaries = Dict::insert(ge->ordinaries, (*f->name)[1],
                                  new $(new EnumRes(ed,f), true));
  }
  ge->enumdecls = Dict::insert(ge->enumdecls, v, new ed);
}

static bool okay_externC(seg_t loc, scope_t sc) {
  switch (sc) {
  case Static:
    warn(loc,"static declaration nested within extern \"C\"");
    return false;
  case Abstract:
    warn(loc,"abstract declaration nested within extern \"C\"");
    return false;
  case Public: return true;
  case Extern:
    // warn(loc,"converting extern declaration to extern \"C\"");
    return true;
  case ExternC:
    warn(loc,"nested extern \"C\" declaration");
    return true;
  }
}

// Typecheck a list, ds, of declarations in environment te.
// As a side effect, all declarations and variable references are made
// absolute, so later passes just recurse through namespace and using
// New: a second pass shakes out unnecessary vardecls.
// FIX: shake out type definitions too.
static void tc_decls(tenv_t te, list_t<decl_t> ds0, bool in_externC) {

  genv_t ge = Dict::lookup(te->ae,te->ns); // no longer a copy!!!

  for (let ds = ds0; ds != null; ds = ds->tl) {
    decl_t    d   = ds->hd;
    seg_t loc = d->loc;

    switch (d->r) {
    case &Let_d(_,_,_,_,_): // FIX
      terr(loc,"top level let-declarations are not implemented");
      break;
    case &Var_d(vd):
      if (in_externC && okay_externC(d->loc,vd->sc))
	vd->sc = ExternC;
      tcVardecl(te,ge,loc,vd);
      break;
    case &Fn_d(fd):
      if (in_externC && okay_externC(d->loc,fd->sc))
	fd->sc = ExternC;
      tcFndecl(te,ge,loc,fd);
      break;
    case &Typedef_d(td):
      tcTypedefdecl(te,ge,loc,td);
      break;
    case &Struct_d(sd):
      if (in_externC && okay_externC(d->loc,sd->sc))
	sd->sc = ExternC;
      tcStructdecl(te,ge,loc,sd);
      break;
    case &Union_d(ud):
      if (in_externC && okay_externC(d->loc,ud->sc))
        ud->sc = ExternC;
      tcUniondecl(te,ge,loc,ud);
      break;
    case &Tunion_d(ed):
      if (in_externC && okay_externC(d->loc,ed->sc))
	ed->sc = ExternC;
      tcTuniondecl(te,ge,loc,ed);
      break;
    case &XTunion_d(xd):
      if (in_externC && okay_externC(d->loc,xd->sc))
	xd->sc = ExternC;
      tcXTuniondecl(te,ge,loc,xd);
      break;

    case &Enum_d(ed):
      if (in_externC && okay_externC(d->loc,ed->sc))
        ed->sc = ExternC;
      tcEnumdecl(te,ge,loc,ed);
      break;

    case &Namespace_d(v,ds2):
      // DAN: This case is much more imperative than it used to be.
      let ns  = te->ns;
      let ns2 = List::append(ns,new List(v,null));
      // Make sure namespace v has been declared in the current namespace
      if (!Set::member(ge->namespaces,v)) {
        ge->namespaces = Set::insert(ge->namespaces,v);
	te->ae = Dict::insert(te->ae, ns2, empty_genv());
      }
      // Do the nested declarations then restore the namespace
      te->ns = ns2;
      tc_decls(te,ds2,in_externC);
      te->ns = ns;
      break;

    case &Using_d(&$(nsl,v),ds2):
      // DAN: We're more imperative here too.
      var_t first;
      list_t<var_t> rest;
      switch (nsl) {
      case Loc_n:       fallthru;
      case &Rel_n(null): fallthru;
      case &Abs_n(null):
        first = v; rest = null; break;
      case &Rel_n(&List(x,y)): fallthru(x,y);
      case &Abs_n(&List(x,y)):
        first = x; rest = List::append(y,new List(v,null)); break;
      }
      let ns2 = resolve_namespace(te,loc,first,rest);
      ge->availables = new List(ns2,ge->availables);
      tc_decls(te,ds2,in_externC);
      ge->availables = ge->availables->tl;
      break;

    case &ExternC_d(ds2):
      tc_decls(te,ds2,true);
      break;
    }
  }
}

static string cyc_string = "Cyc";
static stringptr cyc_ns = &cyc_string;

void tc(tenv_t te, bool add_cyc_namespace, list_t<decl_t> ds) {
  if (add_cyc_namespace)
    // wrap an implicit "namespace Cyc" around the declarations
    ds = new List(new Decl{new Namespace_d(cyc_ns,ds),null},null);

  tc_decls(te,ds,false);
}

// for tree-shaking (so we don't include the world)
// Note: We must shake after all type-checking or we'll be too eager.
// Note: All names should now be absolute.

// We recompute the global environment and delete what's not needed anymore
// all would be far easier if Dict has a delete function :-)

// for each namespace, we have the environment and a list of what has to be removed in it
typedef Dict::dict_t<list_t<var_t>, $(genv_t, Set::set_t<var_t>) @> treeshake_env_t;

static bool vardecl_needed(treeshake_env_t env, decl_t d);

static list_t<decl_t> treeshake_f(treeshake_env_t env, list_t<decl_t> ds) {
  return List::filter_c(vardecl_needed, env, ds);
}

static bool vardecl_needed(treeshake_env_t env, decl_t d) {
  switch(d->r) {
  case &Var_d(vd):
    // get rid of externs that are never referenced
    if(vd->sc != Extern)
      return true;
    let &$(nsl,name) = vd->name;
    list_t<var_t> ns;
    switch (nsl) {
    case Loc_n:    ns = null; break;
    case &Rel_n(y): ns = y; break;
    case &Abs_n(y): ns = y; break;
    }
    let nsenv = Dict::lookup(env,ns);
    let ge = (*nsenv)[0];
    let needed = (*Dict::lookup(ge->ordinaries,name))[1];
    if (! needed) {
      (*nsenv)[1] = Set::insert((*nsenv)[1], name); // we'll remove it later from ge->ordinaries
    }
    return needed;
  case &Using_d(_,*ds2p): fallthru(ds2p);
  case &Namespace_d(_,*ds2p):
    *ds2p = treeshake_f(env,*ds2p);
    return true;
  default: return true;
  }
}

// Mathieu : all this would be really nicer if we had local functions...
static bool treeshake_remove_f(Set::set_t<var_t> set, var_t x, _ y) {
  return !Set::member(set, x);
}

static void treeshake_remove(list_t<var_t> ns, $(genv_t, Set::set_t<var_t>) @ nsenv) {
  let ge = (*nsenv)[0];
  let set = (*nsenv)[1];
  ge->ordinaries = Dict::filter_c(treeshake_remove_f, set, ge->ordinaries);
}
			     			     
static $(genv_t, Set::set_t<var_t>)@ treeshake_make_env_f(genv_t ge) {
  return new $(ge, Set::empty(String::strptrcmp));
}

list_t<decl_t> treeshake(tenv_t te, list_t<decl_t> ds) {
  let env = Dict::map(treeshake_make_env_f, te->ae);
  let ds1 = treeshake_f(env, ds);
  
  Dict::iter(treeshake_remove, env); // update the global environment

  return ds1;
}
