// A pass over the code, after type-checking that:
// * Ensures variables (and local-aggregate fields) 
//   are defined before they are used
// * Ensures goto does not enter a declaration or exception handler
// * Ensures non-void functions return
// * Ensures cases do not implicitly fall-through

// Assumes that type-checking (the previous pass) has:
// * Done all of its checks (documented elsewhere)
// * Resolved all variables to their correct bindings
// * Decorated all exp things with their correct type
// * Decorated all stmts with their correct non_local_preds
//   (and filled in the correct field for jumpers to their destination)
// * The annot field of statements is properly initialized.
//   (Of course, this step could be a trivial walk to find all the
//    statements and initialize this field.)
// * Set the "enclosing decl or try"
//   field on statements that we use to do "goto doesn't enter"
//   WARNING: The implicit list ends with a self-loop, not a null.

// NOTE: The fact that we don't have to iterate and annotate w.r.t.
//       expressions is a result of definite assignment being
//       monotonic.  We'll need expression annotations to do null-check
//       warning correctly w.r.t. undefined evaluation order.  It will be
//       interesting to see how well such expression munging scales.
//       Alertnately, we'll do something more conservative for obfuscated
//       expressions, eg., one that assigns a variable null in the "middle".

#include "core.h"
#include "list.h"
#include "set.h"
#include "dict.h"
#include "string.h"
#include "absyn.h"
#include "absynpp.h"
#include "tcutil.h"
#include "evexp.h"
#include "control_flow.h"

using Core;
using List;
using Absyn;
using Absynpp;
using Tcutil;

namespace ControlFlow;

typedef vardecl             vardecl_t;
typedef field_name          field_name_t;
typedef Set::set_t<`a>      set_t<`a>;
typedef Dict::dict_t<`a,`b> dict_t<`a,`b>;

// The set of variables that may be unassigned.
// Note we exploit that vardecls are shared -- we use pointer equality
// to compare fields of this type.
// Note we could treat a simple var as a one-field thing, but it seems
// worth special-casing (more intuitive and more efficient)
// FIX: Would be better to tie the knot so we can allow nested structs
//      and tuples.  (The question is how this interacts with pointers
//      which are the real issue.)  Probably suffices to just make the codomain
//      a set of list of "int or field_name".
static struct FlowInfo {
  set_t<vardecl_t>                     simples; // vars are uninitialized
  dict_t<vardecl_t, set_t<int>>        tuples;  // codomain is uninitialized
  dict_t<vardecl_t, set_t<field_name>> structs; // codomain is uninitialized
};
typedef struct FlowInfo flow_info_t; // NOT a pointer!!!

static struct Tqual     bogus_tqual     = Tqual(false,false,false);
static string           empty_string    = "";
static $(enum Nmspace,var) bogus_qvar   = $(Abs_n(null),&empty_string);
static struct Vardecl   bogus_vardecl_v = Vardecl(Public, &bogus_qvar,
						  &bogus_tqual, VoidType, null,
						  0, null);
static vardecl_t bogus_vardecl = &bogus_vardecl_v;


static flow_info_t * empty_flow_info = null;

static flow_info_t empty_flow() {
  if(empty_flow_info == null)
    empty_flow_info = &FlowInfo(Set::empty(ptrcmp), 
				Dict::empty(ptrcmp),
				Dict::empty(ptrcmp));
  return *empty_flow_info;
}

// There's exactly a 50% chance I've named merge and meet correctly. :-)
// WARNING: You can try to do all this with a lot less allocation (of sets
//  and dicts) or with less live space (with bit vectors), but the code gets
//  a lot muckier.  Let's hope this stuff is fast enough in practice.
static flow_info_t merge_flow(flow_info_t f1, flow_info_t f2) {
  return FlowInfo(Set::union_two(f1.simples, f2.simples),
		  Dict::union_two(Set::union_two, f1.tuples,  f2.tuples),
		  Dict::union_two(Set::union_two, f1.structs, f2.structs));
}
static flow_info_t meet_flow(flow_info_t f1, flow_info_t f2) {
  return FlowInfo(Set::intersect(f1.simples, f2.simples),
		  Dict::intersect(Set::intersect, f1.tuples,  f2.tuples),
		  Dict::intersect(Set::intersect, f1.structs, f2.structs));
} 

static bool dict_less_than_f(dict_t<`a,set_t<`b>> d2, `a a, set_t<`b> s){
  return !Dict::member(d2,a) || Set::subset(s, Dict::lookup(d2,a));
}
static bool less_than_flow(flow_info_t f1, flow_info_t f2) {
  return 
    Set::subset(f1.simples,f2.simples) 
    && Dict::forall_c(dict_less_than_f, f1.tuples,  f2.tuples)
    && Dict::forall_c(dict_less_than_f, f1.structs, f2.structs);
}
static flow_info_t add_unassigned(flow_info_t f, vardecl_t vd) {
  // track aggregate types more precisely.  For under-constrained types,
  // I think it's sound and reasonable to just treat them as simple.
  switch (compress(vd->type)) {
  case TupleType(l):
    let n = List::length(l) - 1;
    let s = Set::empty(intcmp);
    for(; n >= 0; --n)
      s = Set::insert(s, n);
    return FlowInfo(f.simples, Dict::insert(f.tuples, vd, s), f.structs);
  case StructType(_,_, & &Structdecl(_,_,_,&Opt(fs))):
    let s = Set::empty(String::zstrptrcmp);
    for(; fs != null; fs = fs->tl)
      s = Set::insert(s, (*fs->hd)[0]);
    return FlowInfo(f.simples, f.tuples, Dict::insert(f.structs, vd, s));
  default:
    return FlowInfo(Set::insert(f.simples,vd), f.tuples, f.structs);
  }
}
// Note: Dict doesn't support delete, whereas SlowDict does.
//       Instead I leave a "zombie" in the dict as an empty set.
//       (For efficiency should share the empty sets.)
static flow_info_t remove_unassigned(flow_info_t f, vardecl_t vd) {
  if(Set::member(f.simples,vd))
    return FlowInfo(Set::delete(f.simples,vd), 
		    f.tuples, 
		    f.structs);
  if(Dict::member(f.tuples,vd))
    return FlowInfo(f.simples, 
		    Dict::insert(f.tuples,vd,Set::empty(intcmp)),
		    f.structs);
  if(Dict::member(f.structs,vd))
    return FlowInfo(f.simples,
		    f.tuples,
		    Dict::insert(f.structs,vd,Set::empty(String::zstrptrcmp)));
  return f;
}
static flow_info_t remove_unassigned_tuplefield(flow_info_t f, vardecl_t vd, 
						int field) {
  if(Dict::member(f.tuples,vd)) {
    let s = Dict::lookup(f.tuples,vd);
    if(Set::member(s, field))
      return FlowInfo(f.simples,
		      Dict::insert(f.tuples, vd, Set::delete(s, field)),
		      f.structs);
  }
  return f;
}
static flow_info_t remove_unassigned_structfield(flow_info_t f, vardecl_t vd, 
						 field_name_t field) {
  if(Dict::member(f.structs,vd)) {
    let s = Dict::lookup(f.structs,vd);
    if(Set::member(s, field))
      return FlowInfo(f.simples,
		      f.tuples,
		      Dict::insert(f.structs, vd, Set::delete(s, field)));
  }
  return f;
}

// Note: We're now doing significantly more work per variable access.
//   Could avoid the Dict::member calls when type is non-tuple or non-struct.
static bool is_unassigned(flow_info_t f, vardecl_t vd) {
  return Set::member(f.simples,vd)
    || Dict::member(f.tuples, vd) && !Set::is_empty(Dict::lookup(f.tuples, vd))
    || Dict::member(f.structs,vd) && !Set::is_empty(Dict::lookup(f.structs,vd));
}
static bool is_unassigned_tuplefield(flow_info_t f, vardecl_t vd, 
				     int field) {
  return Dict::member(f.tuples,vd) 
    && Set::member(Dict::lookup(f.tuples,vd),field);
}
static bool is_unassigned_structfield(flow_info_t f, vardecl_t vd,
				      field_name_t field) {
  return Dict::member(f.structs,vd) 
    && Set::member(Dict::lookup(f.structs,vd),field);
}

abstract struct CFStmtAnnot {
  stmt        encloser;
  int         visited;
  flow_info_t old_env; // env with which the stmt was last analyzed
};
typedef struct CFStmtAnnot cf_stmt_annot_t; // NOT a pointer!!!
xenum StmtAnnot { CFAnnot(cf_stmt_annot_t); };

// to be used by the type-checking pass to get things set up for us
// must be called on EVERY stmt in the abstract syntax (even the dummy ones)
void set_encloser(stmt enclosee, stmt encloser) {
  enclosee->annot = CFAnnot(CFStmtAnnot(encloser, 0, empty_flow()));
}
static cf_stmt_annot_t @ get_stmt_annot(stmt s) {
  switch(s->annot) {
  case CFAnnot(*x): return x;
  default: throw Impossible("ControlFlow -- wrong stmt annotation");
  }
}

struct CFExpSyn {
  flow_info_t when_true;
  flow_info_t when_false;
};
typedef struct CFExpSyn cfexpsyn_t; // NOT a pointer!!!

static flow_info_t expsynth_to_flow(cfexpsyn_t syn) {
  return merge_flow(syn.when_true, syn.when_false);
}

// s1 and s2 are from an e1 and e2 that may execute in either order, but
// both have executed before the return synth
static cfexpsyn_t meet_expsynth(cfexpsyn_t syn1, cfexpsyn_t syn2) {
  let f = meet_flow(expsynth_to_flow(syn1),
		    expsynth_to_flow(syn2));
  return CFExpSyn(f,f);
}

// Global control variables -- to be re-entrant, we'd need to replace this
// with a shared variable in an environment passed to cf_check_stmt
static bool iterate_cf_check = false;
static int  iteration_num    = 0;

static flow_info_t pre_stmt_check(flow_info_t env, stmt s) {
  cf_stmt_annot_t @ sannot = get_stmt_annot(s);

  // add in information that flows from non-local predecessors
  env = merge_flow(env, sannot->old_env);

  // reset the old_env so we can detect the need to iterate
  sannot->old_env = env;
  ++sannot->visited;
  
  // sanity check (an omittable assert)
  if(sannot->visited != iteration_num)
    throw Impossible("ControlFlow::cf_check_stmt -- bad traversal");

  return env;
}

static void update_flow(stmt s, flow_info_t new_flow) {
  // get the annotation
  cf_stmt_annot_t @ sannot = get_stmt_annot(s);

  // do the update as necessary
  if(!less_than_flow(new_flow, sannot->old_env)) {
    sannot->old_env = merge_flow(sannot->old_env, new_flow);
    if(sannot->visited == iteration_num)
      iterate_cf_check = true;
  }
}

static flow_info_t cf_check_stmt(flow_info_t, stmt);
static cfexpsyn_t  cf_check_exp (flow_info_t, exp);

static cfexpsyn_t cf_check_explist_unordered(flow_info_t env, list_t<exp> es) {
  cfexpsyn_t accum = CFExpSyn(env,env);
  // undefined eval order means we check each exp under env
  for(; es != null; es = es->tl)
    accum = meet_expsynth(cf_check_exp(env,es->hd),accum);
  return accum;
}

static cfexpsyn_t cf_check_exp(flow_info_t env, exp e0) {
  switch(e0->r) {
  case Const_e(Int_c(Signed,0)): return CFExpSyn(empty_flow(), env);
  case Const_e(Int_c(Signed,_)): return CFExpSyn(env, empty_flow());
    // could try to evaluate expressions here, but I think it makes more
    // sense to do such constant folding earlier and separately.
  case Const_e(_):     return CFExpSyn(env, env);
  case Primop_e(_,es): return cf_check_explist_unordered(env,es);

    // FIX: Once we support nested aggregates, we will need recursion to
    // detect "interesting" lvalues.
  // Var, StructMember and Subscript need to check for iniialization
  case Var_e(&$(_,v),Local_b(vd)):
    if(is_unassigned(env,vd))
      terr(e0->loc, xprintf("variable %s may be uninitialized",*v));
    return CFExpSyn(env,env);
  case Var_e(_,_):     
    return CFExpSyn(env,env);
  case StructMember_e(&Exp(_,Var_e(&$(_,v),Local_b(vd)),_),field): 
    if(is_unassigned_structfield(env,vd,field))
      terr(e0->loc, xprintf("field %s of struct %s may be uninitialized",
			    *field, *v));
    return CFExpSyn(env,env);
  case StructMember_e(e,_):
    return cf_check_exp(env,e);
  case Subscript_e(e1,e2):
    switch ($(e1->r,compress(e1->topt->v))) {
    case $(Var_e(&$(_,v),Local_b(vd)), TupleType(_)):
      // no need to deal with e2 initializing b/c it is a constant exp
      // I wonder how many times the compiler computes the field number.
      let field = Evexp::eval_const_uint_exp(e2);
      if(is_unassigned_tuplefield(env,vd,field))
	terr(e0->loc, xprintf("field %u of tuple %s may be uninitialized",
	                      field, *v));
      return CFExpSyn(env,env);
    default: return meet_expsynth(cf_check_exp(env,e1), cf_check_exp(env,e2));
    }
    
    // AssignOp of Var, StructMember, and Subscript (of tuple) must initialize
    // Note: we check e2 before initializing the var.
    // Note: we must not have a primop (eg. +=).
  case AssignOp_e(e1,null,e2):
    let syn2 = cf_check_exp(env,e2);
    _ flow;
    switch (e1->r) {
    case Var_e(_,Local_b(vd)):
      flow = remove_unassigned(expsynth_to_flow(syn2),vd);
      return CFExpSyn(flow,flow);
    case StructMember_e(&Exp(_,Var_e(_,Local_b(vd)),_),field): 
      flow = remove_unassigned_structfield(expsynth_to_flow(syn2),vd,field);
      return CFExpSyn(flow,flow);
    case Subscript_e(e3,e4):
      switch ($(e3->r,compress(e3->topt->v))) {
      case $(Var_e(_,Local_b(vd)), TupleType(_)):
	let field = Evexp::eval_const_uint_exp(e4);
	flow = remove_unassigned_tuplefield(expsynth_to_flow(syn2),vd,field);
	return CFExpSyn(flow,flow);
      default: return meet_expsynth(cf_check_exp(env,e1), syn2);
      }
    default: return meet_expsynth(cf_check_exp(env,e1), syn2);
    }
  case AssignOp_e(e1,_,e2):
    // Perhaps C guarantees left before right, in which case we're
    // overly conservative here.
    return meet_expsynth(cf_check_exp(env,e1), cf_check_exp(env,e2));

  case Conditional_e(e1,e2,e3):
    let syn1 = cf_check_exp(env,             e1);
    let syn2 = cf_check_exp(syn1.when_true,  e2);
    let syn3 = cf_check_exp(syn1.when_false, e3);
    return CFExpSyn(merge_flow(syn2.when_true,  syn3.when_true),
		    merge_flow(syn2.when_false, syn3.when_false));

  case FnCall_e(e,es):
    // If C evaluates e before es, then we are overly conservative.
    return meet_expsynth(cf_check_exp(env,e),
			 cf_check_explist_unordered(env, es));
  case Throw_e(e):
    cf_check_exp(env, e);
    return CFExpSyn(empty_flow(), empty_flow());

  case Increment_e(e,_):    fallthru(e);
  case NoInstantiate_e(e):  fallthru(e);
  case Instantiate_e(e,_):  fallthru(e);
  case Cast_e(_,e):         fallthru(e);
    // we currently assume pointers always point at initialized memory
    // so we cannot allow &x when x is uninitialized.
  case Address_e(e):        fallthru(e);
  case Deref_e(e):          fallthru(e);
    // FIX: StructMember with a lhs of a local needs to be checked for 
    //      partial initialization.
  case StructArrow_e(e,_):  return cf_check_exp(env,e);

  case Sizeof_e(_): return CFExpSyn(env,env);

  case Tuple_e(es):        fallthru(es);
  case Enum_e(_,_,es,_,_): fallthru(es); 
  case Xenum_e(_,es,_,_):  return cf_check_explist_unordered(env,es);

  case CompoundLit_e(_,des): fallthru(des);
  case Array_e(_,des):       fallthru(des);
  case Struct_e(_,_,des,_):
    cfexpsyn_t accum = CFExpSyn(env,env);
    for(; des != null; des = des->tl)
      accum = meet_expsynth(cf_check_exp(env,(*des->hd)[1]),accum);
    return accum;

    // I'm assuming C insists e1 before e2, but I didn't look it up.
    // Note that e2 does not execute when e1 evaluates to 0.
    // Monotonicity is why we can ignore the result of e2.
  case Comprehension_e(_,e1,e2): 
    let syn1 = cf_check_exp(env,e1);
    cf_check_exp(expsynth_to_flow(syn1),e2);
    return syn1;

  case SeqExp_e(e1,e2): 
    return cf_check_exp(expsynth_to_flow(cf_check_exp(env,e1)), e2);

  // Technically we're being too conservative here because we could
  // have different when_true/when_false on the last expression.
  // Given that that's a pain to deal with, it would take rather
  // convoluted code to matter, lots of such convoluted code could be
  // written with SeqExp_e (and all of it if you allow declarations to
  // be hoisted), I won't bother.
  case StmtExp_e(s):
    let syn = cf_check_stmt(env, s);
    return CFExpSyn(syn,syn); 

  default: throw Impossible("ControlFlow::cf_check_exp -- bad exp syntax"
			    " or unimplemented exp form");
  }
}

// true means the statement might fall-through
// The cute hack is adding a variable that cannot be assigned to.
// That way, we can distinguish all-real-varibles-assigned from a jump.
static bool cf_check_stmt_ft(flow_info_t env, stmt s) {
  return !less_than_flow(cf_check_stmt(add_unassigned(env,bogus_vardecl), s),
			 empty_flow());
}

// NOTE: all control-flow to below a switch is currently done
// via break, i.e. non-local-preds. That is why we seem to ignore
// the synth from the clauses.
static void cf_check_switch_clauses(flow_info_t env, list_t<switch_clause> scs) {
  for(; scs != null; scs = scs->tl) {
    let &Switch_clause(_,_,where_opt,body,_) = scs->hd;
    if(where_opt!=null) 
      env = expsynth_to_flow(cf_check_exp(env,(exp)where_opt));
    if(cf_check_stmt_ft(env,body))
      terr(body->loc, "switch clause may implicitly fallthru");
  }
}

// NOTE: Must visit everything, even when it appears a stmt is unreachable
//       (If you don't visit, then a descendant with non_local_preds
//        gets treated incorrectly!)
// NOTE: On a non-local jump, we must iterate again whenever we change
//       the destination's environment and the destination has already been
//       traversed on the current pass. 
static flow_info_t cf_check_stmt(flow_info_t env, stmt s) {

  env = pre_stmt_check(env,s);

  switch(s->r) {
  case Skip_s:            return env;
  case Exp_s(e):          return expsynth_to_flow(cf_check_exp(env,e));
  case Return_s(null):    return empty_flow();
  case Return_s(e):       cf_check_exp(env,(exp)e); return empty_flow();
  case Seq_s(s1,s2):      return cf_check_stmt(cf_check_stmt(env,s1), s2);
  case IfThenElse_s(e,s1,s2):
    let syn_e = cf_check_exp(env,e);
    let syn1  = cf_check_stmt(syn_e.when_true,  s1);
    let syn2  = cf_check_stmt(syn_e.when_false, s2);
    return merge_flow(syn1,syn2);
  case While_s($(e,cont),body):
    let syn_e = cf_check_exp(pre_stmt_check(env,cont),e);
    let syn_b = cf_check_stmt(syn_e.when_true, body);
    update_flow(cont, syn_b);
    return syn_e.when_false;
  case Do_s(body,$(e,cont)):
    let syn_b = cf_check_stmt(env,body);
    let syn_e = cf_check_exp(pre_stmt_check(syn_b,cont),e);
    update_flow(body, syn_e.when_true);
    return syn_e.when_false;
  case For_s(e1,$(e2,guard),$(e3,cont),body):
    let syn_e1 = expsynth_to_flow(cf_check_exp(env,e1));
    let syn_e2 = cf_check_exp(pre_stmt_check(syn_e1,guard),e2);
    let syn_b  = cf_check_stmt(syn_e2.when_true, body);
    let syn_e3 = expsynth_to_flow(cf_check_exp(pre_stmt_check(syn_b,cont),e3));
    update_flow(guard, syn_e3);
    return syn_e2.when_false;
  case Goto_s(_,dest):  
    // must make sure not into scope 
    // doesn't change, so can just do the first time.
    if(iteration_num == 1) {
      let my_encloser   = get_stmt_annot(s)->encloser;
      let dest_encloser = get_stmt_annot((stmt)dest)->encloser;
      while(dest_encloser != my_encloser) {
	let next_encloser = get_stmt_annot(my_encloser)->encloser;
	if(next_encloser == my_encloser) { // function body is own encloser
	  terr(s->loc, "goto enters local scope or exception handler");
	  break;
	}
	my_encloser = next_encloser;
      }
    }
    update_flow((stmt)dest, env);
    return empty_flow();

  case Break_s(null): // eg. break dest is function end.
    return empty_flow(); 
  case Break_s(dest):     fallthru(dest);
  case Continue_s(dest):
    update_flow((stmt)dest, env);
    return empty_flow();
  case Fallthru_s(es,dest):
    update_flow((stmt)dest, 
		expsynth_to_flow(cf_check_explist_unordered(env,es)));
    return empty_flow();

  // could someday refine env for branches, but seems rather unuseful
  // in non-pathological cases and/or a lot of work.
  // So in essence we do it only on booleans, and only when you use
  // the "sugar" of if insted of switch.
  case Switch_s(e,scs):
    cf_check_switch_clauses(expsynth_to_flow(cf_check_exp(env,e)), scs);
    return empty_flow();

  // monotonicity is what allows us to check the clauses without
  // worrying about when an exception might be thrown (i.e. env is 
  // a conservative approximation)
  case TryCatch_s(s,scs):
    cf_check_switch_clauses(env,scs);
    return cf_check_stmt(env,s);
  case Decl_s(&Decl(Var_d(vd),_),s):
    exp_opt e = vd->initializer;
    if(e == null)
      return cf_check_stmt(add_unassigned(env,vd), s);
    // vd is unassigned in e (important only if e has a jump in it)
    let e_env = add_unassigned(env,vd);
    let s_env = remove_unassigned(expsynth_to_flow(cf_check_exp(e_env,(exp)e)),
				  vd);
    return cf_check_stmt(s_env,s);
  case Decl_s(&Decl(Let_d(_,&Opt(vds),_,e,_),_),s):
    // vds are unassigned in e (important only if e has a jump in it)
    let e_env = env;
    for(_ vds2 = vds; vds2 != null; vds2 = vds2->tl)
      e_env = add_unassigned(env,vds2->hd);
    let s_env = expsynth_to_flow(cf_check_exp(e_env,e));
    for(_ vds2 = vds; vds2 != null; vds2 = vds2->tl)
      s_env = remove_unassigned(env,vds2->hd);
    return cf_check_stmt(s_env,s);
  // all the work necessary for non-local control flow is done by the jumpers
  case Label_s(_,s):
    return cf_check_stmt(env,s);
  default: throw Impossible("ControlFlow::cf_check_stmt -- bad stmt syntax"
			    " or unimplemented stmt form");
  }
}

static void cf_check_fun(fndecl fd) {
  iterate_cf_check = true;
  iteration_num    = 0;
  while(iterate_cf_check) {
    ++iteration_num;
    iterate_cf_check = false;
    if(fd->ret_type != VoidType) {
      if(cf_check_stmt_ft(empty_flow(), fd->body))
	terr(fd->body->loc, "function may complete without returning a value");
    }
    else
      cf_check_stmt(empty_flow(), fd->body);
  }
}

void cf_check(list_t<decl> ds) {
  for(; ds != null; ds = ds->tl) {
    switch(ds->hd->r) {
    case Fn_d(fd):           cf_check_fun(fd); break;
    case Using_d(_,ds2):     fallthru(ds2);
    case Namespace_d(_,ds2): cf_check(ds2);    break;
    default: break;
    }
  }
}

