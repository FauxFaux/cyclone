/* Computing Strongest Post-conditions
   Copyright (C) 2003 Greg Morrisett
   This file is part of the Cyclone compiler.

   The Cyclone compiler is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   The Cyclone compiler is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with the Cyclone compiler; see the file COPYING. If not,
   write to the Free Software Foundation, Inc., 59 Temple Place -
   Suite 330, Boston, MA 02111-1307, USA. */

/* this file contains the definition of assertions, the terms used in
   assertions as well as utilities on them (such as comparison, debugging
   printing etc.). */

#include "flags.h"
#include "assndef.h"
#include "pratt_prover.h"
#include <sexp.h>
#include <set.h>

namespace AssnDef;
using List;
using Hashtable;
///////////////////// Terms /////////////////////

string_t term2string(term_t t) {
  string_t res;
  switch (t) {
  case &Uint(i): res = aprintf("0x%x", i); break;
  case &Const(e): res = Absynpp::exp2string(e); break;
  case &Var(vd): 
    if (Flags::debug_assn) 
      res = aprintf("%s_%x",Absynpp::qvar2string(vd->name),(unsigned int)vd); 
    else 
      res = Absynpp::qvar2string(vd->name);
    break;
  case &Addr(vd):
    if (Flags::debug_assn) 
      res = aprintf("&%s_%x",Absynpp::qvar2string(vd->name),(unsigned int)vd); 
    else 
      res = aprintf("&%s",Absynpp::qvar2string(vd->name));
    break;
  case &Select(t1,t2,_):
    res = aprintf("Sel(%s,%s)",term2string(t1),term2string(t2));
    break;
  case &Update(t1,t2,t3):
    res = aprintf("Upd(%s,%s,%s)",term2string(t1),term2string(t2),term2string(t3));
    break;
  case &LogicVar(NULL,i,_): res = aprintf("_X%d",i); break;
  case &LogicVar(vd,i,_): 
    res = aprintf("_%s%d",Absynpp::qvar2string(vd->name),i); break;
  case &Binop(p,t1,t2,_):
    res = aprintf("(%s%s%s)",term2string(t1),Absynpp::prim2string(p),
                  term2string(t2));
    break;
  case &Unop(p,t1,_):
    res = aprintf("%s(%s)",Absynpp::prim2string(p),term2string(t1)); break;
  case &Cast(tp,tm):
    res = aprintf("(%s)%s",Absynpp::typ2string(tp),term2string(tm)); break;
  case &Aggr(tms,_):
    static string_t lb = "{";
    static string_t rb = "}";
    static string_t comma = ",";
    list_t<stringptr_t> ss = new List{&lb,NULL};
    for (; tms != NULL; tms = tms->tl) {
      let s = term2string(tms->hd);
      ss = new List{new s,ss};
      if (tms->tl != NULL) ss = new List{&comma,ss};
    }
    ss = new List{&rb,ss};
    ss = List::imp_rev(ss);
    res = strconcat_l(ss);
    break;
  case &Proj(t,i,_):
    res = aprintf("#%d(%s)",i,term2string(t));
    break;
  case &Okderef(t):
    res = aprintf("Okderef(%s)",term2string(t));
    break;
  }
  return res;
}

static int hash_const(Absyn::cnst_t c) {
  switch (c) {
  case Absyn::Cnst{.Null_c = _}: return 0;
  case Absyn::Cnst{.Char_c = $(_,c)}: return c;
  case Absyn::Cnst{.Short_c = $(_,c)}: return c;
  case Absyn::Cnst{.Int_c = $(_,i)}: return i;
  case Absyn::Cnst{.LongLong_c = $(_,i)}: return (int)i;
  case Absyn::Cnst{.Float_c = $(s,_)}: fallthru(s);
  case Absyn::Cnst{.Wchar_c = s}: fallthru(s);
  case Absyn::Cnst{.String_c = s}: fallthru(s);
  case Absyn::Cnst{.Wstring_c = s}:
    return Hashtable::hash_string(s);
  }
}

static int hash_exp(exp_t e) {
  switch (e->r) {
  case &Absyn::Const_e(c): return hash_const(c);
  case &Absyn::Var_e(...): return 1;
  case &Absyn::Pragma_e(...): return 2;
  case &Absyn::Primop_e(...): return 3;
  case &Absyn::Conditional_e(...): return 4;
  case &Absyn::And_e(...): return 5;
  case &Absyn::Or_e(...): return 6;
  case &Absyn::SeqExp_e(...): return 7;
  case &Absyn::NoInstantiate_e(...): return 8;
  case &Absyn::Instantiate_e(...): return 9;
  case &Absyn::Cast_e(...): return 10;
  case &Absyn::Address_e(...): return 11;
  case &Absyn::Sizeoftype_e(...): return 12;
  case &Absyn::Sizeofexp_e(...): return 13;
  case &Absyn::Offsetof_e(...): return 14;
  case &Absyn::Enum_e(...): return 15;
  case &Absyn::AnonEnum_e(...): return 16;
  case &Absyn::Valueof_e(...): return 17;
  case &Absyn::Assert_e(...): return 18;
  default: return 19;
  }
}

int termhash(datatype Term @t) {
  switch (t) {
  case &Uint(i): return i;
  case &Const(e): return hash_exp(e) + 61;
  case &Var(vd): return (unsigned int)vd;
  case &LogicVar(vd,i,_): return (unsigned int)vd ^ (i+1);
  case &Binop(p,t1,t2,_):
    return p ^ (unsigned int)t1 ^ (unsigned int)t2;
  case &Unop(p,t1,_): return p ^ (unsigned int)t1 + 1;
  case &Cast(_,t): return termhash(t);
  case &Select(t1,t2,_):
    return (unsigned int)t1 ^ (unsigned int)t2 + 2;
  case &Update(t1,t2,t3):
    return (unsigned int)t1 ^ (unsigned int)t2 ^ (unsigned int)t3 + 3;
  case &Addr(vd): return (unsigned int)vd+4;
  case &Proj(t,i,_): return (unsigned int)t ^ i;
  case &Aggr(ts,_):
    unsigned int res = 37;
    for (; ts != NULL; ts = ts->tl)
      res = res ^ (unsigned int)ts->hd;
    return res;
  case &Okderef(t):
    return termhash(t)+97;
  }
}

int cmp_term(datatype Term @t1, datatype Term @t2) {
  switch $(t1,t2) {
  case $(&Uint(i1), &Uint(i2)): return i1-i2;
  case $(&Uint(_), _): return -1;
  case $(_, &Uint(_)): return 1;
  case $(&Const(e1),&Const(e2)): return Evexp::exp_cmp(e1,e2);
  case $(&Const(_),_): return -1;
  case $(_,&Const(_)): return 1;
  case $(&Var(vd1),&Var(vd2)): return (int)vd1 - (int)vd2;
  case $(&Var(_),_): return -1;
  case $(_,&Var(_)): return 1;
  case $(&Addr(vd1),&Addr(vd2)): return (int)vd1 - (int)vd2;
  case $(&Addr(_),_): return -1;
  case $(_,&Addr(_)): return 1;
  case $(&LogicVar(vd1,i,_),&LogicVar(vd2,j,_)): 
    if (vd1 == vd2) return (i - j);
    return (int)vd1 - (int)vd2;
  case $(&LogicVar(...),_): return -1;
  case $(_,&LogicVar(...)): return 1;
  case $(&Cast(tp1,tm1),&Cast(tp2,tm2)):
    int c = Tcutil::typecmp(tp1,tp2);
    if (c != 0) return c;
    return cmp_term(tm1,tm2);
  case $(&Cast(...),_): return -1;
  case $(_,&Cast(...)): return 1;
  case $(&Unop(p1,t1,_),&Unop(p2,t2,_)): 
    if (p1 != p2) return (int)p1 - (int)p2;
    return cmp_term(t1,t2);
  case $(&Unop(...),_): return -1;
  case $(_,&Unop(...)): return 1;
  case $(&Select(t11,t12,_),&Select(t21,t22,_)):
    int c = cmp_term(t11,t21);
    if (c != 0) return c;
    return cmp_term(t12,t22);
  case $(&Select(...),_): return -1;
  case $(_,&Select(...)): return 1;
  case $(&Update(t11,t12,t13),&Update(t21,t22,t23)):
    int c = cmp_term(t11,t21);
    if (c != 0) return c;
    int c = cmp_term(t12,t22);
    if (c != 0) return c;
    return cmp_term(t13,t23);
  case $(&Update(...),_): return -1;
  case $(_,&Update(...)): return 1;
  case $(&Proj(t1,i1,_),&Proj(t2,i2,_)): 
    int c = i1 - i2;
    if (c != 0) return c;
    return cmp_term(t1,t2);
  case $(&Proj(...),_): return -1;
  case $(_,&Proj(...)): return 1;
  case $(&Okderef(t1),&Okderef(t2)):
    return cmp_term(t1,t2);
  case $(&Okderef(_),_): return -1;
  case $(_,&Okderef(_)): return 1;
  case $(&Aggr(ts1,_),&Aggr(ts2,_)):
    int c;
    for (; ts1 != NULL && ts2 != NULL; ts1=ts1->tl, ts2=ts2->tl) {
      c = cmp_term(ts1->hd,ts2->hd);
      if (c != 0) return c;
    }
    if (ts1 == ts2) return 0;
    if (ts1 == NULL) return -1;
    return 1;
  case $(&Aggr(...),_): return -1;
  case $(_,&Aggr(...)): return 1;
  case $(&Binop(p1,t11,t12,tp1),&Binop(p2,t21,t22,tp2)):
    if (p1 != p2) return (int)p1 - (int)p2;
    int c = cmp_term(t11,t21);
    if (c != 0) return c;
    return cmp_term(t12,t22);
  }
}

static term_t copy_term(datatype Term@ t) {
  switch (t) {
  case &Uint(i): return new Uint(i);
  case &Const(e): return new Const(e);
  case &Var(vd): return new Var(vd);
  case &Addr(vd): return new Addr(vd);
  case &LogicVar(vd,i,tp): return new LogicVar(vd,i,tp);
  case &Binop(p,t1,t2,tp): return new Binop(p,t1,t2,tp);
  case &Unop(p,t,tp): return new Unop(p,t,tp);
  case &Cast(tp,t): return new Cast(tp,t);
  case &Select(t1,t2,tp): return new Select(t1,t2,tp);
  case &Update(t1,t2,t3): return new Update(t1,t2,t3);
  case &Proj(t,i,tp): return new Proj(t,i,tp);
  case &Aggr(ts,tp): return new Aggr(ts,tp);
  case &Okderef(t): return new Okderef(t);
  }
}

// a hash-table to hold all of the term nodes to maximize sharing.  
static struct Hashtable::Table<term_t,term_t> *term_hash_cons_table = NULL;

datatype Term.Uint zero_value = Uint(0);
datatype Term.Uint one_value = Uint(1);

static term_t hash_cons_term(datatype Term @t) {
  Hashtable::table_t<term_t,term_t> h;
  if (term_hash_cons_table == NULL) {
    h = Hashtable::create(123, cmp_term, termhash);
    term_hash_cons_table = h;
    Hashtable::insert(h,&zero_value,&zero_value);
    Hashtable::insert(h,&one_value,&one_value);
  } else {
    h = (Hashtable::table_t)term_hash_cons_table;
  }
  let resopt = Hashtable::lookup_other_opt(h,t,cmp_term,termhash);
  if (resopt == NULL) {
    let t2 = copy_term(t);
    Hashtable::insert(h,t2,t2);
    return t2;
  } else return *resopt;
}


// rewrite uint, cnst, var, 
term_t uint(unsigned int i) {
  let t = Uint(i);
  return hash_cons_term(&t);
}
term_t zero() {
  return &zero_value;
}
term_t one() {
  return &one_value;
}
term_t cnst(Absyn::exp_t e) { 
  let $(c, known) = Evexp::eval_const_uint_exp(e);
  if (known) return uint(c);
  let t = Const(e);
  return hash_cons_term(&t);
}
term_t var(vardecl_t vd) { 
  let t = Var(vd);
  return hash_cons_term(&t);
}
term_t addr(vardecl_t vd) {
  let t = Addr(vd);
  return hash_cons_term(&t);
}
term_t logicvar(vardecl_opt_t vd,int i,type_opt_t tp) {
  let t = LogicVar(vd,i,tp);
  return hash_cons_term(&t);
}
term_t update(term_t t1, term_t t2, term_t t3) {
  switch $(t1,t2) {
  case $(&Update(m,a as &Addr(x),e1),&Addr(y)):
    // Update(Update(m,Addr(x),e1),Addr(x),t3) = Update(m,Addr(x),t3)
    if (x == y) return update(m,t2,t3);
    // Not sure if this is worth it since it is a slow insertion sort
    // on the updates...  
    // Update(Update(m,Addr(x),e1),Addr(y),t3) = 
    //    Update(Update(m,Addr(y),t3),Addr(x),e1)
    //if ((unsigned int)y < (unsigned int)x)
    //  return update(update(m,t2,t3),a,e1);
    break;
  default: break;
  }
  let t = Update(t1,t2,t3);
  return hash_cons_term(&t);
}
term_t select(term_t t1, term_t t2,type_opt_t tp) {
  switch $(t1,t2) {
  case $(&Update(m,&Addr(x),v),&Addr(y)):
    // Select(Update(m,a,v),a) == v
    if (x == y) return v;
    // addresses of distinct program variables must be distinct so we
    // know that Select(Update(m,Addr(x),v),Addr(y)) == Select(m,Addr(y))
    else return select(m,t2,tp);
  case $(&Update(m,a1,v),a2):
    // Select(Update(m,a,v),a) == v
    if (a1 == a2) return v;
    fallthru;
  default:
    let t = Select(t1,t2,tp);
    return hash_cons_term(&t);
  }
}
term_t proj(term_t t1, unsigned i, type_opt_t tp) {
  switch (t1) {
  case &Aggr(ts,_): return nth(ts,i);
  default: 
    let t = Proj(t1,i,tp);
    return hash_cons_term(&t);
  }
}
term_t aggr(list_t<term_t,`H> ts, type_opt_t tp) {
  // could eta-reduce Aggr(proj(t,0),proj(t,1),...,proj(t,n)) to t,
  // using the type information to figure out n.
  let t = Aggr(ts,tp);
  return hash_cons_term(&t);
}
term_t okderef(term_t t1){
  let t = Okderef(t1);
  return hash_cons_term(&t);
}
inline static bool is_nonassociative_commutative(Absyn::primop_t p) {
  switch (p) {
  case Absyn::Eq:
  case Absyn::Neq: return true;
  default: return false;
  }
}

inline static bool is_associative_commutative(Absyn::primop_t p) {
  switch (p) {
  case Absyn::Plus:
  case Absyn::Times:
  case Absyn::Bitand:
  case Absyn::Bitor:
  case Absyn::Bitxor: return true;
  default: return false;
  }
}

// given a primop p, return an unsigned int u such that
// for all term t, t p Uint(u) == Uint(u) p t == t,
// i.e., Uint(u) is the identity in the commutative group.
inline static unsigned id_of_primop(Absyn::primop_t p){
  switch(p) {
  case Absyn::Plus:   return 0;
  case Absyn::Times:  return 1;
  case Absyn::Bitand: return 0xFFFFFFFF;
  case Absyn::Bitor:  return 0;
  case Absyn::Bitxor: return 0;
  default: Warn::impos("no id for primop %s",Absynpp::prim2string(p));
  }
}

//evaluating commutative associative bin op on constants.
inline static unsigned eval_binop(Absyn::primop_t p, unsigned i, unsigned j){
  switch(p){
  case Absyn::Plus: return (i+j);
  case Absyn::Times: return (i*j);
  case Absyn::Bitand: return (i & j);
  case Absyn::Bitor: return (i | j);
  case Absyn::Bitxor: return (i ^ j);
  default: Warn::impos("Error in evaluating binop");
  }
}

Absyn::type_opt_t get_term_type(term_t t) {
  switch (t) {
  case &Uint(_): return Absyn::int_type(Absyn::None, Absyn::Int_sz);
  case &Const(e): return e->topt;
  case &Var(vd): return vd->type;
  case &LogicVar(_,_,topt): return topt;
  case &Binop(_,_,_,tp): return tp;
  case &Unop(_,_,tp): return tp;
  case &Cast(tp,_): return tp;
  case &Select(_,_,tp): return tp;
  case &Aggr(ts,tp): return tp;
  case &Proj(t1,i,tp): return tp;
  // not sure that this is the right thing to do...
  case &Addr(vd): return Absyn::int_type(Absyn::None, Absyn::Int_sz);
  case &Update(...): return NULL;
  case &Okderef(_): return NULL;
  }
}

term_t plus(term_t t1, term_t t2, type_opt_t tp) {
  return binop(Absyn::Plus,t1,t2,tp);
}
term_t minus(term_t t1, term_t t2, type_opt_t tp) {
  return binop(Absyn::Minus,t1,t2,tp);
}

term_t unop(Absyn::primop_t p, term_t t, type_opt_t tp) {
  // +t = t;
  if (p == Absyn::Plus) return t;
  // -t = t * (-1);
  if (p == Absyn::Minus) return binop(Absyn::Times,t,uint(-1),tp);
  let ptr = Unop(p,t,tp);
  return hash_cons_term(&ptr);
}

term_t numelts_term(term_t t) {
  return unop(Absyn::Numelts, t, Absyn::uint_type);
}

static int inv_cmp_term(term_t t1, term_t t2){
  return -cmp_term(t1, t2);
}


inline static term_t compute_factor(int c, term_t t, type_opt_t topt){
  if (c == 1) return t;
  else {
    let newfactor = Binop(Absyn::Times,t,uint(c),topt);
    return hash_cons_term(&newfactor);
  }
}
static term_t termcoeflist2term(term_coef_list_t q_list, int newc, type_opt_t topt){
  if (q_list == NULL) return uint(newc);
  // q_list is not empty, compute the first factor term newf = hd->f0 * hd->f1
  term_t res = compute_factor(q_list->hd->f0,q_list->hd->f1,topt);
  q_list = q_list -> tl;
  while(q_list != NULL){
    let newf = compute_factor(q_list->hd->f0,q_list->hd->f1,topt);
    let newterm = Binop(Absyn::Plus,res,newf,topt);
    res = hash_cons_term(&newterm);
    q_list = q_list->tl;
  }
  if (newc == 0) return res;
  else {
    let newterm = Binop(Absyn::Plus,res,uint(newc),topt);
    return hash_cons_term(&newterm);
  }
}
// the normal for of term t is t1*c1 + t2*c2 + ... + tn*cn+c
$(term_coef_list_t,int res) flatten_plus(term_t t){
  term_coef_list_t term_coef_list = NULL;
  int res = 0;
 LOOP:
  switch(t){
  case &Uint(i): res = i; break;
  case &Binop(Absyn::Plus,t1,&Uint(i),_):
    res = i;
    t = t1;
    goto LOOP;
  case &Binop(Absyn::Plus, t1, t2,_):
    switch(t2){
    case &Binop(Absyn::Times,t21,&Uint(c2),_):
      term_coef_list = new List(new $(c2,t21), term_coef_list);
      break;
    case &Binop(Absyn::Plus,_,_,_):
      Warn::impos("Plus in the right branch, not a normal form");
      break;
    default:
      term_coef_list = new List(new $(1,t2),term_coef_list);
      break;
    }
    t = t1;
    goto LOOP;
  default:
    switch(t){
    case &Binop(Absyn::Times,t21,&Uint(c2),_):
      term_coef_list = new List(new $(c2,t21), term_coef_list);
      break;
    default:
      term_coef_list = new List(new $(1,t),term_coef_list);
      break;
    }
    break;
  }
  return $(term_coef_list,res);
}

// given two sorted list [(t1,c1),(t2,c2),...,(tn,cn)]
// and [(s1,d1),(s2,d2),...,(sn,dn)]
// generate a merged list [(q1,e1),(q2,e2),...,(qm,em)]
// think about it as adding two polynomials
// by merging the coefficients of same terms.
// the final result should also be sorted and each term
// in the list should be unique.
static coef_list_t<`a,`r> imp_merge_with_coef(int less_eq(`a,`a), coef_list_t<`a,`r> a,coef_list_t<`a,`r> b){
  coef_list_t c=NULL, d=NULL;
  if (a == NULL) return b;
  if (b == NULL) return a;
  let cmp_result = less_eq(a->hd->f1,b->hd->f1);
  while ((a != NULL) && (b != NULL)){
    let cmp_result = less_eq(a->hd->f1,b->hd->f1);
    if (cmp_result < 0){ // a < b
      if (c == NULL){
	c = a;
	a = a->tl;
	d = c;
      }else{
	c->tl = a;
	c = a;
	a = a->tl;
      }
    } else if (cmp_result > 0) { // b < a
      if (c == NULL){
	c = b;
	b = b->tl;
	d = c;
      } else {
	c->tl = b;
	c = b;
	b = b->tl;
      }
    } else { // cmp_result == 0, a == b
      // merge two values;
      let i = a->hd->f0 + b->hd->f0;
      if (i != 0){
	a->hd->f0 = i;
	if (c == NULL){
	  c = a;
	  d = c;
	} else {
	  c->tl = a;
	  c = a;
	}
      }
      a = a->tl;
      b = b->tl;
    }
  }
  if (c == NULL) {
    c = (a == NULL)? b : a;
    d = c;
  } else {
    c->tl = (a==NULL)? b : a;
  }
  return d;
}
// given two terms of the form 
// t = t1*c1 + t2*c2 + ... + tn*cn + c
// s = s1*d1 + s2*d2 + ... + sm*dm + d
// we want to produce a new term q = t+s with common terms merged
static term_t flatten_merge_plus(term_t t, term_t s, type_opt_t topt){
  let $(t_list,c) = flatten_plus(t);
  let $(s_list,d) = flatten_plus(s);
  let q_list = imp_merge_with_coef(inv_cmp_term,t_list,s_list);
  let newc = c+d;
  return termcoeflist2term(q_list,newc,topt);
}

// for a binop p that is both commutative and associative
// t has normal form for p, i.e., t = (((t1*c1 p t2*c2) p t3*c3)...p tn*cn)+c
// where t1 >= t2 >= t3 >= tn and c, ci are all constants
// p are some commutative and associative binops excluding plus
// !!! flatten, and flatten_merge only work with the assumption
// that Uint(_) is the form of smallest term.
static $(list_t<term_t,`H>,int res) flatten(Absyn::primop_t p, term_t t){
  list_t<term_t,`H> termlist = NULL;
  int res = id_of_primop(p);
 LOOP:
  switch (t){
  case &Uint(i): res = i; break;
  case &Binop(p1,t1,&Uint(i),_) && p1 == p: 
    res = i;
    t = t1;
    goto LOOP;
  case &Binop(p1, t1, t2,_)&& p1 == p:
    termlist = new List(t2, termlist);
    t = t1;
    goto LOOP;
  default:
    termlist = new List(t, termlist);
    break;
  }
  return $(termlist,res);
}

static $(int,term_t)@ times_newc(int c, $(int,term_t)@ td){
  return new $(td->f0*c,td->f1);
}

// flatten generates two lists of terms [t11,t12,...] and [t21,t22,...]
// merge the list into one, and generate a normalized term from the
// new list.
static term_t flatten_merge(Absyn::primop_t p, term_t t1, term_t t2, type_opt_t topt){
  let $(tlist1,c1) = flatten(p,t1);
  let $(tlist2,c2) = flatten(p,t2);
  // termlist is (tn, tn-1, ..., t2, t1) where ti >= t(i-1).
  let termlist = List::imp_merge(inv_cmp_term, tlist1, tlist2);
  let id = id_of_primop(p);
  let newc = eval_binop(p,c1,c2);
  if (termlist == NULL) return uint(newc);
  term_t t = termlist->hd;
  termlist = termlist -> tl;
  while(termlist != NULL){
    let newterm = Binop(p,t, termlist->hd, topt);
    t = hash_cons_term(&newterm);
    termlist = termlist->tl;
  }
  if (id == newc) return t;
  else {
    // term is of the form t * c
    if (p == Absyn::Times){
      switch(t){
	// term is of the form (t1 + ... + tn) * newc, distribute the newc
      case &Binop(Absyn::Plus,_,_,_):
	let $(t_list,c) = flatten_plus(t);
	let newt_list = map_c(times_newc,newc,t_list);
	return termcoeflist2term(newt_list,c*newc,topt);
	break;
      default: break;
      }
    }
    let newterm = Binop(p,t,uint(newc),topt);
    return hash_cons_term(&newterm);
  }
}

term_t binop(Absyn::primop_t p, term_t t1, term_t t2, type_opt_t tp) {
  if (is_nonassociative_commutative(p) && cmp_term(t1,t2) < 0) {
    t1 :=: t2;
  }
  switch $(p,t1,t2) {
    // constant folding
  case $(_,&Uint(i),&Uint(j)):
    switch (p) {
    case Absyn::Plus: return uint(i+j);
    case Absyn::Minus: return uint(i-j);
    case Absyn::Bitand: return uint(i & j);
    case Absyn::Bitor: return uint(i | j);
    case Absyn::Bitxor: return uint(i ^ j);
    case Absyn::Bitlshift: return uint(i << j);
    case Absyn::Bitlrshift: return uint(i >> j);
    default: break;
    }
    break;
    // t1 - c  ==>  t1 + (-c)
  case $(Absyn::Minus,t1,&Uint(i)): return plus(t1,uint(0 - i),tp);
    // t - t   ==>  0
  case $(Absyn::Minus,t1,t2):
    if (cmp_term(t1,t2) == 0) return uint(0);
    p == Absyn::Plus;
    t2 = binop(Absyn::Times,t2,uint(-1),tp);
    return binop(Absyn::Plus,t1,t2,tp);
    // t1 + 0  ==>  t1
    //  case $(Absyn::Plus,t1,&Uint(0)): return t1;
    // t1 * 1  ==>  t1
    //  case $(Absyn::Times,t1,&Uint(1)): return t1;
    // trying to normalize for commutative and associative operator p
    // into the form ((t1 p t2) p t3) ... p tn) where
    // t1 <= t2 <= t3 <= ... <= tn
  default:
    if (p == Absyn::Plus) return flatten_merge_plus(t1,t2,tp);
    if (is_associative_commutative(p)) return flatten_merge(p,t1,t2,tp);
    break;
  }
  let p = Binop(p,t1,t2,tp);
  return hash_cons_term(&p);
}

term_t cast(Absyn::type_t tp, term_t tm) {
  let t = Cast(tp,tm);
  return hash_cons_term(&t);
}
term_t fresh_var(type_opt_t t) {
  static int counter = 0;
  return logicvar(NULL,counter++,t);
}

static bool same_term(term_t t1, term_t t2) { return cmp_term(t1,t2) == 0; }

///////////////////// Assertions /////////////////////
// inner loop for calculating the size of an assertion -- we
// take care to figure out the size as a dag and not a tree.
static unsigned int 
assn_size_loop(assn_t a, unsigned int c, list_t<assn_t,`H>@ prev){
 LOOP:
  if (memq(*prev,a)) return c;
  *prev = new List(a,*prev);
  switch (a) {
  case &True:  return c;
  case &False: return c;
  case &Prim(...): return 1+c;
  case &And(a1,a2): fallthru(a1,a2);
  case &Or(a1,a2): 
    c = assn_size_loop(a2,1+c,prev);
    a = a1;
    goto LOOP;
  case &Not(a1):
    ++c;
    a = a1;
    goto LOOP;
  case &Subst(vd,t,a1):
    ++c;
    a = a1;
    goto LOOP;
  }
}

// counter used for reporting purposes
static unsigned int max_assn_size = 0;

// calculate the size of an assertion
unsigned int assn_size(assn_t a) {
  list_t<assn_t,`H> prev = NULL;
  let c = assn_size_loop(a,0,&prev);
  if (c > max_assn_size) {
    max_assn_size = c;
  }
  return c;
}

static string_t d2string(assn_t a, int @c,
                         list_t<$(assn_t,string_t<`H>,string_t<`H>)@`H,`H>@ prev) {
  for (let ps = *prev; ps != NULL; ps = ps->tl) {
    let &$(a1,n,v) = ps->hd;
    if ((unsigned int)a1 == (unsigned int)a) return n;
  }
  let n = aprintf("A%d",*c); 
  *c = *c+1;
  string_t s;
  switch (a) {
  case &True: s = "true"; break;
  case &False: s = "false"; break;
  case &Prim(...): s = assn2string(a); break;
  case &And(a1,a2):
    let d1 = d2string(a1,c,prev);
    let d2 = d2string(a2,c,prev);
    s = aprintf("%s && %s",d1,d2);
    break;
  case &Or(a1,a2):
    let d1 = d2string(a1,c,prev);
    let d2 = d2string(a2,c,prev);
    s = aprintf("%s || %s",d1,d2);
    break;
  case &Not(a):
    let d = d2string(a,c,prev);
    s = aprintf("not(%s)",d);
    break;
  case &Subst(vd,t,a):
    let d = d2string(a,c,prev);
    s = aprintf("Subst[%s=%s](%s)",Absynpp::qvar2string(vd->name),
                term2string(t),d);
    break;
  }
  *prev = new List{new $(a,n,s),*prev};
  return n;
}

string_t dag2string(assn_t a) {
  list_t<$(assn_t,string_t<`H>,string_t<`H>)@`H,`H> decls = NULL;
  string_t@`H newline = new "\n";
  string_t@`H equals = new " = ";
  int count = 0;
  string_t res = d2string(a,&count,&decls);
  list_t<string_t@`H,`H> strings = list(new " in ",new res,newline);
  for (; decls != NULL; decls = decls->tl) {
    let &$(_,*n,*d) = decls->hd;
    strings = new List{n,new List{equals,new List{d,new List{newline,strings}}}};
  }
  return strconcat_l(strings);
}

// calculate a string representation (and total tree node count) for an
// assertion.  the prec field (precedent) is used to avoid some parens.
static string_t a2string(assn_t a, int prec, int@ size) {
  switch (a) {
  case &True: return "true";
  case &False: return "false";
  case &Prim(t1,p,t2):
    *size += 1;
    string_t ps;
    switch (p) {
    case Eq: ps = "=="; break;
    case Neq: ps = "!="; break;
    case SLt: ps = " S< "; break;
    case SLte: ps = " S<= "; break;
    case ULt: ps = " U< "; break;
    case ULte: ps = " U<= "; break;
    default: Warn::impos("assn2string primop");
    }
    return aprintf("%s%s%s",term2string(t1),ps,term2string(t2));
  case &Or(a1,a2): 
    *size += 1;
    if (prec <= 5)
      return aprintf("%s || %s",a2string(a1,5,size),a2string(a2,5,size));
    else 
      return aprintf("(%s || %s)",a2string(a1,5,size),a2string(a2,5,size));
  case &And(a1,a2): 
    *size += 1;
    if (prec <= 10)
      return aprintf("%s && %s",a2string(a1,10,size),a2string(a2,10,size));
    else 
      return aprintf("(%s && %s)",a2string(a1,10,size),a2string(a2,10,size));
  case &Not(a1):
    *size += 1;
    return aprintf("!%s",a2string(a1,20,size));
  case &Subst(vd,t,a):
    *size += 1;
    return aprintf("Subst[%s:=%s](%s)",Absynpp::qvar2string(vd->name),
                   term2string(t),a2string(a,0,size));
  }
}

int tree_size = 0;

// convert an assertion to a string.
string_t assn2string(assn_t a) {
  tree_size = 0;
  return a2string(a,0,&tree_size);
}

// assertion constants for true and false
datatype Assn.True true_assn = True;
datatype Assn.False false_assn = False;

//////////////////////////////////////////////////////////////
// hash-consing to try to preserve as much sharing as we
// can -- has a nice impact on performance (much better than
// lazy substitution), but alas, we still end up allocating a lot.  
// It would be better if we didn't have to allocate the thing 
// that want to lookup.  That could happen if we had a different 
// type for hashtable lookup (as we did with dictionaries.)

int assnhash(datatype Assn @a) {
  switch (a) {
  case &False: return 0;
  case &True: return 1;
  case &Prim(t1,p,t2): 
    return (unsigned int)t1 ^ (unsigned int)p ^ (unsigned int)t2;
  case &And(a1,a2): return (unsigned int)a1 ^ (unsigned int)a2;
  case &Or(a1,a2): return ((unsigned int)a1 ^ (unsigned int)a2) | 1;
  case &Not(a1): return ((unsigned int)a1) + 61;
  case &Subst(vd,t,a): return ((unsigned int)a ^ (unsigned int)vd ^
                               (unsigned int)t) | 3;
  }
}

// compare two assertions for structural equality -- does not assume
// the components have been hash-consed, but probably could.
int assncmp(datatype Assn @a1, datatype Assn @a2) {
 LOOP:
  if (a1 == a2) return 0;
  switch $(a1,a2) {
  case $(&True,&True): return 0;
  case $(&True,_): return -1;
  case $(_,&True): return 1;
  case $(&False,&False): return 0;
  case $(&False,_): return -1;
  case $(_,&False): return 1;
  case $(&Or(a11,a12),&Or(a21,a22)): fallthru(a11,a12,a21,a22);
  case $(&And(a11,a12),&And(a21,a22)): 
    int c = assncmp(a11,a21);
    if (c != 0) return c;
    a1 = a12;
    a2 = a22;
    goto LOOP;
  case $(&Or(_,_),_): return -1;
  case $(_,&Or(_,_)): return 1;
  case $(&And(_,_),_): return -1;
  case $(_,&And(_,_)): return 1;
  case $(&Prim(t11,p1,t12),&Prim(t21,p2,t22)):
    int c = (int)p1 - (int)p2;
    if (c != 0) return c;
    c = cmp_term(t11,t21);
    if (c != 0) return c;
    return cmp_term(t12,t22);
  case $(&Prim(...),_): return -1;
  case $(_,&Prim(...)): return 1;
  case $(&Not(na1),&Not(na2)): a1 = na1; a2 = na2; goto LOOP;
  case $(&Not(_),_): return -1;
  case $(_,&Not(_)): return 1;
  case $(&Subst(vd1,t1,a11),&Subst(vd2,t2,a22)):
    int c = (int)vd1 - (int)vd2;
    if (c != 0) return c;
    c = cmp_term(t1,t2);
    if (c != 0) return c;
    a1 = a11;
    a2 = a22;
    goto LOOP;
  }
}

// a hash-table to hold all of the assertion nodes to maximize
// sharing.  we also record an optional reduced version of the
// assertion, and provide an optional set of primitive assertions 
// that correspond to the factored normal form for the assertion.
typedef struct AssnInfo {
  assn_t          assn;
  assn_opt_t      reduced;
  assn_set_opt_t *widened_set;
} assn_info_t;

static struct Hashtable::Table<assn_t,assn_info_t@> *hash_cons_table = NULL;

void reset_hash_cons_table(void){
  term_hash_cons_table = NULL;
  hash_cons_table = NULL;
};

static Hashtable::table_t<assn_t,assn_info_t@>
get_hash_cons_table() {
  Hashtable::table_t h;
  if (hash_cons_table == NULL) {
    h = Hashtable::create(123, assncmp, assnhash);
    hash_cons_table = h;
  } else {
    h = (Hashtable::table_t)hash_cons_table;
  }
  return h;
}
static assn_info_t@ hash_cons_it(datatype Assn@`r a);
static assn_t hash_cons(datatype Assn@`r a);


// shallow copy of an assertion from region `r to the heap and 
// simultaneously determine whether or not the assertion is
// reduced so that we can put the information in the table.
static assn_info_t@ copy_assn(datatype Assn@`r a){
  switch (a) {
  case &True: 
    assn_set_opt_t s = Set::empty(assncmp);
    return new AssnInfo{&true_assn,&true_assn,new s};
  case &False: 
    return new AssnInfo{&false_assn,&false_assn,new NULL};
  case &And(a1,a2): 
    let a1info = hash_cons_it(a1);
    let a2info = hash_cons_it(a2);
    bool reduced = true;
    if (a1info->reduced == NULL) {
      reduced = false;
      a1 = a1info->assn;
    } else {
      a1 = (assn_t)a1info->reduced;
    }
    if (a2info->reduced == NULL) {
      reduced = false;
      a2 = a2info->assn;
    } else {
      a2 = (assn_t)a2info->reduced;
    }
    assn_t newa = new And(a1,a2);
    assn_opt_t reda = reduced ? (assn_opt_t)newa : (assn_opt_t)NULL;
    return new AssnInfo{newa,reda,NULL};
  case &Or(a1,a2): 
    let a1info = hash_cons_it(a1);
    let a2info = hash_cons_it(a2);
    bool reduced = true;
    if (a1info->reduced == NULL) {
      reduced = false;
      a1 = a1info->assn;
    } else {
      a1 = (assn_t)a1info->reduced;
    }
    if (a2info->reduced == NULL) {
      reduced = false;
      a2 = a2info->assn;
    } else {
      a2 = (assn_t)a2info->reduced;
    }
    assn_t newa = new Or(a1,a2);
    assn_opt_t reda = reduced ? (assn_opt_t)newa : (assn_opt_t)NULL;
    return new AssnInfo{newa,reda,NULL};
  case &Prim(t1,p,t2): 
    assn_t newa = new Prim(t1,p,t2);
    return new AssnInfo{newa,newa,NULL};
  case &Not(a): return new AssnInfo{new Not(hash_cons(a)),NULL,NULL};
  case &Subst(vd1,t1,a1): 
    return new AssnInfo{new Subst(vd1,t1,hash_cons(a1)),NULL,NULL};
  }
}

/*
void print_assn(assn_t a) {
  printf("%s",assn2string(a));
}

void print_assninfo(assn_info_t @a) {
  return;
}

void dump_hashtable(Hashtable::table_t<assn_t,assn_info_t@> h) {
  print_table_map(h, print_assn, print_assninfo);
}
*/

// given an assertion node, look it up in the hash-table.  If it's
// not already there, then make a shallow copy and enter it (along
// with info regarding whether or not it's been reduced) into the
// hash table.
static assn_info_t@ hash_cons_it(datatype Assn@`r a) {
  Hashtable::table_t h = get_hash_cons_table();
  let resopt = Hashtable::lookup_other_opt(h,a,assncmp,assnhash);
  if (resopt == NULL) {
    let ainfo = copy_assn(a);
    Hashtable::insert(h,ainfo->assn,ainfo);
    return ainfo;
  } else {
    return *resopt;
  }
}

static assn_t hash_cons(datatype Assn@`r a) {
  let ainfo = hash_cons_it(a);
  let redopt = ainfo->reduced;
  if (redopt == NULL) return ainfo->assn;
  else return (assn_t)redopt;
}

// Need to fake up a vardecl for the "memory"
using Absyn {
  static string_t memory_var = "#Mem";
  static $(nmspace_t,var_t) memvar = $(Nmspace{.Loc_n = 0},&memory_var);
  static datatype TyCon.VoidCon void_con = VoidCon;
  static datatype Type.AppType vd_type = AppType(&void_con,NULL);


  struct Absyn::Vardecl memory_struct = {
    .sc = Absyn::Public,
    .name = &memvar,
    .varloc = 0,
    .tq = {0,0,0,0,0},
    .type = &vd_type,
    .initializer = NULL,
    .rgn = NULL,
    .attributes = NULL,
    .escapes = false,
    .is_proto = false
  };
  vardecl_t memory = &memory_struct;
}

// build an and node.
assn_t and(assn_t a1, assn_t a2) {
  if (a1 == a2) return a1;
  switch $(a1,a2) {
  case $(&True,_): return a2;
  case $(_,&True): return a1;
  case $(&False,_): return a1;
  case $(_,&False): return a2;
  default: 
    // NB: used to sort the operands based on physical address, but
    // to keep things more deterministic, I'm not sorting now.
    let a = And(a1,a2);
    return hash_cons(&a);
  }
}

// build an or-node.
assn_t or(assn_t a1, assn_t a2) {
  if (a1 == a2) return a1;
  switch $(a1,a2) {
  case $(&True,_): return a1;
  case $(_,&True): return a2;
  case $(&False,_): return a2;
  case $(_,&False): return a1;
  default: 
    // NB: used to sort the operands based on physical address, but
    // to keep things more deterministic, I'm not sorting now.
    let a = Or(a1,a2);
    return hash_cons(&a);
  }
}

// build a lazy substitution node.  
assn_t subst(vardecl_t x, term_t newx, assn_t a) {
  switch (a) {
  case &True:
  case &False: return a;
  case &Subst(y,newy,a2) && x == y:
    // we have a2[newy/x][newx/x] == a2[newy[newx/x]/x]
    return subst(x, subst_term(newx,x,newy), a2);
  default:
    let p = Subst(x,newx,a); 
    return hash_cons(&p);
  }
}

// build a primitive relation node.
assn_t prim(term_t t1, prim_reln_t p, term_t t2) {
  let ptr = Prim(t1,p,t2);
  return hash_cons(&ptr);
}

// for eq and neq, we sort the terms
assn_t eq(term_opt_t t1opt, term_opt_t t2opt) {
  if (t1opt == NULL || t2opt == NULL) return &true_assn;
  let t1 = (term_t)t1opt;
  let t2 = (term_t)t2opt;
  if (cmp_term(t1,t2) > 0) {
    t1 :=: t2;
  }
  return prim(t1,Eq,t2); 
}

// for eq and neq, we sort the terms
assn_t neq(term_opt_t t1opt, term_opt_t t2opt) {
  if (t1opt == NULL || t2opt == NULL) return &true_assn;
  let t1 = (term_t)t1opt;
  let t2 = (term_t)t2opt;
  if (cmp_term(t1,t2) > 0) {
    t1 :=: t2;
  }
  return prim(t1,Neq,t2); 
}

// some macros and functions for rest of the primitive relations.
#define prim_assn(p,P) assn_t p(term_opt_t t1, term_opt_t t2) { \
  if (t1 == NULL || t2 == NULL) return &true_assn; \
  return prim((term_t)t1,P,(term_t)t2); \
}

prim_assn(slt,SLt)
  prim_assn(slte,SLte)
  prim_assn(ult,ULt)
  prim_assn(ulte,ULte)
#define sgte(t1,t2) (slte(t2,t1))
#define ugte(t1,t2) (ulte(t2,t1))
#define sgt(t1,t2) (slt(t2,t1))
#define ugt(t1,t2) (ult(t2,t1))

static assn_t not_prim(term_t t1, Absyn::primop_t p, term_t t2) {
  switch (p) {
  case Eq : return neq(t1,t2);
  case Neq: return eq(t1,t2);
  case SLt : return sgte(t1,t2);
  case SLte: return sgt(t1,t2);
  case ULt : return ugte(t1,t2);
  case ULte: return ugt(t1,t2);
  default: Warn::impos("Vcgen::not_prim: non-primop");
  }
}

assn_t not(assn_t a) {
  switch (a) {
  case &True: return &false_assn;
  case &False: return &true_assn;
  case &Prim(t1,p,t2): return not_prim(t1,p,t2);
  case &Not(a): return a;
  default:
    let ptr = Not(a);
    return hash_cons(&ptr);
  }
}

////// Push Through Subst and Not nodes ////
// These functions take care of eliminating all of the Not and
// Subst nodes in an assertion in one pass.  It is, unfortunately,
// something that requires crawling over the tree, not just the dag.
// However, we could improve things by memoizing the results, since
// it's likely that we'll hit the same substitutions for various
// assertion nodes.  The problem is that we will generally have
// different environments built up when we run into them.

// Both reduce_term and reduce_assn take in a substitution for 
// non-escaping variables, as well as a pointer to a substitution
// for escaping variables.  
// TRY: we could try using dictionaries here instead of lists.

static term_t 
reduce_term(term_t t, list_t<$(vardecl_t,term_t)@> subst) {
  switch (t) {
  case &Uint(_): 
  case &Const(_): 
  case &LogicVar(...): return t;
  case &Cast(tp,tm):
    let tm2 = reduce_term(tm,subst);
    if (tm != tm2) return cast(tp,tm2);
    else return t;
  case &Unop(p,tm,tp):
    let tm2 = reduce_term(tm,subst);
    if (tm != tm2) return unop(p,tm2,tp);
    else return t;
  case &Binop(p,t1,s1,tp):
    let t2 = reduce_term(t1,subst);
    let s2 = reduce_term(s1,subst);
    if (t1 != t2 || s1 != s2) return binop(p,t2,s2,tp);
    else return t;
  case &Select(t1,s1,tp):
    let t2 = reduce_term(t1,subst);
    let s2 = reduce_term(s1,subst);
    if (t1 != t2 || s1 != s2) return select(t2,s2,tp);
    else return t;
  case &Update(t1,s1,u1):
    let t2 = reduce_term(t1,subst);
    let s2 = reduce_term(s1,subst);
    let u2 = reduce_term(u1,subst);
    if (t1 != t2 || s1 != s2 || u1 != u2) return update(t2,s2,u2);
    else return t;
  case &Proj(t1,i,tp):
    let t2 = reduce_term(t1,subst);
    if (t1 != t2) return proj(t1,i,tp);
    else return t;
  case &Aggr(ts1,tp):
    list_t<term_t> ts2 = NULL;
    bool change = false;
    for (; ts1 != NULL; ts1 = ts1->tl) {
      let t1 = ts1->hd;
      let t2 = reduce_term(t1,subst);
      ts2 = new List{t2,ts2};
      if (t1 != t2) change = true;
    }
    if (change) {
      return aggr(List::imp_rev(ts2),tp);
    } else return t;
  case &Addr(vd): fallthru(vd);
  case &Var(vd):
    for (; subst != NULL; subst = subst->tl) {
      let $(vd2,t2) = *subst->hd;
      if (vd == vd2) return t2;
    }
    return t;
  case &Okderef(t1): 
    let t2 = reduce_term(t1,subst);
    if (t1 != t2) return okderef(t2);
    else return t;
  }
}

typedef list_t<$(vardecl_t,term_t)@> subst_t;
typedef Hashtable::table_t<assn_t,list_t<$(subst_t,bool,assn_t)@>> reduce_info_t;

static bool same_subst(subst_t s1, subst_t s2) {
  if (s1 == s2) return true;
  for (; s1 != NULL && s2 != NULL; s1=s1->tl, s2=s2->tl) {
    let $(vd1,t1) = *s1->hd;
    let $(vd2,t2) = *s2->hd;
    if (vd1 != vd2 || t1 != t2) return false;
    if (s1->tl == s2->tl) return true;
  }
  return (s1 != s2);
}

// We memoize the reductions to once again ensure we traverse the dag
// instead of the tree.  The problem is that we have to memoize w.r.t.
// substitution as well as the negation flag.  Nonetheless, this results
// in a substantial speedup when we have large assertions.
static assn_t 
reduce_assn(assn_t a, subst_t subst, bool negate, reduce_info_t h) {
  let info_opt = Hashtable::lookup_opt(h,a);
  list_t<$(subst_t,bool,assn_t)@> info = NULL;
  if (info_opt != NULL) {
    info = *info_opt;
    for (let p = info; p != NULL; p = p->tl) {
      let $(subst2,negate2,a2) = *p->hd;
      if (negate == negate2 && same_subst(subst,subst2)) { 
        return a2;
      }
    }
  } 
  assn_t res;
  switch (a) {
  case &True: if (negate) return &false_assn; else return &true_assn;
  case &False: if (negate) return &true_assn; else return &false_assn;
  case &Prim(t1,p,t2):
    let newt1 = reduce_term(t1,subst);
    let newt2 = reduce_term(t2,subst);
    if (negate) { res = not_prim(newt1,p,newt2); break; }
    if (t1 != newt1 || t2 != newt2) 
      a = prim(newt1,p,newt2);
    res = a;
    break;
  case &And(a1,a2):
    let newa1 = reduce_assn(a1,subst,negate,h);
    let newa2 = reduce_assn(a2,subst,negate,h);
    if (negate) { res = or(newa1,newa2); break; }
    if (a1 != newa1 || a2 != newa2) 
      a = and(newa1,newa2);
    res = a;
    break;
  case &Or(a1,a2):
    let newa1 = reduce_assn(a1,subst,negate,h);
    let newa2 = reduce_assn(a2,subst,negate,h);
    if (negate) { res = and(newa1,newa2); break; }
    if (a1 != newa1 || a2 != newa2) 
      a = or(newa1,newa2);
    res = a;
    break;
  case &Subst(vd,t,a1):
    t = reduce_term(t,subst);
    // add vd->t to the subst
    let new_subst = new List(new $(vd,t),subst);
    res = reduce_assn(a1, new_subst, negate, h);
    break;
  case &Not(a1):
    res = reduce_assn(a1, subst, !negate, h);
    break;
  }
  Hashtable::insert(h,a,new List{new $(subst,negate,res),info}); 
  return res;
}

// get rid of all Not and Subst nodes.
assn_t reduce(assn_t a) {
  // check to see if we've already eliminated them.
  let ainfo = hash_cons_it(a);
  let redopt = ainfo->reduced;
  if (redopt != NULL) return (assn_t)redopt;
  a = reduce_assn(a,NULL,false,Hashtable::create(33,assncmp,assnhash));
  ainfo->reduced = a;
  return a;
}

// a one-shot substitution -- needed in the assignment code.
term_t subst_term(term_t t, vardecl_t x, term_t newx) {
  let s = $(x,newx);
  let subst = List{&s,NULL};
  return reduce_term(t,&subst);
}

/////////////////// Assertion Factoring //////////////////
// This code isn't currently used but may be useful.  The
// basic idea is to try to pull the common conjuncts out
// to a wider scope.  Eg..,  (A & B & C) || (A & D & C) 
// should factor into (A & C) & (B || D).  

// intersect two lists of assertions returning the common
// assertions, and the remainders of the two lists.  Assumes
// the assertions are in sorted order.
static void intersect(list_t<assn_t,`H> a1s, list_t<assn_t,`H> a2s, 
                      list_t<assn_t,`H>@common,
                      list_t<assn_t,`H>@res1,
                      list_t<assn_t,`H>@res2) {
  while (true) {
    switch $(a1s,a2s) {
    case $(NULL,NULL): return;
    case $(_,NULL): *res1 = List::revappend(a1s,*res1); return;
    case $(NULL,_): *res2 = List::revappend(a2s,*res2); return;
    default: 
      int c = assncmp(a1s->hd,a2s->hd);
      if (c == 0) {
        *common = new List(a1s->hd,*common);
        a1s = a1s->tl;
        a2s = a2s->tl;
      } else if (c < 0) {
        *res1 = new List(a1s->hd,*res1);
        a1s = a1s->tl;
      } else {
        *res2 = new List(a2s->hd,*res2);
        a2s = a2s->tl;
      }
    }
  }
}

$(list_t<assn_t> common, list_t<assn_t> res1, list_t<assn_t> res2) 
  intersect_assns(list_t<assn_t,`H> a1s, list_t<assn_t,`H> a2s) {
  let common = NULL;
  let res1 = NULL;
  let res2 = NULL;
  intersect(a1s,a2s,&common,&res1,&res2);
  return $(List::imp_rev(common),List::imp_rev(res1),List::imp_rev(res2));
}

// pull out the common primitive relations, but avoid duplicating
// things in forming the full cross-product
$(list_t<assn_t>,assn_t) factor(assn_t a) {
  switch (a) {
  case &True: return $(NULL,&true_assn);
  case &False: return $(NULL,&false_assn);
  case &Prim(...): return $(new List{a,NULL},&true_assn);
  case &And(a1,a2):
    let $(c1s,a1) = factor(a1);
    let $(c2s,a2) = factor(a2);
    return $(List::merge(assncmp,c1s,c2s),and(a1,a2));
  case &Or(a1,a2):
    let $(c1s,a1) = factor(a1);
    let $(c2s,a2) = factor(a2);
    let $(cs,c1s,c2s) = intersect_assns(c1s,c2s);
    return $(cs,or(List::fold_left(and,a1,c1s),List::fold_left(and,a2,c2s)));
  default: return $(NULL,a);
  }
}

assn_t factor_assn(assn_t a) {
  //unsigned int asize = assn_size(a);
  let $(cs,a) = factor(a);
  a = List::fold_left(and,a,cs);
  //unsigned int newsize = assn_size(a);
  //fprintf(stderr,"factor before %d after %d\n",asize,newsize);
  //fprintf(stderr,"%s\n",assn2string(a));
  return a;
}

// returns the set of primitive relations implied by the assertion (if any).
// this gets cached in the hash-cons-table so it isn't recomputed.
assn_set_opt_t widen_it(assn_t a) {
  let ainfo = hash_cons_it(a);
  if (ainfo->widened_set != NULL) return *ainfo->widened_set;
  assn_set_opt_t s;
  switch (a) {
  case &True: s = Set::empty(assncmp); break;
  case &False: s = NULL; break;
  case &And(a1,a2):
    let s1 = widen_it(a1);
    let s2 = widen_it(a2);
    if (s1 == NULL || s2 == NULL) 
      s = NULL; 
    else 
      s = Set::union_two((assn_set_t)s1,(assn_set_t)s2);
    break;
  case &Or(a1,a2):
    let s1 = widen_it(a1);
    let s2 = widen_it(a2);
    if (s1 == NULL) 
      s = s2;
    else if (s2 == NULL)
      s = s1;
    else
      s = Set::intersect((assn_set_t)s1,(assn_set_t)s2);
    break;
  case &Prim(t1,p,t2):
    s = Set::singleton(assncmp,a);
    switch (p) {
    case Eq:
      // when we have t1 == t2 and they are of integral type, then we
      // also want to remember that t1 <= t2 and t2 <= t1 so that when
      // we intersect, we don't lose the information.
      let topt1 = get_term_type(t1);
      let topt2 = get_term_type(t2);
      if ((topt1 != NULL && Tcutil::is_integral_type((type_t)topt1)) ||
          (topt2 != NULL && Tcutil::is_integral_type((type_t)topt2))) {
        s = Set::insert(s,slte(t1,t2));
        s = Set::insert(s,slte(t2,t1));
        s = Set::insert(s,ulte(t1,t2));
        s = Set::insert(s,ulte(t2,t1));
      }
      break;
    case SLt:
      s = Set::insert(s,slte(t1,t2));
      break;
    case ULt:
      s = Set::insert(s,ulte(t1,t2));
      break;
    default: break;
    }
    break;
  default:
    s = widen_it(reduce(a));
    break;
  }
  ainfo->widened_set = new s;
  return s;
}

// factors out all of the common primitive relations in a.
assn_t widen(assn_t a) {
  // force the hash-cons table to be around just to be safe
  let sopt = widen_it(a);
  if (sopt == NULL) return &false_assn;
  let res = Set::fold(and,(assn_set_t)sopt,&true_assn);
  return res;
}

// tries to see if a can be proved from the set of primitive
// relations in ctxt.
static bool simple_prv(assn_set_t ctxt, assn_t a) {
  while (true) {
    switch (a) {
    case &Prim(t1,p,t2): 
      if (Set::member(ctxt,a)) return true;
      switch (p) {
      case Neq: 
        return (Set::member(ctxt,ult(t2,t1)) ||
                Set::member(ctxt,ugt(t2,t1)) ||
                Set::member(ctxt,slt(t2,t1)) ||
                Set::member(ctxt,sgt(t2,t1)));
      case SLte: 
        return (Set::member(ctxt,slt(t1,t2)) || 
                Set::member(ctxt,eq(t1,t2)));
      case ULte: 
        return (Set::member(ctxt,ult(t1,t2)) || 
                Set::member(ctxt,eq(t1,t2)));
      default: return false;
      }
    case &True: return true;
    case &False: return false;
    case &And(a1,a2): 
      if (!simple_prv(ctxt,a1)) return false;
      a = a2; 
      continue;
    case &Or(a1,a2): 
      if (simple_prv(ctxt,a1)) return true;
      a = a2;
      continue;
    default: 
      a = reduce(a);
      continue;
    }
  }
}


// returns true when ctxt |- a
// uses only very local, syntactic matching.
bool simple_prove(assn_t ctxt, assn_t a) {
  if (ctxt == a) return true; 
  let sopt = widen_it(ctxt);
  if (sopt == NULL) return true;
  return simple_prv((assn_set_t)sopt, a);
}
