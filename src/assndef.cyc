/* Computing Strongest Post-conditions
   Copyright (C) 2003 Greg Morrisett
   This file is part of the Cyclone compiler.

   The Cyclone compiler is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   The Cyclone compiler is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with the Cyclone compiler; see the file COPYING. If not,
   write to the Free Software Foundation, Inc., 59 Temple Place -
   Suite 330, Boston, MA 02111-1307, USA. */

/* this file contains the definition of assertions, the terms used in
   assertions as well as utilities on them (such as comparison, debugging
   printing etc.). */

#include "flags.h"
#include "assndef.h"
#include "pratt_prover.h"
#include <sexp.h>
#include <set.h>
namespace AssnDef;
using List;
using Hashtable;
///////////////////// Terms /////////////////////

datatype Term {
  Uint(unsigned int);
  Const(exp_t); // a Cyclone "constant" expression (e.g., 3, sizeof(e), etc.)
  Var(vardecl_t);
  LogicVar(vardecl_opt_t,int,type_opt_t);
  Unop(Absyn::primop_t,term_t,type_opt_t);
  Binop(Absyn::primop_t,term_t,term_t,type_opt_t);
  Cast(Absyn::type_t, term_t);
};

string_t term2string(term_t t) {
  string_t res;
  switch (t) {
  case &Uint(i): res = aprintf("0x%x", i); break;
  case &Const(e): res = Absynpp::exp2string(e); break;
  case &Var(vd): 
    if (Flags::debug_assn) 
      res = aprintf("%s_%x",Absynpp::qvar2string(vd->name),(unsigned int)vd); 
    else 
      res = Absynpp::qvar2string(vd->name);
    break;
  case &LogicVar(NULL,i,_): res = aprintf("_X%d",i); break;
  case &LogicVar(vd,i,_): 
    res = aprintf("_%s%d",Absynpp::qvar2string(vd->name),i); break;
  case &Binop(p,t1,t2,_):
    res = aprintf("(%s%s%s)",term2string(t1),Absynpp::prim2string(p),
                  term2string(t2));
    break;
  case &Unop(p,t1,_):
    res = aprintf("%s(%s)",Absynpp::prim2string(p),term2string(t1)); break;
  case &Cast(tp,tm):
    res = aprintf("(%s)%s",Absynpp::typ2string(tp),term2string(tm)); break;
  }
  return res;
}

static int hash_exp(exp_t e) {
  switch (e->r) {
  case &Absyn::Const_e(...): return 0;
  case &Absyn::Var_e(...): return 1;
  case &Absyn::Pragma_e(...): return 2;
  case &Absyn::Primop_e(...): return 3;
  case &Absyn::Conditional_e(...): return 4;
  case &Absyn::And_e(...): return 5;
  case &Absyn::Or_e(...): return 6;
  case &Absyn::SeqExp_e(...): return 7;
  case &Absyn::NoInstantiate_e(...): return 8;
  case &Absyn::Instantiate_e(...): return 9;
  case &Absyn::Cast_e(...): return 10;
  case &Absyn::Address_e(...): return 11;
  case &Absyn::Sizeoftype_e(...): return 12;
  case &Absyn::Sizeofexp_e(...): return 13;
  case &Absyn::Offsetof_e(...): return 14;
  case &Absyn::Enum_e(...): return 15;
  case &Absyn::AnonEnum_e(...): return 16;
  case &Absyn::Valueof_e(...): return 17;
  case &Absyn::Assert_e(...): return 18;
  default: return 19;
  }
}

static int termhash(datatype Term @t) {
  switch (t) {
  case &Uint(i): return i;
  case &Const(e): return hash_exp(e) + 61;
  case &Var(vd): return (unsigned int)vd;
  case &LogicVar(vd,i,_): return (unsigned int)vd ^ (i+1);
  case &Binop(p,t1,t2,_):
    return p ^ (unsigned int)t1 ^ (unsigned int)t2;
  case &Unop(p,t1,_): return p ^ (unsigned int)t1 + 1;
  case &Cast(_,t): return termhash(t);
  }
}

int cmp_term(datatype Term @t1, datatype Term @t2) {
  switch $(t1,t2) {
  case $(&Uint(i1), &Uint(i2)): return i1-i2;
  case $(&Uint(_), _): return -1;
  case $(_, &Uint(_)): return 1;
  case $(&Const(e1),&Const(e2)): return Evexp::exp_cmp(e1,e2);
  case $(&Const(_),_): return -1;
  case $(_,&Const(_)): return 1;
  case $(&Var(vd1),&Var(vd2)): return (int)vd1 - (int)vd2;
  case $(&Var(_),_): return -1;
  case $(_,&Var(_)): return 1;
  case $(&LogicVar(vd1,i,_),&LogicVar(vd2,j,_)): 
    if (vd1 == vd2) return (i - j);
    return (int)vd1 - (int)vd2;
  case $(&LogicVar(...),_): return -1;
  case $(_,&LogicVar(...)): return 1;
  case $(&Cast(tp1,tm1),&Cast(tp2,tm2)):
    int c = Tcutil::typecmp(tp1,tp2);
    if (c != 0) return c;
    return cmp_term(tm1,tm2);
  case $(&Cast(...),_): return -1;
  case $(_,&Cast(...)): return 1;
  case $(&Unop(p1,t1,_),&Unop(p2,t2,_)): 
    if (p1 != p2) return (int)p1 - (int)p2;
    return cmp_term(t1,t2);
  case $(&Unop(...),_): return -1;
  case $(_,&Unop(...)): return 1;
  case $(&Binop(p1,t11,t12,tp1),&Binop(p2,t21,t22,tp2)):
    if (p1 != p2) return (int)p1 - (int)p2;
    int c = cmp_term(t11,t21);
    if (c != 0) return c;
    return  cmp_term(t12,t22);
  }
}

static term_t copy_term(datatype Term@ t) {
  switch (t) {
  case &Uint(i): return new Uint(i);
  case &Const(e): return new Const(e);
  case &Var(vd): return new Var(vd);
  case &LogicVar(vd,i,tp): return new LogicVar(vd,i,tp);
  case &Binop(p,t1,t2,tp): return new Binop(p,t1,t2,tp);
  case &Unop(p,t,tp): return new Unop(p,t,tp);
  case &Cast(tp,t): return new Cast(tp,t);
  }
}

// a hash-table to hold all of the term nodes to maximize sharing.  
static struct Hashtable::Table<term_t,term_t> *term_hash_cons_table = NULL;

static term_t hash_cons_term(datatype Term @t) {
  Hashtable::table_t h;
  if (term_hash_cons_table == NULL) {
    h = Hashtable::create(123, cmp_term, termhash);
    term_hash_cons_table = h;
  } else {
    h = (Hashtable::table_t)term_hash_cons_table;
  }
  let resopt = Hashtable::lookup_other_opt(h,t,cmp_term,termhash);
  if (resopt == NULL) {
    let t2 = copy_term(t);
    Hashtable::insert(h,t2,t2);
    return t2;
  } else return *resopt;
}


// rewrite uint, cnst, var, 
term_t uint(unsigned int i) {
  let t = Uint(i);
  return hash_cons_term(&t);
}
term_t zero() {
  return uint(0);
}
term_t one() {
  return uint(1);
}
term_t cnst(Absyn::exp_t e) { 
  let $(c, known) = Evexp::eval_const_uint_exp(e);
  if (known) return uint(c);
  let t = Const(e);
  return hash_cons_term(&t);
}
term_t var(vardecl_t vd) { 
  let t = Var(vd);
  return hash_cons_term(&t);
}
term_t logicvar(vardecl_opt_t vd,int i,type_opt_t tp) {
  let t = LogicVar(vd,i,tp);
  return hash_cons_term(&t);
}

inline static bool is_nonassociative_commutative(Absyn::primop_t p) {
  switch (p) {
  case Absyn::Eq:
  case Absyn::Neq: return true;
  default: return false;
  }
}

inline static bool is_associative_commutative(Absyn::primop_t p) {
  switch (p) {
  case Absyn::Plus:
  case Absyn::Times:
  case Absyn::Bitand:
  case Absyn::Bitor:
  case Absyn::Bitxor: return true;
  default: return false;
  }
}

Absyn::type_opt_t get_term_type(term_t t) {
  switch (t) {
  case &Uint(_): return Absyn::int_type(Absyn::None, Absyn::Int_sz);
  case &Const(e): return e->topt;
  case &Var(vd): return vd->type;
  case &LogicVar(_,_,topt): return topt;
  case &Binop(_,_,_,tp): return tp;
  case &Unop(_,_,tp): return tp;
  case &Cast(tp,_): return tp;
  }
}

term_t plus(term_t t1, term_t t2, type_opt_t tp) {
  return binop(Absyn::Plus,t1,t2,tp);
}
term_t minus(term_t t1, term_t t2, type_opt_t tp) {
  return binop(Absyn::Minus,t1,t2,tp);
}

term_t unop(Absyn::primop_t p, term_t t, type_opt_t tp) {
  // +t = t;
  if (p == Absyn::Plus) return t;
  let ptr = Unop(p,t,tp);
  return hash_cons_term(&ptr);
}


//evaluating commutative associative bin op on constants.
static term_t eval_binop(Absyn::primop_t p, unsigned i, unsigned j){
  switch(p){
  case Absyn::Plus: return uint(i+j);
  case Absyn::Times: return uint(i*j);
  case Absyn::Bitand: return uint(i & j);
  case Absyn::Bitor: return uint(i | j);
  case Absyn::Bitxor: return uint(i ^ j);
  default: Warn::impos("Error in evaluating binop");
  }
}
// for a binop p that is both commutative and associative
// t has normal form for p, i.e., t = (((t1 p t2) p t3)...p tn)
// where t1 >= t2 >= t3 >= tn
static $(list_t<term_t,`H>, unsigned *) flatten(Absyn::primop_t p, term_t t){
  list_t<term_t,`H> termlist = NULL;
  unsigned * res = NULL;
 LOOP:
  switch (t){
  case &Uint(i): res = new i; break;
  case &Binop(p1,t1,&Uint(i),_) && p1 == p: 
    res = new i;
    t = t1;
    goto LOOP;
  case &Binop(p1, t1, t2,_)&& p1 == p:
    termlist = new List(t2, termlist);
    t = t1;
    goto LOOP;
  default:
    termlist = new List(t, termlist);
    break;
  }
  return $(termlist,res);
}

static int inv_cmp_term(term_t t1, term_t t2){
  return -cmp_term(t1, t2);
}
static term_t flatten_merge(Absyn::primop_t p, term_t t1, term_t t2, type_opt_t topt){
  let $(tlist1,ip1) = flatten(p,t1);
  let $(tlist2,ip2) = flatten(p,t2);
  // termlist is (tn, tn-1, ..., t2, t1) where ti >= t(i-1).
  let termlist = List::imp_merge(inv_cmp_term, tlist1, tlist2);
  if (termlist == NULL){
    Warn::impos(" commutative associative operator has no non constant operators!");
  }
  term_t t = termlist->hd;
  termlist = termlist -> tl;
  while(termlist != NULL){
    let ptr = Binop(p,t, termlist->hd, topt);
    t = hash_cons_term(&ptr);
    termlist = termlist->tl;
  }
  if (ip1 == NULL) {
    if (ip2 != NULL) {
      if (((p == Absyn::Plus) && (*ip2 == 0))||
	  ((p == Absyn::Times) && (*ip2 == 1)))
	return t;
      let ptr = Binop(p, t, uint(*ip2),topt);
      t = hash_cons_term(&ptr);
    }
  } else {
    if (ip2 != NULL) {
      term_t binres = eval_binop(p, *ip1, *ip2);
      if (((p == Absyn::Plus) && (cmp_term(binres, zero())==0)) ||
	  ((p == Absyn::Times) && (cmp_term(binres, one())==0)))
	return t;
      let ptr = Binop(p, t, binres, topt);
      t = hash_cons_term(&ptr);
    } else {
      if (((p == Absyn::Plus) && (*ip1 == 0))||
	  ((p == Absyn::Times) && (*ip1 == 1)))
	return t;
      let ptr = Binop(p, t, uint(*ip1), topt);
      t = hash_cons_term(&ptr);
    }
  }
  return t;
}

term_t binop(Absyn::primop_t p, term_t t1, term_t t2, type_opt_t tp) {
  if (is_nonassociative_commutative(p) && cmp_term(t1,t2) < 0) {
    t1 :=: t2;
  }
  switch $(p,t1,t2) {
    // constant folding
  case $(_,&Uint(i),&Uint(j)):
    switch (p) {
    case Absyn::Plus: return uint(i+j);
    case Absyn::Minus: return uint(i-j);
    case Absyn::Bitand: return uint(i & j);
    case Absyn::Bitor: return uint(i | j);
    case Absyn::Bitxor: return uint(i ^ j);
    case Absyn::Bitlshift: return uint(i << j);
    case Absyn::Bitlrshift: return uint(i >> j);
    default: break;
    }
    break;
    // t1 - c  ==>  t1 + (-c)
  case $(Absyn::Minus,t1,&Uint(i)): return plus(t1,uint(0 - i),tp);
    // t - t   ==>  0
  case $(Absyn::Minus,t1,t2):
    if (cmp_term(t1,t2) == 0) return uint(0);
    break;
    // t1 + 0  ==>  t1
    //  case $(Absyn::Plus,t1,&Uint(0)): return t1;
    // t1 * 1  ==>  t1
    //  case $(Absyn::Times,t1,&Uint(1)): return t1;
    // trying to normalize for commutative and associative operator p
    // into the form ((t1 p t2) p t3) ... p tn) where
    // t1 <= t2 <= t3 <= ... <= tn
  default:
    if (is_associative_commutative(p)) return flatten_merge(p,t1,t2,tp);
    break;
  }
  let p = Binop(p,t1,t2,tp);
  return hash_cons_term(&p);
}

term_t cast(Absyn::type_t tp, term_t tm) {
  let t = Cast(tp,tm);
  return hash_cons_term(&t);
}
term_t fresh_var(type_opt_t t) {
  static int counter = 0;
  return logicvar(NULL,counter++,t);
}

static bool same_term(term_t t1, term_t t2) { return cmp_term(t1,t2) == 0; }

///////////////////// Assertions /////////////////////
datatype Assn {
  True;
  False;
  Prim(term_t,prim_reln_t,term_t);
  And(assn_t,assn_t);
  Or(assn_t,assn_t);
  Not(assn_t);
  Subst(vardecl_t x,term_t t,assn_t a); // a[t/x] -- lazy substitution
  Kill(assn_t); // replace all escaping variables with fresh logic variables
};

// inner loop for calculating the size of an assertion -- we
// take care to figure out the size as a dag and not a tree.
static unsigned int 
assn_size_loop(assn_t a, unsigned int c, list_t<assn_t,`H>@ prev){
 LOOP:
  if (memq(*prev,a)) return c;
  *prev = new List(a,*prev);
  switch (a) {
  case &True:  return c;
  case &False: return c;
  case &Prim(...): return 1+c;
  case &And(a1,a2): fallthru(a1,a2);
  case &Or(a1,a2): 
    c = assn_size_loop(a2,1+c,prev);
    a = a1;
    goto LOOP;
  case &Not(a1):
    ++c;
    a = a1;
    goto LOOP;
  case &Subst(vd,t,a1):
    ++c;
    a = a1;
    goto LOOP;
  case &Kill(a1): 
    ++c;
    a = a1;
    goto LOOP;
  }
}

// counter used for reporting purposes
static unsigned int max_assn_size = 0;

// calculate the size of an assertion
unsigned int assn_size(assn_t a) {
  list_t<assn_t,`H> prev = NULL;
  let c = assn_size_loop(a,0,&prev);
  if (c > max_assn_size) {
    max_assn_size = c;
  }
  return c;
}

static string_t d2string(assn_t a, int @c,
                         list_t<$(assn_t,string_t<`H>,string_t<`H>)@`H,`H>@ prev) {
  for (let ps = *prev; ps != NULL; ps = ps->tl) {
    let &$(a1,n,v) = ps->hd;
    if ((unsigned int)a1 == (unsigned int)a) return n;
  }
  let n = aprintf("A%d",*c); 
  *c = *c+1;
  string_t s;
  switch (a) {
  case &True: s = "true"; break;
  case &False: s = "false"; break;
  case &Prim(...): s = assn2string(a); break;
  case &And(a1,a2):
    let d1 = d2string(a1,c,prev);
    let d2 = d2string(a2,c,prev);
    s = aprintf("%s && %s",d1,d2);
    break;
  case &Or(a1,a2):
    let d1 = d2string(a1,c,prev);
    let d2 = d2string(a2,c,prev);
    s = aprintf("%s || %s",d1,d2);
    break;
  case &Not(a):
    let d = d2string(a,c,prev);
    s = aprintf("not(%s)",d);
    break;
  case &Subst(vd,t,a):
    let d = d2string(a,c,prev);
    s = aprintf("Subst[%s=%s](%s)",Absynpp::qvar2string(vd->name),
                term2string(t),d);
    break;
  case &Kill(a):
    let d = d2string(a,c,prev);
    s = aprintf("Kill(%s)",d);
    break;
  }
  *prev = new List{new $(a,n,s),*prev};
  return n;
}

string_t dag2string(assn_t a) {
  list_t<$(assn_t,string_t<`H>,string_t<`H>)@`H,`H> decls = NULL;
  string_t@`H newline = new "\n";
  string_t@`H equals = new " = ";
  int count = 0;
  string_t res = d2string(a,&count,&decls);
  list_t<string_t@`H,`H> strings = new List{new " in ",new List{new res,NULL}};
  for (; decls != NULL; decls = decls->tl) {
    let &$(_,*n,*d) = decls->hd;
    strings = new List{n,new List{equals,new List{d,new List{newline,strings}}}};
  }
  return strconcat_l(strings);
}

// calculate a string representation (and total tree node count) for an
// assertion.  the prec field (precedent) is used to avoid some parens.
static string_t a2string(assn_t a, int prec, int@ size) {
  switch (a) {
  case &True: return "true";
  case &False: return "false";
  case &Prim(t1,p,t2):
    *size += 1;
    string_t ps;
    switch (p) {
    case Eq: ps = "=="; break;
    case Neq: ps = "!="; break;
    case SLt: ps = " S< "; break;
    case SLte: ps = " S<= "; break;
    case ULt: ps = " U< "; break;
    case ULte: ps = " U<= "; break;
    default: Warn::impos("assn2string primop");
    }
    return aprintf("%s%s%s",term2string(t1),ps,term2string(t2));
  case &Or(a1,a2): 
    *size += 1;
    if (prec <= 5)
      return aprintf("%s || %s",a2string(a1,5,size),a2string(a2,5,size));
    else 
      return aprintf("(%s || %s)",a2string(a1,5,size),a2string(a2,5,size));
  case &And(a1,a2): 
    *size += 1;
    if (prec <= 10)
      return aprintf("%s && %s",a2string(a1,10,size),a2string(a2,10,size));
    else 
      return aprintf("(%s && %s)",a2string(a1,10,size),a2string(a2,10,size));
  case &Not(a1):
    *size += 1;
    return aprintf("!%s",a2string(a1,20,size));
  case &Subst(vd,t,a):
    *size += 1;
    return aprintf("Subst[%s:=%s](%s)",Absynpp::qvar2string(vd->name),
                   term2string(t),a2string(a,0,size));
  case &Kill(a):
    *size += 1;
    return aprintf("Kill(%s)",a2string(a,0,size));
  }
}

int tree_size = 0;

// convert an assertion to a string.
string_t assn2string(assn_t a) {
  tree_size = 0;
  return a2string(a,0,&tree_size);
}

// assertion constants for true and false
datatype Assn.True true_assn = True;
datatype Assn.False false_assn = False;

//////////////////////////////////////////////////////////////
// hash-consing to try to preserve as much sharing as we
// can -- has a nice impact on performance (much better than
// lazy substitution), but alas, we still end up allocating a lot.  
// It would be better if we didn't have to allocate the thing 
// that want to lookup.  That could happen if we had a different 
// type for hashtable lookup (as we did with dictionaries.)

int assnhash(datatype Assn @a) {
  switch (a) {
  case &False: return 0;
  case &True: return 1;
  case &Prim(t1,p,t2): 
    return (unsigned int)t1 ^ (unsigned int)p ^ (unsigned int)t2;
  case &And(a1,a2): return (unsigned int)a1 ^ (unsigned int)a2;
  case &Or(a1,a2): return ((unsigned int)a1 ^ (unsigned int)a2) | 1;
  case &Not(a1): return ((unsigned int)a1) + 61;
  case &Subst(vd,t,a): return ((unsigned int)a ^ (unsigned int)vd ^
                               (unsigned int)t) | 3;
  case &Kill(a): return (unsigned int)a + 37;
  }
}

// compare two assertions for structural equality -- does not assume
// the components have been hash-consed, but probably could.
int assncmp(datatype Assn @a1, datatype Assn @a2) {
 LOOP:
  if (a1 == a2) return 0;
  switch $(a1,a2) {
  case $(&True,&True): return 0;
  case $(&True,_): return -1;
  case $(_,&True): return 1;
  case $(&False,&False): return 0;
  case $(&False,_): return -1;
  case $(_,&False): return 1;
  case $(&Or(a11,a12),&Or(a21,a22)): fallthru(a11,a12,a21,a22);
  case $(&And(a11,a12),&And(a21,a22)): 
    int c = assncmp(a11,a21);
    if (c != 0) return c;
    a1 = a12;
    a2 = a22;
    goto LOOP;
  case $(&Or(_,_),_): return -1;
  case $(_,&Or(_,_)): return 1;
  case $(&And(_,_),_): return -1;
  case $(_,&And(_,_)): return 1;
  case $(&Prim(t11,p1,t12),&Prim(t21,p2,t22)):
    int c = (int)p1 - (int)p2;
    if (c != 0) return c;
    c = cmp_term(t11,t21);
    if (c != 0) return c;
    return cmp_term(t12,t22);
  case $(&Prim(...),_): return -1;
  case $(_,&Prim(...)): return 1;
  case $(&Not(na1),&Not(na2)): a1 = na1; a2 = na2; goto LOOP;
  case $(&Not(_),_): return -1;
  case $(_,&Not(_)): return 1;
  case $(&Kill(na1),&Kill(na2)): a1 = na1; a2 = na2; goto LOOP;
  case $(&Kill(_),_): return -1;
  case $(_,&Kill(_)): return 1;
  case $(&Subst(vd1,t1,a11),&Subst(vd2,t2,a22)):
    int c = (int)vd1 - (int)vd2;
    if (c != 0) return c;
    c = cmp_term(t1,t2);
    if (c != 0) return c;
    a1 = a11;
    a2 = a22;
    goto LOOP;
  }
}

// a hash-table to hold all of the assertion nodes to maximize
// sharing.  we also record whether or not a node has delayed
// substitutions or kills within it, and also provide an optional 
// set of primitive assertions that correspond to the factored
// normal form for the assertion.
typedef Set::set_t<assn_t> assn_set_t;
typedef struct Set::Set<assn_t> *assn_set_opt_t;

static struct Hashtable::Table<assn_t,$(assn_t,bool reduced,assn_set_opt_t@)@> 
*hash_cons_table = NULL;

static Hashtable::table_t<assn_t,$(assn_t,bool reduced,assn_set_opt_t@)@>
get_hash_cons_table() {
  Hashtable::table_t h;
  if (hash_cons_table == NULL) {
    h = Hashtable::create(123, assncmp, assnhash);
    hash_cons_table = h;
    // make sure true and false are in the table so we can
    // ask if they are reduced.
    assn_set_opt_t s = Set::empty(assncmp);
    Hashtable::insert(h,&true_assn,new $(&true_assn,true,new s));
    Hashtable::insert(h,&false_assn,new $(&false_assn,true,new NULL));
  } else {
    h = (Hashtable::table_t)hash_cons_table;
  }
  return h;
}

void reset_hash_cons_table(void){
  term_hash_cons_table = NULL;
  hash_cons_table = NULL;
};
// lookup an assertion to see if it has delayed substitutions or
// kills with in it.  
bool is_reduced(assn_t a) {
  let resopt = Hashtable::lookup_opt(get_hash_cons_table(),a);
  if (resopt == NULL) return false;
  let &$(_,b,_) = *resopt;
  return b;
}

// shallow copy of an assertion from region `r to the heap and 
// simultaneously determine whether or not the assertion is
// reduced so that we can put the information in the table.
static $(assn_t,bool reduced) copy_assn(datatype Assn@`r a){
  switch (a) {
  case &True: return $(&true_assn,true);
  case &False: return $(&false_assn,true);
  case &And(a1,a2): 
    return $(new And(a1,a2),is_reduced(a1) && is_reduced(a2));
  case &Or(a1,a2): 
    return $(new Or(a1,a2),is_reduced(a1) && is_reduced(a2));
  case &Not(a): return $(new Not(a),false);
  case &Prim(t1,p,t2): return $(new Prim(t1,p,t2),true);
  case &Subst(vd1,t1,a1): return $(new Subst(vd1,t1,a1),false);
  case &Kill(a): return $(new Kill(a),false);
  }
}

// given an assertion node, look it up in the hash-table.  If it's
// not already there, then make a shallow copy and enter it (along
// with info regarding whether or not it's been reduced) into the
// hash table.
static assn_t hash_cons(datatype Assn@`r a) {
  Hashtable::table_t h = get_hash_cons_table();
  let resopt = Hashtable::lookup_other_opt(h,a,assncmp,assnhash);
  if (resopt == NULL) {
    let $(res,reduced) = copy_assn(a);
    Hashtable::insert(h,res,new $(res,reduced,new NULL));
    return res;
  } else {
    let &$(res,_,_) = *resopt;
    return res;
  }
}

// build a kill node.
assn_t kill(assn_t a) {
  switch (a) {
  case &True: 
  case &False:
  case &Kill(_): return a; // Kill(Kill(a)) = Kill(a)
  default:
    let p = Kill(a);
    return hash_cons(&p);
  }
}

// build an and node.
assn_t and(assn_t a1, assn_t a2) {
  if (a1 == a2) return a1;
  switch $(a1,a2) {
  case $(&True,_): return a2;
  case $(_,&True): return a1;
  case $(&False,_): return a1;
  case $(_,&False): return a2;
  default: 
    // NB: used to sort the operands based on physical address, but
    // to keep things more deterministic, I'm not sorting now.
    let a = And(a1,a2);
    return hash_cons(&a);
  }
}

// build an or-node.
assn_t or(assn_t a1, assn_t a2) {
  if (a1 == a2) return a1;
  switch $(a1,a2) {
  case $(&True,_): return a1;
  case $(_,&True): return a2;
  case $(&False,_): return a2;
  case $(_,&False): return a1;
  default: 
    // NB: used to sort the operands based on physical address, but
    // to keep things more deterministic, I'm not sorting now.
    let a = Or(a1,a2);
    return hash_cons(&a);
  }
}

// build a lazy substitution node.  
assn_t subst(vardecl_t x, term_t newx, assn_t a) {
  switch (a) {
  case &True:
  case &False: return a;
  default:
    let p = Subst(x,newx,a); 
    return hash_cons(&p);
  }
}

// build a primitive relation node.
assn_t prim(term_t t1, prim_reln_t p, term_t t2) {
  let ptr = Prim(t1,p,t2);
  return hash_cons(&ptr);
}

// for eq and neq, we sort the terms
assn_t eq(term_opt_t t1opt, term_opt_t t2opt) {
  if (t1opt == NULL || t2opt == NULL) return &true_assn;
  let t1 = (term_t)t1opt;
  let t2 = (term_t)t2opt;
  if (cmp_term(t1,t2) > 0) {
    t1 :=: t2;
  }
  return prim(t1,Eq,t2); 
}

// for eq and neq, we sort the terms
assn_t neq(term_opt_t t1opt, term_opt_t t2opt) {
  if (t1opt == NULL || t2opt == NULL) return &true_assn;
  let t1 = (term_t)t1opt;
  let t2 = (term_t)t2opt;
  if (cmp_term(t1,t2) > 0) {
    t1 :=: t2;
  }
  return prim(t1,Neq,t2); 
}

// some macros and functions for rest of the primitive relations.
#define prim_assn(p,P) assn_t p(term_opt_t t1, term_opt_t t2) { \
  if (t1 == NULL || t2 == NULL) return &true_assn; \
  return prim((term_t)t1,P,(term_t)t2); \
}

prim_assn(slt,SLt)
  prim_assn(slte,SLte)
  prim_assn(ult,ULt)
  prim_assn(ulte,ULte)
#define sgte(t1,t2) (slte(t2,t1))
#define ugte(t1,t2) (ulte(t2,t1))
#define sgt(t1,t2) (slt(t2,t1))
#define ugt(t1,t2) (ult(t2,t1))

static assn_t not_prim(term_t t1, Absyn::primop_t p, term_t t2) {
  switch (p) {
  case Eq : return neq(t1,t2);
  case Neq: return eq(t1,t2);
  case SLt : return sgte(t1,t2);
  case SLte: return sgt(t1,t2);
  case ULt : return ugte(t1,t2);
  case ULte: return ugt(t1,t2);
  default: Warn::impos("Vcgen::not_prim: non-primop");
  }
}

assn_t not(assn_t a) {
  switch (a) {
  case &True: return &false_assn;
  case &False: return &true_assn;
  case &Prim(t1,p,t2): return not_prim(t1,p,t2);
  case &Not(a): return a;
  default:
    let ptr = Not(a);
    return hash_cons(&ptr);
  }
}

////// Push Through Subst, Kill, and Not nodes ////
// These functions take care of eliminating all of the Not, Kill and
// Subst nodes in an assertion in one pass.  It is, unfortunately,
// something that requires crawling over the tree, not just the dag.
// However, we could improve things by memoizing the results, since
// it's likely that we'll hit the same substitutions for various
// assertion nodes.  The problem is that we will generally have
// different environments built up when we run into them.

// Both reduce_term and reduce_assn take in a substitution for 
// non-escaping variables, as well as a pointer to a substitution
// for escaping variables.  We want to reduce Kill(a) to something
// like substitute fresh logic variables for each escaping variable
// in a.  We do this by accumulating a substitution for the escaping
// variables as we go.  So, the esc_subst pointer is non-NULL when
// we are under a Kill node.

// TRY: we could try using dictionaries here instead of lists.
static term_t 
reduce_term(term_t t, list_t<$(vardecl_t,term_t)@`H,`H> non_esc_subst,
            list_t<$(vardecl_t,term_t)@`H,`H> *esc_subst) {
  switch (t) {
  case &Uint(_):
  case &Const(_):
  case &LogicVar(...): return t;
  case &Cast(tp,tm):
    let tm2 = reduce_term(tm,non_esc_subst,esc_subst);
    if (tm != tm2) return cast(tp,tm2);
    else return t;
  case &Unop(p,tm,tp):
    let tm2 = reduce_term(tm,non_esc_subst,esc_subst);
    if (tm != tm2) return unop(p,tm2,tp);
    else return t;
  case &Binop(p,t1,s1,tp):
    let t2 = reduce_term(t1,non_esc_subst,esc_subst);
    let s2 = reduce_term(s1,non_esc_subst,esc_subst);
    if (t1 != t2 || s1 != s2) return binop(p,t2,s2,tp);
    else return t;
  case &Var(vd):
    if (vd->escapes && esc_subst != NULL) {
      // it's an escaping variable and we're under a Kill node.
      // see if we've already assigned it a fresh variable in the esc_subst.
      let s = *esc_subst;
      for (; s != NULL; s = s->tl) {
        let $(vd2,t2) = *s->hd;
	//wangyl: originally it was "return t", but I think it's t2
        if (vd2 == vd) return t2;
      }
      // if not, then assign it a fresh variable and record it in the
      // esc_subst.
      let t = fresh_var(vd->type);
      *esc_subst = new List{new $(vd,t),*esc_subst};
      return t;
    } else if (!vd->escapes) {
      // it's a non-escaping variable -- look it up in non_esc_subst.
      for (; non_esc_subst != NULL; non_esc_subst = non_esc_subst->tl) {
        let $(vd2,t2) = *non_esc_subst->hd;
        if (vd == vd2) return t2;
      }
    }
    return t;
  }
}

static assn_t 
reduce_assn(assn_t a, list_t<$(vardecl_t,term_t)@`H,`H> non_esc_subst, 
            list_t<$(vardecl_t,term_t)@`H,`H> *esc_subst,
            bool negate) {
  assn_t res;
 LOOP:
  switch (a) {
  case &True: if (negate) return &false_assn; else return &true_assn;
  case &False: if (negate) return &true_assn; else return &false_assn;
  case &Prim(t1,p,t2):
    let newt1 = reduce_term(t1,non_esc_subst,esc_subst);
    let newt2 = reduce_term(t2,non_esc_subst,esc_subst);
    if (negate) return not_prim(t1,p,t2);
    if (t1 != newt1 || t2 != newt2) 
      a = prim(newt1,p,newt2);
    return a;
  case &And(a1,a2):
    let newa1 = reduce_assn(a1,non_esc_subst,esc_subst,negate);
    let newa2 = reduce_assn(a2,non_esc_subst,esc_subst,negate);
    if (negate) return or(newa1,newa2);
    if (a1 != newa1 || a2 != newa2) 
      a = and(newa1,newa2);
    return a;
  case &Or(a1,a2):
    let newa1 = reduce_assn(a1,non_esc_subst,esc_subst,negate);
    let newa2 = reduce_assn(a2,non_esc_subst,esc_subst,negate);
    if (negate) return and(newa1,newa2);
    if (a1 != newa1 || a2 != newa2) 
      a = or(newa1,newa2);
    return a;
  case &Kill(a): 
    // start a new esc_subst for a.  not sure this is necessary
    // when esc_subst is non-null...
    list_t<$(vardecl_t,term_t)@> new_esc_subst = NULL;
    return reduce_assn(a,non_esc_subst,&new_esc_subst,negate);
  case &Subst(vd,t,a1):
    // add vd->t to the non_esc_subst
    t = reduce_term(t,non_esc_subst,esc_subst);
    non_esc_subst = new List(new $(vd,t),non_esc_subst);
    a = a1;
    goto LOOP;
  case &Not(a1):
    a = a1;
    negate = !negate;
    goto LOOP;
  }
}

// get rid of all Not, Kill and Subst nodes.
assn_t reduce(assn_t a) {
  // check to see if we've already eliminated them.
  if (is_reduced(a)) return a;
  return reduce_assn(a,NULL,NULL,false);
}

// a one-shot substitution -- needed in the assignment code below.
term_t subst_term(term_t t, vardecl_t x, term_t newx) {
  switch (t) {
  case &Var(vd):
    if (vd == x) return newx;
    return t;
  case &Unop(p,t1,tp):
    let t2 = subst_term(t1,x,newx);
    if (t1 != t2) return unop(p,t2,tp);
    return t;
  case &Binop(p,t1,s1,tp):
    let t2 = subst_term(t1,x,newx);
    let s2 = subst_term(s1,x,newx);
    if (t1 != t2 || s1 != s2) return binop(p,t2,s2,tp);
    else return t;
  case &Cast(tp,tm):
    let tm2 = subst_term(tm,x,newx);
    if (tm != tm2) return cast(tp,tm2);
    else return t;
  case &Uint(_):
  case &Const(_):
  case &LogicVar(...): return t;
  }
}

// an eager kill for terms (we don't bother to do terms lazily, only assns)
term_t kill_mem_term(term_t t) {
  let esc_subst = NULL;
  return reduce_term(t,NULL,&esc_subst);
}


/////////////////// Assertion Factoring //////////////////
// This code isn't currently used but may be useful.  The
// basic idea is to try to pull the common conjuncts out
// to a wider scope.  Eg..,  (A & B & C) || (A & D & C) 
// should factor into (A & C) & (B || D).  

// intersect two lists of assertions returning the common
// assertions, and the remainders of the two lists.  Assumes
// the assertions are in sorted order.
static void intersect(list_t<assn_t,`H> a1s, list_t<assn_t,`H> a2s, 
                      list_t<assn_t,`H>@common,
                      list_t<assn_t,`H>@res1,
                      list_t<assn_t,`H>@res2) {
  while (true) {
    switch $(a1s,a2s) {
    case $(NULL,NULL): return;
    case $(_,NULL): *res1 = List::revappend(a1s,*res1); return;
    case $(NULL,_): *res2 = List::revappend(a2s,*res2); return;
    default: 
      int c = assncmp(a1s->hd,a2s->hd);
      if (c == 0) {
        *common = new List(a1s->hd,*common);
        a1s = a1s->tl;
        a2s = a2s->tl;
      } else if (c < 0) {
        *res1 = new List(a1s->hd,*res1);
        a1s = a1s->tl;
      } else {
        *res2 = new List(a2s->hd,*res2);
        a2s = a2s->tl;
      }
    }
  }
}

$(list_t<assn_t> common, list_t<assn_t> res1, list_t<assn_t> res2) 
  intersect_assns(list_t<assn_t,`H> a1s, list_t<assn_t,`H> a2s) {
  let common = NULL;
  let res1 = NULL;
  let res2 = NULL;
  intersect(a1s,a2s,&common,&res1,&res2);
  return $(List::imp_rev(common),List::imp_rev(res1),List::imp_rev(res2));
}

// pull out the common primitive relations, but avoid duplicating
// things in forming the full cross-product
$(list_t<assn_t>,assn_t) factor(assn_t a) {
  switch (a) {
  case &True: return $(NULL,&true_assn);
  case &False: return $(NULL,&false_assn);
  case &Prim(...): return $(new List{a,NULL},&true_assn);
  case &And(a1,a2):
    let $(c1s,a1) = factor(a1);
    let $(c2s,a2) = factor(a2);
    return $(List::merge(assncmp,c1s,c2s),and(a1,a2));
  case &Or(a1,a2):
    let $(c1s,a1) = factor(a1);
    let $(c2s,a2) = factor(a2);
    let $(cs,c1s,c2s) = intersect_assns(c1s,c2s);
    return $(cs,or(List::fold_left(and,a1,c1s),List::fold_left(and,a2,c2s)));
  default: return $(NULL,a);
  }
}

assn_t factor_assn(assn_t a) {
  //unsigned int asize = assn_size(a);
  let $(cs,a) = factor(a);
  a = List::fold_left(and,a,cs);
  //unsigned int newsize = assn_size(a);
  //fprintf(stderr,"factor before %d after %d\n",asize,newsize);
  //fprintf(stderr,"%s\n",assn2string(a));
  return a;
}

// returns the set of primitive relations implied by the assertion (if any).
// this gets cached in the hash-cons-table so it isn't recomputed.
static assn_set_opt_t widen_it(Hashtable::table_t<assn_t,$(assn_t,bool,assn_set_opt_t@`H)@`H> table, assn_t a) {
 LOOP:
  let popt = Hashtable::lookup_opt(table, a);
  if (popt == NULL) { 
    a = hash_cons(a); goto LOOP; 
  }
  $(assn_t,bool,assn_set_opt_t@)@ p = *popt;
  let &$(_,_,*r) = p;
  if (**r != NULL) {
    return **r;
  }
  assn_set_opt_t s;
  switch (a) {
  case &True: s = Set::empty(assncmp); break;
  case &False: s = NULL; break;
  case &And(a1,a2):
    let s1 = widen_it(table,a1);
    let s2 = widen_it(table,a2);
    if (s1 == NULL || s2 == NULL) 
      s = NULL; 
    else 
      s = Set::union_two((assn_set_t)s1,(assn_set_t)s2);
    break;
  case &Or(a1,a2):
    let s1 = widen_it(table,a1);
    let s2 = widen_it(table,a2);
    if (s1 == NULL) 
      s = s2;
    else if (s2 == NULL)
      s = s1;
    else
      s = Set::intersect((assn_set_t)s1,(assn_set_t)s2);
    break;
  case &Prim(t1,p,t2):
    s = Set::singleton(assncmp,a);
    switch (p) {
    case Eq:
      // when we have t1 == t2 and they are of integral type, then we
      // also want to remember that t1 <= t2 and t2 <= t1 so that when
      // we intersect, we don't lose the information.
      let topt1 = get_term_type(t1);
      let topt2 = get_term_type(t2);
      if ((topt1 != NULL && Tcutil::is_integral_type((type_t)topt1)) ||
          (topt2 != NULL && Tcutil::is_integral_type((type_t)topt2))) {
        s = Set::insert(s,slte(t1,t2));
        s = Set::insert(s,slte(t2,t1));
        s = Set::insert(s,ulte(t1,t2));
        s = Set::insert(s,ulte(t2,t1));
      }
      break;
    case SLt:
      s = Set::insert(s,slte(t1,t2));
      break;
    case ULt:
      s = Set::insert(s,ulte(t1,t2));
      break;
    default: break;
    }
    break;
  default:
    s = widen_it(table,reduce(a));
    break;
  }
  *r = new s;
  return s;
}

// factors out all of the common primitive relations in a.
assn_t widen(assn_t a) {
  // force the hash-cons table to be around just to be safe
  let h = get_hash_cons_table();
  let sopt = widen_it(h,a);
  if (sopt == NULL) return &false_assn;
  return Set::fold(and,(assn_set_t)sopt,&true_assn);
}

// tries to see if a can be proved from the set of primitive
// relations in ctxt.
static bool simple_prv(assn_set_t ctxt, assn_t a) {
  while (true) {
    switch (a) {
    case &Prim(t1,p,t2): 
      if (Set::member(ctxt,a)) return true;
      switch (p) {
      case Neq: 
        return (Set::member(ctxt,ult(t2,t1)) ||
                Set::member(ctxt,ugt(t2,t1)) ||
                Set::member(ctxt,slt(t2,t1)) ||
                Set::member(ctxt,sgt(t2,t1)));
      case SLte: 
        return (Set::member(ctxt,slt(t1,t2)) || 
                Set::member(ctxt,eq(t1,t2)));
      case ULte: 
        return (Set::member(ctxt,ult(t1,t2)) || 
                Set::member(ctxt,eq(t1,t2)));
      default: return false;
      }
    case &True: return true;
    case &False: return false;
    case &And(a1,a2): 
      if (!simple_prv(ctxt,a1)) return false;
      a = a2; 
      continue;
    case &Or(a1,a2): 
      if (simple_prv(ctxt,a1)) return true;
      a = a2;
      continue;
    default: 
      a = reduce(a);
      continue;
    }
  }
}


// returns true when ctxt |- a
// uses only very local, syntactic matching.
bool simple_prove(assn_t ctxt, assn_t a) {
  if (ctxt == a) return true; 
  let sopt = widen_it(get_hash_cons_table(),ctxt);
  if (sopt == NULL) return true;
  return simple_prv((assn_set_t)sopt, a);
}
