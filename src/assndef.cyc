/* Computing Strongest Post-conditions
   Copyright (C) 2003 Greg Morrisett
   This file is part of the Cyclone compiler.

   The Cyclone compiler is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   The Cyclone compiler is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with the Cyclone compiler; see the file COPYING. If not,
   write to the Free Software Foundation, Inc., 59 Temple Place -
   Suite 330, Boston, MA 02111-1307, USA. */

/* this file contains the definition of assertions, the terms used in
   assertions as well as utilities on them (such as comparison, debugging
   printing etc.). */

#include "absyn.h"
#include "absynpp.h"
#include "flags.h"
#include "evexp.h"
#include "tcutil.h"
#include "warn.h"
#include "assndef.h"
#include <hashtable.h>
#include <list.h>
#include <dict.h>
#include <set.h>

namespace Hashtable {
  using List;
  struct Cell<`a,`b,`r> {
    `a key;
    `b value;
    struct Cell<`a,`b,`r>*`r next;
  };
  
  typedef struct Cell<`a,`b,`r>*`r cell_t<`a,`b,`r>;
  
  typedef struct Bucket<`a,`b,`r> {
    unsigned int length;
    cell_t<`a,`b,`r> cells;
  } bucket_t<`a,`b,`r>;
  
  /*abstract*/
  struct Table<`a,`b,`r> {
    region_t<`r> r;
    int          (@cmp)(`a,`a);
    int          (@hash)(`a);
    int	       max_len; // maximum length of bucket list before resize
    bucket_t<`a,`b,`r>?`r tab;
  };
}

namespace AssnDef;
using List;
using Hashtable;


///////////////////// Terms /////////////////////

string_t term2string(term_t t) {
  string_t res;
  switch (t) {
  case &Uint(i,_): res = aprintf("0x%x", i); break;
  case &Const(e): res = aprintf("%s[%d]",Absynpp::exp2string(e),(int)e); break;
  case &Tagof(t): res = aprintf("tagof_tm(%s)",term2string(t)); break;
  case &Select(t1,t2,_):
    res = aprintf("Sel(%s,%s)",term2string(t1),term2string(t2));
    break;
  case &Update(t1,t2,t3):
    res = aprintf("Upd(%s,%s,%s)",term2string(t1),term2string(t2),term2string(t3));
    break;
  case &LogicVar(NULL,i,_): res = aprintf("_X%d",i); break;
  case &LogicVar(vd,i,_): 
    res = aprintf("_%s%d",Absynpp::qvar2string(vd->name),i); break;
  case &Unop(p,t1,_):
    res = aprintf("%s(%s)",Absynpp::prim2string(p),term2string(t1)); break;
  case &Binop(p,t1,t2,_):
    res = aprintf("(%s%s%s)",term2string(t1),Absynpp::prim2string(p),
                  term2string(t2));
    break;
  case &Cast(tp,tm):
    res = aprintf("(%s)%s",Absynpp::typ2string(tp),term2string(tm)); break;
  case &Aggr(is_union,tag,tms,_):
    static string_t lb = "{";
    static string_t rb = "}";
    static string_t comma = ",";
    list_t<stringptr_t> ss = new List{&lb,NULL};
    for (; tms != NULL; tms = tms->tl) {
      let s = term2string(tms->hd);
      ss = new List{new s,ss};
      if (tms->tl != NULL) ss = new List{&comma,ss};
    }
    ss = new List{&rb,ss};
    ss = List::imp_rev(ss);
    res = strconcat_l(ss);
    if (tag != -1) res = aprintf("tag(%d)%s",tag,res);
    if (is_union) res = aprintf("union%s",res);
    break;
  case &Proj(t,i,_):
    res = aprintf("#%d(%s)",i,term2string(t));
    break;
  case &Addr(vd):
    if (Flags::debug_assn) 
      res = aprintf("&%s_%x",Absynpp::qvar2string(vd->name),(unsigned int)vd); 
    else 
      res = aprintf("&%s",Absynpp::qvar2string(vd->name));
    break;
  case &Alloc(e,t,i,_):
    res = aprintf("Alloc(%s[%d],%s,%d)", Absynpp::exp2string(e),(int)e,term2string(t),i);
    break;
  case &Offsetf(field,t,_):
    res = aprintf("Offsetf(%s)+%s",*field,term2string(t));
    break;
  case &Offseti(t1,t2,_):
    res = aprintf("%s+%s",term2string(t1),term2string(t2));
    break;
  }
  return res;
}

static int hash_const(Absyn::cnst_t c) {
  switch (c) {
  case Absyn::Cnst{.Null_c = _}: return 0;
  case Absyn::Cnst{.Char_c = $(_,c)}: return c;
  case Absyn::Cnst{.Short_c = $(_,c)}: return c;
  case Absyn::Cnst{.Int_c = $(_,i)}: return i;
  case Absyn::Cnst{.LongLong_c = $(_,i)}: return (int)i;
  case Absyn::Cnst{.Float_c = $(s,_)}: fallthru(s);
  case Absyn::Cnst{.Wchar_c = s}: fallthru(s);
  case Absyn::Cnst{.String_c = s}: fallthru(s);
  case Absyn::Cnst{.Wstring_c = s}:
    return Hashtable::hash_string(s);
  }
}

static int hash_binding(Absyn::binding_t b) {
  switch (b) {
  case &Absyn::Local_b(vd): return ((unsigned)vd >> 4) + 21;
  case &Absyn::Pat_b(vd): return ((unsigned)vd >> 4) + 23;
  case &Absyn::Param_b(vd): return ((unsigned)vd >> 4) + 27;
  case &Absyn::Funname_b(vd): return ((unsigned)vd >> 4) + 29;
  case &Absyn::Global_b(vd): return ((unsigned)vd >> 4) + 31;
  case &Absyn::Unresolved_b(q): return 1;
  }
}

static int hash_exp(exp_t e) {
  switch (e->r) {
  case &Absyn::Const_e(c): return hash_const(c);
  case &Absyn::Var_e(b): return hash_binding(b);
  default: return tagof(e->r) + 1;
  }
}

int termhash(datatype Term @t) {
  switch (t) {
  case &Uint(i,_): return i;
  case &Const(e): return hash_exp(e) + 61;
  case &LogicVar(vd,i,_): return ((unsigned int)vd >> 3) + (i+1);
  case &Unop(p,t1,_): return p + ((unsigned int)t1 >> 4) + 1;
  case &Binop(p,t1,t2,_):
    return p + (((unsigned int)t1 + (unsigned int)t2) >> 4);
  case &Cast(_,t): return termhash(t);
  case &Select(t1,t2,_):
    return (((unsigned int)t1 + (unsigned int)t2) >> 4) + 2;
  case &Update(t1,t2,t3):
    return (((unsigned int)t1 + (unsigned int)t2 + (unsigned int)t3) >> 4) + 3;
  case &Proj(t,i,_): return ((unsigned int)t >> 4) + i + 23;
  case &Aggr(is_union,tag,ts,_):
    unsigned int res = 37+tag+is_union;
    for (; ts != NULL; ts = ts->tl)
      res = res + ((unsigned int)ts->hd >> 4);
    return res;
  case &Addr(vd): return ((unsigned int)vd >> 4)+7;
  case &Alloc(e,_,i,_): return hash_exp(e) + i;
  case &Offsetf(f,t,_): return (unsigned int)f + termhash(t)+11;
  case &Offseti(index,t,_): return termhash(index) + termhash(t) + 13;
  case &Tagof(t): return ((unsigned)t >> 3) + 741;
  }
}

int termcmp(datatype Term @`r1 _t1, datatype Term @`r2 _t2) {
  datatype Term @`r1+`H t1 = _t1;
  datatype Term @`r2+`H t2 = _t2;
 LOOP:
  int c = tagof(t1) - tagof(t2);
  if (c != 0) return c;
  if (t1 == t2) return 0;
  switch $(t1,t2) {
  case $(&LogicVar(vd1,i,_),&LogicVar(vd2,j,_)): 
    int c = i - j;
    if (c != 0) return c;
    return (int)vd1 - (int)vd2;
  case $(&Uint(i1,_), &Uint(i2,_)): return i1-i2;
  case $(&Const(e1),&Const(e2)): return Evexp::exp_cmp(e1,e2)?(int)e1-(int)e2:0;
  case $(&Addr(vd1),&Addr(vd2)): return (int)vd1 - (int)vd2;
  case $(&Unop(p1,t1a,_),&Unop(p2,t2a,_)): 
    if (p1 != p2) return (int)p1 - (int)p2;
    t1 = t1a;
    t2 = t2a;
    goto LOOP;
  case $(&Binop(p1,t11,t12,tp1),&Binop(p2,t21,t22,tp2)):
    if (p1 != p2) return (int)p1 - (int)p2;
    int c = termcmp(t11,t21);
    if (c != 0) return c;
    t1 = t12;
    t2 = t22;
    goto LOOP;
  case $(&Cast(tp1,tm1),&Cast(tp2,tm2)):
    int c = Tcutil::typecmp(tp1,tp2);
    if (c != 0) return c;
    t1 = tm1;
    t2 = tm2;
    goto LOOP;
  case $(&Select(t11,t12,_),&Select(t21,t22,_)):
    int c = termcmp(t11,t21);
    if (c != 0) return c;
    t1 = t12;
    t2 = t22;
    goto LOOP;
  case $(&Update(t11,t12,t13),&Update(t21,t22,t23)):
    int c = termcmp(t11,t21);
    if (c != 0) return c;
    int c = termcmp(t12,t22);
    if (c != 0) return c;
    t1 = t13;
    t2 = t23;
    goto LOOP;
  case $(&Tagof(tm1),&Tagof(tm2)): 
    t1 = tm1;
    t2 = tm2;
    goto LOOP;
  case $(&Proj(tm1,i1,_),&Proj(tm2,i2,_)): 
    int c = i1 - i2;
    if (c != 0) return c;
    t1 = tm1;
    t2 = tm2;
    goto LOOP;
  case $(&Alloc(e1,_,i1,_),&Alloc(e2,_,i2,_)):
    if (e1 != e2) return (int)e1-(int)e2;
    else return (i1-i2);
  case $(&Offsetf(f1,tm1,_),&Offsetf(f2,tm2,_)):
    int c = strptrcmp(f1,f2);
    if (c != 0) return c;
    t1 = tm1;
    t2 = tm2;
    goto LOOP;
  case $(&Offseti(i1,tm1,_),&Offseti(i2,tm2,_)):
    int c = termcmp(tm1,tm2);
    if (c != 0) return c;
    t1 = tm1;
    t2 = tm2;
    goto LOOP;
  case $(&Aggr(is_union1,tag1,ts1,_),&Aggr(is_union2,tag2,ts2,_)):
    int c = tag1 - tag2;
    if (c != 0) return c;
    c = is_union2 - is_union1;
    if (c != 0) return c;
    for (; ts1 != NULL && ts2 != NULL; ts1=ts1->tl, ts2=ts2->tl) {
      c = termcmp(ts1->hd,ts2->hd);
      if (c != 0) return c;
    }
    if (ts1 == ts2) return 0;
    if (ts1 == NULL) return -1;
    return 1;
  default: Warn::impos("different terms but same codes!");
  }
}

static term_t copy_term(datatype Term@ t) {
  switch (t) {
  case &Uint(i,tp): return new Uint(i,tp);
  case &Const(e): return new Const(e);
  case &Addr(vd): return new Addr(vd);
  case &LogicVar(vd,i,tp): return new LogicVar(vd,i,tp);
  case &Binop(p,t1,t2,tp): return new Binop(p,t1,t2,tp);
  case &Unop(p,t,tp): return new Unop(p,t,tp);
  case &Cast(tp,t): return new Cast(tp,t);
  case &Select(t1,t2,tp): return new Select(t1,t2,tp);
  case &Update(t1,t2,t3): return new Update(t1,t2,t3);
  case &Proj(t,i,tp): return new Proj(t,i,tp);
  case &Aggr(is_union,tag,ts,tp): return new Aggr(is_union,tag,ts,tp);
  case &Alloc(e,offset,i,tp): return new Alloc(e,offset,i,tp);
  case &Offsetf(f,t,tp): return new Offsetf(f,t,tp);
  case &Offseti(i,t,tp): return new Offseti(i,t,tp);
  case &Tagof(t): return new Tagof(t);
  }
}

datatype Term.Uint zero_value = Uint(0,NULL);
datatype Term.Uint one_value = Uint(1,NULL);

static term_set_t empty_term_set() {
   static term_set_t *term_set = NULL;
   if (term_set == NULL) {
     term_set = new Set::empty(termcmp);
   }
   return *term_set;
}

typedef struct TermHashedInfo {
  term_t term;
  term_set_t *free_logicvar_set;
} @term_hashed_info_t;

// a hash-table to hold all of the term nodes to maximize sharing.  
static struct Hashtable::Table<term_t,term_hashed_info_t> *term_hash_cons_table = NULL;


static Hashtable::table_t<term_t,term_hashed_info_t>
get_term_hash_cons_table(){
  Hashtable::table_t<term_t,term_hashed_info_t> h;
  if (term_hash_cons_table == NULL) {
    h = Hashtable::create(221, termcmp, termhash);
    term_hash_cons_table = h;
    term_set_t tst = empty_term_set();
    Hashtable::insert(h,&zero_value,new TermHashedInfo{&zero_value,new tst});
    Hashtable::insert(h,&one_value,new TermHashedInfo{&one_value,new tst});
  } else {
    h = (Hashtable::table_t)term_hash_cons_table;
  }
  return h;
}

static term_t hash_cons_term(datatype Term @t) {
  let h = get_term_hash_cons_table();
  let resopt = Hashtable::lookup_other_opt(h,t,termcmp,termhash);
  if (resopt == NULL) {
    let t2 = copy_term(t);
    //int i = h->max_len;
    Hashtable::insert(h,t2,new TermHashedInfo{t2,NULL});
    //if (i < h->max_len) 
    //  fprintf(stderr,"grew term hash table after inserting %s due to chains %d\n",term2string(t2),i);
    return t2;
  } else 
    return (*resopt)->term;
}

// computing the set of logicvars that occured
// in a term, use the hash table to memoize the
// result
static term_set_t term_fr_logicvar(term_t t) {
  let h = get_term_hash_cons_table();
  let thinfo = Hashtable::lookup_opt(h,t);
  // the info was computed before and stored in the table
  if (thinfo == NULL) {
    t = hash_cons_term(t);
    thinfo = Hashtable::lookup_opt(h,t);
  }
  if ((*thinfo)->free_logicvar_set != NULL)
    return *(*thinfo)->free_logicvar_set;
  term_set_t res;
  switch (t) {
  case &Uint(...): 
  case &Const(...):
  case &Addr(...):
    res = empty_term_set(); break;
  case &Alloc(_,t1,_,_):
    res = term_fr_logicvar(t1); break;
  case &LogicVar(...):
    res = Set::singleton(termcmp,t);
    break;
  case &Select(t1,t2,_):
    fallthru(t1,t2);
  case &Binop(_,t1,t2,_):
    fallthru(t1,t2);
  case &Offseti(t1,t2,_):
    res = Set::union_two(term_fr_logicvar(t1),term_fr_logicvar(t2));
    break;
  case &Update(t1,t2,t3):
    res = Set::union_two(Set::union_two(term_fr_logicvar(t1),
					term_fr_logicvar(t2)),
			 term_fr_logicvar(t3));
    break;
  case &Unop(_,t1,_):
    fallthru(t1);
  case &Proj(t1,_,_):
    fallthru(t1);
  case &Offsetf(_,t1,_):
    fallthru(t1);
  case &Tagof(t1):
    fallthru(t1);
  case &Cast(_,t1):
    res = term_fr_logicvar(t1);
    break;
  case &Aggr(_,_,ts,_):
    let tsets = map(term_fr_logicvar,ts);
    res = fold_left(Set::union_two,empty_term_set(),tsets);
    break;
  }
  (*thinfo)->free_logicvar_set = new res;
  return res;
}

static bool logicvar_in_term(term_t lvar, term_t t) {
  let lvset = term_fr_logicvar(t);
  return Set::member(lvset,lvar);
}

term_t uint(unsigned int i) {
  let t = Uint(i,NULL);
  return hash_cons_term(&t);
}
term_t zero() {
  return &zero_value;
}
term_t one() {
  return &one_value;
}
term_t cnst(Absyn::exp_t e) { 
  let $(c, known) = Evexp::eval_const_uint_exp(e);
  if (known) return uint(c);
  let t = Const(e);
  return hash_cons_term(&t);
}
term_t addr(vardecl_t vd) {
  let t = Addr(vd);
  return hash_cons_term(&t);
}
term_t logicvar(vardecl_opt_t vd,int i,type_opt_t tp) {
  let t = LogicVar(vd,i,tp);
  return hash_cons_term(&t);
}
term_t update(term_t t1, term_t t2, term_t t3) {
  switch $(t1,t2) {
  case $(&Update(m,a as &Addr(x),e1),&Addr(y)):
    // Update(Update(m,Addr(x),e1),Addr(x),t3) = Update(m,Addr(x),t3)
    if (x == y) return update(m,t2,t3);
    break;
  default: break;
  }
  let t = Update(t1,t2,t3);
  return hash_cons_term(&t);
}

term_t select(term_t t1, term_t t2,type_opt_t tp) {
  switch $(t1,t2) {
  case $(&Update(m,&Addr(x),v),&Addr(y)):
    // Select(Update(m,a,v),a) == v
    if (x == y) return v;
    // addresses of distinct program variables must be distinct so we
    // know that Select(Update(m,Addr(x),v),Addr(y)) == Select(m,Addr(y))
    else return select(m,t2,tp);
  case $(&Update(m,a1,v),a2):
    // Select(Update(m,a,v),a) == v
    if (a1 == a2) return v;
    fallthru;
  default:
    let t = Select(t1,t2,tp);
    return hash_cons_term(&t);
  }
}

// Unions are represented by one tagged value.  The tag records
// the member that was last written, and we can only reduce a
// projection when the member being read was the same as the one last
// written.  (This holds for both @tagged and bits-only unions.)
// For datatypes, the is_union field is false, and the tag field
// records which constructor we're dealing with.  For structs,
// the is_union field is false, and the tag is set to -1.
term_t proj(term_t t1, unsigned i, type_opt_t tp) {
  switch (t1) {
  case &Aggr(is_union,tag,ts,_): 
    let n = List::length(ts);
    if (!is_union && i < n)
      return nth(ts,i);
    else if (tag == i && n >= 1)
      return ts->hd;
    else break;
  default: break;
  }
  let t = Proj(t1,i,tp);
  return hash_cons_term(&t);
}

term_t aggr(bool is_union, unsigned tag, list_t<term_t,`H> ts, type_opt_t tp){
  // could eta-reduce Aggr(proj(t,0),proj(t,1),...,proj(t,n)) to t,
  // using the type information to figure out n.
  let t = Aggr(is_union,tag,ts,tp);
  return hash_cons_term(&t);
}
term_t struct_aggr(list_t<term_t,`H> ts, type_opt_t tp) {
  return aggr(false,-1,ts,tp);
}
term_t datatype_aggr(unsigned tag, list_t<term_t,`H> ts, type_opt_t tp) {
  return aggr(false,tag,ts,tp);
}
term_t union_aggr(unsigned tag, list_t<term_t,`H> ts, type_opt_t tp) {
  return aggr(true,tag,ts,tp);
}
term_t tagof_tm(term_t t1) {
  switch (t1) {
  case &Aggr(_,tag,...): return uint(tag);
  default: 
    let t = Tagof(t1);
    return hash_cons_term(&t);
  }
}

term_t cast(type_t tp, term_t tm){
  let t = Cast(tp,tm);
  return hash_cons_term(&t);
}

term_t alloc(exp_t e, term_t offset, type_opt_t tp){
  static int counter = 0;
  let t = Alloc(e,offset,counter,tp);
  counter++;
  return hash_cons_term(&t);
}

term_t offsetf(field_name_t f, term_t tm, type_opt_t tp){
  let t = Offsetf(f,tm,tp);
  return hash_cons_term(&t);
}

term_t offseti(term_t i, term_t tm, type_opt_t tp){
  let t = Offseti(i,tm,tp);
  return hash_cons_term(&t);
}
term_t fresh_var(type_opt_t tp){
  static int counter = 0;
  let t = logicvar(NULL,counter,tp);
  counter++;
  return t;
}

term_t plus(term_t t1, term_t t2, type_opt_t tp) {
  return binop(Absyn::Plus,t1,t2,tp);
}
term_t minus(term_t t1, term_t t2, type_opt_t tp) {
  return binop(Absyn::Minus,t1,t2,tp);
}

term_t unop(Absyn::primop_t p, term_t t, type_opt_t tp) {
  // +t = t;
  if (p == Absyn::Plus) return t;
  // -t = t * (-1);
  if (p == Absyn::Minus) return binop(Absyn::Times,t,uint(-1),tp);
  let ptr = Unop(p,t,tp);
  return hash_cons_term(&ptr);
}

term_t numelts_term(term_t t) {
  return unop(Absyn::Numelts, t, Absyn::uint_type);
}

// Need to fake up vardecls for the "memory" and "exception"
using Absyn {
  static string_t memory_var = "#Mem";
  static $(nmspace_t,var_t) memvar = $(Nmspace{.Loc_n = 0},&memory_var);
  static datatype TyCon.VoidCon void_con = VoidCon;
  static datatype Type.AppType vd_type = AppType(&void_con,NULL);

  struct Absyn::Vardecl memory_struct = {
    .sc = Absyn::Public,
    .name = &memvar,
    .varloc = 0,
    .tq = {0,0,0,0,0},
    .type = &vd_type,
    .initializer = NULL,
    .rgn = NULL,
    .attributes = NULL,
    .escapes = false,
    .is_proto = false
  };
  vardecl_t memory = &memory_struct;

  static string_t exception_var = "#Exn";
  static $(nmspace_t,var_t) exnvar = $(Nmspace{.Loc_n = 0},&exception_var);

  struct Absyn::Vardecl exception_struct = {
    .sc = Absyn::Public,
    .name = &exnvar,
    .varloc = 0,
    .tq = {0,0,0,0,0},
    .type = &vd_type,
    .initializer = NULL,
    .rgn = NULL,
    .attributes = NULL,
    .escapes = false,
    .is_proto = false
  };

  vardecl_t exception_vardecl() {
    let vd = &exception_struct;
    vd->type = Absyn::exn_type();
    return vd;
  }
}

// data structure for a polynomial a1*t1 + a2*t2 + ... + an*tn
// used in 1) normalizing a term. 
//         2) generating matrix for Gaussian elimination
typedef List::list_t<$(int,term_t)@,`H> coefficient_term_list_t;
// a function to retrieve the coefficients and terms in a
// polynomial from a term, the extra integer represent
// the constants a0 in the term
// a0 + a1*t1 + a2*t2 + ...


$(coefficient_term_list_t,int) get_coefficient_term_list(term_t t) {
  coefficient_term_list_t coefficient_term_list = NULL;
  int res = 0;
 LOOP:
  switch(t){
  case &Uint(i,_): res = i; break;
  case &Binop(Absyn::Plus,t1,&Uint(i,_),_):
    res = i;
    t = t1;
    goto LOOP;
  case &Binop(Absyn::Plus, t1, t2,_):
    switch(t2){
    case &Binop(Absyn::Times,t21,&Uint(c2,_),_):
      coefficient_term_list = new List(new $(c2,t21), coefficient_term_list);
      break;
    case &Binop(Absyn::Plus,_,_,_):
      Warn::impos("Plus in the right branch, not a normal form");
      break;
    default:
      coefficient_term_list = new List(new $(1,t2),coefficient_term_list);
      break;
    }
    t = t1;
    goto LOOP;
  default:
    switch(t){
    case &Binop(Absyn::Times,t21,&Uint(c2,_),_):
      coefficient_term_list = new List(new $(c2,t21), coefficient_term_list);
      break;
    default:
      coefficient_term_list = new List(new $(1,t),coefficient_term_list);
      break;
    }
    break;
  }
  return $(coefficient_term_list,res);
}

// given two sorted list [(t1,c1),(t2,c2),...,(tn,cn)]
// and [(s1,d1),(s2,d2),...,(sn,dn)]
// generate a merged list [(q1,e1),(q2,e2),...,(qm,em)]
// think about it as adding two polynomials
// by merging the coefficients of same terms.
// the final result should also be sorted and each term
// in the list should be unique.
static coefficient_term_list_t 
imp_merge_coefficient_term_list(int less_eq(term_t,term_t),
		    coefficient_term_list_t termlist1,
		    coefficient_term_list_t termlist2){
  coefficient_term_list_t res_tail = NULL;
  coefficient_term_list_t res = NULL;
  if (termlist1 == NULL) return termlist2;
  if (termlist2 == NULL) return termlist1;
  let cmp_result = less_eq(termlist1->hd->f1,termlist2->hd->f1);
  while ((termlist1 != NULL) && (termlist2!= NULL)){
    let cmp_result = less_eq(termlist1->hd->f1,termlist2->hd->f1);
    if (cmp_result < 0){ // termlist1< termlist2
      if (res_tail== NULL){
	res_tail= termlist1;
	termlist1= termlist1->tl;
	res = res_tail;
      }else{
	res_tail->tl = termlist1;
	res_tail= termlist1;
	termlist1= termlist1->tl;
      }
    } else if (cmp_result > 0) { // termlist2< termlist1
      if (res_tail== NULL){
	res_tail= termlist2;
	termlist2= termlist2->tl;
	res = res_tail;
      } else {
	res_tail->tl = termlist2;
	res_tail= termlist2;
	termlist2= termlist2->tl;
      }
    } else { // cmp_result == 0, termlist1== termlist2
      // merge two values;
      let i = termlist1->hd->f0 + termlist2->hd->f0;
      if (i != 0){
	termlist1->hd->f0 = i;
	if (res_tail== NULL){
	  res_tail= termlist1;
	  res = res_tail;
	} else {
	  res_tail->tl = termlist1;
	  res_tail= termlist1;
	}
      }
      termlist1= termlist1->tl;
      termlist2= termlist2->tl;
    }
  }
  if (res_tail== NULL) {
    res_tail= (termlist1== NULL)? termlist2: termlist1;
    res = res_tail;
  } else {
    res_tail->tl = (termlist1==NULL)? termlist2: termlist1;
  }
  return res;
}

// given a primop p, return an unsigned int u such that
// for all term t, t p Uint(u) == Uint(u) p t == t,
// i.e., Uint(u) is the identity in the commutative group.
inline static unsigned id_of_primop(Absyn::primop_t p){
  switch(p) {
  case Absyn::Plus:   return 0;
  case Absyn::Times:  return 1;
  case Absyn::Bitand: return 0xFFFFFFFF;
  case Absyn::Bitor:  return 0;
  case Absyn::Bitxor: return 0;
  default: Warn::impos("no id for primop %s",Absynpp::prim2string(p));
  }
}


// given a list t1, t2, t3, t4,... and a primop p
// return a term ((((t1 p t2) p t3) p t4)...)
static term_t termlist2term(list_t<term_t> termlist, int newc, Absyn::primop_t p, type_opt_t tp){
  let id = id_of_primop(p);
  if (termlist == NULL) return uint(newc);
  term_t t = termlist->hd;
  termlist = termlist->tl;
  while(termlist != NULL){
    let newterm = Binop(p,t, termlist->hd, tp);
    t = hash_cons_term(&newterm);
    termlist = termlist->tl;
  }
  if (id == newc) return t;
  else {
//     // term is of the form t * c
//     if (p == Absyn::Times){
//       switch(t){
// 	// term is of the form (t1 + ... + tn) * newc, distribute the newc
//       case &Binop(Absyn::Plus,_,_,_):
// 	let $(t_list,c) = flatten_plus(t);
// 	let newt_list = map_c(times_newc,newc,t_list);
// 	return termcoeflist2term(newt_list,c*newc,topt);
// 	break;
//       default: break;
//       }
//     }
    let newterm = Binop(p,t,uint(newc),tp);
    return hash_cons_term(&newterm);
  }
}

// given a term t and its coefficient c, returns a 
// new term c*t
static term_t compute_factor(type_opt_t tp, $(int, term_t) @coefficient_term){
  let &$(c,t) = coefficient_term;
  if (c == 1) return t;
  else {
    let newfactor = Binop(Absyn::Times,t,uint(c),tp);
    return hash_cons_term(&newfactor);
  }
}

static int inv_termcmp(term_t t1, term_t t2){
  return -termcmp(t1, t2);
}

// try to normalize a term t1 + t2
// first generate coefficient term list from t1, and t2,
// t1 = a1 * t11 + a2 * t12 + ...
// t2 = b1 * t21 + b2 * t22 + ...
// merge the two lists by combining coefficients for the same term
// and return a new normalized term of the form
// c1 * t31 + c2 * t32 + ...
static term_t normalize_plus(term_t t1, term_t t2, type_opt_t tp){
  let $(coefficient_term_list1,i1) = get_coefficient_term_list(t1);
  let $(coefficient_term_list2,i2) = get_coefficient_term_list(t2);
  let coefficient_term_list = 
    imp_merge_coefficient_term_list(inv_termcmp,
				    coefficient_term_list1, 
				    coefficient_term_list2);
  
  let term_list = map_c(compute_factor,tp,coefficient_term_list);
  return termlist2term(term_list,i1+i2,Absyn::Plus,tp);
}


// given a term of the form t1 p t2 p t3 ... tn p c
// where p is a commutative and associative primop,
// return the ordered list [t1,t2,...,tn] and c
// so that we can merge two terms
static $(list_t<term_t,`H>, int)  term2termlist(Absyn::primop_t p, term_t t){
  list_t<term_t,`H> termlist = NULL;
  int res = id_of_primop(p);
 LOOP:
  switch (t){
  case &Uint(i,_): res = i; break;
  case &Binop(p1,t1,&Uint(i,_),_) && p1 == p: 
    res = i;
    t = t1;
    goto LOOP;
  case &Binop(p1, t1, t2,_)&& p1 == p:
    termlist = new List(t2, termlist);
    t = t1;
    goto LOOP;
  default:
    termlist = new List(t, termlist);
    break;
  }
  return $(termlist,res);
}

//evaluating commutative associative bin op on constants.
inline static unsigned eval_binop(Absyn::primop_t p, unsigned i, unsigned j){
  switch(p){
  case Absyn::Plus: return (i+j);
  case Absyn::Times: return (i*j);
  case Absyn::Bitand: return (i & j);
  case Absyn::Bitor: return (i | j);
  case Absyn::Bitxor: return (i ^ j);
  default: Warn::impos("Error in evaluating binop");
  }
}


static term_t normalize_assoc_commu(Absyn::primop_t p, term_t t1, term_t t2,type_opt_t tp){
  let $(term_list1,c1) = term2termlist(p,t1);
  let $(term_list2,c2) = term2termlist(p,t2);
  let term_list = List::imp_merge(inv_termcmp,term_list1,term_list2);
  let c = eval_binop(p,c1,c2);
  return termlist2term(term_list,c,p,tp);
}

inline static bool is_nonassociative_commutative(Absyn::primop_t p,type_opt_t tp) {
  switch (p) {
  case Absyn::Plus: 
  case Absyn::Times:
    switch (tp) {
    case &Absyn::AppType(&Absyn::FloatCon(_),...): return true;
    default: return false;
    }
  case Absyn::Eq:
  case Absyn::Neq: return true;
  default: return false;
  }
}

inline static bool is_associative_commutative(Absyn::primop_t p,type_opt_t tp) {
  switch (p) {
  case Absyn::Plus:
  case Absyn::Times:
    switch (tp) {
      // integer type
    case &Absyn::AppType(&Absyn::IntCon(...),...):return true;
    default: return false;
    }
  case Absyn::Bitand:
  case Absyn::Bitor:
  case Absyn::Bitxor: return true;
  default: return false;
  }
}


term_t binop(Absyn::primop_t p, term_t t1, term_t t2, type_opt_t tp) {
  switch $(p,t1,t2) {
  case $(_,&Uint(i,_),&Uint(j,_)):
    // constant folding
    switch (p) {
    case Absyn::Plus: return uint(i+j);
    case Absyn::Minus: return uint(i-j);
    case Absyn::Bitand: return uint(i & j);
    case Absyn::Bitor: return uint(i | j);
    case Absyn::Bitxor: return uint(i ^ j);
    case Absyn::Bitlshift: return uint(i << j);
    case Absyn::Bitlrshift: return uint(i >> j);
    default: break;
    }
    break;
  case $(Absyn::Minus,t1,t2):
    switch (tp) {
    case &Absyn::AppType(&Absyn::IntCon(...),...):
      // t1 - t1 == 0
      if (termcmp(t1,t2) == 0) return uint(0);
      // t1 - t2 == t1 + (-1) * t2
      t2 = binop(Absyn::Times,t2,uint(-1),tp);
      return binop(Absyn::Plus,t1,t2,tp);
    default: break;
    }
    break;
  default:
    // trying to normalize for commutative and associative operator p
    // into the form ((t1 p t2) p t3) ... p tn) where
    // t1 <= t2 <= t3 <= ... <= tn
    if (is_associative_commutative(p,tp)){
      // given two terms of the form a0 + a1*t1 + a2*t2 + ...
      // and b0 + b1 * s1 + b2 * s2 + ...
      // trying to normalize the sum by merging the coefficient
      // of the same terms
      if (p == Absyn::Plus) return normalize_plus(t1,t2,tp);
      else return normalize_assoc_commu(p,t1,t2,tp);
    }
    if (is_nonassociative_commutative(p,tp)) {
      if (termcmp(t1,t2) > 0) {
	let tmpt = t1;
	t1 = t2;
	t2 = tmpt;
      }
    }
    break;
  }
  let p = Binop(p,t1,t2,tp);
  return hash_cons_term(&p);
}

type_opt_t get_term_type(term_t t) {
  switch (t) {
  case &Uint(_,tp): return tp;
  case &Const(e): return e->topt;
  case &LogicVar(_,_,topt): return topt;
  case &Binop(_,_,_,tp): return tp;
  case &Unop(_,_,tp): return tp;
  case &Cast(tp,_): return tp;
  case &Select(_,_,tp): return tp;
  case &Aggr(_,_,_,tp): return tp;
  case &Proj(t1,i,tp): return tp;
  case &Addr(vd): return Absyn::uint_type;
  case &Update(...): return NULL;
  case &Alloc(_,_,_,tp): return tp;
  case &Offsetf(_,_,tp): return tp;
  case &Offseti(_,_,tp): return tp;
  case &Tagof(_): return Absyn::uint_type;
  }
}

typedef Dict::dict_t<term_t,term_t> term_dict_t;

static term_t subst_term(term_dict_t dict, term_t t,
			 Hashtable::table_t<term_t,term_t> term_h){
  let t1 = Hashtable::lookup_opt(term_h,t);
  if (t1 != NULL) {
#ifdef AssnDefDebug
    fprintf(stderr,"%s was substituted, the result was \n%s\n",
	    term2string(t),term2string(*t1));
#endif
    return *t1;
  }
  term_t res;
  switch (t){
  case &Uint(...):
  case &Const(...): 
  case &Addr(...): 
    res = t; break;
  case &Alloc(e1,t1,i,tp): 
    let s1 = subst_term(dict,t1,term_h);
    let alloc_term = Alloc(e1,s1,i,tp);
    res = hash_cons_term(&alloc_term);
    break;
  case &Select(t1,t2,tp):
    let s1 = subst_term(dict,t1,term_h);
    let s2 = subst_term(dict,t2,term_h);
    res = select(s1,s2,tp);
    break;
  case &Update(t1,t2,t3):
    let s1 = subst_term(dict,t1,term_h);
    let s2 = subst_term(dict,t2,term_h);
    let s3 = subst_term(dict,t3,term_h);
    res = update(s1,s2,s3);
    break;
  case &LogicVar(...):
    let t1 = Dict::lookup_opt(dict,t);
    if (t1 != NULL) res = *t1;
    else res = t;
    break;
  case &Unop(p,t1,tp):
    let s1 = subst_term(dict,t1,term_h);
    res = unop(p,s1,tp);
    break;
  case &Binop(p,t1,t2,tp):
    let s1 = subst_term(dict,t1,term_h);
    let s2 = subst_term(dict,t2,term_h);
    res = binop(p,s1,s2,tp);
    break;
  case &Cast(tp,t1):
    let s1 = subst_term(dict,t1,term_h);
    res = cast(tp,s1);
    break;
  case &Aggr(b,tag,tlist,tp):
    let slist = NULL;
    for(;tlist != NULL; tlist = tlist->tl){
      slist = new List(subst_term(dict,tlist->hd,term_h),slist);
    }
    List::imp_rev(slist);
    res = aggr(b,tag,slist,tp);
    break;
  case &Proj(t1,i,tp):
    let s1 = subst_term(dict,t1,term_h);
    res = proj(s1,i,tp);
    break;
  case &Offsetf(f,t1,tp):
    let s1 = subst_term(dict,t1,term_h);
    res = offsetf(f,s1,tp);
    break;
  case &Offseti(t1,t2,tp):
    let s1 = subst_term(dict,t1,term_h);
    let s2 = subst_term(dict,t2,term_h);
    res = offseti(s1,s2,tp);
    break;
  case &Tagof(t1):
    res = tagof_tm(subst_term(dict,t1,term_h));
    break;
  }
  Hashtable::insert(term_h,t,res);
  return res;
}

static int hash_ptr(`a s) { return (int) s;}


static term_t subst_t(term_dict_t dict,term_t t) {
  Hashtable::table_t<term_t,term_t> term_h = Hashtable::create(137,Core::ptrcmp,hash_ptr);
  return subst_term(dict,t,term_h);
}
/////// assertion manipulation /////////////


static $(string_t,unsigned) a2dag(assn_t a, int @ctr, 
                                  Hashtable::table_t<assn_t,$(const char ?`H,unsigned)@`H> t,
                                  list_t<const char ?`H@`H,`H> @decls)
{
  $(const char ?`H,unsigned)@`H* resopt = Hashtable::lookup_opt(t,a);
  if (resopt != NULL) {
    return **resopt;
  }
  let c = *ctr;
  *ctr = c + 1;
  const char ?name = aprintf("A%d",c);
  const char ?s;
  unsigned size = 1;
  switch (a) {
  case &True: s = "true"; break;
  case &False: s = "false"; break;
  case &Prim(t1,p,t2):
    const char ?ps;
    switch (p) {
    case Eq: ps = "=="; break;
    case Neq: ps = "!="; break;
    case SLt: ps = " S< "; break;
    case SLte: ps = " S<= "; break;
    case ULt: ps = " U< "; break;
    case ULte: ps = " U<= "; break;
    default: Warn::impos("assn2string primop");
    }
    s = aprintf("%s%s%s",term2string(t1),ps,term2string(t2));
    break;
  case &Or(a1,a2):
    let $(s1,n1) = a2dag(a1,ctr,t,decls);
    let $(s2,n2) = a2dag(a2,ctr,t,decls);
    s = aprintf("%s || %s",s1,s2);
    size += (n1 + n2);
    break;
  case &And(a1,a2): 
    let $(s1,n1) = a2dag(a1,ctr,t,decls);
    let $(s2,n2) = a2dag(a2,ctr,t,decls);
    s = aprintf("%s && %s",s1,s2);
    size += (n1 + n2);
    break;
  }
  *decls = new List{new (const char ?)(aprintf("%s = %s\n",name,s)), *decls};
  Hashtable::insert(t,a,new $(name,size));
  return $(name,size);
}

int assnhash(datatype Assn @a);

string_t assn2dag(assn_t a) {
  list_t<const char ?`H@`H> decls = NULL;
  Hashtable::table_t<assn_t,$(const char ?`H,unsigned)@`H> t = 
    Hashtable::create(221, assncmp, assnhash);
  int ctr = 0;
  let $(s,n) = a2dag(a,&ctr,t,&decls);
  decls = List::imp_rev(new List{new (const char ?)(aprintf("in %s (%d nodes as tree)\n",s,n)),decls});
  return strconcat_l(decls);
}

  
// calculate a string representation (and total tree node count) for an
// assertion.  the prec field (precedent) is used to avoid some parens.
static string_t a2string(datatype Assn @a, int inprec) {
  int myprec = 10;
  string_t s;
  switch (a) {
  case &True: s = "true"; break;
  case &False: s = "false"; break;
  case &Prim(t1,p,t2):
    string_t ps;
    switch (p) {
    case Eq: ps = "=="; break;
    case Neq: ps = "!="; break;
    case SLt: ps = " S< "; break;
    case SLte: ps = " S<= "; break;
    case ULt: ps = " U< "; break;
    case ULte: ps = " U<= "; break;
    default: Warn::impos("assn2string primop");
    }
    s = aprintf("%s%s%s",term2string(t1),ps,term2string(t2));
    break;
  case &Or(a1,a2): 
    myprec = 5;
    s = aprintf("%s || %s",a2string(a1,myprec),a2string(a2,myprec));
    break;
  case &And(a1,a2): 
    myprec = 10;
    s = aprintf("%s && %s",a2string(a1,10),a2string(a2,10));
    break;
  }
  if (myprec < inprec)
    s = aprintf("(%s)",s);
  return s;
}

// Warning -- assertions are huge!  Use assn2dag instead...
string_t assn2string(datatype Assn @a){
  return a2string(a,10);
}

//////////////////////////////////////////////////////////////
// hash-consing to try to preserve as much sharing as we
// can -- has a nice impact on performance (much better than
// lazy substitution), but alas, we still end up allocating a lot.  
// It would be better if we didn't have to allocate the thing 
// that want to lookup.  That could happen if we had a different 
// type for hashtable lookup (as we did with dictionaries.)

int assnhash(datatype Assn @a) {
  switch (a) {
  case &False: return 0;
  case &True: return 1;
  case &Prim(t1,p,t2): 
    return termhash(t1) + p + termhash(t2);
  case &And(a1,a2): 
    return (((unsigned int)a1 + (unsigned int)a2) >> 4) + 3;
  case &Or(a1,a2): 
    return (((unsigned int)a2 + (unsigned int)a1) >> 4) + 5;    
  }
}

// compare two assertions for structural equality -- does not assume
// the components have been hash-consed, but probably could.
int assncmp(datatype Assn @`r1 _a1, datatype Assn @`r2 _a2) {
  datatype Assn @`r1+`H a1 = _a1;
  datatype Assn @`r2+`H a2 = _a2;
 LOOP:
  if (a1 == a2) return 0;
  int c = tagof(a2) - tagof(a1);
  if (c != 0) return c;
  switch $(a1,a2) {
  case $(&And(a11,a12),&And(a21,a22)): fallthru(a11,a12,a21,a22);
  case $(&Or(a11,a12),&Or(a21,a22)): 
    int c = assncmp(a11,a21);
    if (c != 0) return c;
    a1 = a12;
    a2 = a22;
    goto LOOP;
  case $(&Prim(t11,p1,t12),&Prim(t21,p2,t22)):
    int c = (int)p1 - (int)p2;
    if (c != 0) return c;
    c = termcmp(t11,t21);
    if (c != 0) return c;
    return termcmp(t12,t22);
  default: Warn::impos("assncmp:  tagof failure");
  }
}

// shallow copy of an assertion from region `r to the heap and 
// simultaneously determine whether or not the assertion is
// reduced so that we can put the information in the table.
static assn_t copy_assn(datatype Assn@`r a){
  switch (a) {
  case &True: 
    Warn::impos("True assertion should be in the table");
  case &False: 
    Warn::impos("False assertion should be in the table");
  case &And(a1,a2): return new And(a1,a2);
  case &Or(a1,a2): return new Or(a1,a2);
  case &Prim(t1,p,t2): return new Prim(t1,p,t2);
  }
}


// assertion constants for true and false
datatype Assn.True true_assn = True;
datatype Assn.False false_assn = False;

static assn_t neg_assn(datatype Assn@ a){
  switch (a) {
  case &True: return &false_assn;
  case &False: return &true_assn;
  case &And(a1,a2): return new Or(not(a1),not(a2));
  case &Or(a1,a2): return new And(not(a1),not(a2));
  case &Prim(t1,p,t2): 
    switch (p){
    case Eq: return new Prim(t1,Neq,t2);
    case Neq: return new Prim(t1,Eq,t2);
    case SLt: return new Prim(t2,SLte,t1);
    case SLte: return new Prim(t2,SLt,t1);
    case ULt: return new Prim(t2,ULte,t1);
    case ULte: return new Prim(t2,ULt,t1);
    default: Warn::impos("undefined prim relation");
    }
  }
}

// the assn_hash_table stores the assertion, its negation, and the widened_set
// the invariant for the assn_hash_table is that each assertion
// a and not a are added to the table at the same time.
// i.e., if a is not in the table, neither is not a.
typedef struct AssnHashedInfo {
  assn_t assn;
  assn_t negation;
  assn_set_opt_t *widened_set;
  term_set_t *free_logicvar_set;
} @assn_hashed_info_t;

static struct Hashtable::Table<assn_t, assn_hashed_info_t> *assn_hash_cons_table;

static Hashtable::table_t<assn_t,assn_hashed_info_t> 
get_assn_hash_cons_table(){
  Hashtable::table_t<assn_t,assn_hashed_info_t> h;
  if (assn_hash_cons_table == NULL) {
    h = Hashtable::create(221, assncmp, assnhash);
    assn_hash_cons_table = h;
    assn_set_opt_t ast = Set::empty(assncmp);
    term_set_t tst = empty_term_set();
    Hashtable::insert(h,&true_assn,new AssnHashedInfo{&true_assn,&false_assn,new ast,new tst});
    Hashtable::insert(h,&false_assn,new AssnHashedInfo{&false_assn,&true_assn,new NULL,new tst});
  } else {
    h = (Hashtable::table_t)assn_hash_cons_table;
  }
  return h;
}
static assn_t hash_cons_assn(datatype Assn @a) {
  let h = get_assn_hash_cons_table();
  let resopt = Hashtable::lookup_other_opt(h,a,assncmp,assnhash);
  if (resopt == NULL) {
    // given the invariant, if a was not in the table,
    // neither was nega in the table.
    let a2 = copy_assn(a);
    let nega2 = neg_assn(a);
    //int i = h->max_len;
    Hashtable::insert(h,a2,new AssnHashedInfo{a2,nega2,NULL,NULL});
    Hashtable::insert(h,nega2,new AssnHashedInfo{nega2,a2,NULL,NULL});
    //if (i < h->max_len)
    //  fprintf(stderr,"grew hash table on %s\n",assn2string(a2));
    return a2;
  } else 
    return (*resopt)->assn;
}

assn_t and(assn_t a1, assn_t a2){
  if (a1 == a2) return a1;
  switch $(a1,a2) {
  case $(&True,_): return a2;
  case $(_,&True): return a1;
  case $(&False,_): return a1;
  case $(_,&False): return a2;
  default: 
    // NB: used to sort the operands based on physical address, but
    // to keep things more deterministic, I'm not sorting now.
    let a = And(a1,a2);
    return hash_cons_assn(&a);
  }  
}

assn_t or(assn_t a1, assn_t a2){
  if (a1 == a2) return a1;
  switch $(a1,a2) {
  case $(&True,_): return a1;
  case $(_,&True): return a2;
  case $(&False,_): return a2;
  case $(_,&False): return a1;
  default: 
    // NB: used to sort the operands based on physical address, but
    // to keep things more deterministic, I'm not sorting now.
    let a = Or(a1,a2);
    return hash_cons_assn(&a);
  }
}

// some assertions that was created as part of 
// function signatures get nuked out before
// entering a new function definition analysis
// we need to enter the assertion (as well as
// its sub assertions) into the hash table again
// the reason we need to do this is while inserting
// an assertion to the table, we are computing
// the negation for the assertion at the same time
// and stored in the hash table as well.
static assn_t reinsert(assn_t a) {
  let h = get_assn_hash_cons_table();
  switch (a) {
  case &True:
  case &False: return a;
  case &And(a1,a2): 
    if (Hashtable::lookup_opt(h,a1) == NULL)
      a1 = reinsert(a1);
    if (Hashtable::lookup_opt(h,a2) == NULL)
      a2 = reinsert(a2);
    let a = And(a1,a2);
    return hash_cons_assn(&a);
  case &Or(a1,a2):
    if (Hashtable::lookup_opt(h,a1) == NULL)
      a1 = reinsert(a1);
    if (Hashtable::lookup_opt(h,a2) == NULL)
      a2 = reinsert(a2);
    let a = Or(a1,a2);
    return hash_cons_assn(&a);
  case &Prim(...):
    return hash_cons_assn(a);
  }
}

static term_set_t assn_fr_logicvar(assn_t a) {
  let h = get_assn_hash_cons_table();
  let ahinfo = Hashtable::lookup_opt(h,a);
  if (ahinfo == NULL) {
    a = reinsert(a);
    ahinfo = Hashtable::lookup_opt(h,a);
  }
  if ((*ahinfo)->free_logicvar_set != NULL)
    return *(*ahinfo)->free_logicvar_set;
  term_set_t res; 
  switch (a) {
  case &True:
  case &False:
    res = empty_term_set();
    break;
  case &And(a1,a2):
    fallthru(a1,a2);
  case &Or(a1,a2):
    res = Set::union_two(assn_fr_logicvar(a1),assn_fr_logicvar(a2));
    break;
  case &Prim(t1,_,t2):
    res = Set::union_two(term_fr_logicvar(t1),term_fr_logicvar(t2));
    break;
  }
  (*ahinfo)->free_logicvar_set = new res;
  return res;
}

static bool logicvar_in_assn(term_t lvar, assn_t a) {
  let lvset = assn_fr_logicvar(a);
  return Set::member(lvset,lvar);
}

// since a was already in the assn hashtable, (not a) must
// be there too. 
assn_t not(assn_t a){
  let h = get_assn_hash_cons_table();
  assn_hashed_info_t *ahinfo = Hashtable::lookup_opt(h,a);
  if (ahinfo == NULL) {
    a = reinsert(a);
    ahinfo = Hashtable::lookup_opt(h,a);
  }
  return (*ahinfo)->negation;
}

assn_t prim(term_t t1, prim_reln_t p, term_t t2){
  let ptr = Prim(t1,p,t2);
  return hash_cons_assn(&ptr);
}

// some macros and functions for rest of the primitive relations.
#define prim_assn(p,P) assn_t p(term_t t1, term_t t2) { \
  return prim((term_t)t1,P,(term_t)t2); \
}

prim_assn(slt,SLt)
  prim_assn(slte,SLte)
  prim_assn(ult,ULt)
  prim_assn(ulte,ULte)

assn_t eq(term_t t1, term_t t2){
  if (termcmp(t1,t2)>0) {
    t1 :=: t2;
  }
  return prim(t1,Eq,t2);
}

assn_t neq(term_t t1, term_t t2){
  if (termcmp(t1,zero())==0)
    return prim(zero(),ULt,t2);
  else if (termcmp(t2,zero())==0)
    return prim(zero(),ULt,t1);
  if (termcmp(t1,t2)>0) {
    t1 :=: t2;
  }
  return prim(t1,Neq,t2);
}

static assn_set_opt_t widen_it(assn_t a){
  let h = get_assn_hash_cons_table();
  let ahinfo = Hashtable::lookup_opt(h,a);
  if (ahinfo == NULL) {
    a = reinsert(a);
    ahinfo = Hashtable::lookup_opt(h,a);
  }
  if ((*ahinfo)->widened_set != NULL) return *(*ahinfo)->widened_set;
  assn_set_opt_t s;
  switch (a){
  case &True:
  case &False:
    Warn::impos("true and false should have widened_set");
  case &And(a1,a2):
    let s1 = widen_it(a1);
    let s2 = widen_it(a2);
    if (s1 == NULL || s2 == NULL) 
      s = NULL; 
    else 
      s = Set::union_two((assn_set_t)s1,(assn_set_t)s2);
    break;
  case &Or(a1,a2):
    let s1 = widen_it(a1);
    let s2 = widen_it(a2);
    if (s1 == NULL) 
      s = s2;
    else if (s2 == NULL)
      s = s1;
    else
      s = Set::intersect((assn_set_t)s1,(assn_set_t)s2);
    break;
  case &Prim(t1,p,t2):
    s = Set::singleton(assncmp,a);
    switch (p) {
   case Eq:
      // when we have t1 == t2 and they are of integral type, then we
      // also want to remember that t1 <= t2 and t2 <= t1 so that when
      // we intersect, we don't lose the information.
      let topt1 = get_term_type(t1);
      let topt2 = get_term_type(t2);
      if ((topt1 != NULL && Tcutil::is_integral_type((type_t)topt1)) ||
          (topt2 != NULL && Tcutil::is_integral_type((type_t)topt2))) {
        s = Set::insert(s,slte(t1,t2));
        s = Set::insert(s,slte(t2,t1));
        s = Set::insert(s,ulte(t1,t2));
        s = Set::insert(s,ulte(t2,t1));
      }
      break;
    case SLt:
      s = Set::insert(s,slte(t1,t2));
      break;
    case ULt:
      s = Set::insert(s,ulte(t1,t2));
      break;
    default: break;
    }
    break;
  }
  (*ahinfo)->widened_set = new s;
  return s;
}

// factors out all of the common primitive relations in a.
static assn_t widen(assn_t a) {
  // force the hash-cons table to be around just to be safe
  let sopt = widen_it(a);
  if (sopt == NULL) return &false_assn;
  let res = Set::fold(and,(assn_set_t)sopt,&true_assn);
  return res;
}

static assn_t subst_assn(term_dict_t dict, assn_t a, 
			 Hashtable::table_t<assn_t,assn_t> assn_h,
			 Hashtable::table_t<term_t,term_t> term_h){
  let a1 = Hashtable::lookup_opt(assn_h,a);
  if (a1 != NULL) {
#ifdef AssnDefDebug
    fprintf(stderr, "%s was substituted before, and the result is \n%s\n",
	    assn2string(a),assn2string(*a1));
#endif
    return *a1;
  }
  assn_t res;
  switch (a) {
  case &True:
  case &False: res = a; break;
  case &Prim(t1,p,t2):
    let s1 = subst_term(dict,t1,term_h);
    let s2 = subst_term(dict,t2,term_h);
    res = prim(s1,p,s2);
    break;
  case &And(a1,a2):
    let b1 = subst_assn(dict,a1,assn_h,term_h);
    let b2 = subst_assn(dict,a2,assn_h,term_h);
    res = and(b1,b2);
    break;
  case &Or(a1,a2):
    let b1 = subst_assn(dict,a1,assn_h,term_h);
    let b2 = subst_assn(dict,a2,assn_h,term_h);
    res = or(b1,b2);
    break;
  }
  Hashtable::insert(assn_h,a,res);
  return res;
} 

static assn_t subst_a(term_dict_t dict, assn_t a){
  // create new hashtables to record the substituted result
  // with respect to this particular dict. 
  Hashtable::table_t<assn_t,assn_t> assn_h = Hashtable::create(107,Core::ptrcmp,hash_ptr);
  Hashtable::table_t<term_t,term_t> term_h = Hashtable::create(137,Core::ptrcmp,hash_ptr);
  return subst_assn(dict,a,assn_h,term_h);
}
#ifdef AssnDefDebug
static void fprint_assn(assn_t a) {
  fprintf(stderr,"%s[%d]\n",assn2string(a),(int)a);
}

static void fprint_assncmp(assn_t a1, assn_t a2) {
  if (assncmp(a1,a2) == 0) fprintf(stderr, "%s EQ %s\n",
				   assn2string(a1),
				   assn2string(a2));
}
#endif
// tries to see if a can be proved from the set of primitive
// relations in ctxt.
static bool simple_prv(assn_set_t ctxt, assn_t a) {
  while (true) {
    switch (a) {
    case &Prim(t1,p,t2): 
      if (Set::member(ctxt,a)) return true;
#ifdef AssnDefDebug
      fprintf(stderr,"simple_prv prim: failed\n");
      Set::iter(fprint_assn,ctxt);
      Set::iter_c(fprint_assncmp,a,ctxt);
      fprintf(stderr,"simple_prv prim: %s[%d] NOT OK\n",assn2string(a),(int)a);
#endif
      switch (p) {
      case Neq: 
        return (Set::member(ctxt,ult(t2,t1)) ||
                Set::member(ctxt,ult(t1,t2)) ||
                Set::member(ctxt,slt(t2,t1)) ||
                Set::member(ctxt,slt(t1,t2)));
      case SLte: 
        return (Set::member(ctxt,slt(t1,t2)) || 
                Set::member(ctxt,eq(t1,t2)));
      case ULte: 
        return (Set::member(ctxt,ult(t1,t2)) || 
                Set::member(ctxt,eq(t1,t2)));
      default: return false;
      }
    case &True: return true;
    case &False: return false;
    case &And(a1,a2): 
      if (!simple_prv(ctxt,a1)) {
	return false;
      }
#ifdef AssnDefDebug
      fprintf(stderr,"simple_prv: and a1 OK\n");
#endif
      a = a2; 
      continue;
    case &Or(a1,a2): 
      if (simple_prv(ctxt,a1)) return true;
      a = a2;
      continue;
    }
  }
}


// returns true when ctxt |- a
// uses only very local, syntactic matching.
bool simple_prove(assn_t ctxt, assn_t a) {
  if (ctxt == a) return true; 
  let sopt = widen_it(ctxt);
  if (sopt == NULL) return true;
  return simple_prv((assn_set_t)sopt, a);
}


// functions related to handling the nonescvar_map
static list_t<string_t<`H>@`H, `H> m2string(vardecl_t vd, term_t value, list_t<string_t<`H>@`H, `H> stringlist){
  string_t<`H> res = aprintf("%s == %s", Absynpp::qvar2string(vd->name),term2string(value));
  return new List{new res,stringlist};
}

string_t<`H> map2string(nonescvar_map_t m){
  list_t<string_t<`H>@`H, `H> stringlist = Dict::fold(m2string,m,NULL);
  string_t<`H> s;
  if (stringlist == NULL) return aprintf(" ");
  else s = aprintf("%s",*stringlist->hd);
  while (stringlist->tl != NULL){
    stringlist = stringlist->tl;
    s = aprintf("%s && %s",s,*stringlist->hd);
  }
  return s;
}

// functions related to handling assnmap as one entity
string_t<`H> assnmap2string(assn_map_t am){
  return aprintf("{%s}&&\n%s",map2string(am.map),assn2string(am.assn));
}

string_t assnmap2dag(assn_map_t am) {
  return aprintf("{%s}\n%s",map2string(am.map),assn2dag(am.assn));
}

static nonescvar_map_t empty_map() {
   static nonescvar_map_t *mt = NULL;
   if (mt == NULL) {
     let d = Dict::empty(Core::ptrcmp);
     mt = new d;
     return d;
   } else
     return *mt;
}

assn_map_t false_assnmap(){
  return AssnMap{&false_assn,empty_map()};
}

assn_map_t true_assnmap(){
  return AssnMap{&true_assn,empty_map()};
}

// looking up a vd in the nonescvar_map,
// if the vd was not defined before, create a fresh new var
// and let vd maps to that var.
$(term_t,assn_map_t) lookup_var_map(vardecl_t vd, assn_map_t am){
  term_t *t = Dict::lookup_opt(am.map,vd);
  if (t != NULL) return $(*t,am);
  let newt = fresh_var(vd->type);
  let newm = Dict::insert(am.map,vd,newt);
  return $(newt, AssnMap{am.assn,newm});
}


// update the nonescvar_map to associate vd with a new term newt
assn_map_t update_var_map(vardecl_t vd,term_t newt,assn_map_t am){
  let newm = Dict::insert(am.map,vd,newt);
  return AssnMap{am.assn,newm};
}

// widen the assn part of an assnmap
assn_map_t widen_assnmap(assn_map_t am){
  return AssnMap{widen(am.assn),am.map};
}

// extend the assn part of an assnmap with or(a,_)
assn_map_t or_assnmap_assn(assn_map_t am, assn_t a){
  return AssnMap{or(am.assn,a),am.map};
}

// extend the assn part of an assnmap with and(a,_)
assn_map_t and_assnmap_assn(assn_map_t am, assn_t a){
  return AssnMap{and(am.assn,a),am.map};
}

term_t merge(vardecl_t vd, term_t t1, term_t t2){
  if (t1 == t2) return t1;
  else return fresh_var(vd->type);
}

static term_t subst_term_internal($(Hashtable::table_t<term_t,term_t>, term_dict_t) @env, term_t t) {
  return subst_term(env->f1,t,env->f0);
}

static assn_map_t subst_am(term_dict_t dict, assn_map_t am) {
  // create new hashtables to record the substituted result
  // with respect to this particular dict. 
  Hashtable::table_t<assn_t,assn_t> assn_h = Hashtable::create(107,Core::ptrcmp,hash_ptr);
  Hashtable::table_t<term_t,term_t> term_h = Hashtable::create(137,Core::ptrcmp,hash_ptr);
  let assn = subst_assn(dict,am.assn,assn_h,term_h);
  let map = Dict::map_c(subst_term_internal,new $(term_h,dict),am.map);
  return AssnMap(assn,map);
}
typedef struct Accum{
  assn_t a1;
  assn_t a2;
  nonescvar_map_t m1;
  nonescvar_map_t m2;
  nonescvar_map_t m;
} accum_t;

static bool logicvar_in_map_internal(term_t lvar, vardecl_t dummy, term_t value, bool in_map) {
  return in_map || logicvar_in_term(lvar,value);
}

static bool logicvar_in_map(term_t lv, nonescvar_map_t m) {
  return Dict::fold_c(logicvar_in_map_internal,lv,m,false);
}

// helper function used when we are folding in am1.map
// for each vd in am1.map, we look it up in am2.map and
// adjust the new map and assertions accordingly
static accum_t @`r foldm1(vardecl_t vd, term_t t, accum_t @`r accum){
  let t2 = Dict::lookup_opt(accum->m2,vd);
  // before merge: M1: x -> t M2: x undefined
  // after merge:  M: x -> v, a1 = and(a1,v==t), a2 unchanged
  if (t2 == NULL) {
    switch (t) {
    case &LogicVar(...): 
      if (!logicvar_in_assn(t,accum->a2) && !logicvar_in_map(t,accum->m2)) {
	accum->m2 = Dict::insert(accum->m2,vd,t);
	accum->m = Dict::insert(accum->m,vd,t);
	return accum;
      }
      break;
    default:
      break;
    }
    let v = fresh_var(vd->type);
    accum->a1 = and(accum->a1,eq(v,t));
    accum->m1 = Dict::insert(accum->m1,vd,v);
    accum->m2 = Dict::insert(accum->m2,vd,v);
    accum->m = Dict::insert(accum->m,vd,v);
    return accum;
  }
  // t2 != NULL
  if (t == *t2){
    // before merge: M1: x -> t, M2: x -> t
    // after merge:  M: x -> t
    accum->m = Dict::insert(accum->m,vd,t);
    return accum;
  }
  // before merge: M1: x -> t, M2: x -> t2
  // after merge: M: x -> v, a1 = and(a1,v==t), a2 = and(a2,v==t2)
  switch $(t,*t2) {
  case $(&LogicVar(...),&LogicVar(...)):
    if (!logicvar_in_assn(t,accum->a2) && !logicvar_in_map(t,accum->m2)){
      // t is logicvar and does not occur in am2
      accum->a2 = and(eq(t,*t2),accum->a2);
      accum->m2 = Dict::insert(accum->m2,vd,t);
      accum->m = Dict::insert(accum->m,vd,t);
      return accum;
    } else if (!logicvar_in_assn(*t2,accum->a1) && !logicvar_in_map(*t2,accum->m1)) {
      // *t2 is logicvar and does not occur in am1
      accum->a1 = and(eq(t,*t2),accum->a1);
      accum->m1 = Dict::insert(accum->m1,vd,*t2);
      accum->m = Dict::insert(accum->m,vd,*t2);
    }
    break;
  case $(&LogicVar(...),_):
    if (!logicvar_in_assn(t,accum->a2) && !logicvar_in_map(t,accum->m2)){
      // t is logicvar and does not occur in am2
      accum->a2 = and(eq(t,*t2),accum->a2);
      accum->m2 = Dict::insert(accum->m2,vd,t);
      accum->m = Dict::insert(accum->m,vd,t);
      return accum;
    }
    break;
  case $(_,&LogicVar(...)):
    if (!logicvar_in_assn(*t2,accum->a1) && !logicvar_in_map(*t2,accum->m1)) {
      // *t2 is logicvar and does not occur in am1
      accum->a1 = and(eq(t,*t2),accum->a1);
      accum->m1 = Dict::insert(accum->m1,vd,*t2);
      accum->m = Dict::insert(accum->m,vd,*t2);
    }
    break;
  default:
    break;
  }
  let v = fresh_var(vd->type);
  accum->a1 = and(eq(v,t),accum->a1);
  accum->a2 = and(eq(v,*t2),accum->a2);
  accum->m1 = Dict::insert(accum->m1,vd,v);
  accum->m2 = Dict::insert(accum->m2,vd,v);
  accum->m = Dict::insert(accum->m,vd,v);
  return accum;
}

// helper function when we are folding in am2.map-am1.map
// all the vd's in here are undefined in am1.map
// before merge: M1: x undefined,, M2: x->t
// after merge: M: x->v, a2 = and(v==t,a2);
static accum_t @`r foldm2(vardecl_t vd, term_t t, accum_t @`r accum){
  switch (t) {
//   case &LogicVar(...):
//     accum->m = Dict::insert(accum->m,vd,t);
//     return accum;
  default:
    let v = fresh_var(vd->type);
    accum->a2 = and(eq(v,t),accum->a2);
    accum->m = Dict::insert(accum->m,vd,v);
    return accum;
  }
}


term_dict_t empty_term_dict() {
  static term_dict_t *term_dict = NULL;
  if (term_dict == NULL) {
    term_dict = new Dict::empty(Core::ptrcmp);
  }
  return *term_dict;
}

// Given two assn_map am1, am2, where the nonescvarmap
// might be different, unify their nonescvar_maps and
// return a1,a2 map such that
// AssnMap(a1,map) <=> am1 and
// AssnMap(a2,map) <=> am2
$(assn_t,assn_t,nonescvar_map_t) unify_var_maps(assn_map_t am1, assn_map_t am2){
  if (am1.assn == &false_assn) return $(am1.assn,am2.assn,am2.map);
  if (am2.assn == &false_assn) return $(am1.assn,am2.assn,am1.map);
  accum_t accum = Accum{am1.assn,am2.assn,am1.map,am2.map,empty_map()};
  Dict::fold(foldm1,am1.map,&accum);
  Dict::fold(foldm2,Dict::difference(am2.map,am1.map),&accum);
  return $(accum.a1,accum.a2,accum.m);
}


static term_dict_t @collect_subst(nonescvar_map_t @map2, vardecl_t vd, term_t value, term_dict_t @`H dict) {
  switch (value) {
  case &LogicVar(...):
    // even if we have a logic var, if 
    // the other map had the same value for 
    // this vd, there is no need to do substitution
    let v = Dict::lookup_opt(*map2,vd);
    // otherwise, make sure we haven't used this 
    // value in earlier substitution.
    if (Dict::lookup_opt(*dict,value) == NULL) {
      if (v != NULL && *v == value) 
	return new Dict::insert(*dict,value,*v);
      return new Dict::insert(*dict,value,fresh_var(vd->type));
    }
    break;
  default:
    break;
  }
  return dict;
}
// given two assn_map am1, am2, where the nonescvarmap
// might be different unify their nonescvar_maps
// if am1.map: x->v where v is a logic var,
// we unify the am2.map to x->v too, but we need
// to do substitution in am2.assn and am2.map so
// that v does not occur free in am2
// we only want to do this expensive unify during
// loops to keep the cost do
$(assn_t,assn_t,nonescvar_map_t) unify_var_maps_subst(assn_map_t am1, assn_map_t am2) {
  if (am1.assn == &false_assn) return $(am1.assn,am2.assn,am2.map);
  if (am2.assn == &false_assn) return $(am1.assn,am2.assn,am1.map);
  // go over am1.map, if xi->vi, vi is a logic var,
  // we will substitue vi with a new ui in am2 so
  // that we can have x->vi in am2.
  term_dict_t subst_dict = *Dict::fold_c(collect_subst,&am2.map,am1.map,new empty_term_dict());
  let am2 = subst_am(subst_dict,am2);
  return unify_var_maps(am1,am2);
}

assn_map_t or_assnmap_assnmap(assn_map_t am1, assn_map_t am2){
  let $(a1,a2,map) = unify_var_maps(am1,am2);
  return AssnMap(or(a1,a2),map);
}


typedef struct Canonical_am_accum {
  assn_t assn;
  nonescvar_map_t map;
  struct Set::Set<term_t> @used_lvars;
} @canonical_am_accum_t;

static canonical_am_accum_t fold_canonical(vardecl_t vd, term_t value, canonical_am_accum_t accum) {
  switch (value) {
  case &LogicVar(...):
    if (!Set::member(accum->used_lvars,value)) {
      accum->used_lvars = Set::insert(accum->used_lvars,value);
      accum->map = Dict::insert(accum->map,vd,value);
      return accum;
    }
    break;
  default:
    break;
  }
  let v = fresh_var(vd->type);
  accum->used_lvars = Set::insert(accum->used_lvars,v);
  accum->map = Dict::insert(accum->map,vd,v);
  accum->assn = and(accum->assn,eq(v,value));
  return accum;
}

// given an assnmap, return a logically equivalent
// assnmap such that
// xi->vi where v1, ..., vn are distinct logicvars
// for every vd in the map
assn_map_t canonical_assnmap(assn_map_t am) {
  let accum = new Canonical_am_accum(am.assn,empty_map(),Set::empty(Core::ptrcmp));
  Dict::fold(fold_canonical,am.map,accum);
  return AssnMap (accum->assn,accum->map);
}
// given two assertion_map a1, a2, where the nonescvarmap 
// only maps vardecls to logical vars of the form:
// a1 = assn1, x1=v1(or NULL) ,x2=v2(or NULL),...
// a2 = assn2, y1=u1,          y2=u2,...
// return a new a2
// a2 = assn2(vi/ui) yi = ui for each xi=vi in a1.
// this function is used when we are comparing two
// function signatures (such as subtyping or type equivalence)
assn_t merge_assnmaps(list_t<vardecl_opt_t> vds1, assn_map_t a1,
			  list_t<vardecl_opt_t> vds2, assn_map_t a2){
  term_dict_t dict=empty_term_dict();
  for (; vds1 != NULL && vds2 != NULL; vds1 = vds1->tl, vds2 = vds2->tl){
    if (vds1->hd != NULL && vds2->hd != NULL){
      let v1 = Dict::lookup_opt(a1.map,(vardecl_t)vds1->hd);
      let v2 = Dict::lookup_opt(a2.map,(vardecl_t)vds2->hd);
      if (v1 != NULL && v2 != NULL){
	dict = Dict::insert(dict,*v2,*v1);
      }
    }
#ifdef AssnDefDebug
    else {
      if (vds1->hd == NULL) fprintf(stderr, "var in vds1 is NULL\n");
      if (vds2->hd == NULL) fprintf(stderr, "var in vds2 is NULL\n");
    }
#endif
  }
  if (Dict::is_empty(dict)) return a2.assn;
  else return subst_a(dict,a2.assn);
}

// given an assertion_map of the form 
// a1 = assn1, x1 = v1, x2 = v2, ...xn = vn
// and a new list of vardecls y1, y2, ...yn
// generating a new assertion_map of the form
// a2 = assn1[ui/vi] yi = ui
// this function is used when we are creating a
// new function signature that has the same type
// as the old function signature
extern assn_map_t *subst_vardecls(List::list_t<vardecl_opt_t> vds1,
				  List::list_t<vardecl_opt_t> vds2,
				  assn_map_t *a){
  if (a == NULL) return NULL;
  let newmap = empty_map();
  let dict = empty_term_dict();
  // deal with memory as if it were a variable...
  let v = Dict::lookup_opt(a->map,memory);
  if (v != NULL) {
    let u = fresh_var(NULL);
    newmap = Dict::insert(newmap,memory,u);
    dict = Dict::insert(dict,*v,u);
  }
  for(; vds1 != NULL && vds2 != NULL; vds1 = vds1->tl, vds2 = vds2->tl){
    if (vds1->hd != NULL && vds2->hd != NULL){
      let v = Dict::lookup_opt(a->map,(vardecl_t)vds1->hd);
      if (v != NULL) {
	let u = fresh_var(vds2->hd->type);
	// map yi to a new logicvar ui,
	newmap = Dict::insert(newmap,(vardecl_t)vds2->hd,u);
	// add pair vi,ui into the dict for substitution
	dict = Dict::insert(dict,*v,u);
      }
    }
  }
  // get newa = a.assn[ui/vi]
  let newa = subst_a(dict,a->assn);
  return new AssnMap(newa,newmap);
}

// given an assnmap that was part of a function's signature
// of the form assn /\ x1 = v1, x2 = v2,
// and the actual function argument t1,t2,...
// return the assertion assn[ti/vi]
// this function is used during vcgen for function calls
assn_t subst_args(list_t<vardecl_opt_t> args, vardecl_opt_t res,
                  list_t<term_t> actual_args, term_opt_t actual_res,
                  term_t mem,
                  assn_map_t am){
  term_dict_t dict = empty_term_dict();
  let mem_val = Dict::lookup_opt(am.map,memory);
  if (mem_val != NULL)
    dict = Dict::insert(dict,*mem_val,mem);
  if (res != NULL && actual_res != NULL){
    let res_val = Dict::lookup_opt(am.map,(vardecl_t)res);
    if (res_val != NULL)
      dict = Dict::insert(dict,*res_val, (term_t)actual_res);
  }
  for(; args != NULL && actual_args != NULL; args = args->tl, actual_args=actual_args->tl){
    if (args->hd != NULL && actual_args->hd != NULL){
      let arg_val = Dict::lookup_opt(am.map,(vardecl_t)args->hd);
      if (arg_val != NULL) 
	dict = Dict::insert(dict,*arg_val,actual_args->hd);
    }
  }
  return subst_a(dict,am.assn);
}

void reset_hash_cons_table(void){
  term_hash_cons_table = NULL;
  assn_hash_cons_table = NULL;
};
