/* Computing Strongest Post-conditions
   Copyright (C) 2003 Greg Morrisett
   This file is part of the Cyclone compiler.

   The Cyclone compiler is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   The Cyclone compiler is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with the Cyclone compiler; see the file COPYING. If not,
   write to the Free Software Foundation, Inc., 59 Temple Place -
   Suite 330, Boston, MA 02111-1307, USA. */

/* this file contains the definition of assertions, the terms used in
   assertions as well as utilities on them (such as comparison, debugging
   printing etc.). */

#include "absyn.h"
#include "absynpp.h"
#include "flags.h"
#include "evexp.h"
#include "tcutil.h"
#include "warn.h"
#include "assndef.h"
#include "unify.h"
#include <hashtable.h>
#include <list.h>
#include <dict.h>
#include <set.h>

namespace Hashtable {
  using List;
  struct Cell<`a,`b,`r> {
    `a key;
    `b value;
    struct Cell<`a,`b,`r>*`r next;
  };
  
  typedef struct Cell<`a,`b,`r>*`r cell_t<`a,`b,`r>;
  
  typedef struct Bucket<`a,`b,`r> {
    unsigned int length;
    cell_t<`a,`b,`r> cells;
  } bucket_t<`a,`b,`r>;
  
  /*abstract*/
  struct Table<`a,`b,`r> {
    region_t<`r> r;
    int          (@cmp)(`a,`a);
    int          (@hash)(`a);
    int	       max_len; // maximum length of bucket list before resize
    bucket_t<`a,`b,`r>?`r tab;
  };

  extern void print_hist(table_t<`a,`b> t);
}

namespace AssnDef;
using List;
using Hashtable;


///////////////////// Terms /////////////////////

string_t typopt2string(type_opt_t tp) {
  if (tp == NULL) return "NULL";
  return Absynpp::typ2string((type_t)tp);
}

static string_t term2string_i(term_t t, Set::set_t<term_t,`H> @seen, int @depth) {
  string_t res;
  bool seen_it = false;
  if (*depth == 0)
    return "<depth>";
  *depth = *depth - 1;
  if (Set::member(*seen,t)) {
    seen_it = true;
  }
  let old_seen = *seen;
  *seen = Set::insert(old_seen,t);
  switch (t) {
  case &Uint(i,_): res = aprintf("0x%x", i); break;
  case &Const(e): res = aprintf("%s[%d]",Absynpp::exp2string(e),(int)e); break;
  case &Tagof(t): res = aprintf("tagof_tm(%s)",term2string_i(t,seen,depth)); break;
  case &Select(t1,t2,tp):
    res = aprintf("Sel(%s,%s,%s)",term2string_i(t1,seen,depth),term2string_i(t2,seen,depth),typopt2string(tp));
    break;
  case &Update(t1,t2,t3):
    res = aprintf("Upd(%s,%s,%s)",term2string_i(t1,seen,depth),term2string_i(t2,seen,depth),term2string_i(t3,seen,depth));
    break;
  case &LogicVar(NULL,i,_): res = aprintf("_X%d",i); break;
  case &LogicVar(vd,i,_): 
    res = aprintf("_%s%d",Absynpp::qvar2string(vd->name),i); break;
  case &Unop(p,t1,_):
    res = aprintf("%s(%s)",Absynpp::prim2string(p),term2string_i(t1,seen,depth)); break;
  case &Binop(p,t1,t2,_):
    res = aprintf("(%s%s%s)",term2string_i(t1,seen,depth),Absynpp::prim2string(p),
                  term2string_i(t2,seen,depth));
    break;
  case &Cast(tp,tm):
    res = aprintf("(%s)%s",Absynpp::typ2string(tp),term2string_i(tm,seen,depth)); break;
  case &Aggr(is_union,tag,tms,_):
    static string_t lb = "{";
    static string_t rb = "}";
    static string_t comma = ",";
    list_t<stringptr_t> ss = new List{&lb,NULL};
    for (; tms != NULL; tms = tms->tl) {
      let s = term2string_i(tms->hd,seen,depth);
      ss = new List{new s,ss};
      if (tms->tl != NULL) ss = new List{&comma,ss};
    }
    ss = new List{&rb,ss};
    ss = List::imp_rev(ss);
    res = strconcat_l(ss);
    if (tag != -1) res = aprintf("tag(%d)%s",tag,res);
    if (is_union) res = aprintf("union%s",res);
    break;
  case &Proj(t,i,tp):
    res = aprintf("#%d(%s)",i,term2string_i(t,seen,depth));
    break;
  case &AggrUpdate(a,i,v):
    res = aprintf("Aupd(%s,%d,%s)",term2string_i(a,seen,depth),i,term2string_i(v,seen,depth));
    break;
  case &Addr(vd,invoke,_):
    res = aprintf("&%s_%s_%x",Absynpp::qvar2string(vd->name),
                  term2string_i(invoke,seen,depth),(unsigned int)vd); 
    //res = aprintf("&%s",Absynpp::qvar2string(vd->name));
    break;
  case &Alloc(e,id,nelts,invoke,_):
    res = aprintf("Alloc(%d,%d,%s,%s)", (int)e,id,term2string_i(nelts,seen,depth),term2string_i(invoke,seen,depth));
    break;
  case &Offsetf(t,i,tp):
    res = aprintf("Offsetf(%s,%d,%s)",term2string_i(t,seen,depth),i,typopt2string(tp));
    break;
  case &Offseti(t1,t2,_):
    res = aprintf("%s.+.%s",term2string_i(t1,seen,depth),term2string_i(t2,seen,depth));
    break;
  }
  *seen = old_seen;
  *depth = *depth + 1;
  if (seen_it) res = aprintf("<loop: %s>\n",res);
  return res;
}

string_t term2string(term_t t) {
  let s = Set::empty(termcmp);
  let d = 100;
  return term2string_i(t, &s, &d);
}

static int hash_const(Absyn::cnst_t c) {
  switch (c) {
  case Absyn::Cnst{.Null_c = _}: return 0;
  case Absyn::Cnst{.Char_c = $(_,c)}: return c;
  case Absyn::Cnst{.Short_c = $(_,c)}: return c;
  case Absyn::Cnst{.Int_c = $(_,i)}: return i;
  case Absyn::Cnst{.LongLong_c = $(_,i)}: return (int)i;
  case Absyn::Cnst{.Float_c = $(s,_)}: fallthru(s);
  case Absyn::Cnst{.Wchar_c = s}: fallthru(s);
  case Absyn::Cnst{.String_c = s}: fallthru(s);
  case Absyn::Cnst{.Wstring_c = s}:
    return Hashtable::hash_string(s);
  }
}

static int hash_binding(Absyn::binding_t b) {
  switch (b) {
  case &Absyn::Local_b(vd): return ((unsigned)vd >> 4) + 21;
  case &Absyn::Pat_b(vd): return ((unsigned)vd >> 4) + 23;
  case &Absyn::Param_b(vd): return ((unsigned)vd >> 4) + 27;
  case &Absyn::Funname_b(vd): return ((unsigned)vd >> 4) + 29;
  case &Absyn::Global_b(vd): return ((unsigned)vd >> 4) + 31;
  case &Absyn::Unresolved_b(q): return 1;
  }
}

static int hash_exp(exp_t e) {
  switch (e->r) {
  case &Absyn::Const_e(c): return hash_const(c);
  case &Absyn::Var_e(b): return hash_binding(b);
  default: return tagof(e->r) + 1;
  }
}

int termhash(datatype Term @t) {
  switch (t) {
  case &Uint(i,_): return i;
  case &Const(e): return hash_exp(e) + 61;
  case &LogicVar(vd,i,_): return ((unsigned int)vd >> 4) + (i+1);
  case &Unop(p,t1,_): return p + ((unsigned int)t1 >> 4) + 1;
  case &Binop(p,t1,t2,_):
    return p + (((unsigned int)t1 + (unsigned int)t2) >> 4);
  case &Cast(_,t): return termhash(t) + 1;
  case &Select(t1,t2,_):
    return (((unsigned int)t1 + (unsigned int)t2) >> 4) + 2;
  case &Update(t1,t2,t3):
    return (((unsigned int)t1 + (unsigned int)t2 + (unsigned int)t3) >> 4) + 3;
  case &Proj(t,i,_): return ((unsigned int)t >> 4) + i + 23;
  case &Aggr(is_union,tag,ts,_):
    unsigned int res = 37+tag+is_union;
    for (; ts != NULL; ts = ts->tl)
      res = res + ((unsigned int)ts->hd >> 4);
    return res;
  case &AggrUpdate(a,i,v):
    return ((((unsigned int)a) + ((unsigned int)v)) >> 4) + i + 17;
  case &Addr(vd,invok,_): 
    return (((unsigned int)invok + (unsigned int)vd) >> 4)+7;
  case &Alloc(e,i,n,invok,_): 
    return (((unsigned int)e + (unsigned int)n + (unsigned int)invok) >> 4)+i;
  case &Offsetf(t,i,_): return ((unsigned int)t >> 4) + i + 11;
  case &Offseti(t,index,_): 
    return (((unsigned int)index + (unsigned int)t) >> 4) + 13;
  case &Tagof(t): return ((unsigned)t >> 4) + 741;
  }
}

int termcmp(datatype Term @`r1 _t1, datatype Term @`r2 _t2) {
  datatype Term @`r1+`H t1 = _t1;
  datatype Term @`r2+`H t2 = _t2;
 LOOP:
  int c = tagof(t1) - tagof(t2);
  if (c != 0) return c;
  if (t1 == t2) return 0;
  switch $(t1,t2) {
  case $(&Binop(p1,t11,t12,tp1),&Binop(p2,t21,t22,tp2)):
    int c = (int)p1 - (int)p2;
    c = termcmp(t11,t21);
    if (c != 0) return c;
    t1 = t12;
    t2 = t22;
    goto LOOP;
  case $(&LogicVar(vd1,i,_),&LogicVar(vd2,j,_)): 
    int c = i - j;
    if (c != 0) return c;
    return (int)vd1 - (int)vd2;
  case $(&Uint(i1,_), &Uint(i2,_)): return i1-i2;
  case $(&Const(e1),&Const(e2)): 
    return Evexp::exp_cmp(e1,e2)?(int)e1-(int)e2:0;
  case $(&Addr(vd1,i1,_),&Addr(vd2,i2,_)): 
    int c = (int)vd1 - (int)vd2;
    if (c != 0) return c;
    t1 = i1;
    t2 = i2;
    goto LOOP;
  case $(&Unop(p1,t1a,_),&Unop(p2,t2a,_)): 
    int c = (int)p1 - (int)p2;
    if (c != 0) return c;
    t1 = t1a;
    t2 = t2a;
    goto LOOP;
  case $(&Cast(tp1,tm1),&Cast(tp2,tm2)):
    int c = Tcutil::typecmp(tp1,tp2);
    if (c != 0) return c;
    t1 = tm1;
    t2 = tm2;
    goto LOOP;
  case $(&Select(t11,t12,_),&Select(t21,t22,_)):
    int c = termcmp(t11,t21);
    if (c != 0) return c;
    t1 = t12;
    t2 = t22;
    goto LOOP;
  case $(&Update(t11,t12,t13),&Update(t21,t22,t23)):
    int c = termcmp(t11,t21);
    if (c != 0) return c;
    c = termcmp(t12,t22);
    if (c != 0) return c;
    t1 = t13;
    t2 = t23;
    goto LOOP;
  case $(&Tagof(tm1),&Tagof(tm2)): 
    t1 = tm1;
    t2 = tm2;
    goto LOOP;
  case $(&Proj(tm1,i1,_),&Proj(tm2,i2,_)): 
    int c = i1 - i2;
    if (c != 0) return c;
    t1 = tm1;
    t2 = tm2;
    goto LOOP;
  case $(&AggrUpdate(tm1,i1,v1),&AggrUpdate(tm2,i2,v2)):
    int c = i1 - i2;
    if (c != 0) return c;
    c = termcmp(tm1,tm2);
    if (c != 0) return c;
    t1 = v1;
    t2 = v2;
    goto LOOP;
  case $(&Alloc(e1,i1,n1,v1,_),&Alloc(e2,i2,n2,v2,_)):
    int c = (int)e1 - (int)e2;
    if (c != 0) return c;
    c = i1 - i2;
    if (c != 0) return c;
    c = termcmp(n1,n2);
    if (c != 0) return c;
    t1 = v1;
    t2 = v2;
    goto LOOP;
  case $(&Offsetf(tm1,i1,_),&Offsetf(tm2,i2,_)):
    int c = i1 - i2;
    if (c != 0) return c;
    t1 = tm1;
    t2 = tm2;
    goto LOOP;
  case $(&Offseti(tm1,i1,_),&Offseti(tm2,i2,_)):
    int c = termcmp(i1,i2);
    if (c != 0) return c;
    t1 = tm1;
    t2 = tm2;
    goto LOOP;
  case $(&Aggr(is_union1,tag1,ts1,_),&Aggr(is_union2,tag2,ts2,_)):
    int c = tag1 - tag2;
    if (c != 0) return c;
    c = is_union2 - is_union1;
    if (c != 0) return c;
    for (; ts1 != NULL && ts2 != NULL; ts1=ts1->tl, ts2=ts2->tl) {
      c = termcmp(ts1->hd,ts2->hd);
      if (c != 0) return c;
    }
    if (ts1 == ts2) return 0;
    if (ts1 == NULL) return -1;
    return 1;
  default: Warn::impos("different terms but same codes!");
  }
}

static term_t copy_term(datatype Term@ t, unsigned @size) {
  switch (t) {
  case &Uint(i,tp): *size = 1; return new Uint(i,tp);
  case &Const(e): *size = 1; return new Const(e);
  case &Addr(vd,t,tp): 
    *size = 1 + term_size(t);
    return new Addr(vd,t,tp);
  case &LogicVar(vd,i,tp): 
    *size = 1;
    return new LogicVar(vd,i,tp);
  case &Binop(p,t1,t2,tp): 
    *size = 1 + term_size(t1) + term_size(t2);
    return new Binop(p,t1,t2,tp);
  case &Unop(p,t,tp): 
    *size = 1 + term_size(t);
    return new Unop(p,t,tp);
  case &Cast(tp,t): 
    *size = 1 + term_size(t);
    return new Cast(tp,t);
  case &Select(t1,t2,tp): 
    *size = 1 + term_size(t1) + term_size(t2);
    return new Select(t1,t2,tp);
  case &Update(t1,t2,t3): 
    *size = 1 + term_size(t1) + term_size(t2) + term_size(t3);
    return new Update(t1,t2,t3);
  case &Proj(t,i,tp): 
    *size = 1 + term_size(t);
    return new Proj(t,i,tp);
  case &AggrUpdate(t,i,v): 
    *size = 1 + term_size(t) + term_size(v);
    return new AggrUpdate(t,i,v);
  case &Aggr(is_union,tag,ts,tp): 
    *size = 1;
    for (let p = ts; p != NULL; p = p->tl) *size += term_size(p->hd);
    return new Aggr(is_union,tag,ts,tp);
  case &Alloc(e,i,n,v,tp): 
    *size = 1 + term_size(v) + term_size(n);
    return new Alloc(e,i,n,v,tp);
  case &Offsetf(t,i,tp): 
    *size = 1 + term_size(t);
    return new Offsetf(t,i,tp);
  case &Offseti(t,i,tp): 
    *size = 1 + term_size(t) + term_size(i);
    return new Offseti(t,i,tp);
  case &Tagof(t): 
    *size = 1 + term_size(t);
    return new Tagof(t);
  }
}

datatype Term.Uint zero_value = Uint(0,NULL);
datatype Term.Uint one_value = Uint(1,NULL);

static term_set_t empty_term_set() {
   static term_set_t *term_set = NULL;
   if (term_set == NULL) {
     term_set = new Set::empty(termcmp);
   }
   return *term_set;
}

typedef struct TermHashedInfo {
  term_t term;
  unsigned size;
  term_set_t *free_logicvar_set;
} @term_hashed_info_t;

// a hash-table to hold all of the term nodes to maximize sharing.  
static struct Hashtable::Table<term_t,term_hashed_info_t> *term_hash_cons_table = NULL;


static Hashtable::table_t<term_t,term_hashed_info_t>
get_term_hash_cons_table(){
  Hashtable::table_t<term_t,term_hashed_info_t> h;
  if (term_hash_cons_table == NULL) {
    h = Hashtable::create(221, termcmp, termhash);
    term_hash_cons_table = h;
    term_set_t tst = empty_term_set();
    Hashtable::insert(h,&zero_value,new TermHashedInfo{&zero_value,1,new tst});
    Hashtable::insert(h,&one_value,new TermHashedInfo{&one_value,1,new tst});
  } else {
    h = (Hashtable::table_t)term_hash_cons_table;
  }
  return h;
}

static term_t hash_cons_term(datatype Term @t) {
  let h = get_term_hash_cons_table();
  let resopt = Hashtable::lookup_other_opt(h,t,termcmp,termhash);
  if (resopt == NULL) {
    unsigned size = 0;
    let t2 = copy_term(t,&size);
    //int i = h->max_len;
    Hashtable::insert(h,t2,new TermHashedInfo{t2,size,NULL});
    //if (i < h->max_len) 
    //  fprintf(stderr,"grew term hash table after inserting %s due to chains %d\n",term2string(t2),i);
    return t2;
  } else 
    return (*resopt)->term;
}

// compute and cache the size of a term
unsigned term_size(term_t t) {
  let h = get_term_hash_cons_table();
  let resopt = Hashtable::lookup_opt(h,t);
  if (resopt == NULL) {
    hash_cons_term(t);
    return term_size(t);
  }
  let res = *resopt;
  return res->size;
}

// computing the set of logicvars that occured
// in a term, use the hash table to memoize the
// result
term_set_t term_fr_logicvar(term_t t) {
  let h = get_term_hash_cons_table();
  let thinfo = Hashtable::lookup_opt(h,t);
  // the info was computed before and stored in the table
  if (thinfo == NULL) {
    t = hash_cons_term(t);
    thinfo = Hashtable::lookup_opt(h,t);
  }
  if ((*thinfo)->free_logicvar_set != NULL)
    return *(*thinfo)->free_logicvar_set;
  term_set_t res;
  switch (t) {
  case &Uint(...): 
  case &Const(...):
    res = empty_term_set(); break;
  case &LogicVar(...):
    res = Set::singleton(termcmp,t);
    break;
  case &Alloc(_,_,t1,t2,_):
    fallthru(t1,t2);
  case &Select(t1,t2,_):
    fallthru(t1,t2);
  case &AggrUpdate(t1,_,t2):
    fallthru(t1,t2);
  case &Binop(_,t1,t2,_):
    fallthru(t1,t2);
  case &Offseti(t1,t2,_):
    res = Set::union_two(term_fr_logicvar(t1),term_fr_logicvar(t2));
    break;
  case &Update(t1,t2,t3):
    res = Set::union_two(Set::union_two(term_fr_logicvar(t1),
					term_fr_logicvar(t2)),
			 term_fr_logicvar(t3));
    break;
  case &Addr(_,t1,_):
    fallthru(t1);
  case &Unop(_,t1,_):
    fallthru(t1);
  case &Proj(t1,_,_):
    fallthru(t1);
  case &Offsetf(t1,_,_):
    fallthru(t1);
  case &Tagof(t1):
    fallthru(t1);
  case &Cast(_,t1):
    res = term_fr_logicvar(t1);
    break;
  case &Aggr(_,_,ts,_):
    let tsets = map(term_fr_logicvar,ts);
    res = fold_left(Set::union_two,empty_term_set(),tsets);
    break;
  }
  (*thinfo)->free_logicvar_set = new res;
  return res;
}

static bool logicvar_in_term(term_t lvar, term_t t) {
  let lvset = term_fr_logicvar(t);
  return Set::member(lvset,lvar);
}

term_t uint(unsigned int i) {
  let t = Uint(i,NULL);
  return hash_cons_term(&t);
}
term_t zero() {
  return &zero_value;
}
term_t one() {
  return &one_value;
}
term_t cnst(Absyn::exp_t e) { 
  let $(c, known) = Evexp::eval_const_uint_exp(e);
  if (known) return uint(c);
  let t = Const(e);
  return hash_cons_term(&t);
}
term_t addr(vardecl_t vd, term_t invok) {
  type_t tp = vd->type;
  switch (Absyn::compress(tp)) {
  case &Absyn::ArrayType(...): break;
  default: 
    type_t rgn = vd->rgn ? (type_t)vd->rgn : Absyn::heap_rgn_type;
    tp = Absyn::at_type(tp,rgn, Absyn::al_qual_type, Absyn::empty_tqual(0), Absyn::false_type, Absyn::false_type);
  }
  let t = Addr(vd,invok,tp);
  return hash_cons_term(&t);
}
term_t logicvar(vardecl_opt_t vd,int i,type_opt_t tp) {
  let t = LogicVar(vd,i,tp);
  return hash_cons_term(&t);
}
term_t update(term_t t1, term_t t2, term_t t3) {
 LOOP1:
  // if t2 = a.fi then we want to turn this into
  // update(t1, a, aggr_update(select(t1,a), i, t3))
  // JGM: this might be a bad idea -- the select could reduce
  // to a large aggregate (which is fine because it will share)
  // but then the aggregate update will reduce and change the
  // aggregate (breaking the sharing...).  
  switch (t2) {
  case &Offsetf(a,i,tp):
    t2 = a;
    type_opt_t tpopt = NULL;
    if (tp != NULL && Tcutil::is_pointer_type((type_t)tp))
      tpopt = Tcutil::pointer_elt_type((type_t)tp);
    t3 = aggr_update(select(t1,a,tp),i,t3);
    goto LOOP1;
  default:
    break;
  }
  // if t1 == update(m,t2,_) then reduce to update(m,t2,t3).
 LOOP2:
  switch (t1) {
  case &Update(m,t,_) && t == t2:
    t1 = m;
    goto LOOP2;
  default: break;
  }
  let t = Update(t1,t2,t3);
  return hash_cons_term(&t);
}

term_t aggr_update(term_t t1, unsigned i, term_t t2) {
 LOOP:
  switch (t1) {
  case &AggrUpdate(t,j,t3):
    if (i == j) {
      // aggr_update(aggr_update(t,i,_),i,t2) == aggr_update(t,i,t2)
      t1 = t;
      goto LOOP;
    } 
    if (i < j) {
      // aggr_update(aggr_update(t,j,t3),i,t2) == 
      //    aggr_update(aggr_update(t,i,t2),j,t3)
      return aggr_update(aggr_update(t,i,t2),j,t3);
    }
    break;
  case &Aggr(is_union,tag,ts,tp):
    // for unions, we only have to update one field, but also the tag
    if (is_union) return aggr(is_union,i,list(t2),tp);
    // for aggregates and data types, the tag remains the same...
    list_t<term_t> revnewts = NULL;
    for (; i != 0; i--) {
      if (ts == NULL) fallthru;
      revnewts = new List{ts->hd,revnewts};
      ts = ts->tl;
    }
    if (ts == NULL) fallthru;
    list_t<term_t> newts = revappend(revnewts,new List{t2,ts->tl});
    let res = aggr(is_union,tag,newts,tp);
    return res;
  default:
    break;
  }
  let t = AggrUpdate(t1,i,t2);
  return hash_cons_term(&t);
}

static bool address_disjoint(term_t t1, term_t t2);

// try to prove the two terms t1 and t2 are not equal
static bool term_neq(term_t t1, term_t t2) {
 LOOP:
  switch $(t1,t2) {
  case $(&Uint(i,_),&Uint(j,_)): return i != j;
  case $(&Binop(Absyn::Plus,t11,t12,_),&Binop(Absyn::Plus,t21,t22,_)) && t11 == t21:
    // t+t12 != t+t22 if t12 != t22
    t1 = t12;
    t2 = t22;
    goto LOOP;
  case $(&Binop(Absyn::Plus,t11,t12,_),t21) && t11 == t21:
    t1 = t12;
    t2 = zero();
    goto LOOP;
  case $(t11, &Binop(Absyn::Plus,t21,t22,_)) && t11 == t21:
    t1 = zero();
    t2 = t22;
    goto LOOP;
  case $(&Unop(Absyn::Bitnot,t1,_),t2) && t1 == t2: return true;
  case $(t1,&Unop(Absyn::Bitnot,t2,_)) && t1 == t2: return true;
  default:
    // if they are disjoint addresses then they can't be equal
    return address_disjoint(t1,t2);
  }
}

// t1 and t2 are pointers and we want to argue that they are not
// overlapping -- in particular, sel(update(m,t1,v),t2) == sel(m,t2).
static bool address_disjoint(term_t t1, term_t t2) {
 LOOP:
  if (t1 == t2) return false;
  switch $(t1,t2) {
  case $(&Addr(x,nv1,_), &Addr(y,nv2,_)): 
    // could try to prove nv1 != nv2 but they're always vars
    return x != y;
  case $(&Addr(...), &Alloc(...)): return true;
  case $(&Alloc(...), &Addr(...)): return true;
  case $(&Alloc(exp1,i1,tm1,nv1,_),&Alloc(exp2,i2,tm2,nv2,_)):
    // distinct allocation points must be distinct regions of memory
    // could try to prove nv1 != nv2 but they're always vars
    // could try to prove tm1 != tm2 but unlikely when static
    return (exp1 != exp2 || i1 != i2);
  case $(&Offsetf(tm1,i,_),&Offsetf(tm2,j,_)):
    // given the same root but distinct offsets, we know the addresses
    // cannot overlap.
    if (tm1 == tm2 && i != j) return true;
    t1 = tm1;
    t2 = tm2;
    goto LOOP;
  case $(&Offseti(tm1,i1,_),&Offseti(tm2,i2,_)):
    if (tm1 == tm2 && term_neq(i1,i2)) return true;
    t1 = tm1;
    t2 = tm2;
    goto LOOP;
  // If we can prove the roots of the terms don't overlap
  // then an offset can't overlap.
  case $(&Offsetf(tm1,_,_),_): 
    t1 = tm1;
    goto LOOP;
  case $(_,&Offsetf(tm2,_,_)): 
    t2 = tm2;
    goto LOOP;
  case $(&Offseti(tm1,_,_),_): 
    t1 = tm1;
    goto LOOP;
  case $(_,&Offseti(tm2,_,_)): 
    t2 = tm2;
    goto LOOP;
  default: return false;
  }
}

$(term_t,list_t<$(int,type_opt_t)@>) split_addr(term_t a) {
  list_t<$(int,type_opt_t)@> fields = NULL;
  while (true) {
    switch (a) {
    case &Offsetf(r,i,tp):
      fields = new List{new $(i,tp),fields};
      a = r;
      continue;
    default: 
      return $(a,fields);
    }
  }
}

term_t apply_aggr_update(term_t a, list_t<$(int,type_opt_t)@> fields, term_t v) {
  if (fields == NULL) return v;
  let &$(i,tpopt) = fields->hd;
  type_opt_t tp = NULL;
  if (tpopt != NULL && Tcutil::is_pointer_type((type_t)tpopt)) {
    tp = Tcutil::pointer_elt_type((type_t)tpopt);
  }
  let res = aggr_update(a, i,
                        apply_aggr_update(proj(a,i,tp),fields->tl,v));
  return res;
}

static term_t proj_fields(term_t v, list_t<$(int,type_opt_t)@> fs) {
  for (; fs != NULL; fs = fs->tl) {
    let &$(i,tpopt) = fs->hd;
    if (tpopt != NULL && Tcutil::is_pointer_type((type_t)tpopt)) {
      v = proj(v,i,Tcutil::pointer_elt_type((type_t)tpopt));
    } else 
      v = proj(v,i,NULL);
  }
  return v;
}

term_t select(term_t t1, term_t t2,type_opt_t tp) {
 LOOP:
  switch $(t1,t2) {
  case $(&Update(m,a1,v),a2):
    if (a1 == a2) return v;
    if (address_disjoint(a1,a2)) {
      t1 = m;
      goto LOOP;
      // effectively: return select(m,a2,tp);
    }
    // If a2 = offsetf(...(offsetf(offsetf(a1,i1),i2))...,in) then we can 
    // turn this into 
    // proj(...(proj(proj(v,i1),i2))...,in)
    let $(root,fields) = split_addr(a2);
    if (a1 == root) 
      return proj_fields(v,fields);
    fallthru;
  default:
    let t = Select(t1,t2,tp);
    return hash_cons_term(&t);
  }
}

// Unions are represented by one tagged value.  The tag records
// the member that was last written, and we can only reduce a
// projection when the member being read was the same as the one last
// written.  (This holds for both @tagged and bits-only unions.)
// For datatypes, the is_union field is false, and the tag field
// records which constructor we're dealing with.  For structs,
// the is_union field is false, and the tag is set to -1.
term_t proj(term_t t1, unsigned i, type_opt_t tp) {
 LOOP:
  switch (t1) {
  case &Aggr(is_union,tag,ts,_): 
    let n = List::length(ts);
    if (!is_union && i < n)
      return nth(ts,i);
    else if (tag == i && n >= 1)
      return ts->hd;
    else break;
  case &AggrUpdate(t,j,t2):
    if (i == j) return t2;
    // if t1 is a union, then we shouldn't reduce.  The last update
    // was to field j, but we're trying to read from field i.  
    let topt = get_term_type(t1);
    if (topt == NULL) goto NOREDUCE;
    switch (Absyn::compress((type_t)topt)) {
    case &Absyn::AppType(&Absyn::AggrCon(ai),_):
      switch (ai) {
      case {.KnownAggr = &ad}: 
        if (ad->kind == Absyn::UnionA) goto NOREDUCE; break;
      case {.UnknownAggr = $(Absyn::UnionA,_,_)}: goto NOREDUCE;
      default: break;
      }
      break;
    case &Absyn::AnonAggrType(Absyn::UnionA,_,_): goto NOREDUCE;
    default: break;
    }
    t1 = t;
    goto LOOP;
  case &Select(m,a,tp2): return select(m,offsetf(a,i,tp2),tp);
  default: break;
  }
 NOREDUCE:
  let t = Proj(t1,i,tp);
  return hash_cons_term(&t);
}

term_t aggr(bool is_union, unsigned tag, list_t<term_t,`H> ts, type_opt_t tp){
  // could eta-reduce Aggr(proj(t,0),proj(t,1),...,proj(t,n)) to t,
  // using the type information to figure out n.
  let t = Aggr(is_union,tag,ts,tp);
  return hash_cons_term(&t);
}
term_t struct_aggr(list_t<term_t,`H> ts, type_opt_t tp) {
  return aggr(false,-1,ts,tp);
}
term_t datatype_aggr(unsigned tag, list_t<term_t,`H> ts, type_opt_t tp) {
  return aggr(false,tag,ts,tp);
}
term_t union_aggr(unsigned tag, list_t<term_t,`H> ts, type_opt_t tp) {
  return aggr(true,tag,ts,tp);
}
term_t tagof_tm(term_t t1) {
  switch (t1) {
  case &Aggr(_,tag,...): return uint(tag);
  case &AggrUpdate(t,j,_):
    // if t is a union, then the tag is j
    let topt = get_term_type(t1);
    if (topt == NULL) break;
    switch (Absyn::compress((type_t)topt)) {
    case &Absyn::AppType(&Absyn::AggrCon(ai),_):
      switch (ai) {
      case {.KnownAggr = &ad}: 
        if (ad->kind == Absyn::UnionA) return uint(j);
        break;
      case {.UnknownAggr = $(Absyn::UnionA,_,_)}: return uint(j);
      default: break;
      }
      break;
    case &Absyn::AnonAggrType(Absyn::UnionA,_,_): return uint(j);
    default: break;
    }
    break;
  default: break;
  }
  let t = Tagof(t1);
  return hash_cons_term(&t);
}

term_t cast(type_t tp, term_t tm){
  let t = Cast(tp,tm);
  return hash_cons_term(&t);
}

term_t alloc(exp_t e, term_t nelts, term_t invok, type_opt_t tp){
  static int counter = 0;
  let t = Alloc(e,counter,nelts,invok,tp);
  counter++;
  return hash_cons_term(&t);
}

term_t offsetf(term_t tm, unsigned int i, type_opt_t tp){
  let t = Offsetf(tm,i,tp);
  return hash_cons_term(&t);
}

term_t offseti(term_t tm, term_t i, type_opt_t tp){
  switch $(tm,i) {
  case $(_,&Uint(0,_)): return tm;
  case $(&Offseti(t,j,tp2),_):
    if (tp != NULL && tp2 != NULL && Unify::unify(tp,tp2))
      return offseti(t,plus(i,j,Absyn::sint_type),tp);
    fallthru;
  default:
    let t = Offseti(tm,i,tp);
    return hash_cons_term(&t);
  }
}
term_t fresh_var(type_opt_t tp){
  static int counter = 0;
  let t = logicvar(NULL,counter,tp);
  counter++;
  return t;
}

term_t plus(term_t t1, term_t t2, type_opt_t tp) {
  return binop(Absyn::Plus,t1,t2,tp);
}
term_t minus(term_t t1, term_t t2, type_opt_t tp) {
  return binop(Absyn::Minus,t1,t2,tp);
}

term_t unop(Absyn::primop_t p, term_t t, type_opt_t tp) {
  // +t = t;
  if (p == Absyn::Plus) return t;
  // -t = t * (-1);
  if (p == Absyn::Minus) return binop(Absyn::Times,t,uint(-1),tp);
  let ptr = Unop(p,t,tp);
  return hash_cons_term(&ptr);
}

term_t numelts_term(term_t t) {
  return unop(Absyn::Numelts, t, Absyn::uint_type);
}

// Need to fake up vardecls for the "memory" and "exception"
using Absyn {
  static string_t memory_var = "#Mem";
  static $(nmspace_t,var_t) memvar = $(Nmspace{.Loc_n = 0},&memory_var);
  static datatype TyCon.VoidCon void_con = VoidCon;
  static datatype Type.AppType vd_type = AppType(&void_con,NULL);

  struct Absyn::Vardecl memory_struct = {
    .sc = Absyn::Public,
    .name = &memvar,
    .varloc = 0,
    .tq = {0,0,0,0,0},
    .type = &vd_type,
    .initializer = NULL,
    .rgn = NULL,
    .attributes = NULL,
    .escapes = false,
    .is_proto = false,
    .rename = NULL
  };
  vardecl_t memory = &memory_struct;

  static string_t exception_var = "#Exn";
  static $(nmspace_t,var_t) exnvar = $(Nmspace{.Loc_n = 0},&exception_var);

  struct Absyn::Vardecl exception_struct = {
    .sc = Absyn::Public,
    .name = &exnvar,
    .varloc = 0,
    .tq = {0,0,0,0,0},
    .type = &vd_type,
    .initializer = NULL,
    .rgn = NULL,
    .attributes = NULL,
    .escapes = false,
    .is_proto = false,
    .rename = NULL
  };

  vardecl_t exception_vardecl() {
    let vd = &exception_struct;
    vd->type = Absyn::exn_type();
    return vd;
  }
}

// data structure for a polynomial a1*t1 + a2*t2 + ... + an*tn
// used in 1) normalizing a term. 
//         2) generating matrix for Gaussian elimination
typedef List::list_t<$(int,term_t)@,`H> coefficient_term_list_t;
// a function to retrieve the coefficients and terms in a
// polynomial from a term, the extra integer represent
// the constants a0 in the term
// a0 + a1*t1 + a2*t2 + ...


$(coefficient_term_list_t,int) get_coefficient_term_list(term_t t) {
  coefficient_term_list_t coefficient_term_list = NULL;
  int res = 0;
 LOOP:
  switch(t){
  case &Uint(i,_): res = i; break;
  case &Binop(Absyn::Plus,t1,&Uint(i,_),_):
    res = i;
    t = t1;
    goto LOOP;
  case &Binop(Absyn::Plus, t1, t2,_):
    switch(t2){
    case &Binop(Absyn::Times,t21,&Uint(c2,_),_):
      coefficient_term_list = new List(new $(c2,t21), coefficient_term_list);
      break;
    case &Binop(Absyn::Plus,_,_,_):
      Warn::impos("Plus in the right branch, not a normal form");
      break;
    default:
      coefficient_term_list = new List(new $(1,t2),coefficient_term_list);
      break;
    }
    t = t1;
    goto LOOP;
  default:
    switch(t){
    case &Binop(Absyn::Times,t21,&Uint(c2,_),_):
      coefficient_term_list = new List(new $(c2,t21), coefficient_term_list);
      break;
    default:
      coefficient_term_list = new List(new $(1,t),coefficient_term_list);
      break;
    }
    break;
  }
  return $(coefficient_term_list,res);
}

// given two sorted list [(t1,c1),(t2,c2),...,(tn,cn)]
// and [(s1,d1),(s2,d2),...,(sn,dn)]
// generate a merged list [(q1,e1),(q2,e2),...,(qm,em)]
// think about it as adding two polynomials
// by merging the coefficients of same terms.
// the final result should also be sorted and each term
// in the list should be unique.
static coefficient_term_list_t 
imp_merge_coefficient_term_list(int less_eq(term_t,term_t),
		    coefficient_term_list_t termlist1,
		    coefficient_term_list_t termlist2){
  coefficient_term_list_t res_tail = NULL;
  coefficient_term_list_t res = NULL;
  if (termlist1 == NULL) return termlist2;
  if (termlist2 == NULL) return termlist1;
  let cmp_result = less_eq(termlist1->hd->f1,termlist2->hd->f1);
  while ((termlist1 != NULL) && (termlist2!= NULL)){
    let cmp_result = less_eq(termlist1->hd->f1,termlist2->hd->f1);
    if (cmp_result < 0){ // termlist1< termlist2
      if (res_tail== NULL){
	res_tail= termlist1;
	termlist1= termlist1->tl;
	res = res_tail;
      }else{
	res_tail->tl = termlist1;
	res_tail= termlist1;
	termlist1= termlist1->tl;
      }
    } else if (cmp_result > 0) { // termlist2< termlist1
      if (res_tail== NULL){
	res_tail= termlist2;
	termlist2= termlist2->tl;
	res = res_tail;
      } else {
	res_tail->tl = termlist2;
	res_tail= termlist2;
	termlist2= termlist2->tl;
      }
    } else { // cmp_result == 0, termlist1== termlist2
      // merge two values;
      let i = termlist1->hd->f0 + termlist2->hd->f0;
      if (i != 0){
	termlist1->hd->f0 = i;
	if (res_tail== NULL){
	  res_tail= termlist1;
	  res = res_tail;
	} else {
	  res_tail->tl = termlist1;
	  res_tail= termlist1;
	}
      }
      termlist1= termlist1->tl;
      termlist2= termlist2->tl;
    }
  }
  if (res_tail== NULL) {
    res_tail= (termlist1== NULL)? termlist2: termlist1;
    res = res_tail;
  } else {
    res_tail->tl = (termlist1==NULL)? termlist2: termlist1;
  }
  return res;
}

// given a primop p, return an unsigned int u such that
// for all term t, t p Uint(u) == Uint(u) p t == t,
// i.e., Uint(u) is the identity in the commutative group.
inline static unsigned id_of_primop(Absyn::primop_t p){
  switch(p) {
  case Absyn::Plus:   return 0;
  case Absyn::Times:  return 1;
  case Absyn::Bitand: return 0xFFFFFFFF;
  case Absyn::Bitor:  return 0;
  case Absyn::Bitxor: return 0;
  default: Warn::impos("no id for primop %s",Absynpp::prim2string(p));
  }
}


// given a list t1, t2, t3, t4,... and a primop p
// return a term ((((t1 p t2) p t3) p t4)...)
static term_t termlist2term(list_t<term_t> termlist, int newc, Absyn::primop_t p, type_opt_t tp){
  let id = id_of_primop(p);
  if (termlist == NULL) return uint(newc);
  term_t t = termlist->hd;
  termlist = termlist->tl;
  while(termlist != NULL){
    let newterm = Binop(p,t, termlist->hd, tp);
    t = hash_cons_term(&newterm);
    termlist = termlist->tl;
  }
  if (id == newc) return t;
  else {
//     // term is of the form t * c
//     if (p == Absyn::Times){
//       switch(t){
// 	// term is of the form (t1 + ... + tn) * newc, distribute the newc
//       case &Binop(Absyn::Plus,_,_,_):
// 	let $(t_list,c) = flatten_plus(t);
// 	let newt_list = map_c(times_newc,newc,t_list);
// 	return termcoeflist2term(newt_list,c*newc,topt);
// 	break;
//       default: break;
//       }
//     }
    let newterm = Binop(p,t,uint(newc),tp);
    return hash_cons_term(&newterm);
  }
}

// given a term t and its coefficient c, returns a 
// new term c*t
static term_t compute_factor(type_opt_t tp, $(int, term_t) @coefficient_term){
  let &$(c,t) = coefficient_term;
  if (c == 1) return t;
  else {
    let newfactor = Binop(Absyn::Times,t,uint(c),tp);
    return hash_cons_term(&newfactor);
  }
}

static int inv_termcmp(term_t t1, term_t t2){
  return -termcmp(t1, t2);
}

// try to normalize a term t1 + t2
// first generate coefficient term list from t1, and t2,
// t1 = a1 * t11 + a2 * t12 + ...
// t2 = b1 * t21 + b2 * t22 + ...
// merge the two lists by combining coefficients for the same term
// and return a new normalized term of the form
// c1 * t31 + c2 * t32 + ...
static term_t normalize_plus(term_t t1, term_t t2, type_opt_t tp){
  let $(coefficient_term_list1,i1) = get_coefficient_term_list(t1);
  let $(coefficient_term_list2,i2) = get_coefficient_term_list(t2);
  let coefficient_term_list = 
    imp_merge_coefficient_term_list(inv_termcmp,
				    coefficient_term_list1, 
				    coefficient_term_list2);
  
  let term_list = map_c(compute_factor,tp,coefficient_term_list);
  let res = termlist2term(term_list,i1+i2,Absyn::Plus,tp);
  return res;
}


// given a term of the form t1 p t2 p t3 ... tn p c
// where p is a commutative and associative primop,
// return the ordered list [t1,t2,...,tn] and c
// so that we can merge two terms
static $(list_t<term_t,`H>, int)  term2termlist(Absyn::primop_t p, term_t t){
  list_t<term_t,`H> termlist = NULL;
  int res = id_of_primop(p);
 LOOP:
  switch (t){
  case &Uint(i,_): res = i; break;
  case &Binop(p1,t1,&Uint(i,_),_) && p1 == p: 
    res = i;
    t = t1;
    goto LOOP;
  case &Binop(p1, t1, t2,_)&& p1 == p:
    termlist = new List(t2, termlist);
    t = t1;
    goto LOOP;
  default:
    termlist = new List(t, termlist);
    break;
  }
  return $(termlist,res);
}

//evaluating commutative associative bin op on constants.
inline static unsigned eval_binop(Absyn::primop_t p, unsigned i, unsigned j){
  switch(p){
  case Absyn::Plus: return (i+j);
  case Absyn::Times: return (i*j);
  case Absyn::Bitand: return (i & j);
  case Absyn::Bitor: return (i | j);
  case Absyn::Bitxor: return (i ^ j);
  default: Warn::impos("Error in evaluating binop");
  }
}


static term_t normalize_assoc_commu(Absyn::primop_t p, term_t t1, term_t t2,type_opt_t tp){
  let $(term_list1,c1) = term2termlist(p,t1);
  let $(term_list2,c2) = term2termlist(p,t2);
  let term_list = List::imp_merge(inv_termcmp,term_list1,term_list2);
  let c = eval_binop(p,c1,c2);
  return termlist2term(term_list,c,p,tp);
}

inline static bool is_nonassociative_commutative(Absyn::primop_t p,type_opt_t tp) {
  switch (p) {
  case Absyn::Plus: 
  case Absyn::Times:
    if (tp != NULL) {
      switch (Absyn::compress(tp)) {
      case &Absyn::AppType(&Absyn::FloatCon(_),...): return true;
      default: return false;
      }
    }
    return false;
  case Absyn::Eq:
  case Absyn::Neq: return true;
  default: return false;
  }
}

inline static bool is_associative_commutative(Absyn::primop_t p,type_opt_t tp) {
  switch (p) {
  case Absyn::Plus:
  case Absyn::Times:
    if (tp != NULL) {
      switch (Absyn::compress((type_t)tp)) {
        // integer type
      case &Absyn::AppType(&Absyn::IntCon(...),...):return true;
      default: return false;
      }
    }
    return false;
  case Absyn::Bitand:
  case Absyn::Bitor:
  case Absyn::Bitxor: return true;
  default: return false;
  }
}


term_t binop(Absyn::primop_t p, term_t t1, term_t t2, type_opt_t tp) {
  switch $(p,t1,t2) {
  case $(_,&Uint(i,_),&Uint(j,_)):
    // constant folding
    switch (p) {
    case Absyn::Plus: return uint(i+j);
    case Absyn::Minus: return uint(i-j);
    case Absyn::Bitand: return uint(i & j);
    case Absyn::Bitor: return uint(i | j);
    case Absyn::Bitxor: return uint(i ^ j);
    case Absyn::Bitlshift: return uint(i << j);
    case Absyn::Bitlrshift: return uint(i >> j);
    case Absyn::Div: if (j != 0) return uint((int)i / (int)j); break;
    case Absyn::UDiv: if (j != 0) return uint(i / j); break;
    case Absyn::Mod: if (j != 0) return uint((int)i % (int)j); break;
    case Absyn::UMod: if (j != 0) return uint(i % j); break;
    case Absyn::Times: return uint(i * j);
    default: break;
    }
    break;
  case $(Absyn::Minus,t1,t2):
    switch (tp) {
    case &Absyn::AppType(&Absyn::IntCon(...),...):
      // t1 - t1 == 0
      if (termcmp(t1,t2) == 0) return uint(0);
      // t1 - t2 == t1 + (-1) * t2
      t2 = binop(Absyn::Times,t2,uint(-1),tp);
      return binop(Absyn::Plus,t1,t2,tp);
    default: break;
    }
    break;
  default:
    // trying to normalize for commutative and associative operator p
    // into the form ((t1 p t2) p t3) ... p tn) where
    // t1 <= t2 <= t3 <= ... <= tn
    if (is_associative_commutative(p,tp)){
      // given two terms of the form a0 + a1*t1 + a2*t2 + ...
      // and b0 + b1 * s1 + b2 * s2 + ...
      // trying to normalize the sum by merging the coefficient
      // of the same terms
      if (p == Absyn::Plus) return normalize_plus(t1,t2,tp);
      else return normalize_assoc_commu(p,t1,t2,tp);
    }
    if (is_nonassociative_commutative(p,tp)) {
      if (termcmp(t1,t2) > 0) {
	let tmpt = t1;
	t1 = t2;
	t2 = tmpt;
      }
    } else if (p == Absyn::Plus) { // must be pointer arithmetic -- special case
      switch $(t1,t2) {
      case $(&Binop(Absyn::Plus,t1,&Uint(i,_),tp2),&Uint(j,_)):
        if (tp != NULL && tp2 != NULL && Unify::unify((type_t)tp,(type_t)tp2))
          return plus(t1,uint(i+j),tp);
        break;
      default: break;
      }
    }
    break;
  }
  let p = Binop(p,t1,t2,tp);
  return hash_cons_term(&p);
}

type_opt_t get_term_type(term_t t) {
 LOOP:
  switch (t) {
  case &Uint(_,tp): return tp;
  case &Const(e): return e->topt;
  case &LogicVar(_,_,topt): return topt;
  case &Binop(_,_,_,tp): return tp;
  case &Unop(_,_,tp): return tp;
  case &Cast(tp,_): return tp;
  case &Select(_,_,tp): return tp;
  case &Aggr(_,_,_,tp): return tp;
  case &Proj(t1,i,tp): return tp;
  case &AggrUpdate(t1,_,_): t = t1; goto LOOP;
  case &Addr(vd,_,tp): return tp;
  case &Update(...): return NULL;
  case &Alloc(_,_,_,_,tp): return tp;
  case &Offsetf(_,_,tp): return tp;
  case &Offseti(_,_,tp): return tp;
  case &Tagof(_): return Absyn::uint_type;
  }
}

static term_t subst_term(term_dict_t dict, term_t t,
			 Hashtable::table_t<term_t,term_t> term_h){
  let t1 = Hashtable::lookup_opt(term_h,t);
  if (t1 != NULL) {
#ifdef AssnDefDebug
    fprintf(stderr,"%s was substituted, the result was \n%s\n",
	    term2string(t),term2string(*t1));
#endif
    return *t1;
  }
  term_t res;
  switch (t){
  case &Uint(...):
  case &Const(...): 
    res = t; break;
  case &Addr(vd,t1,tp): 
    let s1 = subst_term(dict,t1,term_h);
    let addr_term = Addr(vd,s1,tp);
    res = hash_cons_term(&addr_term);
    break;
  case &Alloc(e1,i,t1,t2,tp): 
    let s1 = subst_term(dict,t1,term_h);
    let s2 = subst_term(dict,t2,term_h);
    let alloc_term = Alloc(e1,i,s1,s2,tp);
    res = hash_cons_term(&alloc_term);
    break;
  case &Select(t1,t2,tp):
    let s1 = subst_term(dict,t1,term_h);
    let s2 = subst_term(dict,t2,term_h);
    res = select(s1,s2,tp);
    break;
  case &Update(t1,t2,t3):
    let s1 = subst_term(dict,t1,term_h);
    let s2 = subst_term(dict,t2,term_h);
    let s3 = subst_term(dict,t3,term_h);
    res = update(s1,s2,s3);
    break;
  case &LogicVar(...):
    let t1 = Dict::lookup_opt(dict,t);
    if (t1 != NULL) res = *t1;
    else res = t;
    break;
  case &Unop(p,t1,tp):
    let s1 = subst_term(dict,t1,term_h);
    res = unop(p,s1,tp);
    break;
  case &Binop(p,t1,t2,tp):
    let s1 = subst_term(dict,t1,term_h);
    let s2 = subst_term(dict,t2,term_h);
    res = binop(p,s1,s2,tp);
    break;
  case &Cast(tp,t1):
    let s1 = subst_term(dict,t1,term_h);
    res = cast(tp,s1);
    break;
  case &Aggr(b,tag,tlist,tp):
    let slist = NULL;
    for(;tlist != NULL; tlist = tlist->tl){
      slist = new List(subst_term(dict,tlist->hd,term_h),slist);
    }
    List::imp_rev(slist);
    res = aggr(b,tag,slist,tp);
    break;
  case &Proj(t1,i,tp):
    let s1 = subst_term(dict,t1,term_h);
    res = proj(s1,i,tp);
    break;
  case &AggrUpdate(t1,i,t2):
    let s1 = subst_term(dict,t1,term_h);
    let s2 = subst_term(dict,t2,term_h);
    res = aggr_update(s1,i,s2);
    break;
  case &Offsetf(t1,i,tp):
    let s1 = subst_term(dict,t1,term_h);
    res = offsetf(s1,i,tp);
    break;
  case &Offseti(t1,t2,tp):
    let s1 = subst_term(dict,t1,term_h);
    let s2 = subst_term(dict,t2,term_h);
    res = offseti(s1,s2,tp);
    break;
  case &Tagof(t1):
    res = tagof_tm(subst_term(dict,t1,term_h));
    break;
  }
  Hashtable::insert(term_h,t,res);
  return res;
}

static int hash_ptr(`a s) { return (int) s;}


term_t subst_t(term_dict_t dict,term_t t) {
  Hashtable::table_t<term_t,term_t> term_h = Hashtable::create(137,Core::ptrcmp,hash_ptr);
  return subst_term(dict,t,term_h);
}
/////// assertion manipulation /////////////


static $(string_t,unsigned) a2dag(assn_t a, int @ctr, 
                                  Hashtable::table_t<assn_t,$(const char ?`H,unsigned)@`H> t,
                                  list_t<const char ?`H@`H,`H> @decls)
{
  $(const char ?`H,unsigned)@`H* resopt = Hashtable::lookup_opt(t,a);
  if (resopt != NULL) {
    return **resopt;
  }
  let c = *ctr;
  *ctr = c + 1;
  const char ?name = aprintf("A%d",c);
  const char ?s;
  unsigned size = 1;
  switch (a) {
  case &True: s = "true"; break;
  case &False: s = "false"; break;
  case &Prim(t1,p,t2):
    const char ?ps;
    switch (p) {
    case Eq: ps = "=="; break;
    case Neq: ps = "!="; break;
    case SLt: ps = " S< "; break;
    case SLte: ps = " S<= "; break;
    case ULt: ps = " U< "; break;
    case ULte: ps = " U<= "; break;
    default: Warn::impos("assn2string primop");
    }
    s = aprintf("%s%s%s",term2string(t1),ps,term2string(t2));
    break;
  case &Or(a1,a2):
    let $(s1,n1) = a2dag(a1,ctr,t,decls);
    let $(s2,n2) = a2dag(a2,ctr,t,decls);
    s = aprintf("%s || %s",s1,s2);
    size += (n1 + n2);
    break;
  case &And(a1,a2): 
    let $(s1,n1) = a2dag(a1,ctr,t,decls);
    let $(s2,n2) = a2dag(a2,ctr,t,decls);
    s = aprintf("%s && %s",s1,s2);
    size += (n1 + n2);
    break;
  }
  *decls = new List{new (const char ?)(aprintf("%s = %s\n",name,s)), *decls};
  Hashtable::insert(t,a,new $(name,size));
  return $(name,size);
}

int assnhash(datatype Assn @a);

string_t assn2dag(assn_t a) {
  list_t<const char ?`H@`H> decls = NULL;
  Hashtable::table_t<assn_t,$(const char ?`H,unsigned)@`H> t = 
    Hashtable::create(221, assncmp, assnhash);
  int ctr = 0;
  let $(s,n) = a2dag(a,&ctr,t,&decls);
  decls = List::imp_rev(new List{new (const char ?)(aprintf("in %s (%d nodes as tree)\n",s,n)),decls});
  return strconcat_l(decls);
}

  
// calculate a string representation (and total tree node count) for an
// assertion.  the prec field (precedent) is used to avoid some parens.
static string_t a2string(datatype Assn @a, int inprec) {
  int myprec = 10;
  string_t s;
  switch (a) {
  case &True: s = "true"; break;
  case &False: s = "false"; break;
  case &Prim(t1,p,t2):
    string_t ps;
    switch (p) {
    case Eq: ps = "=="; break;
    case Neq: ps = "!="; break;
    case SLt: ps = " S< "; break;
    case SLte: ps = " S<= "; break;
    case ULt: ps = " U< "; break;
    case ULte: ps = " U<= "; break;
    default: Warn::impos("assn2string primop");
    }
    s = aprintf("%s%s%s",term2string(t1),ps,term2string(t2));
    break;
  case &Or(a1,a2): 
    myprec = 5;
    s = aprintf("%s || %s",a2string(a1,myprec),a2string(a2,myprec));
    break;
  case &And(a1,a2): 
    myprec = 10;
    s = aprintf("%s && %s",a2string(a1,10),a2string(a2,10));
    break;
  }
  if (myprec < inprec)
    s = aprintf("(%s)",s);
  return s;
}

// Warning -- assertions are huge!  Use assn2dag instead...
string_t assn2string(datatype Assn @a){
  return a2string(a,10);
}

//////////////////////////////////////////////////////////////
// hash-consing to try to preserve as much sharing as we
// can -- has a nice impact on performance (much better than
// lazy substitution), but alas, we still end up allocating a lot.  
// It would be better if we didn't have to allocate the thing 
// that want to lookup.  That could happen if we had a different 
// type for hashtable lookup (as we did with dictionaries.)

int assnhash(datatype Assn @a) {
  switch (a) {
  case &False: return 0;
  case &True: return 1;
  case &Prim(t1,p,t2): 
    return termhash(t1) + p + termhash(t2);
  case &And(a1,a2): 
    return (((unsigned int)a1 + (unsigned int)a2) >> 4) + 3;
  case &Or(a1,a2): 
    return (((unsigned int)a2 + (unsigned int)a1) >> 4) + 5;    
  }
}

// compare two assertions for structural equality -- does not assume
// the components have been hash-consed, but probably could.
int assncmp(datatype Assn @`r1 _a1, datatype Assn @`r2 _a2) {
  datatype Assn @`r1+`H a1 = _a1;
  datatype Assn @`r2+`H a2 = _a2;
 LOOP:
  if (a1 == a2) return 0;
  int c = tagof(a2) - tagof(a1);
  if (c != 0) return c;
  switch $(a1,a2) {
  case $(&And(a11,a12),&And(a21,a22)): fallthru(a11,a12,a21,a22);
  case $(&Or(a11,a12),&Or(a21,a22)): 
    int c = assncmp(a11,a21);
    if (c != 0) return c;
    a1 = a12;
    a2 = a22;
    goto LOOP;
  case $(&Prim(t11,p1,t12),&Prim(t21,p2,t22)):
    int c = (int)p1 - (int)p2;
    if (c != 0) return c;
    c = termcmp(t11,t21);
    if (c != 0) return c;
    return termcmp(t12,t22);
  default: Warn::impos("assncmp:  tagof failure");
  }
}

// shallow copy of an assertion from region `r to the heap and 
// simultaneously determine whether or not the assertion is
// reduced so that we can put the information in the table.
static assn_t copy_assn(datatype Assn@`r a){
  switch (a) {
  case &True: 
    Warn::impos("True assertion should be in the table");
  case &False: 
    Warn::impos("False assertion should be in the table");
  case &And(a1,a2): return new And(a1,a2);
  case &Or(a1,a2): return new Or(a1,a2);
  case &Prim(t1,p,t2): return new Prim(t1,p,t2);
  }
}


// assertion constants for true and false
datatype Assn.True true_assn = True;
datatype Assn.False false_assn = False;

// computes the negation of an assertion a
// and allocate it in the heap
// it is called by hasn_cons_assn, so that
// every assertion in the hashtable has
// its negation in the table as well
static assn_t neg_assn(datatype Assn@ a){
  switch (a) {
  case &True: return &false_assn;
  case &False: return &true_assn;
  case &And(a1,a2): return new Or(not(a1),not(a2));
  case &Or(a1,a2): return new And(not(a1),not(a2));
  case &Prim(t1,p,t2): 
    switch (p){
    case Eq: return new Prim(t1,Neq,t2);
    case Neq: return new Prim(t1,Eq,t2);
    case SLt: return new Prim(t2,SLte,t1);
    case SLte: return new Prim(t2,SLt,t1);
    case ULt: return new Prim(t2,ULte,t1);
    case ULte: return new Prim(t2,ULt,t1);
    default: Warn::impos("undefined prim relation");
    }
  }
}

// the assn_hash_table stores the assertion, its negation, and the widened_set
// the invariant for the assn_hash_table is that each assertion
// a and not a are added to the table at the same time.
// i.e., if a is not in the table, neither is not a.
typedef struct AssnHashedInfo {
  assn_t assn;
  assn_t negation;
  assn_set_opt_t *widened_set;
  term_set_t *free_logicvar_set;
} @assn_hashed_info_t;

static struct Hashtable::Table<assn_t, assn_hashed_info_t> *assn_hash_cons_table;

static Hashtable::table_t<assn_t,assn_hashed_info_t> 
get_assn_hash_cons_table(){
  Hashtable::table_t<assn_t,assn_hashed_info_t> h;
  if (assn_hash_cons_table == NULL) {
    h = Hashtable::create(221, assncmp, assnhash);
    assn_hash_cons_table = h;
    assn_set_opt_t ast = Set::empty(assncmp);
    term_set_t tst = empty_term_set();
    Hashtable::insert(h,&true_assn,new AssnHashedInfo{&true_assn,&false_assn,new ast,new tst});
    Hashtable::insert(h,&false_assn,new AssnHashedInfo{&false_assn,&true_assn,new NULL,new tst});
  } else {
    h = (Hashtable::table_t)assn_hash_cons_table;
  }
  return h;
}
static assn_t hash_cons_assn(datatype Assn @a) {
  let h = get_assn_hash_cons_table();
  let resopt = Hashtable::lookup_other_opt(h,a,assncmp,assnhash);
  if (resopt == NULL) {
    // given the invariant, if a was not in the table,
    // neither was nega in the table.
    let a2 = copy_assn(a);
    let nega2 = neg_assn(a);
    //int i = h->max_len;
    Hashtable::insert(h,a2,new AssnHashedInfo{a2,nega2,NULL,NULL});
    Hashtable::insert(h,nega2,new AssnHashedInfo{nega2,a2,NULL,NULL});
    //if (i < h->max_len)
    //  fprintf(stderr,"grew hash table on %s\n",assn2string(a2));
    return a2;
  } else 
    return (*resopt)->assn;
}

assn_t and(assn_t a1, assn_t a2){
  if (a1 == a2) return a1;
  switch $(a1,a2) {
  case $(&True,_): return a2;
  case $(_,&True): return a1;
  case $(&False,_): return a1;
  case $(_,&False): return a2;
  default: 
    // NB: used to sort the operands based on physical address, but
    // to keep things more deterministic, I'm not sorting now.
    let a = And(a1,a2);
    return hash_cons_assn(&a);
  }  
}

assn_t or(assn_t a1, assn_t a2){
  if (a1 == a2) return a1;
  //if (a1 == not(a2)) return &true_assn;
  switch $(a1,a2) {
  case $(&True,_): return a1;
  case $(_,&True): return a2;
  case $(&False,_): return a2;
  case $(_,&False): return a1;
  default: 
    // NB: used to sort the operands based on physical address, but
    // to keep things more deterministic, I'm not sorting now.
    let a = Or(a1,a2);
    return hash_cons_assn(&a);
  }
}

// some assertions that was created as part of 
// function signatures get nuked out before
// entering a new function definition analysis
// we need to enter the assertion (as well as
// its sub assertions) into the hash table again
// the reason we need to do this is while inserting
// an assertion to the table, we are computing
// the negation for the assertion at the same time
// and stored in the hash table as well.
static assn_t reinsert(assn_t a) {
  let h = get_assn_hash_cons_table();
  switch (a) {
  case &True:
  case &False: return a;
  case &And(a1,a2): 
    if (Hashtable::lookup_opt(h,a1) == NULL)
      a1 = reinsert(a1);
    if (Hashtable::lookup_opt(h,a2) == NULL)
      a2 = reinsert(a2);
    let a = And(a1,a2);
    return hash_cons_assn(&a);
  case &Or(a1,a2):
    if (Hashtable::lookup_opt(h,a1) == NULL)
      a1 = reinsert(a1);
    if (Hashtable::lookup_opt(h,a2) == NULL)
      a2 = reinsert(a2);
    let a = Or(a1,a2);
    return hash_cons_assn(&a);
  case &Prim(...):
    return hash_cons_assn(a);
  }
}

// returns the set of logicvars that are free in
// an assertion a
term_set_t assn_fr_logicvar(assn_t a) {
  let h = get_assn_hash_cons_table();
  let ahinfo = Hashtable::lookup_opt(h,a);
  if (ahinfo == NULL) {
    a = reinsert(a);
    ahinfo = Hashtable::lookup_opt(h,a);
  }
  if ((*ahinfo)->free_logicvar_set != NULL)
    return *(*ahinfo)->free_logicvar_set;
  term_set_t res; 
  switch (a) {
  case &True:
  case &False:
    res = empty_term_set();
    break;
  case &And(a1,a2):
    fallthru(a1,a2);
  case &Or(a1,a2):
    res = Set::union_two(assn_fr_logicvar(a1),assn_fr_logicvar(a2));
    break;
  case &Prim(t1,_,t2):
    res = Set::union_two(term_fr_logicvar(t1),term_fr_logicvar(t2));
    break;
  }
  (*ahinfo)->free_logicvar_set = new res;
  return res;
}

// returns true if an logicvar lvar is free in a
static bool logicvar_in_assn(term_t lvar, assn_t a) {
  let lvset = assn_fr_logicvar(a);
  return Set::member(lvset,lvar);
}

// since a was already in the assn hashtable, (not a) must
// be there too. 
assn_t not(assn_t a){
  let h = get_assn_hash_cons_table();
  assn_hashed_info_t *ahinfo = Hashtable::lookup_opt(h,a);
  if (ahinfo == NULL) {
    a = reinsert(a);
    ahinfo = Hashtable::lookup_opt(h,a);
  }
  return (*ahinfo)->negation;
}

assn_t prim(term_t t1, prim_reln_t p, term_t t2){
  let ptr = Prim(t1,p,t2);
  return hash_cons_assn(&ptr);
}

assn_t eq(term_t t1, term_t t2){
  if (t1 == t2) return &true_assn;
  if (term_neq(t1,t2)) return &false_assn;
  if (termcmp(t1,t2)>0) {
    t1 :=: t2;
  }
  return prim(t1,Eq,t2);
}

assn_t slt(term_t t1, term_t t2) {
  if (t1 == t2) return &false_assn;
  switch $(t1,t2) {
  case $(&Uint(i,_),&Uint(j,_)): 
    if ((int)i < (int)j) return &true_assn; else return &false_assn;
  default: return prim(t1,SLt,t2);
  }
}

assn_t slte(term_t t1, term_t t2) {
  if (t1 == t2) return &true_assn;
  switch $(t1,t2) {
  case $(&Uint(i,_),&Uint(j,_)): 
    if ((int)i <= (int)j) return &true_assn; else return &false_assn;
  default: return prim(t1,SLte,t2);
  }
}

assn_t ult(term_t t1, term_t t2) {
  if (t1 == t2) return &false_assn;
  switch $(t1,t2) {
  case $(&Uint(i,_),&Uint(j,_)): 
    if (i < j) return &true_assn; else return &false_assn;
  default: return prim(t1,ULt,t2);
  }
}

assn_t ulte(term_t t1, term_t t2) {
  if (t1 == t2) return &true_assn;
  switch $(t1,t2) {
  case $(&Uint(i,_),&Uint(j,_)): 
    if (i <= j) return &true_assn; else return &false_assn;
  default: return prim(t1,ULte,t2);
  }
}

assn_t neq(term_t t1, term_t t2){
  if (t1 == t2) return &false_assn;
  if (term_neq(t1,t2)) return &true_assn;
  switch $(t1,t2) {
  case $(&Uint(i,_),_) && i == 0:
    return ult(zero(),t2);
  case $(_,&Uint(j,_)) && j == 0:
    return ult(zero(),t1);
  default:
    if (termcmp(t1,t2)>0) {
      t1 :=: t2;
    }
    return prim(t1,Neq,t2);
  }
}

assn_set_opt_t widen_it(assn_t a){
  let h = get_assn_hash_cons_table();
  let ahinfo = Hashtable::lookup_opt(h,a);
  if (ahinfo == NULL) {
    a = reinsert(a);
    ahinfo = Hashtable::lookup_opt(h,a);
  }
  if ((*ahinfo)->widened_set != NULL) return *(*ahinfo)->widened_set;
  assn_set_opt_t s;
  switch (a){
  case &True:
  case &False:
    Warn::impos("true and false should have widened_set");
  case &And(a1,a2):
    let s1 = widen_it(a1);
    let s2 = widen_it(a2);
    if (s1 == NULL || s2 == NULL) 
      s = NULL; 
    else 
      s = Set::union_two((assn_set_t)s1,(assn_set_t)s2);
    break;
  case &Or(a1,a2):
    let s1 = widen_it(a1);
    let s2 = widen_it(a2);
    if (s1 == NULL) 
      s = s2;
    else if (s2 == NULL)
      s = s1;
    else
      s = Set::intersect((assn_set_t)s1,(assn_set_t)s2);
    break;
  case &Prim(t1,p,t2):
    s = Set::singleton(assncmp,a);
    switch (p) {
   case Eq:
      // when we have t1 == t2 and they are of integral type, then we
      // also want to remember that t1 <= t2 and t2 <= t1 so that when
      // we intersect, we don't lose the information.
      let topt1 = get_term_type(t1);
      let topt2 = get_term_type(t2);
      if ((topt1 != NULL && Tcutil::is_integral_type((type_t)topt1)) ||
          (topt2 != NULL && Tcutil::is_integral_type((type_t)topt2))) {
        s = Set::insert(s,slte(t1,t2));
        s = Set::insert(s,slte(t2,t1));
        s = Set::insert(s,ulte(t1,t2));
        s = Set::insert(s,ulte(t2,t1));
      }
      break;
    case SLt:
      s = Set::insert(s,slte(t1,t2));
      break;
    case ULt:
      s = Set::insert(s,ulte(t1,t2));
      break;
    default: break;
    }
    break;
  }
  (*ahinfo)->widened_set = new s;
  return s;
}

// factors out all of the common primitive relations in a.
assn_t widen(assn_t a) {
  // force the hash-cons table to be around just to be safe
  let sopt = widen_it(a);
  if (sopt == NULL) return &false_assn;
  let res = Set::fold(and,(assn_set_t)sopt,&true_assn);
  return res;
}

static assn_t subst_assn(term_dict_t dict, assn_t a, 
			 Hashtable::table_t<assn_t,assn_t> assn_h,
			 Hashtable::table_t<term_t,term_t> term_h){
  let a1 = Hashtable::lookup_opt(assn_h,a);
  if (a1 != NULL) {
#ifdef AssnDefDebug
    fprintf(stderr, "%s was substituted before, and the result is \n%s\n",
	    assn2string(a),assn2string(*a1));
#endif
    return *a1;
  }
  assn_t res;
  switch (a) {
  case &True:
  case &False: res = a; break;
  case &Prim(t1,p,t2):
    let s1 = subst_term(dict,t1,term_h);
    let s2 = subst_term(dict,t2,term_h);
    res = prim(s1,p,s2);
    break;
  case &And(a1,a2):
    let b1 = subst_assn(dict,a1,assn_h,term_h);
    let b2 = subst_assn(dict,a2,assn_h,term_h);
    res = and(b1,b2);
    break;
  case &Or(a1,a2):
    let b1 = subst_assn(dict,a1,assn_h,term_h);
    let b2 = subst_assn(dict,a2,assn_h,term_h);
    res = or(b1,b2);
    break;
  }
  Hashtable::insert(assn_h,a,res);
  return res;
} 

assn_t subst_a(term_dict_t dict, assn_t a){
  // create new hashtables to record the substituted result
  // with respect to this particular dict. 
  Hashtable::table_t<assn_t,assn_t> assn_h = Hashtable::create(107,Core::ptrcmp,hash_ptr);
  Hashtable::table_t<term_t,term_t> term_h = Hashtable::create(137,Core::ptrcmp,hash_ptr);
  return subst_assn(dict,a,assn_h,term_h);
}
#ifdef AssnDefDebug
static void fprint_assn(assn_t a) {
  fprintf(stderr,"%s[%d]\n",assn2string(a),(int)a);
}

static void fprint_assncmp(assn_t a1, assn_t a2) {
  if (assncmp(a1,a2) == 0) fprintf(stderr, "%s EQ %s\n",
				   assn2string(a1),
				   assn2string(a2));
}
#endif
// tries to see if a can be proved from the set of primitive
// relations in ctxt.
static bool simple_prv(assn_set_t ctxt, assn_t a) {
  while (true) {
    switch (a) {
    case &Prim(t1,p,t2): 
      if (Set::member(ctxt,a)) return true;
#ifdef AssnDefDebug
      fprintf(stderr,"simple_prv prim: failed\n");
      Set::iter(fprint_assn,ctxt);
      Set::iter_c(fprint_assncmp,a,ctxt);
      fprintf(stderr,"simple_prv prim: %s[%d] NOT OK\n",assn2string(a),(int)a);
#endif
      switch (p) {
      case Neq: 
        return (Set::member(ctxt,ult(t2,t1)) ||
                Set::member(ctxt,ult(t1,t2)) ||
                Set::member(ctxt,slt(t2,t1)) ||
                Set::member(ctxt,slt(t1,t2)));
      case SLte: 
        return (Set::member(ctxt,slt(t1,t2)) || 
                Set::member(ctxt,eq(t1,t2)));
      case ULte: 
        return (Set::member(ctxt,ult(t1,t2)) || 
                Set::member(ctxt,eq(t1,t2)));
      default: return false;
      }
    case &True: return true;
    case &False: return false;
    case &And(a1,a2): 
      if (!simple_prv(ctxt,a1)) {
	return false;
      }
#ifdef AssnDefDebug
      fprintf(stderr,"simple_prv: and a1 OK\n");
#endif
      a = a2; 
      continue;
    case &Or(a1,a2): 
      if (simple_prv(ctxt,a1)) return true;
      a = a2;
      continue;
    }
  }
}


// returns true when ctxt |- a
// uses only very local, syntactic matching.
bool simple_prove(assn_t ctxt, assn_t a) {
  if (ctxt == a) return true; 
  let sopt = widen_it(ctxt);
  if (sopt == NULL) return true;
  return simple_prv((assn_set_t)sopt, a);
}

term_set_t assnfn_fr_logicvar(assnfn_t af) {
  let fvs = assn_fr_logicvar(af->assn);
  for(let as = af->actuals; as != NULL; as = as->tl)
    fvs = Set::delete(fvs,as->hd);
  return fvs;
}

static string_t assnfn2string(assnfn_t af) {
  if (af->actuals == NULL) return assn2string(af->assn);
  return aprintf("/\\ %s .\n%s",term2string(af->actuals->hd),assnfn2string(new AssnFn{af->actuals->tl,af->assn}));
}
string_t existassnfn2string(existassnfn_t eaf) {
  return assnfn2string(eaf->af);
}
// turn an assnmap into an existassnfn,
// where bound logicvars are the value of
// vds.
existassnfn_t assnmap2existassnfn(assn_map_t am, list_t<vardecl_opt_t> vds) {
  let actuals = NULL;
  for( ; vds != NULL; vds = vds->tl) {
    if (vds->hd != NULL) {
      let $(v,_) = lookup_var_map((vardecl_t)vds->hd,am);
      switch (v) {
      case &LogicVar(...): break;
      default: Warn::impos("term to be bound is not a logic var");
      };
      actuals = new List {v,actuals};
    } else {
      actuals = new List {fresh_var(vds->hd == NULL ? NULL:vds->hd->type),actuals};
    }
  }
  actuals = imp_rev(actuals);
  // bound all the lambda variables
  let af = new AssnFn{actuals,am.assn};
  // bound all the existential variables
  let fvs = assnfn_fr_logicvar(af);
  return new ExistAssnFn{af,fvs};
}

// if the terms are not of the form logicvars,
// we need to add assertions vi==ti and
// then do bound the vs in assn and extract
// all other free logicvars as exists
existassnfn_t bound_ts_in_assn(assn_t a,list_t<term_t,`H> ts) {
  // collecting vs
  list_t<term_t,`H> vs = NULL;
  for(; ts != NULL; ts = ts->tl) {
    switch (ts->hd) {
    case &LogicVar(...): 
      // must ensure that the logicvar is not already
      // used as an argument earlier
      bool occured = false;
      for(let xs = vs; xs != NULL; xs = xs->tl) {
	if (termcmp(ts->hd,xs->hd) == 0){
	  occured = true;
	  break;
	}
      }
      if (!occured) vs = new List{ts->hd,vs};
      else {
	let v = fresh_var(get_term_type(ts->hd));
	a = and(a,eq(v,ts->hd));
	vs = new List{v,vs};
      }
      break;
    default:
      let v = fresh_var(get_term_type(ts->hd));
      a = and(a,eq(v,ts->hd));
      vs = new List{v,vs};
      break;
    }
  }
  vs = imp_rev(vs);
  // bound vs in lambda a
  let af = new AssnFn{vs,a};
  // bound the rest of the freevars in exists
  let fvs = assnfn_fr_logicvar(af);
  return new ExistAssnFn{af,fvs};
}

static term_dict_t@`r insertnewmap(term_t t, term_dict_t @`r dict) {
  *dict = Dict::insert(*dict,t,fresh_var(get_term_type(t)));
  return dict;
}

// instantiate existentially bound variables with fresh variables
// and subsitute ts for the formal parameters. 
assn_t existassnfn2assn(existassnfn_t eaf,list_t<term_t> ts) {
  term_dict_t dict = empty_term_dict();
  // pick fresh variables for the existentially bound ones
  dict = *Set::fold(insertnewmap,eaf->existvars,&dict);
  let vs = eaf->af->actuals;
  let a = eaf->af->assn;
  // associate ts with formal arguments
  for (; vs != NULL && ts != NULL; vs = vs->tl, ts = ts->tl) 
    dict = Dict::insert(dict, vs->hd, ts->hd);
  if (vs != NULL || ts != NULL) 
    Warn::impos("wrong number of arguments to existassnfn2assn");
  // apply substitution to assertion -- there's no danger of capture
  // here since a can't have any bound variables.
  return subst_a(dict, a);
}

// functions related to handling the nonescvar_map
static list_t<string_t<`H>@`H, `H> m2string(vardecl_t vd, term_t value, list_t<string_t<`H>@`H, `H> stringlist){
  string_t<`H> res = aprintf("%s == %s", Absynpp::qvar2string(vd->name),term2string(value));
  return new List{new res,stringlist};
}

string_t<`H> map2string(nonescvar_map_t m){
  list_t<string_t<`H>@`H, `H> stringlist = Dict::fold(m2string,m,NULL);
  string_t<`H> s;
  if (stringlist == NULL) return aprintf(" ");
  else s = aprintf("%s",*stringlist->hd);
  while (stringlist->tl != NULL){
    stringlist = stringlist->tl;
    s = aprintf("%s && %s",s,*stringlist->hd);
  }
  return s;
}

// functions related to handling assnmap as one entity
string_t<`H> assnmap2string(assn_map_t am){
  return aprintf("{%s}&&\n%s",map2string(am.map),assn2string(am.assn));
}

string_t assnmap2dag(assn_map_t am) {
  return aprintf("{%s}\n%s",map2string(am.map),assn2dag(am.assn));
}

static nonescvar_map_t empty_map() {
   static nonescvar_map_t *mt = NULL;
   if (mt == NULL) {
     let d = Dict::empty(Core::ptrcmp);
     mt = new d;
     return d;
   } else
     return *mt;
}

assn_map_t false_assnmap(){
  return AssnMap{&false_assn,empty_map()};
}

assn_map_t true_assnmap(){
  return AssnMap{&true_assn,empty_map()};
}

// looking up a vd in the nonescvar_map,
// if the vd was not defined before, create a fresh new var
// and let vd maps to that var.
$(term_t,assn_map_t) lookup_var_map(vardecl_t vd, assn_map_t am){
  term_t *t = Dict::lookup_opt(am.map,vd);
  if (t != NULL) return $(*t,am);
  let newt = fresh_var(vd->type);
  let newm = Dict::insert(am.map,vd,newt);
  return $(newt, AssnMap{am.assn,newm});
}


// update the nonescvar_map to associate vd with a new term newt
assn_map_t update_var_map(vardecl_t vd,term_t newt,assn_map_t am){
  let newm = Dict::insert(am.map,vd,newt);
  return AssnMap{am.assn,newm};
}

// widen the assn part of an assnmap
assn_map_t widen_assnmap(assn_map_t am){
  return AssnMap{widen(am.assn),am.map};
}

// extend the assn part of an assnmap with or(a,_)
assn_map_t or_assnmap_assn(assn_map_t am, assn_t a){
  return AssnMap{or(am.assn,a),am.map};
}

// extend the assn part of an assnmap with and(a,_)
assn_map_t and_assnmap_assn(assn_map_t am, assn_t a){
  return AssnMap{and(am.assn,a),am.map};
}

term_t merge(vardecl_t vd, term_t t1, term_t t2){
  if (t1 == t2) return t1;
  else return fresh_var(vd->type);
}

static term_t subst_term_internal($(Hashtable::table_t<term_t,term_t>, term_dict_t) @env, term_t t) {
  return subst_term(env->f1,t,env->f0);
}

static assn_map_t subst_am(term_dict_t dict, assn_map_t am) {
  // create new hashtables to record the substituted result
  // with respect to this particular dict. 
  Hashtable::table_t<assn_t,assn_t> assn_h = Hashtable::create(107,Core::ptrcmp,hash_ptr);
  Hashtable::table_t<term_t,term_t> term_h = Hashtable::create(137,Core::ptrcmp,hash_ptr);
  let assn = subst_assn(dict,am.assn,assn_h,term_h);
  let map = Dict::map_c(subst_term_internal,new $(term_h,dict),am.map);
  return AssnMap(assn,map);
}
typedef struct Accum{
  assn_t a1;
  assn_t a2;
  nonescvar_map_t m1;
  nonescvar_map_t m2;
  nonescvar_map_t m;
} accum_t;

static bool logicvar_in_map_internal(term_t lvar, vardecl_t dummy, term_t value, bool in_map) {
  return in_map || logicvar_in_term(lvar,value);
}

static bool logicvar_in_map(term_t lv, nonescvar_map_t m) {
  return Dict::fold_c(logicvar_in_map_internal,lv,m,false);
}

// if ta = f(t1,...,tn) and tb = f(u1,...,un) then return
//     f(v1,...,vn) where vi = unify_term(ti,ui)
// if ta and tb do not unify, then pick a fresh variable x and
//    add x==ta to the accumulator's a1, and x==tb to a2, and
//    return x.
// 
static term_t unify_term(accum_t @`r accum, term_t ta, term_t tb) {
  if (ta == tb) return ta;
  switch $(ta,tb) {
  case $(&Unop(pa,ta1,topta),&Unop(pb,tb1,toptb)) && pa == pb:
    let t1 = unify_term(accum,ta1,tb1);
    return unop(pa,t1,topta);
  case $(&Binop(pa,ta1,ta2,topta),&Binop(pb,tb1,tb2,toptb)) && pa == pb:
    let t1 = unify_term(accum,ta1,tb1);
    let t2 = unify_term(accum,ta2,tb2);
    return binop(pa,t1,t2,topta);
  case $(&Cast(atype,ta1),&Cast(btype,tb1)):
    if (!Unify::unify(atype,btype)) break;
    let t1 = unify_term(accum,ta1,tb1);
    return cast(atype,t1);
  case $(&Select(ma,aa,ta),&Select(mb,ab,tb)):
    let m = unify_term(accum,ma,mb);
    let a = unify_term(accum,aa,ab);
    return select(m,a,ta);
  case $(&Update(ma,aa,va),&Update(mb,ab,vb)):
    if (aa == ab) {
      let m = unify_term(accum,ma,mb);
      let v = unify_term(accum,va,vb);
      return update(m,aa,v);
    } else {
      let t1 = update(update(ma,ab,select(ma,ab,get_term_type(vb))),aa,va);
      let t2 = update(update(mb,ab,vb),aa,select(update(mb,ab,vb),aa,get_term_type(va)));
      return unify_term(accum,t1,t2);
    }
    /*
    let m = unify_term(accum,ma,mb);
    let a = unify_term(accum,aa,ab);
    let v = unify_term(accum,va,vb);
    return update(m,a,v);
    */
  case $(&Aggr(aisu, atag, ats, atopt),&Aggr(bisu, btag, bts, btopt)):
    if (aisu != bisu || atag != btag || length(ats) != length(bts)) break;
    let ts = NULL;
    for (; ats != NULL && bts != NULL; ats=ats->tl, bts=bts->tl)
      ts = new List{unify_term(accum,ats->hd,bts->hd),ts};
    return aggr(aisu,atag,imp_rev(ts),atopt);
  case $(&Proj(at,ai,atopt),&Proj(bt,bi,btopt)) && ai == bi:
    let t = unify_term(accum,at,bt);
    return proj(t,ai,atopt);
  case $(&AggrUpdate(at,ai,av),&AggrUpdate(bt,bi,bv)):
    if (ai == bi) {
      let t = unify_term(accum,at,bt);
      let v = unify_term(accum,av,bv);
      return aggr_update(t,ai,v);
    } else {
      let t1 = aggr_update(aggr_update(ta,bi,proj(ta,bi,get_term_type(bv))),ai,av);
      let t2 = aggr_update(aggr_update(tb,bi,bv),ai,proj(aggr_update(tb,bi,bv),ai,get_term_type(av)));
      return unify_term(accum,t1,t2);
    }
  case $(&Addr(ax,ai,atopt),&Addr(bx,bi,btopt)) && (int)ax == (int)bx:
    let i = unify_term(accum,ai,bi);
    return addr(ax,i);
  // FIX: we should make the "id" field of Alloc's a term instead of
  // an int.  In particular, VCGen should have a mapping from alloc
  // fields to a term counter that we increment each time we allocate.
  case $(&Offsetf(at,ai,atopt),&Offsetf(bt,bi,btopt)) && ai == bi:
    let t = unify_term(accum,at,bt);
    return offsetf(t,ai,atopt);
  case $(&Offseti(at,ai,atopt),&Offseti(bt,bi,btopt)):
    let t = unify_term(accum,at,bt);
    let i = unify_term(accum,ai,bi);
    return offseti(t,i,atopt);
  case $(&Tagof(at),&Tagof(bt)):
    let t = unify_term(accum,at,bt);
    return tagof_tm(t);
  default: break;
  }
  type_opt_t topta = get_term_type(ta);
  type_opt_t toptb = get_term_type(tb);
  type_opt_t topt = NULL;
  if (topta != NULL && toptb != NULL && Unify::unify((type_t)topta,
                                                     (type_t)toptb))
    topt = topta;
  let v = fresh_var(topt);
  accum->a1 = and(accum->a1,eq(v,ta));
  accum->a2 = and(accum->a2,eq(v,tb));
  return v;

}

// helper function used when we are folding in am1.map
// for each vd in am1.map, we look it up in am2.map and
// adjust the new map and assertions accordingly
static accum_t @`r foldm1(vardecl_t vd, term_t t, accum_t @`r accum){
  let t2 = Dict::lookup_opt(accum->m2,vd);
  // before merge: M1: x -> t M2: x undefined
  // after merge:  M: x -> v, a1 = and(a1,v==t), a2 unchanged
  if (t2 == NULL) {
    switch (t) {
    case &LogicVar(...): 
      if (!logicvar_in_assn(t,accum->a2) && !logicvar_in_map(t,accum->m2)) {
	accum->m2 = Dict::insert(accum->m2,vd,t);
	accum->m = Dict::insert(accum->m,vd,t);
	return accum;
      }
      break;
    default:
      break;
    }
    let v = fresh_var(vd->type);
    accum->a1 = and(accum->a1,eq(v,t));
    accum->m1 = Dict::insert(accum->m1,vd,v);
    accum->m2 = Dict::insert(accum->m2,vd,v);
    accum->m = Dict::insert(accum->m,vd,v);
    return accum;
  }
  // t2 != NULL
  if (t == *t2){
    // before merge: M1: x -> t, M2: x -> t
    // after merge:  M: x -> t
    accum->m = Dict::insert(accum->m,vd,t);
    return accum;
  }
  // before merge: M1: x -> t, M2: x -> t2
  // after merge: M: x -> v, a1 = and(a1,v==t), a2 = and(a2,v==t2)
  switch $(t,*t2) {
  case $(&LogicVar(...),&LogicVar(...)):
    if (!logicvar_in_assn(t,accum->a2) && !logicvar_in_map(t,accum->m2)){
      // t is logicvar and does not occur in am2
      accum->a2 = and(accum->a2,eq(t,*t2));
      accum->m2 = Dict::insert(accum->m2,vd,t);
      accum->m = Dict::insert(accum->m,vd,t);
      return accum;
    } else if (!logicvar_in_assn(*t2,accum->a1) && !logicvar_in_map(*t2,accum->m1)) {
      // *t2 is logicvar and does not occur in am1
      accum->a1 = and(accum->a1,eq(t,*t2));
      accum->m1 = Dict::insert(accum->m1,vd,*t2);
      accum->m = Dict::insert(accum->m,vd,*t2);
      return accum;
    }
    break;
  case $(&LogicVar(...),_):
    if (!logicvar_in_assn(t,accum->a2) && !logicvar_in_map(t,accum->m2)){
      // t is logicvar and does not occur in am2
      accum->a2 = and(accum->a2,eq(t,*t2));
      accum->m2 = Dict::insert(accum->m2,vd,t);
      accum->m = Dict::insert(accum->m,vd,t);
      return accum;
    }
    break;
  case $(_,&LogicVar(...)):
    if (!logicvar_in_assn(*t2,accum->a1) && !logicvar_in_map(*t2,accum->m1)) {
      // *t2 is logicvar and does not occur in am1
      accum->a1 = and(accum->a1,eq(t,*t2));
      accum->m1 = Dict::insert(accum->m1,vd,*t2);
      accum->m = Dict::insert(accum->m,vd,*t2);
      return accum;
    }
    break;
  default:
    break;
  }
  let newt = unify_term(accum,t,*t2);
  accum->m1 = Dict::insert(accum->m1,vd,newt);
  accum->m2 = Dict::insert(accum->m2,vd,newt);
  accum->m = Dict::insert(accum->m,vd,newt);
  return accum;
}

// helper function when we are folding in am2.map-am1.map
// all the vd's in here are undefined in am1.map
// before merge: M1: x undefined,, M2: x->t
// after merge: M: x->v, a2 = and(v==t,a2);
static accum_t @`r foldm2(vardecl_t vd, term_t t, accum_t @`r accum){
  switch (t) {
//   case &LogicVar(...):
//     accum->m = Dict::insert(accum->m,vd,t);
//     return accum;
  default:
    let v = fresh_var(vd->type);
    accum->a2 = and(eq(v,t),accum->a2);
    accum->m = Dict::insert(accum->m,vd,v);
    return accum;
  }
}

term_dict_t empty_term_dict() {
  static term_dict_t *term_dict = NULL;
  if (term_dict == NULL) {
    term_dict = new Dict::empty(Core::ptrcmp);
  }
  return *term_dict;
}

// Given two assn_map am1, am2, where the nonescvarmap
// might be different, unify their nonescvar_maps and
// return a1,a2 map such that
// AssnMap(a1,map) <=> am1 and
// AssnMap(a2,map) <=> am2
$(assn_t,assn_t,nonescvar_map_t) unify_var_maps(assn_map_t am1, assn_map_t am2){
  if (am1.assn == &false_assn) return $(am1.assn,am2.assn,am2.map);
  if (am2.assn == &false_assn) return $(am1.assn,am2.assn,am1.map);
  accum_t accum = Accum{am1.assn,am2.assn,am1.map,am2.map,empty_map()};
  Dict::fold(foldm1,am1.map,&accum);
  Dict::fold(foldm2,Dict::difference(am2.map,am1.map),&accum);
  return $(accum.a1,accum.a2,accum.m);
}


static term_dict_t @collect_subst(nonescvar_map_t @map2, vardecl_t vd, term_t value, term_dict_t @`H dict) {
  switch (value) {
  case &LogicVar(...):
    // even if we have a logic var, if 
    // the other map had the same value for 
    // this vd, there is no need to do substitution
    let v = Dict::lookup_opt(*map2,vd);
    // otherwise, make sure we haven't used this 
    // value in earlier substitution.
    if (Dict::lookup_opt(*dict,value) == NULL) {
      if (v != NULL && *v == value) 
	return new Dict::insert(*dict,value,*v);
      return new Dict::insert(*dict,value,fresh_var(vd->type));
    }
    break;
  default:
    break;
  }
  return dict;
}
// given two assn_map am1, am2, where the nonescvarmap
// might be different unify their nonescvar_maps
// if am1.map: x->v where v is a logic var,
// we unify the am2.map to x->v too, but we need
// to do substitution in am2.assn and am2.map so
// that v does not occur free in am2
// we only want to do this expensive unify during
// loops to keep the cost do
$(assn_t,assn_t,nonescvar_map_t) unify_var_maps_subst(assn_map_t am1, assn_map_t am2) {
  if (am1.assn == &false_assn) return $(am1.assn,am2.assn,am2.map);
  if (am2.assn == &false_assn) return $(am1.assn,am2.assn,am1.map);
  // go over am1.map, if xi->vi, vi is a logic var,
  // we will substitue vi with a new ui in am2 so
  // that we can have x->vi in am2.
  term_dict_t subst_dict = *Dict::fold_c(collect_subst,&am2.map,am1.map,new empty_term_dict());
  let am2 = subst_am(subst_dict,am2);
  return unify_var_maps(am1,am2);
}

assn_map_t or_assnmap_assnmap(assn_map_t am1, assn_map_t am2){
  let $(a1,a2,map) = unify_var_maps(am1,am2);
  return AssnMap(or(a1,a2),map);
}


typedef struct Canonical_am_accum {
  assn_t assn;
  nonescvar_map_t map;
  struct Set::Set<term_t> @used_lvars;
} @canonical_am_accum_t;

static canonical_am_accum_t fold_canonical(vardecl_t vd, term_t value, canonical_am_accum_t accum) {
  switch (value) {
  case &LogicVar(...):
    if (!Set::member(accum->used_lvars,value)) {
      accum->used_lvars = Set::insert(accum->used_lvars,value);
      accum->map = Dict::insert(accum->map,vd,value);
      return accum;
    }
    break;
  default:
    break;
  }
  let v = fresh_var(vd->type);
  accum->used_lvars = Set::insert(accum->used_lvars,v);
  accum->map = Dict::insert(accum->map,vd,v);
  accum->assn = and(accum->assn,eq(v,value));
  return accum;
}

// given an assnmap, return a logically equivalent
// assnmap such that
// xi->vi where v1, ..., vn are distinct logicvars
// for every vd in the map
assn_map_t canonical_assnmap(assn_map_t am) {
  let accum = new Canonical_am_accum(am.assn,empty_map(),Set::empty(Core::ptrcmp));
  Dict::fold(fold_canonical,am.map,accum);
  return AssnMap (accum->assn,accum->map);
}

static nonescvar_map_t@`r force_it($(assn_t,vardecl_set_t)@env, vardecl_t vd, term_t t, nonescvar_map_t @`r accum) {
  if (Set::member(env->f1,vd)) {
    let new_term = fresh_var(vd->type);
    env->f0 = and(env->f0,eq(new_term,t));
    *accum = Dict::insert(*accum,vd,new_term);
  } else {
    *accum = Dict::insert(*accum,vd,t);
  }
  return accum;
}

// similar to above but forces everything to be a fresh variable.
assn_map_t force_canonical(vardecl_set_t vds, assn_map_t am) {
  vds = Set::insert(vds,memory);
  vds = Set::insert(vds,exception_vardecl());
  let assn = am.assn;
  let env = $(assn,vds);
  let map = empty_map();
  Dict::fold_c(force_it, &env, am.map, &map);
  return AssnMap(env.f0,map);
}

// given two assertion_map a1, a2, where the nonescvarmap 
// only maps vardecls to logical vars of the form:
// a1 = assn1, x1=v1(or NULL) ,x2=v2(or NULL),...
// a2 = assn2, y1=u1,          y2=u2,...
// return a new a2
// a2 = assn2(vi/ui) yi = ui for each xi=vi in a1.
// this function is used when we are comparing two
// function signatures (such as subtyping or type equivalence)
assn_t merge_assnmaps(list_t<vardecl_opt_t> vds1, assn_map_t a1,
			  list_t<vardecl_opt_t> vds2, assn_map_t a2){
  term_dict_t dict=empty_term_dict();
  // deal with memory first
  let v1 = Dict::lookup_opt(a1.map,memory);
  let v2 = Dict::lookup_opt(a2.map,memory);
  if (v1 != NULL && v2 != NULL)
    dict = Dict::insert(dict,*v2,*v1);
  // now deal with vardecls
  for (; vds1 != NULL && vds2 != NULL; vds1 = vds1->tl, vds2 = vds2->tl){
    if (vds1->hd != NULL && vds2->hd != NULL){
      let v1 = Dict::lookup_opt(a1.map,(vardecl_t)vds1->hd);
      let v2 = Dict::lookup_opt(a2.map,(vardecl_t)vds2->hd);
      if (v1 != NULL && v2 != NULL){
	dict = Dict::insert(dict,*v2,*v1);
      }
    }
#ifdef AssnDefDebug
    else {
      if (vds1->hd == NULL) fprintf(stderr, "var in vds1 is NULL\n");
      if (vds2->hd == NULL) fprintf(stderr, "var in vds2 is NULL\n");
    }
#endif
  }
  if (Dict::is_empty(dict)) return a2.assn;
  else return subst_a(dict,a2.assn);
}

// given an assertion_map of the form 
// a1 = assn1, x1 = v1, x2 = v2, ...xn = vn
// and a new list of vardecls y1, y2, ...yn
// generating a new assertion_map of the form
// a2 = assn1[ui/vi] yi = ui
// this function is used when we are creating a
// new function signature that has the same type
// as the old function signature
extern assn_map_t *subst_vardecls(List::list_t<vardecl_opt_t> vds1,
				  List::list_t<vardecl_opt_t> vds2,
				  assn_map_t *a){
  if (a == NULL) return NULL;
  let newmap = empty_map();
  let dict = empty_term_dict();
  // deal with memory as if it were a variable...
  let v = Dict::lookup_opt(a->map,memory);
  if (v != NULL) {
    let u = fresh_var(NULL);
    newmap = Dict::insert(newmap,memory,u);
    dict = Dict::insert(dict,*v,u);
  }
  for(; vds1 != NULL && vds2 != NULL; vds1 = vds1->tl, vds2 = vds2->tl){
    if (vds1->hd != NULL && vds2->hd != NULL){
      let v = Dict::lookup_opt(a->map,(vardecl_t)vds1->hd);
      if (v != NULL) {
	let u = fresh_var(vds2->hd->type);
	// map yi to a new logicvar ui,
	newmap = Dict::insert(newmap,(vardecl_t)vds2->hd,u);
	// add pair vi,ui into the dict for substitution
	dict = Dict::insert(dict,*v,u);
      }
    }
  }
  // get newa = a.assn[ui/vi]
  let newa = subst_a(dict,a->assn);
  return new AssnMap(newa,newmap);
}

// given an assnmap that was part of a function's signature
// of the form assn /\ x1 = v1, x2 = v2,
// and the actual function argument t1,t2,...
// return the assertion assn[ti/vi]
// this function is used during vcgen for function calls
assn_t subst_args(list_t<vardecl_opt_t> args, vardecl_opt_t res,
                  list_t<term_t> actual_args, term_opt_t actual_res,
                  term_t mem,
                  assn_map_t am){
  term_dict_t dict = empty_term_dict();
  let mem_val = Dict::lookup_opt(am.map,memory);
  if (mem_val != NULL)
    dict = Dict::insert(dict,*mem_val,mem);
  if (res != NULL && actual_res != NULL){
    let res_val = Dict::lookup_opt(am.map,(vardecl_t)res);
    if (res_val != NULL)
      dict = Dict::insert(dict,*res_val, (term_t)actual_res);
  }
  for(; args != NULL && actual_args != NULL; args = args->tl, actual_args=actual_args->tl){
    if (args->hd != NULL && actual_args->hd != NULL){
      let arg_val = Dict::lookup_opt(am.map,(vardecl_t)args->hd);
      if (arg_val != NULL) 
	dict = Dict::insert(dict,*arg_val,actual_args->hd);
    }
  }
  return subst_a(dict,am.assn);
}

void reset_hash_cons_table(void){
  //fprintf(stderr,"term hash table:\n");
  //Hashtable::print_hist(term_hash_cons_table);
  term_hash_cons_table = NULL;
  assn_hash_cons_table = NULL;
};

static void f_sizeof_hashtable(`a key, `b value, int @ counter) {
  (*counter)++;
}

int sizeof_hash_cons_table(void){
  int size = 0;
  if (term_hash_cons_table != NULL){
    Hashtable::iter_c(f_sizeof_hashtable,term_hash_cons_table,&size);
  }
  if (assn_hash_cons_table != NULL){
    Hashtable::iter_c(f_sizeof_hashtable,assn_hash_cons_table,&size);
  }
  return size;
}

term_table_t empty_term_table() {
  return Hashtable::create(33, termcmp, termhash);
}

term_t subst_table(term_table_t table, term_t t) {
  let sopt = Hashtable::lookup_opt(table,t);
  let told = t;
  if (sopt != NULL) return *sopt;
  switch (t){
  case &LogicVar(...): break;
  case &Uint(...): break;
  case &Const(...): break;
  case &Addr(vd,t1,tp): 
    let s1 = subst_table(table,t1);
    if (s1 != t1) {
      let a = Addr(vd,s1,tp);
      t = hash_cons_term(&a);
    }
    break;
  case &Alloc(e1,i,t1,t2,tp): 
    let s1 = subst_table(table,t1);
    let s2 = subst_table(table,t2);
    if (s1 != t1 || s2 != t2) {
      let a = Alloc(e1,i,s1,s2,tp);
      t = hash_cons_term(&a);
    }
    break;
  case &Select(t1,t2,tp):
    let s1 = subst_table(table,t1);
    let s2 = subst_table(table,t2);
    if (s1 != t1 || s2 != t2) t = select(s1,s2,tp);
    break;
  case &Update(t1,t2,t3):
    let s1 = subst_table(table,t1);
    let s2 = subst_table(table,t2);
    let s3 = subst_table(table,t3);
    if (s1 != t1 || s2 != t2 || s3 != t3) t = update(s1,s2,s3);
    break;
  case &Unop(p,t1,tp):
    let s1 = subst_table(table,t1);
    if (s1 != t1) t = unop(p,s1,tp);
    break;
  case &Binop(p,t1,t2,tp):
    let s1 = subst_table(table,t1);
    let s2 = subst_table(table,t2);
    if (s1 != t1 || s2 != t2) t = binop(p,s1,s2,tp);
    break;
  case &Cast(tp,t1):
    let s1 = subst_table(table,t1);
    if (s1 != t1) t = cast(tp,s1);
    break;
  case &Aggr(b,tag,tlist,tp):
    let slist = NULL;
    bool changed = false;
    for(;tlist != NULL; tlist = tlist->tl){
      let t1 = tlist->hd;
      let s1 = subst_table(table,t1);
      if (s1 != t1) changed = true;
      slist = new List(s1,slist);
    }
    if (changed) {
      List::imp_rev(slist);
      t = aggr(b,tag,slist,tp);
    }
    break;
  case &Proj(t1,i,tp):
    let s1 = subst_table(table,t1);
    if (s1 != t1) t = proj(s1,i,tp);
    break;
  case &AggrUpdate(t1,i,t2):
    let s1 = subst_table(table,t1);
    let s2 = subst_table(table,t2);
    if (s1 != t1 || s2 != t2) t = aggr_update(s1,i,s2);
    break;
  case &Offsetf(t1,i,tp):
    let s1 = subst_table(table,t1);
    if (s1 != t1) t = offsetf(s1,i,tp);
    break;
  case &Offseti(t1,t2,tp):
    let s1 = subst_table(table,t1);
    let s2 = subst_table(table,t2);
    if (s1 != t1 || s2 != t2) t = offseti(s1,s2,tp);
    break;
  case &Tagof(t1):
    let s1 = subst_table(table,t1);
    if (s1 != t1) t = tagof_tm(s1);
    break;
  }
  Hashtable::insert(table,told,t);
  return t;
}


// calculates (conservatively) the set of non-escaping variables 
// that get changed by an expression or statement.  We use the
// visitors so these functions only have to look locally -- the
// rest of the recursion is handled by the visitors.
static void changed_lhs(vardecl_set_t@ vds, exp_t e) {
  switch (e->r) {
  case &Absyn::Var_e(&Absyn::Param_b(vd)): fallthru(vd);
  case &Absyn::Var_e(&Absyn::Local_b(vd)): fallthru(vd);
  case &Absyn::Var_e(&Absyn::Pat_b(vd)):
    *vds = Set::insert(*vds, vd);
    break;
  default: break;
  }
}

static void changed_pat(vardecl_set_t@ vds, Absyn::pat_t p) {
 LOOP:
  switch (p->r) {
  case &Absyn::Reference_p(vd, p1): fallthru(vd,p1);
  case &Absyn::Var_p(vd, p1): Set::insert(*vds,vd); p = p1; goto LOOP; 
  case &Absyn::TagInt_p(_,vd): fallthru(vd);
  case &Absyn::AliasVar_p(_, vd): Set::insert(*vds,vd); break;
  case &Absyn::Pointer_p(p1): p=p1; goto LOOP;
  case &Absyn::Aggr_p(_,_,_,dlps,_):
    for (; dlps != NULL; dlps = dlps->tl) 
      changed_pat(vds,dlps->hd->f1);
    break;
  case &Absyn::Datatype_p(_,_,ps,_):
    for (; ps != NULL; ps = ps->tl) 
      changed_pat(vds,ps->hd);
    break;
  default: break;
  }
}

static bool changed_exp(vardecl_set_t@ vds, exp_t e) {
  switch (e->r) {
  case &Absyn::AssignOp_e(e,_,_): fallthru(e);
  case &Absyn::Increment_e(e,_) :
    changed_lhs(vds,e);
    break;
  case &Absyn::Comprehension_e(vd,...):
    *vds = Set::insert(*vds,vd);
    break;
  case &Absyn::Swap_e(e1,e2):
    changed_lhs(vds,e1);
    changed_lhs(vds,e2);
    break;
  default: break;
  }
  return true;
}

static bool changed_stmt(vardecl_set_t@ vds, stmt_t s) {
  switch (s->r) {
  case &Absyn::Decl_s(d,_):
    switch (d->r) {
    case &Absyn::Var_d(vd)       : fallthru(vd);
    case &Absyn::Region_d(_,vd,_): *vds = Set::insert(*vds,vd); break;
    case &Absyn::Let_d(p,...): 
      changed_pat(vds,p); break;
    case &Absyn::Letv_d(vds2):
      *vds = Set::union_two(*vds, Set::from_list(Core::ptrcmp, vds2)); break;
    default: break;
    }
    break;
  case &Absyn::Switch_s(_,scs,_)  : fallthru(scs); 
  case &Absyn::TryCatch_s(_,scs,_):
    for (; scs != NULL; scs = scs->tl) 
      changed_pat(vds,scs->hd->pattern);
    break;
  default: break;
  }
  return true;
}

vardecl_set_t calc_changed_vars_exp(exp_t e) {
  vardecl_set_t vds = Set::empty(Core::ptrcmp);
  Absyn::visit_exp(changed_exp, changed_stmt, &vds, e);
  return vds;
}
vardecl_set_t calc_changed_vars_stmt(stmt_t s) {
  vardecl_set_t vds = Set::empty(Core::ptrcmp);
  Absyn::visit_stmt(changed_exp, changed_stmt, &vds, s);
  return vds;
}
