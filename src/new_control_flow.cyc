/* Control flow analysis.
   Copyright (C) 2001 Dan Grossman, Greg Morrisett
   This file is part of the Cyclone compiler.

   The Cyclone compiler is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   The Cyclone compiler is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with the Cyclone compiler; see the file COPYING. If not,
   write to the Free Software Foundation, Inc., 59 Temple Place -
   Suite 330, Boston, MA 02111-1307, USA. */

// TO DO: Get patterns right rather than require fully initialized
//        At very least, special case let x = e !!!

// The previous pass (type-checking) sets up:
// * decorating all stmts with their correct non_local_preds
// * decorating each stmt with CFAnnot
// * setting all the encloser fields (note the list ends with a self-loop,
//   not a NULL!
// (The latter two activities are performed via calls to set_encloser.)

// We now do three passes here:
// * First we:
//    * check that gotos don't jump into scope
//    * collect all the Vardecls and malloc points for the function
//      (and use this to compute all paths, and a mapping from local paths
//       to the leaves)
//    * translate each top-level exp to an absexp_t and decorate the stmt's
//      with the absexp_t's.
// * Then we iterate to make sure memory is written before it is read.
//   Another thing to do during this pass would be NULL-check elimination
//   and/or warning.
// * Last we free space by replacing all the statment annotations.

#include <core.h>
#include <list.h>
#include <set.h>
#include <dict.h>
#include <cstring.h>
#include <assert.h>
#include "absyn.h"
#include "tcutil.h"
#include "evexp.h"

#include "cf_flowinfo.h"
#include "cf_absexp.h"
#include "new_control_flow.h"

// for debugging
#include "absynpp.h"
#include <stdio.h>

using Core;
using List;
using Absyn;
using CfFlowInfo;
using CfAbsexp;
namespace NewControlFlow;

typedef Dict::dict_t<`a,`b> dict_t<`a,`b>;

//////////////////////////// Statement Decoration //////////////////////////

// What the absexps field means for different statement variants:
// (It's a consistent "left to right" reading of the contained expressions.)
// * Exp: list has length 1, abstraction of exp.
// * Return: if eopt != NULL, list has length 1, abstraction of exp.
// * If, While, Do: list has length 2: abstraction of when-true/when-false,
//                  each including use of guard
// * For(e1,e2,e3): list has length 4:
//                    abstraction of e1, e2 when-true, e2 when-false,
//                    abstraction of e3
// * Fallthru(es): list has length 1, unordered of abstraction of es
// * Decl: if there's an initializer expression, list is its abstraction
// * Switch: list has odd length >= 1, abstraction of guard, then abstractions
//      of any where_clause's when-true when-false in the order of the cases
// * TryCatch: abstractions of any where_clause's when-true when-false 
//              in the order of the cases
// * else list is NULL
struct CFStmtAnnot {
  stmt_t           encloser; // for checking goto-scope -- no other use
  int              visited;  // for detecting need to iterate
  flow_info_t      flow;     // flow to merge in when we check again
  list_t<absexp_t> absexps;  // meaning explained above
};
typedef struct CFStmtAnnot cf_stmt_annot_t;
xtunion StmtAnnot { CFAnnot(cf_stmt_annot_t); };

// to be used by the type-checking pass to get things set up for us
// must be called on EVERY stmt in the abstract syntax (even the dummy ones)
void set_encloser(stmt_t enclosee, stmt_t encloser) {
  enclosee->annot = new CFAnnot(CFStmtAnnot(encloser, 0, BottomFL, NULL));
}
static cf_stmt_annot_t @ get_stmt_annot(stmt_t s) {
  switch(s->annot) {
  case &CFAnnot(*x): return x;
  default: throw new Impossible("ControlFlow -- wrong stmt annotation");
  }
}
static void cf_set_absexps(stmt_t s, list_t<absexp_t,`H> ael) {
  get_stmt_annot(s)->absexps = ael;
}

///////////////////////// Translation Environment /////////////////////////
// could just make globals (so prepass wouldn't be re-entrant -- who cares?)
static struct AbsEnv {
  pinfo_dict_t<local_root_t> all_roots; // all path_info leaves are Uninit
};
typedef struct AbsEnv @ absenv_t;
static struct AbsSyn {
  absexp_t when_true_exp;
  absexp_t when_false_exp;
  absop_t  absop;
};
typedef struct AbsSyn abssyn_t; // NOT a pointer!

static void add_var_root(absenv_t env, vardecl_t vd) {
  env->all_roots = Dict::insert_new(env->all_roots,
				    new VarRoot(vd),
				    typ_to_unesc_none_pinfo(vd->type));
}
// Note: The type is the type of the object, not the pointer to the object.
static void add_malloc_root(absenv_t env, exp_t e, type_t t) {
  env->all_roots = Dict::insert_new(env->all_roots,
				    new MallocPt(e),
				    typ_to_unesc_none_pinfo(t));
}
static absexp_t meet_absexp(abssyn_t syn) {
  if(syn.when_true_exp == syn.when_false_exp)
    return syn.when_true_exp;
  return mkGroupAE(OneofG, syn.when_true_exp, syn.when_false_exp);
}

///////////////////////// Expression Translation //////////////////////////

abssyn_t abstract_exp(absenv_t env, exp_t  e);
void     cf_prepass  (absenv_t env, stmt_t s); 

static absexp_t use_exp(absenv_t env, exp_t e) {
  let syn = abstract_exp(env,e);
  return mkGroupAE(OrderedG, meet_absexp(syn), mkUseAE(syn.absop));
}

// To be used when each element of es is used, and the result is unknown. 
// FIX: es need to be used before all es evaluate, but don't need to escape
//      until afterwards (think about function call, eg. f(x, y=x=e)).
//      We're sound but too restrictive as is (nobody will care I bet)
// FIX: for primops, they're ints, so no need to escape.  More generally,
//      don't need to escape when the "destination" type is int.
static abssyn_t use_exp_unordered(absenv_t env, list_t<exp_t,`H> es) {
  let aexp = mkGroupAE_l(UnorderedG, List::map_c(use_exp, env, es));
  return AbsSyn(aexp,aexp,mkUnknownOp());
}

// Used by the Malloc_e and New_e cases (caller adds malloc root)
// Note: we admit that the evaluation of rgn_exp happens before the evaluation
// of init_exp.
// Note: We don't bother to "use" rgn_exp b/c we know its initialized.
abssyn_t abstract_malloc(absenv_t env, exp_t outer_e,
			 exp_opt_t rgn_exp, exp_opt_t init_exp) {
  let malloc_op = mkMallocOp(outer_e);
  absexp_t ans_aexp = mkSkipAE();
  if(init_exp != NULL) {
    let init_syn = abstract_exp(env, (exp_t)init_exp);
    ans_aexp = mkGroupAE(OrderedG, meet_absexp(init_syn),
			 mkAssignAE(malloc_op, init_syn.absop));
  }
  ans_aexp = mkGroupAE(OrderedG, mkMallocAE(outer_e), ans_aexp);
  if(rgn_exp != NULL)
    ans_aexp = 
      mkGroupAE(OrderedG, meet_absexp(abstract_exp(env, (exp_t)rgn_exp)), 
		ans_aexp);
  // Cute: the result of a malloc is not false (we raise an exception)
  return AbsSyn(ans_aexp, mkBottomAE(), mkAddressOp(malloc_op));
}

abssyn_t abstract_exp(absenv_t env, exp_t e) {
  switch(e->r) {

    // C doesn't allow "memory-kind casts", which is good because then
    // we'd have to translate the dictionary domains and that's a pain.
    // But it SHOULD BE THE CASE that the source and destination types
    // are both "leaf types", so there is no problem.
  case &Cast_e(_,e1):        fallthru(e1);
  case &NoInstantiate_e(e1): fallthru(e1);
  case &Instantiate_e(e1,_): return abstract_exp(env, e1);

  // these things are fully initialized non-lvalues that "jump one way"
  case &Const_e(Null_c):
  case &Const_e(&Int_c(Signed,0)):
    return AbsSyn(mkBottomAE(), mkSkipAE(),   mkUnknownOp());
  case &Const_e(&Int_c(Signed,1)): 
    return AbsSyn(mkSkipAE(),   mkBottomAE(), mkUnknownOp());

  // these things are fully initialized non-lvalues that could be true or false
  case &Const_e(_): 
  case &Sizeofexp_e(_): // note the exp is NOT evaluated
  case &Sizeoftyp_e(_):  
  case &Offsetof_e(_,_): 
  case &Gentyp_e(_,_):  
  case &Enum_e(_,_,_): // FIX : distinguish tags that are/aren't 0
  case &Var_e(_,&Funname_b(_)):
    // globals are lvalues, but are escaped and fully initializaed
  case &Var_e(_,&Global_b(_)):
    return AbsSyn(mkSkipAE(), mkSkipAE(), mkUnknownOp());

  case &Var_e(_,&Param_b(vd)): fallthru(vd);
  case &Var_e(_,&Local_b(vd)): fallthru(vd);
  case &Var_e(_,&Pat_b(vd)): return AbsSyn(mkSkipAE(),mkSkipAE(),mkLocalOp(vd));

    // There is no result lhs (= associates to the right).
    // Note that because we make the absop be the left-hand-side, we could
    // in theory lose precision on nested assignments, eg. x = y = z
    // where z points to a known place but y has escaped.  I bet nobody notices
    // and if they do, they can be told the rule and rewrite it y = x = z,
    // which is the right thing to do if y has escaped.
  case &AssignOp_e(e1,NULL,e2):
    let syn1 = abstract_exp(env, e1);
    let syn2 = abstract_exp(env, e2);
    let aexp = 
      mkGroupAE(OrderedG, 
		mkGroupAE(UnorderedG, meet_absexp(syn1), meet_absexp(syn2)),
		mkAssignAE(syn1.absop, syn2.absop));
    return AbsSyn(aexp,aexp,syn1.absop);

  // FIX: do init qualifier (callee can't muck with aliases in that case)
  case &FnCall_e(e1,es,_): return use_exp_unordered(env, new List(e1,es));
  case &AssignOp_e(e1,_,e2): fallthru(new List(e1, new List(e2, NULL)));
  case &Primop_e(_,es): return use_exp_unordered(env, es);

  case &Address_e(e1):
    // If this is really a malloc-and-initialize, do something totally different
    switch(e1->r) {
    case &Struct_e(_,_,_,_): 
    case &Tuple_e(_): 
      add_malloc_root(env, e, e1->topt->v);
      return abstract_malloc(env, e, NULL, e1);
    default:
      let syn1 = abstract_exp(env,e1);
      let aexp = meet_absexp(syn1);
      return AbsSyn(aexp,aexp,mkAddressOp(syn1.absop));
    }

  case &Subscript_e(e1,e2):
    switch(Tcutil::compress(e1->topt->v)) {

    case &TupleType(_): // we track aggregate paths through tuples
      // we know e2 is a constant int, but if the type-checker ever gets
      // more lenient, then we need to call abstract_exp(env,e2)!!!
      let syn1 = abstract_exp(env,e1);
      let aexp = meet_absexp(syn1);
      let field = fieldname(Evexp::eval_const_uint_exp(e2));
      return AbsSyn(aexp,aexp,mkMemberOp(syn1.absop,field));
      
    default: 
      // FIX: add special-case: treat x[0] just like *x (instead of using
      //      e1, make a DerefOp)

      // initialized arrays have initialized elements and things assigned
      // to elements are "used".
      return use_exp_unordered(env, new List(e1, new List(e2,NULL)));
    }

  case &Deref_e(e1):
    let syn1 = abstract_exp(env,e1);
    let aexp = meet_absexp(syn1); // don't just meet when we do null-checks
    absop_t absop; 
    switch(Tcutil::compress(e1->topt->v)) {
    case &PointerType(PtrInfo(t2,_,_,_,bd)):
      if(Tcutil::is_bound_one(bd))
	absop = mkDerefOp(syn1.absop);
      else {
	aexp  = mkGroupAE(OrderedG, aexp, mkUseAE(syn1.absop));
	absop = mkUnknownOp();
      }
      break;
    default: throw new Impossible("NewControlFlow: bad type in Deref");
    }    
    return AbsSyn(aexp,aexp,absop);

    // KLUDGE: Our treatment of UNIONS does not require all memory to
    // be written before its read (because different variants can have
    // different size and alignment), but so long as unions are only bits,
    // memory safety is not compromised.
  case &StructArrow_e(e1,fname):
    let syn1 = abstract_exp(env,e1);
    let aexp = meet_absexp(syn1); // don't just meet when we do null-checks
    absop_t absop; 
    switch(Tcutil::compress(e1->topt->v)) {
    case &PointerType(PtrInfo(t2,_,_,_,bd)):
      if(Tcutil::is_bound_one(bd)) {
	switch(Tcutil::compress(t2)) {
	case &UnionType(_,_,_):
	case &AnonUnionType(_): absop = mkDerefOp(syn1.absop); break;
	default: absop = mkMemberOp(mkDerefOp(syn1.absop),fname);
	}
      } else {
	aexp  = mkGroupAE(OrderedG, aexp, mkUseAE(syn1.absop));
	absop = mkUnknownOp();
      }
      break;
    default: throw new Impossible("NewControlFlow: bad type in StructArrow");
    }    
    return AbsSyn(aexp,aexp,absop);

    // same KLUDGE as in previous case
  case &StructMember_e(e1,fname):
    let syn1 = abstract_exp(env,e1);
    let aexp = meet_absexp(syn1);
    absop_t absop;
    switch(Tcutil::compress(e1->topt->v)) {
    case &AnonUnionType(_): 
    case &UnionType(_,_,_): absop = syn1.absop; break;
    default: absop = mkMemberOp(syn1.absop,fname);
    }
    return AbsSyn(aexp,aexp,absop);

  case &New_e(eopt,e1):
    add_malloc_root(env, e, e1->topt->v);
    return abstract_malloc(env, e, eopt, e1);

  case &Malloc_e(eopt,t):
    add_malloc_root(env, e, t);
    return abstract_malloc(env, e, eopt, NULL);

  case &Tunion_e(_,_,es,_,_): 
    // FIX: can distinguish zero/non-zero tags
    if(es == NULL)
      return AbsSyn(mkSkipAE(),mkSkipAE(),mkUnknownOp());
    fallthru(es);

  case &Tuple_e(es): 
    list_t<absexp_t> arg_aexps = NULL;
    dict_t<field_name_t,absop_t> absop_dict = Dict::empty(Std::zstrptrcmp);
    for(int j=0; es != NULL; es = es->tl, ++j) {
      let syn = abstract_exp(env,es->hd);
      arg_aexps = new List(meet_absexp(syn), arg_aexps);
      absop_dict = Dict::insert(absop_dict, fieldname(j), syn.absop);
    }
    let aexp = mkGroupAE_l(UnorderedG, arg_aexps);
    return AbsSyn(aexp,aexp,mkDictOp(absop_dict));

  case &AnonStruct_e(_,des): fallthru(des);
  case &Struct_e(_,_,des,_): 
    // multiple designators are a pain (and I don't think they parse anyway)
    list_t<absexp_t> arg_aexps = NULL;
    dict_t<field_name_t,absop_t> absop_dict = Dict::empty(Std::zstrptrcmp);
    for(; des != NULL; des = des->tl) {
      let syn = abstract_exp(env,(*des->hd)[1]);
      arg_aexps = new List(meet_absexp(syn), arg_aexps);
      for(_ ds = (*des->hd)[0]; ds != NULL; ds = ds->tl)
	switch (ds->hd) {
	case &ArrayElement(_): throw new Impossible("bad struct designator");
	case &FieldName(f): absop_dict = Dict::insert(absop_dict, f, syn.absop);
	}
    }
    let aexp = mkGroupAE_l(UnorderedG, arg_aexps);
    return AbsSyn(aexp,aexp,mkDictOp(absop_dict));

  // We don't track through arrays, so all array elements must be 
  // fully initialized.  Hence the result is fully initialized.
  case &Array_e(l): return use_exp_unordered(env, map(snd,l));
    
  case &Increment_e(e1,_): 
    // Note: Since e1 is either an int or a tagged array, "using" it won't
    // cause any additional loss of precision.
    return use_exp_unordered(env, new List(e1,NULL));

  case &Throw_e(e1): 
    let aexp = mkGroupAE(OrderedG, use_exp(env,e1), mkBottomAE());
    return AbsSyn(aexp,aexp,mkUnknownOp());

    // Here's where we greatly simplify by being a tiny bit more conservative,
    // by always returning UnknownOp.
    // FIX: don't escape on the "int cases", which includes guards and
    //      null-checks (and always on e1?? -- depends on type of && and ||)
    // Note: I think gcc supports ? : as a left-hand-side but we don't.
  case &Conditional_e(e1,e2,e3):
    let syn1 = abstract_exp(env,e1);
    let syn2 = abstract_exp(env,e2);
    let syn3 = abstract_exp(env,e3);
    let use_1true_aexp = 
      mkGroupAE(OrderedG, syn1.when_true_exp,  mkUseAE(syn1.absop));
    let use_1false_aexp =
      mkGroupAE(OrderedG, syn1.when_false_exp, mkUseAE(syn1.absop));
    let use2 = mkUseAE(syn2.absop);
    let use3 = mkUseAE(syn3.absop);
    let true_aexp = 
      mkGroupAE(OneofG, 
		mkGroupAE(OrderedG, use_1true_aexp,  
			  mkGroupAE(OrderedG, syn2.when_true_exp,  use2)),
		mkGroupAE(OrderedG, use_1false_aexp, 
			  mkGroupAE(OrderedG, syn3.when_true_exp,  use3)));
    let false_aexp = 
      mkGroupAE(OneofG, 
		mkGroupAE(OrderedG, use_1true_aexp,  
			  mkGroupAE(OrderedG, syn2.when_false_exp, use2)),
		mkGroupAE(OrderedG, use_1false_aexp, 
			  mkGroupAE(OrderedG, syn3.when_false_exp, use3)));
    return AbsSyn(true_aexp, false_aexp, mkUnknownOp());

  // Technically we're being too conservative here because we could
  // have different when_true/when_false on the last expression.
  // Given that that's a pain to deal with, it would take rather
  // convoluted code to matter, lots of such code could be written
  // with SeqExp_e, I won't bother.
  case &StmtExp_e(s):
    cf_prepass(env,s);
    // The strange part is we need to use the last expression
    // so we re-do the last statement in order to get this right. 
    let last_s = s;
    while(true)
      switch(last_s->r) {
      case &Seq_s(s1,s2): last_s = s2; continue;
      case &Decl_s(d,s1): last_s = s1; continue;
      case &Exp_s(e):     
	let absop = abstract_exp(env,e).absop;
	let aexp = mkStmtAE(s);
	return AbsSyn(aexp,aexp,absop);
      default: throw new Impossible("abstract_exp: ill-formed StmtExp");
      }

  case &SeqExp_e(e1,e2): // note: it's fine for e1 to be uninitialized
    let syn1  = abstract_exp(env,e1);
    let syn2  = abstract_exp(env,e2);
    let aexp1 = meet_absexp(syn1);
    return AbsSyn(mkGroupAE(OrderedG, aexp1, syn2.when_true_exp),
		  mkGroupAE(OrderedG, aexp1, syn2.when_false_exp),
		  syn2.absop);

    // Note: the second exp might never get executed
    // Note: array elements must be fully initialized
    // Note: e1 must be initialized
    // Note: hoisting the vardecls would be inefficient if there were a ton
    // of them (only need to hoist out to the beginning of the absexp, but
    // that's a pain, so we hoist them to the whole function)
    // (This hoisting is only for the analysis and is for sorta obscure reasons)
  case &Comprehension_e(vd,e1,e2):
    add_var_root(env,vd);
    let syn1 = abstract_exp(env,e1);
    let syn2 = abstract_exp(env,e2);
    let aexp = mkComprehensionAE(vd,
				 syn1.when_true_exp,
				 syn1.when_false_exp,
				 syn1.absop,
				 meet_absexp(syn2),
				 syn2.absop);
    return AbsSyn(aexp,aexp,mkUnknownOp());

  case &Var_e(_,Unresolved_b): 
  case &UnknownId_e(_):        
  case &UnknownCall_e(_,_):    
  case &UnresolvedMem_e(_,_):  
  case &CompoundLit_e(_,_):    
  case &Codegen_e(_):          
  case &Fill_e(_): throw new Impossible("abstract_exp, unexpected exp form");
  }
}

// FIX: no need for escape points-to b/c guards are treated as ints
static $(absexp_t,absexp_t) abstract_guard(absenv_t env, exp_t e) {
  let syn = abstract_exp(env,e);
  let use = mkUseAE(syn.absop);
  if(syn.when_true_exp == syn.when_false_exp) {
    let aexp = mkGroupAE(OrderedG, syn.when_true_exp, use);
    return $(aexp,aexp);
  }
  return $(mkGroupAE(OrderedG, syn.when_true_exp,  use),
	   mkGroupAE(OrderedG, syn.when_false_exp, use));
}


list_t<absexp_t> cf_prepass_scs(absenv_t env, list_t<switch_clause_t> scs) {
  let ans = NULL;
  for(; scs != NULL; scs = scs->tl) {
    let &Switch_clause(_,vds_opt,wherec,body,_) = scs->hd;
    if(vds_opt == NULL)
      throw new Impossible("switch clause vds not set");
    for(_ vds = vds_opt->v; vds != NULL; vds = vds->tl)
      add_var_root(env,vds->hd);
    if(wherec != NULL) {
      let $(when_true,when_false) = abstract_guard(env,(exp_t)wherec);
      ans = new List(when_true,new List(when_false,ans));
    }
    cf_prepass(env,body);
  }
  return imp_rev(ans);
}

void cf_prepass(absenv_t env, stmt_t s) {
  switch(s->r) {
  case Skip_s: return;
  case &Exp_s(e): // e need not be initialized
    cf_set_absexps(s,new List(meet_absexp(abstract_exp(env,e)),NULL)); 
    return;
  case &Seq_s(s1,s2): 
    cf_prepass(env,s1); 
    cf_prepass(env,s2);
    return;
    // FIX: When we have init qualifier, use all init parameters on return.
  case &Return_s(NULL): return;
  case &Return_s(e): // e must be initialized
    cf_set_absexps(s,new List(use_exp(env,(exp_t)e),NULL)); 
    return;
  case &IfThenElse_s(e,s1,s2):
    let $(when_true,when_false) = abstract_guard(env,e);
    cf_set_absexps(s,new List(when_true,new List(when_false,NULL)));
    cf_prepass(env,s1);
    cf_prepass(env,s2);
    return;
  case &Do_s(s1,$(e,cont)): fallthru(e,cont,s1); //order irrelevant in this pass
  case &While_s($(e,cont),s1):
    let $(when_true,when_false) = abstract_guard(env,e);
    cf_set_absexps(s,new List(when_true,new List(when_false,NULL)));
    cf_prepass(env,s1);
    return;
  case &Break_s(_):    
  case &Continue_s(_): return;
  case &Goto_s(_,NULL): throw new Impossible("cf_prepass: goto w/o dest");
  case &Goto_s(_,dest): 
    // check we don't jump into scope -- this is totally orthogonal to 
    // the rest of control-flow checking, so we get it out of the way
    let my_encloser   = get_stmt_annot(s)->encloser;
    let dest_encloser = get_stmt_annot((stmt_t)dest)->encloser;
    while(dest_encloser != my_encloser) {
      let next_encloser = get_stmt_annot(my_encloser)->encloser;
      if(next_encloser == my_encloser) { // function body is own encloser
	Tcutil::terr(s->loc, "goto enters local scope or exception handler");
	break;
      }
      my_encloser = next_encloser;
    } 
    return;
  case &For_s(e1,$(e2,guard),$(e3,cont),s1): //e1,e3 need not be init
    let ae1 = meet_absexp(abstract_exp(env,e1));
    let $(when_true,when_false) = abstract_guard(env,e2);
    let ae3 = meet_absexp(abstract_exp(env,e3));
    cf_set_absexps(s, list(ae1, when_true, when_false, ae3));
    cf_prepass(env,s1);
    return;
  case &Switch_s(e,scs): // e must be init (FIX: interpret patterns)
    cf_set_absexps(s, new List(use_exp(env,e), cf_prepass_scs(env,scs)));
    return;

  case &Fallthru_s(es,_): // FIX: interpret patterns
    cf_set_absexps(s, new List(meet_absexp(use_exp_unordered(env,es)), NULL));
    return;

  case &Decl_s(&Decl(&Var_d(vd),_),s1):
    add_var_root(env,vd);
    if(vd->initializer != NULL) {
      let syn = abstract_exp(env,(exp_t)vd->initializer);
      let aexp = mkGroupAE(OrderedG, meet_absexp(syn),
			   mkAssignAE(mkLocalOp(vd), syn.absop));
      cf_set_absexps(s, new List(aexp, NULL));
    }
    cf_prepass(env,s1);
    return;
  case &Decl_s(&Decl(&Let_d(_,&Opt(vds),_,e,_),_),s1):
    // FIX: interpret patterns
    // FIX: in short term, need to special-case let x = e !!!
    for(; vds != NULL; vds = vds->tl)
      add_var_root(env,vds->hd);
    cf_set_absexps(s, new List(use_exp(env,e), NULL));
    cf_prepass(env,s1);
    return;
  case &Decl_s(&Decl(&Letv_d(vds),_),s1):
    for(; vds != NULL; vds = vds->tl)
      add_var_root(env,vds->hd);
    cf_prepass(env,s1);
    return;
  case &Label_s(_,s1): 
    cf_prepass(env,s1); 
    return;
  case &TryCatch_s(s1,scs):
    cf_prepass(env,s1);
    cf_set_absexps(s,cf_prepass_scs(env,scs));
    return;
  case &Region_s(tv,vd,body):
    add_var_root(env,vd);
    cf_prepass(env,body);
    return;
  case &Decl_s(_,_):    
  case &SwitchC_s(_,_): 
  case &Cut_s(_):       
  case &Splice_s(_): throw new Impossible("cf_prepass: bad stmt form");
  }
}

///////////////////////////// Analysis ///////////////////////////////

// Global control variables -- to be re-entrant, we'd need to replace this
// with a shared variable in the environment passed to cf_check_stmt
static bool iterate_cf_check = false;
static int  iteration_num    = 0;

struct AnalEnv {
  pinfo_dict_t<local_root_t> roots; // the "uninit leaves" versions
  bool        in_try;  // an optimization for the common case
  flow_info_t tryflow; // updated by UseAE and AssignAE, used by TryCatch_s
  place_set_t * all_changed; // NULL for not in unorderd so don't bother
};

// Sound KLUDGE: The changed should go on the destination, but it's easier
// to put it on the source and nobody is ever going to notice the difference
// in precision (it takes a goto or caught throw from an inner unordered
// context to an outer one, I think).  The fix is to keep all the changed
// lists in the env and find the right one for the dest (by following
// enclosers somehow), but again, it is a really strange thing.
void update_tryflow(analenv_t env, flow_info_t new_flow) {
  if(env->in_try)
    env->tryflow = join_flow(env->all_changed, new_flow, env->tryflow);
}

// Sound KLUDGE: same explanation as for update_tryflow above
// need to check for less than after the join b/c of the approximation
// else may not terminate.
static void update_flow(analenv_t env, stmt_t s, flow_info_t flow) { 
  let annot = get_stmt_annot(s);
  let new_flow = join_flow(env->all_changed, flow, annot->flow);
  if(!flow_lessthan_approx(new_flow, annot->flow)) {
    annot->flow = new_flow;
    if(annot->visited == iteration_num)
      iterate_cf_check = true;
  }
}

static cf_stmt_annot_t@ pre_stmt_check(analenv_t env, flow_info_t in_flow, 
				       stmt_t s) {
  let annot = get_stmt_annot(s);
  // merge in the flow we're passed with flow from non-local preds and 
  // earlier iterations
  annot->flow = join_flow(env->all_changed, in_flow, annot->flow);
  // keep the iteration count right
  ++annot->visited;
  assert(annot->visited == iteration_num);
  return annot;
}

static flow_info_t add_init_vars_flow(analenv_t env, flow_info_t flow,
				      list_t<vardecl_t,`r> vds) {
  switch(flow) {
  case BottomFL:   return BottomFL;
  case &InitsFL(d): 
    for(; vds != NULL; vds = vds->tl) {
      let root  = new VarRoot(vds->hd);
      let pinfo = assign_unknown_dict(AllIL, Dict::lookup(env->roots, root));
      d = Dict::insert(d, root, pinfo);
    }
    return new InitsFL(d);
  }
}

// To do: share VarRoot's to avoid re-allocation
static flow_info_t add_vardecls_flow(analenv_t env, flow_info_t flow,
				     list_t<vardecl_t,`r> vds) {
  switch(flow) {
  case BottomFL: return BottomFL;
  case &InitsFL(d): 
    for(; vds != NULL; vds = vds->tl) {
      let root = new VarRoot(vds->hd);
      d = Dict::insert(d, root, Dict::lookup(env->roots, root));
    }
    return new InitsFL(d);
  }
}

static $(flow_info_t,flow_info_t) 
cf_evalguard(analenv_t env, Position::seg_t loc, list_t<absexp_t> aes,
	     flow_info_t in_flow) {
  if(aes->hd == aes->tl->hd) { // optimize for common case
    let out_flow = eval_absexp(env, loc, aes->hd, in_flow);
    return $(out_flow,out_flow);
  }
  return $(eval_absexp(env, loc, aes->hd,     in_flow),
	   eval_absexp(env, loc, aes->tl->hd, in_flow));
}

// for now, pat_vars are initialized FIX WHEN WE INTERPRET PATTERNS
// also some unnecessary allocation here 
static flow_info_t cf_analyze_switch_clauses(analenv_t env,
					     list_t<switch_clause_t> scs, 
					     list_t<absexp_t> aes, 
					     flow_info_t in_flow) {
  for(; scs != NULL; scs = scs->tl) {
    let &Switch_clause(_,vds_opt,where_opt,body,_) = scs->hd;
    let body_inflow = add_vardecls_flow(env, in_flow, vds_opt->v);
    // for now immediately initialize them -- more allocation and 
    // WRONG WHEN WE INTERPRET PATTERNS
    body_inflow = add_init_vars_flow(env, body_inflow, vds_opt->v);

    flow_info_t body_outflow;
    if(where_opt != NULL) {
      let $(true_flow,false_flow) =
	cf_evalguard(env, ((exp_t)where_opt)->loc, aes,  body_inflow);
      aes     = aes->tl->tl;
      in_flow = false_flow;
      body_outflow = cf_analyze_stmt(env, body, true_flow);
    } else
      body_outflow = cf_analyze_stmt(env, body, body_inflow);
    switch(body_outflow) {
    case BottomFL: break;
    default: 
      // no need for a break/fallthru for the last case
      if(scs->tl == NULL)
	return body_outflow;
      else {
	// if the next case has pattern variables, we need an explicit fallthru
	// else just issue a warning
	if (scs->tl->hd->pat_vars->v != NULL)
	  Tcutil::terr(body->loc, "switch clause may implicitly fallthru");
	else 
	  Tcutil::warn(body->loc, "switch clause may implicitly fallthru");
	// in any case, we must update the flow there!
	update_flow(env, scs->tl->hd->body, body_outflow);
      }
      break;
    }
  }
  return BottomFL; // not reached if last case falls through
}

flow_info_t cf_analyze_stmt(analenv_t env, stmt_t s, flow_info_t in_flow) {
  let annot = pre_stmt_check(env,in_flow,s);
  in_flow = annot->flow;
  let aes = annot->absexps;

  switch(s->r) {
  case Skip_s: return in_flow;
    // FIX: when have init parameters, check they're init by "using" them here
  case &Return_s(NULL): return BottomFL;
  case &Return_s(e):    
    eval_absexp(env, e->loc, aes->hd, in_flow); 
    return BottomFL;
    
  case &Exp_s(e): return eval_absexp(env, e->loc, aes->hd, in_flow);

  case &Seq_s(s1,s2):
    return cf_analyze_stmt(env, s2, cf_analyze_stmt(env, s1, in_flow));

  case &IfThenElse_s(e,s1,s2):
    let $(true_flow,false_flow) = cf_evalguard(env, e->loc, aes, in_flow);
    return join_flow(env->all_changed,
		     cf_analyze_stmt(env, s1, true_flow),
		     cf_analyze_stmt(env, s2, false_flow));
  case &While_s($(e,cont),body):
    let e_inflow = pre_stmt_check(env,in_flow,cont)->flow;
    let $(true_flow,false_flow) = cf_evalguard(env, e->loc, aes, e_inflow);
    let body_outflow = cf_analyze_stmt(env, body, true_flow);
    update_flow(env, cont, body_outflow);
    return false_flow;
  case &Do_s(body,$(e,cont)):
    let body_outflow = cf_analyze_stmt(env, body, in_flow);
    let e_inflow = pre_stmt_check(env,body_outflow,cont)->flow;
    let $(true_flow,false_flow) = cf_evalguard(env, e->loc, aes, e_inflow);
    update_flow(env, body, true_flow);
    return false_flow;
  case &For_s(e1,$(e2,guard),$(e3,cont),body):
    let e1_outflow = eval_absexp(env, e1->loc, aes->hd, in_flow);
    let e2_inflow  = pre_stmt_check(env,e1_outflow,guard)->flow;
    let $(true_flow,false_flow) = cf_evalguard(env,e2->loc,aes->tl,e2_inflow);
    let body_outflow = cf_analyze_stmt(env, body, true_flow);
    let e3_inflow  = pre_stmt_check(env,body_outflow,cont)->flow;
    let e3_outflow = eval_absexp(env, e3->loc, aes->tl->tl->tl->hd, e3_inflow);
    update_flow(env, guard, e3_outflow);
    return false_flow;

    // eg. of when this can happen is when destination is end of function
  case &Break_s(NULL): return BottomFL;
  case &Fallthru_s(es,&destclause):
    // The gunk is because the next case's binding vars are still in scope!
    // FIX: WHEN WE INTERPRET PATTERNS
    let out_flow = eval_absexp(env, s->loc, aes->hd, in_flow);
    let ftvars = destclause->pat_vars->v;
    out_flow = add_vardecls_flow(env, out_flow, ftvars);
    out_flow = add_init_vars_flow(env, out_flow, ftvars);
    update_flow(env, (stmt_t)(destclause->body), out_flow);
    return BottomFL;
  case &Break_s(dest):    fallthru(dest);
  case &Continue_s(dest): fallthru(dest);
  case &Goto_s(_,dest):
    update_flow(env, (stmt_t)dest, in_flow);
    return BottomFL;

  case &Switch_s(e,scs):
    return cf_analyze_switch_clauses(env, scs, aes->tl,
				     eval_absexp(env,e->loc,aes->hd,in_flow));
    
  case &TryCatch_s(s,scs):
    // order very important here
    let &AnalEnv(_,old_in_try,old_tryflow,_) = env;
    env->in_try  = true;
    env->tryflow = in_flow;
    let s_outflow  = cf_analyze_stmt(env, s, in_flow); 
    let scs_inflow = env->tryflow;
    env->in_try  = old_in_try;
    env->tryflow = old_tryflow;
    // sound KLUDGE (see update_tryflow)
    update_tryflow(env, scs_inflow);
    let scs_outflow = cf_analyze_switch_clauses(env, scs, aes, scs_inflow);
    return join_flow(env->all_changed, s_outflow, scs_outflow);

    // Note: We don't need to add initialized vars as changed things
    //       because they won't escape to unordered siblings???
    
    // for var, add to dict as uninitialized before ae
    //   translation arleady does the initialization assignment!!
  case &Decl_s(&Decl(&Var_d(vd),_),s):
    let l = List(vd,NULL);
    let e_flow = add_vardecls_flow(env, in_flow, &l);
    let e = vd->initializer;
    if(e != NULL)
      e_flow = eval_absexp(env, ((exp_t)e)->loc, aes->hd, e_flow);
    return cf_analyze_stmt(env, s, e_flow);

    // for pat, add to dict as uninitialized before ae and then initialize
    //   after ae, translation assigns e to Unknown!
    // FIX WHEN WE INTERPRET PATTERNS!!!
  case &Decl_s(&Decl(&Let_d(_,&Opt(vds),_,e,_),_),s):
    let body_inflow =
      eval_absexp(env, e->loc, aes->hd, add_vardecls_flow(env, in_flow, vds));
    // THIS PART GOES AWAY WHEN WE INTERPRET PATTERNS
    body_inflow = add_init_vars_flow(env, body_inflow, vds);
    return cf_analyze_stmt(env, s, body_inflow);

  case &Decl_s(&Decl(&Letv_d(vds),_),s):
    return cf_analyze_stmt(env, s, add_vardecls_flow(env, in_flow, vds));

  case &Label_s(_,s): return cf_analyze_stmt(env,s,in_flow);

  case &Region_s(tv,vd,s):
    let vds = new List{vd,NULL};
    let body_inflow = add_vardecls_flow(env, in_flow, vds);
    body_inflow = add_init_vars_flow(env, body_inflow, vds);
    return cf_analyze_stmt(env, s, body_inflow);

  default: throw new Core::Impossible("cf_analyze_stmt -- bad stmt syntax"
                                      " or unimplemented stmt form");
  }
}

//////////////////////////// Post-pass //////////////////////////////

// Note: This is just a space optimization.  Out of laziness, we don't
//       traverse expressions to find nested statements (due to StmtExp_e),
//       so the space for such annotations leaks.
void cf_postpass(stmt_t s) {
  s->annot = EmptyAnnot;
  switch(s->r) {
  case &Seq_s(s1,s2): fallthru(s1,s2);
  case &IfThenElse_s(_,s1,s2):
    cf_postpass(s1);
    cf_postpass(s2);
    return;
  case &For_s(_,$(_,s2),$(_,s3),s1): 
    cf_postpass(s3); 
    fallthru(s1,s2);
  case &While_s($(_,s2),s1): fallthru(s1,s2);
  case &Do_s(s1,$(_,s2)): 
    cf_postpass(s2);
    fallthru(s1);
  case &Region_s(_,_,s1): fallthru(s1);
  case &Label_s(_,s1): fallthru(s1);
  case &Decl_s(_,s1):    
    cf_postpass(s1);
    return;
  case &TryCatch_s(s1,scs):
    cf_postpass(s1);
    fallthru(scs);
  case &Switch_s(_,scs):
    for(; scs != NULL; scs = scs->tl)
      cf_postpass(scs->hd->body);
    return;
  default:
    return;
  }
}

//////////////////////////// Top-level ////////////////////////////////
void cf_check_fun(fndecl_t fd) {
  //  fprintf(Stdio::stderr,"%s",*(*fd->name)[1]);
  absenv_t absenv = new AbsEnv(Dict::empty(local_root_cmp));
  let arg_vds = fd->param_vardecls->v;
  for(_ vds = arg_vds; vds != NULL; vds = vds->tl)
    add_var_root(absenv, vds->hd);
  cf_prepass(absenv,fd->body);

  // TO DO: account for init qualifier (add ThisIL for those params and
  //        check them on return and on fall off void)
  let analenv = new AnalEnv(absenv->all_roots, false, BottomFL, NULL);
  flow_info_t in_flow = new InitsFL(Dict::empty(local_root_cmp));
  in_flow = add_init_vars_flow(analenv, in_flow, arg_vds);

  flow_info_t out_flow = in_flow;
  iteration_num    = 0;
  iterate_cf_check = true;
  while(iterate_cf_check) {
    //    printf("\n");
    ++iteration_num;
    iterate_cf_check = false;
    out_flow = cf_analyze_stmt(analenv, fd->body, in_flow);
  }

  switch(out_flow) {
  case BottomFL: break;
  default: 
    if(fd->ret_type != VoidType)
      Tcutil::terr(fd->body->loc, 
		   "function may complete without returning a value");
    break;
  }
  cf_postpass(fd->body);
}

void cf_check(list_t<decl_t> ds) {
  for(; ds != NULL; ds = ds->tl) {
    switch(ds->hd->r) {
    case &Fn_d(fd):           cf_check_fun(fd); break;
    case &ExternC_d(ds2):     fallthru(ds2);
    case &Using_d(_,ds2):     fallthru(ds2);
    case &Namespace_d(_,ds2): cf_check(ds2); break;
    default: break;
    }
  }
}
