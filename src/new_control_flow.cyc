/* Control flow analysis.
   Copyright (C) 2001 Dan Grossman, Greg Morrisett
   This file is part of the Cyclone compiler.

   The Cyclone compiler is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   The Cyclone compiler is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with the Cyclone compiler; see the file COPYING. If not,
   write to the Free Software Foundation, Inc., 59 Temple Place -
   Suite 330, Boston, MA 02111-1307, USA. */

// TO DO: Get patterns right rather than require fully initialized
//        At very least, special case let x = e !!

// TO DO: complain about dereference of definitely NULL -- cannot do this
// until we've reached a fixpoint!!!

// TO DO: Exploit @ types to know NotZero!

// KLUDGE: For unions, we just pretend its initialized.  Since you can
// only read bits out, safety is not compromised.

// The previous pass (type-checking) sets up:
// * decorating all stmts with their correct non_local_preds
// * decorating each stmt with CFAnnot
// * setting all the encloser fields (note the list ends with a self-loop,
//   not a NULL!
// (The latter two activities are performed via calls to set_encloser.)

#include <core.h>
#include <list.h>
#include <set.h>
#include <dict.h>
#include <string.h>
#include <hashtable.h>
#include "absyn.h"
#include "tcutil.h"
#include "evexp.h"
#include "cf_flowinfo.h"
#include "new_control_flow.h"
#include "rgnorder.h"

// for debugging
#include "absynpp.h"
#include <stdio.h>

using List;
using Absyn;
using CfFlowInfo;
using Absynpp;
namespace NewControlFlow;

typedef Dict::dict_t<`a,`b> dict_t<`a,`b>;
typedef Position::seg_t     seg_t;

//////////////////////////// Statement Decoration //////////////////////////
struct CFStmtAnnot {
  stmt_t encloser; // for checking goto-scope -- no other use
  int    visited;  // for detecting need to iterate
  // we now use a separate hash table for the flow info
  // flow_t flow;     // flow to merge in when we check again
};
typedef struct CFStmtAnnot cf_stmt_annot_t;
xtunion AbsynAnnot { static CFAnnot(cf_stmt_annot_t); };

// to be used by the type-checking pass to get things set up for us
// must be called on EVERY stmt in the abstract syntax (even the dummy ones)
void set_encloser(stmt_t enclosee, stmt_t encloser) {
  enclosee->annot = new CFAnnot(CFStmtAnnot(encloser, 0));
}

///////////////////////////// Analysis ///////////////////////////////

// FIX: Add some memoization for commonly used absRVal_t values, eg.
// fully initialized and fully uninitialized structs.  Also for root_t value.
// FIX: Assigning a pointer to an int shouldn't cause anything to escape.

// Note: w/o passing down whether we're in a "pointer context", we'll 
// unnecessarily escape points-to on branches of conditional expressions.
// Note: for *(e1 ? e2 : e3) we're requiring e2 and e3 to be all-init.
struct AnalEnv<`r::R> {
  region_t<`r>  r;
  flow_env_t<`r> fenv;
  bool          iterate_again; // set to true when a visited flow is updated
  int           iteration_num; // update annotations with this on each visit
  bool          in_try;      // an optimization for the common case
  flow_t<`r>    tryflow;     // updated by any flow change while in a try-block
  place_set_t<`r>*`r all_changed;// NULL for "not in unorderd so don't bother"
  bool          noreturn;    // true when function is "noreturn"
  list_t<place_t<`r,`r>,`r> param_roots;
  Hashtable::table_t<stmt_t,flow_t<`r>@`r,`r> flow_table;
};
typedef struct AnalEnv<`r> @`r analenv_t<`r>;

static flow_t<`r> anal_stmt(analenv_t<`r>, flow_t<`r>, stmt_t);
static flow_t<`r> anal_decl(analenv_t<`r>, flow_t<`r>, decl_t);
static $(flow_t<`r>,absLval_t<`r>) anal_Lexp(analenv_t<`r>, flow_t<`r>, exp_t);//takes all exps!
static $(flow_t<`r>,absRval_t<`r>) anal_Rexp(analenv_t<`r>, flow_t<`r>, exp_t);
static $(flow_t<`r>,flow_t<`r>)    anal_test(analenv_t<`r>, flow_t<`r>, exp_t);
static list_t<place_t<`r,`r>,`r> noalias_ptrs_rec(analenv_t<`r> env,
						  place_t<`r,`r> p,
						  type_t t);

static cf_stmt_annot_t @ get_stmt_annot(stmt_t s) {
  switch(s->annot) {
  case &CFAnnot(*x): return x;
  default: throw new Core::Impossible("ControlFlow -- wrong stmt annotation");
  }
}

static flow_t<`r>@`r get_stmt_flow(analenv_t<`r> env, stmt_t s) {
  flow_t<`r>@`r*`r sflow = Hashtable::lookup_opt(env->flow_table, s);
  if (sflow == NULL) {
    flow_t@`r res = rnew(env->r) BottomFL;
    Hashtable::insert(env->flow_table, s, res);
    return res;
  }
  return *sflow;
}

static $(cf_stmt_annot_t@,flow_t<`r>@`r) pre_stmt_check(analenv_t<`r> env, flow_t<`r> inflow, stmt_t s){
  let annot = get_stmt_annot(s);
  let sflow = get_stmt_flow(env,s);
  // join inflow with flow from non-local preds and earlier iterations
  *sflow = join_flow(env->fenv, env->all_changed, inflow, *sflow, true);
  // keep the iteration count right, cannot increment because of StmtExp
  // in an unordered position!
  annot->visited = env->iteration_num;
  return $(annot,sflow);
}

static int get_field_index_fs(list_t<aggrfield_t> fs, field_name_t f) {
  int n = 0;
  for (; fs; fs = fs->tl) {
    let f2 = fs->hd->name;
    if (strptrcmp(f2,f) == 0) return n;
    n = n+1;
  }
  throw new Core::Impossible(aprintf("get_field_index_fs failed: %s",*f));
}

static int get_field_index(type_t t, field_name_t f) {
  switch (Tcutil::compress(t)) {
  case &AggrType(AggrInfo(info,_)):
    let fs = get_known_aggrdecl(info)->impl->fields;
    fallthru(fs);
  case &AnonAggrType(_,fs):
    return get_field_index_fs(fs, f);
  default: 
    throw new Core::Impossible(aprintf("get_field_index failed: %s",
                                       Absynpp::typ2string(t)));
  }
}

// Sound KLUDGE: The changed should go on the destination, but it's easier
// to put it on the source and nobody is ever going to notice the difference
// in precision (it takes a goto or caught throw from an inner unordered
// context to an outer one, I think).  The fix is to keep all the changed
// lists in the env and find the right one for the dest (by following
// enclosers somehow), but again, it is a really strange thing.
// Another KLUDGE: may_consume info should never be relevant in a
// catch block, so we clear it here, rather than cleaning it up elsewhere.
static void update_tryflow(analenv_t<`r> env, flow_t<`r> new_flow) {
  if(env->in_try) {
    DEBUG_PRINT("update_tryflow: before flow:\n");
    DEBUG_PRINT_F(print_flow,env->tryflow);
    DEBUG_PRINT("\n");
    DEBUG_PRINT("update_tryflow: new flow:\n");
    DEBUG_PRINT_F(print_flow,new_flow);
    DEBUG_PRINT("\n");
    env->tryflow = join_flow(env->fenv, env->all_changed, new_flow, env->tryflow, true);
    let $(ConsumeInfo(c,mc),_) = save_consume_info(env->fenv, env->tryflow, 
						   false);
    env->tryflow = restore_consume_info(env->tryflow, ConsumeInfo(c,NULL));
    DEBUG_PRINT("update_tryflow: joined flow:\n");
    DEBUG_PRINT_F(print_flow,env->tryflow);
    DEBUG_PRINT("\n");
  }    
}

// Sound KLUDGE: same explanation as for update_tryflow above
// need to check for less than after the join b/c of the approximation
// else may not terminate.
static void update_flow(analenv_t<`r> env, stmt_t s, flow_t<`r> flow) { 
  let annot    = get_stmt_annot(s);
  let sflow    = get_stmt_flow(env,s);
  let new_flow = join_flow(env->fenv, env->all_changed, flow, *sflow, true);
  if(!flow_lessthan_approx(new_flow, *sflow)) {
    DEBUG_PRINT("update_flow for |%s|: flow changed\n*sflow=\n",
		Absynpp::stmt2string(s));
    DEBUG_PRINT_F(print_flow,*sflow);
    DEBUG_PRINT("\njoined flow (> annot_flow):\n");
    DEBUG_PRINT_F(print_flow,new_flow);
    DEBUG_PRINT("\n");
    *sflow = new_flow;
    DEBUG_PRINT("update_flow: annot->visited=%d, iteration_num=%d, *sflow=",
		annot->visited, env->iteration_num);
    DEBUG_PRINT_F(print_flow,*sflow);
    if(annot->visited == env->iteration_num) {
      DEBUG_PRINT("update_flow: will iterate again\n");
      env->iterate_again = true;
    }
  }
}

static flow_t<`r> add_vars(flow_env_t<`r> fenv,
                           flow_t<`r> inflow,list_t<vardecl_t> vds,
                           absRval_t<`r> leafval, Position::seg_t loc) {
  switch(inflow) {
  case BottomFL: return BottomFL;
  case ReachableFL(d,relns,cinfo): 
    for(; vds != NULL; vds = vds->tl) {
      let root = rnew(fenv->r) VarRoot(vds->hd);
      d = Dict::insert(d,root,typ_to_absrval(fenv,vds->hd->type,leafval));
//        if (contains_region(UniqueRgn_k,vds->hd->type))
//  	update_place_set(unique_places, new Place(root,NULL), loc);
    }
    return ReachableFL(d,relns,cinfo);
  }
}

// not in use currently; planning to use to observe when unique variables
// are not getting freed so we can signal a warning
static void remove_vars(flow_env_t<`r> fenv,
                        flow_t<`r> outflow, place_set_t<`r> *out_unique_places,
			place_set_t<`r> old_unique_places) {
  // for all variables in out_unique_places not in c, print a warning
  let $(ConsumeInfo(c,_),_) = save_consume_info(fenv,outflow,false);
  region tmp {
    let iter = Dict::make_iter(tmp,*out_unique_places);
    let elem = *Dict::rchoose(tmp,*out_unique_places);
    while(Iter::next(iter,&elem)) {
      let p = elem[0];
      if (!Dict::member(c,p))
	Tcutil::terr(elem[1],"Failed to consume unique variable %s",
		     place_err_string(p));
    }
  }
  // restore the variable info
  *out_unique_places = old_unique_places;
}

// when using an r-value, we also consume any variables on the consume list.
static flow_t<`r> use_Rval(analenv_t<`r> env, seg_t loc, flow_t<`r> inflow, absRval_t<`r> r){
  switch(inflow) {
  case BottomFL: return BottomFL;
  case ReachableFL(d,relns,cinfo):
    if(initlevel(d,r) != AllIL)
      Tcutil::terr(loc,"expression may not be fully initialized");
    let ans_d = escape_deref(env->fenv, d, env->all_changed, r);
    if(d.t == ans_d.t) return inflow;
    let ans = ReachableFL(ans_d,relns,cinfo);
    update_tryflow(env, ans);
    return ans;
  }
}

static $(flow_t<`r>,list_t<absRval_t<`r>,`rgn>) 
  anal_unordered_Rexps(region_t<`rgn> rgn,
                       analenv_t<`r> env,
                       flow_t<`r> inflow,
                       list_t<exp_t> es,
                       bool arg1_unconsumed) {
  if(es == NULL)
    return $(inflow, NULL);
  if(es->tl == NULL) {
    let $(f,r) = anal_Rexp(env,inflow,es->hd);
    return $(f, rnew(rgn) List(r,NULL));
  }
  place_set_t * outer_all_changed = env->all_changed;
  place_set_t this_all_changed; // keep separate b/c we iterate
  flow_t old_inflow;
  flow_t outflow;
  list_t<absRval_t,`rgn> rvals;
  let $(saved_cinfo, inflow) = save_consume_info(env->fenv,inflow,true);
  consume_t outflow_consume = { env->fenv->mt_place_set, NULL };
  bool init_consume = false;
  do { // unnecessarily recomputes rvals each time
    this_all_changed = env->fenv->mt_place_set;
    // need to reset consume stuff on each iteration
    inflow = restore_consume_info(inflow,saved_cinfo);
    // wouldn't need to peel off the head if we had a TopFL
    env->all_changed = rnew(env->r) env->fenv->mt_place_set;
    let $(f,r) = anal_Rexp(env,inflow,es->hd);
    outflow = f;
    rvals = rnew(rgn) List(r,NULL);
    this_all_changed = union_place_set(this_all_changed,
				       *env->all_changed, false);
    // if the first argument is special (e.g. the source pointer of a
    // subscript), do not consume its first argument
    if (arg1_unconsumed) {
      switch (outflow) {
      case BottomFL: break;
      case ReachableFL(d,r,c):
	outflow = 
	  ReachableFL(d,r,ConsumeInfo(c.consumed,saved_cinfo.may_consume));
      }
    }
    for(_ es2 = es->tl; es2 != NULL; es2 = es2->tl) {
      env->all_changed = rnew(env->r) env->fenv->mt_place_set;
      let $(f,r) = anal_Rexp(env,inflow,es2->hd);
      rvals = rnew(rgn) List(r,rvals);
      outflow = after_flow(env->fenv, &this_all_changed, outflow, f, 
			   this_all_changed, *env->all_changed);
      this_all_changed = union_place_set(this_all_changed, *env->all_changed,
					 false);
    }
    // save/restore the consume information to terminate
    let $(c,_) = save_consume_info(env->fenv, outflow, false);
    if (init_consume) {
#ifdef SANITY
      if (consume_approx(c, outflow_consume)) {
	DEBUG_PRINT("sanity consumed: ");
	DEBUG_PRINT_F(print_place_set,outflow_consume.consumed);
	DEBUG_PRINT("\ncurrent consumed: ");
	DEBUG_PRINT_F(print_place_set,c.consumed);
	DEBUG_PRINT("\nsanity may_consume: ");
	DEBUG_PRINT_F(print_place_list,outflow_consume.may_consume);
	DEBUG_PRINT("\ncurrent may_consume: ");
	DEBUG_PRINT_F(print_place_list,c.may_consume);
	DEBUG_PRINT("\n");
	Tcutil::impos("anal_unordered_exps failed to preserve consumed info");
      }
#endif
      old_inflow = restore_consume_info(inflow, outflow_consume);
    }
    else
      old_inflow = inflow;
    init_consume = true;
    outflow_consume = c;
    // need to check for less than after the join b/c of the approximation
    // else may not terminate.
    inflow = join_flow(env->fenv,outer_all_changed,inflow,outflow,true);
//      DEBUG_PRINT("anal_unordered: old_inflow=\n");
//      DEBUG_PRINT_F(print_flow,old_inflow);
//      DEBUG_PRINT("anal_unordered: joined flow=\n");
//      DEBUG_PRINT_F(print_flow,inflow);
  } while(!flow_lessthan_approx(inflow,old_inflow));
  if(outer_all_changed == NULL)
    env->all_changed = NULL;
  else
    env->all_changed = rnew(env->r) union_place_set(*outer_all_changed,
                                                    this_all_changed, false);
  update_tryflow(env,outflow);
  return $(outflow,imp_rev(rvals));
}

// though the name doesn't indicate it, this is fine for the size primop too
// the point is we don't read through pointers, so nothing escapes.
static $(flow_t<`r>,absRval_t<`r>) 
anal_use_ints(analenv_t<`r> env, flow_t<`r> inflow,
              list_t<exp_t> es, bool arg1_unconsumed) {
  region rgn {
    let $(afterflow, rvals) =
      anal_unordered_Rexps(rgn,env,inflow,es,arg1_unconsumed);
    switch(afterflow) {
    case ReachableFL(d,_,_): 
      for(; rvals != NULL; rvals = rvals->tl, es = es->tl)
        if(initlevel(d,rvals->hd)==NoneIL)
          Tcutil::terr(es->hd->loc, "expression may not be initialized");
      break;
    case BottomFL: break;
    }
    return $(afterflow, env->fenv->unknown_all);
  }
}

// Called from anal_deref* when anal_Rexp([inflow],[e]) yields
// $(UnknownR([il]),[outflow]) where [il] > NoneIL.  Used to generate
// a new lval for that expression and assign to it a new rval that is
// assumed to be not zero, by virtue of the dereference.  We can get
// the lval this way only because f and the flow returned by anal_Lexp
// will not differ w.r.t. must-point-to information.  i.e. we should
// be called with the inflow the caller used as an *argument* to
// anal_Rexp Also: the result of anal_Rexp on e (before calling this)
// MUST be Unknown, not Esc! or it would be unsound to generate a
// place for it.
static flow_t<`r> 
notzero(analenv_t<`r> env, flow_t<`r> inflow, flow_t<`r> outflow,
        exp_t e, initlevel_t il) {
//   fprintf(stderr,"in notzero for exp |%s|\n",Absynpp::exp2string(e));
  DEBUG_PRINT("inflow=\n");
  DEBUG_PRINT_F(print_flow,inflow);
  switch(outflow) {
  case BottomFL: return outflow;
  case ReachableFL(d,relns,cinfo):
    switch(anal_Lexp(env,inflow,e)[1]) {
    case UnknownL: 
      DEBUG_PRINT("Got UnknownL, outflow=\n");
      DEBUG_PRINT_F(print_flow,outflow);
      return outflow;
    case PlaceL(p): // okay b/c p can't be escaped (it's Unknown) 
      DEBUG_PRINT("Got place ");
      DEBUG_PRINT_F(print_place,p);
      absRval_t nzval = il==AllIL ? NotZeroAll : NotZeroThis;
      let outflow = ReachableFL(assign_place(env->fenv,e->loc,d,env->all_changed,
					     p,nzval),relns,cinfo);
      DEBUG_PRINT("outflow=\n");
      DEBUG_PRINT_F(print_flow,outflow);
      return outflow;
    }
  }
}

// Called from anal_test when anal_Rexp([inflow],[e]) yields
// $(UnknownR([il]),[outflow]) where [il] > NoneIL. Used to generate a
// new place [p] for that expression and assign to it a new rval that
// is either zero or notzero if the place is unaliased.
static $(flow_t<`r>,flow_t<`r>) 
splitzero(analenv_t<`r> env, flow_t<`r> inflow, flow_t<`r> outflow,
          exp_t e, initlevel_t il) {
  switch(outflow) {
  case BottomFL: return $(outflow,outflow);
  case ReachableFL(d,relns,cinfo):
    switch(anal_Lexp(env,inflow,e)[1]) {
    case UnknownL: return $(outflow,outflow);
    case PlaceL(p): // okay b/c p can't be escaped (it's Unknown) 
      absRval_t nzval = il==AllIL ? NotZeroAll : NotZeroThis;
      return 
        $(ReachableFL(assign_place(env->fenv,e->loc,d,env->all_changed,
                                   p,nzval),relns,cinfo),
          ReachableFL(assign_place(env->fenv,e->loc,d,env->all_changed,p,Zero),
                      relns,cinfo));
    }
  }
}

// same comments as for previous function, only does anything if r2 is TagCmps
// ASSUMES all cmp primops are Lt, Lte, or Eq
static flow_t<`r> if_tagcmp(analenv_t<`r> env, flow_t<`r> flow, exp_t e1, 
                            absRval_t<`r> r1,  primop_t p,  absRval_t<`r> r2) {
  switch(flow) {
  case BottomFL: return flow;
  case ReachableFL(d,relns,cinfo):
    switch (r2) {
    case &TagCmps(cl2):
      switch(anal_Lexp(env,flow,e1)[1]) {
      case UnknownL: return flow;
      case PlaceL(pl):
	list_t new_cl;
	switch(r1) { 
	case &TagCmps(cl1): new_cl = cl1; break;
	  // some choice for these whether to use tags or not
	case &UnknownR(AllIL):
	case Zero:
	case NotZeroAll: new_cl = NULL; break; 
	default: return flow;
	}
	
	// see assumption above!
	for(; cl2 != NULL; cl2 = cl2->tl) {
	  primop_t new_cmp;
	  switch($(p,cl2->hd->cmp)) {
	  case $(Lt,_):
	  case $(_,Lt):  new_cmp = Lt; break;
	  case $(Eq,Eq): new_cmp = Eq; break;
	  default: new_cmp = Lte; break;
	  }
	  new_cl = 
            rnew(env->r) List(rnew(env->r) TagCmp(new_cmp, cl2->hd->bd), new_cl);
	}
	return ReachableFL(assign_place(env->fenv,e1->loc,d,
                                        env->all_changed,pl,
                                        rnew(env->r) TagCmps(new_cl)),
			       relns,cinfo);
      }
    default: return flow;
    }
  }
}

static xtunion AbsynAnnot.NotZero mt_notzero_v = NotZero(NULL);
static xtunion AbsynAnnot.UnknownZ mt_unknownz_v = UnknownZ(NULL);

// Note: correct for e1 an array b/c r won't be AddressOf??
// FIX: Important place to memoize type_to_absrval calls (b/c StructArrow
//      calls this.)  
static $(flow_t<`r>,absRval_t<`r>) 
  anal_derefR(analenv_t<`r> env, flow_t<`r> inflow,
              flow_t<`r> f, exp_t e, absRval_t<`r> r) {

  switch(Tcutil::compress(e->topt->v)) {
  case &PointerType(PtrInfo(elttype,_,PtrAtts(_,_,bd,zt,_))):
    switch(f) {
    case BottomFL: 
      return $(f,typ_to_absrval(env->fenv,elttype,env->fenv->unknown_all));
    case ReachableFL(outdict,relns,_):
      // else cannot be known: FIX: determine notzero as appropriate
      if(Tcutil::is_bound_one(bd)) {
	switch(r) {
	case NotZeroAll: 
	case NotZeroThis: 
          switch (e->annot) {
          case &NotZero(relns2): 
            if (!same_relns(relns,relns2)) fallthru;
            break;
          default:
            // if e isn't a subscript, we don't need the relns
            switch (e->r) {
            case &Subscript_e(_,_):
              e->annot = new NotZero(copy_relns(Core::heap_region,relns)); 
              break;
            default:
              e->annot = &mt_notzero_v;
              break;
            }
            break;
          }
	  break;
	case &AddressOf(p): 
          switch (e->annot) {
          case &NotZero(relns2):
            if (!same_relns(relns,relns2)) fallthru;
            break;
          default:
            // if e isn't a subscript, we don't need th relns
            switch (e->r) {
            case &Subscript_e(_,_):
              e->annot = new NotZero(copy_relns(Core::heap_region,relns)); 
              break;
            default:
              e->annot = &mt_notzero_v;
              break;
            }
            break;
          }
	  return $(f,lookup_place(outdict,p));
	case Zero: 
	  e->annot = IsZero;
	  return $(BottomFL,typ_to_absrval(env->fenv,elttype,
                                           env->fenv->unknown_all));
	case &UnknownR(il): f = notzero(env,inflow,f,e,il); fallthru;
	default: 
          switch (e->r) {
          case &Subscript_e(_,_):
            e->annot = new UnknownZ(copy_relns(Core::heap_region,relns));
            break;
          default:
            e->annot = &mt_unknownz_v;
            break;
          }
          break;
	}
      } else {
        switch (e->annot) {
        case &UnknownZ(relns2):
          if (!same_relns(relns,relns2)) fallthru;
          break;
        default:
          e->annot = new UnknownZ(copy_relns(Core::heap_region,relns)); // FIX: too conservative?
          break;
        }
      }
      switch(initlevel(outdict,r)) {
      case NoneIL:
	Tcutil::terr(e->loc,"dereference of possibly uninitialized pointer");
	fallthru;
      case AllIL:  
        return $(f,typ_to_absrval(env->fenv,elttype,env->fenv->unknown_all));
      case ThisIL: 
        return $(f,typ_to_absrval(env->fenv,elttype,env->fenv->unknown_none));
      }
    }
  default: throw new Core::Impossible("right deref of non-pointer-type");
  }
}

// we've performed e1[e2] -- if this is of the form x[i], then add
// i < x.size to the relations.
static relns_t<`r> add_subscript_reln(region_t<`r> rgn, 
                                      relns_t<`r> relns, exp_t e1, exp_t e2) {
  switch (e1->r) {
  case &Var_e(_,&Pat_b(x)):   fallthru(x);
  case &Var_e(_,&Local_b(x)): fallthru(x);
  case &Var_e(_,&Param_b(x)): fallthru(x);
  case &Var_e(_,&Global_b(x)):
    if (!x->escapes)
      switch (e2->r) {
      case &Var_e(_,&Pat_b(i)):   fallthru(i);
      case &Var_e(_,&Local_b(i)): fallthru(i);
      case &Var_e(_,&Param_b(i)): fallthru(i);
      case &Var_e(_,&Global_b(i)):
        if (!i->escapes) {
          // we have x[i] -- add i < x.size to relns if not already present.
          bool found = false;
          for (let rs = relns; rs != NULL; rs = rs->tl) {
            let r = rs->hd;
            if (r->vd == i)
              switch (r->rop) {
              case LessNumelts(v) && v == x: return relns;
              default: continue;
              }
          }
          if (!found) 
            return rnew(rgn) List(rnew(rgn) Reln(i,LessNumelts(x)),relns);
        }
        return relns;
      default: return relns;
      }
    else return relns;
  default: return relns;
  }
}

// Given place [p] having type [t], if [p] is pointed to by a no-alias
// pointer or is an aggregate containing no-alias pointers, we add all
// of the relevant places to the may_consume list.  If the places argument
// is non-NULL, we return the places by reference.  The caller will
// invalidate these locations if necessary.  Note that a value can
// appear on the may_consume list multiple times; this will only be an
// error in the event the list is actually consumed.
static consume_t<`r> may_consume_place(analenv_t<`r> env,
				       consume_t<`r> cinfo,
				       place_t<`r,`r> place, 
				       type_t t,
				       list_t<place_t<`r,`r>,`r> *ps) {
  let fenv = env->fenv;
  let places = noalias_ptrs_rec(env, place, t);
  if (ps != NULL) *ps = places;
  if (places == NULL) return cinfo;
#ifdef DEBUG_FLOW
  let x = places;
  DEBUG_PRINT(" considering place ");
  DEBUG_PRINT_F(print_place,place);
  DEBUG_PRINT("\n");
  while (x != NULL) {
    DEBUG_PRINT(" adding ");
    DEBUG_PRINT_F(print_place,x->hd);
    DEBUG_PRINT("to may_consume\n");
    x = x->tl;
  }
#endif
  cinfo.may_consume = List::rmerge(fenv->r,place_cmp, places,
				   cinfo.may_consume);
  return cinfo;
}

// Calls may_consume_place for the expression [e].
static flow_t<`r> may_consume_exp(analenv_t<`r> env,
				  flow_t<`r> inflow,
				  exp_t e) {
  if (Tcutil::is_noalias_path(e)) {
    let fenv = env->fenv;
    let $(_,lval) = anal_Lexp(env,inflow,e);
    switch ($(lval,inflow)) {
    case $(PlaceL(place),ReachableFL(outdict,relns,cinfo)): 
      let c = may_consume_place(env,cinfo,place,e->topt->v,NULL);
      return ReachableFL(outdict,relns,c);
    default: 
      fprintf(stderr,"Oops---no location for noalias_path |%s|\n",
	      Absynpp::exp2string(e));
      return inflow;
    }
  }
  return inflow;
}

static consume_t<`r> consume_place(analenv_t<`r> env,
				   place_t<`r,`r> p,
				   consume_t<`r> cinfo,
				   flowdict_t<`r> outdict,
				   Position::seg_t loc) {
  // see if we are clobbering an unconsumed unique pointer;
  // signal warning if so
  if (!Dict::member(cinfo.consumed,p)) {
    let &Place(root,fs) = p;
    // only signal a warning if the variable is not uninitialized
    // and not NULL
    absRval_t<`r> rval = Zero;
    if (Dict::lookup_bool(outdict,root,&rval) &&
	initlevel(outdict,rval)!=NoneIL && rval != Zero) {
      switch (root) {
      case &VarRoot(vd):
	let s = Absynpp::qvar2string(vd->name);
	if (fs == NULL)
	  Tcutil::warn(loc,"may clobber unique pointer %s", s);
	else
	  Tcutil::warn(loc,"may clobber unique pointer contained in %s", s);
	break;
      default:
	Tcutil::impos("warning locations not for VarRoots");
      }
    }
  }
    
  // if we are not in a unordered expression context, we can
  // remove the root, if present, from consumed set.  We check
  // the error context to ensure we terminate (otherwise we will
  // flip-flop in adding/removing a member from the flow on
  // certain loop-based errors).
  if (env->all_changed == NULL) {
#ifdef DEBUG_FLOW
    if (Dict::member(cinfo.consumed,p)) {
      DEBUG_PRINT("  assign lhs; unconsumed ");
      DEBUG_PRINT_F(print_place,p);
      DEBUG_PRINT("\n");
    }
#endif
    cinfo.consumed = Dict::rdelete(env->fenv->r,cinfo.consumed,p);
  }
  return cinfo;
}

// given an assignment [e] = e2 represented by place [p] in a
// reachable flow with environment [env], dictionary [outdict], and
// consume info [cinfo]: adjust the consume status of [p] and [e] in
// [cinfo] and return it.
static consume_t<`r> consume_assignment(analenv_t<`r> env,
					place_t<`r,`r> p,
					consume_t<`r> cinfo,
					flowdict_t<`r> outdict,
					exp_t e) {
  if (Tcutil::is_noalias_path(e)) {
    let fenv = env->fenv;
    // add lhs to consume list if it's unique and is a unique path
    let ps = NULL;
    DEBUG_PRINT(" consuming assignment for place ");
    DEBUG_PRINT_F(print_place,p);
    DEBUG_PRINT("\n");
    cinfo = may_consume_place(env, cinfo, p, e->topt->v, &ps);
    while (ps != NULL) {
      cinfo = consume_place(env,ps->hd,cinfo,outdict,e->loc);
      ps = ps->tl;
    }
  }
  return cinfo;
}

// given an aggregate place [p], and a list of types [ts] for the fields
// of [p], generate a list of places reachable from [p] that are
// no-alias pointers.
static list_t<place_t<`r,`r>,`r>
noalias_ptrs_aux(analenv_t<`r> env, place_t<`r,`r> p, list_t<type_t> ts) {
  list_t<place_t<`r,`r>,`r> l = NULL;
  let &Place(root,fields) = p;
  for (int fld = 0; ts != NULL; fld++, ts = ts->tl) {
    let t = ts->hd;
    if (Tcutil::is_noalias_pointer(t)) {
      let flds = rappend (env->r, fields, rlist(env->r, fld));
      l = rmerge (env->r, place_cmp,
		  rnew(env->r) List(rnew (env->r) 
				    Place(root,flds),NULL),l);
    } else {
      if (is_aggr_type(t)) {
	let flds = rappend (env->r, fields, rlist(env->r, fld));
	let p2 = rnew (env->r) Place(root,flds);
	l = rmerge(env->r,place_cmp,l,noalias_ptrs_rec(env,p2,t));
      }
    }
  }
  return l;
}

// given an aggregate place [p] having type [t], generate a list of
// places reachable from [p] that are no-alias pointers.
// FIX: make tail-recursive
static list_t<place_t<`r,`r>,`r> noalias_ptrs_rec(analenv_t<`r> env,
						  place_t<`r,`r> p,
						  type_t t) {
  if (Tcutil::is_noalias_pointer(t)) 
    return rnew (env->r) List(p,NULL);

  switch (Tcutil::compress(t)) {
  case &TupleType(qts):
    let ts = NULL;
    while (qts != NULL) {
      ts = rnew(env->r) List((*qts->hd)[1],ts);
      qts = qts->tl;
    }
    ts = imp_rev(ts);
    return noalias_ptrs_aux(env,p,ts);
  case &AnonAggrType(_,fs):
    let ts = NULL;
    while (fs != NULL) {
      ts = rnew(env->r) List(fs->hd->type,ts);
      fs = fs->tl;
    }
    ts = imp_rev(ts);
    return noalias_ptrs_aux(env,p,ts);
  case &AggrType(AggrInfo(KnownAggr(adp),inst_ts)):
    if ((*adp)->impl == NULL) return NULL;
    else {
      let ts = NULL;
      region rgn {
	let inst = List::rzip(rgn,rgn,(*adp)->tvs,inst_ts);
	let x = (*adp)->impl->fields;
	while (x != NULL) {
	  ts = rnew(env->r) List(Tcutil::rsubstitute(rgn,inst,x->hd->type),ts);
	  x = x->tl;
	}
      }
      ts = imp_rev(ts);
      return noalias_ptrs_aux(env,p,ts);
    }
  case &AggrType(AggrInfo(UnknownAggr(_,_),_)):
    Tcutil::impos("got unknown aggr in noalias_ptrs_rec");
  case &TunionType(_):
    // For tunions, we consider the entire tunion to be a place,
    // rather than considering the individual fields.  Tunions
    // are consumed when they are switch'ed and when they
    // copied (as is normal).
    if (Tcutil::is_noalias_pointer_or_aggr(t)) 
      return rnew (env->r) List(p,NULL);
    else
      return NULL;
  case &TunionFieldType(TunionFieldInfo(tinfo,inst_ts)):
    switch (tinfo) {
    case UnknownTunionfield(_):
      Tcutil::impos("got unknown tunion field in noalias_ptrs_rec");
    case KnownTunionfield(td,fld):
      let ts = NULL;
      region rgn {
	let inst = List::rzip(rgn,rgn,td->tvs,inst_ts);
	let typs = fld->typs;
	while (typs != NULL) {
	  ts = rnew (env->r) List(Tcutil::rsubstitute(rgn,inst,(*typs->hd)[1]),
				  ts);
	  typs = typs->tl;
	}
      }
      ts = imp_rev(ts);
      return noalias_ptrs_aux(env,p,ts);
    }
  default: return NULL;
  }
}

// called once for each legal flow in an assignment: left to right order,
// and right to left order.  See anal_Rexp's AssignOp_e case below.
static $(flow_t<`r>,absRval_t<`r>) 
  do_assign(flow_env_t<`r> fenv,
	    analenv_t<`r> env,
	    flow_t<`r> outflow,
	    exp_t lexp, absLval_t<`r> lval,
	    exp_t rexp, absRval_t<`r> rval,
	    Position::seg_t loc) {

  outflow = consume_unique_rvals(loc, outflow); // consume rhs
  switch(outflow) {
  case BottomFL:
    DEBUG_PRINT("leaving AssignOp_e\n");
    return $(BottomFL,rval);
  case ReachableFL(outdict,relns,cinfo):
    switch(lval) {
    case PlaceL(p): 
      cinfo = consume_assignment(env,p,cinfo,outdict,lexp);
      outdict = assign_place(fenv,loc,outdict,env->all_changed,p,rval);
      relns   = reln_assign_exp(fenv->r,relns,lexp,rexp);
      outflow = ReachableFL(outdict,relns,cinfo);
      DEBUG_PRINT("in AssignOp_e; calling update_tryflow\n");
      update_tryflow(env, outflow);
      DEBUG_PRINT("leaving AssignOp_e\n");
      return $(outflow, rval);
    case UnknownL: 
      // if we don't know the place, then this an unconsumed location
      // accessible via a non-unique path (either a global, or
      // a nested definition).  Can do nothing in this case.
      DEBUG_PRINT("leaving AssignOp_e\n");
      return $(use_Rval(env,rexp->loc,outflow,rval), rval);
    }
  }
}

// Note: must deal with try-flow in all "base" cases!!!
static $(flow_t<`r>,absRval_t<`r>) 
anal_Rexp(analenv_t<`r> env, flow_t<`r> inflow, exp_t e) {
  // Note: It is sound to return on BottomFL only because there is no way to
  //       jump into an expression (we reject goto into a StmtExp).
  let fenv = env->fenv;
  flowdict_t d;
  relns_t relns;
  consume_t cinfo;
  DEBUG_PRINT("in Rexp for |%s|\n",Absynpp::exp2string(e));
  switch(inflow) {
  case BottomFL: return $(BottomFL, fenv->unknown_all); // absRval_t irrelvent
  case ReachableFL(d2,relns2,c): d = d2; relns = relns2; cinfo = c;
    //fprintf(stderr,"inflow expression %s:",Absynpp::exp2string(e));
    //print_relns(relns); fprintf(stderr,"\n");
  }
  switch(e->r) {
    // treat this similar to a dereference in that there's a null-check
    // and afterwards, we know the value is not null.
  case &Cast_e(_,e1,_,NonNull_to_Null):
    let $(f1,r1) = anal_Rexp(env,inflow,e1);
    let $(f2,r2) = anal_derefR(env,inflow,f1,e1,r1);
    return $(f2,r1);
    // C doesn't allow "memory-kind casts", which is good because then
    // we'd have to translate the dictionary domains and that's a pain.
    // In essence, we're assuming the result absRval_t is not Aggregate.
  case &Cast_e(_,e1,_,_):    fallthru(e1);
  case &NoInstantiate_e(e1): fallthru(e1);
  case &Instantiate_e(e1,_): return anal_Rexp(env,inflow,e1);

  case &Const_e(Null_c):
  case &Const_e(Int_c(_,0)): return $(inflow, Zero);
  case &Const_e(Int_c(_,_)): 
  case &Var_e(_,&Funname_b(_)):    return $(inflow, NotZeroAll);

  case &Tunion_e(NULL,_,_): // FIX: distinguish zero/non-zero
  case &Const_e(_): 
  case &Sizeofexp_e(_): // note: the exp is NOT evaluated
  case &Sizeoftyp_e(_):  
  case &Offsetof_e(_,_): // FIX: ?? (first field guaranteed zero?) 
  case &Gentyp_e(_,_):  // FIX: distinguish zero/non-zero enum tags
  case &AnonEnum_e(_,_,_): // FIX : distinguish tags that are/aren't 0
  case &Enum_e(_,_,_): return $(inflow, fenv->unknown_all);

  case &Var_e(_,&Global_b(_)): // globals are init and may be aggregates
    return $(inflow, typ_to_absrval(fenv,e->topt->v, fenv->unknown_all));

    // FIX: avoid allocation of VarRoot
    // Note: if Esc we return that even though it isn't an absRval.  That's
    //       okay b/c assign_place_inner does the right thing
  case &Var_e(_,&Param_b(vd)): fallthru(vd);
  case &Var_e(_,&Local_b(vd)): fallthru(vd);
  case &Var_e(_,&Pat_b(vd)): 
    DEBUG_PRINT("in Rexp:Var_e for |%s|\n",Absynpp::exp2string(e));
    inflow = may_consume_exp(env,inflow,e);
    return $(inflow, Dict::lookup(d, rnew(env->r) VarRoot(vd)));

    // Note: none of the primops cause things to escape or do a dereference!
    //       and they all return initialized ints of unknown value.
  case &Primop_e(p,es): 
    DEBUG_PRINT("in Rexp:Primop_e\n");
    let $(f,r) = anal_use_ints(env,inflow,es,false);
    switch (p) {
    case Plus: case Minus: check_unique_rvals(es->hd->loc,f); break;
    default: f = readthrough_unique_rvals(es->hd->loc,f); break;
    }    
    // Note: we could be smarter here and prune the may_consume list
    return $(f,r);

  case &Increment_e(e1,_):   
    let arg = List{e1,NULL};
    let $(f,_) = anal_use_ints(env,inflow,&arg,false);
    check_unique_rvals(e1->loc,f);
    let $(_,lval) = anal_Lexp(env,f,e1);
    switch($(lval,f)) {
    case $(PlaceL(p),ReachableFL(outdict,relns,c)): 
      relns = reln_kill_exp(fenv->r,relns,e1);
      f = ReachableFL(assign_place(fenv,e1->loc,outdict,
                                   env->all_changed,p,fenv->unknown_all),
			  relns,c);
      break;
    default: break;
    }
    return $(f,fenv->unknown_all);

  case &AssignOp_e(l,&_,r): 
    let arg2 = List{r,NULL};
    let arg1 = List{l,&arg2};
    let $(f,_) = anal_use_ints(env,inflow,&arg1,true);
    let $(_,lval) = anal_Lexp(env,f,l);
    f = consume_unique_rvals(e->loc,f); // consume the rhs of the assignment
    switch(f) {
    case ReachableFL(outdict,relns,cinfo):
      switch (lval) {
      case PlaceL(p): 
      DEBUG_PRINT("assignOp: old_inflow=\n");
      DEBUG_PRINT_F(print_flow,f);
	cinfo = consume_assignment(env,p,cinfo,outdict,l);
	relns = reln_kill_exp(fenv->r,relns,l);
	outdict = assign_place(fenv,l->loc,outdict,
			       env->all_changed,p,fenv->unknown_all);
	f = ReachableFL(outdict,relns,cinfo);
        DEBUG_PRINT("assignOp: new flow=\n");
        DEBUG_PRINT_F(print_flow,f);
	break;
      case UnknownL: 
	DEBUG_PRINT("assignOp: unknown place\n");
	// if we don't know the place, then this an unconsumed location
	// accessible via a non-unique path (either a global, or
	// a nested definition).  Can do nothing in this case.
	break;
      }
      break;
    default: break;
    }
    return $(f,fenv->unknown_all);

  case &AssignOp_e(e1,NULL,e2):
    DEBUG_PRINT("in Rexp:AssignOp_e for |%s|\n",Absynpp::exp2string(e));
    let outer_all_changed = env->all_changed;
    // First try left to right eval order
    let $(left_out, lval_lr)   = anal_Lexp(env,inflow,e1);
    let $(outflow_lr, rval_lr) = anal_Rexp(env,left_out,e2);
    let fl                     = do_assign(fenv,env,outflow_lr,e1,lval_lr,
					   e2,rval_lr,e->loc);
    let all_changed_l = env->all_changed;
    // Now do right to left eval order
    env->all_changed = outer_all_changed;
    let $(right_out, rval_rl)  = anal_Rexp(env,inflow,e2);
    let $(outflow_rl, lval_rl) = anal_Lexp(env,right_out,e1);
    let fr                     = do_assign(fenv,env,outflow_rl,e1,lval_rl,
					   e2,rval_rl,e->loc);
    // Now join the flows
    if(outer_all_changed == NULL)
      env->all_changed = NULL;
    else
      *env->all_changed = union_place_set(*all_changed_l, *env->all_changed,
					  false);
    let ret = join_flow_and_rval(fenv, outer_all_changed, fl, fr, true);
    DEBUG_PRINT("ltor flow is ");
    DEBUG_PRINT_F(print_flow,fr[0]);
    DEBUG_PRINT("rtol flow is ");
    DEBUG_PRINT_F(print_flow,fl[0]);
    DEBUG_PRINT("joined flow is ");
    DEBUG_PRINT_F(print_flow,ret[0]);
    return ret;

  case &SeqExp_e(e1,e2): 
    let $(f,r) = anal_Rexp(env,inflow,e1);
    f = drop_unique_rvals(e1->loc,f); // dropping lhs
    return anal_Rexp(env, f, e2);

  case &Throw_e(e1):
    let $(f,r) = anal_Rexp(env,inflow,e1);
    // Unique exns essentially escape to the heap when thrown
    f = consume_unique_rvals(e1->loc,f); // consume exn expression
    use_Rval(env,e1->loc,f,r); // result irrelevant so long as initialized
    return $(BottomFL,typ_to_absrval(fenv,e->topt->v,fenv->unknown_all));

  case &FnCall_e(e1,es,_): 
    region temp {
      let $(fst_outflow,rvals) = anal_unordered_Rexps(temp,env,inflow,rnew(temp) List(e1,rcopy(temp,es)),true);
      // consume arguments
      fst_outflow = consume_unique_rvals(e->loc,fst_outflow);
      // for strange reasons, use_Rval is fine for the function pointer:
      let outflow = use_Rval(env,e1->loc,fst_outflow,rvals->hd);
      rvals = rvals->tl;
      // we just just "use" each arg except for the "initializes" attribute
      list_t<int> init_params = NULL;
      switch(Tcutil::compress(e1->topt->v)) {
      case &PointerType(PtrInfo(t,_,_)):
        switch(Tcutil::compress(t)) {
        case &FnType(FnInfo(_,_,_,_,_,_,_,atts)):
          for(; atts != NULL; atts = atts->tl)
            switch(atts->hd) {
            case &Initializes_att(i): init_params=rnew(temp) List(i,init_params); break;
            default: break;
            }
          break;
        default: Tcutil::impos("anal_Rexp: bad function type");
        }
        break;
      default: Tcutil::impos("anal_Rexp: bad function type");
      }
      for(int i=1; rvals != NULL; rvals = rvals->tl, es = es->tl, ++i) {
        if(!List::memq(init_params,i)) {
          outflow = use_Rval(env,es->hd->loc,outflow,rvals->hd);
          continue;
        }
        switch(fst_outflow) {
        case BottomFL: break;
        case ReachableFL(fst_d,_,_):
          if(initlevel(fst_d,rvals->hd)==NoneIL)
            Tcutil::terr(es->hd->loc,"expression may not be initialized");
          switch(outflow) {
          case BottomFL: break;
          case ReachableFL(d,relns,c):
            // do the escape, but then set to esc_all in outflow
            let ans_d = escape_deref(fenv, d, env->all_changed, rvals->hd);
            switch(rvals->hd) {
            case &AddressOf(p): 
              switch(Tcutil::compress(es->hd->topt->v)) {
              case &PointerType(PtrInfo(t,_,_)):
                ans_d = assign_place(fenv, es->hd->loc, ans_d, 
                                     env->all_changed,
                                     p, typ_to_absrval(fenv,t,fenv->esc_all));
                break;
              default: Tcutil::impos("anal_Rexp:bad type for initialized arg");
              }
              break;
            default: break;
            }
            outflow = ReachableFL(ans_d,relns,c);
            break;
          }
          break;
        }
      }
      // if the called function doesn't return, we get BottomFL out
      if (Tcutil::is_noreturn(e1->topt->v)) 
        return $(BottomFL,typ_to_absrval(fenv,e->topt->v,fenv->unknown_all));
      else 
        return $(outflow,typ_to_absrval(fenv,e->topt->v,fenv->unknown_all));
    }
  case &Malloc_e(MallocInfo{iscalloc,eopt,topt,exp,isfat}):
    root_t    root      = rnew(fenv->r) MallocPt(exp,e->topt->v);
    place_t   place     = rnew(fenv->r) Place(root,NULL);
    absRval_t rval      = rnew(fenv->r) AddressOf(place);
    absRval_t place_val = 
      isfat ? NotZeroAll : typ_to_absrval(fenv,*topt,fenv->unknown_none);
    flow_t    outflow;
    update_place_set(env->all_changed,place,NULL);
    if(eopt!=NULL) {
      region temp {
        let $(f,rvals) = anal_unordered_Rexps(temp,env,inflow,
                                              rlist(temp,(exp_t)eopt,exp),
                                              false);
        outflow = f;
      }
    } else {
      let $(f,_) = anal_Rexp(env,inflow,exp);
      outflow = f;
    }
    outflow = readthrough_unique_rvals(exp->loc,outflow); // read malloc args
    switch(outflow) {
    case BottomFL: return $(outflow,rval);
    case ReachableFL(d2,relns,c):
      return $(ReachableFL(Dict::insert(d2,root,place_val),relns,c), rval);
    }

  case &Swap_e(e1,e2):
    _ left_rval;
    _ right_rval;
    _ outflow;
    DEBUG_PRINT("in Swap_e(%s,%s): at start, flow is\n",
		Absynpp::exp2string(e1),Absynpp::exp2string(e2));
    DEBUG_PRINT_F(print_flow,inflow);
    region temp {
      let $(f,rvals) = anal_unordered_Rexps(temp,env,inflow,
					    rlist(temp,e1,e2),false);
      left_rval = rvals->hd;
      right_rval = rvals->tl->hd;
      outflow = f;
    }
    // make sure we aren't swapping consumed values
    readthrough_unique_rvals(e->loc,outflow);
    // now assign the abstract rvals
    let $(_,left_lval) = anal_Lexp(env,outflow,e1);
    let $(_,right_lval) = anal_Lexp(env,outflow,e2);
    switch (outflow) {
    case ReachableFL(outdict,relns,cinfo):
      // note that we don't have to make any changes to cinfo, since
      // following the swap no `consumed' status will have changed.
      switch(left_lval) {
      case PlaceL(lp):
	outdict = assign_place(fenv,e1->loc,outdict,env->all_changed,
			       lp,right_rval);
	break;
      case UnknownL: break;
      }
      switch(right_lval) {
      case PlaceL(rp): 
	outdict = assign_place(fenv,e2->loc,outdict,env->all_changed,
			       rp,left_rval);
	break;
      case UnknownL: break;
      }	
      // FIX: should swap the relation information
      relns = reln_kill_exp(fenv->r,relns,e1);
      relns = reln_kill_exp(fenv->r,relns,e2);
      // create new flow
      outflow = ReachableFL(outdict,relns,cinfo);
      break;
    default: break;
    }
    DEBUG_PRINT("in Swap_e: after swap, flow is\n");
    DEBUG_PRINT_F(print_flow,outflow);
    return $(outflow,fenv->unknown_all); 

  case &New_e(eopt,e2):
    root_t    root      = rnew(fenv->r) MallocPt(e2,e->topt->v);
    place_t   place     = rnew(fenv->r) Place(root,NULL);
    absRval_t rval      = rnew(fenv->r) AddressOf(place);
    update_place_set(env->all_changed,place,NULL);
    flow_t    outflow;
    absRval_t place_val;
    if(eopt!=NULL) {
      region temp {
        let $(f,rvals) = anal_unordered_Rexps(temp,env,inflow,
                                              rlist(temp,(exp_t)eopt,e2),
                                              false);
      outflow   = f;
      place_val = rvals->tl->hd;
      }
    } else {
      let $(f,r) = anal_Rexp(env,inflow,e2);
      outflow   = f;
      place_val = r;
    }
    outflow = readthrough_unique_rvals(e2->loc, outflow); // read new args
    switch(outflow) {
    case BottomFL: return $(outflow,rval);
    case ReachableFL(d2,relns,c):
      return $(ReachableFL(Dict::insert(d2,root,place_val),relns,c), rval);
    }
    
  case &Address_e(e1): // FIX: support & as a malloc-and-initialize???    
    // MWH: had to call anal_Rexp here to generate the consume info;
    // to retain the Lexp-only semantics, I just copy the consume info
    // into the inflow returned from anal_Lexp.
    let $(f,_) = anal_Rexp(env,inflow,e1);
    let $(c,_) = save_consume_info(env->fenv,f,false);
    let $(f,l) = anal_Lexp(env,inflow,e1);
    f = restore_consume_info(f,c);
    switch(l) {
    case UnknownL:   return $(f, NotZeroAll);
    case PlaceL(p): return $(f, rnew(env->r) AddressOf(p));
    }

  case &Deref_e(e1): 
    let $(f,r) = anal_Rexp(env,inflow,e1);
    f = readthrough_unique_rvals(e->loc, f); // read pointer
    return anal_derefR(env,inflow,f,e1,r);

    // KLUDGE: unions (see comment at top of file)
  case &AggrMember_e(e1,field):
    let $(f,r) = anal_Rexp(env,inflow,e1);
    // we can drop these here because this has to be a unique path
    f = drop_unique_rvals(e->loc, f);
    f = may_consume_exp(env,f,e);
    // FIX: what to do about tunions and unique sub-elements?
    if(is_union_type(e1->topt->v))
      return $(f,typ_to_absrval(fenv,e->topt->v,fenv->unknown_all)); 
    switch (r) {
    case &Aggregate(rdict):
      let field_no = get_field_index(e1->topt->v,field);
      return $(f,rdict[field_no]);
    default: 
      throw new Core::Impossible(aprintf("anal_Rexp: AggrMember: %s",
                                         Absynpp::exp2string(e)));
    }
    
  case &AggrArrow_e(e1,field): // composition of * and ., of course
    let $(f1,r1) = anal_Rexp(env,inflow,e1);
    f1 = readthrough_unique_rvals(e->loc, f1); // read struct pointer
    let $(f2,r2) = anal_derefR(env,inflow,f1,e1,r1);
    switch(Tcutil::compress(e1->topt->v)) {
    case &PointerType(PtrInfo{t2,_,_}):
      if(is_union_type(t2))
	return $(f2,typ_to_absrval(fenv,e->topt->v,fenv->unknown_all)); 
      switch (r2) {
      case &Aggregate(rdict):
        let field_no = get_field_index(t2,field);
        return $(f2,rdict[field_no]);
      default: throw new Core::Impossible("anal_Rexp: AggrArrow");
      }  
    default: throw new Core::Impossible("anal_Rexp: AggrArrow ptr");
    }
      
  case &Conditional_e(e1,e2,e3): 
    let $(f1t,f1f) = anal_test(env,inflow,e1);
    // consider each branch separately with regard to consume info
    f1t = readthrough_unique_rvals(e1->loc, f1t); // read cond exp, true-flow
    f1f = readthrough_unique_rvals(e1->loc, f1f); // read cond exp, false-flow
    let pr2 = anal_Rexp(env,f1t,e2);
    let pr3 = anal_Rexp(env,f1f,e3);
    // merge the consume information on the join
    return join_flow_and_rval(fenv,env->all_changed,pr2,pr3,true);

  case &And_e(e1,e2):
    let $(f1t,f1f) = anal_test(env,inflow,e1);
    f1t     = readthrough_unique_rvals(e1->loc,f1t); // read 1st exp,true-flow
    f1f     = readthrough_unique_rvals(e1->loc,f1f); // read 1st exp,false-flow
    let $(f2t,f2r) = anal_Rexp(env,f1t,e2);
    f2t     = readthrough_unique_rvals(e2->loc,f2t); // read 2nd exp
    let pr2 = $(f2t,f2r);
    let pr3 = $(f1f, (absRval_t)Zero);
    return join_flow_and_rval(fenv,env->all_changed,pr2,pr3,false);

  case &Or_e(e1,e2):
    let $(f1t,f1f) = anal_test(env,inflow,e1);
    f1t     = readthrough_unique_rvals(e1->loc,f1t); // read 1st exp,true-flow
    f1f     = readthrough_unique_rvals(e1->loc,f1f); // read 1st exp,false-flow
    let $(f2t,f2r) = anal_Rexp(env,f1f,e2);
    f2t     = readthrough_unique_rvals(e2->loc,f2t); // read 2nd exp
    let pr2 = $(f2t,f2r);
    let pr3 = $(f1t, (absRval_t)NotZeroAll);
    return join_flow_and_rval(fenv,env->all_changed,pr2,pr3,false);

  case &Subscript_e(e1,e2): 
    region temp {
      let $(f,rvals) = anal_unordered_Rexps(temp,env,inflow,
                                            rlist(temp,e1,e2),true);
      f = readthrough_unique_rvals(e2->loc,f); // deref e1
      let f2 = f;
      switch(f) {
      case ReachableFL(d2,relns,c2):
        //fprintf(stderr,"subscript %s:",Absynpp::exp2string(e));
        //print_relns(relns); fprintf(stderr,"\n");
        if(initlevel(d2,rvals->tl->hd)==NoneIL)
          Tcutil::terr(e2->loc, "expression may not be initialized");
        let new_relns = add_subscript_reln(fenv->r,relns,e1,e2);
        if (relns != new_relns)
          f2 = ReachableFL(d2,new_relns,c2);
        break;
      default: break;
      }
      switch(Tcutil::compress(e1->topt->v)) {
      case &TupleType(tqts):
        switch(rvals->hd) {
        case &Aggregate(rdict): 
	  f2 = may_consume_exp(env,f2,e);
          unsigned int i = Evexp::eval_const_uint_exp(e2)[0];
          return $(f2,rdict[i]);
        default: throw new Core::Impossible("anal_Rexp: Subscript");
        }
      case &PointerType(PtrInfo(_,_,PtrAtts(_,_,b,_,_))):
        // translation to C reports "can't prove in bounds" errors
        /*
        switch(compress_conref(b)->v) {
        case Eq_constr(&AbsUpper_b(_)):
          switch(rvals->tl->hd) {
          case &TagCmps(cl): 
            e2->annot = new HasTagCmps(copy_tagcmps(Core::heap_region,cl)); 
            break;
          default: break;
          }
          break;
        default: break;
        }
        */
        let $(f3,r) = anal_derefR(env,inflow,f,e1,rvals->hd);
        switch (f3) {
        case BottomFL: return $(f3,r);
        default: return $(f2,r);
        }
      default: throw new Core::Impossible("anal_Rexp: Subscript -- bad type");
      }
    }

  case &Tunion_e(es,tud,_): // NULL case handled above
    if (tud->is_flat) {
      // FIX: for now, I'm just requiring everything to be initialized here
      // because otherwise, I'm getting join errors.
      region temp {
        let $(f,rvals) = anal_unordered_Rexps(temp,env,inflow,es,false);
        f = consume_unique_rvals(e->loc,f); // consume init exprs
        for (; es; es = es->tl, rvals = rvals->tl)
          f = use_Rval(env,es->hd->loc,f,rvals->hd);
        return $(f,fenv->unknown_all);
      }
    }
    fallthru(es); 
  case &Tuple_e(es):
    region temp {
      let $(f,rvals) = anal_unordered_Rexps(temp,env,inflow,es,false);
      f = consume_unique_rvals(e->loc,f); // consume init exprs
      aggrdict_t aggrdict = 
        rnew(env->r) {for i < List::length(es) : 
              ({ let temp = rvals->hd;
                 rvals = rvals->tl;
                 temp; })};

      return $(f, rnew(env->r) Aggregate(aggrdict));
    }
  case &AnonStruct_e(_,des): 
    list_t<Absyn::aggrfield_t> fs;
    switch (Tcutil::compress(e->topt->v)) {
    case &AnonAggrType(_,f): fs = f; break;
    default: throw new Core::Impossible("anal_Rexp:anon struct has bad type");
    }
    fallthru(des,fs);
  case &Struct_e(_,_,des,&Aggrdecl{.impl = &AggrdeclImpl{.fields=fs,...},...}):
    region temp {
      let $(f,rvals) = anal_unordered_Rexps(temp,env,inflow,
                                            rmap(temp,Core::snd,des),false);
      
      f = consume_unique_rvals(e->loc,f); // consume init exprs
      aggrdict_t aggrdict = aggrfields_to_aggrdict(fenv,fs,fenv->unknown_all);
      for(int i=0; rvals != NULL; rvals = rvals->tl, des = des->tl, ++i)
        for(_ ds = (*des->hd)[0]; ds != NULL; ds = ds->tl)
          switch (ds->hd) {
          case &ArrayElement(_): throw new Core::Impossible("anal_Rexp:Struct_e");
          case &FieldName(fld): 
            // find the field and update the aggrdict imperatively
            let field_no = get_field_index_fs(fs,fld);
            aggrdict[field_no] = rvals->hd;
          }
      return $(f, rnew(env->r) Aggregate(aggrdict));
    }
  case &Struct_e(_,_,_,_):
    throw new Core::Impossible("anal_Rexp:missing aggrdeclimpl");
  case &Array_e(dles): 
    region temp {
      let es = rmap(temp,Core::snd,dles);
      let $(outflow,rvals) = anal_unordered_Rexps(temp,env,inflow,es,false);
      outflow = consume_unique_rvals(e->loc,outflow); // consume init exprs
      for(; rvals != NULL; rvals = rvals->tl, es = es->tl)
        outflow = use_Rval(env,es->hd->loc,outflow,rvals->hd);
      return $(outflow,typ_to_absrval(fenv,e->topt->v,fenv->unknown_all));
    }
  case &Comprehension_e(vd,e1,e2,zt): 

    let $(f1,r1) = anal_Rexp(env,inflow,e1);
    f1 = readthrough_unique_rvals(e1->loc, f1); // read bound expr
    switch(f1) {
    case BottomFL: return $(f1,fenv->unknown_all);
    case ReachableFL(d1,relns,c1):
      if(initlevel(d1,r1)==NoneIL)
	Tcutil::terr(e1->loc, "expression may not be initialized");

      // add vd < e1 when e1 is something useful
      relns_t new_relns = relns;
    comp_loop:
      switch(e1->r) {
      case &Cast_e(_,e2,_,_): e1 = e2; goto comp_loop;
      case &Var_e(_,&Global_b(v2)) && !v2->escapes: fallthru(v2);
      case &Var_e(_,&Local_b(v2)) && !v2->escapes: fallthru(v2);
      case &Var_e(_,&Pat_b(v2)) && !v2->escapes: fallthru(v2);
      case &Var_e(_,&Param_b(v2)) && !v2->escapes:
        new_relns = rnew(env->r) List(rnew(env->r) Reln(vd,LessVar(v2,v2->type)),relns);
        break;
      case &Const_e(Int_c(_,i)): 
        new_relns = rnew(env->r) List(rnew(env->r) Reln(vd,LessConst(i)),relns);
        break;
      case &Primop_e(Size,&List(e3,_)):
        switch (e3->r) {
        case &Var_e(_,&Global_b(v2)) && !v2->escapes: fallthru(v2);
        case &Var_e(_,&Local_b(v2)) && !v2->escapes: fallthru(v2);
        case &Var_e(_,&Pat_b(v2)) && !v2->escapes: fallthru(v2);
        case &Var_e(_,&Param_b(v2)) && !v2->escapes:
          // size is always unsigned
          new_relns = rnew(env->r) List(rnew(env->r) Reln(vd,LessNumelts(v2)),relns);
          break;
        default: break;
        }
        break;
      default: break;
      }
      if (relns != new_relns) 
        f1 = ReachableFL(d1,new_relns,c1);

      // check e2 now
      switch(r1) {
      case Zero: return $(f1,fenv->unknown_all); // e2 executed 0 times
      case NotZeroThis:
      case NotZeroAll:
      case &AddressOf(_): // e2 executed at least once
	let l = List(vd,NULL);
	f1 = add_vars(fenv,f1,&l,fenv->unknown_all,e->loc);

	let $(f2,r2) = anal_Rexp(env,f1,e2);
	f2 = consume_unique_rvals(e2->loc,f2); // consume rhexp
	switch(f2) {
	case BottomFL: return $(f2,fenv->unknown_all);
	case ReachableFL(d2,_,c2):
	  if(initlevel(d2,r2) != AllIL) {
	    Tcutil::terr(e1->loc, "expression may not be initialized");
	    return $(BottomFL,fenv->unknown_all);
	  }
	}
	f1 = f2;
	fallthru;
      default: // e2 executed any number of times, including 0
	while(true) {
	  let l = List(vd,NULL);
	  f1 = add_vars(fenv,f1,&l,fenv->unknown_all,e->loc);
	  let $(f2,r2) = anal_Rexp(env,f1,e2);
	  f2 = consume_unique_rvals(e2->loc,f2); // consume rh exp
	  switch(f2) {
	  case BottomFL: break;
	  case ReachableFL(d2,_,c2):
	    if(initlevel(d2,r2) != AllIL) {
	      Tcutil::terr(e1->loc, "expression may not be initialized");
	      return $(BottomFL, fenv->unknown_all);
	    }
	  }
	  let newflow = join_flow(fenv,env->all_changed,f1,f2,true);
	  if(flow_lessthan_approx(newflow,f1))
	    break;
	  f1 = newflow;
	}
	return $(f1,fenv->unknown_all);
      }
    }
  case &StmtExp_e(s): 
    // We need the absRval_t from the last expression --
    // that's why we traverse the statement ourselves.
    // make sure we do everything just like anal_stmt does!
    while(true) {
      let $(_,sflow) = pre_stmt_check(env,inflow,s);
      inflow = *sflow;
      switch(s->r) {
      case &Seq_s(s1,s2): 
	inflow = anal_stmt(env,inflow,s1);
	s = s2;
	break;
      case &Decl_s(d,s1): 
	inflow = anal_decl(env,inflow,d);
	s = s1;
	break;
      case &Exp_s(e): 
	return anal_Rexp(env,inflow,e);
      default: throw new Core::Impossible("analyze_Rexp: ill-formed StmtExp");
      }
    } 

  case &Var_e(_,Unresolved_b): 
  case &UnknownId_e(_):        
  case &UnknownCall_e(_,_):    
  case &UnresolvedMem_e(_,_):  
  case &CompoundLit_e(_,_):    
  case &Valueof_e(_):
    throw new Core::Impossible("anal_Rexp, unexpected exp form");
  }
}

// Having $([f],[r]) = anal_Rexp([env],[inflow],[e]) (or the unordered
// version) and the field nesting [flds], where [e] is a pointer being
// dereferenced, we here set the annotations need for null-check
// elimination, etc., and return an appropriate lvalue; either a place
// if it is known or else UnknownL.
static $(flow_t<`r>,absLval_t<`r>) 
  anal_derefL(analenv_t<`r> env,
	      flow_t<`r> inflow,
              exp_t e,
	      flow_t<`r> f,
	      absRval_t<`r> r,
              list_t<int,`r> flds) {
  let fenv = env->fenv;
  switch(Tcutil::compress(e->topt->v)) {
  case &PointerType(PtrInfo{elttype,_,PtrAtts(_,_,bd,zt,_)}):
    switch(f) {
    case BottomFL: return $(f,UnknownL);
    case ReachableFL(outdict,relns,c):
      // else cannot be known: FIX: determine notzero as appropriate
      if(Tcutil::is_bound_one(bd))
	switch(r) {
	case NotZeroAll:
	case NotZeroThis: 
          e->annot = new NotZero(copy_relns(Core::heap_region,relns)); break;
	case &AddressOf(&Place(root,flds2)): 
	  e->annot = new NotZero(copy_relns(Core::heap_region,relns));
	  return $(f, PlaceL(rnew(fenv->r) Place(root, rappend(fenv->r,flds2,flds))));
	case Zero: 
	  e->annot = IsZero;
	  return $(BottomFL,UnknownL);
	case &UnknownR(il): f = notzero(env,inflow,f,e,il); fallthru;
	// Note: I think tag cmps aren't useful here
	default: e->annot = new UnknownZ(copy_relns(Core::heap_region,relns));
	}
      else
	e->annot = new UnknownZ(copy_relns(Core::heap_region,relns)); // FIX: too conservative?
      if(initlevel(outdict,r)==NoneIL)
	Tcutil::terr(e->loc,"dereference of possibly uninitialized pointer");
      return $(f,UnknownL);
    }
  default: throw new Core::Impossible("left deref of non-pointer-type");
  }
}

// Note: we accept all exps, just returning UnknownL for non-lvalues b/c of
// how code like notzero and splitzero use this function, but no reason
// in these cases to track any effects.
// Note: As with anal_Rexp, it's okay to return immediately on BottomFL.
static $(flow_t<`r>,absLval_t<`r>) 
  anal_Lexp_rec(analenv_t<`r> env, flow_t<`r> inflow, 
                exp_t e, list_t<int,`r> flds){
  flowdict_t d;
  let fenv = env->fenv;
  switch(inflow) {
  case BottomFL: return $(BottomFL, UnknownL); // absLval_t irrelvent
  case ReachableFL(d2,relns,_):
    d = d2;
    //fprintf(stderr,"exp %s:",Absynpp::exp2string(e));
    //print_relns(relns); fprintf(stderr,"\n");
  }
  switch(e->r) {
  case &Cast_e(_,e1,_,_):      fallthru(e1);
  case &NoInstantiate_e(e1): fallthru(e1);
  case &Instantiate_e(e1,_): return anal_Lexp_rec(env,inflow,e1,flds);

  case &Var_e(_,&Param_b(vd)): fallthru(vd);
  case &Var_e(_,&Local_b(vd)): fallthru(vd);
  case &Var_e(_,&Pat_b(vd)):
    return $(inflow, PlaceL(rnew(env->r) Place(rnew(env->r) VarRoot(vd), flds)));

  case &Var_e(_,&Global_b(vd)): return $(inflow,UnknownL);

  case &AggrArrow_e(e1,f):
    switch(Tcutil::compress(e1->topt->v)) {
    case &PointerType(PtrInfo{t2,_,_}):
      if(!is_union_type(t2))
	flds = rnew(env->r) List(get_field_index(t2,f),flds);
      break;
    default: throw new Core::Impossible("anal_Rexp: AggrArrow ptr");
    }
    fallthru(e1);
  case &Deref_e(e1): 
    let $(f,r) = anal_Rexp(env,inflow,e1);
    f = readthrough_unique_rvals(e->loc,f); // read e1
    return anal_derefL(env,inflow,e1,f,r,flds);

  case &Subscript_e(e1,e2): 
    // assumes that tuple-projection implies e2 is pure and is evaluable
    switch(Tcutil::compress(e1->topt->v)) {
    case &TupleType(_):
      let fld = Evexp::eval_const_uint_exp(e2)[0];
      return anal_Lexp_rec(env,inflow,e1,rnew(env->r) List(fld,flds));
    case &PointerType(PtrInfo(_,_,PtrAtts(_,_,b,_,_))):
      // by setting the last flag to true, we make sure not to consume
      // the root pointer
      region temp {
        let $(f,rvals) = anal_unordered_Rexps(temp,env,inflow,
                                              rlist(temp,e1,e2),true);
        f = readthrough_unique_rvals(e2->loc,f); // read index expr
        let f2 = f;
        switch(f) {
        case ReachableFL(d2,relns,c):
          if(initlevel(d2,rvals->tl->hd)==NoneIL)
            Tcutil::terr(e2->loc, "expression may not be initialized");
          let new_relns = add_subscript_reln(fenv->r,relns,e1,e2);
          if (relns != new_relns)
            f2 = ReachableFL(d2,new_relns,c);
          break;
        default: break;
        }
        // translation to C reports "can't prove in bounds" errors
        /*
        switch(compress_conref(b)->v) {
        case Eq_constr(&AbsUpper_b(_)):
          switch(rvals->tl->hd) {
          case &TagCmps(cl): 
            e2->annot = new HasTagCmps(copy_tagcmps(Core::heap_region,cl)); 
            break;
          default: break;
          }
          break;
        default: break;
        }
        */
        let $(f3,r) = anal_derefL(env,inflow,e1,f,rvals->hd,flds);
        switch (f3) {
        case BottomFL: return $(f3,r);
        default: return $(f2,r);
        }
      }
    default: throw new Core::Impossible("anal_Lexp: Subscript -- bad type");
    }
    // KLUDGE: unions (see comment at top of file)
  case &AggrMember_e(e1,fld): 
    if(is_union_type(e1->topt->v))
      return $(inflow,UnknownL);
    return anal_Lexp_rec(env,inflow,e1,
                         rnew(env->r) List(get_field_index(e1->topt->v,fld),flds)); 

  default: return $(BottomFL, UnknownL); // see comment before function
  }
}

static $(flow_t<`r>,absLval_t<`r>) 
anal_Lexp(analenv_t<`r> env, flow_t<`r> inflow, exp_t e) {
#ifdef SANITY
  let $(saved_cinfo,_) = save_consume_info(inflow,false); // sanity check
#endif
  let $(f,r) = anal_Lexp_rec(env,inflow,e,NULL);
#ifdef SANITY
  let $(end_cinfo,_) = save_consume_info(inflow,false);
  if (saved_cinfo.may_consume != end_cinfo.may_consume ||
      saved_cinfo.consumed != end_cinfo.consumed)
    Tcutil::impos("oops: anal_Lexp modified consume lists");
#endif
  return $(f,r);
}

// FIX: ?? there are more primops and the "not-zero" cases to add if we care.
//      also we can statically determine stupid tests like NotZero == Zero
static $(flow_t<`r>,flow_t<`r>) 
anal_test(analenv_t<`r> env, flow_t<`r> inflow, exp_t e) {
  let fenv = env->fenv;
  switch(e->r) {
  case &Conditional_e(e1,e2,e3):
    let $(f1t,f1f) = anal_test(env,inflow,e1);
    // consider each branch separately with regard to consume info
    f1t = readthrough_unique_rvals(e1->loc,f1t); // read cond exp, true-flow
    f1f = readthrough_unique_rvals(e1->loc,f1f); // read cond exp, false-flow
    let $(f2t,f2f) = anal_test(env,f1t,e2);
    let $(f3t,f3f) = anal_test(env,f1f,e3);
    return $(join_flow(fenv, env->all_changed, f2t, f3t, true),
	     join_flow(fenv, env->all_changed, f2f, f3f, true));
  case &And_e(e1,e2):
    let $(f1t,f1f) = anal_test(env,inflow,e1);
    f1t = readthrough_unique_rvals(e1->loc,f1t); // read 1st exp, true-flow
    f1f = readthrough_unique_rvals(e1->loc,f1f); // read 1st exp, false-flow
    let $(f2t,f2f) = anal_test(env,f1t,e2);
    f2t = readthrough_unique_rvals(e2->loc,f2t); // read 2nd exp, true-flow
    f2f = readthrough_unique_rvals(e2->loc,f2f); // read 2nd exp, false-flow
    // MWH: not sure if this should maybe be true
    return $(f2t, join_flow(fenv,env->all_changed, f1f, f2f, false));
  case &Or_e(e1,e2):
    let $(f1t,f1f) = anal_test(env,inflow,e1);
    f1t = readthrough_unique_rvals(e1->loc,f1t); // read 1st exp, true-flow
    f1f = readthrough_unique_rvals(e1->loc,f1f); // read 1st exp, false-flow
    let $(f2t,f2f) = anal_test(env,f1f,e2);
    f2t = readthrough_unique_rvals(e2->loc,f2t); // read 2nd exp, true-flow
    f2f = readthrough_unique_rvals(e2->loc,f2f); // read 2nd exp, false-flow
    // MWH: not sure if this should maybe be true
    return $(join_flow(fenv,env->all_changed, f1t, f2t, false), f2f);
  case &SeqExp_e(e1,e2):
    let $(f,r) = anal_Rexp(env,inflow,e1);
    f = drop_unique_rvals(e1->loc,f); // drop left expr
    return anal_test(env, f, e2);
  case &Primop_e(Not,&List(e1,NULL)):          
    let $(f1,f2) = anal_test(env,inflow,e1);
    return $(f2,f1);
  case &Primop_e(p,es):
    // FIX: what if the primop has only one argument?
    absRval_t r1,r2;
    flow_t f;
    region temp {
      let $(fl,rvals) = anal_unordered_Rexps(temp,env,inflow,es,false);
      r1 = rvals->hd;
      r2 = rvals->tl->hd;
      f = fl;
    }
    switch(f) {
    case BottomFL: return $(f,f);
    case ReachableFL(d,relns,cinfo):
      let e1 = es->hd;
      let e2 = es->tl->hd;
      if(initlevel(d,r1)==NoneIL)
        Tcutil::terr(es->hd->loc,"expression may not be initialized");
      if(initlevel(d,r2)==NoneIL)
        Tcutil::terr(es->tl->hd->loc,"expression may not be initialized");
        
      // zero-splitting, only for Eq and Neq with Zero and Unknown, so can
      // take precedence over any array-bounds splitting
      if(p==Eq || p==Neq)
        switch($(r1,r2)) {
	/* XXX here I would adjust things to use VirtualAddrOf; 
	   do a fall-through on that case for the next two */
        case $(&UnknownR(il),Zero): // f is correct for both args b/c unordered
          let $(f1,f2) = splitzero(env,f,f,e1,il);
          switch(p) { 
          case Eq:  return $(f2,f1);
          case Neq: return $(f1,f2);
          default: throw new Core::Impossible("anal_test, zero-split");
          }
        case $(Zero,&UnknownR(il)):
          let $(f1,f2) = splitzero(env,f,f,e2,il);
          switch(p) { 
          case Eq:  return $(f2,f1);
          case Neq: return $(f1,f2);
          default: throw new Core::Impossible("anal_test, zero-split");
          }
        case $(Zero,Zero):
          if (p == Eq) return $(f,BottomFL);
          else return $(BottomFL,f);
        case $(Zero,NotZeroAll): fallthru;
        case $(Zero,NotZeroThis): fallthru;
        case $(Zero,&AddressOf(_)): fallthru;
        case $(NotZeroAll,Zero): fallthru;
        case $(NotZeroThis,Zero): fallthru;
        case $(&AddressOf(_),Zero): 
          if (p == Neq) return $(f,BottomFL);
          else return $(BottomFL,f);
        default: break;
        }
      
      // bounds checking needs unsigned comparisons
      // this (hoisted) check shouldn't disable any of Greg's stuff because
      // it always used to either check for unsigned or require x.size,
      // which is unsigned
      switch($(Tcutil::compress(e1->topt->v),Tcutil::compress(e2->topt->v))) {
      case $(&IntType(Unsigned,_),_):
      case $(_,&IntType(Unsigned,_)):
      case $(&TagType(_),_):
      case $(_,&TagType(_)): break;
      default: return $(f,f);
      }
      
      switch(p) {
      case Eq: 
        let ft = if_tagcmp(env,f,e1,r1,Eq,r2);
        ft = if_tagcmp(env,ft,e2,r2,Eq,r1);
        return $(ft,f);
      case Neq:
        let ff = if_tagcmp(env,f,e1,r1,Eq,r2);
        ff = if_tagcmp(env,ff,e2,r2,Eq,r1);
        return $(f,ff);
      case Gt:
        let ft = if_tagcmp(env,f,e2,r2,Lt,r1);
        let ff = if_tagcmp(env,f,e1,r1,Lte,r2);
        return $(ft,ff);
      case Gte:
        let ft = if_tagcmp(env,f,e2,r2,Lte,r1);
        let ff = if_tagcmp(env,f,e1,r1,Lt,r2);
        return $(ft,ff);
        
      case Lt:
        let ft = if_tagcmp(env,f,e1,r1,Lt,r2);
        let ff = if_tagcmp(env,f,e2,r2,Lte,r1);
        
        switch(ft) {
        case BottomFL: throw new Core::Impossible("anal_test, Lt");
        case ReachableFL(d2,_,cinfo2): d = d2; cinfo = cinfo2;
        }
        
        // this case tracks most of the inequalities we need for bounds-checking
        switch (e1->r) {
          // Note: global arrays are the only thing that don't "escape"
        case &Var_e(_,&Global_b(v1)) && !v1->escapes: fallthru(v1);
        case &Var_e(_,&Local_b(v1))  && !v1->escapes: fallthru(v1);
        case &Var_e(_,&Pat_b(v1))    && !v1->escapes: fallthru(v1);
        case &Var_e(_,&Param_b(v1))  && !v1->escapes:
          switch (e2->r) {
          case &Var_e(_,&Global_b(v2)) && !v2->escapes: fallthru(v2);
          case &Var_e(_,&Local_b(v2))  && !v2->escapes: fallthru(v2);
          case &Var_e(_,&Pat_b(v2))    && !v2->escapes: fallthru(v2);
          case &Var_e(_,&Param_b(v2))  && !v2->escapes:
            // check that v1 or v2 is unsigned to ensure this is an
            // unsigned comparison
            let r = env->fenv->r;
            let relns_true = rnew(r) List(rnew(r) Reln(v1,LessVar(v2,v2->type)),relns);
            return $(ReachableFL(d,relns_true,cinfo), ff);
          case &Const_e(Int_c(_,i)): 
            let r = env->fenv->r;
            let relns_true = rnew(r) List(rnew(r) Reln(v1,LessConst(i)),relns);
            return $(ReachableFL(d,relns_true,cinfo), ff);
          case &Primop_e(Size,&List(e3,_)):
            switch (e3->r) {
            case &Var_e(_,&Global_b(v2)) && !v2->escapes: fallthru(v2);
            case &Var_e(_,&Local_b(v2))  && !v2->escapes: fallthru(v2);
            case &Var_e(_,&Pat_b(v2))    && !v2->escapes: fallthru(v2);
            case &Var_e(_,&Param_b(v2))  && !v2->escapes:
              // size is always unsigned
              let r = env->fenv->r;
              let relns_true = rnew(r) List(rnew(r) Reln(v1,LessNumelts(v2)),relns);
              return $(ReachableFL(d,relns_true,cinfo), ff);
            default: return $(ft,ff);
            }
          default: return $(ft,ff);
          }
        default: return $(ft,ff);
        }
        
      case Lte:
        let ft = if_tagcmp(env,f,e1,r1,Lte,r2);
        let ff = if_tagcmp(env,f,e2,r1,Lt,r1);
        
        switch(ft) {
        case BottomFL: throw new Core::Impossible("anal_test, Lte");
        case ReachableFL(d2,_,cinfo2): d = d2; cinfo = cinfo2;
        }
        
        // this case checks for i <= x.size
        switch (e1->r) {
          // Note: global arrays are the only thing that don't "escape"
        case &Var_e(_,&Global_b(v1)) && !v1->escapes: fallthru(v1);
        case &Var_e(_,&Local_b(v1))  && !v1->escapes: fallthru(v1);
        case &Var_e(_,&Pat_b(v1))    && !v1->escapes: fallthru(v1);
        case &Var_e(_,&Param_b(v1))  && !v1->escapes:
          switch (e2->r) {
          case &Primop_e(Size,&List(e3,_)):
            switch (e3->r) {
            case &Var_e(_,&Global_b(v2)) && !v2->escapes: fallthru(v2);
            case &Var_e(_,&Local_b(v2))  && !v2->escapes: fallthru(v2);
            case &Var_e(_,&Pat_b(v2))    && !v2->escapes: fallthru(v2);
            case &Var_e(_,&Param_b(v2))  && !v2->escapes:
              // size is always unsigned
              let fenv = env->fenv;
              let relns_true = rnew(fenv->r) List(rnew(fenv->r) Reln(v1,LessEqNumelts(v2)),relns);
              return $(ReachableFL(d,relns_true,cinfo), ff);
            default: return $(ft,ff);
            }
          default: return $(ft,ff);
          }
        default: return $(ft,ff);
        }
      default: return $(f,f);
      }
    }
  default: break;
  }
  // NB: just the default case of the outermost switch from here on;
  // should otherwise have returned in switch statement
  let $(f,r) = anal_Rexp(env,inflow,e);
  f = readthrough_unique_rvals(e->loc,f); // read test expr
  switch(f) {
  case BottomFL: return $(f,f);
  case ReachableFL(d,_,_):
    switch(r) {
    case Zero: return $(BottomFL,f);
    case NotZeroThis:
    case NotZeroAll:
    case &AddressOf(_): return $(f,BottomFL);
    case &UnknownR(NoneIL):
    case &Esc(NoneIL): 	
      Tcutil::terr(e->loc,"expression may not be initialized");
      return $(BottomFL,BottomFL);
    /* XXX another place to add VirtAddrOf fallthru */
    case &UnknownR(il): return splitzero(env,inflow,f,e,il);
    case &Esc(_):       return $(f,f);
    case &TagCmps(_):   return $(f,f); // may be better to splitzero?
    case &Aggregate(_): throw new Core::Impossible("anal_test");
    }
  }
}

static void check_init_params(seg_t loc, analenv_t<`r> env, flow_t<`r> flow) {
  switch(flow) {
  case BottomFL: return;
  case ReachableFL(d,_,_):
    for(let inits = env->param_roots; inits!=NULL; inits=inits->tl)
      if(initlevel(d,lookup_place(d,inits->hd))!=AllIL)
	Tcutil::terr(loc, "function may not initialize all the parameters "
		     "with attribute 'initializes'");
    return;
  }
}

// For now, PATTERN VARS ARE INITIALIZED
// FIX: should keep track of which pattern vars are actually consumed
//   so that we don't entirely consume the value being switched on
static flow_t<`r> anal_scs(analenv_t<`r> env,flow_t<`r> inflow,
                           list_t<switch_clause_t> scs){
  let fenv = env->fenv;
  for(; scs != NULL; scs = scs->tl) {
    let &Switch_clause(_,vds_opt,where_opt,body,loc) = scs->hd;
    flow_t clause_inflow = add_vars(fenv,inflow,vds_opt->v,fenv->unknown_all,loc); 
    flow_t clause_outflow;
    if(where_opt != NULL) {
      exp_t wexp = (exp_t)where_opt;
      let $(ft,ff) = anal_test(env,clause_inflow,wexp);
      ft = readthrough_unique_rvals(wexp->loc,ft); // read wexp,true-flow
      ff = readthrough_unique_rvals(wexp->loc,ff); // read wexp,false-flow
      inflow = ff; // affects remaining clauses
      clause_outflow = anal_stmt(env,ft,body);
    } else {
      clause_outflow = anal_stmt(env,clause_inflow,body);
    }
    switch(clause_outflow) {
    case BottomFL: break;
    default:
      // no need for a break/fallthru for the last case
      if(scs->tl == NULL)
	return clause_outflow;
      else {
	// if the next case has pattern variables, we need an explicit fallthru
	// else just issue a warning
	if (scs->tl->hd->pat_vars->v != NULL)
	  Tcutil::terr(body->loc, "switch clause may implicitly fallthru");
	else 
	  Tcutil::warn(body->loc, "switch clause may implicitly fallthru");
	// in any case, we must update the flow there!
	update_flow(env, scs->tl->hd->body, clause_outflow);
      }
      break;
    }
  }
  return BottomFL; // not reached if last case falls through
}

static flow_t<`r> anal_stmt(analenv_t<`r> env, flow_t<`r> inflow, stmt_t s) {
  flow_t outflow;
  let $(annot,sflow) = pre_stmt_check(env,inflow,s);
  inflow = *sflow;
  let fenv = env->fenv;
  
  switch(s->r) {
  case Skip_s: return inflow;
  case &Return_s(NULL): 
    if (env->noreturn) 
      Tcutil::terr(s->loc,"`noreturn' function might return");
    check_init_params(s->loc,env,inflow);
    return BottomFL;
  case &Return_s(e):    
    if (env->noreturn) 
      Tcutil::terr(s->loc,"`noreturn' function might return");
    let $(f,r) = anal_Rexp(env,inflow,(exp_t)e);
    f = consume_unique_rvals(e->loc,f); // consume returned expression
    f = use_Rval(env,e->loc,f,r);
    check_init_params(s->loc,env,f);
    return BottomFL;
    
  case &Exp_s(e): outflow = anal_Rexp(env,inflow,e)[0]; break;

  case &Seq_s(s1,s2): 
    outflow = anal_stmt(env, anal_stmt(env, inflow, s1), s2); break;

  case &IfThenElse_s(e,s1,s2):
    let $(f1t,f1f) = anal_test(env,inflow,e);
    f1t     = readthrough_unique_rvals(e->loc,f1t); // read if exp, true-flow
    f1f     = readthrough_unique_rvals(e->loc,f1f); // read if exp, false-flow
    outflow = join_flow(fenv, env->all_changed,
			anal_stmt(env,f1t,s1),
			anal_stmt(env,f1f,s2),
			true);
    break;

  case &While_s($(e,cont),body):
    DEBUG_PRINT("in anal_stmt:While_s for |%s| (cont=|%s|)\n",
		Absynpp::stmt2string(body), 
		Absynpp::stmt2string(cont));
    let $(_,eflow_ptr) = pre_stmt_check(env,inflow,cont);
    let e_inflow = *eflow_ptr;
    let $(f1t,f1f) = anal_test(env,e_inflow,e);
    f1t     = readthrough_unique_rvals(e->loc,f1t); // read cond exp,true-flow
    f1f     = readthrough_unique_rvals(e->loc,f1f); // read cond exp,false-flow
    let body_outflow = anal_stmt(env,f1t,body);
    update_flow(env, cont, body_outflow);
    outflow = f1f;
    break;

  case &Do_s(body,$(e,cont)):
    DEBUG_PRINT("in anal_stmt:Do_s for |%s|\n",
		Absynpp::stmt2string(body));
    let body_outflow = anal_stmt(env,inflow,body);
    let $(_,eflow_ptr) = pre_stmt_check(env,body_outflow,cont);
    let e_inflow = *eflow_ptr;
    let $(f1t,f1f) = anal_test(env,e_inflow,e);
    update_flow(env, body, f1t);
    outflow = f1f;
    DEBUG_PRINT("done with Do_s\n");
    break;

    // MWH: ok to drop these?  Seems like "null" expressions
  case &For_s(e1,$(e2,guard),$(e3,cont),body):
    let e1_outflow = anal_Rexp(env,inflow,e1)[0];
    e1_outflow = drop_unique_rvals(e1->loc,e1_outflow); // drop init expr
    let $(_,e2flow_ptr) = pre_stmt_check(env,e1_outflow,guard);
    let e2_inflow  = *e2flow_ptr;
    let $(f2t,f2f) = anal_test(env,e2_inflow,e2);
    let body_outflow = anal_stmt(env,f2t,body);
    let $(_,e3flow_ptr) = pre_stmt_check(env,body_outflow,cont);
    let e3_inflow  = *e3flow_ptr;
    let e3_outflow = anal_Rexp(env,e3_inflow,e3)[0];
    e3_outflow = drop_unique_rvals(e3->loc,e3_outflow); // drop iter expr
    update_flow(env, guard, e3_outflow);
    outflow = f2f;
    break;

    // eg. of when this can happen is when destination is end of function
  case &Break_s(NULL): return BottomFL;
  case &Fallthru_s(es,&destclause):
    region temp {
      let $(f,rvals) = anal_unordered_Rexps(temp,env,inflow,es,false);
      // FIX: WHEN WE INTERPRET PATTERNS
      for(; rvals != NULL; rvals = rvals->tl, es = es->tl)
        f = use_Rval(env,es->hd->loc,f,rvals->hd);
      f = consume_unique_rvals(s->loc,f); // consume fallthru exps
      // The gunk is because the next case's binding vars are still in scope!
      f = add_vars(fenv,f,destclause->pat_vars->v,fenv->unknown_all,s->loc);
      update_flow(env, (stmt_t)(destclause->body), f);
      return BottomFL;
    }
  case &Break_s(dest):    fallthru(dest);
  case &Continue_s(dest): fallthru(dest);
  case &Goto_s(_,dest):
    // check we don't jump into scope -- this is totally orthogonal to 
    // the rest of control-flow checking, so we only do it the first iteration
    if(env->iteration_num==1) {
      let my_encloser   = annot->encloser;
      let dest_encloser = get_stmt_annot((stmt_t)dest)->encloser;
      while(dest_encloser != my_encloser) {
	let next_encloser = get_stmt_annot(my_encloser)->encloser;
	if(next_encloser == my_encloser) { // function body is own encloser
	  Tcutil::terr(s->loc, "goto enters local scope or exception handler");
	  break;
	}
	my_encloser = next_encloser;
      }
    } 
    // now just update the dest's flow
    DEBUG_PRINT("in Rexp:Break/Continue/Goto; updating flow\n");
    update_flow(env, (stmt_t)dest, inflow);
    return BottomFL;

  case &Switch_s(e,scs):
    let $(f,r) = anal_Rexp(env,inflow,e);
    f = consume_unique_rvals(e->loc,f); // consume switched exp
    f = use_Rval(env,e->loc,f,r);
    outflow = anal_scs(env,f,scs);
    break;
    
  case &TryCatch_s(s1,scs):
    // order very important here
    DEBUG_PRINT("in anal_stmt:TryCatch_e\n");
    bool   old_in_try  = env->in_try;
    flow_t old_tryflow = env->tryflow;
    env->in_try  = true;
    env->tryflow = inflow;
    flow_t s1_outflow = anal_stmt(env,inflow,s1);
    flow_t scs_inflow = env->tryflow;
    DEBUG_PRINT("inflow for catch clauses:\n");
    DEBUG_PRINT_F(print_flow,scs_inflow);
    env->in_try  = old_in_try;
    env->tryflow = old_tryflow;
    // sound KLUDGE (see update_tryflow)
    update_tryflow(env,scs_inflow); // necessary?
    flow_t scs_outflow = anal_scs(env,scs_inflow,scs);
    switch(scs_outflow) {
    case BottomFL: break;
    default: Tcutil::terr(s->loc, "last catch clause may implicitly fallthru");
    }
    outflow = s1_outflow; // really join with scs_outflow, but it's BottomFL
    DEBUG_PRINT("leaving anal_stmt:TryCatch_e\n");
    break;

  case &Decl_s(d,s): outflow = anal_stmt(env,anal_decl(env,inflow,d),s); break;

  case &Label_s(_,s): outflow = anal_stmt(env,inflow,s); break;

  case &Region_s(tv,vd,resetable,exp_opt,s):
    if (exp_opt != NULL) {
      let e = (exp_t)exp_opt;
      let $(f,r) = anal_Rexp(env,inflow,e);
      f = consume_unique_rvals(e->loc,f);
      inflow = use_Rval(env,e->loc,f,r);
    }
    let vds = List(vd,NULL);
    inflow = add_vars(fenv, inflow,&vds,fenv->unknown_all,s->loc);
    outflow = anal_stmt(env,inflow,s);
    break;

  case &ResetRegion_s(e):
    let $(f,r) = anal_Rexp(env,inflow,e);
    f = readthrough_unique_rvals(e->loc,f); // drop region exp
    let f2 = use_Rval(env,e->loc,f,r);
    switch (Tcutil::compress(e->topt->v)) {
    case &RgnHandleType(r): 
      outflow = kill_flow_region(fenv,f,r);
      break;
    default: throw new Core::Impossible("anal_stmt -- reset_region");
    }
    break;

  case &Alias_s(e,tv,vd,s1):
    let $(f,r) = anal_Rexp(env,inflow,e);
    // save may consume info for rhs to restore after the stmt
    let $(ConsumeInfo(_,mc),_) = save_consume_info(fenv,f,false);
    f = consume_unique_rvals(e->loc,f); // consume rhs
    f = use_Rval(env,e->loc,f,r);
    let vds = List(vd,NULL);
    f = add_vars(fenv,f,&vds,fenv->unknown_all,s->loc);
    outflow = anal_stmt(env,f,s1);
    switch (outflow) {
    case BottomFL: break;
    case ReachableFL(o,r,c):
      // restore rhs if it was consumed
      while (mc != NULL) {
	let old = c.consumed;
	c.consumed = Dict::rdelete(fenv->r,c.consumed,mc->hd);
	if (c.consumed.t != old.t)
	  DEBUG_PRINT("  alias; unconsumed alias rhs |%s|\n",
		      Absynpp::exp2string(e));
	mc = mc->tl;
      }
      outflow = ReachableFL(o,r,c);
      break;
    }
    break;

  default: throw new Core::Impossible("anal_stmt -- bad stmt syntax"
                                      " or unimplemented stmt form");
  }
  // now drop any vars on the may consume list, since we won't use them
  DEBUG_PRINT("stmt boundary; clearing may consume\n");
  outflow = drop_unique_rvals(s->loc, outflow);
  switch (outflow) {
  case ReachableFL(_,_,cinfo):
    DEBUG_PRINT("  consumed: ");
    DEBUG_PRINT_F(print_place_set,cinfo.consumed);
    DEBUG_PRINT("\n");
    break;
  default: break;
  }
  return outflow;
}

static void check_nested_fun(flow_env_t<`r>, flow_t<`r> inflow, fndecl_t fd);

static flow_t<`r> anal_decl(analenv_t<`r> env, flow_t<`r> inflow, decl_t decl) {
  switch(decl->r) {
    // Note: We don't need to add initialized vars as changed things
    //       because they won't escape to unordered siblings???  Similarly
    //       don't need to may_consume list
    
  case &Var_d(vd):
    let vds = List(vd,NULL);
    inflow = add_vars(env->fenv,inflow,&vds,env->fenv->unknown_none,decl->loc);
    let e = vd->initializer;
    if(e==NULL)
      return inflow;
    let $(f,r) = anal_Rexp(env,inflow,(exp_t)e);
    f = consume_unique_rvals(e->loc, f); // consume rhs
    switch(f) {
    case BottomFL: return BottomFL;
    case ReachableFL(outdict,relns,cinfo):
      outdict = assign_place(env->fenv,decl->loc,outdict,env->all_changed,
			     rnew(env->r) Place(rnew(env->r) VarRoot(vd),
                                                NULL), r);
      relns = reln_assign_var(env->r,relns,vd,(exp_t)vd->initializer);
      let outflow = ReachableFL(outdict,relns,cinfo);
      update_tryflow(env,outflow);
      //fprintf(stderr,"outflow for decl %s:",Absynpp::qvar2string(vd->name));
      //print_relns(relns); fprintf(stderr,"\n");
      return outflow;
    }

    // FIX WHEN WE INTERPRET PATTERNS!!! SPECIAL-CASE VAR-PATTERN?
  case &Let_d(_,&Core::Opt(vds),e):
    let $(f,r) = anal_Rexp(env,inflow,e);
    f = consume_unique_rvals(e->loc,f); // consume rhs of let exp
    f = use_Rval(env,e->loc,f,r);
    return add_vars(env->fenv,f,vds,env->fenv->unknown_all,decl->loc);

    // MWH: do I need to do anything here?
  case &Letv_d(vds): 
    return add_vars(env->fenv,inflow,vds,env->fenv->unknown_none,decl->loc);

  case &Fn_d(fd):
    check_nested_fun(env->fenv,inflow,fd);
    let t = fd->cached_typ->v;
    let vd = (vardecl_t)fd->fn_vardecl;
    return add_vars(env->fenv,inflow,rnew(env->r) List(vd,NULL),env->fenv->unknown_all,decl->loc);

  default: throw new Core::Impossible("anal_decl: unexpected decl variant");
  }
}

//////////////////////////// Post-pass //////////////////////////////

// Note: This is just a space optimization.  Out of laziness, we don't
//       traverse expressions to find nested statements (due to StmtExp_e),
//       so the space for such annotations leaks.
// JGM: now that the flow annotations are put in a hashtable (that gets
// collected at the end of the analysis), there's not much need for this.
/*
static void postpass(stmt_t s) {
  s->annot = EmptyAnnot;
  switch(s->r) {
  case &For_s(_,$(_,s2),$(_,s3),s1): postpass(s3); fallthru(s1,s2);

  case &Seq_s(s1,s2):          fallthru(s1,s2);
  case &While_s($(_,s2),s1):   fallthru(s1,s2);
  case &Do_s(s1,$(_,s2)):      fallthru(s1,s2);
  case &IfThenElse_s(_,s1,s2): postpass(s1); fallthru(s2);

  case &Region_s(_,_,_,_,s1): fallthru(s1);
  case &Label_s(_,s1):      fallthru(s1);
  case &Decl_s(_,s1):       postpass(s1); return;

  case &TryCatch_s(s1,scs): postpass(s1); fallthru(scs);
  case &Switch_s(_,scs):
    for(; scs != NULL; scs = scs->tl)
      postpass(scs->hd->body);
    return;
  default: return;
  }
}
*/

//////////////////////////// Top-level ////////////////////////////////

// TO DO: account for init qualifier (add ThisIL for those params and
//        check them on return and on fall off void)
static void check_fun(fndecl_t fd) {
  region frgn {
    flow_env_t<`frgn> fenv = new_flow_env(frgn);
    check_nested_fun(fenv,ReachableFL(fenv->mt_flowdict,NULL,
                                      ConsumeInfo(fenv->mt_place_set,NULL)),fd);
  }
}

static int hash_ptr(`a s) {
  return (int)s;
}

static void check_nested_fun(flow_env_t<`r> fenv, 
                             flow_t<`r> inflow, fndecl_t fd) {
  //fprintf(stderr,"checking %s of type %s\n",*(*fd->name)[1],
  //        Absynpp::typ2string(Tcutil::fndecl2typ(fd)));
  let frgn = fenv->r;
  let loc = fd->body->loc;
  inflow = add_vars(fenv,inflow,fd->param_vardecls->v,fenv->unknown_all,loc);
  list_t<place_t,`r> param_roots = NULL; // only for "initializes"
  switch(inflow) {
  case BottomFL: Tcutil::impos("check_fun");
  case ReachableFL(d,relns,cinfo):
    // NOTE: for reasons Dan doesn't understand, the attributes, are not
    // on the fndecl, only on the type.
    _ atts;
    switch(Tcutil::compress(fd->cached_typ->v)) {
    case &FnType(FnInfo(_,_,_,_,_,_,_,as)): atts = as; break;
    default: Tcutil::impos("check_fun: non-function type cached with fndecl_t");
    }
    for(; atts != NULL; atts = atts->tl)
      switch(atts->hd) {
      case &Initializes_att(i):
	unsigned j = i;
	if(j > List::length(fd->param_vardecls->v)) {
	  Tcutil::terr(loc,
		       "initializes attribute exceeds number of parameters");
	  continue;
	}
	let vd = List::nth(fd->param_vardecls->v,j-1);
	switch(Tcutil::compress(vd->type)) {
	case &PointerType(PtrInfo(t,_,PtrAtts(_,nullable,bd,zt,_))):
	  if(conref_val(nullable))
	    Tcutil::terr(loc, "initializes attribute not allowed on "
			 "nullable pointers");
	  if(!Tcutil::is_bound_one(bd))
	    Tcutil::terr(loc, "initializes attribute allowed only on pointers"
			 " of size 1");
          if(conref_def(false,zt))
	    Tcutil::terr(loc, "initializes attribute allowed only on pointers"
			 " to non-zero-terminated arrays");
	  let r = rnew(frgn) InitParam(j,t);
	  let rp = rnew(frgn) Place(r,NULL);
	  d = Dict::insert(d,r,typ_to_absrval(fenv,t,fenv->esc_none));
	  d = Dict::insert(d,rnew(frgn) VarRoot(vd),rnew(frgn) AddressOf(rp));
	  param_roots = rnew(frgn) List(rp,param_roots);
	  break;
	default: Tcutil::terr(loc, "initializes attribute on non-pointer");
	}
	break;
      default: break;
      }
    inflow = ReachableFL(d,relns,cinfo);
  }

  bool      noreturn = Tcutil::is_noreturn(Tcutil::fndecl2typ(fd));
  Hashtable::table_t<stmt_t,flow_t@`r,`r> flow_table = 
    Hashtable::rcreate(frgn, 33, Core::ptrcmp, hash_ptr);
  analenv_t env = rnew(frgn) AnalEnv(frgn,fenv,true,0,false,inflow,NULL,noreturn,param_roots,flow_table);
  flow_t    outflow  = inflow;
  while(env->iterate_again && !Position::error_p()) {
    ++(env->iteration_num);
    DEBUG_PRINT("\n  ITERATION %d\n\n", env->iteration_num);
    env->iterate_again = false;
    outflow = anal_stmt(env, inflow, fd->body);
    DEBUG_PRINT("clearing may_consume list\n");
    outflow = drop_unique_rvals(fd->body->loc, outflow);
  }
  switch(outflow) {
  case BottomFL: break;
  default: 
    check_init_params(loc,env,outflow);

    // this is the case when the function "falls off the end"
    if (noreturn)
      Tcutil::terr(loc, "`noreturn' function might (implicitly) return");
    else
      switch (Tcutil::compress(fd->ret_type)) {
      case VoidType: break;
      case &DoubleType(_):
      case FloatType: 
      case &IntType(_,_):
        Tcutil::warn(loc, "function may not return a value"); break;
      default:
        Tcutil::terr(loc, "function may not return a value"); break;
      }
    break;
  }
  // postpass(fd->body); // see comments above
}

void cf_check(list_t<decl_t> ds) {
  for(; ds != NULL; ds = ds->tl)
    switch(ds->hd->r) {
    case &Fn_d(fd):	      check_fun(fd); break;
    case &ExternC_d(ds2):     fallthru(ds2);
    case &Using_d(_,ds2):     fallthru(ds2);
    case &Namespace_d(_,ds2): cf_check(ds2); break;
    case &ExternCinclude_d(_,_): break;
    default: break;
    }
}
