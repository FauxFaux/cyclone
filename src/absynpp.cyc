#include "core.h"
#include "stdio.h"
#include "pp.h"
#include "absyn.h"
#include "list.h"
#include "buffer.h"
#include "string.h"
#include "evexp.h"
#include "tcutil.h"
#include "absynpp.h"

namespace Absynpp;

using Core;
using Stdio;
using PP;
using Absyn;
using List;
using Tcutil;

// forward references
extern doc_t egroup(string start, string stop, string sep, list_t<doc_t> ss);
extern doc_t cat12(doc_t,doc_t,doc_t,doc_t,doc_t,doc_t,doc_t,doc_t,doc_t,
                   doc_t,doc_t,doc_t);
extern doc_t cat11(doc_t,doc_t,doc_t,doc_t,doc_t,doc_t,doc_t,doc_t,doc_t,
                   doc_t,doc_t);
extern doc_t cat10(doc_t,doc_t,doc_t,doc_t,doc_t,doc_t,doc_t,doc_t,doc_t,
                   doc_t);
extern doc_t cat9(doc_t,doc_t,doc_t,doc_t,doc_t,doc_t,doc_t,doc_t,doc_t);
extern doc_t cat8(doc_t,doc_t,doc_t,doc_t,doc_t,doc_t,doc_t,doc_t);
extern doc_t cat7(doc_t,doc_t,doc_t,doc_t,doc_t,doc_t,doc_t);
extern doc_t cat6(doc_t,doc_t,doc_t,doc_t,doc_t,doc_t);
extern doc_t cat5(doc_t,doc_t,doc_t,doc_t,doc_t);
extern doc_t cat4(doc_t,doc_t,doc_t,doc_t);
extern doc_t cat3(doc_t,doc_t,doc_t);
extern doc_t cat2(doc_t,doc_t);
extern doc_t dp2doc($(list_t<designator>,pat)@ dp);
extern doc_t switchclauses2doc(list_t<switch_clause> cs);
extern doc_t typ2doc(typ);
extern doc_t structfields2doc(list_t<structfield_t> fields);
extern doc_t scope2doc(scope);
extern doc_t stmt2doc(stmt);
extern doc_t exp2doc(exp);
extern doc_t exp2doc_prec(int inprec, exp e);
extern doc_t exps2doc_prec(int inprec, list_t<exp> es);
extern doc_t qvar2doc(qvar);
extern doc_t typedef_name2doc(qvar);
extern doc_t cnst2doc(cnst_t);
extern doc_t prim2doc(primop);
extern doc_t primapp2doc(int inprec, primop p,list_t<exp> es);
extern doc_t de2doc($(list_t<designator>,exp)@ de);
extern doc_t tqtd2doc(tqual tq, typ t, opt_t<doc_t> dopt);
extern doc_t funargs2doc(list_t<$(opt_t<var>,tqual,typ)@> args,
                       bool varargs,opt_t<typ> effopt);
extern doc_t enumfields2doc(list_t<enumfield> fields);

// Flag controlling whether typedefs are expanded during printing
bool expand_typedefs = false;

// Flag controlling how to print identifiers (better performance (???) than
// re-writing them all in Toc).
bool qvar_to_Cids = false;

// Flag controlling whether declarations have to be at the beginning of the blocks
bool decls_first = false;

// Flag controlling whether to rewrite temporary type variables
// makes reparsing impossible, but gives nicer error messages
bool dont_rewrite_temp_tvars = false;

// Flag controlling whether to print all type variables
bool print_all_tvars = false;

// Flag controlling whether to print all kinds
bool print_all_kinds = false;

// Flag controlling whether to print the Using statements
bool print_using_stmts = false;

// Flag controlling whether to print the extern "C" {...} statements
// after the TC, the extern "C" are propagated to the functions,
// and we get a warning if we don't hide this one
bool print_externC_stmts = false;

// ------ dealing with namespaces --------
static list_t<var> curr_namespace = null;

static void curr_namespace_add(var v) {
  curr_namespace = &List(v, curr_namespace);
}

static void curr_namespace_drop() {
  curr_namespace = curr_namespace -> tl;
}

// ------------

string char_escape(char c) {
  switch (c) {
  case '\a': return("\\a");
  case '\b': return("\\b");
  case '\f': return("\\f");
  case '\n': return("\\n");
  case '\r': return("\\r");
  case '\t': return("\\t");
  case '\v': return("\\v");
  case '\\': return("\\\\");
  case '\"': return("\"");
  case '\'': return("\\'");
  default:
    if (c>=' ' && c<='~') {
      let t = new_string(1);
      t[0] = c;
      return t;
    } else {
      let t = new_string(4);
      int j = 0;
      t[j++] = '\\';
      t[j++] = (char)('0'+((c>>6)&7));
      t[j++] = (char)('0'+((c>>3)&7));
      t[j++] = (char)('0'+(c&7));
      return t;
    }
  }
}

static bool special(string s){
  int sz = s.size-1;
  for (int i = 0; i<sz; i++) {
    char c = s[i];
    if (c<=' ' || c>='~' || c=='\042' || c=='\\')
      return true;
  }
  return false;
}

string string_escape(string s) {
  if (!special(s)) return s;

  int n = s.size - 1;
  // Check for the expected null terminator of a string constant
  if (n>0 && s[n]=='\000') n--;
  // determine length
  int len = 0;
  for (int i=0; i<=n; i++)
    switch (s[i]) {
    case '\a': fallthru;
    case '\b': fallthru;
    case '\f': fallthru;
    case '\n': fallthru;
    case '\r': fallthru;
    case '\t': fallthru;
    case '\v': fallthru;
    case '\\': fallthru;
    case '\"': len += 2; break;
    case c:
      if (c>=' ' && c<='~') len++;
      else len += 4;
      break;
    }
  // build the escaped string
  string t = new_string(len);
  int j = 0;
  for (int i=0; i<=n; i++)
    switch (s[i]) {
    case '\a': t[j++] = '\\'; t[j++] = 'a'; break;
    case '\b': t[j++] = '\\'; t[j++] = 'b'; break;
    case '\f': t[j++] = '\\'; t[j++] = 'f'; break;
    case '\n': t[j++] = '\\'; t[j++] = 'n'; break;
    case '\r': t[j++] = '\\'; t[j++] = 'r'; break;
    case '\t': t[j++] = '\\'; t[j++] = 't'; break;
    case '\v': t[j++] = '\\'; t[j++] = 'v'; break;
    case '\\': t[j++] = '\\'; t[j++] = '\\'; break;
    case '"' : t[j++] = '\\'; t[j++] = '"'; break;
    case c:
      if (c>=' ' && c<='~') t[j++] = c;
      else {
        t[j++] = '\\';
        t[j++] = (char)('0'+((c>>6)&7));
        t[j++] = (char)('0'+((c>>3)&7));
        t[j++] = (char)('0'+(c&7));
      }
      break;
    }
  return t;
}

static doc_t textptr(stringptr s) { return text(*s); }
static string restrict_string = "restrict";
static string volatile_string = "volatile";
static string const_string = "const";
static stringptr restrict_sp = &restrict_string;
static stringptr volatile_sp = &volatile_string;
static stringptr const_sp = &const_string;

doc_t tqual2doc(tqual tq) {
  list_t<stringptr> l = null;

  if (tq->q_restrict) l = &List(restrict_sp,l);
  if (tq->q_volatile) l = &List(volatile_sp,l);
  if (tq->q_const)    l = &List(const_sp,l);
  return egroup(""," "," ",List::map(textptr,l));
}

string kind2string(kind_t k) {
  switch (k) {
  case AnyKind:        return "A";
  case MemKind:        return "M";
  case BoxKind:        return "B";
  case RgnKind:        return "R";
  case EffKind:        return "E";
  }
}

string ckind2string(conref<kind_t> c) {
  switch (compress_conref(c)->v) {
  case Eq_constr(k): return kind2string(k);
  default: return "?";
  }
}

doc_t kind2doc(kind_t k) { return text(kind2string(k)); }
doc_t ckind2doc(conref<kind_t> c) { return text(ckind2string(c)); }

doc_t group(string start, string stop, string sep, list_t<doc_t> ss) {
  return cat3(text(start),
              seq(sep,ss),
              text(stop));
}

// Like group but return the empty doc if the list is empty 
doc_t egroup(string start, string stop, string sep, list_t<doc_t> ss) {
  if (ss==null) return nil_doc();
  else return cat3(text(start),
                   seq(sep,ss),
                   text(stop));
}

doc_t groupl(string start, string stop, string sep, list_t<doc_t> ss) {
  return cat3(text(start),
              seql(sep,ss),
              text(stop));
}


doc_t tps2doc(list_t<typ> ts) {
  return egroup("<",">",",",List::map(typ2doc,ts));
}

doc_t ktvar2doc(tvar tv) {
  switch (compress_conref(tv->kind)->v) {
  case Eq_constr(BoxKind): return textptr(tv->name);
  case Eq_constr(k):
    return cat3(textptr(tv->name), text("::"), kind2doc(k));
  default: return cat2(textptr(tv->name), text("/*::?*/")); //the type should already be known here
  }
}

doc_t ktvars2doc(list_t<tvar> tvs) {
  return egroup("<",">",",",List::map(ktvar2doc,tvs));
}

static tvarname_t get_name(tvar tv) {
  return tv->name;
}

doc_t tvars2doc(list_t<tvar> tvs) {
  if (print_all_kinds)
    return ktvars2doc(tvs);
  return egroup("<",">",",",List::map(textptr,List::map(get_name,tvs)));
}

doc_t arg2doc($(tqual,typ)@ t) {
  return tqtd2doc((*t)[0],(*t)[1],null);
}

doc_t args2doc(list_t<$(tqual,typ)@> ts) {
  return(group("(",")",",",List::map(arg2doc,ts)));
}

doc_t att2doc(attribute_t a) {
  return text(attribute2string(a));
}

doc_t atts2doc(list_t<attribute_t> atts) {
  if (atts == null) return nil_doc();
  return(cat2(text(" __attribute__"),
              group("((","))",",",List::map(att2doc,atts))));
}

bool next_is_pointer(list_t<type_modifier> tms) {
  if (tms==null) return false;
  switch (tms->hd) {
  case Pointer_mod(_,_,_): return true;
  default: return false;
  }
}

extern doc_t ntyp2doc(typ t);

doc_t dtms2doc(doc_t d,list_t<type_modifier> tms) {
  if (tms==null) return d;
  doc_t rest = dtms2doc(d,tms->tl);
  doc_t p_rest = cat3(text("("),rest,text(")"));
  switch (tms->hd) {
  case Carray_mod:
    if (next_is_pointer(tms->tl)) rest = p_rest;
    return cat2(rest,text("[]"));
  case ConstArray_mod(e):
    if (next_is_pointer(tms->tl)) rest = p_rest;
    return cat4(rest, text("["), exp2doc(e), text("]"));
  case Function_mod(args):
    if (next_is_pointer(tms->tl)) rest = p_rest;
    switch (args) {
    case WithTypes(args2,varargs,effopt):
      return cat2(rest,funargs2doc(args2,varargs,effopt));
    case NoTypes(sl,loc):
      return cat2(rest,group("(",")",",",List::map(textptr,sl)));
    }
  case Attributes_mod(_, atts):
    if (next_is_pointer(tms->tl)) rest = p_rest;
    return cat2(rest, atts2doc(atts));
  case TypeParams_mod(ts,loc,print_kinds):
    if (next_is_pointer(tms->tl)) rest = p_rest;
    if (print_kinds) 
      return cat2(rest, ktvars2doc(ts));
    else
      return cat2(rest, tvars2doc(ts));
    // FIX?? What about tq2?
  case Pointer_mod(ps, rgn, tq2):
    _ ptr;
    switch (ps) {
    case Nullable_ps(e):
      if (Evexp::eval_const_uint_exp(e) == 1)
	ptr = text("*");
      else
	ptr = cat4(text("*"),text("{"),exp2doc(e),text("}"));
      break;
    case NonNullable_ps(e):
      if (Evexp::eval_const_uint_exp(e) == 1)
	ptr = text("@");
      else
	ptr = cat4(text("@"),text("{"),exp2doc(e),text("}"));
      break;
    case TaggedArray_ps: ptr = text("?"); break;
    }
    switch (compress(rgn)) {
    case HeapRgn: return cat2(ptr,rest);
    default: return cat4(ptr,ntyp2doc(rgn),text(" "),rest);
    }
  }
}

doc_t rgn2doc(typ t) {
  switch (compress(t)) {
  case HeapRgn: return text("`H");
  default: return ntyp2doc(t);
  }
}

static void effects2docs(list_t<doc_t> @ `r regions,
			 list_t<doc_t> @ `r effects,
			 typ t)
{
  switch (compress(t)) {
  case AccessEff(r): *regions = &List(rgn2doc(r), *regions); break;
  case JoinEff(ts):
    for (; ts != null; ts = ts->tl) {
      effects2docs(regions, effects, ts->hd);
    }
    break;
  default: *effects = &List(ntyp2doc(t),*effects); break;
  }
}

doc_t eff2doc(typ t) {
  list_t <doc_t> regions = null, effects = null;
  effects2docs(&regions, &effects, t);
  regions = List::imp_rev(regions);
  effects = List::imp_rev(effects);
  if (regions == null && effects != null) {
    return group("","","+",effects);
  } else {
    let doc1 = group("{","}",",",regions);
    return group("","","+",List::imp_append(effects,&List(doc1,null)));
  }
}

// Convert a normalized typ to a doc
doc_t ntyp2doc(typ t) {
  doc_t s;
  switch (t) {
    // The first three cases never turn up in normalized types.
  case ArrayType(_,_,_): return text("[[[array]]]"); //nil_doc();
  case FnType(_)       : return nil_doc();
  case PointerType(_)  : return nil_doc();
    // The remaining cases are possible.
  case VoidType: s = text("void"); break;
  case Evar(k,topt,i):
    if (topt != null)
      // This is an error case, topt should be null in a normalized type
      return(ntyp2doc(topt->v));
    else s = cat5(text("%"),
                  text("("),
                  text(xprintf("%d",i)),
                  text(")::"),
                  kind2doc(k));
    break;
  case VarType(tv):
    s = textptr(tv->name);
    if (print_all_kinds) {
      s = cat3(s,text("::"),ckind2doc(tv->kind));
    }
    //FIX: sometimes need explicit kinds!
    //Mathieu: only if we try to declare kinds inside functions arguments 
    if (! dont_rewrite_temp_tvars && is_temp_tvar(tv)) {
      // we're trying to print a temporary tvar,
      // replace it by _ followed by a comment
      s = cat3(text("_ /* "), s, text(" */"));
      // we cannot print its kind after the underscore for _::E doesn't parse
    }
    break;
  case EnumType(n,ts,_):
    if (n == null)
      s = cat2(text("enum "),
               tps2doc(ts));
    else
      s = cat3(text("enum "),
               qvar2doc((qvar)n),
               tps2doc(ts));
    break;
  case XenumType(n,_):
    s = cat2(text("xenum "),qvar2doc(n));
    break;
  case IntType(sn,sz):
    string sns;
    string ts;
    switch (sn) {
    case Signed:   sns = "";          break;
    case Unsigned: sns = "unsigned "; break;
    }
    switch (sz) {
    case B1:
      switch (sn) {
      case Signed:   sns = "signed "; break;
      case Unsigned: sns = "";        break;
      }
      ts = "char";
      break;
    case B2: ts = "short";     break;
    case B4: ts = "int";       break;
    case B8: ts = "long long"; break;
    }
    s = text(xprintf("%s%s",sns,ts));
    break;
  case FloatType:  s = text("float");  break;
  case DoubleType: s = text("double"); break;
  case TupleType(ts):
    s = cat2(text("$"),args2doc(ts));
    break;
  case StructType(n,ts,_):
    if (n == null)
      s = cat2(text("struct "),tps2doc(ts));
    else
      s = cat3(text("struct "),
               (n==null) ? nil_doc() : qvar2doc((qvar)n),
               tps2doc(ts));
    break;
  case UnionType(n,ts,_):
    if (n == null)
      s = cat2(text("union "),tps2doc(ts));
    else
      s = cat3(text("union "),
               (n==null) ? nil_doc() : qvar2doc((qvar)n),
               tps2doc(ts));
    break;
  case TypedefType(n,ts,topt):
    // NB: we could print out the expanded typedef by following the topt
    // pointer (when non-null).
    // TJ: NO, the way to do that is to expand typedefs in to_tms -- see
    // for example the EVar case in to_tms.  The problem is that topt->v is
    // not going to be "normalized" (i.e., come out of to_tms).
    s = cat2(qvar2doc(n),tps2doc(ts));
    break;
  case RgnHandleType(t):
    s = rgn2doc(t);
    break;
  case HeapRgn:
    s = rgn2doc(t); 
    break;
  case AccessEff(_):
    s = eff2doc(t);
    break;
  case JoinEff(_):
    s = eff2doc(t);
    break;
  }
  return s;
}

doc_t vo2doc(opt_t<var> vo) {
  return (vo==null)?nil_doc():text(*(vo->v));
}

doc_t funarg2doc($(opt_t<var>,tqual,typ)@ t) {
  opt_t<doc_t> dopt = ((*t)[0]==null)?null:&Opt(text(*((*t)[0]->v)));
  return tqtd2doc((*t)[1],(*t)[2],dopt);
}

doc_t funargs2doc(list_t<$(opt_t<var>,tqual,typ)@> args,bool varargs,
                opt_t<typ> effopt) {
  if (effopt == null) {
    if (varargs) // Varargs
      return(group("(",")",",",
                   List::append(List::map(funarg2doc,args),
                                &List(text("..."),null))));
    else      // Not varargs
      return(group("(",")",",",List::map(funarg2doc,args)));
  } else {
    if (varargs)
      return(group("(",")",";",
                   &List(group("","",",",
                               List::append(List::map(funarg2doc,args),
                                            &List(text("..."),null))),
                         &List(eff2doc(effopt->v),null))));
    else 
      return(group("(",")",";",
                   &List(group("","",",",
                               List::map(funarg2doc,args)),
                         &List(eff2doc(effopt->v),null))));
  }
}

$(opt_t<var>,tqual,typ)@ arg_mk_opt($(var,tqual,typ)@ arg) {
  return &$(/*(opt_t<var>)*/&Opt((*arg)[0]), // FIX: can we get rid of the cast? => YES
            (*arg)[1],(*arg)[2]);
}

doc_t var2doc(var v) { return text(*v); }

doc_t qvar2doc(qvar q) {
  let prefix = null;
  switch ((*q)[0]) {
  case Loc_n:       fallthru;
  case Rel_n(null): fallthru;
  case Abs_n(null): return var2doc((*q)[1]);
  case Rel_n(x):    fallthru(x);
  case Abs_n(x):    prefix = x; break;
  }
  if (qvar_to_Cids) {
    return text(String::str_sepstr(List::append(prefix,
						&List((*q)[1],null)),"_"));
  } else {
    // don't print the prefix it aims at the current namespaces
    if (list_prefix(String::strptrcmp, prefix, curr_namespace))
      return var2doc((*q)[1]);
    else
      return cat2(egroup("","::","::",List::map(var2doc,prefix)),
		var2doc((*q)[1]));
  }
}

doc_t typedef_name2doc(qvar v) {
  // avoid the ugly 'wrong namespace' warning when translating to C
  if (qvar_to_Cids) return qvar2doc(v);

  switch ((*v)[0]) {
  case Abs_n(l):
    if (list_cmp(String::strptrcmp, l, curr_namespace) == 0) {
      return var2doc((*v)[1]);      
    } else {
      return cat2(text("/* wrong namespace : */ "), qvar2doc(v));
    }
  default: return qvar2doc(v);    
  }
}

doc_t typ2doc(typ t) {
  return tqtd2doc(empty_tqual(), t, null);
}

// higher precedence means binds more tightly
// not quite right b/c unary operators allow cast expressions,
//   but that just means we put extra parens in.
//       Eg. &((foo) x) has unnecessary parens
// warning -- as a quick hack, exp2_doc_prec also uses some constants
//            in key places
// BIGGER WARNING: Absyndump::dumpexp_prec has to use the same constants!!!
int exp_prec(exp e) {
  switch (e->r) {
  case Const_e(_):       return 10000;
  case Var_e(_,_):       return 10000;
  case UnknownId_e(_):   return 10000;
  case Primop_e(p,_):
    switch (p) {
    case Plus:           return 100;
    case Times:          return 110;
    case Minus:          return 100;
    case Div:            return 110;
    case Mod:            return 110;
    case Eq:             return  70;
    case Neq:            return  70;
    case Gt:             return  80;
    case Lt:             return  80;
    case Gte:            return  80;
    case Lte:            return  80;
    case Not:            return 130;
    case Bitnot:         return 130;
    case Bitand:         return  60;
    case Bitor:          return  40;
    case Bitxor:         return  50;
    case Bitlshift:      return  90;
    case Bitlrshift:     return  80; // unlike C (see grammar)
    case Bitarshift:     return  80; // doesn't actually exist (see grammar)
    case Size:           return 140; // foo.size (same as struct member)
    case Printf:         return 130;
    case Fprintf:        return 130;
    case Xprintf:        return 130;
    case Scanf:          return 130;
    case Fscanf:         return 130;
    case Sscanf:         return 130;
    }
  case AssignOp_e(_,_,_):      return  20;
  case Increment_e(_,_):     return  20;
  case Conditional_e(_,_,_):   return  30; // note || and && are hiding here!
  case SeqExp_e(_,_):        return  10;
  case UnknownCall_e(_,_):   return 140;
  case FnCall_e(_,_):        return 140;
  case Throw_e(_):         return 130;
  case NoInstantiate_e(e2): return exp_prec(e2);
  case Instantiate_e(e2,_): return exp_prec(e2);
  case Cast_e(_,_):          return 120;
  case New_e(_):           return 15; // ???
  case Address_e(_):       return 130;
  case Sizeoftyp_e(_):     return 130;
  case Sizeofexp_e(_):     return 130;
  case Deref_e(_):         return 130;
  case StructMember_e(_,_):  return 140;
  case StructArrow_e(_,_):   return 140; // ???
  case Subscript_e(_,_):     return 140;
  case Tuple_e(_):         return 150;
  case CompoundLit_e(_,_):   fallthru;
  case Array_e(_):           fallthru;
  case Comprehension_e(_,_,_): fallthru;
  case Struct_e(_,_,_,_):    fallthru;
  case Enum_e(_,_,_,_,_):    fallthru;
  case Xenum_e(_,_,_,_):     fallthru;
  case Malloc_e(_):          return 140;
  case UnresolvedMem_e(_,_): return 140; // ???
  case StmtExp_e(_):         return 10000;
  case Codegen_e(_):         return 140;
  case Fill_e(_):            return 140;
  }
}

doc_t exp2doc(exp e) {
   return exp2doc_prec(0,e);
}

doc_t exp2doc_prec(int inprec, exp e) {
  int myprec = exp_prec(e);
  doc_t s;
  switch (e->r) {
  case Const_e(c): s = cnst2doc(c); break;
  case Var_e(x,Local_b(vd)):
    s = qvar2doc(x);
    if(vd->shadow > 0)
      s = cat2(s,text(xprintf("%d",vd->shadow)));
    break;
  case Var_e(x,Pat_b(vd)):
    s = qvar2doc(x);
    if(vd->shadow > 0)
      s = cat2(s,text(xprintf("%d",vd->shadow)));
    break;
  case Var_e(x,_):     s = qvar2doc(x); break;
  case UnknownId_e(x): s = qvar2doc(x); break;
  case Primop_e(p,es): s = primapp2doc(myprec,p,es); break;
  case AssignOp_e(e1,popt,e2):
    s = cat5(exp2doc_prec(myprec,e1),
             text(" "),
             (popt == null) ? text("") : prim2doc(popt->v),
             text("= "),
             exp2doc_prec(myprec,e2));
    break;
  case Increment_e(e2,i):
    let es = exp2doc_prec(myprec,e2);
    switch (i) {
    case PreInc:  s = cat2(text("++"),es); break;
    case PreDec:  s = cat2(text("--"),es); break;
    case PostInc: s = cat2(es,text("++")); break;
    case PostDec: s = cat2(es,text("--")); break;
    }
    break;
  case Conditional_e(e1,e2,e3):
    // decompile to && and || if possible
    switch ($(e2->r,e3->r)) {
      // JGM:  this causes a bug in some places...notably the
      //   file tools/cyclex/compact.cyc
      //case $(Const_e(Int_c(Signed,1)),_):
      //s = cat3(exp2doc_prec(33,e1), text(" || "), exp2doc_prec(33,e3));
      //break;
      //case $(_,Const_e(Int_c(Signed,0))):
      //s = cat3(exp2doc_prec(37,e1), text(" && "), exp2doc_prec(37,e2));
      //break;
      //
    default:
      s = cat5(exp2doc_prec(myprec,e1), text(" ? "), exp2doc_prec(0,e2),
	                                text(" : "), exp2doc_prec(myprec,e3));
      break;
    }
    break;
  case SeqExp_e(e1,e2):
    s = cat3(exp2doc_prec(myprec,e1), text(", "), exp2doc_prec(myprec,e2));
    break;
  case UnknownCall_e(e1,es):
    s = cat4(exp2doc_prec(myprec,e1),
             text("("),
             exps2doc_prec(20,es),
             text(")"));
    break;
  case FnCall_e(e1,es):
    s = cat4(exp2doc_prec(myprec,e1),
             text("("),
             exps2doc_prec(20,es),
             text(")"));
    break;
  case Throw_e(e1):
    s = cat2(text("throw "), exp2doc_prec(myprec,e1));
    break;
  case NoInstantiate_e(e1):
    s = exp2doc_prec(inprec,e1);
    break;
  case Instantiate_e(e1,_):
    s = exp2doc_prec(inprec,e1);
    break;
  case Cast_e(t,e1):
    s = cat4(text("("),
             typ2doc(t),
             text(")"),
             exp2doc_prec(myprec,e1));
    break;
  case Address_e(e1):
    s = cat2(text("&"),
             exp2doc_prec(myprec,e1));
    break;
  case New_e(e1):
    s = cat2(text("new "),
             exp2doc_prec(myprec,e1));
    break;
  case Sizeoftyp_e(t):
    s = cat3(text("sizeof("),
             typ2doc(t),
             text(")"));
    break;
  case Sizeofexp_e(e1):
    s = cat3(text("sizeof("),exp2doc(e1),text(")"));
    break;
  case Deref_e(e1):
    s = cat2(text("*"),
             exp2doc_prec(myprec,e1));
    break;
  case StructMember_e(e1,n):
    s = cat3(exp2doc_prec(myprec,e1), text("."), textptr(n));
    break;
  case StructArrow_e(e1,n):
    s = cat3(exp2doc_prec(myprec,e1), text("->"), textptr(n));
    break;
  case Subscript_e(e1,e2):
    s = cat4(exp2doc_prec(myprec,e1),
             text("["),
             exp2doc(e2),
             text("]"));
    break;
  case Tuple_e(es):
    s = cat3(text("$("),
             exps2doc_prec(20,es),
             text(")"));
    break;
  case CompoundLit_e(vat,des):
    s = cat4(text("("),
             typ2doc((*vat)[2]), // OK to ignore qualifiers??
             text(")"),
             group("{","}",",",List::map(de2doc,des)));
    break;
  case Array_e(des): 
    s = group("{","}",",",List::map(de2doc,des));
    break;
  case Comprehension_e(vd,e1,e2):
    s = cat7(text("new {for "),
             text(*((*vd->name)[1])),
             text(" < "),
             exp2doc(e1),
             text(" : "),
             exp2doc(e2),
             text("}"));
    break;
  case Struct_e(n,_,des,_):
    s = cat2(qvar2doc(n),
             group("{","}",",",List::map(de2doc,des)));
    break;
  case Enum_e(_,_,es,_,ef): fallthru(es,ef);
  case Xenum_e(_,es,_,ef):
    if (es == null)
      // special case: a nullary enum constant is printed "foo" not "foo()"
      s = qvar2doc(ef->name);
    else
      s = cat2(qvar2doc(ef->name),
               egroup("(",")",",",List::map(exp2doc,es)));
    break;
  case Malloc_e(ma):
    // Note: This is for Cyclone's malloc, not the mallocs introduced during
    //       translation to C, which are function calls.
    doc_t inner_d;
    switch(ma) {
    case Typ_m(t):         inner_d = typ2doc(t); break;
    case Enum_m(_,ef):     fallthru(ef);
    case Xenum_m(_,ef):    fallthru(ef->name);
    case Unresolved_m(qv): inner_d = qvar2doc(qv); break;
    }
    s = cat3(text("malloc(sizeof("), inner_d, text("))"));
    break;
  case UnresolvedMem_e(n,des):
    // Currently n is always null from the parser
    s = group("{","}",",",List::map(de2doc,des));
    break;
  case StmtExp_e(s2):
    s = cat3(text("({ "),
             nest(2,stmt2doc(s2)),
             text(" })"));
    break;
  case Codegen_e(fd):
    s = cat3(text("codegen("),
             nest(2,decl2doc(&Decl(Fn_d(fd),e->loc))),
             text(")"));
    break;
  case Fill_e(e1):
    s = cat3(text("fill("),
             nest(2,exp2doc(e1)),
             text(")"));
    break;
  }
  if(inprec >= myprec)
    s = cat3(text("("), s, text(")"));
  return s;
}

doc_t designator2doc(designator d) {
  switch (d) {
  case ArrayElement(e): return cat3(text(".["), exp2doc(e), text("]"));
  case FieldName(v):    return cat2(text("."), textptr(v));
  }
}

doc_t de2doc($(list_t<designator>,exp)@ de) {
  if ((*de)[0] == null) return exp2doc((*de)[1]);
  else return cat2(egroup("","=","=",List::map(designator2doc,(*de)[0])),
		   exp2doc((*de)[1]));
}

doc_t exps2doc_prec(int inprec, list_t<exp> es) {
  return group("","",",",List::map_c(exp2doc_prec,inprec,es));
}

// FIX: take care of sign for Char_c and Short_c
doc_t cnst2doc(cnst_t c) {
  switch (c) {
  case Char_c(sg,ch):     return text(xprintf("'%s'",char_escape(ch)));
  case Short_c(sg,s):     return text(xprintf("(short)%d",(int)s));
  case Int_c(Signed,i):   return text(string_of_int(i));
  case Int_c(Unsigned,i): return text(xprintf("%u",(unsigned)i));
  case LongLong_c(sg,i):  return text("<<FIX LONG LONG CONSTANT>>"); // FIX
  case Float_c(x):  return text(x);
  case Null_c:      return text("null");
  case String_c(s):
    return cat3(text("\""), text(string_escape(s)), text("\""));
  }
}

doc_t primapp2doc(int inprec, primop p,list_t<exp> es) {
  doc_t ps = prim2doc(p);
  if (p == Size) {
    if (es == null || es->tl != null)
      throw Failure(xprintf("Absynpp::primapp2doc Size: %s with bad args",
			    string_of_doc(ps,72)));
    let d = exp2doc_prec(inprec,es->hd);
    return cat2(d,text(".size"));

  } else if (!is_format_prim(p)) {
    list_t<doc_t> ds = List::map_c(exp2doc_prec,inprec,es);
    if (ds == null)
      throw Failure(xprintf("Absynpp::primapp2doc: %s with no args",
			    string_of_doc(ps,72)));
    else if (ds->tl == null)
      return cat3(ps,text(" "),ds->hd);
    else if (ds->tl->tl != null)
      throw Failure(xprintf("Absynpp::primapp2doc: %s with more than 2 args",
			    string_of_doc(ps,72)));
    else
      return cat5(ds->hd,text(" "),ps,text(" "),ds->tl->hd);
  } else {
    // printf, fprintf, xprintf, scanf, fscanf, sscanf
    return cat4(ps, text("("), exps2doc_prec(20,es), text(")"));
  }
}

string prim2str(primop p) {
  switch (p) {
  case Plus: return "+";
  case Times: return "*";
  case Minus: return "-";
  case Div: return "/";
  case Mod: return "%";
  case Eq: return "==";
  case Neq: return "!=";
  case Gt: return ">";
  case Lt: return "<";
  case Gte: return ">=";
  case Lte: return "<=";
  case Not: return "!";
  case Bitnot: return "~";
  case Bitand: return "&";
  case Bitor: return "|";
  case Bitxor: return "^";
  case Bitlshift: return "<<";
  case Bitlrshift: return ">>";
  case Bitarshift: return ">>>";
  case Size: return "size";
  case Printf: return "printf";
  case Fprintf: return "fprintf";
  case Xprintf: return "xprintf";
  case Scanf: return "scanf";
  case Fscanf: return "fscanf";
  case Sscanf: return "sscanf";
  }
}

doc_t prim2doc(primop p) {
  return text(prim2str(p));
}

doc_t structarg2doc($(opt_t<var>,exp)@ t) {
  if ((*t)[0] == null)
     return exp2doc((*t)[1]);
  else return cat3(textptr((*t)[0]->v),
                   text(" = "),
                   exp2doc((*t)[1]));
}

doc_t cat2(doc_t d1,doc_t d2) {
  return concat(d1, d2);
}
doc_t cat3(doc_t d1,doc_t d2,doc_t d3) {
  return
    concat(d1,
    concat(d2,
           d3));
}

doc_t cat4(doc_t d1,doc_t d2,doc_t d3,doc_t d4) {
  return
    concat(d1,
    concat(d2,
    concat(d3,
           d4)));
}

doc_t cat5(doc_t d1,doc_t d2,doc_t d3,doc_t d4,doc_t d5) {
  return
    concat(d1,
    concat(d2,
    concat(d3,
    concat(d4,
           d5))));
}

doc_t cat6(doc_t d1,doc_t d2,doc_t d3,doc_t d4,doc_t d5,doc_t d6) {
  return
    concat(d1,
    concat(d2,
    concat(d3,
    concat(d4,
    concat(d5,
           d6)))));
}

doc_t cat7(doc_t d1,doc_t d2,doc_t d3,doc_t d4,doc_t d5,doc_t d6,doc_t d7) {
  return
    concat(d1,
    concat(d2,
    concat(d3,
    concat(d4,
    concat(d5,
    concat(d6,
           d7))))));
}

doc_t cat8(doc_t d1,doc_t d2,doc_t d3,doc_t d4,doc_t d5,doc_t d6,doc_t d7,doc_t d8) {
  return
    concat(d1,
    concat(d2,
    concat(d3,
    concat(d4,
    concat(d5,
    concat(d6,
    concat(d7,
           d8)))))));
}

doc_t cat9(doc_t d1,doc_t d2,doc_t d3,doc_t d4,doc_t d5,doc_t d6,doc_t d7,doc_t d8,doc_t d9) {
  return
    concat(d1,
    concat(d2,
    concat(d3,
    concat(d4,
    concat(d5,
    concat(d6,
    concat(d7,
    concat(d8,
           d9))))))));
}

doc_t cat10(doc_t d1,doc_t d2,doc_t d3,doc_t d4,doc_t d5,doc_t d6,doc_t d7,doc_t d8,doc_t d9,
          doc_t d10) {
  return
    concat(d1,
    concat(d2,
    concat(d3,
    concat(d4,
    concat(d5,
    concat(d6,
    concat(d7,
    concat(d8,
    concat(d9,
           d10)))))))));
}

doc_t cat11(doc_t d1,doc_t d2,doc_t d3,doc_t d4,doc_t d5,doc_t d6,doc_t d7,doc_t d8,doc_t d9,
          doc_t d10,doc_t d11) {
  return
    concat(d1,
    concat(d2,
    concat(d3,
    concat(d4,
    concat(d5,
    concat(d6,
    concat(d7,
    concat(d8,
    concat(d9,
    concat(d10,
           d11))))))))));
}

doc_t cat12(doc_t d1,doc_t d2,doc_t d3,doc_t d4,doc_t d5,doc_t d6,doc_t d7,doc_t d8,doc_t d9,
          doc_t d10,doc_t d11,doc_t d12) {
  return
    concat(d1,
    concat(d2,
    concat(d3,
    concat(d4,
    concat(d5,
    concat(d6,
    concat(d7,
    concat(d8,
    concat(d9,
    concat(d10,
    concat(d11,
           d12)))))))))));
}

bool is_declaration(stmt s) {
  switch (s->r) {
  case Decl_s(_,_): return true;
  default: return false;
  }
}

doc_t stmt2doc(stmt st) {
  doc_t s;
  switch (st->r) {
  case Skip_s:
    s = text(";"); break;
  case Exp_s(e):
    s = cat2(exp2doc(e),text(";")); break;
  case Seq_s(s1,s2):
    // FIX:  gcc only allows declarations to be used at the beginning
    // of blocks, so we force some explicit blocks to be written below.
    // It is verbose for Cyclone; maybe it should be controlled by a flag.
    // => done
    if (decls_first) {
      if (is_declaration(s1))
	s = cat6(text("{ "),
		 nest(2,stmt2doc(s1)),
		 line_doc(),
		 text("}"),
		 line_doc(),
		 is_declaration(s2)? // for gcc compatibility
		 cat4(text("{ "),
		      nest(2,stmt2doc(s2)),
		      text("}"),
		      line_doc())
		 : stmt2doc(s2));
      else if (is_declaration(s2)) // for gcc compatibility
	s = cat6(stmt2doc(s1),
		 line_doc(),
		 text("{ "),
		 nest(2,stmt2doc(s2)),
		 text("}"),
		 line_doc());
      else
	s = ppseql(stmt2doc,"",&List(s1,&List(s2,null)));
    }
    else
      s = ppseql(stmt2doc,"",&List(s1,&List(s2,null)));
    break;
  case Return_s(eopt):
    if (eopt == null)
      s = text("return;");
    else
      s = cat3(text("return "),
               (eopt==null)?nil_doc():exp2doc((exp)eopt),
               text(";"));
    break;
  case IfThenElse_s(e,s1,s2):
    bool print_else;
    switch (s2->r) {
    case Skip_s: print_else = false; break;
    default:     print_else = true;  break;
    }
    s = cat7(text("if ("),
             exp2doc(e),
             text(") {"),
             nest(2,cat2(line_doc(),stmt2doc(s1))),
	     line_doc(),
	     text("}"),
             print_else ?
             cat5(line_doc(),
                  text("else {"),
                  nest(2,cat2(line_doc(),stmt2doc(s2))),
		  line_doc(),
		  text("}"))
             : nil_doc());
    break;
  case While_s($(e,_),s1):
    s = cat6(text("while ("),
             exp2doc(e),
             text(") {"),
             nest(2,cat2(line_doc(),stmt2doc(s1))),
             line_doc(),
             text("}"));
    break;
  case Break_s(_):    s = text("break;"); break;
  case Continue_s(_): s = text("continue;"); break;
  case Goto_s(x,_):   s = text(xprintf("goto %s;",*x)); break;
  case For_s(e1,$(e2,_),$(e3,_),s1):
    s = cat10(text("for("),
	      exp2doc(e1),
	      text("; "),
	      exp2doc(e2),
	      text("; "),
	      exp2doc(e3),
	      text(") {"),
	      nest(2,cat2(line_doc(),stmt2doc(s1))),
	      line_doc(),
	      text("}"));
    break;
  case Switch_s(e,ss):
    s = cat7(text("switch ("),
             exp2doc(e),
             text(") {"),
             line_doc(),
             switchclauses2doc(ss),
             line_doc(),
             text("}"));
    break;
  case Fallthru_s(null,_): s = text("fallthru;"); break;
  case Fallthru_s(es,_):
    s = cat3(text("fallthru("), exps2doc_prec(20,es), text(");")); break;
  case Decl_s(d,s1):
    s = cat3(decl2doc(d),
             line_doc(),
             stmt2doc(s1));
    break;
  case Cut_s(s1):
    s = cat2(text("cut "),
             nest(2,stmt2doc(s1)));
    break;
  case Splice_s(s1):
    s = cat2(text("splice "),
             nest(2,stmt2doc(s1)));
    break;
  case Label_s(x,s1):
    // FIX:  gcc does not allow declarations to be used immediately after
    // labels.  This next case forces an explicit block to be written.
    // It is verbose for Cyclone; maybe it should be controlled by a flag.
    // => all right !
    if (decls_first && is_declaration(s1)) {
      s = cat6(textptr(x),
	       text(": {"),
	       line_doc(),
	       nest(2,stmt2doc(s1)),
	       line_doc(),
	       text("}"));
    } else
      s = cat3(textptr(x),text(": "),stmt2doc(s1));
    break;
  case Do_s(s1,$(e,_)):
    s = cat7(text("do {"),
             line_doc(),
             nest(2,stmt2doc(s1)),
             line_doc(),
             text("} while ("),
             exp2doc(e),
             text(");"));
    break;
  case TryCatch_s(s1,ss):
    s = cat9(text("try {"),
             line_doc(),
             nest(2,stmt2doc(s1)),
             line_doc(),
             text("} catch {"),
             line_doc(),
             nest(2,switchclauses2doc(ss)),
             line_doc(),
             text("}"));
    break;
  }
  return s;
}

doc_t pat2doc(pat p) {
  doc_t s;
  switch (p->r) {
  case Wild_p: s = text("_"); break;
  case Null_p: s = text("null"); break;
  case Int_p(sg,i):
    if (sg == Signed)
      s = text(xprintf("%d",i));
    else s = text(xprintf("%u",i));
    break;
  case Char_p(ch): s = text(xprintf("'%s'",char_escape(ch))); break;
  case Float_p(x): s = text(x); break;
  case Var_p(vd):  s = qvar2doc(vd->name); break;
  case Tuple_p(ts):
    s = cat3(text("$("),
             ppseq(pat2doc,",",ts),
             text(")"));
    break;
  case Pointer_p(p2):
    s = cat2(text("&"),pat2doc(p2));
    break;
  case Reference_p(vd):
    s = cat2(text("*"),qvar2doc(vd->name));
    break;
  case UnknownId_p(q):
    s = qvar2doc(q);
    break;
  case UnknownCall_p(q,tvs,ps):
    s = cat3(qvar2doc(q),
	     tvars2doc(tvs),
             group("(",")",",",List::map(pat2doc,ps)));
    break;
  case UnknownFields_p(q,tvs,dps):
    s = cat3(qvar2doc(q),
	     tvars2doc(tvs),
             group("{","}",",",List::map(dp2doc,dps)));
    break;
  case Struct_p(sd,_,tvs,dps):
    s = cat3(sd->name==null?nil_doc():qvar2doc(sd->name->v),
	     tvars2doc(tvs),
             group("{","}",",",List::map(dp2doc,dps)));
    break;
  case Enum_p(n,_,tvs,ps,_,_): fallthru(n,tvs,ps);
  case Xenum_p(n,tvs,ps,_,_):
    if (ps == null)
      // special case: a nullary enum constant is printed "foo" not "foo()"
      s = qvar2doc(n);
    else
      s = cat3(qvar2doc(n),
               tvars2doc(tvs),
               egroup("(",")",",",List::map(pat2doc,ps)));
    break;
  }
  return s;
}

doc_t dp2doc($(list_t<designator>,pat)@ dp) {
  return cat2(egroup("","=","=",List::map(designator2doc,(*dp)[0])),
              pat2doc((*dp)[1]));
}

doc_t switchclause2doc(switch_clause c) {
  if (c->where_clause == null && c->pattern->r == Wild_p)
    return
      cat2(text("default: "),
           nest(2,cat2(line_doc(),stmt2doc(c->body))));
  else if (c->where_clause == null)
    return
      cat4(text("case "),
           pat2doc(c->pattern),
           text(": "),
           nest(2,cat2(line_doc(),stmt2doc(c->body))));
  else
    return
      cat6(text("case "),
           pat2doc(c->pattern),
           text(" && "),
           exp2doc((exp)c->where_clause),
           text(": "),
           nest(2,cat2(line_doc(),stmt2doc(c->body))));
}

doc_t switchclauses2doc(list_t<switch_clause> cs) {
  return ppseql(switchclause2doc,"",cs);
}

doc_t decl2doc(decl d) {
  doc_t s;
  switch (d->r) {
  case Fn_d(fd):
    typ t = FnType(FnInfo{fd->tvs,
                          fd->effect,
                          fd->ret_type,
                          List::map(arg_mk_opt,fd->args),
                          fd->varargs, null});
    s = cat7(text(fd->is_inline? "inline " : ""),
             scope2doc(fd->sc),
             tqtd2doc(&Tqual(false,false,false),t,
                      &Opt(cat2(atts2doc(fd->attributes),typedef_name2doc(fd->name)))),
             text(" {"),
             nest(2,cat2(line_doc(),stmt2doc(fd->body))),
             line_doc(),
             text("}"));
    break;
  case Struct_d(sd):
    if (sd->fields==null)
      s = cat5(scope2doc(sd->sc),
               text("struct "),
               (sd->name==null)?text(""):typedef_name2doc(sd->name->v),
               ktvars2doc(sd->tvs),
               text(";"));
    else {
      s = cat10(scope2doc(sd->sc),
                text("struct "),
                (sd->name==null)?text(""):typedef_name2doc(sd->name->v),
                ktvars2doc(sd->tvs),
                text(" {"),
                nest(2,(sd->fields==null)?text(""):
                     cat2(line_doc(),structfields2doc(sd->fields->v))),
                line_doc(),
                text("}"),
                atts2doc(sd->attributes),
                text(";"));
    }
    break;
  case Union_d(ud):
    if (ud->fields==null)
      s = cat5(scope2doc(ud->sc),
               text("union "),
               (ud->name==null)?text(""):qvar2doc(ud->name->v),
               tvars2doc(ud->tvs),
               text(";"));
    else {
      s = cat10(scope2doc(ud->sc),
                text("union "),
                (ud->name==null)?text(""):qvar2doc(ud->name->v),
                tvars2doc(ud->tvs),
                text(" {"),
                nest(2,(ud->fields==null)?text(""):
                     cat2(line_doc(),structfields2doc(ud->fields->v))),
                line_doc(),
                text("}"),
                atts2doc(ud->attributes),
                text(";"));
    }
    break;
  case Var_d(&Vardecl(sc,name,tq,type,initializer,shadow_depth,_,atts)):
    doc_t sn = typedef_name2doc(name);
    if(shadow_depth > 0)
      sn = cat2(sn, text(xprintf("%d",shadow_depth)));
    s = cat5(scope2doc(sc),
             tqtd2doc(tq,type,&Opt(sn)),
             atts2doc(atts),
             (initializer == null)
	       ? text("")
	       : cat2(text(" = "),exp2doc((exp)initializer)),
             text(";"));
    break;
  case Enum_d(ed):
    if (ed->fields==null)
      s = cat5(scope2doc(ed->sc),
               text("enum "),
               (ed->name==null)?text(""):typedef_name2doc(ed->name->v),
               ktvars2doc(ed->tvs),
               text(";"));
    else
      s = cat8(scope2doc(ed->sc),
               text("enum "),
               (ed->name==null)?text(""):typedef_name2doc(ed->name->v),
               ktvars2doc(ed->tvs),
               text(" {"),
               nest(2,(ed->fields==null)?text(""):
                    cat2(line_doc(),enumfields2doc(ed->fields->v))),
               line_doc(),
               text("};"));
    break;
  case Xenum_d(xed):
    s = cat4(scope2doc(xed->sc),
             text("xenum "),
             typedef_name2doc(xed->name),
             (xed->fields==null)
             ?text(";")
             :cat4(text(" {"),
                   nest(2,cat2(line_doc(),enumfields2doc(xed->fields))),
                   line_doc(),
                   text("};")));
    break;
  case Let_d(p,_,_,e,_):
    s = cat5(text("let "),
             pat2doc(p),
             text(" = "),
             exp2doc(e),
             text(";"));
    break;
  case Typedef_d(td):
    s = cat3(text("typedef "),
             tqtd2doc(&Tqual(false,false,false),
                      td->defn,
                      &Opt(cat2(typedef_name2doc(td->name),tvars2doc(td->tvs)))),
             text(";"));
    
    break;
  case Namespace_d(v,tdl):
    if (! qvar_to_Cids) curr_namespace_add(v);
    s = cat7(text("namespace "),
             textptr(v),
             text(" {"),
             line_doc(),
             ppseql(decl2doc,"",tdl),
             line_doc(),
             text("}"));
    if (! qvar_to_Cids) curr_namespace_drop();
    break;
  case Using_d(q,tdl):
    if (print_using_stmts) {
      s = cat7(text("using "),
	       qvar2doc(q),
	       text(" {"),
	       line_doc(),
	       ppseql(decl2doc,"",tdl),
	       line_doc(),
	       text("}"));
    } else {
      s = cat7(text("/* using "),
	       qvar2doc(q),
	       text(" { */"),
	       line_doc(),
	       ppseql(decl2doc,"",tdl),
	       line_doc(),
	       text("/* } */"));
    }
    break;
  case ExternC_d(tdl):
    if (print_externC_stmts) {
      s = cat5(text("extern \"C\" {"),
	       line_doc(),
	       ppseql(decl2doc,"",tdl),
	       line_doc(),
	       text("}"));
    } else {
      s = cat5(text("/* extern \"C\" { */"),
	       line_doc(),
	       ppseql(decl2doc,"",tdl),
	       line_doc(),
	       text("/* } */"));
    }
    break;
  }
  return s;
}

doc_t scope2doc(scope sc) {
  switch (sc) {
  case Static:   return text("static ");
  case Public:   return nil_doc();
  case Extern:   return text("extern ");
  case ExternC:  return text("extern \"C\" ");
  case Abstract: return text("abstract ");
  }
}

// needed to detect default effect
bool exists_temp_tvar_in_effect(typ t) {
  switch (t) {
  case VarType(tv): return is_temp_tvar(tv);
  case JoinEff(l): return exists(exists_temp_tvar_in_effect, l);
  default: return false;
  }
}

// Conversion between alternate forms of types
$(tqual,typ,list_t<type_modifier>) to_tms(tqual tq,typ t) {
  switch (t) {
  case ArrayType(t2,tq2,e):
    // Throw away tq, can't qualify an array
    let $(tq3,t3,tml3) = to_tms(tq2,t2);
    type_modifier tm;
    if (e == null)
      tm = Carray_mod;
    else
      tm = ConstArray_mod((exp)e);
    return $(tq3, t3, (list_t<type_modifier>)&List(tm,tml3));

  case PointerType(PtrInfo{.elt_typ = t2, .rgn_typ = rgntyp,
			   .nullable = nullable, .tq = tq2, .bounds = b}):
    let $(tq3,t3,tml3) = to_tms(tq2,t2);
    enum Pointer_Sort ps;
    switch ($(compress_conref(nullable)->v,compress_conref(b)->v)) {
    case $(Eq_constr(true), Eq_constr(Upper_b(e))):
      ps = Nullable_ps(e); break;
    case $(Eq_constr(false), Eq_constr(Upper_b(e))):
      ps = NonNullable_ps(e); break;
    case $(_, Eq_constr(Unknown_b)):
      ps = TaggedArray_ps; break;
    default:
      // We need to print out something...
      ps = TaggedArray_ps; break;
      // ps = impos("bad pointer type in Absynpp::to_tms"); break;
    }
    type_modifier tm = Pointer_mod(ps,rgntyp,tq);
    return $(tq3, t3, (list_t<type_modifier>)&List(tm,tml3));

  case FnType(FnInfo{typvars,effopt,t2,args,varargs,fn_atts}):
    if (! print_all_tvars) {
      // don't print default effects
      if (effopt == null
	  /* || exists(is_temp_tvar, typvars) */
	  || exists_temp_tvar_in_effect(effopt -> v)) {
	// WARNING : this is our criterion to detect default effect, so it'd better be right...
	// If true, we drop the existent effect
	effopt = null;
	// and the tvars
	// (but could they be useful sometimes ??
	// => yes if they have special kinds with them)
	typvars = null;
      }
    } else {
      if (! dont_rewrite_temp_tvars) {
	// rewrite the temp variables so that they could parse
	// WARNING : we don't check for conflicts with some user-defined tvars
	iter(rewrite_temp_tvar, typvars);
      }
    }

    // discard tq because you can't qualify a function
    let $(tq3,t3,tml3) = to_tms(empty_tqual(),t2);
    list_t<type_modifier> tms = tml3;
    if (fn_atts != null) 
      tms = &List(Attributes_mod(null,fn_atts),tms);
    tms = &List(Function_mod(WithTypes(args,varargs,effopt)),tms);
    if (typvars != null)
      tms = &List(TypeParams_mod(typvars,null,true),tms);
    return $(tq3,t3,tms);

  case Evar(k,topt,i):
    if (topt == null)
      return $(tq,t,null);
    else
      return to_tms(tq,topt->v);

  case TypedefType(n,ts,topt):
    if (topt == null || !expand_typedefs)
      return $(tq,t,null);
    else
      return to_tms(tq,topt->v);

  default: return $(tq,t,null);
  }
}

doc_t tqtd2doc(tqual tq, typ t, opt_t<doc_t> dopt) {
  let $(tq,t,tms) = to_tms(tq,t);
  tms = List::imp_rev(tms);
  if (tms==null && dopt==null)
    return cat2(tqual2doc(tq),ntyp2doc(t));
  else
    return
      cat4(tqual2doc(tq),
           ntyp2doc(t),
           text(" "),
           dtms2doc((dopt==null)?nil_doc():dopt->v,tms));
}

doc_t structfield2doc(structfield_t f) {
  if (f->width != null) 
    return cat5(tqtd2doc(f->tq, f->type, &Opt(textptr(f->name))),
                text(":"), exp2doc(f->width->v),
                atts2doc(f->attributes), text(";"));
  else 
    return cat3(tqtd2doc(f->tq, f->type, &Opt(textptr(f->name))),
                atts2doc(f->attributes), text(";"));
}

doc_t structfields2doc(list_t<structfield_t> fields) {
  return ppseql(structfield2doc,"",fields);
}

doc_t enumfield2doc(enumfield f) {
  return cat4(typedef_name2doc(f->name),
	      (f->tvs==null)?nil_doc(): ktvars2doc(f->tvs),
	      (f->tag==null)?nil_doc():cat2(text("="),exp2doc((exp)f->tag)),
	      (f->typs==null)?nil_doc():args2doc(f->typs));
}

doc_t enumfields2doc(list_t<enumfield> fields) {
  return ppseql(enumfield2doc,",",fields);
}

#ifndef PP_WIDTH
#define PP_WIDTH 72
#endif

//// Public interface -- extend with what clients actually want to print
void decllist2file(list_t<decl> tdl, FILE @f) {
  for (; tdl != null; tdl = tdl->tl) {
    file_of_doc(decl2doc(tdl->hd),PP_WIDTH,f);
    fprintf(f,"\n");
  }
}

string decllist2string(list_t<decl> tdl) {
  return string_of_doc(seql("",List::map(decl2doc,tdl)),PP_WIDTH);
}
string exp2string(exp e)     {return string_of_doc(exp2doc(e),  PP_WIDTH);}
string stmt2string(stmt s)   {return string_of_doc(stmt2doc(s), PP_WIDTH);}
string typ2string(typ t)     {
  dont_rewrite_temp_tvars = true; // so that error messages remain 'nice'
  let s = string_of_doc(typ2doc(t),  PP_WIDTH);
  dont_rewrite_temp_tvars = false;
  return s;
}
string qvar2string(qvar v)   {return string_of_doc(qvar2doc(v), PP_WIDTH);}
string prim2string(primop p) {return string_of_doc(prim2doc(p), PP_WIDTH);}
string pat2string(pat p)     {return string_of_doc(pat2doc(p),  PP_WIDTH);}


