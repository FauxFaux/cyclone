/* Pretty printer for the abstract syntax.
   Copyright (C) 2001 Greg Morrisett, AT&T
   This file is part of the Cyclone compiler.

   The Cyclone compiler is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   The Cyclone compiler is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with the Cyclone compiler; see the file COPYING. If not,
   write to the Free Software Foundation, Inc., 59 Temple Place -
   Suite 330, Boston, MA 02111-1307, USA. */

#include <core.h>
#include <stdio.h>
#include <pp.h>
#include "absyn.h"
#include <list.h>
#include <buffer.h>
#include <string.h>
#include "evexp.h"
#include "tcutil.h"
#include "absynpp.h"

namespace Absynpp;

using Core;
using PP;
using Absyn;
using List;
using Tcutil;

// forward references
extern doc_t dp2doc($(list_t<designator_t>,pat_t)@ dp);
extern doc_t switchclauses2doc(list_t<switch_clause_t,`H> cs);
extern doc_t switchCclauses2doc(list_t<switchC_clause_t,`H> cs);
extern doc_t typ2doc(type_t);
extern doc_t structfields2doc(list_t<structfield_t,`H> fields);
extern doc_t scope2doc(scope_t);
extern doc_t stmt2doc(stmt_t);
extern doc_t exp2doc(exp_t);
extern doc_t exp2doc_prec(int inprec, exp_t e);
extern doc_t exps2doc_prec(int inprec, list_t<exp_t> es);
extern doc_t qvar2doc(qvar_t);
extern doc_t typedef_name2doc(qvar_t);
extern doc_t cnst2doc(cnst_t);
extern doc_t prim2doc(primop_t);
extern doc_t primapp2doc(int inprec, primop_t p,list_t<exp_t> es);
extern doc_t de2doc($(list_t<designator_t>,exp_t)@ de);
extern doc_t tqtd2doc(tqual_t tq, type_t t, opt_t<doc_t> dopt);
extern doc_t funargs2doc(list_t<$(opt_t<var_t>,tqual_t,type_t)@> args,
                         bool c_varargs,vararg_info_t *cyc_varargs,
                         opt_t<type_t> effopt, 
                         list_t<$(type_t,type_t)@> rgn_po);
extern doc_t tunionfields2doc(list_t<tunionfield_t,`H> fields);
extern doc_t enumfields2doc(list_t<enumfield_t,`H> fs);
extern doc_t vardecl2doc(vardecl_t vd);
// Flag controlling whether typedefs are expanded during printing
static bool expand_typedefs;

// Flag controlling how to print identifiers (better performance (???) than
// re-writing them all in Toc).
static bool qvar_to_Cids;

string_t cyc_string = "Cyc";
stringptr_t cyc_stringptr = &cyc_string;
// Flag controlling whether to add the cyc prefix to the C-identifiers
static bool add_cyc_prefix;

// Flag controlling whether the (C) output should be for VC instead of gcc.
// (Differences: long long vs. __int64 and inline vs. __inline)
static bool to_VC;

// Flag controlling whether declarations have to be at the beginning of the blocks
static bool decls_first;

// Flag controlling whether to rewrite temporary type variables
// makes reparsing impossible, but gives nicer error messages
static bool rewrite_temp_tvars;

// Flag controlling whether to print all type variables
static bool print_all_tvars;

// Flag controlling whether to print all kinds
static bool print_all_kinds;

// Flag controlling whether to print the Using statements
static bool print_using_stmts;

// Flag controlling whether to print the extern "C" {...} statements
// after the TC, the extern "C" are propagated to the functions,
// and we get a warning if we don't hide this one
static bool print_externC_stmts;

// Flag controlling whether to print out free tvars that can be
// used when instantiating evars
static bool print_full_evars;

// Flag controlling whether to insert #line directives in c output
static bool generate_line_directives;

// Flag controlling whether to use the variable curr_namespace or not
static bool use_curr_namespace;

// keep a track of the current namespace
static list_t<var_t> curr_namespace = NULL;

struct Params {
  bool expand_typedefs :1;
  bool qvar_to_Cids :1;
  bool add_cyc_prefix :1;
  bool to_VC :1;
  bool decls_first :1;
  bool rewrite_temp_tvars :1;
  bool print_all_tvars :1;
  bool print_all_kinds :1;
  bool print_using_stmts :1;
  bool print_externC_stmts :1;
  bool print_full_evars :1;
  bool generate_line_directives :1;
  bool use_curr_namespace :1;
  list_t<var_t> curr_namespace;
};

void set_params(struct Params @ `r fs) {
  expand_typedefs = fs->expand_typedefs;
  qvar_to_Cids = fs->qvar_to_Cids;
  add_cyc_prefix = fs->add_cyc_prefix;
  to_VC = fs->to_VC;
  decls_first = fs->decls_first;
  rewrite_temp_tvars = fs->rewrite_temp_tvars;
  print_all_tvars = fs->print_all_tvars;
  print_all_kinds = fs->print_all_kinds;
  print_using_stmts = fs->print_using_stmts;
  print_externC_stmts = fs->print_externC_stmts;
  print_full_evars = fs->print_full_evars;
  generate_line_directives = fs->generate_line_directives;
  use_curr_namespace = fs->use_curr_namespace;
  curr_namespace = fs->curr_namespace;
}

struct Params cyc_params_r =
  Params{
    .expand_typedefs = false,
    .qvar_to_Cids = false,
    .add_cyc_prefix = false,
    .to_VC = false,
    .decls_first = false,
    .rewrite_temp_tvars = true,
    .print_all_tvars = false,
    .print_all_kinds = false,
    .print_using_stmts = true,
    .print_externC_stmts = true,
    .print_full_evars = false,
    .generate_line_directives = false,
    .use_curr_namespace = true,
    .curr_namespace = NULL
  };

struct Params cyci_params_r =
  Params{
    .expand_typedefs = true,
    .qvar_to_Cids = false,
    .add_cyc_prefix = false,
    .to_VC = false,
    .decls_first = false,
    .rewrite_temp_tvars = true,
    .print_all_tvars = false,
    .print_all_kinds = false,
    .print_using_stmts = true,
    .print_externC_stmts = true,
    .print_full_evars = false,
    .generate_line_directives = false,
    .use_curr_namespace = true,
    .curr_namespace = NULL
  };

struct Params c_params_r =
  Params{
    .expand_typedefs = true,
    .qvar_to_Cids = true,
    .add_cyc_prefix = true,
    .to_VC = false,
    .decls_first = true,
    .rewrite_temp_tvars = false,
    .print_all_tvars = false,
    .print_all_kinds = false,
    .print_using_stmts = false,
    .print_externC_stmts = false,
    .print_full_evars = false,
    .generate_line_directives = false,
    .use_curr_namespace = false,
    .curr_namespace = NULL
  };

struct Params tc_params_r =
  Params{
    .expand_typedefs = false,
    .qvar_to_Cids = false,
    .add_cyc_prefix = false,
    .to_VC = false,
    .decls_first = false,
    .rewrite_temp_tvars = false,
    .print_all_tvars = false,
    .print_all_kinds = false,
    .print_using_stmts = true,
    .print_externC_stmts = true,
    .print_full_evars = false,
    .generate_line_directives = false,
    .use_curr_namespace = false,
    .curr_namespace = NULL
  };


static void curr_namespace_add(var_t v) {
  curr_namespace = imp_append(curr_namespace, new List(v, NULL));
}

static void suppr_last(list_t<`a> @ `r l) {// could be in List
  if ((*l) -> tl == NULL) {
    *l = NULL;
  } else {
    suppr_last(&((*l) -> tl));
  }
}

static void curr_namespace_drop() {
  suppr_last(&curr_namespace);
}

string_t char_escape(char c) {
  switch (c) {
  case '\a': return("\\a");
  case '\b': return("\\b");
  case '\f': return("\\f");
  case '\n': return("\\n");
  case '\r': return("\\r");
  case '\t': return("\\t");
  case '\v': return("\\v");
  case '\\': return("\\\\");
  case '\"': return("\"");
  case '\'': return("\\'");
  default:
    if (c>=' ' && c<='~') {
      let t = new_string(1);
      t[0] = c;
      return t;
    } else {
      let t = new_string(4);
      int j = 0;
      t[j++] = '\\';
      t[j++] = (char)('0'+(((unsigned char)c>>6)&7));
      t[j++] = (char)('0'+((c>>3)&7));
      t[j++] = (char)('0'+(c&7));
      return t;
    }
  }
}

static bool special(string_t s){
  int sz = s.size-1;
  for (int i = 0; i<sz; i++) {
    char c = s[i];
    if (c<=' ' || c>='~' || c=='\042' || c=='\\')
      return true;
  }
  return false;
}

string_t string_escape(string_t<`H> s) {
  if (!special(s)) return s;

  int n = s.size - 1;
  // Check for the expected NUL terminator of a string constant
  if (n>0 && s[n]=='\000') n--;
  // determine length
  int len = 0;
  for (int i=0; i<=n; i++)
    switch (s[i]) {
    case '\a': fallthru;
    case '\b': fallthru;
    case '\f': fallthru;
    case '\n': fallthru;
    case '\r': fallthru;
    case '\t': fallthru;
    case '\v': fallthru;
    case '\\': fallthru;
    case '\"': len += 2; break;
    case c:
      if (c>=' ' && c<='~') len++;
      else len += 4;
      break;
    }
  // build the escaped string
  mstring_t t = new_string(len);
  int j = 0;
  for (int i=0; i<=n; i++)
    switch (s[i]) {
    case '\a': t[j++] = '\\'; t[j++] = 'a'; break;
    case '\b': t[j++] = '\\'; t[j++] = 'b'; break;
    case '\f': t[j++] = '\\'; t[j++] = 'f'; break;
    case '\n': t[j++] = '\\'; t[j++] = 'n'; break;
    case '\r': t[j++] = '\\'; t[j++] = 'r'; break;
    case '\t': t[j++] = '\\'; t[j++] = 't'; break;
    case '\v': t[j++] = '\\'; t[j++] = 'v'; break;
    case '\\': t[j++] = '\\'; t[j++] = '\\'; break;
    case '"' : t[j++] = '\\'; t[j++] = '"'; break;
    case c:
      if (c>=' ' && c<='~') t[j++] = c;
      else {
        t[j++] = '\\';
        t[j++] = (char)('0'+((c>>6)&7));
        t[j++] = (char)('0'+((c>>3)&7));
        t[j++] = (char)('0'+(c&7));
      }
      break;
    }
  return t;
}

static string_t restrict_string = "restrict";
static string_t volatile_string = "volatile";
static string_t const_str = "const";
static stringptr_t restrict_sp = &restrict_string;
static stringptr_t volatile_sp = &volatile_string;
static stringptr_t const_sp = &const_str;

doc_t tqual2doc(tqual_t tq) {
  list_t<stringptr_t> l = NULL;

  if (tq.q_restrict) l = new List(restrict_sp,l);
  if (tq.q_volatile) l = new List(volatile_sp,l);
  if (tq.q_const)    l = new List(const_sp,l);
  return egroup(""," "," ",List::map(textptr,l));
}

string_t kind2string(kind_t k) {
  switch (k) {
  case AnyKind:        return "A";
  case MemKind:        return "M";
  case BoxKind:        return "B";
  case RgnKind:        return "R";
  case EffKind:        return "E";
  }
}

string_t kindbound2string(kindbound_t c) {
  switch (compress_kb(c)) {
  case &Eq_kb(k): return kind2string(k);
  case &Unknown_kb(_): return "?";
  case &Less_kb(_,k): return kind2string(k);
  }
}

doc_t kind2doc(kind_t k) { return text(kind2string(k)); }
doc_t kindbound2doc(kindbound_t c) { return text(kindbound2string(c)); }

doc_t tps2doc(list_t<type_t> ts) {
  return egroup("<",">",",",List::map(typ2doc,ts));
}

doc_t ktvar2doc(tvar_t tv) {
  switch (compress_kb(tv->kind)) {
  case &Unknown_kb(_): fallthru;
  case &Eq_kb(BoxKind): return textptr(tv->name);
  case &Less_kb(_,k): fallthru(k);
  case &Eq_kb(k): 
    return cat(textptr(tv->name), text("::"), kind2doc(k));
  }
}

doc_t ktvars2doc(list_t<tvar_t> tvs) {
  return egroup("<",">",",",List::map(ktvar2doc,tvs));
}

static tvarname_t get_name(tvar_t tv) {
  return tv->name;
}

doc_t tvars2doc(list_t<tvar_t> tvs) {
  if (print_all_kinds)
    return ktvars2doc(tvs);
  return egroup("<",">",",",List::map(textptr,List::map(get_name,tvs)));
}

doc_t arg2doc($(tqual_t,type_t)@ t) {
  return tqtd2doc((*t)[0],(*t)[1],NULL);
}

doc_t args2doc(list_t<$(tqual_t,type_t)@> ts) {
  return(group("(",")",",",List::map(arg2doc,ts)));
}

doc_t noncallatt2doc(attribute_t att) {
  switch(att) {
  case Stdcall_att:  return nil_doc();
  case Cdecl_att:    return nil_doc();
  case Fastcall_att: return nil_doc();
  default: return text(attribute2string(att));
  }
}

doc_t callconv2doc(attributes_t atts) { // for MS only
  for(; atts != NULL; atts = atts->tl)
    switch(atts->hd) {
    case Stdcall_att:  return text(" _stdcall ");
    case Cdecl_att:    return text(" _cdecl ");
    case Fastcall_att: return text(" _fastcall ");
    default: break;
    }
  return nil_doc();
}

doc_t noncallconv2doc(attributes_t atts) { // for MS only
  bool hasatt = false;
   for(_ atts2 = atts; atts2 != NULL; atts2 = atts2->tl)
    switch(atts2->hd) {
    case Stdcall_att:  break;
    case Cdecl_att:    break;
    case Fastcall_att: break;
    default: hasatt = true; break;
    }
  if(!hasatt)
    return nil_doc();
  return cat(text("__declspec("), 
	     group("",""," ",List::map(noncallatt2doc,atts)),
	     text(")"));
}

doc_t att2doc(attribute_t a) { // for gcc only
  return text(attribute2string(a));
}

doc_t atts2doc(attributes_t atts) {
  if (atts == NULL) return nil_doc();
  if(Absynpp::to_VC)
    return noncallconv2doc(atts);
  return(cat(text(" __attribute__"),
             group("((","))",",",List::map(att2doc,atts))));
}

bool next_is_pointer(list_t<type_modifier_t> tms) {
  if (tms==NULL) return false;
  switch (tms->hd) {
  case &Pointer_mod(_,_,_): return true;
  case &Attributes_mod(_,_): 
    if(!to_VC) return false;
    // KLUDGE for VC calling conventions
    // FIX -- not sure this is right
    return next_is_pointer(tms->tl);
  default: return false;
  }
}

extern doc_t ntyp2doc(type_t t);

doc_t dtms2doc(doc_t d,list_t<type_modifier_t> tms) {
  if (tms==NULL) return d;
  doc_t rest = dtms2doc(d,tms->tl);
  doc_t p_rest = cat(text("("),rest,text(")"));
  switch (tms->hd) {
  case Carray_mod:
    if (next_is_pointer(tms->tl)) rest = p_rest;
    return cat(rest,text("[]"));
  case &ConstArray_mod(e):
    if (next_is_pointer(tms->tl)) rest = p_rest;
    return cat(rest, text("["), exp2doc(e), text("]"));
  case &Function_mod(args):
    if (next_is_pointer(tms->tl)) rest = p_rest;
    switch (args) {
    case &WithTypes(args2,c_varargs,cyc_varargs,effopt,rgn_po):
      return cat(rest,funargs2doc(args2,c_varargs,cyc_varargs,effopt,rgn_po));
    case &NoTypes(sl,loc):
      return cat(rest,group("(",")",",",List::map(textptr,sl)));
    }
  case &Attributes_mod(_, atts):
    if(!to_VC) {
      if (next_is_pointer(tms->tl)) rest = p_rest;
      return cat(rest, atts2doc(atts));
    } else {
      // KLUDGE for VC calling conventions
      // FIX -- not sure this is right
      if(next_is_pointer(tms->tl))
	return cat(callconv2doc(atts), rest);
      return rest;
    }

  case &TypeParams_mod(ts,loc,print_kinds):
    if (next_is_pointer(tms->tl)) rest = p_rest;
    if (print_kinds)
      return cat(rest, ktvars2doc(ts));
    else
      return cat(rest, tvars2doc(ts));
    // FIX?? What about tq2?
  case &Pointer_mod(ps, rgn, tq2):
    _ ptr;
    switch (ps) {
    case &Nullable_ps(e):
      if (Evexp::eval_const_uint_exp(e) == 1)
	ptr = text("*");
      else
	ptr = cat(text("*"),text("{"),exp2doc(e),text("}"));
      break;
    case &NonNullable_ps(e):
      if (Evexp::eval_const_uint_exp(e) == 1)
	ptr = text("@");
      else
	ptr = cat(text("@"),text("{"),exp2doc(e),text("}"));
      break;
    case TaggedArray_ps: ptr = text("?"); break;
    }
    switch (compress(rgn)) {
    case HeapRgn: return cat(ptr,rest);
    default: return cat(ptr,typ2doc(rgn),text(" "),rest);
    }
  }
}

doc_t rgn2doc(type_t t) {
  switch (compress(t)) {
  case HeapRgn: return text("`H");
  default: return ntyp2doc(t);
  }
}

static void effects2docs(list_t<doc_t,`H> @ `r rgions,
			 list_t<doc_t,`H> @ `r effects,
			 type_t t)
{
  switch (compress(t)) {
  case &AccessEff(r): *rgions = new List(rgn2doc(r), *rgions); break;
  case &JoinEff(ts):
    for (; ts != NULL; ts = ts->tl) {
      effects2docs(rgions, effects, ts->hd);
    }
    break;
  default: *effects = new List(typ2doc(t),*effects); break;
  }
}

doc_t eff2doc(type_t t) {
  list_t <doc_t> rgions = NULL, effects = NULL;
  effects2docs(&rgions, &effects, t);
  rgions = List::imp_rev(rgions);
  effects = List::imp_rev(effects);
  if (rgions == NULL && effects != NULL) {
    return group("","","+",effects);
  } else {
    let doc1 = group("{","}",",",rgions);
    return group("","","+",List::imp_append(effects,new List(doc1,NULL)));
  }
}

// Convert a normalized typ to a doc
doc_t ntyp2doc(type_t t) {
  doc_t s;
  switch (t) {
    // The first three cases never turn up in normalized types.
  case &ArrayType(_,_,_): return text("[[[array]]]"); //nil_doc();
  case &FnType(_)       : return nil_doc();
  case &PointerType(_)  : return nil_doc();
    // The remaining cases are possible.
  case VoidType: s = text("void"); break;
  case &Evar(k,topt,i,tvs):
    if (topt != NULL)
      // This is an error case, topt should be NULL in a normalized type
      return(ntyp2doc(topt->v));
    else s = cat(text("%"),
                 text("("),
                 text(aprintf("%d",i)),
                 (!print_full_evars || tvs == NULL) ?
                 text("") : tvars2doc(tvs->v),
                 text(")::"),k == NULL ? text("?") : kind2doc(k->v));
    break;
  case &VarType(tv):
    s = textptr(tv->name);
    if (print_all_kinds) {
      s = cat(s,text("::"),kindbound2doc(tv->kind));
    }
    //FIX: sometimes need explicit kinds!
    //Mathieu: only if we try to declare kinds inside functions arguments
    if (rewrite_temp_tvars && is_temp_tvar(tv)) {
      // we're trying to print a temporary tvar,
      // replace it by _ followed by a comment
      s = cat(text("_ /* "), s, text(" */"));
      // we cannot print its kind after the underscore for _::E doesn't parse
    }
    break;
  case &TunionType(TunionInfo(tu_info,ts,r)):
    switch(tu_info) {
    case &UnknownTunion(UnknownTunionInfo(n,is_x)): fallthru(n,is_x);
    case &KnownTunion(&(&Tuniondecl(_,n,_,_,is_x))):
      let kw = text(is_x ? "xtunion " : "tunion ");
      switch (compress(r)) {
      case HeapRgn:
	s = cat(kw,qvar2doc(n),tps2doc(ts)); break;
      default:
	s = cat(kw,typ2doc(r),text(" "),qvar2doc(n),tps2doc(ts)); break;
      }
      break;
    }
    break;
  case &TunionFieldType(TunionFieldInfo(tuf_info,ts)):
    switch(tuf_info) {
    case &UnknownTunionfield(UnknownTunionFieldInfo(tname,fname,is_x)):
      fallthru(tname,is_x,fname);
      case &KnownTunionfield(&Tuniondecl(_,tname,_,_,is_x),
                             &Tunionfield(fname,_,_,_,_)):
                               let kw = text(is_x ? "xtunion " : "tunion ");
      s = cat(kw, qvar2doc(tname),text("."),qvar2doc(fname));
      break;
    }
    break;
  case &IntType(sn,sz):
    string_t sns;
    string_t ts;
    switch (sn) {
    case Signed:   sns = "";          break;
    case Unsigned: sns = "unsigned "; break;
    }
    switch (sz) {
    case B1:
      switch (sn) {
      case Signed:   sns = "signed "; break;
      case Unsigned: break;
      }
      ts = "char";
      break;
    case B2: ts = "short"; break;
    case B4: ts = "int";   break;
    case B8: ts = (to_VC ? "__int64" : "long long"); break;
    }
    s = text(aprintf("%s%s",sns,ts));
    break;
  case FloatType:  s = text("float");  break;
  case &DoubleType(b): 
    if (b) 
      s = text("long double"); 
    else 
      s = text("double");
    break;
  case &TupleType(ts):
    s = cat(text("$"),args2doc(ts));
    break;
  case &StructType(n,ts,_):
    if (n == NULL)
      s = cat(text("struct "),tps2doc(ts));
    else
      s = cat(text("struct "),
              (n==NULL) ? nil_doc() : qvar2doc((qvar_t)n),
              tps2doc(ts));
    break;
  case &UnionType(n,ts,_):
    if (n == NULL)
      s = cat(text("union "),tps2doc(ts));
    else
      s = cat(text("union "),
              (n==NULL) ? nil_doc() : qvar2doc((qvar_t)n),
              tps2doc(ts));
    break;
  case &AnonStructType(fs):
    s = cat(text("struct {"),
            nest(2, structfields2doc(fs)),
            text("}"));
    break;
  case &AnonUnionType(fs):
    s = cat(text("union {"),
            nest(2, structfields2doc(fs)),
            text("}"));
    break;
  case &AnonEnumType(fs):
    s = cat(text("enum {"),nest(2, enumfields2doc(fs)), text("}"));
    break;
  case &EnumType(n,_):
    s = cat(text("enum "),qvar2doc(n)); break;
  case &SizeofType(t):
    s = cat(text("sizeof_t<"),typ2doc(t),text(">"));
    break;
  case &TypedefType(n,ts,topt):
    // NB: we could print out the expanded typedef by following the topt
    // pointer (when non-NULL).
    // TJ: NO, the way to do that is to expand typedefs in to_tms -- see
    // for example the EVar case in to_tms.  The problem is that topt->v is
    // not going to be "normalized" (i.e., come out of to_tms).
    s = cat(qvar2doc(n),tps2doc(ts));
    break;
  case &RgnHandleType(t):
    s = cat(text("region_t<"),rgn2doc(t),text(">"));
    break;
  case HeapRgn:
    s = rgn2doc(t);
    break;
  case &RgnsEff(t):
    s = cat(text("regions("),typ2doc(t),text(")"));
    break;
  case &AccessEff(_):
    fallthru;
  case &JoinEff(_):
    s = eff2doc(t);
    break;
  }
  return s;
}

doc_t vo2doc(opt_t<var_t> vo) {
  return (vo==NULL)?nil_doc():text(*(vo->v));
}

doc_t rgn_cmp2doc($(type_t,type_t)@ cmp) {
  let &$(r1,r2) = cmp;
  return cat(rgn2doc(r1),text(" < "),rgn2doc(r2));
}

doc_t rgnpo2doc(list_t<$(type_t,type_t)@> po) {
  return group("","",",",List::map(rgn_cmp2doc,po));
}

doc_t funarg2doc($(opt_t<var_t>,tqual_t,type_t)@ t) {
  opt_t<doc_t> dopt = ((*t)[0]==NULL)?NULL:(new Opt(text(*((*t)[0]->v))));
  return tqtd2doc((*t)[1],(*t)[2],dopt);
}

doc_t funargs2doc(list_t<$(opt_t<var_t>,tqual_t,type_t)@> args,bool c_varargs,
                  vararg_info_t *cyc_varargs, opt_t<type_t> effopt,
                  list_t<$(type_t,type_t)@> rgn_po) {
  let arg_docs = List::map(funarg2doc,args);
  doc_t eff_doc;
  if (c_varargs) 
    arg_docs = List::append(arg_docs,new List(text("..."),NULL));
  else if (cyc_varargs != NULL) {
    let varargs_doc = cat(text("..."),
                          cyc_varargs->inject ? text(" inject ") : text(" "),
                          funarg2doc(new $(cyc_varargs->name,cyc_varargs->tq,
                                           cyc_varargs->type)));
    arg_docs = List::append(arg_docs,new List(varargs_doc,NULL));
  }
  let arg_doc = group("","",",",arg_docs);
  if (effopt != NULL) 
    arg_doc = cat(arg_doc,text(";"),eff2doc(effopt->v));
  if (rgn_po != NULL) 
    arg_doc = cat(arg_doc,text(":"),rgnpo2doc(rgn_po));
  return cat(text("("),arg_doc,text(")"));
}

$(opt_t<var_t>,tqual_t,type_t)@ arg_mk_opt($(var_t,tqual_t,type_t)@ arg) {
  return new $(new Opt((*arg)[0]),
               (*arg)[1],(*arg)[2]);
}

doc_t var2doc(var_t v) { return text(*v); }

doc_t qvar2doc(qvar_t q) {
  let prefix = NULL;
  let match;
  switch ((*q)[0]) {
  case Loc_n:
    fallthru(NULL);
  case &Rel_n(x):
    match = false;
    prefix = x;
    break;
  case &Abs_n(x):
    match = use_curr_namespace && list_prefix(strptrcmp, x, curr_namespace);
    prefix = qvar_to_Cids && add_cyc_prefix ? new List(cyc_stringptr, x) : x;
    break;
  }
  if (qvar_to_Cids) {
    return text(str_sepstr(List::append(prefix,
						new List((*q)[1],NULL)),"_"));
  } else {
    // don't print the prefix it matches the current namespaces
    if (match)
      return var2doc((*q)[1]);
    else
      return text(str_sepstr(List::append(prefix,
						  new List((*q)[1],NULL)),"::"));
  }
}

doc_t typedef_name2doc(qvar_t v) {
  // behave as qvar2doc when translating to C
  if (qvar_to_Cids) return qvar2doc(v);

  // otherwise we should not print the complete namespace here (it won't reparse)
  if (use_curr_namespace) {
    switch ((*v)[0]) {
    case Loc_n: fallthru;
    case &Rel_n(NULL): return var2doc((*v)[1]);
    case &Abs_n(l):
      if (list_cmp(strptrcmp, l, curr_namespace) == 0) {
	return var2doc((*v)[1]);
      } else {
	fallthru;
      }
    default: return cat(text("/* bad namespace : */ "), qvar2doc(v));
    }
  } else {
    return var2doc((*v)[1]);
  }
}

doc_t typ2doc(type_t t) {
  return tqtd2doc(empty_tqual(), t, NULL);
}

// higher precedence means binds more tightly
// not quite right b/c unary operators allow cast expressions,
//   but that just means we put extra parens in.
//       Eg. &((foo) x) has unnecessary parens
// warning -- as a quick hack, exp2_doc_prec also uses some constants
//            in key places
// BIGGER WARNING: Absyndump::dumpexp_prec has to use the same constants!!!
int exp_prec(exp_t e) {
  switch (e->r) {
  case &Const_e(_):       return 10000;
  case &Var_e(_,_):       return 10000;
  case &UnknownId_e(_):   return 10000;
  case &Primop_e(p,_):
    switch (p) {
    case Plus:           return 100;
    case Times:          return 110;
    case Minus:          return 100;
    case Div:            return 110;
    case Mod:            return 110;
    case Eq:             return  70;
    case Neq:            return  70;
    case Gt:             return  80;
    case Lt:             return  80;
    case Gte:            return  80;
    case Lte:            return  80;
    case Not:            return 130;
    case Bitnot:         return 130;
    case Bitand:         return  60;
    case Bitor:          return  40;
    case Bitxor:         return  50;
    case Bitlshift:      return  90;
    case Bitlrshift:     return  80; // unlike C (see grammar)
    case Bitarshift:     return  80; // doesn't actually exist (see grammar)
    case Size:           return 140; // foo.size (same as struct member)
    }
  case &AssignOp_e(_,_,_):      return  20;
  case &Increment_e(_,_):       return 130;
  case &Conditional_e(_,_,_):   return  30; // note || and && are hiding here!
  case &SeqExp_e(_,_):          return  10;
  case &UnknownCall_e(_,_):     return 140;
  case &FnCall_e(_,_,_):        return 140;
  case &Throw_e(_):             return 130;
  case &NoInstantiate_e(e2):    return exp_prec(e2);
  case &Instantiate_e(e2,_):    return exp_prec(e2);
  case &Cast_e(_,_):            return 120;
  case &New_e(_,_):             return 15; // ???
  case &Address_e(_):           return 130;
  case &Sizeoftyp_e(_):         return 130;
  case &Sizeofexp_e(_):         return 130;
  case &Offsetof_e(_,_):        return 130;
  case &Gentyp_e(_,_):            return 130;
  case &Deref_e(_):             return 130;
  case &StructMember_e(_,_):    return 140;
  case &StructArrow_e(_,_):     return 140; // ???
  case &Subscript_e(_,_):       return 140;
  case &Tuple_e(_):             return 150;
  case &CompoundLit_e(_,_):     fallthru;
  case &Array_e(_):             fallthru;
  case &Comprehension_e(_,_,_): fallthru;
  case &Struct_e(_,_,_,_):      fallthru;
  case &AnonStruct_e(_,_):      fallthru;
  case &Tunion_e(_,_,_,_,_):    fallthru;
  case &Enum_e(_,_,_):          fallthru;
  case &AnonEnum_e(_,_,_):      fallthru;
  case &Malloc_e(_):            return 140;
  case &UnresolvedMem_e(_,_):   return 140; // ???
  case &StmtExp_e(_):           return 10000;
  case &Codegen_e(_):           return 140;
  case &Fill_e(_):              return 140;
  }
}

doc_t exp2doc(exp_t e) {
  return exp2doc_prec(0,e);
}

doc_t exp2doc_prec(int inprec, exp_t e) {
  int myprec = exp_prec(e);
  doc_t s;
  switch (e->r) {
  case &Const_e(c):     s = cnst2doc(c); break;
  case &Var_e(x,_):     fallthru(x);
  case &UnknownId_e(x): s = qvar2doc(x); break;
  case &Primop_e(p,es): s = primapp2doc(myprec,p,es); break;
  case &AssignOp_e(e1,popt,e2):
    s = cat(exp2doc_prec(myprec,e1),
            text(" "),
            (popt == NULL) ? text("") : prim2doc(popt->v),
            text("= "),
            exp2doc_prec(myprec,e2));
    break;
  case &Increment_e(e2,i):
    let es = exp2doc_prec(myprec,e2);
    switch (i) {
    case PreInc:  s = cat(text("++"),es); break;
    case PreDec:  s = cat(text("--"),es); break;
    case PostInc: s = cat(es,text("++")); break;
    case PostDec: s = cat(es,text("--")); break;
    }
    break;
  case &Conditional_e(e1,e2,e3):
    // decompile to && and || if possible
    switch ($(e2->r,e3->r)) {
      // JGM:  this causes a bug in some places...notably the
      //   file tools/cyclex/compact.cyc
      //case $(Const_e(Int_c(Signed,1)),_):
      //s = cat(exp2doc_prec(33,e1), text(" || "), exp2doc_prec(33,e3));
      //break;
      //case $(_,Const_e(Int_c(Signed,0))):
      //s = cat(exp2doc_prec(37,e1), text(" && "), exp2doc_prec(37,e2));
      //break;
      //
    default:
      s = cat(exp2doc_prec(myprec,e1), text(" ? "), exp2doc_prec(0,e2),
              text(" : "), exp2doc_prec(myprec,e3));
      break;
    }
    break;
  case &SeqExp_e(e1,e2):
    // DAN: put in parens because in initializers , doesn't mean SeqExp and
    // our recursive descent doesn't know if we're in an initializer.
    s = cat(text("("), exp2doc(e1), text(", "), exp2doc(e2), text(")"));
    break;
  case &UnknownCall_e(e1,es):
    s = cat(exp2doc_prec(myprec,e1),
            text("("),
            exps2doc_prec(20,es),
            text(")"));
    break;
  case &FnCall_e(e1,es,_):
    s = cat(exp2doc_prec(myprec,e1),
            text("("),
            exps2doc_prec(20,es),
            text(")"));
    break;
  case &Throw_e(e1):
    s = cat(text("throw "), exp2doc_prec(myprec,e1));
    break;
  case &NoInstantiate_e(e1):
    s = exp2doc_prec(inprec,e1);
    break;
  case &Instantiate_e(e1,_):
    s = exp2doc_prec(inprec,e1);
    break;
  case &Cast_e(t,e1):
    s = cat(text("("),
            typ2doc(t),
            text(")"),
            exp2doc_prec(myprec,e1));
    break;
  case &Address_e(e1):
    s = cat(text("&"),
            exp2doc_prec(myprec,e1));
    break;
  case &New_e(ropt,e1):
    if (ropt == NULL)
      s = cat(text("new "),exp2doc_prec(myprec,e1));
    else
      s = cat(text("rnew("),exp2doc((exp_t)ropt),text(") "),
              exp2doc_prec(myprec,e1));
    break;
  case &Sizeoftyp_e(t):  s = cat(text("sizeof("), typ2doc(t), text(")")); break;
  case &Sizeofexp_e(e1): s = cat(text("sizeof("),exp2doc(e1), text(")")); break;
  case &Offsetof_e(t,&StructField(n)): 
    s = cat(text("offsetof("), typ2doc(t), text(","), textptr(n), text(")"));
    break;
  case &Offsetof_e(t,&TupleIndex(n)): 
    s = cat(text("offsetof("), typ2doc(t), text(","), text(aprintf("%d",n)), text(")"));
    break;
  case &Gentyp_e(tvs,t):  s = cat(text("__gen("), tvars2doc(tvs), typ2doc(t), text(")")); break;
  case &Deref_e(e1):
    s = cat(text("*"), exp2doc_prec(myprec,e1));
    break;
  case &StructMember_e(e1,n):
    s = cat(exp2doc_prec(myprec,e1), text("."), textptr(n));
    break;
  case &StructArrow_e(e1,n):
    s = cat(exp2doc_prec(myprec,e1), text("->"), textptr(n));
    break;
  case &Subscript_e(e1,e2):
    s = cat(exp2doc_prec(myprec,e1),
            text("["),
            exp2doc(e2),
            text("]"));
    break;
  case &Tuple_e(es):
    s = cat(text("$("),
            exps2doc_prec(20,es),
            text(")"));
    break;
  case &CompoundLit_e(vat,des):
    s = cat(text("("),
            typ2doc((*vat)[2]), // OK to ignore qualifiers??
            text(")"),
            group("{","}",",",List::map(de2doc,des)));
    break;
  case &Array_e(des):
    s = group("{","}",",",List::map(de2doc,des));
    break;
  case &Comprehension_e(vd,e1,e2):
    s = cat(text("{for "),
            text(*((*vd->name)[1])),
            text(" < "),
            exp2doc(e1),
            text(" : "),
            exp2doc(e2),
            text("}"));
    break;
  case &Struct_e(n,_,des,_):
    s = cat(qvar2doc(n),
            group("{","}",",",List::map(de2doc,des)));
    break;
  case &AnonStruct_e(_,des):
    s = group("{","}",",",List::map(de2doc,des));
    break;
  case &Tunion_e(_,_,es,_,ef):
    if (es == NULL)
      // special case: a nullary tunion constant is printed "foo" not "foo()"
      s = qvar2doc(ef->name);
    else
      s = cat(qvar2doc(ef->name),
              egroup("(",")",",",List::map(exp2doc,es)));
    break;
  case &Enum_e(n,_,_):
    s = qvar2doc(n);
    break;
  case &AnonEnum_e(q,_,_):
    s = qvar2doc(q);
    break;
  case &Malloc_e(MallocInfo{is_calloc,rgnopt,topt,e,_}):
    // Note: This is for Cyclone's malloc, not the mallocs introduced during
    //       translation to C, which are function calls.
    if (is_calloc) {
      // topt should not be NULL for calloc's
      exp_t st = sizeoftyp_exp(*topt,NULL);
      if (rgnopt == NULL)
        s = cat(text("calloc("),exp2doc(e),text(","),exp2doc(st),text(")"));
      else 
        s = cat(text("rcalloc("),exp2doc((exp_t)rgnopt),text(","),
                exp2doc(e),text(","),exp2doc(st),text(")"));
    } else {
      exp_t new_e;
      // see comments in absyn.h
      if (topt == NULL)
        new_e = e;
      else 
        new_e = times_exp(sizeoftyp_exp(*topt,NULL),e,NULL);
    
      if (rgnopt == NULL)
        s = cat(text("malloc("),exp2doc(new_e),text(")"));
      else
        s = cat(text("rmalloc("),exp2doc((exp_t)rgnopt),text(","),
                exp2doc(new_e),text(")"));
    }
    break;
  case &UnresolvedMem_e(n,des):
    // Currently n is always NULL from the parser
    s = group("{","}",",",List::map(de2doc,des));
    break;
  case &StmtExp_e(s2):
    s = cat(text("({ "),
            nest(2,stmt2doc(s2)),
            text(" })"));
    break;
  case &Codegen_e(fd):
    s = cat(text("codegen("),
            nest(2,decl2doc(new Decl(new Fn_d(fd),e->loc))),
            text(")"));
    break;
  case &Fill_e(e1):
    s = cat(text("fill("),
            nest(2,exp2doc(e1)),
            text(")"));
    break;
  }
  if(inprec >= myprec)
    s = cat(text("("), s, text(")"));
  return s;
}

doc_t designator2doc(designator_t d) {
  switch (d) {
  case &ArrayElement(e): return cat(text(".["), exp2doc(e), text("]"));
  case &FieldName(v):    return cat(text("."), textptr(v));
  }
}

doc_t de2doc($(list_t<designator_t>,exp_t)@ de) {
  if ((*de)[0] == NULL) return exp2doc((*de)[1]);
  else return cat(egroup("","=","=",List::map(designator2doc,(*de)[0])),
                  exp2doc((*de)[1]));
}

doc_t exps2doc_prec(int inprec, list_t<exp_t> es) {
  return group("","",",",List::map_c(exp2doc_prec,inprec,es));
}

// FIX: take care of sign for Char_c and Short_c
doc_t cnst2doc(cnst_t c) {
  switch (c) {
  case &Char_c(sg,ch):     return text(aprintf("'%s'",char_escape(ch)));
  case &Short_c(sg,s):     return text(aprintf("%d",(int)s));
  case &Int_c(Signed,i):   return text(aprintf("%d",i));
  case &Int_c(Unsigned,i): return text(aprintf("%u",(unsigned)i));
  case &LongLong_c(sg,i):  return text("<<FIX LONG LONG CONSTANT>>"); // FIX
  case &Float_c(x):  return text(x);
  case Null_c:      return text("NULL");
  case &String_c(s):
    return cat(text("\""), text(string_escape(s)), text("\""));
  }
}

doc_t primapp2doc(int inprec, primop_t p,list_t<exp_t> es) {
  doc_t ps = prim2doc(p);
  if (p == (primop_t)Size) {
    if (es == NULL || es->tl != NULL)
      throw new Failure(aprintf("Absynpp::primapp2doc Size: %s with bad args",
                                string_of_doc(ps,72)));
    let d = exp2doc_prec(inprec,es->hd);
    return cat(d,text(".size"));

  } else {
    list_t<doc_t> ds = List::map_c(exp2doc_prec,inprec,es);
    if (ds == NULL)
      throw new Failure(aprintf("Absynpp::primapp2doc: %s with no args",
                                string_of_doc(ps,72)));
    else if (ds->tl == NULL)
      return cat(ps,text(" "),ds->hd);
    else if (ds->tl->tl != NULL)
      throw new Failure(aprintf("Absynpp::primapp2doc: %s with more than 2 args",
                                string_of_doc(ps,72)));
    else
      return cat(ds->hd,text(" "),ps,text(" "),ds->tl->hd);
  } 
}

string_t prim2str(primop_t p) {
  switch (p) {
  case Plus: return "+";
  case Times: return "*";
  case Minus: return "-";
  case Div: return "/";
  case Mod: return "%";
  case Eq: return "==";
  case Neq: return "!=";
  case Gt: return ">";
  case Lt: return "<";
  case Gte: return ">=";
  case Lte: return "<=";
  case Not: return "!";
  case Bitnot: return "~";
  case Bitand: return "&";
  case Bitor: return "|";
  case Bitxor: return "^";
  case Bitlshift: return "<<";
  case Bitlrshift: return ">>";
  case Bitarshift: return ">>>";
  case Size: return "size";
  }
}

doc_t prim2doc(primop_t p) {
  return text(prim2str(p));
}

doc_t structarg2doc($(opt_t<var_t>,exp_t)@ t) {
  if ((*t)[0] == NULL)
    return exp2doc((*t)[1]);
  else return cat(textptr((*t)[0]->v),
                  text(" = "),
                  exp2doc((*t)[1]));
}

bool is_declaration(stmt_t s) {
  switch (s->r) {
  case &Decl_s(_,_): return true;
  default: return false;
  }
}

doc_t stmt2doc(stmt_t st) {
  doc_t s;
  switch (st->r) {
  case Skip_s:
    s = text(";"); break;
  case &Exp_s(e):
    s = cat(exp2doc(e),text(";")); break;
  case &Seq_s(s1,s2):
    if (decls_first) {
      if (is_declaration(s1))
	s = cat(text("{ "),
                nest(2,stmt2doc(s1)),
                line_doc(),
                text("}"),
                line_doc(),
                is_declaration(s2)? // for gcc compatibility
                cat(text("{ "),
                    nest(2,stmt2doc(s2)),
                    text("}"),
                    line_doc())
                : stmt2doc(s2));
      else if (is_declaration(s2)) // for gcc compatibility
	s = cat(stmt2doc(s1),
                line_doc(),
                text("{ "),
                nest(2,stmt2doc(s2)),
                text("}"),
                line_doc());
      else
	s = ppseql(stmt2doc,"",new List(s1,new List(s2,NULL)));
    }
    else
      s = ppseql(stmt2doc,"",new List(s1,new List(s2,NULL)));
    break;
  case &Return_s(eopt):
    if (eopt == NULL)
      s = text("return;");
    else
      s = cat(text("return "),
              (eopt==NULL)?nil_doc():exp2doc((exp_t)eopt),
              text(";"));
    break;
  case &IfThenElse_s(e,s1,s2):
    bool print_else;
    switch (s2->r) {
    case Skip_s: print_else = false; break;
    default:     print_else = true;  break;
    }
    s = cat(text("if ("),
            exp2doc(e),
            text(") {"),
            nest(2,cat(line_doc(),stmt2doc(s1))),
            line_doc(),
            text("}"),
            print_else ?
            cat(line_doc(),
                text("else {"),
                nest(2,cat(line_doc(),stmt2doc(s2))),
                line_doc(),
                text("}"))
            : nil_doc());
    break;
  case &While_s($(e,_),s1):
    s = cat(text("while ("),
            exp2doc(e),
            text(") {"),
            nest(2,cat(line_doc(),stmt2doc(s1))),
            line_doc(),
            text("}"));
    break;
  case &Break_s(_):    s = text("break;"); break;
  case &Continue_s(_): s = text("continue;"); break;
  case &Goto_s(x,_):   s = text(aprintf("goto %s;",*x)); break;
  case &For_s(e1,$(e2,_),$(e3,_),s1):
    s = cat(text("for("),
            exp2doc(e1),
            text("; "),
            exp2doc(e2),
            text("; "),
            exp2doc(e3),
            text(") {"),
            nest(2,cat(line_doc(),stmt2doc(s1))),
            line_doc(),
            text("}"));
    break;
  case &ForArray_s(ForArrayInfo{d,$(e1,_),$(e2,_),s1}):
    s = cat(text("forarray("),
            ppseql(vardecl2doc, " ", d),
            exp2doc(e1),
            text("; "),
            exp2doc(e2),
            text(") {"),
            nest(2,cat(line_doc(),stmt2doc(s1))),
            line_doc(),
            text("}"));
    break;
  case &Switch_s(e,ss):
    s = cat(text("switch ("),
            exp2doc(e),
            text(") {"),
            line_doc(),
            switchclauses2doc(ss),
            line_doc(),
            text("}"));
    break;
  case &SwitchC_s(e,ss):
    s = cat(text("switch \"C\" ("),
	    exp2doc(e),
	    text(") {"),
	    line_doc(),
	    switchCclauses2doc(ss),
	    line_doc(),
	    text("}"));
    break;
  case &Fallthru_s(NULL,_): s = text("fallthru;"); break;
  case &Fallthru_s(es,_):
    s = cat(text("fallthru("), exps2doc_prec(20,es), text(");")); break;
  case &Decl_s(d,s1):
    s = cat(decl2doc(d),
            line_doc(),
            stmt2doc(s1));
    break;
  case &Cut_s(s1):
    s = cat(text("cut "),
            nest(2,stmt2doc(s1)));
    break;
  case &Splice_s(s1):
    s = cat(text("splice "),
            nest(2,stmt2doc(s1)));
    break;
  case &Label_s(x,s1):
    if (decls_first && is_declaration(s1)) {
      s = cat(textptr(x),
              text(": {"),
              line_doc(),
              nest(2,stmt2doc(s1)),
              line_doc(),
              text("}"));
    } else
      s = cat(textptr(x),text(": "),stmt2doc(s1));
    break;
  case &Do_s(s1,$(e,_)):
    s = cat(text("do {"),
            line_doc(),
            nest(2,stmt2doc(s1)),
            line_doc(),
            text("} while ("),
            exp2doc(e),
            text(");"));
    break;
  case &TryCatch_s(s1,ss):
    s = cat(text("try {"),
            line_doc(),
            nest(2,stmt2doc(s1)),
            line_doc(),
            text("} catch {"),
            line_doc(),
            nest(2,switchclauses2doc(ss)),
            line_doc(),
            text("}"));
    break;
  case &Region_s(tv,vd,s1):
    s = cat(text("region<"),
            textptr(get_name(tv)),
            text(">" ),
            qvar2doc(vd->name),
            text("{"),
            line_doc(),
            nest(2,stmt2doc(s1)),
            line_doc(),
            text("}"));
    break;
  }
  return s;
}

doc_t pat2doc(pat_t p) {
  doc_t s;
  switch (p->r) {
  case Wild_p: s = text("_"); break;
  case Null_p: s = text("NULL"); break;
  case &Int_p(sg,i):
    if (sg == (sign_t)Signed)
      s = text(aprintf("%d",i));
    else s = text(aprintf("%u",i));
    break;
  case &Char_p(ch): s = text(aprintf("'%s'",char_escape(ch))); break;
  case &Float_p(x): s = text(x); break;
  case &Var_p(vd):  s = qvar2doc(vd->name); break;
  case &Tuple_p(ts):
    s = cat(text("$("),
            ppseq(pat2doc,",",ts),
            text(")"));
    break;
  case &Pointer_p(p2):
    s = cat(text("&"),pat2doc(p2));
    break;
  case &Reference_p(vd):
    s = cat(text("*"),qvar2doc(vd->name));
    break;
  case &UnknownId_p(q):
    s = qvar2doc(q);
    break;
  case &UnknownCall_p(q,tvs,ps):
    s = cat(qvar2doc(q),
            tvars2doc(tvs),
            group("(",")",",",List::map(pat2doc,ps)));
    break;
  case &UnknownFields_p(q,tvs,dps):
    s = cat(qvar2doc(q),
            tvars2doc(tvs),
            group("{","}",",",List::map(dp2doc,dps)));
    break;
  case &Struct_p(sd,_,tvs,dps):
    s = cat(sd->name==NULL?nil_doc():qvar2doc(sd->name->v),
            tvars2doc(tvs),
            group("{","}",",",List::map(dp2doc,dps)));
    break;
  case &Enum_p(_,ef):
    s = qvar2doc(ef->name);
    break;
  case &AnonEnum_p(_,ef):
    s = qvar2doc(ef->name);
    break;
  case &Tunion_p(_,tuf,tvs,ps):
    if (ps == NULL)
      // special case: a nullary tunion constant is printed "foo" not "foo()"
      s = qvar2doc(tuf->name);
    else
      s = cat(qvar2doc(tuf->name),
              tvars2doc(tvs),
              egroup("(",")",",",List::map(pat2doc,ps)));
    break;
  }
  return s;
}

doc_t dp2doc($(list_t<designator_t>,pat_t)@ dp) {
  return cat(egroup("","=","=",List::map(designator2doc,(*dp)[0])),
             pat2doc((*dp)[1]));
}

doc_t switchclause2doc(switch_clause_t c) {
  if (c->where_clause == NULL && c->pattern->r == (raw_pat_t)Wild_p)
    return cat(text("default: "),
	       nest(2,cat(line_doc(),stmt2doc(c->body))));
  else if (c->where_clause == NULL)
    return cat(text("case "),
	       pat2doc(c->pattern),
	       text(": "),
	       nest(2,cat(line_doc(),stmt2doc(c->body))));
  else
    return cat(text("case "),
	       pat2doc(c->pattern),
	       text(" && "),
	       exp2doc((exp_t)c->where_clause),
	       text(": "),
	       nest(2,cat(line_doc(),stmt2doc(c->body))));
}

doc_t switchclauses2doc(list_t<switch_clause_t,`H> cs) {
  return ppseql(switchclause2doc,"",cs);
}

doc_t switchCclause2doc(switchC_clause_t c) {
  let &SwitchC_clause(e,s,_) = c;
  if(e == NULL)
    return cat(text("default: "),
	       nest(2,cat(line_doc(),stmt2doc(c->body))));
  else 
    return cat(text("case "),
	       exp2doc((exp_t)e),
	       text(": "),
	       nest(2,cat(line_doc(),stmt2doc(s))));
}

doc_t switchCclauses2doc(list_t<switchC_clause_t,`H> cs) {
  return ppseql(switchCclause2doc,"",cs);
}

doc_t enumfield2doc(enumfield_t f) {
  if (f->tag == NULL)
    return qvar2doc(f->name);
  else
    return cat(qvar2doc(f->name),text(" = "),exp2doc((exp_t)f->tag));
}

doc_t enumfields2doc(list_t<enumfield_t,`H> fs) {
  return ppseql(enumfield2doc,",",fs);
}

static doc_t id2doc(vardecl_t v) {
  return qvar2doc(v->name);
}

static doc_t ids2doc(list_t<vardecl_t,`H> vds) {
  return ppseq(id2doc,",",vds);
}

doc_t vardecl2doc(vardecl_t vd) {
  let &Vardecl{sc,name,tq,type,initializer,_,atts} = vd;
  doc_t s;
  doc_t sn = typedef_name2doc(name);
  doc_t attsdoc   = atts2doc(atts);
  doc_t beforenamedoc;
  if(!to_VC)
    beforenamedoc = attsdoc;
  else
    // lots of VC calling convention KLUDGE here -- atts doesn't have
    // the calling convention -- it's in type
    switch(compress(type)) {
    case &FnType(FnInfo(_,_,_,_,_,_,_,atts2)): 
      beforenamedoc = callconv2doc(atts2); break;
    default: beforenamedoc = nil_doc(); break;
    }
  s = cat((to_VC ? attsdoc : nil_doc()),
          scope2doc(sc),
          tqtd2doc(tq,type,new Opt(cat(beforenamedoc,sn))),
          (initializer == NULL)
          ? text("")
          : cat(text(" = "),exp2doc((exp_t)initializer)),
          text(";"));
  return s;
}

doc_t decl2doc(decl_t d) {
  doc_t s;
  switch (d->r) {
  case &Fn_d(fd):
    type_t t = new FnType(FnInfo{fd->tvs,
                                 fd->effect,
                                 fd->ret_type,
                                 List::map(arg_mk_opt,fd->args),
                                 fd->c_varargs, fd->cyc_varargs,
                                 fd->rgn_po,
                                 NULL});
    doc_t attsdoc   = atts2doc(fd->attributes);
    doc_t inlinedoc;
    if(fd->is_inline)
      if(to_VC)
	inlinedoc = text("__inline ");
      else
	inlinedoc = text("inline ");
    else
      inlinedoc = nil_doc();
    doc_t scopedoc  = scope2doc(fd->sc);
    doc_t beforenamedoc = (to_VC ? callconv2doc(fd->attributes) : attsdoc);
    doc_t namedoc   = typedef_name2doc(fd->name);
    doc_t tqtddoc   = tqtd2doc(Tqual(false,false,false), t,
			       new Opt(cat(beforenamedoc,namedoc)));
    doc_t bodydoc   = cat(text(" {"),
			  nest(2,cat(line_doc(),stmt2doc(fd->body))),
			  line_doc(),
			  text("}"));
    s = cat(inlinedoc,scopedoc,tqtddoc,bodydoc);
    if(to_VC)
      s = cat(attsdoc,s);
    break;
    
  case &Struct_d(sd):
    if (sd->fields==NULL)
      s = cat(scope2doc(sd->sc),
              text("struct "),
              (sd->name==NULL)?text(""):typedef_name2doc(sd->name->v),
              ktvars2doc(sd->tvs),
              text(";"));
    else {
      s = cat(scope2doc(sd->sc),
              text("struct "),
              (sd->name==NULL)?text(""):typedef_name2doc(sd->name->v),
              ktvars2doc(sd->tvs),
              text(" {"),
              nest(2, cat(line_doc(),structfields2doc(sd->fields->v))),
              line_doc(),
              text("}"),
              atts2doc(sd->attributes),
              text(";"));
    }
    break;
  case &Union_d(ud):
    if (ud->fields==NULL)
      s = cat(scope2doc(ud->sc),
              text("union "),
              (ud->name==NULL)?text(""):qvar2doc(ud->name->v),
              tvars2doc(ud->tvs),
              text(";"));
    else {
      s = cat(scope2doc(ud->sc),
              text("union "),
              (ud->name==NULL)?text(""):qvar2doc(ud->name->v),
              tvars2doc(ud->tvs),
              text(" {"),
              nest(2, cat(line_doc(),structfields2doc(ud->fields->v))),
              line_doc(),
              text("}"),
              atts2doc(ud->attributes),
              text(";"));
    }
    break;
  case &Var_d(vd):
    s = vardecl2doc(vd);
    break;
  case &Tunion_d(&Tuniondecl(sc,name,tvs,fields,is_xtunion)):
    if (fields==NULL)
      s = cat(scope2doc(sc),
              (is_xtunion ? text("xtunion ") : text("tunion ")),
              (is_xtunion ? qvar2doc(name) : typedef_name2doc(name)),
              ktvars2doc(tvs),
              text(";"));
    else
      s = cat(scope2doc(sc),
              (is_xtunion ? text("xtunion ") : text("tunion ")),
              (is_xtunion ? qvar2doc(name) : typedef_name2doc(name)),
              ktvars2doc(tvs),
              text(" {"),
              nest(2, cat(line_doc(),tunionfields2doc(fields->v))),
              line_doc(),
              text("};"));
    break;
  case &Let_d(p,_,_,e,_):
    s = cat(text("let "),
            pat2doc(p),
            text(" = "),
            exp2doc(e),
            text(";"));
    break;
  case &Letv_d(vds):
    s = cat(text("let "),
            ids2doc(vds),
            text(";"));
    break;
  case &Enum_d(&Enumdecl{sc,n,fields}):
    if (fields == NULL)
      s = cat(scope2doc(sc),
              text("enum "),
              typedef_name2doc(n),
              text(";"));
    else
      s = cat(scope2doc(sc),
              text("enum "),
              qvar2doc(n),
              text(" {"),
              nest(2, cat(line_doc(),enumfields2doc(fields->v))),
              line_doc(),
              text("};"));
    break;
  case &Typedef_d(td):
    s = cat(text("typedef "),
            tqtd2doc(Tqual(false,false,false),
                   td->defn,
		   new Opt(cat(typedef_name2doc(td->name),tvars2doc(td->tvs)))),
            text(";"));

    break;
  case &Namespace_d(v,tdl):
    if (use_curr_namespace) curr_namespace_add(v);
    s = cat(text("namespace "),
            textptr(v),
            text(" {"),
            line_doc(),
            ppseql(decl2doc,"",tdl),
            line_doc(),
            text("}"));
    if (use_curr_namespace) curr_namespace_drop();
    break;
  case &Using_d(q,tdl):
    if (print_using_stmts) {
      s = cat(text("using "),
              qvar2doc(q),
              text(" {"),
              line_doc(),
              ppseql(decl2doc,"",tdl),
              line_doc(),
              text("}"));
    } else {
      s = cat(text("/* using "),
              qvar2doc(q),
              text(" { */"),
              line_doc(),
              ppseql(decl2doc,"",tdl),
              line_doc(),
              text("/* } */"));
    }
    break;
  case &ExternC_d(tdl):
    if (print_externC_stmts) {
      s = cat(text("extern \"C\" {"),
              line_doc(),
              ppseql(decl2doc,"",tdl),
              line_doc(),
              text("}"));
    } else {
      s = cat(text("/* extern \"C\" { */"),
              line_doc(),
              ppseql(decl2doc,"",tdl),
              line_doc(),
              text("/* } */"));
    }
    break;
  }
  return s;
}

doc_t scope2doc(scope_t sc) {
  switch (sc) {
  case Static:   return text("static ");
  case Public:   return nil_doc();
  case Extern:   return text("extern ");
  case ExternC:  return text("extern \"C\" ");
  case Abstract: return text("abstract ");
  }
}

// needed to detect default effect
bool exists_temp_tvar_in_effect(type_t t) {
  switch (t) {
  case &VarType(tv): return is_temp_tvar(tv);
  case &JoinEff(l): return exists(exists_temp_tvar_in_effect, l);
  default: return false;
  }
}

/* This is used in deciding whether to expand a typedef -- we don't
   expand a typedef of an anonymous function even if expand_typedefs
   is true, because we end up with anonymous structs in, e.g.,
   function parameters where gcc does not like them. */
bool is_anon_structtype(type_t t) {
  switch (t) {
  case &StructType(NULL,_,_):
    /* FIX: is this case even possible now that we have AnonStructType ?? */
    return true;
  case &AnonStructType(_):
    return true;
  case &TypedefType(_,_,NULL):
    return false;
  case &TypedefType(_,_,x):
    /* This won't loop if the types come from a .cyc file,
       because typedefs in Cyclone (or C) can't be recursive */
    return is_anon_structtype(x->v);
  default: return false;
  }
}

// Conversion between alternate forms of types
$(tqual_t,type_t,list_t<type_modifier_t>) to_tms(tqual_t tq,type_t t) {
  switch (t) {
  case &ArrayType(t2,tq2,e):
    // Throw away tq, can't qualify an array
    let $(tq3,t3,tml3) = to_tms(tq2,t2);
    type_modifier_t tm;
    if (e == NULL)
      tm = Carray_mod;
    else
      tm = new ConstArray_mod((exp_t)e);
    return $(tq3, t3, new List(tm,tml3));

  case &PointerType(PtrInfo(t2,rgntyp,nullable,tq2,b)):
    let $(tq3,t3,tml3) = to_tms(tq2,t2);
    tunion Pointer_Sort ps;
    switch ($(compress_conref(nullable)->v,compress_conref(b)->v)) {
    case $(&Eq_constr(true), &Eq_constr(&Upper_b(e))):
      ps = new Nullable_ps(e); break;
    case $(&Eq_constr(false), &Eq_constr(&Upper_b(e))):
      ps = new NonNullable_ps(e); break;
    case $(_, &Eq_constr(Unknown_b)):
      ps = TaggedArray_ps; break;
    default:
      // We need to print out something...
      // Dan: but this is impossible, isn't it??
      ps = TaggedArray_ps; break;
      // ps = impos("bad pointer type in Absynpp::to_tms"); break;
    }
    type_modifier_t tm = new Pointer_mod(ps,rgntyp,tq);
    return $(tq3, t3, new List(tm,tml3));

  case &FnType(FnInfo{typvars,effopt,t2,args,c_varargs,cyc_varargs,
                        rgn_po,fn_atts}):
    if (! print_all_tvars) {
      // don't print default effects
      // WARNING: this is our criterion to detect default effect, 
      // so it'd better be right
      if (effopt == NULL || exists_temp_tvar_in_effect(effopt->v)) {
	effopt = NULL;	//drop the existing effect
	typvars = NULL;	//drop the tvars, but they could be useful b/c of kinds!
      }
    } else {
      if (rewrite_temp_tvars) {
	// rewrite the temp variables so that they could parse
	// WARNING : we don't check for conflicts with user-defined tvars
	iter(rewrite_temp_tvar, typvars);
      }
    }

    // discard tq because you can't qualify a function
    let $(tq3,t3,tml3) = to_tms(empty_tqual(),t2);
    list_t<type_modifier_t> tms = tml3;
    // mess with attributes and arguments:
    // * for gcc: we put all attributes after the args
    // * for VC: 
    //   o we drop non-calling conventions on the floor (in fact,
    //     decl printing puts them at the declaration beginning)
    //   o for calling conventions, we put them before the args and rely
    //     on the caller to move them to the right place. KLUDGE! FIX!
    //     (I doubt this is right in all cases.)
    if (fn_atts != NULL && !to_VC)
      tms = new List(new Attributes_mod(NULL,fn_atts),tms);
    tms = new List(new Function_mod(new WithTypes(args,c_varargs,
                                                  cyc_varargs,effopt,
                                                  rgn_po)),tms);
    if(to_VC)
      for(; fn_atts != NULL; fn_atts = fn_atts->tl)
	switch(fn_atts->hd) {
	case Stdcall_att:  fallthru;
	case Cdecl_att:    fallthru;
	case Fastcall_att:
	  tms = new List(new Attributes_mod(NULL,new List(fn_atts->hd,NULL)),
			 tms);
	  goto AfterAtts;
	default: break;
	}
  AfterAtts:
    if (typvars != NULL)
      tms = new List(new TypeParams_mod(typvars,NULL,true),tms);
    return $(tq3,t3,tms);

  case &Evar(k,topt,i,_):
    if (topt == NULL)
      return $(tq,t,NULL);
    else
      return to_tms(tq,topt->v);

  case &TypedefType(n,ts,topt):
    if (topt == NULL || !expand_typedefs || is_anon_structtype(topt->v))
      return $(tq,t,NULL);
    else
      return to_tms(tq,topt->v);

  default: return $(tq,t,NULL);
  }
}

doc_t tqtd2doc(tqual_t tq, type_t t, opt_t<doc_t> dopt) {
  let $(tq,t,tms) = to_tms(tq,t);
  tms = List::imp_rev(tms);
  if (tms==NULL && dopt==NULL)
    return cat(tqual2doc(tq),ntyp2doc(t));
  else
    return
      cat(tqual2doc(tq),
          ntyp2doc(t),
          text(" "),
          dtms2doc((dopt==NULL)?nil_doc():dopt->v,tms));
}

doc_t structfield2doc(structfield_t f) {
  if (f->width != NULL)
    return cat(tqtd2doc(f->tq, f->type, new Opt(textptr(f->name))),
               text(":"), exp2doc((exp_t)f->width),
               atts2doc(f->attributes), text(";"));
  else
    return cat(tqtd2doc(f->tq, f->type, new Opt(textptr(f->name))),
               atts2doc(f->attributes), text(";"));
}

doc_t structfields2doc(list_t<structfield_t,`H> fields) {
  return ppseql(structfield2doc,"",fields);
}

doc_t tunionfield2doc(tunionfield_t f) {
  return cat(scope2doc(f->sc), typedef_name2doc(f->name),
             (f->tvs==NULL)?nil_doc(): ktvars2doc(f->tvs),
             (f->typs==NULL)?nil_doc():args2doc(f->typs));
}

doc_t tunionfields2doc(list_t<tunionfield_t,`H> fields) {
  return ppseql(tunionfield2doc,",",fields);
}

#ifndef PP_WIDTH
#define PP_WIDTH 72
#endif

//// Public interface -- extend with what clients actually want to print
void decllist2file(list_t<decl_t> tdl, FILE @f) {
  for (; tdl != NULL; tdl = tdl->tl) {
    file_of_doc(decl2doc(tdl->hd),PP_WIDTH,f);
    fprintf(f,"\n");
  }
}

string_t decllist2string(list_t<decl_t> tdl) {
  return string_of_doc(seql("",List::map(decl2doc,tdl)),PP_WIDTH);
}
string_t exp2string(exp_t e)     {return string_of_doc(exp2doc(e),  PP_WIDTH);}
string_t stmt2string(stmt_t s)   {return string_of_doc(stmt2doc(s), PP_WIDTH);}
string_t typ2string(type_t t)    {return string_of_doc(typ2doc(t),  PP_WIDTH);}
string_t qvar2string(qvar_t v)   {return string_of_doc(qvar2doc(v), PP_WIDTH);}
string_t typ2cstring(type_t t) {
  bool old_qvar_to_Cids = qvar_to_Cids;
  bool old_add_cyc_prefix = add_cyc_prefix;
  qvar_to_Cids = true;
  add_cyc_prefix = false;
  string_t s = typ2string(t);
  qvar_to_Cids = old_qvar_to_Cids;
  add_cyc_prefix = old_add_cyc_prefix;
  //  printf("for %s, add_cyc_prefix = %s, qvar_to_cids = %s\n", s, add_cyc_prefix ? "true " : "false", qvar_to_Cids ? "true " : "false");
  return s;
}
string_t prim2string(primop_t p) {return string_of_doc(prim2doc(p), PP_WIDTH);}
string_t pat2string(pat_t p)     {return string_of_doc(pat2doc(p),  PP_WIDTH);}

// used for error messages
string_t scope2string(scope_t sc) {
  switch (sc) {
  case Static:   return "static";
  case Public:   return "public";
  case Extern:   return "extern";
  case ExternC:  return "extern \"C\"";
  case Abstract: return "abstract";
  }
}
