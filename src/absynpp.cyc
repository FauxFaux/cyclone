/* Pretty printer for the abstract syntax.
   Copyright (C) 2001 Greg Morrisett, AT&T
   This file is part of the Cyclone compiler.

   The Cyclone compiler is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   The Cyclone compiler is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with the Cyclone compiler; see the file COPYING. If not,
   write to the Free Software Foundation, Inc., 59 Temple Place -
   Suite 330, Boston, MA 02111-1307, USA. */

#include <buffer.h>
#include <string.h>
#include "evexp.h"
#include "tcutil.h"
#include "warn.h"
#include "flags.h"
#include "absynpp.h"
using Core;
using PP;
using Absyn;
using List;
using Tcutil;
namespace Absynpp;

// forward references
doc_t dp2doc($(list_t<designator_t>,pat_t)@ dp);
doc_t switchclauses2doc(list_t<switch_clause_t> cs);
doc_t typ2doc(type_t);
doc_t aggrfields2doc(list_t<aggrfield_t> fields);
doc_t scope2doc(scope_t);
doc_t stmt2doc(stmt_t,bool expstmt,list_t<qvar_t,`H> varsinblock);
doc_t exp2doc(exp_t);
doc_t exp2doc_prec(int inprec, exp_t e);
doc_t exps2doc_prec(int inprec, list_t<exp_t> es);
doc_t qvar2doc(qvar_t);
doc_t typedef_name2doc(qvar_t);
doc_t cnst2doc(cnst_t);
doc_t prim2doc(primop_t);
doc_t primapp2doc(int inprec, primop_t p,list_t<exp_t> es);
doc_t de2doc($(list_t<designator_t>,exp_t)@ de);
doc_t tqtd2doc(tqual_t tq, type_t t, opt_t<doc_t> dopt);
doc_t funargs2doc(list_t<$(var_opt_t,tqual_t,type_t)@> args,
		  bool c_varargs,vararg_info_t *cyc_varargs,
		  type_opt_t effopt,
		  list_t<$(type_t,type_t)@> rgn_po,
		  exp_opt_t requires, exp_opt_t ensures);
doc_t datatypefields2doc(list_t<datatypefield_t> fields);
doc_t enumfields2doc(list_t<enumfield_t> fs);
doc_t vardecl2doc(vardecl_t vd);
doc_t aggrdecl2doc(aggrdecl_t ad);
doc_t enumdecl2doc(enumdecl_t ad);
doc_t datatypedecl2doc(datatypedecl_t ad);
// Flag controlling whether typedefs are expanded during printing
static bool expand_typedefs;

// Flag controlling how to print identifiers (better performance (???) than
// re-writing them all in Toc).
static bool qvar_to_Cids;

string_t cyc_string = "Cyc";
stringptr_t cyc_stringptr = &cyc_string;
// Flag controlling whether to add the cyc prefix to the C-identifiers
static bool add_cyc_prefix;

// Flag controlling whether the (C) output should be for VC instead of gcc.
// (Differences: long long vs. __int64 and inline vs. __inline)
static bool to_VC;

// Flag controlling whether declarations have to be at the beginning of blocks
static bool decls_first;

// Flag controlling whether to rewrite temporary type variables
// makes reparsing impossible, but gives nicer error messages
static bool rewrite_temp_tvars;

// Flag controlling whether to print all type variables
static bool print_all_tvars;

// Flag controlling whether to print all kinds
static bool print_all_kinds;

// Flag controlling whether to print effects on functions
static bool print_all_effects;

// Flag controlling whether to print the Using statements
static bool print_using_stmts;

// Flag controlling whether to print the extern "C" {...} statements
// after the TC, the extern "C" are propagated to the functions,
// and we get a warning if we don't hide this one
static bool print_externC_stmts;

// Flag controlling whether to print out free tvars that can be
// used when instantiating evars
static bool print_full_evars;

// Flag controlling whether to insert #line directives in c output
static bool generate_line_directives;

// Flag controlling whether to use the variable curr_namespace or not
static bool use_curr_namespace;

// Flag controlling whether to print [NO]ZEROTERM
static bool print_zeroterm;

// keep a track of the current namespace
static list_t<var_t> curr_namespace = NULL;

// used by cycdoc to suppress printing extern, etc.
int print_for_cycdoc = false;

struct Params {
  bool expand_typedefs;
  bool qvar_to_Cids;
  bool add_cyc_prefix;
  bool to_VC;
  bool decls_first;
  bool rewrite_temp_tvars;
  bool print_all_tvars;
  bool print_all_kinds;
  bool print_all_effects;
  bool print_using_stmts;
  bool print_externC_stmts;
  bool print_full_evars;
  bool print_zeroterm;
  bool generate_line_directives;
  bool use_curr_namespace;
  list_t<var_t> curr_namespace;
};

void set_params(struct Params @ fs) {
  expand_typedefs = fs->expand_typedefs;
  qvar_to_Cids = fs->qvar_to_Cids;
  add_cyc_prefix = fs->add_cyc_prefix;
  to_VC = fs->to_VC;
  decls_first = fs->decls_first;
  rewrite_temp_tvars = fs->rewrite_temp_tvars;
  print_all_tvars = fs->print_all_tvars;
  print_all_kinds = fs->print_all_kinds;
  print_all_effects = fs->print_all_effects;
  print_using_stmts = fs->print_using_stmts;
  print_externC_stmts = fs->print_externC_stmts;
  print_full_evars = fs->print_full_evars;
  print_zeroterm = fs->print_zeroterm;
  generate_line_directives = fs->generate_line_directives;
  use_curr_namespace = fs->use_curr_namespace;
  curr_namespace = fs->curr_namespace;
}

struct Params cyc_params_r =
  Params{
    .expand_typedefs = false,
    .qvar_to_Cids = false,
    .add_cyc_prefix = false,
    .to_VC = false,
    .decls_first = false,
    .rewrite_temp_tvars = true,
    .print_all_tvars = false,
    .print_all_kinds = false,
    .print_all_effects = false,
    .print_using_stmts = true,
    .print_externC_stmts = true,
    .print_full_evars = false,
    .print_zeroterm = true,
    .generate_line_directives = false,
    .use_curr_namespace = true,
    .curr_namespace = NULL
  };

struct Params cyci_params_r =
  Params{
    .expand_typedefs = true,
    .qvar_to_Cids = false,
    .add_cyc_prefix = true,
    .to_VC = false,
    .decls_first = false,
    .rewrite_temp_tvars = true,
    .print_all_tvars = false,
    .print_all_kinds = false,
    .print_all_effects = false,
    .print_using_stmts = true,
    .print_externC_stmts = true,
    .print_full_evars = false,
    .print_zeroterm = true,
    .generate_line_directives = false,
    .use_curr_namespace = true,
    .curr_namespace = NULL
  };

struct Params c_params_r =
  Params{
    .expand_typedefs = true,
    .qvar_to_Cids = true,
    .add_cyc_prefix = true,
    .to_VC = false,
    .decls_first = true,
    .rewrite_temp_tvars = false,
    .print_all_tvars = false,
    .print_all_kinds = false,
    .print_all_effects = false,
    .print_using_stmts = false,
    .print_externC_stmts = false,
    .print_full_evars = false,
    .print_zeroterm = false,
    .generate_line_directives = true,
    .use_curr_namespace = false,
    .curr_namespace = NULL
  };

struct Params tc_params_r =
  Params{
    .expand_typedefs = false,
    .qvar_to_Cids = false,
    .add_cyc_prefix = false,
    .to_VC = false,
    .decls_first = false,
    .rewrite_temp_tvars = true,
    .print_all_tvars = false,
    .print_all_kinds = false,
    .print_all_effects = false,
    .print_using_stmts = true,
    .print_externC_stmts = true,
    .print_full_evars = false,
    .print_zeroterm = true,
    .generate_line_directives = false,
    .use_curr_namespace = false,
    .curr_namespace = NULL
  };


static void curr_namespace_add(var_t v) {
  curr_namespace = imp_append(curr_namespace, new List(v, NULL));
}

static void suppr_last(list_t @ l) {// could be in List
  if ((*l)->tl == NULL) {
    *l = NULL;
  } else {
    suppr_last(&((*l)->tl));
  }
}

static void curr_namespace_drop() {
  suppr_last(&curr_namespace);
}

string_t char_escape(char c) {
  switch (c) {
  case '\a': return("\\a");
  case '\b': return("\\b");
  case '\f': return("\\f");
  case '\n': return("\\n");
  case '\r': return("\\r");
  case '\t': return("\\t");
  case '\v': return("\\v");
  case '\\': return("\\\\");
  case '\"': return("\"");
  case '\'': return("\\'");
  default:
    if (c>=' ' && c<='~') {
      let t = new_string(2);
      t[0] = c;
      return t;
    } else {
      let t = new_string(5);
      int j = 0;
      t[j++] = '\\';
      t[j++] = (char)('0'+(((unsigned char)c>>6)&3));
      t[j++] = (char)('0'+((c>>3)&7));
      t[j++] = (char)('0'+(c&7));
      return t;
    }
  }
}

static bool special(string_t s){
  int sz = numelts(s)-1;
  for (int i = 0; i<sz; i++) {
    char c = s[i];
    if (c<=' ' || c>='~' || c=='\042' || c=='\\')
      return true;
  }
  return false;
}

string_t string_escape(string_t<`H> s) {
  if (!special(s)) return s;

  int n = numelts(s) - 1;
  // Check for the expected NUL terminator of a string constant
  if (n>0 && s[n]=='\000') n--;
  // determine length
  int len = 0;
  for (int i=0; i<=n; i++)
    switch (s[i]) {
    case '\a':
    case '\b':
    case '\f':
    case '\n':
    case '\r':
    case '\t':
    case '\v':
    case '\\':
    case '\"': len += 2; break;
    case c:
      if (c>=' ' && c<='~') len++;
      else len += 4;
      break;
    }
  // build the escaped string
  mstring_t t = new_string(len+1);
  int j = 0;
  for (int i=0; i<=n; i++)
    switch (s[i]) {
    case '\a': t[j++] = '\\'; t[j++] = 'a'; break;
    case '\b': t[j++] = '\\'; t[j++] = 'b'; break;
    case '\f': t[j++] = '\\'; t[j++] = 'f'; break;
    case '\n': t[j++] = '\\'; t[j++] = 'n'; break;
    case '\r': t[j++] = '\\'; t[j++] = 'r'; break;
    case '\t': t[j++] = '\\'; t[j++] = 't'; break;
    case '\v': t[j++] = '\\'; t[j++] = 'v'; break;
    case '\\': t[j++] = '\\'; t[j++] = '\\'; break;
    case '"' : t[j++] = '\\'; t[j++] = '"'; break;
    case c:
      if (c>=' ' && c<='~') t[j++] = c;
      else {
        unsigned char uc = c; // NB: typechecker declares c to have type char, might not be
                              // unsigned, and this makes a difference to the calculations
                              // below when the high bit is set
        t[j++] = '\\';
        t[j++] = (char)('0'+((uc>>6)&7));
        t[j++] = (char)('0'+((uc>>3)&7));
        t[j++] = (char)('0'+(uc&7));
      }
      break;
    }
  return t;
}

static string_t restrict_string = "restrict";
static string_t volatile_string = "volatile";
static string_t const_str = "const";
static stringptr_t restrict_sp = &restrict_string;
static stringptr_t volatile_sp = &volatile_string;
static stringptr_t const_sp = &const_str;

doc_t tqual2doc(tqual_t tq) {
  list_t<stringptr_t> l = NULL;

  if (tq.q_restrict)  l = new List(restrict_sp,l);
  if (tq.q_volatile)  l = new List(volatile_sp,l);
  if (tq.print_const) l = new List(const_sp,l);
  return egroup(""," "," ",List::map(textptr,l));
}

string_t kind2string(kind_t ka) {
  let &Kind(k,a) = ka;
  switch (k) {
  case AnyKind:
    switch (a) {
    case Aliasable: return "A";
    case Unique: return "UA";
    case Top: default: return "TA";
    }
  case MemKind:
    switch (a) {
    case Aliasable: return "M";
    case Unique: return "UM";
    case Top: default: return "TM";
    }
  case BoxKind:
    switch (a) {
    case Aliasable: return "B";
    case Unique: return "UB";
    case Top: default: return "TB";
    }
  case RgnKind:
    switch (a) {
    case Aliasable: return "R";
    case Unique: return "UR";
    case Top: default: return "TR";
    }
  case EffKind: return "E";
  case IntKind: return "I";
  case BoolKind: return "BOOL";
  case PtrBndKind: default: return "PTRBND";
  }
}
doc_t kind2doc(kind_t k) { return text(kind2string(k)); }

string_t kindbound2string(kindbound_t c) {
  switch (compress_kb(c)) {
  case &Eq_kb(k): return kind2string(k);
  case &Unknown_kb(_):
    if (PP::tex_output)
      return "{?}"; // protect against following ` in TeX, spacing ignored
    else return "?";
  case &Less_kb(_,k): return aprintf("<=%s",kind2string(k));
  }
}
/* Code duplication so we can get spacing correct in TeX */
doc_t kindbound2doc(kindbound_t c) {
  switch (compress_kb(c)) {
  case &Eq_kb(k): return text(kind2string(k));
  case &Unknown_kb(_):
    if (PP::tex_output)
      return text_width("{?}",1); // protect against following ` in TeX
    else return text("?");
  case &Less_kb(_,k): return text(kind2string(k));
  }
}

doc_t tps2doc(list_t<type_t> ts) {
  return egroup("<",">",",",List::map(typ2doc,ts));
}

doc_t tvar2doc(tvar_t tv) {
  let n = *tv->name;
  // FIX:  we're rewriting internally-generated tvars to `Gxxx
  // which might conflict...
  if (rewrite_temp_tvars && Tcutil::is_temp_tvar(tv))
    { 
      string_t kstring = "K";
      switch (compress_kb(tv->kind)) {
      case &Less_kb(_,k): fallthru(k);
      case &Eq_kb(k): kstring = kind2string(k); break;
      default: break;
      }
      return text(aprintf("`G%s%s",kstring,n+1));
    }
  return text(n);
}

doc_t ktvar2doc(tvar_t tv) {
  switch (compress_kb(tv->kind)) {
  case &Unknown_kb(_):
  case &Eq_kb(&Kind(BoxKind,Aliasable)): return tvar2doc(tv);
  case &Less_kb(_,k):   fallthru(k);
  case &Eq_kb(k):       return cat(tvar2doc(tv), text("::"), kind2doc(k));
  }
}

doc_t ktvars2doc(list_t<tvar_t> tvs) {
  return egroup("<",">",",",List::map(ktvar2doc,tvs));
}

doc_t tvars2doc(list_t<tvar_t> tvs) {
  if (print_all_kinds)
    return ktvars2doc(tvs);
  return egroup("<",">",",",List::map(tvar2doc,tvs));
}

doc_t arg2doc($(tqual_t,type_t)@ t) {
  return tqtd2doc((*t)[0],(*t)[1],NULL);
}

doc_t args2doc(list_t<$(tqual_t,type_t)@> ts) {
  return(group("(",")",",",List::map(arg2doc,ts)));
}

doc_t noncallatt2doc(attribute_t att) {
  switch(att) {
  case &Stdcall_att:
  case &Cdecl_att:
  case &Fastcall_att: return nil_doc();
  default: return text(attribute2string(att));
  }
}

doc_t callconv2doc(attributes_t atts) { // for MS only
  for(; atts != NULL; atts = atts->tl)
    switch(atts->hd) {
    case &Stdcall_att:  return text(" _stdcall ");
    case &Cdecl_att:    return text(" _cdecl ");
    case &Fastcall_att: return text(" _fastcall ");
    default: break;
    }
  return nil_doc();
}

doc_t noncallconv2doc(attributes_t atts) { // for MS only
  bool hasatt = false;
   for(_ atts2 = atts; atts2 != NULL; atts2 = atts2->tl)
    switch(atts2->hd) {
    case &Stdcall_att:
    case &Cdecl_att:
    case &Fastcall_att: break;
    default: hasatt = true; break;
    }
  if(!hasatt)
    return nil_doc();
  return cat(text(" __declspec("),
	     group("",""," ",List::map(noncallatt2doc,atts)),
	     text(")"));
}

string_t attribute2string(attribute_t a) {
  switch (a) {
  case &Regparm_att(i): return aprintf("regparm(%d)",i);
  case &Stdcall_att: return "stdcall";
  case &Cdecl_att: return "cdecl";
  case &Fastcall_att: return "fastcall";
  case &Noreturn_att: return "noreturn";
  case &Const_att: return "const";
  case &Aligned_att(e): 
    if (e == NULL) return "aligned";
    else /* return aprintf("aligned(%d)",i);*/
      switch(Flags::c_compiler){
      case Flags::Gcc_c: return aprintf("aligned(%s)",exp2string(e));
      case Flags::Vc_c:  
      default: return aprintf("align(%s)",exp2string(e));
      }
  case &Packed_att: return "packed";
  case &Section_att(s): return aprintf("section(\"%s\")",s);
  case &Nocommon_att: return "nocommon";
  case &Shared_att: return "shared";
  case &Unused_att: return "unused";
  case &Weak_att: return "weak";
  case &Dllimport_att: return "dllimport";
  case &Dllexport_att: return "dllexport";
  case &No_instrument_function_att: return "no_instrument_function";
  case &Constructor_att: return "constructor";
  case &Destructor_att: return "destructor";
  case &No_check_memory_usage_att: return "no_check_memory_usage";
  case &Format_att(Printf_ft,n,m): return aprintf("format(printf,%u,%u)",n,m);
  case &Format_att(/*Scanf_ft*/_,n,m): 
    return aprintf("format(scanf,%u,%u)", n,m);
  case &Initializes_att(n): return aprintf("initializes(%d)",n);
  case &Noliveunique_att(n): return aprintf("noliveunique(%d)",n);
  case &Consume_att(n): return aprintf("consume(%d)",n);
  case &Pure_att: return "pure";
  case &Always_inline_att: return "always_inline";
  case &Mode_att(s): return aprintf("__mode__(\"%s\")",s); 
  case &Alias_att(s): return aprintf("alias(\"%s\")",s); 
 }
}

doc_t att2doc(attribute_t a) { // for gcc only
  return text(attribute2string(a));
}

doc_t atts2doc(attributes_t atts) {
  if (atts == NULL) return nil_doc();
  switch(Flags::c_compiler) {
  case Flags::Vc_c:  return noncallconv2doc(atts);
  default:
    return(cat(text(" __attribute__"),
                        group("((","))",",",List::map(att2doc,atts))));
  }
}

bool next_is_pointer(list_t<type_modifier_t> tms) {
  if (tms==NULL) return false;
  switch (tms->hd) {
  case &Pointer_mod(_,_): return true;
  case &Attributes_mod(_,_):
    switch(Flags::c_compiler){
    case Flags::Gcc_c: return false;
    default:   return next_is_pointer(tms->tl);
    }
  default: return false;
  }
}

extern doc_t ntyp2doc(type_t t);


static struct Doc *cache_question = NULL;
static doc_t question() {
  if (!cache_question) {
    if (PP::tex_output)
      cache_question = text_width("{?}",1); // protect against following ` in TeX
    else cache_question = text("?");
  }
  return (doc_t)cache_question;
}
static struct Doc *cache_lb = NULL;
static doc_t lb() {
  if (!cache_lb) {
    if (PP::tex_output)
      cache_lb = text_width("{\\lb}",1);
    else cache_lb = text("{");
  }
  return (doc_t)cache_lb;
}
static struct Doc *cache_rb = NULL;
static doc_t rb() {
  if (!cache_rb) {
    if (PP::tex_output)
      cache_rb = text_width("{\\rb}",1);
    else cache_rb = text("}");
  }
  return (doc_t)cache_rb;
}
static struct Doc *cache_dollar = NULL;
static doc_t dollar() {
  if (!cache_dollar) {
    if (PP::tex_output)
      cache_dollar = text_width("\\$",1);
    else cache_dollar = text("$");
  }
  return (doc_t)cache_dollar;
}
doc_t group_braces(string_t<`H> sep, list_t<doc_t,`H> ss) {
  return cat(lb(), seq(sep,ss), rb());
}

// for debugging
static void print_tms(list_t<type_modifier_t> tms) {
  for (; tms != NULL; tms = tms->tl)
    switch (tms->hd) {
    case &Carray_mod(_,_): fprintf(stderr,"Carray_mod "); break;
    case &ConstArray_mod(_,_,_):fprintf(stderr,"ConstArray_mod "); break;
    case &Function_mod(&WithTypes(ys,_,_,_,_,_,_)):
      fprintf(stderr,"Function_mod(");
      for (; ys != NULL; ys = ys->tl) {
        let v = (*ys->hd)[0];
        if (v == NULL) fprintf(stderr,"?");
        else fprintf(stderr,*v);
        if (ys->tl != NULL) fprintf(stderr,",");
      }
      fprintf(stderr,") ");
      break;
    case &Function_mod(_):
      fprintf(stderr,"Function_mod()"); break;
    case &Attributes_mod(_,_):fprintf(stderr,"Attributes_mod "); break;
    case &TypeParams_mod(_,_,_):fprintf(stderr,"TypeParams_mod "); break;
    case &Pointer_mod(_,_):fprintf(stderr,"Pointer_mod "); break;
    }
  fprintf(stderr,"\n");
}

doc_t rgn2doc(type_t t);

doc_t dtms2doc(bool is_char_ptr, doc_t d,list_t<type_modifier_t> tms) {
  if (tms==NULL) return d;
  doc_t rest = dtms2doc(false,d,tms->tl);
  doc_t p_rest = cat(text("("),rest,text(")"));
  switch (tms->hd) {
  case &Carray_mod(zeroterm,_):
    if (next_is_pointer(tms->tl)) rest = p_rest;
    return cat(rest,type2bool(false,zeroterm) ?
               text("[]@zeroterm") : text("[]"));
  case &ConstArray_mod(e,zeroterm,_):
    if (next_is_pointer(tms->tl)) rest = p_rest;
    return cat(rest, text("["), exp2doc(e),
               type2bool(false,zeroterm) ? text("]@zeroterm") : text("]"));
  case &Function_mod(args):
    if (next_is_pointer(tms->tl)) rest = p_rest;
    switch (args) {
    case &WithTypes(args2,c_varargs,cyc_varargs,effopt,rgn_po,req,ens):
      return cat(rest,funargs2doc(args2,c_varargs,cyc_varargs,effopt,rgn_po,req,ens));
    case &NoTypes(sl,loc):
      return cat(rest,group("(",")",",",List::map(textptr,sl)));
    }
  case &Attributes_mod(_, atts):
    switch(Flags::c_compiler){
    case Flags::Gcc_c:
      if (next_is_pointer(tms->tl)) 
	rest = p_rest;
      return cat(rest, atts2doc(atts));
    default:
     if(next_is_pointer(tms->tl))
       return cat(callconv2doc(atts), rest);
     return rest;
    }
  case &TypeParams_mod(ts,loc,print_kinds):
    if (next_is_pointer(tms->tl)) rest = p_rest;
    if (print_kinds)
      return cat(rest, ktvars2doc(ts));
    else
      return cat(rest, tvars2doc(ts));

    // FIX? What about attributes that we parse before tq2??
  case &Pointer_mod(PtrAtts(rgn,nullable,bd,zt,_),tq2):
    doc_t ptr;
    doc_t mt = nil_doc();
    doc_t ztd = mt;
    doc_t rgd = mt;
    doc_t tqd = tqual2doc(tq2);
    switch (compress(bd)) {
    case &AppType(&FatCon,_): ptr = question(); break;
    case &AppType(&ThinCon,&List{targ,_}):
      switch (compress(targ)) {
      case &ValueofType(e): 
        ptr = text(type2bool(true,nullable) ? "*" : "@");
        let $(val,known) = Evexp::eval_const_uint_exp(e);
        if(!known || val != 1)
          ptr = cat(ptr,lb(),exp2doc(e),rb());
        break;
      default:
        ptr = text(type2bool(true,nullable) ? "*" : "@");
        ptr = cat(ptr,lb(),typ2doc(targ),rb());
        break;
      }
      break;
    default:
      ptr = text(type2bool(true,nullable) ? "*" : "@");
      ptr = cat(ptr,lb(),typ2doc(bd),rb());
      break;
      
    }
    if (print_zeroterm) {
      if (!is_char_ptr && type2bool(false,zt))
        ztd = text("@zeroterm");
      else if (is_char_ptr && !type2bool(false,zt))
	ztd = text("@nozeroterm");
    }
    switch(compress(rgn)) {
    case &AppType(&HeapCon,_): break;
    case &Evar(...) && print_for_cycdoc: break;
    default: rgd = rgn2doc(rgn);
    }
    doc_t spacer1 = (tqd != mt && (ztd != mt || rgd != mt)) ? text(" ") : mt;
    doc_t spacer2 = (rest != mt) ? text(" ") : mt;
    return cat(ptr,ztd,rgd,spacer1,tqd,spacer2,rest);
  }
}

doc_t rgn2doc(type_t t) {
  switch (compress(t)) {
  case &AppType(&HeapCon,_):   return text("`H");
  case &AppType(&UniqueCon,_): return text("`U");
  case &AppType(&RefCntCon,_): return text("`RC");
  default: return ntyp2doc(t);
    //default: return cat(text("@region("),ntyp2doc(t),text(")"));
  }
}

static void effects2docs(list_t<doc_t,`H> @ `r rgions,
			 list_t<doc_t,`H> @ `r effects,
			 type_t t)
{
  switch (compress(t)) {
  case &AppType(&AccessCon,&List{r,_}): *rgions = new List(rgn2doc(r), *rgions); break;
  case &AppType(&JoinCon,ts):
    for (; ts != NULL; ts = ts->tl) {
      effects2docs(rgions, effects, ts->hd);
    }
    break;
  default: *effects = new List(typ2doc(t),*effects); break;
  }
}

doc_t eff2doc(type_t t) {
  list_t <doc_t> rgions = NULL, effects = NULL;
  effects2docs(&rgions, &effects, t);
  rgions  = List::imp_rev(rgions);
  effects = List::imp_rev(effects);
  if (rgions == NULL && effects != NULL) {
    return group("","","+",effects);
  } else {
    let doc1 = group_braces(",",rgions);
    return group("","","+",List::imp_append(effects,new List(doc1,NULL)));
  }
}

doc_t aggr_kind2doc(aggr_kind_t k) {
  switch(k) {
  case StructA: return text("struct ");
  default:      return text("union ");
  }
}

// Convert a normalized typ to a doc
doc_t ntyp2doc(type_t t) {
  doc_t s;
  switch (t) {
    // The first three cases never turn up in normalized types.
  case &ArrayType(_)    : return text("[[[array]]]"); //nil_doc();
  case &FnType(_)       : return nil_doc();
  case &PointerType(_)  : return nil_doc();
    // The remaining cases are possible.
  case &AppType(&VoidCon,_): s = text("void"); break;
  case &Evar(k,topt,i,tvs):
    if (topt != NULL)
      // This is an error case, topt should be NULL in a normalized type
      return(ntyp2doc(topt));
    else {
      string_t kindstring = (k == NULL) ? "K" : kind2string(k->v);
      s = text(aprintf("`E%s%d",kindstring,i));
    }
    break;
  case &VarType(tv):
    s = tvar2doc(tv);
    if (print_all_kinds)
      s = cat(s,text("::"),kindbound2doc(tv->kind));
    break;
  case &AppType(&DatatypeCon(tu_info),ts):
    switch(tu_info) {
    case {.UnknownDatatype = UnknownDatatypeInfo(n,is_x)}: fallthru(n,is_x);
    case {.KnownDatatype = &&Datatypedecl(_,n,_,_,is_x)}:
      let kw = text("datatype ");
      let ext = is_x ? text("@extensible ") : nil_doc();
      s = cat(ext,kw,qvar2doc(n),tps2doc(ts));
      break;
    }
    break;
  case &AppType(&DatatypeFieldCon(tuf_info),ts):
    switch(tuf_info) {
    case {.UnknownDatatypefield = UnknownDatatypeFieldInfo(tname,fname,is_x)}:
      fallthru(tname,is_x,fname);
    case {.KnownDatatypefield = $(&Datatypedecl(_,tname,_,_,is_x),
             &Datatypefield(fname,_,_,_))}:
      let kw = text(is_x ? "@extensible datatype " : "datatype ");
      s = cat(kw, qvar2doc(tname),text("."),qvar2doc(fname));
      break;
    }
    break;
  case &AppType(&IntCon(sn,sz),_):
    string_t sns;
    string_t ts;
    switch (sn) {
    case None:
    case Signed: sns = "";          break;
    default:     sns = "unsigned "; break;
    }
    switch (sz) {
    case Char_sz:
      switch (sn) {
      case None:   sns = "";          break;
      case Signed: sns = "signed ";   break;
      default:     sns = "unsigned "; break;
      }
      ts = "char";
      break;
    case Short_sz: ts = "short";  break;
    case Int_sz:   ts = "int";    break;
    case Long_sz:  ts = "long";   break;
    case LongLong_sz:
    default:
      switch(Flags::c_compiler) {
      case Flags::Gcc_c: ts = "long long"; break;
      default:           ts = "__int64";   break;
      }
      break;
    }
    s = text(aprintf("%s%s",sns,ts));
    break;
  case &AppType(&FloatCon(i),_):
    switch(i) {
    case 0:  s = text("float");       break;
    case 1:  s = text("double");      break;
    default: s = text("long double"); break;
    }
    break;
  case &TupleType(ts): s = cat(dollar(),args2doc(ts)); break;
  case &AppType(&AggrCon(info),ts):
    let $(k,n) = aggr_kinded_name(info);
    s = cat(aggr_kind2doc(k), qvar2doc(n), tps2doc(ts));
    break;
  case &AnonAggrType(k,fs):
    s = cat(aggr_kind2doc(k), lb(),
            nest(2, aggrfields2doc(fs)),
            rb());
    break;
  case &AppType(&AnonEnumCon(fs),_):
    s = cat(text("enum "),lb(),nest(2, enumfields2doc(fs)), rb()); break;
  case &AppType(&EnumCon(n,_),_): s = cat(text("enum "),qvar2doc(n)); break;
  case &ValueofType(e): s = cat(text("valueof_t("),exp2doc(e),text(")")); break;
  case &TypeofType(e):  s = cat(text("typeof("),  exp2doc(e),text(")"));  break;
  case &AppType(&BuiltinCon(t,_),_): s = text(t); break;
  case &TypedefType(n,ts,kopt,_):
    // NB: we could print out the expanded typedef by following the topt
    // pointer (when non-NULL).
    // TJ: NO, the way to do that is to expand typedefs in to_tms -- see
    // for example the EVar case in to_tms.  The problem is that topt->v is
    // not going to be "normalized" (i.e., come out of to_tms).
    s = cat(qvar2doc(n),tps2doc(ts));
    break;
  case &AppType(&RgnHandleCon,ts):
    s = cat(text("region_t<"),rgn2doc(ts->hd),text(">")); break;
  case &AppType(&TagCon,ts):
    s = cat(text("tag_t<"),typ2doc(ts->hd),text(">")); break;
  case &AppType(&UniqueCon,_):
  case &AppType(&HeapCon,_):
  case &AppType(&RefCntCon,_): s = rgn2doc(t); break;
  case &AppType(&RgnsCon,ts):
    s = cat(text("regions("),typ2doc(ts->hd),text(")")); break;
  case &AppType(&AccessCon,_):
  case &AppType(&JoinCon,_):   s = eff2doc(t); break;
  case &TypeDeclType(&{.r=&Aggr_td(d),...},_):     s=aggrdecl2doc(d);     break;
  case &TypeDeclType(&{.r=&Enum_td(d),...},_):     s=enumdecl2doc(d);     break;
  case &TypeDeclType(&{.r=&Datatype_td(d),...},_): s=datatypedecl2doc(d); break;
  case &AppType(&TrueCon,_):  s = text("@true");  break;
  case &AppType(&FalseCon,_): s = text("@false"); break;
  case &AppType(&ThinCon,&List{t,_}):  
    s = cat(text("@thin @numelts"),lb(),typ2doc(t),rb()); break;
  case &AppType(&ThinCon,_):  
    s = text("@thin"); break;
  case &AppType(&FatCon,_):   s = text("@fat");   break;
  }
  return s;
}

doc_t vo2doc(var_opt_t vo) {
  return (vo==NULL)?nil_doc():text(*(var_t)(vo));
}

doc_t rgn_cmp2doc($(type_t,type_t)@ cmp) {
  let &$(r1,r2) = cmp;
  return cat(rgn2doc(r1),text(" > "),rgn2doc(r2));
}

doc_t rgnpo2doc(list_t<$(type_t,type_t)@> po) {
  return group("","",",",List::map(rgn_cmp2doc,po));
}

doc_t funarg2doc($(var_opt_t,tqual_t,type_t)@ t) {
  let vo = (*t)[0];
  opt_t<doc_t> dopt = (vo==NULL)?NULL:(new Opt(text(*vo)));
  return tqtd2doc((*t)[1],(*t)[2],dopt);
}

doc_t funargs2doc(list_t<$(var_opt_t,tqual_t,type_t)@> args,bool c_varargs,
                  vararg_info_t *cyc_varargs, type_opt_t effopt,
                  list_t<$(type_t,type_t)@> rgn_po, exp_opt_t req,
                  exp_opt_t ens) {
  let arg_docs = List::map(funarg2doc,args);
  doc_t eff_doc;
  if (c_varargs)
    arg_docs = List::append(arg_docs,new List(text("..."),NULL));
  else if (cyc_varargs != NULL) {
    let varargs_doc = cat(text("..."),
                          cyc_varargs->inject ? text(" inject ") : text(" "),
                          funarg2doc(new $(cyc_varargs->name,cyc_varargs->tq,
                                           cyc_varargs->type)));
    arg_docs = List::append(arg_docs,new List(varargs_doc,NULL));
  }
  let arg_doc = group("","",",",arg_docs);
  if (effopt != NULL && print_all_effects)
    arg_doc = cat(arg_doc,text(";"),eff2doc(effopt));
  if (rgn_po != NULL)
    arg_doc = cat(arg_doc,text(":"),rgnpo2doc(rgn_po));
  let res = cat(text("("),arg_doc,text(")"));
  if (req != NULL)
    res = cat(res,text(" @requires("),exp2doc(req),text(")"));
  if (ens != NULL)
    res = cat(res,text(" @ensures("),exp2doc(ens),text(")"));
  return res;
}

doc_t var2doc(var_t v) { return text(*v); }

string_t qvar2string(qvar_t q) {
  let prefix = NULL;
  let match;
  switch ((*q)[0]) {
  case {.Loc_n = _}: fallthru(NULL);
  case {.Rel_n = x}:
    match = false;
    prefix = x;
    break;
  case {.C_n = x}:
    match = use_curr_namespace && list_prefix(strptrcmp, x, curr_namespace);
    // No namespace prefixes in the C namespace.
    break;
  case {.Abs_n = x}:
    match = use_curr_namespace && list_prefix(strptrcmp, x, curr_namespace);
    prefix = qvar_to_Cids && add_cyc_prefix ? new List(cyc_stringptr, x) : x;
    break;
  }
  if (qvar_to_Cids) {
    return str_sepstr(List::append(prefix,
                                   new List((*q)[1],NULL)),"_");
  } else {
    // don't print the prefix if it matches the current namespaces
    if (match)
      return *((*q)[1]);
    else
      return str_sepstr(List::append(prefix, new List((*q)[1],NULL)),"::");
  }
}

doc_t qvar2doc(qvar_t q) {
  return text(qvar2string(q));
}

doc_t qvar2bolddoc(qvar_t q) {
  let qs = qvar2string(q);
  if (PP::tex_output)
    /* FIX: make strconcat vararg and simplify this */
    return text_width(strconcat(strconcat("\\textbf{",qs),"}"),
                      strlen(qs));
  else return text(qs);
}

string_t typedef_name2string(qvar_t v) {
  // behave as qvar2string when translating to C
  if (qvar_to_Cids) return qvar2string(v);

  // otherwise we should not print the complete namespace here (it won't reparse)
  if (use_curr_namespace) {
    switch ((*v)[0]) {
    case {.Loc_n = _}: fallthru;
    case {.Rel_n = NULL}: return *((*v)[1]);
    case {.C_n = l}: fallthru(l); // FIX: is this correct?
    case {.Abs_n = l}:
      if (list_cmp(strptrcmp, l, curr_namespace) == 0) {
	return *((*v)[1]);
      } else {
	fallthru;
      }
    default: return strconcat("/* bad namespace : */ ", qvar2string(v));
    }
  } else {
    return *((*v)[1]);
  }
}
doc_t typedef_name2doc(qvar_t v) {
  return text(typedef_name2string(v));
}
doc_t typedef_name2bolddoc(qvar_t v) {
  let vs = typedef_name2string(v);
  if (PP::tex_output)
    /* FIX: make strconcat vararg and simplify this */
    return text_width(strconcat(strconcat("\\textbf{",vs),"}"),
                      strlen(vs));
  else return text(vs);
}

doc_t typ2doc(type_t t) {
  return tqtd2doc(empty_tqual(0), t, NULL);
}

static doc_t offsetof_field_to_doc(offsetof_field_t f) {
  switch(f) {
  case &StructField(n): return textptr(n);
  case &TupleIndex(n):  return text(aprintf("%d",n));
  }
}

// higher precedence means binds more tightly
// not quite right b/c unary operators allow cast expressions,
//   but that just means we put extra parens in.
//       Eg. &((foo) x) has unnecessary parens
// warning -- as a quick hack, exp2_doc_prec also uses some constants
//            in key places
// BIGGER WARNING: Absyndump::dumpexp_prec has to use the same constants!!!
int exp_prec(exp_t e) {
  switch (e->r) {
  case &Const_e(...):
  case &Var_e(...): return 10000;
  case &Primop_e(p,_):
    switch (p) {
    case Plus:           return 100;
    case Times:          return 110;
    case Minus:          return 100;
    case Div:
    case Mod:            return 110;
    case Eq:
    case Neq:            return  70;
    case Gt:
    case Lt:
    case Gte:
    case Lte:            return  80;
    case Not:
    case Bitnot:         return 130;
    case Bitand:         return  60;
    case Bitor:          return  40;
    case Bitxor:         return  50;
    case Bitlshift:      return  90;
    case Bitlrshift:     return  80; // unlike C (see grammar)
    case Numelts:        return 140; // numelts(foo)
    default:             return 140;
    }
  case &AssignOp_e(...):      return  20;
  case &Increment_e(...):     return 130;
  case &Conditional_e(...):   return  30;
  case &And_e(...):           return  35; // FIX: right precedence for &&
  case &Or_e(...):            return  30; // FIX: right precedence for ||
  case &SeqExp_e(...):        return -10; // DJG: must be less than 0 
  case &FnCall_e(...):        return 140;
  case &Pragma_e(...):        return 140;
  case &Throw_e(...):         return 130;
  case &NoInstantiate_e(e2):  return exp_prec(e2);
  case &Instantiate_e(e2,_):  return exp_prec(e2);
  case &Cast_e(...):          return 120;
  case &New_e(...):           return 15; // ???
  case &Address_e(_):
  case &Sizeoftype_e(_):
  case &Sizeofexp_e(_):
  case &Valueof_e(_):
  case &Asm_e(...):
  case &Tagcheck_e(...):
  case &Offsetof_e(...):
  case &Deref_e(...):
  case &Assert_e(...):
  case &Extension_e(...):     return 130;
  case &AggrMember_e(...):
  case &AggrArrow_e(...):
  case &Subscript_e(...):     return 140;
  case &Tuple_e(...):         return 150;
  case &CompoundLit_e(...):
  case &Array_e(...):
  case &Comprehension_e(...):
  case &ComprehensionNoinit_e(...):
  case &Aggregate_e(...):
  case &AnonStruct_e(...):
  case &Datatype_e(...):
  case &Enum_e(...):
  case &AnonEnum_e(...):
  case &Malloc_e(_):
  case &Swap_e(...):
  case &UnresolvedMem_e(...):  return 140; // ???
  case &StmtExp_e(...):        return 10000;
  }
}

doc_t exp2doc(exp_t e) {
  return exp2doc_prec(0,e);
}

static doc_t asm_iolist_doc_in(list_t<$(string_t<`H>, exp_t)@> o) {
  doc_t s=nil_doc();
  while(o) {
    let &$(c, e) = o->hd;
    s = cat(text("\""), text(c), text("\" ("), exp2doc(e), text(")"));
    o = o->tl;
    if(o) {
      s = cat(s, text(","));
    }
  }
  return s;
}

static doc_t asm_iolist_doc(list_t<$(string_t<`H>, exp_t)@> o, list_t<$(string_t<`H>, exp_t)@> i, list_t<string_t<`H>@> cl) {
  doc_t s=nil_doc();
  if(o) {
    s = cat(text(": "), asm_iolist_doc_in(o));
  }
  if(i) {
    if(!o)
      s = cat(s, text(": : "), asm_iolist_doc_in(i));
    else
      s = cat(s, text(" : "), asm_iolist_doc_in(i));
  }
  if(cl) {
    int ncol = (i ? 2 : o ? 1 : 0);
    s = cat(s, ncol == 0 ? text(": : :") : ncol == 1 ? text(" : : ") : text(" : "));
    while(cl != NULL) {
      s = cat(s, text("\""), text(*cl->hd), text("\""));
      cl=cl->tl;
      if(cl)
	s =cat(s, text(", "));
    }
  }
  return s;
}

doc_t exp2doc_prec(int inprec, exp_t e) {
  int myprec = exp_prec(e);
  doc_t s;
  switch (e->r) {
  case &Const_e(c):     s = cnst2doc(c); break;
  case &Var_e(b):       s = qvar2doc(binding2qvar(b)); break;
  case &Pragma_e(p):
    s = cat(text("__cyclone_pragma__"),text("("),text(p),text(")")); break;
  case &Primop_e(p,es): s = primapp2doc(myprec,p,es); break;
  case &AssignOp_e(e1,popt,e2):
    s = cat(exp2doc_prec(myprec,e1),
            text(" "),
            (popt == NULL) ? nil_doc() : prim2doc(popt->v),
            text("= "),
            exp2doc_prec(myprec,e2));
    break;
  case &Increment_e(e2,i):
    let es = exp2doc_prec(myprec,e2);
    switch (i) {
    case PreInc:  s = cat(text("++"),es); break;
    case PreDec:  s = cat(text("--"),es); break;
    case PostInc: s = cat(es,text("++")); break;
    case PostDec: 
    default:      s = cat(es,text("--")); break;
    }
    break;
  case &Conditional_e(e1,e2,e3):
    s = cat(exp2doc_prec(myprec,e1), text(" ? "), exp2doc_prec(0,e2),
            text(" : "), exp2doc_prec(myprec,e3));
    break;
  case &And_e(e1,e2):
    s = cat(exp2doc_prec(myprec,e1),text(" && "),exp2doc_prec(myprec,e2));
    break;
  case &Or_e(e1,e2):
    s = cat(exp2doc_prec(myprec,e1),text(" || "),exp2doc_prec(myprec,e2));
    break;
  case &SeqExp_e(e1,e2):
    // DJG: as a hack to avoid piles of parens for aggregate initialization
    // we pass our precedence - 1 recursively -- sound because , is associative
    s = cat(exp2doc_prec(myprec-1,e1), text(", "), exp2doc_prec(myprec-1,e2));
    break;
  case &FnCall_e(e1,es,...):
    s = cat(exp2doc_prec(myprec,e1),
            text("("),
            exps2doc_prec(20,es),
            text(")"));
    break;
  case &Throw_e(e1,_): s = cat(text("throw "), exp2doc_prec(myprec,e1)); break;
  case &NoInstantiate_e(e1): s = exp2doc_prec(inprec,e1); break;
  case &Instantiate_e(e1,_): s = exp2doc_prec(inprec,e1); break;
  case &Cast_e(t,e1,_,_): 
    s = cat(text("("), typ2doc(t), text(")"), exp2doc_prec(myprec,e1)); break;
  case &Address_e(e1): s = cat(text("&"), exp2doc_prec(myprec,e1)); break;
  case &New_e(ropt,e1):
    if (ropt == NULL)
      s = cat(text("new "),exp2doc_prec(myprec,e1));
    else
      s = cat(text("rnew("),exp2doc(ropt),text(") "), exp2doc_prec(myprec,e1));
    break;
  case &Sizeoftype_e(t): s = cat(text("sizeof("), typ2doc(t), text(")")); break;
  case &Sizeofexp_e(e1): s = cat(text("sizeof("),exp2doc(e1), text(")")); break;
  case &Assert_e(e):
    s = cat(text("@assert("),exp2doc(e),text(")")); break;
  case &Extension_e(e):  
    s = cat(text("__extension__("),exp2doc(e),text(")")); break;
  case &Valueof_e(t): s = cat(text("valueof("), typ2doc(t), text(")")); break;
  case &Asm_e(vol,t,o,i,cl):
    if (vol)
      s = cat(text("__asm__"),text(" volatile ("),text("\""),text(string_escape(t)),text("\""),asm_iolist_doc(o,i,cl),text(")"));
    else
      s = cat(text("__asm__("),text("\""),text(string_escape(t)),text("\""),asm_iolist_doc(o,i,cl),text(")"));
    break;
  case &Tagcheck_e(e,f):
    s = cat(text("tagcheck("), exp2doc(e), text("."), textptr(f), text(")"));
    break;
  case &Offsetof_e(t,l):
    s = cat(text("offsetof("), typ2doc(t), text(","),
	    seq(".",List::map(offsetof_field_to_doc,l)), text(")"));
    break;
  case &Deref_e(e1): s = cat(text("*"), exp2doc_prec(myprec,e1)); break;
  case &AggrMember_e(e1,n,...):
    s = cat(exp2doc_prec(myprec,e1), text("."), textptr(n)); break;
  case &AggrArrow_e(e1,n,...):
    s = cat(exp2doc_prec(myprec,e1), text("->"), textptr(n)); break;
  case &Subscript_e(e1,e2):
    s = cat(exp2doc_prec(myprec,e1), text("["), exp2doc(e2), text("]")); break;
  case &Tuple_e(es):
    s = cat(dollar(), text("("), exps2doc_prec(20,es), text(")")); break;
  case &CompoundLit_e(vat,des): // OK to ignore qualifiers??
    s = cat(text("("), typ2doc((*vat)[2]), text(")"),
            group_braces(",",List::map(de2doc,des)));
    break;
  case &Array_e(des): s = group_braces(",",List::map(de2doc,des)); break;
  case &Comprehension_e(vd,e1,e2,_):
    s = cat(lb(), text("for "), 
	    text(*((*vd->name)[1])), text(" < "), exp2doc(e1), text(" : "), 
	    exp2doc(e2), rb());
    break;
  case &ComprehensionNoinit_e(e,t,_):
    s = cat(lb(), text("for x "),
            text(" < "),
            exp2doc(e),
            text(" : "),
            typ2doc(t),
            rb());
    break;
  case &Aggregate_e(n,ts,des,_):
    let des_doc = List::map(de2doc,des);
    s = cat(qvar2doc(n),
            group_braces(",",
		  (ts != NULL ? new List(tps2doc(ts), des_doc) : des_doc)));
    break;
  case &AnonStruct_e(_,des): s = group_braces(",",List::map(de2doc,des)); break;
  case &Datatype_e(es,_,tuf):
    if (es == NULL)
      // special case: a nullary datatype constant is printed "foo" not "foo()"
      s = qvar2doc(tuf->name);
    else
      s = cat(qvar2doc(tuf->name),
              egroup("(",")",",",List::map(exp2doc,es)));
    break;
  case &Enum_e(_,ef):     fallthru(ef);
  case &AnonEnum_e(_,ef): s = qvar2doc(ef->name); break;
  case &Malloc_e(MallocInfo{is_calloc,rgnopt,topt,e,_,inline_call}):
    // Note: This is for Cyclone's malloc, not the mallocs introduced during
    //       translation to C, which are function calls.
    if (is_calloc) {
      // topt should not be NULL for calloc's
      exp_t st = sizeoftype_exp(*topt,0);
      if (rgnopt == NULL)
        s = cat(text("calloc("),exp2doc(e),text(","),exp2doc(st),text(")"));
      else
        s = cat(text("rcalloc("),exp2doc((exp_t)rgnopt),text(","),
                exp2doc(e),text(","),exp2doc(st),text(")"));
    } else {
      exp_t new_e;
      // see comments in absyn.h
      if (topt == NULL)
        new_e = e;
      else
        new_e = times_exp(sizeoftype_exp(*topt,0),e,0);

      if (rgnopt == NULL)
        s = cat(text("malloc("),exp2doc(new_e),text(")"));
      else {
        if (inline_call) 
          s = cat(text("rmalloc_inline("),exp2doc((exp_t)rgnopt),text(","),
                  exp2doc(new_e),text(")"));
        else
          s = cat(text("rmalloc("),exp2doc((exp_t)rgnopt),text(","),
                  exp2doc(new_e),text(")"));
      }
    }
    break;
  case &Swap_e(e1,e2):
    s = cat(exp2doc_prec(myprec,e1), text(" :=: "), exp2doc_prec(myprec,e2));
    break;
  case &UnresolvedMem_e(n,des): // Currently n is always NULL from the parser
    s = group_braces(",",List::map(de2doc,des));
    break;
  case &StmtExp_e(s2):
    s = cat(text("("),lb(),blank_doc(),
            nest(2,stmt2doc(s2,true,NULL)),
            blank_doc(),rb(),text(")"));
    break;
  }
  if(inprec >= myprec)
    s = cat(text("("), s, text(")"));
  return s;
}

doc_t designator2doc(designator_t d) {
  switch (d) {
  case &ArrayElement(e): return cat(text(".["), exp2doc(e), text("]"));
  case &FieldName(v):    return cat(text("."), textptr(v));
  }
}

doc_t de2doc($(list_t<designator_t>,exp_t)@ de) {
  if ((*de)[0] == NULL) return exp2doc((*de)[1]);
  else return cat(egroup("","=","=",List::map(designator2doc,(*de)[0])),
                  exp2doc((*de)[1]));
}

doc_t exps2doc_prec(int inprec, list_t<exp_t> es) {
  return group("","",",",List::map_c(exp2doc_prec,inprec,es));
}

string_t longlong2string(unsigned long long i) {
  char ? x = new { for i < 28 : 'z'};
  x[27] = '\0';
  x[26] = 'L';
  x[25] = 'L';
  x[24] = 'U';
  x[23] = '0';
  int index = 23;
  while (i != 0) {
    char c = (char)('0' + (i % 10));
    x[index] = c;
    i = i / 10;
    index--;
  }
  return x+index+1;
}

// FIX: take care of sign for Char_c and Short_c
doc_t cnst2doc(cnst_t c) {
  switch (c) {
  case {.Char_c = $(sg,ch)}: return text(aprintf("'%s'",char_escape(ch)));
  case {.Wchar_c = s}:       return text(aprintf("L'%s'",s));
  case {.Short_c = $(sg,s)}: return text(aprintf("%d",(int)s));
  case {.Int_c = $(sn,i)}:
    if (sn == Unsigned) return text(aprintf("%uU",(unsigned)i));
    else                return text(aprintf("%d",i));
  case {.LongLong_c = $(sg,i)}:
    // FIX -- take account of sign!
    return text(longlong2string(i));
  case {.Float_c = $(x,_)}: return text(x);
  case {.Null_c = _}:       return text("NULL");
  case {.String_c=s}:  return cat(text("\""),text(string_escape(s)),text("\""));
  case {.Wstring_c=s}: return cat(text("L\""), text(s), text("\""));
  }
}

doc_t primapp2doc(int inprec, primop_t p,list_t<exp_t> es) {
  doc_t ps = prim2doc(p);
  if (p == (primop_t)Numelts) {
    if (es == NULL || es->tl != NULL)
      throw new Failure(aprintf("Absynpp::primapp2doc Numelts: %s with bad args",
                                string_of_doc(ps,72)));
    return cat(text("numelts("),exp2doc(es->hd),text(")"));
  } else {
    list_t<doc_t> ds = List::map_c(exp2doc_prec,inprec,es);
    if (ds == NULL)
      throw new Failure(aprintf("Absynpp::primapp2doc: %s with no args",
                                string_of_doc(ps,72)));
    else if (ds->tl == NULL)
      return cat(ps,text(" "),ds->hd);
    else if (ds->tl->tl != NULL)
      throw new Failure(aprintf("Absynpp::primapp2doc: %s with more than 2 args",
                                string_of_doc(ps,72)));
    else
      return cat(ds->hd,text(" "),ps,text(" "),ds->tl->hd);
  }
}

string_t prim2str(primop_t p) {
  switch (p) {
  case Plus: return "+";
  case Times: return "*";
  case Minus: return "-";
  case Div: return "/";
  case Mod: return (print_for_cycdoc?"\\%":"%");
  case Eq: return "==";
  case Neq: return "!=";
  case Gt: return ">";
  case Lt: return "<";
  case Gte: return ">=";
  case Lte: return "<=";
  case Not: return "!";
  case Bitnot: return "~";
  case Bitand: return "&";
  case Bitor: return "|";
  case Bitxor: return "^";
  case Bitlshift: return "<<";
  case Bitlrshift: return ">>";
  case Numelts: return "numelts";
  default: return "?";
  }
}

doc_t prim2doc(primop_t p) {
  return text(prim2str(p));
}

bool is_declaration(stmt_t s) {
  switch (s->r) {
  case &Decl_s(_,_): return true;
  default: return false;
  }
}

// Returns true if the declaration d shadows any of the variables in
// the list of varsinblock.  In this case, we also return a singleton
// list with the variable that is declared since it will be the only
// variable in the newblock.  Otherwise, returns the variable declared
// by the decl (if any) cons'd onto the varsinblock. 
// We only bother to record Var_d declarations since it's only C code 
// that we have to wrap extra braces around when a declaration shadows a 
// previous one.
$(bool, list_t<qvar_t,`H>) shadows(decl_t d, list_t<qvar_t,`H> varsinblock) {
  switch (d->r) {
  case &Var_d(vd):
    if (List::mem(qvar_cmp,varsinblock,vd->name)) 
      return $(true,new List{vd->name,NULL});
    else
      return $(false,new List{vd->name,varsinblock});
  default:
    return $(false, varsinblock);
  }
}

doc_t block(bool stmtexp, doc_t d) {
  if (stmtexp) 
    return cat(text("("),lb(),blank_doc(),nest(2,d),line_doc(),rb(),
               text(");"),line_doc());
  else 
    return cat(lb(),blank_doc(),nest(2,d),line_doc(),rb(),line_doc());
}

doc_t stmt2doc(stmt_t st, bool stmtexp, list_t<qvar_t,`H> varsinblock) {
  doc_t s;
  switch (st->r) {
  case &Skip_s: s = text(";"); break;
  case &Exp_s(e): s = cat(exp2doc(e),text(";")); break;
  case &Seq_s(s1,s2):
    if (decls_first) {
      if (is_declaration(s1))
	s = cat(block(false,stmt2doc(s1,false,NULL)),
                is_declaration(s2)? // for gcc compatibility
                block(stmtexp,stmt2doc(s2,stmtexp,NULL))
                : stmt2doc(s2,stmtexp,varsinblock));
      else if (is_declaration(s2)) // for gcc compatibility
	s = cat(stmt2doc(s1,false,varsinblock),
                line_doc(),
                block(stmtexp,stmt2doc(s2,stmtexp,NULL)));
      else
	s = cat(stmt2doc(s1,false,varsinblock),line_doc(),
                stmt2doc(s2,stmtexp,varsinblock));
    }
    else
      s = cat(stmt2doc(s1,false,NULL),line_doc(),stmt2doc(s2,stmtexp,NULL));
    break;
  case &Return_s(eopt):
    if (eopt == NULL)
      s = text("return;");
    else
      s = cat(text("return "),
              (eopt==NULL)?nil_doc():exp2doc((exp_t)eopt),
              text(";"));
    break;
  case &IfThenElse_s(e,s1,s2):
    bool print_else;
    switch (s2->r) {
    case &Skip_s: print_else = false; break;
    default:     print_else = true;  break;
    }
    s = cat(text("if ("),
            exp2doc(e),
            text(") "),
            block(false,stmt2doc(s1,false,NULL)),
            print_else ?
            cat(line_doc(),
                text("else "),
                block(false,stmt2doc(s2,false,NULL)))
            : nil_doc());
    break;
  case &While_s($(e,_),s1):
    s = cat(text("while ("),
            exp2doc(e),
            text(") "),
            block(false,stmt2doc(s1,false,NULL)));
    break;
  case &Break_s:    s = text("break;"); break;
  case &Continue_s: s = text("continue;"); break;
  case &Goto_s(x):  s = text(aprintf("goto %s;",*x)); break;
  case &For_s(e1,$(e2,_),$(e3,_),s1):
    s = cat(text("for("),
            exp2doc(e1),
            text("; "),
            exp2doc(e2),
            text("; "),
            exp2doc(e3),
            text(") "),
            block(false,stmt2doc(s1,false,NULL)));
    break;
  case &Switch_s(e,ss,_):
    s = cat(text("switch ("),
            exp2doc(e),
            text(") "),
            lb(),
            line_doc(),
            switchclauses2doc(ss),
            line_doc(),
            rb());
    break;
  case &Fallthru_s(NULL,_): s = text("fallthru;"); break;
  case &Fallthru_s(es,_):
    s = cat(text("fallthru("), exps2doc_prec(20,es), text(");")); break;
  case &Decl_s(d,s1):
    let $(newblock, newvarsinblock) = shadows(d,varsinblock);
    s = cat(decl2doc(d),line_doc(),stmt2doc(s1,stmtexp,newvarsinblock));
    if (newblock) s = block(stmtexp,s);
    break;
  case &Label_s(x,s1):
    if (decls_first && is_declaration(s1)) {
      s = cat(textptr(x),text(": "),block(stmtexp,stmt2doc(s1,stmtexp,NULL)));
    } else
      s = cat(textptr(x),text(": "),stmt2doc(s1,stmtexp,varsinblock));
    break;
  case &Do_s(s1,$(e,_)):
    s = cat(text("do "),
            block(false,stmt2doc(s1,false,NULL)),
            text(" while ("),
            exp2doc(e),
            text(");"));
    break;
  case &TryCatch_s(s1,ss,_):
    s = cat(text("try "),
            block(false,stmt2doc(s1,false,NULL)),
            text(" catch "),
            block(false,switchclauses2doc(ss)));
    break;
  }
  return s;
}

doc_t pat2doc(pat_t p) {
  doc_t s;
  switch (p->r) {
  case &Wild_p: s = text("_"); break;
  case &Null_p: s = text("NULL"); break;
  case &Int_p(sg,i):
    if (sg != (sign_t)Unsigned)
      s = text(aprintf("%d",i));
    else s = text(aprintf("%u",i));
    break;
  case &Char_p(ch): s = text(aprintf("'%s'",char_escape(ch))); break;
  case &Float_p(x,_): s = text(x); break;
  case &Var_p(vd,&Pat{.r = &Wild_p,...}):
    s = qvar2doc(vd->name); break;
  case &Var_p(vd,p2):
    s = cat(qvar2doc(vd->name),text(" as "),pat2doc(p2)); break;
  case &AliasVar_p(tv,vd):
    s = cat(text("alias"),text(" <"),tvar2doc(tv),text("> "),
            vardecl2doc(vd));
    break;
  case &TagInt_p(tv,vd):
    s = cat(qvar2doc(vd->name), text("<"), tvar2doc(tv), text(">"));
    break;
  case &Tuple_p(ts,dots):
    s = cat(dollar(), text("("), ppseq(pat2doc,",",ts),
            dots ? text(", ...)") : text(")"));
    break;
  case &Pointer_p(p2):
    s = cat(text("&"),pat2doc(p2));
    break;
  case &Reference_p(vd,&Pat{.r = &Wild_p,...}):
    s = cat(text("*"),qvar2doc(vd->name));
    break;
  case &Reference_p(vd,p2):
    s = cat(text("*"),qvar2doc(vd->name),text(" as "),pat2doc(p2));
    break;
  case &UnknownId_p(q):
    s = qvar2doc(q);
    break;
  case &UnknownCall_p(q,ps,dots):
    string_t term = dots ? ", ...)" : ")";
    s = cat(qvar2doc(q), group("(",term,",",List::map(pat2doc,ps)));
    break;
  case &Aggr_p(&info,exists,dps,dots):
    string_t term = dots ? ", ...}" : "}";
    let $(_,n) = aggr_kinded_name(info);
    s = cat(qvar2doc(n), lb(),
	    egroup("[","]",",",List::map(tvar2doc,exists)),
	    group("",term,",",List::map(dp2doc,dps)));
    break;
  case &Aggr_p(NULL,exists,dps,dots):
    string_t term = dots ? ", ...}" : "}";
    s = cat(lb(),
	    egroup("[","]",",",List::map(tvar2doc,exists)),
	    group("",term,",",List::map(dp2doc,dps)));
    break;
  case &Enum_p(_,ef): fallthru(ef);
  case &AnonEnum_p(_,ef):     s = qvar2doc(ef->name);  break;
  case &Datatype_p(_,tuf,NULL,_): s = qvar2doc(tuf->name); break;
  case &Datatype_p(_,tuf,ps,dots):
    string_t term = dots ? ", ...)" : ")";
    s = cat(qvar2doc(tuf->name), egroup("(",term,",",List::map(pat2doc,ps)));
    break;
  case &Exp_p(e):
    s = exp2doc(e); break;
  }
  return s;
}

doc_t dp2doc($(list_t<designator_t>,pat_t)@ dp) {
  return cat(egroup("","=","=",List::map(designator2doc,(*dp)[0])),
             pat2doc((*dp)[1]));
}

doc_t switchclause2doc(switch_clause_t c) {
  // must treat switch clauses like labelled statements
  doc_t body = stmt2doc(c->body,false,NULL);
  if (decls_first && is_declaration(c->body))
    body = block(false,body);
  if (c->where_clause == NULL && c->pattern->r == (raw_pat_t)&Wild_p_val)
    return cat(text("default: "),
	       nest(2,cat(line_doc(),body)));
  else if (c->where_clause == NULL)
    return cat(text("case "),
	       pat2doc(c->pattern),
	       text(": "),
	       nest(2,cat(line_doc(),body)));
  else
    return cat(text("case "),
	       pat2doc(c->pattern),
	       text(" && "),
	       exp2doc((exp_t)c->where_clause),
	       text(": "),
	       nest(2,cat(line_doc(),body)));
}

doc_t switchclauses2doc(list_t<switch_clause_t> cs) {
  return ppseql(switchclause2doc,"",cs);
}

doc_t enumfield2doc(enumfield_t f) {
  if (f->tag == NULL)
    return qvar2doc(f->name);
  else
    return cat(qvar2doc(f->name),text(" = "),exp2doc((exp_t)f->tag));
}

doc_t enumfields2doc(list_t<enumfield_t> fs) {
  return ppseql(enumfield2doc,",",fs);
}

static doc_t id2doc(vardecl_t v) {
  return qvar2doc(v->name);
}

static doc_t ids2doc(list_t<vardecl_t> vds) {
  return ppseq(id2doc,",",vds);
}

doc_t vardecl2doc(vardecl_t vd) {
  let &Vardecl{sc,name,varloc,tq,type,initializer,_,atts,...} = vd;
  doc_t s;
  doc_t sn = typedef_name2bolddoc(name);
  doc_t attsdoc   = atts2doc(atts);
  doc_t beforenamedoc;
  switch(Flags::c_compiler){
  case Flags::Gcc_c: beforenamedoc = attsdoc; break;
  default:
    switch(compress(type)) {
    case &FnType(FnInfo{.attributes = atts2,...}):
      beforenamedoc = callconv2doc(atts2);
      break;
    default: beforenamedoc = nil_doc(); break;
    }
    break;
  }

  doc_t tmp_doc;
  switch(Flags::c_compiler){
  case Flags::Gcc_c: tmp_doc = nil_doc(); break;
  default:           tmp_doc = attsdoc;   break;
  }
  s = cat(/*(to_VC ? attsdoc : nil_doc()),*/
          tmp_doc,
          scope2doc(sc),
          tqtd2doc(tq,type,new Opt(cat(beforenamedoc,sn))),
          (initializer == NULL)
          ? nil_doc()
          : cat(text(" = "),exp2doc((exp_t)initializer)),
          text(";"));
  return s;
}

doc_t export2doc($(Position::seg_t,qvar_t,bool)@ x) {
  let $(_,v,_) = *x;
  return qvar2doc(v);
}

doc_t aggrdecl2doc(aggrdecl_t ad) {
  if (ad->impl==NULL)
    return cat(scope2doc(ad->sc),
               aggr_kind2doc(ad->kind),
               qvar2bolddoc(ad->name),
               ktvars2doc(ad->tvs));
  else
    return cat(scope2doc(ad->sc),
               aggr_kind2doc(ad->kind),
               qvar2bolddoc(ad->name),
               ktvars2doc(ad->tvs),
               blank_doc(),lb(),
               ktvars2doc(ad->impl->exist_vars),
               (ad->impl->rgn_po==NULL ? nil_doc() :
                cat(text(":"),rgnpo2doc(ad->impl->rgn_po))),
               nest(2, cat(line_doc(),aggrfields2doc(ad->impl->fields))),
               line_doc(),
               rb(),
               atts2doc(ad->attributes));
}

doc_t datatypedecl2doc(datatypedecl_t dd) {
  let &Datatypedecl(sc,name,tvs,fields,is_x) = dd;
  if (fields==NULL)
    return cat(scope2doc(sc),
               (is_x ? text("@extensible ") : blank_doc()),
               text("datatype "),
               (is_x ? qvar2bolddoc(name) : typedef_name2bolddoc(name)),
               ktvars2doc(tvs));
  else
    return cat(scope2doc(sc),
               (is_x ? text("@extensible ") : blank_doc()),
               text("datatype "),
               (is_x ? qvar2bolddoc(name) : typedef_name2bolddoc(name)),
               ktvars2doc(tvs),
               blank_doc(),lb(),
               nest(2, cat(line_doc(),datatypefields2doc(fields->v))),
               line_doc(),
               rb());
}

doc_t enumdecl2doc(enumdecl_t ed) {
  let &Enumdecl{sc,n,fields} = ed;
  if (fields == NULL)
    return cat(scope2doc(sc),
               text("enum "),
               typedef_name2bolddoc(n));

  else
    return cat(scope2doc(sc),
               text("enum "),
               qvar2bolddoc(n),
               blank_doc(),lb(),
               nest(2, cat(line_doc(),enumfields2doc(fields->v))),
               line_doc(),
               rb());
}

doc_t decl2doc(decl_t d) {
  doc_t s;
  switch (d->r) {
  case &Fn_d(fd):
    fn_info_t type_info = fd->i;
    type_info.attributes = NULL;
    type_t t = new FnType(type_info);
    if(fd->cached_type != NULL)
      switch(compress((type_t)fd->cached_type)) {
      case &FnType(i): 
	fd->i.attributes = append(fd->i.attributes,i.attributes); break;
      default: Warn::impos("function has non-function type");
      }
    doc_t attsdoc   = atts2doc(fd->i.attributes);
    doc_t inlinedoc;
    if(fd->is_inline)
      switch(Flags::c_compiler) {
      case Flags::Gcc_c:  inlinedoc = text("inline ");    break;
      default:            inlinedoc = text("__inline ");  break;
      }
    else
      inlinedoc = nil_doc();
    doc_t scopedoc  = scope2doc(fd->sc);
    doc_t beforenamedoc;
    switch(Flags::c_compiler){
    case Flags::Gcc_c: beforenamedoc = attsdoc; break;
    default:           beforenamedoc = callconv2doc(fd->i.attributes); break;
    }
    doc_t namedoc   = typedef_name2doc(fd->name);
    doc_t tqtddoc   = tqtd2doc(empty_tqual(0), t,
			       new Opt(cat(beforenamedoc,namedoc)));
    // NOTE: if we have a local variable declared in the outermost block
    // that shadows a parameter, gcc will warn.  If we want to get rid of
    // the warning, we could pass in the parameters as the list of variables
    // defined in the block and then we will insert an extra { ... } which
    // supresses the warning.
    doc_t bodydoc   = cat(blank_doc(),lb(),
			  nest(2,cat(line_doc(),stmt2doc(fd->body,false,NULL))),
			  line_doc(),
			  rb());
    s = cat(inlinedoc,scopedoc,tqtddoc,bodydoc);

    switch(Flags::c_compiler){
    case Flags::Vc_c:  s = cat(attsdoc,s); break;
    default: break;
    }

    break;

  case &Aggr_d(ad):
    s = cat(aggrdecl2doc(ad),text(";"));
    break;
  case &Var_d(vd):
    s = vardecl2doc(vd);
    break;
  case &Region_d(tv,vd,open_exp_opt):
    s = cat(text("region"),
            text("<"),
            tvar2doc(tv),
            text(">" ),
            qvar2doc(vd->name),
            (open_exp_opt ? cat(text(" = open("),exp2doc(open_exp_opt),
                                text(")")) : nil_doc()),
            text(";"));
    break;
  case &Datatype_d(dd):
    s = cat(datatypedecl2doc(dd),text(";"));
    break;
  case &Let_d(p,_,e,_):
    s = cat(text("let "),
            pat2doc(p),
            text(" = "),
            exp2doc(e),
            text(";"));
    break;
  case &Letv_d(vds):
    s = cat(text("let "), ids2doc(vds), text(";"));
    break;
  case &Enum_d(ed):
    s = cat(enumdecl2doc(ed),text(";"));
    break;
  case &Typedef_d(td):
    type_t t;
    if (td->defn != NULL)
      t = (type_t)td->defn;
    else
      t = new_evar(td->kind,NULL);
    s = cat(text("typedef "),
            tqtd2doc(td->tq,
                     t,
                     new Opt(cat(typedef_name2bolddoc(td->name),
                                 tvars2doc(td->tvs)))),
            // FIX:  not clear where attributes should go...
            atts2doc(td->atts),
            text(";"));

    break;
  case &Namespace_d(v,tdl):
    if (use_curr_namespace) curr_namespace_add(v);
    s = cat(text("namespace "),
            textptr(v),
            blank_doc(),lb(),
            line_doc(),
            ppseql(decl2doc,"",tdl),
            line_doc(),
            rb());
    if (use_curr_namespace) curr_namespace_drop();
    break;
  case &Using_d(q,tdl):
    if (print_using_stmts)
      s = cat(text("using "),
              qvar2doc(q),
              blank_doc(),lb(),
              line_doc(),
              ppseql(decl2doc,"",tdl),
              line_doc(),
              rb());
    else
      s = cat(text("/* using "),
              qvar2doc(q),
              blank_doc(),
              lb(),
              text(" */"),
              line_doc(),
              ppseql(decl2doc,"",tdl),
              line_doc(),
              text("/* "),
              rb(),
              text(" */"));
    break;
  case &ExternC_d(tdl):
    if (print_externC_stmts)
      s = cat(text("extern \"C\" "),
              lb(),
              line_doc(),
              ppseql(decl2doc,"",tdl),
              line_doc(),
              rb());
    else
      s = cat(text("/* extern \"C\" "),
              lb(),
              text(" */"),
              line_doc(),
              ppseql(decl2doc,"",tdl),
              line_doc(),
              text("/* "),
              rb(),
              text(" */"));
    break;
  case &ExternCinclude_d(tdl,ovrs,exs,wc):
    if (print_externC_stmts) {
      doc_t exs_doc;
      doc_t ovrs_doc;
      if (exs != NULL)
        exs_doc = cat(rb(),text(" export "),lb(),
                      line_doc(),ppseql(export2doc,",",exs),
                      line_doc(),rb());
      else
        exs_doc = rb();
      if (ovrs != NULL)
        ovrs_doc = cat(rb(),text(" cycdef "),lb(),
                      line_doc(), ppseql(decl2doc,"",ovrs),
                      line_doc(),rb());
      else
        ovrs_doc = rb();
      s = cat(text("extern \"C include\" "),
              lb(),
              line_doc(),
              ppseql(decl2doc,"",tdl),
              line_doc(),
              exs_doc);
    } else
      s = cat(text("/* extern \"C include\" "),
              lb(),
              text(" */"),
              line_doc(),
              ppseql(decl2doc,"",tdl),
              line_doc(),
              text("/* "),
              rb(),
              text(" */"));
    break;
  case &Porton_d:
    s = cat(text("__cyclone_port_on__;"), lb());
    break;
  case &Portoff_d:
    s = cat(text("__cyclone_port_off__;"), lb());
    break;
  case &Tempeston_d:
    s = cat(text("__tempest_on__;"), lb());
    break;
  case &Tempestoff_d:
    s = cat(text("__tempest_off__;"), lb());
    break;

  }
  return s;
}

doc_t scope2doc(scope_t sc) {
  if (print_for_cycdoc) return nil_doc();
  switch (sc) {
  case Static:   return text("static ");
  case Public:   return nil_doc();
  case Extern:   return text("extern ");
  case ExternC:  return text("extern \"C\" ");
  case Abstract: return text("abstract ");
  case Register: return text("register ");
  default: return nil_doc();
  }
}

// needed to detect default effect
bool exists_temp_tvar_in_effect(type_t t) {
  switch (compress(t)) {
  case &VarType(tv): return is_temp_tvar(tv);
  case &AppType(&JoinCon,l):  return exists(exists_temp_tvar_in_effect, l);
  default: return false;
  }
}

// This is used in deciding whether to expand a typedef -- we don't
// expand a typedef of an anonymous function even if expand_typedefs
// is true, because we end up with anonymous structs in, e.g.,
// function parameters where gcc does not like them.
bool is_anon_aggrtype(type_t t) {
  switch (t) {
  case &AnonAggrType(_,_): return true;
  case &AppType(&AnonEnumCon(_),_): return true;
  case &TypedefType(_,_,td,x) && x != NULL:
    // This won't loop if the types come from a .cyc file,
    // because typedefs in Cyclone (or C) can't be recursive
    return is_anon_aggrtype((type_t)x);
  default: return false;
  }
}

// bubble the attribute modifier past a running series of
// Pointer_mod Function_mod's
static list_t<type_modifier_t<`r>,`r>
bubble_attributes(region_t<`r> r,type_modifier_t<`r> atts,
                  list_t<type_modifier_t<`r>,`r> tms) {
  if (tms != NULL && tms->tl != NULL) {
    switch ($(tms->hd,tms->tl->hd)) {
    case $(&Pointer_mod(_,_),&Function_mod(_)):
      return rnew(r) List(tms->hd,rnew(r) List(tms->tl->hd,bubble_attributes(r,atts,tms->tl->tl)));
    default: return rnew(r) List(atts,tms);
    }
  } else return rnew(r) List(atts,tms);
}

static void rewrite_temp_tvar(tvar_t t){ // change t->name from "#xxx" to "`xxx"
  if (! is_temp_tvar(t)) return;
  let s = strconcat("`", *(t -> name));
  s[1] = 't';
  t -> name = new{(string_t)s};
}


// Conversion between alternate forms of types
$(tqual_t,type_t,list_t<type_modifier_t<`r>,`r>) to_tms(region_t<`r> r,
                                                        tqual_t tq,type_t t) {
  switch (t) {
  case &ArrayType(ArrayInfo{t2,tq2,e,zeroterm,ztl}):
    // Throw away tq, can't qualify an array
    let $(tq3,t3,tml3) = to_tms(r,tq2,t2);
    type_modifier_t tm;
    if (e == NULL)
      tm = rnew(r) Carray_mod(zeroterm,ztl);
    else
      tm = rnew(r) ConstArray_mod((exp_t)e,zeroterm,ztl);
    return $(tq3, t3, rnew(r) List(tm,tml3));

  case &PointerType(PtrInfo(t2,tq2,ptratts)):
    let $(tq3,t3,tml3) = to_tms(r,tq2,t2);
    tml3 = rnew(r) List(rnew(r) Pointer_mod(ptratts,tq),tml3);
    return $(tq3, t3, tml3);

  case &FnType(FnInfo{typvars,effopt,t2qual,t2,args,c_varargs,cyc_varargs,
                        rgn_po,fn_atts,req,_,ens,_,_}):
    if (! print_all_tvars) {
      // don't print default effects
      // WARNING: this is our criterion to detect default effect,
      // so it'd better be right
      if (effopt == NULL || exists_temp_tvar_in_effect(effopt)) {
	effopt = NULL;	//drop the existing effect
	typvars = NULL;	//drop the tvars, but they could be useful b/c of kinds!
      }
    } else {
      if (rewrite_temp_tvars) {
	// rewrite the temp variables so that they could parse
	// WARNING : we don't check for conflicts with user-defined tvars
	iter(rewrite_temp_tvar, typvars);
      }
    }

    // discard tq because you can't qualify a function
    let $(tq3,t3,tml3) = to_tms(r,t2qual,t2);
    list_t<type_modifier_t<`r>,`r> tms = tml3;
    // mess with attributes and arguments:
    // * for gcc: we put all attributes after the args
    // * for VC:
    //   o we drop non-calling conventions on the floor (in fact,
    //     decl printing puts them at the declaration beginning)
    //   o for calling conventions, we put them before the args and rely
    //     on the caller to move them to the right place. KLUDGE! FIX!
    //     (I doubt this is right in all cases.)

    switch(Flags::c_compiler){
    case Flags::Gcc_c:
      if (fn_atts != NULL){
        // if the return type is a function pointer, then we have to
        // move the attributes past that function modifier and so forth
        tms = bubble_attributes(r,rnew(r) Attributes_mod(0,fn_atts),tms);
      }
      tms = rnew(r) List(rnew(r)
                         Function_mod(rnew(r) WithTypes(args,c_varargs,
                                                        cyc_varargs,effopt,
                                                        rgn_po,req,ens)),tms);
      break;
    default:
      tms = rnew(r) List(rnew(r)
                         Function_mod(rnew(r) WithTypes(args,c_varargs,
                                                        cyc_varargs,effopt,
                                                      rgn_po,req,ens)),tms);
      for(; fn_atts != NULL; fn_atts = fn_atts->tl)
	switch(fn_atts->hd) {
	case &Stdcall_att:
	case &Cdecl_att:
	case &Fastcall_att:
	  tms = rnew(r) List(rnew(r) Attributes_mod(0,new List(fn_atts->hd,NULL)),tms);
	  goto AfterAtts;
	default: break;
	}
        break;
    }

  AfterAtts:
    if (typvars != NULL)
      tms = rnew(r) List(rnew(r) TypeParams_mod(typvars,0,true),tms);
    return $(tq3,t3,tms);

  case &Evar(k,topt,i,_):
    if (topt == NULL)
      return $(tq,t,NULL);
    else
      return to_tms(r,tq,topt);

  case &TypedefType(n,ts,td,topt):
    // we don't want to expand when either the flag is set,
    // or it's qualified in some way...
    // DJG: we now expand anonymous aggrs b/c we hoist and name them
    if (topt == NULL || !expand_typedefs)
      return $(tq,t,NULL);
    else {
      if (tq.real_const)
        tq.print_const = tq.real_const;
      return to_tms(r,tq,(type_t)topt);
    }

  default: return $(tq,t,NULL);
  }
}

static bool is_char_ptr(type_t t) {
  // want to avoid compressing here when possible
  switch (t) {
  case &Evar(_,def,_,_) && def != NULL: return is_char_ptr((type_t)def);
  case &PointerType(PtrInfo{elt_typ,_,_}):
  L:
    switch (elt_typ) {
    case &Evar(_,t,_,_) && t != NULL: elt_typ = (type_t)t; goto L;
    case &TypedefType(_,_,_,t) && t != NULL: elt_typ = (type_t)t; goto L;
    case &AppType(&IntCon(_,Char_sz),_): return true;
    default: return false;
    }
  default: return false;
  }
}

doc_t tqtd2doc(tqual_t tq, type_t typ, opt_t<doc_t> dopt) {
  region temp; {
    let $(tq,t,tms) = to_tms(temp,tq,typ);
    tms = List::imp_rev(tms);
    if (tms==NULL && dopt==NULL)
      return cat(tqual2doc(tq),ntyp2doc(t));
    else
      return
        cat(tqual2doc(tq),
            ntyp2doc(t),
            text(" "),
            dtms2doc(is_char_ptr(typ),(dopt==NULL)?nil_doc():dopt->v,tms));
  }
}

doc_t aggrfield2doc(aggrfield_t f) {
  doc_t requires_doc;
  let req = f->requires_clause;
  if (req)
    requires_doc = cat(text("@requires "),exp2doc(req));
  else 
    requires_doc = nil_doc();

  switch(Flags::c_compiler){
  case Flags::Gcc_c:
    // NB: can't have both where and width
    if (f->width != NULL)
      return cat(tqtd2doc(f->tq, f->type, new Opt(textptr(f->name))),
                 text(":"), exp2doc((exp_t)f->width),
                 atts2doc(f->attributes), text(";"));
    return cat(tqtd2doc(f->tq, f->type, new Opt(textptr(f->name))),
	       atts2doc(f->attributes), requires_doc, text(";"));
  default:
    if (f->width != NULL)
      return cat(atts2doc(f->attributes),
                 tqtd2doc(f->tq, f->type, new Opt(textptr(f->name))),
                 text(":"), exp2doc((exp_t)f->width),text(";"));
    return cat(atts2doc(f->attributes),
	       tqtd2doc(f->tq, f->type, new Opt(textptr(f->name))),
	       requires_doc, text(";"));
\
  }
}

doc_t aggrfields2doc(list_t<aggrfield_t> fields) {
  return ppseql(aggrfield2doc,"",fields);
}

doc_t datatypefield2doc(datatypefield_t f) {
  return cat(scope2doc(f->sc), typedef_name2doc(f->name),
             (f->typs==NULL)?nil_doc():args2doc(f->typs));
}

doc_t datatypefields2doc(list_t<datatypefield_t> fields) {
  return ppseql(datatypefield2doc,",",fields);
}

#ifndef PP_WIDTH
#define PP_WIDTH 72
#endif

//// Public interface -- extend with what clients actually want to print
void decllist2file(list_t<decl_t> tdl, FILE @f) {
  for (; tdl != NULL; tdl = tdl->tl) {
    file_of_doc(decl2doc(tdl->hd),PP_WIDTH,f);
    fprintf(f,"\n");
  }
}

string_t decllist2string(list_t<decl_t> tdl) {
  return string_of_doc(seql("",List::map(decl2doc,tdl)),PP_WIDTH);
}
string_t exp2string(exp_t e)     {return string_of_doc(exp2doc(e),  PP_WIDTH);}
string_t stmt2string(stmt_t s)   {return string_of_doc(stmt2doc(s,false,NULL), PP_WIDTH);}
string_t typ2string(type_t t)    {return string_of_doc(typ2doc(t),  PP_WIDTH);}
string_t tvar2string(tvar_t t)   {return string_of_doc(tvar2doc(t), PP_WIDTH);}
string_t typ2cstring(type_t t) {
  bool old_qvar_to_Cids = qvar_to_Cids;
  bool old_add_cyc_prefix = add_cyc_prefix;
  qvar_to_Cids = true;
  add_cyc_prefix = false;
  string_t s = typ2string(t);
  qvar_to_Cids = old_qvar_to_Cids;
  add_cyc_prefix = old_add_cyc_prefix;
  return s;
}
string_t prim2string(primop_t p) {return string_of_doc(prim2doc(p),  PP_WIDTH);}
string_t pat2string(pat_t p)     {return string_of_doc(pat2doc(p),   PP_WIDTH);}
string_t scope2string(scope_t sc){return string_of_doc(scope2doc(sc),PP_WIDTH);}
string_t cnst2string(cnst_t c)   {return string_of_doc(cnst2doc(c),  PP_WIDTH);}

string_t get_type_kind(type_t t) {
  if(t==NULL)
    return (string_t)"NULL";
  switch(t) {
  case &AppType(...): return (string_t)"AppType"; 
  case &Evar(...):  return(string_t) "Evar";  
  case &VarType(...): return (string_t) "Vartype";  // type variables, kind induced by tvar
  case &PointerType(...): return (string_t) "Pointertype";  // t*, t?, t@, etc.  BoxKind when not Unknown_b
  case &ArrayType(...): return (string_t) "ArrayType"; // MemKind
  case &FnType(...): return (string_t) "FnType";  // MemKind
  case &TupleType(...): return (string_t) "TupleType";  // MemKind
  case &AnonAggrType(...): return (string_t) "AnonAggrType";  // MemKind
  case &TypedefType(_, _, td, _): 
    return (string_t) "Typedeftype"; 
  case &ValueofType(...): return (string_t) "Valueoftype";       // IntKind -- exp must be a type-level expression
  case &TypeDeclType(...): return (string_t) "Typedecltype";  
  case &TypeofType(...): return (string_t) "Typeoftype"; 
  }
}
