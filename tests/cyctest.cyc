#include <stdio.h>
#include <list.h>
#include <set.h>
#include <hashtable.h>
#include <string.h>
#include <strings.h>
#include <buffer.h>
#include <queue.h>
#include <rope.h>
#include <dict.h>
#include <ctype.h>
#include <xarray.h>
#include <bitvec.h>
#include <ref.h>
#include <filename.h>
#include <fn.h>
#include <pp.h>
#include <array.h>
#include <arg.h>
#include <errno.h>

using List;
using Set;
using Dict;
using Hashtable;
using Xarray;
using Bitvec;
using Ref;
using Fn;
using Array;

#define allocstr(s) ((stringptr_t) (new (string_t)s))

void test_begin(string_t t) {
  int x = 12-t.size;
  if (x<0) x=0;
  mstring_t padding = new { for i < x : ' ' };
  printf("%s%s: ",padding,t);
}
void test_end() {
  printf("\n");
}
void ok() {
  printf(".");
}
bool no_errors = true;
void fail() {
  no_errors = false;
  printf("\n!!!!!!!!!!!!!!!!!!!!! FAILED !!!!!!!!!!!!!!!!!!!!!\n");
}
void okfailn(int n,bool b) {
  if (b) ok(); else {printf("test %d",n); fail();}
}
void okfail(bool b) {
  if (b) ok(); else fail();
}
void eqstrings(string_t s1,string_t s2) {
  int i = strcmp(s1,s2);
  if (i != 0)
    fprintf(stderr,"%s != %s",s1,s2);
  okfail(i == 0);
}

int test_list_cmp(int cmp(`a,`a),list_t<`a> x,list_t<`a> y) {
  if (x == NULL)
    if (y == NULL) return 0;
    else return -1;
  if (y == NULL) return 1;
  int c = cmp(x->hd,y->hd);
  if (c != 0) return c;
  return test_list_cmp(cmp,x->tl,y->tl);
}

int array_cmp(int cmp(`a,`a),`a ?x,`a ?y) {
  int sx = x.size;
  int sy = y.size;
  if (sx > sy) return 1;
  if (sx < sy) return -1;
  int c;
  for(int i = 0; i < sx; i++) {
    c = cmp(x[i],y[i]);
    if (c != 0) return c;
  }
  return 0;
}
  

void pr_string(string_t s) {
  printf("%s; ",s);
}

void pr_int(int i) {
  printf("%d;",i);
}

void pr_list(list_t<int> x) {
  printf("[");
  List::iter(pr_int,x);
  printf("]\n");
}

void pr_array(int ?x) {
  printf("[|");
  Array::iter(pr_int,x);
  printf("|]\n");
}

int int_cmp(int a, int b) {
  if (a == b) return 0;
  if (a < b) return -1;
  return 1;
}

int my_add(int i, int j) { return i+j; }
int add2(int i) { return i+2; }
bool odd(int i) { return (1 == (i % 2)); }
bool even(int i) { return (0 == (i % 2)); }

void return_from_try_test() {
  try
    return;
  catch {
  default:
    printf("Wrong handler!\n");
    return;
  }
}

void break_in_try_test() {
  printf("Testing break in try: ");
  try {
    for (int i = 5; i>0; i--) {
      try {
        if (i == 3) break;
      }
      catch {
      default:
        printf("INCORRECT HANDLER, break in try\n");
        break;
      }
    }
    throw List::List_mismatch;
  }
  catch {
  default:
    printf("break in try found\n");
    break;
  }
}

void continue_in_try_test() {
  printf("Testing continue in try: ");
  try {
    for (int i = 5; i>0; i--) {
      try continue;
      catch {
      default:
        printf("INCORRECT HANDLER, continue in try\n");
        break;
      }
    }
    throw List::List_mismatch;
  }
  catch {
  default:
    printf("continue in try found\n");
    break;
  }
}

void list_test() {
  test_begin("List");
  // x = list from 1 to 10, backwards
  list_t<int> x = NULL;
  for (int i=1; i<11; i++) x = new List(i,x);
  // xrev = list from 1 to 10, forwards
  list_t<int> xrev = NULL;
  for (int i=1; i<11; i++) xrev = new List(11-i,xrev);
  okfail(0==test_list_cmp(int_cmp,List::rev(x),xrev));

  // xrev2 = [1;1;2;2; ...;10;10]
  list_t<int> xrev2 = NULL;
  for (int i=1; i<11; i++) xrev2 = new List(11-i,new List(11-i,xrev2));
  // test mergesort and append
  okfail(0==test_list_cmp(int_cmp,xrev2,
                     List::merge_sort(int_cmp,
                                      List::append(x,x))));
  okfail(0==test_list_cmp(int_cmp,xrev2,
                     List::merge_sort(int_cmp,
                                      List::append(List::filter(even,xrev2),
                                                   List::filter(odd,xrev2)))));

  // increment x in place
  for (list_t<int> y = x; y != NULL; y=y->tl)
    y->hd = y->hd + 1;
  // xplus = list from 2 to 11, backwards
  list_t<int> xplus = NULL;
  for (int i=1; i<11; i++) xplus = new List(i+1,xplus);
  okfail(0==test_list_cmp(int_cmp,x,xplus));

  // FIX:  casts are required for typechecking.  Should string constants
  // have type char? or char[sz] ??
  let slist = new List(allocstr("hello"),new List(allocstr("world"),NULL));
  let rlist = List::rev(slist);
  okfail(0==test_list_cmp(strptrcmp,slist,List::rev(rlist)));

  list_t<int> xx = NULL;
  list_t<int> yy = NULL;
  // xx = list from 1 to 10, backwards
  for (int i=1; i<11; i++) xx = new List(i,xx);
  // yy = list of 10 11's
  for (int i=1; i<11; i++) yy = new List(11,yy);
  try {
    okfail(0==test_list_cmp(int_cmp,yy,
                       List::map2(my_add,xx,List::rev(xx))));
  }
  catch {
  case List_mismatch:
    fail();
    break;
  }
  try {
    List::map2(my_add,xx,List::append(xx,xx));
    fail();
  }
  catch {
  case List_mismatch:
    ok();
    break;
  }
  test_end();
}

void array_test() {
  // could definitely use more tests
  test_begin("Array");
  unsigned int ?x = new { for i < 6 : 2*i }; // Note, not int ?x
  for (int i=0; i<6; i++)
    okfail(x[i]==2*i);
  for (int i=0; i<6; i+=2) {
    let temp = x[i];
    x[i] = x[i+1];
    x[i+1] = temp;
  }
  for (int i=0; i<6; i+=2) {
    okfail(x[i] == 2*(i+1));
    okfail(x[i+1] == 2*i);
  }
  int ?z1 = new { for i < 10 : (int)(10-i) }; // 10 to 1
  int ?z2 = Array::copy(z1);
  Array::imp_rev(z2);
  int ?z3 = Array::rev_copy(Array::rev_copy(z1));
  // z2 is sorted, z1 and z3 are backwards
  okfail(0==array_cmp(int_cmp,z1,z3));
  Array::qsort(int_cmp,z1,10);
  okfail(0==array_cmp(int_cmp,z1,z2));
  Array::msort(int_cmp,z3,10);
  okfail(0==array_cmp(int_cmp,z3,z2));
  int x = 4;
  int ?z4 = Array::map(add2,Array::extract(z2,2,&x));
  Array::imp_map(add2,z4);
  okfail(0==array_cmp(int_cmp,z4,Array::extract(z2,6,NULL)));
  $(int,int) ?z5 = new {for i < 10 : $((int)(i),(int)(i)) };
  okfail(10==z5.size);
  $(int ?,int ?) pair = Array::split(z5);
  okfail(0==array_cmp(int_cmp,pair[0],pair[1]));
  test_end();
}

void tuple_test() {
  test_begin("Tuple");
  let x = $(1,2);
  let $(y,z) = x;
  okfail(y==1);
  okfail(z==2);
  x[0]=-3;
  x[1]=9;
  let $(y2,z2) = x;
  okfail(y2==-3);
  okfail(z2==9);
  test_end();
}

void pattern_match_test() {
  test_begin("Patterns");
  // char patterns
  switch ((char)('a'+2)) { // Note, cast is needed to typecheck
  case 'b': fail(); break;
  case 'c': ok(); break;
  case 'd': fail(); break;
  default: fail(); break;
  }
  // tuple patterns
  switch ($(1,2,3)) {
  case $(1,3,2): fail(); break;
  case $(1,2,3): ok(); break;
  case $(2,1,3): fail(); break;
  default: fail(); break;
  }
  // nested tuple patterns
  switch ($($(1,2),3)) {
  case $($(1,3),2): fail(); break;
  case $($(1,2),3): ok(); break;
  case $($(2,1),3): fail(); break;
  default: fail(); break;
  }
  // & patterns
  switch ($(new $(1,2),3)) {
  case $(&$(1,3),2): fail(); break;
  case $(&$(1,2),3): ok(); break;
  case $(&$(2,1),3): fail(); break;
  default: fail(); break;
  }
  // && patterns
  switch ($(1,2,3)) {
  case $(1,x,3) && x<2: fail(); break;
  case $(1,x,3) && x==2: ok(); break;
  case $(1,x,3) && x>2: fail(); break;
  default: fail(); break;
  }
  test_end();;
}

void set_test() {
  // UNTESTED:
  // singleton
  // compare
  // fold
  // fold_c
  // app
  // iter
  // iter_c
  // choose

  test_begin("Set");
  set_t<int> x = Set::empty(int_cmp);
  okfail(Set::is_empty(x));
  x = Set::insert(x,9);
  let x2 = x;
  x = Set::insert(x,11);
  x = Set::insert(x,2);
  x = Set::insert(x,-2);
  okfail(Set::member(x,9));
  okfail(!Set::member(Set::delete(x,9),9));
  okfail(Set::member(x,-2));
  okfail(Set::member(Set::delete(x,9),-2));
  okfail(!Set::member(x,4));
  okfail(test_list_cmp(int_cmp,Set::elements(x),
                  new List(-2,new List(2,new List(9,new List(11,NULL))))) == 0);
  okfail(Set::subset(x2,x));
  okfail(!Set::subset(x,x2));
  okfail(Set::subset(x,x));
  okfail(!Set::equals(x,x2));
  okfail(Set::equals(x,x));
  okfail(Set::member(Set::intersect(x2,x),9));
  okfail(!Set::member(Set::intersect(x2,x),2));
  okfail(Set::member(Set::diff(x,x2),11));
  okfail(!Set::member(Set::diff(x,x2),9));
  let x3 = Set::from_list(int_cmp,
                          new List(11,new List(99,NULL)));
  okfail(!Set::subset(x3,x));
  okfail(!Set::subset(x,x3));
  okfail(Set::cardinality(Set::union_two(x,x3))==5);
  okfail(Set::member(Set::union_two(x,x3),9));
  okfail(Set::member(Set::union_two(x,x3),99));
  okfail(Set::member(Set::union_two(x,x3),11));
  okfail(!Set::is_empty(x));

  set_t<stringptr_t<`H,`H>,`H> s = Set::empty(strptrcmp);
  s = Set::insert(s,allocstr("hello"));
  s = Set::insert(s,allocstr("world"));
  s = Set::insert(s,allocstr("sphinx"));
  s = Set::insert(s,allocstr("quartz"));
  okfail(test_list_cmp(strptrcmp,Set::elements(s),
                  new List(allocstr("hello"),
                        new List(allocstr("quartz"),
                              new List(allocstr("sphinx"),
                                    new List(allocstr("world"),NULL))))) == 0);
  test_end();;
}

void pr_binding(int i, int j) {
  printf("%d -> %d; ",i,j);
}

void dict_test() {
  test_begin("Dict");
  dict_t<int,int> x = Dict::empty(int_cmp);
  x = Dict::insert(x,34,68);
  x = Dict::insert(x,1,2);
  x = Dict::insert(x,5,10);
  x = Dict::insert(x,-2,-4);
  okfail(Dict::lookup(x,1)==2);
  okfail(Dict::lookup(x,5)==10);
  okfail(Dict::lookup(x,34)==68);
  okfail(Dict::lookup(x,-2)==-4);
  test_end();;
}

int hash_int(int i) { return i; }
void hashtable_test() {
  test_begin("Hashtable");
  table_t<int,int> x = Hashtable::create(17,int_cmp,hash_int);
  Hashtable::insert(x,1,2);
  Hashtable::insert(x,-4,445);
  Hashtable::insert(x,300,2828);
  okfail(Hashtable::lookup(x,1)==2);
  okfail(Hashtable::lookup(x,-4)==445);
  okfail(Hashtable::lookup(x,300)==2828);

  table_t<stringptr_t<`H,`H>,stringptr_t<`H,`H>> x2 = 
    Hashtable::create(17,strptrcmp,hash_stringptr);
  Hashtable::insert(x2,allocstr("foo"),allocstr("bar"));
  Hashtable::insert(x2,allocstr("baz"),allocstr("rogue"));
  okfail(strptrcmp(Hashtable::lookup(x2,allocstr("foo")),
			   allocstr("bar"))==0);
  okfail(strptrcmp(Hashtable::lookup(x2,allocstr("baz")),
			   allocstr("rogue"))==0);

  test_end();;
}

void string_test() {
  // UNTESTED:
  // strpbrk
  // strspn
  // expand
  // realloc_str

  test_begin("String");

  okfailn(1,to_int("1234",NULL) == 1234);
  okfailn(2,to_int("-1234",NULL) == -1234);
  okfailn(3,to_int("  -1234   ",NULL) == -1234);
  int x = 1;
  okfailn(4,to_int("-1234  ",&x) == 1234);
  okfailn(5,x == 5);
  okfailn(6,to_double("0",NULL) == 0.0);
  okfailn(7,to_double(".0",NULL) == 0.0);
  okfailn(8,to_double("1.",NULL) == 1.0);
  okfailn(9,(to_double("3.14159",NULL) - 3.14159) < 0.000000001);
  okfailn(10,(to_double("-3.14159",NULL) - -3.14159) < 0.000000001);
  okfailn(11,(to_double("3.14e3",NULL) - 3.14e3) < 0.000000001);
  okfailn(12,(to_double("3.14e-3",NULL) - 3.14e-3) < 0.000000001);
  okfailn(13,(to_double("  \t3.14e-3",NULL) - 3.14e-3) < 0.000000001);

  okfailn(14,strcmp("hello","world") < 0);
  okfailn(15,strcmp("hello","hello") == 0);
  okfailn(16,strcmp("world","hello") > 0);

  okfail(strcmp(substring("hello",2,2),"ll")==0);
  okfail(strcmp(replace_suffix("hello.world","world","bar"),
                        "hello.bar")==0);
  // FIX:  polymorphism requires the cast char[sz]->char?
  okfail(strcmp(strconcat_l(new List(allocstr("hello "),
                                                  new List(allocstr("world"),NULL))),
                        "hello world")==0);
  okfail(strcmp(str_sepstr(new List(allocstr("hello"),
                                                 new List(allocstr("world"),NULL)),
                                           "**"),
                        "hello**world")==0);
  // FIX:  polymorphism requires the cast char->int
  okfail(strcmp(implode(new List((int)'a',
                                              new List((int)'b',
                                                    new List((int)'c',NULL)))),
                        "abc")==0);
  switch ((char)explode("abc")->tl->hd) {
  case 'a': fail(); break;
  case 'b': ok(); break;
  case 'c': fail(); break;
  default: fail(); break;
  }

  let s1 = strdup("hello");
  okfail(strlen(s1)==5);
  okfail(strlen((string_t)s1+2)==3);
  s1[3]='\000'; // Note, this writes over a string constant.
  okfail(strlen(s1)==3);
  okfail(strlen((mstring_t)s1+2)==1);
  okfail(strlen((mstring_t)s1+3)==0);
  okfail(strlen((mstring_t)s1+4)==1);
  mstring_t s2 = new { for i < 20 : '\000' };
  okfail(strlen(s2)==0);
  strcat(s2,s1);
  okfail(strcmp(s2,s1)==0);
  okfail(strcmp(s2,"hel")==0);
  strcat(s2,s1);
  okfail(strcmp(s2+2,"helhel"+2)==0);
  okfail(strcmp(s2+2,"xxlhel"+2)==0);
  strcat(s2,(mstring_t)s1+4);
  okfail(strcmp(s2,"helhelo")==0);
  strcpy(s2,"foobar");
  okfail(strcmp(s2,"foobar")==0);
  strncpy(s2+1,"foobar"+2,3);
  okfail(strcmp(s2,"fobaar")==0);
  okfail(strcmp(s2,"xxxfobaar"+3)==0);
  okfail(strcmp(strchr((mstring_t)s2+1,'a'),"aar")==0);
  okfail(strchr((mstring_t)s2+2,'z')==NULL);
  okfail(strcmp(strrchr((mstring_t)s2+1,'a'),"ar")==0);
  okfail(strrchr((mstring_t)s2+2,'o')==NULL);
  okfail(strncmp((mstring_t)s2+1,"xxxobaax"+3,4)==0);
  okfail(strncmp((mstring_t)s2+1,"xxxobaax"+3,5)!=0);
  okfail(strncasecmp((mstring_t)s2+1,"xxxObAax"+3,4)==0);
  let s3 = strdup(s2);
  okfail(strcmp(s3,s2)==0);

  test_end();
}

// THIS DOESN'T WORK!!
string_t bad_strrchr(string_t<`H> s, char c) {
  int len = strlen(s);

  for (int i = len-1; i>=0; i--) {
    if (s[i] == c)
      return &s[i];
  }
  return NULL;
}
void bad_test() {
  test_begin("KNOWN TO BE BAD");
  let s2 = "fobaar";
  printf("\nDa  IN string is %s\n",s2+1);
  printf("Da OUT string is %s\n",bad_strrchr(s2+1,'a'));
  okfail(strcmp(bad_strrchr(s2+1,'a'),"ar")==0);
  test_end();
}

void buffer_test() {
  test_begin("Buffer");
  Buffer::T b = Buffer::create(5);
  Buffer::add_char(b,'a');
  okfail(strcmp(Buffer::contents(b),"a")==0);
  Buffer::add_string(b,"bc");
  okfail(strcmp(Buffer::contents(b),"abc")==0);
  Buffer::add_string(b,"defg");
  okfail(strcmp(Buffer::contents(b),"abcdefg")==0);
  Buffer::add_substring(b,"efghijkl",3,4);
  okfail(strcmp(Buffer::contents(b),"abcdefghijk")==0);
  okfail(Buffer::length(b)==11);
  test_end();;
}

void queue_test() {
  test_begin("Queue");
  Queue::queue_t<stringptr_t<`H,`H>> q = Queue::create();
  okfail(Queue::is_empty(q));
  Queue::add(q,allocstr("a"));
  okfail(!Queue::is_empty(q));
  Queue::add(q,allocstr("b"));
  okfail(strcmp(*(Queue::peek(q)),"a") == 0);
  okfail(strcmp(*(Queue::take(q)),"a") == 0);
  okfail(Queue::length(q) == 1);
  test_end();;
}

void rope_test() {
  test_begin("Rope");
  Rope::rope_t r = Rope::from_string("hello world*");
  let r2 = Rope::concat(r,r);
  let r3 = Rope::concatl(new List(Rope::from_string("xx"),
                               new List(Rope::from_string("yy"),NULL)));
  okfail(Rope::length(r) == strlen("hello world*"));
  okfail(Rope::length(r2) == 2*strlen("hello world*"));
  okfail(Rope::cmp(r,r2) != 0);
  okfail(Rope::cmp(r3,r3) == 0);
  okfail(strcmp(Rope::to_string(r),"hello world*")==0);
  okfail(strcmp(Rope::to_string(r2),"hello world*hello world*")==0);
  okfail(strcmp(Rope::to_string(r3),"xxyy")==0);
  test_end();;
}

void ctype_test() {
  test_begin("Ctype");
  okfail(isupper('A'));
  okfail(!isupper('a'));
  okfail(!isupper('9'));
  okfail(!isupper('\000'));
  okfail(!islower('A'));
  okfail(islower('a'));
  okfail(!islower('9'));
  okfail(!islower('\000'));
  okfail(!isdigit('A'));
  okfail(!isdigit('a'));
  okfail(isdigit('9'));
  okfail(!isdigit('\000'));
  okfail(isxdigit('A'));
  okfail(isxdigit('a'));
  okfail(!isxdigit('h'));
  okfail(isxdigit('9'));
  okfail(!isxdigit('\000'));
  okfail(isspace(' '));
  okfail(!isspace('9'));
  okfail(!isspace('\000'));
  okfail(isalpha('A'));
  okfail(isalpha('a'));
  okfail(isalpha('h'));
  okfail(!isalpha('9'));
  okfail(!isalpha('\000'));
  okfail(isprint(' '));
  okfail(isprint('A'));
  okfail(isprint('a'));
  okfail(isprint('h'));
  okfail(isprint('9'));
  okfail(!isprint('\000'));
  okfail(!isgraph(' '));
  okfail(isgraph('A'));
  okfail(isgraph('a'));
  okfail(isgraph('h'));
  okfail(isgraph('9'));
  okfail(!isgraph('\000'));
  okfail(toupper('c')=='C');
  okfail(toupper('C')=='C');
  okfail(toupper('9')=='9');
  okfail(tolower('c')=='c');
  okfail(tolower('C')=='c');
  okfail(tolower('9')=='9');
  test_end();;
}

void xarray_test() {
  test_begin("Xarray");
  let xa = Xarray::create(3,(int)'a');
  Xarray::add(xa,'a');
  Xarray::add(xa,'b');
  Xarray::add(xa,'c');
  okfail(Xarray::get(xa,0)=='a');
  okfail(Xarray::get(xa,1)=='b');
  okfail(Xarray::get(xa,2)=='c');
  try { Xarray::get(xa,3); fail(); } catch { case &Core::Invalid_argument(x): ok(); break; }
  Xarray::set(xa,1,'B');
  okfail(Xarray::get(xa,1)=='B');
  Xarray::add(xa,'d');
  okfail(Xarray::get(xa,3)=='d');
  try { Xarray::get(xa,4); fail(); } catch { case &Core::Invalid_argument(x): ok(); break; }
  test_end();;
}

void bitvec_test() {
  test_begin("Bitvec");
  bitvec_t b1 = Bitvec::new_empty(24);  // a 24-bit vector
  Bitvec::set(b1,3);                  // set fourth and fifth bits
  Bitvec::set(b1,4);
  okfail(Bitvec::get(b1,3));
  okfail(Bitvec::get(b1,4));
  okfail(!Bitvec::get(b1,2));
  let l1 = Bitvec::to_sorted_list(b1,24);
  okfail(0==test_list_cmp(int_cmp,l1,
			  new List(3,new List(4,NULL))));
  bitvec_t b2 = Bitvec::new_full(24);
  bitvec_t b3 = Bitvec::new_empty(24);
  Bitvec::intersect_two(b3,b1,b2);
  okfail(Bitvec::compare_two(b3,b1));
  Bitvec::union_two(b3,b1,b2);
  okfail(Bitvec::compare_two(b3,b2));
  bitvec_t b4 = Bitvec::new_empty(24);
  Bitvec::diff_two(b3,b2,b1);
  Bitvec::intersect_two(b3,b3,b1);
  okfail(Bitvec::compare_two(b3,b4));
  Bitvec::clear(b1,3);
  Bitvec::clear(b1,4);
  okfail(Bitvec::compare_two(b1,b4));
  test_end();
}

void ref_test() {
  test_begin("Ref");
  ref_t<int> x = new_ref(4);
  okfail(Ref::get(x)==4);
  okfail(Ref::get(x)!=5);
  Ref::set(x,2);
  okfail(Ref::get(x)==2);
  okfail(Ref::get(x)!=4);

  ref_t<stringptr_t> y = new_ref(allocstr("hello")); // FIX: cast required!
  okfail(0==strcmp(*(Ref::get(y)),"hello"));
  okfail(0!=strcmp(*(Ref::get(y)),"world"));
  Ref::set(y,allocstr("world"));
  okfail(0!=strcmp(*(Ref::get(y)),"hello"));
  okfail(0==strcmp(*(Ref::get(y)),"world"));
  test_end();
}

void filename_test() {
  // UNTESTED:
  // gnuify
  // NOT WORKING:
  // current_dir_name  -- because can't have string global, bad initializer

  test_begin("Filename");
  let cwd = ".";
  okfail(0==strcmp(Filename::concat(cwd,"foo"),
                           "./foo"));
  okfail(0==strcmp(Filename::chop_extension("foo.bar"),
                           "foo"));
  okfail(0==strcmp(Filename::dirname("/foo/bar"),
                           "/foo"));
  okfail(0==strcmp(Filename::basename("/foo/bar"),
                           "bar"));
  okfail(Filename::check_suffix("/foo/bar","bar"));
  okfail(!Filename::check_suffix("/foo/bar","foo"));
  test_end();
}

void float_test() {
  test_begin("Float");
  // FIX: parser is having trouble with floating point constants
  float x;
  float y;
  x = (float)2;
  y = (float)4;
  okfail(y==x*x);
  okfail(y==x+x);
  okfail(y!=3*x);
  okfail(y!=y+x);
  okfail(x==y-x);
  okfail(x==y/x);
  test_end();
}

static int addn(int env, int arg) {
  return arg + env;
}

static int addpair($(int,int)@ x) {
  return (*x)[0] + (*x)[1];
}

void fn_test() {
  test_begin("Fn");
  fn_t<int,int,{}> inc = make_fn(addn,1);
  fn_t<int,int,{}> dec = make_fn(addn,-1);
  fn_t<int,int,{}> blah = compose(inc,dec);
  fn_t<$(int,int)@,int,{}> addp = fp2fn(addpair);
  fn_t<int,fn_t<int,int,{}>,{}> addc = curry(addp);
  fn_t<$(int,int)@,int,{}> addu = uncurry(addc);
  okfail(apply(inc,0) == 1);
  okfail(apply(dec,0) == -1);
  okfail(apply(blah,0) == 0);
  okfail(apply(addp,new $(1,2)) == 3);
  okfail(apply(apply(addc,1),2) == 3);
  okfail(apply(addu,new $(1,2)) == 3);
  list_t<int> xs = NULL;
  for (int i = 0; i < 10; i ++)
    xs = new List(i,xs);
  xs = map_fn(apply(addc,2),xs);
  bool okay = true;
  for (int i = 11; xs != NULL; xs = xs->tl, i--) {
    if (xs->hd != i) okay = false;
  }
  okfail(okay);
  test_end();
}

//////////////////////////// Pretty-printer test
using PP {
tunion term {
  Var(string_t),
  App(tunion term,tunion term),
  Lam(string_t,tunion term)
};
bool is_lam(tunion term t) {
  switch (t) {
  case &Lam(x,t1): return true;
  default: return false;
  }
}
doc_t pp_term(tunion term t) {
  switch (t) {
  case &Var(x):
    return text(x);
  case &App(t1,t2):
    if (is_lam(t1))
      return cat(text("("),pp_term(t1),text(")"),text("("),pp_term(t2),text(")"));
      else return cat(pp_term(t1),text("("),pp_term(t2),text(")"));
  case &Lam(x,t1):
    return cat(text("\\"),text(x),text("."),pp_term(t1));
  }
}
void pp_test() {
  test_begin("PP");
  let x = new Var("x");
  let y = new Var("y");
  let z = new Var("z");
  let t1 = new Lam("x",new App(x,x));
  let t2 = new App(t1,t1);
  okfail(0==strcmp("\\x.x(x)",string_of_doc(pp_term(t1),72)));
  okfail(0==strcmp("(\\x.x(x))(\\x.x(x))",
                           string_of_doc(pp_term(t2),72)));
  test_end();
}
}

using Arg {
static int u_foo_foo = 0;
void u_foo() {
  u_foo_foo++;
}
static int i_foo_foo = 0;
void i_foo(int i) {
  i_foo_foo = i;
}
void r_foo(string_t s) {
  printf("Got %s\n",s);
}
void a_foo(string_t s) {
  printf("Anon %s\n",s);
}
typedef $(string_t,bool,string_t,spec_t,string_t) @arg_t;
void arg_test(string_t<`H> ?`H args) {
  // NOTE, TO TEST IT GIVE IT SOME ARGS!
  test_begin("Arg");

  if (args.size<=0) fail();
  else if (args.size==1) ok();
  else {
    arg_t u = new $("-u",false,"",(spec_t)(new Unit_spec(u_foo)),"unit");
    let s_foo = new false;
    arg_t s = new $("-s",false,"",(spec_t)(new Set_spec(s_foo)),"set");
    let c_foo = new true;
    arg_t c = new $("-c",false,"",(spec_t)(new Clear_spec(c_foo)),"clear");
    arg_t i = new $("-i",false,"",(spec_t)(new Int_spec(i_foo)),"int");
    arg_t r = new $("-r",false,"",(spec_t)(new Rest_spec(r_foo)),"rest");
    parse(new List(u,new List(s,new List(c,new List(i,new List(r,NULL))))),
          a_foo,
          "Usage:",
	  args);
    printf("u_foo_foo=%d, "
           "s_foo=%s, "
           "c_foo=%s, "
           "i_foo=%d\n",
           u_foo_foo,
           (*s_foo)?(string_t)"true":(string_t)"false",
           (*c_foo)?(string_t)"true":(string_t)"false",
           i_foo_foo);
  }

  test_end();
}
}

void printf_test() {
  test_begin("Printf");
  // test without %s...
  eqstrings("hello",aprintf("hel" "lo"));
  eqstrings("10",aprintf("%d",10));
  eqstrings("+10",aprintf("%+d",10));
  eqstrings("12",aprintf("%i",10+2));
  eqstrings("12 ",aprintf("%-3i",10+2));
  eqstrings("14",aprintf("%o",10+2));
  eqstrings(" c",aprintf("%2x",10+2));
  eqstrings(" C",aprintf("%*X",2,10+2));
  eqstrings("%",aprintf("%%"));
  eqstrings("45.300000",aprintf("%f",45.3));
  eqstrings("45.30",aprintf("%.*f",2,45.3));
  eqstrings("45.3",aprintf("%g",45.3));
  eqstrings("4.530000e+01",aprintf("%e",45.3));
  eqstrings("XXX  4.53e+01",aprintf("XXX%*.2e",10,45.3));
  eqstrings("XXX  4.53e+01",aprintf("XXX%10.*e",2,45.3));
  eqstrings("XXX  4.53e+01",aprintf("XXX%*.*e",10,2,45.3));
  // and with %s, because the code in toc follows those 2 cases
  eqstrings("hellofoo",aprintf("hel" "lo" "%s","foo"));
  eqstrings("10foo",aprintf("%d%s",10,"foo"));
  eqstrings("+10foo",aprintf("%+d%s",10,"foo"));
  eqstrings("12foo",aprintf("%i%s",10+2,"foo"));
  eqstrings("12 foo",aprintf("%-3i%s",10+2,"foo"));
  eqstrings("foo14",aprintf("%s%o","foo",10+2));
  eqstrings(" cfoo",aprintf("%2x%s",10+2,"foo"));
  eqstrings("foo C",aprintf("%s%*X","foo",2,10+2));
  eqstrings("%foo",aprintf("%%%s","foo"));
  eqstrings("foo45.300000",aprintf("%s%f","foo",45.3));
  eqstrings("foo45.30",aprintf("%s%.*f","foo",2,45.3));
  eqstrings("foo45.3",aprintf("%s%g","foo",45.3));
  eqstrings("foo4.530000e+01",aprintf("%s%e","foo",45.3));
  eqstrings("XXX  4.53e+01foo",aprintf("XXX%*.2e%s",10,45.3,"foo"));
  eqstrings("XXX  4.53e+01foo",aprintf("XXX%10.*e%s",2,45.3,"foo"));
  eqstrings("XXX  4.53e+01foo",aprintf("XXX%*.*e%s",10,2,45.3,"foo"));
  test_end();
}

// Normally commented out because sscanf is insecure.
// Sometimes uncommented for testing.
void scanf_test() {
  test_begin("Scanf");
  long l = 0;
  int i = 0;
  short s = 0;
  char c = 0;
  unsigned long ul = 0;
  unsigned int ui = 0;
  unsigned short us = 0;
  unsigned char uc = 0;
  double d = 0.0;

  sscanf("10","%d",&i);
  okfail(i == 10);
  sscanf("+11","%d",&i);
  okfail(i == 11);
  sscanf("-10","%d",&i);
  okfail(i == -10);
  sscanf("10","%o",&ui);
  okfail(ui == 010);
  sscanf("-10","%o",&ui);
  okfail(ui == -010);
  sscanf("+11","%o",&ui);
  okfail(ui == 011);
  sscanf("af","%x",&ui);
  okfail(ui == 0xaf);
  sscanf("-af","%X",&ui);
  okfail(ui == -0xaf);
  sscanf("+fe","%x",&ui);
  okfail(ui == 0xfe);
  sscanf("AF","%x",&ui);
  okfail(ui == 0xaf);
  sscanf("-AF","%X",&ui);
  okfail(ui == -0xaf);
  sscanf("+FE","%x",&ui);
  okfail(ui == 0xfe);
  sscanf("%45","%%%i",&i);
  okfail(i == 45);

  // Note we have to use %lf etc. for &d !!
  // Printf uses %f for double, but %f means float for scanf.
  sscanf("45.300000","%lf",&d);
  okfail(d == 45.3);
  sscanf("54.30","%lf",&d);
  okfail(d == 54.3);
  sscanf("5.43","%lg",&d);
  okfail(d == 5.43);
  sscanf("4.530000e+01","%le",&d);
  okfail(d == 45.3);
  sscanf("XXX  4.53e+02","XXX%le",&d);
  okfail(d == 453.0);
  sscanf("XXX  3.53e+01","XXX%le",&d);
  okfail(d == 35.3);
  test_end();
}

// check the functionality of extern "C"
extern "C" double cos(double);

extern "C" {
  double sin(double);
  extern double sinh(double);  // should get a warning here
}

namespace CMath {
  extern "C" double atan(double);
}

namespace MyMath {
  double atan(double x) {
    return CMath::atan(x);
  }
}

// test out attribute stuff
  int att_f(int g(int) __attribute__((stdcall)) , int i) {
    return g(i);
  }

  int __attribute__((__stdcall__)) att_foo(int i) {
    return i+1;
  }

  short __attribute__((aligned(4))) att_x = 0;

  struct AttFoo {
    short x __attribute__((aligned(4)));
    short y;
  } __attribute__((packed));

  void att_test() {
    test_begin("Attributes");
//    okfail(_sys_nerr == __CYCLONE_SYS_NUM_ERR);
    okfail(att_f(att_foo,3) == 4);
    test_end();
  }

void letv_test() {
    test_begin("Letv");
    let x,y;
    y = 0;
    if (y != 0) x = 3;
    else x = 4;
    okfail(x == 4);
    okfail(y == 0);
    test_end();
}

int main(int argc, string_t<`H> ?`H args) {
  printf("*************** CYCLONE TEST SUITE ***************\n\n");

  printf("EXCEPTIONS:\n");
  try {
    printf("Testing return in try: ");
    return_from_try_test();
    throw List_mismatch;
  }
  catch {
  case List_mismatch:
    printf("return in try found\n");
    break;
  }
  break_in_try_test();
  continue_in_try_test();

  printf("\nLIBRARIES:\n");

  list_test();
  array_test();
  tuple_test();
  pattern_match_test();
  set_test();
  dict_test();
  hashtable_test();
  string_test();
  buffer_test();
  queue_test();
  rope_test();
  ctype_test();
  xarray_test();
  bitvec_test();
  ref_test();
  filename_test();
  float_test();
  fn_test();
  pp_test();
  arg_test(args);
  printf_test();
  att_test();
  letv_test();
  // scanf_test(); // commented out because sscanf is insecure

  if (no_errors) {
    printf("\nDONE: there were no errors\n");
    return 0;
  } else {
    printf("\n!! ERRORS FOUND !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
    return 1;
  }
}
