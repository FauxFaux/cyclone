#include <core.h>
#include <list.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "smlng.h"
#include "tag_elim.h"
#include "dynamic.h"
#include "timer.h"
#include "buffer.h"
#include "parser.h"
#include "flat.h"
using Core;
using Stdio;
using Buffer;
using Parser;
using String;

bool is_change = true;

string_t start_tags[] = {
  "<0>", "<1>", "<2>", "<3>", "<4>", "<5>", "<6>", "<7>", "<8>", "<9>",
  "<B>", "<EM>", "<I>", "<PL>", "<S>", "<TT>", "<U>", "<r>", "<g>",
  "<b>", "<c>", "<m>", "<y>", "<k>", "<w>"
};
string_t end_tags[] = {
  "</0>", "</1>", "</2>", "</3>", "</4>", "</5>", "</6>", "</7>", "</8>", 
  "</9>", "</B>", "</EM>", "</I>", "</PL>", "</S>", "</TT>", "</U>", "</r>", 
  "</g>", "</b>", "</c>", "</m>", "</y>", "</k>", "</w>"
};

extern tunion Document;
tunion Document {
  Seq(List::list_t<doc_t>); // list must NEVER BE SHARED
  Text(unsigned int);
  Spc(unsigned int);
  Tagged(tag_t,doc_t);
  Mt;
};

bool is_white(char c) {
  switch(c) {
  case 0x20: 
  case 0x0D:
  case 0x0A:
  case 0x09: return true;
  default: return false;
  }
}

// does not copy the actual text
doc_t copy_doc(doc_t d) {
  switch(d) {
  case &Text(i): return new Text(i);
  case &Spc(i): return new Spc(i);
  case &Seq(ds): return new Seq(List::copy(ds));
  case &Tagged(t,d): return new Tagged(t,d);
  case Mt: return Mt;
  }
}

void dump(buf_t b, doc_t d) {
  switch (d) {
  case &Seq(ds): for (; ds != null; ds=ds->tl) dump(b,ds->hd); break;
  case &Text(i): Buffer::write_buf(stdout,b,i); break;
  case &Spc(i): Buffer::write_buf(stdout,b,i); break;
  case &Tagged(tag,d):
    try {
      fwrite(start_tags[tag],1,strlen(start_tags[tag]),stdout); 
      dump(b,d); 
      fwrite(end_tags[tag],1,strlen(end_tags[tag]),stdout);
    } catch {
    default: fprintf(stderr,"bad tag %d\n",tag); exit(1); break;
    }
    break;
  case Mt: break;
  }
}

int doc_size(buf_t b,doc_t d) {
  int sum = 0;
  switch (d) {
  case &Seq(ds):
    for (; ds != null; ds=ds->tl)
      sum += doc_size(b,ds->hd); 
    break;
  case &Text(i): sum += Buffer::size(b,i); break;
  case &Spc(i): sum += Buffer::size(b,i); break;
  case &Tagged(tag,d):
    sum += start_tags[tag].size;
    sum += doc_size(b,d);
    sum += end_tags[tag].size;
    break;
  case Mt: break;
  }
  return sum;
}

unsigned int num_texts(doc_t d) {
  unsigned int sum = 0;
  switch (d) {
  case &Seq(ds):
    for (; ds != null; ds=ds->tl)
      sum += num_texts(ds->hd); 
    break;
  case &Text(s): ++sum; break;
  case &Spc(s): ++sum; break;
  case &Tagged(tag,d):
    sum += num_texts(d);
    break;
  case Mt: break;
  }
  return sum;
}


struct Context {
  unsigned int B :1;
  unsigned int EM :1;
  unsigned int I :1;
  unsigned int S :1;
  unsigned int TT :1;
  char U :2;    // [0-3]
  char size;    // [0-9]
  char color;   // [r_tag-w_tag]
};
context_t init_context = {
  .B = false, .EM = false, .I = false, .S = false, .TT = false, .U = false,
  .size = DONT_KNOW, .color = DONT_KNOW
};

/*filtering out Mt's in a list of docs
 *used in remove_Mt(doc_t d) */
static List::list_t<doc_t> filter_Mt(List::list_t<doc_t> ds){
  while(ds != null && ds->hd == Mt)
    ds = ds->tl;
  if(ds == null)
    return null;
  let prev = ds;
  let ds2 = ds->tl;
  for(; ds2 != null; ds2 = ds2->tl) {
    if(ds2->hd == Mt)
      prev->tl = ds2->tl;
    else
      prev = ds2;

  }
  return ds;
}

//getting rid of Mt branches
doc_t remove_Mt(doc_t d){
  switch(d){
  case &Seq(ds):
    let oldds = ds;
    for(; ds!=null; ds=ds->tl)
      ds->hd = remove_Mt(ds->hd);
    ds = filter_Mt(oldds);
    if (ds==null) return Mt;
    if (ds->tl==null) return ds->hd;//size 1
    return new Seq(ds);
  case &Text(_): return d;
  case &Spc(_): return d;
  case &Tagged(tag,*d2):
    let d3 = remove_Mt(*d2);
    if (d3 == Mt) return Mt;
    else return new Tagged(tag,d3);
  case Mt: return Mt;
  }
}

// gets rid of redundant tags in a top-down fashion
doc_t down_opt(context_t ctxt, doc_t d) {
  switch (d) {
  case &Seq(ds):
    for (; ds!=null; ds=ds->tl)
      ds->hd = down_opt(ctxt,ds->hd);
    return d;
  case &Text(_): return d;
  case &Spc(_): return d;
  case &Tagged(tag,*d2):
    switch (tag) {
    case B_tag:
      if (ctxt.B) {is_change = true; return down_opt(ctxt,*d2);}
      ctxt.B = true; 
      break;
    case EM_tag:
      if (ctxt.S) {is_change = true; return down_opt(ctxt,*d2);} 
      switch(*d2){
      case &Tagged(tag_in_EM,*d3):
        if (tag_in_EM==EM_tag){
          is_change = true;
          return down_opt(ctxt, *d3);
        }
        break;
      case &Seq(ds):
        switch(ds->hd){
        case &Tagged(tag_in_EM,*d3):
          if (tag_in_EM==EM_tag){
            is_change = true;
            ds->hd = down_opt(ctxt,*d3);
            let tail_doc = down_opt(ctxt,new Tagged(EM_tag, new Seq(ds->tl)));
            ds->tl = new List::List(tail_doc,null);
            return new Seq(ds);
          }
          break;
        default:
          if (ds->tl){
            //find the last doc
            let previous = ds;
            let tail_docs = ds->tl;
            while(tail_docs->tl){
              previous = tail_docs;
              tail_docs = tail_docs->tl;
            }
            switch(tail_docs->hd){
            case &Tagged(tag_in_EM,*d3):
              if (tag_in_EM==EM_tag){
                is_change = true;
                previous->tl = null;
                let head_docs = down_opt(ctxt,new Tagged(EM_tag,new Seq(ds)));
                let last_doc = down_opt(ctxt, *d3);
                ds = new List::List(head_docs,new List::List(last_doc,null));
                return new Seq(ds);
              }
              break;
            default:
              break;
            }
          }
          break;
        }
        break;
      default:
        break;
      }
      ctxt.EM = !ctxt.EM; 
      break;
    case I_tag:
      if (ctxt.I) {is_change = true; return down_opt(ctxt,*d2);}
      ctxt.I = true;
      break;
    case PL_tag:
      // PL clears the U, B, EM, I, S, and TT attributes
      if (ctxt.U == 0 && !ctxt.B && !ctxt.EM && !ctxt.I && !ctxt.S && !ctxt.TT){
	is_change = true;
        return down_opt(ctxt,*d2);
      }
      ctxt.U = 0; ctxt.B = false; ctxt.EM = false; ctxt.I = false;
      ctxt.S = false; ctxt.TT = false;
      break;
    case S_tag:
      if (ctxt.S) {is_change=true; return down_opt(ctxt,*d2);}
      ctxt.S = true;
      ctxt.EM = false; // S hides the EM attribute
      break;
    case TT_tag:
      if (ctxt.TT) {is_change=true; return down_opt(ctxt,*d2);}
      ctxt.TT = true;
      break;
    case U_tag:
      if (ctxt.U == 3){is_change=true; return down_opt(ctxt,*d2);}
      ctxt.U++;
      break;
    case Zero:
    case One:
    case Two:
    case Three:
    case Four:
    case Five:
    case Six:
    case Seven:
    case Eight:
    case Nine:
      char sz = (char)tag;
      if (ctxt.size == sz) {
	is_change=true; return down_opt(ctxt,*d2);
      }
      ctxt.size = sz;
      break;
    case r_tag:
    case g_tag:
    case b_tag:
    case c_tag:
    case m_tag:
    case y_tag:
    case k_tag:
    case w_tag:
      char color = (char)tag;
      if (ctxt.color == color) 
	{is_change=true; return down_opt(ctxt,*d2);}
      ctxt.color = color;
      break;
    default: throw new Impossible("down_opt");
    }
    *d2 = down_opt(ctxt,*d2);
    return d;
  case Mt: return Mt;
  }
}

// Queues for fast append
struct Q {
  List::list_t<doc_t> first;
  List::list_t<doc_t> last;
};

struct Q qappend(struct Q q1, struct Q q2) {
  if (q1.last == null) return q2;
  else if (q2.last == null) return q1;
  else {
    q1.last->tl = q2.first;
    q1.last = q2.last;
    return q1;
  }
}

/* removes all of the Seq's from a document, returning it as a list of 
   non-Seq-containing docs */
struct Q flattenit(doc_t d) {
  switch (d) {
  case &Seq(ds):
    struct Q q = {null,null};
    List::list_t<doc_t> ds1, ds_tot = null;
    for (; ds != null; ds = ds->tl) 
      q = qappend(q,flattenit(ds->hd));
    return q;
  case &Text(i): 
    let x = new List::List(d,null);
    return Q{x,x};
  case &Spc(i): 
    let x = new List::List(d,null);
    return Q{x,x};
  case &Tagged(tag,d):
    struct Q q = flattenit(d);
    for (_ x = q.first; x != null; x = x->tl) 
      x->hd = new Tagged(tag,x->hd);
    return q;
  case Mt: return Q{null,null};
  }
}  

List::list_t<doc_t> flatten(doc_t d) {
  return flattenit(d).first;
}

extern void validate_docs(buf_t,doc_t,doc_t);

int main(int argc, char ??argv) {
  string_t tlimit = "182";
  FILE @f = stdin;

  if (argc <= 1) {
    tlimit = Stdlib::getenv("TLIMIT");
    if (tlimit == null) {
      fprintf(stderr,"please set the TLIMIT environment variable\n"
	      "or give a time limit command argument.\n");
      exit(1);
    }
  } else {
    tlimit = argv[1];
    if (argc >= 3) {
      FILE *g = fopen(argv[2],"r");
      if (g != null) f = (FILE @)g;
    }
  }
  start_timer(tlimit);
  if(sizeof(TagElim::synth_t) != sizeof(unsigned long long))
    fprintf(stderr, "TagElim::synth_t has gotten too big!!!");
  buf_t b = init_buf();
  fprintf(stderr,"getting docs..."); fflush(stderr);
  // doc_t orig = get_docs(init_context,b,f);
  // fprintf(stderr,"%d\ncopying docs...",check_time()); fflush(stderr);
  // doc_t d = copy_doc(orig);
  doc_t d = get_docs(init_context,b,f);
  d = remove_Mt(d);

  try {
   // JGM: uncomment to try the bottom up approach
  //fprintf(stderr,"%d\nflatten into array...", check_time());
  //d = Flat::flatten_array(d);
  
  is_change = true;
  int round_num = 1;
  int outer_round_num = 0;
  while(is_change && check_time() > 2 && outer_round_num < 10) {
    ++outer_round_num;
    while(is_change && check_time() > 2  && round_num < 12) {
      is_change = false;
      fprintf(stderr,"%d\nup_opt...", check_time()); fflush(stderr);
      d = TagElim::up_opt(d)[0];
      fprintf(stderr,"%d\ndown_opt...", check_time()); fflush(stderr);
      d = down_opt(init_context,d);
      ++round_num;
    }
    if(round_num > 1 && check_time() > 8) {
      fprintf(stderr,"%d\nup_shuffle...", check_time()); fflush(stderr);
      d = TagElim::up_shuffle(d)[0];
      fprintf(stderr,"%d\nunder_elim...", check_time()); fflush(stderr);
      d = TagElim::under_elim(d)[0];
            // down_opt must precede up_opt 
      fprintf(stderr,"%d\ndown_opt...", check_time()); fflush(stderr);
      d = remove_Mt(d);
      d = down_opt(init_context,d);
      is_change = true;
      round_num = 0;
    }
  }
  //not sure how much time we need, notice we wait until cheaper things have run
  fprintf(stderr,"%d\ndynamic_regions...", check_time()); fflush(stderr);
  let $(d2,TagElim::DynSynth(sz,col)) = TagElim::dynamic_regions(d);
  d = d2;
  if(sz)
    d = dynamic_size(d);
  if(col)
    d = dynamic_color(d);
  } catch {
  case e: 
    fprintf(stderr, "...uncaught exception! dumping anyway...");
    fflush(stderr);
    break;
  }
  fprintf(stderr,"%d\ndumping docs...",check_time()); fflush(stderr);
  dump(b,d);
  let t = check_time();
  fprintf(stderr,"time left: %d sec out of %s sec\n",t,tlimit); fflush(stderr);
  //fprintf(stderr,"validating docs\n",t); fflush(stderr);
  //validate_docs(b,d,orig);
  return 0;
}

