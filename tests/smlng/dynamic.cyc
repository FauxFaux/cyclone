
#include "core.h"
#include "list.h"
#include "dynamic.h"
#include "smlng.h"
#include "timer.h"
#include "stdio.h"
using Stdio;
using List;

#define MAX_INT 0x7fffffff
#define INPUT_SIZE 4 // make bigger when not testing! (but not too big :-( )
#define NUM_SIZES 11

// should probably pass in the context size / color, but I don't know it
// the way I currently have things structured.

// and we'll definitely need to check the clock and throw an exception
// if necessary -- so make sure we're called with the whole doc in a 
// consistent state!

// for simplicity, we flatten the whole thing and then compute 
// INPUT_SIZE at a time.

// int is cost -- can recompute how to achieve it after we're done
// space is wasteful (array is triangular), but that's okay
int size_table[INPUT_SIZE][INPUT_SIZE][NUM_SIZES];
#define S(i,j,s) size_table[i][j][s]

void flatten_size(doc_t doc, $(doc_t,int) ?@`r doc_arr, int @`r curr_pos) {
  doc_t next_doc;
  int   next_size;
  switch(doc) {
  case Mt:             return;
  case &Spc(_):        fallthru;
  case &Text(_):       next_doc = doc; next_size = NUM_SIZES - 1; break;
  case &Tagged(tag,d): next_doc = d;   next_size = tag - Zero;   break;
  case &Seq(ds): 
    for(; ds != null; ds = ds->tl)
      flatten_size(ds->hd,doc_arr,curr_pos);
    return;
  }
  if(*curr_pos == (*doc_arr).size)
    *doc_arr = new {for i < (*doc_arr).size*2: 
		    i < (*doc_arr).size ? (*doc_arr)[i] : $(Mt,0)};
  (*doc_arr)[(*curr_pos)++] = $(next_doc,next_size);
  return;
}

// TO DO: Decide where the size/recomoputation trade-offs are

doc_t unflatten_size($(doc_t,int) ? doc_arr, int left, int right, int outer_sz){
  //  fprintf(stderr,"|%d %d ", left, right);
  if(left == right) {
    doc_t ans = doc_arr[left][0];
    if(doc_arr[left][1] == outer_sz)
      return ans;
    else
      return new Tagged(doc_arr[left][1],ans);
  }
  int min_cost = MAX_INT;
  int sz = 0;
  // our caller just computed this (except for outermost) WASTED WORK
  for(int s=0; s < NUM_SIZES; ++s) {
    int cost = S(left,right,s);
    if(cost < min_cost) {
      min_cost = cost;
      sz = s;
    }
  }
  //  fprintf(stderr,"%d %d %d|", min_cost, sz, outer_sz);
  for(int i=left; i < right; ++i)
    for(int s1=0; s1 < NUM_SIZES; ++s1)
      for(int s2=0; s2 < NUM_SIZES; ++s2)
	if(S(left,i,s1) + S(i+1,right,s2) == min_cost) {
	  doc_t ans = new Seq(list(unflatten_size(doc_arr,left,i,    sz),
				   unflatten_size(doc_arr,i+1, right,sz)));
	  if(sz != outer_sz)
	    ans = new Tagged(sz,ans);
	  return ans;
	}
  fprintf(stderr,"XXXXXXXXXXXXXXXX");
  throw new Core::Impossible("unflatten_size failed recomputation");
}

// FIX: solve the last problem (where INPUT_SIZE is too big)!!!!
// FIX: do something quick when we're out of time
doc_t dynamic_size(doc_t doc) {
  list_t<doc_t> ans = null;
  $(doc_t,int) ? doc_arr = new {for i < INPUT_SIZE : $(Mt,0)};
  int curr_pos = 0;
  flatten_size(doc, &doc_arr, &curr_pos);
  int arr_size = curr_pos;
  //  fprintf(stderr,"!%d!",arr_size);
  curr_pos = 0;
  for(; curr_pos + INPUT_SIZE <= arr_size; curr_pos += INPUT_SIZE) {
    //  fprintf(stderr,"\n====");
    // need to check time in here!
    for (int i = 0; i < INPUT_SIZE; i++)
      for (int s = 0; s < NUM_SIZES; s++) {
	int this_sz = doc_arr[curr_pos+i][1];
	S(i,i,s) = (this_sz == s)?0:((this_sz==NUM_SIZES-1)?MAX_INT:1);
	//fprintf(stderr,"\n#(%d,%d,%d) = %d#", i,i,s,S(i,i,s));
      }
    for (int d = 1; d < INPUT_SIZE; d++)
      for (int s = 0; s < NUM_SIZES; s++)
	for (int i = 0; i+d < INPUT_SIZE; i++) {
	  int j = i+d;
	  int m = MAX_INT;
	  for (int k = i; k < j; k++)
	    for (int s1 = 0; s1 < NUM_SIZES; s1++)
	      for (int s2 = 0; s2 < NUM_SIZES; s2++) {
		if ((s1!=NUM_SIZES-1 && s2!=NUM_SIZES-1) || s==NUM_SIZES-1) {
		  int left  = S(i,  k,s1);
		  int right = S(k+1,j,s2);
		  int m_new;
		  if(left || right == MAX_INT)
		    m_new = MAX_INT;
		  else
		    m_new = left + ((s1==s)?0:1) + right + ((s2==s)?0:1);
		  if (m_new<m) 
		    m = m_new;
		}
	      }
	  //fprintf(stderr,"\n#(%d,%d,%d) = %d#", i,j,s,m);
	  S(i,j,s) = m;
	}
    ans = new List(unflatten_size(doc_arr+curr_pos, 
				  0, INPUT_SIZE-1, NUM_SIZES-1),
		   ans);
  }
  // do something smarter about leftovers, but for now:
  fprintf(stderr,"A%d %dA", curr_pos,arr_size);
  for(int i = curr_pos; i < arr_size; ++i) {
    int sz = doc_arr[i][1];
    if(sz == NUM_SIZES-1)
      ans = new List(doc_arr[i][0], ans);
    else
      ans = new List(new Tagged(doc_arr[i][1]+Zero,doc_arr[i][0]), ans);
  }
  return new Seq(imp_rev(ans));
}

doc_t dynamic_color(doc_t d) {
  return d;
}

