#include "core.h"
#include "list.h"
#include "stdio.h"
#include "buffer.h"
#include "smlng.h"
#include "tag_elim.h"
using Core;
using List;
using Stdio;
namespace TagElim;

// field is true if all text in the doc is guarded by an appropriate tag,
// making an outer tag unnecessary.  Another pass
// gets the top-down things.  (Eg. This pass makes <r><r>x</r><r><y></r> into
// <r>x</r><r><y></r> instead of <r>xy</r>)

// Difference between useless and seen (can't think of better names):
// <B><B>x</B><PL>y</PL></B> strips outer B b/c bold_useless is set
// <B>x</B><B>y</B> wraps an outer B so that down_opt can elim the tags, but
//                  only when bold_seen (and bold_useless) is set
struct SynthS {
  bool bold_useless: 1;
  bool bold_seen: 1;
  //  bool emph: 1;
  bool ital_useless: 1;
  bool ital_seen: 1;
  bool strong_useless: 1;
  bool strong_seen: 1; 
  bool tt_useless: 1;
  bool tt_seen: 1;
  bool plain: 1;
  bool u1: 1; // invariant: true if u2 is true
  bool u2: 1; // invariant: true if u3 is true
  bool u3: 1;
  bool color: 1;
  bool sz: 1;
  int sizes: 10; // 0 at bit n means n DOES get used as a size
  int colors: 8; // 0 at bit n means n DOES get used as a color
};

// unfortunately, the return size of up_opt is now 3 words, so it uses the
// stack.
union Synth {
  struct SynthS s;
  unsigned long long i;
};

synth_t init;

// currently destructive (of doc), but could easily be made functional
$(doc_t, synth_t) up_opt(Buffer::buf_t b, doc_t doc) {
  switch(doc) {
  case &Seq(*dsp): 
    let ds = *dsp;
    init.s = SynthS(1,0,1,0,1,0,1,0,1,1,1,1,1,1,~0,~0);
    synth_t synth      = init;
    synth_t prev_synth = init;
    if(ds == null)
      return $(doc,synth);
    list_t<doc_t> prev     = ds; // won't get used b/c of prev_synth
    list_t<doc_t> prevprev = ds; // won't get used b/c of prev_synth
    while(ds != null) {
      let $(newd, inner_synth) = up_opt(b, ds->hd);
      ds->hd = newd; // destructive here
      // look for reasons to split the sequence and wrap with a redundant tag
      // so the ensuing down optimization can remove the inner tags
      list_t<int> split_tags = null; // no need to be heap-allocated
      if(prev_synth.s.bold_seen && inner_synth.s.bold_seen)
	split_tags = new List(B_tag, split_tags);
      if(prev_synth.s.ital_seen && inner_synth.s.ital_seen)
	split_tags = new List(I_tag, split_tags);
      if(prev_synth.s.strong_seen && inner_synth.s.strong_seen)
	split_tags = new List(S_tag, split_tags);
      if(prev_synth.s.tt_seen && inner_synth.s.tt_seen)
	split_tags = new List(TT_tag, split_tags);
      
      if(prev_synth.s.sz & inner_synth.s.sz 
	 && ~(prev_synth.s.sizes | inner_synth.s.sizes)) {
	int sizes = prev_synth.s.sizes | inner_synth.s.sizes;
	// ASSUMES Zero is least and colors are consecutive.  Very destructive.
	let split_tag = Zero;
	while(sizes & 1 != 0) {
	  sizes >>= 1;
	  ++split_tag;
	}
	split_tags = new List(split_tag,split_tags);
	}
      if(prev_synth.s.color & inner_synth.s.color
	 && ~(prev_synth.s.colors | inner_synth.s.colors)) {
	int colors = prev_synth.s.colors | inner_synth.s.colors;
	// ASSUMES r_tag is least and colors are consecutive.  Very destructive.
	let split_tag = r_tag;
	while(colors & 1 != 0) {
	  colors >>= 1;
	  ++split_tag;
	}
	split_tags = new List(split_tag,split_tags);
      }
      if(split_tags != null) { //subtle: won't happen on first loop iteration
	// IN PLACE sequence splitting
	let next = ds->tl;
	ds->tl = null;
	doc_t d = new Seq(prev);
	for(; split_tags != null; split_tags = split_tags->tl)
	  d = new Tagged(split_tags->hd, d);
	if(prev == *dsp)
	  *dsp = prevprev = prev = new List(d,next);
	else {
	  prev = new List(d,next);
	  prevprev->tl = null;
	  *dsp = new List(new Seq(*dsp), prev);
	  prevprev = *dsp;
	}
	ds = next;
      } else {
	prevprev = prev;
	prev = ds;
	ds = ds->tl;
      }
      synth.i = synth.i & inner_synth.i;
      prev_synth = inner_synth;
    }
    return $(doc,synth);
  case &Text(pos): 
    synth_t synth;
    //    if(Buffer::get_char(b, pos) == '\0')
    //      synth.i = ~0;
    //    else
    synth.i = 0;
    synth.s.sizes  = ~0;
    synth.s.colors = ~0;
    return $(doc,synth);
  case &Tagged(tag,d):
    let $(d2, synth) = up_opt(b, d);
    bool useless = false;
#define USELESS(FIELD) do {useless=synth.s.FIELD; synth.s.FIELD=true;} while(0)
#define SEEN(FIELD) do {synth.s.FIELD=true;} while(0)
    switch(tag) {
    case Zero: case One: case  Two: case  Three: case  Four: case  Five: 
    case Six: case  Seven: case  Eight: case  Nine:
      USELESS(sz);
      // assumes Zero is least tag and they're consecutive
      if(!useless)
	synth.s.sizes = ~(1 << (tag - Zero));
      break;
    case r_tag: case g_tag: case b_tag: case c_tag: case  m_tag: 
    case y_tag: case k_tag: case w_tag:
      USELESS(color); 
      // assumes r_tag is least tag and they're consecutive
      if(!useless)
	synth.s.colors = ~(1 << (tag - r_tag));
      break;
    case B_tag:  USELESS(bold_useless);   SEEN(bold_seen);   break;
    case I_tag:  USELESS(ital_useless);   SEEN(ital_seen);   break;
    case S_tag:  USELESS(strong_useless); SEEN(strong_seen); break;
    case TT_tag: USELESS(tt_useless);     SEEN(tt_seen);     break;
    case EM_tag: useless = synth.s.strong_useless; break; // can float EM?
    case PL_tag: // only color and size matter from outer tags
      USELESS(plain);
      synth.s.bold_useless = 1;   synth.s.bold_seen = 0;
      synth.s.ital_useless = 1;   synth.s.ital_seen = 0;
      synth.s.strong_useless = 1; synth.s.strong_seen = 0;
      synth.s.tt_useless = 1;     synth.s.tt_seen = 0;
      synth.s.tt_useless = 1;     synth.s.tt_seen = 0;
      synth.s.u1 = synth.s.u2 = synth.s.u3 = 1;
      break;
    case U_tag: // can float U?
      if(synth.s.u3)
	useless = true;
      if(synth.s.u2)
	synth.s.u3 = true;
      if(synth.s.u1)
	synth.s.u2 = true;
      synth.s.u1 = true;
      break;
    default: throw new Impossible("tag_elim: tag");
    }
#undef USELESS
#undef SEEN
    if(useless)
      return $(d2,synth);
    else if(d2 == d)
      return $(doc,synth);
    else
      return $(new Tagged(tag,d2),synth);
  }
}

