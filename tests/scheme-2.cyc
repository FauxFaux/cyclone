/* A test case for the Cyclone compiler that was built from the callcc
   example of the scheme-2 interpreter.  It has some unusual static
   allocation and region stuff.  It does a garbage collection, use
   --gc-messages to see it.  It should be compiled with -nogc.

   Output looks like this:

    % ./scheme-2 --gc-messages
    major gc...
      from-space(used): 262144 bytes...
      from-space(free): 153312 bytes...
      from-space(alloc): 108728 bytes...
      from-space(wasted): 104 bytes...
      to-space(used): 65536 bytes...
      to-space(free): 54048 bytes...
      to-space(alloc): 11392 bytes...
      to-space(wasted): 96 bytes...
      to-space(limit): 65536 bytes...done.
    32
    program returned:
    ##unspecified##

*/

#include <core.h>
#include <dict.h>
#ifndef _DYNAMIC_REGION_SEQ_H_
#define _DYNAMIC_REGION_SEQ_H_

//////////////////////////////////////////////////////////////////////
// Dynamic region sequence interface
//////////////////////////////////////////////////////////////////////
namespace DynamicRegionSeq {
  using Core;

  // next_rgn maps regions to regions and gives us a way to generate
  // an infinite name supply for regions.
  typedef _::R next_rgn<`r::R>;

  // a capability to generate next_region<`r>'s key (and the next generator)
  struct DynamicRegionGen<`r::R>;
  typedef struct DynamicRegionGen<`r>@`U uregion_gen_t<`r>;

  struct DynamicRegionSeq<`r> {
    uregion_key_t<`r> key;
    uregion_gen_t<`r> gen;
  };
  typedef struct DynamicRegionSeq<`r> drseq_t<`r>;

  // return type for new_region_seq() -- a fresh region, a key for the region,
  // and a seed for generating follow-on regions.
  struct NewDynamicRegionSeq { <`r::R>
    struct DynamicRegionSeq<`r> drseq;
  };

  extern struct NewDynamicRegionSeq new_drseq();
  extern struct DynamicRegionSeq<next_rgn<`r>> next_drseq(uregion_gen_t<`r> gen; {});
}
#endif
#ifndef _SCHEME_H_
#define _SCHEME_H_

#define forward_ptr_t(t, r) t<next_rgn<r>>
#define forward_t(t,r) $(forward_ptr_t(t, r), t<r>)

#define RNEW(r,e) rnew(r) e

namespace Scheme {
  using Core;
  using DynamicRegionSeq;

  //////////////////////////////////////////////////////////////////////
  // Core data-structures
  //////////////////////////////////////////////////////////////////////
  datatype Const<`r::R>;
  typedef datatype Const<`r>@`r const_t<`r>;

  datatype ExpD<`r::R>;
  struct Exp<`a::A,`r::R>;
  typedef struct Exp<datatype ExpD<`r>,`r>*`r exp_t<`r>;

  datatype ValueD<`r::R>;
  struct Value<`a::A,`r::R>;
  typedef struct Value<datatype ValueD<`r>,`r>*`r value_t<`r>;

  struct Env<`r::R>;
  typedef struct Env<`r>*`r env_t<`r>;

  @tagged union Frame<`r::R>;
  typedef union Frame<`r> frame_t<`r>;

  struct Stack<`r::R>;
  typedef struct Stack<`r>*`r stack_t<`r>;

  @tagged union Result<`r::R>;
  typedef union Result<`r> result_t<`r>;

  struct State<`r::R>;
  typedef struct State<`r> state_t<`r>;
  typedef struct State<`r>@`s state_ptr_t<`r,`s>;

  //////////////////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////////////////

  // Constants
  datatype Const<`r> {
    Bool_l(bool);
    Char_l(char);
    Int_l(int);
    Real_l(double);
    String_l(const char *@notnull@fat@nozeroterm `r);
    Symbol_l(stringptr_t<`H,`H>);
    Undef_l;
    Unspec_l;
  };

  // expressions:
  // e ::= K | x | (e e1 ... en) |
  //       (lambda (x1 ... xn) e) |
  //       (lambda (x1 ... xn . y) e) |
  //       (if e1 e2 e3) | (set! x e)
  datatype ExpD<`r> {
    Const_e(value_t<`r> K);
    Var_e(const char ?, unsigned int i, unsigned int j);
    Apply_e(exp_t<`r>*@notnull@fat`r es);
    Lambda_e(const char??`r, exp_t<`r> e);
    VarArgsLambda_e(const char??`r, const char ?, exp_t<`r> es);
    If_e(exp_t<`r> e1, exp_t<`r> e2, exp_t<`r> e3);
    Set_e(const char ?, unsigned int i, unsigned int j, exp_t<`r> e);
  };
  struct Exp<`a::A,`r::R> {
    forward_ptr_t(exp_t,`r) forward;
    `a exp;
  };


  // stack frames:  correspond to Felleisen and Wright-style semantics
  // F ::= (v1 v2 ... vi-1 [] ei+1 ... en) | (if [] e2 e3) | (set! x [])
  // S ::= nil | F::S
  @tagged union Frame<`r> {
    exp_t<`H>*@notnull@numelts(2)`r if_frame; // if [] e2 e3
    $(exp_t<`H>*@notnull@fat`r,
      unsigned int,
      value_t<`r>*@notnull@fat`r) apply_frame; //(v1 ... vi-1 [] ei+1 ... en)
    $(unsigned int depth,
      unsigned int offset) set_frame; // (set! x [])
  };

  struct Stack<`r> {
    forward_ptr_t(stack_t,`r) forward;
    bool shared;
    stack_t<`r> next;
    env_t<`r> env;
    frame_t<`r> frame;
  };

  @tagged union Result<`r> {
    value_t<`r> value;
    exp_t<`H> expr;
  };

  struct State<`r> {
    stack_t<`r> stack;
    env_t<`r> env;
    result_t<`r> result;
    env_t<`r> top_env;
    stack_t<`r> free_frames;
    value_t<`r> true_v;
    value_t<`r> false_v;
  };

  typedef void (@`H primop_t)<`r,`s>(region_t<`r>,state_ptr_t<`r,`s>,value_t<`r>*@notnull@fat`r);
  typedef Dict::dict_t<stringptr_t<`H,`r::R>,$(unsigned,unsigned)@`r,`r> static_env_t<`r>;
  // run-time values:
  datatype ValueD<`r> {
    Const_v(const_t<`r> K);
    Throw_v(stack_t<`r> S, env_t<`r> rho);
    Closure_v(unsigned int n, env_t<`r> rho, exp_t<`H> e);
    VarArgsClosure_v(unsigned int m, env_t<`r> rho, exp_t<`H> e);
    Pair_v(value_t<`r> l1, value_t<`r> l2);
    Vector_v(value_t<`r>*@notnull@fat`r ls);
    String_v(char *@notnull@fat@nozeroterm `r s);
    Primop_v(primop_t p);
    Primop_cons_v;
    Primop_car_v;
    Primop_cdr_v;
    Primop_eq_p_v;
    Primop_null_p_v;
  };
  struct Value<`a::A,`r::R> {
    forward_ptr_t(value_t,`r) forward;
    `a value;
  };
  struct Env<`r> {
    forward_ptr_t(env_t,`r) forward;
    env_t<`r> next;
    value_t<`r>*@notnull@fat`r values;
  };

#define EnvP(next,values) Env{_,next,values}
#define EnvC(next,values) Env{NULL,next,values}
#define ExpP(exp) Exp{_,exp}
#define ExpC(exp) Exp{NULL,exp}
#define ValueP(value) Value{_,value}
#define ValueC(value) Value{NULL,value}
#define StackC(shared,next,env,frame) Stack{NULL,shared,next,env,frame}

  extern void fail(const char ?msg) __attribute__((noreturn));
  extern void error(const char ?msg,
		    stack_t<`r> stack,
		    env_t<`r> env) __attribute__((noreturn));
  extern void scheme(exp_t<`H> prog());
  void frame_push<`r,`s>(region_t<`r> r,state_ptr_t<`r,`s> s, frame_t<`r> f);
}
#endif

#ifndef _CSAST_H_
#define _CSAST_H_

//////////////////////////////////////////////////////////////////////
// abstract syntax constructors
//////////////////////////////////////////////////////////////////////
namespace Scheme {namespace CoreSchemeAst {
  using Core;
  using Scheme;

  extern stringptr_t<`H,`H> intern(stringptr_t<`H,`H>);
}}

#endif
#ifndef _FLAGS_H_
#define _FLAGS_H_

namespace Scheme { namespace Flags {

  extern bool gc_messages;
  extern bool nil_is_false;
  extern bool trace_prims;
  extern bool verbose;
}}

#endif
#ifndef _SCHEME_GC_H_
#define _SCHEME_GC_H_

namespace Scheme {namespace GC {
  using DynamicRegionSeq;
  using Scheme;

/**open: frags/pp-GCState.tex*/
// the gc state encapsulates
//  - the current region (existentially bound)
//  - a dynamic region sequence (containing a key and generator)
//  - the state (containing roots)
typedef struct GCState { <`r> 
  drseq_t<`r> key_gen;
  state_t<`r> state;
} gcstate_t;
/**close*/

  gcstate_t maybeGC(gcstate_t gcs);
  const_t<`s> copy_constant(region_t<`s> to_r, const_t<`r> from_const);
}}

#endif
#ifndef _PP_H_
#define _PP_H_

//////////////////////////////////////////////////////////////////////
// Pretty Printer for debuging
//////////////////////////////////////////////////////////////////////
namespace Scheme { namespace PrettyPrint {
  using Core;
  using Scheme;

  extern int pp_indent;
  extern bool pp_with_deb_idx;
  extern bool pp_with_lets;
  extern void pp_const(FILE @fp,int indent,const_t<`r> l);
  extern void pp_exp(FILE @fp,int indent,exp_t<`r> e);
  extern void pp_value(FILE @fp,int indent,value_t<`r> o);
  extern void pp_env(FILE @fp,int indent,env_t<`r> e);
  extern void pp_frame(FILE @fp,int indent,frame_t<`r> f);
  extern void pp_stack(FILE @fp,int indent,stack_t<`r> s);
  extern void pp_result(FILE @fp,int indent,result_t<`r> r);
  extern void pp_state(FILE @fp,int indent,state_ptr_t<`r> s);
}}

#endif
#ifndef _PRIMOPS_H_
#define _PRIMOPS_H_


namespace Scheme {namespace PrimOps {
  using Core;
  using Scheme;

  // constructs the initial run-time environment which has a binding
  // for each of the primops.
  extern env_t<`r> initial_env(region_t<`r> r);

  // constructs the initial static environment which will map the
  // name of the primop to the right offset in the top-level environment.
  extern static_env_t<`r> initial_static_env(region_t<`r> r);

  // Find the name of a primop.
  extern const char?`H prim_name(primop_t p);
}}


#define COMMA ,

#define PRIM(p) void p<`r,`s>(region_t<`r> r, state_ptr_t<`r,`s> state, value_t<`r>?`r args)
#define ERROR(s) error(s,state->stack,state->env)
#define RETURN(obj) {let OBJ = obj; state->result = Result{.value=OBJ}; return; }

#define ANYARGCHECK \
  unsigned nelts = numelts(args)

#ifdef NDEBUG
#define ARGCHECK(n) \
  unsigned nelts = numelts(args)
#else
#define ARGCHECK(n) \
  unsigned nelts = numelts(args); \
  if (nelts != (n)) \
    ERROR(aprintf("expecting %d arguments",(n)))
#endif
#define ARGRANGECHECK(n,m) \
  unsigned nelts = numelts(args); \
  if ((nelts < n) || (m < nelts)) \
    ERROR(aprintf("expecting %d arguments",(n)))

#define PREDICATE1WITH(pat,stm) \
  switch (args[0]) { \
  case &ValueP(*ARG0_): \
    switch (ARG0_) { \
      case pat: stm; \
      default: RETURN(FALSE); } \
  default: RETURN(FALSE); }
#define PREDICATE1(pat) \
  PREDICATE1WITH(pat,RETURN(TRUE))
#define PREDICATE2WITH(pat1,stm1,pat2,stm2) \
  switch (args[0]) { \
  case &ValueP(*ARG0_): \
    switch (ARG0_) { \
      case pat1: stm1; \
      case pat2: stm2; \
      default: RETURN(FALSE); } \
  default: RETURN(FALSE); }
#define PREDICATE2(pat1,pat2) \
  PREDICATE2WITH(pat1,RETURN(TRUE),pat2,RETURN(TRUE))
#define PREDICATE3WITH(pat1,stm1,pat2,stm2,pat3,stm3) \
  switch (args[0]) { \
  case &ValueP(*ARG0_): \
    switch (ARG0_) { \
      case pat1: stm1; \
      case pat2: stm2; \
      case pat3: stm3; \
      default: RETURN(FALSE); } \
  default: RETURN(FALSE); }
#define PREDICATE3(pat1,pat2,pat3) \
  PREDICATE3WITH(pat1,RETURN(TRUE),pat2,RETURN(TRUE),pat3,RETURN(TRUE))
#define PREDICATE4WITH(pat1,stm1,pat2,stm2,pat3,stm3,pat4,stm4) \
  switch (args[0]) { \
  case &ValueP(*ARG0_): \
    switch (ARG0_) { \
      case pat1: stm1; \
      case pat2: stm2; \
      case pat3: stm3; \
      case pat4: stm4; \
      default: RETURN(FALSE); } \
  default: RETURN(FALSE); }
#define PREDICATE4(pat1,pat2,pat3,pat4) \
   PREDICATE4WITH(pat1,RETURN(TRUE),pat2,RETURN(TRUE),pat3,RETURN(TRUE),pat4,RETURN(TRUE))

#define LET1(ty,x,arg,pat,stm,err) \
  ty x; \
  switch (arg) { \
  case &ValueP(*ARG_): \
    switch (ARG_) { \
    case pat: stm; break; \
    default: ERROR(err); } break; \
  default: ERROR(err); }

#define LET2(ty,x,arg,pat1,stm1,pat2,stm2,err) \
  ty x; \
  switch (arg) { \
  case &ValueP(*ARG_): \
    switch (ARG_) { \
    case pat1: stm1; break; \
    case pat2: stm2; break; \
    default: ERROR(err); } break; \
  default: ERROR(err); }


#define CONST(v) RNEW(r,ValueC(Const_v(v)))
#define UNSPEC CONST(RNEW(r,Unspec_l))

#define CHAR(c) CONST(RNEW(r,Char_l(c)))
#define LETCHAR(x,arg) \
   LET1(char,x,arg, \
        &Const_v(&Char_l(X)), x = X, \
        "expected char")

//#define TRUE CONST(RNEW(r,Bool_l(true)))
//#define FALSE CONST(RNEW(r,Bool_l(false)))
#define TRUE state->true_v
#define FALSE state->false_v
#define BOOL(b)	((b) ? (TRUE) : (nil_is_false ?  NULL : FALSE))

#define INT(i) CONST(RNEW(r,Int_l(i)))
#define REAL(x) CONST(RNEW(r,Real_l(x)))

#define LETNUM(n,arg) \
   LET2(num_t,n,arg,\
        &Const_v(&Int_l(I)), n = mknum_integer(I), \
        &Const_v(&Real_l(X)), n = mknum_real(X), \
        "expected number")

#define LETINT(i,arg) \
   LET2(int,i,arg,\
        &Const_v(&Int_l(I)), i = I, \
        &Const_v(&Real_l(X)), int Y = (int) X; if (X == (double)Y) i = Y; else ERROR("expected integer"), \
        "expected integer")

#define LETREAL(x,arg) \
   LET2(double,x,arg,\
        &Const_v(&Int_l(I)), x = (double)I, \
        &Const_v(&Real_l(X)), x = X, \
        "expected integer")


#define PAIR(hd,tl) RNEW(r,ValueC(Pair_v(hd COMMA tl)))
#define LETPAIR(hd,tl,arg) \
  LET1(value_t<`r>, hd COMMA tl, arg, \
       &Pair_v(HD,TL), hd = HD; tl = TL, \
       "expected pair")
#define LETPAIRP(hd,tl,arg) \
  LET1(value_t<`r>, @hd COMMA @tl, arg, \
       &Pair_v(*HD,*TL), hd = HD; tl = TL, \
       "expected pair")


#define SYM(s) CONST (RNEW(r,Symbol_l(s)))
#define LETSYMBOL(s,arg) \
  LET1(stringptr_t<`H COMMA `H>, s, arg, \
       &Const_v(&Symbol_l(S)), s = S, \
       "expected symbol")


#define STR(s) CONST(RNEW(r,String_l(s)))
#define MSTR(s) RNEW(r,ValueC(String_v(s)))
#define LETSTRING(s,arg) \
  LET2(const char ? @nozeroterm `r, s, arg, \
       &Const_v(&String_l(S)), s = S, \
       &String_v(S), s = S, \
       "expected string")
#define LETMSTRING(s,arg) \
  LET1(char ? @nozeroterm `r, s, arg, \
       &String_v(S), s = S, \
       "expected mutable string")


#define VEC(v) RNEW(r,ValueC(Vector_v(v)))
#define LETVECTOR(v,arg) \
  LET1(value_t<`r> ?, v, arg, \
       &Vector_v(V), v = V, \
       "expected vector")
#endif
/* A test case for the Cyclone compiler built from the callcc example
   of the scheme-2 interpreter.  It does some unusual static
   allocation and region stuff.
*/

#include <hashtable.h>
#include <string.h>
using Core {
using Scheme;
using Scheme::Flags;

namespace Scheme;
namespace CoreSchemeAst;
using Hashtable;

/* this approach leaks */
static table_t<stringptr_t,stringptr_t>? sym_table;
static int hash(stringptr_t<`H,`H> x) {
  return hash_string(*x);
}
stringptr_t<`H,`H> intern(stringptr_t<`H,`H> s) {
  if(sym_table == NULL) {
    sym_table = new create(1024,strptrcmp,hash);
  }
  let v = lookup_opt(*sym_table,s);
  if(v != NULL) {
    return *v;
  } else {
    insert(*sym_table,s,s);
    return s;
  }
}
}
using Core {

namespace DynamicRegionSeq;

// I need this function to keep the compiler from trimming away
// the prototype for Cyc_Core_new_ukey() which is called below.
static void never_called() {
  new_ukey();
}

// Here are the new C functions we need for generating a fresh
// key and counter, as well as the next key and counter.
extern "C include" {
  // get a new region, it's key, and it's counter
  struct NewDynamicRegionSeq Cyc_DynamicRegionSeq_new_drseq() {
    struct Cyc_DynamicRegionSeq_NewDynamicRegionSeq res;
    //    res.drseq.key = new_ukey().key;
    res.drseq.key = Cyc_Core__new_ukey(0,"internal-error","internal-error",0).key;
    res.drseq.gen = 0;
    return res;
  }
  // generate the next region -- you pass in the capability for the
  // region counter on `r, and you get out a key for the next_rgn<`r>
  // as well as a generator for generating next_rgn<next_rgn<`r>> and
  // so forth.
  struct DynamicRegionSeq<next_rgn<`r>> Cyc_DynamicRegionSeq_next_drseq(uregion_gen_t<`r> gen; {}) {
    struct Cyc_DynamicRegionSeq_DynamicRegionSeq next;
    //    next.key = new_ukey().key;
    next.key = Cyc_Core__new_ukey(0,"internal-error","internal-error",0).key;
    next.gen = 0;
    return next;
  }
} export { Cyc_DynamicRegionSeq_new_drseq, Cyc_DynamicRegionSeq_next_drseq }

}
namespace Scheme {
namespace Flags;

bool gc_messages = false;
bool nil_is_false = false;
bool trace_prims = false;
bool verbose = false;
}
using Core {
using DynamicRegionSeq;
using Scheme;
using Scheme::Flags;

namespace Scheme;
namespace GC;

// copy a constant value -- no internal forwarding necessary
const_t<`s> copy_constant(region_t<`s> to_r, const_t<`r> from_const) {
  switch (from_const) {
  case &Bool_l(b): return rnew(to_r) Bool_l(b);
  case &Char_l(c): return rnew(to_r) Char_l(c);
  case &Int_l(i): return rnew(to_r) Int_l(i);
  case &Real_l(x): return rnew(to_r) Real_l(x);
  case &String_l(s): return rnew(to_r) String_l(rstrdup(to_r,s));
  case &Symbol_l(s): return rnew(to_r) Symbol_l(s);
  case &Undef_l: return rnew(to_r) Undef_l;
  case &Unspec_l: return rnew(to_r) Unspec_l;
  }
}

#define LIVE_RATIO 4.0
#define INITIAL_HEAP_LIMIT 1<<16
int heap_limit = INITIAL_HEAP_LIMIT;

////////////////////////////////////////////////////////////////////
// The explicit queue used for maintaining the frontier of objects
// to be forwarded.
struct Frontier<`r::R>;
typedef struct Frontier<`r>*`U frontier_t<`r>;
// A non-null pointer in region `r to an `a -- useful when `r needs
// to be next_rgn<->.  
typedef `a@`r gptr_t<`a,`r>;
// A copy function which takes in the frontier, the to-space, and a pointer
// to a from-space object.  Returns the a pointer in to-space to the new
// object and a new frontier which includes all of the fields within the
// from-space object to still be forwarded.
typedef $(frontier_t<`r>,`b) (@copy_t<`r,`a,`b>)(frontier_t<`r>, region_t<next_rgn<`r>>, `a ; {`r,next_rgn<`r>}) __attribute__((consume(1)));

// A queue element for the frontier
struct Front<`r> { <`a,`b> // abstract `a and `b -- could be environments, stacks, etc.
  copy_t<`r,`a,`b> copy; // copy function
  `a from_ptr; // from-space object to copy
  gptr_t<`b,next_rgn<`r>> to_ptr_ptr; // to-space place to plug in new object
};

//#define FRONTIER_AS_QUEUE
#define FRONTIER_AS_STACK
#ifdef FRONTIER_AS_QUEUE
// A queue: 
// invariants:  empty when first == next 
//              full when next+1 == first
struct Frontier<`r> { 
  unsigned int first;
  unsigned int next;
  struct Front<`r> ?`U queue;
};

#define INITIAL_QUEUE_SIZE 1<<10;

// Enqueue the object to be forwarded, along with it's copy function,
// and the place to plug the result in in to-space.  
static frontier_t<`r> add_front(frontier_t<`r> front, copy_t<`r,`a,`b> copy, 
                                `a from_ptr, 
                                gptr_t<`b,next_rgn<`r>> to_ptr_ptr;
                                {`r}) __attribute__((consume(1))) {
  static int qs = INITIAL_QUEUE_SIZE;
  struct Front f = {copy, from_ptr, to_ptr_ptr};
  // check for empty queue
  if (front == NULL) {
    // just return a new queue
    return unew Frontier{0,1,unew {for i < qs : f}};
  }
  unsigned nelts = numelts(front->queue);
  unsigned n = (front->next + 1) % nelts;
  // check to see if the queue is full
  if (n == front->first) {
    // grow the queue so it's twice as big
    unsigned new_nelts = 2*nelts;
    qs = new_nelts;
    if (gc_messages)
      fprintf(stderr,"\n  growing GC queue from %d to %d...",nelts,new_nelts);
    let new_queue = unew {for i < new_nelts : f};
    // dequeue elements of the old queue and write them into the new one
    for (unsigned i = 0; front->first != front->next; i++) {
      new_queue[i] = front->queue[front->first];
      front->first = (front->first + 1) % nelts;
    }
    // swap the old and new queues
    front->queue :=: new_queue;
    // free the old queue
    ufree(new_queue);
    // reseet the first and next fields
    front->first = 0;
    front->next = nelts+1;
    return front; // NB: we've already written f since we've initialized things
  } else {
    // common case -- queue is not full, so write f at next and bump next
    front->queue[front->next] = f;
    front->next = n;
    return front;
  }
}

// complete the frontier by dequeing front elements, calling the
// copy function, plug in the result, etc.  We have to thread the
// frontier queue through this as copying may add more things to
// the queue.
static void finish_front(frontier_t<`r> front, region_t<next_rgn<`r>> to_rgn
                         ; {`r,next_rgn<`r>}) {
  // check for empty frontier
  if (front == NULL) return;
  // iterate until queue is empty
  while (front->first != front->next) {
    // dequeue an element
    let Front{copy,from,to_ptr} = front->queue[front->first];
    front->first = (front->first + 1) % numelts(front->queue);
    // forward it, getting a new frontier
    let $(new_front,to) = copy(front, to_rgn, from);
    front = new_front;
    // plug in the to-space ptr
    *to_ptr = to;
  }
  // free up the frontier
  ufree(front->queue);
  ufree(front);
}

#endif

#ifdef FRONTIER_AS_STACK

// A stack: 
struct Frontier<`r> { 
  unsigned int next;
  struct Front<`r> ?`U stack;
};

#define INITIAL_STACK_SIZE 1<<10;

// Push the object to be forwarded, along with its copy function,
// and the place to plug the result in in to-space.  
static frontier_t<`r> add_front(frontier_t<`r> front, copy_t<`r,`a,`b> copy, 
                                `a from_ptr, 
                                gptr_t<`b,next_rgn<`r>> to_ptr_ptr;
                                {`r}) __attribute__((consume(1))) {
  struct Front f = {copy, from_ptr, to_ptr_ptr};
  static int qs = INITIAL_STACK_SIZE;
  // check for empty stack
  if (front == NULL) {
    // just return a new stack
    return unew Frontier{1,unew {for i < qs : f}};
  }
  unsigned nelts = numelts(front->stack);
  unsigned n = (front->next + 1) % nelts;
  // check to see if the stack is full
  if (n == 0) {
    // grow the stack so it's twice as big
    unsigned new_nelts = 2*nelts;
    qs = new_nelts;
    if (gc_messages)
      fprintf(stderr,"\n  growing GC stack from %d to %d...",nelts,new_nelts);
    let new_stack = unew {for i < new_nelts : f};
    // pop elements of the old stack and write them into the new one
    for (unsigned i = 0; i != front->next; i++) {
      new_stack[i] = front->stack[i];
    }
    // swap the old and new stacks
    front->stack :=: new_stack;
    // free the old stack
    ufree(new_stack);
    // reset the first and next fields
    front->next = nelts+1;
    return front; // NB: we've already written f since we've initialized things
  } else {
    // common case -- stack is not full, so write f at next and bump next
    front->stack[front->next] = f;
    front->next = n;
    return front;
  }
}

// complete the frontier by poping elements, calling the
// copy function, plug in the result, etc.  We have to thread the
// frontier stack through this as copying may add more things to
// the stack.
static void finish_front(frontier_t<`r> front, region_t<next_rgn<`r>> to_rgn
                         ; {`r,next_rgn<`r>}) __attribute__((consume(1))) {
  // check for empty frontier
  if (front == NULL) return;
  // iterate until stack is empty
  while (0 != front->next) {
    // pop an element
    front->next = (front->next - 1) % numelts(front->stack);
    let Front{copy,from,to_ptr} = front->stack[front->next];
    // forward it, getting a new frontier
    let $(new_front,to) = copy(front, to_rgn, from);
    front = new_front;
    // plug in the to-space ptr
    *to_ptr = to;
  }
  // free up the frontier
  ufree(front->stack);
  ufree(front);
}

#endif

////////////////////////////////////////////////////////////////////  
// forward declarations for copy functions
//static $(frontier_t<`r>, exp_t<next_rgn<`r>>)
//  copy_exp(frontier_t<`r>,
//	   region_t<next_rgn<`r>> to_r, exp_t<`r> from_exp ;
//           {`r,next_rgn<`r>}) __attribute__((consume(1)));
static $(frontier_t<`r>, value_t<next_rgn<`r>>)
  copy_value(frontier_t<`r>,
              region_t<next_rgn<`r>> to_r, value_t<`r> from_obj ; 
              {`r,next_rgn<`r>}) __attribute__((consume(1)));
static $(frontier_t<`r>, env_t<next_rgn<`r>>)
  copy_env(frontier_t<`r>, 
           region_t<next_rgn<`r>> to_r, env_t<`r> from_env ;
           {`r,next_rgn<`r>}) __attribute__((consume(1))) ;
static $(frontier_t<`r>, stack_t<next_rgn<`r>>)
  copy_stack(frontier_t<`r>,
             region_t<next_rgn<`r>> to_r, stack_t<`r> from_stack; 
             {`r,next_rgn<`r>}) __attribute__((consume(1)));
static struct State<next_rgn<`r>> 
  copy_state(region_t<next_rgn<`r>> to_r, struct State<`r> from_state ;
             {`r,next_rgn<`r>});

// forward things from `r to next_rgn<`r>, given a handle for
// next_rgn<`r>.  We have to put in an explicit capability since
// I haven't hacked Cyclone to recognize that it should assume
// all types of region kind should be assumed in the capability.
//
// This works by creating the thing in the to-space (but setting all
// of its fields to NULL), setting the forwarding pointer to point
// to the new thing, then adding all of the from-space fields,
// along with their to-space counterparts' addresses to the 
// frontier (to be forwarded later).  

//static $(frontier_t<`r>, exp_t<next_rgn<`r>>)
//  copy_exp(frontier_t<`r> frontier,
//           region_t<next_rgn<`r>> to_r, exp_t<`r> from_exp ;
//           {`r,next_rgn<`r>}) __attribute__((consume(1))) {
//  switch (from_exp) {
//  case NULL: return $(frontier, NULL);
//  case &Exp{*f,*from_exp_}:
//    if (*f != NULL) return $(frontier,*f);
//    switch (from_exp_) {
//    case &Var_e(x,d,off):
//      let to_exp as &Exp{_,Var_e(_,_,_)} =
//	rnew(to_r) Exp{NULL, Var_e(x,d,off)};
//      *f = to_exp;
//      return $(frontier, to_exp);
//    case &Const_e(from_const):
//      let to_exp as &Exp{_,Const_e(*vp)} = rnew(to_r) Exp{NULL, Const_e(NULL)};
//      frontier = add_front(frontier, copy_value, from_const, vp);
//      *f = to_exp;
//      return $(frontier, to_exp);
//    case &Apply_e(from_es):
//      let to_es = rnew(to_r) {for i < numelts(from_es) : NULL};
//      let to_exp as &Exp{_,Apply_e(_)} =
//	rnew (to_r) Exp{NULL, Apply_e(to_es)};
//      *f = to_exp;
//      for (unsigned i = 0; i < numelts(from_es); i++) 
//	frontier = add_front(frontier, copy_exp, from_es[i],
//			     (exp_t<_>@)(&to_es[i]));
//      return $(frontier, to_exp);
//    case &Lambda_e(from_xs,from_exp):
//      let to_xs = rnew(to_r) {for i < numelts(from_xs) : from_xs[i]};
//      let to_exp as &Exp{_,Lambda_e(_,*to_expp)} =
//	rnew (to_r) Exp{NULL, Lambda_e(to_xs,NULL)};
//      *f = to_exp;
//      frontier = add_front(frontier, copy_exp, from_exp, to_expp);
//      return $(frontier, to_exp);
//    case &VarArgsLambda_e(from_xs,rest,from_exp):
//      let to_xs = rnew(to_r) {for i < numelts(from_xs) : from_xs[i]};
//      let to_exp as &Exp{_,VarArgsLambda_e(_,_,*to_expp)} =
//	rnew (to_r) Exp{NULL, VarArgsLambda_e(to_xs,rest,NULL)};
//      *f = to_exp;
//      frontier = add_front(frontier, copy_exp, from_exp, to_expp);
//      return $(frontier, to_exp);
//    case &If_e(from_exp1,from_exp2,from_exp3):
//      let to_exp as &Exp{_,If_e(*to_exp1p,*to_exp2p,*to_exp3p)} =
//	rnew (to_r) Exp{NULL, If_e(NULL,NULL,NULL)};
//      *f = to_exp;
//      frontier = add_front(frontier, copy_exp, from_exp1, to_exp1p);
//      frontier = add_front(frontier, copy_exp, from_exp2, to_exp2p);
//      frontier = add_front(frontier, copy_exp, from_exp3, to_exp3p);
//      return $(frontier, to_exp);
//    case &Set_e(x,d,off,from_exp):
//      let to_exp as &Exp{_,Set_e(_,_,_,*to_expp)} =
//	rnew (to_r) Exp{NULL, Set_e(x,d,off,NULL)};
//      *f = to_exp;
//      frontier = add_front(frontier, copy_exp, from_exp, to_expp);
//      return $(frontier, to_exp);
//    }
//  }
//}

/**open: frags/pp-copy_value.tex*/
static $(frontier_t<`r>, value_t<next_rgn<`r>>)
  /**+hide*/
  copy_value(frontier_t<`r> frontier, 
             region_t<next_rgn<`r>> to_r, 
	     value_t<`r> from_obj ; 
              {`r,next_rgn<`r>}) __attribute__((consume(1))) {
  /**+alt
  copy_value(frontier_t<`r> frontier, 
             region_t<next_rgn<`r>> to_r, 
             value_t<`r> from_obj) {
  /**-alt*/
  /**-hide*/
  switch (from_obj) {
  case NULL: return $(frontier, NULL);
  case &Value{*f,*from_obj_}: 
    // if a forwarding pointer is installed,
    //  return it and an unmodified frontier.
    if (*f != NULL) return $(frontier,*f);
    switch (from_obj_) {
    /**+hide*/
    case &Const_v(from_const): 
      let to_obj as &Value{_,Const_v(_)} =
	rnew(to_r) Value{NULL, Const_v(copy_constant(to_r, from_const))};
      *f = to_obj;
      return $(frontier, to_obj);
    case &Primop_v(p): 
      let to_obj as &Value{_,Primop_v(_)} =
	rnew(to_r) Value{NULL, Primop_v(p<>)};
      *f = to_obj;
      return $(frontier, to_obj);
    case &Throw_v(from_stack,from_env): 
      let to_obj as &Value{_,Throw_v(*to_stackp,*to_envp)} = 
	rnew(to_r) Value{NULL, Throw_v(NULL,NULL)};
      *f = to_obj;
      frontier = add_front(frontier,copy_stack,from_stack,to_stackp);
      frontier = add_front(frontier,copy_env,from_env,to_envp);
      return $(frontier, to_obj);
    /**-hide*/
    case &Closure_v(n,from_env,from_exp):
      // allocate a new Closure in to-space,
      //  extracting the addresses of child pointers
      let to_obj as
	&Value{_,Closure_v(_,*to_envp,_)} = 
	rnew(to_r) Value{NULL,Closure_v(n,NULL,from_exp)};
      // install the forwarding pointer
      *f = to_obj;
      // add children to the frontier
      frontier = add_front(frontier,copy_env,
			   from_env,to_envp);
//      frontier = add_front(frontier,copy_exp,
//			   from_exp,to_expp);
      // return new frontier and pointer
      return $(frontier, to_obj);
    /**+hide*/
    case &VarArgsClosure_v(m,from_env,from_exp):
      let to_obj as &Value{_, VarArgsClosure_v(_,*to_envp,_)} =
	rnew(to_r) Value{NULL, VarArgsClosure_v(m,NULL,from_exp)};
      *f = to_obj;
      frontier = add_front(frontier,copy_env,from_env,to_envp);
//      frontier = add_front(frontier,copy_exp,from_exp,to_expp);
      return $(frontier, to_obj);
    /**-hide*/
    case &Pair_v(from_obj1,from_obj2):
      // allocate a new Pair in to-space,
      //  extracting the addresses of child pointers
      let to_obj as
	&Value{_,Pair_v(*to_obj1p,*to_obj2p)} = 
	rnew(to_r) Value{NULL,Pair_v(NULL,NULL)};
      // install the forwarding pointer
      *f = to_obj;
      // add children to the frontier
      frontier = add_front(frontier,copy_value,
			   from_obj1,to_obj1p);
      frontier = add_front(frontier,copy_value,
			   from_obj2,to_obj2p);
      // return new frontier and pointer
      return $(frontier,to_obj);
    /**+hide*/
    case &Vector_v(from_objs):
      unsigned n = numelts(from_objs);
      let to_objs = rnew(to_r) {for i < n : NULL};
      let to_obj as &Value{_,Vector_v(_)} = 
	rnew(to_r) Value{NULL, Vector_v(to_objs)};
      *f = to_obj;
      for (unsigned i = 0; i < n; i++) 
	frontier = add_front(frontier,copy_value,from_objs[i],
			     (value_t<_>@)(&to_objs[i]));
      return $(frontier, to_obj);
    /**-hide*/
    /**+hide*/
    /**+alt
    ...
    /**-alt*/
    /**-hide*/
    /**+hide*/
    case &String_v(s):
      let to_obj as &Value{_,String_v(_)} = 
	rnew(to_r) Value{NULL, String_v(rstrdup(to_r,s))};
      *f = to_obj;
      return $(frontier, to_obj);
    case &Primop_cons_v: 
      let to_obj as &Value{_,Primop_cons_v} =
	rnew(to_r) Value{NULL, Primop_cons_v};
      *f = to_obj;
      return $(frontier, to_obj);
    case &Primop_car_v: 
      let to_obj as &Value{_,Primop_car_v} =
	rnew(to_r) Value{NULL, Primop_car_v};
      *f = to_obj;
      return $(frontier, to_obj);
    case &Primop_cdr_v: 
      let to_obj as &Value{_,Primop_cdr_v} =
	rnew(to_r) Value{NULL, Primop_cdr_v};
      *f = to_obj;
      return $(frontier, to_obj);
    case &Primop_eq_p_v: 
      let to_obj as &Value{_,Primop_eq_p_v} =
	rnew(to_r) Value{NULL, Primop_eq_p_v};
      *f = to_obj;
      return $(frontier, to_obj);
    case &Primop_null_p_v: 
      let to_obj as &Value{_,Primop_null_p_v} =
	rnew(to_r) Value{NULL, Primop_null_p_v};
      *f = to_obj;
      return $(frontier, to_obj);
    /**-hide*/
    }
  }
}
/**close*/

// forward an environment
static $(frontier_t<`r>, env_t<next_rgn<`r>>)
  copy_env(frontier_t<`r> frontier,
           region_t<next_rgn<`r>> to_r, env_t<`r> from_env; 
           {`r,next_rgn<`r>}) __attribute__((consume(1))) {
  if (from_env == NULL) return $(frontier,NULL);
  if (from_env->forward != NULL) return $(frontier,from_env->forward);
  unsigned n = numelts(from_env->values);
  let to_values = rnew(to_r) {for i < n : NULL};
  let to_env = rnew(to_r) Env{NULL,NULL,to_values};
  from_env->forward = to_env;
  frontier = add_front(frontier,copy_env,from_env->next,&to_env->next);
  for (unsigned i = 0; i < n; i++) 
    frontier = add_front(frontier,copy_value,from_env->values[i],
                         (value_t<_>@)(&to_values[i]));
  return $(frontier,to_env);
}

// forward a stack (and anything reachable)
static $(frontier_t<`r>, stack_t<next_rgn<`r>>)
  copy_stack(frontier_t<`r> frontier,
             region_t<next_rgn<`r>> to_r, stack_t<`r> from_stack; 
             {`r,next_rgn<`r>}) __attribute__((consume(1))) {
  if (from_stack == NULL) return $(frontier, NULL);
  if (from_stack->forward != NULL) return $(frontier, from_stack->forward);
  let to_stack = 
    rnew(to_r)Stack{NULL, from_stack->shared, 
		    NULL, NULL, Frame{.set_frame = $(0,0)}};
  from_stack->forward = to_stack;
  frontier = add_front(frontier,copy_stack,from_stack->next,&to_stack->next);
  frontier = add_front(frontier,copy_env,from_stack->env,&to_stack->env);
  switch (from_stack->frame) {
  case {.if_frame = from_es}:
    let to_es = rnew(to_r) {from_es[0], from_es[1]};
    to_stack->frame = Frame{.if_frame = to_es};
//    frontier = add_front(frontier, copy_exp, from_es[0], 
//			 (exp_t<_>@)(&to_es[0]));
//    frontier = add_front(frontier, copy_exp, from_es[1], 
//			 (exp_t<_>@)(&to_es[1]));
    break;
  case {.apply_frame = $(from_es,i,from_vs)}:
    let to_es = rnew(to_r) {for i < numelts(from_es) : from_es[i]};
    let to_vs = rnew(to_r) {for i < numelts(from_vs) : NULL};
    to_stack->frame = Frame{.apply_frame = $(to_es,i,to_vs)};
    // Don't need evaluated expressions.
//    for (unsigned j = i; j < numelts(from_es); j++) 
//      frontier = add_front(frontier, copy_exp, from_es[j], 
//                           (exp_t<_>@)(&to_es[j]));
    // Don't need unevaluated values.
    for (unsigned j = 0; j <= i; j++) 
      frontier = add_front(frontier, copy_value, from_vs[j], 
                           (value_t<_>@)(&to_vs[j]));
    break;
  case {.set_frame = $(d,off)}:
    to_stack->frame = Frame{.set_frame = $(d,off)};
    break;
  }
  return $(frontier, to_stack);
}
// copy the machine state (stack, environment, and current result)
// from from-space to to-space.
static struct State<next_rgn<`r>> 
  copy_state(region_t<next_rgn<`r>> to_r, struct State<`r> from_state ;
             {`r,next_rgn<`r>}) {
  frontier_t<`r> frontier = NULL;
  // copy the stack
  let $(front2,to_stack) = copy_stack(frontier,to_r,from_state.stack);
  frontier = front2;
  // copy the environment
  let $(front3,to_env) = copy_env(frontier,to_r,from_state.env);
  frontier = front3;
  // copy the environment
  let $(front4,to_top_env) = copy_env(frontier,to_r,from_state.top_env);
  frontier = front4;
  // copy true and false
  let $(front5,to_true) = copy_value(frontier,to_r,from_state.true_v);
  frontier = front5;
  let $(front5,to_false) = copy_value(frontier,to_r,from_state.false_v);
  frontier = front5;
  // copy the result
  result_t<next_rgn<`r>> to_result;
  switch (from_state.result) {
  case {.expr = e}: 
  //    let $(front4,to_e) = copy_exp(frontier,to_r,e);
  //    frontier = front4;
    to_result = Result{.expr = e};
    break;
  case {.value = v}: 
    let $(front4,to_v) = copy_value(frontier,to_r,v);
    frontier = front4;
    to_result = Result{.value = to_v};
    break;
  }
  // finish off the frontier
  finish_front(frontier,to_r);
  return State{to_stack, to_env, to_result, to_top_env, NULL, to_true, to_false};
}

/**open: frags/pp-doGC.tex*/
gcstate_t doGC(gcstate_t gcs) {
  /**+hide*/
  if (gc_messages)
    fprintf(stderr,"major gc...");
  /**-hide*/
  // unpack the gc state, naming the existentially bound region (`r)
  let GCState{<`r> DynamicRegionSeq {from_key, from_gen}, from_state} = gcs;
  // generate the to-space (next_rgn<`r>)
  let DynamicRegionSeq{to_key, to_gen} = next_drseq(from_gen);
  state_t<next_rgn<`r>> to_state;
  // open the from-space's key
  { region from_r = open(from_key);
    /**+hide*/
    if (gc_messages) {
      int used = region_used_bytes(from_r);
      int free = region_free_bytes(from_r);
      int alloc = region_alloc_bytes(from_r);
      int wasted = used - free - alloc;
      fprintf(stderr,"\n  from-space(used): %d bytes...",used);
      fprintf(stderr,"\n  from-space(free): %d bytes...",free);
      fprintf(stderr,"\n  from-space(alloc): %d bytes...",alloc);
      fprintf(stderr,"\n  from-space(wasted): %d bytes...",wasted);
    }
    /**-hide*/
    // open the to-space's key
    { region to_r = open(to_key); 
      // copy the state and reachable data
      to_state = copy_state(to_r, from_state);
      /**+hide*/
      int new_limit = (int)(LIVE_RATIO * (region_alloc_bytes(to_r)));
      if(new_limit > heap_limit) {
	heap_limit = new_limit;
      }
      /**-hide*/
      /**+hide*/
      if (gc_messages) {
	int used = region_used_bytes(to_r);
	int free = region_free_bytes(to_r);
	int alloc = region_alloc_bytes(to_r);
	int wasted = used - free - alloc;
	fprintf(stderr,"\n  to-space(used): %d bytes...",used);
	fprintf(stderr,"\n  to-space(free): %d bytes...",free);
	fprintf(stderr,"\n  to-space(alloc): %d bytes...",alloc);
	fprintf(stderr,"\n  to-space(wasted): %d bytes...",wasted);
	fprintf(stderr,"\n  to-space(limit): %d bytes...",heap_limit);
      }
      /**-hide*/
    }
    // pack the new gc state
    gcs = GCState{DynamicRegionSeq{to_key, to_gen}, to_state};
  }
  // free the from-space and return the new gc state
  free_ukey(from_key); 
  /**+hide*/
  if (gc_messages)
    fprintf(stderr,"done.\n");
  /**-hide*/
  return gcs;
}
/**close*/

gcstate_t maybeGC(gcstate_t gcs) {
  bool needGC = false;
  let GCState{<`r> DynamicRegionSeq {key, gen}, state} = gcs;
  { region r = open(key);
    needGC = region_alloc_bytes(r) > heap_limit;
  }
  gcs = GCState{DynamicRegionSeq {key, gen}, state};
  if (needGC)
      gcs = doGC(gcs);
  return gcs;
}
}
#include <stdio.h>
#include <arg.h>
using Core {
using Arg;
using List;

using Scheme;
using Scheme::Flags;

extern exp_t prog();

static void nop(string_t<`H> s) {
}
static bool false_ff(string_t<`H> s) {
  return false;
}
extern void set_default_region_page_size(int);
static void set_page_size(int s) {
 set_default_region_page_size(s);
}

int main(int argc, string_t<`H> ?`H argv) {
  set_default_region_page_size(1<<16);
  region r; {
    Arg::speclist_t<`r,`r> options =
      rlist(r,
	    rnew(r)$("--gc-messages",false,"",
		     rnew(r) Set_spec(&gc_messages),
		     "Run with gc messages"),
	    rnew(r)$("--verbose",false,"",
		     rnew(r) Set_spec(&verbose),
		     "Run in verbose mode"),
	    rnew(r)$("--nil-is-false",false,"",
		     rnew(r) Set_spec(&nil_is_false),
		     "Treat nil as false"),
	    rnew(r)$("--region-page-size",false,"",
		     rnew(r) Int_spec(set_page_size),
		     "Set region page size"),
	    rnew(r)$("--trace-prims",false,"",
		     rnew(r) Set_spec(&trace_prims),
		     "Trace prims"));
    parse(options,nop,false_ff,argv[0],argv);
  }

  scheme(prog);
  return 0;
}
}
using Core {
using Scheme;
using Scheme::PrimOps;

namespace Scheme;
namespace PrettyPrint;

int pp_indent = 2;

bool pp_with_deb_idx = true;
bool pp_with_lets = true;

static void nl(FILE @fp,int indent) {
  fputc('\n',fp);
  while(indent--) {
    fputc(' ',fp);
  }
}

void pp_var(FILE @fp, const char? x, int depth, int offset) {
  if(pp_with_deb_idx) {
    fprintf(fp,"%s<%d,%d>",x,depth,offset);
  } else {
    fprintf(fp,"%s",x);
  }
}

bool try_let(FILE @fp,int indent,exp_t<`r> ?`r es) {
  if(pp_with_lets && (numelts(es) > 0)) {
    switch (es[0]) {
    case &ExpP(*es0_):
      switch (es0_) {
      case &Lambda_e(args,body) && (numelts(args) == (numelts(es) - 1)):
	fprintf(fp,"(let (");
	for(int i = 0; i < numelts(args); i++) {
	  fprintf(fp,"(%s ",args[i]);
	  pp_exp(fp,indent+pp_indent,es[i+1]);
	  fprintf(fp,")");
	  if(i + 1 < numelts(args)) {
	    fprintf(fp," ");
	  }
	}
	fprintf(fp,")");
	nl(fp,indent+pp_indent);
	switch(body) {
	case &ExpP(*body_):
	  switch (body_) {
	  case &Apply_e(es):
	    if(try_let(fp,indent,es)) {
	      fprintf(fp,")");
	      return true;
	    }
	    break;
	  default: ; //  nop
	  }
	  break;
	default: ; //  nop
	}
	pp_exp(fp,indent+pp_indent,body);
	fprintf(fp,")");
	return true;
      default: return false;
      }
      break;
    default: return false;
    }
  }
  return false;
}

void pp_const(FILE @fp,int indent,const_t<`r> l) {
  switch (l) {
  case &Bool_l(0):
    fprintf(fp,"#f");
    break;
  case &Bool_l(_):
    fprintf(fp,"#t");
    break;
  case &Char_l(c):
    fprintf(fp,"'%c'",c);
    break;
  case &Int_l(n):
    fprintf(fp,"%d",n);
    break;
  case &Real_l(x):
    fprintf(fp,"%lf",x);
    break;
  case &String_l(s):
    fprintf(fp,"\"%s\"",s);
    break;
  case &Symbol_l(s):
    fprintf(fp,"%s",*s);
    break;
  case &Undef_l:
    fprintf(fp,"##undefined##");
    break;
  case &Unspec_l:
    fprintf(fp,"##unspecified##");
    break;
  }
}

void pp_value(FILE @fp,int indent,value_t<`r> o);

void pp_exp(FILE @fp,int indent,exp_t<`r> e) {
  switch (e) {
  case NULL: break;
  case &ExpP(*e_):
    switch (e_) {
    case &Var_e(x,depth,offset):
      pp_var(fp,x,depth,offset);
      break;
    case &Const_e(v):
      pp_value(fp,indent,v);
      break;
    case &Apply_e(es):
      if(!try_let(fp,indent,es)) {
	fprintf(fp,"(");
	for (unsigned i = 0; i < numelts(es); i++) {
	  pp_exp(fp,indent,es[i]);
	  if(i+1 < numelts(es)) {
	    if(numelts(es) < 3) {
	      fprintf(fp," ");
	    } else {
	      nl(fp,(indent+pp_indent));
	    }
	  }
	}
	fprintf(fp,")");
      }
      break;
    case &Lambda_e(args,body):
      fprintf(fp,"(lambda (");
      for (unsigned i = 0; i < numelts(args); i++) {
	if(i+1 < numelts(args)) {
	  fprintf(fp,"%s ",args[i]);
	} else {
	  fprintf(fp,"%s",args[i]);
	}
      }
      fprintf(fp,") ");
      indent += 8 + pp_indent;
      nl(fp,indent);
      pp_exp(fp,indent,body);
      fprintf(fp,")");
      break;
    case &VarArgsLambda_e(args,rest,body):
      if(numelts(args) == 0) {
	fprintf(fp,"(lambda %s",rest);
      } else {
	fprintf(fp,"(lambda (");
	for (unsigned i = 0; i < numelts(args); i++) {
	  if(i+1 < numelts(args)) {
	    fprintf(fp,"%s ",args[i]);
	  } else {
	    fprintf(fp,"%s",args[i]);
	  }
	}
	fprintf(fp," . %s)",rest);
      }
      indent += 8 + pp_indent;
      nl(fp,indent);
      pp_exp(fp,indent,body);
      fprintf(fp,")");
      break;
    case &If_e(e1,e2,e3):
      fprintf(fp,"(if ");
      pp_exp(fp,indent,e1);
      fprintf(fp," ");
      indent += pp_indent;
      nl(fp,indent);
      pp_exp(fp,indent,e2);
      nl(fp,indent);
      pp_exp(fp,indent,e3);
      fprintf(fp,")");
      break;
    case &Set_e(x,depth,offset,e):
      fprintf(fp,"(set! ");
      pp_var(fp,x,depth,offset);
      fprintf(fp," ");
      pp_exp(fp,indent+pp_indent,e);
      fprintf(fp,")");
      break;
    }
    break;
  }
}

void pp_value(FILE @fp,int indent,value_t<`r> o) {
  switch (o) {
  case NULL:
    fprintf(fp,"'()");
    break;
  case &ValueP(*o_):
    switch (o_) {
    case &Closure_v(_,_,_):
      fprintf(fp,"<##closure##>");
      break;
    case &Const_v(l):
      pp_const(fp,indent,l);
      break;
    case &Pair_v(v1,v2):
      fprintf(fp,"<##cons##>");
      break;
    case &Primop_v(p):
      fprintf(fp,"<##primop:%s##>",prim_name(p<>));
      break;
    case &String_v(s):
      fprintf(fp,"\"%s\"",s);
      break;
    case &Throw_v(_,_):
      fprintf(fp,"<##throw##>");
      break;
    case &VarArgsClosure_v(_,_,_):
      fprintf(fp,"<##closure##>");
      break;
    case &Vector_v(_):
      fprintf(fp,"<##vector##>");
      break;
    case &Primop_cons_v:
      fprintf(fp,"<##primop:cons##>");
      break;
    case &Primop_car_v:
      fprintf(fp,"<##primop:car##>");
      break;
    case &Primop_cdr_v:
      fprintf(fp,"<##primop:cdr##>");
      break;
    case &Primop_null_p_v:
      fprintf(fp,"<##primop:null?##>");
      break;
    case &Primop_eq_p_v:
      fprintf(fp,"<##primop:eq?##>");
      break;
    }
    break;
  }
}

void pp_env(FILE @fp,int indent,env_t<`r> e) {
  fprintf(fp,"<##env##>");
}

void pp_frame(FILE @fp,int indent,frame_t<`r> f) {
  switch (f) {
  case {.if_frame = es}:
    fprintf(fp,"(if [] ");
    indent += 4;
    nl(fp,indent);
    pp_exp(fp,indent,es[0]);
    nl(fp,indent);
    pp_exp(fp,indent,es[1]);
    fprintf(fp,")");
    break;
  case {.apply_frame = $(es,i,vs)}:
    fprintf(fp,"(");
    indent +=1;
    for (unsigned j = 0; j < i; j++) {
      pp_value(fp,indent,vs[j]);
      nl(fp,indent);
    }
    fprintf(fp,"[] ");
    for (unsigned j = i + 1; j < numelts(es); j++) {
      nl(fp,indent);
      pp_exp(fp,indent,es[j]);
    }
    fprintf(fp,")");
    break;
  case {.set_frame = $(d,off)}:
    fprintf(fp,"(set! ");
    pp_var(fp,"",d,off);
    fprintf(fp, " [])");
    break;
  }
}

void pp_stack(FILE @fp,int indent,stack_t<`r> s) {
  if (s == NULL) return;
  /*
  let StackP(shared,next,env,frame) = *s;
  pp_frame(fp,indent,frame);
  nl(fp,indent);
  pp_env(fp,indent,env);
  nl(fp,indent);
  pp_stack(fp,indent,next);
  */
}

void pp_result(FILE @fp,int indent,result_t<`r> r) {
  switch (r) {
  case {.value = v}: pp_value(fp,indent,v); break;
  case {.expr = e}: pp_exp(fp,indent,e); break;
  }
}

void pp_state(FILE @fp,int indent,state_ptr_t<`r> s) {
  pp_stack(fp,indent,s->stack);
  pp_env(fp,indent,s->env);
  pp_result(fp,indent,s->result);
}
}
#include <math.h>
#include <sys/time.h>

using Core {
using Scheme;
using Scheme::Flags;
using Scheme::PrettyPrint;
namespace Scheme;
namespace PrimOps;

//////////////////////////////////////////////////////////////////////
// primops
//////////////////////////////////////////////////////////////////////

@tagged union Number {
  int integer;
  double real;
};
typedef union Number num_t;

// BUG: need to jump through these functions
//      because control flow is doing the
//      wrong thing with unions at join points.
num_t mknum_integer(int i) {
  return Number{.integer = i};
}
num_t mknum_real(double x) {
  return Number{.real = x};
}



//////////////////////////////////////////////////////////////////////
// Forward declarations
//////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////
// Equivalence predicates
//////////////////////////////////////////////////////////////////////

PRIM(eqv_p) {
  ARGCHECK(2);
  switch $(args[0],args[1]) {
  case $(NULL,NULL): RETURN(TRUE);
  case $(&ValueP(*arg0_),&ValueP(*arg1_)):
    switch $(arg0_,arg1_) {
    case $(&Const_v(&Bool_l(b1)),&Const_v(&Bool_l(b2))):
      RETURN(BOOL(b1 == b2));
    case $(&Const_v(&Char_l(c1)),&Const_v(&Char_l(c2))):
      RETURN(BOOL(c1 == c2));
    case $(&Const_v(&Int_l(x1)),&Const_v(&Int_l(x2))):
      RETURN(BOOL(x1 == x2));
    case $(&Const_v(&Int_l(x1)),&Const_v(&Real_l(x2))):
      RETURN(BOOL((double)x1 == x2));
    case $(&Const_v(&Symbol_l(s1)),&Const_v(&Symbol_l(s2))):
      RETURN(BOOL(s1 == s2));
    case $(&Const_v(&String_l(s1)),&Const_v(&String_l(s2))):
      RETURN(BOOL(s1 == s2));
    case $(&Const_v(&Real_l(x1)),&Const_v(&Int_l(x2))):
      RETURN(BOOL(x1 == (double)x2));
    case $(&Const_v(&Real_l(x1)),&Const_v(&Real_l(x2))):
      RETURN(BOOL(x1 == x2));
    case $(&Pair_v(_,_),&Pair_v(_,_)):
    case $(&Vector_v(_),&Vector_v(_)):
      RETURN(BOOL(args[0] == args[1]));
    case $(&Primop_v(_),&Primop_v(_)):
    case $(&VarArgsClosure_v(_,_,_),&VarArgsClosure_v(_,_,_)):
    case $(&Closure_v(_,_,_),&Closure_v(_,_,_)):
    case $(&Throw_v(_,_),&Throw_v(_,_)):
      RETURN(BOOL(args[0] == args[1]));
    default: RETURN(FALSE);
    }
  default: RETURN(FALSE);
  }
}

PRIM(eq_p) {
  ARGCHECK(2);
  if (args[0] == args[1]) {
    RETURN(TRUE);
  } else {
    switch $(args[0],args[1]) {
    case $(NULL,NULL): RETURN(TRUE);
    case $(&ValueP(*arg0_),&ValueP(*arg1_)):
      switch (arg0_) {
      case &Const_v(&Symbol_l(s1)):
	switch(arg1_) {
	case &Const_v(&Symbol_l(s2)):
	  RETURN(BOOL(s1 == s2));
	default: RETURN(FALSE);
	}
      case &Const_v(&Bool_l(b1)):
	switch(arg1_) {
	case &Const_v(&Bool_l(b2)):
	  RETURN(BOOL(b1 == b2));
	default: RETURN(FALSE);
	}
      default: RETURN(FALSE);
      }
    default: RETURN(FALSE);
    }
  }
}

//////////////////////////////////////////////////////////////////////
// Number
//////////////////////////////////////////////////////////////////////

PRIM(number_p) { ARGCHECK(1); PREDICATE2(&Const_v(&Int_l(_)),
					 &Const_v(&Real_l(_))); }


PRIM(integer_p) {
  ARGCHECK(1);
  PREDICATE2WITH(&Const_v(&Int_l(_)), RETURN(TRUE),
		 &Const_v(&Real_l(x)), {int y = (int)x; RETURN(BOOL(x == (double)y))})
}


PRIM(real_p) { ARGCHECK(1); PREDICATE2(&Const_v(&Int_l(_)),
				       &Const_v(&Real_l(_))); }

#define NUMBER_COMP(p,cmp) \
   PRIM(number_##p) { \
     ANYARGCHECK; \
     if (nelts == 0) { \
       RETURN(TRUE); \
     } else { \
       LETNUM(last,args[0]); \
       for (unsigned i = 1; i < nelts; i++) { \
         LETNUM(n,args[i]); \
         bool b; \
         switch $(last,n) { \
	 case $({.integer = last_n}, \
                {.integer = n_n}) : b = (last_n cmp n_n); break; \
	 case $({.integer = last_n}, \
                {.real = n_n}) : b = ((double)last_n cmp n_n); break; \
	 case $({.real = last_n}, \
                {.integer = n_n}) : b = (last_n cmp (double)n_n); break; \
	 case $({.real = last_n}, \
                {.real = n_n}) : b = (last_n cmp n_n); break; \
         } \
         if (b) last = n; \
         else { RETURN(FALSE); } \
       } \
       RETURN(TRUE); \
     } \
   }

NUMBER_COMP(eq, ==)
NUMBER_COMP(lt, <)
NUMBER_COMP(lte, <=)
NUMBER_COMP(gt, >)
NUMBER_COMP(gte, >=)

PRIM(plus) {
  ANYARGCHECK;
  num_t sum = mknum_integer(0); // Number{.integer = 0};
  for (unsigned i = 0; i < nelts; i++) {
    LETNUM(n,args[i]);
    switch $(sum,n) {
    case $({.integer = sum_n},{.integer = n_n}):
      sum.integer = sum_n + n_n;
      break;
    case $({.integer = sum_n},{.real = n_n}):
      sum.real = (double)sum_n + n_n;
      break;
    case $({.real = sum_n},{.integer = n_n}):
      sum.real = sum_n + (double)n_n;
      break;
    case $({.real = sum_n},{.real = n_n}):
      sum.real = sum_n + n_n;
      break;
    }
  }
  switch sum {
  case {.integer = i}: RETURN(INT(i));
  case {.real = x}: RETURN(REAL(x));
  }
}

PRIM(times) {
  ANYARGCHECK;
  num_t prod = mknum_integer(1); // Number{.integer = 1};
  for (unsigned i = 0; i < nelts; i++) {
    LETNUM(n,args[i]);
    switch $(prod,n) {
    case $({.integer = prod_n},{.integer = n_n}):
      prod.integer = prod_n * n_n;
      break;
    case $({.integer = prod_n},{.real = n_n}):
      prod.real = (double)prod_n * n_n;
      break;
    case $({.real = prod_n},{.integer = n_n}):
      prod.real = prod_n * (double)n_n;
      break;
    case $({.real = prod_n},{.real = n_n}):
      prod.real = prod_n * n_n;
      break;
    }
  }
  switch prod {
  case {.integer = i}: RETURN(INT(i));
  case {.real = x}: RETURN(REAL(x));
  }
}

PRIM(minus) {
  ARGRANGECHECK(1,-1);
  if (nelts == 1) {
    LETNUM(n,args[0]);
    switch n {
    case {.integer = i}: RETURN(INT(-i));
    case {.real = x}: RETURN(REAL(-x));
    }
  } else {
    LETNUM(diff,args[0]);
    for (unsigned i = 1; i < nelts; i++) {
      LETNUM(n,args[i]);
      switch $(diff,n) {
      case $({.integer = diff_n},{.integer = n_n}):
	diff.integer = diff_n - n_n;
	break;
      case $({.integer = diff_n},{.real = n_n}):
	diff.real = (double)diff_n - n_n;
	break;
      case $({.real = diff_n},{.integer = n_n}):
	diff.real = diff_n - (double)n_n;
	break;
      case $({.real = diff_n},{.real = n_n}):
	diff.real = diff_n - n_n;
	break;
      }
    }
    switch diff {
    case {.integer = i}: RETURN(INT(i));
    case {.real = x}: RETURN(REAL(x));
    }
  }
}

PRIM(divide) {
  ARGRANGECHECK(1,-1);
  if (nelts == 1) {
    LETNUM(n,args[0]);
    switch n {
    case {.integer = i}: RETURN(INT(-i));
    case {.real = x}: RETURN(REAL(-x));
    }
  } else {
    LETNUM(quot,args[0]);
    for (unsigned i = 1; i < nelts; i++) {
      LETNUM(n,args[i]);
      switch $(quot,n) {
      case $({.integer = quot_n},{.integer = n_n}):
	if (quot_n % n_n == 0)
	  quot.integer = quot_n / n_n;
	else
	  quot.real = (double)quot_n / (double)n_n;
	break;
      case $({.integer = quot_n},{.real = n_n}):
	quot.real = (double)quot_n - n_n;
	break;
      case $({.real = quot_n},{.integer = n_n}):
	quot.real = quot_n - (double)n_n;
	break;
      case $({.real = quot_n},{.real = n_n}):
	quot.real = quot_n - n_n;
	break;
      }
    }
    switch quot {
    case {.integer = i}: RETURN(INT(i));
    case {.real = x}: RETURN(REAL(x));
    }
  }
}

//////////////////////////////////////////////////////////////////////
// Integer
//////////////////////////////////////////////////////////////////////

PRIM(quotient) {
  ARGCHECK(2);
  LETINT(x,args[0]);
  LETINT(y,args[1]);
  RETURN(INT(x / y));
}

PRIM(remainder) {
  ARGCHECK(2);
  LETINT(x,args[0]);
  LETINT(y,args[1]);
  RETURN(INT(x - ((x / y) * y)));
}

PRIM(modulo) {
  ARGCHECK(2);
  LETINT(x,args[0]);
  LETINT(y,args[1]);
  RETURN(INT(x % y));
}

//////////////////////////////////////////////////////////////////////
// Real
//////////////////////////////////////////////////////////////////////

PRIM(exact_p) { ARGCHECK(1); PREDICATE1(&Const_v(&Int_l(_))); }
PRIM(inexact_p) { ARGCHECK(1); PREDICATE1(&Const_v(&Real_l(_))); }

#define MATHROUND(fn) \
  PRIM(fn##Fn) { \
    ARGCHECK(1); \
    LETNUM(n,args[0]); \
    switch (n) { \
    case {.integer = i}: RETURN(INT(i)); \
    case {.real = x}: RETURN(REAL(fn(x))); \
    } \
  }

MATHROUND(floor);
MATHROUND(ceil);
extern "C" double trunc(double);
MATHROUND(trunc);
extern "C" double round(double);
MATHROUND(round);
extern "C" int gettimeofday(struct timeval *tv,struct timezone *tz);
#define MATH(fn) \
  PRIM(fn##Fn) { \
    ARGCHECK(1); \
    LETREAL(x,args[0]); \
    RETURN(REAL(fn(x))); \
  }

#define MATH2(fn) \
  PRIM(fn##Fn) { \
    ARGCHECK(2); \
    LETREAL(x,args[0]); \
    LETREAL(y,args[1]); \
    RETURN(REAL(fn(x,y))); \
  }

MATH(exp);
MATH(log);
MATH(sin);
MATH(cos);
MATH(tan);
MATH(asin);
MATH(acos);

PRIM(atanFn) {
  ARGRANGECHECK(1,2);
  if (nelts == 1) {
    LETREAL(x,args[0]);
    RETURN(REAL(atan(x)));
  } else {
    LETREAL(x,args[0]);
    LETREAL(y,args[1]);
    RETURN(REAL(atan2(x,y)));
  }
}

MATH(sqrt);

PRIM(expt) {
  ARGCHECK(2);
  LETNUM(n,args[0]);
  LETNUM(m,args[1]);
  switch $(n,m) {
  case $({.integer = n_n}, {.integer = m_n}):
    if (m_n >= 0) {
      int k = 1;
      while (m_n > 0) {
	k = k * n_n;
	m_n--;
      }
      RETURN(INT(k));
    } else {
      RETURN(REAL(pow((double)n_n,(double)m_n)));
    };
  case $({.integer = n_n}, {.real = m_n}):
    RETURN(REAL(pow((double)n_n,m_n)));
  case $({.real = n_n}, {.integer = m_n}):
    RETURN(REAL(pow(n_n,(double)m_n)));
  case $({.real = n_n}, {.real = m_n}):
    RETURN(REAL(pow(n_n,m_n)));
  }
}

PRIM(exact_inexact) {
  ARGCHECK(1);
  LETINT(x,args[0]);
  RETURN(REAL((double)x));
}

PRIM(inexact_exact) {
  ARGCHECK(1);
  LETREAL(x,args[0]);
  int y = (int)x;
  if (x == (double)y) {
    RETURN(INT((int)x));
  } else
    ERROR("inexact number cannot be represented as an exact number");
}

//////////////////////////////////////////////////////////////////////
// Number
//////////////////////////////////////////////////////////////////////

PRIM(number_to_string) {
  ARGCHECK(1);
  LETNUM(n,args[0]);
  switch (n) {
  case {.integer = i}:
    RETURN(MSTR(rprintf(r,"%d",i)));
  case {.real = x}:
    RETURN(MSTR(rprintf(r,"%f",x)));
  };
}

//////////////////////////////////////////////////////////////////////
// Boolean
//////////////////////////////////////////////////////////////////////

PRIM(boolean_p) { ARGCHECK(1); PREDICATE1(&Const_v(&Bool_l(_))); }

//////////////////////////////////////////////////////////////////////
// Pairs and Lists
//////////////////////////////////////////////////////////////////////

PRIM(pair_p) { ARGCHECK(1); PREDICATE1(&Pair_v(_,_)); }

PRIM(cons) { ARGCHECK(2); RETURN(PAIR(args[0],args[1])) }

PRIM(car) { ARGCHECK(1); LETPAIR(hd,tl,args[0]); RETURN(hd); }
PRIM(cdr) { ARGCHECK(1); LETPAIR(hd,tl,args[0]); RETURN(tl); }

PRIM(null_p) {
  ARGCHECK(1);
  RETURN(BOOL(args[0] == NULL));
}

PRIM(setcar) {
  ARGCHECK(2);
  LETPAIRP(hd,tl,args[0]);
  *hd = args[1];
  RETURN(UNSPEC);
}

PRIM(setcdr) {
  ARGCHECK(2);
  LETPAIRP(hd,tl,args[0]);
  *tl = args[1];
  RETURN(UNSPEC);
}

//////////////////////////////////////////////////////////////////////
// Symbols
//////////////////////////////////////////////////////////////////////

PRIM(symbol_p) { ARGCHECK(1); PREDICATE1(&Const_v(&Symbol_l(_))); }

PRIM(symbol_to_string) {
  ARGCHECK(1);
  LETSYMBOL(s,args[0]);
  RETURN(STR(rstrdup(r,*s)));
}

PRIM(string_to_symbol) {
  ARGCHECK(1);
  LETSTRING(s,args[0]);
  stringptr_t<`H,`H> v =
    CoreSchemeAst::intern(new (new {for i < numelts(s): (char)tolower(s[i])}));
  RETURN(SYM(v));
}

//////////////////////////////////////////////////////////////////////
// Character operations
//////////////////////////////////////////////////////////////////////

PRIM(char_p) { ARGCHECK(1); PREDICATE1(&Const_v(&Char_l(_))); }

#define CHAR_COMP(p,cmp) \
   PRIM(char_##p) { \
     ANYARGCHECK; \
     if (nelts == 0) { \
       RETURN(TRUE); \
     } else { \
       LETCHAR(last,args[0]); \
       for (unsigned i = 1; i < nelts; i++) { \
         LETCHAR(x,args[i]); \
         if (last cmp x) { \
	   last = x; \
         } else { RETURN(FALSE); } \
       } \
       RETURN(TRUE); \
     } \
   }

CHAR_COMP(eq, ==)
CHAR_COMP(lt, <)
CHAR_COMP(lte, <=)
CHAR_COMP(gt, >)
CHAR_COMP(gte, >=)

PRIM(char_to_integer) {
  ARGCHECK(1);
  LETCHAR(c,args[0]);
  RETURN(INT((int)c));
}

PRIM(integer_to_char) {
  ARGCHECK(1);
  LETINT(i,args[0]);
  RETURN(CHAR((char)i));
}

//////////////////////////////////////////////////////////////////////
// String operations
//////////////////////////////////////////////////////////////////////

PRIM(string_p) { ARGCHECK(1); PREDICATE1(&String_v(_)); }

PRIM(make_string) {
  ARGRANGECHECK(1,2);
  LETINT(sz,args[0]);
  if(nelts == 1) {
    RETURN(MSTR(rnew(r) {for i < sz + 1: 0}));
  } else {
    LETCHAR(c,args[1]);
    RETURN(MSTR((rnew(r) {for i < sz + 1 : ((i == sz) ? 0 : c)})));
  }
}

PRIM(string) {
  ANYARGCHECK;
  char ?`r s = rnew(r) {for i < nelts + 1 : 0};
  for (unsigned i = 0; i < nelts ; i++) {
    LETCHAR(c,args[i]);
    s[i] = c;
  };
  RETURN(MSTR(s));
}

PRIM(string_length) {
  ARGCHECK(1);
  LETSTRING(s,args[0]);
  RETURN(INT(numelts(s) - 1));
}

PRIM(string_ref) {
  ARGCHECK(2);
  LETSTRING(s,args[0]);
  LETINT(idx,args[1]);
  if(idx < numelts(s) - 1) {
    RETURN(CHAR(s[idx]));
  };
  ERROR(aprintf("string-ref out of bounds len=%d idx=%d",numelts(s) - 1,idx));
}

PRIM(string_set) {
  ARGCHECK(3);
  LETMSTRING(s,args[0]);
  LETINT(idx,args[1]);
  LETCHAR(c,args[2]);
  if(idx < numelts(s) - 1) {
    s[idx] = c;
    RETURN(UNSPEC);
  };
  ERROR(aprintf("string-set! out of bounds len=%d idx=%d",numelts(s) - 1,idx));
}

//////////////////////////////////////////////////////////////////////
// Vector operations
//////////////////////////////////////////////////////////////////////

PRIM(vector_p) { ARGCHECK(1); PREDICATE1(&Vector_v(_)); }

PRIM(make_vector) {
  ARGRANGECHECK(1,2);
  LETINT(sz,args[0]);
  if(nelts == 1) {
    // RETURN(VEC(rnew(r) {for i < sz : UNSPEC}));
    let vs = rnew(r) {for i < sz : args[0]};
    for (unsigned i = 0; i < sz; i++) {
      let u = UNSPEC;
      vs[i] = u;
    }
    RETURN(VEC(vs));
  } else {
    RETURN(VEC(rnew(r) {for i < sz : args[1]}));
  }
}

PRIM(vector) {
  ANYARGCHECK;
  RETURN(VEC(rnew(r) {for i < nelts : args[i]}));
}

PRIM(vector_length) {
  ARGCHECK(1);
  LETVECTOR(v,args[0]);
  RETURN(INT(numelts(v)));
}

PRIM(vector_ref) {
  ARGCHECK(2);
  LETVECTOR(v,args[0]);
  LETINT(idx,args[1]);
  if(idx < numelts(v)) {
    RETURN(v[idx]);
  };
  ERROR(aprintf("vector-ref out of bounds len=%d idx=%d",numelts(v),idx));
}

PRIM(vector_set) {
  ARGCHECK(3);
  LETVECTOR(v,args[0]);
  LETINT(idx,args[1]);
  if(idx < numelts(v)) {
    v[idx] = args[2];
    RETURN(UNSPEC);
  };
  ERROR(aprintf("vector-set! out of bounds len=%d idx=%d",numelts(v),idx));
}

//////////////////////////////////////////////////////////////////////
// Control
//////////////////////////////////////////////////////////////////////

PRIM(procedure_p) {
  ARGCHECK(1);
  PREDICATE4(&Primop_v(_),
	     &Closure_v(_,_,_),
	     &VarArgsClosure_v(_,_,_),
	     &Throw_v(_,_));
}

PRIM(apply) {
  ARGRANGECHECK(2,-1);
  unsigned new_args_sz = nelts-1;
  value_t<`r> l = args[nelts-1];
  while(l) {
    LETPAIR(hd,tl,l);
    l = tl;
    new_args_sz++;
  }
  value_t<`r>?`r new_args =
    rnew(r) { for i < new_args_sz : NULL};
  new_args_sz--;
  unsigned i = 0;
  for ( ; i < nelts-1; i++)
    new_args[i] = args[i];
  l = args[nelts-1];
  while(l) {
    LETPAIR(hd,tl,l);
    new_args[i++] = hd;
    l = tl;
  }
  let frame = Frame{.apply_frame = $(rnew(r) {}, new_args_sz, new_args)};
  frame_push(r,state,frame);
  state->result = Result{.value=new_args[new_args_sz]};
}

// call-with-current-continuation
PRIM(callcc) {
  ARGCHECK(1);
  stack_t<`r> stack = state->stack;
  while (stack) {
    stack->shared = true;
    stack = stack->next;
  }
  let cont = rnew(r) ValueC(Throw_v(state->stack,state->env));
  let frame = Frame{.apply_frame = $(rnew(r) {}, 1, rnew(r) {args[0], NULL})};
  frame_push(r,state,frame);
  state->result = Result{.value=cont};
}

//////////////////////////////////////////////////////////////////////
// Misc
//////////////////////////////////////////////////////////////////////

PRIM(print) {
  ANYARGCHECK;
  for (unsigned i = 0; i < nelts; i++)
    switch (args[i]) {
    case &ValueP(*argi_):
      switch (argi_) {
      case &Const_v(&Bool_l(b)):
	if (b)
	  fprintf(stdout,"#t");
	else
	  fprintf(stdout,"#f");
	break;
      case &Const_v(&Char_l(c)):
	fprintf(stdout,"%c", c);
	break;
      case &Const_v(&Int_l(i)):
	fprintf(stdout,"%d", i);
	break;
      case &Const_v(&Real_l(x)):
	fprintf(stdout,"%f", x);
	break;
      case &Const_v(&String_l(s)):
	fprintf(stdout,"%s", s);
	break;
      case &String_v(s):
	fprintf(stdout,"%s", s);
	break;
      default:
	fprintf(stdout,"<todo>");
      }
      break;
    default:
      fprintf(stdout,"<todo>");
    }
  RETURN(UNSPEC);
}

PRIM(scheme_error) {
  ANYARGCHECK;
  fprintf(stdout,"\n");
  for (unsigned i = 0; i < nelts; i++) {
    pp_value(stderr,0,args[i]);
  }
  ERROR("user_error");
}

PRIM(time_now) {
  ARGCHECK(0);
  struct timeval tv;
  gettimeofday(&tv,NULL);
  let x = INT(tv.tv_sec);
  let y = INT(tv.tv_usec);
  RETURN(PAIR(x,y));
}

PRIM(last_arg) { ANYARGCHECK; RETURN(args[nelts-1]); }
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

struct Prim {
  primop_t primop;
  const char ?`H id;
};

// table of all of the primops together with their identifier as a string
// used to construct dynamic and  environments below
static struct Prim primop_table[] = {
  Prim{acosFn<>, "acos"},
  Prim{apply<>, "apply"},
  Prim{asinFn<>, "asin"},
  Prim{atanFn<>, "atan"},
  Prim{callcc<>, "call-with-current-continuation"},
  Prim{car<>, "car"},
  Prim{cdr<>, "cdr"},
  Prim{ceilFn<>, "ceil"},
  Prim{char_eq<>, "char=?"},
  Prim{char_gt<>, "char>?"},
  Prim{char_gte<>, "char>=?"},
  Prim{char_lt<>, "char<?"},
  Prim{char_lte<>, "char<=?"},
  Prim{char_p<>, "char?"},
  Prim{char_to_integer<>, "char->integer"},
  Prim{cons<>, "cons"},
  Prim{cosFn<>, "cos"},
  Prim{divide<>, "/"},
  Prim{eq_p<>, "eq?"},
  Prim{eqv_p<>, "eqv?"},
  Prim{exact_inexact<>, "exact->inexact"},
  Prim{exact_p<>, "exact?"},
  Prim{expFn<>, "exp"},
  Prim{expt<>, "expt"},
  Prim{floorFn<>, "floor"},
  Prim{inexact_exact<>, "inexact->exact"},
  Prim{inexact_p<>, "inexact?"},
  Prim{integer_p<>, "integer?"},
  Prim{integer_to_char<>, "integer->char"},
  Prim{logFn<>, "log"},
  Prim{make_string<>, "make-string"},
  Prim{make_vector<>, "make-vector"},
  Prim{minus<>, "-"},
  Prim{modulo<>, "modulo"},
  Prim{null_p<>, "null?"},
  Prim{number_eq<>, "="},
  Prim{number_gt<>, ">"},
  Prim{number_gte<>, ">="},
  Prim{number_lt<>, "<"},
  Prim{number_lte<>, "<="},
  Prim{number_p<>, "number?"},
  Prim{number_to_string<>, "number->string"},
  Prim{pair_p<>, "pair?"},
  Prim{plus<>, "+"},
  Prim{print<>, "print"},
  Prim{procedure_p<>, "procedure?"},
  Prim{quotient<>, "quotient"},
  Prim{real_p<>, "real?"},
  Prim{remainder<>, "remainder"},
  Prim{roundFn<>, "round"},
  Prim{scheme_error<>, "error"},
  Prim{setcar<>, "set-car!"},
  Prim{setcdr<>, "set-cdr!"},
  Prim{sinFn<>, "sin"},
  Prim{sqrtFn<>, "sqrt"},
  Prim{string<>, "string"},
  Prim{string_length<>, "string-length"},
  Prim{string_p<>, "string?"},
  Prim{string_ref<>, "string-ref"},
  Prim{string_set<>, "string-set!"},
  Prim{string_to_symbol<>, "string->symbol"},
  Prim{symbol_to_string<>, "symbol->string"},
  Prim{tanFn<>, "tan"},
  Prim{times<>, "*"},
  Prim{truncFn<>, "trunc"},
  Prim{vector<>, "vector"},
  Prim{vector_length<>, "vector-length"},
  Prim{vector_p<>, "vector?"},
  Prim{vector_ref<>, "vector-ref"},
  Prim{vector_set<>, "vector-set!"},
  Prim{time_now<>, "time-now"},
  Prim{last_arg<>, "%last-arg%"},
};
// constructs the initial static environment which will map the
// name of the primop to the right offset in the top-level environment.
Dict::dict_t<stringptr_t<`H,`r::R>,$(unsigned,unsigned)@`r,`r>
initial_static_env(region_t<`r> r) {
  let env = Dict::rempty(r, strptrcmp);
  for (unsigned i = 0; i < numelts(primop_table); i++)
    env = Dict::insert(env, rnew(r) (primop_table[i].id), rnew(r) $((unsigned)0,i));
  return env;
}

extern const char?`H prim_name(primop_t p) {
  for(int i = 0; i < numelts(primop_table); i++) {
    if(primop_table[i].primop == p) {
      return primop_table[i].id;
    }
  }
  return  "<unknown prim>";
}

static int prim_index(primop_t p) {
  for(int i = 0; i < numelts(primop_table); i++) {
    if(primop_table[i].primop == p) {
      return i;
    }
  }
  return -1;
}
const primop_t p_cons = cons<>;
const primop_t p_car = car<>;
const primop_t p_cdr = cdr<>;
const primop_t p_null_p = null_p<>;
const primop_t p_eq_p = eq_p<>;
// constructs the initial run-time environment which has a binding
// for each of the primops.
env_t<`r> initial_env(region_t<`r> r) {
  value_t<`r>?`r primops = rnew(r) {for i < numelts(primop_table) : NULL};
  for (unsigned i = 0; i < numelts(primop_table); i++) {
    let p = rnew(r) ValueC(Primop_v((primop_table[i].primop)<>));
    primops[i] = p;
  }
  let p = rnew(r) ValueC(Primop_cons_v);
  primops[prim_index(p_cons<>)] = p;
  let p = rnew(r) ValueC(Primop_car_v);
  primops[prim_index(p_car<>)] = p;
  let p = rnew(r) ValueC(Primop_cdr_v);
  primops[prim_index(p_cdr<>)] = p;
  let p = rnew(r) ValueC(Primop_null_p_v);
  primops[prim_index(p_null_p<>)] = p;
  let p = rnew(r) ValueC(Primop_eq_p_v);
  primops[prim_index(p_eq_p<>)] = p;
  return rnew(r) EnvC(NULL,primops);
}
}
using Core {
using DynamicRegionSeq;
using Scheme::Flags;
using Scheme::GC;
using Scheme::PrettyPrint;
using Scheme::PrimOps;

namespace Scheme;

#define _INLINE inline
#define _ALWAYS_INLINE __attribute__((always_inline))

value_t<`r> copy_static_value(region_t<`r> r, value_t<`s> v) {
  switch (v) {
  case NULL:
    throw new Invalid_argument("copy_static_value");
  case &Value(_,*d):
    switch (d) {
    case &Const_v(c):
      const_t<`r> l = copy_constant(r,c);
      struct Value<datatype ValueD.Const_v<`r>,`r> x = ValueC(Const_v(l));
      return rnew(r) x;
    /* The rest aren't needed to copy the static values;
       static values come from dump-ast.scm, and it doesn't
       generate these. */
    case &Primop_v(_):
    case &Primop_cons_v:
    case &Primop_car_v:
    case &Primop_cdr_v:
    case &Primop_eq_p_v:
    case &Primop_null_p_v:
    case &Pair_v(_,_):
    case &Vector_v(_):
    case &String_v(_):
    case &Throw_v(_,_):
    case &Closure_v(_,_,_):
    case &VarArgsClosure_v(_,_,_):
      throw new Invalid_argument("copy_static_value");
  }
  }
}


//////////////////////////////////////////////////////////////////////
// Core lambda calculus interpreter
//////////////////////////////////////////////////////////////////////

// failure function
void fail(const char ?msg) __attribute__((noreturn)) {
  fprintf(stderr,"Runtime Exception: %s\n", msg);
  exit(1);
}

// lookup variable in the environment
static _INLINE
value_t<`r> lookup(state_ptr_t<`r> s,
		   int depth,
		   unsigned int offset) _ALWAYS_INLINE {
  if(depth < 0) {
    return s->top_env->values[offset];
  } else {
    let env = s->env;
    for (; depth != 0; depth--) env = env->next;
    let vs = env->values;
    return vs[offset];
  }
}

// set the value of a variable in the environment
static _INLINE
void setvar(state_ptr_t<`r> s,
	    int depth,
	    unsigned int offset,
	    value_t<`r> v) _ALWAYS_INLINE {
  if(depth < 0) {
    s->top_env->values[offset] = v;

  } else {
    let env = s->env;
    for (; depth != 0; depth--) env = env->next;
    let vs = env->values;
    vs[offset] = v;
  }
}

//////////////////////////////////////////////////////////////////////
// Operations on frames
//////////////////////////////////////////////////////////////////////
static _INLINE
void push_frame(region_t<`r> r,
		state_ptr_t<`r> s,
		frame_t<`r> f) _ALWAYS_INLINE {
  if(s->free_frames == NULL) {
    s->stack = RNEW(r,StackC(false,s->stack,s->env,f));
    return;
  }
  let stack = s->free_frames;
  s->free_frames = stack->next;
  stack->next = s->stack;
  stack->env = s->env;
  stack->frame = f;
  s->stack = stack;
}
/* stub for primops */
void frame_push(region_t<`r> r, state_ptr_t<`r> s, frame_t<`r> f) {
  push_frame(r,s,f);
}
static _INLINE
frame_t<`r> pop_frame(state_ptr_t<`r> state,bool @shared) _ALWAYS_INLINE {
  let stack = state->stack;
  state->env = stack->env;
  state->stack = stack->next;
  if (!(stack->shared)) {
    *shared = false;
    stack->next = state->free_frames;
    state->free_frames = stack;
  } else {
    *shared = true;
  }
  return stack->frame;
}

static _INLINE
void apply_vals(region_t<`r> r,
		state_ptr_t<`r> state,
		value_t<`r>?`r vs) _ALWAYS_INLINE {
  let f = vs[0];
  let args = vs+1;
  switch (f) {
  case &ValueP(*f_):
    switch(f_) {
    case &Primop_cons_v:
      ARGCHECK(2);
      RETURN(PAIR(args[0],args[1]));
    case &Primop_car_v:
       ARGCHECK(1);
       LETPAIR(hd,tl,args[0]);
       RETURN(hd);
    case &Primop_cdr_v:
      ARGCHECK(1); LETPAIR(hd,tl,args[0]);
      RETURN(tl);
    case &Primop_null_p_v:
      ARGCHECK(1);
      RETURN(BOOL(args[0] == NULL));
    case &Primop_eq_p_v:
      ARGCHECK(2);
      if (args[0] == args[1]) {
	RETURN(TRUE);
      } else {
	switch $(args[0],args[1]) {
	case $(NULL,NULL): RETURN(TRUE);
	case $(&ValueP(*arg0_),&ValueP(*arg1_)):
	  switch (arg0_) {
	  case &Const_v(c):
	    switch(c) {
	    case &Symbol_l(s1):
	      switch(arg1_) {
	      case &Const_v(&Symbol_l(s2)):
		RETURN(BOOL(s1 == s2));
	      default: RETURN(BOOL(FALSE));
	      }
	    case &Bool_l(b1):
	      switch(arg1_) {
	      case &Const_v(&Bool_l(b2)):
		RETURN(BOOL(b1 == b2));
	      default: RETURN(BOOL(FALSE));
	      }
	    default: RETURN(FALSE);
	    }
	  default: RETURN(FALSE);
	  }
	default: RETURN(FALSE);
	}
	RETURN(FALSE);
      }
    case &Primop_v(p): p(r,state,args); break;
    case &Closure_v(nargs,clos_env,body):
      let env = RNEW(r, EnvC(clos_env,args));
      state->env = env;
      state->result.expr = body;
      break;
    case &VarArgsClosure_v(margs,clos_env,body):
      value_t<`r> rest = NULL;
      int i = numelts(args);
      while(margs < i--) {
	let obj = RNEW(r, ValueC(Pair_v(args[i],rest)));
	rest = obj;
	args[i] = NULL;
      }
      if(margs < numelts(args)) {
	args[margs] = rest;
      } else {
	args = RNEW(r,{for i < margs+1 : (i < margs ? args[i] : rest)});
      }
      let env = RNEW(r, EnvC(clos_env,args));
      state->env = env;
      state->result.expr = body;
      break;
    case &Throw_v(throw_stack,throw_env):
      state->stack = throw_stack;
      state->env = throw_env;
      state->result.value = args[0];
      break;
    default:
      fail("expecting primop or closure");
    }
    break;
  default:
    fail("expecting primop or closure");
  }
}

static _INLINE void
eval_apply_frame(region_t<`r> r,
		 state_ptr_t<`r> state,
		 exp_t<`H>?`r es,
		 unsigned int i,
		 value_t<`r>?`r vs) _ALWAYS_INLINE {
  while(i < numelts(es)) {
    switch (es[i]) {
    case NULL:  vs[i] = NULL; break;
    case &ExpP(*e_): {
      switch (e_) {
      case &Var_e(x,d,off): // lookup the variable in the env
	vs[i] = lookup(state,d,off);
	break;
      case &Const_e(v):
	// TJIM: Sadly, we need a copy here
	vs[i] = copy_static_value(r,v);
	break;
      case &Lambda_e(vars,e): // allocate a closure
	let obj = RNEW(r,ValueC(Closure_v(numelts(vars),state->env,e)));
	vs[i] = obj;
	break;
      case &VarArgsLambda_e(vars,_,e): // allocate a closure
	let obj = RNEW(r, ValueC(VarArgsClosure_v(numelts(vars),state->env,e)));
	vs[i] = obj;
	break;
      default: // push a new frame
	let frame = Frame{.apply_frame = $(es,i,vs)};
	push_frame(r,state,frame);
	state->result.expr = es[i];
	return;
      }
    }
      break;
    }
    i++;
  }
  apply_vals(r,state,vs);
}

// we have an expression to evaluate -- if it's a value, return
// it immediately.  Otherwise, push a frame on the stack and start
// evaluating sub-expressions.
static void _INLINE
eval_exp(region_t<`r> r,
	 state_ptr_t<`r> state,
	 exp_t<`H> e) _ALWAYS_INLINE {
  switch (e) {
  case NULL:
    state->result.value = NULL;
    break;
  case &ExpP(*e_):
    switch (e_) {
    case &Var_e(x,d,off): // lookup the variable in the env
      state->result.value = lookup(state,d,off);
      break;
    case &Const_e(v):
      // TJIM: Sadly, we need a copy here
      state->result.value = copy_static_value(r,v);
      break;
    case &Lambda_e(vars,e): // allocate a closure
      let obj = RNEW(r, ValueC(Closure_v(numelts(vars),state->env,e)));
      state->result.value = obj;
      break;
    case &VarArgsLambda_e(vars,_,e): // allocate a closure
      let obj = RNEW(r, ValueC(VarArgsClosure_v(numelts(vars),state->env,e)));
      state->result.value = obj;
      break;
    case &Apply_e(es):
      // push "[] e2 ... en" on stack and evaluate e1
      value_t<`r>? vs = RNEW(r, {for i < numelts(es) : NULL});
      eval_apply_frame(r,state,es,0,vs);
      break;
    case &If_e(e1,e2,e3):
      // push "if [] e2 e3" on stack and evaluate e1
      let es = RNEW(r, {e2 COMMA e3});
      let frame = Frame{.if_frame = es};
      push_frame(r,state,frame);
      state->result.expr = e1;
      break;
    case &Set_e(_,depth,offset,e):
      // push "set x []" on stack and evaluate e
      let frame = Frame{.set_frame = $(depth,offset)};
      push_frame(r,state,frame);
      state->result.expr = e;
      break;
    }
    break;
  }
}

// we have a value to evaluate -- pop a frame from the stack, plug in
// the value into the hole, and continue as appropriate.
static _INLINE
void eval_pop_value(region_t<`r> r,
		    state_ptr_t<`r> state,
		    value_t<`r> v) _ALWAYS_INLINE {
  bool shared = false;
  let frame = pop_frame(state,&shared);
  switch (frame) {
  case {.if_frame = es }:
    // if [] e2 e3: if v is #f evaluate e3, else evaluate e2
    switch (v) {
    case NULL && nil_is_false:
      state->result.expr = es[1];
      break;
    case &ValueP(*v_):
      switch (v_) {
      case &Const_v(&Bool_l(false)):
	state->result.expr = es[1];
	break;
      default:
	state->result.expr = es[0];
	break;
      }
      break;
    default:
      state->result.expr = es[0];
      break;
    }
    break;
  case {.set_frame = $(depth,offset)}:
    // set! x []:
    // Do allocation before side-effect:
    //   if the allocation triggers a GC,
    //   we need to restart in the orignal state.
    let obj = RNEW(r, ValueC(Const_v(RNEW(r, Unspec_l))));
    state->result.value = obj;
    setvar(state, depth, offset, v);
    break;
    // application
  case {.apply_frame = $(es,off,vs)}:
    // (v1 ... vi-1 [] ei+1 ... en):
    // Must copy to support callcc properly.
    let old_vs = vs;
    if (shared)
      vs = RNEW(r,{for i < numelts(vs) : ((i < off) ? old_vs[i] : ((i == off) ? v : NULL))});
    else
      vs[off] = v;
    off = off + 1;
    eval_apply_frame(r,state,es,off,vs);
    break;
  }
}

// take a bounded number of steps in the operational semantics
// inputs:  r is the region where everything is allocated
//          stack is the current control-stack
//          env should be a list of the values corresponding to the variables
//          e is the expression to reduce or the last value reduced
// modifies: updated stack, environment, and expression or value
// outputs: true if the program evaluates to a value
static bool stepi(int n,region_t<`r> r, state_ptr_t<`r> state) {
  while(n--) {
    switch (state->result) {
    case {.expr = e}:
      eval_exp(r,state,e);
      break;
    case {.value = v}:
      if (state->stack == NULL) {
	// stack empty end of program
	fprintf(stdout,"program returned:\n");
	pp_value(stdout,0,v);
	fprintf(stdout,"\n");
	return true;
      } else {
	eval_pop_value(r,state,v);
      }
      break;
    }
  }
  return false;
}

// map a string variable to its debruijn depth and offset, given
// an environment that has all of the bound variables in it.
static $(unsigned depth,unsigned offset)
  static_map(region_t<`r> r,
	     unsigned depth,
	     Dict::dict_t<stringptr_t<`H,`r::R>,$(unsigned,unsigned)@`r,`r> env,
	     stringptr_t<`H,`r> x) {
  try {
    let $(height,off) = *Dict::lookup(env, x);
    if(height == 0) return $(-1, off);
    return $(depth - height, off);
  } catch { case &Dict::Absent:
    fail(aprintf("Unbound Variable: %s",*x));
  }
}

// add debruijn indices in to all variables
static void deb(region_t<`r> r,
		unsigned d,
		Dict::dict_t<stringptr_t<`H,`r::R>,$(unsigned,unsigned)@`r,`r> env,
		exp_t<`H> e) {
  switch (e) {
  case NULL: break;
  case &ExpP(*e_):
    switch (e_) {
    case &Var_e(*x,*depth,*offset):
      let $(dep,off) = static_map(r,d,env,x);
      *depth = dep;
      *offset = off;
      break;
    case &Const_e(_): break;
    case &Apply_e(es):
      for (unsigned i = 0; i < numelts(es); i++)
	deb(r,d,env,es[i]);
      break;
    case &Lambda_e(args,body):
      let d = d + 1;
      for (unsigned i = 0; i < numelts(args); i++)
	env = Dict::insert(env, &(args[i]), rnew(r) $(d,i));
      deb(r,d,env,body);
      break;
    case &VarArgsLambda_e(args,*rest,body):
      let d = d + 1;
      unsigned i = 0;
      while(i < numelts(args)) {
	env = Dict::insert(env, &(args[i]), rnew(r) $(d,i));
	i++;
      }
      env = Dict::insert(env, rest, rnew(r) $(d,i));
      deb(r,d,env,body);
      break;
    case &If_e(e1,e2,e3):
      deb(r,d,env,e1);
      deb(r,d,env,e2);
      deb(r,d,env,e3);
      break;
    case &Set_e(*x,*depth,*offset,e):
      let $(dep,off) = static_map(r,d,env,x);
      *depth = dep;
      *offset = off;
      deb(r,d,env,e);
      break;
    }
    break;
  }
}

// Convert an expression using strings as variables
// to one that has depth and offsets for the environment.
void debruijn(region_t<`r> r, exp_t<`H> e) {
  let env = initial_static_env(r);
  deb(r, 0, env, e);
}

#define MAX_STEPS 500

/**open: frags/pp-scheme-drs.tex*/
void scheme(exp_t<`H> prog()) {
  // construct the initial heap
  let NewDynamicRegionSeq {<`r> DynamicRegionSeq{key, gen}} = new_drseq();
  // load the program and initial environment into the initial heap
  exp_t<`H> e = prog();
  /**+hide*/
  value_t<`r> true_v;
  value_t<`r> false_v;
  /**-hide*/
  env_t<`r> env;
  { region r = open(key);
    /**+hide*/
    debruijn(r, e);
    if (verbose)
      pp_exp(stderr, 0, e);
    const_t<`r> true_c = RNEW(r,Bool_l(true));
    const_t<`r> false_c = RNEW(r,Bool_l(false));
    struct Value<datatype ValueD.Const_v<`r>,`r> tv = ValueC(Const_v(true_c));
    struct Value<datatype ValueD.Const_v<`r>,`r> fv = ValueC(Const_v(false_c));
    true_v = RNEW(r,tv);
    false_v = RNEW(r,fv);
    /**-hide*/
    env = initial_env(r);
  }
  // construct the initial state
  /**+hide*/
  state_t<`r> state = State{NULL,env,{.expr = e},env,NULL,true_v,false_v};
  /**+alt
  state_t<`r> state = State{NULL,env,{.expr = e}};
  /**-alt*/
  /**-hide*/
  // construct the initial gc state with
  //  - the dynamic region sequence
  //  - the initial state 
  struct GCState gcs = GCState{{key,gen},state};
  while (true) {
    // unpack the current gc state, naming the existentially bound region (`s)
    let GCState{<`s> DynamicRegionSeq{key, gen}, state} = gcs;
    { // open the current heap
      region r = open(key);
      // take a fixed number of steps
      bool done = stepi(MAX_STEPS,r,&state);
      // check for termination
      if (done) { goto Finished; } 
    }
    // pack the new gc state and allow a GC
    gcs = GCState{DynamicRegionSeq{key, gen}, state};
    gcs = maybeGC(gcs);
  }
 Finished:
  // unpack the final gc state and free the final region
  let GCState{<`r> DynamicRegionSeq{key, gen}, state} = gcs;
  free_ukey(key);
}
/**close*/

// error
void error(const char ?msg, stack_t<`r> stack, env_t<`r> env) __attribute__((noreturn)) {
  fprintf(stdout,"Runtime Exception: %s\n", msg);
  fprintf(stdout,"Stack dump:\n");
  pp_with_deb_idx = true;
  pp_stack(stderr,0,stack);
  fprintf(stderr,"\n");
  exit(1);
}
}

using Scheme;
const char ?v2[] = { "equal?","zero?","positive?","negative?","odd?","even?","min","max","abs","not","caar","cadr","cdar","cddr","caaar","caadr","cadar","caddr","cdaar","cdadr","cddar","cdddr","caaaar","caaadr","caadar","caaddr","cadaar","cadadr","caddar","cadddr","cdaaar","cdaadr","cdadar","cdaddr","cddaar","cddadr","cdddar","cddddr","list?","list","length","append","reverse","list-tail","list-ref","memq","memv","member","assq","assv","assoc","string-copy","string-append","list->vector","newline","display","write","map","for-each","time-diff","time-to-ms","run-benchmark","fib" };
struct Exp<datatype ExpD.Var_e> v4 = { NULL,Var_e("%last-arg%",0,0) };
const char ?v6[] = { "g14051407","g14061408" };
struct Exp<datatype ExpD.Var_e> v8 = { NULL,Var_e("pair?",0,0) };
struct Exp<datatype ExpD.Var_e> v9 = { NULL,Var_e("g14051407",0,0) };
exp_t v10[] = { (exp_t)&v8,&v9 };
struct Exp<datatype ExpD.Apply_e> v7 = { NULL,Apply_e(v10) };
struct Exp<datatype ExpD.Var_e> v12 = { NULL,Var_e("pair?",0,0) };
struct Exp<datatype ExpD.Var_e> v13 = { NULL,Var_e("g14061408",0,0) };
exp_t v14[] = { (exp_t)&v12,&v13 };
struct Exp<datatype ExpD.Apply_e> v11 = { NULL,Apply_e(v14) };
datatype Const.Bool_l v15 = Bool_l(false);
struct Value<datatype ValueD.Const_v> v16 = { NULL,Const_v(&v15) };
struct Exp<datatype ExpD.Const_e> v17 = { NULL,Const_e(&v16) };
struct Exp<datatype ExpD.If_e> v18 = { NULL,If_e(&v7,&v11,&v17) };
struct Exp<datatype ExpD.Var_e> v20 = { NULL,Var_e("equal?",0,0) };
struct Exp<datatype ExpD.Var_e> v22 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v23 = { NULL,Var_e("g14051407",0,0) };
exp_t v24[] = { (exp_t)&v22,&v23 };
struct Exp<datatype ExpD.Apply_e> v21 = { NULL,Apply_e(v24) };
struct Exp<datatype ExpD.Var_e> v26 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v27 = { NULL,Var_e("g14061408",0,0) };
exp_t v28[] = { (exp_t)&v26,&v27 };
struct Exp<datatype ExpD.Apply_e> v25 = { NULL,Apply_e(v28) };
exp_t v29[] = { (exp_t)&v20,&v21,&v25 };
struct Exp<datatype ExpD.Apply_e> v19 = { NULL,Apply_e(v29) };
struct Exp<datatype ExpD.Var_e> v31 = { NULL,Var_e("equal?",0,0) };
struct Exp<datatype ExpD.Var_e> v33 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v34 = { NULL,Var_e("g14061408",0,0) };
exp_t v35[] = { (exp_t)&v33,&v34 };
struct Exp<datatype ExpD.Apply_e> v32 = { NULL,Apply_e(v35) };
struct Exp<datatype ExpD.Var_e> v37 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v38 = { NULL,Var_e("g14061408",0,0) };
exp_t v39[] = { (exp_t)&v37,&v38 };
struct Exp<datatype ExpD.Apply_e> v36 = { NULL,Apply_e(v39) };
exp_t v40[] = { (exp_t)&v31,&v32,&v36 };
struct Exp<datatype ExpD.Apply_e> v30 = { NULL,Apply_e(v40) };
datatype Const.Bool_l v41 = Bool_l(false);
struct Value<datatype ValueD.Const_v> v42 = { NULL,Const_v(&v41) };
struct Exp<datatype ExpD.Const_e> v43 = { NULL,Const_e(&v42) };
struct Exp<datatype ExpD.If_e> v44 = { NULL,If_e(&v19,&v30,&v43) };
datatype Const.Bool_l v45 = Bool_l(true);
struct Value<datatype ValueD.Const_v> v46 = { NULL,Const_v(&v45) };
struct Exp<datatype ExpD.Const_e> v47 = { NULL,Const_e(&v46) };
struct Exp<datatype ExpD.Var_e> v49 = { NULL,Var_e("eqv?",0,0) };
struct Exp<datatype ExpD.Var_e> v50 = { NULL,Var_e("g14051407",0,0) };
struct Exp<datatype ExpD.Var_e> v51 = { NULL,Var_e("g14061408",0,0) };
exp_t v52[] = { (exp_t)&v49,&v50,&v51 };
struct Exp<datatype ExpD.Apply_e> v48 = { NULL,Apply_e(v52) };
datatype Const.Undef_l v53 = Undef_l;
struct Value<datatype ValueD.Const_v> v54 = { NULL,Const_v(&v53) };
struct Exp<datatype ExpD.Const_e> v55 = { NULL,Const_e(&v54) };
struct Exp<datatype ExpD.If_e> v56 = { NULL,If_e(&v47,&v48,&v55) };
struct Exp<datatype ExpD.If_e> v57 = { NULL,If_e(&v18,&v44,&v56) };
struct Exp<datatype ExpD.Lambda_e> v5 = { NULL,Lambda_e(v6,&v57) };
struct Exp<datatype ExpD.Set_e> v58 = { NULL,Set_e("equal?",0,0,&v5) };
const char ?v60[] = { "g14091410" };
struct Exp<datatype ExpD.Var_e> v62 = { NULL,Var_e("=",0,0) };
datatype Const.Int_l v63 = Int_l(0);
struct Value<datatype ValueD.Const_v> v64 = { NULL,Const_v(&v63) };
struct Exp<datatype ExpD.Const_e> v65 = { NULL,Const_e(&v64) };
struct Exp<datatype ExpD.Var_e> v66 = { NULL,Var_e("g14091410",0,0) };
exp_t v67[] = { (exp_t)&v62,&v65,&v66 };
struct Exp<datatype ExpD.Apply_e> v61 = { NULL,Apply_e(v67) };
struct Exp<datatype ExpD.Lambda_e> v59 = { NULL,Lambda_e(v60,&v61) };
struct Exp<datatype ExpD.Set_e> v68 = { NULL,Set_e("zero?",0,0,&v59) };
const char ?v70[] = { "g14111412" };
struct Exp<datatype ExpD.Var_e> v72 = { NULL,Var_e("<",0,0) };
datatype Const.Int_l v73 = Int_l(0);
struct Value<datatype ValueD.Const_v> v74 = { NULL,Const_v(&v73) };
struct Exp<datatype ExpD.Const_e> v75 = { NULL,Const_e(&v74) };
struct Exp<datatype ExpD.Var_e> v76 = { NULL,Var_e("g14111412",0,0) };
exp_t v77[] = { (exp_t)&v72,&v75,&v76 };
struct Exp<datatype ExpD.Apply_e> v71 = { NULL,Apply_e(v77) };
struct Exp<datatype ExpD.Lambda_e> v69 = { NULL,Lambda_e(v70,&v71) };
struct Exp<datatype ExpD.Set_e> v78 = { NULL,Set_e("positive?",0,0,&v69) };
const char ?v80[] = { "g14131414" };
struct Exp<datatype ExpD.Var_e> v82 = { NULL,Var_e(">",0,0) };
datatype Const.Int_l v83 = Int_l(0);
struct Value<datatype ValueD.Const_v> v84 = { NULL,Const_v(&v83) };
struct Exp<datatype ExpD.Const_e> v85 = { NULL,Const_e(&v84) };
struct Exp<datatype ExpD.Var_e> v86 = { NULL,Var_e("g14131414",0,0) };
exp_t v87[] = { (exp_t)&v82,&v85,&v86 };
struct Exp<datatype ExpD.Apply_e> v81 = { NULL,Apply_e(v87) };
struct Exp<datatype ExpD.Lambda_e> v79 = { NULL,Lambda_e(v80,&v81) };
struct Exp<datatype ExpD.Set_e> v88 = { NULL,Set_e("negative?",0,0,&v79) };
const char ?v90[] = { "g14151416" };
struct Exp<datatype ExpD.Var_e> v92 = { NULL,Var_e("=",0,0) };
datatype Const.Int_l v93 = Int_l(1);
struct Value<datatype ValueD.Const_v> v94 = { NULL,Const_v(&v93) };
struct Exp<datatype ExpD.Const_e> v95 = { NULL,Const_e(&v94) };
struct Exp<datatype ExpD.Var_e> v97 = { NULL,Var_e("modulo",0,0) };
struct Exp<datatype ExpD.Var_e> v98 = { NULL,Var_e("g14151416",0,0) };
datatype Const.Int_l v99 = Int_l(2);
struct Value<datatype ValueD.Const_v> v100 = { NULL,Const_v(&v99) };
struct Exp<datatype ExpD.Const_e> v101 = { NULL,Const_e(&v100) };
exp_t v102[] = { (exp_t)&v97,&v98,&v101 };
struct Exp<datatype ExpD.Apply_e> v96 = { NULL,Apply_e(v102) };
exp_t v103[] = { (exp_t)&v92,&v95,&v96 };
struct Exp<datatype ExpD.Apply_e> v91 = { NULL,Apply_e(v103) };
struct Exp<datatype ExpD.Lambda_e> v89 = { NULL,Lambda_e(v90,&v91) };
struct Exp<datatype ExpD.Set_e> v104 = { NULL,Set_e("odd?",0,0,&v89) };
const char ?v106[] = { "g14171418" };
struct Exp<datatype ExpD.Var_e> v108 = { NULL,Var_e("=",0,0) };
datatype Const.Int_l v109 = Int_l(0);
struct Value<datatype ValueD.Const_v> v110 = { NULL,Const_v(&v109) };
struct Exp<datatype ExpD.Const_e> v111 = { NULL,Const_e(&v110) };
struct Exp<datatype ExpD.Var_e> v113 = { NULL,Var_e("modulo",0,0) };
struct Exp<datatype ExpD.Var_e> v114 = { NULL,Var_e("g14171418",0,0) };
datatype Const.Int_l v115 = Int_l(2);
struct Value<datatype ValueD.Const_v> v116 = { NULL,Const_v(&v115) };
struct Exp<datatype ExpD.Const_e> v117 = { NULL,Const_e(&v116) };
exp_t v118[] = { (exp_t)&v113,&v114,&v117 };
struct Exp<datatype ExpD.Apply_e> v112 = { NULL,Apply_e(v118) };
exp_t v119[] = { (exp_t)&v108,&v111,&v112 };
struct Exp<datatype ExpD.Apply_e> v107 = { NULL,Apply_e(v119) };
struct Exp<datatype ExpD.Lambda_e> v105 = { NULL,Lambda_e(v106,&v107) };
struct Exp<datatype ExpD.Set_e> v120 = { NULL,Set_e("even?",0,0,&v105) };
const char ?v122[] = { "g14211428","g14201429" };
const char ?v125[] = { "g14221431" };
const char ?v128[] = { "g14231432" };
const char ?v131[] = { "t1437" };
struct Exp<datatype ExpD.Var_e> v133 = { NULL,Var_e("g14231432",0,0) };
struct Exp<datatype ExpD.Var_e> v134 = { NULL,Var_e("g14221431",0,0) };
struct Exp<datatype ExpD.Var_e> v135 = { NULL,Var_e("g14191430",0,0) };
exp_t v136[] = { (exp_t)&v133,&v134,&v135 };
struct Exp<datatype ExpD.Apply_e> v132 = { NULL,Apply_e(v136) };
struct Exp<datatype ExpD.Lambda_e> v130 = { NULL,Lambda_e(v131,&v132) };
const char ?v138[] = { "g14241433","g14251434" };
struct Exp<datatype ExpD.Var_e> v140 = { NULL,Var_e("null?",0,0) };
struct Exp<datatype ExpD.Var_e> v141 = { NULL,Var_e("g14251434",0,0) };
exp_t v142[] = { (exp_t)&v140,&v141 };
struct Exp<datatype ExpD.Apply_e> v139 = { NULL,Apply_e(v142) };
struct Exp<datatype ExpD.Var_e> v143 = { NULL,Var_e("g14241433",0,0) };
const char ?v146[] = { "g14261435","g14271436" };
struct Exp<datatype ExpD.Var_e> v148 = { NULL,Var_e("<",0,0) };
struct Exp<datatype ExpD.Var_e> v149 = { NULL,Var_e("g14261435",0,0) };
struct Exp<datatype ExpD.Var_e> v150 = { NULL,Var_e("g14241433",0,0) };
exp_t v151[] = { (exp_t)&v148,&v149,&v150 };
struct Exp<datatype ExpD.Apply_e> v147 = { NULL,Apply_e(v151) };
struct Exp<datatype ExpD.Var_e> v153 = { NULL,Var_e("g14231432",0,0) };
struct Exp<datatype ExpD.Var_e> v154 = { NULL,Var_e("g14261435",0,0) };
struct Exp<datatype ExpD.Var_e> v155 = { NULL,Var_e("g14271436",0,0) };
exp_t v156[] = { (exp_t)&v153,&v154,&v155 };
struct Exp<datatype ExpD.Apply_e> v152 = { NULL,Apply_e(v156) };
struct Exp<datatype ExpD.Var_e> v158 = { NULL,Var_e("g14231432",0,0) };
struct Exp<datatype ExpD.Var_e> v159 = { NULL,Var_e("g14241433",0,0) };
struct Exp<datatype ExpD.Var_e> v160 = { NULL,Var_e("g14271436",0,0) };
exp_t v161[] = { (exp_t)&v158,&v159,&v160 };
struct Exp<datatype ExpD.Apply_e> v157 = { NULL,Apply_e(v161) };
struct Exp<datatype ExpD.If_e> v162 = { NULL,If_e(&v147,&v152,&v157) };
struct Exp<datatype ExpD.Lambda_e> v145 = { NULL,Lambda_e(v146,&v162) };
struct Exp<datatype ExpD.Var_e> v164 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v165 = { NULL,Var_e("g14251434",0,0) };
exp_t v166[] = { (exp_t)&v164,&v165 };
struct Exp<datatype ExpD.Apply_e> v163 = { NULL,Apply_e(v166) };
struct Exp<datatype ExpD.Var_e> v168 = { NULL,Var_e("cdr",0,0) };
struct Exp<datatype ExpD.Var_e> v169 = { NULL,Var_e("g14251434",0,0) };
exp_t v170[] = { (exp_t)&v168,&v169 };
struct Exp<datatype ExpD.Apply_e> v167 = { NULL,Apply_e(v170) };
exp_t v171[] = { (exp_t)&v145,&v163,&v167 };
struct Exp<datatype ExpD.Apply_e> v144 = { NULL,Apply_e(v171) };
struct Exp<datatype ExpD.If_e> v172 = { NULL,If_e(&v139,&v143,&v144) };
struct Exp<datatype ExpD.Lambda_e> v137 = { NULL,Lambda_e(v138,&v172) };
struct Exp<datatype ExpD.Set_e> v173 = { NULL,Set_e("g14231432",0,0,&v137) };
exp_t v174[] = { (exp_t)&v130,&v173 };
struct Exp<datatype ExpD.Apply_e> v129 = { NULL,Apply_e(v174) };
struct Exp<datatype ExpD.Lambda_e> v127 = { NULL,Lambda_e(v128,&v129) };
datatype Const.Undef_l v175 = Undef_l;
struct Value<datatype ValueD.Const_v> v176 = { NULL,Const_v(&v175) };
struct Exp<datatype ExpD.Const_e> v177 = { NULL,Const_e(&v176) };
exp_t v178[] = { (exp_t)&v127,&v177 };
struct Exp<datatype ExpD.Apply_e> v126 = { NULL,Apply_e(v178) };
struct Exp<datatype ExpD.Lambda_e> v124 = { NULL,Lambda_e(v125,&v126) };
struct Exp<datatype ExpD.Var_e> v180 = { NULL,Var_e("<",0,0) };
struct Exp<datatype ExpD.Var_e> v181 = { NULL,Var_e("g14211428",0,0) };
struct Exp<datatype ExpD.Var_e> v182 = { NULL,Var_e("g14201429",0,0) };
exp_t v183[] = { (exp_t)&v180,&v181,&v182 };
struct Exp<datatype ExpD.Apply_e> v179 = { NULL,Apply_e(v183) };
struct Exp<datatype ExpD.Var_e> v184 = { NULL,Var_e("g14211428",0,0) };
struct Exp<datatype ExpD.Var_e> v185 = { NULL,Var_e("g14201429",0,0) };
struct Exp<datatype ExpD.If_e> v186 = { NULL,If_e(&v179,&v184,&v185) };
exp_t v187[] = { (exp_t)&v124,&v186 };
struct Exp<datatype ExpD.Apply_e> v123 = { NULL,Apply_e(v187) };
struct Exp<datatype ExpD.VarArgsLambda_e> v121 = { NULL,VarArgsLambda_e(v122,"g14191430",&v123) };
struct Exp<datatype ExpD.Set_e> v188 = { NULL,Set_e("min",0,0,&v121) };
const char ?v190[] = { "g14401447","g14391448" };
const char ?v193[] = { "g14411450" };
const char ?v196[] = { "g14421451" };
const char ?v199[] = { "t1456" };
struct Exp<datatype ExpD.Var_e> v201 = { NULL,Var_e("g14421451",0,0) };
struct Exp<datatype ExpD.Var_e> v202 = { NULL,Var_e("g14411450",0,0) };
struct Exp<datatype ExpD.Var_e> v203 = { NULL,Var_e("g14381449",0,0) };
exp_t v204[] = { (exp_t)&v201,&v202,&v203 };
struct Exp<datatype ExpD.Apply_e> v200 = { NULL,Apply_e(v204) };
struct Exp<datatype ExpD.Lambda_e> v198 = { NULL,Lambda_e(v199,&v200) };
const char ?v206[] = { "g14431452","g14441453" };
struct Exp<datatype ExpD.Var_e> v208 = { NULL,Var_e("null?",0,0) };
struct Exp<datatype ExpD.Var_e> v209 = { NULL,Var_e("g14441453",0,0) };
exp_t v210[] = { (exp_t)&v208,&v209 };
struct Exp<datatype ExpD.Apply_e> v207 = { NULL,Apply_e(v210) };
struct Exp<datatype ExpD.Var_e> v211 = { NULL,Var_e("g14431452",0,0) };
const char ?v214[] = { "g14451454","g14461455" };
struct Exp<datatype ExpD.Var_e> v216 = { NULL,Var_e(">",0,0) };
struct Exp<datatype ExpD.Var_e> v217 = { NULL,Var_e("g14451454",0,0) };
struct Exp<datatype ExpD.Var_e> v218 = { NULL,Var_e("g14431452",0,0) };
exp_t v219[] = { (exp_t)&v216,&v217,&v218 };
struct Exp<datatype ExpD.Apply_e> v215 = { NULL,Apply_e(v219) };
struct Exp<datatype ExpD.Var_e> v221 = { NULL,Var_e("g14421451",0,0) };
struct Exp<datatype ExpD.Var_e> v222 = { NULL,Var_e("g14451454",0,0) };
struct Exp<datatype ExpD.Var_e> v223 = { NULL,Var_e("g14461455",0,0) };
exp_t v224[] = { (exp_t)&v221,&v222,&v223 };
struct Exp<datatype ExpD.Apply_e> v220 = { NULL,Apply_e(v224) };
struct Exp<datatype ExpD.Var_e> v226 = { NULL,Var_e("g14421451",0,0) };
struct Exp<datatype ExpD.Var_e> v227 = { NULL,Var_e("g14431452",0,0) };
struct Exp<datatype ExpD.Var_e> v228 = { NULL,Var_e("g14461455",0,0) };
exp_t v229[] = { (exp_t)&v226,&v227,&v228 };
struct Exp<datatype ExpD.Apply_e> v225 = { NULL,Apply_e(v229) };
struct Exp<datatype ExpD.If_e> v230 = { NULL,If_e(&v215,&v220,&v225) };
struct Exp<datatype ExpD.Lambda_e> v213 = { NULL,Lambda_e(v214,&v230) };
struct Exp<datatype ExpD.Var_e> v232 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v233 = { NULL,Var_e("g14441453",0,0) };
exp_t v234[] = { (exp_t)&v232,&v233 };
struct Exp<datatype ExpD.Apply_e> v231 = { NULL,Apply_e(v234) };
struct Exp<datatype ExpD.Var_e> v236 = { NULL,Var_e("cdr",0,0) };
struct Exp<datatype ExpD.Var_e> v237 = { NULL,Var_e("g14441453",0,0) };
exp_t v238[] = { (exp_t)&v236,&v237 };
struct Exp<datatype ExpD.Apply_e> v235 = { NULL,Apply_e(v238) };
exp_t v239[] = { (exp_t)&v213,&v231,&v235 };
struct Exp<datatype ExpD.Apply_e> v212 = { NULL,Apply_e(v239) };
struct Exp<datatype ExpD.If_e> v240 = { NULL,If_e(&v207,&v211,&v212) };
struct Exp<datatype ExpD.Lambda_e> v205 = { NULL,Lambda_e(v206,&v240) };
struct Exp<datatype ExpD.Set_e> v241 = { NULL,Set_e("g14421451",0,0,&v205) };
exp_t v242[] = { (exp_t)&v198,&v241 };
struct Exp<datatype ExpD.Apply_e> v197 = { NULL,Apply_e(v242) };
struct Exp<datatype ExpD.Lambda_e> v195 = { NULL,Lambda_e(v196,&v197) };
datatype Const.Undef_l v243 = Undef_l;
struct Value<datatype ValueD.Const_v> v244 = { NULL,Const_v(&v243) };
struct Exp<datatype ExpD.Const_e> v245 = { NULL,Const_e(&v244) };
exp_t v246[] = { (exp_t)&v195,&v245 };
struct Exp<datatype ExpD.Apply_e> v194 = { NULL,Apply_e(v246) };
struct Exp<datatype ExpD.Lambda_e> v192 = { NULL,Lambda_e(v193,&v194) };
struct Exp<datatype ExpD.Var_e> v248 = { NULL,Var_e(">",0,0) };
struct Exp<datatype ExpD.Var_e> v249 = { NULL,Var_e("g14401447",0,0) };
struct Exp<datatype ExpD.Var_e> v250 = { NULL,Var_e("g14391448",0,0) };
exp_t v251[] = { (exp_t)&v248,&v249,&v250 };
struct Exp<datatype ExpD.Apply_e> v247 = { NULL,Apply_e(v251) };
struct Exp<datatype ExpD.Var_e> v252 = { NULL,Var_e("g14401447",0,0) };
struct Exp<datatype ExpD.Var_e> v253 = { NULL,Var_e("g14391448",0,0) };
struct Exp<datatype ExpD.If_e> v254 = { NULL,If_e(&v247,&v252,&v253) };
exp_t v255[] = { (exp_t)&v192,&v254 };
struct Exp<datatype ExpD.Apply_e> v191 = { NULL,Apply_e(v255) };
struct Exp<datatype ExpD.VarArgsLambda_e> v189 = { NULL,VarArgsLambda_e(v190,"g14381449",&v191) };
struct Exp<datatype ExpD.Set_e> v256 = { NULL,Set_e("max",0,0,&v189) };
const char ?v258[] = { "g14571458" };
struct Exp<datatype ExpD.Var_e> v260 = { NULL,Var_e("negative?",0,0) };
struct Exp<datatype ExpD.Var_e> v261 = { NULL,Var_e("g14571458",0,0) };
exp_t v262[] = { (exp_t)&v260,&v261 };
struct Exp<datatype ExpD.Apply_e> v259 = { NULL,Apply_e(v262) };
struct Exp<datatype ExpD.Var_e> v264 = { NULL,Var_e("-",0,0) };
struct Exp<datatype ExpD.Var_e> v265 = { NULL,Var_e("g14571458",0,0) };
exp_t v266[] = { (exp_t)&v264,&v265 };
struct Exp<datatype ExpD.Apply_e> v263 = { NULL,Apply_e(v266) };
struct Exp<datatype ExpD.Var_e> v267 = { NULL,Var_e("g14571458",0,0) };
struct Exp<datatype ExpD.If_e> v268 = { NULL,If_e(&v259,&v263,&v267) };
struct Exp<datatype ExpD.Lambda_e> v257 = { NULL,Lambda_e(v258,&v268) };
struct Exp<datatype ExpD.Set_e> v269 = { NULL,Set_e("abs",0,0,&v257) };
const char ?v271[] = { "g14591460" };
struct Exp<datatype ExpD.Var_e> v272 = { NULL,Var_e("g14591460",0,0) };
datatype Const.Bool_l v273 = Bool_l(false);
struct Value<datatype ValueD.Const_v> v274 = { NULL,Const_v(&v273) };
struct Exp<datatype ExpD.Const_e> v275 = { NULL,Const_e(&v274) };
datatype Const.Bool_l v276 = Bool_l(true);
struct Value<datatype ValueD.Const_v> v277 = { NULL,Const_v(&v276) };
struct Exp<datatype ExpD.Const_e> v278 = { NULL,Const_e(&v277) };
struct Exp<datatype ExpD.If_e> v279 = { NULL,If_e(&v272,&v275,&v278) };
struct Exp<datatype ExpD.Lambda_e> v270 = { NULL,Lambda_e(v271,&v279) };
struct Exp<datatype ExpD.Set_e> v280 = { NULL,Set_e("not",0,0,&v270) };
const char ?v282[] = { "g14611462" };
struct Exp<datatype ExpD.Var_e> v284 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v286 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v287 = { NULL,Var_e("g14611462",0,0) };
exp_t v288[] = { (exp_t)&v286,&v287 };
struct Exp<datatype ExpD.Apply_e> v285 = { NULL,Apply_e(v288) };
exp_t v289[] = { (exp_t)&v284,&v285 };
struct Exp<datatype ExpD.Apply_e> v283 = { NULL,Apply_e(v289) };
struct Exp<datatype ExpD.Lambda_e> v281 = { NULL,Lambda_e(v282,&v283) };
struct Exp<datatype ExpD.Set_e> v290 = { NULL,Set_e("caar",0,0,&v281) };
const char ?v292[] = { "g14631464" };
struct Exp<datatype ExpD.Var_e> v294 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v296 = { NULL,Var_e("cdr",0,0) };
struct Exp<datatype ExpD.Var_e> v297 = { NULL,Var_e("g14631464",0,0) };
exp_t v298[] = { (exp_t)&v296,&v297 };
struct Exp<datatype ExpD.Apply_e> v295 = { NULL,Apply_e(v298) };
exp_t v299[] = { (exp_t)&v294,&v295 };
struct Exp<datatype ExpD.Apply_e> v293 = { NULL,Apply_e(v299) };
struct Exp<datatype ExpD.Lambda_e> v291 = { NULL,Lambda_e(v292,&v293) };
struct Exp<datatype ExpD.Set_e> v300 = { NULL,Set_e("cadr",0,0,&v291) };
const char ?v302[] = { "g14651466" };
struct Exp<datatype ExpD.Var_e> v304 = { NULL,Var_e("cdr",0,0) };
struct Exp<datatype ExpD.Var_e> v306 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v307 = { NULL,Var_e("g14651466",0,0) };
exp_t v308[] = { (exp_t)&v306,&v307 };
struct Exp<datatype ExpD.Apply_e> v305 = { NULL,Apply_e(v308) };
exp_t v309[] = { (exp_t)&v304,&v305 };
struct Exp<datatype ExpD.Apply_e> v303 = { NULL,Apply_e(v309) };
struct Exp<datatype ExpD.Lambda_e> v301 = { NULL,Lambda_e(v302,&v303) };
struct Exp<datatype ExpD.Set_e> v310 = { NULL,Set_e("cdar",0,0,&v301) };
const char ?v312[] = { "g14671468" };
struct Exp<datatype ExpD.Var_e> v314 = { NULL,Var_e("cdr",0,0) };
struct Exp<datatype ExpD.Var_e> v316 = { NULL,Var_e("cdr",0,0) };
struct Exp<datatype ExpD.Var_e> v317 = { NULL,Var_e("g14671468",0,0) };
exp_t v318[] = { (exp_t)&v316,&v317 };
struct Exp<datatype ExpD.Apply_e> v315 = { NULL,Apply_e(v318) };
exp_t v319[] = { (exp_t)&v314,&v315 };
struct Exp<datatype ExpD.Apply_e> v313 = { NULL,Apply_e(v319) };
struct Exp<datatype ExpD.Lambda_e> v311 = { NULL,Lambda_e(v312,&v313) };
struct Exp<datatype ExpD.Set_e> v320 = { NULL,Set_e("cddr",0,0,&v311) };
const char ?v322[] = { "g14691470" };
struct Exp<datatype ExpD.Var_e> v324 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v326 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v328 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v329 = { NULL,Var_e("g14691470",0,0) };
exp_t v330[] = { (exp_t)&v328,&v329 };
struct Exp<datatype ExpD.Apply_e> v327 = { NULL,Apply_e(v330) };
exp_t v331[] = { (exp_t)&v326,&v327 };
struct Exp<datatype ExpD.Apply_e> v325 = { NULL,Apply_e(v331) };
exp_t v332[] = { (exp_t)&v324,&v325 };
struct Exp<datatype ExpD.Apply_e> v323 = { NULL,Apply_e(v332) };
struct Exp<datatype ExpD.Lambda_e> v321 = { NULL,Lambda_e(v322,&v323) };
struct Exp<datatype ExpD.Set_e> v333 = { NULL,Set_e("caaar",0,0,&v321) };
const char ?v335[] = { "g14711472" };
struct Exp<datatype ExpD.Var_e> v337 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v339 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v341 = { NULL,Var_e("cdr",0,0) };
struct Exp<datatype ExpD.Var_e> v342 = { NULL,Var_e("g14711472",0,0) };
exp_t v343[] = { (exp_t)&v341,&v342 };
struct Exp<datatype ExpD.Apply_e> v340 = { NULL,Apply_e(v343) };
exp_t v344[] = { (exp_t)&v339,&v340 };
struct Exp<datatype ExpD.Apply_e> v338 = { NULL,Apply_e(v344) };
exp_t v345[] = { (exp_t)&v337,&v338 };
struct Exp<datatype ExpD.Apply_e> v336 = { NULL,Apply_e(v345) };
struct Exp<datatype ExpD.Lambda_e> v334 = { NULL,Lambda_e(v335,&v336) };
struct Exp<datatype ExpD.Set_e> v346 = { NULL,Set_e("caadr",0,0,&v334) };
const char ?v348[] = { "g14731474" };
struct Exp<datatype ExpD.Var_e> v350 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v352 = { NULL,Var_e("cdr",0,0) };
struct Exp<datatype ExpD.Var_e> v354 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v355 = { NULL,Var_e("g14731474",0,0) };
exp_t v356[] = { (exp_t)&v354,&v355 };
struct Exp<datatype ExpD.Apply_e> v353 = { NULL,Apply_e(v356) };
exp_t v357[] = { (exp_t)&v352,&v353 };
struct Exp<datatype ExpD.Apply_e> v351 = { NULL,Apply_e(v357) };
exp_t v358[] = { (exp_t)&v350,&v351 };
struct Exp<datatype ExpD.Apply_e> v349 = { NULL,Apply_e(v358) };
struct Exp<datatype ExpD.Lambda_e> v347 = { NULL,Lambda_e(v348,&v349) };
struct Exp<datatype ExpD.Set_e> v359 = { NULL,Set_e("cadar",0,0,&v347) };
const char ?v361[] = { "g14751476" };
struct Exp<datatype ExpD.Var_e> v363 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v365 = { NULL,Var_e("cdr",0,0) };
struct Exp<datatype ExpD.Var_e> v367 = { NULL,Var_e("cdr",0,0) };
struct Exp<datatype ExpD.Var_e> v368 = { NULL,Var_e("g14751476",0,0) };
exp_t v369[] = { (exp_t)&v367,&v368 };
struct Exp<datatype ExpD.Apply_e> v366 = { NULL,Apply_e(v369) };
exp_t v370[] = { (exp_t)&v365,&v366 };
struct Exp<datatype ExpD.Apply_e> v364 = { NULL,Apply_e(v370) };
exp_t v371[] = { (exp_t)&v363,&v364 };
struct Exp<datatype ExpD.Apply_e> v362 = { NULL,Apply_e(v371) };
struct Exp<datatype ExpD.Lambda_e> v360 = { NULL,Lambda_e(v361,&v362) };
struct Exp<datatype ExpD.Set_e> v372 = { NULL,Set_e("caddr",0,0,&v360) };
const char ?v374[] = { "g14771478" };
struct Exp<datatype ExpD.Var_e> v376 = { NULL,Var_e("cdr",0,0) };
struct Exp<datatype ExpD.Var_e> v378 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v380 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v381 = { NULL,Var_e("g14771478",0,0) };
exp_t v382[] = { (exp_t)&v380,&v381 };
struct Exp<datatype ExpD.Apply_e> v379 = { NULL,Apply_e(v382) };
exp_t v383[] = { (exp_t)&v378,&v379 };
struct Exp<datatype ExpD.Apply_e> v377 = { NULL,Apply_e(v383) };
exp_t v384[] = { (exp_t)&v376,&v377 };
struct Exp<datatype ExpD.Apply_e> v375 = { NULL,Apply_e(v384) };
struct Exp<datatype ExpD.Lambda_e> v373 = { NULL,Lambda_e(v374,&v375) };
struct Exp<datatype ExpD.Set_e> v385 = { NULL,Set_e("cdaar",0,0,&v373) };
const char ?v387[] = { "g14791480" };
struct Exp<datatype ExpD.Var_e> v389 = { NULL,Var_e("cdr",0,0) };
struct Exp<datatype ExpD.Var_e> v391 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v393 = { NULL,Var_e("cdr",0,0) };
struct Exp<datatype ExpD.Var_e> v394 = { NULL,Var_e("g14791480",0,0) };
exp_t v395[] = { (exp_t)&v393,&v394 };
struct Exp<datatype ExpD.Apply_e> v392 = { NULL,Apply_e(v395) };
exp_t v396[] = { (exp_t)&v391,&v392 };
struct Exp<datatype ExpD.Apply_e> v390 = { NULL,Apply_e(v396) };
exp_t v397[] = { (exp_t)&v389,&v390 };
struct Exp<datatype ExpD.Apply_e> v388 = { NULL,Apply_e(v397) };
struct Exp<datatype ExpD.Lambda_e> v386 = { NULL,Lambda_e(v387,&v388) };
struct Exp<datatype ExpD.Set_e> v398 = { NULL,Set_e("cdadr",0,0,&v386) };
const char ?v400[] = { "g14811482" };
struct Exp<datatype ExpD.Var_e> v402 = { NULL,Var_e("cdr",0,0) };
struct Exp<datatype ExpD.Var_e> v404 = { NULL,Var_e("cdr",0,0) };
struct Exp<datatype ExpD.Var_e> v406 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v407 = { NULL,Var_e("g14811482",0,0) };
exp_t v408[] = { (exp_t)&v406,&v407 };
struct Exp<datatype ExpD.Apply_e> v405 = { NULL,Apply_e(v408) };
exp_t v409[] = { (exp_t)&v404,&v405 };
struct Exp<datatype ExpD.Apply_e> v403 = { NULL,Apply_e(v409) };
exp_t v410[] = { (exp_t)&v402,&v403 };
struct Exp<datatype ExpD.Apply_e> v401 = { NULL,Apply_e(v410) };
struct Exp<datatype ExpD.Lambda_e> v399 = { NULL,Lambda_e(v400,&v401) };
struct Exp<datatype ExpD.Set_e> v411 = { NULL,Set_e("cddar",0,0,&v399) };
const char ?v413[] = { "g14831484" };
struct Exp<datatype ExpD.Var_e> v415 = { NULL,Var_e("cdr",0,0) };
struct Exp<datatype ExpD.Var_e> v417 = { NULL,Var_e("cdr",0,0) };
struct Exp<datatype ExpD.Var_e> v419 = { NULL,Var_e("cdr",0,0) };
struct Exp<datatype ExpD.Var_e> v420 = { NULL,Var_e("g14831484",0,0) };
exp_t v421[] = { (exp_t)&v419,&v420 };
struct Exp<datatype ExpD.Apply_e> v418 = { NULL,Apply_e(v421) };
exp_t v422[] = { (exp_t)&v417,&v418 };
struct Exp<datatype ExpD.Apply_e> v416 = { NULL,Apply_e(v422) };
exp_t v423[] = { (exp_t)&v415,&v416 };
struct Exp<datatype ExpD.Apply_e> v414 = { NULL,Apply_e(v423) };
struct Exp<datatype ExpD.Lambda_e> v412 = { NULL,Lambda_e(v413,&v414) };
struct Exp<datatype ExpD.Set_e> v424 = { NULL,Set_e("cdddr",0,0,&v412) };
const char ?v426[] = { "g14851486" };
struct Exp<datatype ExpD.Var_e> v428 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v430 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v432 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v434 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v435 = { NULL,Var_e("g14851486",0,0) };
exp_t v436[] = { (exp_t)&v434,&v435 };
struct Exp<datatype ExpD.Apply_e> v433 = { NULL,Apply_e(v436) };
exp_t v437[] = { (exp_t)&v432,&v433 };
struct Exp<datatype ExpD.Apply_e> v431 = { NULL,Apply_e(v437) };
exp_t v438[] = { (exp_t)&v430,&v431 };
struct Exp<datatype ExpD.Apply_e> v429 = { NULL,Apply_e(v438) };
exp_t v439[] = { (exp_t)&v428,&v429 };
struct Exp<datatype ExpD.Apply_e> v427 = { NULL,Apply_e(v439) };
struct Exp<datatype ExpD.Lambda_e> v425 = { NULL,Lambda_e(v426,&v427) };
struct Exp<datatype ExpD.Set_e> v440 = { NULL,Set_e("caaaar",0,0,&v425) };
const char ?v442[] = { "g14871488" };
struct Exp<datatype ExpD.Var_e> v444 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v446 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v448 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v450 = { NULL,Var_e("cdr",0,0) };
struct Exp<datatype ExpD.Var_e> v451 = { NULL,Var_e("g14871488",0,0) };
exp_t v452[] = { (exp_t)&v450,&v451 };
struct Exp<datatype ExpD.Apply_e> v449 = { NULL,Apply_e(v452) };
exp_t v453[] = { (exp_t)&v448,&v449 };
struct Exp<datatype ExpD.Apply_e> v447 = { NULL,Apply_e(v453) };
exp_t v454[] = { (exp_t)&v446,&v447 };
struct Exp<datatype ExpD.Apply_e> v445 = { NULL,Apply_e(v454) };
exp_t v455[] = { (exp_t)&v444,&v445 };
struct Exp<datatype ExpD.Apply_e> v443 = { NULL,Apply_e(v455) };
struct Exp<datatype ExpD.Lambda_e> v441 = { NULL,Lambda_e(v442,&v443) };
struct Exp<datatype ExpD.Set_e> v456 = { NULL,Set_e("caaadr",0,0,&v441) };
const char ?v458[] = { "g14891490" };
struct Exp<datatype ExpD.Var_e> v460 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v462 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v464 = { NULL,Var_e("cdr",0,0) };
struct Exp<datatype ExpD.Var_e> v466 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v467 = { NULL,Var_e("g14891490",0,0) };
exp_t v468[] = { (exp_t)&v466,&v467 };
struct Exp<datatype ExpD.Apply_e> v465 = { NULL,Apply_e(v468) };
exp_t v469[] = { (exp_t)&v464,&v465 };
struct Exp<datatype ExpD.Apply_e> v463 = { NULL,Apply_e(v469) };
exp_t v470[] = { (exp_t)&v462,&v463 };
struct Exp<datatype ExpD.Apply_e> v461 = { NULL,Apply_e(v470) };
exp_t v471[] = { (exp_t)&v460,&v461 };
struct Exp<datatype ExpD.Apply_e> v459 = { NULL,Apply_e(v471) };
struct Exp<datatype ExpD.Lambda_e> v457 = { NULL,Lambda_e(v458,&v459) };
struct Exp<datatype ExpD.Set_e> v472 = { NULL,Set_e("caadar",0,0,&v457) };
const char ?v474[] = { "g14911492" };
struct Exp<datatype ExpD.Var_e> v476 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v478 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v480 = { NULL,Var_e("cdr",0,0) };
struct Exp<datatype ExpD.Var_e> v482 = { NULL,Var_e("cdr",0,0) };
struct Exp<datatype ExpD.Var_e> v483 = { NULL,Var_e("g14911492",0,0) };
exp_t v484[] = { (exp_t)&v482,&v483 };
struct Exp<datatype ExpD.Apply_e> v481 = { NULL,Apply_e(v484) };
exp_t v485[] = { (exp_t)&v480,&v481 };
struct Exp<datatype ExpD.Apply_e> v479 = { NULL,Apply_e(v485) };
exp_t v486[] = { (exp_t)&v478,&v479 };
struct Exp<datatype ExpD.Apply_e> v477 = { NULL,Apply_e(v486) };
exp_t v487[] = { (exp_t)&v476,&v477 };
struct Exp<datatype ExpD.Apply_e> v475 = { NULL,Apply_e(v487) };
struct Exp<datatype ExpD.Lambda_e> v473 = { NULL,Lambda_e(v474,&v475) };
struct Exp<datatype ExpD.Set_e> v488 = { NULL,Set_e("caaddr",0,0,&v473) };
const char ?v490[] = { "g14931494" };
struct Exp<datatype ExpD.Var_e> v492 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v494 = { NULL,Var_e("cdr",0,0) };
struct Exp<datatype ExpD.Var_e> v496 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v498 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v499 = { NULL,Var_e("g14931494",0,0) };
exp_t v500[] = { (exp_t)&v498,&v499 };
struct Exp<datatype ExpD.Apply_e> v497 = { NULL,Apply_e(v500) };
exp_t v501[] = { (exp_t)&v496,&v497 };
struct Exp<datatype ExpD.Apply_e> v495 = { NULL,Apply_e(v501) };
exp_t v502[] = { (exp_t)&v494,&v495 };
struct Exp<datatype ExpD.Apply_e> v493 = { NULL,Apply_e(v502) };
exp_t v503[] = { (exp_t)&v492,&v493 };
struct Exp<datatype ExpD.Apply_e> v491 = { NULL,Apply_e(v503) };
struct Exp<datatype ExpD.Lambda_e> v489 = { NULL,Lambda_e(v490,&v491) };
struct Exp<datatype ExpD.Set_e> v504 = { NULL,Set_e("cadaar",0,0,&v489) };
const char ?v506[] = { "g14951496" };
struct Exp<datatype ExpD.Var_e> v508 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v510 = { NULL,Var_e("cdr",0,0) };
struct Exp<datatype ExpD.Var_e> v512 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v514 = { NULL,Var_e("cdr",0,0) };
struct Exp<datatype ExpD.Var_e> v515 = { NULL,Var_e("g14951496",0,0) };
exp_t v516[] = { (exp_t)&v514,&v515 };
struct Exp<datatype ExpD.Apply_e> v513 = { NULL,Apply_e(v516) };
exp_t v517[] = { (exp_t)&v512,&v513 };
struct Exp<datatype ExpD.Apply_e> v511 = { NULL,Apply_e(v517) };
exp_t v518[] = { (exp_t)&v510,&v511 };
struct Exp<datatype ExpD.Apply_e> v509 = { NULL,Apply_e(v518) };
exp_t v519[] = { (exp_t)&v508,&v509 };
struct Exp<datatype ExpD.Apply_e> v507 = { NULL,Apply_e(v519) };
struct Exp<datatype ExpD.Lambda_e> v505 = { NULL,Lambda_e(v506,&v507) };
struct Exp<datatype ExpD.Set_e> v520 = { NULL,Set_e("cadadr",0,0,&v505) };
const char ?v522[] = { "g14971498" };
struct Exp<datatype ExpD.Var_e> v524 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v526 = { NULL,Var_e("cdr",0,0) };
struct Exp<datatype ExpD.Var_e> v528 = { NULL,Var_e("cdr",0,0) };
struct Exp<datatype ExpD.Var_e> v530 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v531 = { NULL,Var_e("g14971498",0,0) };
exp_t v532[] = { (exp_t)&v530,&v531 };
struct Exp<datatype ExpD.Apply_e> v529 = { NULL,Apply_e(v532) };
exp_t v533[] = { (exp_t)&v528,&v529 };
struct Exp<datatype ExpD.Apply_e> v527 = { NULL,Apply_e(v533) };
exp_t v534[] = { (exp_t)&v526,&v527 };
struct Exp<datatype ExpD.Apply_e> v525 = { NULL,Apply_e(v534) };
exp_t v535[] = { (exp_t)&v524,&v525 };
struct Exp<datatype ExpD.Apply_e> v523 = { NULL,Apply_e(v535) };
struct Exp<datatype ExpD.Lambda_e> v521 = { NULL,Lambda_e(v522,&v523) };
struct Exp<datatype ExpD.Set_e> v536 = { NULL,Set_e("caddar",0,0,&v521) };
const char ?v538[] = { "g14991500" };
struct Exp<datatype ExpD.Var_e> v540 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v542 = { NULL,Var_e("cdr",0,0) };
struct Exp<datatype ExpD.Var_e> v544 = { NULL,Var_e("cdr",0,0) };
struct Exp<datatype ExpD.Var_e> v546 = { NULL,Var_e("cdr",0,0) };
struct Exp<datatype ExpD.Var_e> v547 = { NULL,Var_e("g14991500",0,0) };
exp_t v548[] = { (exp_t)&v546,&v547 };
struct Exp<datatype ExpD.Apply_e> v545 = { NULL,Apply_e(v548) };
exp_t v549[] = { (exp_t)&v544,&v545 };
struct Exp<datatype ExpD.Apply_e> v543 = { NULL,Apply_e(v549) };
exp_t v550[] = { (exp_t)&v542,&v543 };
struct Exp<datatype ExpD.Apply_e> v541 = { NULL,Apply_e(v550) };
exp_t v551[] = { (exp_t)&v540,&v541 };
struct Exp<datatype ExpD.Apply_e> v539 = { NULL,Apply_e(v551) };
struct Exp<datatype ExpD.Lambda_e> v537 = { NULL,Lambda_e(v538,&v539) };
struct Exp<datatype ExpD.Set_e> v552 = { NULL,Set_e("cadddr",0,0,&v537) };
const char ?v554[] = { "g15011502" };
struct Exp<datatype ExpD.Var_e> v556 = { NULL,Var_e("cdr",0,0) };
struct Exp<datatype ExpD.Var_e> v558 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v560 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v562 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v563 = { NULL,Var_e("g15011502",0,0) };
exp_t v564[] = { (exp_t)&v562,&v563 };
struct Exp<datatype ExpD.Apply_e> v561 = { NULL,Apply_e(v564) };
exp_t v565[] = { (exp_t)&v560,&v561 };
struct Exp<datatype ExpD.Apply_e> v559 = { NULL,Apply_e(v565) };
exp_t v566[] = { (exp_t)&v558,&v559 };
struct Exp<datatype ExpD.Apply_e> v557 = { NULL,Apply_e(v566) };
exp_t v567[] = { (exp_t)&v556,&v557 };
struct Exp<datatype ExpD.Apply_e> v555 = { NULL,Apply_e(v567) };
struct Exp<datatype ExpD.Lambda_e> v553 = { NULL,Lambda_e(v554,&v555) };
struct Exp<datatype ExpD.Set_e> v568 = { NULL,Set_e("cdaaar",0,0,&v553) };
const char ?v570[] = { "g15031504" };
struct Exp<datatype ExpD.Var_e> v572 = { NULL,Var_e("cdr",0,0) };
struct Exp<datatype ExpD.Var_e> v574 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v576 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v578 = { NULL,Var_e("cdr",0,0) };
struct Exp<datatype ExpD.Var_e> v579 = { NULL,Var_e("g15031504",0,0) };
exp_t v580[] = { (exp_t)&v578,&v579 };
struct Exp<datatype ExpD.Apply_e> v577 = { NULL,Apply_e(v580) };
exp_t v581[] = { (exp_t)&v576,&v577 };
struct Exp<datatype ExpD.Apply_e> v575 = { NULL,Apply_e(v581) };
exp_t v582[] = { (exp_t)&v574,&v575 };
struct Exp<datatype ExpD.Apply_e> v573 = { NULL,Apply_e(v582) };
exp_t v583[] = { (exp_t)&v572,&v573 };
struct Exp<datatype ExpD.Apply_e> v571 = { NULL,Apply_e(v583) };
struct Exp<datatype ExpD.Lambda_e> v569 = { NULL,Lambda_e(v570,&v571) };
struct Exp<datatype ExpD.Set_e> v584 = { NULL,Set_e("cdaadr",0,0,&v569) };
const char ?v586[] = { "g15051506" };
struct Exp<datatype ExpD.Var_e> v588 = { NULL,Var_e("cdr",0,0) };
struct Exp<datatype ExpD.Var_e> v590 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v592 = { NULL,Var_e("cdr",0,0) };
struct Exp<datatype ExpD.Var_e> v594 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v595 = { NULL,Var_e("g15051506",0,0) };
exp_t v596[] = { (exp_t)&v594,&v595 };
struct Exp<datatype ExpD.Apply_e> v593 = { NULL,Apply_e(v596) };
exp_t v597[] = { (exp_t)&v592,&v593 };
struct Exp<datatype ExpD.Apply_e> v591 = { NULL,Apply_e(v597) };
exp_t v598[] = { (exp_t)&v590,&v591 };
struct Exp<datatype ExpD.Apply_e> v589 = { NULL,Apply_e(v598) };
exp_t v599[] = { (exp_t)&v588,&v589 };
struct Exp<datatype ExpD.Apply_e> v587 = { NULL,Apply_e(v599) };
struct Exp<datatype ExpD.Lambda_e> v585 = { NULL,Lambda_e(v586,&v587) };
struct Exp<datatype ExpD.Set_e> v600 = { NULL,Set_e("cdadar",0,0,&v585) };
const char ?v602[] = { "g15071508" };
struct Exp<datatype ExpD.Var_e> v604 = { NULL,Var_e("cdr",0,0) };
struct Exp<datatype ExpD.Var_e> v606 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v608 = { NULL,Var_e("cdr",0,0) };
struct Exp<datatype ExpD.Var_e> v610 = { NULL,Var_e("cdr",0,0) };
struct Exp<datatype ExpD.Var_e> v611 = { NULL,Var_e("g15071508",0,0) };
exp_t v612[] = { (exp_t)&v610,&v611 };
struct Exp<datatype ExpD.Apply_e> v609 = { NULL,Apply_e(v612) };
exp_t v613[] = { (exp_t)&v608,&v609 };
struct Exp<datatype ExpD.Apply_e> v607 = { NULL,Apply_e(v613) };
exp_t v614[] = { (exp_t)&v606,&v607 };
struct Exp<datatype ExpD.Apply_e> v605 = { NULL,Apply_e(v614) };
exp_t v615[] = { (exp_t)&v604,&v605 };
struct Exp<datatype ExpD.Apply_e> v603 = { NULL,Apply_e(v615) };
struct Exp<datatype ExpD.Lambda_e> v601 = { NULL,Lambda_e(v602,&v603) };
struct Exp<datatype ExpD.Set_e> v616 = { NULL,Set_e("cdaddr",0,0,&v601) };
const char ?v618[] = { "g15091510" };
struct Exp<datatype ExpD.Var_e> v620 = { NULL,Var_e("cdr",0,0) };
struct Exp<datatype ExpD.Var_e> v622 = { NULL,Var_e("cdr",0,0) };
struct Exp<datatype ExpD.Var_e> v624 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v626 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v627 = { NULL,Var_e("g15091510",0,0) };
exp_t v628[] = { (exp_t)&v626,&v627 };
struct Exp<datatype ExpD.Apply_e> v625 = { NULL,Apply_e(v628) };
exp_t v629[] = { (exp_t)&v624,&v625 };
struct Exp<datatype ExpD.Apply_e> v623 = { NULL,Apply_e(v629) };
exp_t v630[] = { (exp_t)&v622,&v623 };
struct Exp<datatype ExpD.Apply_e> v621 = { NULL,Apply_e(v630) };
exp_t v631[] = { (exp_t)&v620,&v621 };
struct Exp<datatype ExpD.Apply_e> v619 = { NULL,Apply_e(v631) };
struct Exp<datatype ExpD.Lambda_e> v617 = { NULL,Lambda_e(v618,&v619) };
struct Exp<datatype ExpD.Set_e> v632 = { NULL,Set_e("cddaar",0,0,&v617) };
const char ?v634[] = { "g15111512" };
struct Exp<datatype ExpD.Var_e> v636 = { NULL,Var_e("cdr",0,0) };
struct Exp<datatype ExpD.Var_e> v638 = { NULL,Var_e("cdr",0,0) };
struct Exp<datatype ExpD.Var_e> v640 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v642 = { NULL,Var_e("cdr",0,0) };
struct Exp<datatype ExpD.Var_e> v643 = { NULL,Var_e("g15111512",0,0) };
exp_t v644[] = { (exp_t)&v642,&v643 };
struct Exp<datatype ExpD.Apply_e> v641 = { NULL,Apply_e(v644) };
exp_t v645[] = { (exp_t)&v640,&v641 };
struct Exp<datatype ExpD.Apply_e> v639 = { NULL,Apply_e(v645) };
exp_t v646[] = { (exp_t)&v638,&v639 };
struct Exp<datatype ExpD.Apply_e> v637 = { NULL,Apply_e(v646) };
exp_t v647[] = { (exp_t)&v636,&v637 };
struct Exp<datatype ExpD.Apply_e> v635 = { NULL,Apply_e(v647) };
struct Exp<datatype ExpD.Lambda_e> v633 = { NULL,Lambda_e(v634,&v635) };
struct Exp<datatype ExpD.Set_e> v648 = { NULL,Set_e("cddadr",0,0,&v633) };
const char ?v650[] = { "g15131514" };
struct Exp<datatype ExpD.Var_e> v652 = { NULL,Var_e("cdr",0,0) };
struct Exp<datatype ExpD.Var_e> v654 = { NULL,Var_e("cdr",0,0) };
struct Exp<datatype ExpD.Var_e> v656 = { NULL,Var_e("cdr",0,0) };
struct Exp<datatype ExpD.Var_e> v658 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v659 = { NULL,Var_e("g15131514",0,0) };
exp_t v660[] = { (exp_t)&v658,&v659 };
struct Exp<datatype ExpD.Apply_e> v657 = { NULL,Apply_e(v660) };
exp_t v661[] = { (exp_t)&v656,&v657 };
struct Exp<datatype ExpD.Apply_e> v655 = { NULL,Apply_e(v661) };
exp_t v662[] = { (exp_t)&v654,&v655 };
struct Exp<datatype ExpD.Apply_e> v653 = { NULL,Apply_e(v662) };
exp_t v663[] = { (exp_t)&v652,&v653 };
struct Exp<datatype ExpD.Apply_e> v651 = { NULL,Apply_e(v663) };
struct Exp<datatype ExpD.Lambda_e> v649 = { NULL,Lambda_e(v650,&v651) };
struct Exp<datatype ExpD.Set_e> v664 = { NULL,Set_e("cdddar",0,0,&v649) };
const char ?v666[] = { "g15151516" };
struct Exp<datatype ExpD.Var_e> v668 = { NULL,Var_e("cdr",0,0) };
struct Exp<datatype ExpD.Var_e> v670 = { NULL,Var_e("cdr",0,0) };
struct Exp<datatype ExpD.Var_e> v672 = { NULL,Var_e("cdr",0,0) };
struct Exp<datatype ExpD.Var_e> v674 = { NULL,Var_e("cdr",0,0) };
struct Exp<datatype ExpD.Var_e> v675 = { NULL,Var_e("g15151516",0,0) };
exp_t v676[] = { (exp_t)&v674,&v675 };
struct Exp<datatype ExpD.Apply_e> v673 = { NULL,Apply_e(v676) };
exp_t v677[] = { (exp_t)&v672,&v673 };
struct Exp<datatype ExpD.Apply_e> v671 = { NULL,Apply_e(v677) };
exp_t v678[] = { (exp_t)&v670,&v671 };
struct Exp<datatype ExpD.Apply_e> v669 = { NULL,Apply_e(v678) };
exp_t v679[] = { (exp_t)&v668,&v669 };
struct Exp<datatype ExpD.Apply_e> v667 = { NULL,Apply_e(v679) };
struct Exp<datatype ExpD.Lambda_e> v665 = { NULL,Lambda_e(v666,&v667) };
struct Exp<datatype ExpD.Set_e> v680 = { NULL,Set_e("cddddr",0,0,&v665) };
const char ?v682[] = { "g15171518" };
struct Exp<datatype ExpD.Var_e> v684 = { NULL,Var_e("pair?",0,0) };
struct Exp<datatype ExpD.Var_e> v685 = { NULL,Var_e("g15171518",0,0) };
exp_t v686[] = { (exp_t)&v684,&v685 };
struct Exp<datatype ExpD.Apply_e> v683 = { NULL,Apply_e(v686) };
struct Exp<datatype ExpD.Var_e> v688 = { NULL,Var_e("list?",0,0) };
struct Exp<datatype ExpD.Var_e> v690 = { NULL,Var_e("cdr",0,0) };
struct Exp<datatype ExpD.Var_e> v691 = { NULL,Var_e("g15171518",0,0) };
exp_t v692[] = { (exp_t)&v690,&v691 };
struct Exp<datatype ExpD.Apply_e> v689 = { NULL,Apply_e(v692) };
exp_t v693[] = { (exp_t)&v688,&v689 };
struct Exp<datatype ExpD.Apply_e> v687 = { NULL,Apply_e(v693) };
struct Exp<datatype ExpD.Var_e> v695 = { NULL,Var_e("null?",0,0) };
struct Exp<datatype ExpD.Var_e> v696 = { NULL,Var_e("g15171518",0,0) };
exp_t v697[] = { (exp_t)&v695,&v696 };
struct Exp<datatype ExpD.Apply_e> v694 = { NULL,Apply_e(v697) };
struct Exp<datatype ExpD.If_e> v698 = { NULL,If_e(&v683,&v687,&v694) };
struct Exp<datatype ExpD.Lambda_e> v681 = { NULL,Lambda_e(v682,&v698) };
struct Exp<datatype ExpD.Set_e> v699 = { NULL,Set_e("list?",0,0,&v681) };
const char ?v701[] = {  };
struct Exp<datatype ExpD.Var_e> v702 = { NULL,Var_e("g15191520",0,0) };
struct Exp<datatype ExpD.VarArgsLambda_e> v700 = { NULL,VarArgsLambda_e(v701,"g15191520",&v702) };
struct Exp<datatype ExpD.Set_e> v703 = { NULL,Set_e("list",0,0,&v700) };
const char ?v705[] = { "g15211522" };
struct Exp<datatype ExpD.Var_e> v707 = { NULL,Var_e("null?",0,0) };
struct Exp<datatype ExpD.Var_e> v708 = { NULL,Var_e("g15211522",0,0) };
exp_t v709[] = { (exp_t)&v707,&v708 };
struct Exp<datatype ExpD.Apply_e> v706 = { NULL,Apply_e(v709) };
datatype Const.Int_l v710 = Int_l(0);
struct Value<datatype ValueD.Const_v> v711 = { NULL,Const_v(&v710) };
struct Exp<datatype ExpD.Const_e> v712 = { NULL,Const_e(&v711) };
struct Exp<datatype ExpD.Var_e> v714 = { NULL,Var_e("+",0,0) };
datatype Const.Int_l v715 = Int_l(1);
struct Value<datatype ValueD.Const_v> v716 = { NULL,Const_v(&v715) };
struct Exp<datatype ExpD.Const_e> v717 = { NULL,Const_e(&v716) };
struct Exp<datatype ExpD.Var_e> v719 = { NULL,Var_e("length",0,0) };
struct Exp<datatype ExpD.Var_e> v721 = { NULL,Var_e("cdr",0,0) };
struct Exp<datatype ExpD.Var_e> v722 = { NULL,Var_e("g15211522",0,0) };
exp_t v723[] = { (exp_t)&v721,&v722 };
struct Exp<datatype ExpD.Apply_e> v720 = { NULL,Apply_e(v723) };
exp_t v724[] = { (exp_t)&v719,&v720 };
struct Exp<datatype ExpD.Apply_e> v718 = { NULL,Apply_e(v724) };
exp_t v725[] = { (exp_t)&v714,&v717,&v718 };
struct Exp<datatype ExpD.Apply_e> v713 = { NULL,Apply_e(v725) };
struct Exp<datatype ExpD.If_e> v726 = { NULL,If_e(&v706,&v712,&v713) };
struct Exp<datatype ExpD.Lambda_e> v704 = { NULL,Lambda_e(v705,&v726) };
struct Exp<datatype ExpD.Set_e> v727 = { NULL,Set_e("length",0,0,&v704) };
const char ?v729[] = {  };
const char ?v732[] = { "g15241530" };
struct Exp<datatype ExpD.Var_e> v734 = { NULL,Var_e("=",0,0) };
struct Exp<datatype ExpD.Var_e> v735 = { NULL,Var_e("g15241530",0,0) };
datatype Const.Int_l v736 = Int_l(0);
struct Value<datatype ValueD.Const_v> v737 = { NULL,Const_v(&v736) };
struct Exp<datatype ExpD.Const_e> v738 = { NULL,Const_e(&v737) };
exp_t v739[] = { (exp_t)&v734,&v735,&v738 };
struct Exp<datatype ExpD.Apply_e> v733 = { NULL,Apply_e(v739) };
struct Exp<datatype ExpD.Var_e> v741 = { NULL,Var_e("=",0,0) };
struct Exp<datatype ExpD.Var_e> v742 = { NULL,Var_e("g15241530",0,0) };
datatype Const.Int_l v743 = Int_l(1);
struct Value<datatype ValueD.Const_v> v744 = { NULL,Const_v(&v743) };
struct Exp<datatype ExpD.Const_e> v745 = { NULL,Const_e(&v744) };
exp_t v746[] = { (exp_t)&v741,&v742,&v745 };
struct Exp<datatype ExpD.Apply_e> v740 = { NULL,Apply_e(v746) };
struct Exp<datatype ExpD.Var_e> v748 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v749 = { NULL,Var_e("g15231529",0,0) };
exp_t v750[] = { (exp_t)&v748,&v749 };
struct Exp<datatype ExpD.Apply_e> v747 = { NULL,Apply_e(v750) };
struct Exp<datatype ExpD.Var_e> v752 = { NULL,Var_e("=",0,0) };
struct Exp<datatype ExpD.Var_e> v753 = { NULL,Var_e("g15241530",0,0) };
datatype Const.Int_l v754 = Int_l(2);
struct Value<datatype ValueD.Const_v> v755 = { NULL,Const_v(&v754) };
struct Exp<datatype ExpD.Const_e> v756 = { NULL,Const_e(&v755) };
exp_t v757[] = { (exp_t)&v752,&v753,&v756 };
struct Exp<datatype ExpD.Apply_e> v751 = { NULL,Apply_e(v757) };
const char ?v760[] = { "g15251531" };
const char ?v763[] = { "g15261532" };
const char ?v766[] = {  };
const char ?v769[] = { "g15271533" };
const char ?v772[] = { "t1535" };
struct Exp<datatype ExpD.Var_e> v774 = { NULL,Var_e("g15271533",0,0) };
struct Exp<datatype ExpD.Var_e> v775 = { NULL,Var_e("g15251531",0,0) };
exp_t v776[] = { (exp_t)&v774,&v775 };
struct Exp<datatype ExpD.Apply_e> v773 = { NULL,Apply_e(v776) };
struct Exp<datatype ExpD.Lambda_e> v771 = { NULL,Lambda_e(v772,&v773) };
const char ?v778[] = { "g15281534" };
struct Exp<datatype ExpD.Var_e> v780 = { NULL,Var_e("null?",0,0) };
struct Exp<datatype ExpD.Var_e> v781 = { NULL,Var_e("g15281534",0,0) };
exp_t v782[] = { (exp_t)&v780,&v781 };
struct Exp<datatype ExpD.Apply_e> v779 = { NULL,Apply_e(v782) };
struct Exp<datatype ExpD.Var_e> v783 = { NULL,Var_e("g15261532",0,0) };
struct Exp<datatype ExpD.Var_e> v785 = { NULL,Var_e("cons",0,0) };
struct Exp<datatype ExpD.Var_e> v787 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v788 = { NULL,Var_e("g15281534",0,0) };
exp_t v789[] = { (exp_t)&v787,&v788 };
struct Exp<datatype ExpD.Apply_e> v786 = { NULL,Apply_e(v789) };
struct Exp<datatype ExpD.Var_e> v791 = { NULL,Var_e("g15271533",0,0) };
struct Exp<datatype ExpD.Var_e> v793 = { NULL,Var_e("cdr",0,0) };
struct Exp<datatype ExpD.Var_e> v794 = { NULL,Var_e("g15281534",0,0) };
exp_t v795[] = { (exp_t)&v793,&v794 };
struct Exp<datatype ExpD.Apply_e> v792 = { NULL,Apply_e(v795) };
exp_t v796[] = { (exp_t)&v791,&v792 };
struct Exp<datatype ExpD.Apply_e> v790 = { NULL,Apply_e(v796) };
exp_t v797[] = { (exp_t)&v785,&v786,&v790 };
struct Exp<datatype ExpD.Apply_e> v784 = { NULL,Apply_e(v797) };
struct Exp<datatype ExpD.If_e> v798 = { NULL,If_e(&v779,&v783,&v784) };
struct Exp<datatype ExpD.Lambda_e> v777 = { NULL,Lambda_e(v778,&v798) };
struct Exp<datatype ExpD.Set_e> v799 = { NULL,Set_e("g15271533",0,0,&v777) };
exp_t v800[] = { (exp_t)&v771,&v799 };
struct Exp<datatype ExpD.Apply_e> v770 = { NULL,Apply_e(v800) };
struct Exp<datatype ExpD.Lambda_e> v768 = { NULL,Lambda_e(v769,&v770) };
datatype Const.Undef_l v801 = Undef_l;
struct Value<datatype ValueD.Const_v> v802 = { NULL,Const_v(&v801) };
struct Exp<datatype ExpD.Const_e> v803 = { NULL,Const_e(&v802) };
exp_t v804[] = { (exp_t)&v768,&v803 };
struct Exp<datatype ExpD.Apply_e> v767 = { NULL,Apply_e(v804) };
struct Exp<datatype ExpD.Lambda_e> v765 = { NULL,Lambda_e(v766,&v767) };
exp_t v805[] = { (exp_t)&v765 };
struct Exp<datatype ExpD.Apply_e> v764 = { NULL,Apply_e(v805) };
struct Exp<datatype ExpD.Lambda_e> v762 = { NULL,Lambda_e(v763,&v764) };
struct Exp<datatype ExpD.Var_e> v807 = { NULL,Var_e("cadr",0,0) };
struct Exp<datatype ExpD.Var_e> v808 = { NULL,Var_e("g15231529",0,0) };
exp_t v809[] = { (exp_t)&v807,&v808 };
struct Exp<datatype ExpD.Apply_e> v806 = { NULL,Apply_e(v809) };
exp_t v810[] = { (exp_t)&v762,&v806 };
struct Exp<datatype ExpD.Apply_e> v761 = { NULL,Apply_e(v810) };
struct Exp<datatype ExpD.Lambda_e> v759 = { NULL,Lambda_e(v760,&v761) };
struct Exp<datatype ExpD.Var_e> v812 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v813 = { NULL,Var_e("g15231529",0,0) };
exp_t v814[] = { (exp_t)&v812,&v813 };
struct Exp<datatype ExpD.Apply_e> v811 = { NULL,Apply_e(v814) };
exp_t v815[] = { (exp_t)&v759,&v811 };
struct Exp<datatype ExpD.Apply_e> v758 = { NULL,Apply_e(v815) };
struct Exp<datatype ExpD.Var_e> v817 = { NULL,Var_e(">",0,0) };
struct Exp<datatype ExpD.Var_e> v818 = { NULL,Var_e("g15241530",0,0) };
datatype Const.Int_l v819 = Int_l(2);
struct Value<datatype ValueD.Const_v> v820 = { NULL,Const_v(&v819) };
struct Exp<datatype ExpD.Const_e> v821 = { NULL,Const_e(&v820) };
exp_t v822[] = { (exp_t)&v817,&v818,&v821 };
struct Exp<datatype ExpD.Apply_e> v816 = { NULL,Apply_e(v822) };
struct Exp<datatype ExpD.Var_e> v824 = { NULL,Var_e("apply",0,0) };
struct Exp<datatype ExpD.Var_e> v825 = { NULL,Var_e("append",0,0) };
struct Exp<datatype ExpD.Var_e> v827 = { NULL,Var_e("append",0,0) };
struct Exp<datatype ExpD.Var_e> v829 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v830 = { NULL,Var_e("g15231529",0,0) };
exp_t v831[] = { (exp_t)&v829,&v830 };
struct Exp<datatype ExpD.Apply_e> v828 = { NULL,Apply_e(v831) };
struct Exp<datatype ExpD.Var_e> v833 = { NULL,Var_e("cadr",0,0) };
struct Exp<datatype ExpD.Var_e> v834 = { NULL,Var_e("g15231529",0,0) };
exp_t v835[] = { (exp_t)&v833,&v834 };
struct Exp<datatype ExpD.Apply_e> v832 = { NULL,Apply_e(v835) };
exp_t v836[] = { (exp_t)&v827,&v828,&v832 };
struct Exp<datatype ExpD.Apply_e> v826 = { NULL,Apply_e(v836) };
struct Exp<datatype ExpD.Var_e> v838 = { NULL,Var_e("cddr",0,0) };
struct Exp<datatype ExpD.Var_e> v839 = { NULL,Var_e("g15231529",0,0) };
exp_t v840[] = { (exp_t)&v838,&v839 };
struct Exp<datatype ExpD.Apply_e> v837 = { NULL,Apply_e(v840) };
exp_t v841[] = { (exp_t)&v824,&v825,&v826,&v837 };
struct Exp<datatype ExpD.Apply_e> v823 = { NULL,Apply_e(v841) };
datatype Const.Undef_l v842 = Undef_l;
struct Value<datatype ValueD.Const_v> v843 = { NULL,Const_v(&v842) };
struct Exp<datatype ExpD.Const_e> v844 = { NULL,Const_e(&v843) };
struct Exp<datatype ExpD.If_e> v845 = { NULL,If_e(&v816,&v823,&v844) };
struct Exp<datatype ExpD.If_e> v846 = { NULL,If_e(&v751,&v758,&v845) };
struct Exp<datatype ExpD.If_e> v847 = { NULL,If_e(&v740,&v747,&v846) };
struct Exp<datatype ExpD.If_e> v848 = { NULL,If_e(&v733,NULL,&v847) };
struct Exp<datatype ExpD.Lambda_e> v731 = { NULL,Lambda_e(v732,&v848) };
struct Exp<datatype ExpD.Var_e> v850 = { NULL,Var_e("length",0,0) };
struct Exp<datatype ExpD.Var_e> v851 = { NULL,Var_e("g15231529",0,0) };
exp_t v852[] = { (exp_t)&v850,&v851 };
struct Exp<datatype ExpD.Apply_e> v849 = { NULL,Apply_e(v852) };
exp_t v853[] = { (exp_t)&v731,&v849 };
struct Exp<datatype ExpD.Apply_e> v730 = { NULL,Apply_e(v853) };
struct Exp<datatype ExpD.VarArgsLambda_e> v728 = { NULL,VarArgsLambda_e(v729,"g15231529",&v730) };
struct Exp<datatype ExpD.Set_e> v854 = { NULL,Set_e("append",0,0,&v728) };
const char ?v856[] = { "g15361537" };
struct Exp<datatype ExpD.Var_e> v858 = { NULL,Var_e("null?",0,0) };
struct Exp<datatype ExpD.Var_e> v859 = { NULL,Var_e("g15361537",0,0) };
exp_t v860[] = { (exp_t)&v858,&v859 };
struct Exp<datatype ExpD.Apply_e> v857 = { NULL,Apply_e(v860) };
struct Exp<datatype ExpD.Var_e> v861 = { NULL,Var_e("g15361537",0,0) };
struct Exp<datatype ExpD.Var_e> v863 = { NULL,Var_e("append",0,0) };
struct Exp<datatype ExpD.Var_e> v865 = { NULL,Var_e("reverse",0,0) };
struct Exp<datatype ExpD.Var_e> v867 = { NULL,Var_e("cdr",0,0) };
struct Exp<datatype ExpD.Var_e> v868 = { NULL,Var_e("g15361537",0,0) };
exp_t v869[] = { (exp_t)&v867,&v868 };
struct Exp<datatype ExpD.Apply_e> v866 = { NULL,Apply_e(v869) };
exp_t v870[] = { (exp_t)&v865,&v866 };
struct Exp<datatype ExpD.Apply_e> v864 = { NULL,Apply_e(v870) };
struct Exp<datatype ExpD.Var_e> v872 = { NULL,Var_e("list",0,0) };
struct Exp<datatype ExpD.Var_e> v874 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v875 = { NULL,Var_e("g15361537",0,0) };
exp_t v876[] = { (exp_t)&v874,&v875 };
struct Exp<datatype ExpD.Apply_e> v873 = { NULL,Apply_e(v876) };
exp_t v877[] = { (exp_t)&v872,&v873 };
struct Exp<datatype ExpD.Apply_e> v871 = { NULL,Apply_e(v877) };
exp_t v878[] = { (exp_t)&v863,&v864,&v871 };
struct Exp<datatype ExpD.Apply_e> v862 = { NULL,Apply_e(v878) };
struct Exp<datatype ExpD.If_e> v879 = { NULL,If_e(&v857,&v861,&v862) };
struct Exp<datatype ExpD.Lambda_e> v855 = { NULL,Lambda_e(v856,&v879) };
struct Exp<datatype ExpD.Set_e> v880 = { NULL,Set_e("reverse",0,0,&v855) };
const char ?v882[] = { "g15381540","g15391541" };
struct Exp<datatype ExpD.Var_e> v884 = { NULL,Var_e("zero?",0,0) };
struct Exp<datatype ExpD.Var_e> v885 = { NULL,Var_e("g15391541",0,0) };
exp_t v886[] = { (exp_t)&v884,&v885 };
struct Exp<datatype ExpD.Apply_e> v883 = { NULL,Apply_e(v886) };
struct Exp<datatype ExpD.Var_e> v887 = { NULL,Var_e("g15381540",0,0) };
struct Exp<datatype ExpD.Var_e> v889 = { NULL,Var_e("list-tail",0,0) };
struct Exp<datatype ExpD.Var_e> v891 = { NULL,Var_e("cdr",0,0) };
struct Exp<datatype ExpD.Var_e> v892 = { NULL,Var_e("g15381540",0,0) };
exp_t v893[] = { (exp_t)&v891,&v892 };
struct Exp<datatype ExpD.Apply_e> v890 = { NULL,Apply_e(v893) };
struct Exp<datatype ExpD.Var_e> v895 = { NULL,Var_e("-",0,0) };
struct Exp<datatype ExpD.Var_e> v896 = { NULL,Var_e("g15391541",0,0) };
datatype Const.Int_l v897 = Int_l(1);
struct Value<datatype ValueD.Const_v> v898 = { NULL,Const_v(&v897) };
struct Exp<datatype ExpD.Const_e> v899 = { NULL,Const_e(&v898) };
exp_t v900[] = { (exp_t)&v895,&v896,&v899 };
struct Exp<datatype ExpD.Apply_e> v894 = { NULL,Apply_e(v900) };
exp_t v901[] = { (exp_t)&v889,&v890,&v894 };
struct Exp<datatype ExpD.Apply_e> v888 = { NULL,Apply_e(v901) };
struct Exp<datatype ExpD.If_e> v902 = { NULL,If_e(&v883,&v887,&v888) };
struct Exp<datatype ExpD.Lambda_e> v881 = { NULL,Lambda_e(v882,&v902) };
struct Exp<datatype ExpD.Set_e> v903 = { NULL,Set_e("list-tail",0,0,&v881) };
const char ?v905[] = { "g15421544","g15431545" };
struct Exp<datatype ExpD.Var_e> v907 = { NULL,Var_e("zero?",0,0) };
struct Exp<datatype ExpD.Var_e> v908 = { NULL,Var_e("g15431545",0,0) };
exp_t v909[] = { (exp_t)&v907,&v908 };
struct Exp<datatype ExpD.Apply_e> v906 = { NULL,Apply_e(v909) };
struct Exp<datatype ExpD.Var_e> v911 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v912 = { NULL,Var_e("g15421544",0,0) };
exp_t v913[] = { (exp_t)&v911,&v912 };
struct Exp<datatype ExpD.Apply_e> v910 = { NULL,Apply_e(v913) };
struct Exp<datatype ExpD.Var_e> v915 = { NULL,Var_e("list-tail",0,0) };
struct Exp<datatype ExpD.Var_e> v917 = { NULL,Var_e("cdr",0,0) };
struct Exp<datatype ExpD.Var_e> v918 = { NULL,Var_e("g15421544",0,0) };
exp_t v919[] = { (exp_t)&v917,&v918 };
struct Exp<datatype ExpD.Apply_e> v916 = { NULL,Apply_e(v919) };
struct Exp<datatype ExpD.Var_e> v921 = { NULL,Var_e("-",0,0) };
struct Exp<datatype ExpD.Var_e> v922 = { NULL,Var_e("g15431545",0,0) };
datatype Const.Int_l v923 = Int_l(1);
struct Value<datatype ValueD.Const_v> v924 = { NULL,Const_v(&v923) };
struct Exp<datatype ExpD.Const_e> v925 = { NULL,Const_e(&v924) };
exp_t v926[] = { (exp_t)&v921,&v922,&v925 };
struct Exp<datatype ExpD.Apply_e> v920 = { NULL,Apply_e(v926) };
exp_t v927[] = { (exp_t)&v915,&v916,&v920 };
struct Exp<datatype ExpD.Apply_e> v914 = { NULL,Apply_e(v927) };
struct Exp<datatype ExpD.If_e> v928 = { NULL,If_e(&v906,&v910,&v914) };
struct Exp<datatype ExpD.Lambda_e> v904 = { NULL,Lambda_e(v905,&v928) };
struct Exp<datatype ExpD.Set_e> v929 = { NULL,Set_e("list-ref",0,0,&v904) };
const char ?v931[] = { "g15461548","g15471549" };
struct Exp<datatype ExpD.Var_e> v933 = { NULL,Var_e("null?",0,0) };
struct Exp<datatype ExpD.Var_e> v934 = { NULL,Var_e("g15471549",0,0) };
exp_t v935[] = { (exp_t)&v933,&v934 };
struct Exp<datatype ExpD.Apply_e> v932 = { NULL,Apply_e(v935) };
datatype Const.Bool_l v936 = Bool_l(false);
struct Value<datatype ValueD.Const_v> v937 = { NULL,Const_v(&v936) };
struct Exp<datatype ExpD.Const_e> v938 = { NULL,Const_e(&v937) };
struct Exp<datatype ExpD.Var_e> v940 = { NULL,Var_e("eq?",0,0) };
struct Exp<datatype ExpD.Var_e> v941 = { NULL,Var_e("g15461548",0,0) };
struct Exp<datatype ExpD.Var_e> v943 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v944 = { NULL,Var_e("g15471549",0,0) };
exp_t v945[] = { (exp_t)&v943,&v944 };
struct Exp<datatype ExpD.Apply_e> v942 = { NULL,Apply_e(v945) };
exp_t v946[] = { (exp_t)&v940,&v941,&v942 };
struct Exp<datatype ExpD.Apply_e> v939 = { NULL,Apply_e(v946) };
struct Exp<datatype ExpD.Var_e> v947 = { NULL,Var_e("g15471549",0,0) };
struct Exp<datatype ExpD.Var_e> v949 = { NULL,Var_e("memq",0,0) };
struct Exp<datatype ExpD.Var_e> v950 = { NULL,Var_e("g15461548",0,0) };
struct Exp<datatype ExpD.Var_e> v952 = { NULL,Var_e("cdr",0,0) };
struct Exp<datatype ExpD.Var_e> v953 = { NULL,Var_e("g15471549",0,0) };
exp_t v954[] = { (exp_t)&v952,&v953 };
struct Exp<datatype ExpD.Apply_e> v951 = { NULL,Apply_e(v954) };
exp_t v955[] = { (exp_t)&v949,&v950,&v951 };
struct Exp<datatype ExpD.Apply_e> v948 = { NULL,Apply_e(v955) };
struct Exp<datatype ExpD.If_e> v956 = { NULL,If_e(&v939,&v947,&v948) };
struct Exp<datatype ExpD.If_e> v957 = { NULL,If_e(&v932,&v938,&v956) };
struct Exp<datatype ExpD.Lambda_e> v930 = { NULL,Lambda_e(v931,&v957) };
struct Exp<datatype ExpD.Set_e> v958 = { NULL,Set_e("memq",0,0,&v930) };
const char ?v960[] = { "g15501552","g15511553" };
struct Exp<datatype ExpD.Var_e> v962 = { NULL,Var_e("null?",0,0) };
struct Exp<datatype ExpD.Var_e> v963 = { NULL,Var_e("g15511553",0,0) };
exp_t v964[] = { (exp_t)&v962,&v963 };
struct Exp<datatype ExpD.Apply_e> v961 = { NULL,Apply_e(v964) };
datatype Const.Bool_l v965 = Bool_l(false);
struct Value<datatype ValueD.Const_v> v966 = { NULL,Const_v(&v965) };
struct Exp<datatype ExpD.Const_e> v967 = { NULL,Const_e(&v966) };
struct Exp<datatype ExpD.Var_e> v969 = { NULL,Var_e("eqv?",0,0) };
struct Exp<datatype ExpD.Var_e> v970 = { NULL,Var_e("g15501552",0,0) };
struct Exp<datatype ExpD.Var_e> v972 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v973 = { NULL,Var_e("g15511553",0,0) };
exp_t v974[] = { (exp_t)&v972,&v973 };
struct Exp<datatype ExpD.Apply_e> v971 = { NULL,Apply_e(v974) };
exp_t v975[] = { (exp_t)&v969,&v970,&v971 };
struct Exp<datatype ExpD.Apply_e> v968 = { NULL,Apply_e(v975) };
struct Exp<datatype ExpD.Var_e> v976 = { NULL,Var_e("g15511553",0,0) };
struct Exp<datatype ExpD.Var_e> v978 = { NULL,Var_e("memv",0,0) };
struct Exp<datatype ExpD.Var_e> v979 = { NULL,Var_e("g15501552",0,0) };
struct Exp<datatype ExpD.Var_e> v981 = { NULL,Var_e("cdr",0,0) };
struct Exp<datatype ExpD.Var_e> v982 = { NULL,Var_e("g15511553",0,0) };
exp_t v983[] = { (exp_t)&v981,&v982 };
struct Exp<datatype ExpD.Apply_e> v980 = { NULL,Apply_e(v983) };
exp_t v984[] = { (exp_t)&v978,&v979,&v980 };
struct Exp<datatype ExpD.Apply_e> v977 = { NULL,Apply_e(v984) };
struct Exp<datatype ExpD.If_e> v985 = { NULL,If_e(&v968,&v976,&v977) };
struct Exp<datatype ExpD.If_e> v986 = { NULL,If_e(&v961,&v967,&v985) };
struct Exp<datatype ExpD.Lambda_e> v959 = { NULL,Lambda_e(v960,&v986) };
struct Exp<datatype ExpD.Set_e> v987 = { NULL,Set_e("memv",0,0,&v959) };
const char ?v989[] = { "g15541556","g15551557" };
struct Exp<datatype ExpD.Var_e> v991 = { NULL,Var_e("null?",0,0) };
struct Exp<datatype ExpD.Var_e> v992 = { NULL,Var_e("g15551557",0,0) };
exp_t v993[] = { (exp_t)&v991,&v992 };
struct Exp<datatype ExpD.Apply_e> v990 = { NULL,Apply_e(v993) };
datatype Const.Bool_l v994 = Bool_l(false);
struct Value<datatype ValueD.Const_v> v995 = { NULL,Const_v(&v994) };
struct Exp<datatype ExpD.Const_e> v996 = { NULL,Const_e(&v995) };
struct Exp<datatype ExpD.Var_e> v998 = { NULL,Var_e("equal?",0,0) };
struct Exp<datatype ExpD.Var_e> v999 = { NULL,Var_e("g15541556",0,0) };
struct Exp<datatype ExpD.Var_e> v1001 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v1002 = { NULL,Var_e("g15551557",0,0) };
exp_t v1003[] = { (exp_t)&v1001,&v1002 };
struct Exp<datatype ExpD.Apply_e> v1000 = { NULL,Apply_e(v1003) };
exp_t v1004[] = { (exp_t)&v998,&v999,&v1000 };
struct Exp<datatype ExpD.Apply_e> v997 = { NULL,Apply_e(v1004) };
struct Exp<datatype ExpD.Var_e> v1005 = { NULL,Var_e("g15551557",0,0) };
struct Exp<datatype ExpD.Var_e> v1007 = { NULL,Var_e("member",0,0) };
struct Exp<datatype ExpD.Var_e> v1008 = { NULL,Var_e("g15541556",0,0) };
struct Exp<datatype ExpD.Var_e> v1010 = { NULL,Var_e("cdr",0,0) };
struct Exp<datatype ExpD.Var_e> v1011 = { NULL,Var_e("g15551557",0,0) };
exp_t v1012[] = { (exp_t)&v1010,&v1011 };
struct Exp<datatype ExpD.Apply_e> v1009 = { NULL,Apply_e(v1012) };
exp_t v1013[] = { (exp_t)&v1007,&v1008,&v1009 };
struct Exp<datatype ExpD.Apply_e> v1006 = { NULL,Apply_e(v1013) };
struct Exp<datatype ExpD.If_e> v1014 = { NULL,If_e(&v997,&v1005,&v1006) };
struct Exp<datatype ExpD.If_e> v1015 = { NULL,If_e(&v990,&v996,&v1014) };
struct Exp<datatype ExpD.Lambda_e> v988 = { NULL,Lambda_e(v989,&v1015) };
struct Exp<datatype ExpD.Set_e> v1016 = { NULL,Set_e("member",0,0,&v988) };
const char ?v1018[] = { "g15581560","g15591561" };
struct Exp<datatype ExpD.Var_e> v1020 = { NULL,Var_e("null?",0,0) };
struct Exp<datatype ExpD.Var_e> v1021 = { NULL,Var_e("g15591561",0,0) };
exp_t v1022[] = { (exp_t)&v1020,&v1021 };
struct Exp<datatype ExpD.Apply_e> v1019 = { NULL,Apply_e(v1022) };
datatype Const.Bool_l v1023 = Bool_l(false);
struct Value<datatype ValueD.Const_v> v1024 = { NULL,Const_v(&v1023) };
struct Exp<datatype ExpD.Const_e> v1025 = { NULL,Const_e(&v1024) };
struct Exp<datatype ExpD.Var_e> v1027 = { NULL,Var_e("eq?",0,0) };
struct Exp<datatype ExpD.Var_e> v1028 = { NULL,Var_e("g15581560",0,0) };
struct Exp<datatype ExpD.Var_e> v1030 = { NULL,Var_e("caar",0,0) };
struct Exp<datatype ExpD.Var_e> v1031 = { NULL,Var_e("g15591561",0,0) };
exp_t v1032[] = { (exp_t)&v1030,&v1031 };
struct Exp<datatype ExpD.Apply_e> v1029 = { NULL,Apply_e(v1032) };
exp_t v1033[] = { (exp_t)&v1027,&v1028,&v1029 };
struct Exp<datatype ExpD.Apply_e> v1026 = { NULL,Apply_e(v1033) };
struct Exp<datatype ExpD.Var_e> v1035 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v1036 = { NULL,Var_e("g15591561",0,0) };
exp_t v1037[] = { (exp_t)&v1035,&v1036 };
struct Exp<datatype ExpD.Apply_e> v1034 = { NULL,Apply_e(v1037) };
struct Exp<datatype ExpD.Var_e> v1039 = { NULL,Var_e("assq",0,0) };
struct Exp<datatype ExpD.Var_e> v1040 = { NULL,Var_e("g15581560",0,0) };
struct Exp<datatype ExpD.Var_e> v1042 = { NULL,Var_e("cdr",0,0) };
struct Exp<datatype ExpD.Var_e> v1043 = { NULL,Var_e("g15591561",0,0) };
exp_t v1044[] = { (exp_t)&v1042,&v1043 };
struct Exp<datatype ExpD.Apply_e> v1041 = { NULL,Apply_e(v1044) };
exp_t v1045[] = { (exp_t)&v1039,&v1040,&v1041 };
struct Exp<datatype ExpD.Apply_e> v1038 = { NULL,Apply_e(v1045) };
struct Exp<datatype ExpD.If_e> v1046 = { NULL,If_e(&v1026,&v1034,&v1038) };
struct Exp<datatype ExpD.If_e> v1047 = { NULL,If_e(&v1019,&v1025,&v1046) };
struct Exp<datatype ExpD.Lambda_e> v1017 = { NULL,Lambda_e(v1018,&v1047) };
struct Exp<datatype ExpD.Set_e> v1048 = { NULL,Set_e("assq",0,0,&v1017) };
const char ?v1050[] = { "g15621564","g15631565" };
struct Exp<datatype ExpD.Var_e> v1052 = { NULL,Var_e("null?",0,0) };
struct Exp<datatype ExpD.Var_e> v1053 = { NULL,Var_e("g15631565",0,0) };
exp_t v1054[] = { (exp_t)&v1052,&v1053 };
struct Exp<datatype ExpD.Apply_e> v1051 = { NULL,Apply_e(v1054) };
datatype Const.Bool_l v1055 = Bool_l(false);
struct Value<datatype ValueD.Const_v> v1056 = { NULL,Const_v(&v1055) };
struct Exp<datatype ExpD.Const_e> v1057 = { NULL,Const_e(&v1056) };
struct Exp<datatype ExpD.Var_e> v1059 = { NULL,Var_e("eqv?",0,0) };
struct Exp<datatype ExpD.Var_e> v1060 = { NULL,Var_e("g15621564",0,0) };
struct Exp<datatype ExpD.Var_e> v1062 = { NULL,Var_e("caar",0,0) };
struct Exp<datatype ExpD.Var_e> v1063 = { NULL,Var_e("g15631565",0,0) };
exp_t v1064[] = { (exp_t)&v1062,&v1063 };
struct Exp<datatype ExpD.Apply_e> v1061 = { NULL,Apply_e(v1064) };
exp_t v1065[] = { (exp_t)&v1059,&v1060,&v1061 };
struct Exp<datatype ExpD.Apply_e> v1058 = { NULL,Apply_e(v1065) };
struct Exp<datatype ExpD.Var_e> v1067 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v1068 = { NULL,Var_e("g15631565",0,0) };
exp_t v1069[] = { (exp_t)&v1067,&v1068 };
struct Exp<datatype ExpD.Apply_e> v1066 = { NULL,Apply_e(v1069) };
struct Exp<datatype ExpD.Var_e> v1071 = { NULL,Var_e("assv",0,0) };
struct Exp<datatype ExpD.Var_e> v1072 = { NULL,Var_e("g15621564",0,0) };
struct Exp<datatype ExpD.Var_e> v1074 = { NULL,Var_e("cdr",0,0) };
struct Exp<datatype ExpD.Var_e> v1075 = { NULL,Var_e("g15631565",0,0) };
exp_t v1076[] = { (exp_t)&v1074,&v1075 };
struct Exp<datatype ExpD.Apply_e> v1073 = { NULL,Apply_e(v1076) };
exp_t v1077[] = { (exp_t)&v1071,&v1072,&v1073 };
struct Exp<datatype ExpD.Apply_e> v1070 = { NULL,Apply_e(v1077) };
struct Exp<datatype ExpD.If_e> v1078 = { NULL,If_e(&v1058,&v1066,&v1070) };
struct Exp<datatype ExpD.If_e> v1079 = { NULL,If_e(&v1051,&v1057,&v1078) };
struct Exp<datatype ExpD.Lambda_e> v1049 = { NULL,Lambda_e(v1050,&v1079) };
struct Exp<datatype ExpD.Set_e> v1080 = { NULL,Set_e("assv",0,0,&v1049) };
const char ?v1082[] = { "g15661568","g15671569" };
struct Exp<datatype ExpD.Var_e> v1084 = { NULL,Var_e("null?",0,0) };
struct Exp<datatype ExpD.Var_e> v1085 = { NULL,Var_e("g15671569",0,0) };
exp_t v1086[] = { (exp_t)&v1084,&v1085 };
struct Exp<datatype ExpD.Apply_e> v1083 = { NULL,Apply_e(v1086) };
datatype Const.Bool_l v1087 = Bool_l(false);
struct Value<datatype ValueD.Const_v> v1088 = { NULL,Const_v(&v1087) };
struct Exp<datatype ExpD.Const_e> v1089 = { NULL,Const_e(&v1088) };
struct Exp<datatype ExpD.Var_e> v1091 = { NULL,Var_e("equal?",0,0) };
struct Exp<datatype ExpD.Var_e> v1092 = { NULL,Var_e("g15661568",0,0) };
struct Exp<datatype ExpD.Var_e> v1094 = { NULL,Var_e("caar",0,0) };
struct Exp<datatype ExpD.Var_e> v1095 = { NULL,Var_e("g15671569",0,0) };
exp_t v1096[] = { (exp_t)&v1094,&v1095 };
struct Exp<datatype ExpD.Apply_e> v1093 = { NULL,Apply_e(v1096) };
exp_t v1097[] = { (exp_t)&v1091,&v1092,&v1093 };
struct Exp<datatype ExpD.Apply_e> v1090 = { NULL,Apply_e(v1097) };
struct Exp<datatype ExpD.Var_e> v1099 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v1100 = { NULL,Var_e("g15671569",0,0) };
exp_t v1101[] = { (exp_t)&v1099,&v1100 };
struct Exp<datatype ExpD.Apply_e> v1098 = { NULL,Apply_e(v1101) };
struct Exp<datatype ExpD.Var_e> v1103 = { NULL,Var_e("assoc",0,0) };
struct Exp<datatype ExpD.Var_e> v1104 = { NULL,Var_e("g15661568",0,0) };
struct Exp<datatype ExpD.Var_e> v1106 = { NULL,Var_e("cdr",0,0) };
struct Exp<datatype ExpD.Var_e> v1107 = { NULL,Var_e("g15671569",0,0) };
exp_t v1108[] = { (exp_t)&v1106,&v1107 };
struct Exp<datatype ExpD.Apply_e> v1105 = { NULL,Apply_e(v1108) };
exp_t v1109[] = { (exp_t)&v1103,&v1104,&v1105 };
struct Exp<datatype ExpD.Apply_e> v1102 = { NULL,Apply_e(v1109) };
struct Exp<datatype ExpD.If_e> v1110 = { NULL,If_e(&v1090,&v1098,&v1102) };
struct Exp<datatype ExpD.If_e> v1111 = { NULL,If_e(&v1083,&v1089,&v1110) };
struct Exp<datatype ExpD.Lambda_e> v1081 = { NULL,Lambda_e(v1082,&v1111) };
struct Exp<datatype ExpD.Set_e> v1112 = { NULL,Set_e("assoc",0,0,&v1081) };
const char ?v1114[] = { "g15701575" };
const char ?v1117[] = { "g15711576" };
const char ?v1120[] = { "g15721577" };
const char ?v1123[] = {  };
const char ?v1126[] = { "g15731578" };
const char ?v1129[] = { "t1582" };
const char ?v1132[] = { "t1581" };
struct Exp<datatype ExpD.Var_e> v1133 = { NULL,Var_e("g15721577",0,0) };
struct Exp<datatype ExpD.Lambda_e> v1131 = { NULL,Lambda_e(v1132,&v1133) };
struct Exp<datatype ExpD.Var_e> v1135 = { NULL,Var_e("g15731578",0,0) };
datatype Const.Int_l v1136 = Int_l(0);
struct Value<datatype ValueD.Const_v> v1137 = { NULL,Const_v(&v1136) };
struct Exp<datatype ExpD.Const_e> v1138 = { NULL,Const_e(&v1137) };
exp_t v1139[] = { (exp_t)&v1135,&v1138 };
struct Exp<datatype ExpD.Apply_e> v1134 = { NULL,Apply_e(v1139) };
exp_t v1140[] = { (exp_t)&v1131,&v1134 };
struct Exp<datatype ExpD.Apply_e> v1130 = { NULL,Apply_e(v1140) };
struct Exp<datatype ExpD.Lambda_e> v1128 = { NULL,Lambda_e(v1129,&v1130) };
const char ?v1142[] = { "g15741579" };
struct Exp<datatype ExpD.Var_e> v1144 = { NULL,Var_e(">=",0,0) };
struct Exp<datatype ExpD.Var_e> v1145 = { NULL,Var_e("g15741579",0,0) };
struct Exp<datatype ExpD.Var_e> v1146 = { NULL,Var_e("g15711576",0,0) };
exp_t v1147[] = { (exp_t)&v1144,&v1145,&v1146 };
struct Exp<datatype ExpD.Apply_e> v1143 = { NULL,Apply_e(v1147) };
const char ?v1150[] = { "t1580" };
struct Exp<datatype ExpD.Var_e> v1152 = { NULL,Var_e("g15731578",0,0) };
struct Exp<datatype ExpD.Var_e> v1154 = { NULL,Var_e("+",0,0) };
struct Exp<datatype ExpD.Var_e> v1155 = { NULL,Var_e("g15741579",0,0) };
datatype Const.Int_l v1156 = Int_l(1);
struct Value<datatype ValueD.Const_v> v1157 = { NULL,Const_v(&v1156) };
struct Exp<datatype ExpD.Const_e> v1158 = { NULL,Const_e(&v1157) };
exp_t v1159[] = { (exp_t)&v1154,&v1155,&v1158 };
struct Exp<datatype ExpD.Apply_e> v1153 = { NULL,Apply_e(v1159) };
exp_t v1160[] = { (exp_t)&v1152,&v1153 };
struct Exp<datatype ExpD.Apply_e> v1151 = { NULL,Apply_e(v1160) };
struct Exp<datatype ExpD.Lambda_e> v1149 = { NULL,Lambda_e(v1150,&v1151) };
struct Exp<datatype ExpD.Var_e> v1162 = { NULL,Var_e("string-set!",0,0) };
struct Exp<datatype ExpD.Var_e> v1163 = { NULL,Var_e("g15721577",0,0) };
struct Exp<datatype ExpD.Var_e> v1164 = { NULL,Var_e("g15741579",0,0) };
struct Exp<datatype ExpD.Var_e> v1166 = { NULL,Var_e("string-ref",0,0) };
struct Exp<datatype ExpD.Var_e> v1167 = { NULL,Var_e("g15701575",0,0) };
struct Exp<datatype ExpD.Var_e> v1168 = { NULL,Var_e("g15741579",0,0) };
exp_t v1169[] = { (exp_t)&v1166,&v1167,&v1168 };
struct Exp<datatype ExpD.Apply_e> v1165 = { NULL,Apply_e(v1169) };
exp_t v1170[] = { (exp_t)&v1162,&v1163,&v1164,&v1165 };
struct Exp<datatype ExpD.Apply_e> v1161 = { NULL,Apply_e(v1170) };
exp_t v1171[] = { (exp_t)&v1149,&v1161 };
struct Exp<datatype ExpD.Apply_e> v1148 = { NULL,Apply_e(v1171) };
struct Exp<datatype ExpD.If_e> v1172 = { NULL,If_e(&v1143,NULL,&v1148) };
struct Exp<datatype ExpD.Lambda_e> v1141 = { NULL,Lambda_e(v1142,&v1172) };
struct Exp<datatype ExpD.Set_e> v1173 = { NULL,Set_e("g15731578",0,0,&v1141) };
exp_t v1174[] = { (exp_t)&v1128,&v1173 };
struct Exp<datatype ExpD.Apply_e> v1127 = { NULL,Apply_e(v1174) };
struct Exp<datatype ExpD.Lambda_e> v1125 = { NULL,Lambda_e(v1126,&v1127) };
datatype Const.Undef_l v1175 = Undef_l;
struct Value<datatype ValueD.Const_v> v1176 = { NULL,Const_v(&v1175) };
struct Exp<datatype ExpD.Const_e> v1177 = { NULL,Const_e(&v1176) };
exp_t v1178[] = { (exp_t)&v1125,&v1177 };
struct Exp<datatype ExpD.Apply_e> v1124 = { NULL,Apply_e(v1178) };
struct Exp<datatype ExpD.Lambda_e> v1122 = { NULL,Lambda_e(v1123,&v1124) };
exp_t v1179[] = { (exp_t)&v1122 };
struct Exp<datatype ExpD.Apply_e> v1121 = { NULL,Apply_e(v1179) };
struct Exp<datatype ExpD.Lambda_e> v1119 = { NULL,Lambda_e(v1120,&v1121) };
struct Exp<datatype ExpD.Var_e> v1181 = { NULL,Var_e("make-string",0,0) };
struct Exp<datatype ExpD.Var_e> v1182 = { NULL,Var_e("g15711576",0,0) };
datatype Const.Char_l v1183 = Char_l(32);
struct Value<datatype ValueD.Const_v> v1184 = { NULL,Const_v(&v1183) };
struct Exp<datatype ExpD.Const_e> v1185 = { NULL,Const_e(&v1184) };
exp_t v1186[] = { (exp_t)&v1181,&v1182,&v1185 };
struct Exp<datatype ExpD.Apply_e> v1180 = { NULL,Apply_e(v1186) };
exp_t v1187[] = { (exp_t)&v1119,&v1180 };
struct Exp<datatype ExpD.Apply_e> v1118 = { NULL,Apply_e(v1187) };
struct Exp<datatype ExpD.Lambda_e> v1116 = { NULL,Lambda_e(v1117,&v1118) };
struct Exp<datatype ExpD.Var_e> v1189 = { NULL,Var_e("string-length",0,0) };
struct Exp<datatype ExpD.Var_e> v1190 = { NULL,Var_e("g15701575",0,0) };
exp_t v1191[] = { (exp_t)&v1189,&v1190 };
struct Exp<datatype ExpD.Apply_e> v1188 = { NULL,Apply_e(v1191) };
exp_t v1192[] = { (exp_t)&v1116,&v1188 };
struct Exp<datatype ExpD.Apply_e> v1115 = { NULL,Apply_e(v1192) };
struct Exp<datatype ExpD.Lambda_e> v1113 = { NULL,Lambda_e(v1114,&v1115) };
struct Exp<datatype ExpD.Set_e> v1193 = { NULL,Set_e("string-copy",0,0,&v1113) };
const char ?v1195[] = {  };
const char ?v1198[] = { "g15841596" };
struct Exp<datatype ExpD.Var_e> v1200 = { NULL,Var_e("=",0,0) };
struct Exp<datatype ExpD.Var_e> v1201 = { NULL,Var_e("g15841596",0,0) };
datatype Const.Int_l v1202 = Int_l(0);
struct Value<datatype ValueD.Const_v> v1203 = { NULL,Const_v(&v1202) };
struct Exp<datatype ExpD.Const_e> v1204 = { NULL,Const_e(&v1203) };
exp_t v1205[] = { (exp_t)&v1200,&v1201,&v1204 };
struct Exp<datatype ExpD.Apply_e> v1199 = { NULL,Apply_e(v1205) };
struct Exp<datatype ExpD.Var_e> v1207 = { NULL,Var_e("make-string",0,0) };
datatype Const.Int_l v1208 = Int_l(0);
struct Value<datatype ValueD.Const_v> v1209 = { NULL,Const_v(&v1208) };
struct Exp<datatype ExpD.Const_e> v1210 = { NULL,Const_e(&v1209) };
datatype Const.Char_l v1211 = Char_l(32);
struct Value<datatype ValueD.Const_v> v1212 = { NULL,Const_v(&v1211) };
struct Exp<datatype ExpD.Const_e> v1213 = { NULL,Const_e(&v1212) };
exp_t v1214[] = { (exp_t)&v1207,&v1210,&v1213 };
struct Exp<datatype ExpD.Apply_e> v1206 = { NULL,Apply_e(v1214) };
struct Exp<datatype ExpD.Var_e> v1216 = { NULL,Var_e("=",0,0) };
struct Exp<datatype ExpD.Var_e> v1217 = { NULL,Var_e("g15841596",0,0) };
datatype Const.Int_l v1218 = Int_l(1);
struct Value<datatype ValueD.Const_v> v1219 = { NULL,Const_v(&v1218) };
struct Exp<datatype ExpD.Const_e> v1220 = { NULL,Const_e(&v1219) };
exp_t v1221[] = { (exp_t)&v1216,&v1217,&v1220 };
struct Exp<datatype ExpD.Apply_e> v1215 = { NULL,Apply_e(v1221) };
struct Exp<datatype ExpD.Var_e> v1223 = { NULL,Var_e("string-copy",0,0) };
struct Exp<datatype ExpD.Var_e> v1225 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v1226 = { NULL,Var_e("g15831595",0,0) };
exp_t v1227[] = { (exp_t)&v1225,&v1226 };
struct Exp<datatype ExpD.Apply_e> v1224 = { NULL,Apply_e(v1227) };
exp_t v1228[] = { (exp_t)&v1223,&v1224 };
struct Exp<datatype ExpD.Apply_e> v1222 = { NULL,Apply_e(v1228) };
struct Exp<datatype ExpD.Var_e> v1230 = { NULL,Var_e("=",0,0) };
struct Exp<datatype ExpD.Var_e> v1231 = { NULL,Var_e("g15841596",0,0) };
datatype Const.Int_l v1232 = Int_l(2);
struct Value<datatype ValueD.Const_v> v1233 = { NULL,Const_v(&v1232) };
struct Exp<datatype ExpD.Const_e> v1234 = { NULL,Const_e(&v1233) };
exp_t v1235[] = { (exp_t)&v1230,&v1231,&v1234 };
struct Exp<datatype ExpD.Apply_e> v1229 = { NULL,Apply_e(v1235) };
const char ?v1238[] = { "g15851597" };
const char ?v1241[] = { "g15861598" };
const char ?v1244[] = { "g15871599" };
const char ?v1247[] = { "g15881600" };
const char ?v1250[] = { "g15891601" };
const char ?v1253[] = { "g15901602" };
const char ?v1256[] = {  };
const char ?v1259[] = { "g15911603","g15921604" };
const char ?v1262[] = { "t1611" };
const char ?v1265[] = { "t1612" };
const char ?v1268[] = { "t1609" };
const char ?v1271[] = { "t1610" };
struct Exp<datatype ExpD.Var_e> v1272 = { NULL,Var_e("g15901602",0,0) };
struct Exp<datatype ExpD.Lambda_e> v1270 = { NULL,Lambda_e(v1271,&v1272) };
struct Exp<datatype ExpD.Var_e> v1274 = { NULL,Var_e("g15921604",0,0) };
datatype Const.Int_l v1275 = Int_l(0);
struct Value<datatype ValueD.Const_v> v1276 = { NULL,Const_v(&v1275) };
struct Exp<datatype ExpD.Const_e> v1277 = { NULL,Const_e(&v1276) };
exp_t v1278[] = { (exp_t)&v1274,&v1277 };
struct Exp<datatype ExpD.Apply_e> v1273 = { NULL,Apply_e(v1278) };
exp_t v1279[] = { (exp_t)&v1270,&v1273 };
struct Exp<datatype ExpD.Apply_e> v1269 = { NULL,Apply_e(v1279) };
struct Exp<datatype ExpD.Lambda_e> v1267 = { NULL,Lambda_e(v1268,&v1269) };
struct Exp<datatype ExpD.Var_e> v1281 = { NULL,Var_e("g15911603",0,0) };
datatype Const.Int_l v1282 = Int_l(0);
struct Value<datatype ValueD.Const_v> v1283 = { NULL,Const_v(&v1282) };
struct Exp<datatype ExpD.Const_e> v1284 = { NULL,Const_e(&v1283) };
exp_t v1285[] = { (exp_t)&v1281,&v1284 };
struct Exp<datatype ExpD.Apply_e> v1280 = { NULL,Apply_e(v1285) };
exp_t v1286[] = { (exp_t)&v1267,&v1280 };
struct Exp<datatype ExpD.Apply_e> v1266 = { NULL,Apply_e(v1286) };
struct Exp<datatype ExpD.Lambda_e> v1264 = { NULL,Lambda_e(v1265,&v1266) };
const char ?v1288[] = { "g15941607" };
struct Exp<datatype ExpD.Var_e> v1290 = { NULL,Var_e(">=",0,0) };
struct Exp<datatype ExpD.Var_e> v1291 = { NULL,Var_e("g15941607",0,0) };
struct Exp<datatype ExpD.Var_e> v1292 = { NULL,Var_e("g15881600",0,0) };
exp_t v1293[] = { (exp_t)&v1290,&v1291,&v1292 };
struct Exp<datatype ExpD.Apply_e> v1289 = { NULL,Apply_e(v1293) };
const char ?v1296[] = { "t1608" };
struct Exp<datatype ExpD.Var_e> v1298 = { NULL,Var_e("g15921604",0,0) };
struct Exp<datatype ExpD.Var_e> v1300 = { NULL,Var_e("+",0,0) };
struct Exp<datatype ExpD.Var_e> v1301 = { NULL,Var_e("g15941607",0,0) };
datatype Const.Int_l v1302 = Int_l(1);
struct Value<datatype ValueD.Const_v> v1303 = { NULL,Const_v(&v1302) };
struct Exp<datatype ExpD.Const_e> v1304 = { NULL,Const_e(&v1303) };
exp_t v1305[] = { (exp_t)&v1300,&v1301,&v1304 };
struct Exp<datatype ExpD.Apply_e> v1299 = { NULL,Apply_e(v1305) };
exp_t v1306[] = { (exp_t)&v1298,&v1299 };
struct Exp<datatype ExpD.Apply_e> v1297 = { NULL,Apply_e(v1306) };
struct Exp<datatype ExpD.Lambda_e> v1295 = { NULL,Lambda_e(v1296,&v1297) };
struct Exp<datatype ExpD.Var_e> v1308 = { NULL,Var_e("string-set!",0,0) };
struct Exp<datatype ExpD.Var_e> v1309 = { NULL,Var_e("g15901602",0,0) };
struct Exp<datatype ExpD.Var_e> v1311 = { NULL,Var_e("+",0,0) };
struct Exp<datatype ExpD.Var_e> v1312 = { NULL,Var_e("g15871599",0,0) };
struct Exp<datatype ExpD.Var_e> v1313 = { NULL,Var_e("g15941607",0,0) };
exp_t v1314[] = { (exp_t)&v1311,&v1312,&v1313 };
struct Exp<datatype ExpD.Apply_e> v1310 = { NULL,Apply_e(v1314) };
struct Exp<datatype ExpD.Var_e> v1316 = { NULL,Var_e("string-ref",0,0) };
struct Exp<datatype ExpD.Var_e> v1317 = { NULL,Var_e("g15861598",0,0) };
struct Exp<datatype ExpD.Var_e> v1318 = { NULL,Var_e("g15941607",0,0) };
exp_t v1319[] = { (exp_t)&v1316,&v1317,&v1318 };
struct Exp<datatype ExpD.Apply_e> v1315 = { NULL,Apply_e(v1319) };
exp_t v1320[] = { (exp_t)&v1308,&v1309,&v1310,&v1315 };
struct Exp<datatype ExpD.Apply_e> v1307 = { NULL,Apply_e(v1320) };
exp_t v1321[] = { (exp_t)&v1295,&v1307 };
struct Exp<datatype ExpD.Apply_e> v1294 = { NULL,Apply_e(v1321) };
struct Exp<datatype ExpD.If_e> v1322 = { NULL,If_e(&v1289,NULL,&v1294) };
struct Exp<datatype ExpD.Lambda_e> v1287 = { NULL,Lambda_e(v1288,&v1322) };
struct Exp<datatype ExpD.Set_e> v1323 = { NULL,Set_e("g15921604",0,0,&v1287) };
exp_t v1324[] = { (exp_t)&v1264,&v1323 };
struct Exp<datatype ExpD.Apply_e> v1263 = { NULL,Apply_e(v1324) };
struct Exp<datatype ExpD.Lambda_e> v1261 = { NULL,Lambda_e(v1262,&v1263) };
const char ?v1326[] = { "g15931605" };
struct Exp<datatype ExpD.Var_e> v1328 = { NULL,Var_e(">=",0,0) };
struct Exp<datatype ExpD.Var_e> v1329 = { NULL,Var_e("g15931605",0,0) };
struct Exp<datatype ExpD.Var_e> v1330 = { NULL,Var_e("g15871599",0,0) };
exp_t v1331[] = { (exp_t)&v1328,&v1329,&v1330 };
struct Exp<datatype ExpD.Apply_e> v1327 = { NULL,Apply_e(v1331) };
const char ?v1334[] = { "t1606" };
struct Exp<datatype ExpD.Var_e> v1336 = { NULL,Var_e("g15911603",0,0) };
struct Exp<datatype ExpD.Var_e> v1338 = { NULL,Var_e("+",0,0) };
struct Exp<datatype ExpD.Var_e> v1339 = { NULL,Var_e("g15931605",0,0) };
datatype Const.Int_l v1340 = Int_l(1);
struct Value<datatype ValueD.Const_v> v1341 = { NULL,Const_v(&v1340) };
struct Exp<datatype ExpD.Const_e> v1342 = { NULL,Const_e(&v1341) };
exp_t v1343[] = { (exp_t)&v1338,&v1339,&v1342 };
struct Exp<datatype ExpD.Apply_e> v1337 = { NULL,Apply_e(v1343) };
exp_t v1344[] = { (exp_t)&v1336,&v1337 };
struct Exp<datatype ExpD.Apply_e> v1335 = { NULL,Apply_e(v1344) };
struct Exp<datatype ExpD.Lambda_e> v1333 = { NULL,Lambda_e(v1334,&v1335) };
struct Exp<datatype ExpD.Var_e> v1346 = { NULL,Var_e("string-set!",0,0) };
struct Exp<datatype ExpD.Var_e> v1347 = { NULL,Var_e("g15901602",0,0) };
struct Exp<datatype ExpD.Var_e> v1348 = { NULL,Var_e("g15931605",0,0) };
struct Exp<datatype ExpD.Var_e> v1350 = { NULL,Var_e("string-ref",0,0) };
struct Exp<datatype ExpD.Var_e> v1351 = { NULL,Var_e("g15851597",0,0) };
struct Exp<datatype ExpD.Var_e> v1352 = { NULL,Var_e("g15931605",0,0) };
exp_t v1353[] = { (exp_t)&v1350,&v1351,&v1352 };
struct Exp<datatype ExpD.Apply_e> v1349 = { NULL,Apply_e(v1353) };
exp_t v1354[] = { (exp_t)&v1346,&v1347,&v1348,&v1349 };
struct Exp<datatype ExpD.Apply_e> v1345 = { NULL,Apply_e(v1354) };
exp_t v1355[] = { (exp_t)&v1333,&v1345 };
struct Exp<datatype ExpD.Apply_e> v1332 = { NULL,Apply_e(v1355) };
struct Exp<datatype ExpD.If_e> v1356 = { NULL,If_e(&v1327,NULL,&v1332) };
struct Exp<datatype ExpD.Lambda_e> v1325 = { NULL,Lambda_e(v1326,&v1356) };
struct Exp<datatype ExpD.Set_e> v1357 = { NULL,Set_e("g15911603",0,0,&v1325) };
exp_t v1358[] = { (exp_t)&v1261,&v1357 };
struct Exp<datatype ExpD.Apply_e> v1260 = { NULL,Apply_e(v1358) };
struct Exp<datatype ExpD.Lambda_e> v1258 = { NULL,Lambda_e(v1259,&v1260) };
datatype Const.Undef_l v1359 = Undef_l;
struct Value<datatype ValueD.Const_v> v1360 = { NULL,Const_v(&v1359) };
struct Exp<datatype ExpD.Const_e> v1361 = { NULL,Const_e(&v1360) };
datatype Const.Undef_l v1362 = Undef_l;
struct Value<datatype ValueD.Const_v> v1363 = { NULL,Const_v(&v1362) };
struct Exp<datatype ExpD.Const_e> v1364 = { NULL,Const_e(&v1363) };
exp_t v1365[] = { (exp_t)&v1258,&v1361,&v1364 };
struct Exp<datatype ExpD.Apply_e> v1257 = { NULL,Apply_e(v1365) };
struct Exp<datatype ExpD.Lambda_e> v1255 = { NULL,Lambda_e(v1256,&v1257) };
exp_t v1366[] = { (exp_t)&v1255 };
struct Exp<datatype ExpD.Apply_e> v1254 = { NULL,Apply_e(v1366) };
struct Exp<datatype ExpD.Lambda_e> v1252 = { NULL,Lambda_e(v1253,&v1254) };
struct Exp<datatype ExpD.Var_e> v1368 = { NULL,Var_e("make-string",0,0) };
struct Exp<datatype ExpD.Var_e> v1369 = { NULL,Var_e("g15891601",0,0) };
datatype Const.Char_l v1370 = Char_l(32);
struct Value<datatype ValueD.Const_v> v1371 = { NULL,Const_v(&v1370) };
struct Exp<datatype ExpD.Const_e> v1372 = { NULL,Const_e(&v1371) };
exp_t v1373[] = { (exp_t)&v1368,&v1369,&v1372 };
struct Exp<datatype ExpD.Apply_e> v1367 = { NULL,Apply_e(v1373) };
exp_t v1374[] = { (exp_t)&v1252,&v1367 };
struct Exp<datatype ExpD.Apply_e> v1251 = { NULL,Apply_e(v1374) };
struct Exp<datatype ExpD.Lambda_e> v1249 = { NULL,Lambda_e(v1250,&v1251) };
struct Exp<datatype ExpD.Var_e> v1376 = { NULL,Var_e("+",0,0) };
struct Exp<datatype ExpD.Var_e> v1377 = { NULL,Var_e("g15871599",0,0) };
struct Exp<datatype ExpD.Var_e> v1378 = { NULL,Var_e("g15881600",0,0) };
exp_t v1379[] = { (exp_t)&v1376,&v1377,&v1378 };
struct Exp<datatype ExpD.Apply_e> v1375 = { NULL,Apply_e(v1379) };
exp_t v1380[] = { (exp_t)&v1249,&v1375 };
struct Exp<datatype ExpD.Apply_e> v1248 = { NULL,Apply_e(v1380) };
struct Exp<datatype ExpD.Lambda_e> v1246 = { NULL,Lambda_e(v1247,&v1248) };
struct Exp<datatype ExpD.Var_e> v1382 = { NULL,Var_e("string-length",0,0) };
struct Exp<datatype ExpD.Var_e> v1383 = { NULL,Var_e("g15861598",0,0) };
exp_t v1384[] = { (exp_t)&v1382,&v1383 };
struct Exp<datatype ExpD.Apply_e> v1381 = { NULL,Apply_e(v1384) };
exp_t v1385[] = { (exp_t)&v1246,&v1381 };
struct Exp<datatype ExpD.Apply_e> v1245 = { NULL,Apply_e(v1385) };
struct Exp<datatype ExpD.Lambda_e> v1243 = { NULL,Lambda_e(v1244,&v1245) };
struct Exp<datatype ExpD.Var_e> v1387 = { NULL,Var_e("string-length",0,0) };
struct Exp<datatype ExpD.Var_e> v1388 = { NULL,Var_e("g15851597",0,0) };
exp_t v1389[] = { (exp_t)&v1387,&v1388 };
struct Exp<datatype ExpD.Apply_e> v1386 = { NULL,Apply_e(v1389) };
exp_t v1390[] = { (exp_t)&v1243,&v1386 };
struct Exp<datatype ExpD.Apply_e> v1242 = { NULL,Apply_e(v1390) };
struct Exp<datatype ExpD.Lambda_e> v1240 = { NULL,Lambda_e(v1241,&v1242) };
struct Exp<datatype ExpD.Var_e> v1392 = { NULL,Var_e("cadr",0,0) };
struct Exp<datatype ExpD.Var_e> v1393 = { NULL,Var_e("g15831595",0,0) };
exp_t v1394[] = { (exp_t)&v1392,&v1393 };
struct Exp<datatype ExpD.Apply_e> v1391 = { NULL,Apply_e(v1394) };
exp_t v1395[] = { (exp_t)&v1240,&v1391 };
struct Exp<datatype ExpD.Apply_e> v1239 = { NULL,Apply_e(v1395) };
struct Exp<datatype ExpD.Lambda_e> v1237 = { NULL,Lambda_e(v1238,&v1239) };
struct Exp<datatype ExpD.Var_e> v1397 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v1398 = { NULL,Var_e("g15831595",0,0) };
exp_t v1399[] = { (exp_t)&v1397,&v1398 };
struct Exp<datatype ExpD.Apply_e> v1396 = { NULL,Apply_e(v1399) };
exp_t v1400[] = { (exp_t)&v1237,&v1396 };
struct Exp<datatype ExpD.Apply_e> v1236 = { NULL,Apply_e(v1400) };
struct Exp<datatype ExpD.Var_e> v1402 = { NULL,Var_e(">",0,0) };
struct Exp<datatype ExpD.Var_e> v1403 = { NULL,Var_e("g15841596",0,0) };
datatype Const.Int_l v1404 = Int_l(2);
struct Value<datatype ValueD.Const_v> v1405 = { NULL,Const_v(&v1404) };
struct Exp<datatype ExpD.Const_e> v1406 = { NULL,Const_e(&v1405) };
exp_t v1407[] = { (exp_t)&v1402,&v1403,&v1406 };
struct Exp<datatype ExpD.Apply_e> v1401 = { NULL,Apply_e(v1407) };
struct Exp<datatype ExpD.Var_e> v1409 = { NULL,Var_e("apply",0,0) };
struct Exp<datatype ExpD.Var_e> v1410 = { NULL,Var_e("string-append",0,0) };
struct Exp<datatype ExpD.Var_e> v1412 = { NULL,Var_e("string-append",0,0) };
struct Exp<datatype ExpD.Var_e> v1414 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v1415 = { NULL,Var_e("g15831595",0,0) };
exp_t v1416[] = { (exp_t)&v1414,&v1415 };
struct Exp<datatype ExpD.Apply_e> v1413 = { NULL,Apply_e(v1416) };
struct Exp<datatype ExpD.Var_e> v1418 = { NULL,Var_e("cadr",0,0) };
struct Exp<datatype ExpD.Var_e> v1419 = { NULL,Var_e("g15831595",0,0) };
exp_t v1420[] = { (exp_t)&v1418,&v1419 };
struct Exp<datatype ExpD.Apply_e> v1417 = { NULL,Apply_e(v1420) };
exp_t v1421[] = { (exp_t)&v1412,&v1413,&v1417 };
struct Exp<datatype ExpD.Apply_e> v1411 = { NULL,Apply_e(v1421) };
struct Exp<datatype ExpD.Var_e> v1423 = { NULL,Var_e("cddr",0,0) };
struct Exp<datatype ExpD.Var_e> v1424 = { NULL,Var_e("g15831595",0,0) };
exp_t v1425[] = { (exp_t)&v1423,&v1424 };
struct Exp<datatype ExpD.Apply_e> v1422 = { NULL,Apply_e(v1425) };
exp_t v1426[] = { (exp_t)&v1409,&v1410,&v1411,&v1422 };
struct Exp<datatype ExpD.Apply_e> v1408 = { NULL,Apply_e(v1426) };
datatype Const.Undef_l v1427 = Undef_l;
struct Value<datatype ValueD.Const_v> v1428 = { NULL,Const_v(&v1427) };
struct Exp<datatype ExpD.Const_e> v1429 = { NULL,Const_e(&v1428) };
struct Exp<datatype ExpD.If_e> v1430 = { NULL,If_e(&v1401,&v1408,&v1429) };
struct Exp<datatype ExpD.If_e> v1431 = { NULL,If_e(&v1229,&v1236,&v1430) };
struct Exp<datatype ExpD.If_e> v1432 = { NULL,If_e(&v1215,&v1222,&v1431) };
struct Exp<datatype ExpD.If_e> v1433 = { NULL,If_e(&v1199,&v1206,&v1432) };
struct Exp<datatype ExpD.Lambda_e> v1197 = { NULL,Lambda_e(v1198,&v1433) };
struct Exp<datatype ExpD.Var_e> v1435 = { NULL,Var_e("length",0,0) };
struct Exp<datatype ExpD.Var_e> v1436 = { NULL,Var_e("g15831595",0,0) };
exp_t v1437[] = { (exp_t)&v1435,&v1436 };
struct Exp<datatype ExpD.Apply_e> v1434 = { NULL,Apply_e(v1437) };
exp_t v1438[] = { (exp_t)&v1197,&v1434 };
struct Exp<datatype ExpD.Apply_e> v1196 = { NULL,Apply_e(v1438) };
struct Exp<datatype ExpD.VarArgsLambda_e> v1194 = { NULL,VarArgsLambda_e(v1195,"g15831595",&v1196) };
struct Exp<datatype ExpD.Set_e> v1439 = { NULL,Set_e("string-append",0,0,&v1194) };
const char ?v1441[] = {  };
struct Exp<datatype ExpD.Var_e> v1443 = { NULL,Var_e("apply",0,0) };
struct Exp<datatype ExpD.Var_e> v1444 = { NULL,Var_e("vector",0,0) };
struct Exp<datatype ExpD.Var_e> v1445 = { NULL,Var_e("g16131614",0,0) };
exp_t v1446[] = { (exp_t)&v1443,&v1444,&v1445 };
struct Exp<datatype ExpD.Apply_e> v1442 = { NULL,Apply_e(v1446) };
struct Exp<datatype ExpD.VarArgsLambda_e> v1440 = { NULL,VarArgsLambda_e(v1441,"g16131614",&v1442) };
struct Exp<datatype ExpD.Set_e> v1447 = { NULL,Set_e("list->vector",0,0,&v1440) };
const char ?v1449[] = {  };
struct Exp<datatype ExpD.Var_e> v1451 = { NULL,Var_e("print",0,0) };
datatype Const.Char_l v1452 = Char_l(10);
struct Value<datatype ValueD.Const_v> v1453 = { NULL,Const_v(&v1452) };
struct Exp<datatype ExpD.Const_e> v1454 = { NULL,Const_e(&v1453) };
exp_t v1455[] = { (exp_t)&v1451,&v1454 };
struct Exp<datatype ExpD.Apply_e> v1450 = { NULL,Apply_e(v1455) };
struct Exp<datatype ExpD.Lambda_e> v1448 = { NULL,Lambda_e(v1449,&v1450) };
struct Exp<datatype ExpD.Set_e> v1456 = { NULL,Set_e("newline",0,0,&v1448) };
const char ?v1458[] = { "g16151616" };
struct Exp<datatype ExpD.Var_e> v1460 = { NULL,Var_e("print",0,0) };
struct Exp<datatype ExpD.Var_e> v1461 = { NULL,Var_e("g16151616",0,0) };
exp_t v1462[] = { (exp_t)&v1460,&v1461 };
struct Exp<datatype ExpD.Apply_e> v1459 = { NULL,Apply_e(v1462) };
struct Exp<datatype ExpD.Lambda_e> v1457 = { NULL,Lambda_e(v1458,&v1459) };
struct Exp<datatype ExpD.Set_e> v1463 = { NULL,Set_e("display",0,0,&v1457) };
const char ?v1465[] = { "g16171618" };
struct Exp<datatype ExpD.Var_e> v1467 = { NULL,Var_e("print",0,0) };
struct Exp<datatype ExpD.Var_e> v1468 = { NULL,Var_e("g16171618",0,0) };
exp_t v1469[] = { (exp_t)&v1467,&v1468 };
struct Exp<datatype ExpD.Apply_e> v1466 = { NULL,Apply_e(v1469) };
struct Exp<datatype ExpD.Lambda_e> v1464 = { NULL,Lambda_e(v1465,&v1466) };
struct Exp<datatype ExpD.Set_e> v1470 = { NULL,Set_e("write",0,0,&v1464) };
const char ?v1472[] = { "g16201637" };
const char ?v1475[] = { "g16211639","g16221640","g16231641" };
const char ?v1478[] = { "t1659" };
const char ?v1481[] = { "t1660" };
const char ?v1484[] = { "t1661" };
const char ?v1487[] = { "g16321652" };
struct Exp<datatype ExpD.Var_e> v1489 = { NULL,Var_e("null?",0,0) };
struct Exp<datatype ExpD.Var_e> v1491 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v1492 = { NULL,Var_e("g16191638",0,0) };
exp_t v1493[] = { (exp_t)&v1491,&v1492 };
struct Exp<datatype ExpD.Apply_e> v1490 = { NULL,Apply_e(v1493) };
exp_t v1494[] = { (exp_t)&v1489,&v1490 };
struct Exp<datatype ExpD.Apply_e> v1488 = { NULL,Apply_e(v1494) };
struct Exp<datatype ExpD.Var_e> v1496 = { NULL,Var_e("=",0,0) };
struct Exp<datatype ExpD.Var_e> v1497 = { NULL,Var_e("g16321652",0,0) };
datatype Const.Int_l v1498 = Int_l(1);
struct Value<datatype ValueD.Const_v> v1499 = { NULL,Const_v(&v1498) };
struct Exp<datatype ExpD.Const_e> v1500 = { NULL,Const_e(&v1499) };
exp_t v1501[] = { (exp_t)&v1496,&v1497,&v1500 };
struct Exp<datatype ExpD.Apply_e> v1495 = { NULL,Apply_e(v1501) };
const char ?v1504[] = { "g16331653" };
const char ?v1507[] = { "t1654" };
struct Exp<datatype ExpD.Var_e> v1508 = { NULL,Var_e("g16331653",0,0) };
struct Exp<datatype ExpD.Lambda_e> v1506 = { NULL,Lambda_e(v1507,&v1508) };
struct Exp<datatype ExpD.Var_e> v1510 = { NULL,Var_e("g16211639",0,0) };
struct Exp<datatype ExpD.Var_e> v1511 = { NULL,Var_e("g16331653",0,0) };
struct Exp<datatype ExpD.Var_e> v1513 = { NULL,Var_e("cdar",0,0) };
struct Exp<datatype ExpD.Var_e> v1514 = { NULL,Var_e("g16191638",0,0) };
exp_t v1515[] = { (exp_t)&v1513,&v1514 };
struct Exp<datatype ExpD.Apply_e> v1512 = { NULL,Apply_e(v1515) };
exp_t v1516[] = { (exp_t)&v1510,&v1511,&v1512 };
struct Exp<datatype ExpD.Apply_e> v1509 = { NULL,Apply_e(v1516) };
exp_t v1517[] = { (exp_t)&v1506,&v1509 };
struct Exp<datatype ExpD.Apply_e> v1505 = { NULL,Apply_e(v1517) };
struct Exp<datatype ExpD.Lambda_e> v1503 = { NULL,Lambda_e(v1504,&v1505) };
struct Exp<datatype ExpD.Var_e> v1519 = { NULL,Var_e("cons",0,0) };
struct Exp<datatype ExpD.Var_e> v1521 = { NULL,Var_e("g16201637",0,0) };
struct Exp<datatype ExpD.Var_e> v1523 = { NULL,Var_e("caar",0,0) };
struct Exp<datatype ExpD.Var_e> v1524 = { NULL,Var_e("g16191638",0,0) };
exp_t v1525[] = { (exp_t)&v1523,&v1524 };
struct Exp<datatype ExpD.Apply_e> v1522 = { NULL,Apply_e(v1525) };
exp_t v1526[] = { (exp_t)&v1521,&v1522 };
struct Exp<datatype ExpD.Apply_e> v1520 = { NULL,Apply_e(v1526) };
exp_t v1527[] = { (exp_t)&v1519,&v1520,NULL };
struct Exp<datatype ExpD.Apply_e> v1518 = { NULL,Apply_e(v1527) };
exp_t v1528[] = { (exp_t)&v1503,&v1518 };
struct Exp<datatype ExpD.Apply_e> v1502 = { NULL,Apply_e(v1528) };
struct Exp<datatype ExpD.Var_e> v1530 = { NULL,Var_e("=",0,0) };
struct Exp<datatype ExpD.Var_e> v1531 = { NULL,Var_e("g16321652",0,0) };
datatype Const.Int_l v1532 = Int_l(2);
struct Value<datatype ValueD.Const_v> v1533 = { NULL,Const_v(&v1532) };
struct Exp<datatype ExpD.Const_e> v1534 = { NULL,Const_e(&v1533) };
exp_t v1535[] = { (exp_t)&v1530,&v1531,&v1534 };
struct Exp<datatype ExpD.Apply_e> v1529 = { NULL,Apply_e(v1535) };
const char ?v1538[] = { "g16341655" };
const char ?v1541[] = { "g16351656" };
const char ?v1544[] = { "g16361657" };
const char ?v1547[] = {  };
const char ?v1550[] = { "t1658" };
struct Exp<datatype ExpD.Var_e> v1551 = { NULL,Var_e("g16361657",0,0) };
struct Exp<datatype ExpD.Lambda_e> v1549 = { NULL,Lambda_e(v1550,&v1551) };
struct Exp<datatype ExpD.Var_e> v1553 = { NULL,Var_e("g16221640",0,0) };
struct Exp<datatype ExpD.Var_e> v1554 = { NULL,Var_e("g16361657",0,0) };
struct Exp<datatype ExpD.Var_e> v1556 = { NULL,Var_e("cdr",0,0) };
struct Exp<datatype ExpD.Var_e> v1557 = { NULL,Var_e("g16341655",0,0) };
exp_t v1558[] = { (exp_t)&v1556,&v1557 };
struct Exp<datatype ExpD.Apply_e> v1555 = { NULL,Apply_e(v1558) };
struct Exp<datatype ExpD.Var_e> v1560 = { NULL,Var_e("cdr",0,0) };
struct Exp<datatype ExpD.Var_e> v1561 = { NULL,Var_e("g16351656",0,0) };
exp_t v1562[] = { (exp_t)&v1560,&v1561 };
struct Exp<datatype ExpD.Apply_e> v1559 = { NULL,Apply_e(v1562) };
exp_t v1563[] = { (exp_t)&v1553,&v1554,&v1555,&v1559 };
struct Exp<datatype ExpD.Apply_e> v1552 = { NULL,Apply_e(v1563) };
exp_t v1564[] = { (exp_t)&v1549,&v1552 };
struct Exp<datatype ExpD.Apply_e> v1548 = { NULL,Apply_e(v1564) };
struct Exp<datatype ExpD.Lambda_e> v1546 = { NULL,Lambda_e(v1547,&v1548) };
exp_t v1565[] = { (exp_t)&v1546 };
struct Exp<datatype ExpD.Apply_e> v1545 = { NULL,Apply_e(v1565) };
struct Exp<datatype ExpD.Lambda_e> v1543 = { NULL,Lambda_e(v1544,&v1545) };
struct Exp<datatype ExpD.Var_e> v1567 = { NULL,Var_e("cons",0,0) };
struct Exp<datatype ExpD.Var_e> v1569 = { NULL,Var_e("g16201637",0,0) };
struct Exp<datatype ExpD.Var_e> v1571 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v1572 = { NULL,Var_e("g16341655",0,0) };
exp_t v1573[] = { (exp_t)&v1571,&v1572 };
struct Exp<datatype ExpD.Apply_e> v1570 = { NULL,Apply_e(v1573) };
struct Exp<datatype ExpD.Var_e> v1575 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v1576 = { NULL,Var_e("g16351656",0,0) };
exp_t v1577[] = { (exp_t)&v1575,&v1576 };
struct Exp<datatype ExpD.Apply_e> v1574 = { NULL,Apply_e(v1577) };
exp_t v1578[] = { (exp_t)&v1569,&v1570,&v1574 };
struct Exp<datatype ExpD.Apply_e> v1568 = { NULL,Apply_e(v1578) };
exp_t v1579[] = { (exp_t)&v1567,&v1568,NULL };
struct Exp<datatype ExpD.Apply_e> v1566 = { NULL,Apply_e(v1579) };
exp_t v1580[] = { (exp_t)&v1543,&v1566 };
struct Exp<datatype ExpD.Apply_e> v1542 = { NULL,Apply_e(v1580) };
struct Exp<datatype ExpD.Lambda_e> v1540 = { NULL,Lambda_e(v1541,&v1542) };
struct Exp<datatype ExpD.Var_e> v1582 = { NULL,Var_e("cadr",0,0) };
struct Exp<datatype ExpD.Var_e> v1583 = { NULL,Var_e("g16191638",0,0) };
exp_t v1584[] = { (exp_t)&v1582,&v1583 };
struct Exp<datatype ExpD.Apply_e> v1581 = { NULL,Apply_e(v1584) };
exp_t v1585[] = { (exp_t)&v1540,&v1581 };
struct Exp<datatype ExpD.Apply_e> v1539 = { NULL,Apply_e(v1585) };
struct Exp<datatype ExpD.Lambda_e> v1537 = { NULL,Lambda_e(v1538,&v1539) };
struct Exp<datatype ExpD.Var_e> v1587 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v1588 = { NULL,Var_e("g16191638",0,0) };
exp_t v1589[] = { (exp_t)&v1587,&v1588 };
struct Exp<datatype ExpD.Apply_e> v1586 = { NULL,Apply_e(v1589) };
exp_t v1590[] = { (exp_t)&v1537,&v1586 };
struct Exp<datatype ExpD.Apply_e> v1536 = { NULL,Apply_e(v1590) };
struct Exp<datatype ExpD.Var_e> v1592 = { NULL,Var_e("g16231641",0,0) };
struct Exp<datatype ExpD.Var_e> v1594 = { NULL,Var_e("list->vector",0,0) };
struct Exp<datatype ExpD.Var_e> v1595 = { NULL,Var_e("g16191638",0,0) };
exp_t v1596[] = { (exp_t)&v1594,&v1595 };
struct Exp<datatype ExpD.Apply_e> v1593 = { NULL,Apply_e(v1596) };
exp_t v1597[] = { (exp_t)&v1592,&v1593 };
struct Exp<datatype ExpD.Apply_e> v1591 = { NULL,Apply_e(v1597) };
struct Exp<datatype ExpD.If_e> v1598 = { NULL,If_e(&v1529,&v1536,&v1591) };
struct Exp<datatype ExpD.If_e> v1599 = { NULL,If_e(&v1495,&v1502,&v1598) };
struct Exp<datatype ExpD.If_e> v1600 = { NULL,If_e(&v1488,NULL,&v1599) };
struct Exp<datatype ExpD.Lambda_e> v1486 = { NULL,Lambda_e(v1487,&v1600) };
struct Exp<datatype ExpD.Var_e> v1602 = { NULL,Var_e("length",0,0) };
struct Exp<datatype ExpD.Var_e> v1603 = { NULL,Var_e("g16191638",0,0) };
exp_t v1604[] = { (exp_t)&v1602,&v1603 };
struct Exp<datatype ExpD.Apply_e> v1601 = { NULL,Apply_e(v1604) };
exp_t v1605[] = { (exp_t)&v1486,&v1601 };
struct Exp<datatype ExpD.Apply_e> v1485 = { NULL,Apply_e(v1605) };
struct Exp<datatype ExpD.Lambda_e> v1483 = { NULL,Lambda_e(v1484,&v1485) };
const char ?v1607[] = { "g16311651" };
struct Exp<datatype ExpD.Var_e> v1609 = { NULL,Var_e("error",0,0) };
datatype Const.String_l v1610 = String_l("unimplemented");
struct Value<datatype ValueD.Const_v> v1611 = { NULL,Const_v(&v1610) };
struct Exp<datatype ExpD.Const_e> v1612 = { NULL,Const_e(&v1611) };
exp_t v1613[] = { (exp_t)&v1609,&v1612 };
struct Exp<datatype ExpD.Apply_e> v1608 = { NULL,Apply_e(v1613) };
struct Exp<datatype ExpD.Lambda_e> v1606 = { NULL,Lambda_e(v1607,&v1608) };
struct Exp<datatype ExpD.Set_e> v1614 = { NULL,Set_e("g16231641",0,0,&v1606) };
exp_t v1615[] = { (exp_t)&v1483,&v1614 };
struct Exp<datatype ExpD.Apply_e> v1482 = { NULL,Apply_e(v1615) };
struct Exp<datatype ExpD.Lambda_e> v1480 = { NULL,Lambda_e(v1481,&v1482) };
const char ?v1617[] = { "g16271646","g16281647","g16291648" };
struct Exp<datatype ExpD.Var_e> v1619 = { NULL,Var_e("null?",0,0) };
struct Exp<datatype ExpD.Var_e> v1620 = { NULL,Var_e("g16281647",0,0) };
exp_t v1621[] = { (exp_t)&v1619,&v1620 };
struct Exp<datatype ExpD.Apply_e> v1618 = { NULL,Apply_e(v1621) };
const char ?v1624[] = { "g16301649" };
const char ?v1627[] = { "t1650" };
struct Exp<datatype ExpD.Var_e> v1629 = { NULL,Var_e("g16221640",0,0) };
struct Exp<datatype ExpD.Var_e> v1630 = { NULL,Var_e("g16301649",0,0) };
struct Exp<datatype ExpD.Var_e> v1632 = { NULL,Var_e("cdr",0,0) };
struct Exp<datatype ExpD.Var_e> v1633 = { NULL,Var_e("g16281647",0,0) };
exp_t v1634[] = { (exp_t)&v1632,&v1633 };
struct Exp<datatype ExpD.Apply_e> v1631 = { NULL,Apply_e(v1634) };
struct Exp<datatype ExpD.Var_e> v1636 = { NULL,Var_e("cdr",0,0) };
struct Exp<datatype ExpD.Var_e> v1637 = { NULL,Var_e("g16291648",0,0) };
exp_t v1638[] = { (exp_t)&v1636,&v1637 };
struct Exp<datatype ExpD.Apply_e> v1635 = { NULL,Apply_e(v1638) };
exp_t v1639[] = { (exp_t)&v1629,&v1630,&v1631,&v1635 };
struct Exp<datatype ExpD.Apply_e> v1628 = { NULL,Apply_e(v1639) };
struct Exp<datatype ExpD.Lambda_e> v1626 = { NULL,Lambda_e(v1627,&v1628) };
struct Exp<datatype ExpD.Var_e> v1641 = { NULL,Var_e("set-cdr!",0,0) };
struct Exp<datatype ExpD.Var_e> v1642 = { NULL,Var_e("g16271646",0,0) };
struct Exp<datatype ExpD.Var_e> v1643 = { NULL,Var_e("g16301649",0,0) };
exp_t v1644[] = { (exp_t)&v1641,&v1642,&v1643 };
struct Exp<datatype ExpD.Apply_e> v1640 = { NULL,Apply_e(v1644) };
exp_t v1645[] = { (exp_t)&v1626,&v1640 };
struct Exp<datatype ExpD.Apply_e> v1625 = { NULL,Apply_e(v1645) };
struct Exp<datatype ExpD.Lambda_e> v1623 = { NULL,Lambda_e(v1624,&v1625) };
struct Exp<datatype ExpD.Var_e> v1647 = { NULL,Var_e("cons",0,0) };
struct Exp<datatype ExpD.Var_e> v1649 = { NULL,Var_e("g16201637",0,0) };
struct Exp<datatype ExpD.Var_e> v1651 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v1652 = { NULL,Var_e("g16281647",0,0) };
exp_t v1653[] = { (exp_t)&v1651,&v1652 };
struct Exp<datatype ExpD.Apply_e> v1650 = { NULL,Apply_e(v1653) };
struct Exp<datatype ExpD.Var_e> v1655 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v1656 = { NULL,Var_e("g16291648",0,0) };
exp_t v1657[] = { (exp_t)&v1655,&v1656 };
struct Exp<datatype ExpD.Apply_e> v1654 = { NULL,Apply_e(v1657) };
exp_t v1658[] = { (exp_t)&v1649,&v1650,&v1654 };
struct Exp<datatype ExpD.Apply_e> v1648 = { NULL,Apply_e(v1658) };
exp_t v1659[] = { (exp_t)&v1647,&v1648,NULL };
struct Exp<datatype ExpD.Apply_e> v1646 = { NULL,Apply_e(v1659) };
exp_t v1660[] = { (exp_t)&v1623,&v1646 };
struct Exp<datatype ExpD.Apply_e> v1622 = { NULL,Apply_e(v1660) };
struct Exp<datatype ExpD.If_e> v1661 = { NULL,If_e(&v1618,NULL,&v1622) };
struct Exp<datatype ExpD.Lambda_e> v1616 = { NULL,Lambda_e(v1617,&v1661) };
struct Exp<datatype ExpD.Set_e> v1662 = { NULL,Set_e("g16221640",0,0,&v1616) };
exp_t v1663[] = { (exp_t)&v1480,&v1662 };
struct Exp<datatype ExpD.Apply_e> v1479 = { NULL,Apply_e(v1663) };
struct Exp<datatype ExpD.Lambda_e> v1477 = { NULL,Lambda_e(v1478,&v1479) };
const char ?v1665[] = { "g16241642","g16251643" };
struct Exp<datatype ExpD.Var_e> v1667 = { NULL,Var_e("null?",0,0) };
struct Exp<datatype ExpD.Var_e> v1668 = { NULL,Var_e("g16251643",0,0) };
exp_t v1669[] = { (exp_t)&v1667,&v1668 };
struct Exp<datatype ExpD.Apply_e> v1666 = { NULL,Apply_e(v1669) };
const char ?v1672[] = { "g16261644" };
const char ?v1675[] = { "t1645" };
struct Exp<datatype ExpD.Var_e> v1677 = { NULL,Var_e("g16211639",0,0) };
struct Exp<datatype ExpD.Var_e> v1678 = { NULL,Var_e("g16261644",0,0) };
struct Exp<datatype ExpD.Var_e> v1680 = { NULL,Var_e("cdr",0,0) };
struct Exp<datatype ExpD.Var_e> v1681 = { NULL,Var_e("g16251643",0,0) };
exp_t v1682[] = { (exp_t)&v1680,&v1681 };
struct Exp<datatype ExpD.Apply_e> v1679 = { NULL,Apply_e(v1682) };
exp_t v1683[] = { (exp_t)&v1677,&v1678,&v1679 };
struct Exp<datatype ExpD.Apply_e> v1676 = { NULL,Apply_e(v1683) };
struct Exp<datatype ExpD.Lambda_e> v1674 = { NULL,Lambda_e(v1675,&v1676) };
struct Exp<datatype ExpD.Var_e> v1685 = { NULL,Var_e("set-cdr!",0,0) };
struct Exp<datatype ExpD.Var_e> v1686 = { NULL,Var_e("g16241642",0,0) };
struct Exp<datatype ExpD.Var_e> v1687 = { NULL,Var_e("g16261644",0,0) };
exp_t v1688[] = { (exp_t)&v1685,&v1686,&v1687 };
struct Exp<datatype ExpD.Apply_e> v1684 = { NULL,Apply_e(v1688) };
exp_t v1689[] = { (exp_t)&v1674,&v1684 };
struct Exp<datatype ExpD.Apply_e> v1673 = { NULL,Apply_e(v1689) };
struct Exp<datatype ExpD.Lambda_e> v1671 = { NULL,Lambda_e(v1672,&v1673) };
struct Exp<datatype ExpD.Var_e> v1691 = { NULL,Var_e("cons",0,0) };
struct Exp<datatype ExpD.Var_e> v1693 = { NULL,Var_e("g16201637",0,0) };
struct Exp<datatype ExpD.Var_e> v1695 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v1696 = { NULL,Var_e("g16251643",0,0) };
exp_t v1697[] = { (exp_t)&v1695,&v1696 };
struct Exp<datatype ExpD.Apply_e> v1694 = { NULL,Apply_e(v1697) };
exp_t v1698[] = { (exp_t)&v1693,&v1694 };
struct Exp<datatype ExpD.Apply_e> v1692 = { NULL,Apply_e(v1698) };
exp_t v1699[] = { (exp_t)&v1691,&v1692,NULL };
struct Exp<datatype ExpD.Apply_e> v1690 = { NULL,Apply_e(v1699) };
exp_t v1700[] = { (exp_t)&v1671,&v1690 };
struct Exp<datatype ExpD.Apply_e> v1670 = { NULL,Apply_e(v1700) };
struct Exp<datatype ExpD.If_e> v1701 = { NULL,If_e(&v1666,NULL,&v1670) };
struct Exp<datatype ExpD.Lambda_e> v1664 = { NULL,Lambda_e(v1665,&v1701) };
struct Exp<datatype ExpD.Set_e> v1702 = { NULL,Set_e("g16211639",0,0,&v1664) };
exp_t v1703[] = { (exp_t)&v1477,&v1702 };
struct Exp<datatype ExpD.Apply_e> v1476 = { NULL,Apply_e(v1703) };
struct Exp<datatype ExpD.Lambda_e> v1474 = { NULL,Lambda_e(v1475,&v1476) };
datatype Const.Undef_l v1704 = Undef_l;
struct Value<datatype ValueD.Const_v> v1705 = { NULL,Const_v(&v1704) };
struct Exp<datatype ExpD.Const_e> v1706 = { NULL,Const_e(&v1705) };
datatype Const.Undef_l v1707 = Undef_l;
struct Value<datatype ValueD.Const_v> v1708 = { NULL,Const_v(&v1707) };
struct Exp<datatype ExpD.Const_e> v1709 = { NULL,Const_e(&v1708) };
datatype Const.Undef_l v1710 = Undef_l;
struct Value<datatype ValueD.Const_v> v1711 = { NULL,Const_v(&v1710) };
struct Exp<datatype ExpD.Const_e> v1712 = { NULL,Const_e(&v1711) };
exp_t v1713[] = { (exp_t)&v1474,&v1706,&v1709,&v1712 };
struct Exp<datatype ExpD.Apply_e> v1473 = { NULL,Apply_e(v1713) };
struct Exp<datatype ExpD.VarArgsLambda_e> v1471 = { NULL,VarArgsLambda_e(v1472,"g16191638",&v1473) };
struct Exp<datatype ExpD.Set_e> v1714 = { NULL,Set_e("map",0,0,&v1471) };
const char ?v1716[] = { "g16621664","g16631665" };
struct Exp<datatype ExpD.Var_e> v1718 = { NULL,Var_e("null?",0,0) };
struct Exp<datatype ExpD.Var_e> v1719 = { NULL,Var_e("g16631665",0,0) };
exp_t v1720[] = { (exp_t)&v1718,&v1719 };
struct Exp<datatype ExpD.Apply_e> v1717 = { NULL,Apply_e(v1720) };
const char ?v1723[] = { "t1666" };
struct Exp<datatype ExpD.Var_e> v1725 = { NULL,Var_e("for-each",0,0) };
struct Exp<datatype ExpD.Var_e> v1726 = { NULL,Var_e("g16621664",0,0) };
struct Exp<datatype ExpD.Var_e> v1728 = { NULL,Var_e("cdr",0,0) };
struct Exp<datatype ExpD.Var_e> v1729 = { NULL,Var_e("g16631665",0,0) };
exp_t v1730[] = { (exp_t)&v1728,&v1729 };
struct Exp<datatype ExpD.Apply_e> v1727 = { NULL,Apply_e(v1730) };
exp_t v1731[] = { (exp_t)&v1725,&v1726,&v1727 };
struct Exp<datatype ExpD.Apply_e> v1724 = { NULL,Apply_e(v1731) };
struct Exp<datatype ExpD.Lambda_e> v1722 = { NULL,Lambda_e(v1723,&v1724) };
struct Exp<datatype ExpD.Var_e> v1733 = { NULL,Var_e("g16621664",0,0) };
struct Exp<datatype ExpD.Var_e> v1735 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v1736 = { NULL,Var_e("g16631665",0,0) };
exp_t v1737[] = { (exp_t)&v1735,&v1736 };
struct Exp<datatype ExpD.Apply_e> v1734 = { NULL,Apply_e(v1737) };
exp_t v1738[] = { (exp_t)&v1733,&v1734 };
struct Exp<datatype ExpD.Apply_e> v1732 = { NULL,Apply_e(v1738) };
exp_t v1739[] = { (exp_t)&v1722,&v1732 };
struct Exp<datatype ExpD.Apply_e> v1721 = { NULL,Apply_e(v1739) };
struct Exp<datatype ExpD.If_e> v1740 = { NULL,If_e(&v1717,NULL,&v1721) };
struct Exp<datatype ExpD.Lambda_e> v1715 = { NULL,Lambda_e(v1716,&v1740) };
struct Exp<datatype ExpD.Set_e> v1741 = { NULL,Set_e("for-each",0,0,&v1715) };
const char ?v1743[] = { "g16671671","g16681672" };
const char ?v1746[] = { "g16691673","g16701674" };
struct Exp<datatype ExpD.Var_e> v1748 = { NULL,Var_e("<",0,0) };
struct Exp<datatype ExpD.Var_e> v1749 = { NULL,Var_e("g16701674",0,0) };
datatype Const.Int_l v1750 = Int_l(0);
struct Value<datatype ValueD.Const_v> v1751 = { NULL,Const_v(&v1750) };
struct Exp<datatype ExpD.Const_e> v1752 = { NULL,Const_e(&v1751) };
exp_t v1753[] = { (exp_t)&v1748,&v1749,&v1752 };
struct Exp<datatype ExpD.Apply_e> v1747 = { NULL,Apply_e(v1753) };
struct Exp<datatype ExpD.Var_e> v1755 = { NULL,Var_e("cons",0,0) };
struct Exp<datatype ExpD.Var_e> v1757 = { NULL,Var_e("-",0,0) };
struct Exp<datatype ExpD.Var_e> v1758 = { NULL,Var_e("g16691673",0,0) };
datatype Const.Int_l v1759 = Int_l(1);
struct Value<datatype ValueD.Const_v> v1760 = { NULL,Const_v(&v1759) };
struct Exp<datatype ExpD.Const_e> v1761 = { NULL,Const_e(&v1760) };
exp_t v1762[] = { (exp_t)&v1757,&v1758,&v1761 };
struct Exp<datatype ExpD.Apply_e> v1756 = { NULL,Apply_e(v1762) };
struct Exp<datatype ExpD.Var_e> v1764 = { NULL,Var_e("+",0,0) };
struct Exp<datatype ExpD.Var_e> v1765 = { NULL,Var_e("g16701674",0,0) };
datatype Const.Int_l v1766 = Int_l(1000000);
struct Value<datatype ValueD.Const_v> v1767 = { NULL,Const_v(&v1766) };
struct Exp<datatype ExpD.Const_e> v1768 = { NULL,Const_e(&v1767) };
exp_t v1769[] = { (exp_t)&v1764,&v1765,&v1768 };
struct Exp<datatype ExpD.Apply_e> v1763 = { NULL,Apply_e(v1769) };
exp_t v1770[] = { (exp_t)&v1755,&v1756,&v1763 };
struct Exp<datatype ExpD.Apply_e> v1754 = { NULL,Apply_e(v1770) };
struct Exp<datatype ExpD.Var_e> v1772 = { NULL,Var_e("cons",0,0) };
struct Exp<datatype ExpD.Var_e> v1773 = { NULL,Var_e("g16691673",0,0) };
struct Exp<datatype ExpD.Var_e> v1774 = { NULL,Var_e("g16701674",0,0) };
exp_t v1775[] = { (exp_t)&v1772,&v1773,&v1774 };
struct Exp<datatype ExpD.Apply_e> v1771 = { NULL,Apply_e(v1775) };
struct Exp<datatype ExpD.If_e> v1776 = { NULL,If_e(&v1747,&v1754,&v1771) };
struct Exp<datatype ExpD.Lambda_e> v1745 = { NULL,Lambda_e(v1746,&v1776) };
struct Exp<datatype ExpD.Var_e> v1778 = { NULL,Var_e("-",0,0) };
struct Exp<datatype ExpD.Var_e> v1780 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v1781 = { NULL,Var_e("g16671671",0,0) };
exp_t v1782[] = { (exp_t)&v1780,&v1781 };
struct Exp<datatype ExpD.Apply_e> v1779 = { NULL,Apply_e(v1782) };
struct Exp<datatype ExpD.Var_e> v1784 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v1785 = { NULL,Var_e("g16681672",0,0) };
exp_t v1786[] = { (exp_t)&v1784,&v1785 };
struct Exp<datatype ExpD.Apply_e> v1783 = { NULL,Apply_e(v1786) };
exp_t v1787[] = { (exp_t)&v1778,&v1779,&v1783 };
struct Exp<datatype ExpD.Apply_e> v1777 = { NULL,Apply_e(v1787) };
struct Exp<datatype ExpD.Var_e> v1789 = { NULL,Var_e("-",0,0) };
struct Exp<datatype ExpD.Var_e> v1791 = { NULL,Var_e("cdr",0,0) };
struct Exp<datatype ExpD.Var_e> v1792 = { NULL,Var_e("g16671671",0,0) };
exp_t v1793[] = { (exp_t)&v1791,&v1792 };
struct Exp<datatype ExpD.Apply_e> v1790 = { NULL,Apply_e(v1793) };
struct Exp<datatype ExpD.Var_e> v1795 = { NULL,Var_e("cdr",0,0) };
struct Exp<datatype ExpD.Var_e> v1796 = { NULL,Var_e("g16681672",0,0) };
exp_t v1797[] = { (exp_t)&v1795,&v1796 };
struct Exp<datatype ExpD.Apply_e> v1794 = { NULL,Apply_e(v1797) };
exp_t v1798[] = { (exp_t)&v1789,&v1790,&v1794 };
struct Exp<datatype ExpD.Apply_e> v1788 = { NULL,Apply_e(v1798) };
exp_t v1799[] = { (exp_t)&v1745,&v1777,&v1788 };
struct Exp<datatype ExpD.Apply_e> v1744 = { NULL,Apply_e(v1799) };
struct Exp<datatype ExpD.Lambda_e> v1742 = { NULL,Lambda_e(v1743,&v1744) };
struct Exp<datatype ExpD.Set_e> v1800 = { NULL,Set_e("time-diff",0,0,&v1742) };
const char ?v1802[] = { "g16751676" };
struct Exp<datatype ExpD.Var_e> v1804 = { NULL,Var_e("+",0,0) };
struct Exp<datatype ExpD.Var_e> v1806 = { NULL,Var_e("*",0,0) };
datatype Const.Int_l v1807 = Int_l(1000);
struct Value<datatype ValueD.Const_v> v1808 = { NULL,Const_v(&v1807) };
struct Exp<datatype ExpD.Const_e> v1809 = { NULL,Const_e(&v1808) };
struct Exp<datatype ExpD.Var_e> v1811 = { NULL,Var_e("car",0,0) };
struct Exp<datatype ExpD.Var_e> v1812 = { NULL,Var_e("g16751676",0,0) };
exp_t v1813[] = { (exp_t)&v1811,&v1812 };
struct Exp<datatype ExpD.Apply_e> v1810 = { NULL,Apply_e(v1813) };
exp_t v1814[] = { (exp_t)&v1806,&v1809,&v1810 };
struct Exp<datatype ExpD.Apply_e> v1805 = { NULL,Apply_e(v1814) };
struct Exp<datatype ExpD.Var_e> v1816 = { NULL,Var_e("quotient",0,0) };
struct Exp<datatype ExpD.Var_e> v1818 = { NULL,Var_e("cdr",0,0) };
struct Exp<datatype ExpD.Var_e> v1819 = { NULL,Var_e("g16751676",0,0) };
exp_t v1820[] = { (exp_t)&v1818,&v1819 };
struct Exp<datatype ExpD.Apply_e> v1817 = { NULL,Apply_e(v1820) };
datatype Const.Int_l v1821 = Int_l(1000);
struct Value<datatype ValueD.Const_v> v1822 = { NULL,Const_v(&v1821) };
struct Exp<datatype ExpD.Const_e> v1823 = { NULL,Const_e(&v1822) };
exp_t v1824[] = { (exp_t)&v1816,&v1817,&v1823 };
struct Exp<datatype ExpD.Apply_e> v1815 = { NULL,Apply_e(v1824) };
exp_t v1825[] = { (exp_t)&v1804,&v1805,&v1815 };
struct Exp<datatype ExpD.Apply_e> v1803 = { NULL,Apply_e(v1825) };
struct Exp<datatype ExpD.Lambda_e> v1801 = { NULL,Lambda_e(v1802,&v1803) };
struct Exp<datatype ExpD.Set_e> v1826 = { NULL,Set_e("time-to-ms",0,0,&v1801) };
const char ?v1828[] = { "g16771683","g16781684" };
const char ?v1831[] = { "g16791685" };
const char ?v1834[] = { "g16801686" };
const char ?v1837[] = { "g16811687" };
const char ?v1840[] = { "g16821688" };
const char ?v1843[] = {  };
const char ?v1846[] = { "t1689" };
const char ?v1849[] = { "t1690" };
const char ?v1852[] = { "t1691" };
const char ?v1855[] = { "t1692" };
const char ?v1858[] = { "t1693" };
struct Exp<datatype ExpD.Var_e> v1859 = { NULL,Var_e("g16801686",0,0) };
struct Exp<datatype ExpD.Lambda_e> v1857 = { NULL,Lambda_e(v1858,&v1859) };
struct Exp<datatype ExpD.Var_e> v1861 = { NULL,Var_e("display",0,0) };
datatype Const.Char_l v1862 = Char_l(10);
struct Value<datatype ValueD.Const_v> v1863 = { NULL,Const_v(&v1862) };
struct Exp<datatype ExpD.Const_e> v1864 = { NULL,Const_e(&v1863) };
exp_t v1865[] = { (exp_t)&v1861,&v1864 };
struct Exp<datatype ExpD.Apply_e> v1860 = { NULL,Apply_e(v1865) };
exp_t v1866[] = { (exp_t)&v1857,&v1860 };
struct Exp<datatype ExpD.Apply_e> v1856 = { NULL,Apply_e(v1866) };
struct Exp<datatype ExpD.Lambda_e> v1854 = { NULL,Lambda_e(v1855,&v1856) };
struct Exp<datatype ExpD.Var_e> v1868 = { NULL,Var_e("display",0,0) };
struct Exp<datatype ExpD.Var_e> v1869 = { NULL,Var_e("g16821688",0,0) };
exp_t v1870[] = { (exp_t)&v1868,&v1869 };
struct Exp<datatype ExpD.Apply_e> v1867 = { NULL,Apply_e(v1870) };
exp_t v1871[] = { (exp_t)&v1854,&v1867 };
struct Exp<datatype ExpD.Apply_e> v1853 = { NULL,Apply_e(v1871) };
struct Exp<datatype ExpD.Lambda_e> v1851 = { NULL,Lambda_e(v1852,&v1853) };
struct Exp<datatype ExpD.Var_e> v1873 = { NULL,Var_e("display",0,0) };
datatype Const.String_l v1874 = String_l(", ");
struct Value<datatype ValueD.Const_v> v1875 = { NULL,Const_v(&v1874) };
struct Exp<datatype ExpD.Const_e> v1876 = { NULL,Const_e(&v1875) };
exp_t v1877[] = { (exp_t)&v1873,&v1876 };
struct Exp<datatype ExpD.Apply_e> v1872 = { NULL,Apply_e(v1877) };
exp_t v1878[] = { (exp_t)&v1851,&v1872 };
struct Exp<datatype ExpD.Apply_e> v1850 = { NULL,Apply_e(v1878) };
struct Exp<datatype ExpD.Lambda_e> v1848 = { NULL,Lambda_e(v1849,&v1850) };
struct Exp<datatype ExpD.Var_e> v1880 = { NULL,Var_e("display",0,0) };
struct Exp<datatype ExpD.Var_e> v1881 = { NULL,Var_e("g16771683",0,0) };
exp_t v1882[] = { (exp_t)&v1880,&v1881 };
struct Exp<datatype ExpD.Apply_e> v1879 = { NULL,Apply_e(v1882) };
exp_t v1883[] = { (exp_t)&v1848,&v1879 };
struct Exp<datatype ExpD.Apply_e> v1847 = { NULL,Apply_e(v1883) };
struct Exp<datatype ExpD.Lambda_e> v1845 = { NULL,Lambda_e(v1846,&v1847) };
struct Exp<datatype ExpD.Var_e> v1885 = { NULL,Var_e("display",0,0) };
datatype Const.String_l v1886 = String_l(";; cycscheme, ");
struct Value<datatype ValueD.Const_v> v1887 = { NULL,Const_v(&v1886) };
struct Exp<datatype ExpD.Const_e> v1888 = { NULL,Const_e(&v1887) };
exp_t v1889[] = { (exp_t)&v1885,&v1888 };
struct Exp<datatype ExpD.Apply_e> v1884 = { NULL,Apply_e(v1889) };
exp_t v1890[] = { (exp_t)&v1845,&v1884 };
struct Exp<datatype ExpD.Apply_e> v1844 = { NULL,Apply_e(v1890) };
struct Exp<datatype ExpD.Lambda_e> v1842 = { NULL,Lambda_e(v1843,&v1844) };
exp_t v1891[] = { (exp_t)&v1842 };
struct Exp<datatype ExpD.Apply_e> v1841 = { NULL,Apply_e(v1891) };
struct Exp<datatype ExpD.Lambda_e> v1839 = { NULL,Lambda_e(v1840,&v1841) };
struct Exp<datatype ExpD.Var_e> v1893 = { NULL,Var_e("time-to-ms",0,0) };
struct Exp<datatype ExpD.Var_e> v1895 = { NULL,Var_e("time-diff",0,0) };
struct Exp<datatype ExpD.Var_e> v1896 = { NULL,Var_e("g16811687",0,0) };
struct Exp<datatype ExpD.Var_e> v1897 = { NULL,Var_e("g16791685",0,0) };
exp_t v1898[] = { (exp_t)&v1895,&v1896,&v1897 };
struct Exp<datatype ExpD.Apply_e> v1894 = { NULL,Apply_e(v1898) };
exp_t v1899[] = { (exp_t)&v1893,&v1894 };
struct Exp<datatype ExpD.Apply_e> v1892 = { NULL,Apply_e(v1899) };
exp_t v1900[] = { (exp_t)&v1839,&v1892 };
struct Exp<datatype ExpD.Apply_e> v1838 = { NULL,Apply_e(v1900) };
struct Exp<datatype ExpD.Lambda_e> v1836 = { NULL,Lambda_e(v1837,&v1838) };
struct Exp<datatype ExpD.Var_e> v1902 = { NULL,Var_e("time-now",0,0) };
exp_t v1903[] = { (exp_t)&v1902 };
struct Exp<datatype ExpD.Apply_e> v1901 = { NULL,Apply_e(v1903) };
exp_t v1904[] = { (exp_t)&v1836,&v1901 };
struct Exp<datatype ExpD.Apply_e> v1835 = { NULL,Apply_e(v1904) };
struct Exp<datatype ExpD.Lambda_e> v1833 = { NULL,Lambda_e(v1834,&v1835) };
struct Exp<datatype ExpD.Var_e> v1906 = { NULL,Var_e("g16781684",0,0) };
exp_t v1907[] = { (exp_t)&v1906 };
struct Exp<datatype ExpD.Apply_e> v1905 = { NULL,Apply_e(v1907) };
exp_t v1908[] = { (exp_t)&v1833,&v1905 };
struct Exp<datatype ExpD.Apply_e> v1832 = { NULL,Apply_e(v1908) };
struct Exp<datatype ExpD.Lambda_e> v1830 = { NULL,Lambda_e(v1831,&v1832) };
struct Exp<datatype ExpD.Var_e> v1910 = { NULL,Var_e("time-now",0,0) };
exp_t v1911[] = { (exp_t)&v1910 };
struct Exp<datatype ExpD.Apply_e> v1909 = { NULL,Apply_e(v1911) };
exp_t v1912[] = { (exp_t)&v1830,&v1909 };
struct Exp<datatype ExpD.Apply_e> v1829 = { NULL,Apply_e(v1912) };
struct Exp<datatype ExpD.Lambda_e> v1827 = { NULL,Lambda_e(v1828,&v1829) };
struct Exp<datatype ExpD.Set_e> v1913 = { NULL,Set_e("run-benchmark",0,0,&v1827) };
const char ?v1915[] = { "g16941695" };
struct Exp<datatype ExpD.Var_e> v1917 = { NULL,Var_e("<=",0,0) };
struct Exp<datatype ExpD.Var_e> v1918 = { NULL,Var_e("g16941695",0,0) };
datatype Const.Int_l v1919 = Int_l(1);
struct Value<datatype ValueD.Const_v> v1920 = { NULL,Const_v(&v1919) };
struct Exp<datatype ExpD.Const_e> v1921 = { NULL,Const_e(&v1920) };
exp_t v1922[] = { (exp_t)&v1917,&v1918,&v1921 };
struct Exp<datatype ExpD.Apply_e> v1916 = { NULL,Apply_e(v1922) };
datatype Const.Int_l v1923 = Int_l(1);
struct Value<datatype ValueD.Const_v> v1924 = { NULL,Const_v(&v1923) };
struct Exp<datatype ExpD.Const_e> v1925 = { NULL,Const_e(&v1924) };
struct Exp<datatype ExpD.Var_e> v1927 = { NULL,Var_e("+",0,0) };
struct Exp<datatype ExpD.Var_e> v1929 = { NULL,Var_e("fib",0,0) };
struct Exp<datatype ExpD.Var_e> v1931 = { NULL,Var_e("-",0,0) };
struct Exp<datatype ExpD.Var_e> v1932 = { NULL,Var_e("g16941695",0,0) };
datatype Const.Int_l v1933 = Int_l(1);
struct Value<datatype ValueD.Const_v> v1934 = { NULL,Const_v(&v1933) };
struct Exp<datatype ExpD.Const_e> v1935 = { NULL,Const_e(&v1934) };
exp_t v1936[] = { (exp_t)&v1931,&v1932,&v1935 };
struct Exp<datatype ExpD.Apply_e> v1930 = { NULL,Apply_e(v1936) };
exp_t v1937[] = { (exp_t)&v1929,&v1930 };
struct Exp<datatype ExpD.Apply_e> v1928 = { NULL,Apply_e(v1937) };
struct Exp<datatype ExpD.Var_e> v1939 = { NULL,Var_e("fib",0,0) };
struct Exp<datatype ExpD.Var_e> v1941 = { NULL,Var_e("-",0,0) };
struct Exp<datatype ExpD.Var_e> v1942 = { NULL,Var_e("g16941695",0,0) };
datatype Const.Int_l v1943 = Int_l(2);
struct Value<datatype ValueD.Const_v> v1944 = { NULL,Const_v(&v1943) };
struct Exp<datatype ExpD.Const_e> v1945 = { NULL,Const_e(&v1944) };
exp_t v1946[] = { (exp_t)&v1941,&v1942,&v1945 };
struct Exp<datatype ExpD.Apply_e> v1940 = { NULL,Apply_e(v1946) };
exp_t v1947[] = { (exp_t)&v1939,&v1940 };
struct Exp<datatype ExpD.Apply_e> v1938 = { NULL,Apply_e(v1947) };
exp_t v1948[] = { (exp_t)&v1927,&v1928,&v1938 };
struct Exp<datatype ExpD.Apply_e> v1926 = { NULL,Apply_e(v1948) };
struct Exp<datatype ExpD.If_e> v1949 = { NULL,If_e(&v1916,&v1925,&v1926) };
struct Exp<datatype ExpD.Lambda_e> v1914 = { NULL,Lambda_e(v1915,&v1949) };
struct Exp<datatype ExpD.Set_e> v1950 = { NULL,Set_e("fib",0,0,&v1914) };
struct Exp<datatype ExpD.Var_e> v1952 = { NULL,Var_e("print",0,0) };
const char ?v1955[] = { "g16961701","g16971702","g16981703" };
struct Exp<datatype ExpD.Var_e> v1957 = { NULL,Var_e("+",0,0) };
struct Exp<datatype ExpD.Var_e> v1959 = { NULL,Var_e("fib",0,0) };
datatype Const.Int_l v1960 = Int_l(1);
struct Value<datatype ValueD.Const_v> v1961 = { NULL,Const_v(&v1960) };
struct Exp<datatype ExpD.Const_e> v1962 = { NULL,Const_e(&v1961) };
exp_t v1963[] = { (exp_t)&v1959,&v1962 };
struct Exp<datatype ExpD.Apply_e> v1958 = { NULL,Apply_e(v1963) };
struct Exp<datatype ExpD.Var_e> v1965 = { NULL,Var_e("fib",0,0) };
datatype Const.Int_l v1966 = Int_l(2);
struct Value<datatype ValueD.Const_v> v1967 = { NULL,Const_v(&v1966) };
struct Exp<datatype ExpD.Const_e> v1968 = { NULL,Const_e(&v1967) };
exp_t v1969[] = { (exp_t)&v1965,&v1968 };
struct Exp<datatype ExpD.Apply_e> v1964 = { NULL,Apply_e(v1969) };
struct Exp<datatype ExpD.Var_e> v1971 = { NULL,Var_e("fib",0,0) };
datatype Const.Int_l v1972 = Int_l(3);
struct Value<datatype ValueD.Const_v> v1973 = { NULL,Const_v(&v1972) };
struct Exp<datatype ExpD.Const_e> v1974 = { NULL,Const_e(&v1973) };
exp_t v1975[] = { (exp_t)&v1971,&v1974 };
struct Exp<datatype ExpD.Apply_e> v1970 = { NULL,Apply_e(v1975) };
struct Exp<datatype ExpD.Var_e> v1977 = { NULL,Var_e("call-with-current-continuation",0,0) };
const char ?v1979[] = { "g16991704" };
struct Exp<datatype ExpD.Var_e> v1980 = { NULL,Var_e("g16981703",0,0) };
const char ?v1983[] = { "t1705" };
struct Exp<datatype ExpD.Var_e> v1985 = { NULL,Var_e("fib",0,0) };
datatype Const.Int_l v1986 = Int_l(4);
struct Value<datatype ValueD.Const_v> v1987 = { NULL,Const_v(&v1986) };
struct Exp<datatype ExpD.Const_e> v1988 = { NULL,Const_e(&v1987) };
exp_t v1989[] = { (exp_t)&v1985,&v1988 };
struct Exp<datatype ExpD.Apply_e> v1984 = { NULL,Apply_e(v1989) };
struct Exp<datatype ExpD.Lambda_e> v1982 = { NULL,Lambda_e(v1983,&v1984) };
struct Exp<datatype ExpD.Var_e> v1990 = { NULL,Var_e("g16991704",0,0) };
struct Exp<datatype ExpD.Set_e> v1991 = { NULL,Set_e("g16961701",0,0,&v1990) };
exp_t v1992[] = { (exp_t)&v1982,&v1991 };
struct Exp<datatype ExpD.Apply_e> v1981 = { NULL,Apply_e(v1992) };
struct Exp<datatype ExpD.Var_e> v1994 = { NULL,Var_e("fib",0,0) };
datatype Const.Int_l v1995 = Int_l(5);
struct Value<datatype ValueD.Const_v> v1996 = { NULL,Const_v(&v1995) };
struct Exp<datatype ExpD.Const_e> v1997 = { NULL,Const_e(&v1996) };
exp_t v1998[] = { (exp_t)&v1994,&v1997 };
struct Exp<datatype ExpD.Apply_e> v1993 = { NULL,Apply_e(v1998) };
struct Exp<datatype ExpD.If_e> v1999 = { NULL,If_e(&v1980,&v1981,&v1993) };
struct Exp<datatype ExpD.Lambda_e> v1978 = { NULL,Lambda_e(v1979,&v1999) };
exp_t v2000[] = { (exp_t)&v1977,&v1978 };
struct Exp<datatype ExpD.Apply_e> v1976 = { NULL,Apply_e(v2000) };
struct Exp<datatype ExpD.Var_e> v2002 = { NULL,Var_e("call-with-current-continuation",0,0) };
const char ?v2004[] = { "g17001706" };
struct Exp<datatype ExpD.Var_e> v2005 = { NULL,Var_e("g16981703",0,0) };
const char ?v2008[] = { "t1707" };
const char ?v2011[] = { "t1708" };
struct Exp<datatype ExpD.Var_e> v2013 = { NULL,Var_e("g16961701",0,0) };
struct Exp<datatype ExpD.Var_e> v2015 = { NULL,Var_e("fib",0,0) };
datatype Const.Int_l v2016 = Int_l(6);
struct Value<datatype ValueD.Const_v> v2017 = { NULL,Const_v(&v2016) };
struct Exp<datatype ExpD.Const_e> v2018 = { NULL,Const_e(&v2017) };
exp_t v2019[] = { (exp_t)&v2015,&v2018 };
struct Exp<datatype ExpD.Apply_e> v2014 = { NULL,Apply_e(v2019) };
exp_t v2020[] = { (exp_t)&v2013,&v2014 };
struct Exp<datatype ExpD.Apply_e> v2012 = { NULL,Apply_e(v2020) };
struct Exp<datatype ExpD.Lambda_e> v2010 = { NULL,Lambda_e(v2011,&v2012) };
datatype Const.Bool_l v2021 = Bool_l(false);
struct Value<datatype ValueD.Const_v> v2022 = { NULL,Const_v(&v2021) };
struct Exp<datatype ExpD.Const_e> v2023 = { NULL,Const_e(&v2022) };
struct Exp<datatype ExpD.Set_e> v2024 = { NULL,Set_e("g16981703",0,0,&v2023) };
exp_t v2025[] = { (exp_t)&v2010,&v2024 };
struct Exp<datatype ExpD.Apply_e> v2009 = { NULL,Apply_e(v2025) };
struct Exp<datatype ExpD.Lambda_e> v2007 = { NULL,Lambda_e(v2008,&v2009) };
struct Exp<datatype ExpD.Var_e> v2026 = { NULL,Var_e("g17001706",0,0) };
struct Exp<datatype ExpD.Set_e> v2027 = { NULL,Set_e("g16971702",0,0,&v2026) };
exp_t v2028[] = { (exp_t)&v2007,&v2027 };
struct Exp<datatype ExpD.Apply_e> v2006 = { NULL,Apply_e(v2028) };
struct Exp<datatype ExpD.Var_e> v2030 = { NULL,Var_e("g16971702",0,0) };
struct Exp<datatype ExpD.Var_e> v2032 = { NULL,Var_e("fib",0,0) };
datatype Const.Int_l v2033 = Int_l(7);
struct Value<datatype ValueD.Const_v> v2034 = { NULL,Const_v(&v2033) };
struct Exp<datatype ExpD.Const_e> v2035 = { NULL,Const_e(&v2034) };
exp_t v2036[] = { (exp_t)&v2032,&v2035 };
struct Exp<datatype ExpD.Apply_e> v2031 = { NULL,Apply_e(v2036) };
exp_t v2037[] = { (exp_t)&v2030,&v2031 };
struct Exp<datatype ExpD.Apply_e> v2029 = { NULL,Apply_e(v2037) };
struct Exp<datatype ExpD.If_e> v2038 = { NULL,If_e(&v2005,&v2006,&v2029) };
struct Exp<datatype ExpD.Lambda_e> v2003 = { NULL,Lambda_e(v2004,&v2038) };
exp_t v2039[] = { (exp_t)&v2002,&v2003 };
struct Exp<datatype ExpD.Apply_e> v2001 = { NULL,Apply_e(v2039) };
exp_t v2040[] = { (exp_t)&v1957,&v1958,&v1964,&v1970,&v1976,&v2001 };
struct Exp<datatype ExpD.Apply_e> v1956 = { NULL,Apply_e(v2040) };
struct Exp<datatype ExpD.Lambda_e> v1954 = { NULL,Lambda_e(v1955,&v1956) };
datatype Const.Bool_l v2041 = Bool_l(true);
struct Value<datatype ValueD.Const_v> v2042 = { NULL,Const_v(&v2041) };
struct Exp<datatype ExpD.Const_e> v2043 = { NULL,Const_e(&v2042) };
exp_t v2044[] = { (exp_t)&v1954,NULL,NULL,&v2043 };
struct Exp<datatype ExpD.Apply_e> v1953 = { NULL,Apply_e(v2044) };
exp_t v2045[] = { (exp_t)&v1952,&v1953 };
struct Exp<datatype ExpD.Apply_e> v1951 = { NULL,Apply_e(v2045) };
struct Exp<datatype ExpD.Var_e> v2047 = { NULL,Var_e("print",0,0) };
datatype Const.Char_l v2048 = Char_l(10);
struct Value<datatype ValueD.Const_v> v2049 = { NULL,Const_v(&v2048) };
struct Exp<datatype ExpD.Const_e> v2050 = { NULL,Const_e(&v2049) };
exp_t v2051[] = { (exp_t)&v2047,&v2050 };
struct Exp<datatype ExpD.Apply_e> v2046 = { NULL,Apply_e(v2051) };
exp_t v2052[] = { (exp_t)&v4,&v58,&v68,&v78,&v88,&v104,&v120,&v188,&v256,&v269,&v280,&v290,&v300,&v310,&v320,&v333,&v346,&v359,&v372,&v385,&v398,&v411,&v424,&v440,&v456,&v472,&v488,&v504,&v520,&v536,&v552,&v568,&v584,&v600,&v616,&v632,&v648,&v664,&v680,&v699,&v703,&v727,&v854,&v880,&v903,&v929,&v958,&v987,&v1016,&v1048,&v1080,&v1112,&v1193,&v1439,&v1447,&v1456,&v1463,&v1470,&v1714,&v1741,&v1800,&v1826,&v1913,&v1950,&v1951,&v2046 };
struct Exp<datatype ExpD.Apply_e> v3 = { NULL,Apply_e(v2052) };
struct Exp<datatype ExpD.Lambda_e> v1 = { NULL,Lambda_e(v2,&v3) };
struct Exp<datatype ExpD.Var_e> v2054 = { NULL,Var_e("cons",0,0) };
const char ?v2055 = "##core#undefined#";
datatype Const.Symbol_l v2056 = Symbol_l(&v2055);
struct Value<datatype ValueD.Const_v> v2057 = { NULL,Const_v(&v2056) };
struct Exp<datatype ExpD.Const_e> v2058 = { NULL,Const_e(&v2057) };
exp_t v2059[] = { (exp_t)&v2054,&v2058,NULL };
struct Exp<datatype ExpD.Apply_e> v2053 = { NULL,Apply_e(v2059) };
struct Exp<datatype ExpD.Var_e> v2061 = { NULL,Var_e("cons",0,0) };
const char ?v2062 = "##core#undefined#";
datatype Const.Symbol_l v2063 = Symbol_l(&v2062);
struct Value<datatype ValueD.Const_v> v2064 = { NULL,Const_v(&v2063) };
struct Exp<datatype ExpD.Const_e> v2065 = { NULL,Const_e(&v2064) };
exp_t v2066[] = { (exp_t)&v2061,&v2065,NULL };
struct Exp<datatype ExpD.Apply_e> v2060 = { NULL,Apply_e(v2066) };
struct Exp<datatype ExpD.Var_e> v2068 = { NULL,Var_e("cons",0,0) };
const char ?v2069 = "##core#undefined#";
datatype Const.Symbol_l v2070 = Symbol_l(&v2069);
struct Value<datatype ValueD.Const_v> v2071 = { NULL,Const_v(&v2070) };
struct Exp<datatype ExpD.Const_e> v2072 = { NULL,Const_e(&v2071) };
exp_t v2073[] = { (exp_t)&v2068,&v2072,NULL };
struct Exp<datatype ExpD.Apply_e> v2067 = { NULL,Apply_e(v2073) };
struct Exp<datatype ExpD.Var_e> v2075 = { NULL,Var_e("cons",0,0) };
const char ?v2076 = "##core#undefined#";
datatype Const.Symbol_l v2077 = Symbol_l(&v2076);
struct Value<datatype ValueD.Const_v> v2078 = { NULL,Const_v(&v2077) };
struct Exp<datatype ExpD.Const_e> v2079 = { NULL,Const_e(&v2078) };
exp_t v2080[] = { (exp_t)&v2075,&v2079,NULL };
struct Exp<datatype ExpD.Apply_e> v2074 = { NULL,Apply_e(v2080) };
struct Exp<datatype ExpD.Var_e> v2082 = { NULL,Var_e("cons",0,0) };
const char ?v2083 = "##core#undefined#";
datatype Const.Symbol_l v2084 = Symbol_l(&v2083);
struct Value<datatype ValueD.Const_v> v2085 = { NULL,Const_v(&v2084) };
struct Exp<datatype ExpD.Const_e> v2086 = { NULL,Const_e(&v2085) };
exp_t v2087[] = { (exp_t)&v2082,&v2086,NULL };
struct Exp<datatype ExpD.Apply_e> v2081 = { NULL,Apply_e(v2087) };
struct Exp<datatype ExpD.Var_e> v2089 = { NULL,Var_e("cons",0,0) };
const char ?v2090 = "##core#undefined#";
datatype Const.Symbol_l v2091 = Symbol_l(&v2090);
struct Value<datatype ValueD.Const_v> v2092 = { NULL,Const_v(&v2091) };
struct Exp<datatype ExpD.Const_e> v2093 = { NULL,Const_e(&v2092) };
exp_t v2094[] = { (exp_t)&v2089,&v2093,NULL };
struct Exp<datatype ExpD.Apply_e> v2088 = { NULL,Apply_e(v2094) };
struct Exp<datatype ExpD.Var_e> v2096 = { NULL,Var_e("cons",0,0) };
const char ?v2097 = "##core#undefined#";
datatype Const.Symbol_l v2098 = Symbol_l(&v2097);
struct Value<datatype ValueD.Const_v> v2099 = { NULL,Const_v(&v2098) };
struct Exp<datatype ExpD.Const_e> v2100 = { NULL,Const_e(&v2099) };
exp_t v2101[] = { (exp_t)&v2096,&v2100,NULL };
struct Exp<datatype ExpD.Apply_e> v2095 = { NULL,Apply_e(v2101) };
struct Exp<datatype ExpD.Var_e> v2103 = { NULL,Var_e("cons",0,0) };
const char ?v2104 = "##core#undefined#";
datatype Const.Symbol_l v2105 = Symbol_l(&v2104);
struct Value<datatype ValueD.Const_v> v2106 = { NULL,Const_v(&v2105) };
struct Exp<datatype ExpD.Const_e> v2107 = { NULL,Const_e(&v2106) };
exp_t v2108[] = { (exp_t)&v2103,&v2107,NULL };
struct Exp<datatype ExpD.Apply_e> v2102 = { NULL,Apply_e(v2108) };
struct Exp<datatype ExpD.Var_e> v2110 = { NULL,Var_e("cons",0,0) };
const char ?v2111 = "##core#undefined#";
datatype Const.Symbol_l v2112 = Symbol_l(&v2111);
struct Value<datatype ValueD.Const_v> v2113 = { NULL,Const_v(&v2112) };
struct Exp<datatype ExpD.Const_e> v2114 = { NULL,Const_e(&v2113) };
exp_t v2115[] = { (exp_t)&v2110,&v2114,NULL };
struct Exp<datatype ExpD.Apply_e> v2109 = { NULL,Apply_e(v2115) };
struct Exp<datatype ExpD.Var_e> v2117 = { NULL,Var_e("cons",0,0) };
const char ?v2118 = "##core#undefined#";
datatype Const.Symbol_l v2119 = Symbol_l(&v2118);
struct Value<datatype ValueD.Const_v> v2120 = { NULL,Const_v(&v2119) };
struct Exp<datatype ExpD.Const_e> v2121 = { NULL,Const_e(&v2120) };
exp_t v2122[] = { (exp_t)&v2117,&v2121,NULL };
struct Exp<datatype ExpD.Apply_e> v2116 = { NULL,Apply_e(v2122) };
struct Exp<datatype ExpD.Var_e> v2124 = { NULL,Var_e("cons",0,0) };
const char ?v2125 = "##core#undefined#";
datatype Const.Symbol_l v2126 = Symbol_l(&v2125);
struct Value<datatype ValueD.Const_v> v2127 = { NULL,Const_v(&v2126) };
struct Exp<datatype ExpD.Const_e> v2128 = { NULL,Const_e(&v2127) };
exp_t v2129[] = { (exp_t)&v2124,&v2128,NULL };
struct Exp<datatype ExpD.Apply_e> v2123 = { NULL,Apply_e(v2129) };
struct Exp<datatype ExpD.Var_e> v2131 = { NULL,Var_e("cons",0,0) };
const char ?v2132 = "##core#undefined#";
datatype Const.Symbol_l v2133 = Symbol_l(&v2132);
struct Value<datatype ValueD.Const_v> v2134 = { NULL,Const_v(&v2133) };
struct Exp<datatype ExpD.Const_e> v2135 = { NULL,Const_e(&v2134) };
exp_t v2136[] = { (exp_t)&v2131,&v2135,NULL };
struct Exp<datatype ExpD.Apply_e> v2130 = { NULL,Apply_e(v2136) };
struct Exp<datatype ExpD.Var_e> v2138 = { NULL,Var_e("cons",0,0) };
const char ?v2139 = "##core#undefined#";
datatype Const.Symbol_l v2140 = Symbol_l(&v2139);
struct Value<datatype ValueD.Const_v> v2141 = { NULL,Const_v(&v2140) };
struct Exp<datatype ExpD.Const_e> v2142 = { NULL,Const_e(&v2141) };
exp_t v2143[] = { (exp_t)&v2138,&v2142,NULL };
struct Exp<datatype ExpD.Apply_e> v2137 = { NULL,Apply_e(v2143) };
struct Exp<datatype ExpD.Var_e> v2145 = { NULL,Var_e("cons",0,0) };
const char ?v2146 = "##core#undefined#";
datatype Const.Symbol_l v2147 = Symbol_l(&v2146);
struct Value<datatype ValueD.Const_v> v2148 = { NULL,Const_v(&v2147) };
struct Exp<datatype ExpD.Const_e> v2149 = { NULL,Const_e(&v2148) };
exp_t v2150[] = { (exp_t)&v2145,&v2149,NULL };
struct Exp<datatype ExpD.Apply_e> v2144 = { NULL,Apply_e(v2150) };
struct Exp<datatype ExpD.Var_e> v2152 = { NULL,Var_e("cons",0,0) };
const char ?v2153 = "##core#undefined#";
datatype Const.Symbol_l v2154 = Symbol_l(&v2153);
struct Value<datatype ValueD.Const_v> v2155 = { NULL,Const_v(&v2154) };
struct Exp<datatype ExpD.Const_e> v2156 = { NULL,Const_e(&v2155) };
exp_t v2157[] = { (exp_t)&v2152,&v2156,NULL };
struct Exp<datatype ExpD.Apply_e> v2151 = { NULL,Apply_e(v2157) };
struct Exp<datatype ExpD.Var_e> v2159 = { NULL,Var_e("cons",0,0) };
const char ?v2160 = "##core#undefined#";
datatype Const.Symbol_l v2161 = Symbol_l(&v2160);
struct Value<datatype ValueD.Const_v> v2162 = { NULL,Const_v(&v2161) };
struct Exp<datatype ExpD.Const_e> v2163 = { NULL,Const_e(&v2162) };
exp_t v2164[] = { (exp_t)&v2159,&v2163,NULL };
struct Exp<datatype ExpD.Apply_e> v2158 = { NULL,Apply_e(v2164) };
struct Exp<datatype ExpD.Var_e> v2166 = { NULL,Var_e("cons",0,0) };
const char ?v2167 = "##core#undefined#";
datatype Const.Symbol_l v2168 = Symbol_l(&v2167);
struct Value<datatype ValueD.Const_v> v2169 = { NULL,Const_v(&v2168) };
struct Exp<datatype ExpD.Const_e> v2170 = { NULL,Const_e(&v2169) };
exp_t v2171[] = { (exp_t)&v2166,&v2170,NULL };
struct Exp<datatype ExpD.Apply_e> v2165 = { NULL,Apply_e(v2171) };
struct Exp<datatype ExpD.Var_e> v2173 = { NULL,Var_e("cons",0,0) };
const char ?v2174 = "##core#undefined#";
datatype Const.Symbol_l v2175 = Symbol_l(&v2174);
struct Value<datatype ValueD.Const_v> v2176 = { NULL,Const_v(&v2175) };
struct Exp<datatype ExpD.Const_e> v2177 = { NULL,Const_e(&v2176) };
exp_t v2178[] = { (exp_t)&v2173,&v2177,NULL };
struct Exp<datatype ExpD.Apply_e> v2172 = { NULL,Apply_e(v2178) };
struct Exp<datatype ExpD.Var_e> v2180 = { NULL,Var_e("cons",0,0) };
const char ?v2181 = "##core#undefined#";
datatype Const.Symbol_l v2182 = Symbol_l(&v2181);
struct Value<datatype ValueD.Const_v> v2183 = { NULL,Const_v(&v2182) };
struct Exp<datatype ExpD.Const_e> v2184 = { NULL,Const_e(&v2183) };
exp_t v2185[] = { (exp_t)&v2180,&v2184,NULL };
struct Exp<datatype ExpD.Apply_e> v2179 = { NULL,Apply_e(v2185) };
struct Exp<datatype ExpD.Var_e> v2187 = { NULL,Var_e("cons",0,0) };
const char ?v2188 = "##core#undefined#";
datatype Const.Symbol_l v2189 = Symbol_l(&v2188);
struct Value<datatype ValueD.Const_v> v2190 = { NULL,Const_v(&v2189) };
struct Exp<datatype ExpD.Const_e> v2191 = { NULL,Const_e(&v2190) };
exp_t v2192[] = { (exp_t)&v2187,&v2191,NULL };
struct Exp<datatype ExpD.Apply_e> v2186 = { NULL,Apply_e(v2192) };
struct Exp<datatype ExpD.Var_e> v2194 = { NULL,Var_e("cons",0,0) };
const char ?v2195 = "##core#undefined#";
datatype Const.Symbol_l v2196 = Symbol_l(&v2195);
struct Value<datatype ValueD.Const_v> v2197 = { NULL,Const_v(&v2196) };
struct Exp<datatype ExpD.Const_e> v2198 = { NULL,Const_e(&v2197) };
exp_t v2199[] = { (exp_t)&v2194,&v2198,NULL };
struct Exp<datatype ExpD.Apply_e> v2193 = { NULL,Apply_e(v2199) };
struct Exp<datatype ExpD.Var_e> v2201 = { NULL,Var_e("cons",0,0) };
const char ?v2202 = "##core#undefined#";
datatype Const.Symbol_l v2203 = Symbol_l(&v2202);
struct Value<datatype ValueD.Const_v> v2204 = { NULL,Const_v(&v2203) };
struct Exp<datatype ExpD.Const_e> v2205 = { NULL,Const_e(&v2204) };
exp_t v2206[] = { (exp_t)&v2201,&v2205,NULL };
struct Exp<datatype ExpD.Apply_e> v2200 = { NULL,Apply_e(v2206) };
struct Exp<datatype ExpD.Var_e> v2208 = { NULL,Var_e("cons",0,0) };
const char ?v2209 = "##core#undefined#";
datatype Const.Symbol_l v2210 = Symbol_l(&v2209);
struct Value<datatype ValueD.Const_v> v2211 = { NULL,Const_v(&v2210) };
struct Exp<datatype ExpD.Const_e> v2212 = { NULL,Const_e(&v2211) };
exp_t v2213[] = { (exp_t)&v2208,&v2212,NULL };
struct Exp<datatype ExpD.Apply_e> v2207 = { NULL,Apply_e(v2213) };
struct Exp<datatype ExpD.Var_e> v2215 = { NULL,Var_e("cons",0,0) };
const char ?v2216 = "##core#undefined#";
datatype Const.Symbol_l v2217 = Symbol_l(&v2216);
struct Value<datatype ValueD.Const_v> v2218 = { NULL,Const_v(&v2217) };
struct Exp<datatype ExpD.Const_e> v2219 = { NULL,Const_e(&v2218) };
exp_t v2220[] = { (exp_t)&v2215,&v2219,NULL };
struct Exp<datatype ExpD.Apply_e> v2214 = { NULL,Apply_e(v2220) };
struct Exp<datatype ExpD.Var_e> v2222 = { NULL,Var_e("cons",0,0) };
const char ?v2223 = "##core#undefined#";
datatype Const.Symbol_l v2224 = Symbol_l(&v2223);
struct Value<datatype ValueD.Const_v> v2225 = { NULL,Const_v(&v2224) };
struct Exp<datatype ExpD.Const_e> v2226 = { NULL,Const_e(&v2225) };
exp_t v2227[] = { (exp_t)&v2222,&v2226,NULL };
struct Exp<datatype ExpD.Apply_e> v2221 = { NULL,Apply_e(v2227) };
struct Exp<datatype ExpD.Var_e> v2229 = { NULL,Var_e("cons",0,0) };
const char ?v2230 = "##core#undefined#";
datatype Const.Symbol_l v2231 = Symbol_l(&v2230);
struct Value<datatype ValueD.Const_v> v2232 = { NULL,Const_v(&v2231) };
struct Exp<datatype ExpD.Const_e> v2233 = { NULL,Const_e(&v2232) };
exp_t v2234[] = { (exp_t)&v2229,&v2233,NULL };
struct Exp<datatype ExpD.Apply_e> v2228 = { NULL,Apply_e(v2234) };
struct Exp<datatype ExpD.Var_e> v2236 = { NULL,Var_e("cons",0,0) };
const char ?v2237 = "##core#undefined#";
datatype Const.Symbol_l v2238 = Symbol_l(&v2237);
struct Value<datatype ValueD.Const_v> v2239 = { NULL,Const_v(&v2238) };
struct Exp<datatype ExpD.Const_e> v2240 = { NULL,Const_e(&v2239) };
exp_t v2241[] = { (exp_t)&v2236,&v2240,NULL };
struct Exp<datatype ExpD.Apply_e> v2235 = { NULL,Apply_e(v2241) };
struct Exp<datatype ExpD.Var_e> v2243 = { NULL,Var_e("cons",0,0) };
const char ?v2244 = "##core#undefined#";
datatype Const.Symbol_l v2245 = Symbol_l(&v2244);
struct Value<datatype ValueD.Const_v> v2246 = { NULL,Const_v(&v2245) };
struct Exp<datatype ExpD.Const_e> v2247 = { NULL,Const_e(&v2246) };
exp_t v2248[] = { (exp_t)&v2243,&v2247,NULL };
struct Exp<datatype ExpD.Apply_e> v2242 = { NULL,Apply_e(v2248) };
struct Exp<datatype ExpD.Var_e> v2250 = { NULL,Var_e("cons",0,0) };
const char ?v2251 = "##core#undefined#";
datatype Const.Symbol_l v2252 = Symbol_l(&v2251);
struct Value<datatype ValueD.Const_v> v2253 = { NULL,Const_v(&v2252) };
struct Exp<datatype ExpD.Const_e> v2254 = { NULL,Const_e(&v2253) };
exp_t v2255[] = { (exp_t)&v2250,&v2254,NULL };
struct Exp<datatype ExpD.Apply_e> v2249 = { NULL,Apply_e(v2255) };
struct Exp<datatype ExpD.Var_e> v2257 = { NULL,Var_e("cons",0,0) };
const char ?v2258 = "##core#undefined#";
datatype Const.Symbol_l v2259 = Symbol_l(&v2258);
struct Value<datatype ValueD.Const_v> v2260 = { NULL,Const_v(&v2259) };
struct Exp<datatype ExpD.Const_e> v2261 = { NULL,Const_e(&v2260) };
exp_t v2262[] = { (exp_t)&v2257,&v2261,NULL };
struct Exp<datatype ExpD.Apply_e> v2256 = { NULL,Apply_e(v2262) };
struct Exp<datatype ExpD.Var_e> v2264 = { NULL,Var_e("cons",0,0) };
const char ?v2265 = "##core#undefined#";
datatype Const.Symbol_l v2266 = Symbol_l(&v2265);
struct Value<datatype ValueD.Const_v> v2267 = { NULL,Const_v(&v2266) };
struct Exp<datatype ExpD.Const_e> v2268 = { NULL,Const_e(&v2267) };
exp_t v2269[] = { (exp_t)&v2264,&v2268,NULL };
struct Exp<datatype ExpD.Apply_e> v2263 = { NULL,Apply_e(v2269) };
struct Exp<datatype ExpD.Var_e> v2271 = { NULL,Var_e("cons",0,0) };
const char ?v2272 = "##core#undefined#";
datatype Const.Symbol_l v2273 = Symbol_l(&v2272);
struct Value<datatype ValueD.Const_v> v2274 = { NULL,Const_v(&v2273) };
struct Exp<datatype ExpD.Const_e> v2275 = { NULL,Const_e(&v2274) };
exp_t v2276[] = { (exp_t)&v2271,&v2275,NULL };
struct Exp<datatype ExpD.Apply_e> v2270 = { NULL,Apply_e(v2276) };
struct Exp<datatype ExpD.Var_e> v2278 = { NULL,Var_e("cons",0,0) };
const char ?v2279 = "##core#undefined#";
datatype Const.Symbol_l v2280 = Symbol_l(&v2279);
struct Value<datatype ValueD.Const_v> v2281 = { NULL,Const_v(&v2280) };
struct Exp<datatype ExpD.Const_e> v2282 = { NULL,Const_e(&v2281) };
exp_t v2283[] = { (exp_t)&v2278,&v2282,NULL };
struct Exp<datatype ExpD.Apply_e> v2277 = { NULL,Apply_e(v2283) };
struct Exp<datatype ExpD.Var_e> v2285 = { NULL,Var_e("cons",0,0) };
const char ?v2286 = "##core#undefined#";
datatype Const.Symbol_l v2287 = Symbol_l(&v2286);
struct Value<datatype ValueD.Const_v> v2288 = { NULL,Const_v(&v2287) };
struct Exp<datatype ExpD.Const_e> v2289 = { NULL,Const_e(&v2288) };
exp_t v2290[] = { (exp_t)&v2285,&v2289,NULL };
struct Exp<datatype ExpD.Apply_e> v2284 = { NULL,Apply_e(v2290) };
struct Exp<datatype ExpD.Var_e> v2292 = { NULL,Var_e("cons",0,0) };
const char ?v2293 = "##core#undefined#";
datatype Const.Symbol_l v2294 = Symbol_l(&v2293);
struct Value<datatype ValueD.Const_v> v2295 = { NULL,Const_v(&v2294) };
struct Exp<datatype ExpD.Const_e> v2296 = { NULL,Const_e(&v2295) };
exp_t v2297[] = { (exp_t)&v2292,&v2296,NULL };
struct Exp<datatype ExpD.Apply_e> v2291 = { NULL,Apply_e(v2297) };
struct Exp<datatype ExpD.Var_e> v2299 = { NULL,Var_e("cons",0,0) };
const char ?v2300 = "##core#undefined#";
datatype Const.Symbol_l v2301 = Symbol_l(&v2300);
struct Value<datatype ValueD.Const_v> v2302 = { NULL,Const_v(&v2301) };
struct Exp<datatype ExpD.Const_e> v2303 = { NULL,Const_e(&v2302) };
exp_t v2304[] = { (exp_t)&v2299,&v2303,NULL };
struct Exp<datatype ExpD.Apply_e> v2298 = { NULL,Apply_e(v2304) };
struct Exp<datatype ExpD.Var_e> v2306 = { NULL,Var_e("cons",0,0) };
const char ?v2307 = "##core#undefined#";
datatype Const.Symbol_l v2308 = Symbol_l(&v2307);
struct Value<datatype ValueD.Const_v> v2309 = { NULL,Const_v(&v2308) };
struct Exp<datatype ExpD.Const_e> v2310 = { NULL,Const_e(&v2309) };
exp_t v2311[] = { (exp_t)&v2306,&v2310,NULL };
struct Exp<datatype ExpD.Apply_e> v2305 = { NULL,Apply_e(v2311) };
struct Exp<datatype ExpD.Var_e> v2313 = { NULL,Var_e("cons",0,0) };
const char ?v2314 = "##core#undefined#";
datatype Const.Symbol_l v2315 = Symbol_l(&v2314);
struct Value<datatype ValueD.Const_v> v2316 = { NULL,Const_v(&v2315) };
struct Exp<datatype ExpD.Const_e> v2317 = { NULL,Const_e(&v2316) };
exp_t v2318[] = { (exp_t)&v2313,&v2317,NULL };
struct Exp<datatype ExpD.Apply_e> v2312 = { NULL,Apply_e(v2318) };
struct Exp<datatype ExpD.Var_e> v2320 = { NULL,Var_e("cons",0,0) };
const char ?v2321 = "##core#undefined#";
datatype Const.Symbol_l v2322 = Symbol_l(&v2321);
struct Value<datatype ValueD.Const_v> v2323 = { NULL,Const_v(&v2322) };
struct Exp<datatype ExpD.Const_e> v2324 = { NULL,Const_e(&v2323) };
exp_t v2325[] = { (exp_t)&v2320,&v2324,NULL };
struct Exp<datatype ExpD.Apply_e> v2319 = { NULL,Apply_e(v2325) };
struct Exp<datatype ExpD.Var_e> v2327 = { NULL,Var_e("cons",0,0) };
const char ?v2328 = "##core#undefined#";
datatype Const.Symbol_l v2329 = Symbol_l(&v2328);
struct Value<datatype ValueD.Const_v> v2330 = { NULL,Const_v(&v2329) };
struct Exp<datatype ExpD.Const_e> v2331 = { NULL,Const_e(&v2330) };
exp_t v2332[] = { (exp_t)&v2327,&v2331,NULL };
struct Exp<datatype ExpD.Apply_e> v2326 = { NULL,Apply_e(v2332) };
struct Exp<datatype ExpD.Var_e> v2334 = { NULL,Var_e("cons",0,0) };
const char ?v2335 = "##core#undefined#";
datatype Const.Symbol_l v2336 = Symbol_l(&v2335);
struct Value<datatype ValueD.Const_v> v2337 = { NULL,Const_v(&v2336) };
struct Exp<datatype ExpD.Const_e> v2338 = { NULL,Const_e(&v2337) };
exp_t v2339[] = { (exp_t)&v2334,&v2338,NULL };
struct Exp<datatype ExpD.Apply_e> v2333 = { NULL,Apply_e(v2339) };
struct Exp<datatype ExpD.Var_e> v2341 = { NULL,Var_e("cons",0,0) };
const char ?v2342 = "##core#undefined#";
datatype Const.Symbol_l v2343 = Symbol_l(&v2342);
struct Value<datatype ValueD.Const_v> v2344 = { NULL,Const_v(&v2343) };
struct Exp<datatype ExpD.Const_e> v2345 = { NULL,Const_e(&v2344) };
exp_t v2346[] = { (exp_t)&v2341,&v2345,NULL };
struct Exp<datatype ExpD.Apply_e> v2340 = { NULL,Apply_e(v2346) };
struct Exp<datatype ExpD.Var_e> v2348 = { NULL,Var_e("cons",0,0) };
const char ?v2349 = "##core#undefined#";
datatype Const.Symbol_l v2350 = Symbol_l(&v2349);
struct Value<datatype ValueD.Const_v> v2351 = { NULL,Const_v(&v2350) };
struct Exp<datatype ExpD.Const_e> v2352 = { NULL,Const_e(&v2351) };
exp_t v2353[] = { (exp_t)&v2348,&v2352,NULL };
struct Exp<datatype ExpD.Apply_e> v2347 = { NULL,Apply_e(v2353) };
struct Exp<datatype ExpD.Var_e> v2355 = { NULL,Var_e("cons",0,0) };
const char ?v2356 = "##core#undefined#";
datatype Const.Symbol_l v2357 = Symbol_l(&v2356);
struct Value<datatype ValueD.Const_v> v2358 = { NULL,Const_v(&v2357) };
struct Exp<datatype ExpD.Const_e> v2359 = { NULL,Const_e(&v2358) };
exp_t v2360[] = { (exp_t)&v2355,&v2359,NULL };
struct Exp<datatype ExpD.Apply_e> v2354 = { NULL,Apply_e(v2360) };
struct Exp<datatype ExpD.Var_e> v2362 = { NULL,Var_e("cons",0,0) };
const char ?v2363 = "##core#undefined#";
datatype Const.Symbol_l v2364 = Symbol_l(&v2363);
struct Value<datatype ValueD.Const_v> v2365 = { NULL,Const_v(&v2364) };
struct Exp<datatype ExpD.Const_e> v2366 = { NULL,Const_e(&v2365) };
exp_t v2367[] = { (exp_t)&v2362,&v2366,NULL };
struct Exp<datatype ExpD.Apply_e> v2361 = { NULL,Apply_e(v2367) };
struct Exp<datatype ExpD.Var_e> v2369 = { NULL,Var_e("cons",0,0) };
const char ?v2370 = "##core#undefined#";
datatype Const.Symbol_l v2371 = Symbol_l(&v2370);
struct Value<datatype ValueD.Const_v> v2372 = { NULL,Const_v(&v2371) };
struct Exp<datatype ExpD.Const_e> v2373 = { NULL,Const_e(&v2372) };
exp_t v2374[] = { (exp_t)&v2369,&v2373,NULL };
struct Exp<datatype ExpD.Apply_e> v2368 = { NULL,Apply_e(v2374) };
struct Exp<datatype ExpD.Var_e> v2376 = { NULL,Var_e("cons",0,0) };
const char ?v2377 = "##core#undefined#";
datatype Const.Symbol_l v2378 = Symbol_l(&v2377);
struct Value<datatype ValueD.Const_v> v2379 = { NULL,Const_v(&v2378) };
struct Exp<datatype ExpD.Const_e> v2380 = { NULL,Const_e(&v2379) };
exp_t v2381[] = { (exp_t)&v2376,&v2380,NULL };
struct Exp<datatype ExpD.Apply_e> v2375 = { NULL,Apply_e(v2381) };
struct Exp<datatype ExpD.Var_e> v2383 = { NULL,Var_e("cons",0,0) };
const char ?v2384 = "##core#undefined#";
datatype Const.Symbol_l v2385 = Symbol_l(&v2384);
struct Value<datatype ValueD.Const_v> v2386 = { NULL,Const_v(&v2385) };
struct Exp<datatype ExpD.Const_e> v2387 = { NULL,Const_e(&v2386) };
exp_t v2388[] = { (exp_t)&v2383,&v2387,NULL };
struct Exp<datatype ExpD.Apply_e> v2382 = { NULL,Apply_e(v2388) };
struct Exp<datatype ExpD.Var_e> v2390 = { NULL,Var_e("cons",0,0) };
const char ?v2391 = "##core#undefined#";
datatype Const.Symbol_l v2392 = Symbol_l(&v2391);
struct Value<datatype ValueD.Const_v> v2393 = { NULL,Const_v(&v2392) };
struct Exp<datatype ExpD.Const_e> v2394 = { NULL,Const_e(&v2393) };
exp_t v2395[] = { (exp_t)&v2390,&v2394,NULL };
struct Exp<datatype ExpD.Apply_e> v2389 = { NULL,Apply_e(v2395) };
struct Exp<datatype ExpD.Var_e> v2397 = { NULL,Var_e("cons",0,0) };
const char ?v2398 = "##core#undefined#";
datatype Const.Symbol_l v2399 = Symbol_l(&v2398);
struct Value<datatype ValueD.Const_v> v2400 = { NULL,Const_v(&v2399) };
struct Exp<datatype ExpD.Const_e> v2401 = { NULL,Const_e(&v2400) };
exp_t v2402[] = { (exp_t)&v2397,&v2401,NULL };
struct Exp<datatype ExpD.Apply_e> v2396 = { NULL,Apply_e(v2402) };
struct Exp<datatype ExpD.Var_e> v2404 = { NULL,Var_e("cons",0,0) };
const char ?v2405 = "##core#undefined#";
datatype Const.Symbol_l v2406 = Symbol_l(&v2405);
struct Value<datatype ValueD.Const_v> v2407 = { NULL,Const_v(&v2406) };
struct Exp<datatype ExpD.Const_e> v2408 = { NULL,Const_e(&v2407) };
exp_t v2409[] = { (exp_t)&v2404,&v2408,NULL };
struct Exp<datatype ExpD.Apply_e> v2403 = { NULL,Apply_e(v2409) };
struct Exp<datatype ExpD.Var_e> v2411 = { NULL,Var_e("cons",0,0) };
const char ?v2412 = "##core#undefined#";
datatype Const.Symbol_l v2413 = Symbol_l(&v2412);
struct Value<datatype ValueD.Const_v> v2414 = { NULL,Const_v(&v2413) };
struct Exp<datatype ExpD.Const_e> v2415 = { NULL,Const_e(&v2414) };
exp_t v2416[] = { (exp_t)&v2411,&v2415,NULL };
struct Exp<datatype ExpD.Apply_e> v2410 = { NULL,Apply_e(v2416) };
struct Exp<datatype ExpD.Var_e> v2418 = { NULL,Var_e("cons",0,0) };
const char ?v2419 = "##core#undefined#";
datatype Const.Symbol_l v2420 = Symbol_l(&v2419);
struct Value<datatype ValueD.Const_v> v2421 = { NULL,Const_v(&v2420) };
struct Exp<datatype ExpD.Const_e> v2422 = { NULL,Const_e(&v2421) };
exp_t v2423[] = { (exp_t)&v2418,&v2422,NULL };
struct Exp<datatype ExpD.Apply_e> v2417 = { NULL,Apply_e(v2423) };
struct Exp<datatype ExpD.Var_e> v2425 = { NULL,Var_e("cons",0,0) };
const char ?v2426 = "##core#undefined#";
datatype Const.Symbol_l v2427 = Symbol_l(&v2426);
struct Value<datatype ValueD.Const_v> v2428 = { NULL,Const_v(&v2427) };
struct Exp<datatype ExpD.Const_e> v2429 = { NULL,Const_e(&v2428) };
exp_t v2430[] = { (exp_t)&v2425,&v2429,NULL };
struct Exp<datatype ExpD.Apply_e> v2424 = { NULL,Apply_e(v2430) };
struct Exp<datatype ExpD.Var_e> v2432 = { NULL,Var_e("cons",0,0) };
const char ?v2433 = "##core#undefined#";
datatype Const.Symbol_l v2434 = Symbol_l(&v2433);
struct Value<datatype ValueD.Const_v> v2435 = { NULL,Const_v(&v2434) };
struct Exp<datatype ExpD.Const_e> v2436 = { NULL,Const_e(&v2435) };
exp_t v2437[] = { (exp_t)&v2432,&v2436,NULL };
struct Exp<datatype ExpD.Apply_e> v2431 = { NULL,Apply_e(v2437) };
struct Exp<datatype ExpD.Var_e> v2439 = { NULL,Var_e("cons",0,0) };
const char ?v2440 = "##core#undefined#";
datatype Const.Symbol_l v2441 = Symbol_l(&v2440);
struct Value<datatype ValueD.Const_v> v2442 = { NULL,Const_v(&v2441) };
struct Exp<datatype ExpD.Const_e> v2443 = { NULL,Const_e(&v2442) };
exp_t v2444[] = { (exp_t)&v2439,&v2443,NULL };
struct Exp<datatype ExpD.Apply_e> v2438 = { NULL,Apply_e(v2444) };
struct Exp<datatype ExpD.Var_e> v2446 = { NULL,Var_e("cons",0,0) };
const char ?v2447 = "##core#undefined#";
datatype Const.Symbol_l v2448 = Symbol_l(&v2447);
struct Value<datatype ValueD.Const_v> v2449 = { NULL,Const_v(&v2448) };
struct Exp<datatype ExpD.Const_e> v2450 = { NULL,Const_e(&v2449) };
exp_t v2451[] = { (exp_t)&v2446,&v2450,NULL };
struct Exp<datatype ExpD.Apply_e> v2445 = { NULL,Apply_e(v2451) };
struct Exp<datatype ExpD.Var_e> v2453 = { NULL,Var_e("cons",0,0) };
const char ?v2454 = "##core#undefined#";
datatype Const.Symbol_l v2455 = Symbol_l(&v2454);
struct Value<datatype ValueD.Const_v> v2456 = { NULL,Const_v(&v2455) };
struct Exp<datatype ExpD.Const_e> v2457 = { NULL,Const_e(&v2456) };
exp_t v2458[] = { (exp_t)&v2453,&v2457,NULL };
struct Exp<datatype ExpD.Apply_e> v2452 = { NULL,Apply_e(v2458) };
struct Exp<datatype ExpD.Var_e> v2460 = { NULL,Var_e("cons",0,0) };
const char ?v2461 = "##core#undefined#";
datatype Const.Symbol_l v2462 = Symbol_l(&v2461);
struct Value<datatype ValueD.Const_v> v2463 = { NULL,Const_v(&v2462) };
struct Exp<datatype ExpD.Const_e> v2464 = { NULL,Const_e(&v2463) };
exp_t v2465[] = { (exp_t)&v2460,&v2464,NULL };
struct Exp<datatype ExpD.Apply_e> v2459 = { NULL,Apply_e(v2465) };
struct Exp<datatype ExpD.Var_e> v2467 = { NULL,Var_e("cons",0,0) };
const char ?v2468 = "##core#undefined#";
datatype Const.Symbol_l v2469 = Symbol_l(&v2468);
struct Value<datatype ValueD.Const_v> v2470 = { NULL,Const_v(&v2469) };
struct Exp<datatype ExpD.Const_e> v2471 = { NULL,Const_e(&v2470) };
exp_t v2472[] = { (exp_t)&v2467,&v2471,NULL };
struct Exp<datatype ExpD.Apply_e> v2466 = { NULL,Apply_e(v2472) };
struct Exp<datatype ExpD.Var_e> v2474 = { NULL,Var_e("cons",0,0) };
const char ?v2475 = "##core#undefined#";
datatype Const.Symbol_l v2476 = Symbol_l(&v2475);
struct Value<datatype ValueD.Const_v> v2477 = { NULL,Const_v(&v2476) };
struct Exp<datatype ExpD.Const_e> v2478 = { NULL,Const_e(&v2477) };
exp_t v2479[] = { (exp_t)&v2474,&v2478,NULL };
struct Exp<datatype ExpD.Apply_e> v2473 = { NULL,Apply_e(v2479) };
struct Exp<datatype ExpD.Var_e> v2481 = { NULL,Var_e("cons",0,0) };
const char ?v2482 = "##core#undefined#";
datatype Const.Symbol_l v2483 = Symbol_l(&v2482);
struct Value<datatype ValueD.Const_v> v2484 = { NULL,Const_v(&v2483) };
struct Exp<datatype ExpD.Const_e> v2485 = { NULL,Const_e(&v2484) };
exp_t v2486[] = { (exp_t)&v2481,&v2485,NULL };
struct Exp<datatype ExpD.Apply_e> v2480 = { NULL,Apply_e(v2486) };
struct Exp<datatype ExpD.Var_e> v2488 = { NULL,Var_e("cons",0,0) };
const char ?v2489 = "##core#undefined#";
datatype Const.Symbol_l v2490 = Symbol_l(&v2489);
struct Value<datatype ValueD.Const_v> v2491 = { NULL,Const_v(&v2490) };
struct Exp<datatype ExpD.Const_e> v2492 = { NULL,Const_e(&v2491) };
exp_t v2493[] = { (exp_t)&v2488,&v2492,NULL };
struct Exp<datatype ExpD.Apply_e> v2487 = { NULL,Apply_e(v2493) };
exp_t v2494[] = { (exp_t)&v1,&v2053,&v2060,&v2067,&v2074,&v2081,&v2088,&v2095,&v2102,&v2109,&v2116,&v2123,&v2130,&v2137,&v2144,&v2151,&v2158,&v2165,&v2172,&v2179,&v2186,&v2193,&v2200,&v2207,&v2214,&v2221,&v2228,&v2235,&v2242,&v2249,&v2256,&v2263,&v2270,&v2277,&v2284,&v2291,&v2298,&v2305,&v2312,&v2319,&v2326,&v2333,&v2340,&v2347,&v2354,&v2361,&v2368,&v2375,&v2382,&v2389,&v2396,&v2403,&v2410,&v2417,&v2424,&v2431,&v2438,&v2445,&v2452,&v2459,&v2466,&v2473,&v2480,&v2487 };
struct Exp<datatype ExpD.Apply_e> v0 = { NULL,Apply_e(v2494) };
exp_t prog() { return &v0; }
