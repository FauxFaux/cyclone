#include <stdio.h>
#include <list.h>

//  extern int rand();
//  extern void g(int,int);
int rand() { return 7; }
void g(int x, int y) {}

void f() {
  int *`U x = unew 3;
}

#ifdef ONE
int outoforder() {
  int d = 0;
  int *`U x = unew 3;
  int *`U y;
  while (!d || (y = x)) {
    if (rand())
      d = 1;
  }
  return x;
}
#endif

struct s1 {
  int x; int y;
};

// just checks basic variable stuff

int *`U h(int b) {
  int *`U x = unew 3;
  int *`U y = unew 4;
  int *`U z = unew 5;
  
  let a1 = unew { x, y };  // consumed = { x, y }

  x = unew 3; // consumed = { y }
  y = unew 3; // consumed = { }
  int ok = 1;
  int ?`U a2 = unew { (ok = rand(), (int)z), (ok ? (int)x : (int)y) }; // consumed = { x, y, z }

//    a2++; // consumed = { x, y, z }
  int yy = ((int)(int *`H)a2) * 1; // consumed = { x, y, z }
//    a2 = a2 + 1; // consumed = { x, y, z }

  y = unew 4; // consumed = { x, z }
  try {
    z = unew 5; // consumed = { x }
  } catch {
  case Core::Not_found:
    x = y; // consumed = { y, z }
    break;
  }
  // @join: consumed = { x, y, z }
  x = unew 3; // consumed = { y, z }
  int *`H h = (int *`H)x; // consumed = { x, y, z }

  struct s1 *`U ps1 = unew s1(1,2);
  int i;
  i = (*ps1).x;
  i = (*ps1).y;

  x = unew 5; // consumed = { y, z }
  y = unew 4; // consumed = { z }
  struct s1 ls1 = { (int)x, (int)y }; // consumed = { x, y, z }

  x = unew 3; // consumed = { y, z }

  g(*x,*x);
  i = *x;
  i = x[0];
  i = x[(x[0],0)];

  y = unew 3; // consumed = { z }

  switch (b) {
  case 1:
    z = x; // consumed = { x }
    fallthru;
  case 2:
    z = y; // consumed = { x, y }
    break;
  default:
    z = unew 7; // consumed = { }
    break;
  }
  // @join: consumed = { x, y }

 retry:
  x = z; // consumed = { y, z }
  if (b) {
    z = unew 7; // consumed = { y }
    b = rand();
    b = 0;
    goto retry; 
  }
  // @join: consumed = { y, z }

  y = unew 1; // consumed = { z }

  int zz;
  zz = ({ z; *y; y; }); // consumed = { y, z }

  y = (z = unew 4, unew 1); // consumed = { z } DUE TO ANALYSIS INACCURACY

  while (i < 5) {
    x = y; // consumed = { y, z }
    y = x; // consumed = { x, z }
    i++;
  }
  // @join: consumed = { x, z }

  do {
    z = y; // consumed = { x, y, z }
    y = z; // consumed = { x, z }
    i--;
  } while ((x = unew 4) && (i > 0));
  // @join: consumed = { z }

  for (i=0, y = x /* consumed = { z, x } */; i<5; i++) {
    z = y; // consumed = { x, y }
    break;
  }
  // @join: consumed = { x, y, z }

  if (b) // b is 0 due to above test, so first clause not invoked
    y = z;
  else
    y = unew 5; // consumed = { x, z }
  // @join: consumed = { x, z }

  Core::ufree(y);

  y = unew 7;
  return y;
}

// can be parameterized by either kind of region
struct Mylist<`a,`r::TR> {
  `a hd;
  struct Mylist<`a,`r> *`r tl;
};
typedef struct Mylist<`a,`r> *`r mylist_u_t<`a,`r>;

// this checks paths, etc.
int p(int b) {
  struct Mylist<int,`U> e = Mylist(1,NULL);
  e.tl = unew Mylist(3,NULL);
//    mylist_u_t l = e.tl;
}

// for testing aggregates

struct foo {
  int *`U x;
  int *`U y;
};

void f2(int b) {
  struct foo f = { unew 1, unew 2 };
  struct foo g;
  g = f; // this should consume f.0 and f.1
//   Core::ufree(f.x); // not allowed
  Core::ufree(g.x);
  g.x = NULL;
  struct foo @ h = new foo(unew 1, unew 2);
  cycswap(g.x,h->x);
  $(int *`U, int *`U) tup = $(g.x, g.y);
  g.x = tup[0];
  g.y = tup[1];
}

struct g { int *`U x; int *`U y; };
struct f { int *`U x; struct g y; };

void f3(int b) {
  struct f z;
  z.y.x = unew 1;
  z.y.y = unew 2;
  struct g zg = z.y;
  Core::ufree(zg.x);
  zg.x = NULL;
  struct f @pf = new f(unew 1, g(NULL,unew 2));
  cycswap(zg.x,(pf->y).x);
  (pf->y).x = NULL;
}

int main() {
  int *`U v = h(1);
  Core::ufree(v);
  return 0;
}

