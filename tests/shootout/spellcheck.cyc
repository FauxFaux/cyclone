/*
 * http://www.bagley.org/~doug/shootout/
 */

#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include "simple_hash_cyc.h"
#include "timer.h"

#define MAXLINELEN 128

char ?`U strrealloc(char ?buf, unsigned sz) {
  char ?`U res = calloc(sz,sizeof(char));
  unsigned i = numelts(buf);
  for (unsigned j = 0; j < i; j++)
    res[j] = buf[j];
  return res;
}

int main(int argc, char ?argv[]) {
    int i, wordbufsize = 80;
    char line[MAXLINELEN+1]ZEROTERM = {for i < MAXLINELEN : 0};
    char c, ?cp, ?`U wordbuf;
    struct ht_ht @dict;
    FILE *fh;
    START_TIME
    wordbuf = calloc(wordbufsize + 1,sizeof(char));
    dict = ht_create(40000);
    if ((fh = fopen("words.txt", "r")) == NULL) {
	perror("fopen");
	exit(1);
    }
    i = 0;
    while (fgets(line, MAXLINELEN, fh)) {
	for (cp=line; *cp > 0; cp++) {
	    if (isspace(*cp)) {
		if (i > 0) {
		    wordbuf[i] = '\0';
		    alias <`r> x = (char ?`r)wordbuf;
		    ht_find_new(dict, x)->val = 1;
		    i = 0;
		}
	    } else {
		wordbuf[i++] = *cp;
		if (i == wordbufsize) {
		    wordbufsize *= 2;
		    wordbuf = strrealloc(wordbuf, wordbufsize + 1);
		}
	    }
        }
    }
    fclose(fh);

    i = 0;
    while (fgets(line, MAXLINELEN, stdin)) {
	for (cp=line; *cp > 0; cp++) {
	    if (isspace(*cp)) {
		if (i > 0) {
		    wordbuf[i] = '\0';
		    { alias <`r> xwordbuf = (char ?`r)wordbuf;
		    if (ht_find(dict, xwordbuf) == NULL) {
			printf("%s\n", xwordbuf);
		    }
		    }
		    i = 0;
		}
	    } else {
		wordbuf[i++] = *cp;
		if (i == wordbufsize) {
		    wordbufsize *= 2;
		    wordbuf = strrealloc(wordbuf, wordbufsize + 1);
		}
	    } 
        }
    }
    Core::ufree(wordbuf);
    ht_destroy(dict);
    END_TIME
    return(0);
}
