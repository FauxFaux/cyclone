/*
 * http://www.bagley.org/~doug/shootout/
 */

#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>
#include <string.h>
#include "simple_hash_cyc.h"
#include "timer.h"

int cmp_hash(struct ht_node *`H const @`H a, struct ht_node *`H const @`H b) {
    int val = (*b)->val - (*a)->val;
    return((val == 0) ? strcmp((*b)->key, (*a)->key) : val);
}

char ?`U strrealloc(char ?buf, unsigned sz) {
  char ?`U res = calloc(sz,sizeof(char));
  unsigned i = numelts(buf);
  for (unsigned j = 0; j < i; j++)
    res[j] = buf[j];
  return res;
}

int main() {
    int bufsize = 80;
    char ?`U buf;
    char c;
    int i = 0;
    struct ht_ht @ht;
    struct ht_node *?sort_array, *?sort_tmp, *node;
    START_TIME
    buf = calloc(bufsize + 1,sizeof(char));
    ht = ht_create(75000);

    while ((c = getchar()) > 0) {
        if (isalpha(c)) {
            buf[i++] = tolower(c);
	    if (i == bufsize) {
                bufsize *= 2;
                buf = strrealloc(buf, bufsize + 1);
	    } 
        } else {
	    if (i > 0) {
		buf[i] = '\0';
		{ alias <`r> xbuf = (char ?`r)buf;
		++(ht_find_new(ht, xbuf)->val); }
		i = 0;
	    }
        }
    }
    Core::ufree(buf);

    sort_array = sort_tmp =
        calloc(ht_count(ht)+1,sizeof(struct ht_node *));

    for (node=ht_first(ht); (*sort_tmp++ = node) != 0; node=ht_next(ht)) ;

    qsort(sort_array, ht_count(ht), sizeof(struct ht_node *),
	  cmp_hash);

    for (i=0; i<ht_count(ht); i++)
	printf("%7d\t%s\n", ht_val(sort_array[i]), ht_key(sort_array[i])); 

    ht_destroy(ht);
    END_TIME
    return(0);
}
