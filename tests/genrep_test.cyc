//#define ABSYN_CYC

#include <stdio.h>
#include <typerep.h>
#include "marshal.h"
#include <list.h>
#include "../src/absyn.h"

using List;
using Typerep;
using Marshal;

#define NEW
//#define TEST


typedef union Bar {
  int x;
  double y;
} bar_t;

/* Example types */
typedef tunion Foo {
  Foo1;
  Foo2(int,int);
  Foo3(float);
  Foo4(int,tunion Foo);
} foo_t; 


typedef struct Intlist {
  unsigned int val;
  struct Intlist * next;
} intlist_t;


extern struct Inttree;
typedef struct Inttree inttree_t;

struct Inttree {
  unsigned int val;
  inttree_t * left;
  inttree_t * right;
};

enum Enum { A, B, C};
typedef enum Enum enum_t;


struct Layout {
  char a;
  char b;
  double c;
  char d;
  int e;
};

typedef $(char,char,double,char,int) layout_t;
#ifdef TEST 

// base types
tunion Typestruct int_rep = gen(int);
tunion Typestruct float_rep = gen(float);
tunion Typestruct double_rep = gen(double);

// ptrs/arrays
tunion Typestruct arr_rep = gen(int[5]);
tunion Typestruct ptr_rep = gen(int*);
tunion Typestruct fptr_rep = gen(int?);
tunion Typestruct arr_rep2 = gen(int[7][6][5]);

// tuples
tunion Typestruct tuple_rep = gen($(double,$(int,int)));
// typedefs
typedef $(int,float)@ pair_t;
// tunions
tunion Typestruct pair_t_rep = gen(pair_t);
struct Pair {
  float a;
  int b;
};
tunion Typestruct pair_rep = gen(struct Pair);
typedef struct {
  int a;
  int b;
  int c;
} triple_t;


tunion Typestruct triple_rep = gen(triple_t);

// recursive structs
tunion Typestruct intlist_rep = __gen(intlist_t );
tunion Typestruct inttree_rep = __gen(inttree_t );

// enums
tunion Typestruct enum_rep = __gen(enum_t);

// tunionfields
tunion Typestruct tunionfield_rep = __gen(tunion Foo.Foo2);

// recursive tunions
tunion Typestruct foo_rep = __gen(foo_t);
// unions
tunion Typestruct bar_rep = __gen(bar_t);

// test recursive structs with parameters
tunion Typestruct list_rep = __gen(list_t<int>);




// test forward declarations for structs
extern  struct Zot3;
typedef struct Zot3 zot3_t;
struct Zot3 {
  int a;
  zot3_t * b;
};


tunion Typestruct zot3_rep = __gen(zot3_t);

// test forward declarations for unions

extern  union Zot4;
typedef union Zot4 zot4_t;
union Zot4 {
  int a;
  zot3_t * b;
};
tunion Typestruct zot4_rep = __gen(zot4_t);

// test fwd decls for enums
extern enum Zot;
typedef enum Zot zot_t;
enum Zot {FF,GG};
tunion Typestruct zot_rep = __gen(zot_t);

// test forward declarations for tunions
extern  tunion Zot2;
typedef tunion Zot2 zot2_t;
tunion Zot2 {
  AA(int);
  BB(zot2_t);
  };
tunion Typestruct zot2_rep = __gen(zot2_t);

struct Two<`a> {
  `a x;
  `a y;
} ;

tunion Typestruct two_rep = __gen(struct Two<int>);

// test tunions with parameters

tunion maybe<`a> {
  None;
  Some(`a);
};

tunion Typestruct sum_rep = __gen(tunion maybe<int>);

// test unions with parameters
// not allowed in any meaningful sense
union cast<`r::R> {
  int cast_val;
  float val;
};

tunion Typestruct cast_rep = __gen(union cast<`H>);



#endif

#ifdef NEW

// test structs with bitfields

struct bitfield {
  int z : 1;
  int x : 2;
  int c : 3;
};

tunion Typestruct bitfield_rep = __gen(struct bitfield);

//tunion Typestruct decl_rep = __gen(Absyn::scope_t);
//tunion Typestruct decl2_rep = __gen(Absyn::tqual_t);
//tunion Typestruct decl3_rep = __gen(Absyn::size_of_t);
//tunion Typestruct decl4_rep = __gen(Absyn::kind_t);
//tunion Typestruct decl5_rep = __gen(Absyn::tvar_t);
//tunion Typestruct decl6_rep = __gen(Absyn::sign_t);
//tunion Typestruct decl7_rep = __gen(Absyn::bounds_t); fndecl 
//tunion Typestruct decl8_rep = __gen(Absyn::ptr_info_t);
//tunion Typestruct decl9_rep = __gen(Absyn::vararg_info_t); fndecl
//tunion Typestruct decl10_rep = __gen(Absyn::fn_info_t); fndecl
tunion Typestruct decl11_rep = __gen(Absyn::decl_t);
#endif


extern "C" `b unsafe_cast<`b,`a>(`a x);

void do_print(tunion Typestruct rep, `a val) {
  int @foo = unsafe_cast(val);
  if(foo == NULL) printf("NULL");
  else print_type(rep,foo);
  printf("\n");
}

void do_xmlize(tunion Typestruct rep, `a val) {
  int @foo = unsafe_cast(val);
  if(foo == NULL) printf("<null>");
  else xmlize_type(rep,foo);
  printf("\n");
}



void main() {

#ifdef TEST
  int i = 0xffffffff;
  do_print(int_rep,&i);
  do_xmlize(int_rep,&i);
  float j = 1.2345678;
  do_print(float_rep,&j);
  do_xmlize(float_rep,&j);
  double k = 1.23456789101112;
  do_print(double_rep,&k);
  do_xmlize(double_rep,&k);
  // FIX: Make interface to print_type more uniform
  // Avoid type dependence of whether to take address of argument
  int* ip = &i;
  do_print(ptr_rep,ip);
  do_xmlize(ptr_rep,ip);

  // FIX/DANGER: Because of unsafe casting, float constants don't get promoted
  // to doubles automatically, so testing this is tricky.  There's
  // no real bug, you just have to remember to make the doubleness explicit.
  let t = $((double)1.0,$(20,300));
  do_print(tuple_rep,&t);
  do_xmlize(tuple_rep,&t);

  // Typedef test
  let td = $(1,55.5);
  do_print(pair_t_rep,&td);
  do_xmlize(pair_t_rep,&td);

  // Struct test: nonrecursive
  let ps = Pair{.a = 310.1, .b = 7};
  do_print(pair_rep,&ps);
  do_xmlize(pair_rep,&ps);

  // Anon struct test: this should work if above does
  // But: scares the heck out of C compiler!  Lots of warnings
  triple_t ts;
  ts.a = 1;
  ts.b = 2;
  ts.c = 3;
  do_print(triple_rep,&ts);
  do_xmlize(triple_rep,&ts);

  struct Intlist * g = NULL;
  do_print(intlist_rep,g);
  do_xmlize(intlist_rep,g);
  g = new Intlist{.val=(unsigned int)6,.next=NULL};

  do_print(intlist_rep,g);
  do_xmlize(intlist_rep,g);

  g = new Intlist{.val=(unsigned int)5,.next=new Intlist{.val=(unsigned int)6,.next=new Intlist{.val = (unsigned int)7, .next=NULL}}};


  do_print(intlist_rep,g);
  do_xmlize(intlist_rep,g);


  inttree_t* h = NULL;
  do_print(inttree_rep,h);
  do_xmlize(inttree_rep,h);
  
  inttree_t* h = new Inttree{.val=5,.left=NULL,.right=NULL};
  do_print(inttree_rep,h);
  do_xmlize(inttree_rep,h);
  inttree_t* h = new Inttree{.val=5,.left=new Inttree{.val=4,.left=NULL,.right=NULL},.right=new Inttree{.val=6,.left=NULL,.right=NULL}};
  do_print(inttree_rep,h);
  do_xmlize(inttree_rep,h);

  enum_t en = A;
  do_print(enum_rep,&en);
  do_xmlize(enum_rep,&en);

  tunion Foo.Foo2 blah = Foo2(12,34);
  do_print(tunionfield_rep, &blah);
  do_xmlize(tunionfield_rep,&blah);

  tunion Foo f;

  f = Foo1;
  do_print(foo_rep,f);
  do_xmlize(foo_rep,f);

  f = new Foo2(1,2);
  do_print(foo_rep,f);
  do_xmlize(foo_rep,f);

  f = new Foo3(1.245);
  do_print(foo_rep,f);
  do_xmlize(foo_rep,f);

  f = new Foo4(1,f);
  do_print(foo_rep,f);
  do_xmlize(foo_rep,f);


  let l = List::list(1,2,3,4);
  do_print(list_rep,l);
  do_xmlize(list_rep,l);

#endif
  
#ifdef CYCLE
  //demonstration that cycles break things
  intlist_t * cycle = new Intlist{.val = (unsigned int) 6, .next = NULL};
  h->next = cycle;
  do_print2(cycle);
  do_xmlize2(cycle);
#endif  
}

