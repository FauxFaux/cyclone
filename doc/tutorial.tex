\section{Cyclone for C Programmers}

We begin with a quick overview of Cyclone, suitable for those who
already know how to program in C\@.  We'll explain some of the ways
that Cyclone differs from C, and some of the reasons why; you should
come away with enough knowledge to start writing, compiling, and
running your own Cyclone programs.  We assume that the Cyclone
compiler is already installed on your system (see
Appendix~\ref{sec:install} or the Cyclone web site if you need to
install the compiler).

\subsection{Getting Started}

Here's a Cyclone program that prints the words ``\texttt{hello,
  world}.''
\begin{verbatim}
    #include <stdio.h>
    using Stdio;

    int main() {
      printf("hello, world\n");
      return 0;
    }
\end{verbatim}

Except for the \texttt{using} statement, it looks very much like a C
program: it uses \texttt{\#include} to tell the preprocessor to import
some standard definitions, it defines a distinguished function
\texttt{main} that serves as the entry point of the program, and it
uses the familiar \texttt{printf} function to handle the printing.  To
compile the program, put it into a file \texttt{hello.cyc}, and run
the command
\begin{verbatim}
    cyclone hello.cyc -o hello
\end{verbatim}
This tells the Cyclone compiler (\texttt{cyclone}) to compile the file
\texttt{hello.cyc}; the \texttt{-o} flag tells the compiler to leave
the executable output in the file \texttt{hello} (or, in Windows,
\texttt{hello.exe}).  If all goes well you can execute the program by
typing
\begin{verbatim}
    hello
\end{verbatim}
and it will print
\begin{verbatim}
    hello, world
\end{verbatim}

It's interesting to compare our program with a version written in C:
\begin{verbatim}
    #include <stdio.h>

    int main() {
      printf("hello, world\n");
    }
\end{verbatim}

A C compiler will happily compile and run the C version.  However,
it's not valid Cyclone code: it will be rejected by the Cyclone
compiler, for a couple of reasons.  The first reason is that the C
version omits a \texttt{return} statement.  Cyclone requires a
\emph{definite return}: any function with a return type other than
\texttt{void} must explicitly return a value of the correct type.
Since \texttt{main} is declared with return type \texttt{int}, the
Cyclone version makes sure to return a 0.

Definite return is important for both safety and security.  The caller
of the function expects to receive a value of the return type; if the
function does not execute a \texttt{return} statement, the caller will
receive some random value instead.  This could easily lead to a crash
(for example, the caller might expect a pointer to be returned).  We
don't expect that problem here (since the return type is
\texttt{int}), but there is another problem: the random value returned
is probably drawn from the space occupied by local variables of the
function.  The caller can exploit this to inspect the internal
variables of the function, leading to a security breach.

The second reason that Cyclone rejects the C version is that it omits
the \texttt{using} statement.  The \texttt{using} statement is
necessary because Cyclone wraps all of its standard library
definitions in C++ \emph{namespaces}.  A namespace is essentially a
named scope: it associates a name with a set of declarations.  For
example, the file \texttt{<stdio.h>} looks, in part, like this:
\begin{alltt}
    namespace Stdio \lb
      {\it \ldots\ declarations \ldots}
      extern int fflush(FILE *);
    \rb
\end{alltt}
All of the declarations found in C's version of \texttt{<stdio.h>},
including the one for the \texttt{fflush} function shown here, are
contained within the namespace \texttt{Stdio}.  Once you've included
the \texttt{<stdio.h>} file, you can refer to the variables in the
namespace by prefixing them with \texttt{Stdio}, for example,
\texttt{Stdio::fflush}.  If you don't want to use the \texttt{::}
notation, you can make all of the variables within \texttt{Stdio}
available with a \texttt{using} statement.  So, in our \texttt{hello}
program, the statement \texttt{using Stdio;} allowed us to refer to
the \texttt{printf} function as just \texttt{printf}, rather than
\texttt{Stdio::printf}.

Namespaces allow two programmers to choose names without worrying that
they will clash with each other.  For example, if you like you can
define your own version of the \texttt{printf} function, and use your
\texttt{printf} and \texttt{Stdio::printf} in the same program.  When
namespaces are used properly, they isolate one programmer's internal
variables from another's, enhancing safety.

\subsection{Pointers}

Programs that use pointers properly in C can be both fast and elegant.
But when pointers are used improperly in C, they cause core dumps and
buffer overflows.  To prevent this, Cyclone puts some restrictions on
how you can use pointers.

There are actually several kinds of pointers in Cyclone.  The first
kind of pointer is indicated with a \texttt{*}, as in C.  For example,
if we declare
\begin{verbatim}
    int x = 3;
    int *y = &x;
\end{verbatim}
then \texttt{y} is a pointer to the integer 3 (the contents of
\texttt{x}).  The pointer, \texttt{y}, is represented by a memory
address, namely, the address of \texttt{x}.  To refer to the contents
of \texttt{y}, you use \texttt{*y}, so, for example, you can increment
the value of \texttt{x} with an assignment like
\begin{verbatim}
    *y = *y + 1;
\end{verbatim}

This much is just as in C\@.  However, there are some differences in
Cyclone:
\begin{itemize}
\item You can't cast an integer to a pointer.  Cyclone prevents this
  because it would let you overwrite arbitrary memory locations.  In
  fact, you can't use \texttt{(void *)0} (C's typical definition of
  \texttt{NULL}) as a pointer in Cyclone.  Instead, Cyclone provides a
  new keyword, \texttt{null}, for writing the null pointer.  (Also,
  \texttt{NULL} is macro-defined as \texttt{null} in Cyclone's
  \texttt{<stddef.h>}.)
\item You can't do pointer arithmetic on a \texttt{*} pointer.
  Pointer arithmetic in C can take a pointer out of bounds, so that
  when the pointer is eventually dereferenced, it corrupts memory or
  causes a crash.
\item There is one other way to crash a C program using pointers: you
  can dereference the null pointer or try to update the null location.
  Cyclone prevents this by inserting a null check whenever you
  dereference a \texttt{*} pointer or try to assign to its contents.
\end{itemize}

These are drastic differences from C, particularly the restriction on
pointer arithmetic.  The benefit is that you can't cause a crash using
\texttt{*} pointers in Cyclone.

\subsubsection*{Pointer arithmetic}

If you need to do pointer arithmetic in Cyclone, you must use a second
kind of pointer, indicated by \texttt{?}\ (the question mark).  For
example, here is a program that echoes its command line arguments:
\begin{verbatim}
    int main(int argc, char ??argv) {
      argc--; argv++; /* skip command name */
      if (argc > 0) {
        /* print first arg without a preceding space */
        printf("%s",*argv);
        argc--; argv++;
      }
      while (argc > 0) {
        /* print other args with a preceding space */
        printf(" %s",*argv);
        argc--; argv++;
      }
      printf("\n");
      return 0;
    }
\end{verbatim}

Except for the declaration of \texttt{argv}, which holds the
command-line arguments, the program looks just like you would write it
in C: pointer arithmetic (\texttt{argv++}) is used to move
\texttt{argv} to point to each argument in turn, so it can be printed.

In C, \texttt{argv} would typically be declared with type \texttt{char
  **}, a pointer to a pointer to a character, which is thought of as
an array of an array of characters.  In Cyclone, \texttt{argv} is
instead declared with type \texttt{char ??}, which is thought of in
the same way: it is a pointer to a pointer to characters.  The
difference between a \texttt{*} pointer and a \texttt{?}\ pointer is
that a \texttt{?}\ pointer comes with bounds information.  Each time a
\texttt{?}\ pointer is dereferenced or its contents are assigned to,
Cyclone inserts not only a null check but a bounds check.  This
guarantees that a \texttt{?}\ pointer can never cause a buffer
overflow.

Because of the bounds information contained in \texttt{?}\ pointers,
\texttt{argc} is superfluous: you can get the size of \texttt{argv} by
writing \texttt{argv.size}.  We've kept \texttt{argc} as an argument
of \texttt{main} for backwards compatibility.

\subsubsection*{Never-null pointers}

There is one other kind of pointer in Cyclone: the never-null pointer.
A never-null pointer is indicated by \texttt{@} (the at sign).  An
\texttt{@} pointer is like a \texttt{*} pointer, except that it is
guaranteed not to be null.  This means that when you dereference an
\texttt{@} pointer or assign to its contents, a null check is
unnecessary.

\texttt{@} pointers are useful in Cyclone for both efficiency and
documentation.  This can be seen at work in the standard library,
where many functions take \texttt{@} pointers as arguments, or return
\texttt{@} pointers as results.  For example, the \texttt{getc}
function that reads a character from a file is declared,
\begin{verbatim}
    int getc(FILE @);
\end{verbatim}
This says that \texttt{getc} expects to be called with a non-null
pointer to a \texttt{FILE}\@.  Cyclone guarantees that, in fact, when
the \texttt{getc} function is entered, its argument is not null.  This
means that \texttt{getc} does not have to test whether it is null, or
decide what to do if it is in fact null.

In C, the argument of \texttt{getc} is declared to have type
\texttt{FILE *}, and programmers can call \texttt{getc} with
\texttt{NULL}\@.  So for safety, C's \texttt{getc} ought to check for
\texttt{NULL}\@.  In practice, many C implementations omit the check,
so that \texttt{getc(NULL)} is an easy way to crash a program.

In Cyclone, you can still call \texttt{getc} with a possibly-null
\texttt{FILE} pointer (a \texttt{FILE *}).  However, Cyclone insists
that you insert a check before the actual call:
\begin{verbatim}
    FILE *f = fopen("/etc/passwd","r");
    int c = getc((FILE @)f);
\end{verbatim}
Here \texttt{f} will be null if the file \texttt{/etc/passwd} doesn't
exist or can't be read.  So, in Cyclone \texttt{f} must be cast to
\texttt{FILE @} before the call to \texttt{getc}.  The cast causes a
null check.  If you try to call \texttt{getc} without the cast,
Cyclone will insert one for you automatically, and warn you that it is
doing so.

If you call \texttt{getc} with a \texttt{FILE @}, of course, no check
is required.  For example, \texttt{stdin} is a \texttt{FILE @} in
Cyclone, so you can simply call \texttt{getc(stdin)}.  In Cyclone you
will find that many functions return \texttt{@} pointers, so, many of
the pointers you deal with will already be \texttt{@} pointers, and
neither the caller nor the called function needs to do null checks.

\subsubsection*{Other features of pointers}

There's much more to Cyclone pointers than we've described here.
A pointer type can also specify that it points to a particular
\emph{region} of memory, or that it points to a sequence of known
length.  See Section~\ref{sec:pointers} for details.

\subsection{Tagged Unions and Pattern Matching}

It's often necessary to write a function that accepts an argument with
more than one possible type.  For example, in
\begin{verbatim}
    printf("%d",x);
\end{verbatim}
\texttt{x} should be an integer, but in
\begin{verbatim}
    printf("%s",x);
\end{verbatim}
\texttt{x} should be a pointer to a sequence of characters.

If we call \texttt{printf("\%s",x)} with an integer \texttt{x},
instead of a pointer \texttt{x}, the program will likely crash.
To prevent this, most C compilers treat \texttt{printf} specially:
they examine the first argument and require that the remaining
arguments have the appropriate types.  However, a compiler can't check
this if \texttt{printf} isn't called with a literal string:
\begin{verbatim}
    printf(s,x);
\end{verbatim}
where \texttt{s} is a string variable.  This means that in C, programs
that use \texttt{printf} (or \texttt{scanf}, or a number of related
functions) are vulnerable to crashes and corrupted memory.  In fact,
it's possible for someone else to crash your program by causing it to
call \texttt{printf} with arguments that don't match the format
string.  This is called a \emph{format string attack}, and it's an
increasingly common exploit.

Cyclone provides \emph{tagged unions} so that you can safely write
functions that accept an argument with more than one possible type.
Like a C \texttt{union}, a Cyclone \texttt{tunion} is a type that has
several possible cases.  Here's a simple example:
\begin{verbatim}
    tunion t {
      Integer(int);
      String(char ?);
    };
    tunion t x = new Integer(3);
    tunion t y = new String("hello, world");
\end{verbatim}
This declares a new type, \texttt{tunion t}, that can hold either an
integer or a string (remember, a string is a \texttt{char ?}\ in
Cyclone).  \texttt{Integer} and \texttt{String} are \emph{tags} for
the two possibilities.  The tags are used to build values of type
\texttt{tunion t}, as in the declarations of \texttt{x} and
\texttt{y}.

\emph{Pattern matching} is used to determine the tag of a value of
type \texttt{tunion t}, and to extract the underlying value.  For
example, here is a function that will print either an integer or a
string:
\begin{verbatim}
    void print(tunion t a) {
      switch (a) {
      case &Integer(i): printf("%d",i); return;
      case &String(s): printf("%s",s); return;
      }
    }
\end{verbatim}
The argument \texttt{a} has type \texttt{tunion t}, so it is either
built with tag \texttt{Integer} or tag \texttt{String}.  Cyclone
extends \texttt{switch} statements with \emph{patterns} that
distinguish between the cases.  The first case,
\begin{verbatim}
   case &Integer(i): printf("%d",i); return;
\end{verbatim}
contains a pattern, \texttt{\&Integer(i)}, that will only match values
that have been built with the \texttt{Integer} tag.  The variable
\texttt{i} is bound to the underlying integer, and it can be used in
the body of the case.  For example, \texttt{print(x)} will print 3,
since \texttt{x} was initialized by \texttt{new Integer(3)}.

The cases of a \texttt{tunion} can carry any number of values,
including none, and they can be recursive.  For example, we can define
a tree datatype as follows.
\begin{verbatim}
    tunion tree {
      Empty;
      Leaf(int);
      Node(tunion tree, tunion tree);
    };
\end{verbatim}
A tree can be empty, or it can be a single (leaf) node holding an
integer, or it can be an internal node with a left and a right
subtree.  In other words, \texttt{tunion tree} is the type of possibly
empty binary trees with integer leaves.

Here's a function, \texttt{sum}, that calculates the sum of the leaves
of a tree:
\begin{verbatim}
    int sum(tunion tree x) {
      switch (x) {
      case Empty: return 0;
      case &Leaf(i): return i;
      case &Node(y,z): return sum(y)+sum(z);
      }
    }
\end{verbatim}

It's written in a straightforward way, with a case for each possible
tag in the type \texttt{tunion tree}.  The \texttt{Empty} case is
noticeably different than the other two cases: the pattern does not
use the \texttt{\&} character.  The reason has to do with how
\texttt{tunion} is implemented.  Every value of \texttt{tunion} type
must have the same size; for example, the \texttt{Node} case
recursively calls \texttt{sum} on the subtrees \texttt{y} and
\texttt{z}, \emph{without knowing} whether they are empty, leaves, or
internal nodes.  The only way that it can extract \texttt{y} and
\texttt{z} from \texttt{x} without knowing this is if all possible
cases of \texttt{tunion tree} have the same size.

At the same time, each tag of a \texttt{tunion} can carry a different
number of values, so obviously each can require a different amount of
space.  To make it all work, the value-carrying cases of a
\texttt{tunion} are represented as pointers to structures containing a
distinguishing integer plus the values, and the non-value-carrying
cases of a \texttt{tunion} are represented just as distinguishing
integers.  Since integers and pointers have the same size in Cyclone,
this achieves the goal.

The data representation is reflected both in how \texttt{tunion}
values are constructed and in the patterns used to take them apart.
Value-carrying cases are built using the \texttt{new} keyword, which
performs a heap allocation and results in a pointer to the new
storage.  Non-value-carrying cases don't require any allocation, and
so they don't use \texttt{new}.  For example,
\begin{verbatim}
   new Node(Empty,new Leaf(5))
\end{verbatim}
builds a tree consisting of an internal node with an empty left
subtree, and a right subtree consisting of a single leaf, 5.  We use
\texttt{new} for the value-carrying cases, \texttt{Node} and
\texttt{Leaf}, but not for \texttt{Empty}.

In pattern matching, we use the \texttt{\&} character to match a
pointer.  So in the function \texttt{sum}, since \texttt{Leaf} and
\texttt{Node} are constructed as pointers, the \texttt{\&} is required
to match them.  Since \texttt{Empty} is not built as a pointer, the
\texttt{\&} is not needed.

You might be wondering, how does Cyclone tell whether a
\texttt{tunion} comes from a value-carrying case or a
non-value-carrying case?  In particular, how can Cyclone tell the
integers used for non-value-carrying cases apart from the pointers
used for the other cases?  Here's how we do it in our current
implementation.  We reserve a space in the low part of memory where we
will never allocate Cyclone objects using \texttt{new}.  If a value of
a \texttt{tunion} is an address in this space, then it represents a
tag without values, and if it is an address outside of this space, it
represents a pointer to a structure containing a tag plus the values
that it carries.
  
You can find out more about patterns in Section~\ref{sec:patterns};
for more about \texttt{tunion} and memory management, see
Section~\ref{sec:regions}.

%%% For example, \texttt{connect} is a C
%%% library function used to initiate communication with a machine on the
%%% Internet.  It can do so using a number of communication protocols,
%%% including IPv4 (Internet Protocol Version 4) and IPv6.  Each protocol
%%% uses a different form of address for machines on the Internet; to make
%%% an IPv4 connection, you call \texttt{connect} with an IPv4 address,
%%% and to make an IPv6 connection, you call \texttt{connect} with an IPv6
%%% address.  In other words, \texttt{connect}'s address argument has
%%% a different type depending on whether an IPv4 or IPv6 connection is
%%% being made.
%%%
%%% To make this work in C, \texttt{connect} is given the following type:
%%% \begin{alltt}
%%%     int \textbf{connect}(int \textit{fd}, const struct sockaddr *\textit{a}, socklen_t \textit{len});
%%% \end{alltt}
%%% The address argument, \textit{\texttt{a}}, is declared with type
%%% \texttt{struct sockaddr *}.  However, \texttt{connect} is never called
%%% with an argument of that type.  Instead, it will be called with an
%%% argument of type \texttt{struct sockaddr_in *} for an IPv4 connection,
%%% or \texttt{struct sockaddr_in6 *} for an IPv6 connection.  The
%%% \texttt{connect} function casts \textit{\texttt{a}} from type
%%% \texttt{struct sockaddr *} to type \texttt{struct sockaddr_in *} or
%%% type \texttt{struct sockaddr_in6 *} as appropriate.
%%%
%%% How does \texttt{connect} know whether to cast to an IPv4 address or
%%% an IPv6 address?  It expects all address structures to have a common
%%% field, at the same place in each structure, that gives the kind of
%%% address.  So \texttt{connect} examines the field and does the
%%% appropriate cast.  This can work quite well, but it isn't safe.  It's
%%% possible to call \texttt{connect} with an address structure where the
%%% common field is fill out incorrectly, either by accident or by
%%% malicious intent.  C has no protections against this, and
%%% \texttt{connect} has no way of detecting it; the cast will succeed and
%%% \texttt{connect}'s ``address'' argument might be something very
%%% different.


\subsection{Exceptions}

So far we've glossed over what happens when you try to dereference a
null pointer, or assign to an out-of-bounds \texttt{?}\ pointer.
We've said that Cyclone inserts checks to make sure the operation is
safe, but what if the checks fail?  For safety, it would be sufficient
to halt the program and print an error message---a big improvement
over a core dump, or, worse, a program with corrupted data that keeps
running.

In fact, Cyclone does something a bit more general than halting with
an error message: it throws an \emph{exception}.  The advantage of
exceptions is that they can be \emph{caught} by the programmer, who
can then take corrective action and perhaps continue with the program.
If the exception is not caught, the program halts and prints an error
message.  Consider our earlier example:
\begin{verbatim}
    FILE *f = fopen("/etc/passwd","r");
    int c = getc((FILE @)f);
\end{verbatim}
Suppose that there is no file \texttt{/etc/passwd}; then
\texttt{fopen} will return null, and when \texttt{f} is cast to
\texttt{FILE @}, the implied null check will fail.  The program will
halt with an error message,
\begin{verbatim}
    Uncaught exception Null_Exception
\end{verbatim}
\texttt{Null_Exception} is one of a handful of standard exceptions
used in Cyclone.  Each exception is like a case of a \texttt{tunion}:
it can carry along some values with it.  For example, the standard
exception \texttt{InvalidArg} carries a string.  Exceptions can be
handled in \texttt{try}-\texttt{catch} statements, using pattern
matching:
\begin{verbatim}
    FILE *f = fopen("/etc/passwd","r");
    int c;
    try {
      c = getc((FILE @)f);
    }
    catch {
    case Null_Exception:
      printf("Error: can't open /etc/passwd\n");
      exit(1);
    case InvalidArg(s):
      printf("Error: InvalidArg(%s)\n",s);
      exit(1);
    }
\end{verbatim}
Here we've ``wrapped'' the call to \texttt{getc} in a
\texttt{try}-\texttt{catch} statement.  If \texttt{f} isn't null and
the \texttt{getc} succeeds, then execution just continues, ignoring
the \texttt{catch}.  But if \texttt{f} is null, then the null check
will fail and the exception \texttt{Null_Exception} will be thrown;
execution immediately continues with the \texttt{catch} (the call to
\texttt{getc} never happens).  In the \texttt{catch} the thrown
exception is pattern matched against the cases.  Since the thrown
exception is \texttt{Null_Exception}, the first case is executed here.

There is one important difference between an exception and a case of a
\texttt{tunion}: with \texttt{tunion}, all of the cases have to be
declared at once, while a new exception can be declared at any time.
So, exceptions are an \emph{extensible} \texttt{tunion}, or
\texttt{xtunion}.  Here's how to declare a new exception:
\begin{verbatim}
    xtunion exn {
      My_Exception(char ?);
    };
\end{verbatim}
The type \texttt{xtunion exn} is the type of exceptions, and this
declaration introduces a new case for the \texttt{xtunion exn} type:
\texttt{My_Exception}, which carries a single value (a string).
Exception values are created just like \texttt{tunion} values---using
\texttt{new} for value-carrying tags only---and are thrown with a
\texttt{throw} statement.  For example,
\begin{verbatim}
    throw new My_Exception("some kind of error");
\end{verbatim}
or
\begin{verbatim}
    throw Null_Exception;
\end{verbatim}

\subsection{Tuples}

Tuples are like lightweight structs.  They need not be declared in
advance, and have member or field names that are implicitly 0, 1, 2,
3, etc.  For example, the following code declares \texttt{x} to be a
3-tuple of an integer, a character, and a boolean, initialized with
the values 42, \texttt{'z'}, and \texttt{true} respectively.  It then
checks to see whether the third component in the tuple is \texttt{true}
(it is) and if so, increments the first component in the tuple.
\begin{verbatim}
  $(int,char,bool) x = $(42,'z',true)

  if (x[2])
    x[0]++;
\end{verbatim}

The above code would be roughly equivalent to writing:
\begin{verbatim}
  struct {int f0; char f1; bool f2;} x = {42,'z',true};
  if (x.f2)
    x.f1++;
\end{verbatim}

Thus, tuple types are written \texttt{\$(type1,...,typen)}, tuple
constructor expressions are written \texttt{\$(exp1,...,expn)}, and
extracting the ith component of a tuple is written using subscript
notation \texttt{exp[i-1]}.  Note that, consistent with the rest of C,
the members start with 0, not 1.

Unlike structs, tuple types are treated equivalent as long as they are
structurally equivalent.  As in C, struct types are equivalent only if
they have the same tag or name.  (Note that in C, all struct
declarations have a tag, even if the compiler has to gensym one.)


\subsection{Features Added}

Cyclone adds a number of features to C, ranging from convenient
expression forms, to advanced typing constructs.  For instance,
Cyclone includes many of the GCC and C99 extensions that make writing
code a bit easier.  Variables need not be declared at the top of a
block, a declaration can appear within a for-statement, expressions
can have statements nested inside them, etc.  Cyclone also adds
support for ML or Haskell-style algebraic datatypes (also known as
tagged unions) and pattern matching.  Datatypes can seriously lift the
level of abstraction for code, and pattern matching can be an
effective tool for ensuring that all cases in a tricky test are
covered.

In addition, Cyclone adds advanced typing support in the form of (a)
parametric polymorphism, (b) structural subtyping, (c) some
unification-based, local-type inference.  These features are necessary
to type-check or port a number of (potentially) unsafe C idioms,
usually involving ``\texttt{void*}'' or the like.  Similarly, datatypes
can be used to code around many of the uses for C's \texttt{union} types
-- another potential source of unsoundness.  Cyclone also adds new
support for checked pointer arithmetic and ensures that all pointer
accesses are to valid objects.  Again, these features are aimed at
making it easy to port C code to Cyclone.

In what follows, we give a brief overview of these added features.

\subsection{GCC and C99 Additions}

GCC and the
\href{http://web.onetelnet.ch/~twolf/tw/c/c9x_changes.html}{ISO C99
  standard} have some useful new features that we have adopted for
Cyclone. Some of the ones that we current support:
\begin{itemize}
\item Statement expressions: There is a new expression form,
  \texttt{(\lb} \textit{statement} \textit{expression} \texttt{\rb)}.
  The statement is executed first, then the expression, and the value
  of the entire expression is the value of the expression
\item Struct expressions:  If you've declared
  \verb|struct point{int x; int y;};| then you can write
  \verb|point{.x=expression, .y=expression}| to allocate and
  initialize a struct point
\item \texttt{//} comments as in Java or C++
\item Trailing comma allowed in \texttt{enum} declarations.  Also, you
  can use semi-colons instead of commas.
\item Declarations can appear in any statement position.  It is not
  necessary to wrap braces around the declaration of a local variable.
\item For-statements can include a declaration. For instance:
  \verb|for (int x=0; x < n; x++) { ... }|
\end{itemize}

We expect to follow the C99 standard fairly closely.

%%% \subsection{Pointers}
%%% There are three different pointer types in Cyclone, written
%%% ``\texttt{t*},'' ``\texttt{t@},'' and ``\texttt{t?}.''  Actually, pointers
%%% are quite a bit more complicated than this, but these are the pointer
%%% types that you'll most likely use the most.
%%%
%%% A value of type \texttt{t*} is a possibly \texttt{null} pointer to a
%%% value of type \texttt{t}.  When these values are dereferenced, a
%%% \texttt{null} check is performed and an exception is raised if the
%%% value is actually \texttt{null}. To ensure statically that a pointer
%%% cannot be \texttt{null}, you can use the type \texttt{t@} instead.
%%% Dereferencing a \texttt{@} pointer requires no run-time overhead and
%%% will not raise an exception.  Pointer arithmetic and subscripting
%%% (except for 0) are not supported for values of type \texttt{t*} or
%%% \texttt{t@} (but see below).  Both kinds of pointers are represented
%%% the same way as C pointers.
%%%
%%% In general, one can write ``\verb|t*{e}|'' to describe a pointer to an
%%% array of \texttt{t} values with \texttt{e} elements, where \texttt{e} is a
%%% constant expression.  For instance, the following code is permissible:
%%% \begin{verbatim}
%%%   int x[5] = {0,1,2,3,4};
%%%   int *{5}p = x;
%%% \end{verbatim}
%%%
%%% Here, we've said that \texttt{p} is a (possibly \texttt{null}) pointer to
%%% an array of five integers. When a pointer has type \verb|t*{e}|, then
%%% it is permissible to use subscripts in the range 0 to \texttt{e}-1 to
%%% access the elements of \texttt{p}.  Note that \texttt{t*} is short hand
%%% for \verb|t*{1}| (and similarly \texttt{t@} is short hand for
%%% \verb|t@{1}|).
%%%
%%% A value of type \texttt{t?}\ is a checked pointer to a (possibly empty)
%%% array of values of type \texttt{t}.  Unlike \texttt{*} or \texttt{@}
%%% pointers, checked pointers support arbitrary pointer arithmetic
%%% (following the rules of C), arbitrary integer subscripts, etc.
%%% However, each access is checked to ensure that the pointer is within
%%% the bounds of the original underlying array.
%%%
%%% Values of type \verb|t*{e}| or \verb|t@{e}| or \texttt{t[e]} can be cast
%%% to type \texttt{t?}\ to support pointer arithmetic.  Furthermore, values
%%% of type \texttt{t?}\ can be cast to type \verb|t*{e}| or \verb|t@{e}|,
%%% but this requires a run-time check to ensure that the corresponding
%%% array slice is in bounds.
%%%
%%% Obviously, checked pointers require more information than \texttt{*} or
%%% \texttt{@} pointers, so that we can determine whether the access is in
%%% bounds.  Consequently, checked pointers are larger than normal
%%% pointers.  (The current implementation uses three words for each
%%% checked pointer.)  However, one rarely needs checked pointers unless
%%% you're performing lots of pointer arithmetic. In subsequent releases,
%%% we hope to support checked but untagged representations for these
%%% pointers using technology from dependent type theory.
%%%
%%% Finally, we should note that in fact all pointers in Cyclone point
%%% into a region. By default, if you don't mention a region, then the
%%% pointer points into the disgtinguished heap region (written `H).
%%% Pointers to stack-allocated objects live in regions that are private
%%% to the enclosing scope. More on this later\ldots

\subsection{Creating Arrays}
There are about four ways to create arrays in Cyclone. One can always
declare an array and provide an initializer as in C\@. For instance:
\begin{verbatim}
  int foo[8] = {1,2,3,4,5,6,7,8};
  char s[4] = "bar";
\end{verbatim}
are both examples from C for creating arrays.  Note that Cyclone
follows C's conventions here, so that if you declare arrays as above
within a function, then the lifetime of the array coincides with the
activation record of the enclosing scope.  In other words, such arrays
will be stack allocated.

To create heap-allocated arrays (or strings) within a Cyclone
function, you should either use ``\texttt{new}'' operator with either an
array initializer or an array comprehension. The following code
demonstrates this:
\begin{verbatim}
  // foo is a pointer to a heap-allocated array
  int *{8}foo = new {1,2,3,4,5,6,7,8};

  // s is a checked pointer to a heap-allocated string
  char ?s = new "bar";

  // a non-null pointer to the first 100 even numbers
  int @{100}evens = new {for i < 100 : 2*i};
\end{verbatim}

\subsection{Subtyping}
Cyclone supports ``extension on the right'' and ``covariant depth on
\texttt{const}'' subtyping for pointers.  This simply means that you
can cast a value \texttt{x} from having a type ``pointer to a struct
with 10 fields,'' to ``pointer to a struct having only the first 5
fields.''  For example, if we have the following definitions:
\begin{verbatim}
  typedef struct Point {float x,y;} *point;

  typedef struct CPoint {float x,y; int color;} *cpoint;

  float xcoord(point p) {
    return p->x;
  }
\end{verbatim}
then you can call \texttt{xcoord} with either a \texttt{point} or
\texttt{cpoint} object.  You can also cast a pointer to a tuple having 3
fields (e.g., \texttt{\$(int,bool,double)*}) to a pointer to a tuple
having only 2 fields (e.g., \texttt{\$(int,bool)*}).  In other words, you
can forget about the ``tail'' of the object.  This allows a degree of
polymorphism that is useful when porting C code.  In addition, you can
do ``deep'' casts on pointer fields that are \texttt{const}.  (It is
unsafe to allow deep casts on non-const fields.)  Also, you can cast
a field from being non-const to being const.  You can also cast a
constant-sized array to an equivalent pointer to a struct or tuple.
In short, Cyclone attempts to allow you to cast one type to another as
long as it is safe.  Note, however, that these casts must be explicit.

We expect to add more support for subtyping in the future (e.g.,
subtyping on function pointers, bounded subtyping, etc.)


%%% \subsection{Tagged Unions}
%%% 
%%% Cyclone's tagged unions (\texttt{tunion}) are based on the algebraic
%%% datatypes that first appeared in functional languages such as Hope,
%%% Miranda, ML, and Haskell.  They provide a safe way for building data
%%% structures that contain possibly many different types and can be used
%%% to build algebraic or inductively defined structures, such as lists,
%%% trees, graphs, etc.  For instance, the following tunion declarations
%%% give a way to construct abstract syntax trees for a simple calculator
%%% language:
%%% \begin{verbatim}
%%%   tunion operator { Plus, Times, Minus, Divide }
%%%   tunion absyn {
%%%     Integer(int);
%%%     Term(tunion absyn, tunion operator, tunion absyn);
%%%   }
%%%   tunion absyn e1 = new Term(new Integer(3),Plus,new Integer(4));
%%%   tunion absyn e2 = new Term(e1,Times,new Integer(5));
%%% \end{verbatim}
%%% 
%%% The operator definition is like an enum---it just defines symbolic
%%% constants for \texttt{Plus}, \texttt{Times}, \texttt{Minus}, and
%%% \texttt{Divide}.  The \texttt{absyn} definition defines an inductive
%%% tree-like data type for abstract syntax.  The \texttt{Integer}
%%% constructor takes an \texttt{int} argument and returns an \texttt{absyn}
%%% value.  The \texttt{Term} constructor takes an abstract syntax tree, an
%%% operator, and an abstract syntax tree and returns a new abstract
%%% syntax tree.  So, for example, \texttt{e1} is a tree representing the
%%% term ``3 + 4'' while \texttt{e2} is a tree representing the term ``(3 +
%%% 4) * 5.''
%%% 
%%% Internally, \texttt{tunion} constructors are either represented as an
%%% integer value (as with \texttt{Plus}, \texttt{Times}, \texttt{Minus}, and
%%% \texttt{Divide}) or a pointer to an object containing a tag and the
%%% arguments to the constructor.  The object is always allocated on the
%%% heap.  To traverse the tree, we use pattern matching, again in the
%%% style of functional languages such as ML or Haskell.
%%% 
%%% In the future, we plan to make the representation of tunions explicit
%%% and to allow programmers to control tag placement and do explicit
%%% tests on the tag to refine the type of an object in a more
%%% traditional, data-flow fashion.  We will probably keep the tunion
%%% construct as is for convenience.

\subsection{Pattern Matching}
Pattern matching in Cyclone generalizes the switch construct of C
allowing you to not only test integral values, but also to test
structured values such as the abstract syntax trees above.  For
example, the following function takes in an abstract syntax tree and
prints the tree to stdout:
\begin{verbatim}
  void print_absyn(tunion absyn tree) {
     switch (tree) {
     case &Integer(i)       : printf("%d",i); break;
     case &Term(t1,Plus,t2) : printf("("; print_absyn(t1);
                              printf("+");
                              print_absyn(t2); printf(")"); break;
     case &Term(t1,Times,t2): printf("("; print_absyn(t1);
                              printf("*");
                              print_absyn(t2); printf(")"); break;
     case &Term(t1,Minus,t2): printf("("; print_absyn(t1);
                              printf("-");
                              print_absyn(t2); printf(")"); break;
     case &Term(t1,Divide,t2):printf("("; print_absyn(t1);
                              printf("/");
                              print_absyn(t2); printf(")"); break;
  }
\end{verbatim}

Note that patterns introduce and initialize new variables local to a
given case.  For instance, in the \texttt{Integer} case above, the
pattern variable \texttt{i} is introduced and is initialized to whatever
value is carried by the Integer constructor.  Thus, \texttt{i} is
available for use on the right-hand-side of the case.  You can pattern
match on just about any kind of value, and destructure it.  For
instance, you can pattern match on tuples, structs, pointers to
tuples/structs, etc.  See the grammar for the syntax of the various
pattern forms.

The type-checker for Cyclone is much more picky about \texttt{switch}
statements than C\@.  In particular, it will check that all of the
patterns you have are exhaustive (or else there's a \texttt{default:}
clause) and that none of the patterns overlap.  This is useful for
evolving code.  For instance, if we added a new operator (say
\texttt{Mod}), then the compiler would complain that the \texttt{switch}
in \texttt{print_absyn} doesn't cover all possible cases (namely the
case where we have a term involving the \texttt{Mod} operator.)

In addition, the Cyclone type-checker makes sure that you don't
accidentally fall-through from one case to another.  In particular, if
you don't put in explicit breaks, returns, throws, etc., then the
compiler will reject the code.  You can still fall through to the next
case, but you have to do it with an explicit ``\texttt{fallthru}''
statement.  If the case pattern doesn't bind any new variables, then
you just write ``\texttt{fallthru;}'' as the last thing in the case.  If
you want to fall through to a case that defines new variables, then
you need to give values for those variables.  For instance, in the
following code:
\begin{verbatim}
  void foo(tunion absyn tree) {
     switch (tree) {
     case &Integer(i)       : printf("%d ",i); break;
     case &Term(t1,Plus,t2) : printf("It's a plus \n");
                              fallthru(t2,Plus,t1);
     case &Term(t1,op,t2)   : foo(t1); foo(t2); break;
  }
\end{verbatim}
if we pass it a tree \texttt{Term(Integer(3),Plus,Integer(4))} then we
will see ``It's a plus 4 3,'' but if we pass it
\texttt{Term(Integer(3),Times,Integer(4))} we will see ``3 4.''

\subsection{Let Declarations}
Sometimes, it's painful to declare a variable because you have to
write down its type.  Cyclone includes some limited support for type
inference using let declarations.  In particular, you can write:
\begin{verbatim}
  int foo(int x) {
    let y = x+3;
    let z = 3.14159;
    return (int)(y*z);
  }
\end{verbatim}

Here, we declared two variables y and z using ``\texttt{let}.''  When
you use \texttt{let}, you don't have to write down the type of the
variable.  Rather, the compiler infers the type from the expression
that initializes the variable.  More generally, you can write
``\texttt{let pattern = exp;}'' to destructure a value into a bunch of
variables.  For instance, if you pass a tuple to a function, then you
can extract the components as follows:
\begin{verbatim}
  int sum($(int,int,int) args) {
    let $(x,y,z) = args;
    return (x+y+z);
  }
\end{verbatim}

\subsection{Polymorphic Functions}
As mentioned above, Cyclone supports a limited amount of subtyping
polymorphism.  It also supports a fairly powerful form of parametric
polymorphism.  Those of you coming from ML or Haskell will find this
familiar.  Those of you coming from C++ will also find it somewhat
familiar.  The basic idea is that you can write one function that
abstracts the types of some of the values it manipulates.  For
instance, consider the following two functions:
\begin{verbatim}
  $(string,int) swap1($(int,string) x) {
     return $(x[1], x[0]);
  }
  $(int,int) swap2($(int,int) x) {
     return $(x[1], x[0]);
  }
\end{verbatim}

The two functions are quite similar: They both take in a pair (i.e., a
2-tuple) and return a pair with the components swapped.  At the
machine-level, the code for these two functions will be exactly the
same, assuming that \texttt{int}s and \texttt{string}s (\texttt{char *}) are
represented the same way.  So it seems silly to write the code twice.
Normally, a C programmer would replace the definition with simply:
\begin{verbatim}
  $(void *,void *) swap1($(void *,void *) x) {
     return $(x[1], x[0]);
  }
\end{verbatim}
(assuming you added tuples to C).  But of course, this isn't type-safe
because once I cast the values to \texttt{void *}, then I can't be sure
what type I'm getting out.  In Cyclone, you can instead write
something like this:
\begin{verbatim}
  $(`b,`a) swap<`a,`b>($(`a,`b) x) {
     return $(x[1],x[0]);
  }
\end{verbatim}
The code is the same, but it abstracts what the types are.  The extra
parameters \texttt{<`a,`b>} are type variables that can be instantiated
with any word-sized, general-purpose register type.  So, for instance,
you can call swap on pairs of integers, pairs of pointers, pairs of an
integer and a pointer, etc.:
\begin{verbatim}
  let $(x,y) = swap($("hello",3));  // x is 3, y is hello
  let $(w,z) = swap($(4,3));        // w is 3, z is 4
\end{verbatim}

Note that when calling a polymorphic function, you need not tell it
what types you're using to instantiate the type variables.  Rather,
Cyclone figures this out through unification.

C++ supports similar functionality with templates.  However, C++ and
Cyclone differ considerably in their implementation strategies.
First, Cyclone only produces one copy of the code, whereas a C++
template is specialized and duplicated at each type that it is used.
This approach requires that you include definitions of templates in
interfaces and thus defeats separate compilation.  However, the
approach used by Cyclone does have its drawbacks: in particular, the
only types that can instantiate type variables are those that can be
treated uniformly.  This ensures that we can use the same code for
different types.  The general rule is that values of the types that
instantiate a type variable must fit into a machine word and must be
passed in general-purpose (as opposed to floating-point) registers.
Examples of such types include \texttt{int}, pointers, \texttt{tunion},
and \texttt{xtunion} types.  Other types, including \texttt{char},
\texttt{short}, \texttt{long long}, \texttt{float}, \texttt{double},
\texttt{struct}, and \texttt{tuple} types violate this rule and thus
values of these types cannot be passed to a function like swap in
place of the type variables. In practice, this means that you tend to
manipulate a lot of pointers in Cyclone code.

The combination of parametric polymorphism and sub-typing means that
you can cover a lot of C idioms where \texttt{void*} or unsafe casts
were used without sacrificing type-safety.  We use polymorphism a lot
when coding in Cyclone.  For instance, the standard library includes
many container abstractions (lists, sets, queues, etc.) that are all
polymorphic in the element type.  This allows us to re-use a lot of
code.  In addition, unlike C++, those libraries can be compiled once
and need not be specialized.  On the downside, this style of
polymorphism does not allow you to do any type-specific things (e.g.,
overloading or ad-hoc polymorphism.)  Someday, we may add support for
this, but in the short run, we're happy not to have it.


\subsection{Polymorphic Data Structures}
Just as function definitions can be parameterized by types, so can
\texttt{struct} definitions, \texttt{tunion} definitions, and even
\texttt{typedef}s.  For instance, the following \texttt{struct} definition
is used in the standard library for lists:
\begin{verbatim}
  struct List<`a> {`a hd; struct List<`a> *tl; };
  typedef struct List<`a> *list_t<`a>;
\end{verbatim}

Here, we've declared a \texttt{struct List} parameterized by a type
\texttt{`a}.  The \texttt{hd} field contains an element of type \texttt{`a}
and the \texttt{tl} field contains a (possibly \texttt{null}) pointer to a
\texttt{struct List} with elements of type \texttt{`a}.  We then define
\texttt{list_t<`a>} as an abbreviation for \texttt{struct List<`a>*}.  So,
for instance, we can declare both integer and string lists like this:
\begin{verbatim}
  list_t<int> ilist = new List{1,new List{2,null}};
  list_t<string> slist = new List{.hd = "foo",
                                  .tl = new List{"bar",null}};
\end{verbatim}

Note that we use ``\texttt{new}'' as in C++ to allocate a new
\texttt{struct List} on the heap and return a pointer to the resulting
(initialized) \texttt{List} object.  Note also that the field designator
(``\texttt{.hd}'', ``\texttt{.tl}'') are optional.

Once you have polymorphic data structures, you can write lots of
useful polymorphic code and use it over and over again.  For instance,
the standard list library (see lib/list.h) includes functions for
mapping over a list, looking up items in a list, concatenating two
lists, copying lists, sorting lists, etc.

\subsection{Abstract and Existential Types}
Suppose you want to declare an abstract type for implementing stacks.
In Cyclone, the way this is accomplished is by declaring a struct that
encapsulates the implementation type, and by adding the
``\texttt{abstract}'' qualifier to the struct definition.  For instance,
if we write:
\begin{verbatim}
  abstract struct Queue<`a> { list_t<`a> front, rear; };
\end{verbatim}
then this declares a polymorphic \texttt{Queue} implementation that is
abstract.  The definition of the struct is available within the unit
that declares the Queue, but will not be made available to the outside
world.  (This will be enforced by a link-time type-checker which we
are currently putting together.)  Typically, the provider of the
\texttt{Queue} abstraction would write in an interface file:
\begin{verbatim}
  extern struct Queue<`a>;
\end{verbatim}
The abstract keyword in the implementation ensures that the definition
does not leak to a client.  One can also declare \texttt{tunion}s to be
abstract, though I find it more useful to always use a \texttt{struct}
to encapsulate the tunion, and make the \texttt{tunion} static, and the
struct \texttt{abstract}.  That way, clients are always given an
abstract struct to manipulate.

\texttt{Typedef}s cannot be made abstract.  As in C, typedefs are type
abbreviations and are expanded at compile time.  If we chose to make
them (potentially) abstract, then we'd have to enforce a ``boxedness''
restriction, similar to the restrictions on type variables.  To
simplify the language, we chose to make structs abstract.

It's also possible to code up ``first-class'' abstract data types
using \texttt{tunion}s or \texttt{xtunion}s.  Individual [x]tunion
constructors can be parameterized by additional type variables that
are local to the type-constructor.  (From a type-theoretic point of
view, these are existentially-quantified variables.)  I won't bother
to say a lot more about these here, except that the approach used is
quite similar to the treatment of existential types in Haskell.  In
particular, pattern matching one of these constructors requires you to
introduce explicit type variables into which the actual types are
``unpacked.''  These variables are treated abstractly in the body of a
case.  However, when creating one of the values, it is not necessary
to explicitly ``pack'' the types to be abstracted.  Rather, the types
are discovered through unification.  For an example of the use of
existential types, see the \texttt{fn.h} and \texttt{fn.cyc} files in the
standard library which implement first-class closures.

\subsection{Restrictions}
\begin{itemize}
\item Cyclone requires every function to declare a return type (the
  implicit int for the return type of a function is removed).
\item Cyclone requires the format argument of the \texttt{printf},
  \texttt{fprintf}, and \texttt{sprintf} functions to be a string
  constant.  This is so that we can statically protect against format
  string attacks.  (We should support dynamic checks too!)
\item Cyclone does not allow user-defined vararg functions. (We should
  support this too.)
\item Cyclone does not permit some of the casts that are allowed in C\@.
  Incorrect casts in C can lead to crashes.  In general, you should be
  able to cast something from one type to another as long as the
  underlying representations are compatible.
\item Cyclone does not support pointer arithmetic on \texttt{*} or
  \texttt{@} pointers.  Pointer arithmetic is not unsafe in itself, but
  it can lead to unsafe code when the resulting pointer is assigned or
  dereferenced.  You can cast the \texttt{*} or \texttt{@} value to a
  \texttt{?}\ value and then do the pointer arithmetic instead.
\item Cyclone inserts a NULL check when a \texttt{*} pointer is
  dereferenced and it cannot determine statically that the pointer is
  not NULL\@.  This prevents segmentation faults.
\item Cyclone requires any function that is supposed to return a
  non-\texttt{void} value to execute a return statement (or throw an
  exception) on every possible execution path. This is needed to
  ensure that the value returned from the function has the right type,
  and is not just a random value left in a register or on the stack.
\item Unions in Cyclone can only hold ``bits.''  In particular, they
  can hold combinations of chars, ints, shorts, longs, floats,
  doubles, structs of bits, or tuples of bits. Pointer types are not
  supported.  This avoids the situation where an arbitrary bit pattern
  is cast to a pointer and then dereferenced. If you want to use
  multiple types, then use tagged unions (\texttt{tunion}s.)
\item Cyclone only supports a limited form of \texttt{malloc} which is
  baked in. Tuples, tunions, and structs can all be allocated via
  \texttt{malloc} but this requires writing explicitly:
  \texttt{malloc(sizeof(t))} where t is the type of the value that you
  are allocating.
\item Cyclone performs a static analysis to ensure that every variable
  and every \texttt{struct} field is initialized before it is used. This
  prevents a random stack value from being used improperly. The
  analysis is somewhat conservative so you may need to initialize
  things earlier than you would do in C\@. For instance, currently,
  Cyclone does not support initializing a struct in a procedure
  separate from the one that does the allocation.
\item Cyclone does not permit \texttt{goto}s from one scope into
  another. C warns against this practice, as it can cause crashes;
  Cyclone rules it out entirely.
\item Cyclone places some limitations on the form of \texttt{switch}
  statements that rule out crashes like those caused by unrestricted
  \texttt{goto}.  Furthermore, Cyclone prevents you from accidentally
  falling through from one case to another. To fall through, you must
  explicitly use the \texttt{fallthru} keyword.  Otherwise, you must
  explicitly \texttt{break}, \texttt{goto}, \texttt{continue},
  \texttt{return}, or \texttt{throw} an exception.
\item In the near future, Cyclone will place some restrictions on
  linking for safety reasons. In particular, if you import a variable
  or function with one type, then it must be exported by another file
  with that type. In addition, access to C code will be restricted
  based on a notion of security roles.
\item Cyclone has some new keywords (\texttt{let}, \texttt{abstract},
  etc.) that can no longer be used as identifiers.
\item Cyclone prevents you from using pointers to stack-allocated
  objects as freely as in C to avoid security holes. The reason is
  that each declaration block is placed in a conceptual ``region'' and
  the type system tracks the region into which a pointer points.
\item Cyclone currently does not support nested type declarations
  within a function. All \texttt{struct}, \texttt{union}, \texttt{enum},
  \texttt{tunion}, \texttt{xtunion}, and \texttt{typedef} definitions must
  be at the top-level.
\item Cyclone does not allow you to explicitly free a heap-allocated
  object. Instead, you can either use the region mechanism or rely
  upon the conservative garbage collector to reclaim the space.
\end{itemize}

% Local Variables:
% TeX-master: "main-screen"
% End:
