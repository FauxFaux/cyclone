\section{Cyclone for C Programmers}

We begin with a quick overview of Cyclone, suitable for those who
already know how to program in C\@.  We'll explain some of the ways
that Cyclone differs from C and some of the reasons why; you should
come away with enough knowledge to start writing, compiling, and
running your own Cyclone programs.  We assume that the Cyclone
compiler is already installed on your system (see
\hyperref[{sec:install}]{Appendix~\ref{sec:install}} or \href{http://www.cs.cornell.edu/projects/cyclone}{http://www.cs.cornell.edu/projects/cyclone}
if you need to install the compiler).

\subsection{Getting Started}

Here's a Cyclone program that prints the string ``\texttt{hello,
  world}.''
\begin{verbatim}
    #include <stdio.h>

    int main() {
      printf("hello, world\n");
      return 0;
    }
\end{verbatim}

It looks rather like a C program---in fact, a C compiler will happily
compile it.  The program uses \texttt{\#include} to tell the
preprocessor to import some standard definitions, it defines a
distinguished function \texttt{main} that serves as the entry point of
the program, and it uses the familiar \texttt{printf} function to
handle the printing; all of this is just as in C\@.

To compile the program, put it into a file \texttt{hello.cyc}, and run
the command
\begin{verbatim}
    cyclone -o hello hello.cyc 
\end{verbatim}
This tells the Cyclone compiler (\texttt{cyclone}) to compile the file
\texttt{hello.cyc}; the \texttt{-o} flag tells the compiler to leave
the executable output in the file \texttt{hello} (or, in Windows,
\texttt{hello.exe}).  If all goes well you can execute the program by
typing
\begin{verbatim}
    hello
\end{verbatim}
and it will print
\begin{verbatim}
    hello, world
\end{verbatim}

It's interesting to compare our program with a version that omits the
return statement:
\begin{verbatim}
    #include <stdio.h>

    int main() {
      printf("hello, world\n");
    }
\end{verbatim}

A C compiler will compile and run this version without warning.  
In contrast, Cyclone will warn that you have failed to return
an \texttt{int}.  Cyclone only warns you when you fail to return
an integral type (\texttt{char}, \texttt{short}, \texttt{int}, etc.) 
but it gives an error if you fail to return
other types (e.g., pointer types).  This requirement of
\emph{definite return} ensures type safety while imposing
minimal constraints on a programmer porting C code to Cyclone.

Definite return reflects Cyclone's concern with safety.  The caller of
the function expects to receive a value of the return type; if the
function does not execute a \texttt{return} statement, the caller will
receive some incorrect value instead.  If the returned value is supposed
to be a pointer, the caller might try to dereference it, and
dereferencing an arbitrary address can cause the program to crash.  So,
Cyclone requires a return statement with a value of the return
type whenever type safety can be compromised.  

\subsection{Pointers}

Programs that use pointers properly in C can be both fast and elegant.
But when pointers are used improperly in C, they cause core dumps and
buffer overflows.  To prevent this, Cyclone introduces different kinds
of pointers and either (a) puts some restrictions on how you can use pointers
of a given kind or (b) places no restrictions but may insert additional
run-time checks.

\subsubsection*{Nullable Pointers}

The first kind of pointer is indicated with a \texttt{*}, as in C\@.  For
example, if we declare
\begin{verbatim}
    int x = 3;
    int *y = &x;
\end{verbatim}
then \texttt{y} is a pointer to the integer 3 (the contents of
\texttt{x}).  The pointer, \texttt{y}, is represented by a memory
address, namely, the address of \texttt{x}.  To refer to the contents
of \texttt{y}, you use \texttt{*y}, so, for example, you can increment
the value of \texttt{x} with an assignment like
\begin{verbatim}
    *y = *y + 1;
\end{verbatim}

This much is just as in C\@.  However, there are some differences in
Cyclone:
\begin{itemize}
\item You can't cast an integer to a pointer.  Cyclone prevents this
  because it would let you overwrite arbitrary memory locations.  In
  Cyclone, \texttt{NULL} is a keyword suitable for situations where
  you would use a (casted) \texttt{0} in C\@.  The compiler 
  accepts \texttt{0} as a legal possibly-null pointer value, but using
  \texttt{NULL} is preferred.
\item You can't do pointer arithmetic on a \texttt{*} pointer.
  Pointer arithmetic in C can take a pointer out of bounds, so that
  when the pointer is eventually dereferenced, it corrupts memory or
  causes a crash.  (However, pointer arithmetic is possible
  using \texttt{@fat}\ and \texttt{@zeroterm} pointers.)
\item There is one other way to crash a C program using pointers: you
  can dereference the \texttt{NULL} pointer or try to update the 
  \texttt{NULL} location.
  Cyclone prevents this by inserting a \texttt{NULL}-check whenever you
  dereference a \texttt{*} pointer (that is, whenever you use the
  \texttt{*}, \texttt{->}, or subscript operation on a pointer.)
\end{itemize}

These are drastic differences from C, particularly the restriction on
pointer arithmetic.  The benefit is that you can't cause a crash using
\texttt{*} pointers in Cyclone.

\subsubsection*{Fat Pointers}

If you need to do pointer arithmetic in Cyclone, you can use a second
kind of pointer, called a \emph{fat pointer} and indicated by 
writing the qualifier \texttt{@fat} after the \texttt{*}.  For
example, here is a program that echoes its command-line arguments:
\begin{verbatim}
    #include <stdio.h>

    int main(int argc, char *@fat *@fat argv) {
      argc--; argv++; /* skip command name */
      if (argc > 0) {
        /* print first arg without a preceding space */
        printf("%s",*argv);
        argc--; argv++;
      }
      while (argc > 0) {
        /* print other args with a preceding space */
        printf(" %s",*argv);
        argc--; argv++;
      }
      printf("\n");
      return 0;
    }
\end{verbatim}

Except for the declaration of \texttt{argv}, which holds the
command-line arguments, the program looks just like you would write it
in C: pointer arithmetic (\texttt{argv++}) is used to move
\texttt{argv} to point to each argument in turn, so it can be printed.

In C, \texttt{argv} would typically be declared with type \texttt{char
  **}, a pointer to a pointer to a character, which is thought of as
an array of an array of characters.  In Cyclone, \texttt{argv} is
instead declared with type \texttt{char *@fat*@fat}, which is thought of in
the same way: it is a (fat) pointer to a (fat) pointer to characters.  The
difference between an unqualified pointer and a \texttt{@fat}\ pointer is
that a \texttt{@fat}\ pointer comes with bounds information and is thus
``fatter'' than a traditional pointer.  Each time a
fat pointer is dereferenced or its contents are assigned to,
Cyclone inserts both a \texttt{NULL} check and a bounds check.  This
guarantees that a \texttt{@fat}\ pointer can never cause a buffer
overflow.

Because of the bounds information contained in \texttt{@fat}\ pointers,
\texttt{argc} is superfluous: you can get the size of \texttt{argv} by
writing \texttt{numelts(argv)}.  We've kept \texttt{argc} as an argument
of \texttt{main} for backwards compatibility.

It's worth remarking that you can always cast a \texttt{*} pointer
to a \texttt{@fat} pointer (and vice-versa).  So, it is possible to do
pointer arithmetic on a value of type \texttt{*}, but only when you
insert the appropriate casts to convert from one pointer type to 
another.  Note that some of these casts can fail at run-time.  For
instance, if you try to cast a fat pointer that points to an empty 
sequence of characters to \texttt{char *}, then the cast will fail
since the sequence doesn't contain at least one character. 

Finally, \texttt{@fat} pointers are used so frequently in Cyclone,
that there is special character, \texttt{?} (question mark) that you 
can use as an abbreviation for \texttt{*@fat}.  For instance, we could
write the prototype for main as:
\begin{verbatim}
  int main(int argc, char ?? argv);
\end{verbatim}
instead of the more verbose:
\begin{verbatim}
  int main(int argc, char *@fat *@fat argv);
\end{verbatim}

\subsubsection*{Non-NULL pointers}

There is one other kind of pointer in Cyclone: the non-NULL pointer.
A non-null pointer is indicated by the qualifier \texttt{@nonnull}.  A
\texttt{@nonnull} pointer is like an unqualified pointer, except that it is
guaranteed not to be NULL\@.  This means that when you dereference a
\texttt{@nonnull} pointer or assign to its contents, a null check is
sometimes unnecessary.

\texttt{@nonnull} pointers are useful in Cyclone both for efficiency and as
documentation.  This can be seen at work in the standard library,
where many functions take \texttt{@nonnull} pointers as arguments, or return
\texttt{@nonull} pointers as results.  For example, the \texttt{getc}
function that reads a character from a file is declared,
\begin{verbatim}
    int getc(FILE *@nonnull);
\end{verbatim}
This says that \texttt{getc} expects to be called with a non-NULL
pointer to a \texttt{FILE}\@.  Cyclone guarantees that, in fact, when
the \texttt{getc} function is entered, its argument is not \texttt{NULL}.  
This means that \texttt{getc} does not have to test whether it is 
\texttt{NULL}, or decide what to do if it is in fact \texttt{NULL}\@.

In C, the argument of \texttt{getc} is declared to have type
\texttt{FILE *}, and programmers can call \texttt{getc} with
\texttt{NULL}\@.  So for safety, C's \texttt{getc} ought to check for
\texttt{NULL}\@.  In practice, many C implementations omit the check;
\texttt{getc(NULL)} is an easy way to crash a C program.

In Cyclone, you can still call \texttt{getc} with a possibly-\texttt{NULL}
\texttt{FILE} pointer (a \texttt{FILE *}).  However, Cyclone insists
that you insert a check before the actual call:
\begin{verbatim}
    FILE *f = fopen("/etc/passwd","r");
    int c = getc((FILE *@nonnull)f);
\end{verbatim}
Here \texttt{f} will be \texttt{NULL} if the file \texttt{/etc/passwd} doesn't
exist or can't be read.  So, in Cyclone \texttt{f} must be cast to
\texttt{FILE @} before the call to \texttt{getc}.  The cast causes a
\texttt{NULL} check.  If you try to call \texttt{getc} without the cast,
Cyclone will insert one for you automatically, and warn you that it is
doing so.  

You should pay attention to these warnings and attempt
to get rid of them by rewriting the code.  Not only will this make
your code more crash-proof, it will tend to make it faster.  For
instance, if we rewrite the code above so that we explicitly
test whether or not \texttt{fopen} succeeds in returning a
non-\texttt{NULL} file descriptor:
\begin{verbatim}
    FILE *f = fopen("/etc/passwd","r");
    if (f == NULL) {
      fprintf(stderr,"cannot open passwd file!");
      exit(-1);
    }
    int c = getc(f);
\end{verbatim}
then Cyclone no longer issues a warning at the call to \texttt{getc}
and the resulting code does not have to do a \texttt{NULL}-check.

If you call \texttt{getc} with a \texttt{FILE *@nonnull}, of course, no check
is required.  For example, \texttt{stdin} is a \texttt{FILE *@nonnull} in
Cyclone, so you can simply call \texttt{getc(stdin)}.  In Cyclone you
will find that many functions return \texttt{*@nonnull} pointers, so many of
the pointers you deal with will already be \texttt{*@nonull} pointers, and
neither the caller nor the called function needs to do null
checks---and this is perfectly safe.

Like \texttt{@fat} pointers, \texttt{@nonnull} pointers are so useful,
that there is an abbreviation.  Instead of writing \texttt{FILE*@nonnull}
you can simply write \texttt{FILE@} when you want to write the
type of a non-\texttt{NULL} pointer to a \texttt{FILE}.

\subsubsection*{Zero-Terminated Pointers}

Fat pointers support arbitrary pointer arithmetic and subscripting
but they don't have the same representation as pointers in C.  This
is because we need extra information to determine the bounds and
ensure a subscript or dereference is in bounds.  Unfortunately,
this change in representations can make it difficult to interface
with legacy C code where the representations might not be easily
changed.  

Fortunately, Cyclone supports one more pointer type where the
representation matches C's and yet supports a limited form of
pointer arithmetic and subscripting:  the zero-terminated pointer.
A zero-terminated pointer is a pointer to a sequence of elements
that are guaranteed to be terminated with a zero.  A good
example of such a sequence is C's strings.  In Cyclone, we
the type of C's strings can be written as \texttt{char *@zeroterm}.
The \texttt{@zeroterm} qualifier indicates that the pointer
points to a zero-terminated sequence.  The qualifier is
orthogonal to other qualifiers, such as \texttt{@fat} or
\texttt{@nonnull}, so you can freely combine them.

Because C strings arise so frequently, the types \texttt{char*}, 
\texttt{char *@nonnull} and \texttt{char *@fat} are by default qualified
with \texttt{@zeroterm}.  Other types (e.g., \texttt{int*}) are
not but you can put the qualifier in explicitly when you want
this property.  You can override the \texttt{@zeroterm} qualifier
on \texttt{char} pointers by putting in an explicit
\texttt{@nozeroterm} qualifier (e.g., \texttt{char*@nozeroterm}.)

If \texttt{x} is a thin, zero-terminated pointer, then you can
do a subscript (e.g., \texttt{x[i]}) or pointer arithmetic
(e.g., \texttt{x+i}) but the compiler inserts checks
to ensure that (a) \texttt{i} is non-negative and (b) there is no
zero between \texttt{x[0]} and \texttt{x[i-1]} inclusive.
This ensures that you can't read past the zero.  
In addition, when writing to a zero-terminated pointer, the
compiler inserts checks to ensure that you don't replace
the final zero with some other value.  This is crucial for
ensuring that a buffer overrun cannot occur.  

Because subscripts and pointer arithmetic on zero-terminated
thin pointers must check to see if you pass a zero, these operations
can be fairly expensive.  In particular, if you are not careful,
you can turn what appears to be an \emph{O(n)} algorithm into
an \emph{O(n-squared)} one.  You can avoid this overhead by
casting the pointer to a \texttt{@fat} zero-terminated pointer.  This
computes the length of the sequence once and then then uses
the bounds information associated with the fat pointer to do
any bounds checks.  

These constraints on zero-terminated pointers mean that you
have to be careful when porting code.  For instance, consider
the following function:
\begin{verbatim}
  void foo(char *s, int offset) {
     unsigned int len = strlen(s);
     for (unsigned int i = 0; offset+i < len; i++)
        s[offset+i] = 'a';
  }
\end{verbatim}
This code can be quite expensive when \texttt{offset} is large
because the compiler must check that there is no intervening
zero between \texttt{s[0]} and \texttt{s[offset+i]} for each
iteration of the loop.  You can get rid of this overhead by
rewriting the code as follows:
\begin{verbatim}
  void foo(char *s, int offset) {
     unsigned int len = strlen(s);
     s += offset;
     for (unsigned int i = 0; offset+i < len; i++, s++)
        *s = 'a';
  }
\end{verbatim}
Now the compiler is only checking that \texttt{*s} is not
zero when it does the increment \texttt{s++}.  In addition,
however, the compiler is checking each time you do \texttt{*s = 'a'}
that \texttt{*s} is not zero, for then you could overwrite
the zero with an \texttt{'a'} and potentially step outside
the bounds of the buffer. 

One way to get rid of all of this check is to cast \texttt{s}
to a non-zero-terminated fat pointer before entering the loop.
When you cast a zero-terminated pointer to a non-zero-terminated
fat pointer, the compiler calculates the length of the sequence
once, decrements it by one and then builds an appropriate
fat pointer with this bounds information.  Now when doing 
updates the bounds check on the array keep you from writing
any value into the last location.  Furthermore, if you write
the code in a straightforward fashion using subscripting,
the compiler is more likely to eliminate the bounds checks.
Here is an example:
\begin{verbatim}
  void foo(char *s, int offset) {
    char *@fat @nozeroterm fat_s = (char @fat @nozeroterm)s;
    unsigned int len; 
    fat_s += offset;
    len = numelts(fat_s);    
    for (unsigned int i = 0; i < len; i++)
      fat_s[i] = 'a';
  }
\end{verbatim}
The C code generated by the compiler looks something like this:      
\begin{verbatim}
struct _tagged_arr { 
  char *base;
  char *curr;
  char *last;
};

void Cyc_foo(char *s,int offset){
  struct _tagged_arr fat_s = {s, s, strlen(s)};
  unsigned int len;
  fat_s.curr += offset;
  if (fat_s.curr < fat_s.base || fat_s.curr >= fat_s.last) 
    len = 0;
  else 
    len = fat_s.last - fat_s.curr;
  { unsigned int i = 0;
    for(0; i < len; i++)
      fat_s.curr[i] = 'a';
  }
}
\end{verbatim}
Notice that here, the compiler is able to eliminate all bounds
checks within the loop and still ensure safety.

\subsubsection*{Initializing Pointers}

Pointers must be initialized before they are used to ensure that unknown
bits do not get used as a pointer.  This requirement goes for
variables that have pointer type, as well for arrays, elements of arrays,
and for fields in structures.  Conversely, data that does not have pointer
type need not be initialized before it is used, since doing so cannot result
in a violation of safety.  This decision adheres to the philosophy of C, but
diverges from that of traditional type-safe languages like Java and ML.

\subsubsection*{Other features of pointers}

There's much more to Cyclone pointers than we've described here.  

In particular, a pointer type can also specify that it points to a
sequence of a particular (statically known) length using the
\texttt{@numelts} qualifier.  For instance, we can write:
\begin{verbatim}
void foo(int *@numelts(4) arr);
\end{verbatim}
Here, the parameter \texttt{arr} is a pointer to a sequence of
four integer values.  Both the non-null and nullable pointers
support explicit sequence bounds that are tracked statically.
Indeed, both pointer kinds always have length information and
when you write ``\texttt{int *}'' this is just short-hand for
``\texttt{int *@numelts(1)}''.

We explain pointers in more detail in
\hyperref[{sec:pointers}]{Section~\ref{sec:pointers}}.

\subsection{Regions}

Another potential way to crash a program or violate security is
to dereference a dangling pointer---a pointer to storage that
has been deallocated.  These are particularly insidious bugs
because the error might not manifest itself immediately.  
For example, consider the following C code:
\begin{verbatim}
struct Point {int x; int y;};

struct Point *newPoint(int x,int y) {
  struct Point result = {x,y};
  return &result;
}

void foo(struct Point *p) {
  p->y = 1234;
  return;
}

void bar() {
  struct Point *p = newPoint(1,2);
  foo(p);
}
\end{verbatim}
The code has an obvious bug: the function \texttt{newPoint} returns a
pointer to a locally-defined variable (\texttt{result}), even though
the storage for that variable is deallocated upon exit from the
function.  That storage may be re-used (\emph{e.g.}, by a subsequent procedure
call) leading to subtle bugs or security problems.  For instance, in
the code above, after \texttt{bar} calls \texttt{newPoint}, the storage
for the point is reused to store information for the activation
record of the call to \texttt{foo}.  This includes a copy of the
pointer \texttt{p} and the return address of \texttt{foo}.  Therefore,
it may be that \texttt{p->y} actually points to the return address of
\texttt{foo}. The assignment of the integer 1234 to that location could
then result in \texttt{foo} ``returning'' to an arbitrary hunk of code
in memory.  Nevertheless, the C type-checker readily
admits the code.

In Cyclone, this code would be rejected by the type-checker to avoid
the kind of problems mentioned above.  The reason the code is rejected
is that the Cyclone compiler tracks object lifetimes and ensures that
a pointer to an object can only be dereferenced if that object 
has not been deallocated.  

The way that Cyclone achieves this is by assigning each object a
symbolic \emph{region} that corresponds to the lexical block in which
the object is declared, and each pointer type reflects the region
into which a pointer points.  For instance, the variable \texttt{result}
lives within a region that corresponds to the
invocation of the function \texttt{newPoint}.  We write the
name of the region explicitly using a back-quote as in \texttt{`newPoint}.

Because \texttt{result} lives in region \texttt{`newPoint}, the
expression \texttt{\&result} is a pointer into region
\texttt{`newPoint}.  If we like, we can write the type of
\texttt{\&result} with the explicit region as ``\texttt{struct Point *
@region(`newPoint)}''.  

When control flow exits a block, the storage (\emph{i.e.}, 
the region) for that 
block is deallocated.  Cyclone keeps track of the set of regions that
are allocated and deallocated at every control-flow point and ensures
that you only dereference pointers to allocated regions.  For example,
consider the following fragment of (bad) Cyclone code:
\begin{verbatim}
1 int f() {
2    int x = 0;
3    int *@region(`f) y = &x;
4    L:{ int a = 0;
5        y = &a;
6      }
7    return *y;
8 }
\end{verbatim}
In the function \texttt{f} above, the variables \texttt{x} and 
\texttt{y} live within the region \texttt{`f} because they are
declared in the outermost block of the function.  The storage for
those variables will live as long as the invocation of the function.
Note that since \texttt{y} is a pointer to \texttt{x}, the type of
\texttt{y} is \texttt{int *@region(`f)} reflecting that \texttt{y} 
points into region \texttt{`f}.

The variable \texttt{a} does \emph{not} live in region \texttt{`f} because
it is declared in an inner block, which we have labeled with
\texttt{L}.  The storage for the inner block \texttt{L} may be
deallocated upon exit of the block.  To be more precise, the
storage for \texttt{a} is deallocated
at line 7 in the code.  Thus, it is an error to try to access
this storage in the rest of the computation, as is done on line 7.

Cyclone detects the error because it gives the expression \texttt{\&a} the
type \texttt{int *@region(`L)} reflecting the fact that the value is
a pointer into region \texttt{`L}.  So, the assignment 
\texttt{y = \&a} fails to type-check because \texttt{y} expects
to hold a pointer into region \texttt{`f}, not region \texttt{`L}.
The restriction, compared to C, is that a pointer's type indicates
\emph{one} region instead of \emph{all} regions.

\subsubsection*{Region Inference}

If you had to write a \texttt{@region} qualifier on every
pointer type, then writing code would be far from pleasant.
Fortunately, Cyclone provides a number of mechanisms to
cut down on the region annotations you have to write.  

First off, you can omit the \texttt{@region} qualifier keyword
and simply write the region name (e.g., \texttt{`r}) as long
as you put the region name after any other qualifiers.  For
instance, instead of writing ``\texttt{int *@nonnull @region(`r)}''
we can simply write ``\texttt{int @`r}''.  In this document,
we will use an explicit \texttt{@region} qualifier, but
you'll find that the libraries and other sample codes tend
to use the (cryptic) abbreviations.  

In addition, Cyclone often figures out the region of a pointer
without the programmer providing the information.  This is called {\em
region inference}.  For instance, we can rewrite the function
\texttt{f} above without any region annotations, and without 
labelling the blocks:
\begin{verbatim}
1 int f() {
2    int x = 0;
3    int *y = &x;
4    { int a = 0;
5      y = &a;
6    }
7    return *y;
8 }
\end{verbatim}
Cyclone can still figure out that \texttt{y} is a pointer into
region \texttt{`f}, and \texttt{\&a} is a pointer into a different
(now anonymous) region, so the code should be rejected.

As we will show below, occasionally you will need to put explicit
region annotations into the code to convince the type-checker that
something points into a particular region, or that two things point
into the same region.  In addition, it is sometimes useful to put in
the region annotations for documentation purposes, or to make type
errors a little less cryptic.

You need to understand at least four more details about regions to
be an effective Cyclone programmer:  the heap region, growable
regions, region polymorphism, and default region annotations for
function parameters.  The following sections give a brief overview
of these details.

\subsubsection*{The Heap Region}

There is a special region for the heap, written \texttt{`H}, that
holds all of the storage for top-level variables, and for data
allocated via \texttt{new} or \texttt{malloc}.  For instance, if we
write the following declarations at the top-level:
\begin{verbatim}
struct Point p = {0,1};
struct Point *ptr = &p;
\end{verbatim}
then Cyclone figures out that \texttt{ptr} points into the heap
region.  To reflect this explicitly, we can put the region in
the type of \texttt{ptr} if we like:
\begin{verbatim}
struct Point p = {0,1};
struct Point *@region(`H) ptr = &p;
\end{verbatim}

As another example, the following function heap-allocates a point and
returns it to the caller.  We put the regions in here to be explicit:
\begin{verbatim}
struct Point *@region(`H) good_newPoint(int x,int y) {
  struct Point *@region(`H) p = malloc(sizeof(struct Point));
  p->x = x;
  p->y = y;
  return p;
}
\end{verbatim}
Alternatively, we can use \texttt{new} to heap-allocate and 
initialize the result:
\begin{verbatim}
struct Point *@region(`H) good_newPoint(int x,int y) {
  return new Point{x,y};
}
\end{verbatim}

\subsubsection*{Growable Regions}

Storage on the stack is implicitly allocated and recycled when you
enter and leave a block.  Storage in the heap is explicitly allocated
via \texttt{new} or \texttt{malloc}, but there is no support in
Cyclone for explicitly freeing an object in the heap.  The reason is
that Cyclone cannot accurately track the lifetimes of individual
objects within the heap, so it can't be sure whether dereferencing a
pointer into the heap would cause problems.  Instead, a conservative
garbage collector reclaims the data allocated in the heap.

Using a garbage collector to recycle memory is the right thing to do
for most applications.  For instance, the Cyclone compiler uses
heap-allocated data and relies upon the collector to recycle most
objects it creates when compiling a program. But a garbage collector
can introduce pauses in the program, and as a general purpose memory
manager, might not be as space- or time-efficient as routines tailored
to an application.

To address these applications, Cyclone provides support for \emph{growable
regions}.  A growable region is similar to the region associated with
a code block.  In particular, when you execute:
\begin{verbatim}
{ region<`r> h;
   ...
}
\end{verbatim}
this declares a new region \texttt{`r} along with a \emph{region handle}
\texttt{h}.  The handle can be used for dynamically allocating objects within
the region \texttt{`r}.  All of the storage for
the region is deallocated at the point of the closing brace.  
Unlike block
regions, the number (and size) of objects that you allocate into
the region is not fixed at compile time.  In this respect, growable
regions are more like the heap.  You can use the \texttt{rnew(h)} and
\texttt{rmalloc(h,...)} operations to allocate objects within a growable
region, where \texttt{h} is the handle for the region.
 
For instance, the following code takes an integer $n$, creates
a new dynamic region and allocates an array of size
$n$ within the region using \texttt{rnew}.  
\begin{verbatim}
int k(int n) {
  int result;
  { region<`r> h;
    int ?arr = rnew(h) {for i < n : i};
    result = process(h, arr);
  }
  return result;
}
\end{verbatim}
It then passes the
handle for the region and the array to some processing function.
Note that the processing function is free to allocate objects
into the region \texttt{`r} using the supplied handle.  
After processing the array, we exit the region which deallocates
the array, and then return the calculated result.

It is worth remarking that the heap is really just a growable region
with global scope, and you can use the global variable 
\texttt{Core::heap_region}
as a handle on the heap.  Indeed, \texttt{new} and \texttt{malloc(...)}
are just abbreviations for \texttt{rnew(Core::heap_region)} and
\texttt{rmalloc(Core::heap_region,...)} respectively.  

\subsubsection*{Region Polymorphism}

Another key concept you need to understand is called
\emph{region polymorphism}.  This is just a fancy way of saying
that you can write functions in Cyclone that don't care which
specific region a given object lives in, as long as it's still
alive.  For example, the function \texttt{foo} from the beginning
of this section is a region-polymorphic function.  To make this
clear, let us re-write the function making the regions explicit:
\begin{verbatim}
void foo(struct Point *@region(`r) p) {
  p->y = 1234;
  return;
}
\end{verbatim}
The function is parameterized by a region \emph{variable} \texttt{`r}
and accepts a pointer to a \texttt{Point} that lives in region
\texttt{`r}.  Note that \texttt{`r} can be instantiated with
any region you like, including the heap, or a region local to
a function.  So, for instance, we can write the following:
\begin{verbatim}
void g() {
  struct Point p = {0,1};
  struct Point *@region(`g) ptr1 = &p;
  struct Point *@region(`H) ptr2 = new Point{2,3};
  foo(ptr1);
  foo(ptr2);
}
\end{verbatim}
Note that in the first call to \texttt{foo}, we are passing
a pointer into region \texttt{`g}, and in the second call to 
\texttt{foo}, we are passing in a pointer into the heap.  In
the first call, \texttt{`r} is implicitly instantiated with
\texttt{`g} and in the second call, with \texttt{`H}.  

Cyclone automatically inserts region parameters for function
arguments, so you rarely have to write them.  For instance,
\texttt{foo} can be written simply as:
\begin{verbatim}
void foo(struct Point * p) {
  p->y = 1234;
  return;
}
\end{verbatim}
As another example, if you write the following:
\begin{verbatim}
void h(struct Point * p1, struct Point * p2) {
  p1->x += p2->x;
  p2->x += p2->y;
}
\end{verbatim}
then Cyclone fills in the region parameters for you by assuming
that the points \texttt{p1} and \texttt{p2} can live in any
two regions \texttt{`r1} and \texttt{`r2}.  To make this explicit,
we would write:
\begin{verbatim}
void h(struct Point *@region(`r1) p1, 
       struct Point *@region(`r2) p2) {
  p1->x += p2->x;
  p2->x += p2->y;
}
\end{verbatim}
Now we can call \texttt{h} with pointers into any two regions,
or even two pointers into the same region.  This is because
the code is type-correct \emph{for all} regions \texttt{`r1} and \texttt{`r2}.

Occasionally, you will have to put region parameters in explicitly.
This happens when you need to assert that two pointers point into 
the same region.  Consider for instance the following function:
\begin{verbatim}
void j(struct Point * p1, struct Point * p2) {
  p1 = p2;
}
\end{verbatim}
Cyclone will reject the code because it assumes that in general,
\texttt{p1} and \texttt{p2} might point into \emph{different} regions.
That is, Cyclone fills in the missing regions as follows:
\begin{verbatim}
void j(struct Point *@region(`r1) p1, 
       struct Point *@region(`r2) p2) {
  p1 = p2;
}
\end{verbatim}
Now it is clear that the assignment does not type-check because
the types of \texttt{p1} and \texttt{p2} differ.  In other words,
\texttt{`r1} and \texttt{`r2} \emph{might} be instantiated with
different regions, in which case the code would be incorrect.
But you can make them the same by putting in the same explicit region
for each pointer.  Thus, the following code does type-check:
\begin{verbatim}
void j(struct Point *@region(`r1) p1, 
       struct Point *@region(`r1) p2) {
  p1 = p2;
}
\end{verbatim}

So, Cyclone assumes that each pointer argument to a function is
in a (potentially) different region unless you specify otherwise.
The reason we chose this as the default is that (a) it is often
the right choice for code, (b) it is the most general type in
the sense that if it does work out, clients will have the most
lattitude in passing arguments from different regions or the
same region to the function.  

What about the results?  Here, there is no good answer because
the region of the result of a function cannot be easily determined
without looking at the body of the function, which defeats separate
compilation of function definitions from their prototypes.  Therefore,
we have arbitrarily chosen the heap as the default region for
function results.  Consequently, the following code:
\begin{verbatim}
struct Point * good_newPoint(int x,int y) {
  return new Point{x,y};
}
\end{verbatim}
type-checks since the \texttt{new} operator returns a pointer
to the heap, and the default region for the return type is the heap.

This explains why the original bad code for allocating a new
point does not type-check:
\begin{verbatim}
struct Point *newPoint(int x,int y) {
  struct Point result = {x,y};
  return &result;
}
\end{verbatim}
The value \texttt{\&result} is a pointer into region \texttt{`newPoint}
but the result type of the function needs to be a pointer into
the heap (region \texttt{`H}).  

If you want to return a pointer that is not in the heap region,
then you need to put the region in explicitly.  For instance,
the following code:
\begin{verbatim}
int * id(int *x) {
  return x;
}
\end{verbatim}
will not type-check.  To see why, let us rewrite the
code with the default region annotations filled in.  The argument
is assumed to be in a region \texttt{`r}, and the result is assumed to be
in the heap, so the fully elaborated code is:
\begin{verbatim}
int *@region(`H) id(int *@region(`r) x) {
  return x;
}
\end{verbatim}
Now the type-error is manifest.  To fix the code, we must put in
explicit regions to connect the argument type with the result type.
For instance, we might write:
\begin{verbatim}
int *@region(`r) id(int *@region(`r) x) {
  return x;
}
\end{verbatim}
or using the abbreviation:
\begin{verbatim}
int *`r id(int *`r x) {
  return x;
}
\end{verbatim}

\subsubsection*{Region Summary}

In summary, each pointer in Cyclone points into a given region
and this region is reflected in the type of the pointer.  Cyclone
won't let you dereference a pointer into a deallocated region.
The lexical blocks declared in functions correspond to one
type of region, and simply declaring a variable within that
block allocates storage within the region.  The storage is
deallocated upon exit of the block.  Growable regions are
similar, except that a dynamic number of objects can be allocated
within the region using the region's handle.  The heap is a
special region that is garbage collected.  

Region polymorphism makes it possible to omit many region 
annotations on types.  Cyclone assumes that pointers passed
to functions may live in distinct regions, and assumes that
result pointers are in the heap.  These assumptions are not
perfect, but (a) programmers can fix the assumptions by providing
explicit region annotations, (b) it permits Cyclone files
to be separately compiled.

The region-based type system of Cyclone is perhaps the most
complicated aspect of the language.  In large part, this is
because memory management is a difficult and tricky business.
We have attempted to make stack allocation and region polymorphic
functions simple to use without sacrificing programmer control
over the lifetimes of objects and without having to resort to
garbage collection.  

For more information about regions, see
\hyperref[{sec:regions}]{Section~\ref{sec:regions}}.

\subsection{Tagged Unions and Pattern Matching}

It's often necessary to write a function that accepts an argument with
more than one possible type.  For example, in
\begin{verbatim}
    printf("%d",x);
\end{verbatim}
\texttt{x} should be an integer, but in
\begin{verbatim}
    printf("%s",x);
\end{verbatim}
\texttt{x} should be a pointer to a sequence of characters.

If we call \texttt{printf("\%s",x)} with an integer \texttt{x},
instead of a pointer \texttt{x}, the program will likely crash.
To prevent this, most C compilers treat \texttt{printf} specially:
they examine the first argument and require that the remaining
arguments have the appropriate types.  However, a compiler can't check
this if \texttt{printf} isn't called with a literal string:
\begin{verbatim}
    printf(s,x);
\end{verbatim}
where \texttt{s} is a string variable.  This means that in C, programs
that use \texttt{printf} (or \texttt{scanf}, or a number of related
functions) are vulnerable to crashes and corrupted memory.  In fact,
it's possible for someone else to crash your program by causing it to
call \texttt{printf} with arguments that don't match the format
string.  This is called a \emph{format string attack}, and it's an
increasingly common exploit.

Cyclone provides \emph{tagged unions} so that you can safely write
functions that accept an argument with more than one possible type.
Like a C \texttt{union}, a Cyclone \texttt{tunion} is a type that has
several possible cases.  Here's a simple example:
\begin{verbatim}
    tunion t {
      Integer(int);
      String(const char ?);
    };
    tunion t x = new Integer(3);
    tunion t y = new String("hello, world");
\end{verbatim}
This declares a new type, \texttt{tunion t}, that can hold either an
integer or a string (remember, a string is a \texttt{char ?}\ in
Cyclone).  \texttt{Integer} and \texttt{String} are \emph{tags} for
the two possibilities.  The tags are used to build values of type
\texttt{tunion t}, as in the declarations of \texttt{x} and
\texttt{y}.

\emph{Pattern matching} is used to determine the tag of a value of
type \texttt{tunion t}, and to extract the underlying value.  For
example, here is a function that will print either an integer or a
string:
\begin{verbatim}
    void print(tunion t a) {
      switch (a) {
      case &Integer(i): printf("%d",i); return;
      case &String(s): printf("%s",s); return;
      }
    }
\end{verbatim}
The argument \texttt{a} has type \texttt{tunion t}, so it is either
built with tag \texttt{Integer} or tag \texttt{String}.  Cyclone
extends switch statements with \emph{patterns} that
distinguish between the cases.  The first case,
\begin{verbatim}
   case &Integer(i): printf("%d",i); return;
\end{verbatim}
contains a pattern, \texttt{\&Integer(i)}, that will match only values
that have been built with the \texttt{Integer} tag.  The variable
\texttt{i} is bound to the underlying integer, and it can be used in
the body of the case.  For example, \texttt{print(x)} will print 3,
since \texttt{x} holds \texttt{new Integer(3)}, and
\texttt{print(y)} will print \texttt{hello, world}.

The cases of a \texttt{tunion} can carry any number of values,
including none, and they can be recursive.  For example, we can define
a tree datatype as follows.
\begin{verbatim}
    tunion tree {
      Empty;
      Leaf(int);
      Node(tunion tree, tunion tree);
    };
\end{verbatim}
A tree can be empty, or it can be a single (leaf) node holding an
integer, or it can be an internal node with a left and a right
subtree.  In other words, \texttt{tunion tree} is the type of possibly
empty binary trees with integer leaves.

Here's a function, \texttt{sum}, that calculates the sum of the leaves
of a tree:
\begin{verbatim}
    int sum(tunion tree x) {
      switch (x) {
      case Empty: return 0;
      case &Leaf(i): return i;
      case &Node(y,z): return sum(y)+sum(z);
      }
    }
\end{verbatim}

It's written in a straightforward way, with a case for each possible
tag in the type \texttt{tunion tree}.  The \texttt{Empty} case is
noticeably different than the other two cases: the pattern does not
use the \texttt{\&} character.  The reason has to do with how
\texttt{tunion} is implemented.  Every value of \texttt{tunion} type
must have the same size; for example, the \texttt{Node} case
recursively calls \texttt{sum} on the subtrees \texttt{y} and
\texttt{z}, \emph{without knowing} whether they are empty, leaves, or
internal nodes.  The only way that it can extract \texttt{y} and
\texttt{z} from \texttt{x} without knowing this is if all possible
cases of \texttt{tunion tree} have the same size.

At the same time, each tag of a \texttt{tunion} can carry a different
number of values, so obviously each can require a different amount of
space.  To make it all work, the value-carrying cases of a
\texttt{tunion} are represented as pointers to structures containing a
distinguishing integer plus the values, and the non-value-carrying
cases of a \texttt{tunion} are represented just as distinguishing
integers.  Since integers and pointers have the same size in Cyclone,
this achieves the goal.

The data representation is reflected both in how \texttt{tunion}
values are constructed and in the patterns used to take them apart.
Value-carrying cases are built using the \texttt{new} keyword, which
performs a heap allocation and results in a pointer to the new
storage.  Non-value-carrying cases don't require any allocation, and
so they don't use \texttt{new}.  For example,
\begin{verbatim}
   new Node(Empty,new Leaf(5))
\end{verbatim}
builds a tree consisting of an internal node with an empty left
subtree, and a right subtree consisting of a single leaf, 5.  We use
\texttt{new} for the value-carrying cases, \texttt{Node} and
\texttt{Leaf}, but not for \texttt{Empty}.

In pattern matching, we use the \texttt{\&} character to match a
pointer.  So in the function \texttt{sum}, since \texttt{Leaf} and
\texttt{Node} are constructed as pointers, the \texttt{\&} is required
to match them.  Since \texttt{Empty} is not built as a pointer, the
\texttt{\&} must not appear.

You might be wondering, ``how does Cyclone tell whether a
\texttt{tunion} comes from a value-carrying case or a
non-value-carrying case?''  In particular, how can Cyclone tell the
integers used for non-value-carrying cases apart from the pointers
used for the other cases?  Here's how we do it in our current
implementation:  We reserve a space in the low part of memory where we
will never allocate Cyclone objects using \texttt{new}.  If a value of
a \texttt{tunion} is an address in this space, then it represents a
tag without values, and if it is an address outside of this space, it
represents a pointer to a structure containing a tag plus the values
that it carries.
  
You can find out more about patterns in
\hyperref[{sec:patterns}]{Section~\ref{sec:patterns}}; for more about
\texttt{tunion} and memory management, see
\hyperref[{sec:regions}]{Section~\ref{sec:regions}}.

%%% For example, \texttt{connect} is a C
%%% library function used to initiate communication with a machine on the
%%% Internet.  It can do so using a number of communication protocols,
%%% including IPv4 (Internet Protocol Version 4) and IPv6.  Each protocol
%%% uses a different form of address for machines on the Internet; to make
%%% an IPv4 connection, you call \texttt{connect} with an IPv4 address,
%%% and to make an IPv6 connection, you call \texttt{connect} with an IPv6
%%% address.  In other words, \texttt{connect}'s address argument has
%%% a different type depending on whether an IPv4 or IPv6 connection is
%%% being made.
%%%
%%% To make this work in C, \texttt{connect} is given the following type:
%%% \begin{alltt}
%%%     int \textbf{connect}(int \textit{fd}, const struct sockaddr *\textit{a}, socklen_t \textit{len});
%%% \end{alltt}
%%% The address argument, \textit{\texttt{a}}, is declared with type
%%% \texttt{struct sockaddr *}.  However, \texttt{connect} is never called
%%% with an argument of that type.  Instead, it will be called with an
%%% argument of type \texttt{struct sockaddr_in *} for an IPv4 connection,
%%% or \texttt{struct sockaddr_in6 *} for an IPv6 connection.  The
%%% \texttt{connect} function casts \textit{\texttt{a}} from type
%%% \texttt{struct sockaddr *} to type \texttt{struct sockaddr_in *} or
%%% type \texttt{struct sockaddr_in6 *} as appropriate.
%%%
%%% How does \texttt{connect} know whether to cast to an IPv4 address or
%%% an IPv6 address?  It expects all address structures to have a common
%%% field, at the same place in each structure, that gives the kind of
%%% address.  So \texttt{connect} examines the field and does the
%%% appropriate cast.  This can work quite well, but it isn't safe.  It's
%%% possible to call \texttt{connect} with an address structure where the
%%% common field is fill out incorrectly, either by accident or by
%%% malicious intent.  C has no protections against this, and
%%% \texttt{connect} has no way of detecting it; the cast will succeed and
%%% \texttt{connect}'s ``address'' argument might be something very
%%% different.


\subsection{Exceptions}

So far we've glossed over what happens when you try to dereference a
null pointer, or assign to an out-of-bounds \texttt{?}\ pointer.
We've said that Cyclone inserts checks to make sure the operation is
safe, but what if the checks fail?  For safety, it would be sufficient
to halt the program and print an error message---a big improvement
over a core dump, or, worse, a program with corrupted data that keeps
running.

In fact, Cyclone does something a bit more general than halting with
an error message: it throws an \emph{exception}.  The advantage of
exceptions is that they can be \emph{caught} by the programmer, who
can then take corrective action and perhaps continue with the program.
If the exception is not caught, the program halts and prints an error
message.  Consider our earlier example:
\begin{verbatim}
    FILE *f = fopen("/etc/passwd","r");
    int c = getc((FILE @)f);
\end{verbatim}
Suppose that there is no file \texttt{/etc/passwd}; then
\texttt{fopen} will return NULL, and when \texttt{f} is cast to
\texttt{FILE @}, the implied null check will fail.  The program will
halt with an error message,
\begin{verbatim}
    Uncaught exception Null_Exception
\end{verbatim}
\texttt{Null_Exception} is one of a handful of standard exceptions
used in Cyclone.  Each exception is like a case of a \texttt{tunion}:
it can carry along some values with it.  For example, the standard
exception \texttt{InvalidArg} carries a string.  Exceptions can be
handled in \texttt{try}-\texttt{catch} statements, using pattern
matching:
\begin{verbatim}
    FILE *f = fopen("/etc/passwd","r");
    int c;
    try {
      c = getc((FILE @)f);
    }
    catch {
    case Null_Exception:
      printf("Error: can't open /etc/passwd\n");
      exit(1);
    case &InvalidArg(s):
      printf("Error: InvalidArg(%s)\n",s);
      exit(1);
    }
\end{verbatim}
Here we've ``wrapped'' the call to \texttt{getc} in a
\texttt{try}-\texttt{catch} statement.  If \texttt{f} isn't NULL and
the \texttt{getc} succeeds, then execution just continues, ignoring
the \texttt{catch}.  But if \texttt{f} is NULL, then the null check
will fail and the exception \texttt{Null_Exception} will be thrown;
execution immediately continues with the \texttt{catch} (the call to
\texttt{getc} never happens).  In the \texttt{catch}, the thrown
exception is pattern matched against the cases.  Since the thrown
exception is \texttt{Null_Exception}, the first case is executed here.

There is one important difference between an exception and a case of a
\texttt{tunion}: with \texttt{tunion}, all of the cases have to be
declared at once, while a new exception can be declared at any time.
So, exceptions are an \emph{extensible} \texttt{tunion}, or
\texttt{xtunion}.  Here's how to declare a new exception:
\begin{verbatim}
    xtunion exn {
      My_Exception(char ?);
    };
\end{verbatim}
The type \texttt{xtunion exn} is the type of exceptions, and this
declaration introduces a new case for the \texttt{xtunion exn} type:
\texttt{My_Exception}, which carries a single value (a string).
Exception values are created just like \texttt{tunion} values---using
\texttt{new} for value-carrying tags only---and are thrown with a
\texttt{throw} statement.  For example,
\begin{verbatim}
    throw new My_Exception("some kind of error");
\end{verbatim}
or
\begin{verbatim}
    throw Null_Exception;
\end{verbatim}

\subsection{Additional Features of Cyclone}

Thus far, we have mentioned a number of advanced features of
Cyclone that provide facilities needed to avoid common bugs
or security holes in C.  
But there are many other features in Cyclone that are
aimed at making it easier to write code, ranging from convenient
expression forms, to advanced typing constructs.  For instance,
like GCC and C99, Cyclone allows you declare variables just
about anywhere, instead of at the top of a block.  As another
example, like Java, Cyclone lets you declare variables within
the initializer of a \texttt{for}-statement.  

In addition, Cyclone adds advanced typing support in the form of (a)
parametric polymorphism, (b) structural subtyping, (c) some
unification-based, local-type inference.  These features are necessary
to type-check or port a number of (potentially) unsafe C idioms,
usually involving ``\texttt{void*}'' or the like.  Similarly, \texttt{tunion}
types can be used to code around many of the uses for C's \texttt{union} types
-- another potential source of unsoundness.  
In what follows, we give a brief overview of these added features.

\subsection{GCC and C99 Additions}

GCC and the
\href{http://web.onetelnet.ch/~twolf/tw/c/c9x_changes.html}{ISO C99
  standard} have some useful new features that we have adopted for
Cyclone. Some of the ones that we currently support are:
\begin{itemize}
\item Statement expressions: There is a new expression form,
  \texttt{(\lb} \textit{statement} \textit{expression} \texttt{\rb)}.
  The statement is executed first, then the expression, and the value
  of the entire expression is the value of the expression
\item Struct expressions:  If you've declared
  \texttt{struct point\{int x; int y;\};} then you can write
  \texttt{point\{.x=\textit{expression}, .y=\textit{expression}\}}
 to allocate and initialize a struct point
\item \texttt{//} comments as in Java or C++
\item Declarations can appear in any statement position.  It is not
  necessary to wrap braces around the declaration of a local variable.
\item For-statements can include a declaration. For instance:
\begin{verbatim}
  for (int x=0; x < n; x++) { 
    ...
  }
\end{verbatim}
\end{itemize}

We expect to follow the C99 standard fairly closely.

%%% \subsection{Pointers}
%%% There are three different pointer types in Cyclone, written
%%% ``\texttt{t*},'' ``\texttt{t@},'' and ``\texttt{t?}.''  Actually, pointers
%%% are quite a bit more complicated than this, but these are the pointer
%%% types that you'll most likely use the most.
%%%
%%% A value of type \texttt{t*} is a possibly \texttt{null} pointer to a
%%% value of type \texttt{t}.  When these values are dereferenced, a
%%% \texttt{null} check is performed and an exception is raised if the
%%% value is actually \texttt{null}. To ensure statically that a pointer
%%% cannot be \texttt{null}, you can use the type \texttt{t@} instead.
%%% Dereferencing a \texttt{@} pointer requires no run-time overhead and
%%% will not raise an exception.  Pointer arithmetic and subscripting
%%% (except for 0) are not supported for values of type \texttt{t*} or
%%% \texttt{t@} (but see below).  Both kinds of pointers are represented
%%% the same way as C pointers.
%%%
%%% In general, one can write ``\verb|t*{e}|'' to describe a pointer to an
%%% array of \texttt{t} values with \texttt{e} elements, where \texttt{e} is a
%%% constant expression.  For instance, the following code is permissible:
%%% \begin{verbatim}
%%%   int x[5] = {0,1,2,3,4};
%%%   int *{5}p = x;
%%% \end{verbatim}
%%%
%%% Here, we've said that \texttt{p} is a (possibly \texttt{null}) pointer to
%%% an array of five integers. When a pointer has type \verb|t*{e}|, then
%%% it is permissible to use subscripts in the range 0 to \texttt{e}-1 to
%%% access the elements of \texttt{p}.  Note that \texttt{t*} is short hand
%%% for \verb|t*{1}| (and similarly \texttt{t@} is short hand for
%%% \verb|t@{1}|).
%%%
%%% A value of type \texttt{t?}\ is a checked pointer to a (possibly empty)
%%% array of values of type \texttt{t}.  Unlike \texttt{*} or \texttt{@}
%%% pointers, checked pointers support arbitrary pointer arithmetic
%%% (following the rules of C), arbitrary integer subscripts, etc.
%%% However, each access is checked to ensure that the pointer is within
%%% the bounds of the original underlying array.
%%%
%%% Values of type \verb|t*{e}| or \verb|t@{e}| or \texttt{t[e]} can be cast
%%% to type \texttt{t?}\ to support pointer arithmetic.  Furthermore, values
%%% of type \texttt{t?}\ can be cast to type \verb|t*{e}| or \verb|t@{e}|,
%%% but this requires a run-time check to ensure that the corresponding
%%% array slice is in bounds.
%%%
%%% Obviously, checked pointers require more information than \texttt{*} or
%%% \texttt{@} pointers, so that we can determine whether the access is in
%%% bounds.  Consequently, checked pointers are larger than normal
%%% pointers.  (The current implementation uses three words for each
%%% checked pointer.)  However, one rarely needs checked pointers unless
%%% you're performing lots of pointer arithmetic. In subsequent releases,
%%% we hope to support checked but untagged representations for these
%%% pointers using technology from dependent type theory.
%%%
%%% Finally, we should note that in fact all pointers in Cyclone point
%%% into a region. By default, if you don't mention a region, then the
%%% pointer points into the disgtinguished heap region (written `H).
%%% Pointers to stack-allocated objects live in regions that are private
%%% to the enclosing scope. More on this later\ldots

\subsection{Tuples}

Tuples are like lightweight structs.  They need not be declared in
advance, and have member or field names that are implicitly 0, 1, 2,
3, etc.  For example, the following code declares \texttt{x} to be a
3-tuple of an integer, a character, and a boolean, initialized with
the values 42, \texttt{'z'}, and \texttt{true} respectively.  It then
checks to see whether the third component in the tuple is \texttt{true}
(it is) and if so, increments the first component in the tuple.
\begin{verbatim}
  $(int,char,bool) x = $(42,'z',true)

  if (x[2])
    x[0]++;
\end{verbatim}

The above code would be roughly equivalent to writing:
\begin{verbatim}
  struct {int f0; char f1; bool f2;} x = {42,'z',true};
  if (x.f2)
    x.f1++;
\end{verbatim}

Thus, tuple types are written \texttt{\$(type1,...,typen)}, tuple
constructor expressions are written \texttt{\$(exp1,...,expn)}, and
extracting the ith component of a tuple is written using subscript
notation \texttt{exp[i-1]}.  Note that, consistent with the rest of C,
the members start with 0, not 1.

Unlike structs, tuple types are treated equivalent as long as they are
structurally equivalent.  As in C, struct types are equivalent only if
they have the same tag or name.  (Note that in C, all struct
declarations have a tag, even if the compiler has to gensym one.)


\subsection{Creating Arrays}

There are about four ways to create arrays in Cyclone. One can always
declare an array and provide an initializer as in C\@. For instance:
\begin{verbatim}
  int foo[8] = {1,2,3,4,5,6,7,8};
  char s[4] = "bar";
\end{verbatim}
are both examples from C for creating arrays.  Note that Cyclone
follows C's conventions here, so that if you declare arrays as above
within a function, then the lifetime of the array coincides with the
activation record of the enclosing scope.  In other words, such arrays
will be stack allocated.

To create heap-allocated arrays (or strings) within a Cyclone
function, you should either use ``\texttt{new}'' operator with either an
array initializer or an array comprehension. The following code
demonstrates this:
\begin{verbatim}
  // foo is a pointer to a heap-allocated array
  int *{8}foo = new {1,2,3,4,5,6,7,8};

  // s is a checked pointer to a heap-allocated string
  char ?s = new "bar";

  // a non-null pointer to the first 100 even numbers
  int @{100}evens = new {for i < 100 : 2*i};
\end{verbatim}

\subsection{Subtyping}
Cyclone supports ``extension on the right'' and ``covariant depth on
\texttt{const}'' subtyping for pointers.  This simply means that you
can cast a value \texttt{x} from having a type ``pointer to a struct
with 10 fields,'' to ``pointer to a struct having only the first 5
fields.''  For example, if we have the following definitions:
\begin{verbatim}
  typedef struct Point {float x,y;} *point;

  typedef struct CPoint {float x,y; int color;} *cpoint;

  float xcoord(point p) {
    return p->x;
  }
\end{verbatim}
then you can call \texttt{xcoord} with either a \texttt{point} or
\texttt{cpoint} object.  You can also cast a pointer to a tuple having 3
fields (e.g., \texttt{\$(int,bool,double)*}) to a pointer to a tuple
having only 2 fields (e.g., \texttt{\$(int,bool)*}).  In other words, you
can forget about the ``tail'' of the object.  This allows a degree of
polymorphism that is useful when porting C code.  In addition, you can
do ``deep'' casts on pointer fields that are \texttt{const}.  (It is
unsafe to allow deep casts on non-const fields.)  Also, you can cast
a field from being non-const to being const.  You can also cast a
constant-sized array to an equivalent pointer to a struct or tuple.
In short, Cyclone attempts to allow you to cast one type to another as
long as it is safe.  Note, however, that these casts must be explicit.

We expect to add more support for subtyping in the future (e.g.,
subtyping on function pointers, bounded subtyping, etc.)


%%% \subsection{Tagged Unions}
%%% 
%%% Cyclone's tagged unions (\texttt{tunion}) are based on the algebraic
%%% datatypes that first appeared in functional languages such as Hope,
%%% Miranda, ML, and Haskell.  They provide a safe way for building data
%%% structures that contain possibly many different types and can be used
%%% to build algebraic or inductively defined structures, such as lists,
%%% trees, graphs, etc.  For instance, the following tunion declarations
%%% give a way to construct abstract syntax trees for a simple calculator
%%% language:
%%% \begin{verbatim}
%%%   tunion operator { Plus, Times, Minus, Divide }
%%%   tunion absyn {
%%%     Integer(int);
%%%     Term(tunion absyn, tunion operator, tunion absyn);
%%%   }
%%%   tunion absyn e1 = new Term(new Integer(3),Plus,new Integer(4));
%%%   tunion absyn e2 = new Term(e1,Times,new Integer(5));
%%% \end{verbatim}
%%% 
%%% The operator definition is like an enum---it just defines symbolic
%%% constants for \texttt{Plus}, \texttt{Times}, \texttt{Minus}, and
%%% \texttt{Divide}.  The \texttt{absyn} definition defines an inductive
%%% tree-like data type for abstract syntax.  The \texttt{Integer}
%%% constructor takes an \texttt{int} argument and returns an \texttt{absyn}
%%% value.  The \texttt{Term} constructor takes an abstract syntax tree, an
%%% operator, and an abstract syntax tree and returns a new abstract
%%% syntax tree.  So, for example, \texttt{e1} is a tree representing the
%%% term ``3 + 4'' while \texttt{e2} is a tree representing the term ``(3 +
%%% 4) * 5.''
%%% 
%%% Internally, \texttt{tunion} constructors are either represented as an
%%% integer value (as with \texttt{Plus}, \texttt{Times}, \texttt{Minus}, and
%%% \texttt{Divide}) or a pointer to an object containing a tag and the
%%% arguments to the constructor.  The object is always allocated on the
%%% heap.  To traverse the tree, we use pattern matching, again in the
%%% style of functional languages such as ML or Haskell.
%%% 
%%% In the future, we plan to make the representation of tunions explicit
%%% and to allow programmers to control tag placement and do explicit
%%% tests on the tag to refine the type of an object in a more
%%% traditional, data-flow fashion.  We will probably keep the tunion
%%% construct as is for convenience.

%%% \subsection{Pattern Matching}
%%% Pattern matching in Cyclone generalizes the switch construct of C
%%% allowing you to not only test integral values, but also to test
%%% structured values such as the abstract syntax trees above.  For
%%% example, the following function takes in an abstract syntax tree and
%%% prints the tree to stdout:
%%% \begin{verbatim}
%%%   void print_absyn(tunion absyn tree) {
%%%      switch (tree) {
%%%      case &Integer(i)       : printf("%d",i); break;
%%%      case &Term(t1,Plus,t2) : printf("("; print_absyn(t1);
%%%                               printf("+");
%%%                               print_absyn(t2); printf(")"); break;
%%%      case &Term(t1,Times,t2): printf("("; print_absyn(t1);
%%%                               printf("*");
%%%                               print_absyn(t2); printf(")"); break;
%%%      case &Term(t1,Minus,t2): printf("("; print_absyn(t1);
%%%                               printf("-");
%%%                               print_absyn(t2); printf(")"); break;
%%%      case &Term(t1,Divide,t2):printf("("; print_absyn(t1);
%%%                               printf("/");
%%%                               print_absyn(t2); printf(")"); break;
%%%   }
%%% \end{verbatim}
%%% 
%%% Note that patterns introduce and initialize new variables local to a
%%% given case.  For instance, in the \texttt{Integer} case above, the
%%% pattern variable \texttt{i} is introduced and is initialized to whatever
%%% value is carried by the Integer constructor.  Thus, \texttt{i} is
%%% available for use on the right-hand-side of the case.  You can pattern
%%% match on just about any kind of value, and destructure it.  For
%%% instance, you can pattern match on tuples, structs, pointers to
%%% tuples/structs, etc.  See the grammar for the syntax of the various
%%% pattern forms.
%%% 
%%% The type-checker for Cyclone is much more picky about switch
%%% statements than C\@.  In particular, it will check that all of the
%%% patterns you have are exhaustive (or else there's a \texttt{default:}
%%% clause) and that none of the patterns overlap.  This is useful for
%%% evolving code.  For instance, if we added a new operator (say
%%% \texttt{Mod}), then the compiler would complain that the \texttt{switch}
%%% in \texttt{print_absyn} doesn't cover all possible cases (namely the
%%% case where we have a term involving the \texttt{Mod} operator.)
%%% 
%%% In addition, the Cyclone type-checker makes sure that you don't
%%% accidentally fall-through from one case to another.  In particular, if
%%% you don't put in explicit breaks, returns, throws, etc., then the
%%% compiler will reject the code.  You can still fall through to the next
%%% case, but you have to do it with an explicit ``\texttt{fallthru}''
%%% statement.  If the case pattern doesn't bind any new variables, then
%%% you just write ``\texttt{fallthru;}'' as the last thing in the case.  If
%%% you want to fall through to a case that defines new variables, then
%%% you need to give values for those variables.  For instance, in the
%%% following code:
%%% \begin{verbatim}
%%%   void foo(tunion absyn tree) {
%%%      switch (tree) {
%%%      case &Integer(i)       : printf("%d ",i); break;
%%%      case &Term(t1,Plus,t2) : printf("It's a plus \n");
%%%                               fallthru(t2,Plus,t1);
%%%      case &Term(t1,op,t2)   : foo(t1); foo(t2); break;
%%%   }
%%% \end{verbatim}
%%% if we pass it a tree \texttt{Term(Integer(3),Plus,Integer(4))} then we
%%% will see ``It's a plus 4 3,'' but if we pass it
%%% \texttt{Term(Integer(3),Times,Integer(4))} we will see ``3 4.''

\subsection{Let Declarations}

Sometimes, it's painful to declare a variable because you have to
write down its type, and Cyclone types can be big when compared
to their C counterparts since they may include bounds information,
regions, \emph{etc}.  Therefore, Cyclone includes additional support for type
inference using let declarations.  In particular, you can write:
\begin{verbatim}
  int foo(int x) {
    let y = x+3;
    let z = 3.14159;
    return (int)(y*z);
  }
\end{verbatim}

Here, we declared two variables y and z using ``\texttt{let}.''  When
you use \texttt{let}, you don't have to write down the type of the
variable.  Rather, the compiler infers the type from the expression
that initializes the variable.  More generally, you can write
``\texttt{let pattern = exp;}'' to destructure a value into a bunch of
variables.  For instance, if you pass a tuple to a function, then you
can extract the components as follows:
\begin{verbatim}
  int sum($(int,int,int) args) {
    let $(x,y,z) = args;
    return (x+y+z);
  }
\end{verbatim}

\subsection{Polymorphic Functions}
As mentioned above, Cyclone supports a limited amount of subtyping
polymorphism.  It also supports a fairly powerful form of parametric
polymorphism.  Those of you coming from ML or Haskell will find this
familiar.  Those of you coming from C++ will also find it somewhat
familiar.  The basic idea is that you can write one function that
abstracts the types of some of the values it manipulates.  For
instance, consider the following two functions:
\begin{verbatim}
  $(char*,int) swap1($(int,char*) x) {
     return $(x[1], x[0]);
  }
  $(int,int) swap2($(int,int) x) {
     return $(x[1], x[0]);
  }
\end{verbatim}

The two functions are quite similar: They both take in a pair (i.e., a
2-tuple) and return a pair with the components swapped.  At the
machine-level, the code for these two functions will be exactly the
same, assuming that \texttt{int}s and \texttt{char *}s are
represented the same way.  So it seems silly to write the code twice.
Normally, a C programmer would replace the definition with simply:
\begin{verbatim}
  $(void *,void *) swap1($(void *,void *) x) {
     return $(x[1], x[0]);
  }
\end{verbatim}
(assuming you added tuples to C).  But of course, this isn't type-safe
because once I cast the values to \texttt{void *}, then I can't be sure
what type I'm getting out.  In Cyclone, you can instead write
something like this:
\begin{verbatim}
  $(`b,`a) swap($(`a,`b) x) {
     return $(x[1],x[0]);
  }
\end{verbatim}
The code is the same, but it abstracts what the types are.  The types
\texttt{`a} and \texttt{`b} are type variables that can be instantiated
with any word-sized, general-purpose register type.  So, for instance,
you can call swap on pairs of integers, pairs of pointers, pairs of an
integer and a pointer, etc.:
\begin{verbatim}
  let $(x,y) = swap($("hello",3));  // x is 3, y is hello
  let $(w,z) = swap($(4,3));        // w is 3, z is 4
\end{verbatim}

Note that when calling a polymorphic function, you need not tell it
what types you're using to instantiate the type variables.  Rather,
Cyclone figures this out through unification.

C++ supports similar functionality with templates.  However, C++ and
Cyclone differ considerably in their implementation strategies.
First, Cyclone only produces one copy of the code, whereas a C++
template is specialized and duplicated at each type that it is used.
This approach requires that you include definitions of templates in
interfaces and thus defeats separate compilation.  However, the
approach used by Cyclone does have its drawbacks: in particular, the
only types that can instantiate type variables are those that can be
treated uniformly.  This ensures that we can use the same code for
different types.  The general rule is that values of the types that
instantiate a type variable must fit into a machine word and must be
passed in general-purpose (as opposed to floating-point) registers.
Examples of such types include \texttt{int}, pointers, \texttt{tunion},
and \texttt{xtunion} types.  Other types, including \texttt{char},
\texttt{short}, \texttt{long long}, \texttt{float}, \texttt{double},
\texttt{struct}, and \texttt{tuple} types violate this rule and thus
values of these types cannot be passed to a function like swap in
place of the type variables. In practice, this means that you tend to
manipulate a lot of pointers in Cyclone code.

The combination of parametric polymorphism and sub-typing means that
you can cover a lot of C idioms where \texttt{void*} or unsafe casts
were used without sacrificing type-safety.  We use polymorphism a lot
when coding in Cyclone.  For instance, the standard library includes
many container abstractions (lists, sets, queues, etc.) that are all
polymorphic in the element type.  This allows us to re-use a lot of
code.  In addition, unlike C++, those libraries can be compiled once
and need not be specialized.  On the downside, this style of
polymorphism does not allow you to do any type-specific things (e.g.,
overloading or ad-hoc polymorphism.)  Someday, we may add support for
this, but in the short run, we're happy not to have it.


\subsection{Polymorphic Data Structures}
Just as function definitions can be parameterized by types, so can
\texttt{struct} definitions, \texttt{tunion} definitions, and even
\texttt{typedef}s.  For instance, the following \texttt{struct} definition
is similar to the one used in the standard library for lists:
\begin{verbatim}
  struct List<`a> {`a hd; struct List<`a> * tl; };
  typedef struct List<`a> *list_t<`a>;
\end{verbatim}

Here, we've declared a \texttt{struct List} parameterized by a type
\texttt{`a}.  The \texttt{hd} field contains an element of type \texttt{`a}
and the \texttt{tl} field contains a possibly-null pointer to a
\texttt{struct List} with elements of type \texttt{`a}.  We then define
\texttt{list_t<`a>} as an abbreviation for \texttt{struct List<`a>*}.  So,
for instance, we can declare both integer and string lists like this:
\begin{verbatim}
  list_t<int> ilist = new List{1,new List{2,null}};
  list_t<string_t> slist = new List{.hd = "foo",
                                  .tl = new List{"bar",null}};
\end{verbatim}

Note that we use ``\texttt{new}'' as in C++ to allocate a new
\texttt{struct List} on the heap and return a pointer to the resulting
(initialized) \texttt{List} object.  Note also that the field designator
(``\texttt{.hd}'', ``\texttt{.tl}'') are optional.

Once you have polymorphic data structures, you can write lots of
useful polymorphic code and use it over and over again.  For instance,
the standard list library (see lib/list.h) includes functions for
mapping over a list, looking up items in a list, concatenating two
lists, copying lists, sorting lists, etc.

\subsection{Abstract and Existential Types}
Suppose you want to declare an abstract type for implementing stacks.
In Cyclone, the way this is accomplished is by declaring a struct that
encapsulates the implementation type, and by adding the
``\texttt{abstract}'' qualifier to the struct definition.  For instance,
if we write:
\begin{verbatim}
  abstract struct Queue<`a> { list_t<`a> front, rear; };
\end{verbatim}
then this declares a polymorphic \texttt{Queue} implementation that is
abstract.  The definition of the struct is available within the unit
that declares the Queue, but will not be made available to the outside
world.  (This will be enforced by a link-time type-checker that we
are currently putting together.)  Typically, the provider of the
\texttt{Queue} abstraction would write in an interface file:
\begin{verbatim}
  extern struct Queue<`a>;
\end{verbatim}
The abstract keyword in the implementation ensures that the definition
does not leak to a client.  
% One can also declare \texttt{tunion}s to be
% abstract, though I find it more useful to always use a \texttt{struct}
% to encapsulate the tunion, and make the \texttt{tunion} static, and the
% struct \texttt{abstract}.  That way, clients are always given an
% abstract struct to manipulate.

\texttt{Typedef}s can be made abstract by writing:
\begin{verbatim}
typedef _ foo_t;
\end{verbatim}
However, our current implementation does not support later redefining
\texttt{foo_t} as a non-abstract typedef.  The default kind for the
type is B; you can write an explicit kind like this:
\begin{verbatim}
typedef _::A bar_t;
\end{verbatim}
Generally abstract structs are sufficient.  An abstract typedef is
useful in some cases, though, such as when the abstracted type is
actually \texttt{int}.

It's also possible to code up ``first-class'' abstract data types
using \texttt{struct}s with \emph{existentially quantified type
  variables}.  Existential types are described in
\hyperref[{sec:advanced}]{Section~\ref{sec:advanced}}.

% In particular, pattern matching one of these constructors
% requires you to introduce explicit type variables into which the
% actual types are ``unpacked.''  
% These variables are treated abstractly
% in the body of a case.  However, when creating one of the values, it
% is not necessary to explicitly ``pack'' the types to be abstracted.
% Rather, the types are discovered through unification.  
For an example of the use of existential types, see the \texttt{fn.h}
and \texttt{fn.cyc} files in the standard library, which implement
first-class closures.

\subsection{Restrictions}

Though Cyclone adds many new features to C, there are also a number
of restrictions that it must enforce to ensure code does not crash.
Here is a list of the major restrictions:
\begin{itemize}
\item Cyclone does not permit some of the casts that are allowed in C because
  incorrect casts can lead to crashes, and it is not always possible
  for us to determine what is safe.  In general, you should be
  able to cast something from one type to another as long as the
  underlying representations are compatible.  Note that Cyclone is
  very conservative about ``compatible'' because it does not know
  the size or alignment constraints of your C compiler.  

\item Cyclone does not support pointer arithmetic on \texttt{*} or
  \texttt{@} pointers unless they are zero-terminated and even then,
  there are checks to make sure you can't go past a zero.  Pointer 
  arithmetic is not unsafe in itself, but
  it can lead to unsafe code when the resulting pointer is assigned or
  dereferenced.  You can cast the \texttt{*} or \texttt{@} value to a
  \texttt{?}\ value and then do the pointer arithmetic instead.

\item Cyclone inserts a NULL check when a \texttt{*} pointer is
  dereferenced and it cannot determine statically that the pointer is
  not NULL\@.

\item Cyclone requires any function that is supposed to return a
  non-\texttt{void} value to execute a return statement (or throw an
  exception) on every possible execution path. This is needed to
  ensure that the value returned from the function has the right type,
  and is not just a random value left in a register or on the stack.

\item Unions in Cyclone can only hold ``bits.''  In particular, they
  can hold combinations of chars, ints, shorts, longs, floats,
  doubles, structs of bits, or tuples of bits. Pointer types are not
  supported.  This avoids the situation where an arbitrary bit pattern
  is cast to a pointer and then dereferenced. If you want to use
  multiple types, then use tagged unions (\texttt{tunion}s).

\item Cyclone only supports a limited form of \texttt{malloc} which is
  baked in. Tuples and structs can be allocated via \texttt{malloc}
  but this requires writing explicitly: \texttt{malloc(sizeof(t))}
  where t is the type of the value that you are allocating.  You
  can \texttt{malloc} arrays (e.g., \texttt{malloc(sizeof(int)*34)})
  but the type must be ``bits-only'' (i.e., not contain pointer types.)
  You can use \texttt{calloc} to allocate arrays of (possibly NULL)
  pointers (e.g., \texttt{calloc(sizeof(char*),34)}).  

\item Cyclone performs a static analysis to ensure that every
  non-numeric (i.e., pointer) variable
  and \texttt{struct} field is initialized before it is used. This
  prevents a random stack value from being used improperly. The
  analysis is somewhat conservative so you may need to initialize
  things earlier than you would do in C\@.  There is only limited
  support for initializing memory in a procedure separate from the one
  that does the allocation.

\item Cyclone does not permit \texttt{goto}s from one scope into
  another. C warns against this practice, as it can cause crashes;
  Cyclone rules it out entirely.

\item Cyclone places some limitations on the form of switch statements
  that rule out crashes like those caused by unrestricted
  \texttt{goto}.  Furthermore, Cyclone prevents you from accidentally
  falling through from one case to another. To fall through, you must
  explicitly use the \texttt{fallthru} keyword.  Otherwise, you must
  explicitly \texttt{break}, \texttt{goto}, \texttt{continue},
  \texttt{return}, or \texttt{throw} an exception.  However, adjacent
  cases for a switch statement (with no intervening statement) do
  not require an explicit \texttt{fallthru}.

\item In the near future, Cyclone will place some restrictions on
  linking for safety reasons. In particular, if you import a variable
  or function with one type, then it must be exported by another file
  with that type. In addition, access to C code will be restricted
  based on a notion of security roles.

\item Cyclone has some new keywords (\texttt{let}, \texttt{abstract},
  \texttt{region}, etc.) that can no longer be used as identifiers.

\item Cyclone prevents you from using pointers to stack-allocated
  objects as freely as in C to avoid security holes. The reason is
  that each declaration block is placed in a conceptual ``region'' and
  the type system tracks the region into which a pointer points.

\item Cyclone does not allow you to explicitly free a heap-allocated
  object. Instead, you can either use the region mechanism or rely
  upon the conservative garbage collector to reclaim the space.

\end{itemize}

In addition, there are a number of shortcomings of the current
implementation that we hope to correct in the near future.  For
instance:
\begin{itemize}
\item Cyclone currently does not support nested type declarations
  within a function. All \texttt{struct}, \texttt{union}, \texttt{enum},
  \texttt{tunion}, \texttt{xtunion}, and \texttt{typedef} definitions must
  be at the top-level.

\item Cyclone does not allow you to use a \texttt{struct}, \texttt{tunion},
  \texttt{union}, \texttt{xtunion}, or \texttt{enum} type without first
  declaring it.  We do support one special case of this where you embed
  a declaration within a typedef as in:
\begin{verbatim}
  typedef struct Point {int x,y} *point_t;
\end{verbatim}

\item Cyclone does not allow a typedef declaration to be shadowed by
another declaration.
\end{itemize}


% Local Variables:
% TeX-master: "main-screen"
% End:
