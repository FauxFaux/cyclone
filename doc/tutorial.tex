\section{Cyclone for C Programmers}

We begin with a quick overview of Cyclone, suitable for those who
already know how to program in C\@.  We'll explain some of the ways
that Cyclone differs from C and some of the reasons why; you should
come away with enough knowledge to start writing, compiling, and
running your own Cyclone programs.  We assume that the Cyclone
compiler is already installed on your system (see
\hyperref[{sec:install}]{Appendix~\ref{sec:install}}
if you need to install the compiler).

\subsection{Getting Started}

Here's a Cyclone program that prints the string ``\texttt{hello,
  world}.''
\begin{verbatim}
    #include <stdio.h>

    int main() {
      printf("hello, world\n");
      return 0;
    }
\end{verbatim}

It looks rather like a C program---in fact, a C compiler will happily
compile it.  The program uses \texttt{\#include} to tell the
preprocessor to import some standard definitions, it defines a
distinguished function \texttt{main} that serves as the entry point of
the program, and it uses the familiar \texttt{printf} function to
handle the printing; all of this is just as in C\@.

To compile the program, put it into a file \texttt{hello.cyc}, and run
the command
\begin{verbatim}
    cyclone -o hello hello.cyc 
\end{verbatim}
This tells the Cyclone compiler (\texttt{cyclone}) to compile the file
\texttt{hello.cyc}; the \texttt{-o} flag tells the compiler to leave
the executable output in the file \texttt{hello} (or, in Windows,
\texttt{hello.exe}).  If all goes well you can execute the program by
typing
\begin{verbatim}
    hello
\end{verbatim}
and it will print
\begin{verbatim}
    hello, world
\end{verbatim}

It's interesting to compare our program with a version that omits the
return statement:
\begin{verbatim}
    #include <stdio.h>

    int main() {
      printf("hello, world\n");
    }
\end{verbatim}

A C compiler will compile and run this version without warning.  
In contrast, Cyclone will warn that you have failed to return
an \texttt{int}.  Cyclone only warns you when you fail to return
an integral type (\texttt{char}, \texttt{short}, \texttt{int}, etc.) 
but it gives an error if you fail to return
other types (e.g., pointer types).  This requirement of
\emph{definite return} ensures type safety while imposing
minimal constraints on a programmer porting C code to Cyclone.

Definite return reflects Cyclone's concern with safety.  The caller of
the function expects to receive a value of the return type; if the
function does not execute a \texttt{return} statement, the caller will
receive some incorrect value instead.  If the returned value is supposed
to be a pointer, the caller might try to dereference it, and
dereferencing an arbitrary address can cause the program to crash.  So,
Cyclone requires a return statement with a value of the return
type whenever type safety can be compromised.  

\subsection{Pointers}

Programs that use pointers properly in C can be both fast and elegant.
But when pointers are used improperly in C, they cause core dumps and
buffer overflows.  To prevent this, Cyclone introduces different kinds
of pointers and either (a) puts some restrictions on how you can use pointers
of a given kind or (b) places no restrictions but may insert additional
run-time checks.

\subsubsection*{Nullable Pointers}

The first kind of pointer is indicated with a \texttt{*}, as in C\@.  For
example, if we declare
\begin{verbatim}
    int x = 3;
    int *y = &x;
\end{verbatim}
then \texttt{y} is a pointer to the integer 3 (the contents of
\texttt{x}).  The pointer, \texttt{y}, is represented by a memory
address, namely, the address of \texttt{x}.  To refer to the contents
of \texttt{y}, you use \texttt{*y}, so, for example, you can increment
the value of \texttt{x} with an assignment like
\begin{verbatim}
    *y = *y + 1;
\end{verbatim}

This much is just as in C\@.  However, there are some differences in
Cyclone:
\begin{itemize}
\item You can't cast an integer to a pointer.  Cyclone prevents this
  because it would let you overwrite arbitrary memory locations.  In
  Cyclone, \texttt{NULL} is a keyword suitable for situations where
  you would use a (casted) \texttt{0} in C\@.  The compiler 
  accepts \texttt{0} as a legal possibly-null pointer value, but using
  \texttt{NULL} is preferred.
\item You can't do pointer arithmetic on a \texttt{*} pointer.
  Pointer arithmetic in C can take a pointer out of bounds, so that
  when the pointer is eventually dereferenced, it corrupts memory or
  causes a crash.  (However, pointer arithmetic is possible
  using \texttt{@fat}\ and \texttt{@zeroterm} pointers.)
\item There is one other way to crash a C program using pointers: you
  can dereference the \texttt{NULL} pointer or try to update the 
  \texttt{NULL} location.
  Cyclone prevents this by inserting a null check whenever you
  dereference a \texttt{*} pointer (that is, whenever you use the
  \texttt{*}, \texttt{->}, or subscript operation on a pointer.)
\end{itemize}

These are drastic differences from C, particularly the restriction on
pointer arithmetic.  The benefit is that you can't cause a crash using
\texttt{*} pointers in Cyclone.

\subsubsection*{Fat Pointers}

If you need to do pointer arithmetic in Cyclone, you can use a second
kind of pointer, called a \emph{fat pointer} and indicated by 
writing the qualifier \texttt{@fat} after the \texttt{*}.  For
example, here is a program that echoes its command-line arguments:
\begin{verbatim}
    #include <stdio.h>

    int main(int argc, char *@fat *@fat argv) {
      argc--; argv++; /* skip command name */
      if (argc > 0) {
        /* print first arg without a preceding space */
        printf("%s",*argv);
        argc--; argv++;
      }
      while (argc > 0) {
        /* print other args with a preceding space */
        printf(" %s",*argv);
        argc--; argv++;
      }
      printf("\n");
      return 0;
    }
\end{verbatim}

Except for the declaration of \texttt{argv}, which holds the
command-line arguments, the program looks just like you would write it
in C: pointer arithmetic (\texttt{argv++}) is used to move
\texttt{argv} to point to each argument in turn, so it can be printed.

In C, \texttt{argv} would typically be declared with type \texttt{char
  **}, a pointer to a pointer to a character, which is thought of as
an array of an array of characters.  In Cyclone, \texttt{argv} is
instead declared with type \texttt{char *@fat*@fat}, which is thought of in
the same way: it is a (fat) pointer to a (fat) pointer to characters.  The
difference between an unqualified pointer and a \texttt{@fat}\ pointer is
that a \texttt{@fat}\ pointer comes with bounds information and is thus
``fatter'' than a traditional pointer.  Each time a
fat pointer is dereferenced or its contents are assigned to,
Cyclone inserts both a null check and a bounds check.  This
guarantees that a \texttt{@fat}\ pointer can never cause a buffer
overflow.

Because of the bounds information contained in \texttt{@fat}\ pointers,
\texttt{argc} is superfluous: you can get the size of \texttt{argv} by
writing \texttt{numelts(argv)}.  We've kept \texttt{argc} as an argument
of \texttt{main} for backwards compatibility.

It's worth remarking that you can always cast a \texttt{*} pointer
to a \texttt{@fat} pointer (and vice-versa).  So, it is possible to do
pointer arithmetic on a value of type \texttt{*}, but only when you
insert the appropriate casts to convert from one pointer type to 
another.  Note that some of these casts can fail at run-time.  For
instance, if you try to cast a fat pointer that points to an empty 
sequence of characters to \texttt{char *}, then the cast will fail
since the sequence doesn't contain at least one character. 

Finally, \texttt{@fat} pointers are used so frequently in Cyclone,
that there is special character, \texttt{?} (question mark) that you 
can use as an abbreviation for \texttt{*@fat}.  For instance, we could
write the prototype for main as:
\begin{verbatim}
  int main(int argc, char ?? argv);
\end{verbatim}
instead of the more verbose:
\begin{verbatim}
  int main(int argc, char *@fat *@fat argv);
\end{verbatim}

\subsubsection*{Non-NULL Pointers}


Another kind of pointer in Cyclone is the non-NULL pointer.
A non-NULL pointer is indicated by the qualifier \texttt{@notnull}.  A
\texttt{@notnull} pointer is like an unqualified pointer, except that it is
guaranteed not to be NULL\@.  This means that when you dereference a
\texttt{@notnull} pointer or assign to its contents, a null check is
sometimes unnecessary.

\texttt{@notnull} pointers are useful in Cyclone both for efficiency and as
documentation.  This can be seen at work in the standard library,
where many functions take \texttt{@notnull} pointers as arguments, or return
\texttt{@notnull} pointers as results.  For example, the \texttt{getc}
function that reads a character from a file is declared,
\begin{verbatim}
    int getc(FILE *@notnull);
\end{verbatim}
This says that \texttt{getc} expects to be called with a non-NULL
pointer to a \texttt{FILE}\@.  Cyclone guarantees that, in fact, when
the \texttt{getc} function is entered, its argument is not \texttt{NULL}.  
This means that \texttt{getc} does not have to test whether it is 
\texttt{NULL}, or decide what to do if it is in fact \texttt{NULL}\@.

In C, the argument of \texttt{getc} is declared to have type
\texttt{FILE *}, and programmers can call \texttt{getc} with
\texttt{NULL}\@.  So for safety, C's \texttt{getc} ought to check for
\texttt{NULL}\@.  In practice, many C implementations omit the check;
\texttt{getc(NULL)} is an easy way to crash a C program.

In Cyclone, you can still call \texttt{getc} with a possibly-\texttt{NULL}
\texttt{FILE} pointer (a \texttt{FILE *}).  However, Cyclone insists
that you insert a check before the actual call:
\begin{verbatim}
    FILE *f = fopen("/etc/passwd","r");
    int c = getc((FILE *@notnull)f);
\end{verbatim}
Here \texttt{f} will be \texttt{NULL} if the file \texttt{/etc/passwd}
doesn't exist or can't be read.  So, in Cyclone \texttt{f} must be
cast to \texttt{FILE *@notnull} before the call to \texttt{getc}.  The
cast causes a null check.  If you try to call \texttt{getc} without
the cast, Cyclone will insert one for you automatically, and warn you
that it is doing so.

These warnings do not mean that your program is unsafe---after all,
Cyclone has inserted the check for you.  However, you should pay
attention to the warnings because they indicate a place where your
program could suddenly halt (if the check fails), and because the
inserted checks can slow down your program.  It's worth rewriting your
code to handle the error case better, or even eliminate the null
check.  For instance, if we rewrite the code above so that we
explicitly test whether or not \texttt{fopen} succeeds in returning a
non-\texttt{NULL} file descriptor:
\begin{verbatim}
    FILE *f = fopen("/etc/passwd","r");
    if (f == NULL) {
      fprintf(stderr,"cannot open passwd file!");
      exit(-1);
    }
    int c = getc(f);
\end{verbatim}
then Cyclone no longer issues a warning at the call to \texttt{getc}
and the resulting code does not have to do a null check.

If you call \texttt{getc} with a \texttt{FILE *@notnull}, of course, no check
is required.  For example, \texttt{stdin} is a \texttt{FILE *@notnull} in
Cyclone, so you can simply call \texttt{getc(stdin)}.  In Cyclone you
will find that many functions return \texttt{*@notnull} pointers, so many of
the pointers you deal with will already be \texttt{*@notnull} pointers, and
neither the caller nor the called function needs to do null
checks---and this is perfectly safe.

Like \texttt{@fat} pointers, \texttt{@notnull} pointers are so useful,
Cyclone provides an abbreviation.  Instead of writing \texttt{FILE
*@notnull}, you can simply write \texttt{FILE @} when you want to
write the type of a non-\texttt{NULL} pointer to a \texttt{FILE}.

\subsubsection*{Zero-Terminated Pointers}

Fat pointers support arbitrary pointer arithmetic and subscripting,
but they don't have the same representation as pointers in C.  This
is because we need extra information to determine the bounds and
ensure that a subscript or dereference is in bounds.  Unfortunately,
this change in representations can make it difficult to interface
with legacy C code where the representations might not be easily
changed.  

Fortunately, Cyclone supports one more pointer type where the
representation matches C's and yet supports a limited form of pointer
arithmetic and subscripting: the zero-terminated pointer.  A
zero-terminated pointer is a pointer to a sequence of elements that
are guaranteed to be terminated with a zero.  C's strings are a good
example.  In Cyclone, the type of C's strings can be written as
\texttt{char *@zeroterm}.  The \texttt{@zeroterm} qualifier indicates
that the pointer points to a zero-terminated sequence.  The qualifier
is orthogonal to other qualifiers, such as \texttt{@fat} or
\texttt{@notnull}, so you can freely combine them.

Because C strings arise so frequently, the types \texttt{char *},
\texttt{char *@notnull}, and \texttt{char *@fat} are by default
qualified with \texttt{@zeroterm}.  You can override the
\texttt{@zeroterm} qualifier on \texttt{char} pointers by putting in
an explicit \texttt{@nozeroterm} qualifier (e.g., \texttt{char
*@nozeroterm}).  Pointers to other types (e.g., \texttt{int *})
have a default qualifier of \texttt{@nozeroterm}.

If \texttt{x} is a \texttt{* @zeroterm} pointer, you can use pointer
arithmetic on it, as in \texttt{x+i}.  However, the compiler inserts
checks to ensure that (a) \texttt{i} is non-negative and (b) there is
no zero between \texttt{x[0]} and \texttt{x[i-1]} inclusive.  This
ensures that you can't read past the terminating zero.  In addition,
when writing to a zero-terminated pointer, the compiler inserts checks
to ensure that you don't replace the final zero with some other value.
This is crucial for ensuring that a buffer overrun cannot occur.
As in C, \texttt{x[i]} is equivalent to \texttt{x+i}, so subscripts
come with the same checks.

Because of these checks, subscripts and pointer arithmetic on
\texttt{* @zeroterm} can be fairly expensive.  In particular, if you
are not careful, you can turn what appears to be an \emph{O(n)}
algorithm into an \emph{O(n-squared)} one.  You can avoid this
overhead by casting the pointer to a \texttt{@fat} zero-terminated
pointer.  This computes the length of the sequence once and then uses
the bounds information associated with the fat pointer to do any
bounds checks.

Cyclone's constraints on zero-terminated pointers mean that you have
to be careful when porting code from C\@.  For instance, consider the
following function:
\begin{verbatim}
  void foo(char *s, int offset) {
     unsigned int len = strlen(s);
     for (unsigned int i = 0; offset+i < len; i++)
        s[offset+i] = 'a';
  }
\end{verbatim}
This code can be quite expensive when \texttt{offset} is large
because the compiler must check that there is no intervening
zero between \texttt{s[0]} and \texttt{s[offset+i]} for each
iteration of the loop.  You can get rid of this overhead by
rewriting the code as follows:
\begin{verbatim}
  void foo(char *s, int offset) {
     unsigned int len = strlen(s);
     s += offset;
     for (unsigned int i = 0; offset+i < len; i++, s++)
        *s = 'a';
  }
\end{verbatim}
Now the compiler is only checking that \texttt{*s} is not
zero when it does the increment \texttt{s++}.  In addition,
however, the compiler is checking each time you do \texttt{*s = 'a'}
that \texttt{*s} is not zero, because then you could overwrite
the zero with an \texttt{'a'} and potentially step outside
the bounds of the buffer. 

One way to get rid of all of these checks is to cast \texttt{s} to a
non-zero-terminated fat pointer before entering the loop.  When you
cast a zero-terminated pointer to a non-zero-terminated fat pointer,
the compiler calculates the length of the sequence once, decrements it
by one, and then builds an appropriate fat pointer with this bounds
information.  When you write using the fat pointer, bounds checks (not
zero checks) keep you from writing any value over the zero.
Furthermore, if you write the code in a straightforward fashion using
subscripting, the compiler is more likely to eliminate the bounds
checks.  Here is an example:
\begin{verbatim}
  void foo(char *s, int offset) {
    char *@fat @nozeroterm fat_s = (char *@fat @nozeroterm)s;
    unsigned int len; 
    fat_s += offset;
    len = numelts(fat_s);    
    for (unsigned int i = 0; i < len; i++)
      fat_s[i] = 'a';
  }
\end{verbatim}
The Cyclone compiler generates code that works like the following C code:
\begin{verbatim}
struct _tagged_arr { 
  char *base;
  char *curr;
  char *last;
};

void Cyc_foo(char *s,int offset){
  struct _tagged_arr fat_s = {s, s, s+strlen(s)};
  unsigned int len;
  fat_s.curr += offset;
  if (fat_s.curr < fat_s.base || fat_s.curr >= fat_s.last) 
    len = 0;
  else 
    len = fat_s.last - fat_s.curr;
  { unsigned int i = 0;
    for(0; i < len; i++)
      fat_s.curr[i] = 'a';
  }
}
\end{verbatim}
Notice that here, the compiler is able to eliminate all bounds
checks within the loop and still ensure safety.

\subsubsection*{Initializing Pointers}

Pointers must be initialized before they are used to ensure that unknown
bits do not get used as a pointer.  This requirement goes for
variables that have pointer type, as well for arrays, elements of arrays,
and for fields in structures.  Conversely, data that does not have pointer
type need not be initialized before it is used, since doing so cannot result
in a violation of safety.  This decision adheres to the philosophy of C, but
diverges from that of traditional type-safe languages like Java and ML.

\subsubsection*{Other features of pointers}

There's much more to Cyclone pointers than we've described here.  

In particular, a pointer type can also specify that it points to a
sequence of a particular (statically known) length using the
\texttt{@numelts} qualifier.  For instance, we can write:
\begin{verbatim}
void foo(int *@numelts(4) arr);
\end{verbatim}
Here, the parameter \texttt{arr} is a pointer to a sequence of
four integer values.  Both the non-null and nullable pointers
support explicit sequence bounds that are tracked statically.
Indeed, both pointer kinds always have length information and
when you write ``\texttt{int *}'' this is just short-hand for
``\texttt{int *@numelts(1)}''.

We explain pointers in more detail in
\hyperref[{sec:pointers}]{Section~\ref{sec:pointers}}.

\subsection{Regions}

Another potential way to crash a program or violate security is
to dereference a \emph{dangling pointer}: a pointer to storage that
has been deallocated.  These are particularly insidious bugs
because the error might not manifest itself immediately.  
For example, consider the following C code:
\begin{verbatim}
struct Point {int x; int y;};

struct Point *newPoint(int x,int y) {
  struct Point result = {x,y};
  return &result;
}

void foo(struct Point *p) {
  p->y = 1234;
  return;
}

void bar() {
  struct Point *p = newPoint(1,2);
  foo(p);
}
\end{verbatim}
The code has an obvious bug: the function \texttt{newPoint} returns a
pointer to a locally-defined variable (\texttt{result}), even though
the storage for that variable is deallocated upon exit from the
function.  That storage may be re-used (\emph{e.g.}, by a subsequent procedure
call) leading to subtle bugs or security problems.  For instance, in
the code above, after \texttt{bar} calls \texttt{newPoint}, the storage
for the point is reused to store information for the activation
record of the call to \texttt{foo}.  This includes a copy of the
pointer \texttt{p} and the return address of \texttt{foo}.  Therefore,
it may be that \texttt{p->y} actually points to the return address of
\texttt{foo}. The assignment of the integer 1234 to that location could
then result in \texttt{foo} ``returning'' to an arbitrary hunk of code
in memory.  Nevertheless, the C type-checker readily
admits the code.

In Cyclone, this code would be rejected by the type-checker to avoid
the kind of problems mentioned above.  The reason the code is rejected
is that the Cyclone compiler tracks object lifetimes and ensures that
a pointer to an object can only be dereferenced if that object 
has not been deallocated.  

Cyclone achieves this by assigning each object a symbolic
\emph{region} that corresponds to the lexical block in which the
object is declared.  Cyclone also tracks, for every pointer, what
region it points into.  The region pointed to can be written as part
of the pointer type, but usually the region can be omitted---the
compiler is smart enough to discover the region automatically in most
cases.

For example, the variable \texttt{result} in our code above lives
within a region that corresponds to the invocation of the function
\texttt{newPoint}.  We write the name of the region explicitly using a
back-quote, as in \texttt{`newPoint}.  Because \texttt{result} lives
in region \texttt{`newPoint}, the expression \texttt{\&result} is a
pointer into region \texttt{`newPoint}.  The full Cyclone type of
\texttt{\&result}, with the explicit region, is \texttt{struct Point
* @region(`newPoint)}.

When control flow exits a block, the storage (\emph{i.e.}, 
the region) for that 
block is deallocated.  Cyclone keeps track of the set of regions that
are allocated and deallocated at every control-flow point and ensures
that you only dereference pointers to allocated regions.  For example,
consider the following fragment of (bad) Cyclone code:
\begin{verbatim}
1 int f() {
2    int x = 0;
3    int *@region(`f) y = &x;
4    L:{ int a = 0;
5        y = &a;
6      }
7    return *y;
8 }
\end{verbatim}
In the function \texttt{f} above, the variables \texttt{x} and 
\texttt{y} live within the region \texttt{`f} because they are
declared in the outermost block of the function, and because
the default region name for the block of a function is
\texttt{`<function name>}.  
The storage for
those variables will live as long as the invocation of the function.
Note that since \texttt{y} is a pointer to \texttt{x}, the type of
\texttt{y} is \texttt{int *@region(`f)}, indicating that \texttt{y} 
points into region \texttt{`f}.

The variable \texttt{a} does \emph{not} live in region \texttt{`f},
because it is declared in an inner block, which we have labeled with
\texttt{L}.  The storage for the inner block \texttt{L} may be
deallocated upon exit of the block, before the function itself
returns.  To be more precise, the storage for \texttt{a} is
deallocated at line 7 in the code.  Thus, it is an error to try to
access this storage in the rest of the computation, as is done on line
7.

Cyclone detects the error because it gives the expression \texttt{\&a}
the type \texttt{int *@region(`L)}, meaning that the value is a
pointer into region \texttt{`L}.  So, the assignment \texttt{y = \&a}
fails to type-check because \texttt{y} expects to hold a pointer into
region \texttt{`f}, not region \texttt{`L}.  The restriction, compared
to C, is that a pointer's type indicates \emph{one} region instead of
\emph{all} regions.

\subsubsection*{Region Inference}

If you had to write a \texttt{@region} qualifier on every
pointer type, then writing code would be far from pleasant.
Fortunately, Cyclone provides a number of mechanisms to
cut down on the region annotations you have to write.  

First off, you can omit the \texttt{@region} qualifier keyword
and simply write the region name (e.g., \texttt{`r}) as long
as you put the region name after any other qualifiers.  For
instance, instead of writing ``\texttt{int *@notnull @region(`r)}''
we can simply write ``\texttt{int @`r}''.  In this document,
we will use an explicit \texttt{@region} qualifier, but
you'll find that the libraries and other example programs tend
to use the abbreviations.  

In addition, Cyclone often figures out the region of a pointer
without the programmer providing the information.  This is called {\em
region inference}.  For instance, we can rewrite the function
\texttt{f} above without any region annotations, and without 
labelling the blocks:
\begin{verbatim}
1 int f() {
2    int x = 0;
3    int *y = &x;
4    { int a = 0;
5      y = &a;
6    }
7    return *y;
8 }
\end{verbatim}
Cyclone can still figure out that \texttt{y} is a pointer into
region \texttt{`f}, and \texttt{\&a} is a pointer into a different
(now anonymous) region, so the code should be rejected.

As we will show below, occasionally you will need to put explicit
region annotations into the code to convince the type-checker that
something points into a particular region, or that two things point
into the same region.  In addition, it is sometimes useful to put in
the region annotations for documentation purposes, or to make type
errors a little less cryptic.

You need to understand a few more details about regions to
be an effective Cyclone programmer:  the heap region, growable
regions, region polymorphism, dynamic regions, and default region 
annotations for
function parameters.  The following sections give a brief overview
of these details.

\subsubsection*{The Heap Region}

There is a special region for the heap, written \texttt{`H}, that
holds all of the storage for top-level variables, and for data
allocated via \texttt{new} or \texttt{malloc}.  For instance, if we
write the following declarations at the top-level:
\begin{verbatim}
struct Point p = {0,1};
struct Point *ptr = &p;
\end{verbatim}
then Cyclone figures out that \texttt{ptr} points into the heap
region.  To reflect this explicitly, we can put the region in
the type of \texttt{ptr} if we like:
\begin{verbatim}
struct Point p = {0,1};
struct Point *@region(`H) ptr = &p;
\end{verbatim}

As another example, the following function heap-allocates a point and
returns it to the caller.  We put the regions in here to be explicit:
\begin{verbatim}
struct Point *@region(`H) good_newPoint(int x,int y) {
  struct Point *@region(`H) p = 
    malloc(sizeof(struct Point));
  p->x = x;
  p->y = y;
  return p;
}
\end{verbatim}
Alternatively, we can use \texttt{new} to heap-allocate and 
initialize the result:
\begin{verbatim}
struct Point *@region(`H) good_newPoint(int x,int y) {
  return new Point{x,y};
}
\end{verbatim}

\subsubsection*{Growable Regions}

Storage on the stack is implicitly allocated and recycled when you
enter and leave a block.  Storage in the heap is explicitly allocated
via \texttt{new} or \texttt{malloc}, but there is no support in
Cyclone for explicitly freeing an object in the heap.  The reason is
that Cyclone cannot accurately track the lifetimes of individual
objects within the heap, so it can't be sure whether dereferencing a
pointer into the heap would cause problems.  Instead, a conservative
garbage collector is used to reclaim the data allocated in the heap.

Using a garbage collector to recycle memory is the right thing to do
for most applications.  For instance, the Cyclone compiler uses
heap-allocated data and relies upon the collector to recycle most
objects it creates when compiling a program.  But a garbage collector
can introduce pauses in the program, and as a general purpose memory
manager, might not be as space- or time-efficient as routines tailored
to an application.

To address these applications, Cyclone provides support for \emph{growable
regions} and \emph{dynamic regions}.  A growable region is similar to the 
region associated with
a code block.  In particular, when you execute:
\begin{verbatim}
{ region<`r> h;
   ...
}
\end{verbatim}
this declares a new region \texttt{`r} along with a \emph{region handle}
\texttt{h}.  The handle can be used for dynamically allocating objects within
the region \texttt{`r}.  All of the storage for
the region is deallocated at the point of the closing brace.  
Unlike block
regions, the number (and size) of objects that you allocate into
the region is not fixed at compile time.  In this respect, growable
regions are more like the heap.  You can use the \texttt{rnew(h)} and
\texttt{rmalloc(h,...)} operations to allocate objects within a growable
region, where \texttt{h} is the handle for the region.
 
For instance, the following code takes an integer $n$, creates
a new dynamic region and allocates an array of size
$n$ within the region using \texttt{rnew}.  
\begin{verbatim}
int k(int n) {
  int result;
  { region<`r> h;
    int ?arr = rnew(h) {for i < n : i};
    result = process(h, arr);
  }
  return result;
}
\end{verbatim}
It then passes the
handle for the region and the array to some processing function.
Note that the processing function is free to allocate objects
into the region \texttt{`r} using the supplied handle.  
After processing the array, we exit the region which deallocates
the array, and then return the calculated result.

It is worth remarking that the heap is really just a growable region
with global scope, and you can use the global variable 
\texttt{Core::heap_region}
as a handle on the heap.  Indeed, \texttt{new} and \texttt{malloc(...)}
are just abbreviations for \texttt{rnew(Core::heap_region)} and
\texttt{rmalloc(Core::heap_region,...)} respectively.  

\subsubsection*{Dynamic Regions}

Block regions and growable regions allow you to create arenas that
are lexically scoped.  The lifetimes of these regions begin and end
in a last-in-first-out (LIFO) manner that follows the block structure
of the code.  They are particularly good for allocating temporary
data during a computation.  But they are not so good when we cannot
statically bound the lifetime of an object that we wish to allocate.

For example, consider an event loop where each event contains some
data that should be passed to the event handler when the event is
triggered.  And assume that the event handler wishes to deallocate
the data when it is invoked.  Since we cannot determine when (or even
if) the event handler will be invoked, we cannot statically determine
the lifetime of its associated data.

In these situations, you can use a \emph{dynamic region}.  A dynamic
region can be deallocated at (almost) any point within a program.
However, before the data within a dynamic region can be accessed
and before you can allocate new data into a dynamic region, the
region must be \emph{opened}.  When you open a dynamic region, this
checks that the region has not been deallocated, and also prevents
someone from deallocating the region as long as it is open.  In
other words, once open, you are free to access or allocate data 
within the region, but you cannot free the region.  

If you attempt to open a dynamic region that has already been freed, then
an exception will be thrown.  Dually, if you attempt to free a
dynamic region that is currently open, then an exception will be
thrown.  

A dynamic region is created as follows:
\begin{verbatim}
  let NewRegion{<`d> dh} = Core::rnew_dynregion(rh);
\end{verbatim}
where \texttt{rh} is a handle for a region \texttt{`r}, \texttt{`d} is
the name of the new dynamic region, and \texttt{dh} is the dynamic region handle.
The dynamic region handle \texttt{dh} has type \texttt{dynregion_t<`d,`r>}.
We say that it is a handle for \texttt{`d} and is contained in the
region \texttt{`r}.

To access or allocate data within a dynamic region, you must
open the region as follows:
\begin{verbatim}
  { region sh = open(dh);
    ...
  }
\end{verbatim}
In this case, the dynamic region handle \texttt{dh} is opened and we
are given a \emph{static} region handle \texttt{sh}.  The region
remains opened throughout the scope of the static region handle.
That is, the code in the curly braces (\texttt{...}) can access
the region, but outside the curly braces, the data within the
region may not be accessed.  The static region
handle \texttt{sh} can be used to allocate data within the dynamic 
region \texttt{`d}.

If the region \texttt{`d} has already been freed, then the 
\texttt{open} will fail by throwing the exception \texttt{Core::Open_Region}.

You can free a dynamic region (as long as it is not open) by 
calling the following function and passing in the dynamic
region handle:
\begin{verbatim}
  Core::free_dynregion(dh);
\end{verbatim}
If the dynamic region has already been freed or if it is currently
open, the \texttt{free_dynregion} will throw the exception
\texttt{Core::Free_Region}.

The dynamic region handle \texttt{dh} is contained in the region
\texttt{`r}.  When \texttt{`r} is deallocated, then \texttt{dh}
becomes inaccessible and thus \texttt{`d} is deallocated as well.  

\subsubsection*{Region Polymorphism}

Another key concept you need to understand is called
\emph{region polymorphism}.  This is just a fancy way of saying
that you can write functions in Cyclone that don't care which
specific region a given object lives in, as long as it's still
alive.  For example, the function \texttt{foo} from the beginning
of this section is a region-polymorphic function.  To make this
clear, let us re-write the function making the regions explicit:
\begin{verbatim}
void foo(struct Point *@region(`r) p) {
  p->y = 1234;
  return;
}
\end{verbatim}
The function is parameterized by a \emph{region variable} \texttt{`r},
and accepts a pointer to a \texttt{Point} that lives in region
\texttt{`r}.  Note that \texttt{`r} can be instantiated with any
region you like, including the heap, or a region local to a function.
So, for instance, we can write the following:
\begin{verbatim}
void g() {
  struct Point p = {0,1};
  struct Point *@region(`g) ptr1 = &p;
  struct Point *@region(`H) ptr2 = new Point{2,3};
  foo(ptr1);
  foo(ptr2);
}
\end{verbatim}
Note that in the first call to \texttt{foo}, we are passing
a pointer into region \texttt{`g}, and in the second call to 
\texttt{foo}, we are passing in a pointer into the heap.  In
the first call, \texttt{`r} is implicitly instantiated with
\texttt{`g}, and in the second call, with \texttt{`H}.  

Cyclone automatically inserts region parameters for function
arguments, so you rarely have to write them.  For instance,
\texttt{foo} can be written simply as:
\begin{verbatim}
void foo(struct Point * p) {
  p->y = 1234;
  return;
}
\end{verbatim}
As another example, if you write the following:
\begin{verbatim}
void h(struct Point * p1, struct Point * p2) {
  p1->x += p2->x;
  p2->x += p2->y;
}
\end{verbatim}
then Cyclone fills in the region parameters for you by assuming
that the points \texttt{p1} and \texttt{p2} can live in any
two regions \texttt{`r1} and \texttt{`r2}.  To make this explicit,
we would write:
\begin{verbatim}
void h(struct Point *@region(`r1) p1, 
       struct Point *@region(`r2) p2) {
  p1->x += p2->x;
  p2->x += p2->y;
}
\end{verbatim}
Now we can call \texttt{h} with pointers into any two regions,
or even two pointers into the same region.  This is because
the code is type-correct \emph{for all} regions \texttt{`r1} and \texttt{`r2}.

Occasionally, you will have to put region parameters in explicitly.
This happens when you need to assert that two pointers point into 
the same region.  Consider for instance the following function:
\begin{verbatim}
void j(struct Point * p1, struct Point * p2) {
  p1 = p2;
}
\end{verbatim}
Cyclone will reject the code because it assumes that in general,
\texttt{p1} and \texttt{p2} might point into \emph{different} regions.
That is, Cyclone fills in the missing regions as follows:
\begin{verbatim}
void j(struct Point *@region(`r1) p1, 
       struct Point *@region(`r2) p2) {
  p1 = p2;
}
\end{verbatim}
Now it is clear that the assignment does not type-check because
the types of \texttt{p1} and \texttt{p2} differ.  In other words,
\texttt{`r1} and \texttt{`r2} \emph{might} be instantiated with
different regions, in which case the code would be incorrect.
But you can make them the same by putting in the same explicit region
for each pointer.  Thus, the following code does type-check:
\begin{verbatim}
void j(struct Point *@region(`r) p1, 
       struct Point *@region(`r) p2) {
  p1 = p2;
}
\end{verbatim}

So, Cyclone assumes that each pointer argument to a function is
in a (potentially) different region unless you specify otherwise.
The reason we chose this as the default is that (a) it is often
the right choice for code, (b) it is the most general type in
the sense that if it does work out, clients will have the most
lattitude in passing arguments from different regions or the
same region to the function.  

What about the results?  Here, there is no good answer because
the region of the result of a function cannot be easily determined
without looking at the body of the function, which defeats separate
compilation of function definitions from their prototypes.  Therefore,
we have arbitrarily chosen the heap as the default region for
function results.  Consequently, the following code:
\begin{verbatim}
struct Point * good_newPoint(int x,int y) {
  return new Point{x,y};
}
\end{verbatim}
type-checks since the \texttt{new} operator returns a pointer
to the heap, and the default region for the return type is the heap.

This explains why the original bad code for allocating a new
point does not type-check:
\begin{verbatim}
struct Point *newPoint(int x,int y) {
  struct Point result = {x,y};
  return &result;
}
\end{verbatim}
The value \texttt{\&result} is a pointer into region \texttt{`newPoint}
but the result type of the function needs to be a pointer into
the heap (region \texttt{`H}).  

If you want to return a pointer that is not in the heap region,
then you need to put the region in explicitly.  For instance,
the following code:
\begin{verbatim}
int * id(int *x) {
  return x;
}
\end{verbatim}
will not type-check.  To see why, let us rewrite the
code with the default region annotations filled in.  The argument
is assumed to be in a region \texttt{`r}, and the result is assumed to be
in the heap, so the fully elaborated code is:
\begin{verbatim}
int *@region(`H) id(int *@region(`r) x) {
  return x;
}
\end{verbatim}
Now the type-error is manifest.  To fix the code, we must put in
explicit regions to connect the argument type with the result type.
For instance, we might write:
\begin{verbatim}
int *@region(`r) id(int *@region(`r) x) {
  return x;
}
\end{verbatim}
or using the abbreviation:
\begin{verbatim}
int *`r id(int *`r x) {
  return x;
}
\end{verbatim}

\subsubsection*{Region Summary}

In summary, each pointer in Cyclone points into a given region
and this region is reflected in the type of the pointer.  Cyclone
won't let you dereference a pointer into a deallocated region.
The lexical blocks declared in functions correspond to one
type of region, and simply declaring a variable within that
block allocates storage within the region.  The storage is
deallocated upon exit of the block.  Growable regions are
similar, except that a dynamic number of objects can be allocated
within the region using the region's handle.  Both block
and growable regions have structured lifetimes.  Dynamic
regions, in contrast, support arbitrary lifetimes, but
must be opened to be accessed.  Finally, the heap is a
special growable region that is garbage collected.  

Region polymorphism and region inference make it possible to omit many
region annotations on types.  Cyclone assumes that pointers passed to
functions may live in distinct regions, and assumes that result
pointers are in the heap.  These assumptions are not perfect, but (a)
programmers can fix the assumptions by providing explicit region
annotations, (b) it permits Cyclone files to be separately compiled.

The region-based type system of Cyclone is perhaps the most
complicated aspect of the language.  In large part, this is
because memory management is a difficult and tricky business.
We have attempted to make stack allocation and region polymorphic
functions simple to use without sacrificing programmer control
over the lifetimes of objects and without having to resort to
garbage collection.  

For more information about regions, see
\hyperref[{sec:regions}]{Section~\ref{sec:regions}}.

\subsection{Tagged Unions and Datatypes}

It's often necessary to write a function that accepts an argument with
more than one possible type.  For example, in
\begin{verbatim}
    printf("%d",x);
\end{verbatim}
\texttt{x} should be an integer, but in
\begin{verbatim}
    printf("%s",x);
\end{verbatim}
\texttt{x} should be a pointer to a sequence of characters.

If we call \texttt{printf("\%s",x)} with an integer \texttt{x},
instead of a pointer \texttt{x}, the program will likely crash.
To prevent this, most C compilers treat \texttt{printf} specially:
they examine the first argument and require that the remaining
arguments have the appropriate types.  However, a compiler can't check
this if \texttt{printf} isn't called with a literal format string:
\begin{verbatim}
    printf(s,x);
\end{verbatim}
where \texttt{s} is a string variable.  This means that in C, programs
that use \texttt{printf} (or \texttt{scanf}, or a number of related
functions) are vulnerable to crashes and corrupted memory.  In fact,
it's possible for someone else to crash your program by causing it to
call \texttt{printf} with arguments that don't match the format
string.  This is called a \emph{format string attack}, and it's an
increasingly common exploit.

Cyclone provides \emph{tagged unions} so that you can safely write
functions that accept an argument with more than one possible type.
Like a C \texttt{union}, a Cyclone \texttt{@tagged union} is a type that has
several possible cases.  Here's a simple example:
\begin{verbatim}
    @tagged union T {
      int Integer;
      const char *@fat String;
    };
    union T x = {.Integer = 3};
    union T y = {.String = "hello, world"};
\end{verbatim}
This declares a new tagged union type \texttt{T}, that can hold either an
integer or a string (remember, a string is a \texttt{char *@fat}\ in
Cyclone).  It also declares to \texttt{union T} values \texttt{x} and
\texttt{y} and initializes them with an integer and string respectively.

Just as with C unions, you can read and write any member of a tagged 
union.  However, to prevent security holes, Cyclone enforces the
property that you can only read the last member written.  This
prevents you from accidentally treating an integer as if it's
a string or some other kind of pointer.  

Cyclone enforces this safety property by inserting a hidden tag
into the union (hence the \texttt{@tagged} qualifier.)  
You can test the
tag by using the built-in \texttt{tagcheck} function.  For
instance, here is a function that uses the real \texttt{printf}
to safely print out the contents of a \texttt{union T} value,
regardless of its contents:
\begin{verbatim}
    bool printT(union T w) {
      if (tagcheck(w.Integer))
        printf("%d",w);
      else 
        printf("%s",w);
    }
\end{verbatim}
Note that \texttt{tagcheck(w.Integer)} does not return the
value of the \texttt{Integer} member, but rather returns true
if and only if the \texttt{Integer} member was the last member
written (and is thus safe to read.)  

Each write to a tagged union member causes the hidden tag to
be updated, and each read is preceded by a 
check to ensure that the member was the last one written.
If you attempt to read some member other than the last one
written, than the \texttt{Match}
exception is thrown.  For example, the following code writes
the \texttt{String} member and then attempts to read the
\texttt{Integer} member, so it will throw a \texttt{Match}
exception:
\begin{verbatim}
    union T a;
    int x;
    a.String = "hello, world";
    /* Next line fails */
    x = a.Integer + 3;
\end{verbatim}

When you have a big union, it can be awkward to use \texttt{tagcheck}
to test the hidden tag.  You might accidentally test the wrong
member or forget to cover a member.  In these cases, its probably
best to use \emph{pattern matching} to determine the tag and 
to extract the underlying value.  For
example, here is the function \texttt{printT} coded with
pattern matching:
\begin{verbatim}
    void printT(union T a) {
      switch (a) {
      case {.Integer = i}: printf("%d",i); return;
      case {.String = s}: printf("%s",s); return;
      }
    }
\end{verbatim}
The argument \texttt{a} has type \texttt{union T}, so it is either
an \texttt{Integer} or \texttt{String}.  Cyclone
extends switch statements with \emph{patterns} that distinguish
between the cases.  The first case,
\begin{verbatim}
   case {.Integer = i}: printf("%d",i); return;
\end{verbatim}
contains a pattern, \texttt{\{Integer = i\}}, that will match only 
\texttt{T} values where the \texttt{Integer} member was the last
one written.  The variable
\texttt{i} is bound to the underlying integer, and it can be used in
the body of the case.  For example, \texttt{printT(x)} will print 3,
since \texttt{x} holds \texttt{\{.Integer = 3\}}, and
\texttt{printT(y)} will print \texttt{hello, world}.
You can find out more about patterns in
\hyperref[{sec:patterns}]{Section~\ref{sec:patterns}}; 

Cyclone also supports untagged unions, but there are restrictions
on how they may be used to ensure safety.  In particular, you can
write any value you like into a union, but you can only read out
values that do not contain pointers.  This ensures that you don't
``spoof'' a pointer with an integer or some other bogus value.
So, the general rule is that you can use a normal C union if
you aren't using pointers, but you must use a \texttt{@tagged}
union if you are using pointers.  

Cyclone provides another alternative to tagged unions for supporting
hetrogenous values called a \emph{datatype}.  Tagged
unions require space proportional to the largest member (plus room
for the tag.)  In contrast, a datatype only requires space for the
member being used.  However, datatypes cannot be updated with a
different member and require a level of indirection. 

Here is our example type re-coded using a \texttt{datatype} declaration:
\begin{verbatim}
    datatype T {
      Integer(int);
      String(const char *@fat);
    };

    datatype T.Integer x = Integer(3);
    datatype T.String y = String("hello, world");

    void printT(datatype T@ a) {
      switch (a) {
      case &Integer(i): printf("%d",i); return;
      case &String(s): printf("%s",s); return;
      }
    }
\end{verbatim}
In general, a \texttt{datatype} declaration includes a set of
\emph{constructors} which can be used to build datatype values.
In this case, the constructors are \texttt{Integer} and \texttt{String}.
The \texttt{Integer} constructor takes an \texttt{int} and returns
a value of type \texttt{datatype T.Integer}.  The \texttt{String}
constructor takes a string and returns a \texttt{datatype T.String}
value.  

Note that the types of \texttt{x} and \texttt{y} are not 
the same so we can't interchange them, nor can we pass them
directly to the \texttt{printT} function.  In particular,
their types reveal which constructor was used to build
them.  However, we can manipulate pointers to these values
in an abstract way.  In particular, 
we can pass a pointer to a \texttt{datatype T.Integer} value
or a pointer to a \texttt{datatype T.String} value 
anywhere that expects a \texttt{datatype T}.  For instance,
we can write \texttt{printT(\&x)} to print out the integer 
value in \texttt{x}, and we can write \texttt{printT(\&y)}
to print out the \texttt{"hello, world"} string in y.

For more on datatypes, see
\hyperref[{sec:taggedunions}]{Section~\ref{sec:taggedunions}}.

\subsection{Exceptions}

So far we've glossed over what happens when you try to dereference a
null pointer, or assign to an out-of-bounds \texttt{@fat} pointer.
We've said that Cyclone inserts checks to make sure the operation is
safe, but what if the checks fail?  For safety, it would be sufficient
to halt the program and print an error message---a big improvement
over a core dump, or, worse, a program with corrupted data that keeps
running.

In fact, Cyclone does something a bit more general than halting with
an error message: it throws an \emph{exception}.  The advantage of
exceptions is that they can be \emph{caught} by the programmer, who
can then take corrective action and perhaps continue with the program.
If the exception is not caught, the program halts and prints an error
message.  Consider our earlier example:
\begin{verbatim}
    FILE *f = fopen("/etc/passwd","r");
    int c = getc((FILE @)f);
\end{verbatim}
Suppose that there is no file \texttt{/etc/passwd}; then
\texttt{fopen} will return NULL, and when \texttt{f} is cast to
\texttt{FILE *@notnull}, the implied null check will fail.  The program will
halt with an error message,
\begin{verbatim}
    Uncaught exception Null_Exception
\end{verbatim}
\texttt{Null_Exception} is one of a handful of standard exceptions
used in Cyclone.  Each exception is like a case of a \texttt{datatype}:
it can carry along some values with it.  For example, the standard
exception \texttt{InvalidArg} carries a string.  Exceptions can be
handled in \texttt{try}-\texttt{catch} statements, using pattern
matching:
\begin{verbatim}
    FILE *f = fopen("/etc/passwd","r");
    int c;
    try {
      c = getc((FILE *@notnull)f);
    }
    catch {
    case &Null_Exception:
      printf("Error: can't open /etc/passwd\n");
      exit(1);
    case &InvalidArg(s):
      printf("Error: InvalidArg(%s)\n",s);
      exit(1);
    }
\end{verbatim}
Here we've ``wrapped'' the call to \texttt{getc} in a
\texttt{try}-\texttt{catch} statement.  If \texttt{f} isn't \texttt{NULL} and
the \texttt{getc} succeeds, then execution just continues, ignoring
the \texttt{catch}.  But if \texttt{f} is NULL, then the null check
will fail and the exception \texttt{Null_Exception} will be thrown;
execution immediately continues with the \texttt{catch} (the call to
\texttt{getc} never happens).  In the \texttt{catch}, the thrown
exception is pattern matched against the cases.  Since the thrown
exception is \texttt{Null_Exception}, the first case is executed here.

There is one important difference between an exception and a case of a
\texttt{datatype}: with a \texttt{datatype}, all of the cases have to be
declared at once, while a new exception can be declared at any time.
So, exceptions are an \emph{extensible} \texttt{datatype}.  You can
specify that a datatype is extensible when you declare it, using the
\texttt{@extensible} qualifier.  For example, 
here's how to declare a new exception:
\begin{verbatim}
    @extensible datatype exn {
      My_Exception(char *@fat);
    };
\end{verbatim}
The type \texttt{@extensible datatype exn} is the type of exceptions,
and this declaration introduces a new case for the \texttt{@extensible
datatype exn} type: \texttt{My_Exception}, which carries a single
value (a string).  Exception values are created just like
\texttt{datatype} values, and are thrown with a \texttt{throw}
statement.  For example,
\begin{verbatim}
    throw new My_Exception("some kind of error");
\end{verbatim}
or
\begin{verbatim}
    throw new Null_Exception;
\end{verbatim}

In practice, ``\texttt{@extensible datatype}'' is quite a mouthful.
So, Cyclone allows you abbreviate it with just \texttt{datatype},
as long as you've declared a datatype as \texttt{@extensible} once.
So a more typical way to declare a new exception in Cyclone is
\begin{verbatim}
    datatype exn {
      My_Exception(char ?);
    };
\end{verbatim}

\subsection{Additional Features of Cyclone}

So far we've mentioned a number of advanced features of
Cyclone that provide facilities needed to avoid common bugs
or security holes in C.  
But there are many other features in Cyclone that are
aimed at making it easier to write code, ranging from convenient
expression forms, to advanced typing constructs.  For instance,
like GCC and C99, Cyclone allows you declare variables just
about anywhere, instead of at the top of a block.  As another
example, like Java, Cyclone lets you declare variables within
the initializer of a \texttt{for}-statement.  

In addition, Cyclone adds advanced typing support in the form of (a)
parametric polymorphism, (b) structural subtyping, and (c) some
unification-based, local-type inference.  These features are necessary
to type-check or port a number of (potentially) unsafe C idioms,
usually involving ``\texttt{void *}'' or the like.  Similarly,
\texttt{@tagged union} types and \texttt{datatypes} 
can be used to code around many of the uses
for C's \texttt{union} types -- another potential source of
unsoundness.  The rest of this section is a brief overview of these
added features.

\subsection{GCC and C99 Additions}

GCC and the
\href{http://web.onetelnet.ch/~twolf/tw/c/c9x_changes.html}{ISO C99
  standard} have some useful new features that we have adopted for
Cyclone. Some of the ones that we currently support are:
\begin{itemize}
\item Statement expressions: There is a new expression form,
  \texttt{(\lb} \textit{statement} \textit{expression} \texttt{\rb)}.
  The statement is executed first, then the expression, and the value
  of the entire expression is the value of the expression
\item Struct and Union expressions:  If you've declared
  \texttt{struct point\{int x; int y;\};} then you can write
  \texttt{point\{.x=\textit{expression}, .y=\textit{expression}\}}
 to allocate and initialize a struct point.  The same sort of
 constructors may be used for unions, tagged or not.
\item \texttt{//} comments as in Java or C++
\item Declarations can appear in any statement position.  It is not
  necessary to wrap braces around the declaration of a local variable.
\item For-statements can include a declaration. For instance:
\begin{verbatim}
  for (int x=0; x < n; x++) { 
    ...
  }
\end{verbatim}
\end{itemize}

We expect to follow the C99 standard fairly closely.

%%% \subsection{Pointers}
%%% There are three different pointer types in Cyclone, written
%%% ``\texttt{t*},'' ``\texttt{t@},'' and ``\texttt{t?}.''  Actually, pointers
%%% are quite a bit more complicated than this, but these are the pointer
%%% types that you'll most likely use the most.
%%%
%%% A value of type \texttt{t*} is a possibly \texttt{null} pointer to a
%%% value of type \texttt{t}.  When these values are dereferenced, a
%%% \texttt{null} check is performed and an exception is raised if the
%%% value is actually \texttt{null}. To ensure statically that a pointer
%%% cannot be \texttt{null}, you can use the type \texttt{t@} instead.
%%% Dereferencing a \texttt{@} pointer requires no run-time overhead and
%%% will not raise an exception.  Pointer arithmetic and subscripting
%%% (except for 0) are not supported for values of type \texttt{t*} or
%%% \texttt{t@} (but see below).  Both kinds of pointers are represented
%%% the same way as C pointers.
%%%
%%% In general, one can write ``\verb|t*{e}|'' to describe a pointer to an
%%% array of \texttt{t} values with \texttt{e} elements, where \texttt{e} is a
%%% constant expression.  For instance, the following code is permissible:
%%% \begin{verbatim}
%%%   int x[5] = {0,1,2,3,4};
%%%   int *{5}p = x;
%%% \end{verbatim}
%%%
%%% Here, we've said that \texttt{p} is a (possibly \texttt{null}) pointer to
%%% an array of five integers. When a pointer has type \verb|t*{e}|, then
%%% it is permissible to use subscripts in the range 0 to \texttt{e}-1 to
%%% access the elements of \texttt{p}.  Note that \texttt{t*} is short hand
%%% for \verb|t*{1}| (and similarly \texttt{t@} is short hand for
%%% \verb|t@{1}|).
%%%
%%% A value of type \texttt{t?}\ is a checked pointer to a (possibly empty)
%%% array of values of type \texttt{t}.  Unlike \texttt{*} or \texttt{@}
%%% pointers, checked pointers support arbitrary pointer arithmetic
%%% (following the rules of C), arbitrary integer subscripts, etc.
%%% However, each access is checked to ensure that the pointer is within
%%% the bounds of the original underlying array.
%%%
%%% Values of type \verb|t*{e}| or \verb|t@{e}| or \texttt{t[e]} can be cast
%%% to type \texttt{t?}\ to support pointer arithmetic.  Furthermore, values
%%% of type \texttt{t?}\ can be cast to type \verb|t*{e}| or \verb|t@{e}|,
%%% but this requires a run-time check to ensure that the corresponding
%%% array slice is in bounds.
%%%
%%% Obviously, checked pointers require more information than \texttt{*} or
%%% \texttt{@} pointers, so that we can determine whether the access is in
%%% bounds.  Consequently, checked pointers are larger than normal
%%% pointers.  (The current implementation uses three words for each
%%% checked pointer.)  However, one rarely needs checked pointers unless
%%% you're performing lots of pointer arithmetic. In subsequent releases,
%%% we hope to support checked but untagged representations for these
%%% pointers using technology from dependent type theory.
%%%
%%% Finally, we should note that in fact all pointers in Cyclone point
%%% into a region. By default, if you don't mention a region, then the
%%% pointer points into the disgtinguished heap region (written `H).
%%% Pointers to stack-allocated objects live in regions that are private
%%% to the enclosing scope. More on this later\ldots

\subsection{Tuples}

Tuples are like lightweight structs.  They need not be declared in
advance, and have member or field names that are implicitly 0, 1, 2,
3, etc.  For example, the following code declares \texttt{x} to be a
3-tuple of an integer, a character, and a boolean, initialized with
the values 42, \texttt{'z'}, and \texttt{true} respectively.  It then
checks to see whether the third component in the tuple is \texttt{true}
(it is) and if so, increments the first component in the tuple.
\begin{verbatim}
  $(int,char,bool) x = $(42,'z',true)

  if (x[2])
    x[0]++;
\end{verbatim}

The above code would be roughly equivalent to writing:
\begin{verbatim}
  struct {int f0; char f1; bool f2;} x = {42,'z',true};
  if (x.f2)
    x.f1++;
\end{verbatim}

Thus, tuple types are written \texttt{\$(type1,...,typen)}, tuple
constructor expressions are written \texttt{\$(exp1,...,expn)}, and
extracting the ith component of a tuple is written using subscript
notation \texttt{exp[i-1]}.  Note that, consistent with the rest of C,
the members start with 0, not 1.

Unlike structs, tuple types are treated equivalent as long as they are
structurally equivalent.  As in C, struct types are equivalent only if
they have the same tag or name.  (Note that in C, all struct
declarations have a tag, even if the compiler has to gensym one.)


\subsection{Creating Arrays}

There are about four ways to create arrays in Cyclone. One can always
declare an array and provide an initializer as in C\@. For instance:
\begin{verbatim}
  int foo[8] = {1,2,3,4,5,6,7,8};
  char s[4] = "bar";
\end{verbatim}
are both examples from C for creating arrays.  Note that Cyclone
follows C's conventions here, so that if you declare arrays as above
within a function, then the lifetime of the array coincides with the
activation record of the enclosing scope.  In other words, such arrays
will be stack allocated.

To create heap-allocated arrays (or strings) within a Cyclone
function, you should either use ``\texttt{new}'' operator with either an
array initializer or an array comprehension. The following code
demonstrates this:
\begin{verbatim}
  // foo is a pointer to a heap-allocated array
  int *{8}foo = new {1,2,3,4,5,6,7,8};

  // s is a checked pointer to a heap-allocated string
  char ?s = new "bar";

  // a non-null pointer to the first 100 even numbers
  int @{100}evens = new {for i < 100 : 2*i};
\end{verbatim}

\subsection{Subtyping}
Cyclone supports ``extension on the right'' and ``covariant depth on
\texttt{const}'' subtyping for pointers.  This simply means that you
can cast a value \texttt{x} from having a type ``pointer to a struct
with 10 fields,'' to ``pointer to a struct having only the first 5
fields.''  For example, if we have the following definitions:
\begin{verbatim}
  typedef struct Point {float x,y;} *point;

  typedef struct CPoint {float x,y; int color;} *cpoint;

  float xcoord(point p) {
    return p->x;
  }
\end{verbatim}
then you can call \texttt{xcoord} with either a \texttt{point} or
\texttt{cpoint} object.  You can also cast a pointer to a tuple having 3
fields (e.g., \texttt{\$(int,bool,double)*}) to a pointer to a tuple
having only 2 fields (e.g., \texttt{\$(int,bool)*}).  In other words, you
can forget about the ``tail'' of the object.  This allows a degree of
polymorphism that is useful when porting C code.  In addition, you can
do ``deep'' casts on pointer fields that are \texttt{const}.  (It is
unsafe to allow deep casts on non-const fields.)  Also, you can cast
a field from being non-const to being const.  You can also cast a
constant-sized array to an equivalent pointer to a struct or tuple.
In short, Cyclone attempts to allow you to cast one type to another as
long as it is safe.  Note, however, that these casts must be explicit.

We expect to add more support for subtyping in the future (e.g.,
subtyping on function pointers, bounded subtyping, etc.)


%%% \subsection{Tagged Unions}
%%% 
%%% Cyclone's tagged unions (\texttt{datatype}) are based on the algebraic
%%% datatypes that first appeared in functional languages such as Hope,
%%% Miranda, ML, and Haskell.  They provide a safe way for building data
%%% structures that contain possibly many different types and can be used
%%% to build algebraic or inductively defined structures, such as lists,
%%% trees, graphs, etc.  For instance, the following datatype declarations
%%% give a way to construct abstract syntax trees for a simple calculator
%%% language:
%%% \begin{verbatim}
%%%   datatype operator { Plus, Times, Minus, Divide }
%%%   datatype absyn {
%%%     Integer(int);
%%%     Term(datatype absyn, datatype operator, datatype absyn);
%%%   }
%%%   datatype absyn e1 = new Term(new Integer(3),Plus,new Integer(4));
%%%   datatype absyn e2 = new Term(e1,Times,new Integer(5));
%%% \end{verbatim}
%%% 
%%% The operator definition is like an enum---it just defines symbolic
%%% constants for \texttt{Plus}, \texttt{Times}, \texttt{Minus}, and
%%% \texttt{Divide}.  The \texttt{absyn} definition defines an inductive
%%% tree-like data type for abstract syntax.  The \texttt{Integer}
%%% constructor takes an \texttt{int} argument and returns an \texttt{absyn}
%%% value.  The \texttt{Term} constructor takes an abstract syntax tree, an
%%% operator, and an abstract syntax tree and returns a new abstract
%%% syntax tree.  So, for example, \texttt{e1} is a tree representing the
%%% term ``3 + 4'' while \texttt{e2} is a tree representing the term ``(3 +
%%% 4) * 5.''
%%% 
%%% Internally, \texttt{datatype} constructors are either represented as an
%%% integer value (as with \texttt{Plus}, \texttt{Times}, \texttt{Minus}, and
%%% \texttt{Divide}) or a pointer to an object containing a tag and the
%%% arguments to the constructor.  The object is always allocated on the
%%% heap.  To traverse the tree, we use pattern matching, again in the
%%% style of functional languages such as ML or Haskell.
%%% 
%%% In the future, we plan to make the representation of datatypes explicit
%%% and to allow programmers to control tag placement and do explicit
%%% tests on the tag to refine the type of an object in a more
%%% traditional, data-flow fashion.  We will probably keep the datatype
%%% construct as is for convenience.

%%% \subsection{Pattern Matching}
%%% Pattern matching in Cyclone generalizes the switch construct of C
%%% allowing you to not only test integral values, but also to test
%%% structured values such as the abstract syntax trees above.  For
%%% example, the following function takes in an abstract syntax tree and
%%% prints the tree to stdout:
%%% \begin{verbatim}
%%%   void print_absyn(datatype absyn tree) {
%%%      switch (tree) {
%%%      case &Integer(i)       : printf("%d",i); break;
%%%      case &Term(t1,Plus,t2) : printf("("; print_absyn(t1);
%%%                               printf("+");
%%%                               print_absyn(t2); printf(")"); break;
%%%      case &Term(t1,Times,t2): printf("("; print_absyn(t1);
%%%                               printf("*");
%%%                               print_absyn(t2); printf(")"); break;
%%%      case &Term(t1,Minus,t2): printf("("; print_absyn(t1);
%%%                               printf("-");
%%%                               print_absyn(t2); printf(")"); break;
%%%      case &Term(t1,Divide,t2):printf("("; print_absyn(t1);
%%%                               printf("/");
%%%                               print_absyn(t2); printf(")"); break;
%%%   }
%%% \end{verbatim}
%%% 
%%% Note that patterns introduce and initialize new variables local to a
%%% given case.  For instance, in the \texttt{Integer} case above, the
%%% pattern variable \texttt{i} is introduced and is initialized to whatever
%%% value is carried by the Integer constructor.  Thus, \texttt{i} is
%%% available for use on the right-hand-side of the case.  You can pattern
%%% match on just about any kind of value, and destructure it.  For
%%% instance, you can pattern match on tuples, structs, pointers to
%%% tuples/structs, etc.  See the grammar for the syntax of the various
%%% pattern forms.
%%% 
%%% The type-checker for Cyclone is much more picky about switch
%%% statements than C\@.  In particular, it will check that all of the
%%% patterns you have are exhaustive (or else there's a \texttt{default:}
%%% clause) and that none of the patterns overlap.  This is useful for
%%% evolving code.  For instance, if we added a new operator (say
%%% \texttt{Mod}), then the compiler would complain that the \texttt{switch}
%%% in \texttt{print_absyn} doesn't cover all possible cases (namely the
%%% case where we have a term involving the \texttt{Mod} operator.)
%%% 
%%% In addition, the Cyclone type-checker makes sure that you don't
%%% accidentally fall-through from one case to another.  In particular, if
%%% you don't put in explicit breaks, returns, throws, etc., then the
%%% compiler will reject the code.  You can still fall through to the next
%%% case, but you have to do it with an explicit ``\texttt{fallthru}''
%%% statement.  If the case pattern doesn't bind any new variables, then
%%% you just write ``\texttt{fallthru;}'' as the last thing in the case.  If
%%% you want to fall through to a case that defines new variables, then
%%% you need to give values for those variables.  For instance, in the
%%% following code:
%%% \begin{verbatim}
%%%   void foo(datatype absyn tree) {
%%%      switch (tree) {
%%%      case &Integer(i)       : printf("%d ",i); break;
%%%      case &Term(t1,Plus,t2) : printf("It's a plus \n");
%%%                               fallthru(t2,Plus,t1);
%%%      case &Term(t1,op,t2)   : foo(t1); foo(t2); break;
%%%   }
%%% \end{verbatim}
%%% if we pass it a tree \texttt{Term(Integer(3),Plus,Integer(4))} then we
%%% will see ``It's a plus 4 3,'' but if we pass it
%%% \texttt{Term(Integer(3),Times,Integer(4))} we will see ``3 4.''

\subsection{Let Declarations}

Sometimes, it's painful to declare a variable because you have to
write down its type, and Cyclone types can be big when compared
to their C counterparts since they may include bounds information,
regions, \emph{etc}.  Therefore, Cyclone includes additional support for type
inference using let declarations.  In particular, you can write:
\begin{verbatim}
  int foo(int x) {
    let y = x+3;
    let z = 3.14159;
    return (int)(y*z);
  }
\end{verbatim}

Here, we declared two variables y and z using ``\texttt{let}.''  When
you use \texttt{let}, you don't have to write down the type of the
variable.  Rather, the compiler infers the type from the expression
that initializes the variable.  More generally, you can write
``\texttt{let pattern = exp;}'' to destructure a value into a bunch of
variables.  For instance, if you pass a tuple to a function, then you
can extract the components as follows:
\begin{verbatim}
  int sum($(int,int,int) args) {
    let $(x,y,z) = args;
    return (x+y+z);
  }
\end{verbatim}

\subsection{Polymorphic Functions}
As mentioned above, Cyclone supports a limited amount of subtyping
polymorphism.  It also supports a fairly powerful form of parametric
polymorphism.  Those of you coming from ML or Haskell will find this
familiar.  Those of you coming from C++ will also find it somewhat
familiar.  The basic idea is that you can write one function that
abstracts the types of some of the values it manipulates.  For
instance, consider the following two functions:
\begin{verbatim}
  $(char*,int) swap1($(int,char*) x) {
     return $(x[1], x[0]);
  }
  $(int,int) swap2($(int,int) x) {
     return $(x[1], x[0]);
  }
\end{verbatim}

The two functions are quite similar: They both take in a pair (i.e., a
2-tuple) and return a pair with the components swapped.  At the
machine-level, the code for these two functions will be exactly the
same, assuming that \texttt{int}s and \texttt{char *}s are
represented the same way.  So it seems silly to write the code twice.
Normally, a C programmer would replace the definition with simply:
\begin{verbatim}
  $(void *,void *) swap1($(void *,void *) x) {
     return $(x[1], x[0]);
  }
\end{verbatim}
(assuming you added tuples to C).  But of course, this isn't type-safe
because once I cast the values to \texttt{void *}, then I can't be sure
what type I'm getting out.  In Cyclone, you can instead write
something like this:
\begin{verbatim}
  $(`b,`a) swap($(`a,`b) x) {
     return $(x[1],x[0]);
  }
\end{verbatim}
The code is the same, but it abstracts what the types are.  The types
\texttt{`a} and \texttt{`b} are type variables that can be instantiated
with any word-sized, general-purpose register type.  So, for instance,
you can call swap on pairs of integers, pairs of pointers, pairs of an
integer and a pointer, etc.:
\begin{verbatim}
  let $(x,y) = swap($("hello",3));  // x is 3, y is hello
  let $(w,z) = swap($(4,3));        // w is 3, z is 4
\end{verbatim}

Note that when calling a polymorphic function, you need not tell it
what types you're using to instantiate the type variables.  Rather,
Cyclone figures this out through unification.

C++ supports similar functionality with templates.  However, C++ and
Cyclone differ considerably in their implementation strategies.
First, Cyclone only produces one copy of the code, whereas a C++
template is specialized and duplicated at each type that it is used.
This approach requires that you include definitions of templates in
interfaces and thus defeats separate compilation.  However, the
approach used by Cyclone does have its drawbacks: in particular, the
only types that can instantiate type variables are those that can be
treated uniformly.  This ensures that we can use the same code for
different types.  The general rule is that values of the types that
instantiate a type variable must fit into a machine word and must be
passed in general-purpose (as opposed to floating-point) registers.
Examples of such types include \texttt{int}, pointers, \texttt{datatype},
and \texttt{xdatatype} types.  Other types, including \texttt{char},
\texttt{short}, \texttt{long long}, \texttt{float}, \texttt{double},
\texttt{struct}, and \texttt{tuple} types violate this rule and thus
values of these types cannot be passed to a function like swap in
place of the type variables. In practice, this means that you tend to
manipulate a lot of pointers in Cyclone code.

The combination of parametric polymorphism and sub-typing means that
you can cover a lot of C idioms where \texttt{void*} or unsafe casts
were used without sacrificing type-safety.  We use polymorphism a lot
when coding in Cyclone.  For instance, the standard library includes
many container abstractions (lists, sets, queues, etc.) that are all
polymorphic in the element type.  This allows us to re-use a lot of
code.  In addition, unlike C++, those libraries can be compiled once
and need not be specialized.  On the downside, this style of
polymorphism does not allow you to do any type-specific things (e.g.,
overloading or ad-hoc polymorphism.)  Someday, we may add support for
this, but in the short run, we're happy not to have it.


\subsection{Polymorphic Data Structures}
Just as function definitions can be parameterized by types, so can
\texttt{struct} definitions, \texttt{datatype} definitions, and even
\texttt{typedef}s.  For instance, the following \texttt{struct} definition
is similar to the one used in the standard library for lists:
\begin{verbatim}
  struct List<`a> {`a hd; struct List<`a> * tl; };
  typedef struct List<`a> *list_t<`a>;
\end{verbatim}

Here, we've declared a \texttt{struct List} parameterized by a type
\texttt{`a}.  The \texttt{hd} field contains an element of type \texttt{`a}
and the \texttt{tl} field contains a possibly-null pointer to a
\texttt{struct List} with elements of type \texttt{`a}.  We then define
\texttt{list_t<`a>} as an abbreviation for \texttt{struct List<`a>*}.  So,
for instance, we can declare both integer and string lists like this:
\begin{verbatim}
  list_t<int> ilist = new List{1,new List{2,null}};
  list_t<string_t> slist = new List{.hd = "foo",
                                  .tl = new List{"bar",null}};
\end{verbatim}

Note that we use ``\texttt{new}'' as in C++ to allocate a new
\texttt{struct List} on the heap and return a pointer to the resulting
(initialized) \texttt{List} object.  Note also that the field designator
(``\texttt{.hd}'', ``\texttt{.tl}'') are optional.

Once you have polymorphic data structures, you can write lots of
useful polymorphic code and use it over and over again.  For instance,
the standard list library (see lib/list.h) includes functions for
mapping over a list, looking up items in a list, concatenating two
lists, copying lists, sorting lists, etc.

\subsection{Abstract and Existential Types}
Suppose you want to declare an abstract type for implementing stacks.
In Cyclone, the way this is accomplished is by declaring a struct that
encapsulates the implementation type, and by adding the
``\texttt{abstract}'' qualifier to the struct definition.  For instance,
if we write:
\begin{verbatim}
  abstract struct Queue<`a> { list_t<`a> front, rear; };
\end{verbatim}
then this declares a polymorphic \texttt{Queue} implementation that is
abstract.  The definition of the struct is available within the unit
that declares the Queue, but will not be made available to the outside
world.  (This will be enforced by a link-time type-checker that we
are currently putting together.)  Typically, the provider of the
\texttt{Queue} abstraction would write in an interface file:
\begin{verbatim}
  extern struct Queue<`a>;
\end{verbatim}
The abstract keyword in the implementation ensures that the definition
does not leak to a client.  
% One can also declare \texttt{datatype}s to be
% abstract, though I find it more useful to always use a \texttt{struct}
% to encapsulate the datatype, and make the \texttt{datatype} static, and the
% struct \texttt{abstract}.  That way, clients are always given an
% abstract struct to manipulate.

\texttt{Typedef}s can be made abstract by writing:
\begin{verbatim}
typedef _ foo_t;
\end{verbatim}
However, our current implementation does not support later redefining
\texttt{foo_t} as a non-abstract typedef.  The default kind for the
type is B; you can write an explicit kind like this:
\begin{verbatim}
typedef _::A bar_t;
\end{verbatim}
Generally abstract structs are sufficient.  An abstract typedef is
useful in some cases, though, such as when the abstracted type is
actually \texttt{int}.

It's also possible to code up ``first-class'' abstract data types
using \texttt{struct}s with \emph{existentially quantified type
  variables}.  Existential types are described in
\hyperref[{sec:advanced}]{Section~\ref{sec:advanced}}.

% In particular, pattern matching one of these constructors
% requires you to introduce explicit type variables into which the
% actual types are ``unpacked.''  
% These variables are treated abstractly
% in the body of a case.  However, when creating one of the values, it
% is not necessary to explicitly ``pack'' the types to be abstracted.
% Rather, the types are discovered through unification.  
For an example of the use of existential types, see the \texttt{fn.h}
and \texttt{fn.cyc} files in the standard library, which implement
first-class closures.

\subsection{Restrictions}

Though Cyclone adds many new features to C, there are also a number
of restrictions that it must enforce to ensure code does not crash.
Here is a list of the major restrictions:
\begin{itemize}
\item Cyclone does not permit some of the casts that are allowed in C because
  incorrect casts can lead to crashes, and it is not always possible
  for us to determine what is safe.  In general, you should be
  able to cast something from one type to another as long as the
  underlying representations are compatible.  Note that Cyclone is
  very conservative about ``compatible'' because it does not know
  the size or alignment constraints of your C compiler.  

\item Cyclone does not support pointer arithmetic on thin
  pointers unless they are zero-terminated and even then,
  there are checks to make sure you can't go past a zero.  Pointer 
  arithmetic is not unsafe in itself, but
  it can lead to unsafe code when the resulting pointer is assigned or
  dereferenced.  You can cast the thin pointer value to a
  \texttt{@fat} value and then do the pointer arithmetic instead.

\item Cyclone inserts a NULL check when a possibly-NULL pointer is
  dereferenced and it cannot determine statically that the pointer is
  not NULL\@.

\item If a function's return type is not ``bits-only'' (i.e., contains
  pointers), Cyclone requires that the function 
  executes a return statement, throws an
  exception, or calls a \texttt{noreturn} function on every possible 
  execution path. This is needed to
  ensure that the value returned from the function has the right type,
  and is not just a random value left in a register or on the stack.

\item Untagged unions in Cyclone can hold arbitrary values, but you
  can only read out ``bits.''  In particular, the members you can
  read out can only have combinations of chars, ints, shorts, longs, floats,
  doubles, structs of bits, or tuples of bits. Pointer types are not
  supported.  This avoids the situation where an arbitrary bit pattern
  is cast to a pointer and then dereferenced. If you want to use
  multiple types, then use \texttt{@tagged union}s or \texttt{datatype}s.

\item Cyclone only supports limited forms of \texttt{malloc} (and
  \texttt{calloc}).  You must write \texttt{malloc(sizeof(t)*n)}
  and \texttt{t} must be a ``bits-only'' type.  
  You can use \texttt{calloc} to allocate arrays of (possibly NULL)
  pointers (e.g., \texttt{calloc(sizeof(char*),34)}).  

\item Cyclone performs a static analysis to ensure that every
  non-numeric (i.e., pointer) variable
  and \texttt{struct} field is initialized before it is used. This
  prevents a random stack value from being used improperly. The
  analysis is somewhat conservative so you may need to initialize
  things earlier than you would do in C\@.  There is only limited
  support for initializing memory in a procedure separate from the one
  that does the allocation.

\item Cyclone does not permit \texttt{goto}s from one scope into
  another. C warns against this practice, as it can cause crashes;
  Cyclone rules it out entirely.

\item Cyclone places some limitations on the form of switch statements
  that rule out crashes like those caused by unrestricted
  \texttt{goto}.  Furthermore, Cyclone prevents you from accidentally
  falling through from one case to another. To fall through, you must
  explicitly use the \texttt{fallthru} keyword.  Otherwise, you must
  explicitly \texttt{break}, \texttt{goto}, \texttt{continue},
  \texttt{return}, or \texttt{throw} an exception.  However, adjacent
  cases for a switch statement (with no intervening statement) do
  not require an explicit \texttt{fallthru}.

\item In the near future, Cyclone will place some restrictions on
  linking for safety reasons. In particular, if you import a variable
  or function with one type, then it must be exported by another file
  with that type. In addition, access to C code will be restricted
  based on a notion of security roles.

\item Cyclone has some new keywords (beyond those of C99 and GCC)
  that can no longer be used as identifiers.  The list includes:
  \texttt{abstract}, \texttt{alias}, \texttt{calloc}, \texttt{datatype},
  \texttt{dynregion_t}, \texttt{export}, \texttt{fallthru}, 
  \texttt{__gen}, \texttt{let}, \texttt{malloc}, \texttt{namespace},
  \texttt{numelts}, \texttt{__cyclone_port_on__}, 
  \texttt{__cyclone_port_off__}, \texttt{region}, \texttt{regions},
  \texttt{reset_region}, \texttt{rmalloc}, \texttt{rnew}, \texttt{tagcheck},
  \texttt{tag_t}, \texttt{throw}, \texttt{try}, \texttt{using},
  \texttt{valueof}, and \texttt{valueof_t}.

\item Cyclone prevents you from using pointers to stack-allocated
  objects as freely as in C to avoid security holes. The reason is
  that each declaration block is placed in a conceptual ``region'' and
  the type system tracks the region into which a pointer points.

\item Cyclone does not allow you to explicitly free a heap-allocated
  object. Instead, you can either use the region mechanism or rely
  upon the conservative garbage collector to reclaim the space.

\end{itemize}

In addition, there are a number of shortcomings of the current
implementation that we hope to correct in the near future.  For
instance:
\begin{itemize}
\item Cyclone currently does not support nested type declarations
  within a function. All \texttt{struct}, \texttt{union}, \texttt{enum},
  \texttt{datatype}, and \texttt{typedef} definitions must
  be at the top-level.

\item Cyclone does not allow a typedef declaration to be shadowed by
another declaration.
\end{itemize}


% Local Variables:
% TeX-master: "main-screen"
% End:
