<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<title>Cyclone Version 1</title>
</head>

<body>

<h1 align="center"><img border="0" src="cyclone.gif" width="50" height="46">Cyclone Version 1.0 User's Guide</h1>
<h2 align="center">Greg Morrisett</h2>
<h2 align="center">Cornell University</h2>
<p align="center">November, 2000</p>
<hr>
<h2 align="left">Table of Contents</h2>
<p align="left"><a href="#Goals of the Cyclone Project">Goals of the Cyclone
Project<br>
</a><a href="#Installing Cyclone">Installing Cyclone<br>
</a><a href="#Using Cyclone">Using Cyclone<br>
</a>&nbsp;&nbsp;&nbsp; <a href="#Hello World">Hello World<br>
</a><a href="#Quick Guide to Cyclone">Quick Overview<br>
</a>&nbsp;&nbsp;&nbsp; <a href="#Features Added">Features added<br>
</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#GCC and C-9X Additions:&nbsp;">GCC and C-9X
    features</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <a href="#Namespaces">Namespaces</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <a href="#Tuples">Tuples</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <a href="#Non-null Pointers:">Non-Null Pointers</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <a href="#Exceptions">Exceptions</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <a href="#Variable Sized Arrays">Variable-Sized Arrays</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <a href="#Subtyping">Subtyping and Coercions</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <a href="#Datatype Enums:">Datatype Enums</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <a href="#Pattern Matching:">Pattern Matching</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <a href="#Let Declarations:">Let Declarations</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <a href="#Extensible Enums (xenums):">Extensible Enums</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <a href="#Polymorphic Functions:">Polymorphic Functions</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <a href="#Polymorphic Data Structures:">Polymorphic Data Structures</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <a href="#Abstract and Existential Types:">Abstract and Existential Types<br>
</a>&nbsp;&nbsp;&nbsp; <a href="#Restrictions">Restrictions<br>
</a><a href="#The Grammar of Cyclone">Annotated Grammar<br>
</a>The Standard Library</p>
<hr>
<h2><a name="Goals of the Cyclone Project">
    Goals of the Cyclone Project</a>
</h2>
<p>
Cyclone is intended to be a type-safe variant of C.&nbsp; The primary goals
of Cyclone are to:
</p>
<ol>
  <li><b>Be type safe</b> --- at a minimum, this should include support for
    memory safety, and ideally, much more.&nbsp; As with languages such as 
    ML or Java, modern typing features such as polymorphism, subtyping, 
    abstract data types, etc. should all be supported so that programs may 
    be easily assembled and debugged.&nbsp; Ideally, the type system should 
    support static detection and elimination of as many errors as possible, 
    falling back on dynamic checks only when necessary.</li>

  <li><b>Support as much of C as possible</b> --- Cyclone should share as much
    with C as possible, including syntax, static semantics, data
    representations, calling conventions, and dynamic semantics.&nbsp; 
    This rule should only be violated when in direct conflict with the 
    first goal of supporting type safety.</li>
</ol>

<p>
The intended user of Cyclone is someone who is either (a) writing systems
code, or (b) needs to port C code to a safe environment.&nbsp; Though languages
such as Java, ML, or Scheme are safe, they do not give the control over data
representations, calling conventions, etc. that C does.&nbsp; Hence, they are
often unsuitable for building systems where performance and control
matter.&nbsp; For instance, no one suggests building a run-time system
in these languages.  
Furthermore, today's implementations of 
these languages make it relatively difficult to
interface with legacy code written in C or to incrementally move program units
from C to the safe setting.&nbsp; The goals of Cyclone are aimed at making it
easier to build systems software without sacrificing safety or
control.&nbsp;&nbsp;
</p>

<p>
Of course, the two goals above are in direct conflict and thus we also see
Cyclone as a driver for new research into safe, low-level languages.&nbsp; For
instance, right now, all heap-allocated memory is reclaimed via (conservative)
garbage collection.&nbsp; This is type safe, but prevents systems programmers
from using Cyclone for latency-critical or space-sensitive applications.&nbsp;
One of the big research goals of Cyclone is to introduce new typing
abstractions, such as linear types or regions, that support programmer control
over memory management without sacrificing safety.
</p>

<p>
You might wonder what is the difference between the Cyclone project
and a few other projects, notably 
<a href="http://lclint.cs.virginia.edu">LCLint</a> out of MIT and Virginia, 
the Extended Static
Checking (ESC) project out of Compaq SRC, and the 
<a href="http://www.cs.wisc.edu/~austin/scc.html">Safe-C</a> project
from the University of Wisconsin.    
These are good systems and we have great respect for the
work that has gone into them.  But their goals are quite different
from Cyclone and we view our work as somewhat overlapping, but
mostly complimentary.  
</p>
<p>
Though we are interested
in finding and eliminating bugs, we also want to guarantee a certain
level of safety.  LCLint can't provide such a guarantee, because 
the underlying language (C) and associated static analyses are
unsound (i.e., some bugs will not be caught).  The reason for this
is that without changing C, it is extremely difficult to guarantee
even memory safety, much less a stronger type safety property,
without a lot of extra runtime overhead, or a lot of false positives
in your static analysis.  LCLint is aimed at being a practical tool
for debugging C code, and as such, makes certain compromises to eliminate
false positives, but at the expense of soundness.  Thus, LCLint can't
be used in settings where security is a concern.
</p>
<p>
ESC is similar in some ways to LCLint, but is built on top of Java.
(A previous version was built on top of Modula-3).
Since Java and Modula-3 are type-safe, there is a fundamental safety
guarantee provided by the ESC system.  And in addition, one gets
the extra (really amazing) bug-finding power of ESC.  However,
as we argued above, many systems programming tasks cannot be
coded in languages such as Java (or Modula-3) or at least can't
be coded efficiently.  
</p>
<p>
Consequently, we see the ESC and LCLint projects as complimentary
to the Cyclone project.  Ideally, after Cyclone reaches a stable
design point, we should be able to put an "ESC/Cyclone" or "LCLint/Cyclone"
static debugging tool together.
</p>
<p>
The Safe-C project out of Wisconsin is perhaps the closest in
spirit to ours, in that they are attempting to provide a memory-safety
guarantee.  However, the approach taken by Safe-C is quite different
than Cyclone:  Programs continue to be written in C, but extra indirections
and dynamic checks are inserted to ensure that abstractions are
respected.  For example, pointers in Safe-C are actually rather
complex data structures, and dereferencing a pointer is an expensive
operation as a number of checks must be done to ensure that the
pointer is still valid.  In order to avoid some of these overheads,
the Wisconsin folks apply sophisticated, automatic analyses.  
</p>
<p>
The advantage of Safe-C is that, in principle, programs can be
compiled and run with no modification by the programmer.  The
disadvantages are that (a) there is still a great deal of space and
time overhead for programs, (b) the data representations change
radically.  As such, the whole system (e.g., the standard libraries)
has to be recompiled and pieces of code cannot be migrated from C to
Safe-C.  In contrast, Cyclone goes to great lengths to preserve
the data representations so that Cyclone and C code can smoothly
interoperate.  Furthermore, many more checks are performed statically
in Cyclone.  The downside is that programmers have to change the
code (typically, by modifying or adding more typing information),
and they can't always write what they want.  Our research is aimed
at eliminating these drawbacks and to compare against the Safe-C
approach.
</p>

<p>
Obviously, Cyclone is a work in progress.  The people involved now
are at Cornell and AT&amp;T.&nbsp;
In particular, Trevor Jim and I have worked out most of the initial
design and implementation.&nbsp; Dan Grossman is working on version
2.0 of the system which should add support for a number of other
features and clean up the type-checker considerably.&nbsp; Fred Smith,
Dave Walker, and Stephanie Weirich have contributed greatly through
discussions, if not code.&nbsp; Jeff Vinocur, Nathan Lutchansky,
Matthew Harris, Kate Oliver, and Hubert Chao have also made many 
valuable contributions.  Many of the ideas contained within
Cyclone are derived from our previous experience and work on the
Popcorn safe-C language and the Typed Assembly Language
project.&nbsp;&nbsp;
</p>
<hr>
<h2><a name="Installing Cyclone">Installing Cyclone</a></h2>
<p>
Cyclone currently only runs on 32-bit machines, and has only been tested on
Win32 and Linux platforms.&nbsp; Other platforms might or might not work.&nbsp;
There are definitely 32-bit dependencies, so the system will not work on a
64-bit machine without major surgery.&nbsp; To install and use Cyclone, you'll
need to use the Gnu utilities, including GCC (the Gnu C compiler) and
Gnu-Make.&nbsp; For Win32, you should first install the latest version of the 
<a href="http://cygwin.com/">Cygwin</a>
utilities to do the build, and make sure that the Cygwin bin directory is on
your path.
</p>

<p>
The file cyclone.zip (or cyclone.tar.gz) contains all of the files that you
need to build and install the system.&nbsp; After unzipping the file into a
directory, you should have a directory structure that looks like this:
</p>
<pre>
cyclone/
     bin/
        genfiles/
             lib/
             src/
     doc/
     gc/
     lib/
     src/
     tests/
     tools/
         cycbison/
         cyclex/
</pre>
<p>
There is a Makefile at the top-level.&nbsp; To build the system, change into
the Cyclone directory, and then type &quot;make&quot;.&nbsp; This should 
produce files cycbison.exe, cyclex.exe, cyclib.a, cyclone.exe, and 
gc.a appropriate for your architecture, and place them in the bin/ directory.&nbsp; (<i>Note:&nbsp; someone should get rid of the silly &quot;.exe&quot;'s 
for Unix platforms.)</i>&nbsp; The cyclone executable is the compiler which 
translates Cyclone code into GCC code.&nbsp; The cycbison executable is a 
version of Gnu's Bison parser generator which emits Cyclone code for 
parsing.&nbsp; The cyclex executable is a version of the Ocaml lexer 
generator which emits Cyclone code for lexing.&nbsp; The gc.a
library is the Boehm-Demers-Weiser garbage collector.&nbsp; And cyclib.a is a
library of pre-built Cyclone functions.&nbsp; After building the system, 
you may want to add the bin/ directory to your path (and possibly the lib 
directory to your include path.)
</p>

<p>The cycbison utility is written in C (soon to be ported to Cyclone) and its
source is in the tools/cycbison/ sub-directory.&nbsp; The BDW garbage collector
is also written in C and can be found in the gc/ directory (this was obtained
directly from<a href="http://www.hpl.hp.com/personal/Hans_Boehm/gc/"> Hans Boehm's GC page</a>.)&nbsp;
The rest of the code is written in Cyclone.&nbsp; However, the directory bin/genfiles
contains the C code that the Cyclone compiler produces when run on itself.&nbsp;
This is what allows you to build the initial executable.&nbsp;&nbsp;</p>
<p>Once you've built the compiler from the C courses, you can use it to compile
the Cyclone code in lib/, src/, tests/, or tools/cyclex.&nbsp; To do so, simply
type &quot;make cyclone_src&quot;.&nbsp; This will use the Cyclone compiler to
compile all of the files in these directories and place the resulting
executables in the appropriate directory.&nbsp; (It will <i>not</i> overwrite
the binaries in the bin/ directory.)&nbsp; If you want to make a change to the
compiler and then start using the change, you can type &quot;make update&quot;
which will update the genfiles/ with any different C files that you
generated.&nbsp; Then you can type &quot;make cyclone&quot; to bootstrap with
the new code.</p>
<hr>
<h2><a name="Using Cyclone">Using Cyclone</a></h2>
<p>Once you've successfully installed Cyclone, you can use it to compile Cyclone
programs to C, and then use GCC to compile the resulting code to machine
code.&nbsp; Typically, if one wants to compile the file foo.cyc to an object
file foo.o, one would write:</p>
<pre>  cyclone -tc -toc -pp -o foo.c foo.cyc 
  gcc -c foo.c</pre>
<p>The &quot;tc&quot; flag tells Cyclone to type-check the code, the &quot;toc&quot;
flag tells it to translate the code to C, and the &quot;pp&quot; flag says to
pretty print the resulting C code.  The output is directed via the
&quot;-o&quot; flag to the file foo.c.&nbsp;  (When no output is specified
it is sent to standard out.)&nbsp;  In the example above,
this would type-check foo.cyc, translate it to C, and then print the output to
foo.c.&nbsp; Then we invoke GCC to compile the foo.c file to foo.o</p>
<p>Note that Cyclone runs the C pre-processor on the file before actually
compiling it (just as with C).&nbsp;&nbsp;</p>
<p>The cyclone compiler takes the following command line arguments:</p>
<ul>
  <li>-I <i>dir</i>:&nbsp; add <i>dir</i> to the search path for #include files
    (as in C)</li>
  <li>-o <i>file</i> :&nbsp; print the output to <i>file</i></li>
  <li>-tc:&nbsp; type-check the input code</li>
  <li>-toc:&nbsp; translate the input code to C</li>
  <li>-pp: pretty-print the code</li>
  <li>-up: ugly-print the code</li>
  <li>-D <i>defn</i>: pass a definition to the pre-processor (as in C)</li>
  <li>-check-null:&nbsp; generate explicit tests for null (currently broken)</li>
  <li>-noexpandtypedefs:&nbsp; do not expand type-defs during pretty-printing</li>
</ul>
<p>We expect to put a more realistic front-end driver on Cyclone so that it will
look just like a C compiler (and transparently invoke GCC for you.)&nbsp; Note
that if you simply pass -tc and -pp to cyclone, then it will type-check the code
and pretty-print it without translating to C.&nbsp; Note also that translation
to C requires the -toc flag.&nbsp;&nbsp;</p>
<p>The output of Cyclone includes the file &quot;cyc_include.h&quot; in the
top-level directory, so make sure it's accessible when you invoke GCC on the
resulting code.&nbsp;&nbsp;</p>
<hr>
<h2><a name="Hello World">Hello World</a></h2>
<p>As a simple example of Cyclone, here is the canonical &quot;Hello&quot; world
program:</p>
<pre>  <font color="#008000">#include</font> &quot;<font color="#0000FF">core.h</font>&quot;  </pre>
<pre>  <b>using</b> Core;
  
  <font color="#FF0000"><i>// &quot;main&quot; is always called cyc_main in Cyclone</i></font>
  void <b>cyc_main</b>() {
    <font color="#FF0000"><i>// Get the command line arguments as an array of strings.
    // The first string is the name of the program.</i></font>
    string args[?] = std_args();  
   
    <i><font color="#FF0000">// if there was no argument to the program, raise an error.</font></i>
    <b>if</b> (args.size &lt;= 1) 
      <b>throw</b> Failure(&quot;<font color="#0000FF">missing name!</font>&quot;);
    <b>else</b>
      <b>printf</b>(&quot;<font color="#0000FF">Hello, %s.\n</font>&quot;,args[1]);
  }
  </pre>
<p>There are a few things to note about the example:&nbsp; First, Cyclone uses
the C-Preprocessor, hence the #include line.&nbsp; The file core.h can be found
in the lib/ directory and includes a number of core definitions that just about
any Cyclone compilation unit will need.&nbsp; The declaration &quot;using
Core;&quot; opens up the Core namespace to make the operations in Core
immediately available to the following code.&nbsp; The declaration &quot;void
cyc_main() { ... }&quot; declares the &quot;main&quot; function for the Cyclone
program, which takes no arguments and returns no result.&nbsp; Note that
failures in Cyclone are signalled using exceptions instead of returning error
codes.</p>
<p>The first line of the cyc_main function declares a variable &quot;args&quot;
to be a variable-sized array of strings.&nbsp; The declaration also initializes
args by calling the function std_args() which is part of the Core
namespace.&nbsp; After initializing args, the function checks to see if the size
(in terms of the number of elements in the array) of args is less than or equal
to 1.&nbsp; If so, a failure is signalled by throwing the Failure exception
(with an argument string reading &quot;missing name!&quot;).&nbsp; Otherwise,
the program prints to standard output &quot;Hello &lt;name&gt;&quot; where
&lt;name&gt; is the first argument to the program.&nbsp;&nbsp;</p>
<p>The file tests/hello.cyc contains the code above.&nbsp; If you change into
the tests directory, then you can compile the file to C by typing:</p>
<pre>  cyclone -I ../lib -tc -toc -pp hello.cyc &gt; hello.c</pre>
<p>(This assumes that you have the bin directory on your path.)&nbsp; This
should produce the file hello.c.&nbsp; You can look at the C code to see what it
looks like.&nbsp; Most of it is definitions that are imported from core.h.&nbsp;
The part that corresponds to the Cyclone code will be found at the bottom. The
code is pretty similar to the Cyclone code except that you can see that there is
extra gunk that corresponds to an array bounds check, and extra gunk to deal
with the variable-sized arrays, etc.</p>
<p>After generating hello.c, you can use GCC to compile it to an
executable.&nbsp; To do so, you need to make sure that the file cyc_include.h is
accessible, and to link against the cyclib.a and gclib.a libraries.&nbsp; Here's
an example of this:</p>
<pre>  gcc -I .. -o hello.exe hello.c ..\bin\cyclib.a ..\bin\gc.a</pre>
<p>This will produce an executable program hello.exe.&nbsp; Typing
&quot;hello&quot; under Win32 (&quot;hello.exe&quot; resp. under Unix) will
yield &quot;Uncaught exception Core_Failure&quot;.&nbsp; Typing &quot;hello
Fred&quot; will yield &quot;Hello, Fred.&quot;&nbsp;&nbsp;</p>
<p>To write real, standalone Cyclone applications, your best best is to follow the
Makefile examples in the directories.&nbsp; For instance, the Makefile in tests/
builds an application cyctest.exe which we've used during development to test
various features. At a minimum, you'll need to link against the cyclib.a and
gc.a libraries in the bin/ directory.&nbsp;&nbsp;</p>
<hr>
<h2><a name="Quick Guide to Cyclone">Quick Overview of the Language</a></h2>
<p>C programmers should find it fairly easy to get up to speed in Cyclone.&nbsp;
In particular, the syntax that we use is lifted directly from ANSI C and
wherever possible, we try to follow the static and dynamic semantics.&nbsp;
Nonetheless, there are a number of additions and restrictions that you need to
know in order to use the language effectively.</p>
<p>We'll begin by going over the new features that Cyclone adds to C.&nbsp; Then
we'll go over the common idioms that Cyclone prohibits, and see how these can be
coded using the new facilities.</p>
<hr>
<h2><a name="Features Added">Features Added</a></h2>
<p>Cyclone adds a number of features to C, ranging from convenient expression
forms, to advanced typing constructs.&nbsp; For instance, Cyclone includes many
of the GCC and proposed C-9X extensions that make writing code a bit
easier.&nbsp; Variables need not be declared at the top of a block, a
declaration can appear within a for-statement, expressions can have statements
nested inside them, etc.&nbsp; Cyclone also adds support for ML or Haskell-style
algebraic datatypes and pattern matching.&nbsp; Datatypes can seriously lift the
level of abstraction for code, and pattern matching can be an effective tool for
ensuring that all cases in a tricky test are covered.&nbsp;&nbsp;</p>
<p>In addition, Cyclone adds advanced typing support in the form of (a)
parametric polymorphism, (b) structural subtyping, (c) some unification-based,
local-type inference.&nbsp; These features are necessary to type-check or port a
number of (potentially) unsafe C idioms, usually involving &quot;void*&quot; or
the like.&nbsp; Similarly, datatypes can be used to code around many of the uses
for C's union types -- another potential source of unsoundness.&nbsp; Cyclone
also adds new support for variable length arrays and ensures that all array
indices are in bounds.&nbsp; Again, these features are aimed at making it easy
to port C code to Cyclone.</p>
<p>In what follows, we give a brief overview of these added
features.&nbsp;&nbsp;</p>
<hr>
<h4><a name="GCC and C-9X Additions:&nbsp;">GCC and C-9X Additions:&nbsp;</a></h4>
<p>Cyclone includes a number of features that GCC and the proposed <a href="http://web.onetelnet.ch/~twolf/tw/c/c9x_changes.html">ANSI
C-9X</a> standard include.&nbsp; A quick summary of the ones that Cyclone
currently includes are as follows:</p>
<ul>
  <li>Expressions can include statements of the form <code>({<i>stmt;</i>
    <i>exp</i>})</code></li>
  <li>Struct expressions:&nbsp; If you've declared <code>struct
    point{int x; int y;};</code> then you can write <code>point{.x=<i>exp,
    </i>.y=<i>exp</i>}</code> as a <code>struct point</code>
    expression.&nbsp;&nbsp;</li>
  <li>The implicit &quot;int&quot; for the return type of a function is removed</li>
  <li>// comments as in Java or C++</li>
  <li>Trailing comma allowed in enum declarations.&nbsp; Also, you can use
    semi-colons instead of commas.</li>
  <li>Declarations can appear in any statement position.&nbsp; It is not
    necessary to wrap braces around the declaration of a local variable.</li>
  <li>For-statements can include a declaration. For instance:&nbsp; <code><b>for</b>(int
    x=0; x &lt; n; x++) { ... }</code></li>
</ul>
<p>We expect to follow the C-9X standard fairly closely.&nbsp;&nbsp;</p>
<hr>
<h4><a name="Namespaces">Namespaces</a>:&nbsp;&nbsp;</h4>
<p>As in C++, namespaces are used to avoid name clashes in code.&nbsp; For
example:&nbsp;</p>
<pre><code><b>    namespace</b> Foo { 
      int x = 0; 
      int f() { <b>return</b> x; }<i> 
    </i>}</code></pre>
<p>declares an integer named <code>Foo::x</code> and a
function named <code>Foo::f</code>.&nbsp; Note that within
the namespace, you don't need to use the qualified name.&nbsp; For instance, <code>Foo::f</code> refers to <code>Foo::x</code> as simply <code>x</code>.&nbsp;
We could also simply write &quot;<code><b>namespace</b> Foo;</code>&quot;
(note the trailing semi-colon) and leave out the enclosing braces.&nbsp; Every
declaration following this namespace declaration would be placed in the <code>Foo</code>
namespace.&nbsp;&nbsp;</p>
<p>As noted before, you can refer to elements of a namespace using the
&quot;::&quot; notation.&nbsp; Alternatively, you can open up a namespace with a
&quot;using&quot; declaration.&nbsp;
For example, we could follow the above code with:</p>
<pre>    <b>namespace </b>Bar {
      <b>using </b>Foo {
        int g() { <b>return</b> f(); }
      }
      int h() { <b>return</b> Foo::f(); }
    }</pre>
<p>Here, we opened the <code>Foo</code> namespace within the
definition of <code>Bar::g</code>.&nbsp; One can also write
&quot;<code><b>using Foo;</b></code>&quot;
to open a namespace for the remaining definitions in the current block.</p>
<p>Namespaces can nest as in C++.&nbsp;&nbsp;</p>
<p>Currently, namespaces are only supported at the top-level and you can't
declare a qualified variable directly.&nbsp; Rather, you have to write a
namespace declaration to encapsulate it.&nbsp;&nbsp;</p>
<hr>
<h4><a name="Tuples">Tuples</a>:</h4>
<p>Tuples are like lightweight structs.&nbsp; They need not be declared in
advance, and have member or field names that are implicitly 0, 1, 2, 3,
etc.&nbsp; For example, the following code declares x to be a 3-tuple of an
integer, a character, and a boolean, initialized with the values 42, 'z', and
true respectively.&nbsp; It then checks to see whether the third component in
the tuple is true (it is) and if so, increments the first component in the tuple.</p>
<pre>   $(int,char,bool) x = $(42,'z',<b>true</b>)

   <b>if</b> (x[2]) 
     x[0]++;</pre>
<p>The above code would be roughly equivalent to writing:</p>
<pre>   <b>struct </b>{int f0; char f1; bool f2;} x = {42,'z',<b>true</b>};</pre>
<pre>   <b>if</b> (x.f2)
     x.f1++;</pre>
<p>Thus, tuple types are written $(<i>type1,...,typen</i>), tuple constructor
expressions are written $(<i>exp1,...,expn</i>), and extracting the ith
component of a tuple is written using subscript notation <i>exp[i-1]</i>.&nbsp;
Note that, consistent with the rest of C, the members start with 0, not 1.&nbsp;
Also note that when you have a pointer to a tuple (e.g., $(int,char,bool) *x),
then you can continue to access the fields using the subscript notation.</p>
<p>Unlike structs, tuple types are treated equivalent as long as they are
structurally equivalent.&nbsp; As in C, struct types are equivalent only if they
have the same <i>tag</i> or name.&nbsp; (Note that in C, all struct declarations
have a tag, even if the compiler has to gensym one.)&nbsp;&nbsp;</p>
<hr>
<h4><a name="Non-null Pointers:">Non-null Pointers:</a></h4>
<p>In Cyclone, when a variable has a pointer type (e.g., int *x), then you can't
be sure at compile time whether or not the pointer is null.&nbsp; To avoid
memory safety problems, the compiler and/or runtime system checks each time you
dereference a pointer to ensure that it is not null.&nbsp; If it is null, then
an exception (NullPointer???) is raised.&nbsp; Thus, when reading or writing
code, you're never sure whether or not you'll get a NullPointer exception.&nbsp;
Java has a similar problem.&nbsp;&nbsp;</p>
<p>Thus, Cyclone provides a different pointer type @.&nbsp; When x has type int@
(as opposed to int*), then we know that x is not null.&nbsp; Consequently, there
is no overhead for dereferencing x, nor is there the potential for raising an
exception.&nbsp;&nbsp;</p>
<p>You can cast a @ pointer to a * pointer with no overhead, assuming the things
that point to are the same type.&nbsp; You can also cast a * pointer to a @
pointer, but this induces a run-time check.&nbsp; If the pointer is null, then
the (NullPointer???) exception is raised.</p>
<hr>
<h4><a name="Exceptions">Exceptions</a>:</h4>
<p>Cyclone provides exceptions, <code>throw</code>, and <code>
try</code>/<code>catch</code> statements similar to
Java.&nbsp; (We'll probably add support for finally clauses at some
point.)&nbsp; This is one way to avoid the error-prone and type-unsafe approach in C of
returning a value (e.g., -1) to indicate an error.&nbsp; (An alternative way is to return a possibly-null pointer, or an appropritate enum value.)&nbsp;  Exception values are a special case of
extensible datatype enums (xenums) described below.&nbsp; The following example
shows how to declare a couple of exceptions, how to throw an exception, and how
to catch an exception:</p>
<pre>  <b>xenum </b>exn { NotFound(string); }  <i><font color="#FF0000">// NotFound takes a string as an argument</font></i>
  <b>xenum </b>exn { Foo; }              <i><font color="#FF0000"> // Foo takes no arguments</font></i></pre>
<pre>  <b>void </b>bar() {
    <b>if</b> (coin_toss()) 
      <b>throw</b> Foo;
    <b>else</b> <b>if</b> (!lookup(&quot;<font color="#0000FF">friday</font>&quot;))
      <b>throw</b> NotFound(&quot;<font color="#0000FF">friday isn't here</font>&quot;);
  }</pre>
<pre>  <b>void</b> foo() {
    <b>try</b> {
      bar();
    } <b>catch</b> {
    <b>case</b> NotFound(s):  <b>fprintf</b>(cyc_stderr, &quot;<font color="#0000FF">not found: %s\n</font>&quot;,s); <b>break</b>;
    <b>case</b> Foo: <b>fprintf</b>(cyc_stderr, &quot;<font color="#0000FF">foo raised!\n</font>&quot;); <b>break</b>;
    }
    <b>printf</b>(&quot;<font color="#0000FF">no exception raised.\n</font>&quot;);
  }</pre>
<hr>
<h4><a name="Variable Sized Arrays">Variable Sized Arrays</a>:</h4>
<p>C purposefully confuses arrays and pointers.&nbsp; Cyclone does not, in large
part for type-safety reasons.&nbsp; All array accesses are guaranteed to be in
bounds.&nbsp; To support arrays of variable size, Cyclone provides the
&quot;[?]&quot; array type.&nbsp; For example, string is defined using the
following typedef:</p>
<pre>  <b>typedef </b>string char[?];</pre>
<p>For representation purposes, a char[?] array is represented as a pointer to
a struct of the form {const unsigned int size; char[size] *elts;} but of course,
you can't really write this in C.&nbsp; The point is that there is an extra
level of indirection in order to support dynamically tracking the size of the
array.&nbsp; This allows the compiler to insert array bounds checks as
needed.&nbsp;&nbsp;</p>
<p>Cyclone also has normal C arrays (e.g., char[]) and constant-sized arrays
(e.g., char[3+4] == char[7]), but these are all treated differently.&nbsp; In
particular, you can't perform subscript or update on a char[] array within
Cyclone.&nbsp; You may, however, pass the array off to a C function (which had
better make sure that the accesses are in bounds.)&nbsp; An array char[7]
doesn't need the size information as it is apparent statically.&nbsp; You can
cast [?] arrays to [] arrays with no overhead (this just extracts the underlying
array) and this is useful for calling a C function that was written expecting
the untagged array.&nbsp; You can also cast a [?] array to a [7] array, but this
incurs a check that the size of the [?] array is actually 7.&nbsp; You can cast
a [7] array to a [?] array -- this simply adds the size and a level of
indirection.&nbsp; Finally, you can cast a [7] array to a [] array, again so
that you can call C code.</p>
<p>To allocate and initialize an array, you can use the array comprehension
notation.&nbsp; The following code demonstrates this:</p>
<pre>  int evens[?] = <b>new</b> {<b>for</b> i &lt; n : 2*i};</pre>
<p>The above declares evens to be an int[?] array and initializes it to an array
of size n, where element i has value 2*i in the array.&nbsp; If the upper bound
is a constant expression, then the type of the array will be [c] where c is a
constant.&nbsp; Otherwise, it will be a [?] array.&nbsp; Of course, you can cast
the constant-sized array to a variable-sized array.</p>
<p>Note that all arrays in Cyclone are heap allocated (not stack
allocated).&nbsp;&nbsp;Also note that string literals are treated
as either char[n] arrays or char[?] arrays depending upon context.
If the string literal is of the form "foo", then its size is 4,
due to the implicit trailing "\000" character (and thus its type will be char[4]).

</p>
<p>In the future, we hope to add support for DML-style dependent types so that
arrays need not carry size information and so that bounds checks can be
statically verified.&nbsp; In addition, we hope to add support for regions or
linear types so that arrays can be stack allocated (or managed manually in some
other fashion.)</p>
<hr>
<h4><a name="Subtyping">Subtyping</a>:</h4>
<p>Cyclone supports &quot;extension on the right&quot; and &quot;covariant depth
on const&quot; subtyping for pointers.&nbsp; This simply means that you can cast
a value x from having a type "pointer to a struct with 10 fields", to "pointer to a struct having
only the first 5 fields".&nbsp; For example, if we have the following
definitions:
<pre>
  <b>typedef</b> <b>struct</b> Point {float x,y;} *point;

  <b>typedef</b> <b>struct</b> CPoint {float x,y; int color;} *cpoint;

  float xcoord(point p) {
    <b>return</b> p->x;
  }
</pre>
then you can call xcoord with either a point or cpoint object.  

You can also cast a pointer to a tuple having 3
fields (e.g., $(int,bool,double)*) to a pointer to a tuple having only 
2 fields (e.g., $(int,bool)*).&nbsp; 
In other words, you can forget
about the &quot;tail&quot; of the object.&nbsp; This allows a degree of
polymorphism that is useful when porting C code.&nbsp; In addition, you can do
&quot;deep&quot; casts on pointer fields that are const.&nbsp; (It is unsound to
allow deep casts on non-const fields.)&nbsp; Also, you can cast a field from
being non-const to being const.&nbsp; You can also cast a constant-sized array
to an equivalent pointer to a struct or tuple.&nbsp; In short, Cyclone attempts
to allow you to cast one type to another as long as it is safe.&nbsp; Note,
however, that these casts must be explicit.</p>
<p>We expect to add more support for subtyping in the future (e.g., subtyping on
function pointers, bounded subtyping, etc.)</p>
<hr>
<h4><a name="Datatype Enums:">Datatype Enums:</a></h4>
<p>Enums in Cyclone are more like datatypes in ML.&nbsp; In particular, they can
be used to build algebraic or inductively defined structures, such a lists,
trees, graphs, etc.&nbsp; For instance, the following enum declarations give a
way to construct abstract syntax trees for a simple calculator language:</p>
<pre>  <b>enum </b>operator { Plus, Times, Minus, Divide }</pre>
<pre>  <b>enum </b>absyn {
    Integer(int);
    Term(<b>enum</b> absyn, <b>enum</b> operator, <b>enum</b> absyn);
  }</pre>
<pre>  <b>enum </b>absyn e1 = Term(Integer(3),Plus,Integer(4));
  <b>enum </b>absyn e2 = Term(e1,Times,Integer(5));</pre>
<p>The operator definition is like a normal enum -- it just defines symbolic
constants for Plus, Times, Minus, and Divide.&nbsp; The absyn definition defines
an inductive tree-like data type for abstract syntax.&nbsp; The Integer
constructor takes an int argument and returns an absyn value.&nbsp; The Term
constructor takes an abstract syntax tree, an operator, and an abstract syntax
tree and returns a new abstract syntax tree.&nbsp; So, for example, e1 is a tree
representing the term &quot;3 + 4&quot; while e2 is a tree representing the term
&quot;(3 + 4) * 5&quot;.&nbsp;&nbsp;</p>
<p>Internally, enum constructors are either represented as an integer value (as
with Plus, Times, Minus, and Divide) or a pointer to an object containing a <i>tag</i>
and the arguments to the constructor.&nbsp; The object is always allocated on
the heap.&nbsp; To traverse the tree, we use pattern matching, again in the
style of functional languages such as ML or Haskell.</p>
<p>Why did we choose to extend enums instead of adding a datatype declaration (a
la ML)?&nbsp; We wanted to minimize the number of keywords that we added to the
language, so adding an explicit datatype declaration and keyword was not seen as
desirable.&nbsp; In addition, enums already provided primitive symbolic
names.&nbsp;&nbsp;</p>
<p>In the future, we plan to make the representation of enums explicit and to
allow programmers to control tag placement and do explicit tests on the tag to
refine the type of an object in a more traditional, data-flow fashion.&nbsp; We
will probably keep the enum construct as is for convenience.</p>
<hr>
<h4><a name="Pattern Matching:">Pattern Matching:</a></h4>
<p>Pattern matching in Cyclone generalizes the switch construct of C allowing
you to not only test integral values, but also to test structured values such as
the abstract syntax trees above.&nbsp; For example, the following function takes
in an abstract syntax tree and prints the tree to stdout:</p>
<pre>  <b>void</b> print_absyn(<b>enum</b> absyn tree) {
     <b>switch</b> (tree) {
     <b>case</b> Integer(i)       : <b>printf</b>(&quot;<font color="#0000FF">%d</font>&quot;,i); <b>break</b>;
     <b>case</b> Term(t1,Plus,t2) : <b>printf</b>(&quot;<font color="#0000FF">(</font>&quot;; print_absyn(t1); 
                             <b>printf</b>(&quot;<font color="#0000FF">+</font>&quot;); 
                             print_absyn(t2); <b>printf</b>(&quot;<font color="#0000FF">)</font>&quot;); <b>break</b>;
     <b>case</b> Term(t1,Times,t2): <b>printf</b>(&quot;<font color="#0000FF">(</font>&quot;; print_absyn(t1); 
                             <b>printf</b>(&quot;<font color="#0000FF">*</font>&quot;); 
                             print_absyn(t2); <b>printf</b>(&quot;<font color="#0000FF">)</font>&quot;); <b>break</b>;
     <b>case</b> Term(t1,Minus,t2): <b>printf</b>(&quot;<font color="#0000FF">(</font>&quot;; print_absyn(t1); 
                             <b>printf</b>(&quot;<font color="#0000FF">-</font>&quot;);
                             print_absyn(t2); <b>printf</b>(&quot;<font color="#0000FF">)</font>&quot;); <b>break</b>;
     <b>case</b> Term(t1,Divide,t2):<b>printf</b>(&quot;<font color="#0000FF">(</font>&quot;; print_absyn(t1); 
                             <b>printf</b>(&quot;<font color="#0000FF">/</font>&quot;);
                             print_absyn(t2); <b>printf</b>(&quot;<font color="#0000FF">)</font>&quot;); <b>break</b>;
  }</pre>
<p>Note that patterns introduce and initialize new variables local to a given
case.&nbsp; For instance, in the Integer case above, the pattern variable i is
introduced and is initialized to whatever value is carried by the Integer
constructor.&nbsp; Thus, i is available for use on the right-hand-side of the
case.&nbsp; You can pattern match on just about any kind of value, and
destructure it.&nbsp; For instance, you can pattern match on tuples, structs,
pointers to tuples/structs, etc.&nbsp; See the grammar for the syntax of the
various pattern forms.</p>
<p>The type-checker for Cyclone is much more picky about switch statements than
C.&nbsp; In particular, it will check that all of the patterns you have are
exhaustive (or else there's a default: clause) and that none of the patterns
overlap.&nbsp; This is useful for evolving code.&nbsp; For instance, if we added
a new operator (say Mod), then the compiler would complain that the switch in
print_absyn doesn't cover all possible cases (namely the case where we have a
term involving the Mod operator.)&nbsp;&nbsp;</p>
<p>In addition, the Cyclone type-checker makes sure that you don't accidentally
fall-through from one case to another.&nbsp; In particular, if you don't put in
explicit breaks, returns, throws, etc., then the compiler will reject the
code.&nbsp; You can still fall through to the next case, but you have to do it
with an explicit &quot;fallthru&quot; statement.&nbsp; If the case pattern
doesn't bind any new variables, then you just write &quot;fallthru;&quot; as the
last thing in the case.&nbsp; If you want to fallthru to a case that defines new
variables, then you need to give values for those variables.&nbsp; For instance,
in the following code:</p>
<pre>
  <b>void</b> foo(<b>enum</b> absyn tree) {
     <b>switch</b> (tree) {
     <b>case</b> Integer(i)       : printf(&quot;<font color="#0000FF">%d </font>&quot;,i); <b>break</b>;
     <b>case</b> Term(t1,Plus,t2) : printf(&quot;<font color="#0000FF">It's a plus \n</font>&quot;); <b>fallthru</b>(t2,Plus,t1);
     <b>case</b> Term(t1,op,t2)   : foo(t1); foo(t2); <b>break</b>;
  }</pre>
<p>if we pass it a tree Term(Integer(3),Plus,Integer(4)) then we will see
&quot;It's a plus 4 3 &quot;, but if we pass it
Term(Integer(3),Times,Integer(4)) we will see &quot;3 4 &quot;.</p>
<hr>
<h4><a name="Let Declarations:">Let Declarations:</a></h4>
<p>Sometimes, it's painful to declare a variable because you have to write down
its type.&nbsp; Cyclone includes some limited support for type inference using
let declarations.&nbsp; In particular, you can write:</p>
<pre>  int foo(int x) {
    <b>let</b> y = x+3;
    <b>let</b> z = 3.14159;
    <b>return</b> (int)(y*z);
  }</pre>
<p>&nbsp;Here, we declared two variables y and z using &quot;let&quot;.&nbsp;
When you use let, you don't have to write down the type of the variable.&nbsp;
Rather, the compiler infers the type from the expression that initializes the
variable.&nbsp; More generally, you can write &quot;let <i>pattern </i>= <i>exp</i>;&quot;
to destructure a value into a bunch of variables.&nbsp; For instance, if you
pass a tuple to a function, then you can extract the components as follows:</p>
<pre>  int sum($(int,int,int) args) {
    <b>let</b> $(x,y,z) = args;
    <b>return</b> (x+y+z);
  }</pre>
<hr>
<h4><a name="Extensible Enums (xenums):">Extensible Enums (xenums):</a></h4>
<p>Extensible enums (xenums) are just like enums except that you can add new
constructors anytime you want.&nbsp; Thus, enums are &quot;closed world&quot;
datatypes, whereas xenums are &quot;open world&quot; datatypes.&nbsp; Both are
useful.&nbsp; For instance, with a close world representation of abstract syntax
trees, when we write a function such as print_absyn, we can be sure that we've
covered all of the cases.&nbsp; However, if we want an extensible setting, where
programmers are adding new kinds of nodes all the time, then it's useful to use
xenums.&nbsp; Right now, we really only use xenums in the parser (for various
semantic values) and for exceptions.&nbsp; We might add better subtyping support
for them so that you can extend them depth-wise as well as
width-wise.&nbsp;&nbsp;</p>
<hr>
<h4><a name="Polymorphic Functions:">Polymorphic Functions:</a></h4>
<p>As mentioned above, Cyclone supports a limited amount of subtyping
polymorphism.&nbsp; It also supports a fairly powerful form of parametric
polymorphism.&nbsp; Those of you coming from ML or Haskell will find this
familiar.&nbsp; Those of you coming from C++ will also find it somewhat
familiar.&nbsp; The basic idea is that you can write one function that abstracts
the types of some of the values it manipulates.&nbsp; For instance, consider the
following two functions:</p>
<pre>  $(string,int) swap1($(int,string) x) {
     <b>return</b> $(x[1], x[0]);
  }</pre>
<pre>  $(int,int) swap2($(int,int) x) {
     <b>return</b> $(x[1], x[0]);
  }</pre>
<p>The two functions are quite similar:&nbsp; They both take in a pair (i.e., a
2-tuple) and return a pair with the components swapped.&nbsp; At the
machine-level, the code for these two functions will be exactly the same,
assuming that ints and strings (char *) are represented the same way.&nbsp; So
it seems silly to write the code twice.&nbsp; Normally, a C programmer would
replace the definition with simply:</p>
<pre>  $(void *,void *) swap1($(void *,void *) x) {
     <b>return</b> $(x[1], x[0]);
  }</pre>
<p>(assuming you added tuples to C).&nbsp; But of course, this isn't type-safe
because once I cast the values to void *, then I can't be sure what type I'm
getting out.&nbsp; In Cyclone, you can instead write something like this:</p>
<pre>  $(`b,`a) swap&lt;`a,`b&gt;($(`a,`b) x) {
     <b>return </b>$(x[1],x[0]);
  }</pre>
<p>The code is the same, but it abstracts what the types are.&nbsp; The extra
parameters &lt;`a,`b&gt; are type variables that can be instantiated with any <i>word-sized,
general-purpose register </i>type.&nbsp; So, for instance, you can call swap on
pairs of integers, pairs of pointers, pairs of an integer and a pointer, etc.:</p>
<pre>  <b>let</b> $(x,y) = swap($(&quot;<font color="#0000FF">hello</font>&quot;,3));  <font color="#FF0000"><i>// x is 3, y is hello</i></font>
  <b>let</b> $(w,z) = swap($(4,3));        <i><font color="#FF0000">// w is 3, z is 4</font></i></pre>
<p>Note that when calling a polymorphic function, you need not tell it what
types you're using to instantiate the type variables.&nbsp; Rather, Cyclone
figures this out through unification.&nbsp;&nbsp;</p>
<p>C++ supports similar functionality with templates.&nbsp; However, C++ and
Cyclone differ considerably in their implementation strategies.&nbsp; First,
Cyclone only produces one copy of the code, whereas a C++ template is
specialized and duplicated at each type that it is used.&nbsp; This approach
requires that you include definitions of templates in interfaces and thus
defeats separate compilation.&nbsp; However, the approach used by Cyclone does
have its drawbacks:&nbsp; In particular, the only types that can instantiate
type variables are those that can be treated uniformly.&nbsp; This ensures that
we can use the same code for different types.&nbsp; The general rule is that
values of the types that instantiate a type variable must fit into a machine
word and must be passed in general-purpose (as opposed to floating-point)
registers.&nbsp; Examples of such types include int, pointer, enum, xenum, and
array types.&nbsp; Other types, including char, short, long long, float,
double, struct, and tuple types violate this rule and thus cannot be passed to a
function like swap in place of the type variables.&nbsp;&nbsp;</p>
<p>In practice, this means that you tend to manipulate a lot of pointers in
Cyclone code.&nbsp; To deal with the base types, Cyclone also provides
&quot;boxed&quot; versions (Char, Short, Long Long, Float, Double) that
can be used to instantiate polymorphic code.&nbsp; Boxed types such as 
Char, and Short take up a full machine word in a struct, tuple or array.&nbsp;
Thus, Char[10] consists of 10 words, whereas char[10] consists of 10
bytes.&nbsp; Boxed types such as Long Long and Double that take up more than one
machine word are allocated on the heap and referenced via pointer.&nbsp; This is
similar to the Java boxed base types.&nbsp; Of course, you can cast to/from base
types and their boxed versions.&nbsp; In general, you need not explicitly cast
from the Boxed type to the unboxed type, but you may have to explicitly cast
when going from the unboxed version to the boxed version.&nbsp; (This lets you
know when allocation is happening.)</p>
<p>The combination of parametric polymorphism and sub-typing means that you can
cover a lot of C idioms where void* or unsafe casts were used without
sacrificing type-safety.&nbsp; We use polymorphism a lot when coding in
Cyclone.&nbsp; For instance, the standard library includes many container
abstractions (lists, sets, queues, etc.) that are all polymorphic in the element
type.&nbsp; This allows us to re-use a lot of code.&nbsp; In addition, unlike
C++, those libraries can be compiled once and need not be specialized.&nbsp; On
the downside, this style of polymorphism does not allow you to do any
type-specific things (e.g., overloading or ad-hoc polymorphism.)&nbsp; Someday,
we may add support for this, but in the short run, we're happy not to have
it.&nbsp;</p>
<hr>
<h4><a name="Polymorphic Data Structures:">Polymorphic Data Structures:</a></h4>
<p>Just as function definitions can be parameterized by types, so can struct
definitions, enum definitions, and even typedefs.&nbsp; For instance, the
following struct definition is used in the standard library for lists:</p>
<pre>  <b>struct</b> cons&lt;`a&gt; {`a hd; <b>struct</b> cons&lt;`a&gt; *tl; };
  <b>typedef</b> <b>struct</b> cons&lt;`a&gt; *list&lt;`a&gt;;</pre>
<p>Here, we've declared a struct cons parameterized by a type `a.&nbsp; The hd
field contains an element of type `a and the tl field contains a (possibly null)
pointer to a struct cons with elements of type `a.&nbsp; We then define
list&lt;`a&gt; as an abbreviation for struct cons&lt;`a&gt;*.&nbsp; So, for
instance, we can declare both integer and string lists like this:</p>
<pre>  list&lt;int&gt; ilist = &amp;cons{1,&amp;cons{2,null}};
  list&lt;string&gt; slist = &amp;cons{.hd=&quot;<font color="#0000FF">foo</font>&quot;,.tl=&amp;cons{&quot;<font color="#0000FF">bar</font>&quot;,null}};</pre>
<p>Note that we use &quot;&amp;&quot; like &quot;new&quot; in C++ to allocate a
new struct cons on the heap and return a pointer to the resulting (initialized)
cons object.&nbsp; Note also that the field designator (&quot;.hd&quot;,
&quot;.tl&quot;) are optional.</p>
<p>Once you have polymorphic data structures, you can write lots of useful
polymorphic code and use it over and over again.&nbsp; For instance, the
standard list library includes functions for mapping over a list, looking up
items in a list, concatenating two lists, copying lists, sorting lists,
etc.&nbsp;&nbsp;</p>
<hr>
<h4><a name="Abstract and Existential Types:">Abstract and Existential Types:</a></h4>
<p>Suppose you want to declare an abstract type for implementing stacks.&nbsp;
In Cyclone, the way this is accomplished is by declaring a struct that
encapsulates the implementation type, and by adding the &quot;abstract&quot;
qualifier to the struct definition.&nbsp; For instance, if we write:</p>
<pre>  <b>abstract </b><b>struct</b> Queue&lt;`a&gt; { list&lt;`a&gt; front, rear; };</pre>
<p>then this declares a polymorphic Queue implementation that is abstract.&nbsp;
The definition of the struct is available within the unit that declares the
Queue, but will not be made available to the outside world.&nbsp; (This will be
enforced by a link-time type-checker which we are currently putting
together.)&nbsp; Typically, the provider of the Queue abstraction would write in
an interface file:</p>
<pre>  <b>extern struct </b>Queue&lt;`a&gt;;</pre>
<p>The abstract keyword in the implementation ensures that the definition does
not leak to a client.&nbsp; One can also declare enums to be abstract, though I
find it more useful to always use a struct to encapsulate the enum, and make the
enum static, and the struct abstract.&nbsp; That way, clients are always given
an abstract struct to manipulate.&nbsp;&nbsp;</p>
<p>Typedefs cannot be made abstract.&nbsp; As in C, typedefs are type
abbreviations and are expanded at compile time.&nbsp; If we chose to make them
(potentially) abstract, then we'd have to enforce a &quot;boxedness&quot;
restriction, similar to the restrictions on type variables.&nbsp; To simplify
the language, we chose to make structs abstract.&nbsp;&nbsp;</p>
<p>It's also possible to code up &quot;first-class&quot; abstract data types
using enums or xenums.&nbsp; Individual [x]enum constructors can be
parameterized by additional type variables that are local to the
type-constructor.&nbsp; (From a type-theoretic point of view, these are
existentially-quantified variables.)&nbsp; I won't bother to say a lot more
about these here, except that the approach used is quite similar to the
treatment of existential types in Haskell.&nbsp; In particular, pattern matching
one of these constructors requires you to introduce explicit type variables into
which the actual types are &quot;unpacked&quot;.&nbsp; These variables are
treated abstractly in the body of a case.&nbsp; However, when creating one of
the values, it is not necessary to explicitly &quot;pack&quot; the types to be
abstracted.&nbsp; Rather, the types are discovered through unification.&nbsp;
For an example of the use of existential types, see the fn.h and fn.cyc files in
the standard library which implement first-class closures.</p>
<hr>
<h2><a name="Restrictions">Restrictions</a></h2>
<hr>
<h2><a name="The Grammar of Cyclone">The Grammar of Cyclone</a></h2>

Cyclone's grammar is derived from the next proposed OSI C standard,
C9X.  Changes from and additions to the C9X grammar are noted in red.
The start symbol is <i>translation-unit</i>.
<p>

<b>Quick links:</b>
<a href=#declaration><i>declaration</i></a>,
<a href=#struct-or-union-specifier><i>struct-or-union-specifier</i></a>,
<a href=#enum-specifier><i>enum-specifier</i></a>,
<a href=#declarator><i>declarator</i></a>,
<a href=#statement><i>statement</i></a>,
<a href=#pattern><i>pattern</i></a>,
<a href=#expression><i>expression</i></a>

<p>
&nbsp;
<font color=blue>
<ul>
<i>translation-unit</i>:<br>
<ul>
  <i>external-declaration</i> <i>translation-unit<sub>opt</sub></i><br>
<font color=red>
  <code>using</code> <i>identifier</i> <code>;</code> <i>translation-unit</i></font></font><font color="red"><i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</i></font><font color="#008000">// open namespace <i>identifier </i>within <i>translation-unit&nbsp;</i></font>
<font color=blue>
<font color=red>
  <br>
</font>
</font><font color="#FF0000">
  <code>namespace</code> <i>identifier</i> <code>;</code> <i>translation-unit&nbsp;&nbsp;&nbsp;
  </i></font><font color="#008000">// encapsulate <i>translation-unit </i>within
namespace <i>identifier</i></font>
<font color=blue>
<font color=red>
  <br>
</font></font><font color="#FF0000">
  <code>using</code> <i>identifier</i> <code>{</code> <i>translation-unit</i> <code>}</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</font><font color="#008000">// open namespace <i>identifier </i>within <i>translation-unit</i></font>
<font color=blue>
<font color=red>
  <br>
</font></font><font color="#FF0000">
  <code>namespace</code> <i>identifier</i> <code>{</code> <i>translation-unit</i> <code>}</code>
 </font>
<font color="#008000">
// encapsulate <i>translation-unit </i>within namespace <i>identifier</i></font>
<font color=blue>
<font color=red>
  <br>
</font>
</ul>
<br>
<i>external-declaration</i>:<br>
<ul>
  <i>function-definition</i><br>
  <i>declaration</i><br>
</ul>
<br>
<i>function-definition</i>:<br>
<ul>
  <i>declaration-specifiers<sub>opt</sub></i> <i>declarator</i> <i>declaration-list<sub>opt</sub></i> <i>compound-statement</i><br>
</ul>
<br>
<a name=declaration></a>
<i>declaration</i>:<br>
<ul>
  <i>declaration-specifiers</i> <i>init-declarator-list<sub>opt</sub></i> <code>;</code><br>
<font color=red>
  <code>let</code> <i>pattern</i> <code>=</code> <i>expression</i> <code>;</code></font></font><code><font color="red">&nbsp;
</font></code><font color="#008000">// match <i>expression </i>against <i>pattern </i>and declare pattern variables</font>
<font color=blue>
<font color=red>
  <br>
</font>
</ul>
<br>
<i>declaration-list</i>:<br>
<ul>
  <i>declaration</i><br>
  <i>declaration-list</i> <i>declaration</i><br>
</ul>
<br>
<i>declaration-specifiers</i>:<br>
<ul>
  <i>storage-class-specifier</i> <i>declaration-specifiers<sub>opt</sub></i><br>
  <i>type-specifier</i> <i>declaration-specifiers<sub>opt</sub></i><br>
  <i>type-qualifier</i> <i>declaration-specifiers<sub>opt</sub></i><br>
  <i>function-specifier</i> <i>declaration-specifiers<sub>opt</sub></i><br>
</ul>
<br>
<i>storage-class-specifier</i>: <font color=black>one of</font><br>
<ul>
  <code>auto</code>
  <code>register</code>
  <code>static</code>
  <code>extern</code>
  <code>typedef</code><br>
<font color=red>
  <code>abstract</code> &nbsp;&nbsp;&nbsp;<font color="#008000">// makes struct or enum declarations abstract </font>
</font>
<br>
</ul>
<br>
<font color=green>
(The C9X type-specifiers
<code>_Complex</code>, and
<code>_Imaginary</code>
are not yet supported)
</font><br>
<i>type-specifier</i>: <font color=black>one of</font><br>
<ul>
  <code>void</code>
  <code>char</code>
  <code>short</code>
  <code>int</code>
  <code>long</code>
  <code>float</code>
  <code>double</code>
  <code>signed</code><br>
  <code>unsigned</code>
  <i>struct-or-union-specifier</i>
  <i>enum-specifier</i><br>
  <i>typedef-name</i> <font color=red><i>type-params<sub>opt</sub></i></font>
  <br> 
  <font color=red>
  <i>type-var</i>
  <br>
  <code>Char</code>
  <code>Short</code>
  <code>Int</code>
  <code>Long</code>
  <code>Float</code>
  <code>Double</code>
  &nbsp;&nbsp;&nbsp;<font color="#008000">// boxed types</font>
   <br>
  <code>$</code> <code>(</code> <i>parameter-list</i> <code>)</code>
  &nbsp;&nbsp;&nbsp;<font color="#008000">// tuple types</font><br>
</font>
</ul>
<br>
<i>type-qualifier</i>: <font color=black>one of</font><br>
<ul>
  <code>const</code>
  <code>restrict</code>
  <code>volatile</code><br>
</ul>
<br>
<i>function-specifier</i>:
<ul>
  <code>inline</code><br>
</ul>
<br>
<a name=struct-or-union-specifier></a>
<i>struct-or-union-specifier</i>:<br>
<ul>
  <i>struct-or-union</i> <code>{</code> <i>struct-declaration-list</i> <code>}</code><br>
  <i>struct-or-union</i> <i>identifier</i> <font color=red><i>type-params<sub>opt</sub></i></font> <code>{</code> <i>struct-declaration-list</i> <code>}</code><br>
  <i>struct-or-union</i> <i>identifier</i> <font color=red><i>type-params<sub>opt</sub></i></font><br>
</ul>
<br>
<font color=red>
<i>type-params</i>:<br>
<ul>
  <code><</code> <i>type-name-list</i> <code>></code><br>
</ul>
</font>
<br>
<i>struct-or-union</i>: <font color=black>one of</font><br>
<ul>
  <code>struct</code>
  <code>union</code><br>
</ul>
<br>
<i>struct-declaration-list</i>:<br>
<ul>
  <i>struct-declaration</i><br>
  <i>struct-declaration-list</i> <i>struct-declaration</i><br>
</ul>
<br>
<i>init-declarator-list</i>:<br>
<ul>
  <i>init-declarator</i><br>
  <i>init-declarator-list</i> <code>,</code> <i>init-declarator</i><br>
</ul>
<br>
<i>init-declarator</i>:<br>
<ul>
  <i>declarator</i><br>
  <i>declarator</i> <code>=</code> <i>initializer</i><br>
</ul>
<br>
<i>struct-declaration</i>:<br>
<ul>
  <i>specifier-qualifier-list</i> <i>struct-declarator-list</i> <code>;</code><br>
</ul>
<br>
<i>specifier-qualifier-list</i>:<br>
<ul>
  <i>type-specifier</i> <i>specifier-qualifier-list<sub>opt</sub></i><br>
  <i>type-qualifier</i> <i>specifier-qualifier-list<sub>opt</sub></i><br>
</ul>
<br>
<i>struct-declarator-list</i>:<br>
<ul>
  <i>struct-declarator</i><br>
  <i>struct-declarator-list</i> <code>,</code> <i>struct-declarator</i><br>
</ul>
<br>
<i>struct-declarator</i>:<br>
<ul>
  <i>declarator</i><br>
  <i>declarator<sub>opt</sub></i> <code>:</code> <i>constant-expression</i><br>
</ul>
<br>
<a name=enum-specifier></a>
<i>enum-specifier</i>:<br>
<ul>
  <code>enum</code> <code>{</code> <i>enumerator-list</i> <code>}</code><br>
  <code>enum</code> <i>identifier</i> <font color=red><i>type-params<sub>opt</sub></i></font> <code>{</code> <i>enumerator-list</i> <code>}</code><br>
  <code>enum</code> <i>identifier</i> <font color=red><i>type-params<sub>opt</sub></i></font><br>
<font color=red>
  <code>xenum</code> <i>identifier</i> <code>{</code> <i>enumerator-list</i> <code>}</code><br>
  <code>xenum</code> <i>identifier</i><br>
</font>
</ul>
<br>
<i>enumerator-list</i>:<br>
<ul>
<font color=red>
  <i>enumerator</i><br>
  <i>enumerator</i> <code>,</code> <i>enumerator-list</i><br>
  <i>enumerator</i> <code>;</code><br>
  <i>enumerator</i> <code>;</code> <i>enumerator-list</i><br>
</font>
</ul>
<br>
<i>enumerator</i>:<br>
<ul>
  <i>identifier</i><br>
  <i>identifier</i> <code>=</code> <i>constant-expression</i><br>
<font color=red>
  <i>identifier</i> <code>(</code> <i>parameter-list</i> <code>)</code>
  &nbsp;&nbsp;&nbsp;<font color="#008000">
  // datatype constructor </font>
  <br>
</font>
</ul>
<br>
<a name=declarator></a>
<i>declarator</i>:<br>
<ul>
  <i>pointer<sub>opt</sub></i> <i>direct-declarator</i><br>
</ul>
<br>
<font color=green>(We do not support C9X <code>[*]</code> direct-declarators.)</font><br>
<i>direct-declarator</i>:<br>
<ul>
  <i>identifier</i><br>
  <code>(</code> <i>declarator</i> <code>)</code><br>
  <i>direct-declarator</i> <code>[</code> <i>constant-expression<sub>opt</sub></i> <code>]</code><br>
  <i>direct-declarator</i> <code>(</code> <i>parameter-type-list</i> <code>)</code><br>
  <i>direct-declarator</i> <code>(</code> <i>identifier-list<sub>opt</sub></i> <code>)</code><br>
<font color=red>
  <i>direct-declarator</i> <code>[</code> <code>?</code> <code>]</code>
  &nbsp;&nbsp;&nbsp;<font color="#008000">// variable-length arrays</font>
  <br>
  <i>direct-declarator</i> <code><</code> <i>type-name-list</i> <code>></code><br>
</font>
</ul>
<br>
<i>pointer</i>:<br>
<ul>
  <code>*</code> <i>type-qualifier-list<sub>opt</sub></i> <i>pointer<sub>opt</sub></i><br>
<font color=red>
  <code>@</code> <i>type-qualifier-list<sub>opt</sub></i> <i>pointer<sub>opt</sub></i>
  &nbsp;&nbsp;&nbsp;<font color="#008000">// non-null pointers</font>
<br>
</font>
</ul>
<br>
<i>type-qualifier-list</i>:<br>
<ul>
  <i>type-qualifier</i><br>
  <i>type-qualifier-list</i> <i>type-qualifier</i><br>
</ul>
<br>
<i>parameter-type-list</i>:<br>
<ul>
  <i>parameter-list</i><br>
  <i>parameter-list</i> <code>,</code> <code>...</code><br>
</ul>
<br>
<i>parameter-list</i>:<br>
<ul>
  <i>parameter-declaration</i><br>
  <i>parameter-list</i> <code>,</code> <i>parameter-declaration</i><br>
</ul>
<br>
<i>parameter-declaration</i>:<br>
<ul>
  <font color=red><i>specifier-qualifier-list</i></font> <i>declarator</i><br>
  <font color=red><i>specifier-qualifier-list</i></font> <i>abstract-declarator<sub>opt</sub></i><br>
</ul>
<br>
<i>identifier-list</i>:<br>
<ul>
  <i>identifier</i><br>
  <i>identifier-list</i> <code>,</code> <i>identifier</i><br>
</ul>
<br>
<i>initializer</i>:<br>
<ul>
  <i>assignment-expression</i><br>
  <code>{</code> <i>initializer-list<font color=red><sub>opt</sub></font></i> <code>}</code><br>
  <code>{</code> <i>initializer-list</i> <code>,</code> <code>}</code><br>
</ul>
<br>
<i>initializer-list</i>:<br>
<ul>
  <i>designation<sub>opt</sub></i> <i>initializer</i><br>
  <i>initializer-list</i> <code>,</code> <i>designation<sub>opt</sub></i> <i>initializer</i><br>
</ul>
<br>
<i>designation</i>:<br>
<ul>
  <i>designator-list</i> <code>=</code><br>
</ul>
<br>
<i>designator-list</i>:
<ul>
  <i>designator</i><br>
  <i>designator-list</i> <i>designator</i><br>
</ul>
<br>
<i>designator</i>:
<ul>
  <code>[</code> <i>constant-expression</i> <code>]</code><br>
  <code>.</code> <i>identifier</i><br>
</ul>
<br>
<i>type-name</i>:<br>
<ul>
  <i>specifier-qualifier-list</i> <i>abstract-declarator<sub>opt</sub></i><br>
</ul>
<br>
<i>type-name-list</i>:<br>
<ul>
  <i>type-name</i><br>
  <i>type-name-list</i> <code>,</code> <i>type-name</i><br>
</ul>
<br>
<i>abstract-declarator</i>:<br>
<ul>
  <i>pointer</i><br>
  <i>pointer<sub>opt</sub></i> <i>direct-abstract-declarator</i><br>
</ul>
<br>
<font color=green>(We do not support C9X <code>[*]</code> direct-abstract-declarators.)</font><br>
<i>direct-abstract-declarator</i>:<br>
<ul>
  <code>(</code> <i>abstract-declarator</i> <code>)</code><br>
  <i>direct-abstract-declarator<sub>opt</sub></i> <code>[</code> <i>constant-expression<sub>opt</sub></i> <code>]</code><br>
  <i>direct-abstract-declarator<sub>opt</sub></i> <code>(</code> <i>parameter-type-list<sub>opt</sub></i> <code>)</code><br>
<font color=red>
  <i>direct-abstract-declarator<sub>opt</sub></i> <code>[</code> <code>?</code> <code>]</code><br>
  <i>direct-abstract-declarator</i> <code><</code> <i>type-name-list</i> <code>></code><br>
</font>
</ul>
<br>
<a name=statement></a>
<i>statement</i>:<br>
<ul>
  <i>labeled-statement</i><br>
  <i>expression-statement</i><br>
  <i>compound-statement</i><br>
  <i>selection-statement</i><br>
  <i>iteration-statement</i><br>
  <i>jump-statement</i><br>
<font color=red>
  <code>cut</code> <i>statement</i>
  &nbsp;&nbsp;&nbsp;<font color="#008000">// used for runtime code generation</font>
<br>
  <code>splice</code> <i>statement</i>
  &nbsp;&nbsp;&nbsp;<font color="#008000">// used for runtime code generation</font>
<br>
</font>
</ul>
<br>
<font color=green>
(We treat the 
<code>case</code> and <code>default</code> labels specially;
see <code>switch-clauses</code>)
</font><br>
<i>labeled-statement</i>:<br>
<ul>
  <i>identifier</i> <code>:</code> <i>statement</i><br>
</ul>
<br>
<i>expression-statement</i>:<br>
<ul>
  <i>expression<sub>opt</sub></i> <code>;</code><br>
</ul>
<br>
<i>compound-statement</i>:<br>
<ul>
  <code>{</code> <i>block-item-list<sub>opt</sub></i> <code>}</code><br>
</ul>
<br>
<i>block-item-list</i>:<br>
<ul>
  <i>block-item</i><br>
  <i>block-item</i> <i>block-item-list</i><br>
</ul>
<br>
<i>block-item</i>:<br>
<ul>
  <i>declaration</i><br>
  <i>statement</i><br>
</ul>
<br>
<i>selection-statement</i>:<br>
<ul>
  <code>if</code> <code>(</code> <i>expression</i> <code>)</code> <i>statement</i><br>
  <code>if</code> <code>(</code> <i>expression</i> <code>)</code> <i>statement</i> <code>else</code> <i>statement</i><br>
  <code>switch</code> <code>(</code> <i>expression</i> <code>)</code> <font color=red><code>{</code> <i>switch-clauses</i> <code>}</code></font><br>
<font color=red>
  <code>try</code> <i>statement</i> <code>catch</code> <code>{</code> <i>switch-clauses</i> <code>}</code><br>
</ul>
<br>
<i>switch-clauses</i>:<br>
<ul>
  <font color=green>(empty)</font><br>
  <code>default</code> <code>:</code> <i>block-item-list</i><br>
  <code>case</code> <i>pattern</i> <code>:</code> <i>block-item-list<sub>opt</sub></i> <i>switch-clauses</i><br>
  <code>case</code> <i>pattern</i> &nbsp; <code>&&</code> &nbsp; <i>expression</i> <code>:</code> <i>block-item-list<sub>opt</sub></i> <i>switch-clauses</i><br>
</font>
</ul>
<br>
<i>iteration-statement</i>:<br>
<ul>
  <code>while</code> <code>(</code> <i>expression</i> <code>)</code> <i>statement</i><br>
  <code>do</code> <i>statement</i> <code>while</code> <code>(</code> <i>expression</i> <code>)</code> <code>;</code><br>
  <code>for</code> <code>(</code> <i>expression<sub>opt</sub></i> <code>;</code> <i>expression<sub>opt</sub></i> <code>;</code> <i>expression<sub>opt</sub></i> <code>)</code> <i>statement</i><br>
  <code>for</code> <code>(</code> <i>declaration</i> <i>expression<sub>opt</sub></i> <code>;</code> <i>expression<sub>opt</sub></i> <code>)</code> <i>statement</i><br>
</ul>
<br>
<i>jump-statement</i>:<br>
<ul>
  <code>goto</code> <i>identifier</i> <code>;</code><br>
  <code>continue</code> <code>;</code><br>
  <code>break</code> <code>;</code><br>
  <code>return</code> <code>;</code><br>
  <code>return</code> <i>expression</i> <code>;</code><br>
  <code>
<font color=red>
  fallthru ;</font></code>
<font color=blue>
<br>
</font>

<font color="red"><code>fallthru ( <i>argument-expression-list</i> ) ;</code></font><br>
</ul>
<br>
<font color=red>
<a name=pattern></a>
<i>pattern</i>:<br>
<ul>
  <code><i>_</i></code>
  &nbsp;&nbsp;&nbsp;<font color="#008000">// wild card</font>
  <br>
  <code>(</code> <i>pattern</i> <code>)</code><br>
  <i>integer-constant</i><br>
  <code><i>-</i></code> <i>integer-constant</i><br>
  <i>floating-constant</i><br>
  <i>character-constant</i><br>
  <code>null</code><br>
  <i>identifier</i><br>
  <i>identifier</i> <i>type-params<sub>opt</sub></i> <code>(</code> <i>tuple-pattern-list</i> <code>)</code><br>
  <code>$</code> <code>(</code> <i>tuple-pattern-list</i> <code>)</code><br>

  <i>identifier</i> <i>type-params<sub>opt</sub></i> <code>{</code> <code>}</code><br>
  <i>identifier</i> <i>type-params<sub>opt</sub></i> <code>{</code> <i>field-pattern-list</i> <code>}</code><br>
  <code>&</code> <i>pattern</i><br>
  <code>*</code> <i>pattern</i><br>
</ul>
<br>
<i>tuple-pattern-list</i>:<br>
<ul>
  <font color=green>(empty)</font><br>
  <i>pattern</i><br>
  <i>tuple-pattern-list</i> <code>,</code> <i>pattern</i><br>
</ul>
<br>
<i>field-pattern-list</i>:<br>
<ul>
  <i>field-pattern</i><br>
  <i>field-pattern-list</i> <code>,</code> <i>field-pattern</i><br>
</ul>
<br>
<i>field-pattern</i>:<br>
<ul>
  <i>pattern</i><br>
  <i>designation</i> <i>pattern</i><br>
</ul>
</font>
<br>
<a name=expression></a>
<i>expression</i>:<br>
<ul>
  <i>assignment-expression</i><br>
  <i>expression</i> <code>,</code> <i>assignment-expression</i><br>
</ul>
<br>
<i>assignment-expression</i>:<br>
<ul>
  <i>conditional-expression</i><br>
  <i>unary-expression</i> <i>assignment-operator</i> <i>assignment-expression</i><br>
</ul>
<br>
<i>assignment-operator</i>: <font color=black>one of</font><br>
<ul>
  <code>=</code>
  <code>*=</code>
  <code>/=</code>
  <code>%=</code>
  <code>+=</code>
  <code>-=</code>
  <code><<=</code>
  <code>>>=</code>
  <code>&=</code>
  <code>^=</code>
  <code>|=</code><br>
</ul>
<br>
<i>conditional-expression</i>:<br>
<ul>
  <i>logical-or-expression</i><br>
  <i>logical-or-expression</i> <code>?</code> <i>expression</i> <code>:</code> <i>conditional-expression</i><br>
</ul>
<br>
<i>constant-expression</i>:<br>
<ul>
  <i>conditional-expression</i><br>
</ul>
<br>
<i>logical-or-expression</i>:<br>
<ul>
  <i>logical-and-expression</i><br>
  <i>logical-or-expression</i> <code>||</code> <i>logical-and-expression</i><br>
</ul>
<br>
<i>logical-and-expression</i>:<br>
<ul>
  <i>inclusive-or-expression</i><br>
  <i>logical-and-expression</i> <code>&&</code> <i>inclusive-or-expression</i><br>
</ul>
<br>
<i>inclusive-or-expression</i>:<br>
<ul>
  <i>exclusive-or-expression</i><br>
  <i>inclusive-or-expression</i> <code>|</code> <i>exclusive-or-expression</i><br>
</ul>
<br>
<i>exclusive-or-expression</i>:<br>
<ul>
  <i>and-expression</i><br>
  <i>exclusive-or-expression</i> <code>^</code> <i>and-expression</i><br>
</ul>
<br>
<i>and-expression</i>:<br>
<ul>
  <i>equality-expression</i><br>
  <i>and-expression</i> <code>&</code> <i>equality-expression</i><br>
</ul>
<br>
<i>equality-expression</i>:<br>
<ul>
  <i>relational-expression</i><br>
  <i>equality-expression</i> <code>==</code> <i>relational-expression</i><br>
  <i>equality-expression</i> <code>!=</code> <i>relational-expression</i><br>
</ul>
<br>
<i>relational-expression</i>:<br>
<ul>
  <i>shift-expression</i><br>
  <i>relational-expression</i> <code><</code> <i>shift-expression</i><br>
  <i>relational-expression</i> <code>></code> <i>shift-expression</i><br>
  <i>relational-expression</i> <code><=</code> <i>shift-expression</i><br>
  <i>relational-expression</i> <code>>=</code> <i>shift-expression</i><br>
</ul>
<br>
<i>shift-expression</i>:<br>
<ul>
  <i>additive-expression</i><br>
  <i>shift-expression</i> <code><<</code> <i>additive-expression</i><br>
  <i>shift-expression</i> <code>>></code> <i>additive-expression</i><br>
</ul>
<br>
<i>additive-expression</i>:<br>
<ul>
  <i>multiplicative-expression</i><br>
  <i>additive-expression</i> <code>+</code> <i>multiplicative-expression</i><br>
  <i>additive-expression</i> <code><i>-</i></code> <i>multiplicative-expression</i><br>
</ul>
<br>
<i>multiplicative-expression</i>:<br>
<ul>
  <i>cast-expression</i><br>
  <i>multiplicative-expression</i> <code>*</code> <i>cast-expression</i><br>
  <i>multiplicative-expression</i> <code>/</code> <i>cast-expression</i><br>
  <i>multiplicative-expression</i> <code>%</code> <i>cast-expression</i><br>
</ul>
<br>
<i>cast-expression</i>:<br>
<ul>
  <i>unary-expression</i><br>
  <code>(</code> <i>type-name</i> <code>)</code> <i>cast-expression</i><br>
</ul>
<br>
<i>unary-expression</i>:<br>
<ul>
  <i>postfix-expression</i><br>
  <code>++</code> <i>unary-expression</i><br>
  <code>--</code> <i>unary-expression</i><br>
  <i>unary-operator</i> <i>cast-expression</i><br>
  <code>sizeof</code> <i>unary-expression</i><br>
  <code>sizeof</code> <code>(</code> <i>type-name</i> <code>)<br>
  <font color="#FF0000"><code><i>expression</i> . size</code>
  &nbsp;&nbsp;&nbsp;<font color="#008000">// returns size of array</font>
  <br>
<font color=red>
  <code>raise</code> <i>unary-expression</i><br>
</ul>
</font>
<br>
<i>unary-operator</i>: <font color=black>one of</font><br>
<ul>
  <code>&</code>
  <code>*</code>
  <code>+</code>
  <code>-</code>
  <code>~</code>
  <code>!</code><br>
</ul>
<br>
<i>postfix-expression</i>:<br>
<ul>
  <i>primary-expression</i><br>
  <i>postfix-expression</i> <code>[</code> <i>expression</i> <code>]</code><br>
  <i>postfix-expression</i> <code>(</code> <code>)</code><br>
  <i>postfix-expression</i> <code>(</code> <i>argument-expression-list</i> <code>)</code><br>
  <i>postfix-expression</i> <code>.</code> <i>identifier</i><br>
  <i>postfix-expression</i> <code>-></code> <i>identifier</i><br>
  <i>postfix-expression</i> <code>++</code><br>
  <i>postfix-expression</i> <code>--</code><br>
 <code>( <i>type-name</i>  ) { <i>initializer-list</i>  }<br>
 ( <i>type-name</i>  ) { <i>initializer-list</i>  , }<br>
<font color=red>
  new { <i>initializer-list<sub>opt</sub></i>  }<br>
  new { <i>initializer-list</i>  , }<br>
  new { for <i>identifier</i>  < <i>expression</i>  : <i>expression</i>  }<br>
  fill ( <i>expression</i>  )<br>
  codegen ( <i>function-definition</i>  )<br>
</font>
</ul>
<br>
<i>primary-expression</i>:<br>
<ul>
  <i>identifier</i><br>
  <i>constant</i><br>
  <i>string</i><br>
  ( <i>expression</i>  )<br>
<font color=red>
  <i>identifier</i>  <><br>
  $ ( <i>argument-expression-list</i>  )<br>
  <i>identifier</i>  { <i>initializer-list</i>  }<br>
  ( { <i>block-item-list</i>  } )<br>
</font>
</ul>
<br>
<i>argument-expression-list</i>:<br>
<ul>
  <i>assignment-expression</i><br>
  <i>argument-expression-list</i>  , <i>assignment-expression</i><br>
</ul>
<br>
<i>constant</i>:<br>
<ul>
  <i>integer-constant</i><br>
  <i>character-constant</i><br>
  <i>floating-constant</i><br>
  <i>enumeration-constant</i><br>
<font color=red>
  null<br>
</font>
</ul>
</ul>

</body>

</html>
