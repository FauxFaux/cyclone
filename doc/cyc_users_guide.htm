<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<title>Cyclone Version 1</title>
</head>

<body>

<h1 align="center"><img border="0" src="cyclone.gif" width="50" height="46">Cyclone Version 1.0 User's Guide</h1>
<h2 align="center">Greg Morrisett</h2>
<h2 align="center">Cornell University</h2>
<p align="center">November, 2000</p>
<hr>
<h2 align="left">Table of Contents</h2>
<p align="left"><a href="#Goals of the Cyclone Project">Goals of the Cyclone
Project<br>
</a><a href="#Installing Cyclone">Installing Cyclone<br>
</a><a href="#Using Cyclone">Using Cyclone<br>
</a>&nbsp;&nbsp;&nbsp; <a href="#Hello World">Hello World<br>
</a><a href="#Quick Guide to Cyclone">Quick Overview<br>
</a>&nbsp;&nbsp;&nbsp; <a href="#Features Added">Features added<br>
</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#GCC and C-99 Additions:&nbsp;">GCC and C-99
    features</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <a href="#Namespaces">Namespaces</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <a href="#Tuples">Tuples</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <a href="#Pointers:">Pointers</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <a href="#Exceptions">Exceptions</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <a href="#Creating Arrays">Creating Arrays</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <a href="#Subtyping">Subtyping and Coercions</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <a href="#Datatype Enums:">Datatype Enums</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <a href="#Pattern Matching:">Pattern Matching</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <a href="#Let Declarations:">Let Declarations</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <a href="#Extensible Enums (xenums):">Extensible Enums</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <a href="#Polymorphic Functions:">Polymorphic Functions</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <a href="#Polymorphic Data Structures:">Polymorphic Data Structures</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <a href="#Abstract and Existential Types:">Abstract and Existential Types<br>
</a>&nbsp;&nbsp;&nbsp; <a href="#Restrictions">Restrictions<br>
</a><a href="#The Grammar of Cyclone">Annotated Grammar<br>
</a>The Standard Library</p>
<hr>
<h2><a name="Goals of the Cyclone Project">
    Goals of the Cyclone Project</a>
</h2>
<p>
Cyclone is a programming language that has been designed with two
goals in mind:
</p>
<ol>
  <li><b>Safety</b> --- ideally, there should be no way to write a
    Cyclone program that crashes (i.e., has a core dump, segmentation
    fault or bus error, blue screen of death, and so on).  Safety also
    rules out things like buffer overflows and format string attacks
    (which can lead to crashes).  To achieve safety, Cyclone uses a
    combination of static type checking, extended static checking,
    dynamic checking, and specially prepared libraries.</li>

  <li><b>Support as much of C as possible</b> --- Cyclone should share as much
    with C as possible, including syntax, static semantics, data
    representations, calling conventions, and dynamic semantics.&nbsp; 
    This rule should only be violated when in direct conflict with the 
    first goal of supporting safety.</li>
</ol>

<p>
The intended user of Cyclone is someone who is either (a) writing
systems code, or (b) needs to port C code to a safe environment.&nbsp;
Though languages such as Java, ML, or Scheme are safe, they do not
give the control over data representations, memory management, calling
conventions, etc., that C does.&nbsp; Hence, they are often unsuitable
for building systems where performance and control matter.&nbsp; For
instance, no one suggests building a run-time system in these
languages.  Furthermore, today's implementations of these languages
make it relatively difficult to interface with legacy code written in
C, or to incrementally move program units from C to the safe
setting.&nbsp; The goals of Cyclone are aimed at making it easier to
build systems software without sacrificing safety or
control.&nbsp;&nbsp;
</p>

<p>
Of course, the two goals above are in direct conflict and thus we also see
Cyclone as a driver for new research into safe, low-level languages.&nbsp; For
instance, right now, Cyclone supports a fairly rich form of stack allocation
based on the Tofte-Talpin region type system.  This ensures that you never
try to access a stack-allocated object outside of the lifetime of the object.
However, all heap-allocated memory in Cyclone is reclaimed via (conservative)
garbage collection.&nbsp; This is safe, but prevents systems programmers
from using Cyclone for latency-critical or space-sensitive applications.&nbsp;
One of the big research goals of Cyclone is to introduce new typing
abstractions, such as linear types or regions, that support programmer control
over heap memory management without sacrificing safety.
</p>

<p>
You might wonder what is the difference between the Cyclone project
and a few other projects, notably 
<a href="http://lclint.cs.virginia.edu">LCLint</a> out of MIT and Virginia, 
the Extended Static
Checking (ESC) project out of Compaq SRC, and the 
<a href="http://www.cs.wisc.edu/~austin/scc.html">Safe-C</a> project
from the University of Wisconsin.    
These are good systems and we have great respect for the
work that has gone into them.  But their goals are quite different
from Cyclone and we view our work as somewhat overlapping, but
mostly complimentary.  
</p>
<p>
Though we are interested in finding and eliminating bugs, we also want
to <i>guarantee</i> a certain level of safety.  LCLint can't provide
such a guarantee, because the underlying language (C) and associated
static analyses are unsound (i.e., some bugs will not be caught).  The
reason for this is that without changing C, it is extremely difficult
to guarantee safety without a lot of extra runtime overhead, or a lot
of false positives in your static analysis.  LCLint is aimed at being
a practical tool for debugging C code, and as such, makes compromises
to eliminate false positives, but at the expense of soundness.  Thus,
LCLint can't be used in settings where security is a concern.
</p>
<p>
ESC is similar in some ways to LCLint, but is built on top of Java.
(A previous version was built on top of Modula-3).
Since Java and Modula-3 are type-safe, there is a fundamental safety
guarantee provided by the ESC system.  And in addition, one gets
the extra (really amazing) bug-finding power of ESC.  However,
as we argued above, many systems programming tasks cannot be
coded in languages such as Java (or Modula-3) or at least can't
be coded efficiently.  In addition, it is difficult to move legacy
code written in C to these environments.
</p>
<p>
Consequently, we see the ESC and LCLint projects as complimentary
to the Cyclone project.  Ideally, after Cyclone reaches a stable
design point, we should be able to put an "ESC/Cyclone" or "LCLint/Cyclone"
static debugging tool together.
</p>
<p>
The Safe-C project out of Wisconsin is perhaps the closest in
spirit to ours, in that they are attempting to provide a memory-safety
guarantee.  However, the approach taken by Safe-C is quite different
than Cyclone:  Programs continue to be written in C, but extra indirections
and dynamic checks are inserted to ensure that abstractions are
respected.  For example, pointers in Safe-C are actually rather
complex data structures, and dereferencing a pointer is an expensive
operation as a number of checks must be done to ensure that the
pointer is still valid.  In order to avoid some of these overheads,
the Wisconsin folks apply sophisticated, automatic analyses.  
</p>
<p>
The advantage of Safe-C is that, in principle, programs can be
compiled and run with no modification by the programmer.  The
disadvantages are that (a) there is still a great deal of space and
time overhead for programs, (b) the data representations change
radically.  As such, the whole system (e.g., the standard libraries)
has to be recompiled and pieces of code cannot be migrated from C to
Safe-C.  In contrast, Cyclone goes to great lengths to preserve
the data representations so that Cyclone and C code can smoothly
interoperate.  Furthermore, many more checks are performed statically
in Cyclone.  The downside is that programmers have to change the
code (typically, by modifying or adding more typing information),
and they can't always write what they want.  Our research is aimed
at eliminating these drawbacks and to compare against the Safe-C
approach.
</p>

<p>
Obviously, Cyclone is a work in progress.  The people involved now
are at Cornell and AT&amp;T.&nbsp;
In particular, Trevor Jim and I have worked out most of the initial
design and implementation.&nbsp; Dan Grossman is working on version
2.0 of the system which should add support for a number of other
features and clean up the type-checker considerably.&nbsp; Fred Smith,
Dave Walker, and Stephanie Weirich have contributed greatly through
discussions, if not code.&nbsp; Jeff Vinocur, Nathan Lutchansky,
Matthew Harris, Kate Oliver, and Hubert Chao have also made many 
valuable contributions.  Many of the ideas contained within
Cyclone are derived from our previous experience and work on the
Popcorn safe-C language and the Typed Assembly Language
project.&nbsp;&nbsp;
</p>
<hr>
<h2><a name="Installing Cyclone">Installing Cyclone</a></h2>
<p>
Cyclone currently only runs on 32-bit machines, and has only been tested on
Win32 and Linux platforms.&nbsp; Other platforms might or might not work.&nbsp;
There are definitely 32-bit dependencies, so the system will not work on a
64-bit machine without major surgery.&nbsp; To install and use Cyclone, you'll
need to use the Gnu utilities, including GCC (the Gnu C compiler) and
Gnu-Make.&nbsp; For Win32, you should first install the latest version of the 
<a href="http://cygwin.com/">Cygwin</a>
utilities to do the build, and make sure that the Cygwin bin directory is on
your path.
</p>

<p>
The file cyclone.zip (or cyclone.tar.gz) contains all of the files that you
need to build and install the system.&nbsp; After unzipping the file into a
directory, you should have a directory structure that looks like this:
</p>
<pre>
cyclone/
     bin/
        genfiles/
             lib/
             src/
     doc/
     gc/
     lib/
     src/
     tests/
     tools/
         cycbison/
         cyclex/
</pre>
<p>
There is a Makefile at the top-level.&nbsp; To build the system, change into
the Cyclone directory, and then type &quot;make&quot;.&nbsp; This should 
produce files cycbison.exe, cyclex.exe, cyclib.a, cyclone.exe, and 
gc.a appropriate for your architecture, and place them in the bin/ directory.&nbsp; (<i>Note:&nbsp; someone should get rid of the silly &quot;.exe&quot;'s 
for Unix platforms.)</i>&nbsp; The cyclone executable is the compiler which 
translates Cyclone code into GCC code.&nbsp; The cycbison executable is a 
version of Gnu's Bison parser generator which emits Cyclone code for 
parsing.&nbsp; The cyclex executable is a version of the Ocaml lexer 
generator which emits Cyclone code for lexing.&nbsp; The gc.a
library is the Boehm-Demers-Weiser garbage collector.&nbsp; And cyclib.a is a
library of pre-built Cyclone functions.&nbsp; After building the system, 
you may want to add the bin/ directory to your path (and possibly the lib 
directory to your include path.)
</p>

<p>The cycbison utility is written in C (soon to be ported to Cyclone) and its
source is in the tools/cycbison/ sub-directory.&nbsp; The BDW garbage collector
is also written in C and can be found in the gc/ directory (this was obtained
directly from<a href="http://www.hpl.hp.com/personal/Hans_Boehm/gc/"> Hans Boehm's GC page</a>.)&nbsp;
The rest of the code is written in Cyclone.&nbsp; However, the directory bin/genfiles
contains the C code that the Cyclone compiler produces when run on itself.&nbsp;
This is what allows you to build the initial executable.&nbsp;&nbsp;</p>
<p>Once you've built the compiler from the C courses, you can use it to compile
the Cyclone code in lib/, src/, tests/, or tools/cyclex.&nbsp; To do so, simply
type &quot;make cyclone_src&quot;.&nbsp; This will use the Cyclone compiler to
compile all of the files in these directories and place the resulting
executables in the appropriate directory.&nbsp; (It will <i>not</i> overwrite
the binaries in the bin/ directory.)&nbsp; If you want to make a change to the
compiler and then start using the change, you can type &quot;make update&quot;
which will update the genfiles/ with any different C files that you
generated.&nbsp; Then you can type &quot;make cyclone&quot; to bootstrap with
the new code.</p>
<hr>
<h2><a name="Using Cyclone">Using Cyclone</a></h2>
<p>Once you've successfully installed Cyclone, you can use it to compile Cyclone
programs to C, and then use GCC to compile the resulting code to machine
code.&nbsp; Typically, if one wants to compile the file foo.cyc to an object
file foo.o, one would write:</p>
<pre>  cyclone -tc -toc -pp -o foo.c foo.cyc 
  gcc -c foo.c</pre>
<p>The &quot;tc&quot; flag tells Cyclone to type-check the code, the &quot;toc&quot;
flag tells it to translate the code to C, and the &quot;pp&quot; flag says to
pretty print the resulting C code.  The output is directed via the
&quot;-o&quot; flag to the file foo.c.&nbsp;  (When no output is specified
it is sent to standard out.)&nbsp;  In the example above,
this would type-check foo.cyc, translate it to C, and then print the output to
foo.c.&nbsp; Then we invoke GCC to compile the foo.c file to foo.o</p>
<p>Note that Cyclone runs the C pre-processor on the file before actually
compiling it (just as with C).&nbsp;&nbsp;</p>
<p>The cyclone compiler takes the following command line arguments:</p>
<ul>
  <li>-I <i>dir</i>:&nbsp; add <i>dir</i> to the search path for #include files
    (as in C)</li>
  <li>-o <i>file</i> :&nbsp; print the output to <i>file</i></li>
  <li>-tc:&nbsp; type-check the input code</li>
  <li>-toc:&nbsp; translate the input code to C</li>
  <li>-pp: pretty-print the code</li>
  <li>-up: ugly-print the code</li>
  <li>-D <i>defn</i>: pass a definition to the pre-processor (as in C)</li>
  <li>-check_null:&nbsp; generate explicit tests for null (currently broken)</li>
  <li>-noexpandtypedefs:&nbsp; do not expand type-defs during pretty-printing</li>
  <li>-q:&nbsp; quiet (do not print &quot;Compiling file: foo.....&quot; progress indicator; prints nothing unless error)</li>
  <li>-v:&nbsp; verbose (replace the progress indicator with verbose listing of each stage) -- this overrides -q</li>
  <li>-noremoveunused: don't remove extern variables that aren't used</li>
  <li>-nocyc: don't add the implicit Cyc:: namespace to the generated code</li>
</ul>
<p>We expect to put a more realistic front-end driver on Cyclone so that it will
look just like a C compiler (and transparently invoke GCC for you.)&nbsp; Note
that if you simply pass -tc and -pp to cyclone, then it will type-check the code
and pretty-print it without translating to C.&nbsp; Note also that translation
to C requires the -toc flag.&nbsp;&nbsp;</p>
<p>The output of Cyclone includes the file &quot;cyc_include.h&quot; in the
top-level directory, so make sure it's accessible when you invoke GCC on the
resulting code.&nbsp;&nbsp;</p>

<hr>
<h2><a name="Hello World">Hello World</a></h2>
<p>As a simple example of Cyclone, here is the canonical &quot;Hello&quot; world
program:</p>
<pre>  <font color="#008000">#include</font> &quot;<font color="#0000FF">core.h</font>&quot;  
  <font color="#008000">#include</font> &quot;<font color="#0000FF">stdio.h</font>&quot;  </pre>
<pre>  <b>using</b> Core;
  <b>using</b> Stdio;

  
  int <b>main</b>() {
    <font color="#FF0000"><i>// Get the command line arguments as an array of strings.
    // The first string is the name of the program.</i></font>
    string ?args = std_args();  
   
    <i><font color="#FF0000">// if there was no argument to the program, raise an error.</font></i>
    <b>if</b> (args.size &lt;= 1) 
      <b>throw</b> Failure(&quot;<font color="#0000FF">missing name!</font>&quot;);
    <b>else</b>
      <b>printf</b>(&quot;<font color="#0000FF">Hello, %s.\n</font>&quot;,args[1]);
  }
  </pre>

<p>There are a few things to note about the example:&nbsp; First,
Cyclone uses the C-Preprocessor, hence the #include lines.&nbsp; The
file core.h can be found in the lib/ directory and includes a number
of core definitions that just about any Cyclone compilation unit will
need.&nbsp; The stdio.h file is a port of the C standard library
version of stdio and in this case, is needed to support the printf.
The declaration &quot;using Core;&quot; opens up the Core
namespace to make the operations in Core immediately available to the
following code.&nbsp; Similarly, opening Stdio makes those definitions
in Stdio available.  The declaration &quot;int main() {
... }&quot; declares the &quot;main&quot; function for the Cyclone
program, which takes no arguments and returns an integer result.&nbsp; 

<p>The first line of the main function declares a variable
&quot;args&quot; to be a checked pointer to an array of strings
(written &quot;string ?&quot;.)  The &quot;?&quot; type constructor is
similar to &quot;*&quot; in C in that it supports subscripting,
dereferencing, pointer arithmetic, etc.  However, all dereferences are
checked to ensure that the current pointer value is in range.  The
representation of a &quot;?&quot; pointer is different from the
representation of a normal pointer, as extra information is needed to
support the bounds check.

<p>
The declaration on the first line also initializes args by calling the
function std_args() which is part of the Core namespace.&nbsp; After
initializing args, the function checks to see if the size (in terms of
the number of elements in the array) of args is less than or equal to
1.&nbsp; If so, a failure is signalled by throwing the Failure
exception (with an argument string reading &quot;missing
name!&quot;).&nbsp; Otherwise, the program prints to standard output
&quot;Hello &lt;name&gt;&quot; where &lt;name&gt; is the first
argument to the program.&nbsp;&nbsp;</p> 

<p>The file tests/hello.cyc
contains the code above.&nbsp; If you change into the tests directory,
then you can compile the file to C by typing:</p> 

<pre> cyclone -I ../lib -tc -toc -pp hello.cyc &gt; hello.c</pre> 

<p>(This assumes that you have the bin directory on your path.)&nbsp;
This should produce the file hello.c.&nbsp; You can look at the C code
to see what it looks like.&nbsp; Most of it is definitions that are
imported from core.h.&nbsp; The part that corresponds to the Cyclone
code will be found at the bottom. The code is pretty similar to the
Cyclone code except that you can see that there is extra gunk that
corresponds to an array bounds check, and extra gunk to deal with the
checked pointers, etc.</p>

<p>After generating hello.c, you can use GCC to
compile it to an executable.&nbsp; To do so, you need to make sure
that the file cyc_include.h is accessible, and to link against the
cyclib.a and gclib.a libraries.&nbsp; Here's an example of this:</p>

<pre> gcc -I .. -o hello.exe hello.c ..\bin\cyclib.a ..\bin\gc.a</pre>

<p>This will produce an executable program hello.exe.&nbsp; Typing
&quot;hello&quot; under Win32 (&quot;hello.exe&quot; resp. under Unix)
will yield &quot;Uncaught exception Core_Failure&quot;.&nbsp; Typing
&quot;hello Fred&quot; will yield &quot;Hello,
Fred.&quot;&nbsp;&nbsp;</p> 

<p>To write real, standalone Cyclone applications, your best bet is
to follow the Makefile examples in the directories.&nbsp; For
instance, the Makefile in tests/ builds an application cyctest.exe
which we've used during development to test various features. At a
minimum, you'll need to link against the cyclib.a and gc.a libraries
in the bin/ directory.&nbsp;&nbsp;</p>

<hr>
<h2><a name="Quick Guide to Cyclone">Quick Overview of the
Language</a></h2> <p>C programmers should find it fairly easy to get
up to speed in Cyclone.&nbsp; In particular, the syntax and primitive
types are lifted directly from ISO C, and, wherever possible, we try
to follow its static and dynamic semantics.&nbsp; Nonetheless, there
are a number of additions and restrictions that you need to know in
order to use the language effectively.</p> <p>We'll begin by going
over the new features that Cyclone adds to C.&nbsp; Then we'll go over
the common idioms that Cyclone prohibits, and see how these can be
coded using the new facilities.</p>
<hr>
<h2><a name="Features Added">Features Added</a></h2>
<p>Cyclone adds a number of features to C, ranging from convenient expression
forms, to advanced typing constructs.&nbsp; For instance, Cyclone includes many
of the GCC and C-99 extensions that make writing code a bit
easier.&nbsp; Variables need not be declared at the top of a block, a
declaration can appear within a for-statement, expressions can have statements
nested inside them, etc.&nbsp; Cyclone also adds support for ML or Haskell-style
algebraic datatypes and pattern matching.&nbsp; Datatypes can seriously lift the
level of abstraction for code, and pattern matching can be an effective tool for
ensuring that all cases in a tricky test are covered.&nbsp;&nbsp;</p>
<p>In addition, Cyclone adds advanced typing support in the form of (a)
parametric polymorphism, (b) structural subtyping, (c) some unification-based,
local-type inference.&nbsp; These features are necessary to type-check or port a
number of (potentially) unsafe C idioms, usually involving &quot;void*&quot; or
the like.&nbsp; Similarly, datatypes can be used to code around many of the uses
for C's union types -- another potential source of unsoundness.&nbsp; Cyclone
also adds new support for checked pointer arithmetic and ensures that all 
pointer accesses are to valid objects.&nbsp; Again, these features are 
aimed at making it easy to port C code to Cyclone.</p>

<p>In what follows, we give a brief overview of these added
features.&nbsp;&nbsp;</p>
<hr>
<h4><a name="GCC and C-99 Additions:&nbsp;">GCC and C-99 Additions:&nbsp;</a></h4>
<p>
GCC and the <a
href="http://web.onetelnet.ch/~twolf/tw/c/c9x_changes.html">ISO C-99
standard</a> have some useful new features that we have adopted for
Cyclone.  Some of the ones that we current support:</p>
<ul>
  <li>Statement expressions: There is a new expression form,
    <code>({<i>statement</i> <i>expression</i>})</code>.
    The <i>statement</i> is executed first, then the <i>expression</i>,
    and the value of the entire expression is the value of
    <i>expression</i></li>
  <li>Struct expressions:&nbsp; If you've declared <code>struct
    point{int x; int y;};</code> then you can write
    <code>point{.x=<i>expression, </i>.y=<i>expression</i>}</code> 
    to allocate and initialize a <code>struct point</code></li>
  <li>// comments as in Java or C++</li>
  <li>Trailing comma allowed in enum declarations.&nbsp; Also, you can use
    semi-colons instead of commas.</li>
  <li>Declarations can appear in any statement position.&nbsp; It is not
    necessary to wrap braces around the declaration of a local variable.</li>
  <li>For-statements can include a declaration. For instance:&nbsp; <code><b>for</b>(int
    x=0; x &lt; n; x++) { ... }</code></li>
</ul>
<p>We expect to follow the C-99 standard fairly closely.&nbsp;&nbsp;</p>
<hr>
<h4><a name="Namespaces">Namespaces</a>:&nbsp;&nbsp;</h4>
<p>As in C++, namespaces are used to avoid name clashes in code.&nbsp; For
example:&nbsp;</p>
<pre><code><b>    namespace</b> Foo { 
      int x = 0; 
      int f() { <b>return</b> x; }<i> 
    </i>}</code></pre>
<p>declares an integer named <code>Foo::x</code> and a
function named <code>Foo::f</code>.&nbsp; Note that within
the namespace, you don't need to use the qualified name.&nbsp; For instance, <code>Foo::f</code> refers to <code>Foo::x</code> as simply <code>x</code>.&nbsp;
We could also simply write &quot;<code><b>namespace</b> Foo;</code>&quot;
(note the trailing semi-colon) and leave out the enclosing braces.&nbsp; Every
declaration following this namespace declaration would be placed in the <code>Foo</code>
namespace.&nbsp;&nbsp;</p>
<p>As noted before, you can refer to elements of a namespace using the
&quot;::&quot; notation.&nbsp; Alternatively, you can open up a namespace with a
&quot;using&quot; declaration.&nbsp;
For example, we could follow the above code with:</p>
<pre>    <b>namespace </b>Bar {
      <b>using </b>Foo {
        int g() { <b>return</b> f(); }
      }
      int h() { <b>return</b> Foo::f(); }
    }</pre>
<p>Here, we opened the <code>Foo</code> namespace within the
definition of <code>Bar::g</code>.&nbsp; One can also write
&quot;<code><b>using Foo;</b></code>&quot;
to open a namespace for the remaining definitions in the current block.</p>
<p>Namespaces can nest as in C++.&nbsp;&nbsp;</p>
<p>Currently, namespaces are only supported at the top-level and you can't
declare a qualified variable directly.&nbsp; Rather, you have to write a
namespace declaration to encapsulate it.&nbsp;&nbsp;</p>
<hr>
<h4><a name="Tuples">Tuples</a>:</h4>
<p>Tuples are like lightweight structs.&nbsp; They need not be declared in
advance, and have member or field names that are implicitly 0, 1, 2, 3,
etc.&nbsp; For example, the following code declares x to be a 3-tuple of an
integer, a character, and a boolean, initialized with the values 42, 'z', and
true respectively.&nbsp; It then checks to see whether the third component in
the tuple is true (it is) and if so, increments the first component in the tuple.</p>
<pre>   $(int,char,bool) x = $(42,'z',<b>true</b>)

   <b>if</b> (x[2]) 
     x[0]++;</pre>
<p>The above code would be roughly equivalent to writing:</p>
<pre>   <b>struct </b>{int f0; char f1; bool f2;} x = {42,'z',<b>true</b>};</pre>
<pre>   <b>if</b> (x.f2)
     x.f1++;</pre>
<p>Thus, tuple types are written $(<i>type1,...,typen</i>), tuple constructor
expressions are written $(<i>exp1,...,expn</i>), and extracting the ith
component of a tuple is written using subscript notation <i>exp[i-1]</i>.&nbsp;
Note that, consistent with the rest of C, the members start with 0, not 1.&nbsp;
</p>

<p>Unlike structs, tuple types are treated equivalent as long as they are
structurally equivalent.&nbsp; As in C, struct types are equivalent only if they
have the same <i>tag</i> or name.&nbsp; (Note that in C, all struct declarations
have a tag, even if the compiler has to gensym one.)&nbsp;&nbsp;</p>
<hr>
<h4><a name="Pointers:">Pointers:</a></h4>
<p>There are three different pointer types in Cyclone, written
&quot;t*&quot;, &quot;t@&quot;, and &quot;t?&quot;.  Actually,
pointers are quite a bit more complicated than this, but these
are the pointer types that you'll most likely use the most.

<p>A value of type
t* is a possibly null pointer to a value of type t.  When
these values are dereferenced, a null-check is performed and an exception
is raised if the value is actually null.  To ensure statically that
a pointer cannot be null, you can use the type t@ instead.
Dereferencing these pointers requires no run-time overhead and will
not raise an exception. Pointer arithmetic and subscripting (except for 0)
are not supported for values of type t* or t@
(but see below). Both kinds of pointers are represented the same way
as C pointers.</p>

<p>In general, one can write &quot;t*{e}&quot; to describe a pointer to
an array of t values with e elements, where e is a constant expression.
For instance, the following code is permissible:</p>

<pre>
int x[5] = {0,1,2,3,4};
int *{5}p = x;
</pre>

<p>Here, we've said that p is a (possibly null) pointer to an array of
five integers.  When a pointer has type t*{e}, then it
is permissible to use subscripts in the range 0 to e-1 to access the
elements of p.  Note that t* is short hand for
t*{1} (and similarly t@ is short hand for t@{1}).

<p>A value of type t? is a checked pointer to a (possibly empty)
array of values of type t.  Unlike * or @ pointers, checked pointers
support arbitrary pointer arithmetic (following the rules of C), 
arbitrary integer subscripts, etc.  However, each access is checked to
ensure that the pointer is within the bounds of the original underlying
array.  </p>

<p>Values of type t*{e} or t@{e} or t[e] can be cast to type t? to support
pointer arithmetic.  Furthermore, values of type t? can be cast to
type t*{e} or t@{e}, but this requires a run-time check to ensure
that the corresponding array slice is in bounds.  </p>

<p>Obviously, checked pointers require more information that * or @
pointers, so that we can determine whether the access is in bounds.
Consequently, checked pointers are larger than normal pointers.
(The current implementation uses three words for each checked pointer.)
However, one rarely needs checked pointers unless you're performing
lots of pointer arithmetic.  In subsequent releases, we hope to
support checked but untagged representations for these pointers
using technology from dependent type theory.  
</p>

<p>Finally, we should note that in fact all pointers in Cyclone
point into a <i>region</i>.  By default, if you don't mention a
region, then the pointer points into the disgtinguished heap
region (written `H).  Pointers to stack-allocated objects
live in regions that are private to the enclosing scope.  
More on this later...
</p>


<hr>
<h4><a name="Exceptions">Exceptions</a>:</h4>
<p>Cyclone provides exceptions, <code>throw</code>, and <code>
try</code>/<code>catch</code> statements similar to
Java.&nbsp; (We'll probably add support for finally clauses at some
point.)&nbsp; This is one way to avoid the error-prone and type-unsafe approach in C of
returning a value (e.g., -1) to indicate an error.&nbsp; (An alternative way is to return a possibly-null pointer, or an appropritate enum value.)&nbsp;  Exception values are a special case of
extensible datatype enums (xenums) described below.&nbsp; The following example
shows how to declare a couple of exceptions, how to throw an exception, and how
to catch an exception:</p>
<pre>  <b>xenum </b>exn { NotFound(string); }  <i><font color="#FF0000">// NotFound takes a string as an argument</font></i>
  <b>xenum </b>exn { Foo; }              <i><font color="#FF0000"> // Foo takes no arguments</font></i></pre>
<pre>  <b>void </b>bar() {
    <b>if</b> (coin_toss()) 
      <b>throw</b> Foo;
    <b>else</b> <b>if</b> (!lookup(&quot;<font color="#0000FF">friday</font>&quot;))
      <b>throw</b> NotFound(&quot;<font color="#0000FF">friday isn't here</font>&quot;);
  }</pre>
<pre>  <b>void</b> foo() {
    <b>try</b> {
      bar();
    } <b>catch</b> {
    <b>case</b> NotFound(s):  <b>fprintf</b>(stderr, &quot;<font color="#0000FF">not found: %s\n</font>&quot;,s); <b>break</b>;
    <b>case</b> Foo: <b>fprintf</b>(stderr, &quot;<font color="#0000FF">foo raised!\n</font>&quot;); <b>break</b>;
    }
    <b>printf</b>(&quot;<font color="#0000FF">no exception raised.\n</font>&quot;);
  }</pre>
<hr>
<h4><a name="Creating Arrays">Creating Arrays</a>:</h4>

<p>There are about four ways to create arrays in Cyclone.  One
can always declare an array and provide an initializer as in C.
For instance:</p>
<pre>
  int foo[8] = {1,2,3,4,5,6,7,8};
  char s[4] = &quot;bar&quot;;
</pre>
<p>are both examples from C for creating arrays.  Note that Cyclone
follows C's conventions here, so that if you declare arrays as above
within a function, then the lifetime of the array coincides with the
activation record of the enclosing scope.  In other words, such arrays
will be stack allocated.</p>

<p>To create heap-allocated arrays (or strings) within a Cyclone
function, you should either use &quot;new&quot; operator with
either an array initializer or an array comprehension.  The
following code demonstrates this:</p>
<pre> 
  int *{8}foo = new {1,2,3,4,5,6,7,8}; <font color="#FF0000"><i>// foo is a pointer to a heap-allocated array</i></font>
  char ?s = new "bar"; <font color="#FF0000"><i>// s is a checked pointer to a heap-allocated string</i></font>
  int @{100}evens = <b>new</b> {<b>for</b> i &lt; 100 : 2*i}; <font color="#FF0000"><i>// a non-null pointer to the first 100 even numbers</i></font>
</pre>

<hr>
<h4><a name="Subtyping">Subtyping</a>:</h4>
<p>Cyclone supports &quot;extension on the right&quot; and &quot;covariant depth
on const&quot; subtyping for pointers.&nbsp; This simply means that you can cast
a value x from having a type "pointer to a struct with 10 fields", to "pointer to a struct having
only the first 5 fields".&nbsp; For example, if we have the following
definitions:
<pre>
  <b>typedef</b> <b>struct</b> Point {float x,y;} *point;

  <b>typedef</b> <b>struct</b> CPoint {float x,y; int color;} *cpoint;

  float xcoord(point p) {
    <b>return</b> p->x;
  }
</pre>
then you can call xcoord with either a point or cpoint object.  

You can also cast a pointer to a tuple having 3
fields (e.g., $(int,bool,double)*) to a pointer to a tuple having only 
2 fields (e.g., $(int,bool)*).&nbsp; 
In other words, you can forget
about the &quot;tail&quot; of the object.&nbsp; This allows a degree of
polymorphism that is useful when porting C code.&nbsp; In addition, you can do
&quot;deep&quot; casts on pointer fields that are const.&nbsp; (It is unsound to
allow deep casts on non-const fields.)&nbsp; Also, you can cast a field from
being non-const to being const.&nbsp; You can also cast a constant-sized array
to an equivalent pointer to a struct or tuple.&nbsp; In short, Cyclone attempts
to allow you to cast one type to another as long as it is safe.&nbsp; Note,
however, that these casts must be explicit.</p>
<p>We expect to add more support for subtyping in the future (e.g., subtyping on
function pointers, bounded subtyping, etc.)</p>
<hr>
<h4><a name="Datatype Enums:">Datatype Enums:</a></h4>
<p>Enums in Cyclone are more like datatypes in ML.&nbsp; In particular, they can
be used to build algebraic or inductively defined structures, such a lists,
trees, graphs, etc.&nbsp; For instance, the following enum declarations give a
way to construct abstract syntax trees for a simple calculator language:</p>
<pre>  <b>enum </b>operator { Plus, Times, Minus, Divide }</pre>
<pre>  <b>enum </b>absyn {
    Integer(int);
    Term(<b>enum</b> absyn, <b>enum</b> operator, <b>enum</b> absyn);
  }</pre>
<pre>  <b>enum </b>absyn e1 = Term(Integer(3),Plus,Integer(4));
  <b>enum </b>absyn e2 = Term(e1,Times,Integer(5));</pre>
<p>The operator definition is like a normal enum -- it just defines symbolic
constants for Plus, Times, Minus, and Divide.&nbsp; The absyn definition defines
an inductive tree-like data type for abstract syntax.&nbsp; The Integer
constructor takes an int argument and returns an absyn value.&nbsp; The Term
constructor takes an abstract syntax tree, an operator, and an abstract syntax
tree and returns a new abstract syntax tree.&nbsp; So, for example, e1 is a tree
representing the term &quot;3 + 4&quot; while e2 is a tree representing the term
&quot;(3 + 4) * 5&quot;.&nbsp;&nbsp;</p>
<p>Internally, enum constructors are either represented as an integer value (as
with Plus, Times, Minus, and Divide) or a pointer to an object containing a <i>tag</i>
and the arguments to the constructor.&nbsp; The object is always allocated on
the heap.&nbsp; To traverse the tree, we use pattern matching, again in the
style of functional languages such as ML or Haskell.</p>
<p>Why did we choose to extend enums instead of adding a datatype declaration (a
la ML)?&nbsp; We wanted to minimize the number of keywords that we added to the
language, so adding an explicit datatype declaration and keyword was not seen as
desirable.&nbsp; In addition, enums already provided primitive symbolic
names.&nbsp;&nbsp;</p>
<p>In the future, we plan to make the representation of enums explicit and to
allow programmers to control tag placement and do explicit tests on the tag to
refine the type of an object in a more traditional, data-flow fashion.&nbsp; We
will probably keep the enum construct as is for convenience.</p>
<hr>
<h4><a name="Pattern Matching:">Pattern Matching:</a></h4>
<p>Pattern matching in Cyclone generalizes the switch construct of C allowing
you to not only test integral values, but also to test structured values such as
the abstract syntax trees above.&nbsp; For example, the following function takes
in an abstract syntax tree and prints the tree to stdout:</p>
<pre>  <b>void</b> print_absyn(<b>enum</b> absyn tree) {
     <b>switch</b> (tree) {
     <b>case</b> Integer(i)       : <b>printf</b>(&quot;<font color="#0000FF">%d</font>&quot;,i); <b>break</b>;
     <b>case</b> Term(t1,Plus,t2) : <b>printf</b>(&quot;<font color="#0000FF">(</font>&quot;; print_absyn(t1); 
                             <b>printf</b>(&quot;<font color="#0000FF">+</font>&quot;); 
                             print_absyn(t2); <b>printf</b>(&quot;<font color="#0000FF">)</font>&quot;); <b>break</b>;
     <b>case</b> Term(t1,Times,t2): <b>printf</b>(&quot;<font color="#0000FF">(</font>&quot;; print_absyn(t1); 
                             <b>printf</b>(&quot;<font color="#0000FF">*</font>&quot;); 
                             print_absyn(t2); <b>printf</b>(&quot;<font color="#0000FF">)</font>&quot;); <b>break</b>;
     <b>case</b> Term(t1,Minus,t2): <b>printf</b>(&quot;<font color="#0000FF">(</font>&quot;; print_absyn(t1); 
                             <b>printf</b>(&quot;<font color="#0000FF">-</font>&quot;);
                             print_absyn(t2); <b>printf</b>(&quot;<font color="#0000FF">)</font>&quot;); <b>break</b>;
     <b>case</b> Term(t1,Divide,t2):<b>printf</b>(&quot;<font color="#0000FF">(</font>&quot;; print_absyn(t1); 
                             <b>printf</b>(&quot;<font color="#0000FF">/</font>&quot;);
                             print_absyn(t2); <b>printf</b>(&quot;<font color="#0000FF">)</font>&quot;); <b>break</b>;
  }</pre>
<p>Note that patterns introduce and initialize new variables local to a given
case.&nbsp; For instance, in the Integer case above, the pattern variable i is
introduced and is initialized to whatever value is carried by the Integer
constructor.&nbsp; Thus, i is available for use on the right-hand-side of the
case.&nbsp; You can pattern match on just about any kind of value, and
destructure it.&nbsp; For instance, you can pattern match on tuples, structs,
pointers to tuples/structs, etc.&nbsp; See the grammar for the syntax of the
various pattern forms.</p>
<p>The type-checker for Cyclone is much more picky about switch statements than
C.&nbsp; In particular, it will check that all of the patterns you have are
exhaustive (or else there's a default: clause) and that none of the patterns
overlap.&nbsp; This is useful for evolving code.&nbsp; For instance, if we added
a new operator (say Mod), then the compiler would complain that the switch in
print_absyn doesn't cover all possible cases (namely the case where we have a
term involving the Mod operator.)&nbsp;&nbsp;</p>
<p>In addition, the Cyclone type-checker makes sure that you don't accidentally
fall-through from one case to another.&nbsp; In particular, if you don't put in
explicit breaks, returns, throws, etc., then the compiler will reject the
code.&nbsp; You can still fall through to the next case, but you have to do it
with an explicit &quot;fallthru&quot; statement.&nbsp; If the case pattern
doesn't bind any new variables, then you just write &quot;fallthru;&quot; as the
last thing in the case.&nbsp; If you want to fallthru to a case that defines new
variables, then you need to give values for those variables.&nbsp; For instance,
in the following code:</p>
<pre>
  <b>void</b> foo(<b>enum</b> absyn tree) {
     <b>switch</b> (tree) {
     <b>case</b> Integer(i)       : printf(&quot;<font color="#0000FF">%d </font>&quot;,i); <b>break</b>;
     <b>case</b> Term(t1,Plus,t2) : printf(&quot;<font color="#0000FF">It's a plus \n</font>&quot;); <b>fallthru</b>(t2,Plus,t1);
     <b>case</b> Term(t1,op,t2)   : foo(t1); foo(t2); <b>break</b>;
  }</pre>
<p>if we pass it a tree Term(Integer(3),Plus,Integer(4)) then we will see
&quot;It's a plus 4 3 &quot;, but if we pass it
Term(Integer(3),Times,Integer(4)) we will see &quot;3 4 &quot;.</p>
<hr>
<h4><a name="Let Declarations:">Let Declarations:</a></h4>
<p>Sometimes, it's painful to declare a variable because you have to write down
its type.&nbsp; Cyclone includes some limited support for type inference using
let declarations.&nbsp; In particular, you can write:</p>
<pre>  int foo(int x) {
    <b>let</b> y = x+3;
    <b>let</b> z = 3.14159;
    <b>return</b> (int)(y*z);
  }</pre>
<p>&nbsp;Here, we declared two variables y and z using &quot;let&quot;.&nbsp;
When you use let, you don't have to write down the type of the variable.&nbsp;
Rather, the compiler infers the type from the expression that initializes the
variable.&nbsp; More generally, you can write &quot;let <i>pattern </i>= <i>exp</i>;&quot;
to destructure a value into a bunch of variables.&nbsp; For instance, if you
pass a tuple to a function, then you can extract the components as follows:</p>
<pre>  int sum($(int,int,int) args) {
    <b>let</b> $(x,y,z) = args;
    <b>return</b> (x+y+z);
  }</pre>
<hr>
<h4><a name="Extensible Enums (xenums):">Extensible Enums (xenums):</a></h4>
<p>Extensible enums (xenums) are just like enums except that you can add new
constructors anytime you want.&nbsp; Thus, enums are &quot;closed world&quot;
datatypes, whereas xenums are &quot;open world&quot; datatypes.&nbsp; Both are
useful.&nbsp; For instance, with a close world representation of abstract syntax
trees, when we write a function such as print_absyn, we can be sure that we've
covered all of the cases.&nbsp; However, if we want an extensible setting, where
programmers are adding new kinds of nodes all the time, then it's useful to use
xenums.&nbsp; Right now, we really only use xenums in the parser (for various
semantic values) and for exceptions.&nbsp; We might add better subtyping support
for them so that you can extend them depth-wise as well as
width-wise.&nbsp;&nbsp;</p>
<hr>
<h4><a name="Polymorphic Functions:">Polymorphic Functions:</a></h4>
<p>As mentioned above, Cyclone supports a limited amount of subtyping
polymorphism.&nbsp; It also supports a fairly powerful form of parametric
polymorphism.&nbsp; Those of you coming from ML or Haskell will find this
familiar.&nbsp; Those of you coming from C++ will also find it somewhat
familiar.&nbsp; The basic idea is that you can write one function that abstracts
the types of some of the values it manipulates.&nbsp; For instance, consider the
following two functions:</p>
<pre>  $(string,int) swap1($(int,string) x) {
     <b>return</b> $(x[1], x[0]);
  }</pre>
<pre>  $(int,int) swap2($(int,int) x) {
     <b>return</b> $(x[1], x[0]);
  }</pre>
<p>The two functions are quite similar:&nbsp; They both take in a pair (i.e., a
2-tuple) and return a pair with the components swapped.&nbsp; At the
machine-level, the code for these two functions will be exactly the same,
assuming that ints and strings (char *) are represented the same way.&nbsp; So
it seems silly to write the code twice.&nbsp; Normally, a C programmer would
replace the definition with simply:</p>
<pre>  $(void *,void *) swap1($(void *,void *) x) {
     <b>return</b> $(x[1], x[0]);
  }</pre>
<p>(assuming you added tuples to C).&nbsp; But of course, this isn't type-safe
because once I cast the values to void *, then I can't be sure what type I'm
getting out.&nbsp; In Cyclone, you can instead write something like this:</p>
<pre>  $(`b,`a) swap&lt;`a,`b&gt;($(`a,`b) x) {
     <b>return </b>$(x[1],x[0]);
  }</pre>
<p>The code is the same, but it abstracts what the types are.&nbsp; The extra
parameters &lt;`a,`b&gt; are type variables that can be instantiated with any <i>word-sized,
general-purpose register </i>type.&nbsp; So, for instance, you can call swap on
pairs of integers, pairs of pointers, pairs of an integer and a pointer, etc.:</p>
<pre>  <b>let</b> $(x,y) = swap($(&quot;<font color="#0000FF">hello</font>&quot;,3));  <font color="#FF0000"><i>// x is 3, y is hello</i></font>
  <b>let</b> $(w,z) = swap($(4,3));        <i><font color="#FF0000">// w is 3, z is 4</font></i></pre>
<p>Note that when calling a polymorphic function, you need not tell it what
types you're using to instantiate the type variables.&nbsp; Rather, Cyclone
figures this out through unification.&nbsp;&nbsp;</p>
<p>C++ supports similar functionality with templates.&nbsp; However, C++ and
Cyclone differ considerably in their implementation strategies.&nbsp; First,
Cyclone only produces one copy of the code, whereas a C++ template is
specialized and duplicated at each type that it is used.&nbsp; This approach
requires that you include definitions of templates in interfaces and thus
defeats separate compilation.&nbsp; However, the approach used by Cyclone does
have its drawbacks:&nbsp; In particular, the only types that can instantiate
type variables are those that can be treated uniformly.&nbsp; This ensures that
we can use the same code for different types.&nbsp; The general rule is that
values of the types that instantiate a type variable must fit into a machine
word and must be passed in general-purpose (as opposed to floating-point)
registers.&nbsp; Examples of such types include int, pointer, enum, and xenum
types.&nbsp; Other types, including char, short, long long, float,
double, struct, and tuple types violate this rule and thus values of
these types cannot be passed to a
function like swap in place of the type variables.
In practice, this means that you tend to manipulate a lot of pointers in
Cyclone code.&nbsp; </p>
<p>The combination of parametric polymorphism and sub-typing means that you can
cover a lot of C idioms where void* or unsafe casts were used without
sacrificing type-safety.&nbsp; We use polymorphism a lot when coding in
Cyclone.&nbsp; For instance, the standard library includes many container
abstractions (lists, sets, queues, etc.) that are all polymorphic in the element
type.&nbsp; This allows us to re-use a lot of code.&nbsp; In addition, unlike
C++, those libraries can be compiled once and need not be specialized.&nbsp; On
the downside, this style of polymorphism does not allow you to do any
type-specific things (e.g., overloading or ad-hoc polymorphism.)&nbsp; Someday,
we may add support for this, but in the short run, we're happy not to have
it.&nbsp;</p>
<hr>
<h4><a name="Polymorphic Data Structures:">Polymorphic Data Structures:</a></h4>
<p>Just as function definitions can be parameterized by types, so can struct
definitions, enum definitions, and even typedefs.&nbsp; For instance, the
following struct definition is used in the standard library for lists:</p>
<pre>  <b>struct</b> cons&lt;`a&gt; {`a hd; <b>struct</b> cons&lt;`a&gt; *tl; };
  <b>typedef</b> <b>struct</b> cons&lt;`a&gt; *list&lt;`a&gt;;</pre>
<p>Here, we've declared a struct cons parameterized by a type `a.&nbsp; The hd
field contains an element of type `a and the tl field contains a (possibly null)
pointer to a struct cons with elements of type `a.&nbsp; We then define
list&lt;`a&gt; as an abbreviation for struct cons&lt;`a&gt;*.&nbsp; So, for
instance, we can declare both integer and string lists like this:</p>
<pre>  list&lt;int&gt; ilist = &amp;cons{1,&amp;cons{2,null}};
  list&lt;string&gt; slist = &amp;cons{.hd=&quot;<font color="#0000FF">foo</font>&quot;,.tl=&amp;cons{&quot;<font color="#0000FF">bar</font>&quot;,null}};</pre>
<p>Note that we use &quot;&amp;&quot; like &quot;new&quot; in C++ to allocate a
new struct cons on the heap and return a pointer to the resulting (initialized)
cons object.&nbsp; Note also that the field designator (&quot;.hd&quot;,
&quot;.tl&quot;) are optional.</p>
<p>Once you have polymorphic data structures, you can write lots of useful
polymorphic code and use it over and over again.&nbsp; For instance, the
standard list library includes functions for mapping over a list, looking up
items in a list, concatenating two lists, copying lists, sorting lists,
etc.&nbsp;&nbsp;</p>
<hr>
<h4><a name="Abstract and Existential Types:">Abstract and Existential Types:</a></h4>
<p>Suppose you want to declare an abstract type for implementing stacks.&nbsp;
In Cyclone, the way this is accomplished is by declaring a struct that
encapsulates the implementation type, and by adding the &quot;abstract&quot;
qualifier to the struct definition.&nbsp; For instance, if we write:</p>
<pre>  <b>abstract </b><b>struct</b> Queue&lt;`a&gt; { list&lt;`a&gt; front, rear; };</pre>
<p>then this declares a polymorphic Queue implementation that is abstract.&nbsp;
The definition of the struct is available within the unit that declares the
Queue, but will not be made available to the outside world.&nbsp; (This will be
enforced by a link-time type-checker which we are currently putting
together.)&nbsp; Typically, the provider of the Queue abstraction would write in
an interface file:</p>
<pre>  <b>extern struct </b>Queue&lt;`a&gt;;</pre>
<p>The abstract keyword in the implementation ensures that the definition does
not leak to a client.&nbsp; One can also declare enums to be abstract, though I
find it more useful to always use a struct to encapsulate the enum, and make the
enum static, and the struct abstract.&nbsp; That way, clients are always given
an abstract struct to manipulate.&nbsp;&nbsp;</p>
<p>Typedefs cannot be made abstract.&nbsp; As in C, typedefs are type
abbreviations and are expanded at compile time.&nbsp; If we chose to make them
(potentially) abstract, then we'd have to enforce a &quot;boxedness&quot;
restriction, similar to the restrictions on type variables.&nbsp; To simplify
the language, we chose to make structs abstract.&nbsp;&nbsp;</p>
<p>It's also possible to code up &quot;first-class&quot; abstract data types
using enums or xenums.&nbsp; Individual [x]enum constructors can be
parameterized by additional type variables that are local to the
type-constructor.&nbsp; (From a type-theoretic point of view, these are
existentially-quantified variables.)&nbsp; I won't bother to say a lot more
about these here, except that the approach used is quite similar to the
treatment of existential types in Haskell.&nbsp; In particular, pattern matching
one of these constructors requires you to introduce explicit type variables into
which the actual types are &quot;unpacked&quot;.&nbsp; These variables are
treated abstractly in the body of a case.&nbsp; However, when creating one of
the values, it is not necessary to explicitly &quot;pack&quot; the types to be
abstracted.&nbsp; Rather, the types are discovered through unification.&nbsp;
For an example of the use of existential types, see the fn.h and fn.cyc files in
the standard library which implement first-class closures.</p>
<hr>
<h2><a name="Restrictions">Restrictions</a></h2>
<ul>
  <li>Cyclone requires every function to declare a return type
    (the implicit <tt>int</tt> for the return type of a function
    is removed).</li>
  <li>Cyclone requires the format argument of the printf functions to
    be a string constant.  This is so that we can statically protect
    against format string attacks.
    <i>(We should support dynamic checks too!)</i>
    </li>
  <li>Cyclone does not allow user-defined vararg functions.
    <i>(We should support this too.)</i></li>
  <li>Cyclone does not permit some of the casts that are allowed in C.
    Incorrect casts in C can lead to crashes.</li>
  <li>Cyclone does not support pointer arithmetic on <tt>*</tt> or
    <tt>@</tt>; pointers.    Pointer arithmetic is not unsafe in
    itself, but it can lead to unsafe code when the resulting pointer
    is assigned or dereferenced.</li>
  <li>Cyclone inserts a NULL check when a <tt>*</tt> pointer
    is dereferenced and it cannot determine statically that the
    pointer is not NULL.  This prevents segmentation faults.</li>
  <li>Cyclone requires any function that is supposed to return a
    non-<tt>void</tt> value to execute a <tt>return</tt>
    statement on every possible execution path.  This is needed to
    ensure that the value returned from the function has the right type,
    and is not just a random value left in a register or on the stack.</li>
  <li>Cyclone does not currently support <tt>malloc</tt>.
  <i>(But this is coming soon!)</i>.  Instead we have a variety of
    mechanisms for safely allocating, initializing, and reclaiming memory.</li>
  <li>Cyclone performs a static analysis to ensure that every variable
    is initialized before it is used.  This prevents a random stack
    value from being used improperly.</li>
  <li>Cyclone does not permit <tt>goto</tt>s from one scope into another.
    C warns against this practice, as it can cause crashes; Cyclone
    rules it out entirely.</li>
  <li>Cyclone places some limitations on the form of
    <tt>switch</tt> statements that rule out crashes like those
    caused by unrestricted <tt>goto</tt>.</li>
  <li>Cyclone places some restrictions on <tt>union</tt>s for
    safety reasons.  <i>(In fact we currently rule them out entirely,
    but we should support them soon.)</i></li>
  <li>Cyclone places some restrictions on linking for safety reasons.</li>
  <li>Cyclone requires that every case in a <tt>switch</tt>
    explicitly <tt>fallthru</tt> or <tt>break</tt>.</li>
  <li>Cyclone has some new keywords (<tt>let</tt>,
    <tt>abstract</tt>, etc.) that can no longer be used as identifiers.</li>
</ul>

<hr>
<h2><a name="The Grammar of Cyclone">The Grammar of Cyclone</a></h2>

Cyclone's grammar is derived from the latest ISO C standard, C99.
Changes from and additions to the C99 grammar are noted in red.  The
start symbol is <i>translation-unit</i>.
<p>

<b>Quick links:</b>
<a href=#declaration><i>declaration</i></a>,
<a href=#struct-or-union-specifier><i>struct-or-union-specifier</i></a>,
<a href=#enum-specifier><i>enum-specifier</i></a>,
<a href=#declarator><i>declarator</i></a>,
<a href=#statement><i>statement</i></a>,
<a href=#pattern><i>pattern</i></a>,
<a href=#expression><i>expression</i></a>

<p>
&nbsp;
<font color=blue>
<ul>
<i>translation-unit</i>:<br>
<ul>
  <i>external-declaration</i> <i>translation-unit<sub>opt</sub></i><br>
<font color=red>
  <code>using</code> <i>identifier</i> <code>;</code> <i>translation-unit</i></font></font><font color="red"><i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</i></font><font color="#008000">// open namespace <i>identifier </i>within <i>translation-unit&nbsp;</i></font>
<font color=blue>
<font color=red>
  <br>
</font>
</font><font color="#FF0000">
  <code>namespace</code> <i>identifier</i> <code>;</code> <i>translation-unit&nbsp;&nbsp;&nbsp;
  </i></font><font color="#008000">// encapsulate <i>translation-unit </i>within
namespace <i>identifier</i></font>
<font color=blue>
<font color=red>
  <br>
</font></font><font color="#FF0000">
  <code>using</code> <i>identifier</i> <code>{</code> <i>translation-unit</i> <code>}</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</font><font color="#008000">// open namespace <i>identifier </i>within <i>translation-unit</i></font>
<font color=blue>
<font color=red>
  <br>
</font></font><font color="#FF0000">
  <code>namespace</code> <i>identifier</i> <code>{</code> <i>translation-unit</i> <code>}</code>
 </font>
<font color="#008000">
// encapsulate <i>translation-unit </i>within namespace <i>identifier</i></font>
<font color=blue>
<font color=red>
  <br>
</font>
</ul>
<br>
<i>external-declaration</i>:<br>
<ul>
  <i>function-definition</i><br>
  <i>declaration</i><br>
</ul>
<br>
<i>function-definition</i>:<br>
<ul>
  <i>declaration-specifiers<sub>opt</sub></i> <i>declarator</i> <i>declaration-list<sub>opt</sub></i> <i>compound-statement</i><br>
</ul>
<br>
<a name=declaration></a>
<i>declaration</i>:<br>
<ul>
  <i>declaration-specifiers</i> <i>init-declarator-list<sub>opt</sub></i> <code>;</code><br>
<font color=red>
  <code>let</code> <i>pattern</i> <code>=</code> <i>expression</i> <code>;</code></font></font><code><font color="red">&nbsp;
</font></code><font color="#008000">// match <i>expression </i>against <i>pattern </i>and declare pattern variables</font>
<font color=blue>
<font color=red>
  <br>
</font>
</ul>
<br>
<i>declaration-list</i>:<br>
<ul>
  <i>declaration</i><br>
  <i>declaration-list</i> <i>declaration</i><br>
</ul>
<br>
<i>declaration-specifiers</i>:<br>
<ul>
  <i>storage-class-specifier</i> <i>declaration-specifiers<sub>opt</sub></i><br>
  <i>type-specifier</i> <i>declaration-specifiers<sub>opt</sub></i><br>
  <i>type-qualifier</i> <i>declaration-specifiers<sub>opt</sub></i><br>
  <i>function-specifier</i> <i>declaration-specifiers<sub>opt</sub></i><br>
</ul>
<br>
<i>storage-class-specifier</i>: <font color=black>one of</font><br>
<ul>
  <code>auto</code>
  <code>register</code>
  <code>static</code>
  <code>extern</code>
  <code>typedef</code><br>
<font color=red>
  <code>abstract</code> &nbsp;&nbsp;&nbsp;<font color="#008000">// makes struct or enum declarations abstract </font>
</font>
<br>
</ul>
<br>
<font color=green>
(The C99 type-specifiers
<code>_Complex</code>, and
<code>_Imaginary</code>
are not yet supported)
</font><br>
<i>type-specifier</i>: <font color=black>one of</font><br>
<ul>
  <code>void</code>
  <code>char</code>
  <code>short</code>
  <code>int</code>
  <code>long</code>
  <code>float</code>
  <code>double</code>
  <code>signed</code><br>
  <code>unsigned</code>
  <i>struct-or-union-specifier</i>
  <i>enum-specifier</i><br>
  <i>typedef-name</i> <font color=red><i>type-params<sub>opt</sub></i></font>
  <br> 
  <font color=red>
  <i>type-var</i>
  <br>
  <code>$</code> <code>(</code> <i>parameter-list</i> <code>)</code>
  &nbsp;&nbsp;&nbsp;<font color="#008000">// tuple types</font><br>
</font>
</ul>
<br>
<i>type-qualifier</i>: <font color=black>one of</font><br>
<ul>
  <code>const</code>
  <code>restrict</code>
  <code>volatile</code><br>
</ul>
<br>
<i>function-specifier</i>:
<ul>
  <code>inline</code><br>
</ul>
<br>
<a name=struct-or-union-specifier></a>
<i>struct-or-union-specifier</i>:<br>
<ul>
  <i>struct-or-union</i> <code>{</code> <i>struct-declaration-list</i> <code>}</code><br>
  <i>struct-or-union</i> <i>identifier</i> <font color=red><i>type-params<sub>opt</sub></i></font> <code>{</code> <i>struct-declaration-list</i> <code>}</code><br>
  <i>struct-or-union</i> <i>identifier</i> <font color=red><i>type-params<sub>opt</sub></i></font><br>
</ul>
<br>
<font color=red>
<i>type-params</i>:<br>
<ul>
  <code><</code> <i>type-name-list</i> <code>></code><br>
</ul>
</font>
<br>
<i>struct-or-union</i>: <font color=black>one of</font><br>
<ul>
  <code>struct</code>
  <code>union</code><br>
</ul>
<br>
<i>struct-declaration-list</i>:<br>
<ul>
  <i>struct-declaration</i><br>
  <i>struct-declaration-list</i> <i>struct-declaration</i><br>
</ul>
<br>
<i>init-declarator-list</i>:<br>
<ul>
  <i>init-declarator</i><br>
  <i>init-declarator-list</i> <code>,</code> <i>init-declarator</i><br>
</ul>
<br>
<i>init-declarator</i>:<br>
<ul>
  <i>declarator</i><br>
  <i>declarator</i> <code>=</code> <i>initializer</i><br>
</ul>
<br>
<i>struct-declaration</i>:<br>
<ul>
  <i>specifier-qualifier-list</i> <i>struct-declarator-list</i> <code>;</code><br>
</ul>
<br>
<i>specifier-qualifier-list</i>:<br>
<ul>
  <i>type-specifier</i> <i>specifier-qualifier-list<sub>opt</sub></i><br>
  <i>type-qualifier</i> <i>specifier-qualifier-list<sub>opt</sub></i><br>
</ul>
<br>
<i>struct-declarator-list</i>:<br>
<ul>
  <i>struct-declarator</i><br>
  <i>struct-declarator-list</i> <code>,</code> <i>struct-declarator</i><br>
</ul>
<br>
<i>struct-declarator</i>:<br>
<ul>
  <i>declarator</i><br>
  <i>declarator<sub>opt</sub></i> <code>:</code> <i>constant-expression</i><br>
</ul>
<br>
<a name=enum-specifier></a>
<i>enum-specifier</i>:<br>
<ul>
  <code>enum</code> <code>{</code> <i>enumerator-list</i> <code>}</code><br>
  <code>enum</code> <i>identifier</i> <font color=red><i>type-params<sub>opt</sub></i></font> <code>{</code> <i>enumerator-list</i> <code>}</code><br>
  <code>enum</code> <i>identifier</i> <font color=red><i>type-params<sub>opt</sub></i></font><br>
<font color=red>
  <code>xenum</code> <i>identifier</i> <code>{</code> <i>enumerator-list</i> <code>}</code><br>
  <code>xenum</code> <i>identifier</i><br>
</font>
</ul>
<br>
<i>enumerator-list</i>:<br>
<ul>
<font color=red>
  <i>enumerator</i><br>
  <i>enumerator</i> <code>,</code> <i>enumerator-list</i><br>
  <i>enumerator</i> <code>;</code><br>
  <i>enumerator</i> <code>;</code> <i>enumerator-list</i><br>
</font>
</ul>
<br>
<i>enumerator</i>:<br>
<ul>
  <i>identifier</i><br>
  <i>identifier</i> <code>=</code> <i>constant-expression</i><br>
<font color=red>
  <i>identifier</i> <code>(</code> <i>parameter-list</i> <code>)</code>
  &nbsp;&nbsp;&nbsp;<font color="#008000">
  // datatype constructor </font>
  <br>
</font>
</ul>
<br>
<a name=declarator></a>
<i>declarator</i>:<br>
<ul>
  <i>pointer<sub>opt</sub></i> <i>direct-declarator</i><br>
</ul>
<br>
<font color=green>(We do not support C99 <code>[*]</code> direct-declarators.)</font><br>
<i>direct-declarator</i>:<br>
<ul>
  <i>identifier</i><br>
  <code>(</code> <i>declarator</i> <code>)</code><br>
  <i>direct-declarator</i> <code>[</code> <i>constant-expression<sub>opt</sub></i> <code>]</code><br>
  <i>direct-declarator</i> <code>(</code> <i>parameter-type-list</i> <code>)</code><br>
  <i>direct-declarator</i> <code>(</code> <i>identifier-list<sub>opt</sub></i> <code>)</code><br>
<font color=red>
  <i>direct-declarator</i> <code><</code> <i>type-name-list</i> <code>></code><br>
</font>
</ul>
<br>
<i>pointer</i>:<br>
<ul>
<font color=red>
  <code>*</code>&nbsp; <i>range<sub>opt</sub></i> <i>region<sub>opt</sub></i> &nbsp;<i>type-qualifier-list<sub>opt</sub></i> <i>pointer<sub>opt</sub></i>
</font><br>
<font color=red>
  <code>@</code>&nbsp; <i>range<sub>opt</sub></i> <i>region<sub>opt</sub></i> &nbsp;<i>type-qualifier-list<sub>opt</sub></i> <i>pointer<sub>opt</sub></i>
  &nbsp;&nbsp;&nbsp;<font color="#008000">// non-null pointers</font><br>
<font color=red>
  <code>?</code>&nbsp; <i>region<sub>opt</sub></i>&nbsp; <i>type-qualifier-list<sub>opt</sub></i> <i>pointer<sub>opt</sub></i>
  &nbsp;&nbsp;&nbsp;<font color="#008000">// checked pointers</font>
<br>
</font>
</font>
</ul>
<br>
<font color=red>
<i>range</i>:<br>
<ul>
<code>{</code> &nbsp; <i>constant-expression</i> &nbsp; <code>}</code> <br>
</ul>
</font>

<br>
<font color=red>
<i>region</i>:<br>
<ul>
<code>_</code> 
&nbsp;&nbsp;&nbsp;<font color=green>// wildcard region </font><br>
<i>'H</i> 
&nbsp;&nbsp;&nbsp;<font color=green>// heap region (default)</font><br>
<i>type-var</i>
&nbsp;&nbsp;&nbsp;<font color=green>// region variable</font><br>
</ul>
</font>

<br>
<i>type-qualifier-list</i>:<br>
<ul>
  <i>type-qualifier</i><br>
  <i>type-qualifier-list</i> <i>type-qualifier</i><br>
</ul>
<br>
<i>parameter-type-list</i>:<br>
<ul>
  <i>parameter-list</i><br>
  <i>parameter-list</i> <code>,</code> <code>...</code><br>
</ul>
<br>
<i>parameter-list</i>:<br>
<ul>
  <i>parameter-declaration</i><br>
  <i>parameter-list</i> <code>,</code> <i>parameter-declaration</i><br>
</ul>
<br>
<i>parameter-declaration</i>:<br>
<ul>
  <font color=red><i>specifier-qualifier-list</i></font> <i>declarator</i><br>
  <font color=red><i>specifier-qualifier-list</i></font> <i>abstract-declarator<sub>opt</sub></i><br>
</ul>
<br>
<i>identifier-list</i>:<br>
<ul>
  <i>identifier</i><br>
  <i>identifier-list</i> <code>,</code> <i>identifier</i><br>
</ul>
<br>
<i>initializer</i>:<br>
<ul>
  <i>assignment-expression</i><br>
  <code>{</code> <i>initializer-list<font color=red><sub>opt</sub></font></i> <code>}</code><br>
  <code>{</code> <i>initializer-list</i> <code>,</code> <code>}</code><br>
</ul>
<br>
<i>initializer-list</i>:<br>
<ul>
  <i>designation<sub>opt</sub></i> <i>initializer</i><br>
  <i>initializer-list</i> <code>,</code> <i>designation<sub>opt</sub></i> <i>initializer</i><br>
</ul>
<br>
<i>designation</i>:<br>
<ul>
  <i>designator-list</i> <code>=</code><br>
</ul>
<br>
<i>designator-list</i>:
<ul>
  <i>designator</i><br>
  <i>designator-list</i> <i>designator</i><br>
</ul>
<br>
<i>designator</i>:
<ul>
  <code>[</code> <i>constant-expression</i> <code>]</code><br>
  <code>.</code> <i>identifier</i><br>
</ul>
<br>
<i>type-name</i>:<br>
<ul>
  <i>specifier-qualifier-list</i> <i>abstract-declarator<sub>opt</sub></i><br>
</ul>
<br>
<i>type-name-list</i>:<br>
<ul>
  <i>type-name</i><br>
  <i>type-name-list</i> <code>,</code> <i>type-name</i><br>
</ul>
<br>
<i>abstract-declarator</i>:<br>
<ul>
  <i>pointer</i><br>
  <i>pointer<sub>opt</sub></i> <i>direct-abstract-declarator</i><br>
</ul>
<br>
<font color=green>(We do not support C99 <code>[*]</code> direct-abstract-declarators.)</font><br>
<i>direct-abstract-declarator</i>:<br>
<ul>
  <code>(</code> <i>abstract-declarator</i> <code>)</code><br>
  <i>direct-abstract-declarator<sub>opt</sub></i> <code>[</code> <i>constant-expression<sub>opt</sub></i> <code>]</code><br>
  <i>direct-abstract-declarator<sub>opt</sub></i> <code>(</code> <i>parameter-type-list<sub>opt</sub></i> <code>)</code><br>
<font color=red>
  <i>direct-abstract-declarator<sub>opt</sub></i> <code>[</code> <code>?</code> <code>]</code><br>
  <i>direct-abstract-declarator</i> <code><</code> <i>type-name-list</i> <code>></code><br>
</font>
</ul>
<br>
<a name=statement></a>
<i>statement</i>:<br>
<ul>
  <i>labeled-statement</i><br>
  <i>expression-statement</i><br>
  <i>compound-statement</i><br>
  <i>selection-statement</i><br>
  <i>iteration-statement</i><br>
  <i>jump-statement</i><br>
<font color=red>
  <code>cut</code> <i>statement</i>
  &nbsp;&nbsp;&nbsp;<font color="#008000">// used for runtime code generation</font>
<br>
  <code>splice</code> <i>statement</i>
  &nbsp;&nbsp;&nbsp;<font color="#008000">// used for runtime code generation</font>
<br>
</font>
</ul>
<br>
<font color=green>
(We treat the 
<code>case</code> and <code>default</code> labels specially;
see <code>switch-clauses</code>)
</font><br>
<i>labeled-statement</i>:<br>
<ul>
  <i>identifier</i> <code>:</code> <i>statement</i><br>
</ul>
<br>
<i>expression-statement</i>:<br>
<ul>
  <i>expression<sub>opt</sub></i> <code>;</code><br>
</ul>
<br>
<i>compound-statement</i>:<br>
<ul>
  <code>{</code> <i>block-item-list<sub>opt</sub></i> <code>}</code><br>
</ul>
<br>
<i>block-item-list</i>:<br>
<ul>
  <i>block-item</i><br>
  <i>block-item</i> <i>block-item-list</i><br>
</ul>
<br>
<i>block-item</i>:<br>
<ul>
  <i>declaration</i><br>
  <i>statement</i><br>
</ul>
<br>
<i>selection-statement</i>:<br>
<ul>
  <code>if</code> <code>(</code> <i>expression</i> <code>)</code> <i>statement</i><br>
  <code>if</code> <code>(</code> <i>expression</i> <code>)</code> <i>statement</i> <code>else</code> <i>statement</i><br>
  <code>switch</code> <code>(</code> <i>expression</i> <code>)</code> <font color=red><code>{</code> <i>switch-clauses</i> <code>}</code></font><br>
<font color=red>
  <code>try</code> <i>statement</i> <code>catch</code> <code>{</code> <i>switch-clauses</i> <code>}</code><br>
</ul>
<br>
<i>switch-clauses</i>:<br>
<ul>
  <font color=green>(empty)</font><br>
  <code>default</code> <code>:</code> <i>block-item-list</i><br>
  <code>case</code> <i>pattern</i> <code>:</code> <i>block-item-list<sub>opt</sub></i> <i>switch-clauses</i><br>
  <code>case</code> <i>pattern</i> &nbsp; <code>&&</code> &nbsp; <i>expression</i> <code>:</code> <i>block-item-list<sub>opt</sub></i> <i>switch-clauses</i><br>
</font>
</ul>
<br>
<i>iteration-statement</i>:<br>
<ul>
  <code>while</code> <code>(</code> <i>expression</i> <code>)</code> <i>statement</i><br>
  <code>do</code> <i>statement</i> <code>while</code> <code>(</code> <i>expression</i> <code>)</code> <code>;</code><br>
  <code>for</code> <code>(</code> <i>expression<sub>opt</sub></i> <code>;</code> <i>expression<sub>opt</sub></i> <code>;</code> <i>expression<sub>opt</sub></i> <code>)</code> <i>statement</i><br>
  <code>for</code> <code>(</code> <i>declaration</i> <i>expression<sub>opt</sub></i> <code>;</code> <i>expression<sub>opt</sub></i> <code>)</code> <i>statement</i><br>
</ul>
<br>
<i>jump-statement</i>:<br>
<ul>
  <code>goto</code> <i>identifier</i> <code>;</code><br>
  <code>continue</code> <code>;</code><br>
  <code>break</code> <code>;</code><br>
  <code>return</code> <code>;</code><br>
  <code>return</code> <i>expression</i> <code>;</code><br>
  <code>
<font color=red>
  fallthru ;</font></code>
<font color=blue>
<br>
</font>

<font color="red"><code>fallthru ( <i>argument-expression-list</i> ) ;</code></font><br>
</ul>
<br>
<font color=red>
<a name=pattern></a>
<i>pattern</i>:<br>
<ul>
  <code><i>_</i></code>
  &nbsp;&nbsp;&nbsp;<font color="#008000">// wild card</font>
  <br>
  <code>(</code> <i>pattern</i> <code>)</code><br>
  <i>integer-constant</i><br>
  <code><i>-</i></code> <i>integer-constant</i><br>
  <i>floating-constant</i><br>
  <i>character-constant</i><br>
  <code>null</code><br>
  <i>identifier</i><br>
  <i>identifier</i> <i>type-params<sub>opt</sub></i> <code>(</code> <i>tuple-pattern-list</i> <code>)</code><br>
  <code>$</code> <code>(</code> <i>tuple-pattern-list</i> <code>)</code><br>

  <i>identifier</i> <i>type-params<sub>opt</sub></i> <code>{</code> <code>}</code><br>
  <i>identifier</i> <i>type-params<sub>opt</sub></i> <code>{</code> <i>field-pattern-list</i> <code>}</code><br>
  <code>&</code> <i>pattern</i><br>
  <code>*</code> <i>pattern</i><br>
</ul>
<br>
<i>tuple-pattern-list</i>:<br>
<ul>
  <font color=green>(empty)</font><br>
  <i>pattern</i><br>
  <i>tuple-pattern-list</i> <code>,</code> <i>pattern</i><br>
</ul>
<br>
<i>field-pattern-list</i>:<br>
<ul>
  <i>field-pattern</i><br>
  <i>field-pattern-list</i> <code>,</code> <i>field-pattern</i><br>
</ul>
<br>
<i>field-pattern</i>:<br>
<ul>
  <i>pattern</i><br>
  <i>designation</i> <i>pattern</i><br>
</ul>
</font>
<br>
<a name=expression></a>
<i>expression</i>:<br>
<ul>
  <i>assignment-expression</i><br>
  <i>expression</i> <code>,</code> <i>assignment-expression</i><br>
</ul>
<br>
<i>assignment-expression</i>:<br>
<ul>
  <i>conditional-expression</i><br>
  <i>unary-expression</i> <i>assignment-operator</i> <i>assignment-expression</i><br>
</ul>
<br>
<i>assignment-operator</i>: <font color=black>one of</font><br>
<ul>
  <code>=</code>
  <code>*=</code>
  <code>/=</code>
  <code>%=</code>
  <code>+=</code>
  <code>-=</code>
  <code><<=</code>
  <code>>>=</code>
  <code>&=</code>
  <code>^=</code>
  <code>|=</code><br>
</ul>
<br>
<i>conditional-expression</i>:<br>
<ul>
  <i>logical-or-expression</i><br>
  <i>logical-or-expression</i> <code>?</code> <i>expression</i> <code>:</code> <i>conditional-expression</i><br>
</ul>
<br>
<i>constant-expression</i>:<br>
<ul>
  <i>conditional-expression</i><br>
</ul>
<br>
<i>logical-or-expression</i>:<br>
<ul>
  <i>logical-and-expression</i><br>
  <i>logical-or-expression</i> <code>||</code> <i>logical-and-expression</i><br>
</ul>
<br>
<i>logical-and-expression</i>:<br>
<ul>
  <i>inclusive-or-expression</i><br>
  <i>logical-and-expression</i> <code>&&</code> <i>inclusive-or-expression</i><br>
</ul>
<br>
<i>inclusive-or-expression</i>:<br>
<ul>
  <i>exclusive-or-expression</i><br>
  <i>inclusive-or-expression</i> <code>|</code> <i>exclusive-or-expression</i><br>
</ul>
<br>
<i>exclusive-or-expression</i>:<br>
<ul>
  <i>and-expression</i><br>
  <i>exclusive-or-expression</i> <code>^</code> <i>and-expression</i><br>
</ul>
<br>
<i>and-expression</i>:<br>
<ul>
  <i>equality-expression</i><br>
  <i>and-expression</i> <code>&</code> <i>equality-expression</i><br>
</ul>
<br>
<i>equality-expression</i>:<br>
<ul>
  <i>relational-expression</i><br>
  <i>equality-expression</i> <code>==</code> <i>relational-expression</i><br>
  <i>equality-expression</i> <code>!=</code> <i>relational-expression</i><br>
</ul>
<br>
<i>relational-expression</i>:<br>
<ul>
  <i>shift-expression</i><br>
  <i>relational-expression</i> <code><</code> <i>shift-expression</i><br>
  <i>relational-expression</i> <code>></code> <i>shift-expression</i><br>
  <i>relational-expression</i> <code><=</code> <i>shift-expression</i><br>
  <i>relational-expression</i> <code>>=</code> <i>shift-expression</i><br>
</ul>
<br>
<i>shift-expression</i>:<br>
<ul>
  <i>additive-expression</i><br>
  <i>shift-expression</i> <code><<</code> <i>additive-expression</i><br>
  <i>shift-expression</i> <code>>></code> <i>additive-expression</i><br>
</ul>
<br>
<i>additive-expression</i>:<br>
<ul>
  <i>multiplicative-expression</i><br>
  <i>additive-expression</i> <code>+</code> <i>multiplicative-expression</i><br>
  <i>additive-expression</i> <code><i>-</i></code> <i>multiplicative-expression</i><br>
</ul>
<br>
<i>multiplicative-expression</i>:<br>
<ul>
  <i>cast-expression</i><br>
  <i>multiplicative-expression</i> <code>*</code> <i>cast-expression</i><br>
  <i>multiplicative-expression</i> <code>/</code> <i>cast-expression</i><br>
  <i>multiplicative-expression</i> <code>%</code> <i>cast-expression</i><br>
</ul>
<br>
<i>cast-expression</i>:<br>
<ul>
  <i>unary-expression</i><br>
  <code>(</code> <i>type-name</i> <code>)</code> <i>cast-expression</i><br>
</ul>
<br>
<i>unary-expression</i>:<br>
<ul>
  <i>postfix-expression</i><br>
  <code>++</code> <i>unary-expression</i><br>
  <code>--</code> <i>unary-expression</i><br>
  <i>unary-operator</i> <i>cast-expression</i><br>
  <code>sizeof</code> <i>unary-expression</i><br>
  <code>sizeof</code> <code>(</code> <i>type-name</i> <code>)<br>
  <font color="#FF0000"><code><i>expression</i> . size</code>
  &nbsp;&nbsp;&nbsp;<font color="#008000">// returns size of array</font>
  <br>
<font color=red>
  <code>throw</code> <i>unary-expression</i><br>
</ul>
</font>
</font>
<br>
<i>unary-operator</i>: <font color=black>one of</font><br>
<ul>
  <code>&</code>
  <code>*</code>
  <code>+</code>
  <code>-</code>
  <code>~</code>
  <code>!</code><br>
</ul>
<br>
<i>postfix-expression</i>:<br>
<ul>
  <i>primary-expression</i><br>
  <i>postfix-expression</i> <code>[</code> <i>expression</i> <code>]</code><br>
  <i>postfix-expression</i> <code>(</code> <code>)</code><br>
  <i>postfix-expression</i> <code>(</code> <i>argument-expression-list</i> <code>)</code><br>
  <i>postfix-expression</i> <code>.</code> <i>identifier</i><br>
  <i>postfix-expression</i> <code>-></code> <i>identifier</i><br>
  <i>postfix-expression</i> <code>++</code><br>
  <i>postfix-expression</i> <code>--</code><br>
 <code>( <i>type-name</i>  ) { <i>initializer-list</i>  }<br>
 ( <i>type-name</i>  ) { <i>initializer-list</i>  , }<br>
<font color=red>
  new { <i>initializer-list<sub>opt</sub></i>  }<br>
  new { <i>initializer-list</i>  , }<br>
  new { for <i>identifier</i>  < <i>expression</i>  : <i>expression</i>  }<br>
  fill ( <i>expression</i>  )<br>
  codegen ( <i>function-definition</i>  )<br>
</font>
</ul>
<br>
<i>primary-expression</i>:<br>
<ul>
  <i>identifier</i><br>
  <i>constant</i><br>
  <i>string</i><br>
  ( <i>expression</i>  )<br>
<font color=red>
  <i>identifier</i>  <><br>
  $ ( <i>argument-expression-list</i>  )<br>
  <i>identifier</i>  { <i>initializer-list</i>  }<br>
  ( { <i>block-item-list</i>  } )<br>
</font>
</ul>
<br>
<i>argument-expression-list</i>:<br>
<ul>
  <i>assignment-expression</i><br>
  <i>argument-expression-list</i>  , <i>assignment-expression</i><br>
</ul>
<br>
<i>constant</i>:<br>
<ul>
  <i>integer-constant</i><br>
  <i>character-constant</i><br>
  <i>floating-constant</i><br>
  <i>enumeration-constant</i><br>
<font color=red>
  null<br>
</font>
</ul>
</ul>

</body>

</html>
