\input texinfo
@c
@setfilename library.info
@settitle Cyclone Libraries
@c

@defcodeindex ex

@ifinfo
This is the documentation for the Cyclone libraries.
@end ifinfo

@titlepage
@sp 10
@center @titlefont{The Cyclone Libraries}
@end titlepage

@node Top, Arg, (dir), (dir)

This document describes Cyclone's standard libraries.  Many of the
libraries were ported from Ocaml (@url{http://pauillac.inria.fr/caml/});
see the source files for attribution.

@menu
* Arg::                         Command-line argument processing
* Array::                       Arrays
* Bitvec::                      Bit vectors
* Buffer::                      Extensible buffers of characters
* Character::                   Functions on chars
* Core::                        Core types and functions
* Dict::                        Dictionaries
* Filename::                    Filenames
* Fn::                          Functions with closures
* Hashtable::                   Hashtables
* Id::                          Identifiers
* Lexing::                      Interface to lexers generated by cyclex
* Lineno::                      Line number package for use in lexers
* List::                        Lists
* Printf::                      Formatted output
* Position::                    File position package for use in lexers
* PP::                          Pretty printers
* Queue::                       Queues                       
* Ref::                         Reference cells
* Rope::                        Efficient string library
* Scanf::                       Formatted input
* Set::                         Sets
* Splay::                       Splay trees
* String::                      String functions
* Xarray::                      Extensible arrays

* Function index::              
* Type index::                  
* Exception index::             
@end menu

@node Arg, Array, Top, Top
@chapter Arg

@heading Header
@example
#include "arg.h"
using Arg;
@end example

@node Array, Bitvec, Arg, Top
@chapter Array

Namespace @code{Array} implements some sorting routines on arrays.

@heading Header
@example
#include "array.h"
using Array;
@end example

@heading Functions
@example
void qsort<`a>(int less_eq(`a,`a), `a @var{x}[?], int ofs, int len);
@end example

@heading Use

@defun qsort (less_eq,x,ofs,len)
Does an in-place sort of a segment of array @var{x}, starting at the
element with index @var{ofs}, and continuing for @var{len} elements.
The function @var{less_eq} should return an integer less than, equal to,
or greater than 0 if its first argument is less than, equal to, or
greater than its second argument, respectively.  @code{qsort} throws
@code{Core::InvalidArg("Array::qsort")} if @var{len} is negative or
@var{ofs} and @var{len} specify a segment outside the bounds of @var{x}.
@end defun

@node Bitvec, Buffer, Array, Top
@chapter Bitvec

Namespace @code{Bitvec} implements bit vectors, which can be used to
represent sets with a fixed number of elements.

@heading Header
@example
#include "bitvec.h"
using Bitvec;
@end example

@heading Types
@tindex BITVEC
@example
typedef int BITVEC[?];
@end example

@menu
* Creating bit vectors::        
* Accessing and updating bits::  
* Combining and comparing bit vectors::  
* Printing bit vectors::        
@end menu

@node Creating bit vectors, Accessing and updating bits, Bitvec, Bitvec
@section Creating bit vectors

@heading Functions
@example
BITVEC new_empty(int);
BITVEC new_full(int);
BITVEC new_copy(BITVEC);
BITVEC from_list<`a,`b>(Dict::Dict<`a,`b> @var{d}, int @var{f}(`b),int sz, List::list<`a>);
List::list<int> to_sorted_list(BITVEC bvec, int sz);
@end example

@heading Use

@defun new_empty (n)
Returns a bit vector containing @var{n} bits, all set to 0.
@end defun

@defun new_full (n)
Returns a bit vector containing @var{n} bits, all set to 1.
@end defun

@defun new_copy (v)
Returns a copy of bit vector @var{v}.
@end defun

@node Accessing and updating bits, Combining and comparing bit vectors, Creating bit vectors, Bitvec
@section Accessing and updating bits

@heading Functions
@example
bool get(BITVEC, int);
void set(BITVEC, int);
void clear(BITVEC, int);
bool get_and_set(BITVEC, int);
void clear_all(BITVEC);
void set_all(BITVEC);
bool all_set(BITVEC bvec, int sz);
@end example

@heading Use

@defun get (v,n)
Returns the @var{n}th bit of vector @var{v}.
@end defun

@defun set (v,n)
Sets the @var{n}th bit of vector @var{v} to 1.
@end defun

@defun clear (v,n)
Sets the @var{n}th bit of vector @var{v} to 0.
@end defun

@defun get_and_set (v,n)
Sets the @var{n}th bit of vector @var{v} to 1, and returns the value
that the @var{n}th bit had before it was set to 1.
@end defun

@defun set_all (v)
Sets every bit of @var{v} to 1.
@end defun

@defun clear_all (v)
Sets every bit of @var{v} to 0.
@end defun

@defun all_set (v,n)
Does ?????  FIX
@end defun

@node Combining and comparing bit vectors, Printing bit vectors, Accessing and updating bits, Bitvec
@section Combining and comparing bit vectors

@heading Functions
@example
void union_two(BITVEC dest, BITVEC src1, BITVEC src2);
void intersect_two(BITVEC dest, BITVEC src1, BITVEC src2);
void diff_two(BITVEC dest, BITVEC src1, BITVEC src2);
bool compare_two(BITVEC src1, BITVEC src2);
@end example

@heading Use

@defun union_two (dest,src1,src2)
Updates @var{dest} with the bitwise-or of @var{src1} and @var{src2}.
There is no error if @var{dest} is shorter than @var{src1} or
@var{src2} (extra bits are ignored).  If @var{src1} or @var{src2}
is shorter than @var{dest}, @code{Null_Exception} is thrown; 
@var{dest} may be partially updated.
@end defun

@defun intersect_two (dest,src1,src2)
Updates @var{dest} with the bitwise-and of @var{src1} and @var{src2}.
Its error conditions are the same as @code{union_two}.
@end defun

@defun diff_two (dest,src1,src2)
Updates @var{dest} with the bitwise-difference of @var{src1} and
@var{src2}.  Its error conditions are the same as @code{union_two}.
@end defun

@defun compare_two (src1,src2)
Returns 1 if every bit of
@var{src1} is the same as the corresponding bit of @var{src2}, and 0
otherwise.  If @var{src2} is longer than @var{src1}, its extra bits are
ignored.  If @var{src2} is shorter than @var{src1},
@code{Null_Exception} is thrown.
@end defun

@node Printing bit vectors,  , Combining and comparing bit vectors, Bitvec
@section Printing bit vectors

@heading Functions
@example
void print_bvec(BITVEC bvec);
@end example

@heading Use

@defun print_bvec (v)
FIX: PUT SOMETHING HERE
@end defun

@node Buffer, Character, Bitvec, Top
@chapter Buffer

Namespace @code{Buffer} implements extensible buffers of characters.

@heading Header
@example
#include "buffer.h"
using Buffer;
@end example

@heading Types
@example
struct t;
typedef struct t @@T;
@end example

The type @code{struct t} is the abstract type of buffers.  Most
functions manipulate the type @code{T}, a non-null pointer to a buffer.

@heading Functions
@example
T create(uint @var{n});
string contents(T);
Core::size_t length(T);
void clear(T);
void reset(T);
void add_char(T,char);
void add_substring(T,string,int offset,int len);
void add_string(T,string);
void add_buffer(T buf_dest, T buf_source);
@end example

@heading Use

@defun create (n)
Returns an empty buffer with internal storage of size @var{n}.  If
@var{n} is negative, no exception is thrown; a buffer with a small
amount of internal storage is returned instead.
@end defun

@defun contents (b)
Returns the contents of buffer @var{b} as a string.
@end defun

@defun length (b)
Returns the current length of buffer @var{b}.
@end defun

@defun clear (b)
Sets the length of @var{b} to 0, without modifying its internal storage.
@end defun

@defun reset (b)
Restores @var{b} to its initial internal storage.
@end defun

@defun add_char (b,c)
Adds the character @var{c} to the end of buffer @var{b}.
@end defun

@defun add_substring (b,s,offset,len)
Adds the substring of @var{s} starting at element @var{offset} and
continuing for @var{len} characters to the end of buffer @var{b}.  If
@var{offset} and @var{len} do not specify a valid substring of @var{s},
then the function throws @code{InvalidArg("Buffer::add_substring")}.
Note, the substring specified by @var{offset} and @var{len} may contain
null (0) characters; in any case, the entire substring is appended to
@var{b}, not just the substring up to the first null character.
@end defun

@defun add_string (b,s)
Adds the string @var{s} to the end of buffer @var{b}.
@end defun

@defun add_buffer (buf_dest,buf_source)
Adds the contents of buffer @var{buf_source} to the end of buffer
@var{buf_dest}.
@end defun

@node Character, Core, Buffer, Top
@chapter Character

Namespace @code{Character} implements the character library of C.

@heading Header
@example
#include "character.h"
using Character;
@end example

@heading Functions
@example
bool isupper(char c);
bool islower(char @var{c});
bool isdigit(char @var{c});
bool isxdigit(char @var{c});
bool isspace(char @var{c});
bool isalpha(char @var{c});
bool isprint(char @var{c});
bool isgraph(char @var{c});
char toupper(char @var{c});
char tolower(char @var{c});
@end example

@heading Use

@defun isupper (@var{c})
Returns 1 if @var{c} is an uppercase letter ('A'-'Z'), and returns 0
otherwise.
@end defun

@defun islower (c)
Returns 1 if @var{c} is a lowercase letter ('a'-'z'), and returns 0
otherwise.
@end defun

@defun isdigit (c)
Returns 1 if @var{c} is a decimal digit ('0'-'9'), and returns 0
otherwise.
@end defun

@defun isxdigit (c)
Returns 1 if @var{c} is a hexidecimal digit ('0'-'9' or 'A'-'F' or
'a'-'f'), and returns 0 otherwise.
@end defun

@defun isspace (c)
Returns 1 if @var{c} is the space character ' ', and returns 0
otherwise.
@end defun

@defun isalpha (c)
Returns 1 if @var{c} is an alphabetic character ('A'-'Z' or 'a'-'z'),
and returns 0 otherwise.
@end defun

@defun isprint (c)
Does ??? FIX
@end defun

@defun isgraph (c)
Does ??? FIX
@end defun

@defun toupper (c)
If @var{c} is a lowercase letter ('a'-'z'), then
@code{toupper(@var{c})} returns its uppercase ('A'-'Z') equivalent;
otherwise it returns @var{c}.
@end defun

@defun tolower (c)
If @var{c} is an uppercase letter ('A'-'Z'), then
@code{tolower(@var{c})} returns its lowercase ('a'-'z') equivalent;
otherwise it returns @var{c}.
@end defun

@node Core, Dict, Character, Top
@chapter Core

The @code{Core} namespace contains fundamental types and functions.

@heading Header
@example
#include "core.h"
using Core;
@end example

@menu
* Booleans::                    
* Input and output::            
* Opt::                         
* Core exceptions::             
* Boxing and unboxing::         
* Miscellaneous types::         
* Miscellaneous string stuff::  
* System interface::            
* Miscellaneous functions::     
@end menu

@node Booleans, Input and output, Core, Core
@section Booleans
@heading Types
@example
typedef int bool;
@end example

@heading Values
@example
#define false (0)
#define true (1)
@end example

@heading Functions
@example
bool true_f<`a>(`a);
bool false_f<`a>(`a);
@end example

@node Input and output, Opt, Booleans, Core
@heading Exceptions
@example
xenum exn @{ FileOpenError(string) @};
xenum exn @{ FileCloseError @};
@end example

@heading Values
@example
FILE @@cyc_stdout;
FILE @@cyc_stdin;
FILE @@cyc_stderr;
#define EOF ((char)(-1))
@end example

@heading Functions
@example
int   f_string_read(FILE *,string,int,int);
int   f_string_write(FILE *,string,int,int);
int   f_seek(FILE *,int);
int   fflush(FILE *);
int   fgetc(FILE *);
FILE @@file_open(string fname, string mode);
void  file_close(FILE @@);
int   file_delete(string);
int   file_length(string);
@end example

@node Opt, Core exceptions, Input and output, Core
@section Opt
@heading Types
@example
struct Opt<`a> @{ `a v; @};
typedef struct Opt<`a> *Opt_t<`a>;
@end example

@heading Functions
@example
Opt_t<`b> opt_map<`a,`b>(`b @var{f}(`a), Opt_t<`a> @var{x});
@end example

@node Core exceptions, Boxing and unboxing, Opt, Core
@section Core exceptions
@exindex InvalidArg
@exindex Failure
@exindex Impossible
@exindex Not_found
@exindex Unreadchable
@example
xenum exn @{ InvalidArg(string) @};
xenum exn @{ Failure(string) @};
xenum exn @{ Impossible(string) @};
xenum exn @{ Not_found @};
xenum exn @{ Unreachable(string) @};
@end example

@node Boxing and unboxing, Miscellaneous types, Core exceptions, Core
@section Boxing and unboxing
@heading Functions
@example
Char      box_char(char);
char      unbox_char(Char);
Short     box_short(short);
short     unbox_short(Short);
Long Long box_long_long(long long);
long long unbox_long_long(Long Long);
Float     box_float(float);
float     unbox_float(Float);
Double    box_double(double);
double    unbox_double(Double);
@end example

@node Miscellaneous types, Miscellaneous string stuff, Boxing and unboxing, Core
@section Miscellaneous types
@example
typedef unsigned int uint;
typedef unsigned int size_t;
@end example

@node Miscellaneous string stuff, System interface, Miscellaneous types, Core
@section Miscellaneous string stuff
@heading Types
@example
typedef char Cstring[];
typedef char string[?];
@end example

@heading Functions
@example
Cstring string_to_Cstring(string);
string  new_string(int);
int     int_of_string(string);
string  string_of_int(int);
string  string_of_uint(unsigned int);
string  string_of_char(char);
@end example

@node System interface, Miscellaneous functions, Miscellaneous string stuff, Core
@section System interface
@heading Functions
@example
int    system(Cstring);
string get_env(string);
string std_args()[?];
@end example

@node Miscellaneous functions,  , System interface, Core
@section Miscellaneous functions
@example
`a   fst<`a,`b>($(`a,`b)@@);
`b   snd<`a,`b>($(`a,`b)@@);
`c   third<`a,`b,`c>($(`a,`b,`c)@@);
`a   identity<`a>(`a);
int  intcmp(int,int);
int  charcmp(char,char);
bool is_space(char);
@end example

@node Dict, Filename, Core, Top
@chapter Dict

Namespace @code{Dict} defines @emph{dictionaries}, which map keys to
values.  The dictionaries are implemented functionally: adding a mapping
to an existing dictionary produces a new dictionary, without affecting
the existing dictionary.

@heading Header
@example
#include "dict.h"
using Dict;
@end example

@heading Types
@tindex Dict
@tindex struct dict
@example
struct dict<`a,`b>;
typedef struct dict<`a,`b> @@Dict<`a,`b>;
@end example

@heading Exceptions
@exindex Absent
@exindex Present
@example
xenum exn @{Absent@};
xenum exn @{Present@};
@end example

The exception @code{Absent} is thrown when a key is expected in a
dictionary, but is not present.  Conversely, @code{Present} is
typically thrown when a key is not expected, but is present.

@menu
* Creating dictionaries::       
* Accessing and updating dictionaries::  
* Operating on dictionaries::   
@end menu

@node Creating dictionaries, Accessing and updating dictionaries, Dict, Dict
@section Creating dictionaries

@heading Functions
@example
Dict<`a,`b> empty<`a,`b>(int comp(`a,`a));
Dict<`a,`b> singleton<`a,`b>(int comp(`a,`a),`a key,`b data);
@end example

@heading Use
@defun empty (comp)
Creates a new dictionary.  The function @var{comp} takes two keys as
arguments, and it should return an integer less than, equal to, or
greater than 0 according to whether its first argument is less than,
equal to, or greater than the second, respectively.
@end defun

@defun singleton (comp,key,data)
Creates a new dictionary with a single entry, mapping @var{key} to
@var{data}.  The function @var{comp} should be a comparison function for
keys, as described for @code{empty} above.
@end defun

@node Accessing and updating dictionaries, Operating on dictionaries, Creating dictionaries, Dict
@section Accessing and updating dictionaries

@heading Functions
@example
bool            is_empty<`a,`b>(Dict<`a,`b> @var{d});
bool            member<`a,`b>(Dict<`a,`b> d,`a key);
`b              lookup<`a,`b>(Dict<`a,`b> @var{d},`a key);
Core::Opt_t<`b> lookup_opt<`a,`b>(Dict<`a,`b> @var{d},`a key);
Dict<`a,`b>     insert<`a,`b>(Dict<`a,`b> @var{d},`a key,`b data);
Dict<`a,`b>     insert_new<`a,`b>(Dict<`a,`b> @var{d},`a key,`b data);
Dict<`a,`b>     inserts<`a,`b>(Dict<`a,`b> @var{d},list<$(`a,`b)@@> kds);
Dict<`a,`b>     delete<`a,`b>(Dict<`a,`b> @var{d},`a key);
Dict<`a,`b>     delete_present<`a,`b>(Dict<`a,`b> @var{d},`a key);
@end example

@heading Use

@defun is_empty (d)
Returns 1 if @var{d} is an empty dictionary, and returns 0 if @var{d} is
not empty.
@end defun

@defun member (d,key)
Returns 1 if @var{key} is present in dictionary @var{d}, and returns 0
if @var{key} is not present.
@end defun

@defun lookup (d,key)
Looks up the value associated with @var{key} in dictionary @var{d}, and
returns it.  If @var{key} has no value in @var{d}, then @code{Absent} is
thrown.
@end defun

@defun lookup_opt (d,key)
Looks up the value associated with @var{key} in dictionary @var{d}, and
returns a pointer to it.  If @var{key} has no value in @var{d}, then
@code{NULL} is returned.
@end defun

@defun insert (d,key,data)
Adds a mapping from @var{key} to @var{data} in dictionary @var{d},
overwriting any previous value for @var{key}.
@end defun

@defun insert_new (d,key,data)
Behaves like @code{insert}, except that @code{Present} is thrown if
@var{key} already has a value in @var{d}.
@end defun

@defun inserts (d,kds)
Is used to add a list of mappings to dictionary @var{d}; @var{kds}
should be a list of (@var{key},@var{data}) pairs.
@end defun

@node Operating on dictionaries,  , Accessing and updating dictionaries, Dict
@section Operating on dictionaries

@heading Functions
@example
void        app<`a,`b,`c>(`c f(`a,`b),Dict<`a,`b> @var{d});
void        app_c<`a,`b,`c,`d>(`c @var{f}(`d,`a,`b),`d env,Dict<`a,`b> @var{d});
void        iter<`a,`b>(void @var{f}(`a,`b),Dict<`a,`b> @var{d});
void        iter_c<`a,`b,`c>(void f(`c,`a,`b),`c env,Dict<`a,`b> @var{d});
Dict<`a,`c> map<`a,`b,`c>(`c @var{f}(`b),Dict<`a,`b> @var{d});
Dict<`a,`c> map_c<`a,`b,`c,`d>(`c @var{f}(`d,`b),`d env,Dict<`a,`b> @var{d});
`c          fold<`a,`b,`c>(`c @var{f}(`a,`b,`c),Dict<`a,`b> @var{d},`c accum);
`c          fold_c<`a,`b,`c,`d>(`c @var{f}(`d,`a,`b,`c),`d env,
                                Dict<`a,`b> dict,`c accum);
$(`a,`b)@@   choose<`a,`b>(Dict<`a,`b> @var{d});
list<$(`a,`b)@@> to_list<`a,`b>(Dict<`a,`b> @var{d});
@end example

@heading Use

@defun app (f,d)
Applies the function @var{f} to every (@var{key},@var{data}) pair in
@var{d}.  The return value of @var{f} is ignored.
@end defun

@defun app_c (f,env,d)
Applies the function @var{f} to @var{env} and every
(@var{key},@var{data}) pair in @var{d}.  The argument @var{env} is
intended to hold auxilliary data for @var{f}.  The return value of
@var{f} is ignored.
@end defun

@defun iter (f,d)
Acts just like @code{app}, except that @var{f} can return void.
(@code{app} cannot be used on functions that return void because of
restrictions in the Cyclone type system.)
@end defun

@defun iter_c (f,env,d)
Acts like @code{app_c} except that @var{f} can return void.
@end defun

@defun map (f,d)
Creates a new dictionary with a pair (@var{key},@var{f}(@var{data})) for
each pair (@var{key},@var{data}) in @var{d}.
@end defun

@defun map_c (f,env,d)
Does the same but applies @var{f} to @var{env} as well as @var{data}.
@end defun


@defun fold (f,d,accum)
Returns the value accumulated by applying @var{f} to the keys and data
in @var{d}.  For example, if @var{d} has keys @var{k1} through @var{kn}
and associated values @var{data1} through @var{datan}, then @code{fold}
returns

@example
@var{f}(@var{k1},@var{data1},@var{f}(@var{k2},@var{data2}, ... @var{f}(@var{kn},@var{datan},@var{accum}) ... ))
@end example

@noindent The order in which the keys and data are passed to @var{f} is
not specified.
@end defun

@defun fold_c (f,env,d,accum)
Computes

@example
@var{f}(@var{env},@var{k1},@var{data1}, ... @var{f}(@var{env},@var{kn},@var{datan},@var{accum}) ... )
@end example
@end defun

@defun choose (d)
Returns a (@var{key},@var{data}) pair from @var{d} -- exactly which pair
is unspecified.  If @var{d} is empty, then @code{Absent} is thrown.
@end defun

@defun to_list (d)
Returns a list of the (@var{key},@var{data}) pairs of @var{d}.
@end defun

@node Filename, Fn, Dict, Top
@chapter Filename

The @code{Filename} namespace contains functions for operating on
strings representing file names.

@heading Header
@example
#include "filename.h"
using Filename;
@end example

@heading Functions
@example
string concat(string, string);
string chop_extension(string);
string dirname(string);
string basename(string);
bool   check_suffix(string, string);
string gnuify(string);
@end example

@node Fn, Hashtable, Filename, Top
@chapter Fn

Namespace @code{Fn} supports @emph{closures}, which allow a function to
be packaged up with some hidden data.

@heading Header
@example
#include "fn.h"
using Fn;
@end example

@heading Types
@example
enum Function<`arg,`res> @{
  Fun<`env>(`res (@@)(`env,`arg), `env)
@};
typedef enum Function<`arg,`res> fn<`arg,`res>;
@end example

@heading Functions
@example
fn<`arg,`res>    make_fn<`arg,`res,`env>(`res @var{f}(`env,`arg), `env @var{x});
fn<`arg,`res>    fp2fn<`arg,`res>(`res @var{f}(`arg));
`res             apply<`arg,`res>(fn<`arg,`res> @var{f}, `arg @var{x});
fn<`a,`c>        compose<`a,`b,`c>(fn<`a,`b> @var{g}, fn<`b,`c> @var{f});
fn<`a,fn<`b,`c>> curry<`a,`b,`c>(fn<$(`a,`b)@@,`c> @var{f});
fn<$(`a,`b)@@,`c> uncurry<`a,`b,`c>(fn<`a,fn<`b,`c>> @var{f});
List::list<`b>   map_fn<`a,`b>(fn<`a,`b> @var{f},List::list<`a> x);
@end example

@heading Use
@defun make_fn (f,e)
Creates and returns a new closure for function pointer @var{f} and environment
@var{e}.
@end defun

@defun fp2fn (f)
Creates and returns a new closure for a function pointer that does not
require an environment.
@end defun

@defun apply (f,x)
Applies closure @var{f} to argument @var{x} and returns the result.  The
function pointer of @var{f} is applied to the environment of @var{f} and
the argument @var{x}.
@end defun

@defun compose (g,f)
Returns a new closure that composes the closures @var{f} and @var{g}:
@code{apply(compose(@var{g},@var{f}),@var{x})} should be the same as
@code{apply(@var{g},apply(@var{f},@var{x}))}.
@end defun

@defun curry (f)
@var{f} should be a closure that takes a pointer to a pair as an
argument.  @code{curry(@var{f})} returns a new closure that takes the
two components of a pair in two steps (applies) before passing them to
@var{f}.  That is, @code{apply(@var{f},&$(@var{x},@var{y}))} should be
the same as @code{apply(apply(curry(@var{f}),@var{x}),@var{y})}.
@end defun

@defun uncurry (f)
@code{uncurry} is the opposite of @code{curry}.  It takes a closure that
takes two arguments in sequence and returns a closure that takes the
arguments as a pair.  @code{apply(uncurry(@var{f}),&$(@var{x},@var{y}))}
should be the same as @code{apply(apply(@var{f},@var{x}),@var{y})}.
@end defun

@defun map_fn (f,x)
Applies the closure @var{f} to each element of list @var{x} in turn,
left to right, and returns a list built from the results.
@end defun

@node Hashtable, Id, Fn, Top
@chapter Hashtable

Namespace @code{Hashtable} implements hash tables.

@heading Header
@example
#include "hashtable.h"
using Hashtable;
@end example

@heading Types
@tindex struct table
@tindex Table
@example
struct table<`a,`b>;
typedef struct table<`a,`b> @@Table<`a,`b>;
@end example

@heading Functions

@example
Table<`a,`b> create<`a,`b>(int sz, int cmp(`a,`a), int hash(`a));
void         insert<`a,`b>(Table<`a,`b> @var{t}, `a key, `b val);
`b           lookup<`a,`b>(Table<`a,`b> @var{t}, `a key);
void         resize<`a,`b>(Table<`a,`b> @var{t});
void         remove<`a,`b>(Table<`a,`b> @var{t}, `a key);
int          hash_string(string @var{s});
void         iter<`a,`b>(void f(`a,`b), Table<`a,`b> @var{t});
void         print_table_map<`a,`b>(Table<`a,`b> @var{t}, void prn_key(`a), void prn_val(`b));
@end example

@heading Use

@defun create(sz,cmp,hash)
Builds a new, empty hash table with initial size @var{sz}.  @var{cmp}
should be a comparison function that returns an integer less than, equal
to, or greater than 0 according to whether its first argument is less
than, equal to, or greater than its second argument.  @code{hash} should
be a hash function on the keys of the hash table.  @code{cmp} and
@code{hash} should satisfy the following property: if
@code{cmp(@var{x},@var{y})} is 0, then @code{hash(@var{x}) ==
hash(@var{y})}.
@end defun

@defun insert(t,key,val)
Binds @var{key} to @var{val} in hash table @var{t}.
@end defun

@defun lookup (t,key)
Looks up the value associated with @var{key} in hash table @var{t}.  If
@var{key} does not appear in @var{t}, @code{Not_found} is thrown.
@end defun


@defun resize (t)
Increases the internal storage available to hash table @var{t}.
@code{resize} is called automatically by functions like insert when the
buckets of a hash table get large, however, it can also be called by the
programmer explicitly.
@end defun

@defun remove (t,key)
Removes the most recent binding of @var{key} from @var{t}.  The
next-most-recent binding of @var{key} (if any) is restored.  If
@var{key} is not bound in @var{t}, @code{remove} returns silently
without changing @var{t}.
@end defun


@defun hash_string (s)
Returns a hash of a string @var{s}.  It is provided as a convenience for
making hash tables mapping strings to values.
@end defun

@defun iter (f,t)
Applies the function @var{f} to every (@var{key},@var{value}) pair in
the hash table @var{t}.
@end defun

@defun print_table_map (t,prn_key,prn_val)
Used for debugging.  It prints out the internal structure of @var{t}.
@var{prn_key} must be a function that prints keys, and @var{prn_val}
must be a function that prints values.
@end defun

@node Id, Lexing, Hashtable, Top
@chapter Id

@heading Header
@example
#include "id.h"
using Id;
@end example

@node Lexing, Lineno, Id, Top
@chapter Lexing

@heading Header
@example
#include "lexing.h"
using Lexing;
@end example

@node Lineno, List, Lexing, Top
@chapter Lineno

@heading Header
@example
#include "lineno.h"
using Lineno;
@end example

@node List, Printf, Lineno, Top
@chapter List

Namespace @code{List} defines polymorphic lists and standard operations
over them.

@heading Header
@example
#include "list.h"
using List;
@end example

@heading Types
@tindex struct cons
@tindex list
@tindex List
@example
struct cons<`a>@{`a hd; struct cons<`a> *tl;@};
typedef struct cons<`a> *list<`a>;
typedef struct cons<`a> @@List<`a>;
@end example

A list is built out of "cons cells", which are structures with a head
('hd') field and a tail ('tl') field.  (The term "cons" comes from Lisp.)
The head of a cons cell holds the first element of the list, and the
tail points to the remainder of the list.  Most functions use the
typedef @code{list}, which is a possibly-null pointer to a cons cell.
@code{null} serves as the empty list.

@heading Exceptions
@exindex List_empty
@exindex List_mismatch
@exindex Nth
@example
xenum exn @{List_empty@};
xenum exn @{List_mismatch@};
xenum exn @{Nth@};
@end example

The @code{List_empty} exception is typically thrown by a function that
expects a non-empty list, but is passed null instead.  The
@code{List_mismatch} exception is typically thrown by a function that
expects two lists of the same length, but receives lists of different
lengths instead.  The @code{Nth} exception is thrown when
@code{list_nth} doesn't have enough elements in the list.

@menu
* Basic list operations::       
* Iteration and mapping::       
* Fold::                        
* Reversing lists::             
* Appending lists::             
* Sorting lists::               
* Predicates::                  
* Lists and tuples::            
* Association lists::           
* Lists and arrays::            
* Tabulation::                  
@end menu

@node Basic list operations, Iteration and mapping, List, List
@section Basic list operations
@heading Functions
@example
int      length<`a>(list<`a> x);
`a       hd<`a>(list<`a> x);
list<`a> tl<`a>(list<`a> x);
list<`a> copy<`a>(list<`a> src);
`a       nth<`a>(list<`a> x,int i);
@end example

@heading Use

@defun length (x)
Returns the length of the list @var{x}.
@end defun

@defun hd (x)
Returns the first element of list @var{x}, or throws @code{List_empty}
if @var{x} is empty.
@end defun

@defun tl (x)
Returns the tail of @var{x}, or throws @code{List_empty} if @var{x} is
empty.  Note, @code{hd(@var{x})} is not quite equivalent to
@code{@var{x}->hd}, because the latter will throw @code{Null_Exception}
if @var{x} is empty.
@end defun

@defun copy (src)
Returns a fresh copy of the list @var{src} (all of the cons cells are
duplicated).
@end defun

@defun nth (x,n)
Returns the @var{n}th element of list @var{x}.  The elements of @var{x}
are numbered starting with 0.  If @var{n} does not correspond to an
element of @var{x}, the exception @code{Nth} is thrown.
@end defun

@node Iteration and mapping, Fold, Basic list operations, List
@section Iteration and mapping
@heading Functions
@example
list<`b> map<`a,`b>(`b f(`a),list<`a> x);
list<`b> map_c<`a,`b,`c>(`b f(`c,`a),`c env,list<`a> x);
list<`c> map2<`a,`b,`c>(`c f(`a,`b),list<`a> x,list<`b> y);

void     app<`a,`b>(`b f(`a),list<`a> x);
void     app_c<`a,`b,`c>(`c f(`a,`b),`a,list<`b> x);
void     app2<`a,`b,`c>(`c f(`a,`b),list<`a> x,list<`b> y);
void     app2_c<`a,`b,`c,`d>(`d f(`a,`b,`c),`a env,list<`b> x,list<`c> y);

void     iter<`a>(void f(`a),list<`a> x);
void     iter_c<`a,`b>(void f(`b,`a),`b env,list<`a> x);
void     iter2<`a,`b>(void f(`a,`b),list<`a> x,list<`b> y);
void     iter2_c<`a,`b,`c>(void f(`a,`b,`c),`a env,list<`b> x,list<`c> y);
@end example

@heading Use

@defun map (f,x)
Applies the function @var{f} to each element of list @var{x}, and
returns a new list of the results.
@end defun

@defun map_c (f,env,x)
A version of map where @var{f} takes an environment.
@end defun

@defun map2 (f,x,y)
Applies @var{f} to the pairs consisting of an element from list @var{x}
and its corresponding element from list @var{y}.  The results are
returned in a new list.  If @var{x} and @var{y} don't have the same
length, it throws @code{List_mismatch}.  Note, @var{f} may be applied
some number of times before @code{List_mismatch} is thrown.
@end defun

@defun app (f,x)
Applies @var{f} to each element of list @var{x}.  The results of the
function application are not saved.
@end defun

@defun app_c (f,env,x)
A version of app, except that @var{env} is passed as an additional
argument to @var{f}, along with each element of @var{x}.
@end defun

@defun app2 (f,x,y)
Applies f to one element of x and one element of y in turn, from left to
right in the lists x and y.  If the lists @var{x} and @var{y} are not
the same length, @code{List_mismatch} is thrown.
@end defun

@defun app2_c (f,env,x,y)
Applies f to env, and to one element of x and one element of y in turn,
from left to right in the lists x and y.  If the lists @var{x} and
@var{y} are not the same length, @code{List_mismatch} is thrown.
@end defun

@defun iter (f,x)
Like @code{app(@var{f},@var{x})} except that @var{f} returns void.
@end defun

@defun iter_c (f,env,x)
Like @code{app_c(@var{f},@var{env},@var{x})} except that @var{f} returns
void.
@end defun

@defun iter2 (f,x,y)
Like @code{app2(@var{f},@var{x},@var{y})} except that @var{f} returns
void.
@end defun

@defun iter2_c (f,env,x,y)
Like @code{app2_c(@var{f},@var{env},@var{x},@var{y})} except that @var{f}
returns void.
@end defun


@node Fold, Reversing lists, Iteration and mapping, List
@section Fold
@heading Functions
@example
`a fold_left<`a,`b>(`a f(`a,`b),`a accum,list<`b> x);
`a fold_left_c<`a,`b,`c>(`a f(`c,`a,`b),`c,`a accum,list<`b> x);

`b fold_right<`a,`b>(`b f(`a,`b),list<`a> x,`b accum);
`b fold_right_c<`a,`b,`c>(`b f(`c,`a,`b),`c,list<`a> x,`b accum);
@end example

@heading Use

@defun fold_left (f,accum,x)
Returns the value accumulated by applying @var{f} to the elements of
@var{x}.  For example, if @var{x} has elements @var{v1} through
@var{vn}, then @code{fold_left} returns

@example
@var{f}(@var{f}( ... @var{f}(@var{accum},@var{v1}) ... , @var{vn-1}), @var{vn})
@end example

@noindent Notice that the function is first applied to the left-most (first)
element of the list.
@end defun

@defun fold_left_c (f,env,accum,x)
The same as @code{fold_left} except that @var{f} takes a closure.
@end defun

@defun fold_right (f,x,accum)
Like @code{fold_left} except that it applies @var{f} to the elements
in @var{x} from right to left, rather than left to right:

@example
@var{f}(@var{v1},@var{f}(@var{v2}, ... @var{f}(@var{vn},@var{accum}) ... ))
@end example
@end defun

@defun fold_right_c (f,env,x,accum)
The same as @code{fold_right} except that @var{f} is given a closure
argument.
@end defun


@node Reversing lists, Appending lists, Fold, List
@section Reversing lists
@heading Functions
@example
list<`a> revappend<`a>(list<`a> x,list<`a> y);

list<`a> rev<`a>(list<`a> x);
list<`a> imp_rev<`a>(list<`a> x);
@end example

@heading Use

@defun revappend (x,y)
Returns the list whose elements are the reverse of the elements of
@var{x}, followed by the elements of @var{y}.
@end defun

@defun rev (x)
Returns a new list whose elements are the elements of @var{x} in reverse
order.
@end defun

@defun imp_rev (x)
An imperative version of @code{rev}; instead of allocating a new
list, the elements of @var{x} are reversed in place.
@end defun

@node Appending lists, Sorting lists, Reversing lists, List
@section Appending lists
@heading Functions
@example
list<`a> append<`a>(list<`a> x,list<`a> y);
list<`a> imp_append<`a>(list<`a> x,list<`a> y);
list<`a> flatten<`a>(list<list<`a>> x);
@end example

@heading Use

@defun append (x,y)
Returns a list whose elements are the elements of @var{x} and @var{y}.
The cons cells making up the returned list may be shared with @var{x} or
@var{y}.
@end defun

@defun imp_append (x,y)
An imperative version that modifies @var{x} so that @var{y} is
appended to it.
@end defun

@defun flatten (x)
@var{x} should be a list of lists.  @code{flatten} returns a list whose
elements are the elements of each element of @var{x}, from left to
right.  The returned list may share some cons cells with elements of
@var{x}.
@end defun

@node Sorting lists, Predicates, Appending lists, List
@section Sorting lists
@heading Functions
@example
list<`a> merge_sort<`a>(int less_eq(`a,`a), list<`a> x);
list<`a> merge<`a>(int less_eq(`a,`a),list<`a> a,list<`a> b);
@end example

@heading Use

@defun merge_srt (less_eq,x)
Returns a list the elements of @var{x} in sorted order, according to the
ordering function @var{less_eq}.  @var{less_eq} should return an integer
less than, equal to, or greater than 0 according to whether its first
argument is less than, equal to, or greater than its second argument.
@code{merge_sort} uses an auxiliary function,
@code{merge(@var{less_eq},@var{a},@var{b})}, to merge two lists
according an ordering function.
@end defun

@node Predicates, Lists and tuples, Sorting lists, List
@section Predicates
@heading Functions
@example
bool forall<`a>(bool pred(`a),list<`a> x);
bool forall_c<`a,`b>(bool pred(`a,`b),`a env,list<`b> x);
bool exists<`a>(bool pred(`a),list<`a> x);
bool memq<`a>(list<`a> l,`a x);
bool mem<`a>(int compare(`a,`a), list<`a> l, `a x);
Core::Opt_t<`c> check_unique<`c>(int compare(`c,`c),list<`c> x);
@end example

@heading Use

@defun forall (pred,x)
Returns true if the function @var{pred} returns true when applied to
every element of @var{x}, and returns false otherwise.
@end defun

@defun forall_c (pred,env,x)
A version of forall that takes a closure for the function @var{pred}.
@end defun

@defun exists (pred,x)
Returns true if @var{pred} returns true on any element of the list
@var{x}.
@end defun

@defun memq (l,x)
Returns 1 if @var{l} is an element of list @var{x} (according to
@code{==}), and returns 0 otherwise.
@end defun

@defun mem (compare,l,x)
A version of memq that uses a provided comparison function.
@end defun

@defun check_unique (compare,x)
Checks that a list of elements is unique; it assumes that the elements
of @var{x} are sorted according to the comparison function
@var{compare}.  It returns an element that is duplicated if one exists,
otherwise it returns null.
@end defun

@node Lists and tuples, Association lists, Predicates, List
@section Lists and tuples
@heading Functions
@example
list<$(`a,`b)@@>              zip<`a,`b>(list<`a> x,list<`b> y);
$(list<`a>,list<`b>)          split<`a,`b>(list<$(`a,`b)@@> x);
$(list<`a>,list<`b>,list<`c>) split3<`a,`b,`c>(list<$(`a,`b,`c)@@> x);
@end example
  
@heading Use

@defun zip (x,y)
@var{x} should be a list with elements @var{x1} through @var{xn}, and
@var{y} should be a list with elements @var{y1} through @var{yn}.
@code{zip} returns a list with elements @code{&$(@var{x1},@var{y1})}
through @code{&$(@var{xn},@var{yn})}.  If @var{x} and @var{y} have
different lengths, then @code{zip(@var{x},@var{y})} will throw
@code{List_mismatch}.
@end defun

@defun split (x)
Performs the opposite of @code{zip}; the list @var{x} is a list of
pairs, and @code{split} returns a pair of lists.
@end defun

@defun split3 (x)
A version of split that takes a list of triples and returns a triple
of lists.
@end defun

  
@node Association lists, Lists and arrays, Lists and tuples, List
@section Association lists
@heading Functions
@example
`b   assoc<`a,`b>(list<$(`a,`b)@@> l,`a x);
`b   assoc_cmp<`a,`b>(int compare(`a,`a), list<$(`a,`b)@@> l,`a x);
bool mem_assoc<`a,`b>(list<$(`a,`b)@@> l,`a x);
@end example

@heading Use

@defun assoc (l,x)
@var{l} is a list of (key,value) pairs, and @var{x} is a key.
@code{assoc} returns the value associated with @var{x} in @var{l}, or
throws @code{Core::Not_found} if no such value exists.  It uses
@code{==} to compare @var{x} to the keys in @var{l}.
@end defun

@defun assoc_cmp (compare,l,x)
A variant of assoc that uses the supplied @var{compare} function instead
of @code{==}.
@end defun

@defun mem_assoc (l,x)
@var{l} is a list of (key,value) pairs, and @var{x} is a key.
@code{mem_assoc} returns true if there is a value associated with
@var{x} in @var{l}.
@end defun


@node Lists and arrays, Tabulation, Association lists, List
@section Lists and arrays
@heading Functions
@example
`a       to_array<`a>(list<`a> x) [?];
list<`a> from_array<`a>(`a arr[?]);
@end example

@heading Use

@defun to_array (x)
Makes a new array with elements drawn from list @var{x}.
@end defun

@defun from_array (arr)
Makes a new list with elements drawn from array @var{arr}.
@end defun

@node Tabulation,  , Lists and arrays, List
@section Tabulation
@heading Functions
@example
list<`a> tabulate<`a>(int n, `a f(int));
list<`a> tabulate_c<`a,`b>(int n, `a f(`b,int), `b env);
@end example

@heading Use

@defun tabulate (n,f)
Does ??? FIX
@end defun

@defun tabulate_c (n,f,env)
Does ??? FIX
@end defun

@node Printf, Position, List, Top
@chapter Printf

Cyclone provides safe versions of @code{printf} and @code{fprintf} as
built-in primitives.  It also provides a built-in function,
@code{xprintf}, that allocates a string, prints to it, and returns it.
Cyclone protects against format string attacks by requiring the format
string argument of the @code{printf} functions to be a string constant,
and by doing more rigorous checks than the C version of @code{printf}.

@heading Functions
@example
int    printf(string s, ...);
int    fprintf(FILE @@f, string s, ...);
string xprintf(string s, ...);
@end example

@heading Use

@defun printf (s,...)
Prints to the standard output according to the format string @var{s} and
the remaining arguments.  It returns the number of characters printed,
or a negative value if an output error or encoding error occurred.
@end defun

@defun fprintf (f,s,...)
Prints to the stream pointed to by @var{f} according to the format
string @var{s} and the remaining arguments.  It returns the number of
characters printed, or a negative value if an output error or encoding
error occurred.
@end defun

@defun xprintf (s,...)
Allocates and returns a string whose contents are given by printing
according to the format string @var{s} and the remaining arguments.
FIX: is an error possible?  What do we do then?
@end defun

@heading Format strings

Cyclone requires the format string arguments of @code{printf},
@code{fprintf}, and @code{xprintf} to be string constants, and it checks
the remaining arguments for consistency at compile time.

The format string consists of ordinary (non-@code{%}) characters, which
are copied to the output, and @emph{conversion specifications}, which
are sequences of characters introduced by @code{%}.  Each conversion
specification `converts' zero or more arguments to the output, as
described below.

A conversion specification has the following parts, described, in order,
by regular expressions:
@itemize
@item Zero or more @emph{flags}:
[@code{-} @code{+} @emph{space} @code{#} @code{0}]*
@item An optional minimal @emph{width}:
(@code{*} | [@code{0}-@code{9}]+)?
@item An optional @emph{precision}:
(@code{.} (@code{*} | [@code{0}-@code{9}]+)? )?
@item An optional @emph{length modifier}:
(@code{l} | @code{h} | @code{hh} )
@item A @emph{conversion specifier}:
[@code{d} @code{i} @code{o} @code{u} @code{x} @code{X} @code{f} @code{F} @code{e} @code{E} @code{g} @code{G} @code{a} @code{A} @code{c} @code{s} @code{n} @code{%}]
@end itemize

The flag @code{-} causes left justification; right justification is the
default.  The flag @code{+} is valid for numeric conversions only; it
forces a @code{+} sign to be printed for positive arguments.  The flag
@emph{space} (the space character) is valid for numeric conversions only;
it causes an extra space to be printed in front of positive arguments.
It is ignored if the @code{+} flag is also given.
The flag @code{#} is valid for @code{o}, @code{x}, @code{X}, @code{a},
@code{A}, @code{e}, @code{E}, @code{f}, @code{F}, @code{g}, @code{G}
only; it causes an "alternative form" to be printed.  For @code{o} it
forces a leading zero to be printed; for @code{x} and @code{X}, a
leading @code{0x} or @code{0X} is added to non-zero conversions; for the
other conversions, a decimal point is always printed.

The width of a conversion specification gives a minimum width for the
result of the conversion; if the conversion naturally gives a shorter
result, it is padded by spaces to the minimum width.  If the width has
the form @code{*}, the minimum width is given by an integer argument.

A precision is valid for numeric conversions only.  It gives the minimum
number of digits to appear for the @code{d}, @code{i}, @code{o},
@code{u}, @code{x}, and @code{X} conversions, the number of digits to
appear after the decimal point in the @code{a}, @code{A}, @code{e},
@code{E}, @code{f}, and @code{F} conversions, and the maximum number of
significant digits for the @code{g} and @code{G} conversions.  If the
precision has the form @code{.} @code{*}, it is given by an integer
argument.

The optional length modifier and conversion specifier give the type of
the corresponding argument, as shown in the table below.  If no type
appears, then the combination of conversion specifier and length
modifier is not allowed.

@example
   none           l                 h                hh
   ---------------------------------------------------------------
d: int            long              short            char
i: int            long              short            char
o: unsigned int   unsigned long     unsigned short   unsigned char
u: unsigned int   unsigned long     unsigned short   unsigned char
x: unsigned int   unsigned long     unsigned short   unsigned char
X: unsigned int   unsigned long     unsigned short   unsigned char
f: double
F: double
e: double
E: double
g: double
G: double
a: double
A: double
c: int
s: string
n: int @@          unsigned long @@   short @@          char @@
%  no arg
@end example

No flags, width, precision, or length modifiers are allowed for the
@code{s} and @code{%} conversions.

The @code{d} and @code{i} specifiers print their arguments as signed
decimal integers.

The @code{o} specifier prints its argument as an unsigned octal number.

The @code{u} specifier prints its argument as an unsigned decimal number.

The @code{x} and @code{X} specifiers print their arguments as unsigned
hexidecimal integers.

The @code{f} and @code{F} specifiers print their arguments in the form
[-]ddd.ddd (no exponents).

The @code{e} and @code{E} specifiers print their arguments using exponents.

The @code{g} and @code{G} specifiers print their arguments using either
the @code{f}/@code{F}
style or the @code{e}/@code{E} style, depending on the precision and the
argument.

The @code{a} and @code{A} specifiers print their arguments as
hexidecimal floating point numbers.

The @code{c} specifier prints its argument as an unsigned character.

The @code{s} specifier prints its argument as a zero terminated string.

The @code{n} specifier does not print its argument; instead, the number
of characters written up to the @code{n} specifier is stored where the
argument points.

The @code{%} specifier prints a @code{%} character.


@node Position, PP, Printf, Top
@chapter Position

@heading Header
@example
#include "position.h"
using Position;
@end example

@node PP, Queue, Position, Top
@chapter PP

@heading Header
@example
#include "pp.h"
using PP;
@end example

@node Queue, Ref, PP, Top
@chapter Queue

Namespace @code{Queue} defines generic, imperative, first-in-first-out
queues.

@heading Header
@example
#include "queue.h"
using Queue;
@end example

@heading Types
@tindex struct queue
@tindex Queue
@example
struct queue<`a>;
typedef struct queue<`a> @@Queue<`a>;
@end example

@heading Exceptions
@exindex Empty
@example
xenum exn @{ Empty @};
@end example

@code{Empty} is thrown by operations that expect a non-empty queue, but
receive an empty queue.

@menu
* Basic operations on queues::  
* Iterating over queues::       
@end menu

@node Basic operations on queues, Iterating over queues, Queue, Queue
@section Basic operations on queues
@heading Functions
@example
Queue<`a> create<`a>();
void      add<`a>(Queue<`a>,`a x);
`a        take<`a>(Queue<`a>);
`a        peek<`a>(Queue<`a>);
bool      is_empty<`a>(Queue<`a>);
void      clear<`a>(Queue<`a>);
int       length<`a>(Queue<`a>);  
@end example

@heading Use

@defun create ()
Creates a new, empty queue.
@end defun

@defun add (q,x)
Adds @var{x} to the end of queue @var{q}, by side effect.
@end defun

@defun take (q)
Removes an element from the front of queue @var{q} by side effect, and
returns the element.  If @var{q} is empty, @code{Empty} is thrown.
@code{peek(@var{q})} returns the element at the front of queue @var{q};
if @var{q} is empty, @code{Empty} is thrown.
@end defun

@defun is_empty (q)
Returns @code{true} if @var{q} is an empty queue.
@end defun

@defun clear (q)
Removes all elements from @var{q} by side effect.
@end defun

@defun length (q)
Returns the number of elements in queue @var{q}.
@end defun

@node Iterating over queues,  , Basic operations on queues, Queue
@section Iterating over queues
@heading Functions
@example
void iter<`a>(void f(`a), Queue<`a>);
void app<`a,`b>(`b f(`a), Queue<`a>);
@end example

@heading Use

@defun iter (f,q)
Applies the function @var{f} to the elements of queue @var{q}, in order
from front to back.  @var{f} is a function that returns void.
@end defun

@defun app (f,q)
Applies the function @var{f} to the elements of queue @var{q}, in order
from front to back.  @var{f} is a function that returns a boxed type.
@end defun

@node Ref, Rope, Queue, Top
@chapter Ref

Namespace @code{Ref} defines generic reference cells.

@heading Header
@example
#include "ref.h"
using Ref;
@end example

@heading Types
@tindex struct Reference
@tindex ref
@example
struct Reference<`a> @{`a v;@};
typedef struct Reference<`a> @@ref<`a>;
@end example

@heading Functions
@example
ref<`a> new_ref<`a>(`a);
`a get<`a>(ref<`a>);
void set<`a>(ref<`a>,`a);
@end example

@heading Use

@defun new_ref (x)
Returns a new reference cell holding @var{x}.
@end defun

@defun get (r)
Returns the value held in reference cell @var{r}.
@end defun

@defun set (r,x)
Updates the value held in cell @var{r} with @var{x}.
@end defun

@node Rope, Scanf, Ref, Top
@chapter Rope

Namespace @code{Rope} defines a representation of character strings that
can be concatenated in constant time.

@heading Header
@example
#include "rope.h"
using Rope;
@end example

@heading Types
@tindex struct Rope_node
@tindex rope
@example
struct Rope_node;
typedef struct Rope_node @@rope;
@end example

@menu
* Basic operations on ropes::   
* Converting between ropes and strings::  
* Concatenation::               
@end menu

@node Basic operations on ropes, Converting between ropes and strings, Rope, Rope
@section Basic operations on ropes
@heading Functions
@example
uint length(rope);
int cmp(rope,rope);
@end example

@heading Use

@defun length (r)
Returns the number of characters in the string represented by rope
@var{r}.
@end defun

@defun cmp (r1,r2)
Returns an integer less than, equal to, or greater than 0, according to
whether the string represented by @var{r1} is lexicographically less
than, equal to, or greater than the string represented by @var{r2}.
@end defun

@node Converting between ropes and strings, Concatenation, Basic operations on ropes, Rope
@section Converting between ropes and strings
@heading Functions
@example
rope from_string(string);
string to_string(rope);
@end example

@heading Use

@defun from_string (s)
Allocates and returns a new rope containing string @var{s}.
@end defun

@defun to_string (r)
Converts rope @var{r} to a string and returns it.
@end defun

@node Concatenation,  , Converting between ropes and strings, Rope
@section Concatenation
@heading Functions
@example
rope concat(rope,rope);
rope concata(rope[?]);
rope concatl(List::list<rope>);
@end example

@heading Use

@defun concat (r1,r2)
Returns a rope containing the concatenation of @var{r1} and @var{r2}.
@end defun

@defun concata (arr)
Returns a rope containing the concatenation of the ropes in array
@var{arr}, from left to right.
@end defun

@defun concatl (l)
Returns a rope containing the concatenation of the ropes in list
@var{l}, from left to right.
@end defun

@node Scanf, Set, Rope, Top
@chapter Scanf

Cyclone provides safe versions of @code{scanf} and @code{fscanf} as
built-in primitives.  @code{sscanf} is not yet supported.

@heading Functions
@example
int    scanf(string s,...);
int    fscanf(FILE @@ f, string s,...);
@end example

@heading Use

@defun scanf (s,...)
Reads from the standard input according to the format string @var{s}.
Results are stored in the remaining arguments.
@code{scanf} returns the number of arguments successfully read.
If an error occurs before any arguments are converted, @code{EOF} is
returned.
@end defun

@defun fprintf (f,s,...)
Reads from the stream @var{f} according to the format string @var{s}.
Results are stored in the remaining arguments.
@code{fscanf} returns the number of arguments successfully read.
If an error occurs before any arguments are converted, @code{EOF} is
returned.
@end defun

@heading Format strings

Cyclone requires the format string arguments of @code{scanf} and
@code{fscanf} to be string constants, and it checks the remaining
arguments for consistency at compile time.

The format string consists of white space characters (which match any
(possible empty) sequence of white space characters), ordinary
(non-@code{%}) characters (which match themselves), and @emph{conversion
specifications}, which are sequences of characters introduced by
@code{%}.  Each conversion specification `converts' a sequence of
characters from the input stream, placing the result into storage
pointed to by the corresponding argument of @code{scanf} or
@code{fscanf}.

A conversion specification has the following parts, described, in order,
by regular expressions:
@itemize
@item An optional assignment suppression character, @code{*}
@item An optional maximal @emph{width}:
([@code{0}-@code{9}]+)?
@item An optional @emph{length modifier}:
(@code{l} | @code{h} | @code{hh} )
@item A @emph{conversion specifier}:
[@code{d} @code{i} @code{o} @code{u} @code{x} @code{X} @code{f} @code{F} @code{e} @code{E} @code{g} @code{G} @code{a} @code{A} @code{n} @code{%}]
@end itemize

If the assignment suppression character @code{*} is given, the
characters corresponding to the conversion specifier are read, but no
argument is assigned, and no argument is required for that specifier.

The optional length modifier and conversion specifier give the type of
the corresponding argument, as shown in the table below.  If no type
appears, then the combination of conversion specifier and length
modifier is not allowed.

@example
   none             l                 h                  hh
   ---------------------------------------------------------------------
d: int @@            long @@            short @@            char @@
i: int @@            long @@            short @@            char @@
o: unsigned int @@   unsigned long @@   unsigned short @@   unsigned char @@
u: unsigned int @@   unsigned long @@   unsigned short @@   unsigned char @@
x: unsigned int @@   unsigned long @@   unsigned short @@   unsigned char @@
X: unsigned int @@   unsigned long @@   unsigned short @@   unsigned char @@
f: float@@           double@@
F: float@@           double@@
e: float@@           double@@
E: float@@           double@@
g: float@@           double@@
G: float@@           double@@
a: float@@           double@@
A: float@@           double@@
n: int @@            unsigned long @@   short @@            char @@
%  no arg
@end example

The @code{d} and @code{i} specifiers match optionally signed decimal
integers.

The @code{o} specifier matches an optionally signed octal integer.

The @code{u} specifier matches an optionally signed decimal integer.

The @code{x} and @code{X} specifiers match optionally signed hexidecimal
integers.

The @code{f}, @code{F}, @code{e}, @code{E}, @code{g}, @code{G},
@code{a}, and @code{A} specifiers match floating point numbers.

The @code{n} specifier does not match any input; instead, the number of
characters read by the call of @code{fscanf} or @code{scanf} up to the
@code{n} specifier is stored where the argument points.

The @code{%} specifier matches a @code{%} character.  No assignment
suppression, width, or length modifiers are allowed for the @code{%}
conversion.

@node Set, Splay, Scanf, Top
@chapter Set

Namespace @code{Set} defines polymorphic, functional, finite sets of
elements with a total order.

@heading Header
@example
#include "set.h"
using Set;
@end example

@heading Types
@tindex struct set
@tindex Set
@example
struct set<`a>;
typedef struct set<`a> @@Set<`a>;
@end example

@heading Exceptions
@exindex Absent
@example
xenum exn @{Absent@};
@end example

@menu
* Creating sets::               
* Basic set operations::        
* Predicates on sets ::         
* Iterating over sets::         
* Extracting elements of sets::  
@end menu

@node Creating sets, Basic set operations, Set, Set
@section Creating sets

@heading Functions
@example
Set<`a> empty<`a>(int comp(`a,`a));
Set<`a> singleton<`a>(int comp(`a,`a),`a @var{x});
Set<`a> from_list<`a>(int comp(`a,`a),list<`a> @var{x});
@end example

@heading Use

Each set creation function requires an comparison function @var{comp}
which should return an integer less than, equal to, or greater than 0,
according to whether its first argument is less than, equal to, or
greater than its second argument.

@defun empty (comp)
Allocates and returns a new empty set.
@end defun

@defun singleton (comp,x)
Allocates and returns a new set containing the single element @var{x}.
@end defun

@defun from_list (comp,l)
Allocates and returns a new set with the same elements as the list
@var{l}.
@end defun

@node Basic set operations, Predicates on sets , Creating sets, Set
@section Basic set operations
@heading Functions
@example
Set<`a> insert<`a>(Set<`a> s,`a elt);
Set<`a> delete<`a>(Set<`a> s,`a elt);
Set<`a> union_two<`a>(Set<`a> s1,Set<`a> s2);
Set<`a> intersect<`a>(Set<`a> s1,Set<`a> s2);
Set<`a> diff<`a>(Set<`a> s1,Set<`a> s2);
@end example

@heading Use

@defun insert (s,elt)
Returns a set containing the elements of @var{s} plus the element
@var{elt}.  The set @var{s} is not affected.
@end defun

@defun delete (s,elt)
Returns a set containing all the elements of @var{s}, except for
@var{elt}.  If @var{s} does not contain @var{elt}, a set with the same
elements as @var{s} is returned.
@end defun

@defun union_two (s1,s2)
Returns a set whose elements are the union of the elements of @var{s1}
and @var{s2}.  The name @code{union_two} is used because @code{union} is
a keyword in Cyclone.
@end defun

@defun difference (s1,s2)
Returns a set whose elements are the elements of @var{s1}, except for
those elements that also in set @var{s2}.
@end defun

@defun intersection (s1,s2)
Returns the intersection of @var{s1} and @var{s2}.
@end defun

@node Predicates on sets , Iterating over sets, Basic set operations, Set
@section Predicates on sets
@heading Functions
@example
int  cardinality<`a>(Set<`a> s);
bool is_empty<`a>(Set<`a> s);
bool member<`a>(Set<`a> s,`a elt);
bool subset<`a>(Set<`a> s1,Set<`a> s2);
int  compare<`a>(Set<`a> s1,Set<`a> s2);
bool equals <`a>(Set<`a> s1,Set<`a> s2);
@end example

@heading Use

@defun cardinality (s)
Returns the number of elements in set @var{s}.
@end defun

@defun is_empty (s)
Returns true if the set @var{s} is empty, else it returns false.
@end defun

@defun member (s,elt)
Returns true if @var{elt} is an element of @var{s}.
@end defun

@defun subset (s1,s2)
Returns true if every element of @var{s1} is an element of @var{s2}.
@end defun

@defun compare (s1,s2)
The function @code{compare} defines a total ordering on sets;
@code{compare(@var{s1},@var{s2})} returns an integer less than, equal
to, or greater than 0, according to whether its first argument is less
than, equal to, or greater than its second argument.
@end defun

@defun equals (s1,s2)
Returns true if @var{s1} is a subset of @var{s2} and @var{s2} is a
subset of @var{s1}.
@end defun

@node Iterating over sets, Extracting elements of sets, Predicates on sets , Set
@section Iterating over sets
@heading Functions
@example
void app<`a,`b>(`b f(`a),Set<`a> s);
void iter<`a>(void f(`a),Set<`a> s);
void iter_c<`a,`c>(void f(`c,`a),`c env,Set<`a> s);

`b   fold<`a,`b>(`b f(`a,`b),Set<`a> s,`b accum);
`b   fold_c<`a,`b,`c>(`b f(`c,`a,`b),`c env,Set<`a> s,`b accum);
@end example

@heading Use

@defun app (f,s)
Applies function @var{f} to each element of set @var{s}, in some
unspecified order.  @var{f} is a function returning a boxed value.
@end defun

@defun iter (f,s)
Applies function @var{f} to each element of set @var{s}, in some
unspecified order.  @var{f} is a function returning void.
@end defun

@defun iter_c (f,env,s)
A version of @code{iter} where @var{f} takes a closure, @var{env}.
@end defun

@defun fold (f,s,accum)
If the set @var{s} has elements @var{s1} through @var{sn}, then
@code{fold(@var{f},@var{s},@var{accum})} returns
@example
@var{f}(@var{s1},@var{f}(@var{s2}, ... @var{f}(@var{sn},@var{accum}) ... ))
@end example
@end defun

@defun fold_c (f,env,s,accum)
A version of @var{fold} where @var{f} takes a closure @var{env}.
@end defun

@node Extracting elements of sets,  , Iterating over sets, Set
@section Extracting elements of sets
@heading Functions
@example
`a choose<`a>(Set<`a> s);
list<`a> elements<`a>(Set<`a> s);
@end example

@heading Use

@defun choose (s)
Returns an unspecified element of set @var{s}.
@end defun

@defun elements (s)
Returns all of the elements of set @var{s} in some unspecified order.
@end defun

@node Splay, String, Set, Top
@chapter Splay

@heading Header
@example
#include "splay.h"
using Splay;
@end example

@node String, Xarray, Splay, Top
@chapter String

Namespace @code{String} implements a string library similar to the one
provided by C.  In Cyclone, a string is a @code{char[?]}.  Most
functions in String consider a zero (null) character as an end of string
marker, so we may have @code{strlen(@var{s}) < size(@var{s})} for a
string @var{s}.  Functions that do not follow this convention have names
starting with 'z'.  Many functions accept a string and an offset; these
functions may have names ending in 'o'.  Functions whose arguments have
range errors throw the @code{Core::InvalidArg} exception.

@heading Header
@example
#include "string.h"
using String;
@end example

@menu
* String length::               
* Comparing strings::           
* Concatenating strings::       
* Copying strings and substrings::  
* Transforming strings::        
* Searching in strings::        
* String conversions::          
@end menu

@node String length, Comparing strings, String, String
@section String length
@heading Functions
@example
size_t strlen(string @var{s});
size_t strleno(string @var{s}, int ofs);
@end example

@heading Use

@defun strlen (s)
Returns the length of the string @var{s}.  It considers a null
character to mark the end of the string.
@end defun

@defun strleno(s,ofs)
Returns the length of the string starting from offset @var{ofs}.  If
@var{ofs} is out of range, @code{strleno} throws
@code{Core::InvalidArg("String::strleno")}.
@end defun

@node Comparing strings, Concatenating strings, String length, String
@section Comparing strings
@heading Functions
@example
int strcmp(string @var{s1}, string @var{s2});
int strcmpo(string @var{s1}, int ofs1, string @var{s2}, int ofs2);
int strncmp(string @var{s1}, int ofs1, string @var{s2}, int ofs2, size_t len);
int strncasecmp(string @var{s1}, int ofs1, string @var{s2}, int ofs2, size_t len);
int zstrcmp(string,string);
int zstrncmp(string @var{s1},string @var{s2},size_t @var{n});
@end example

@heading Use

All of these functions return an integer less than, equal to, or greater
than 0 if their first argument is less than, equal to, or greater than
their second argument, respectively.  The ordering used is the standard,
lexicographic ordering.

@defun strcmp (s1,s2)
Compares @var{s1} to @var{s2}.
@end defun

@defun strcmpo (s1,ofs1,s2,ofs2)
Compares @var{s1} starting at offset @var{ofs1} to @var{s2} starting at
@var{ofs2}.  If @var{ofs1} or @var{ofs2} is out of range, @code{strcmpo}
throws @code{Core::InvalidArg("String::strcmpo")}.
@end defun

@defun strncmp (s1,ofs1,s2,ofs2,len)
Compares at most @var{len} characters of @var{s1} starting at offset
@var{ofs1} to @var{s2} starting at @var{ofs2}.  If @var{ofs1} or
@var{ofs2} is out of range, @code{strncmp} throws
@code{Core::InvalidArg("String::strncmp")}.  If @var{len} is negative,
@code{strncmp} returns 0.
@end defun

@defun strncasecmp (s1,ofs1,s2,ofs2,len)
A case-insensitive version of @code{strncmp}.
@end defun

@defun zstrcmp (s1,s2)
Compares @var{s1} to @var{s2}, and it assumes that null (zero)
characters in @var{s1} and @var{s2} are not end-of-string markers.
@end defun

@defun zstrcmp (s1,s2,n)
Compares at most @var{n} characters of @var{s1} to @var{s2}, assuming
that null characters do not mark the end of strings.  If @var{n} is less
than 0, @code{zstrcmp(@var{s1},@var{s2},@var{n})} returns 0.
@end defun

@node Concatenating strings, Copying strings and substrings, Comparing strings, String
@section Concatenating strings
@heading Functions
@example
string strcat(string dest,string src);
string strcato(string dest,string src,int srcOfs);
string strconcat(string,string);
string strconcat_l(list<string>);
string str_sepstr(list<string>,string);
@end example

@heading Use

@defun strcat (dest,src)
Concatenates @var{src} onto @var{dest} and returns @var{dest}.  If
@var{dest} is not large enough, @code{strcat} throws
@code{Core::InvalidArg("String::strcat")}.
@end defun

@defun strcato (dest,src,srcOfs)
Concatenates @var{src} staring at @var{srcOfs} onto @var{dest} and
returns @var{dest}.  If @var{dest} is not large enough, @code{strcat}
throws @code{Core::InvalidArg("String::strcato")}.
@end defun

@defun strconcat (s1,s2)
Allocates and returns a new string whose contents are the concatenation
of @var{s1} and @var{s2}.
@end defun

@defun strconcat_l (l)
Allocates and returns a new string whose contents are the concatenation
of the strings in the list @var{l}, from left to right.
@end defun

@defun str_sepstr (l,s)
Allocates and returns a new string whose contents are the concatenation
of the strings in the list @var{l}, with @var{s} used as a separator
between each two adjacent elements in @var{l}.
@end defun

@node Copying strings and substrings, Transforming strings, Concatenating strings, String
@section Copying strings and substrings
@heading Functions
@example
string strcpy(string dest,string src); 
string strncpy(string,int,string,int,size_t);
string zstrncpy(string,int,string,int,size_t);
string expand(string @var{s}, size_t sz);
string realloc_str(string str, size_t sz);
string strdup(string src);
string substring(string,int ofs, size_t @var{n});
@end example

@heading Use

@defun strcpy (dest,src)
Copies @var{src} into @var{dest} and returns @var{dest}.  If @var{dest}
is not big enough to hold @var{src}, @code{strcpy} throws
@code{Core::InvalidArg("String::strncpy")}.
@end defun

@defun strncpy (dest,destOfs,src,srcOfs,len)
Copies at most @var{len} characters of @var{src} starting at offset
@var{srcOfs} into @var{dest} starting at @var{destOfs}, and returns
@var{dest}.  If @var{dest} is not big enough to hold @var{src}, or
@var{srcOfs} or @var{destOfs} are out of bounds, @code{strcpy} throws
@code{Core::InvalidArg("String::strncpy")}.
@end defun

@defun zstrncpy (dest,destOfs,src,srcOfs,len)
A variant of @code{strncpy} that does not consider null characters to
terminate strings.
@end defun

@defun expand (s,n)
Allocates and returns a new string that has size @var{n} or
@code{strlen(@var{s})}, whichever is greater.  The returned string has
the same contents as @var{s} (considering null characters as string
terminators).
@end defun

@defun realloc_str (s,n)
Like expand except that the returned string is usually a bit bigger than
@var{n} and @code{strlen(@var{s})}.
@end defun

@defun strdup (s)
Allocates and returns a new string with the same contents as @var{s}
(assuming that null characters terminate strings).
@end defun

@defun substring (s,ofs,len)
Allocates and returns a new string whose contents are @var{len}
characters of @var{s} starting at offset @var{ofs}.  If @var{ofs} or
@var{len} are out of bounds then substrings throws
@code{Core::InvalidArg("String::substring")}.
@end defun

@node Transforming strings, Searching in strings, Copying strings and substrings, String
@section Transforming strings
@heading Functions
@example
string replace_suffix(string,string,string);
@end example

@heading Use

@defun replace_suffix (s,before,after)
Allocates and returns a string whose characters are the characters of
@var{s}, with its suffix before replaced by the string after.  If before
is not a suffix of @var{s}, then @code{replace_suffix} throws
@code{Core::InvalidArg("String::replace_suffix")}.
@end defun

@node Searching in strings, String conversions, Transforming strings, String
@section Searching in strings
@heading Functions
@example
int strchr(string @var{s}, int ofs, char @var{c});
int strrchr(string @var{s}, int ofs, char @var{c});
int strpbrk(string @var{s}, int ofs, string accept);
int strspn(string @var{s}, int ofs, string accept);
@end example

@heading Use

@defun strchr (s,ofs,c)
Returns the lowest index @code{@var{i} >= @var{ofs}} such that
@code{@var{s}[@var{i}] == @var{c}}.  If @var{ofs} is out of range strchr
throws @code{Core::InvalidArg("String::strchr")}.  If @var{c} does not
appear in @var{s} starting at @var{ofs}, @code{strchr} returns -1.
@end defun

@defun strrchr (s,ofs,c)
Returns the greatest index @code{@var{i} >= @var{ofs}} such that
@code{@var{s}[@var{i}] == @var{c}}.  If @var{ofs} is out of range,
@code{strrchr} throws @code{Core::InvalidArg("String::strrchr")}.  If
@var{c} does not appear in @var{s} starting at @var{ofs}, @code{strrchr}
returns -1.
@end defun

@defun strpbrk (s,ofs,accept)
Returns the lowest index @code{@var{i} >= @var{ofs}} such that
@code{@var{s}[@var{i}] == @var{c}}, where @var{c} is any character of
accept.  If @var{ofs} is out of range, strpbrk throws
@code{Core::InvalidArg("String::strpbrk")}.  If no character of accept
appears in @var{s} starting at @var{ofs}, @code{strpbrk} returns -1.
@end defun

@defun strspn (s,ofs,accept)
Returns the lowest index @code{@var{i} >= @var{ofs}} such that
@code{@var{s}[@var{i}] == @var{c}}, where @var{c} is any character not
in the string @var{accept}.  If @var{ofs} is out of range, @code{strspn}
throws @code{Core::InvalidArg("String::strpbrk")}.  If no character of
@var{accept} appears in @var{s} starting at @var{ofs}, @code{strspn}
returns the length of @var{s} after @var{ofs}.
@end defun

@node String conversions,  , Searching in strings, String
@section String conversions
@heading Functions
@example
list<Char> explode(string @var{s});
string implode(list<Char> @var{c});
@end example

@heading Use

@defun explode (s)
Returns a list of the characters in string @var{s}.
@end defun

@defun implode (l)
Allocates and returns a string whose contents are the characters in list
@var{l}, from left to right.
@end defun

@node Xarray, Function index, String, Top
@chapter Xarray

Namespace @code{Xarray} defines arrays that can grow: they can be
extended by new elements.  (Currently, an xarray cannot shrink.)

@heading Header
@example
#include "xarray.h"
using Xarray;
@end example

@heading Types
@tindex struct xarray
@tindex Xarray
@example
struct xarray<`a> @{
  `a elmts[?];
  int num_elmts;
@};
typedef struct xarray<`a> @@Xarray<`a>;
@end example

@menu
* Creating xarrays::            
* Accessing and updating xarrays::  
* Conversions on xarrays::      
* Iteration on xarrays::        
* Mapping over xarrays::        
* Miscellaneous operations on xarrays::  
@end menu

@node Creating xarrays, Accessing and updating xarrays, Xarray, Xarray
@section Creating xarrays
@heading Functions
@example
Xarray<`a> create<`a>(int, `a);
Xarray<`a> create_empty<`a>();
Xarray<`a> singleton<`a>(int, `a);
@end example

@heading Use

@defun create_empty ()
Returns a new xarray containing no elements.
@end defun

@defun create (n,x)
Returns a new xarray containing no elements.  The xarray has enough
initial internal storage to hold up to @var{n} elements without
resizing; @var{x} is used internally in allocating this array.
@end defun

@defun singleton (n,x)
Returns a new xarray with a single element, @var{x}.  The xarray has
enough initial internal storage to hold up to @var{n} elements without
resizing.
@end defun

@node Accessing and updating xarrays, Conversions on xarrays, Creating xarrays, Xarray
@section Accessing and updating xarrays
@heading Functions
@example
`a         get<`a>(Xarray<`a>, int);
void       set<`a>(Xarray<`a>, int, `a);
void       add<`a>(Xarray<`a>, `a);
int        add_ind<`a>(Xarray<`a>, `a);
Xarray<`a> append<`a>(Xarray<`a>, Xarray<`a>);
void       imp_append<`a>(Xarray<`a>, Xarray<`a>);
void       delete<`a>(Xarray<`a> xarr, int num);
void       remove<`a>(Xarray<`a> xarr, int @var{i});
@end example

@heading Use

@defun get (a,n)
Returns the @var{n}th element of array @var{a}.  If @var{a} does not
have an @var{n}th element, get throws InvalidArg("Xarray::get: bad
index").
@end defun

@defun set (a,n,x)
Updates the @var{n}th element of @var{a} to be @var{x}.  If @var{a} does
not have an @var{n}th element, set throws InvalidArg("Xarray::set: bad
index").
@end defun

@defun add (a,x)
Extends the array @var{a} by adding @var{x} as a new last element.
@end defun

@defun add_ind (a,x)
Extends the array @var{a} by adding @var{x} as a new last element.  It
returns the index of the new element.
@end defun

@defun append (a1,a2)
Returns a new xarray whose elements are the elements of @var{a1}
followed by the elements of @var{a2}.
@end defun

@defun imp_append (a1,a2)
An imperative version of append.  It extends array @var{a1} by the
elements of @var{a2}.
@end defun

@defun delete (a,n)
Deletes the last @var{n} elements of array @var{a}.  FIX: IT'S IN THE .H
FILE BUT NOT DEFINED IN THE .CYC FILE!  It should throw some exception
if @var{a} has less than @var{n} elements.
@end defun


@defun remove (a,n)
Deletes the @var{n}th element of array @var{a}; all higher elements move
down one position.  FIX: IT'S IN THE .H FILE BUT NOT DEFINED IN THE .CYC
FILE!  It should throw some exception if @var{a} has less than @var{n}
elements.
@end defun

@node Conversions on xarrays, Iteration on xarrays, Accessing and updating xarrays, Xarray
@section Conversions on xarrays
@heading Functions
@example
`a         to_array<`a>(Xarray<`a>) [?];
Xarray<`a> from_array<`a>(`a arr[?]);
@end example

@heading Use

@defun to_array (a)
Returns a new (non-extensible) array with the same elements as the
xarray @var{a}.
@end defun

@defun from_array (b)
Returns a new xarray with the same elements as the array @var{b}.
@end defun

@node Iteration on xarrays, Mapping over xarrays, Conversions on xarrays, Xarray
@section Iteration on xarrays
@heading Functions
@example
void app<`a,`b>(`b f(`a), Xarray<`a>);
void app_c<`a,`b,`c>(`b f(`c,`a), `c, Xarray<`a>);
void iter<`a>(void f(`a), Xarray<`a>);
void iter_c<`a,`b>(void f(`b,`a), `b, Xarray<`a>);
@end example

@heading Use

@defun app (f,a)
Applies the function @var{f} to every element of @var{a}, in order from
low to high index.  The results of the applications are discarded.
@end defun

@defun app_c (f,env,a)
A version of app where the function @var{f} takes a closure.
@end defun

@defun iter (f,a)
A version of app where the function @var{f} returns void.
@end defun

@defun iter_c (f,env,a)
A version of iter where the function @var{f} takes a closure.
@end defun

@node Mapping over xarrays, Miscellaneous operations on xarrays, Iteration on xarrays, Xarray
@section Mapping over xarrays
@heading Functions
@example
Xarray<`b> map<`a,`b>(`b @var{f}(`a), Xarray<`a>);
Xarray<`b> map_c<`a,`b,`c>(`b @var{f}(`c,`a), `c, Xarray<`a>);
@end example

@heading Use

@defun map (f,a)
Returns an xarray with elements @var{f}(@var{x1})..@var{f}(xn), where
@var{x1}..@var{xn} are the elements of xarray @var{a}.
@end defun

@defun map_c (f,env,a)
A version of map where the function @var{f} takes a closure argument.
@end defun

@node Miscellaneous operations on xarrays,  , Mapping over xarrays, Xarray
@section Miscellaneous operations on xarrays
@heading Functions
@example
int length<`a>(Xarray<`a>);
void reuse<`a>(Xarray<`a> xarr);
@end example

@heading Use

@defun length (a)
Returns the number of elements in the xarray @var{a}.
@end defun

@defun reuse (a)
Sets the number of elements in xarray @var{a} to 0.
@end defun

@node Function index, Type index, Xarray, Top
@unnumbered Function index
@printindex fn

@node Type index, Exception index, Function index, Top
@unnumbered Type index
@printindex tp

@node Exception index,  , Type index, Top
@unnumbered Exception index
@printindex ex

@contents
@bye
