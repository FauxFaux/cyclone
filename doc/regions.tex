\section{Memory Management Via Regions}
\label{sec:regions}

%Contents: Introduction, Allocation, Common Uses, Type-Checking Regions

\subsection{Introduction}

C gives programmers complete control over how memory is managed.  An expert
programmer can exploit this to write very fast and/or space-efficient
programs.  However, bugs that creep into memory-management code can cause
crashes and are notoriously hard to debug.

Languages like Java and ML use garbage collectors instead of leaving
memory management in the hands of ordinary programmers.  This makes
memory management much safer, since the garbage collector is written
by experts, and it is used, and, therefore, debugged, by every
program.  However, removing memory management from the control of the
applications programmer can make for slower programs.

Safety is the main goal of Cyclone, so we provide a garbage collector.
But, like C, we also want to give programmers as much control over
memory management as possible, without sacrificing safety.  Cyclone's
region system is a way to give programmers more explicit control over
memory management.

In Cyclone, objects are placed into \emph{regions}.  A region is simply an
area of memory that is allocated and deallocated all at once (but not for
our two special regions; see below).  So to deallocate an object, you
deallocate its region, and when you deallocate a region, you deallocate all
of the objects in the region.  Regions are sometimes called ``arenas'' or
``zones.''

Cyclone has six kinds of region:
\begin{description}
\item[Stack regions] As in C, local variables are allocated on the
  runtime stack; the stack grows when a block is entered, and it
  shrinks when the block exits.  We call the area on the stack
  allocated for the local variables of a block the \emph{stack region}
  of the block.  A stack region has a fixed size---it is just large
  enough to hold the locals of the block, and no more objects can be
  placed into it.  The region is deallocated when the block containing
  the declarations of the local variables finishes executing.  With
  respect to regions, the parameters of a function are considered
  locals---when a function is called, its actual parameters are placed
  in the same stack region as the variables declared at the start of
  the function.
  
\item[Lexical regions] Cyclone also has \emph{lexical regions}, which are so
  named because, like stack regions, their lifetime is delimited by the
  surrounding scope.  Unlike stack regions, however, you can can add new
  objects to a lexical region over time.  You create a lexical region in
  Cyclone with a statement,
\begin{alltt}
  region {\it identifier}; {\it statement}
\end{alltt}
  This declares and allocates a new dynamic region, named
  \textit{identifier}, and executes \textit{statement}.  After
  \textit{statement} finishes executing, the region is deallocated.
  Within \textit{statement}, objects can be added to the region, as we
  will explain below.

  Typically, \textit{statement} is a compound statement:
\begin{alltt}
  \lb region \textit{identifier};
    {\it statement}\(\sb{1}\)
    \ldots
    {\it statement}\(\sb{n}\)
  \rb
\end{alltt}

\item[The heap region] Cyclone has a special region called the
  \emph{heap}. There is only one heap, whose type is denoted \texttt{`H},
  and it is never deallocated.  New objects can be added to the heap at any
  time (the heap can grow).  Cyclone uses a garbage collector to
  automatically remove objects from the heap when they are no longer needed.
  You can think of garbage collection as an optimization that tries to keep
  the size of the heap small.  (Alternatively, you can avoid garbage
  collection all together by specifying the \texttt{-nogc} flag when
  building the executable.)

\item[Dynamic regions]  Stack and lexical regions obey a strictly
  last-in-first-out (LIFO) lifetime discipline.  This is often
  convenient for storing temporary data, but sometimes, the lifetime
  of data cannot be statically determined.  Such data can be allocated
  in a \emph{dynamic region}.  A dynamic region supports deallocation
  at (essentially) any program point.  However, before the data in a
  dynamic region may be accessed, the dynamic region must be \emph{opened}.
  The open operation fails by throwing an exception if the dynamic
  region has already been freed.  Note that each data access within
  a dynamic region does not require a check.  Rather, you can open
  a given dynamic region once, access the data many times with no
  additional cost, and then exit the scope of the open.  Thus, 
  dynamic regions amortize the cost of checking whether or not data
  are still live and localize failure points.  

\item[The unique region] All of the regions mentioned thus far only permit
  deallocation \emph{en masse.}  Cyclone also defines the \emph{unique
  region}, whose type is denoted \texttt{`U}, which allows objects to be
  deallocated individually, using the function \texttt{ufree}.  For freeing
  objects to be safe, we only allow access to objects in \texttt{`U} via
  \emph{unique pointers}.  That is, only a single pointer may be used to
  access the object at any given time; this trivially guarantees that if the
  object is freed through its unique pointer, no other access to the object
  beyond that point is possible.  Objects that become unreachable but are
  not freed manually will be freed by the garbage collector (assuming it's
  not removed with \texttt{-nogc}).

\item[The reference-counted region] The reference-counted region, denoted
  \texttt{`RC}, also permits freeing individual objects.  Unlike the unique
  region, multiple pointers to a single object are permitted, the number of
  which is tracked dynamically via a hidden reference count stored with the
  object.  Additional pointers to an object are created explicitly via a
  call to \texttt{alias\_refptr}, which increases the reference count.
  Individual pointers are removed via a call to \texttt{drop\_refptr}; when
  the last pointer is removed (i.e. the reference count is 0), the object is
  freed.  Like the unique region, objects that become unreachable will be
  freed by the garbage collector.
\end{description}

%% Objects outside of the heap and unique region live until their region is
%% deallocated; there is no way to free such an object earlier.  Objects in the
%% heap or unique region can be garbage collected once they are unreachable
%% (i.e., they cannot be reached by traversing pointers) from the program's
%% variables.  Objects in other regions always appear reachable to the garbage
%% collector (so everything reachable from them appears reachable as well).

Cyclone forbids dereferencing dangling pointers.  This restriction is part of
the type system: it's a compile-time error if a dangling pointer (a pointer
into a deallocated region or to a deallocated object) might be dereferenced.
There are no run-time checks of the form, ``is this pointing into a live
region?''  As explained below, each pointer type has a region and objects of
the type may only point into that region.

\subsection{Allocation}
You can create a new object on the heap using one of a few kinds of
expression: 
\begin{itemize}
\item \texttt{new {\it expr}} evaluates \textit{expr}, places the
  result into the heap, and returns a pointer to the result.  It is
  roughly equivalent to
\begin{alltt}
  t @ temp = malloc(sizeof(t));
  // where t is the type of expr
  *temp = {\it expr};
\end{alltt}
  For example, \texttt{new 17} allocates space for an integer on the
  heap, initializes it to 17, and returns a pointer to the space.  For
  another example, if we have declared
\begin{verbatim}
  struct Pair { int x; int y; };
\end{verbatim}
  then \texttt{new Pair(7,9)} allocates space for two integers on the
  heap, initializes the first to 7 and the second to 9, and returns a
  pointer to the first.

\item \texttt{new {\it array-initializer}} allocates space for an
  array, initializes it according to \textit{array-initializer}, and
  returns a pointer to the first element.  For example,
\begin{verbatim}
  let x = new { 3, 4, 5 };
\end{verbatim}
  declares a new array containing 3, 4, and 5, and initializes
  \texttt{x} to point to the first element.  More interestingly,
\begin{alltt}
  new \lb for {\it identifier} < {\it expr}\(\sb{1}\) : {\it expr}\(\sb{2}\) \rb
\end{alltt}
  is roughly equivalent to
\begin{alltt}
  unsigned int sz = {\it expr}\(\sb{1}\);
  t @ temp = malloc(sz * sizeof(t\(\sb{2}\))); // where t is the  type of expr
  for (int {\it identifier} = 0; {\it identifier} < sz; {\it identifier}++)
    temp[{\it identifier}] = {\it expr}\(\sb{2}\);
\end{alltt}
  That is, 
  {\it expr}\(\sb{1}\)
  is evaluated first to get the size of the new array,
  the array is allocated, and each element of the array is
  initialized by the result of evaluating
  {\it expr}\(\sb{2}\).
  {\it expr}\(\sb{2}\) may use {\it identifier}, which 
  holds the index of the element currently being initialized.
  
  For example, this function returns an array containing the first
  \texttt{n} positive even numbers:
\begin{verbatim}
  int *@fat n_evens(int n) {
    return new {for next < n :  2*(next+1)};
  }
\end{verbatim}

  Note that:
  \begin{itemize}
  \item {\it expr}\(\sb{1}\) is evaluated exactly once, while {\it
      expr}\(\sb{2}\) is evaluated {\it expr}\(\sb{1}\) times.
  \item {\it expr}\(\sb{1}\) might evaluate to 0.
  \item {\it expr}\(\sb{1}\) might evaluate to a negative number.
    If so, it is implicitly converted to a very large unsigned
    integer; the allocation is likely to fail due to insufficient
    memory.  Currently, this will cause a crash!!
  \item Currently, \texttt{for} array initializers are the only way to
    create an object whose size depends on run-time data.
  \end{itemize}

\item \texttt{malloc(sizeof({\it type}))}.  Returns a \texttt{@notnull}
  pointer to an uninitialized value of type \emph{type}.  

\item \texttt{malloc(n*sizeof({\it type}))} or 
      \texttt{malloc(sizeof({\it type})*n)}.  The type must be a bits-only
      type (i.e., cannot contain pointers, tagged unions, zero-terminated
      values, etc.)  If \texttt{n} is a compile-time constant expression,
      returns a \texttt{@thin} pointer with \texttt{@numelts(n)}.  If 
      \texttt{n} is not a compile-time constant, returns 
      a \texttt{@fat} pointer to the sequence of
      \texttt{n} uninitialized values.

\item \texttt{calloc(n,sizeof({\it type}))}.  Similar to 
      the malloc case above, but returns memory that is zero'd.  Therefore,
      \texttt{calloc} supports types that are bits-only or zero-terminated.

\item \texttt{malloc(e)} where \texttt{e} is an expression not of one
      of the above forms.  If \texttt{e} is constant, returns a
      \texttt{char *@numelts(e)@nozeroterm} otherwise 
      returns a \texttt{char *@fat@nozeroterm}.
\end{itemize}

Unique pointers can be allocated just as with the heap, but the context must
make clear that a unique pointer is desired.  For example, in the following
the variable \texttt{temp} is allocated in the heap:
\begin{alltt}
  t * temp = malloc(sizeof(t));
\end{alltt}
Modifying it slightly, we allocate into the unique region instead:
\begin{alltt}
  t *`U temp  =        malloc(sizeof(t));
  t *   temp2 = (t *`U)malloc(sizeof(t));
\end{alltt}
Unfortunately, our type inference system for allocation is overly simple, so
you can't do something like:
\begin{alltt}
  t * temp = malloc(sizeof(t));
  ufree(temp);
\end{alltt}
In an ideal world, the fact that \texttt{temp} was passed to \texttt{ufree}
would signal that it is a unique pointer, rather than a heap pointer.

Objects within lexical and reference-counted regions can be created using
the following analogous expressions.
\begin{itemize}
\item \texttt{rnew({\it identifier}) {\it expr}}
\item \texttt{rnew({\it identifier}) {\it array-initializer}}
\item \texttt{rmalloc({\it identifier},sizeof({\it type}))}
\item \texttt{rmalloc({\it identifier},n*sizeof({\it type}))}
\item \texttt{rmalloc({\it identifier},sizeof({\it type})*n)}
\item \texttt{rmalloc({\it identifier},e))}
\item \texttt{rcalloc({\it identifier},n,sizeof({\it type}))}
\end{itemize}
Note that \texttt{new}, \texttt{malloc}, \texttt{calloc}, 
\texttt{rnew}, \texttt{rmalloc} and \texttt{rcalloc} are keywords.

Here, the first argument specifies a region handle.  The Cyclone library has
global variables \texttt{Core::heap_region}, \texttt{Core::unique_region},
and \texttt{Core::refcnt\_region}, which are handles for the heap, unique,
and reference-counted regions, respectively.  So, for example, \texttt{rnew
(refcnt_region) {\it expr}} allocates memory in the reference-counted region
which is initialized with {\it expr}.  Moreover, \texttt{new {\it expr}} can
be replaced with \texttt{rnew(heap_region) {\it expr}}.
%% We also define a macro
%% \texttt{unew({\it expr})} that expands to \texttt{rnew(unique_region,{\it
%% expr})}.

To allocate an object inside a dynamic region, it must first be
\emph{opened}, revealing its region handle.  At that point, it is treated
just as if it were a lexical region.  The process of creating, opening, and
freeing dynamic regions is explained more below.

The only way to create an object in a stack region is declaring it as
a local variable.  Cyclone does not currently support \texttt{salloc};
use a lexical region instead.

\subsection{Common Uses}
\label{sec:common-use}

Although the type system associated with regions is complicated, there are
some simple common idioms.  If you understand these idioms, you should be
able to easily write programs using regions, and port many legacy C programs
to Cyclone.  The next subsection will explain the usage patterns of unique
and reference-counted pointers, since they are substantially more
restrictive than other pointers.

Remember that every pointer points into a region, and although the
pointer can be updated, it must always point into that same region (or
a region known to outlive that region).  The region that the pointer
points to is indicated in its type, but omitted regions are filled in
by the compiler according to context.

% \begin{verbatim}
%   int x = 7;
%   int *y = &x;
% \end{verbatim}
% Here the local variable \texttt{x} lives in a stack region, and
% \texttt{y} is declared as a heap pointer, so it cannot be assigned the
% address of \texttt{x}.

% To get \texttt{y} to point at \texttt{x}, you must declare it with a
% different type---it should be a pointer into the stack region.  The
% easiest way to do this is to let Cyclone figure out the type for you,
% either using a \texttt{let} declaration:
% \begin{verbatim}
%   int x = 7;
%   let y = &x;
% \end{verbatim}
% If you want to emphasize that \texttt{y} is a pointer to an integer,
% you can use the wildcard type to get Cyclone to fill in the region for
% you: 
% \begin{verbatim}
%   int x = 7;
%   int *_ y = &x;
% \end{verbatim}
% The wildcard (\texttt{_}) tells the compiler, ``fill in this part of
% the type for me.''

When regions are omitted from pointer types in function bodies, the
compiler tries to infer the region.  However, it can sometimes be too
``eager'' and end up rejecting code.  For example, in
\begin{verbatim}
void f1(int * x) {
  int * y = new 42;
  y = &x;
}
\end{verbatim}
the compiler uses y's initializer to decide that y's type is
\texttt{int * `H}.  Hence the assignment is illegal, the parameter's
region (called \texttt{`f1}) does not outlive the heap.  On the other
hand, this function type-checks:
\begin{verbatim}
void f2(int x) {
  int * y = &x;
  y = new 42;
}
\end{verbatim}
because y's type is inferred to be \texttt{int * `f2} and the
assignment makes y point into a region that outlives \texttt{`f2}.  We
can fix our first function by being more explicit:
\begin{verbatim}
void f1(int * x) {
  int *`f1 y = new 42;
  y = &x;
}
\end{verbatim}

Function bodies are the only places where the compiler tries to infer
the region by how a pointer is used.  In function prototypes, type
declarations, and top-level global declarations, the rules for the
meaning of omitted region annotations are fixed.  This is necessary
for separate compilation: we often have no information other than the
prototype or declaration.

In the absence of region annotations, function-parameter pointers are
assumed to point into any possible region.  Hence, given
\begin{verbatim}
void f(int * x, int * y);
\end{verbatim}
we could call f with two stack pointers, a lexical-region pointer and
a heap-pointer, etc.  Hence this type is the ``most useful'' type from
the caller's perspective.  But the callee's body (f) may not
type-check with this type.  For example, x cannot be assigned a
heap pointer because we do not know that x points into the heap.  If
this is necessary, we must give x the type \texttt{int *`H}.  Other
times, we may not care what region x and y are in so long as they are
the \emph{same} region.  Again, our prototype for f does not indicate
this, but we could rewrite it as
\begin{verbatim}
void f(int *`r x, int *`r y);
\end{verbatim}
Finally, we may need to refer to the region for x or y in the function
body.  If we omit the names (relying on the compiler to make up
names), then we obviously won't be able to do so.

Formally, omitted regions in function parameters are filled in by
fresh region names and the function is ``region polymorphic'' over
these names (as well as all explicit regions).

In the absence of region annotations, function-return pointers are
assumed to point into the heap.  Hence the following function will not
type-check:
\begin{verbatim}
int * f(int * x) { return x; }
\end{verbatim}
Both of these functions will type-check:
\begin{verbatim}
int * f(int *`H x) { return x; }
int *`r f(int *`r x) {return x; }
\end{verbatim}
The second one is more useful because it can be called with any
region.

In type declarations (including \texttt{typedef}) and top-level variables,
omitted region annotations are assumed to point into the heap.  In the
future, the meaning of \texttt{typedef} may depend on where the
\texttt{typedef} is used.  In the meantime, the following code will
type-check because it is equivalent to the first function in the previous
example:
\begin{verbatim}
typedef int * foo_t;
foo_t f(foo_t x) { return x; }
\end{verbatim}

% If a function parameter is declared as a pointer into the heap, then
% you are not allowed to call the function with a stack pointer or
% dynamic-region pointer for that parameter.  The function knows that
% the heap is never deallocated, so it is free to keep a copy of the
% pointer around even after it returns; it can safely dereference the saved
% pointer the next time it is called.  If you could pass a stack pointer
% in for the parameter, the function might end up dereferencing a
% dangling pointer.

If you want to write a function that creates new objects in a region
determined by the caller, your function should take a region handle as one
of its arguments.\footnote{The following discussion is not quite correct when
allocating into the unique or reference-counted region; this will be
described in \sectionref{sec:poly-allocate}.}  The type of a handle is
\texttt{region_t<`r>}, where \texttt{`r} is the region information
associated with pointers into the region.  For example, this function
allocates a pair of integers into the region whose handle is \texttt{r}:
\begin{verbatim}
  $(int,int)*`r f(region_t<`r> r, int x, int y) { 
     return rnew(r) $(x,y);
  }
\end{verbatim}
Notice that we used the same \texttt{`r} for the handle and the return
type.  We could have also passed the object back through a pointer
parameter like this:
\begin{verbatim}
  void f2(region_t<`r> r,int x,int y,$(int,int)*`r *`s p){ 
    *p = rnew(r) $(7,9); 
  }
\end{verbatim}

Notice that we have been careful to indicate that the region where
\texttt{*p} lives (corresponding to \texttt{`s}) may be different from
the region for which \texttt{r} is the handle (corresponding to
\texttt{`r}).  Here's how to use \texttt{f2}:
\begin{verbatim}
  { region rgn;
    $(int,int) *`rgn x = NULL; 
    f2(rgn,3,4,&x);
  }
\end{verbatim} %$ <-- this dollar comment helps syntax highlighting
The \texttt{`s} and \texttt{`rgn} in our example are unnecessary
because they would be inferred.

\texttt{typedef}, \texttt{struct}, and \texttt{datatype}
declarations can all be parameterized by regions,
just as they can be parameterized by types.  For example, here is part
of the list library.
\begin{verbatim}
  struct List<`a,`r>{`a hd; struct List<`a,`r> *`r tl;};
  typedef struct List<`a,`r> *`r list_t<`a,`r>;

  // return a fresh copy of the list in r2
  list_t<`a,`r2> rcopy(region_t<`r2> r2, list_t<`a> x) {
    list_t result, prev;

    if (x == NULL) return NULL;
    result = rnew(r2) List{.hd=x->hd,.tl=NULL};
    prev = result;
    for (x=x->tl; x != NULL; x=x->tl) {
      prev->tl = rnew(r2) List(x->hd,NULL);
      prev = prev->tl;
    }
    return result;
  }  
  list_t<`a> copy(list_t<`a> x) {
    return rcopy(heap_region, x);
  }

  // Return the length of a list. 
  int length(list_t x) {
    int i = 0;
    while (x != NULL) {
      ++i;
      x = x->tl;
    }
    return i;
  }
\end{verbatim}
The type \texttt{list_t<\textit{type},\textit{rgn}>} describes
pointers to lists whose elements have type \textit{type} and whose
``spines'' are in \textit{rgn}.  

The functions are interesting for what they \emph{don't} say.
Specifically, when types and regions are omitted from a type
instantiation, the compiler uses rules similar to those used for
omitted regions on pointer types.  More explicit versions of the
functions would look like this:
\begin{verbatim}
  list_t<`a,`r2> rcopy(region_t<`r2> r2, list_t<`a,`r1> x) {
    list_t<`a,`r2> result, prev;
    ...
  }
  list_t<`a,`H> copy(list_t<`a,`r> x) { ... }
  int length(list_t<`a,`r> x) { ... }
\end{verbatim}

% Putting function pointers in struct fields currently requires an
% arcane type definition.  We recommend following the recipe illustrated
% by this example:
% \begin{verbatim}
%   struct X<`e1::E, `e2::E, `ra::R, `rb::R> {
%     int f1(int x, int y; `e1); 
%     int f2(int *`r1 x, int *`r2 y; `e2 + {`ra,`rb});
%   };

%   typedef struct X<{},{},`ra,`b> x_t<`ra::R, `rb::R>;
% \end{verbatim}

% The example is simpler if \texttt{f2} does not accept stack pointers,
% but the effect variables (\texttt{`e1} and \texttt{`e2}) are still
% necessary.  You will probably never encounter a situation where
% \texttt{x_t}'s instantiation of \texttt{`e1} and \texttt{`e2} to \verb|{}|
% causes a program not to type-check, but the gory details are discussed
% below.

\subsection{Unique Pointers}

The main benefit of the regions described thus far is also their drawback:
to free data you must free an entire region.  This implies that to amortize
the cost of creating a region, one needs to allocate into it many times.
Furthermore, the objects allocated in a region should be mostly in use until
the region is freed, or else memory will be wasted in the region that is
unused by the program.

For the cases in which neither situation holds, we can use the \emph{unique
region}, which allows unique pointers to be freed individually.  To prevent
dangling pointers, a static analysis ensures that objects in the unique
region (\emph{unique objects}) can only ever be accessed through one pointer
at any time.  At the time it is freed, this pointer is invalidated, thus
preventing all future accesses to the object.

To ease programming with unique pointers and allow reuse of library code,
unique pointers can be aliased temporarily within a designated lexical scope
using a special \texttt{alias} pattern.  If this kind of aliasing is not
sufficient, users can choose to allocate reference-counted objects; this
idea is explained in the next subsection.  We also define syntax
\texttt{{\it a} :=: {\it b}} to allow two unique pointers $a$ and $b$ to be
atomically swapped.  Careful use of the swap operator allows us to store
unique pointers in objects that are not themselves uniquely pointed to.
Finally, to properly deal with polymorphism, particularly when performing
allocation, we introduce new \emph{kinds} for describing regions.  In
practice, all of these mechanisms are necessary for writing useful and
reusable code.

\subsubsection{Simple Unique Pointers}

Having a unique pointer ensures the object pointed to is not reachable by
any other means.  When pointers are first allocated, e.g. using
\texttt{malloc}, they are unique.  Such pointers are allowed to be
\emph{read through} (that is, dereferenced or indexed) but not copied, as
the following example shows:
\begin{verbatim}
  char *@fat`U buf = malloc(3*sizeof(char));
  buf[0] = 'h';
  buf[1] = 'i';
  buf[2] = '\0';
  ...
  ufree(buf);
\end{verbatim}
This piece of code allocates a unique buffer, and then indexes that buffer
three times to initialize it.  Because the process of storing to the
buffer does not copy its unique pointer, it can be safely freed.

When a unique pointer is copied, e.g. when passed as a parameter to a
function or stored in a datastructure, we say it has been \emph{consumed}.
We ensure that consumed pointers are not read through or copied via a
dataflow analysis.  When a consumed pointer is assigned to, very often it
can be \emph{unconsumed}, making it accessible again.  Here is a simple
example that initializes a datastructure with unique pointers:
\begin{alltt}
{\small 1}  struct pair \{ int *`U x; int *`U y; \} p;
{\small 2}  int *`U x = new 1;  // initializes x
{\small 3}  p.x = x;            // consumes x
{\small 4}  x = new 2;          // unconsumes x
{\small 5}  p.y = x;            // consumes x
\end{alltt}
If an attempt was made to read through or copy \texttt{x} between lines 3
and 4 or after line 5, the flow analysis would reject the code, as in
\begin{alltt}
  int *`U x = new 1;  // initializes x
  p.x = x;            // consumes x
  p.y = x;            // rejected! x has been consumed already
\end{alltt}
When a multi-word data structure is assigned to another one, all of the
unique pointers it contains are consumed.  For example:
\begin{alltt}
{\small 1}  struct pair \{ int *`U x; int *`U y; \} p, q;
{\small 2}  p.x = new 1; p.y = new 2;
{\small 3}  q = p;              // consumes p.x and p.y
\end{alltt}

By default, when a unique pointer is passed to a function, we assume that the
function will free the pointer, store it in a data structure, or otherwise
make it unavailable to the caller.  You can override this behavior using the
attribute \texttt{noconsume}, which indicates that a particular argument
should be available to the caller after the call.  For example:
\begin{verbatim}
void foo(int *`U x) __attribute__((noconsume(1))) {
  *x = 1;
}
void bar() {
  int *`U x = malloc(sizeof(int));
  foo(x);
  ufree(x);
}
\end{verbatim}
Here, the \texttt{noconsume(1)} attribute in the definition of \texttt{foo}
indicates that the first argument should not be consumed within the function
body.  The flow analysis verifies that this is indeed the case.  As a
result, the call to \texttt{foo} within \texttt{bar} does not consume
\texttt{x}, so it can be freed afterwards.

Note that if you fail to free a unique pointer, it will eventually be
garbage collected.

Unique pointers have some restrictions.  In particular:
\begin{itemize}
\item No pointer arithmetic is allowed on unique pointers.  This ensures
  that all unique pointers point to the beginning of the object, so that the
  allocator is not confused when a pointer is passed to \texttt{ufree}.
\item Take the address of a unique pointer is not allowed.  This is because
  doing so effectively creates an alias to the original pointer that cannot
  be easily tracked statically.
\item Unique pointers cannot be stored within datatypes (though they can be
  stored in tagged unions).  This is a shortcoming of the current flow
  analysis.
\end{itemize}

\subsubsection{Nested Unique Pointers}

Directly reading a unique pointer is only allowed along a \emph{unique
path}.  A unique path $u$ has the form
\begin{center}
$u$ \texttt{::=} $x$ $\mid$ $u$\texttt{.m} $\mid$ $u$\texttt{->m} $\mid$ \texttt{*}$u$
\end{center}
where $x$ is a local variable, and $u$ is a unique pointer.  To
appreciate the unique-path restriction, consider this incorrect code:
\begin{verbatim}
int f(int *`U *`r x) {
  int *`U *`r y = x;  //x and y are aliases
  int *`U z = *y;
  ufree(z);
  return **x;  //accesses deallocated storage!
}
\end{verbatim}
Here, \texttt{x} is a pointer into a conventional region \texttt{`r} and
thus its value can be freely copied to \texttt{y}.  We then extract a unique
pointer pointed to by \texttt{y} and free it.  Then we attempt to access the
deallocated storage through \texttt{x}.

If a unique pointer is not accessible via a unique path, it must be
\emph{swapped out} atomically to be used; in Cyclone this is expressed with
syntax \texttt{:=:}.  In particular, the code \texttt{{\it a} :=:{\it b}}
will swap the contents of {\it a} and {\it b}.  We can use this to swap out
a nested unique pointer, and replace it with a different one; we will often
swap in NULL, since this is a unique pointer that is always unconsumed.  For
example, in the code below, we define a queue type for queues that contain
unique pointers, and a function \texttt{take} for removing the first element
from the queue.
\begin{verbatim}
struct Queue<`a,`r> { 
  list_t<`a *`U,`r> front; 
  list_t<`a *`U,`r> rear; 
};
typedef struct Queue<`a,`r> *`r queue_t<`a,`r>;

`a *`U take(queue_t<`a> q) {
  if (q->front == NULL)
    throw &Empty_val;  // exception: def not shown
  else {
    let elem = NULL;
    elem :=: q->front->hd;
    q->front = q->front->tl;
    if (q->front == NULL) q->rear = NULL;
    return elem;
  }
}
\end{verbatim}
Here, in order to extract the element stored in the queue (the \texttt{hd}
portion of the underlying list), we need to use swap, because
\texttt{q->front} is a non-unique pointer, and therefore
\texttt{q->front->hd} is not a unique path.

Note that this code is not as polymorphic as it could be.  In particular,
the above queue definition requires its elements to be nullable unique
pointers, when they could just as easily be non-unique pointers, or even
reference-counted pointers (illustrated later), and the code for
\texttt{take} would still work.  This problem can be addressed, and its
solution is described in \sectionref{sec:poly-allocate}.

\subsubsection{Pattern Matching on Unique Pointers}
\label{sec:unique-patterns}

As described in \sectionref{sec:patterns}, Cyclone supports pattern
matching on structured data with \texttt{let} declarations and
\texttt{switch} statements.  Unique pointers, or structures containing
unique pointers, can be matched against, while still ensuring that only one
legal pointer to a unique object exists at any given time.

In the simplest case, when a unique pointer to a structure is matched
against, the matching operation is treated just like a dereference.
Therefore, the pointer itself is \emph{not} consumed.  For example:
\begin{verbatim}
struct pair { int x; int y; };
void foo() {
  struct pair @`U p = new pair(1,2);
  let &pair{.x=x, .y=y} = p;
  ufree(p);
}
\end{verbatim}
Here, we match against the unique pointer \texttt{p}'s two fields
\texttt{x} and \texttt{y}.  Because we don't make a copy of \texttt{p}, but
rather only of its fields, \texttt{p} is not consumed.  Therefore,
\texttt{p} can be safely freed.

Because each of the fields matched against is assigned to the pattern
variables, unique paths through the original pointer are consumed by virtue
of being assigned.  At the conclusion of the scope of the pattern, we can
\emph{unconsume} any location whose pattern variable has not been consumed
or assigned to, as long as the parent pointer has not been consumed or
assigned to.  Here's an example:
\begin{verbatim}
struct Foo { int *`U x; int *`U y; };
void foo(struct Foo *`U p) {
  { let &Foo{.x=x, .y=y} = p; // consumes p->x and p->y
    ufree(x);                 // consumes x
  }                           // p->y is unconsumed
  ufree(p->y);                // p->y consumed
  ufree(p);                   // p consumed
}
\end{verbatim}
The initial match against \texttt{p} consumes \texttt{p->x} and
\texttt{p->y}, whose contents are copied to \texttt{x} and \texttt{y},
respectively.  At the conclusion of the block, \texttt{p->y} is unconsumed
because it did not change, whereas \texttt{p->x} is not, because \texttt{x}
was freed within the block.

Note that the following code is illegal:
\begin{verbatim}
void foo(struct Foo *`H p) {
 let &Foo{.x=x, .y=y} = p; // non-unique path!
 ...
}
\end{verbatim}
To see why, notice that this is equivalent to
\begin{verbatim}
void foo(struct Foo *`H p) {
 let x = p->x;
 let y = p->y;
 ...
}
\end{verbatim}
This code is illegal because neither \texttt{p->x} nor \texttt{p->y} is a
unique path.  We also do not allow \texttt{*} patterns to create aliases of
the original unique pointer, for the same reason we forbid \texttt{\&}$e$
when $e$ is a unique pointer.  Unfortunately, this means we don't provide a
way to assign to matched-against fields.  However, in the case of the
matched-against struct, we can just do this with regular paths.  In the
above example pattern block, we could do \texttt{p->y = new 1} or something
like that (even within the scope of the pattern).

Matching against tagged unions is essentially like matching against
structures, as just described.  Since we do not allow unique pointers to be
stored within datatypes, there is no change to how datatypes are matched.

\subsubsection{Aliasing Unique Pointers}
\label{sec:alias}

Programmers often write code that aliases values temporarily, e.g. by
storing them in loop iterator variables or by passing them to functions.
Such reasonable uses would be severely hampered by ``no alias'' restrictions
on unique pointers.  To address this problem, we introduce a special
\texttt{alias} pattern variable that permits temporary aliasing of a unique
pointer.  Here is a simple example:
\begin{alltt}
  char *@fat`U dst, *@fat`U src = ...
  \{ let alias <`r>char *@fat`r x = src; // consumes src
    memcpy(dst,x,numelts(x)); \}
  // src unconsumed
  ...
  ufree(src);
\end{alltt}
In general, an alias pattern has form \texttt{alias <`r>$t$ x}, where
\texttt{`r} is a fresh region variable, and $t$ is the type of \texttt{x},
which may mention \texttt{`r}.  The \texttt{alias} pattern introduces a
region \texttt{`r}, copies \texttt{src} to \texttt{x} which is treated as
having the designated type \texttt{char *@fat`r}.  Because \texttt{`r} is
non-unique, \texttt{x} can be freely aliased.  As such, we can pass
\texttt{x} to the \texttt{memcpy} function.  The matching operation consumes
\texttt{src} during the block, and unconsumes it upon exit, so that
\texttt{src} can be ultimately freed.

Alias pattern variables are similar to regular pattern variables.  Like
regular pattern variables, the matched-against expression (i.e. \texttt{src}
in the above example) must be a unique path, and is consumed as a result of
the match.  As well, this expression can be unconsumed at the conclusion of
the surrounding block as long as it hasn't been overwritten.  However, in
the case of regular pattern variables, unconsumption also requires that the
pattern variable itself (i.e. \texttt{x} in the above example) hasn't
changed within the block, while this requirement is unnecessary for alias
patterns.

Intuitively, alias pattern variables are sound because we cast a unique
pointer to instead point into a fresh region, for which there is no
possibility of either creating new values or storing existing values into
escaping data structures.  As such we cannot create aliases that persist
beyond the surrounding scope.  However, we must take care when aliasing data
having recursive type.  For example, the following code is unsound:
\begin{alltt}
  void foo(list\_t<`a,`U> l) \{
    alias <`r> x = (list\_t<`a,`r>)l;
    x->tl = x; // unsound: creates alias!
  \}
\end{alltt}
In this case, the \texttt{alias} effectively created many values in the
fresh region \texttt{`r}: one for each element of the list.  This allows
storing an alias in an element reachable from the original expression
\texttt{l}, so that when the block is exited, this alias escapes.

To prevent this, we only allow ``deep'' aliasing when the aliased pointers
are immutable.  For example, if we have a list structure whose tail pointers
are \texttt{const}, call it \texttt{clist\_t}, we rule out the above code
because the assignment to \texttt{x->tl} would be forbidden.  Here is an
example implementation of a \texttt{length} function that is amenable to
deep aliasing:
\begin{alltt}
  int length(clist\_t<`a,`r> l) \{
    int len = 0;
    while (l != NULL) \{
      len++;
      l = l->tl;
    \}
    return len;
  \}

  int foo() \{
    list\_t<int,`U> l = new List(1,new List(2,NULL));
    let alias <`r>clist\_t<int,`r> x = l;
    return length(x);
  \}
\end{alltt}
Here, the \texttt{length} function works on constant lists, and the
\texttt{foo} function aliases a unique, mutable list \texttt{l} to call
\texttt{length}.

For improved programmer convenience, the Cyclone
typechecker optimistically inserts \texttt{alias} blocks around
function-call arguments that are unique pointers when the
formal-parameter type is polymorphic in the pointer's region.  If this
modified call does not type-check, we remove the inserted \texttt{alias}.
For example, the \texttt{alias} pattern in the \texttt{foo} function above
could be inferred, so we could instead write:
\begin{alltt}
  int foo() \{
    list\_t<int,`U> l = new List(1,new List(2,NULL));
    return length(l);
  \}
\end{alltt}
Right now, \texttt{alias} inference in Cyclone is fairly primitive, but
could be extended to more contexts.  We plan to improve this feature in
future releases.

\subsubsection{Polymorphism}
\label{sec:poly-allocate}

As described in \sectionref{sec:common-use}, we can write functions that
take as arguments a region handle to allocate into.  For example, we wrote a
function \texttt{rcopy} that copies a list into some region \texttt{`r2}.
However, we didn't provide the full story that accounts for the unique
region.  In particular, consider the following function:
\begin{alltt}
  $(int @`r, int @`r) make\_pair(region\_t<`r> rgn) \{
    int @x = rnew (rgn) 1;
    return $(x, x);
  \}
\end{alltt}
This function will return a pair of pointers to the same object.  If we pass
in something other than the unique region, this function will behave
properly:
\begin{alltt}
  $(int @,int@) pair = make\_pair(heap_region);
\end{alltt}
However, things can go badly wrong if we pass in the unique region instead:
\begin{alltt}
  $(int @`U,int @`U) pair = make\_pair(unique_region);
  ufree(pair[0]);
  int x = pair[1]; // error! dereferences freed pointer
\end{alltt}
The problem is that \texttt{make\_pair} creates an alias; if we pass in the
unique region for \texttt{rgn}, we can free one of these aliases (e.g. the
pointer via the first element of the pair), but then dereference the other
(i.e. via the second pair element).

To prevent this behavior, we have to classify the different kinds of regions
that we support: aliasable regions, whose pointers can be freely aliased,
and unique regions, whose pointers cannot be aliased, and can form part of
unique paths.  To do this, we define \emph{kinds} R for aliasable regions
and UR for unique ones.  We can then classify a polymorphic region variable
with the proper kind.  This allows us to change the \texttt{make\_pair}
function as follows:
\begin{alltt}
  $(int @`r, int @`r) make\_pair(region\_t<`r::R> rgn) \{
    int @x = rnew (rgn) 1;
    return $(x, x);
  \}
\end{alltt}
Now we have specified specifically that \texttt{`r} must be an aliasable
region (in fact, when not specified, this is the default for function
parameters).  As such, the illegal code above will not typecheck because we
are attempting to instantiate a unique region (having kind UR) for an
aliasable one, which is disallowed.

For generality, we introduce a third region kind TR (which stands for ``top
region''); TR is a ``super-kind'' of R and UR, meaning that types having TR
kind can be used in places expecting types of R or UR kind.  This also means
that we cannot allow pointers into a TR-kinded region to be aliased, nor can
we assume they do not have aliases (and so they cannot safely form part of a
unique path).  This is because we might instantiate either the unique region
(whose pointers cannot be aliased) or an aliasable region (whose pointers
might be aliased) in place of the TR-kinded variable.

We can now generalize the \texttt{rcopy} example above:
\begin{verbatim}
  struct List<`a,`r::TR>{`a hd; struct List<`a,`r> *`r tl;};
  typedef struct List<`a,`r> *`r list_t<`a,`r>;

  // return a fresh copy of the list in r2
  list_t<`a,`r2> rcopy(region_t<`r2::TR> r2, list_t<`a> x) {
    if (x == NULL) return NULL;
    else {
      list_t rest = rcopy(r2,x->tl);
      return rnew(r2) List{.hd=x->hd,.tl=rest};
    }
  }
  list_t<`a> copy(list_t<`a> x) {
    return rcopy(heap_region, x);
  }
\end{verbatim}
We have made three key changes to the prior version of \texttt{rcopy}:
\begin{enumerate}
\item The definition of \texttt{List} has been generalized so that its
  \texttt{`r} region variable now has kind TR.  This implies that lists can
  point into any region, whether unique or aliasable.  Actually, we need not
  include the ::TR kind annotation on region type variables in typedefs;
  this is the default (since it allows instantation of any region
  parameter).
\item The region handle \texttt{r2} now has kind TR, rather than the default
  R.  This means that we can pass in any region handle, and thus copy a list
  into any kind of region.
\item We have made \texttt{rcopy}'s implementation recursive.  This was
  necessary to avoid creating aliases to the newly created list.  In
  particular, if we were to have used a \texttt{prev} pointer as in the
  version from \sectionref{sec:common-use}, we would have two pointers to
  the last-copied element: the \texttt{tl} field of the element before it in
  the list, and the current iterator variable \texttt{prev}.  The use of
  recursion allows us to iterate to the end of the list and construct it
  back to front, in which no aliases are required.  The cost is we need to
  do extra stack allocation.  This example illustrates that it is sometimes
  difficult to program using no-alias pointers.  This is why, in cases other
  than allocation, we would prefer to use the \texttt{alias} construct to
  allow temporary aliasing.
\end{enumerate}

In addition to needing polymorphism for region allocation, for the same
reasons we need polymorphism for arbitrary values which might be pointers
into either unique or aliasable regions.  For example, consider the
following code analogous to the \texttt{make\_pair} function above:
\begin{verbatim}
  $(`a,`a) pair(`a x) {
    return $(x,x);
  }
\end{verbatim}
Now consider what happens if we call \texttt{pair} with a unique pointer:
\begin{verbatim}
  int @`U p = new 1;
  $(int @`U,int @`U) pair = pair(p);
  ufree(pair[0]);
  int x = pair[1]; // error! dereferences freed pointer
\end{verbatim}%$ <-- help syntax highlighting
Again, the problem is that we have not restricted the kinds of things that
can be used to instantiate polymorphic variables.  We extend our solution
for region kinds, above, to all of Cyclone's kinds.  For example, Cyclone's
``box-kind'' B, which classifies word-sized values, must be extended so that
B refers to aliasable word-sized values, while UB refers to non-aliasable
word-sized values, and TB is the super-kind of both.  A similar extension
occurs for kind M (memory-kinds, having arbitrary size), and kind A
(any-kinds, for abstract, arbitrary-sized data).  With this, we can fix the
\texttt{pair} function to be:
\begin{verbatim}
  $(`a,`a) pair(`a::B x) {
    return $(x,x);
  }
\end{verbatim}
This would prevent the call to \texttt{pair(p)} in the code snippet above.
Actually, as with regions, aliasable kinds are the default, so the
\texttt{::B} can be elided.

\subsection{Reference-counted Pointers}

Cyclone also supports reference-counted pointers, which are treated quite
similarly to unique pointers.  Reference-counted objects are allocated in
the reference-counted region, named \texttt{`RC}. This region has kind
\texttt{TR}, which ensures that pointers into it cannot be aliased
implicitly, but aliases might exist, meaning they cannot form part of unique
paths.  Similarly, reference-counted pointers have kind \texttt{TB}.  We
define the constant \texttt{Core::refcount_region}, having type
\texttt{region_t<`RC>}, for creating reference-counted pointers.  The caveat
here is that when you allocate something in this region, an extra word will
be prepended to your data, which contains the reference count, initialized
to $1$.

As with unique pointers, no pointer arithmetic is allowed, for similar
reasons: it can occlude where the "head" of the object is, and thus make
it impossible to find the hidden reference count.  The reference count
can be accessed via the routine \texttt{Core::refptr_count}:
\begin{verbatim}
  int refptr_count(`a::TA ?`RC ptr)
    __attribute__((noconsume(1)));
\end{verbatim} %$ <--- for syntax highlighting
The constant NULL is allowed to have type \verb+`a::A ?`RC+, and its
reference count is always 0.  The \texttt{noconsume} attribute ensures that
the pointer is not consumed by the call.  Like unique pointers, implicit
aliasing is not allowed.  Aliases are created explicitly using the routine
\texttt{Core::alias_refptr}:
\begin{verbatim}
  `a ?`RC alias_refptr(`a::TA ?`RC ptr)
    __attribute__((noconsume(1)));
\end{verbatim} %$ <--- for syntax highlighting
This routine returns a copy of its argument, which is itself not consumed.
Furthermore, the reference count will be incremented by one.  Reference
counts are reduced explicitly by the routine \texttt{drop_refptr}:
\begin{verbatim}
  void drop_refptr(`a::TA ?`RC ptr);
\end{verbatim}
In the case that the provided object's reference count is 1 (and is thus
dropped to zero), the provided pointer is freed.  The flow analysis will
consume the passed pointer (as is always the case for function arguments),
so you won't be able to use it afterwards.  Just like unique pointers, you
can ``forget'' reference-counted pointers without decrementing the count;
this just means you'll never be able to free the pointer explicitly, but the
GC will get it once it becomes unreachable.

Just like unique pointers, reference-counted pointers can be stored in
normal, aliasable datastructures, and accessed using swap (e.g. \texttt{x
:=: y}).  Because NULL is a \verb+`a::TA ?`RC+ pointer, we can always
cheaply construct a pointer to swap in.  Also, \texttt{alias} pattern
variables can work to create temporary (non-counted) aliases of a
reference-counted pointer.

A good example of the use of unique pointers and reference-counted pointers
is in the Cyclone distribution's \texttt{tests} directory---the file
\texttt{streambuff.cyc}.  This is an implementation of a packet manipulation
library with a representation for packets (called \texttt{streambuff\_t}'s)
that is similar to Linux's \texttt{skbuff\_t}'s.  It uses a combination of
unique header structures and reference-counted data structures.

\subsection{Dynamic Regions}
\label{sec:dynamic-regions}

Dynamic regions combine reference-counted or unique pointers and lexical
regions together to essentially create reference-counted or unique
\emph{regions}; that is, the region is completely first class, and can be
created or freed at conceptually any program point.  This is done by
representing a dynamic region as a unique (or reference-counted) pointer to
an abstract struct \texttt{DynamicRegion} (which internally just contains
the handle to a lexical region).  The unique (or ref-counted) pointer is
called the \emph{key}.  The key serves as a run-time \emph{capability} that
grants access to the region.  At run-time, a key can be presented to a
special \texttt{open} primitive, described later, that grants lexical access
to the region.
        
The operation \texttt{new\_ukey()} creates a fresh dynamic region and returns
a unique key for the region; \texttt{new\_rckey()} creates a fresh dynamic
region and returns a ref-counted key for the region.  The operations
\texttt{free\_ukey()} and \texttt{free\_rckey()} are used to destroy unique
and ref-counted keys respectively.  The \texttt{free\_ukey()} operation
reclaims the key's region, as well as the storage for the key.  The
\texttt{free\_rckey()} operation decrements the reference count, and if it's
zero, reclaims the key's region as well as the storage for the key.  Because
ref-counted keys are pointers, you can use \texttt{alias\_refptr} to make a
copy of a ref-counted key.  (Obviously, you can't make a copy of a unique
key.)  By the same token, you can pass a ref-counted key to
\texttt{drop\_refptr} (and you can pass a unique key to \texttt{ufree}), but
doing so won't actually deallocate the region, but rather only the key.

Given a key $k$, a user can access the contents of its region by temporarily
`opening the region' within a lexical scope.  This is done with the syntax
\verb+region+ $r$ \verb+= open+ $k$.  That is, within the remainder of the
current scope, the region handle $r$ can be used to access $k$'s region.
The key $k$ is temporarily consumed throughout the scope, and then
unconsumed at its conclusion.  This prevents you from opening up the dynamic
region, and then freeing it while it's still in use.  Note that
\texttt{open} is very similar to \texttt{alias} in this way.

Here is a small example of the use of dynamic regions.
\begin{verbatim}
int main() {
  // Create a new dynamic region
  let NewDynamicRegion{<`r> key} = new_ukey();

  // At this point, we refer to the region `r to
  // specify types, but we cannot actually access
  // `r (i.e. it's not in our "static capability,"
  // a concept explained later)

  list_t<int,`r> x = NULL;

  // We can access x by opening the region, which
  // temporarily consumes the key
  { region h = open(key);
    x = rnew(h) List(3,x);
  }

  // Now we can access the key again, but not x.
  // So we have to open the region to increment
  // its contents
  { region h = open(key);
    int i = x->hd + 1;
    x = rnew (h) List(i,x);
  }

  // Finally, destroy the key and the region
  free_ukey(key);
}
\end{verbatim}
First, we allocate a new unique key and open it up, to reveal the name of
the key's region (\texttt{`r}), and the key itself.  Because \texttt{`r} is
now in scope, we can declare a variable \texttt{x} that refers to it.
However, because the key \texttt{key} must be opened before \texttt{`r}
becomes accessible, we cannot actually do anything with \texttt{x} yet (like
dereference it).

Next, we open up the region using \texttt{key}, assigning its handle to the
vairable \texttt{h}.  Now, \texttt{key} is inaccessible (consumed) in the
surrounding block, which prevents us from doing anything that might cause it
to be freed while it's in use.  We can use \texttt{h} to allocate into
\texttt{`r}, so we allocate a list element and store it in \texttt{x}.

At the conclusion of the \texttt{block}, the region \texttt{`r} becomes
inaccessible again, so once again we cannot dereference \texttt{x}.
However, \texttt{key} can now be accessed again, so we can open it again in
the following block, to add a new list cell to \texttt{x}.  At the
conclusion of this block, \texttt{key} is unconsumed once again, so we
legally call \texttt{free\_ukey}.  This frees the key and the region
\texttt{`r}.

You can "share" a dynamic region key by placing it in some shared data
structure, like a global variable.  Of course, you'll then have to swap with
NULL to get it in and out of the shared data structure, as the following
code demonstrates:
\begin{verbatim}
struct MyContainer { <`r>
  uregion_key_t<`r> key;
  list_t<int,`r> data;
} *`U global = NULL;

int main() {
  // allocate a dynamic region, and create a list
  let NewDynamicRegion{<`r> key} = new_ukey();
  list_t<int,`r> x = NULL;
  { region h = open(key);
    x = rnew(h) List(3,x);
  }

  // Stick the key and list in a global data
  // structure. We've now lost direct access to
  // the key and x.
  global = new MyContainer{key,x};

  // But we can regain it by swapping for the
  // container.
  struct MyContainer *`U p = NULL;
  global :=: p;

  // Now we can use it as above
  let MyContainer{<`r2> key2, data2} = *p;
  list_t<int,`r2> d = data2;
  { region h = open(key2);
    int i = d->hd + 1;
    d = rnew (h) List(i,d);
  }
}
\end{verbatim}
Here, we define a global variable having type \texttt{MyContainer}, which
consists of a key and some data into that key's region.  The main function
allocates a unique as before, and allocates some data into its region.  Then
we create a container for that key and data, and store it into the global
variable; this consumes \texttt{key}, making it inaccessible, and
effectively preventing access of \texttt{x} as well.

But we can then get the container back out of the global variable by
swapping its contents with NULL.  Then we can open up the container, and use
the key and data as before.  This way, a single dynamic region can be used
by many different functions in the program.  They simply swap out the global
when they need it, operate on it, and then swap in the result.

One problem with using this technique with unique keys arises when you need
to open the same region multiple times.  The problem, of course, is that if
you swap in NULL, then whoever tries to swap it out will fail.  In other
words, you can't really do recursive opens with `U keys.  However, you can
do this with `RC keys!  Swap out the key, make a copy of it, swap it back
in, and use the copy for the open (making sure to destroy the copy after the
open).
  
One disadvantage of dynamic regions, which is inherited from unique and
reference-counted pointers, is that if you put a key in some shared storage
in a region `r, then it is not the case that when `r is deallocated that the
key will be destroyed automatically.  It's up to you to do the right thing
or let the GC eventually collect it.  In the long run, the right thing to do
is add a finalizer interface for regions so that we can register a routine
to deallocate a dynamic region whenever we put it in a shared data
structure.  The same goes for any unique pointer --- we ought to have a way
to register a finalizer.  This is on our To-do list.

\subsection{Type-Checking Regions}

Because of recursive functions, there can be any number of live
regions at run time.  The compiler uses the following general strategy to
ensure that only pointers into live regions are dereferenced:

\begin{itemize}
\item Use compile-time \emph{region names}.  Syntactically these are
  just type variables, but they are used differently.
\item Decorate each pointer type and handle type with one region name. 
\item Decorate each program point with a (finite) set of region names.
  We call the set the point's \emph{capability}.
\item To dereference a pointer (via \texttt{*}, \texttt{->}, or
  subscript), the pointer's type's region name must be in the program
  point's capability.  Similarly, to use a handle for allocation, the
  handle type's region name must be in the capability.
\item Enforce a type system such that the following is impossible: A
  program point P's capability contains a region name \texttt{`r} that
  decorates a pointer (or handle) expression \textit{expr} that, at
  run time, points into a region that has been deallocated and the
  operation at P dereferences \textit{expr}.
\end{itemize}

This strategy is probably too vague to make sense at this point, but
it may help to refer back to it as we explain specific aspects of the
type system.

Note that in the rest of the documentation (and in common parlance) we
abuse the word ``region'' to refer both to region names and to
run-time collections of objects.  Similarly, we confuse a block of
declarations, its region-name, and the run-time space allocated for
the block.  (With loops and recursive functions, ``the space
allocated'' for the block is really any number of distinct regions.)
But in the rest of this section, we painstakingly distinguish
region names, regions, etc.

\subsubsection{Region Names}

Given a function, we associate a distinct region name with each
program point that creates a region, as follows:

\begin{itemize}
\item If a block (blocks create stack regions) has label \texttt{L},
  then the region-name for the block is \texttt{`L}.
\item If a block has no label, the compiler makes up a fresh
  region-name for the block.
\item In \texttt{region r <`foo> $s$}, the region-name for the construct
  is \texttt{`foo}.
\item In \texttt{region r $s$}, the region-name for the construct is
  \texttt{`r}.
\item In region \texttt{h = open(k) s}, the region-name for the construct is
  \texttt{`r}, assuming \texttt{k} has type \texttt{region\_key\_t<`r,_>}
  (where \texttt{_} is some other region name of no consequence).
\end{itemize}

The region name for the heap is \texttt{`H}, the region name for the unique
region in \texttt{`U}, and the region name for the reference-counted region
is \texttt{`RC}.  Region names associated with program points within a
function should be distinct from each other, distinct from any region names
appearing in the function's prototype, and should not be \texttt{`H},
\texttt{`U}, or \texttt{`RC}.  (So you cannot use \texttt{H} as a label
name, for example.)  Because the function's return type cannot mention a
region name for a block or region-construct in the function, it is
impossible to return a pointer to deallocated storage.

In region \texttt{r <`r> s}, region \texttt{r s}, and region \texttt{r =
open(k) s} the type of \texttt{r} is \texttt{region_t<`r>} (assuming, that
\texttt{k} has type \texttt{region\_key\_t<`r,_>}). In other words, the
handle is decorated with the region name for the construct.  Pointer types'
region names are explicit, although you generally rely on inference to put
in the correct one for you.

\subsubsection{Capabilities}

In the absence of explicit effects (see below), the capability for a
program point includes exactly:
\begin{itemize}
\item \texttt{`H}, \texttt{`U}, and \texttt{`RC}
\item The effect corresponding to the function's prototype.  Briefly,
any region name in the prototype (or inserted by the compiler due to
an omission) is in the corresponding effect.  Furthermore, for each
type variable \texttt{`a} that appears (or is inserted),
``\texttt{regions(`a)}'' is in the corresponding effect.  This latter
effect roughly means, ``I don't know what \texttt{`a} is, but if you
instantiate with a type mentioning some regions, then add those
regions to the effect of the instantiated prototype.''  This is
necessary for safely type-checking calls that include function pointers.
\item The region names for the blocks and ``\texttt{region r s}''
  statements that contain the program point
\end{itemize}

For each dereference or allocation operation, we simply check that the
region name for the type of the object is in the capability.  It takes
extremely tricky code (such as existential region names) to make the
check fail.

\subsubsection{Assignment and Outlives}

A pointer type's region name is part of the type.  If \texttt{e1} and
\texttt{e2} are pointers, then \texttt{e1 = e2} is well-typed only if
the region name for \texttt{e2}'s type ``outlives'' the region name
for \texttt{e1}'s type.  By outlives, we intuitively mean the region
corresponding to one region name will be deallocated after the region
corresponding to the other region name.  The rules for outlives are as
follows:
\begin{itemize}
\item Every region outlives itself.
\item \texttt{`U} outlives \texttt{`H}, and every region name of UR or R
  kind.
\item \texttt{`RC} outlives \texttt{`H}, and every region name of TR or R
  kind.
\item \texttt{`H} outlives every region name of R kind.
\item Region names for inner blocks outlive region names for outer
blocks.
\item For regions in function prototypes, you can provide explicit
``outlives'' as in this example:
\begin{verbatim}
void f(int *`r1*`r2 x,int *`r3 y : {`r2} > `r1, {`r3} > `r2);
\end{verbatim}
This says that \texttt{`r1} outlives \texttt{`r2} and \texttt{`r2}
outlives \texttt{`r3}.  The body will be checked under these
assumptions.  Calls to \texttt{f} will type-check only if the compiler
knows that the region names of the actual arguments obey the outlives
assumptions.

There are some restrictions on specifying outlives relationships when
considering region names of UR or TR kind, though these rarely come up in
practice.  In particular:
\begin{itemize}
\item Region names of R kind can only outlive region names R kind.
\item Region names of UR kind can only outlive region names R kind or UR kind.
\item Region names of TR kind can only outlive region names R kind or TR kind.
\end{itemize}
\end{itemize}

For handles, if \texttt{`r} is a region name, there is at most one
value of type \texttt{region_t<`r>} (there are 0 if \texttt{`r} is a
block's name), so there is little use in creating variables of type
\texttt{region_t<`r>}.

\subsubsection{Type Declarations}

A \texttt{struct}, \texttt{typedef}, or \texttt{datatype} declaration may be
parameterized by any number of region names.  The region names are placed in
the list of type parameters.  They may be followed by their kind;
i.e. either ``\texttt{::R}'', ``\texttt{::UR}'', or ``\texttt{::TR}''.  If
no region kind is provided, \texttt{TR} is the default.  In \texttt{typedef}
declarations, region names that appear as parameters inherit their kind from
the the specification of that region name in the underlying type.  For
example, given
\begin{verbatim}
  struct List<`a,`r>{`a hd; struct List<`a,`r> *`r tl;};
\end{verbatim}
the type \texttt{struct List<int,`H>} is for a list of ints in the heap,
while the type \texttt{struct List<int,`U>} is for a list of ints in the
unique region.  Notice that all of the ``cons cells'' of the \texttt{List}
will be in the same region (the type of the \texttt{tl} field uses the same
region name \texttt{`r} that is used to instantiate the recursive instance
of \texttt{struct List<`a,`r>}).  However, we could instantiate \texttt{`a}
with a pointer type that has a different region name, as long as that region
has kind R.

\subsubsection{Function Calls}

If a function parameter or result has type \texttt{int *`r} or
\texttt{region_t<`r>}, the function is polymorphic over the region name
\texttt{`r}.  That is, the caller can instantiate \texttt{`r} with any
region \emph{in the caller's current capability} as long as the region has
the correct kind. This instantiation is usually implicit, so the caller just
calls the function and the compiler uses the types of the actual arguments
to infer the instantiation of the region names (just like it infers the
instantiation of type variables).

The callee is checked knowing nothing about \texttt{`r} except that it is in
its capability (plus whatever can be determined from explicit outlives
assumptions), and that it has the given kind.  For example, it will be
impossible to assign a parameter of type \texttt{int*`r} to a global
variable.  Why?  Because the global would have to have a type that allowed
it to point into any region.  There is no such type because we could never
safely follow such a pointer (since it could point into a deallocated
region).

\subsubsection{Explicit and Default Effects}

If you are not using existential types, you now know everything you
need to know about Cyclone regions and memory management.  Even if you
are using these types and functions over them (such as the closure
library in the Cyclone library), you probably don't need to know much more
than ``provide a region that the hidden types outlive''.

The problem with existential types is that when you ``unpack'' the
type, you no longer know that the regions into which the fields point
are allocated.  We are sound because the corresponding region names
are not in the capability, but this makes the fields unusable.  To
make them usable, we do not hide the capability needed to use them.
Instead, we use a \emph{region bound} that is not existentially
bound.  

If the contents of existential packages contain only heap pointers,
then \texttt{`H} is a fine choice for a region bound.

These issues are discussed in \sectionref{sec:advanced}.

% If you must write down a function type, then you have to understand
% that we have been lying about the form of function types and
% prototypes.  A function type actually has an explicit effect, written
% at the end of the parameter list, following a semi-colon.  For
% example, \texttt{int f(int,int *`r)}; is really shorthand for:

% \begin{verbatim}
%   int f(int,int; `e+{`r});
% \end{verbatim}

% An effect is part of a function's type; it has nothing to do with
% run-time values.  In particular, the \texttt{+} above has nothing to do
% with addition.  An effect contains region names and effect names.
% Capabilities really include effect names and region names.  A program
% point's capability includes its function's type's effect and the
% region names for the enclosing blocks and region constructs.
% Effect names are discussed more below.

% The full syntax for effects is:

% \begin{itemize}
% \item \verb|{}|, for the empty capability 
% \item \verb|{`r1,...,`rn}| for the capability of region names
%   \texttt{`r1},\ldots, \texttt{`rn} 
% \item \texttt{`e} for the capability of effect name \texttt{`e} 
% \item \texttt{E1 + E2} for the union of the effects of \texttt{E1} and
%   \texttt{E2}.  The union contains all the region names and effect names
%   of \texttt{E1} and \texttt{E2}. 
% \end{itemize}

% \subsubsection{Default Effects}

% When you do not put an explicit effect on a function type, the
% compiler puts one in for you as follows: It is
% \verb|`e+`e1+...+`em+{`r1,...,`rn}| where \texttt{`e} is fresh,
% \texttt{`r1}, \ldots, \texttt{`rn} are the region names appearing in the
% parameter and return types, and \texttt{`e1}, \ldots, \texttt{`em} are the
% effect names appearing the parameter and return types.  The
% \texttt{`e1}, \ldots, \texttt{`em} include effect names added for you.
% For example,
% \begin{verbatim}
%   int f(void g(), 
%         int *`r x, 
%         void h(region_t<`r> rgn));
% \end{verbatim}
% is shorthand for:
% \begin{verbatim}
%   int f(void g(;`e1), 
%         int *`r x, 
%         void h(region_t<`r> rgn; `e2+{`r})
%         ; `e3+`e1+`e2+{`r});
% \end{verbatim}

% In fact, we are still leaving the binding of the region names and
% effect names implicit.  By default, they are bound at the outermost
% level of the function type:
% \begin{verbatim}
%   int f<`r::R,`e1::E,`e2::E,`e3::E>
%        (void g(;`e1), 
%         int *`r x, 
%         void h(region_t<`r> rgn; `e2+{`r})
%         ; `e3+`e1+`e2+{`r});
% \end{verbatim}

% The compiler can only infer default effects for top-level function
% types (i.e., function prototypes) and function types inside other
% function types.  This is why you cannot write down a function-pointer
% type, a function-type \texttt{struct} member, a function-type
% \texttt{typedef} definition, etc., without an explicit effect.

% \subsubsection{Meaning of Effect Names}

% As described above, when functions and type declarations are
% parameterized by region names, uses instantiate the region names with
% region names.  (For example, in \texttt{struct List<int,`H>}, \texttt{`H}
% instantiates \texttt{`r}.)  An effect name is similarly instantiated,
% but with a capability.  The same restrictions on type inference apply.

% We can now understand how to declare and use structs with
% function-pointer members.  The example above puts explicit effects on
% the functions, binds the effect names in the struct declaration, and
% instantiates the effect names (to the empty capability) when using the
% struct declaration.

% Why do functions need effect names in their capabilities?  The short
% answer is that having different effect names for each function type
% ensures the implicit instantiation of region names and effects will
% succeed for all function calls where it should succeed.

% Local Variables:
% TeX-master: "main-screen"
% End:
