\section{Memory Management Via Regions}
\label{sec:regions}

%Contents: Introduction, Allocation, Common Uses, Type-Checking Regions

\subsection{Introduction}

C gives programmers complete control over how memory is managed.  An
expert programmer can exploit this to write very fast programs.
However, bugs that creep into memory-management code can cause
crashes and are notoriously hard to debug.

Languages like Java and ML use garbage collectors instead of leaving
memory management in the hands of ordinary programmers.  This makes
memory management much safer, since the garbage collector is written
by experts, and it is used, and, therefore, debugged, by every
program.  However, removing memory management from the control of the
applications programmer can make for slower programs.

Safety is the main goal of Cyclone, so we provide a garbage collector.
But, like C, we also want to give programmers as much control over
memory management as possible, without sacrificing safety.  Cyclone's
region system is a way to give programmers more explicit control over
memory management.

In Cyclone, objects are placed into \emph{regions}.  A region is simply an
area of memory that is allocated and deallocated all at once (but not for
our two special regions; see below).  So to deallocate an object, you
deallocate its region, and when you deallocate a region, you deallocate all
of the objects in the region.  Regions are sometimes called ``arenas'' or
``zones.''

Cyclone has four sorts of region:
\begin{description}
\item[Stack regions] As in C, local variables are allocated on the
  runtime stack; the stack grows when a block is entered, and it
  shrinks when the block exits.  We call the area on the stack
  allocated for the local variables of a block the \emph{stack region}
  of the block.  A stack region has a fixed size---it is just large
  enough to hold the locals of the block, and no more objects can be
  placed into it.  The region is deallocated when the block containing
  the declarations of the local variables finishes executing.  With
  respect to regions, the parameters of a function are considered
  locals---when a function is called, its actual parameters are placed
  in the same stack region as the variables declared at the start of
  the function.
  
\item[Dynamic regions] Cyclone also has \emph{dynamic regions},
  which are regions that you can add objects to over time.  You create
  a dynamic region in Cyclone with a statement,
\begin{alltt}
  region {\it identifier} {\it statement}
\end{alltt}
  This declares and allocates a new dynamic region, named
  \textit{identifier}, and executes \textit{statement}.  After
  \textit{statement} finishes executing, the region is deallocated.
  Within \textit{statement}, objects can be added to the region, as we
  will explain below.

  Typically, \textit{statement} is a compound statement:
\begin{alltt}
  region \textit{identifier} \lb
    {\it statement}\(\sb{1}\)
    \ldots
    {\it statement}\(\sb{n}\)
  \rb
\end{alltt}

\item[The heap] Cyclone has a special region called the \emph{heap}.
  There is only one heap, and it is never deallocated.  New objects
  can be added to the heap at any time (the heap can grow).  Cyclone
  uses a garbage collector to automatically remove objects from the
  heap when they are no longer needed.  You can think of garbage
  collection as an optimization that tries to keep the size of the
  heap small.

\item[The unique region] Cyclone has another special region called the
  \emph{unique region}.  The unique region type is \texttt{`U}, meaning that
  its pointers (so-called \emph{unique pointers}) look like,
  e.g. \texttt{int *`U}.  The unique region is like the heap in that it can
  grow arbitrarily, it is never deallocated \emph{en masse}, and that it
  uses garbage collection to free unreachable memory.  In addition,
  individual objects objects inside of the unique region can be freed
  explicitly using \texttt{ufree}.  For freeing objects to be sound, we
  impose restrictions on how pointers into the unique region can be used.
\end{description}

Objects outside of the heap and unique region live until their region is
deallocated; there is no way to free such an object earlier.  Objects in the
heap or unique region can be garbage collected once they are unreachable
(i.e., they cannot be reached by traversing pointers) from the program's
variables.  Objects other regions always appear reachable to the garbage
collector (so everything reachable from them appears reachable as well).

Cyclone forbids following dangling pointers.  This restriction is part of
the type system: it's a compile-time error if a dangling pointer (a pointer
into a deallocated region or to a deallocated object) might be followed.
There are no run-time checks of the form, ``is this pointing into a live
region?''  As explained below, each pointer type has a region and objects of
the type may only point into that region.

\subsection{Allocation}
You can create a new object on the heap using one of three kinds of
expression: 
\begin{itemize}
\item \texttt{new {\it expr}} evaluates \textit{expr}, places the
  result into the heap, and returns a pointer to the result.  It is
  roughly equivalent to
\begin{alltt}
  t @ temp = malloc(sizeof(t)); // where t is the type of expr
  *temp = {\it expr};
\end{alltt}
  For example, \texttt{new 17} allocates space for an integer on the
  heap, initializes it to 17, and returns a pointer to the space.  For
  another example, if we have declared
\begin{verbatim}
  struct Pair { int x; int y; };
\end{verbatim}
  then \texttt{new Pair(7,9)} allocates space for two integers on the
  heap, initializes the first to 7 and the second to 9, and returns a
  pointer to the first.

\item \texttt{new {\it array-initializer}} allocates space for an
  array, initializes it according to \textit{array-initializer}, and
  returns a pointer to the first element.  For example,
\begin{verbatim}
  let x = new { 3, 4, 5 };
\end{verbatim}
  declares a new array containing 3, 4, and 5, and initializes
  \texttt{x} to point to the first element.  More interestingly,
\begin{alltt}
  new \lb for {\it identifier} < {\it expr}\(\sb{1}\) : {\it expr}\(\sb{2}\) \rb
\end{alltt}
  is roughly equivalent to
\begin{alltt}
  unsigned int sz = {\it expr}\(\sb{1}\);
  t @ temp = malloc(sz * sizeof(t\(\sb{2}\))); // where t is the  type of expr
  for (int {\it identifier} = 0; {\it identifier} < sz; {\it identifier}++)
    temp[{\it identifier}] = {\it expr}\(\sb{2}\);
\end{alltt}
  That is, 
  {\it expr}\(\sb{1}\)
  is evaluated first to get the size of the new array,
  the array is allocated, and each element of the array is
  initialized by the result of evaluating
  {\it expr}\(\sb{2}\).
  {\it expr}\(\sb{2}\) may use {\it identifier}, which 
  holds the index of the element currently being initialized.
  
  For example, this function returns an array containing the first
  \texttt{n} positive even numbers:
\begin{verbatim}
  int ? n_evens(int n) {
    return new {for next < n :  2*(next+1)};
  }
\end{verbatim}

  Note that:
  \begin{itemize}
  \item {\it expr}\(\sb{1}\) is evaluated exactly once, while {\it
      expr}\(\sb{2}\) is evaluated {\it expr}\(\sb{1}\) times.
  \item {\it expr}\(\sb{1}\) might evaluate to 0.
  \item {\it expr}\(\sb{1}\) might evaluate to a negative number.
    If so, it is implicitly converted to a very large unsigned
    integer; the allocation is likely to fail due to insufficient
    memory.  Currently, this will cause a crash!!
  \item Currently, \texttt{for} array initializers are the only way to
    create an object whose size depends on run-time data.
  \end{itemize}
  
\item \texttt{malloc(sizeof({\it type}))}.  This is the only use of
  \texttt{malloc} allowed in Cyclone; to enforce this, we have made
  \texttt{malloc} a keyword.  This is much more restricted
  than in C, where \texttt{malloc} is just an identifier bound to a
  library function consuming an \texttt{int} and returning a
  \texttt{char *}.

  In Cyclone, you cannot even write \texttt{malloc(8)} if
  \texttt{sizeof({\it type})} is 8!  So, \texttt{malloc} can't be used
  to create an array whose size depends on run-time data.
  
  On the plus side, the type of \texttt{malloc(sizeof({\it type}))} is
  \texttt{{\it type} @} (a subtype of \texttt{{\it type} *}),
  so there is no need to cast the result from \texttt{char *}.
\end{itemize}

Unique pointers can be allocated just as with the heap, but the context must
make clear that a unique pointer is desired.  For example, in the following
the variable \texttt{temp} is allocated in the heap:
\begin{alltt}
  t @ temp = malloc(sizeof(t));
\end{alltt}
Modifying it slightly, we allocate into the unique region instead:
\begin{alltt}
  t @`U temp  =        malloc(sizeof(t));
  t @   temp2 = (t @`U)malloc(sizeof(t));
\end{alltt}
Unfortunately, our type inference system for allocation is overly simple, so
you can't do something like:
\begin{alltt}
  t @ temp = malloc(sizeof(t));
  ufree(temp);
\end{alltt}
In an ideal world, the fact that \texttt{temp} was passed to \texttt{ufree}
would signal that it is a unique pointer, rather than a heap pointer.

Objects can be created in a dynamic region using the following analogous
expressions.
\begin{itemize}
\item \texttt{rnew({\it identifier}) {\it expr}}
\item \texttt{rnew({\it identifier}) {\it array-initializer}}
\item \texttt{rmalloc({\it identifier},sizeof({\it type}))}
\end{itemize}
\texttt{rnew} and \texttt{rmalloc} are keywords.

The Cyclone library has global variables \texttt{Core::heap_region} and
\texttt{Core::unique_region} which are handles for the heap and unique
regions, respectively.  So, for example, \texttt{new {\it expr}} could be
replaced with \texttt{rnew(heap_region,{\it expr})}.  We also define a macro
\texttt{unew({\it expr})} that expands to \texttt{rnew(unique_region,{\it
expr})}.

The only way to create an object in a stack region is declaring it as
a local variable.  Cyclone does not currently support \texttt{salloc};
use a dynamic region instead.

\subsection{Common Uses}
\label{sec:common-use}

Although the type system associated with regions is complicated, there are
some simple common idioms.  If you understand these idioms, you should be
able to easily write programs using regions, and port many legacy C programs
to Cyclone.  The next subsection will explain the usage patterns of unique
pointers, since they are substantially more restrictive than other pointers.

Remember that every pointer points into a region, and although the
pointer can be updated, it must always point into that same region (or
a region known to outlive that region).  The region that the pointer
points to is indicated in its type, but omitted regions are filled in
by the compiler according to context.

% \begin{verbatim}
%   int x = 7;
%   int *y = &x;
% \end{verbatim}
% Here the local variable \texttt{x} lives in a stack region, and
% \texttt{y} is declared as a heap pointer, so it cannot be assigned the
% address of \texttt{x}.

% To get \texttt{y} to point at \texttt{x}, you must declare it with a
% different type---it should be a pointer into the stack region.  The
% easiest way to do this is to let Cyclone figure out the type for you,
% either using a \texttt{let} declaration:
% \begin{verbatim}
%   int x = 7;
%   let y = &x;
% \end{verbatim}
% If you want to emphasize that \texttt{y} is a pointer to an integer,
% you can use the wildcard type to get Cyclone to fill in the region for
% you: 
% \begin{verbatim}
%   int x = 7;
%   int *_ y = &x;
% \end{verbatim}
% The wildcard (\texttt{_}) tells the compiler, ``fill in this part of
% the type for me.''

When regions are omitted from pointer types in function bodies, the
compiler tries to infer the region.  However, it can sometimes be too
``eager'' and end up rejecting code.  For example, in
\begin{verbatim}
void f1(int x) {
  int @ y = new 42;
  y = &x;
}
\end{verbatim}
the compiler uses y's initializer to decide that y's type is
\texttt{int @ `H}.  Hence the assignment is illegal, the parameter's
region (called \texttt{`f1}) does not outlive the heap.  On the other
hand, this function type-checks:
\begin{verbatim}
void f2(int x) {
  int @ y = &x;
  y = new 42;
}
\end{verbatim}
because y's types is inferred to be \texttt{int @ `f2} and the
assignment makes y point into a region that outlives \texttt{`f2}.  We
can fix our first function by being more explicit:
\begin{verbatim}
void f1(int x) {
  int @`f1 y = new 42;
  y = &x;
}
\end{verbatim}

Function bodies are the only places where the compiler tries to infer
the region by how a pointer is used.  In function prototypes, type
declarations, and top-level global declarations, the rules for the
meaning of omitted region annotations are fixed.  This is necessary
for separate compilation: we often have no information other than the
prototype or declaration.

In the absence of region annotations, function-parameter pointers are
assumed to point into any possible region.  Hence, given
\begin{verbatim}
void f(int * x, int * y);
\end{verbatim}
we could call f with two stack pointers, a dynamic-region pointer and
a heap-pointer, etc.  Hence this type is the ``most useful'' type from
the caller's perspective.  But the callee's body (f) may not
type-check with this type.  For example, x cannot be assigned to a
heap pointer because we do not know that x points into the heap.  If
this is necessary, we must give x the type \texttt{int *`H}.  Other
times, we may not care what region x and y are in so long as they are
the \emph{same} region.  Again, our prototype for f does not indicate
this, but we could rewrite it as
\begin{verbatim}
void f(int *`r x, int *`r y);
\end{verbatim}
Finally, we may need to refer to the region for x or y in the function
body.  If we omit the names (relying on the compiler to make up
names), then we obviously won't be able to do so.

Formally, omitted regions in function parameters are filled in by
fresh region names and the function is ``region polymorphic'' over
these names (as well as all explicit regions).

In the absence of region annotations, function-return pointers are
assumed to point into the heap.  Hence the following function will not
type-check:
\begin{verbatim}
int * f(int * x) { return x; }
\end{verbatim}
Both of these functions will type-check; the second one is more
useful:
\begin{verbatim}
int * f(int *`H x) { return x; }
int *`r f(int *`r x) {return x; }
\end{verbatim}

In type declarations (including \texttt{typedef} for now) and
top-level variables, omitted region annotations are assumed to point
into the heap.  In the future, the meaning of \texttt{typedef} may
depend on where the \texttt{typedef} is used.  In the meantime, this
code will type-check because it is equivalent to the first function in
the previous example:
\begin{verbatim}
typedef int * foo_t;
foo_t f(foo_t x) { return x; }
\end{verbatim}

% If a function parameter is declared as a pointer into the heap, then
% you are not allowed to call the function with a stack pointer or
% dynamic-region pointer for that parameter.  The function knows that
% the heap is never deallocated, so it is free to keep a copy of the
% pointer around even after it returns; it can safely dereference the saved
% pointer the next time it is called.  If you could pass a stack pointer
% in for the parameter, the function might end up dereferencing a
% dangling pointer.

If you want to write a function that creates new objects in a region
determined by the caller, your function should take a region handle as one
of its arguments.\footnote{The following discussion does not include
allocating into the unique region; this will be described in
Section~\ref{sec:poly-allocate}.}  The type of a handle is
\texttt{region_t<`r>}, where \texttt{`r} is the region information
associated with pointers into the region.  For example, this function
allocates a pair of integers into the region whose handle is \texttt{r}:
\begin{verbatim}
  $(int,int)@`r f(region_t<`r> r, int x, int y) { 
     return rnew(r) $(x,y);
  }
\end{verbatim}
Notice that we used the same \texttt{`r} for the handle and the return
type.  We could have also passed the object back through a pointer
parameter like this:
\begin{verbatim}
  void f2(region_t<`r> r,int x,int y,$(int,int)*`r *`s p){ 
    *p = rnew(r) $(7,9); 
  }
\end{verbatim}

Notice that we have been careful to indicate that the region where
\texttt{*p} lives (corresponding to \texttt{`s}) may be different from
the region for which \texttt{r} is the handle (corresponding to
\texttt{`r}).  Here's how to use \texttt{f2}:
\begin{verbatim}
  region rgn { 
    $(int,int) *`rgn x = NULL; 
    f2(rgn,3,4,&x);
 }
\end{verbatim} %$ <-- this dollar comment helps syntax highlighting
The \texttt{`s} and \texttt{`rgn} in our example are unnecessary
because they would be inferred.

\texttt{typedef}, \texttt{struct}, and \texttt{datatype}
declarations can all be parameterized by regions,
just as they can be parameterized by types.  For example, here is part
of the list library.  Note that the ``\texttt{::R}'' is necessary.
\begin{verbatim}
  struct List<`a,`r::R>{`a hd; struct List<`a,`r> *`r tl;};
  typedef struct List<`a,`r> *`r list_t<`a,`r>;

  // return a fresh copy of the list in r2
  list_t<`a,`r2> rcopy(region_t<`r2> r2, list_t<`a> x) {
    list_t result, prev;

    if (x == NULL) return NULL;
    result = rnew(r2) List{.hd=x->hd,.tl=NULL};
    prev = result;
    for (x=x->tl; x != NULL; x=x->tl) {
      prev->tl = rnew(r2) List(x->hd,NULL);
      prev = prev->tl;
    }
    return result;
  }  
  list_t<`a> copy(list_t<`a> x) {
    return rcopy(heap_region, x);
  }

  // Return the length of a list. 
  int length(list_t x) {
    int i = 0;
    while (x != NULL) {
      ++i;
      x = x->tl;
    }
    return i;
  }
\end{verbatim}
The type \texttt{list_t<\textit{type},\textit{rgn}>} describes
pointers to lists whose elements have type \textit{type} and whose
``spines'' are in \textit{rgn}.  

The functions are interesting for what they \emph{don't} say.
Specifically, when types and regions are omitted from a type
instantiation, the compiler uses rules similar to those used for
omitted regions on pointer types.  More explicit versions of the
functions would look like this:
\begin{verbatim}
  list_t<`a,`r2> rcopy(region_t<`r2> r2, list_t<`a,`r1> x) {
    list_t<`a,`r2> result, prev;
    ...
  }
  list_t<`a,`H> copy(list_t<`a,`r> x) { ... }
  int length(list_t<`a,`r> x) { ... }
\end{verbatim}

% Putting function pointers in struct fields currently requires an
% arcane type definition.  We recommend following the recipe illustrated
% by this example:
% \begin{verbatim}
%   struct X<`e1::E, `e2::E, `ra::R, `rb::R> {
%     int f1(int x, int y; `e1); 
%     int f2(int *`r1 x, int *`r2 y; `e2 + {`ra,`rb});
%   };

%   typedef struct X<{},{},`ra,`b> x_t<`ra::R, `rb::R>;
% \end{verbatim}

% The example is simpler if \texttt{f2} does not accept stack pointers,
% but the effect variables (\texttt{`e1} and \texttt{`e2}) are still
% necessary.  You will probably never encounter a situation where
% \texttt{x_t}'s instantiation of \texttt{`e1} and \texttt{`e2} to \verb|{}|
% causes a program not to type-check, but the gory details are discussed
% below.

\subsection{Using Unique Pointers}

The main benefit of regions is also their drawback: to free data you must
free an entire region.  This implies that to amortize the cost of creating a
region, one needs to allocate into it many times.  Furthermore, the objects
allocated in a region should be mostly in use until the region is freed, or
else memory will be wasted in the region that is unused by the program.

For the cases in which neither situation holds, we can use the unique region
which allows unique pointers to be freed individually.  To prevent dangling
pointers, a static analysis ensures that no unique pointer is aliased (i.e.,
the object is, in fact, uniquely pointed to) at the time it is freed;
however, we allow controlled forms of aliasing up until that point.  In
particular, we have a primitive \texttt{alias} that allows pointers to be
aliased within the surrounding code block, and we use syntax \texttt{{\it a}
:=: {\it b}} to allow two unique pointers $a$ and $b$ to be atomically
swapped.  Careful use of the swap operator allows us to store unique
pointers in objects that are not themselves uniquely pointed to.  Finally,
to properly deal with polymorphism, particularly when performing allocation,
we introduce new kinds for describing regions.  In practice, all of these
mechanisms are necessary for writing useful and reusable code.

\subsubsection{Simple Unique Pointers}

Having a unique pointer ensures the object pointed to is not reachable by
any other means.  When pointers are first allocated, e.g. using
\texttt{malloc}, they are unique.  Such pointers are allowed to be
\emph{read through} (that is, dereferenced or indexed) but not copied, as
the following example shows:
\begin{alltt}
  char c, ?`U buf = calloc(MAXBUF,sizeof(char));
  int i = 0;
  while ((c = getchar()) > 0 && !isspace(c)) \{
    buf[i++] = c;
  \}
  printf("%s",buf);
  ufree(buf);
\end{alltt}
This piece of code reads characters from \texttt{stdin} until a word is
formed, and then prints that word.  Because the process of storing to the
buffer does not copy its unique pointer, it can be safely freed.

When a unique pointer is copied, e.g. when passed as a parameter to a
function or stored in a datastructure, we say it has been \emph{consumed}.
We ensure that consumed pointers are not read through or copied via a
dataflow analysis.  When a consumed pointer is assigned to, very often it
can be \emph{unconsumed}, making it accessible again.  Here is a simple
example that initializes a datastructure with unique pointers:
\begin{alltt}
{\small 1}  struct pair \{ int *`U x; int *`U y; \} p;
{\small 2}  int *`U x = new 1;  // initializes x
{\small 3}  p.x = x;            // consumes x
{\small 4}  x = new 2;          // unconsumes x
{\small 5}  p.y = x;            // consumes x
\end{alltt}
If an attempt was made to read through or copy x between lines 3 and 4 or
after line 5, the flow analysis would reject the code, as in
\begin{alltt}
  int *`U x = new 1;  // initializes x
  p.x = x;            // consumes x
  p.y = x;            // rejected! x has been consumed already
\end{alltt}

Note that if you fail to free a unique pointer, it will eventually be
garbage collected.

% XXX more to say: How it works with flattened datastructures and pattern
% matching 

\subsubsection{Aliasing Unique Pointers}

Programmers often write code that aliases values temporarily, e.g. by
storing them in loop iterator variables or by passing them to functions.
Such reasonable uses would be severely hampered by ``no alias'' restrictions
on unique pointers.  To address this problem, we introduce a primitive
called \texttt{alias} that permits temporary aliasing of a unique pointer,
provided that no aliases are live when the block completes.
Here is a simple example:
\begin{alltt}
  char ?`U dst, ?`U src = ...
  \{ alias <`r> x = (char ?`r)src; // consumes src
    memcpy(dst,x,numelts(x)); \}
  // src unconsumed
  ...
  ufree(src);
\end{alltt}
The \texttt{alias} primitive introduces a fresh region variable \texttt{`r},
and aliases \texttt{src} with the variable \texttt{x} which is cast to point
into \texttt{`r}.  This operation consumes \texttt{src} for the duration of
the surrounding block, and allows \texttt{x} to be freely aliased.  As such,
we can pass \texttt{x} to the \texttt{memcpy} function, and when the block
exits, we unconsume and can therefore ultimately free \texttt{src}.

Intuitively, the \texttt{alias} operation is sound because we cast a unique
pointer to instead point into a fresh region, for which there is no
possibility of either creating new values or storing existing values into
escaping data structures.  As such we cannot create aliases.  However, we
must take care when aliasing data having recursive type.  For example, the
following code is unsound:
\begin{alltt}
  void foo(list\_t<`a,`U> l) \{
    alias <`r> x = (list\_t<`a,`r>)l;
    x->tl = x; // unsound: creates alias!
  \}
\end{alltt}
In this case, the \texttt{alias} effectively created many values in the
fresh region \texttt{`r}: one for each element of the list.  This allows
storing an alias in an element reachable from the original expression
\texttt{l}, so that when the block is exited, this alias escapes.

To prevent this, we only allow ``deep'' aliasing when the aliased pointers
are immutable.  For example, if we have a list structure whose tail pointers
are \texttt{const}, call it \texttt{clist\_t}, we rule out the above code
because the assignment to \texttt{x->tl} would be forbidden.  Here is an
example implementation of the \texttt{length} function using deep aliasing:
\begin{alltt}
  int length(list\_t<int,`U> l) \{
    alias <`r> x = (clist\_t<int,`r>)l;
    int len = 0;
    while (x != NULL) \{
      len++;
      x = x->tl;
    \}
    return len;
  \}
\end{alltt}
Note that this function is not that useful, since it will consume the list
\texttt{l}.  Instead, we would rather that the function itself take a
\texttt{clist\_t} pointer, and have the caller perform the alias, so that
the unique list could be unconsumed after calling \texttt{length}.  It is on
our to-do list to change the standard libraries to be more
``unique-friendly'' in this way.

%% In general, the problem of deep aliasing has its root cause in reference
%% types and subtyping (XXX cite?).  In particular, we have that $\rho_U
%% \preceq \rho$ and therefore that $\mathtt{int\ *}\rho_U \; \preceq \;
%% \mathtt{int\ *}\rho$.  However, it is not sound to assert $\mathtt{int\
%% *}\rho_U \mathtt{*}\rho' \; \preceq \; \mathtt{int\ *}\rho\mathtt{*}\rho'$.
%% This becomes sound when the nested pointer is made immutable, i.e.
%% $\mathtt{const\ int\ *}\rho_U \mathtt{*}\rho' \; \preceq \; \mathtt{const\
%% int\ *}\rho\mathtt{*}\rho'$.  Because we cast the deep alias problem as a
%% subtyping problem, we can reuse Cyclone's subtyping rules to check for
%% soundness.

\subsubsection{Nested Unique Pointers}

You can also store unique pointers into other datastructures that could be
themselves allocated in some region.  For example, the above example
function \texttt{length} took in a list whose ``spine'' was allocated in the
unique region.  Therefore, each \texttt{tl} pointer in the list is a nested
pointer.  Nested unique pointers cannot be read directly.  In particular,
the following code is illegal:
\begin{alltt}
  void f(list\_t<int,`U> l) \{
    l = l->tl;
  \}
\end{alltt}
This code is disallowed because the unique pointer \texttt{l->tl} is nested.
We make this restriction to keep the invariant that if some unique pointer
\texttt{l} is unconsumed, then all unique pointers that it points to are
also unconsumed.  The assignment above would violate this invariant.  We
maintain this invariant to both simplify the flow analysis, and also to
allow unique pointers to be pointed to by non-unique pointers.  In
particular, a non-unique pointer can always be considered unconsumed, which
implies that any unique pointers it points to must always be unconsumed as
well.

To allow nested unique pointers to be read and used, we provide an swap
operator, having syntax \texttt{:=:}.  In particular, the code \texttt{{\it
a} :=:{\it b}} will swap the contents of {\it a} and {\it b}.  We can use
this to swap out a nested unique pointer, and replace it will a different
one; we will often swap in NULL, since this is a unique pointer that is
always unconsumed.  This allows us to write the length function on a unique
list without using the \texttt{alias} primitive (as we did above), freeing
each list element as we go:
\begin{alltt}
  int length\_unique(list\_t<int,`U> l) \{
    int len = 0;
    list\_t<int,`U> x;
    while (l != NULL) \{
      x = NULL;
      len++;
      x :=: l->tl;
      Core::ufree(l);
      l = x;
    \}
    return len;
  \}
\end{alltt}

It is often useful to have a non-unique datastructure contain unique
pointers.  For example, you could have a normal queue whose elements are
unique pointers.  This way you can freely add and remove elements from the
queue, and then free the unique pointers when the elements are removed.  One
caveat is that we currently do not support instantiating polymorphic value
variables (i.e. non-region variables) with unique pointers, because this
could result in aliasing.  For example, the following code is not allowed:
\begin{alltt}
  list\_t<int @`U> l = new List(new 1,NULL);
\end{alltt}
We can fix this problem by extending the current type system, and plan to do
so in the near future.  In the meantime, you need to create separate,
non-polymoprhic versions of library utilities.  For example, you would have
to create your own version of list that can hold \texttt{int @`U} pointers.

Note that by implementing the swap operation atomically, unique pointers
would be thread-safe as well.  We implemented things this way looking ahead
to when Cyclone will have threads.

\subsubsection{Polymorphic Region Allocation}
\label{sec:poly-allocate}

As described in Section~\ref{sec:common-use}, we can write functions that
take as arguments a region handle to allocate into.  For example, we wrote a
function \texttt{rcopy} that copies a list into some region \texttt{`r2}.
However, we didn't provide the full story that accounts for the unique
region.  In particular, consider the following function:
\begin{alltt}
  $(int @`r, int @`r) make\_pair(region\_t<`r> rgn) \{
    int @x = rnew (rgn) 1;
    return $(x, x);
  \}
\end{alltt}
This function will return a pair of pointers to the same object.  If we pass
in something other than the unique region, this function will behave
properly:
\begin{alltt}
  $(int @,int@) pair = make\_pair(heap_region);
\end{alltt}
However, things can go badly wrong if we pass in the unique region instead:
\begin{alltt}
  $(int @`U,int @`U) pair = make\_pair(unique_region);
  ufree(pair[0]);
  int x = pair[1]; // error! dereferences freed pointer
\end{alltt}
The problem is that \texttt{make\_pair} creates an alias; if we pass in the
unique region for \texttt{rgn}, we can free one of these aliases (e.g. the
pointer via the first element of the pair), but then dereference the other
(i.e. via the second pair element).

To prevent this behavior, we have to classify the two different kinds of
regions that we support: aliasable regions, whose pointers can be freely
aliased, and unique regions, whose pointers cannot be aliased but can be
freed.  To do this, we define \emph{kinds} R for aliasable regions and UR for
unique ones.  We can then classify a polymorphic region variable with the
proper kind.  This allows us to change the \texttt{make\_pair} function as
follows:
\begin{alltt}
  $(int @`r, int @`r) make\_pair(region\_t<`r::R> rgn) \{
    int @x = rnew (rgn) 1;
    return $(x, x);
  \}
\end{alltt}
Now we have specified specifically that \texttt{`r} must be an aliasable
region (in fact, when not specified, this is the default).  As such, the
illegal code above will not typecheck because we are attempting to
instantiate a unique region (having kind UR) for an aliasable one, which is
disallowed.

For generality, we introduce a third region kind TR (which stands for ``top
region''); TR is a ``super-kind'' of R and UR, meaning that types having TR
kind can be used in places expecting types of R or UR kind.  This also means
that pointers into a TR-kinded region can neither be aliased nor freed,
since we might instantiate either the unique region (whose pointers cannot
be aliased) or an aliasable region (whose pointers cannot be freed) in place
of the TR-kinded variable.

We can now generalize the \texttt{rcopy} example above:
\begin{verbatim}
  struct List<`a,`r::TR>{`a hd; struct List<`a,`r> *`r tl;};
  typedef struct List<`a,`r> *`r list_t<`a,`r>;

  // return a fresh copy of the list in r2
  list_t<`a,`r2> rcopy(region_t<`r2::TR> r2, list_t<`a> x) {
    if (x == NULL) return NULL;
    else {
      list_t rest = rcopy(r2,x->tl);
      return rnew(r2) List{.hd=x->hd,.tl=rest};
    }
  }
  list_t<`a> copy(list_t<`a> x) {
    return rcopy(heap_region, x);
  }
\end{verbatim}
We have made three key changes to the prior version of \texttt{rcopy}:
\begin{enumerate}
\item The definition of \texttt{List} has been generalized so that its
  \texttt{`r} region variable now has kind TR.  This implies that lists can
  point into any region, whether unique or aliasable.
\item The region handle \texttt{r2} now has kind TR, rather than the default
  R.  This means that we can pass in any region handle, and thus copy a list
  into any kind of region.
\item We have made \texttt{rcopy}'s implementation recursive.  This was
  necessary to avoid creating aliases to the newly created list.  In
  particular, if we were to have used a \texttt{prev} pointer as in the
  version from Section~\ref{sec:common-use}, we would have two pointers to
  the last-copied element: the \texttt{tl} field of the element before it in
  the list, and the current iterator variable \texttt{prev}.  The use of
  recursion allows us to iterate to the end of the list and construct it
  back to front, in which no aliases are required.  The cost is we need to
  do extra stack allocation.  This example illustrates that it is sometimes
  difficult to program using no-alias pointers.  This is why, in cases other
  than allocation, we would prefer to use the \texttt{alias} construct to
  allow temporary aliasing.
\end{enumerate}

\subsection{Type-Checking Regions}

Because of recursive functions, there can be any number of live
regions at run time.  The compiler the following general strategy to
ensure that only pointers into live regions are dereferenced:

\begin{itemize}
\item Use compile-time \emph{region names}.  Syntactically these are
  just type variables, but they are used differently.
\item Decorate each pointer type and handle type with one region name. 
\item Decorate each program point with a (finite) set of region names.
  We call the set the point's \emph{capability}.
\item To dereference a pointer (via \texttt{*}, \texttt{->}, or
  subscript), the pointer's type's region name must be in the program
  point's capability.  Similarly, to use a handle for allocation, the
  handle type's region name must be in the capability.
\item Enforce a type system such that the following is impossible: A
  program point P's capability contains a region name \texttt{`r} that
  decorates a pointer (or handle) expression \textit{expr} that, at
  run time, points into a region that has been deallocated and the
  operation at P dereferences \textit{expr}.
\end{itemize}

This strategy is probably too vague to make sense at this point, but
it may help to refer back to it as we explain specific aspects of the
type system.

Note that in the rest of the documentation (and in common parlance) we
abuse the word ``region'' to refer both to region names and to
run-time collections of objects.  Similarly, we confuse a block of
declarations, its region-name, and the run-time space allocated for
the block.  (With loops and recursive functions, ``the space
allocated'' for the block is really any number of distinct regions.)
But in the rest of this section, we painstakingly distinguish
region names, regions, etc.

\subsubsection{Region Names}

Given a function, we associate a distinct region name with each
program point that creates a region, as follows:

\begin{itemize}
\item If a block (blocks create stack regions) has label \texttt{L},
  then the region-name for the block is \texttt{`L}.
\item If a block has no label, the compiler makes up a unique
  region-name for the block.
\item In region \texttt{r <`foo> s}, the region-name for the construct
  is \texttt{`foo}.
\item In region \texttt{r s}, the region-name for the construct is
  \texttt{`r}.
\end{itemize}

The region name for the heap is \texttt{`H}, and the region name for the
unique region in \texttt{`U}.  Region names associated with program points
within a function should be distinct from each other, distinct from any
region names appearing in the function's prototype, and should not be
\texttt{`H} or \texttt{`U}.  (So you cannot use \texttt{H} as a label name.)
Because the function's return type cannot mention a region name for a block
or region-construct in the function, it is impossible to return a pointer to
deallocated storage.

In region \texttt{r <`r> s} and region \texttt{r s}, the type of
\texttt{r} is \texttt{region_t<`r>}.  In other words, the handle is
decorated with the region name for the construct.  Pointer types'
region names are explicit, although you generally rely on inference to
put in the correct one for you.

\subsubsection{Capabilities}

In the absence of explicit effects (see below), the capability for a
program point includes exactly:
\begin{itemize}
\item \texttt{`H} and \texttt{`U}
\item The effect corresponding to the function's prototype.  Briefly,
any region name in the prototype (or inserted by the compiler due to
an omission) is in the corresponding effect.  Furthermore, for each
type variable \texttt{`a} that appears (or is inserted),
``\texttt{regions(`a)}'' is in the corresponding effect.  This latter
effect roughly means, ``I don't know what \texttt{`a} is, but if you
instantiate with a type mentioning some regions, then add those
regions to the effect of the instantiated prototype.''  This is
necessary for safely type-checking calls that include function pointers.
\item The region names for the blocks and ``\texttt{region r s}''
  statements that contain the program point
\end{itemize}

For each dereference or allocation operation, we simply check that the
region name for the type of the object is in the capability.  It takes
extremely tricky code (such as existential region names) to make the
check fail.

\subsubsection{Assignment and Outlives}

A pointer type's region name is part of the type.  If \texttt{e1} and
\texttt{e2} are pointers, then \texttt{e1 = e2} is well-typed only if
the region name for \texttt{e2}'s type ``outlives'' the region name
for \texttt{e1}'s type.  By outlives, we intuitively mean the region
corresponding to one region name will be deallocated after the region
corresponding to the other region name.  The rules for outlives are as
follows:
\begin{itemize}
\item Every region outlives itself.
\item \texttt{`U} outlives \texttt{`H} which outlives every other region
name.
\item Region names for inner blocks outlive region names for outer
blocks.
\item For regions in function prototypes, you can provide explicit
``outlives'' as in this example:
\begin{verbatim}
void f(int *`r1*`r2 x,int *`r3 y; {`r2} > `r1, {`r3} > `r2);
\end{verbatim}
This says that \texttt{`r1} outlives \texttt{`r2} and \texttt{`r2}
outlives \texttt{`r3}.  The body will be checked under these
assumptions.  Calls to \texttt{f} will type-check only if the compiler
knows that the region names of the actual arguments obey the outlives
assumptions.  There are some restrictions on specifying outlives
relationships when considering possibly-unique region names, but these
rarely come up in practice.
\end{itemize}

For handlers, if \texttt{`r} is a region name, there is at most one
value of type \texttt{region_t<`r>} (there are 0 if \texttt{`r} is a
block's name), so there is little use in creating variables of type
\texttt{region_t<`r>}.

\subsubsection{Type Declarations}

A \texttt{struct}, \texttt{typedef}, or \texttt{datatype}
declaration may be parameterized by any number of region names.  The region
names are placed in the list of type parameters.  They must be followed by
their kind -- i.e. either ``\texttt{::R}'', ``\texttt{::UR}'', or
``\texttt{::TR}'' -- except for \texttt{typedef} declarations (where the
region name appears in the underlying type).  For example, given
\begin{verbatim}
  struct List<`a,`r::TR>{`a hd; struct List<`a,`r> *`r tl;};
\end{verbatim}
the type \texttt{struct List<int,`H>} is for a list of ints in the heap.
Notice that all of the ``cons cells'' of the \texttt{List} will be in
the same region (the type of the \texttt{tl} field uses the same
region name \texttt{`r} that is used to instantiate the recursive
instance of \texttt{struct List<`a,`r>}).  However, we could instantiate
\texttt{`a} with a pointer type that has a different region name, as long as
that region has kind R.

\texttt{datatype} declarations must also be
instantiated with an additional region name.  An object of type
\texttt{datatype `r Foo}
is treated (capability-wise) as a pointer with region name
\texttt{`r}.  If the region name is omitted from a use of a
\texttt{datatype} declaration, it is implicitly \texttt{`H}.

\subsubsection{Function Calls}

If a function parameter or result has type \texttt{int *`r} or
\texttt{region_t<`r>}, the function is polymorphic over the region name
\texttt{`r}.  That is, the caller can instantiate \texttt{`r} with any
region \emph{in the caller's current capability} as long as the region has
the correct kind. This instantiation is usually implicit, so the caller just
calls the function and the compiler uses the types of the actual arguments
to infer the instantiation of the region names (just like it infers the
instantiation of type variables).

The callee is checked knowing nothing about \texttt{`r} except that it is in
its capability (plus whatever can be determined from explicit outlives
assumptions), and that it has the given kind.  For example, it will be
impossible to assign a parameter of type \texttt{int*`r} to a global
variable.  Why?  Because the global would have to have a type that allowed
it to point into any region.  There is no such type because we could never
safely follow such a pointer (since it could point into a deallocated
region).

\subsubsection{Explicit and Default Effects}

If you are not using existential types, you now know everything you
need to know about Cyclone regions and memory management.  Even if you
are using these types and functions over them (such as the closure
library in the Cyclone library), you probably don't need to know much more
than ``provide a region that the hiddent types outlive''.

The problem with existential types is that when you ``unpack'' the
type, you no longer know that the regions into which the fields point
are allocated.  We are sound because the corresponding region names
are not in the capability, but this makes the fields unusable.  To
make them usable, we do not hide the capability needed to use them.
Instead, we use a \emph{region bound} that is not existentially
bound.  

If the contents of existential packages contain only heap pointers,
then \texttt{`H} is a fine choice for a region bound.

These issues are discussed in
\hyperref[sec:advanced]{Section~\ref{sec:advanced}.}

% If you must write down a function type, then you have to understand
% that we have been lying about the form of function types and
% prototypes.  A function type actually has an explicit effect, written
% at the end of the parameter list, following a semi-colon.  For
% example, \texttt{int f(int,int *`r)}; is really shorthand for:

% \begin{verbatim}
%   int f(int,int; `e+{`r});
% \end{verbatim}

% An effect is part of a function's type; it has nothing to do with
% run-time values.  In particular, the \texttt{+} above has nothing to do
% with addition.  An effect contains region names and effect names.
% Capabilities really include effect names and region names.  A program
% point's capability includes its function's type's effect and the
% region names for the enclosing blocks and region constructs.
% Effect names are discussed more below.

% The full syntax for effects is:

% \begin{itemize}
% \item \verb|{}|, for the empty capability 
% \item \verb|{`r1,...,`rn}| for the capability of region names
%   \texttt{`r1},\ldots, \texttt{`rn} 
% \item \texttt{`e} for the capability of effect name \texttt{`e} 
% \item \texttt{E1 + E2} for the union of the effects of \texttt{E1} and
%   \texttt{E2}.  The union contains all the region names and effect names
%   of \texttt{E1} and \texttt{E2}. 
% \end{itemize}

% \subsubsection{Default Effects}

% When you do not put an explicit effect on a function type, the
% compiler puts one in for you as follows: It is
% \verb|`e+`e1+...+`em+{`r1,...,`rn}| where \texttt{`e} is fresh,
% \texttt{`r1}, \ldots, \texttt{`rn} are the region names appearing in the
% parameter and return types, and \texttt{`e1}, \ldots, \texttt{`em} are the
% effect names appearing the parameter and return types.  The
% \texttt{`e1}, \ldots, \texttt{`em} include effect names added for you.
% For example,
% \begin{verbatim}
%   int f(void g(), 
%         int *`r x, 
%         void h(region_t<`r> rgn));
% \end{verbatim}
% is shorthand for:
% \begin{verbatim}
%   int f(void g(;`e1), 
%         int *`r x, 
%         void h(region_t<`r> rgn; `e2+{`r})
%         ; `e3+`e1+`e2+{`r});
% \end{verbatim}

% In fact, we are still leaving the binding of the region names and
% effect names implicit.  By default, they are bound at the outermost
% level of the function type:
% \begin{verbatim}
%   int f<`r::R,`e1::E,`e2::E,`e3::E>
%        (void g(;`e1), 
%         int *`r x, 
%         void h(region_t<`r> rgn; `e2+{`r})
%         ; `e3+`e1+`e2+{`r});
% \end{verbatim}

% The compiler can only infer default effects for top-level function
% types (i.e., function prototypes) and function types inside other
% function types.  This is why you cannot write down a function-pointer
% type, a function-type \texttt{struct} member, a function-type
% \texttt{typedef} definition, etc., without an explicit effect.

% \subsubsection{Meaning of Effect Names}

% As described above, when functions and type declarations are
% parameterized by region names, uses instantiate the region names with
% region names.  (For example, in \texttt{struct List<int,`H>}, \texttt{`H}
% instantiates \texttt{`r}.)  An effect name is similarly instantiated,
% but with a capability.  The same restrictions on type inference apply.

% We can now understand how to declare and use structs with
% function-pointer members.  The example above puts explicit effects on
% the functions, binds the effect names in the struct declaration, and
% instantiates the effect names (to the empty capability) when using the
% struct declaration.

% Why do functions need effect names in their capabilities?  The short
% answer is that having different effect names for each function type
% ensures the implicit instantiation of region names and effects will
% succeed for all function calls where it should succeed.

% Local Variables:
% TeX-master: "main-screen"
% End:
