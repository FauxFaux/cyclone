\section{Memory Management Via Regions}
\label{sec:regions}

%Contents: Introduction, Allocation, Common Uses, Type-Checking Regions

\subsection{Introduction}

C gives programmers complete control over how memory is managed.  An
expert programmer can exploit this to write very fast programs.
However, bugs that creep in to memory management code can cause
crashes and are notoriously hard to debug.

Languages like Java and ML use garbage collectors instead of leaving
memory management in the hands of ordinary programmers.  This makes
memory management much safer, since the garbage collector is written
by experts, and it is used, and, therefore, debugged, by every
program.  However, removing memory management from the control of the
applications programmer can make for slower programs.

Safety is the main goal of Cyclone, so we provide a garbage collector.
But, like C, we also want to give programmers as much control over
memory management as possible, without sacrificing safety.  Cyclone's
region and effect system is a way to give programmers more explicit
control over memory management.

In Cyclone, objects are placed into \emph{regions}.  A region is
simply an area of memory that is allocated and deallocated all at
once.  So to deallocate an object, you deallocate its region, and
when you deallocate a region, you deallocate all of the objects in the
region.  Regions are sometimes called ``arenas'' or ``zones.''

Cyclone has three sorts of region:
\begin{description}
\item[Stack regions] As in C, local variables are allocated on the
  runtime stack; the stack grows when a block is entered, and it
  shrinks when the block exits.  We call the area on the stack
  allocated for the local variables of a block the \emph{stack region}
  of the block.  A stack region has a fixed size---it is just large
  enough to hold the locals of the block, and no more objects can be
  placed into it.  The region is deallocated when the block containing
  the declarations of the local variables finishes executing.  With
  respect to regions, the parameters of a function are considered
  locals---when a function is called, its actual parameters are placed
  in the same stack region as the variables declared at the start of
  the function.
  
\item[Growable regions] Cyclone also has \emph{growable regions},
  which are regions that you can add objects to over time.  You create
  a growable region in Cyclone with a statement,
\begin{alltt}
  region {\it identifier} {\it statement}
\end{alltt}
  This declares and allocates a new growable region, named
  \textit{identifier}, and executes \textit{statement}.  After
  \textit{statement} finishes executing, the region is deallocated.
  Within \textit{statement}, objects can be added to the region, as we
  will explain below.

  Typically, \textit{statement} is a compound statement:
\begin{alltt}
  region \textit{identifier} \lb
    {\it statement}\(\sb{1}\)
    \ldots
    {\it statement}\(\sb{n}\)
  \rb
\end{alltt}

\item[The heap] Cyclone has a special region called the \emph{heap}.
  There is only one heap, and it is never deallocated.  New objects
  can be added to the heap at any time (the heap can grow).  Cyclone
  uses a garbage collector to automatically remove objects from the
  heap when they are no longer needed.  You can think of garbage
  collection as an optimization that tries to keep the size of the
  heap small.
\end{description}

Objects outside of the heap live until their region is deallocated;
there is no way to free such an object earlier.  Objects in the heap
can be garbage collected once they are unreachable (i.e., they cannot
be reached by traversing pointers) from the program's variables.
Objects in live non-heap regions always appear reachable to the
garbage collector (so everything reachable from them appears reachable
as well).

Cyclone forbids you from following dangling pointers.  This
restriction is part of the type system: it's a compile-time error if a
dangling pointer (a pointer into a deallocated region) might be
followed.  There are no run-time checks of the form, ``is this
pointing into a live region?''  As explained below, each pointer type
has a region and objects of the type may only point into that region.
The type ``\texttt{t *}'' is for pointers into the heap; see below for
how to declare pointers into other regions.

\subsection{Allocation}
You can create a new object on the heap using one of three kinds of
expression: 
\begin{itemize}
\item \texttt{new {\it expr}} evaluates \textit{expr}, places the
  result into the heap, and returns a pointer to the result.  It is
  roughly equivalent to
\begin{alltt}
  let temp = malloc(sizeof({\it expr}));
  *temp = {\it expr};
\end{alltt}
  For example, \texttt{new 17} allocates space for an integer on the
  heap, initializes it to 17, and returns a pointer to the space.  For
  another example, if we have declared
\begin{verbatim}
  struct Pair { int x; int y; };
\end{verbatim}
  then \texttt{new Pair(7,9)} allocates space for two integers on the
  heap, initializes the first to 7 and the second to 9, and returns a
  pointer to the first.

\item \texttt{new {\it array-initializer}} allocates space for an
  array, initializes it according to \textit{array-initializer}, and
  returns a pointer to the first element.  For example,
\begin{verbatim}
  let x = new { 3, 4, 5 };
\end{verbatim}
  declares a new array containing 3, 4, and 5, and initializes
  \texttt{x} to point to the first element.  More interestingly,
\begin{alltt}
  new \lb for {\it identifier} < {\it expr}\(\sb{1}\) : {\it expr}\(\sb{2}\) \rb
\end{alltt}
  is roughly equivalent to
\begin{alltt}
  unsigned int sz = {\it expr}\(\sb{1}\);
  let temp = malloc(sz * sizeof({\it expr}\(\sb{2}\)));
  for (int {\it identifier} = 0; {\it identifier} < sz; {\it identifier}++)
    temp[{\it identifier}] = {\it expr}\(\sb{2}\);
\end{alltt}
  That is, 
  {\it expr}\(\sb{1}\)
  is evaluated first to get the size of the new array,
  the array is allocated, and each element of the array is
  initialized by the result of evaluating
  {\it expr}\(\sb{2}\).
  {\it expr}\(\sb{2}\) may use {\it identifier}, which 
  holds the index of the element currently being initialized.
  
  For example, this function returns an array containing the first
  \texttt{n} positive even numbers:
\begin{verbatim}
  int ? n_evens(int n) {
    return new {for next < n :  2*(next+1)};
  }
\end{verbatim}

  Note that:
  \begin{itemize}
  \item {\it expr}\(\sb{1}\) is evaluated exactly once, while {\it
      expr}\(\sb{2}\) is evaluated {\it expr}\(\sb{1}\) times.
  \item {\it expr}\(\sb{1}\) might evaluate to 0.
  \item {\it expr}\(\sb{1}\) might evaluate to a negative number.
    If so, it is implicitly converted to a very large unsigned
    integer; the allocation is likely to fail due to insufficient
    memory.  Currently, this will cause a crash!!
  \item Currently, \texttt{for} array initializers are the only way to
    create an object whose size depends on run-time data.
  \end{itemize}
  
\item \texttt{malloc(sizeof({\it type}))}.  This is the only use of
  \texttt{malloc} allowed in Cyclone; to enforce this, we have made
  \texttt{malloc} a keyword in Cyclone.  This is much more restricted
  than in C, where \texttt{malloc} is just an identifier bound to a
  library function consuming an \texttt{int} and returning a
  \texttt{char *}.

  In Cyclone, you cannot even write \texttt{malloc(8)} if
  \texttt{sizeof({\it type})} is 8!  So, \texttt{malloc} can't be used
  to create an array whose size depends on run-time data.
  
  On the plus side, the type of \texttt{malloc(sizeof({\it type}))} is
  \texttt{{\it type} @} (a subtype of \texttt{{\it type} *}),
  so there is no need to cast the result from \texttt{char *}.
\end{itemize}

Objects can be created in a growable region using the following analogous
expressions.
\begin{itemize}
\item \texttt{rnew({\it identifier}) {\it expr}}
\item \texttt{rnew({\it identifier}) {\it array-initializer}}
\item \texttt{rmalloc({\it identifier},sizeof({\it type}))}
\end{itemize}
\texttt{rnew} and \texttt{rmalloc} are keywords.

The Cyclone library has a global variable \texttt{Core::heap_region}
which contains a handle for the heap region, so, for example,
\texttt{new {\it expr}} is just \texttt{rnew(heap_region,{\it expr})}.

The only way to create an object in a stack region is declaring it as
a local variable.  Cyclone does not currently support \texttt{salloc};
use a growable region instead.

\subsection{Common Uses}

Although the type system associated with regions is complicated, there
are some simple common idioms.  If you understand these idioms, you
should be able to easily write programs using regions, and port many
legacy C programs to Cyclone.

Remember that every pointer points into a region, and although the
pointer can be updated, it must always point into that same region.
The region that the pointer points to is indicated in its type, and if
no region is explicitly given, it defaults to the heap region.
This means that the following local declarations are not permitted in
Cyclone:
\begin{verbatim}
  int x = 7;
  int *y = &x;
\end{verbatim}
Here the local variable \texttt{x} lives in a stack region, and
\texttt{y} is declared as a heap pointer, so it cannot be assigned the
address of \texttt{x}.

To get \texttt{y} to point at \texttt{x}, you must declare it with a
different type---it should be a pointer into the stack region.  The
easiest way to do this is to let Cyclone figure out the type for you,
either using a \texttt{let} declaration:
\begin{verbatim}
  int x = 7;
  let y = &x;
\end{verbatim}
If you want to emphasize that \texttt{y} is a pointer to an integer,
you can use the wildcard type to get Cyclone to fill in the region for
you: 
\begin{verbatim}
  int x = 7;
  int *_ y = &x;
\end{verbatim}
The wildcard (\texttt{_}) tells the compiler, ``fill in this part of
the type for me.''

Because pointers may only point into a single region during their
lifetime, the following code won't type check, and there is
essentially no way to make it type check:
\begin{alltt}
  int x = 7;
  let y = &x;
  y = new 42;
\end{alltt}
The problem is that \texttt{y} can't hold both pointer to a stack
region and a pointer into the heap.

If a function parameter is declared as a pointer into the heap, then
you are not allowed to call the function with a stack pointer or
growable region pointer for that parameter.  The function knows that
the heap is never deallocated, so it is free to keep a copy of the
pointer around even after it returns; it can safely dereference the saved
pointer the next time it is called.  If you could pass a stack pointer
in for the parameter, the function might end up dereferencing a
dangling pointer.

You can pass a stack pointer to a function provided the function
doesn't keep a copy of the pointer after it returns.  In that case,
the function doesn't care what kind of pointer it gets; it just needs
to dereference the pointer during the function call, and every region
that is allocated before a given function call is only deallocated
after the call returns.  The function only needs to declare that it
doesn't care what region the parameter points into, and this can be
done with region variables.  For example,
\begin{verbatim}
  void f(int *`r x, int *`s y, int *z);
\end{verbatim}
declares a function \texttt{f} that takes an argument \texttt{x}
pointing into any region \texttt{`r}, an argument \texttt{y} that
points into any region \texttt{`s}, and an argument \texttt{z} that
points into the heap.  The regions \texttt{`r} and \texttt{`s} could
be stack regions, growable regions, or the heap region.

A slightly more restrictive version of \texttt{f} can be declared,
\begin{verbatim}
  void f(int *`r x, int *`r y, int *z);
\end{verbatim}
Here we have eliminated \texttt{`s} and replaced it by \texttt{`r}.
Once again, \texttt{`r} could be a stack, growable, or heap region,
however, \texttt{x} and \texttt{y} must point into the \emph{same}
region.  In the previous version of \texttt{f}, \texttt{x} could point
into the heap while \texttt{y} could point into the stack.

To put the fewest restrictions on the regions of the parameters, use a
different region variable for each pointer.

If you want to write a function that creates new objects in a region
determined by the caller, your function should take a region handle as
one of its arguments.  The type of a region handle is allocate into a
caller-provided region).  The type of a handle is
\texttt{region_t<`r>}, where \texttt{`r} is the region information
associated with pointers into the region.  For example, this function
allocates a pair of integers into the region whose handle is
\texttt{r}:
\begin{verbatim}
  $(int,int)@`r f(region_t<`r> r, int x, int y) { 
     return rnew(r) $(x,y);
  }
\end{verbatim}
Notice that we used the same \texttt{`r} for the handle and the return
type.  We could have also passed the object back through a pointer
parameter like this:
\begin{verbatim}
  void f2(region_t<`r> r,int x,int y,$(int,int)*`r *`s p){ 
    *p = rnew(r) $(7,9); 
  }
\end{verbatim}

Notice that we have been careful to indicate that the region where
\texttt{*p} lives (corresponding to \texttt{`s}) may be different from
the region for which \texttt{r} is the handle (corresponding to
\texttt{`r}).  Here's how to use \texttt{f2}:
\begin{verbatim}
  region r { 
    $(int,int) *_ x = null; 
    f2(r,3,4,&x);
 }
\end{verbatim} %$ <-- this dollar comment helps syntax highlighting

\texttt{typedef}, \texttt{struct}, \texttt{tunion}, and
\texttt{xtunion} declarations can all be parameterized by regions.
For example, here is part of the list library.  Note that the
``\texttt{::R}'' is necessary and that \texttt{`H} describes the heap
region.
\begin{verbatim}
  struct List<`a,`r::R>{`a hd; struct List<`a,`r> *`r tl;};
  typedef struct List<`a,`r> *`r glist_t<`a,`r>;
  typedef struct List<`a,`H> *list_t<`a>;

  // return a fresh copy of the list in r2
  glist_t<`a,`r2> rcopy(region_t<`r2> r2, glist_t<`a,`r1> x) {
    glist_t<`a,`r2> result, prev;

    if (x == null) return null;
    result = rnew(r2) List{.hd=x->hd,.tl=null};
    prev = result;
    for (x=x->tl; x != null; x=x->tl) {
      prev->tl = rnew(r2) List(x->hd,null);
      prev = prev->tl;
    }
    return result;
  } 
  list_t<`a> copy(glist_t<`a,`r> x) {
    return rcopy(heap_region, x);
  }
\end{verbatim}

Putting function pointers in struct fields currently requires an
arcane type definition.  We recommend following the recipe illustrated
by this example:
\begin{verbatim}
  struct X<`e1::E, `e2::E, `ra::R, `rb::R> {
    int f1(int x, int y; `e1); 
    int f2(int *`r1 x, int *`r2 y; `e2 + {`ra,`rb});
  };

  typedef struct X<{},{},`ra,`b> x_t<`ra::R, `rb::R>;
\end{verbatim}

The example is simpler if \texttt{f2} does not accept stack pointers,
but the effect variables (\texttt{`e1} and \texttt{`e2}) are still
necessary.  You will probably never encounter a situation where
\texttt{x_t}'s instantiation of \texttt{`e1} and \texttt{`e2} to \verb|{}|
causes a program not to type-check, but the gory details are discussed
below.

\subsection{Type-Checking Regions}

Because of recursive functions, there can be any number of live
regions at run time.  The compiler the following general strategy to
ensure that only pointers into live regions are dereferenced:

\begin{itemize}
\item Use compile-time \emph{region names}.  Syntactically these are
  just type variables, but they are used differently.
\item Decorate each pointer type and handle type with one region name. 
\item Decorate each program point with a (finite) set of region names.
  We call the set the point's \emph{capability}.
\item To dereference a pointer (via \texttt{*}, \texttt{->}, or
  subscript), the pointer's type's region name must be in the program
  point's capability.  Similarly, to use a handle for allocation, the
  handle type's region name must be in the capability.
\item Enforce a type system such that the following is impossible: A
  program point P's capability contains a region name \texttt{`r} that
  decorates a pointer (or handle) expression \textit{expr} that, at
  run time, points into a region that has been deallocated and the
  operation at P dereferences \textit{expr}.
\end{itemize}

This strategy is probably too vague to make sense at this point, but
it may help to refer back to it as we explain specific aspects of the
type system.

Note that in the rest of the documentation (and in common parlance) we
abuse the word ``region'' to refer both to region names and to
run-time collections of objects.  Similarly, we confuse a block of
declarations, its region-name, and the run-time space allocated for
the block.  (With loops and recursive functions, ``the space
allocated'' for the block is really any number of distinct regions.)
But in the rest of this section, we painstakingly distinguish
region names, regions, etc.

\subsubsection{Region Names}

Given a function, we associate a distinct region name with each
program point that creates a region, as follows:

\begin{itemize}
\item If a block (blocks create stack regions) has label \texttt{L},
  then the region-name for the block is \texttt{`L}.
\item If a block has no label, the compiler makes up a unique
  region-name for the block.
\item In region \texttt{r <`foo> s}, the region-name for the construct
  is \texttt{`foo}.
\item In region \texttt{r s}, the region-name for the construct is
  \texttt{`r}.
\end{itemize}

The region name for the heap is \texttt{`H}.  Region names associated
with program points within a function should be distinct from each
other, distinct from any region names appearing in the function's
prototype, and should not be \texttt{`H}.  (So you cannot use
\texttt{H} as a label name.)  Because the function's return type
cannot mention a region name for a block or region-construct in the
function, it is impossible to return a pointer to deallocated storage.

In region \texttt{r <`r> s} and region \texttt{r s}, the type of \texttt{r}
is \texttt{region_t<`r>}.  In other words, the handle is decorated with
the region name for the construct.  Pointer types' region names are
explicit, although you generally use \texttt{_} and rely on inference to
put in the correct one for you.

\subsubsection{Capabilities}

In the absence of explicit effects (see below), the capability for a
program point includes exactly:
\begin{itemize}
\item \texttt{`H}
\item The region names appearing in the function's prototype 
\item The region names for the blocks and ``\texttt{region r s}''
  statements that contain the program point
\end{itemize}

For each dereference or allocation operation, we simply check that the
region name for the type of the object is in the capability.  It is
rare for the check to fail because failing code has to do one of the
following:
\begin{itemize}
\item Have a pointer that outlives the stack or growable region into
  which it points.  Here is a silly example:
\begin{verbatim}
  int *_ x; // region name filled in with an inner block's name
  if(true) {
      int y = 7;
      x = &y;
  }
  *x; 
\end{verbatim}

\item Have existential type variables of region kind.  Doing so is
  useless because the check will always fail (so don't worry if you
  don't know what an existential type variable of region kind is).
\end{itemize}

\subsubsection{Assignment}

A pointer type's region name is part of the type.  Currently, there is
no ``subregioning,'' so you cannot assign between types with different
region names.  For handlers, if \texttt{`r} is a region name, there is
at most one value of type \texttt{region_t<`r>} (there are 0 if
\texttt{`r} is a block's name), so there is little use in creating
variables of type \texttt{region_t<`r>}.

\subsubsection{Type Declarations}

A \texttt{struct}, \texttt{typedef}, \texttt{tunion}, or \texttt{xtunion}
declaration may be parameterized by any number of region names.  The
region names are placed in the list of type parameters.  They must be
followed by ``\texttt{::R}'', except for \texttt{typedef} declarations
(where the region name appears in the underlying type).  As with other
type parameters, these must be instantiated when the type constructor
is used.  For example, given
\begin{verbatim}
  struct List<`a,`r::R>{`a hd; struct List<`a,`r> *`r tl;};
\end{verbatim}
the type \texttt{struct List<int,`H>} is for a list of ints in the heap.
Notice that all of the ``cons cells'' of the \texttt{List} will be in
the same region (the type of the \texttt{tl} field uses the same
region name \texttt{`r} that is used to instantiate the recursive
instance of \texttt{struct List<`a,`r>}).  However, we could instantiate
\texttt{`a} with a pointer type that has a different region name.

Currently, you cannot use type inference to instantiate region names.
For example, if \texttt{lst} has type \texttt{struct List<int,`H>}, you
can write any of the following:
\begin{verbatim}
  struct List<int,`H> lst2 = lst;
  struct List<_,`H> lst2 = lst;
  _ lst2 = lst;
\end{verbatim}
but you cannot write either of
\begin{verbatim}
  struct List<int,_> lst2 = lst;
  struct List<_,_> lst2 = list;
\end{verbatim}

\texttt{tunion} and \texttt{xtunion} declarations must also be
instantiated with an additional region name.  If an object of type
\texttt{tunion `r Foo} turns out to be a value-carrying variant, then
the object is treated (capability-wise) as a pointer with region name
\texttt{`r}.  If the region name is omitted from a use of a
\texttt{tunion} declaration, it is implicitly \texttt{`H}.

\subsubsection{Function Calls}

If a function parameter or result has type \texttt{int *`r} or
\texttt{region_t<`r>}, the function is polymorphic over the region name
\texttt{`r}.  That is, the caller can instantiate \texttt{`r} with any
region \emph{in the caller's current capability}. This instantiation
is usually implicit, so the caller just calls the function and the
compiler uses the types of the actual arguments to infer the
instantiation of the region names (just like it infers the
instantiation of type variables).

The callee is checked knowing nothing about \texttt{`r} except that it
is in its capability.  For example, it will be impossible to assign a
parameter of type \texttt{int*`r} to a global variable.  Why?  Because
the global would have to have a type that allowed it to point into any
region.  There is no such type because we could never safely follow
such a pointer (since it could point into a deallocated region).

\subsubsection{Explicit and Default Effects}

If you are not using function pointers, you now know everything you
need to know about Cyclone regions and memory management.  If you are
using function pointers, you still should not have a problem provided
you follow this draconian measure:
\begin{quote}
  Do not write down function types except in function prototypes
  (i.e., as parameter or return types).  In particular do not write
  down function types for \texttt{struct} members, \texttt{typedef}
  definitions, or local variables.  For local variables, you can use
  type inference (i.e., write \texttt{_} instead of the function type).
\end{quote}

In practice, this restriction is often palatable.  The common use of
function pointers is as parameters, and it usually suffices for the
caller to use just a function name as the argument.

If you must write down a function type, then you have to understand
that we have been lying about the form of function types and
prototypes.  A function type actually has an explicit effect, written
at the end of the parameter list, following a semi-colon.  For
example, \texttt{int f(int,int *`r)}; is really shorthand for:

\begin{verbatim}
  int f(int,int; `e+{`r});
\end{verbatim}

An effect is part of a function's type; it has nothing to do with
run-time values.  In particular, the \texttt{+} above has nothing to do
with addition.  An effect contains region names and effect names.
Capabilities really include effect names and region names.  A program
point's capability includes its function's type's effect and the
region names for the enclosing blocks and region constructs.
Effect names are discussed more below.

The full syntax for effects is:

\begin{itemize}
\item \verb|{}|, for the empty capability 
\item \verb|{`r1,...,`rn}| for the capability of region names
  \texttt{`r1},\ldots, \texttt{`rn} 
\item \texttt{`e} for the capability of effect name \texttt{`e} 
\item \texttt{E1 + E2} for the union of the effects of \texttt{E1} and
  \texttt{E2}.  The union contains all the region names and effect names
  of \texttt{E1} and \texttt{E2}. 
\end{itemize}

\subsubsection{Default Effects}

When you do not put an explicit effect on a function type, the
compiler puts one in for you as follows: It is
\verb|`e+`e1+...+`em+{`r1,...,`rn}| where \texttt{`e} is fresh,
\texttt{`r1}, \ldots, \texttt{`rn} are the region names appearing in the
parameter and return types, and \texttt{`e1}, \ldots, \texttt{`em} are the
effect names appearing the parameter and return types.  The
\texttt{`e1}, \ldots, \texttt{`em} include effect names added for you.
For example,
\begin{verbatim}
  int f(void g(), 
        int *`r x, 
        void h(region_t<`r> rgn));
\end{verbatim}
is shorthand for:
\begin{verbatim}
  int f(void g(;`e1), 
        int *`r x, 
        void h(region_t<`r> rgn; `e2+{`r})
        ; `e3+`e1+`e2+{`r});
\end{verbatim}

In fact, we are still leaving the binding of the region names and
effect names implicit.  By default, they are bound at the outermost
level of the function type:
\begin{verbatim}
  int f<`r::R,`e1::E,`e2::E,`e3::E>
       (void g(;`e1), 
        int *`r x, 
        void h(region_t<`r> rgn; `e2+{`r})
        ; `e3+`e1+`e2+{`r});
\end{verbatim}

The compiler can only infer default effects for top-level function
types (i.e., function prototypes) and function types inside other
function types.  This is why you cannot write down a function-pointer
type, a function-type \texttt{struct} member, a function-type
\texttt{typedef} definition, etc., without an explicit effect.

\subsubsection{Meaning of Effect Names}

As described above, when functions and type declarations are
parameterized by region names, uses instantiate the region names with
region names.  (For example, in \texttt{struct List<int,`H>}, \texttt{`H}
instantiates \texttt{`r}.)  An effect name is similarly instantiated,
but with a capability.  The same restrictions on type inference apply.

We can now understand how to declare and use structs with
function-pointer members.  The example above puts explicit effects on
the functions, binds the effect names in the struct declaration, and
instantiates the effect names (to the empty capability) when using the
struct declaration.

Why do functions need effect names in their capabilities?  The short
answer is that having different effect names for each function type
ensures the implicit instantiation of region names and effects will
succeed for all function calls where it should succeed.

% Local Variables:
% TeX-master: "main-screen"
% End:
