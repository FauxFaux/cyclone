<html>
<head>
<title>The Grammar of Cyclone</title>
</head>
<body>
<h1>The Grammar of Cyclone</h1>

Cyclone's grammar is derived from the next proposed OSI C standard,
C9X.  Changes from and additions to the C9X grammar are noted in red.
The start symbol is <i>translation-unit</i>.
<p>

<b>Quick links:</b>
<a href=#declaration><i>declaration</i></a>,
<a href=#struct-or-union-specifier><i>struct-or-union-specifier</i></a>,
<a href=#enum-specifier><i>enum-specifier</i></a>,
<a href=#declarator><i>declarator</i></a>,
<a href=#statement><i>statement</i></a>,
<a href=#pattern><i>pattern</i></a>,
<a href=#expression><i>expression</i></a>

<p>
<font color=blue>
<ul>
<i>translation-unit</i>:<br>
<ul>
  <i>external-declaration</i> <i>translation-unit<sub>opt</sub></i><br>
<font color=red>
  <code>using</code> <i>identifier</i> <code>;</code> <i>translation-unit</i><br>
  <code>namespace</code> <i>identifier</i> <code>;</code> <i>translation-unit</i><br>
  <code>using</code> <i>identifier</i> <code>{</code> <i>translation-unit</i> <code>}</code><br>
  <code>namespace</code> <i>identifier</i> <code>{</code> <i>translation-unit</i> <code>}</code><br>
</font>
</ul>
<br>
<i>external-declaration</i>:<br>
<ul>
  <i>function-definition</i><br>
  <i>declaration</i><br>
</ul>
<br>
<i>function-definition</i>:<br>
<ul>
  <i>declaration-specifiers<sub>opt</sub></i> <i>declarator</i> <i>declaration-list<sub>opt</sub></i> <i>compound-statement</i><br>
</ul>
<br>
<a name=declaration></a>
<i>declaration</i>:<br>
<ul>
  <i>declaration-specifiers</i> <i>init-declarator-list<sub>opt</sub></i> <code>;</code><br>
<font color=red>
  <code>let</code> <i>pattern</i> <code>=</code> <i>expression</i> <code>;</code><br>
</font>
</ul>
<br>
<i>declaration-list</i>:<br>
<ul>
  <i>declaration</i><br>
  <i>declaration-list</i> <i>declaration</i><br>
</ul>
<br>
<i>declaration-specifiers</i>:<br>
<ul>
  <i>storage-class-specifier</i> <i>declaration-specifiers<sub>opt</sub></i><br>
  <i>type-specifier</i> <i>declaration-specifiers<sub>opt</sub></i><br>
  <i>type-qualifier</i> <i>declaration-specifiers<sub>opt</sub></i><br>
  <i>function-specifier</i> <i>declaration-specifiers<sub>opt</sub></i><br>
</ul>
<br>
<i>storage-class-specifier</i>: <font color=black>one of</font><br>
<ul>
  <code>auto</code>
  <code>register</code>
  <code>static</code>
  <code>extern</code>
  <code>typedef</code>
<font color=red>
  <code>abstract</code>
</font>
<br>
</ul>
<br>
<font color=green>
(The C9X type-specifiers
<code>_Bool</code>,
<code>_Complex</code>, and
<code>_Imaginary</code>
are not yet supported)
</font><br>
<i>type-specifier</i>: <font color=black>one of</font><br>
<ul>
  <code>void</code>
  <code>char</code>
  <code>short</code>
  <code>int</code>
  <code>long</code>
  <code>float</code>
  <code>double</code>
  <code>signed</code><br>
  <code>unsigned</code>
  <i>struct-or-union-specifier</i>
  <i>enum-specifier</i><br>
  <i>typedef-name</i> <font color=red><i>type-params<sub>opt</sub></i></font><br>
  <font color=red>
  <i>type-var</i>
  <code>bool</code>
  <code>Bool</code>
  <code>Char</code>
  <code>Short</code>
  <code>Int</code>
  <code>Long</code>
  <code>Float</code>
  <code>Double</code><br>
  <code>$</code> <code>(</code> <i>parameter-list</i> <code>)</code><br>
</font>
</ul>
<br>
<i>type-qualifier</i>: <font color=black>one of</font><br>
<ul>
  <code>const</code>
  <code>restrict</code>
  <code>volatile</code><br>
</ul>
<br>
<i>function-specifier</i>:
<ul>
  <code>inline</code><br>
</ul>
<br>
<a name=struct-or-union-specifier></a>
<i>struct-or-union-specifier</i>:<br>
<ul>
  <i>struct-or-union</i> <code>{</code> <i>struct-declaration-list</i> <code>}</code><br>
  <i>struct-or-union</i> <i>identifier</i> <font color=red><i>type-params<sub>opt</sub></i></font> <code>{</code> <i>struct-declaration-list</i> <code>}</code><br>
  <i>struct-or-union</i> <i>identifier</i> <font color=red><i>type-params<sub>opt</sub></i></font><br>
</ul>
<br>
<font color=red>
<i>type-params</i>:<br>
<ul>
  <code><</code> <i>type-name-list</i> <code>></code><br>
</ul>
</font>
<br>
<i>struct-or-union</i>: <font color=black>one of</font><br>
<ul>
  <code>struct</code>
  <code>union</code><br>
</ul>
<br>
<i>struct-declaration-list</i>:<br>
<ul>
  <i>struct-declaration</i><br>
  <i>struct-declaration-list</i> <i>struct-declaration</i><br>
</ul>
<br>
<i>init-declarator-list</i>:<br>
<ul>
  <i>init-declarator</i><br>
  <i>init-declarator-list</i> <code>,</code> <i>init-declarator</i><br>
</ul>
<br>
<i>init-declarator</i>:<br>
<ul>
  <i>declarator</i><br>
  <i>declarator</i> <code>=</code> <i>initializer</i><br>
</ul>
<br>
<i>struct-declaration</i>:<br>
<ul>
  <i>specifier-qualifier-list</i> <i>struct-declarator-list</i> <code>;</code><br>
</ul>
<br>
<i>specifier-qualifier-list</i>:<br>
<ul>
  <i>type-specifier</i> <i>specifier-qualifier-list<sub>opt</sub></i><br>
  <i>type-qualifier</i> <i>specifier-qualifier-list<sub>opt</sub></i><br>
</ul>
<br>
<i>struct-declarator-list</i>:<br>
<ul>
  <i>struct-declarator</i><br>
  <i>struct-declarator-list</i> <code>,</code> <i>struct-declarator</i><br>
</ul>
<br>
<i>struct-declarator</i>:<br>
<ul>
  <i>declarator</i><br>
  <i>declarator<sub>opt</sub></i> <code>:</code> <i>constant-expression</i><br>
</ul>
<br>
<a name=enum-specifier></a>
<i>enum-specifier</i>:<br>
<ul>
  <code>enum</code> <code>{</code> <i>enumerator-list</i> <code>}</code><br>
  <code>enum</code> <i>identifier</i> <font color=red><i>type-params<sub>opt</sub></i></font> <code>{</code> <i>enumerator-list</i> <code>}</code><br>
  <code>enum</code> <i>identifier</i> <font color=red><i>type-params<sub>opt</sub></i></font><br>
<font color=red>
  <code>xenum</code> <i>identifier</i> <code>{</code> <i>enumerator-list</i> <code>}</code><br>
  <code>xenum</code> <i>identifier</i><br>
</font>
</ul>
<br>
<i>enumerator-list</i>:<br>
<ul>
<font color=red>
  <i>enumerator</i><br>
  <i>enumerator</i> <code>,</code> <i>enumerator-list</i><br>
  <i>enumerator</i> <code>;</code><br>
  <i>enumerator</i> <code>;</code> <i>enumerator-list</i><br>
</font>
</ul>
<br>
<i>enumerator</i>:<br>
<ul>
  <i>identifier</i><br>
  <i>identifier</i> <code>=</code> <i>constant-expression</i><br>
<font color=red>
  <i>identifier</i> <code>(</code> <i>parameter-list</i> <code>)</code><br>
</font>
</ul>
<br>
<a name=declarator></a>
<i>declarator</i>:<br>
<ul>
  <i>pointer<sub>opt</sub></i> <i>direct-declarator</i><br>
</ul>
<br>
<font color=green>(We do not support C9X <code>[*]</code> direct-declarators.)</font><br>
<i>direct-declarator</i>:<br>
<ul>
  <i>identifier</i><br>
  <code>(</code> <i>declarator</i> <code>)</code><br>
  <i>direct-declarator</i> <code>[</code> <i>constant-expression<sub>opt</sub></i> <code>]</code><br>
  <i>direct-declarator</i> <code>(</code> <i>parameter-type-list</i> <code>)</code><br>
  <i>direct-declarator</i> <code>(</code> <i>identifier-list<sub>opt</sub></i> <code>)</code><br>
<font color=red>
  <i>direct-declarator</i> <code>[</code> <code>?</code> <code>]</code><br>
  <i>direct-declarator</i> <code><</code> <i>type-name-list</i> <code>></code><br>
</font>
</ul>
<br>
<i>pointer</i>:<br>
<ul>
  <code>*</code> <i>type-qualifier-list<sub>opt</sub></i> <i>pointer<sub>opt</sub></i><br>
<font color=red>
  <code>@</code> <i>type-qualifier-list<sub>opt</sub></i> <i>pointer<sub>opt</sub></i><br>
</font>
</ul>
<br>
<i>type-qualifier-list</i>:<br>
<ul>
  <i>type-qualifier</i><br>
  <i>type-qualifier-list</i> <i>type-qualifier</i><br>
</ul>
<br>
<i>parameter-type-list</i>:<br>
<ul>
  <i>parameter-list</i><br>
  <i>parameter-list</i> <code>,</code> <code>...</code><br>
</ul>
<br>
<i>parameter-list</i>:<br>
<ul>
  <i>parameter-declaration</i><br>
  <i>parameter-list</i> <code>,</code> <i>parameter-declaration</i><br>
</ul>
<br>
<i>parameter-declaration</i>:<br>
<ul>
  <font color=red><i>specifier-qualifier-list</i></font> <i>declarator</i><br>
  <font color=red><i>specifier-qualifier-list</i></font> <i>abstract-declarator<sub>opt</sub></i><br>
</ul>
<br>
<i>identifier-list</i>:<br>
<ul>
  <i>identifier</i><br>
  <i>identifier-list</i> <code>,</code> <i>identifier</i><br>
</ul>
<br>
<i>initializer</i>:<br>
<ul>
  <i>assignment-expression</i><br>
  <code>{</code> <i>initializer-list<font color=red><sub>opt</sub></font></i> <code>}</code><br>
  <code>{</code> <i>initializer-list</i> <code>,</code> <code>}</code><br>
</ul>
<br>
<i>initializer-list</i>:<br>
<ul>
  <i>designation<sub>opt</sub></i> <i>initializer</i><br>
  <i>initializer-list</i> <code>,</code> <i>designation<sub>opt</sub></i> <i>initializer</i><br>
</ul>
<br>
<i>designation</i>:<br>
<ul>
  <i>designator-list</i> <code>=</code><br>
</ul>
<br>
<i>designator-list</i>:
<ul>
  <i>designator</i><br>
  <i>designator-list</i> <i>designator</i><br>
</ul>
<br>
<i>designator</i>:
<ul>
  <code>[</code> <i>constant-expression</i> <code>]</code><br>
  <code>.</code> <i>identifier</i><br>
</ul>
<br>
<i>type-name</i>:<br>
<ul>
  <i>specifier-qualifier-list</i> <i>abstract-declarator<sub>opt</sub></i><br>
</ul>
<br>
<i>type-name-list</i>:<br>
<ul>
  <i>type-name</i><br>
  <i>type-name-list</i> <code>,</code> <i>type-name</i><br>
</ul>
<br>
<i>abstract-declarator</i>:<br>
<ul>
  <i>pointer</i><br>
  <i>pointer<sub>opt</sub></i> <i>direct-abstract-declarator</i><br>
</ul>
<br>
<font color=green>(We do not support C9X <code>[*]</code> direct-abstract-declarators.)</font><br>
<i>direct-abstract-declarator</i>:<br>
<ul>
  <code>(</code> <i>abstract-declarator</i> <code>)</code><br>
  <i>direct-abstract-declarator<sub>opt</sub></i> <code>[</code> <i>constant-expression<sub>opt</sub></i> <code>]</code><br>
  <i>direct-abstract-declarator<sub>opt</sub></i> <code>(</code> <i>parameter-type-list<sub>opt</sub></i> <code>)</code><br>
<font color=red>
  <i>direct-abstract-declarator<sub>opt</sub></i> <code>[</code> <code>?</code> <code>]</code><br>
  <i>direct-abstract-declarator</i> <code><</code> <i>type-name-list</i> <code>></code><br>
</font>
</ul>
<br>
<a name=statement></a>
<i>statement</i>:<br>
<ul>
  <i>labeled-statement</i><br>
  <i>expression-statement</i><br>
  <i>compound-statement</i><br>
  <i>selection-statement</i><br>
  <i>iteration-statement</i><br>
  <i>jump-statement</i><br>
<font color=red>
  <code>cut</code> <i>statement</i><br>
  <code>splice</code> <i>statement</i><br>
</font>
</ul>
<br>
<font color=green>
(We treat the 
<code>case</code> and <code>default</code> labels specially;
see <code>switch-clauses</code>)
</font><br>
<i>labeled-statement</i>:<br>
<ul>
  <i>identifier</i> <code>:</code> <i>statement</i><br>
</ul>
<br>
<i>expression-statement</i>:<br>
<ul>
  <i>expression<sub>opt</sub></i> <code>;</code><br>
</ul>
<br>
<i>compound-statement</i>:<br>
<ul>
  <code>{</code> <i>block-item-list<sub>opt</sub></i> <code>}</code><br>
</ul>
<br>
<i>block-item-list</i>:<br>
<ul>
  <i>block-item</i><br>
  <i>block-item</i> <i>block-item-list</i><br>
</ul>
<br>
<i>block-item</i>:<br>
<ul>
  <i>declaration</i><br>
  <i>statement</i><br>
</ul>
<br>
<i>selection-statement</i>:<br>
<ul>
  <code>if</code> <code>(</code> <i>expression</i> <code>)</code> <i>statement</i><br>
  <code>if</code> <code>(</code> <i>expression</i> <code>)</code> <i>statement</i> <code>else</code> <i>statement</i><br>
  <code>switch</code> <code>(</code> <i>expression</i> <code>)</code> <font color=red><code>{</code> <i>switch-clauses</i> <code>}</code></font><br>
<font color=red>
  <code>try</code> <i>statement</i> <code>catch</code> <code>{</code> <i>switch-clauses</i> <code>}</code><br>
</ul>
<br>
<i>switch-clauses</i>:<br>
<ul>
  <font color=green>(empty)</font><br>
  <code>default</code> <code>:</code> <i>block-item-list</i><br>
  <code>case</code> <i>pattern</i> <code>:</code> <i>block-item-list<sub>opt</sub></i> <i>switch-clauses</i><br>
  <code>case</code> <i>pattern</i> <code>where</code> <i>expression</i> <code>:</code> <i>block-item-list<sub>opt</sub></i> <i>switch-clauses</i><br>
</font>
</ul>
<br>
<i>iteration-statement</i>:<br>
<ul>
  <code>while</code> <code>(</code> <i>expression</i> <code>)</code> <i>statement</i><br>
  <code>do</code> <i>statement</i> <code>while</code> <code>(</code> <i>expression</i> <code>)</code> <code>;</code><br>
  <code>for</code> <code>(</code> <i>expression<sub>opt</sub></i> <code>;</code> <i>expression<sub>opt</sub></i> <code>;</code> <i>expression<sub>opt</sub></i> <code>)</code> <i>statement</i><br>
  <code>for</code> <code>(</code> <i>declaration</i> <i>expression<sub>opt</sub></i> <code>;</code> <i>expression<sub>opt</sub></i> <code>)</code> <i>statement</i><br>
</ul>
<br>
<i>jump-statement</i>:<br>
<ul>
  <code>goto</code> <i>identifier</i> <code>;</code><br>
  <code>continue</code> <code>;</code><br>
  <code>break</code> <code>;</code><br>
  <code>return</code> <code>;</code><br>
  <code>return</code> <i>expression</i> <code>;</code><br>
<font color=red>
  <code>fallthru</code> <code>;</code><br>
</font>
</ul>
<br>
<font color=red>
<a name=pattern></a>
<i>pattern</i>:<br>
<ul>
  <code><i>_</i></code><br>
  <code>(</code> <i>pattern</i> <code>)</code><br>
  <i>integer-constant</i><br>
  <code><i>-</i></code> <i>integer-constant</i><br>
  <i>floating-constant</i><br>
  <i>character-constant</i><br>
  <code>null</code><br>
  <code>true</code><br>
  <code>false</code><br>
  <i>identifier</i><br>
  <i>identifier</i> <i>type-params<sub>opt</sub></i> <code>(</code> <i>tuple-pattern-list</i> <code>)</code><br>
  <code>$</code> <code>(</code> <i>tuple-pattern-list</i> <code>)</code><br>

  <i>identifier</i> <i>type-params<sub>opt</sub></i> <code>{</code> <code>}</code><br>
  <i>identifier</i> <i>type-params<sub>opt</sub></i> <code>{</code> <i>field-pattern-list</i> <code>}</code><br>
  <code>&</code> <i>pattern</i><br>
</ul>
<br>
<i>tuple-pattern-list</i>:<br>
<ul>
  <font color=green>(empty)</font><br>
  <i>pattern</i><br>
  <i>tuple-pattern-list</i> <code>,</code> <i>pattern</i><br>
</ul>
<br>
<i>field-pattern-list</i>:<br>
<ul>
  <i>field-pattern</i><br>
  <i>field-pattern-list</i> <code>,</code> <i>field-pattern</i><br>
</ul>
<br>
<i>field-pattern</i>:<br>
<ul>
  <i>pattern</i><br>
  <i>designation</i> <i>pattern</i><br>
</ul>
</font>
<br>
<a name=expression></a>
<i>expression</i>:<br>
<ul>
  <i>assignment-expression</i><br>
  <i>expression</i> <code>,</code> <i>assignment-expression</i><br>
</ul>
<br>
<i>assignment-expression</i>:<br>
<ul>
  <i>conditional-expression</i><br>
  <i>unary-expression</i> <i>assignment-operator</i> <i>assignment-expression</i><br>
</ul>
<br>
<i>assignment-operator</i>: <font color=black>one of</font><br>
<ul>
  <code>=</code>
  <code>*=</code>
  <code>/=</code>
  <code>%=</code>
  <code>+=</code>
  <code>-=</code>
  <code><<=</code>
  <code>>>=</code>
  <code>&=</code>
  <code>^=</code>
  <code>|=</code><br>
</ul>
<br>
<i>conditional-expression</i>:<br>
<ul>
  <i>logical-or-expression</i><br>
  <i>logical-or-expression</i> <code>?</code> <i>expression</i> <code>:</code> <i>conditional-expression</i><br>
</ul>
<br>
<i>constant-expression</i>:<br>
<ul>
  <i>conditional-expression</i><br>
</ul>
<br>
<i>logical-or-expression</i>:<br>
<ul>
  <i>logical-and-expression</i><br>
  <i>logical-or-expression</i> <code>||</code> <i>logical-and-expression</i><br>
</ul>
<br>
<i>logical-and-expression</i>:<br>
<ul>
  <i>inclusive-or-expression</i><br>
  <i>logical-and-expression</i> <code>&&</code> <i>inclusive-or-expression</i><br>
</ul>
<br>
<i>inclusive-or-expression</i>:<br>
<ul>
  <i>exclusive-or-expression</i><br>
  <i>inclusive-or-expression</i> <code>|</code> <i>exclusive-or-expression</i><br>
</ul>
<br>
<i>exclusive-or-expression</i>:<br>
<ul>
  <i>and-expression</i><br>
  <i>exclusive-or-expression</i> <code>^</code> <i>and-expression</i><br>
</ul>
<br>
<i>and-expression</i>:<br>
<ul>
  <i>equality-expression</i><br>
  <i>and-expression</i> <code>&</code> <i>equality-expression</i><br>
</ul>
<br>
<i>equality-expression</i>:<br>
<ul>
  <i>relational-expression</i><br>
  <i>equality-expression</i> <code>==</code> <i>relational-expression</i><br>
  <i>equality-expression</i> <code>!=</code> <i>relational-expression</i><br>
</ul>
<br>
<i>relational-expression</i>:<br>
<ul>
  <i>shift-expression</i><br>
  <i>relational-expression</i> <code><</code> <i>shift-expression</i><br>
  <i>relational-expression</i> <code>></code> <i>shift-expression</i><br>
  <i>relational-expression</i> <code><=</code> <i>shift-expression</i><br>
  <i>relational-expression</i> <code>>=</code> <i>shift-expression</i><br>
</ul>
<br>
<i>shift-expression</i>:<br>
<ul>
  <i>additive-expression</i><br>
  <i>shift-expression</i> <code><<</code> <i>additive-expression</i><br>
  <i>shift-expression</i> <code>>></code> <i>additive-expression</i><br>
</ul>
<br>
<i>additive-expression</i>:<br>
<ul>
  <i>multiplicative-expression</i><br>
  <i>additive-expression</i> <code>+</code> <i>multiplicative-expression</i><br>
  <i>additive-expression</i> <code><i>-</i></code> <i>multiplicative-expression</i><br>
</ul>
<br>
<i>multiplicative-expression</i>:<br>
<ul>
  <i>cast-expression</i><br>
  <i>multiplicative-expression</i> <code>*</code> <i>cast-expression</i><br>
  <i>multiplicative-expression</i> <code>/</code> <i>cast-expression</i><br>
  <i>multiplicative-expression</i> <code>%</code> <i>cast-expression</i><br>
</ul>
<br>
<i>cast-expression</i>:<br>
<ul>
  <i>unary-expression</i><br>
  <code>(</code> <i>type-name</i> <code>)</code> <i>cast-expression</i><br>
</ul>
<br>
<i>unary-expression</i>:<br>
<ul>
  <i>postfix-expression</i><br>
  <code>++</code> <i>unary-expression</i><br>
  <code>--</code> <i>unary-expression</i><br>
  <i>unary-operator</i> <i>cast-expression</i><br>
  <code>sizeof</code> <i>unary-expression</i><br>
  <code>sizeof</code> <code>(</code> <i>type-name</i> <code>)</code><br>
<font color=red>
  <code>raise</code> <i>unary-expression</i><br>
</ul>
</font>
<br>
<i>unary-operator</i>: <font color=black>one of</font><br>
<ul>
  <code>&</code>
  <code>*</code>
  <code>+</code>
  <code>-</code>
  <code>~</code>
  <code>!</code><br>
</ul>
<br>
<i>postfix-expression</i>:<br>
<ul>
  <i>primary-expression</i><br>
  <i>postfix-expression</i> <code>[</code> <i>expression</i> <code>]</code><br>
  <i>postfix-expression</i> <code>(</code> <code>)</code><br>
  <i>postfix-expression</i> <code>(</code> <i>argument-expression-list</i> <code>)</code><br>
  <i>postfix-expression</i> <code>.</code> <i>identifier</i><br>
  <i>postfix-expression</i> <code>-></code> <i>identifier</i><br>
  <i>postfix-expression</i> <code>++</code><br>
  <i>postfix-expression</i> <code>--</code><br>
 <code>(<code> <i>type-name</i> <code>)<code> <code>{<code> <i>initializer-list</i> <code>}<code><br>
 <code>(<code> <i>type-name</i> <code>)<code> <code>{<code> <i>initializer-list</i> <code>,<code> <code>}<code><br>
<font color=red>
  <code>new</code> <code>{</code> <i>initializer-list<sub>opt</sub></i> <code>}</code><br>
  <code>new</code> <code>{</code> <i>initializer-list</i> <code>,</code> <code>}</code><br>
  <code>new</code> <code>{</code> <code>for</code> <i>identifier</i> <code><</code> <i>expression</i> <code>:</code> <i>expression</i> <code>}</code><br>
  <code>fill</code> <code>(</code> <i>expression</i> <code>)</code><br>
  <code>codegen</code> <code>(</code> <i>function-definition</i> <code>)</code><br>
</font>
</ul>
<br>
<i>primary-expression</i>:<br>
<ul>
  <i>identifier</i><br>
  <i>constant</i><br>
  <i>string</i><br>
  <code>(</code> <i>expression</i> <code>)</code><br>
<font color=red>
  <i>identifier</i> <code><></code><br>
  <code>$</code> <code>(</code> <i>argument-expression-list</i> <code>)</code><br>
  <i>identifier</i> <code>{</code> <i>initializer-list</i> <code>}</code><br>
  <code>(</code> <code>{</code> <i>block-item-list</i> <code>}</code> <code>)</code><br>
</font>
</ul>
<br>
<i>argument-expression-list</i>:<br>
<ul>
  <i>assignment-expression</i><br>
  <i>argument-expression-list</i> <code>,</code> <i>assignment-expression</i><br>
</ul>
<br>
<i>constant</i>:<br>
<ul>
  <i>integer-constant</i><br>
  <i>character-constant</i><br>
  <i>floating-constant</i><br>
  <i>enumeration-constant</i><br>
<font color=red>
  <code>true</code><br>
  <code>false</code><br>
  <code>null</code><br>
</font>
</ul>
</ul>
</font>

</body>
</html>
