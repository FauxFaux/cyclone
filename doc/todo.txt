Todo list:

BUG FIXES and UNSOUNDNESSES:
----------------------------
* FIX all of the FIX things.

* Prevent using label H (induces region name `H).  Centralize the
  check that tyvars aren't `H.

* void f() {
   void g();
   g();
  }
We complain that g isn't initialized.  We should complain that
function declarations are only allowed at top-level.

* This won't re-parse and type-check after inference:

  void f() {
    int *_ p;
   L: { 
      int x = 7;
      p = &x;
    }
  }

* Better error message when programmer leaves off effect but
  can't. For example,
  void h() {}
  void (*i)() = h;

* are we treating void properly?

* link-checking:  we need to spit out an internal interface for each
  module and check for consistency at link-time.  Note that we should
  also check that main has the right type.  We should have the compiler
  hash and sign the code and interface so that we can detect tampering
  with the code or interface at link-time.

* Are we treating static variables (within a function) correctly?

* we're too restrictive about typedef names -- C allows typedef names
  to be shadowed by identifiers (or other typedefs).  Our lexer
  doesn't have quite the right infrastructure for this.

* there are unsoundnesses w.r.t. the way we type-check the left-hand-sides
  of certain operations (e.g., x++.)  Part of the problem is that we allow
  implicit coercion from an enum to an integral type.  

* we need to do a bounds check on enum assignments.  Also, the pattern
  matcher assumes that there are no duplicate tags for enums.

* subtyping is broken w.r.t. pointer bounds -- you can cast int@{1} to
  int@{3}.  The whole sub-typing machinery needs to be re-examined to
  make sure that it is sound.  In particular, alignment issues are
  a concern.

* alpha-conversion issues with respect to type variables.  We should
  keep around a list of all of the type variables used in a function
  and ensure that they aren't duplicated (or else provide an internal
  map from user-specified type variables to gensym'd representations.)

* namespace issues:  we treat `namespace Foo {extern "C" int x;}' as if
  x is translated as Cyc_Foo_x but it's translated as "x".  We should
  really define both "x" and "Cyc_Foo_x" in the environment.  In addition,
  users can spoof a Cyclone variable by writing {extern "C" int Cyc_x;}.

* new "foo" and rnew(h) "foo" don't work properly -- they should allocate
  a copy of the string in the region, no?

MISSING THINGS NEEDED TO PORT REAL CODE:
----------------------------------------
* Need to port more C libraries

* We don't allow enough pointer arithmetic.  For instance, we don't
  allow the following:

    int x[35] = {....}

      x+1

* default array initializers, at top level and local, e.g., int x[4];

* nested type declarations? nested exception declarations? nested using?

* structs and enums without a name

* long long, short, float, and double constants (including 12s, 3l, etc.)

* better support for varargs and string descriptors.  Too many systems
  codes have functions that write to log files or something like that
  and have their own wrapper functions for fprintf/fscanf.  So I think
  we have to bite the bullet and provide some support for this.

* command line arguments like GCC's with the proper defaults 
  (e.g., -tc -toc -up should be default.)  Also, should support
  passing flags through to GCC and the pre-processor.

* wide characters and strings

* attributes on enums? (e.g., packed)

THINGS NEEDED TO SIMPLIFY PORTING:
----------------------------------
* get rid of null, replace with 0 (requires clever overloading)

* we should start on the porting tool -- use region inference to
  figure out the "right" interface for code.

* new { for i < x : ' ' }
  causes core dump for negative x.  (Not surprising -- x is treated as
  unsigned so that's a really big number and likely, malloc is returning
  null which we're not checking for when we allocate...)

* better formatting support in printf & friends (i.e., deal with full
  %-specifiers)  

* varargs (...) (integrate with printf, fprintf, xprintf?)

* multi-level initializers, e.g., {{0,1},{2,3}}

* better constant expressions (no doubles? no longs?)

* compound literals, more designators for arrays literals, better 
  designators for structs

* better evaluation in evexp.pop

THINGS NEEDED TO MAKE REGIONS MORE REAL:
----------------------------------------
* Need to add letregion, syntax for region handles, and a way to
  allocate into a region (as opposed to the heap.)

THINGS THAT WOULD BE NICE OR THAT HAVE SEX APPEAL:
--------------------------------------------------
* better type error messages:  keep track of the location where a type
  comes from and merge this information during unification.  Also,
  pretty-print types better (e.g., hide the effects when possible,
  strip off qualifiers in a Using context, try to preserve typedefs,
  etc.)  

* dependent types for arrays (and lots more?)

* nested functions (closures -- with RTCG approach to get calling convention
  right.)

* better comprehensions/iterators

* We should add anonymous structs (and enums)?

* We should allow more deep casts (e.g., function pointers) and have
  generally better support for casting between compatible representations.
  e.g., char[4] to int[1] (note not sound on architectures that require
  word alignment.)

* We should allow partial instantiations of polymorphic routines.

* ought to be able to treat the arguments to a tunion constructor as a tuple
  in a pattern...

* qualifiers for arguments to [x]tunion constructors?  on tuples?

* cut, fill, codegen, splice

* Support qualified identifier declarations (instead of just uses).

* as patterns.  views and abstract patterns.  

* builtin list syntax: list(e1,e2,...,en)? -- also for patterns

* string append operator (++)?

* we should leverage the effect stuff to do exception analysis.

* we should add template-like mechanisms for generating code at
  compile (or run?) time.  That would allow us to abstract over
  Mem types.

THINGS THAT WOULD MAKE THE COMPILER FASTER OR THE CODE BETTER:
--------------------------------------------------------------
* Try to avoid using so many lists in the abstract syntax --
  we should use arrays (e.g., for CompoundLit_e, Array_e,
  Struct_e, Tunion_e, Xtunion_e, and UnresolvedMem_e, Switch_s, etc.)

* We need to re-do the pattern match compilation -- we should take
  advantage of the decision tree built during type-checking.

MISCELLANEOUS
-------------
* allows a cast between a "struct cons<exp>*" and "exp@?" !!!
  at least it gives a warning...  Actually, this may be right.

* We should get the documentation in shape.

* Maybe we should port bison to cyclone.

* need to start putting user's guide together.

* new { for i < x : ' ' }
  causes core dump for negative x.  (Not surprising -- x is treated as
  unsigned so that's a really big number and likely, malloc is returning
  null which we're not checking for when we allocate...)

* better implementation of unresolved mem

* deal with inline?

* translation to C is busted with -noexpandtypedefs because we hoist
tuples to the top (before typedef declarations)




