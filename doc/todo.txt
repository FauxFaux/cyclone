Todo list:

BUG FIXES and UNSOUNDNESSES:
----------------------------
* FIX all of the FIX things.

* We rely on C to catch incomplete types, such as 
  struct X {
    struct X x;
  };

* Prevent using label H (induces region name `H).  Centralize the
  check that tyvars aren't `H.

* void f() {
   void g();
   g();
  }
We complain that g isn't initialized.  We should complain that
function declarations are only allowed at top-level.

* We need to ensure that locally-scoped type variables, introduced
either by (a) a block, (b) a region block, (c) an existentially-quantified
variable in a switch case, do not escape their scope.  For instance:

  bool init = false;
  _ x = null;
  while (true) {
    region r {
      if (!init) {
        x = rnew(r) $(3,4); init = true;
      } else {
        (*x)[0];
      }
    }
  }

Here, x is assigned the type "$(int,int) *`r" even though `r is not
in scope where x is defined.  Note that when you execute this code,
you'll allocate (3,4) in the region the first time, then free the
region, and then try to dereference x the second time through the
loop.  

The fix is to assign a scope level to each VarType and each Evar
and to prevent an Evar from becoming constrained with a type that
includes a VarType (or Evar?) from a deeper scope.  Note that
this would fix the following two bugs.

* This won't re-parse and type-check after inference:

  void f() {
    int *_ p;
   L: { 
      int x = 7;
      p = &x;
    }
  }

* alpha-conversion issues with respect to type variables.  We should
  keep around a list of all of the type variables used in a function
  and ensure that they aren't duplicated (or else provide an internal
  map from user-specified type variables to gensym'd representations.)

* Better error message when programmer leaves off effect but
  can't. For example,
  void h() {}
  void (*i)() = h;

* Translation of lvalues is still broken because we put in casts
(and leave wrong casts) in places we shouldn't.

* are we treating void properly?

* Implementation of exceptions assumes sizeof(void *) == sizeof(int)
  Also we don't follow C's rules about variables live across longjmp
  being declared volatile and setjmp only appearing in guards.

* Let programmer catch Null_Exception and Match_Exception.  They are
  not in the initial environment, so they look like variables in patterns.

* link-checking:  we need to spit out an internal interface for each
  module and check for consistency at link-time.  Note that we should
  also check that main has the right type.  We should have the compiler
  hash and sign the code and interface so that we can detect tampering
  with the code or interface at link-time.

* Are we treating static variables (within a function) correctly?  NO:
  We need to give them heap region and type-check/translate the
  initializers as though they're at top-level.  Basically, these
  should be globals in every sense except scope.

* we're too restrictive about typedef names -- C allows typedef names
  to be shadowed by identifiers (or other typedefs).  Our lexer
  doesn't have quite the right infrastructure for this.

* there are unsoundnesses w.r.t. the way we type-check the left-hand-sides
  of certain operations (e.g., x++.)  Part of the problem is that we allow
  implicit coercion from an enum to an integral type.  

* we need to do a bounds check on enum assignments.  Also, the pattern
  matcher assumes that there are no duplicate tags for enums.

* subtyping is broken w.r.t. pointer bounds -- you can cast int@{1} to
  int@{3}.  The whole sub-typing machinery needs to be re-examined to
  make sure that it is sound.  In particular, alignment issues are
  a concern.

* namespace issues:  we treat `namespace Foo {extern "C" int x;}' as if
  x is translated as Cyc_Foo_x but it's translated as "x".  We should
  really define both "x" and "Cyc_Foo_x" in the environment.  In addition,
  users can spoof a Cyclone variable by writing {extern "C" int Cyc_x;}.

* new "foo" and rnew(h) "foo" don't work properly -- they should allocate
  a copy of the string in the region, no?

* src/Makefile produces $(OUTPUT_PREFIX)parse_tab.h, but parse.h is
  hardcoded to #include "parse_tab.h", so everything breaks when you
  use a prefix.

MISSING THINGS NEEDED TO PORT REAL CODE:
----------------------------------------
* Need to port more C libraries

* We don't allow enough pointer arithmetic.  For instance, we don't
  allow the following:

    int x[35] = {....}

      x+1

* default array initializers within a function: e.g., int x[4];

* nested type declarations? nested exception declarations? nested using?

* long long, short, float, and double constants (including 12s, 3l, etc.)

* write printf, scanf, etc. using our new vararg facility.

* add some way to forward varargs -- easiest would be to cast a vararg
  function to one with an explicit array.

* command line arguments like GCC's with the proper defaults 
  (e.g., -tc -toc -up should be default.)  Also, should support
  passing flags through to GCC and the pre-processor.

* wide characters and strings

* attributes on enums? (e.g., packed)

* we don't allow casts in "constant" expressions so as to avoid
  the issue that our casts may include computation.  We should
  have a way to check to see if a cast doesn't do any computation.

* stdio.h currently defines EOF as type char, not int, so the real
  char at that position is shadowed.  Is there any problem with making
  this change?

* Lots of headers currently define NULL in lots of incompatible ways.

* runtime_cyc.c still defines check_fd and f_seek, which we never use
  (and are mentioned in the docs exactly once).

THINGS NEEDED TO SIMPLIFY PORTING:
----------------------------------
* get rid of null, replace with 0 (requires clever overloading)

* we should start on the porting tool -- use region inference to
  figure out the "right" interface for code.

* new { for i < x : ' ' }
  causes core dump for negative x.  (Not surprising -- x is treated as
  unsigned so that's a really big number and likely, malloc is returning
  null which we're not checking for when we allocate...)

* better formatting support in printf & friends (i.e., deal with full
  %-specifiers)  

* varargs (...) (integrate with printf, fprintf, xprintf?)

* multi-level initializers, e.g., {{0,1},{2,3}}

* better constant expressions (no doubles? no longs?)

* compound literals, more designators for arrays literals, better 
  designators for structs

* better evaluation in evexp.pop

THINGS NEEDED TO MAKE REGIONS MORE REAL:
----------------------------------------
* Need to add letregion, syntax for region handles, and a way to
  allocate into a region (as opposed to the heap.)

THINGS THAT WOULD BE NICE OR THAT HAVE SEX APPEAL:
--------------------------------------------------
* better type error messages:  keep track of the location where a type
  comes from and merge this information during unification.  Also,
  pretty-print types better (e.g., hide the effects when possible,
  strip off qualifiers in a Using context, try to preserve typedefs,
  etc.)  

* dependent types for arrays (and lots more?)

* nested functions (closures -- with RTCG approach to get calling convention
  right.)

* better comprehensions/iterators

* We should add anonymous structs (and enums)?

* We should allow more deep casts (e.g., function pointers) and have
  generally better support for casting between compatible representations.
  e.g., char[4] to int[1] (note not sound on architectures that require
  word alignment.)

* We should allow partial instantiations of polymorphic routines.

* ought to be able to treat the arguments to a tunion constructor as a tuple
  in a pattern...

* qualifiers for arguments to [x]tunion constructors?  on tuples?

* cut, fill, codegen, splice

* Support qualified identifier declarations (instead of just uses).

* as patterns.  views and abstract patterns.  

* builtin list syntax: list(e1,e2,...,en)? -- also for patterns

* string append operator (++)?

* we should leverage the effect stuff to do exception analysis.

* we should add template-like mechanisms for generating code at
  compile (or run?) time.  That would allow us to abstract over
  Mem types.

* Cyclone ought to say something when called with no arguments, as gcc
  does.

THINGS THAT WOULD MAKE THE COMPILER FASTER OR THE CODE BETTER:
--------------------------------------------------------------
* Try to avoid using so many lists in the abstract syntax --
  we should use arrays (e.g., for CompoundLit_e, Array_e,
  Struct_e, Tunion_e, Xtunion_e, and UnresolvedMem_e, Switch_s, etc.)

* We need to re-do the pattern match compilation -- we should take
  advantage of the decision tree built during type-checking.

MISCELLANEOUS
-------------
* allows a cast between a "struct cons<exp>*" and "exp@?" !!!
  at least it gives a warning...  Actually, this may be right.

* We should get the documentation in shape.

* Maybe we should port bison to cyclone.

* need to start putting user's guide together.

* new { for i < x : ' ' }
  causes core dump for negative x.  (Not surprising -- x is treated as
  unsigned so that's a really big number and likely, malloc is returning
  null which we're not checking for when we allocate...)

* better implementation of unresolved mem

* deal with inline?

* translation to C is busted with -noexpandtypedefs because we hoist
tuples to the top (before typedef declarations)

* The FAQ in doc/web/ has two instances of "What does new mean?"
