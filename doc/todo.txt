Todo now:

* if we write:

  let slist = &cons((string)"hello",null)

  then we do not get a type-error, in spite of the fact that we're
  instantiating a boxed type variable with an unboxed type (char[?]).

* shouldn't allow comparisons on strings or other "structs"

* "sizeof e" doesn't do the right thing.

* we don't verify that cyc_main has the right type:  we should rename
  it to "main" (and translate it to _cyc_main or something like this)
  and force it to return an int and take argc, argv as arguments.

* unbox [?] arrays

* get rid of null, replace with 0 (requires clever overloading)

* I'd like to re-code the type-checker so that it pushes information
  down as well as up (more like the local type inference described by
  Pierce.)  This will allow us to, for instance, avoid having to cast
  string literals when we write:

    list<string> x = &Cons{.hd="foo",.tl=null};

* We need to fix & (and * patterns) so that they are sound.  I believe
  now that Dan has the goto and fallthru stuff working correctly, this
  is the only major unsoundness in the system.

* We need to re-do the pattern match compilation -- we should take
  advantage of the decision tree built during type-checking.

* We should add unions in, and allow them when the different variants
  don't contain pointers or abstract types.

* We should add anonymous structs.

* We should fix all of the FIX things in the code.

* We should get the documentation in shape.

* We should allow more deep casts (e.g., function pointers).

* Maybe we should port bison to cyclone.

* Maybe we should start on the porting tool.

* More libraries

* Remove synth stuff to clean up typechecker

* ought to be able to treat the arguments to an enum constructor as a tuple
  in a pattern...

* need to start putting user's guide together.

* lots of places where we're not sure what to do with the type qualifiers

* should hack the popcorn front-end to spit out cyclone (or a close
  approximation thereof.)

* need to spit out an "interface" file for each .cyc file.  The interface
  should list all of the imported types and values, and all of the exported
  types and values.  At link-time, we should suck in all of these and make
  sure they're consistent.  

* better formatting support in printf & friends (i.e., deal with full
  %-specifiers)

* new { for i < x : ' ' }
  causes core dump for negative x.  (Not surprising -- x is treated as
  unsigned so that's a really big number and likely, malloc is returning
  null which we're not checking for when we allocate...)

* multi-dimensional arrays?

* default array initializers, at top level and local, e.g., int x[4];

* functions should not be allowed as fields of enums or tuples, e.g.,
    $(int (int),bool) x;
    enum foo { Bar(int (int)) };
  Anyway the translation fails to go through gcc

* Consider this:     foo?"a":"bc"   won't typecheck because the arms
  are char[2] and char[3] which don't match.  Maybe we should promote
  to string in this case?

* multi-level initializers, e.g., {{0,1},{2,3}}

* more general casts, e.g., char[4] to int[1]

* better constant expressions (no doubles? no longs?)

* varargs (...) (integrate with printf, fprintf, xprintf?)

* scanf, sprintf, and any other vararg functions?

* better (deeper) coercions and casts -- perhaps a more general notion of
  subtyping and isomorphism?

* compound literals

* more designators for arrays literals

* better designators for structs

* qualifiers for arguments to enum/xenum constructors?

* xenum redeclarations in another namespace handled right?

* better implementation of unresolved mem

* deal with inline?

* are we treating void properly?

* cut, fill, codegen, splice

* Support qualified identifier declarations (instead of just uses).

* nested functions (nested type declarations? nested exception declarations?
  nested using?)

* static local variables

* long long, short, float, and double constants (including 12s, 3l, etc.)

* as patterns

* better evaluation in evexp.pop

* builtin list syntax: list(e1,e2,...,en) -- also for patterns

* string append operator (++)?

* qualifiers on tuples (how)?

* Maybe we should treat the following as the same in the
  type-checker/parser:
    void foo(int x[]) == void foo( int (@x)[] )
    void foo(int x[3]) == void foo( int (@x)[3] )
  Problem: this is incompatible with C.  Instead C uses
    void foo(int x[]) == void foo( int *x )
    void foo(int x[3]) == void foo( int *x )
  And, in C there is a difference between (int *x) and (int (*x)[]).
    Consider x[4].  If we have (int *x) then we obtain the (int *) to
    dereference by adding to x.  If we have (int (*x)[]), then
    we have to explicitly dereference x to get an (int[]), and then
    C does an implicit address-of to get the original pointer back,
    but at type (int *).  Only then does the final addition take
    place.
  Note that since [?] arrays are boxed we can already use the notation
    int f(int x[?])[?]
  so, this is really only a concern with C arrays.  We could simply
  live with the inconvenience of the verbose notation for these types
  of arrays -- force the programmer to write int (*f(int (*x[4]))[5].
  However, there is still the question of whether to DISallow things
  like   void f(int x[4])   which in C involves a cast to a int *.

Some things Dan has noticed:

* should allow function prototypes with storage class specifiers other
  than extern (avoid gcc warnings about static following extern)

* getting gcc warning about pointer from integer in, for eg,
  {.hd=0,.tl=null} because from the designator "hd" we have no idea
  that we should cast to (void *) to avoid the warning. (Oddly,
  mapping `a to int would get rid of this problem and probably
  wouldn't cause other problems.)

* do something about all the warnings when compiling the parser

Todo later:

* dependent types for arrays (and lots more?)
* anonymous structs and enums
* bit fields within structs
* unions (in the C sense)
* subtyping
* better comprehensions/iterators
* calling conventions for functions (C vs Cyclone)
