Todo list:

BUG FIXES and UNSOUNDNESSES:
----------------------------
* FIX all of the FIX things.

* using Foo; using Foo; causes "amgiguous" problems.

* fix warning that we get when compiling tc.cyc

* can't cast char?? to const char? const ? (or whatever it is.)

* add F-bounded polymorphism or at least make it possible to abstract
  qualifiers.  The string library isn't polymorphic enough because in
  many places, we want to pass in a mutable string and get out the
  same string, but we're forced to cast up to a const char ? which
  then loses the mutability in the result.

* because of where clauses, we need to have a default pattern everywhere
  (well, you could rule out some of them when things are const.)  Even without
  where clauses, when we add threads, we will need to add default cases
  because a thread can change some mutable value that we're looking at
  during the pattern match.  

* the unifier is a bit too eager about nailing down effects.  The problem
  is that when we do a function call, we need to ensure that the effect
  of the function is a subset of the current capability.  To do this we,
  check that each primitive effect is in the capability.  When we encounter
  regions(%(_)) where the %(_) is an evar that does not occur in the
  capability, we eagerly instantiate the evar to int (thereby making
  the regions(-) reduce to the empty effect, and thus satisfying the
  constraint.)  But all we need to do is cut down the set of free type
  variables that %(_) can have to include those region, type, and effect
  variables that show up in the current capability.  Alternatively, we
  can look at the set associated with the evar and just check that all
  of those things are in the capability...

* when you have int x[56] and do int ?z = &x[1], z has size 1 instead
  of size 55.  

* error messages are confusing now that typedefs have hidden parameters.

* Type-checker must disallow x -= y where x and y are pointers.

* We rely on C to catch incomplete types, such as 
  struct X {
    struct X x;
  };

* void f() {
   void g();
   g();
  }
We complain that g isn't initialized.  We should complain that
function declarations are only allowed at top-level.

* Translation of lvalues is still broken because we put in casts
(and leave wrong casts) in places we shouldn't.

* are we treating void properly?

* Implementation of exceptions assumes sizeof(void *) == sizeof(int)
  Also we don't follow C's rules about variables live across longjmp
  being declared volatile and setjmp only appearing in guards.

* Let programmer catch Null_Exception and Match_Exception.  They are
  not in the initial environment, so they look like variables in patterns.

* link-checking:  we need to spit out an internal interface for each
  module and check for consistency at link-time.  Note that we should
  also check that main has the right type.  We should have the compiler
  hash and sign the code and interface so that we can detect tampering
  with the code or interface at link-time.

* we're too restrictive about typedef names -- C allows typedef names
  to be shadowed by identifiers (or other typedefs).  Our lexer
  doesn't have quite the right infrastructure for this.

* there are unsoundnesses w.r.t. the way we type-check the left-hand-sides
  of certain operations (e.g., x++.)  Part of the problem is that we allow
  implicit coercion from an enum to an integral type.  

* we need to do a bounds check on enum assignments.  Also, the pattern
  matcher assumes that there are no duplicate tags for enums.

* subtyping is broken w.r.t. pointer bounds -- you can cast int@{1} to
  int@{3}.  The whole sub-typing machinery needs to be re-examined to
  make sure that it is sound.  In particular, alignment issues are
  a concern.

* namespace issues:  we treat `namespace Foo {extern "C" int x;}' as if
  x is translated as Cyc_Foo_x but it's translated as "x".  We should
  really define both "x" and "Cyc_Foo_x" in the environment.  In addition,
  users can spoof a Cyclone variable by writing {extern "C" int Cyc_x;}.

* new "foo" and rnew(h) "foo" don't work properly -- they should allocate
  a copy of the string in the region, no?

* src/Makefile produces $(OUTPUT_PREFIX)parse_tab.h, but parse.h is
  hardcoded to #include "parse_tab.h", so everything breaks when you
  use a prefix.

MISSING THINGS NEEDED TO PORT REAL CODE:
----------------------------------------
* Need to port more C libraries

* Some better way to deal with effects for function pointer types.
  It makes sense to do what we do now (i.e., insert an effect tyvar)
  for function definitions or function arguments or function results,
  but it doesn't make sense for fields within structs or elsewhere.
  For instance, when we declare a function variable, it's not clear
  that we should do what we do.  Rather, we should perhaps insert an
  evar?  

* We don't allow enough pointer arithmetic.  For instance, we don't
  allow the following:

    int x[35] = {....}

      x+1

* default array initializers within a function: e.g., int x[4];  Actually,
  for bits-only things, we should only issue a warning if they're used
  before being initialized.  

* should use noreturn attribute, especially for exit, and also check
  that noreturn is actually true for a given function definition.

* nested type declarations? nested exception declarations? nested using?

* long long, short, float, and double constants (including 12s, 3l, etc.)

* add some way to forward varargs -- easiest would be to cast a vararg
  function to one with an explicit array.

* wide characters and strings

* attributes on enums? (e.g., packed)

* we don't allow casts in "constant" expressions so as to avoid
  the issue that our casts may include computation.  We should
  have a way to check to see if a cast doesn't do any computation.

* get rid of null, replace with 0 (requires clever overloading)

* add memcpy and memset somehow.

THINGS NEEDED TO SIMPLIFY PORTING:
----------------------------------
* we should start on the porting tool -- use region inference to
  figure out the "right" interface for code.

* new { for i < x : ' ' }
  causes core dump for negative x.  (Not surprising -- x is treated as
  unsigned so that's a really big number and likely, malloc is returning
  null which we're not checking for when we allocate...)

* multi-level initializers, e.g., {{0,1},{2,3}}

* better constant expressions (no doubles? no longs?)

* compound literals, more designators for arrays literals, better 
  designators for structs

* better evaluation in evexp.pop

* remove cyc_include.h's dependency on setjmp.h, since that really
  pollutes the namespace

* "using foo; using foo;" shouldn't cause ambiguities

* buf+n should have the same type as &buf[n]

* sscanf should support %s when a field width is provided

THINGS NEEDED TO MAKE REGIONS MORE REAL:
----------------------------------------

THINGS THAT WOULD BE NICE OR THAT HAVE SEX APPEAL:
--------------------------------------------------
* better type error messages:  keep track of the location where a type
  comes from and merge this information during unification.  Also,
  pretty-print types better (e.g., hide the effects when possible,
  strip off qualifiers in a Using context, try to preserve typedefs,
  etc.)  

* dependent types for arrays (and lots more?)

* nested functions (closures -- with RTCG approach to get calling convention
  right.)

* better comprehensions/iterators

* We should add anonymous structs (and enums)?

* We should allow more deep casts (e.g., function pointers) and have
  generally better support for casting between compatible representations.
  e.g., char[4] to int[1] (note not sound on architectures that require
  word alignment.)

* We should allow partial instantiations of polymorphic routines.

* ought to be able to treat the arguments to a tunion constructor as a tuple
  in a pattern...

* qualifiers for arguments to [x]tunion constructors?  on tuples?

* cut, fill, codegen, splice

* Support qualified identifier declarations (instead of just uses).

* as patterns.  views and abstract patterns.  

* string append operator (++)?

* we should leverage the effect stuff to do exception analysis.

* we should add template-like mechanisms for generating code at
  compile (or run?) time.  That would allow us to abstract over
  Mem types.

* Cyclone ought to say something when called with no arguments, as gcc
  does.

THINGS THAT WOULD MAKE THE COMPILER FASTER OR THE CODE BETTER:
--------------------------------------------------------------
* Try to avoid using so many lists in the abstract syntax --
  we should use arrays (e.g., for CompoundLit_e, Array_e,
  Struct_e, Tunion_e, Xtunion_e, and UnresolvedMem_e, Switch_s, etc.)

* We need to re-do the pattern match compilation -- we should take
  advantage of the decision tree built during type-checking.

MISCELLANEOUS
-------------
* allows a cast between a "struct cons<exp>*" and "exp@?" !!!
  at least it gives a warning...  Actually, this may be right.

* We should get the documentation in shape.

* need to start putting user's guide together.

* better implementation of unresolved mem

* deal with inline?

* translation to C is busted with -noexpandtypedefs because we hoist
tuples to the top (before typedef declarations)

* The FAQ in doc/web/ has two instances of "What does new mean?"
