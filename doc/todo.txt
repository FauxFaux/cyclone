Todo list:

BUG FIXES and UNSOUNDNESSES:
----------------------------
* there's a bug in control-flow checking of catch-phrases.  If you leave
  the "break" off of a case, then it re-raises the exception.

* we allow enum constructors to shadow other enum constructors even though
  C doesn't.  

* make command line arguments more like gcc: what happens
  when no files are given?  what happens when we have the wrong extension?
  (need flags to say how to treat it, ie. as cyc file, as .o file, as .c
  file, etc.)

* name mangling needs to be dealt with

* minimize initializing

* FIX all of the FIX things.

* can't cast char?? to const char? const ? (or whatever it is.)

* add F-bounded polymorphism or at least make it possible to abstract
  qualifiers.  The string library isn't polymorphic enough because in
  many places, we want to pass in a mutable string and get out the
  same string, but we're forced to cast up to a const char ? which
  then loses the mutability in the result.

* because of where clauses, we need to have a default pattern everywhere
  (well, you could rule out some of them when things are const.)  Even without
  where clauses, when we add threads, we will need to add default cases
  because a thread can change some mutable value that we're looking at
  during the pattern match.  
  Alternatively, we could do like O'Caml and copy the values out
  before doing any tests.

* the unifier is a bit too eager about nailing down effects.  The problem
  is that when we do a function call, we need to ensure that the effect
  of the function is a subset of the current capability.  To do this we,
  check that each primitive effect is in the capability.  When we encounter
  regions(%(_)) where the %(_) is an evar that does not occur in the
  capability, we eagerly instantiate the evar to int (thereby making
  the regions(-) reduce to the empty effect, and thus satisfying the
  constraint.)  But all we need to do is cut down the set of free type
  variables that %(_) can have to include those region, type, and effect
  variables that show up in the current capability.  Alternatively, we
  can look at the set associated with the evar and just check that all
  of those things are in the capability...

* when you have int x[56] and do int ?z = &x[1], z has size 1 instead
  of size 55.  

* We rely on C to catch incomplete types, such as 
  struct X {
    struct X x;
  };

* void f() {
   void g();
   g();
  }
We complain that g isn't initialized.  We should complain that
function declarations are only allowed at top-level.

* Translation of lvalues is still broken because we put in casts
(and leave wrong casts) in places we shouldn't.

* are we treating void properly?

* Implementation of polymorphism assumes sizeof(void *) == sizeof(int).
  Implementations of exceptions and backtrace() assume sizeof(void *)
  == sizeof(int) Also we don't follow C's rules about variables live
  across longjmp being declared volatile and setjmp only appearing in
  guards.

* link-checking:  we need to spit out an internal interface for each
  module and check for consistency at link-time.  Note that we should
  also check that main has the right type.  We should have the compiler
  hash and sign the code and interface so that we can detect tampering
  with the code or interface at link-time.

* we're too restrictive about typedef names -- C allows typedef names
  to be shadowed by identifiers (or other typedefs).  Our lexer
  doesn't have quite the right infrastructure for this.

* there are unsoundnesses w.r.t. the way we type-check the left-hand-sides
  of certain operations (e.g., x++.)  Part of the problem is that we allow
  implicit coercion from an enum to an integral type.  

* we need to do a bounds check on enum assignments.  Also, the pattern
  matcher assumes that there are no duplicate tags for enums.

* The whole sub-typing machinery needs to be re-examined to
  make sure that it is sound.  In particular, alignment issues are
  a concern.

* namespace issues:  we treat `namespace Foo {extern "C" int x;}' as if
  x is translated as Cyc_Foo_x but it's translated as "x".  We should
  really define both "x" and "Cyc_Foo_x" in the environment.  In addition,
  users can spoof a Cyclone variable by writing {extern "C" int Cyc_x;}.

* new "foo" and rnew(h) "foo" don't work properly -- they should allocate
  a copy of the string in the region, no?

* src/Makefile produces $(OUTPUT_PREFIX)parse_tab.h, but parse.h is
  hardcoded to #include "parse_tab.h", so everything breaks when you
  use a prefix.

MISSING THINGS NEEDED TO PORT REAL CODE:
----------------------------------------
* need to port more C libraries

* should have some "intern C" or "unsafe_C" where we can escape
  out to C when needed.  This will allow us to not have to write
  separate files with C code in them.

* need to be able to use inject on a single argument, not just on
  varargs.  This is important for args that are void * for example.

* default array initializers within a function: e.g., int x[4];  Actually,
  for bits-only things, we should only issue a warning if they're used
  before being initialized.  

* should use noreturn attribute, especially for exit, and also check
  that noreturn is actually true for a given function definition.

* nested type declarations? nested exception declarations? nested using?

* long long, short, float, and double constants (including 12s, 3l, etc.)

* add some way to forward varargs -- easiest would be to cast a vararg
  function to one with an explicit array.

* wide characters and strings

* attributes on enums? (e.g., packed)

* we don't allow casts in "constant" expressions so as to avoid
  the issue that our casts may include computation.  We should
  have a way to check to see if a cast doesn't do any computation.

* get rid of null, replace with 0 (requires clever overloading)

* add memcpy and memset somehow.

THINGS NEEDED TO SIMPLIFY PORTING:
----------------------------------
* we should start on the porting tool -- use region inference to
  figure out the "right" interface for code.

* multi-level initializers, e.g., {{0,1},{2,3}}

* better constant expressions (no doubles? no longs?)

* compound literals, more designators for arrays literals, better 
  designators for structs

* better evaluation in evexp.pop

* remove cyc_include.h's dependency on setjmp.h, since that really
  pollutes the namespace

* buf+n should have the same type as &buf[n]

* sscanf should support %s when a field width is provided

THINGS NEEDED TO MAKE REGIONS MORE REAL:
----------------------------------------

THINGS THAT WOULD BE NICE OR THAT HAVE SEX APPEAL:
--------------------------------------------------
* better type error messages:  keep track of the location where a type
  comes from and merge this information during unification.  Also,
  pretty-print types better (e.g., hide the effects when possible,
  strip off qualifiers in a Using context, try to preserve typedefs,
  etc.)  

* dependent types for arrays (and lots more?)

* nested functions (closures -- with RTCG approach to get calling convention
  right.)

* regular expressions

* better comprehensions/iterators

* We should allow more deep casts (e.g., function pointers) and have
  generally better support for casting between compatible representations.
  e.g., char[4] to int[1] (note not sound on architectures that require
  word alignment.)

* We should allow partial instantiations of polymorphic routines.

* ought to be able to treat the arguments to a tunion constructor as a tuple
  in a pattern...

* qualifiers for arguments to [x]tunion constructors?  on tuples?

* cut, fill, codegen, splice

* Support qualified identifier declarations (instead of just uses).

* as patterns.  views and abstract patterns.  

* string append operator (++)?

* we should leverage the effect stuff to do exception analysis.

* we should add template-like mechanisms for generating code at
  compile (or run?) time.  That would allow us to abstract over
  Mem types.

THINGS THAT WOULD MAKE THE COMPILER FASTER OR THE CODE BETTER:
--------------------------------------------------------------
* Try to avoid using so many lists in the abstract syntax --
  we should use arrays (e.g., for CompoundLit_e, Array_e,
  Struct_e, Tunion_e, Xtunion_e, and UnresolvedMem_e, Switch_s, etc.)

* We need to re-do the pattern match compilation -- we should take
  advantage of the decision tree built during type-checking.

MISCELLANEOUS
-------------
* allows a cast between a "struct cons<exp>*" and "exp@?" !!!
  at least it gives a warning...  Actually, this may be right.

* better implementation of unresolved mem

* translation to C with -noexpandtypedefs hasn't been tested in forever.
