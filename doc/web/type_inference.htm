<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>Type Inference</title>
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<meta name="Microsoft Border" content="l, default">
</head>

<body><!--msnavigation--><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr><td valign="top" width="1%">

<nobr><a href="index.htm">Home</a></nobr><br><nobr><a href="quick_questions.htm">Quick&nbsp;Questions</a></nobr><br><nobr><a href="quick_answers.htm">Quick&nbsp;Answers</a></nobr><br><nobr><a href="known_bugs.htm">Known&nbsp;Bugs</a></nobr><br><nobr><a href="pointers.htm">Pointers</a></nobr><br><nobr><a href="discriminated_unions.htm">Discriminated&nbsp;Unions</a></nobr><br><nobr><a href="pattern_matching.htm">Pattern&nbsp;Matching</a></nobr><br><nobr>Type&nbsp;Inference</nobr><br><nobr><a href="polymorphism.htm">Polymorphism</a></nobr><br><nobr><a href="regions_and_effects.htm">Memory&nbsp;Management</a></nobr><br><nobr><a href="definite_assignment.htm">Definite&nbsp;Assignment</a></nobr><br><nobr><a href="namespaces.htm">Namespaces</a></nobr><br><nobr><a href="interfacing_with_c.htm">Interfacing&nbsp;with&nbsp;C</a></nobr>

</td><td valign="top" width="24"></td><!--msnavigation--><td valign="top">
<h1 align="center">Type Inference</h1>
Cyclone allows many explicit types to be elided.&nbsp; In short, you write _
(underscore) where a type should be and the compiler tries to figure out the
type for you.&nbsp; Type inference can make C-like Cyclone code easier to write
and more readable.&nbsp; For example,
<p><font face="Courier New">_ x = malloc(sizeof(sometype_t));</font></p>
<p>is a fine substitute for</p>
<p><font face="Courier New">sometype_t @ x = malloc(sizeof(sometype_t));</font></p>
<p>Of course, explicit types can make code more readable, so it is often
better style not to use inference.</p>
<p>Inference is even more useful because of Cyclone's advanced typing
constructs.&nbsp; For example, it is much easier to write down _ than a type for
a function pointer.&nbsp; Also, you can use it to omit explicit regions, such as
in the following:</p>
<p style="line-height: 0"><font face="Courier New">void f() {</font></p>
<p style="line-height: 0"><font face="Courier New">&nbsp; int x = 3;</font></p>
<p style="line-height: 0"><font face="Courier New">&nbsp; int *_ y = &amp;x;</font></p>
<p style="line-height: 0"><font face="Courier New">}</font></p>
<p>(If the _ is omitted, the code is ill-typed because int * describes heap
pointers.)</p>
<p>We now give a rough idea of when you can elide types and how types get
inferred.&nbsp; In practice, you tend to develop a sense of which idioms
succeed, and, if there's a strange compiler-error message about a variable's
type, you give more explicit information about the variable's type.</p>
<h3><b>Syntax</b></h3>
<p>As far as the parser is concerned, _ is a legal type specifier.&nbsp;
However, the type-checker will immediately reject _ in these places (or at least
it should):</p>
<ul>
  <li>As part of a top-level variable or function's type.</li>
  <li>As part of a struct, tunion, xtunion, or typedef declaration.</li>
  <li>As a part of an explicit type instantiation (eg. Foo&lt;_,_&gt;) where it
    is instantiating a region-name or effect-name.</li>
</ul>
<p>Note that _ can be used for part of a type.&nbsp; A silly example is $(_,int)
= $(3,4);&nbsp; A more useful example is an explicit cast to a non-nullable
pointer (to avoid a compiler warning).&nbsp; For example:</p>
<p style="line-height: 0"><font face="Courier New">void f(some_big_type * x,
some_big_type @ y) {</font></p>
<p style="line-height: 0"><font face="Courier New">if(x != null) {</font></p>
<p style="line-height: 0"><font face="Courier New">&nbsp; y = (_ @) x;</font></p>
<p style="line-height: 0"><font face="Courier New">}</font></p>
<h3><b>Semantics</b></h3>
<p>Except for the subtleties discussed below, using _ should not change the
meaning of programs.&nbsp; However, it may cause a program not to type-check
because the compiler no longer has the type information it needs at some point
in the program.&nbsp; For example, the compiler rejects x-&gt;f if it does not
know the type of x because the different struct types can have members named
f.&nbsp;&nbsp;</p>
<p>The compiler infers the types of expressions based on uses.&nbsp; For
example, consider:</p>
<p style="line-height: 0"><font face="Courier New">_ x = null;</font></p>
<p style="line-height: 0"><font face="Courier New">x = g();</font></p>
<p style="line-height: 0"><font face="Courier New">x-&gt;f;</font></p>
<p>This code will type-check provided the return type of g is a pointer to a
struct with a field named f.&nbsp; If the two statements were in the other
order, the code would not type-check.&nbsp; Also, if g returned an int, the code
would not type-check, even without the x-&gt;f expression, because the _ x =
null constrains x to have a pointer type.</p>
<p>However, the above discussion assumes that sequences of statements are
type-checked in order.&nbsp; This is true, but <b>in general the type-checker's
order is unspecified</b>.</p>
<h3><b>Subtleties</b></h3>
<p>In general, inference has subtle interactions with implicit casts (such as
from t@ to t*) and constants that have multiple types (such as numeric
constants).</p>
<p>The following is a desirable property: If a program is modified by replacing
some explicit types with _ and the program still type-checks, then its meaning
is the same.&nbsp; <i>This property does not hold!</i>&nbsp; Here are two
examples:</p>
<p><b>Numeric Types</b></p>
<p>This program prints -24 1000:</p>
<p><font face="Courier New">int f() {<br>
  char c = 1000;<br>
  return c;<br>
}<br>
int g() {<br>
  _ c = 1000; // compiler infers int<br>
  return c;<br>
}<br>
int main() {<br>
  printf("%d %d", f(), g());<br>
  return 0;<br>
}</font><br>
</p>
<p><b>Order Matters</b></p>
<p>Here is an example where the function's meaning depends on the order the
type-checker examines the function:</p>
<p><font face="Courier New">void h1(int @ c, int maybe) {<br>
&nbsp; _ a;<br>
&nbsp; if(maybe)<br>
&nbsp;&nbsp;&nbsp; a = c;<br>
&nbsp; else<br>
&nbsp;&nbsp;&nbsp; a = null;<br>
}</font><br>
</p>
<p>At first, the type of a is completely unconstrained.&nbsp; If we next
consider a = c, we will give a the type of c, namely int @, an int pointer that
cannot be null.&nbsp; Clearly that makes the assignment a = null problematic,
but Cyclone allows assignment from nullable pointers to non-nullable pointers;
it gives a compile-time warning and inserts a run-time check that the value is
not null.&nbsp; Here the check will fail and an exception will be raised.&nbsp;
That is, h1(p,0) is guaranteed to raise an exception.</p>
<p>But what if the type-checker examines a = null first?&nbsp; Then the
type-checker will constrain a's type to be a nullable pointer to an
unconstrained type.&nbsp; Then the assignment a = c will constrain that type to
be int, so the type of a is int *.&nbsp; An assignment from int @ to int * is
safe, so there is no warning.&nbsp; Moreover, the assignment a = null is not a
run-time error.</p>
<p><i>The order of type-checking is left unspecified.&nbsp; In the future, we
intend to move to a system that is order-independent.</i></p>
&nbsp;<!--msnavigation--></td></tr><!--msnavigation--></table></body>

</html>
