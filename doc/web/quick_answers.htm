<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>Cyclone Quick Answers</title>
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<meta name="Microsoft Border" content="l, default">
</head>

<body><!--msnavigation--><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr><td valign="top" width="1%">

<nobr><a href="index.htm">Home</a></nobr><br><nobr><a href="quick_questions.htm">Quick&nbsp;Questions</a></nobr><br><nobr>Quick&nbsp;Answers</nobr><br><nobr><a href="known_bugs.htm">Known&nbsp;Bugs</a></nobr><br><nobr><a href="pointers.htm">Pointers</a></nobr><br><nobr><a href="discriminated_unions.htm">Discriminated&nbsp;Unions</a></nobr><br><nobr><a href="pattern_matching.htm">Pattern&nbsp;Matching</a></nobr><br><nobr><a href="type_inference.htm">Type&nbsp;Inference</a></nobr><br><nobr><a href="polymorphism.htm">Polymorphism</a></nobr><br><nobr><a href="regions_and_effects.htm">Memory&nbsp;Management</a></nobr><br><nobr><a href="definite_assignment.htm">Definite&nbsp;Assignment</a></nobr><br><nobr><a href="namespaces.htm">Namespaces</a></nobr><br><nobr><a href="interfacing_with_c.htm">Interfacing&nbsp;with&nbsp;C</a></nobr>

</td><td valign="top" width="24"></td><!--msnavigation--><td valign="top">
<h1 align="center">Quick Answers About Cyclone</h1>
<p align="center"><b>Version 1.0</b></p>
<p align="center">[See the <a href="quick_questions.htm">Quick Questions</a>
page for a structured list of contents]</p>
<p><b><a name="types_tuple"></a>What does $(type1,type2) mean?&nbsp; What does
$(exp1, exp2) mean?</b></p>
<p>Cyclone has tuples, which are anonymous structs with fields &quot;named&quot;
0,1,2,...&nbsp; For example, $(int,string) is a pair of an int and a
string.&nbsp; An example value of this type is $(4,&quot;cyclone&quot;).&nbsp;
Getting fields uses array-like notation: you write x[0], not x.0.</p>
<p><b><a name="types_at"></a>What does &quot;int @&quot; mean?</b></p>
<p>@ builds types exactly the same way that * does, except that values of
&quot;@ types&quot; cannot be null.&nbsp; So &quot;int * x = null&quot; will
typecheck, but &quot;int @ x = null&quot; will not.</p>
<p><b><a name="types_bound"></a>What does &quot;int *{37}&quot; mean?</b></p>
<p>This type is for (heap-allocated) arrays containing at least 37
elements.&nbsp; Because Cyclone checks array bounds, it must know the length of
an array.&nbsp; If x has type int *{37}, then the compiler will translate x[e]
to code that evaluates e, checks that it is less than 37 and then do the
subscript operation.&nbsp; Note&nbsp; that &quot;int *&quot; is just short-hand
for &quot;int *{1}&quot;.&nbsp; Currently, the expression in the braces must be
a compile-time constant.</p>
<p><b><a name="types_region"></a>What does &quot;int *r&quot; mean?</b></p>
<p>The type is for pointers to ints in <i>region</i> r.&nbsp; Because Cyclone
prevents dereferencing pointers to deallocated space, the compiler must know
where a pointer points.&nbsp; A region is just a group of objects with the same
lifetime.&nbsp; The heap region is written `H and contains objects that live
&quot;forever&quot; (they may be garbage collected).&nbsp; &quot;int *&quot; is
just shorthand for &quot;int *`H&quot;.&nbsp;&nbsp; If the region for a function
parameter is a type variable (eg. `r), then the function may assume the
parameter points into a region whose lifetime includes the lifetime of the
function, but possibly no longer.</p>
<p><b><a name="types_together"></a>So what does &quot;int @{37}r&quot; mean?</b></p>
<p>All the refinements of pointer types fit together nicely.&nbsp; This type is
for non-null pointers to arrays of at least 37 elements that reside in region r.&nbsp;
Note that int * is just short-hand for int *{1}`H.</p>
<p><b><a name="types_size"></a>What does &quot;int ?&quot; mean?</b></p>
<p>This type is for heap-allocated arrays of ints that carry their size with
them.&nbsp; That way, the compiler can insert array-bounds checks even if the
array's size is unknown at compile-time.&nbsp; These arrays are best
understood in terms of their implementation: There is the &quot;underlying&quot;
array of elements and three pointers.&nbsp; One pointer is to the beginning of
the underlying array and one is to the end.&nbsp; These pointers are not
accessible to the programmer.&nbsp; The third pointer is under programmer
control; you can do pointer arithmetic on it.&nbsp; On arr[e], a
compiler-inserted check ensures that arr+e is between the other two pointers.</p>
<p><b><a name="types_tyvar"></a>What does `a mean?</b></p>
<p>`a is a type variable.&nbsp; For example, if a function takes a parameter of
type `a, then the function can be called with a value of any suitable
type.&nbsp; If there are two arguments of type `a, then any call will have to
give values of the <i>same</i> type.&nbsp; Exactly those identifiers beginning
with ` are type variables.</p>
<p><b><a name="types_boxkind"></a>What types can a type variable stand for?</b></p>
<p>Suppose we have &quot; <font face="Courier New">`a identity(`a x)</font>
&quot;.&nbsp; Then identity can be passed an int, an unsigned int, a pointer, a
tunion, or an xtunion.&nbsp; Arguments of other numeric types are converted to
int or unsigned int using C's rules.&nbsp; <font face="Courier New">identity</font>
cannot be passed a floating point, a struct, a tuple, or a checked array (eg.
int ?).&nbsp; In short, `a can be instantiated with any 4-byte type that is not
float.&nbsp; (In Cyclone, int and pointers always take 4 bytes.)&nbsp; These are
the types of &quot;box kind&quot;.&nbsp; The types of each kind are described <a href="#types_kinds">below</a>.</p>
<p><b><a name="types_voidstar"></a>How do I cast from void *?</b></p>
<p>You can't because we don't allow unsafe casts.&nbsp; Cyclone programs should
use type variables and polymorphism instead of void *.</p>
<p><b><a name="types_infer"></a>What does _ (underscore) as part of a type mean?</b></p>
<p>You can write _ in place of a type or region anywhere inside a function. (_
is not allowed as part of top-level declarations.)&nbsp; The compiler will use
context to try to determine what type or region belongs &quot;in the
blank&quot;.&nbsp; For many useful idioms, the compiler will succeed.&nbsp; For
example, _ pr = new Pair(3,4), the compiler can easily infer &quot;struct Pair
@&quot; for the blank.&nbsp; In fact, if pr is later assigned null, the compiler
will infer &quot;struct Pair *&quot;.&nbsp; If you are using _ and get strange
error messages, simply fill in the blanks yourself.</p>
<p><a name="types_infer_region"></a><b>In particular, what does int *_ mean?</b></p>
<p>Because int * stands for pointers into the heap, you must give a region for
pointers into other regions.&nbsp; But with _, you don't have to give such
regions explicit names.&nbsp; This feature is most often used with stack
pointers.&nbsp; For example, you can write: &quot;int x; int *_ y =
&amp;x;&quot;.&nbsp; (You could also have written _ y = &amp;x; but the former
provides more documentation.)</p>
<p><a name="types_kinds"></a><b>What do `a::B, `a::M, `a::A, `a::R, and `a::E
mean?</b></p>
<p>Types are divided into different groups, which we call kinds.&nbsp; Type
variables can be instantiated with any type of the correct kind.&nbsp; B stands
for Box, M for Memory, A for Any, R for Region and E for Effect.&nbsp; Box types
include int, pointers (not including int ?), tunions, and xtunions.&nbsp; Memory
types include all box types, tuples, tunion an xtunion variants, and
non-abstract structs.&nbsp; Any types include all types not of kind Region or
Effect.&nbsp; Region types are regions, i.e. the heap and stack regions.&nbsp;
Effect types are sets of regions -- effects are explained elsewhere.</p>
<p><b><a name="types_kindinfer"></a>What does it mean when type variables don't
have explicit kinds?</b></p>
<p>Every type variable has one kind, but the programmer often does not have to
write the kind.&nbsp; In function prototypes, the compiler will infer the most
permissive kind.&nbsp; For example, &quot;void f(`a *`b x, `c * y, `a z)&quot;
is shorthand for, &quot;void f(`a::B *`b::R, `c::M * y, `a::B z)&quot;.&nbsp; In
type definitions, no inference is performed: an elided kind is shortand for ::B.
For example, struct S&lt;`a,`r::R&gt; { `a *`r x; }; is shorthand for struct
S&lt;`a::B,`r::R&gt; { `a *`r x;};, but struct S&lt;`a,`r&gt;{`a *`r x;}; is
not.</p>
<p><b><a name="types_list_eg"></a>What does struct List&lt;`a,`r::R&gt; mean?</b></p>
<p>struct List takes a type of box kind (roughly an int or a pointer) and a
region and produces a type.&nbsp; Examples are struct List&lt;int, `H&gt; and
struct List&lt;struct List&lt;int,`H&gt;@, `H&gt;.&nbsp; In terms of the Cyclone
library's struct List, the elements of the list have type `a and the cons cells
are all in region `r.</p>
<p><b><a name="types_discunion"></a>What do tunion and xtunion mean?</b></p>
<p>tunion and xtunion are used to create <a href="discriminated_unions.htm">discriminated
unions</a>.</p>
<p><b><a name="types_struct_fun"></a>How do I make a struct with
function-pointer fields?</b></p>
<p>Follow this arcane format:</p>
<p style="line-height: 50%"><font face="Courier New">struct S&lt;`e1::E,
`e2::E&gt; {</font></p>
<p style="line-height: 50%"><font face="Courier New">&nbsp;&nbsp; void
f1(int,int; `e1);</font></p>
<p style="line-height: 50%"><font face="Courier New">&nbsp;&nbsp; int f2(; `e2);</font></p>
<p style="line-height: 50%"><font face="Courier New">};</font></p>
<p style="line-height: 50%"><font face="Courier New">typedef S&lt;{},{}&gt; s_t;</font></p>
<p>More explanation is in the discussion of <a href="regions_and_effects.htm">memory
management</a>.</p>
<p><b><a name="types_abstract"></a>What does &quot;abstract&quot; mean?</b></p>
<p>&quot;abstract&quot; is a storage-class specifier, like
&quot;static&quot; or &quot;extern&quot;.&nbsp; When attached to a top-level
type declaration, it means other files may only declare the type abstractly
(e.g.. &quot;struct Foo;&quot;).&nbsp; Otherwise, abstract has the same meaning
as the auto (default) storage class.&nbsp; Hence abstract is a way to state
within a Cyclone file that a type's representation cannot be exported.</p>
<p><b><a name="add_keywords"></a>What are the Cyclone keywords?</b></p>
<p>In addition to the C keywords, the following have special meaning and cannot
be used as identifiers: abstract,&nbsp; catch, codegen, cut, fallthru, fill,
fprintf, fscanf, let, malloc, namespace, new, null, printf, rmalloc, rnew,
sscanf, splice,
throw, try, tunion, using, xprintf, xscanf, xtunion.&nbsp; As in gcc,
__attribute__ is reserved.</p>
      <p align="left"><b><a name="add_namespace"></a>What are namespace and using?</b><p>These
constructs provide a convenient way to help avoid name clashes.&nbsp; namespace
X prepends X:: to the declarations in its body (rest of file in case of
namespace X;) and using X makes the identifiers prepended with X:: available
without having to write the X::.&nbsp; A longer explanation and list of common
pitfalls is <a href="namespaces.htm">here</a>.</p>
<p><b><a name="add_fallthru"></a>What does fallthru mean?</b></p>
<p>In Cyclone, you cannot implicitly fall-through from one switch case to the
next.&nbsp; You can explicitly fall-through with the statement &quot;fallthru;&quot;.&nbsp;
fallthru may not appear in the last case of a switch.&nbsp; So <b> to port C code,
place fallthru; at the end of each case that implicitly falls through</b>.&nbsp;
Fallthru is more powerful for two reasons.&nbsp; First, it can appear anywhere
in a case; its meaning is to immediately goto the next case.&nbsp; Second, when
the next case has pattern-matching variables, a fallthru must take expressions
that are bound to the variables before the goto.&nbsp; Hence fallthru is more
powerful (but more verbose) than &quot;or patterns&quot; in ML.</p>
<p><b><a name="add_new"></a>What does new mean?</b></p>
<p>new e, where e is an expression, allocates space on the heap, initializes it
with the result of evaluating e, and returns a pointer to it.&nbsp; It is
roughly equivalent to t @ temp = malloc(sizeof(t)); *temp = e; where t is the
type of e.&nbsp; You can also write new {for i &lt; e1 : e2} to heap-allocate an
array of size e1 with the ith element initialized to e2 (which may mention i).</p>
<p><b><a name="add_tuples"></a>How do I use tuples?</b></p>
<p>A tuple type is $(t1,...,tn) where the ti are types.&nbsp; A value of such a
type is constructed via $(e1,...,en) where ei has type ti.&nbsp; Given an
expression e of type $(t1,...,tn), you extract the ith component via e[i].&nbsp;
The expression in the brackets must be a <a href="#other_constants">compile-time
constant</a>.&nbsp; In short, tuples are like anonymous structs where you use
e[i] instead of e.f.&nbsp; There is no analogue of the -&gt; syntax, so given an
expression p of type $(t1,...,tn) *, you must extract the ith component of the
underlying tuple via (*e)[i].</p>
      <p align="left"><b><a name="add_comprehension"></a>What is the {for i &lt; e1 : e2} construct?</b><p>This
construct is an array initializer.&nbsp; It can appear where array initializers
appear in C, and it can appear as the argument to new. i is an identifier.&nbsp;
e1 is an unsigned int indicating the size of the array.&nbsp; e2 is evaluated e1
times, with i having values 0, 1, ..., e1-1 and the result initializes the ith
element of the array.&nbsp; The form new {for i &lt; e1 : e2} allocates space
for a new array and initializes it as just described.&nbsp; <b>This form is the
only way to create arrays whose size depends on run-time information.</b>&nbsp;
When {for i &lt; e1: e2} is not an argument to new, e1 must be constant and e2
may not mention i.&nbsp; This restriction includes all uses at top-level (for
global variables).</p>
<p><b><a name="add_exns"></a>How do I throw and catch exceptions?</b></p>
<p>To declare a new exception variant, declare xtunion exn {MyExn };.&nbsp; To
throw an exception, use the expression form throw e, for example throw MyExn.&nbsp;
To catch an exception, use the try/catch statement, for example: try&nbsp;
s1&nbsp; catch { case MyExn: s2 }.&nbsp; If execution of s1 throws MyExn (and no
inner exception handler catches it), control transfers immediately to s2.</p>
<p>A catch clause can have any number of case clauses.&nbsp; If none match, the
exception is re-thrown.</p>
<p>Exceptions can carry values with them.&nbsp; For example, to declare an
exception that carries an int, write xtunion exn {MyIntExn(int) };.&nbsp; Values
of such exceptions are heap-allocated, for example, throw new
MyIntExn(42).&nbsp; Catching such exceptions must use &amp;, like this: try s1
catch { case &amp;MyIntExn(x): s2 }.&nbsp; When this construct catches a
MyIntExn, the int carried is bound to x (which can be any identifer) and x's
scope is s2.</p>
<p>To understand the strange syntax, realize that exn is just a pre-defined
xtunion, an extensible <a href="discriminated_unions.htm">discriminated union</a>.&nbsp;
Therefore, all the standard rules for extending, creating objects, and
destructing objects of an xtunion type apply.</p>
<p align="left"><b><a name="add_exncost"></a>How efficient is exception handling?</b><p align="left">Entering
a try block is implemented with setjmp.&nbsp; Creating an xtunion (exception
packets are xtunion's) requires a heap allocation.&nbsp; Throwing an exception
is implemented with longjmp.&nbsp; Pattern-matching an xtunion against each case
variant in the catch clause is a pointer-comparsion.&nbsp; In short, exception
handling is fairly lightweight.<p align="left"><b><a name="add_let"></a>What does let mean?</b><p align="left">A
let declaration has the form let p = e; where p is a pattern and e is an
expression.&nbsp; It can appear wherever declarations can appear within a
function.&nbsp; If p is an identifier, the meaning is the same as t p = e; where
t is the type of e.&nbsp; For less trivial pattern forms, see <a href="pattern_matching.htm">pattern
matching</a>.<p align="left"><b><a name="add_pats"></a>What is a pattern and how do I use it?</b><p align="left">Patterns
allow a convenient way to destructure aggregate objects, such as structs and
tuples.&nbsp; Patterns are the only way to destructure <a href="discriminated_unions.htm">discriminted
unions</a>.&nbsp; Patterns are used in Cyclone's let-declarations and switch
statements.&nbsp; See <a href="pattern_matching.htm">pattern matching</a>.<p align="left"><b><a name="add_under"></a>What does _ mean?</b><p align="left">As
part of a type (or as a whole type), it means, &quot;determine what should go
here and fill it in&quot;.&nbsp; Similarly, as an explicit region annotation it
means, &quot;determine what region should go here and fill it in&quot;.&nbsp;
Learn more in <a href="type_inference.htm">type inference</a>.&nbsp; As part of
a pattern, it is a wild-card: Like an identifier, it matches any object.&nbsp;
Unlike an identifier, it does not actually bind the matching object to
anything.&nbsp; Learn more in <a href="pattern_matching.htm">pattern matching</a>.<p align="left"><b><a name="add_alpha"></a>What are functions that take arguments of type `a?</b><p align="left">Types
that are ` (backquote) followed (without whitespace) by an identifier are <i>type
variables</i>.&nbsp; If a function parameter has a type variable for its type,
it means the function can be called with any pointer or with an int.&nbsp;
However, if two parameters have the same type variable, they must be
instantiated with the <i>same type</i>. If all occurrences of `a appear directly
under pointers (eg. `a *), then an actual parameter can have any type, but the
restrictions about using the same type still apply.&nbsp; In general, Cyclone
has <a href="polymorphism.htm">parametric polymorphism</a> as a safe alternative
to casts and void *.
<p align="left"><b><a name="add_nottemplates"></a>Do functions with type variables get
duplicated like C++
      template functions?&nbsp; Is there run-time overhead for using type
variables?</b><p>No and no.&nbsp; Each Cyclone function gives rise to one
function in the output.&nbsp; Types are not present at run-time.&nbsp; In case
you still don't believe us: When a function is called, it does not need to know
the types with which the caller is instantiating the type variables, so no
instantiation actually occurs -- the types are not present at run-time.&nbsp; We
do not have to duplicate the code because we either know the size of the type or
the size does not matter.&nbsp; This is why we don't allow type variables of
memory kind as parameters -- doing so would require code duplication or run-time
types.</p>
<p><b><a name="del_varargs"></a>Can I use varargs?</b></p>
<p>No, but we intend to support varags in the very near future. printf, scanf, etc. take a
variable number of arguments, but these are built-in constructs.</p>
<p><b><a name="del_nestedtype"></a>Why can't I declare types within functions?</b></p>
<p>We just haven't implemented this support yet.&nbsp; For now, you need to
hoist type declarations and typedefs to the top-level.</p>
<p><b><a name="del_casts"></a>What casts are allowed?</b></p>
<p>In general, we support only casts that do not allow you to misinterpret the
contents of memory.&nbsp; Rather than giving the general rules, here are the
most important specifics.</p>
<ul>
  <li>All of C's numeric casts, conversions, and promotions are unchanged.</li>
  <li>For type t, you can cast among t @{c}, t *{c} and t ?.&nbsp; A cast from t
    ? to one of the other types includes a run-time check that the t? object
    points to at least c objects.&nbsp; A cast to t@{c} from one of the other
    types includes a run-time check that the object is not null.&nbsp; No other
    casts of these forms have run-time checks.&nbsp; A failed run-time check
    throws Null_Exception.</li>
  <li>A pointer into the heap can be cast to a pointer into another region.</li>
  <li>A pointer to one struct/tuple can be cast to a pointer to another struct/tuple
    provided the &quot;target type&quot; is narrower (fewer fields after
    &quot;flattening out&quot; nested structs/tuples) and each (flattened out)
    field of the target type could be the target of a cast from the
    corresponding field of the source type.</li>
  <li>A pointer can be cast to an int.</li>
  <li>The type t*{c1} can be cast to t*{c2} if c2 &lt; c1 and similarly for
    t@{c1} and t@{c2}.</li>
  <li>An object of type tunion T.A can be cast to tunion T if A does not carry
    values.&nbsp; An object of type tunion T.A@ can be cast to tunion T if A
    does carry values.</li>
</ul>
<p>The current implementation isn't quite as lenient as it should be.&nbsp; For
example, it rejects a cast from int *{4} to $(int,int)*{2}, but this cast is
safe.</p>
<p><b><a name="del_fallthru"></a>Why can't I implicitly fall-through to the next switch
      case?</b></p>
<p>This &quot;feature&quot; of C is the one thing that doesn't impair memory
safety but we still found too unpleasant to allow.&nbsp; You can get C's
behavior with an explicit <a href="#add_fallthru">fallthru</a>.</p>
<p><b><a name="del_globals"></a>Do I have to initialize global variables?</b></p>
<p>Yes, you currently must provide explicit initializers for global variables so
that the compiler is sure uninitialized memory is not read.&nbsp; In the future,
we will provide some support for initializing globals in constructor
functions.&nbsp; Two techniques help with initializing global arrays.&nbsp;
First, if an array element could be 0 or null, the compiler will insert 0 for
any elements you do not specify.&nbsp; For example, int x[37] = {}; works.&nbsp;
Second, you can use the comprehension form: int x[37] = {for i &lt; e1 : e2}
provided e1 and e2 are constant expressions.&nbsp; Currently e2 may not use i,
but in the future it will be able to.&nbsp; Note that it is not possible to have
a global variable of an abstract type because it is impossible to know any
constant expression of that type.</p>
<p><a name="del_threads"></a><b>Are there threads?</b></p>
<p>Cyclone does not yet have a threads library and some of the libraries are not
re-entrant.&nbsp; However, it should be fine to call Cyclone code from multiple
C threads (provided the garbage collector is correctly configured).&nbsp; In the
future, we will support threads directly as well as static analysis for
preventing data races.</p>
<p><b><a name="del_setjmp"></a>Can I use setjmp/longjmp?</b>.&nbsp;</p>
<p>No.&nbsp; However, Cyclone has exceptions, which can be used for non-local
control flow.&nbsp; The problem&nbsp; setjmp/longjmp is that safety demands we
prohibit a longjmp to a place no longer on the stack.&nbsp; A future release may
have more support for non-local control flow.</p>
      <p align="left"><b><a name="del_union"></a>What types are allowed for union members?</b><p>Currently,
union members cannot contain pointers.&nbsp; You can have numeric types
(including bit fields and enumerations), structs and tuples of allowable union-member
types, and other unions.</p>
<p><b><a name="del_voidstar"></a>Why can't I do anything with values of type void *?</b></p>
<p>Because we cannot know the size of an object pointed to by a pointer of type
void *, we prohibit derefencing the pointer or casting it to a different pointer
type.&nbsp; To write code that works for all pointer types, use <a href="polymorphism.htm">type
variables and polymorphism</a>.</p>
<p><b><a name="io_how"></a>How do I call printf, scanf, and company?</b></p>
<p>In Cyclone, printf, fprintf, scanf, and fscanf, work as they do in C except:</p>
<ul>
  <li>They are built-in primitives.&nbsp; You cannot use them as function
    pointers.</li>
  <li>The format-string argument must be a literal string.</li>
  <li>The compiler checks that the arguments match the format-string
    argument.&nbsp; A mismatch is a compile-time error.</li>
  <li>The %s specifier is for arguments of type char ?.&nbsp; Because there is
    an implicit coercion from char * to char ?, you usually won't notice.</li>
  <li>The %s specifier currently does not permit variations (flags, width,
    length, precision).</li>
</ul>
      <p align="left"><b><a name="io_xprintf"></a>What is xprintf?</b><p align="left">xprintf
is a primitive taking the same arguments as printf.&nbsp; Instead of writing the
result to stdout, it returns a heap-allocated string containing what would have
printed to stdout had printf been called, plus a trailing null-character.&nbsp;
      <p align="left"><b><a name="io_printf_literal"></a>Why doesn't printf(s) work?</b>
      <p align="left">Printf, fprintf, etc. are primitives in
      Cyclone.&nbsp;&nbsp;The
first argument to printf (second to fprintf) must be a literal string (eg.
&quot;Your name is %s.&nbsp; Your age is %d&quot;); the type-checker ensures
that the remaining arguments have the right types and are in the right
order.&nbsp; Hence you cannot say printf(s) where s is some array of characters.
(Allowing such calls is unsafe because s may contain '%' characters.)
      <p align="left"><b><a name="io_sscanf"></a>Is there sscanf?</b>
      <p align="left">Not yet.
      <p align="left"><b><a name="io_cmdline"></a>How do I access command-line arguments?</b><p align="left">The
type of main should be &quot;int main(int argc, char ?? argv)&quot;.&nbsp; (See
&quot;<a href="#types_size">what does int ? mean</a>&quot;.)&nbsp; As in C, argc is the number of
command-line arguments and argv[i] is a string with the ith argument.&nbsp;
Unlike C, argv and each element of argv carry bounds information.&nbsp; Note
that argc is redundant -- it is always equal to argv.size.<p align="left"><b><a name="ptr_stack"></a>Why can't I pass a stack pointer to certain functions?</b><p align="left">Types
of the form t* and t[128] refer to pointers in the heap, so formal parameters of
these types indicate that actual parameters cannot be stack pointers.&nbsp;
Parameters that can be stack pointers should use region-names to indicate
this:&nbsp; In short, change the parameter type t[128] to t@`r {128} where `r is
some identifier starting with a ` (backquote) that is distinct from the other
type variables and region-names in the function prototype.&nbsp; See <a href="regions_and_effects.htm">Memory
Management Via Regions</a> to learn what the `r stuff really means.<p align="left"><b><a name="ptr_stack2"></a>Why do I get an incomprehensible error when I assign a
      local's address to a pointer variable?</b><p align="left">Types of the
form t* are for pointers in the heap, so you cannot assign a stack pointer to a
variable or formal parameter of type t*.&nbsp; If you want a local variable to
hold a stack pointer, the easiest solution is to declare its type t*_ instead of
t*.&nbsp; It can still only hold pointers into one local scope.&nbsp; (It can
also hold heap pointers, but you will get a warning about an implicit
cast.)&nbsp; For passing stack pointers to functions, see the previous
question.&nbsp; See <a href="regions_and_effects.htm">Memory Management Via
Regions</a> to learn what is really going on.<p align="left"><b><a name="ptr_arith"></a>How much pointer arithmetic can I do?</b><p align="left">On
objects of type t?, you can add or subtract an int (including via
increment/decrement), as in C.&nbsp; It is okay for the result to be outside the
bounds of the object pointed to; it is a run-time error to <i>dereference</i>
outside of the bounds.&nbsp; (The compiler inserts bounds information and a
run-time check.&nbsp; An exception is thrown.)&nbsp; Currently, we do not
support adding/subtracting ints to other pointer types.&nbsp; As in C, you can
subtract two pointers of the same type; the type of the result is unsigned int.
<p><b><a name="pointer_stringlit"></a>What is the type of a literal string?</b></p>
<p>The type of &quot;foo&quot; is char @{4} (remember the trailing '\0').&nbsp;
However, there are implicit casts from char @{4} to char @{2}, char *{4}, and
char ?, so it often &quot;feels like&quot; literal strings have whatever type
you want them to have.</p>
<p><b><a name="ptr_nullterm"></a>Are strings null-terminated?</b></p>
<p>As in C, the convention is for strings to end with character '\0' and many of
the library functions interpret a string to end when '\0' is encountered.&nbsp;
However, the language does not enforce this convention, so memory safety
requires that string-manipulation, including the libraries, does not rely on
it.&nbsp; Hence Cyclone strings generally have type char ?, that is, they carry
bounds information.&nbsp; See the String library to learn how particular
functions interpret '\0' in the middle of a char ? and char ? objects without a
'\0' character.</p>
<p><b><a name="pointer_zero"></a>Why can't I assign 0 to a pointer?</b></p>
<p>We currently distinguish the keyword null from 0, so you have to write int *
x = null;, not int * x = 0;.&nbsp; We intend to be more flexible in the
future.&nbsp; You can use pointers in guards: (e.g. if(p) ...); the guard
evaluates to true if and only if the pointer is not null.</p>
<p><b><a name="mem_new"></a>What does new mean?</b></p>
<p>The expression &quot;new e&quot; has type t @ if e has type t.&nbsp; Its
meaning is to allocate space on the heap for a t, put the result of evaluating e
in the space, and return a pointer to the space.&nbsp; Thus, it is roughly
equivalent to</p>
<p style="line-height: 0"><font face="Courier New">t @ p = malloc(sizeof(t));</font></p>
<p style="line-height: 0"><font face="Courier New">*p = e;</font></p>
<p style="line-height: 0"><font face="Courier New">p;</font></p>
<p>However, for aggregates such as structs, the translation to C is a bit more
sophisticated: new Foo(3,4) translates roughly to &quot;({t @ p =
malloc(sizeof(t)); p-&gt;a = 3; p-&gt;b = 4; p})&quot;.</p>
<p>Currently, you must use new and a comprehension to allocate an array on the
heap.&nbsp; For example, this expression creates the integer array 0, 2, 4, ...,
2*(n-1):</p>
<p><font face="Courier New">new {for i &lt; n : 2*i};</font></p>
<p>Hence heap-allocated arrays must be initialized when allocated.</p>
<p><a name="mem_malloc"></a><b>How do I use malloc?</b></p>
<p>malloc is a Cyclone primitive, not a library function.&nbsp; Currently it has
an extremely restricted syntax: You must write malloc(sizeof(t)) where t is a
type.&nbsp; The expression has type t@.&nbsp; So there is no need to explicitly
cast the result, but doing so is harmless.&nbsp; Usually the construct &quot;new
e&quot; is more convenient than malloc followed by initialization, but malloc
can be useful for certain idioms and when porting C code.</p>
<p>Notice that you cannot (yet) use malloc to allocate space for arrays, such as
with malloc(n*sizeof(t)).&nbsp; Also, the type-checker uses a conservative
analysis to ensure that the fields of the allocated space are written before
they are used.&nbsp;</p>
<p><a name="mem_free"></a><b>Can I call free?</b></p>
<p>No, individual memory objects may not be freed.&nbsp; In future versions, we
may support freeing objects for which you can prove that there are no other
pointers to the object.&nbsp; Until then, you must rely on a garbage collector
to reclaim heap objects or use <a href="regions_and_effects.htm">regions</a>
(similar to &quot;arenas&quot; or &quot;zones&quot;) for managing collections of
objects.</p>
<p>For porting code, you may want to define &quot;void free(`a a) {}&quot;.</p>
<p><b><a name="mem_gc"></a>Is there a garbage collector?</b></p>
<p>Yes, Cyclone code must be linked against the Boehm-Demers-Weiser conservative
collector, which is bin/gc.a in the Cyclone distribution.&nbsp; Even if you do
no heap allocation, the command-line arguments are copied into the heap before
your code executes.&nbsp; If you link against additional C code, that code must
obey the usual rules for conservative garbage collection: no wildcard pointers
and no calling malloc behind the collector's back.&nbsp; Instead, you should
call GC_malloc.&nbsp; See the collector's documentation for more
information.&nbsp;&nbsp;</p>
<p>Note that if you allocate all objects on the stack, garbage collection will
never occur.&nbsp; If you allocate all objects on the stack or in regions, it is
very unlikely collection will occur and nothing will actually get collected.</p>
<p><b><a name="mem_locarr"></a>How can I make a stack-allocated array?</b></p>
<p>As in C, you declare a local variable with an array type.&nbsp; Also as in C,
all uses of the variable, except as an argument to sizeof, are promoted to a
pointer.&nbsp; If the declaration looks like int x[256], then uses of x have
type int @`L{256} where L is the name of the block in which x is declared.&nbsp;
(Most blocks are unnamed and the compiler just makes up a name.)</p>
<p>Stack-allocated arrays must be initialized when they are declared (unlike
other local variables).&nbsp; You must use an array-initializer, either of the
form {e1, e2, ..., en} or of the form <a href="#add_comprehension">{for i &lt;
256: e}</a>.</p>
<p>To pass (a pointer to) the array to another function, the function must have
a type indicating it can accept stack pointers, as explained <a href="#ptr_stack">elsewhere</a>.</p>
<p><b><a name="mem_salloc"></a>Can I use salloc? realloc?</b></p>
<p>No, neither of these functions are currently provided and it is not possible
to write them in Cyclone.&nbsp; Both features are really only useful for
allocating an amount of space that depends on run-time values (such as for some
arrays).&nbsp; Because Cyclone currently requires that such space be initialized
when it is allocated, we cannot safely provide salloc or realloc.&nbsp;&nbsp;</p>
<p><b><a name="error_null"></a>Why do I have to cast from &quot;foo *&quot; to &quot;foo
      @&quot; if I've tested for null?</b></p>
<p>Currently, the type-checker always inserts a run-time check for null when
coercing a &quot;foo @&quot; to a &quot;foo *&quot;.&nbsp; It does not take
tests into the code into account.&nbsp; You can leave the cast implicit, but the
compiler will emit a warning.&nbsp; In the future, we may define a flow-analysis
to omit spurious warning.&nbsp; Because of aliasing and undefined evaluation
order, a sound analysis is non-trivial.</p>
      <p align="left"><b><a name="error_memkind"></a>Why can't a function parameter or struct field have type
      `a::M?</b><p>Type variables of &quot;memory kind&quot; can be instantiated
with types of any size.&nbsp; There is no straightforward way to compile
functions and types that work on values of any size.&nbsp; In fact, the obvious
way is to instead manipulate pointers to the values.&nbsp; In Cyclone, you must
do this level of indirection yourself, by making the parameters and fields have
type `a::M * or `a::M @.</p>
<p><b><a name="tools_pp"></a>Can I get a readable version of the output?</b></p>
<p>Yes, with caveats.&nbsp; Pass Cyclone the flag -pp and the C output will be
pretty-printed.&nbsp; (The default is to &quot;ugly print&quot; because
pretty-printing is slower.)&nbsp; Several things still make the output a bit
unpleasant: Files generally have many extern declarations (because
#include has been pre-processed away) and generated type definitions (because of
tuples and &quot;? types&quot;).&nbsp; Pattern-matching code gets translated to
a mess of temporary variables and goto statements.&nbsp;&nbsp; Array-bounds
checks and null-checks can clutter array-intensive and pointer-intensive code.&nbsp; All typedefs are expanded away
before printing the output.</p>
<p><b><a name="tools_gdb"></a>Can I use gdb on the output?</b></p>
<p>Yes, but doing more than getting a stack trace on a seg fault requires some
sophistication.&nbsp; First, you have to know how Cyclone translates top-level
identifiers to C identifiers (it prepends Cyc_ and separates namespaces by _
instead of ::) so you can set breakpoints at functions.&nbsp; Second, it can be
hard to print values because many Cyclone types get translated to void *.&nbsp;
Third, we do not yet have source correlation, so if you step through code,
you're stepping through C code, not Cyclone code.</p>
<p>Two more hints: First, on some architectures, the first memory allocation
appears to seg fault in GC_findlimit. This is correct and documented
garbage-collector behavior (it handles the signal but gdb doesn't know that);
simply continue execution.&nbsp; Second, a common use of gdb is to find the
location of an uncaught exception.&nbsp; To do this, set a breakpoint at
&quot;throw&quot; (a function in the Cyclone runtime).</p>
      <p align="left"><b><a name="tools_gprof"></a>Can I use gprof on the output?</b><p align="left">Yes,
just compile the C code with the -pg flag.&nbsp; You should also
rebuild the Cyclone libraries and the garbage collector with the -pg flag.&nbsp;
The results of gprof make sense because a Cyclone function is compiled to a C
function.&nbsp;&nbsp;<p align="left">Notes for Cygwin users: First, the versions
of libgmon.a we have downloaded from cygnus are wrong (every call gets counted
as a self-call).&nbsp; We have modified libgmon.a to fix this bug, so download
our version and put it in your cygwin/lib directory.&nbsp; Second, timing
information should be ignored because gprof is only sampling 100 or 1000 times a
second (because it is launching threads instead of using native Windows
profiling).&nbsp; Neither of these problems are Cyclone-specific.
      <p align="left"><b><a name="tools_emacs"></a>Is there an Emacs mode for Cyclone?</b><p>Sort
of. In the doc/ directory of the distribution is a font-lock.el file and elisp
code (in cyclone_dot_emacs.el) suitable for inclusion in your .emacs.&nbsp;
However, these files <i>change </i>C++ mode and use it for Cyclone rather than
creating a new Cyclone mode.&nbsp; Of course, we intend to make our own mode
rather than destroy C++-mode's ability to be good for C++.&nbsp; Note that we
have not changed the C++ indentation rules at all; our elisp code is useful only
for syntax highlighting.</p>
<p><a name="meta_rtcg"></a><b>Does Cyclone have something to do with runtime
code generation?</b></p>
<p>Your confusion is warranted, but this Cyclone currently has no support for
runtime code generation.&nbsp; Because of possible future support, we have
reserved the words codegen, splice, cut, and fill.&nbsp; There is an extension
to the older Popcorn language for runtime code generation.&nbsp; That extension
is also called Cyclone.</p>
<p><b><a name="meta_name"></a>Couldn't you folks come up with a better name than
Cyclone?</b></p>
<p>We've tried.&nbsp; Do you have a suggestion?</p>
<p><b><a name="meta_gcc"></a>Do I have to compile the output with gcc?</b></p>
<p>Yes; the compiler uses gcc extensions (such as statement expressions and
attributes) in its output.</p>
<p><b><a name="meta_platforms"></a>What platforms are supported?</b></p>
<p>A platform needs gcc 2.9, gnumake, ar, and the ability to build the
Boehm-Demers-Weiser garbage collector.&nbsp; Furthermore, the size of int and
all C pointers must be the same.&nbsp; We have built Cyclone on cygwin (Windows
98, NT, 2K), Linux (insert distributions here), Solaris, and OpenBSD.&nbsp;
Information on how to build on various platforms is available elsewhere?</p>
<p><b><a name="meta_libs"></a>Why aren't there more libraries?</b></p>
<p>We are eager to have a wider code base, but we are compiler writers with
limited resources.&nbsp; Let us know of useful code you write.</p>
<p><b><a name="meta_speares"></a>What does Cyclone have in common with Britney
Spears?</b></p>
<p>Nothing that we know of, but the question may help our web-page hit count.</p>
<p><b><a name="other_imprev"></a>How come List::imp_rev(l1) doesn't change l1 to
its reverse?</b></p>
<p>The library function List::imp_rev mutates its argument by reversing the tl
fields.&nbsp; It returns a pointer to the new first (old last) cell, but l1
still points to the old first (new last) cell.</p>
<p><b><a name="other_inline"></a>Can I inline functions?</b></p>
<p>Sure, functions can be declared inline as in gcc (and C++).&nbsp; You can get
additional inlining by compiling the Cyclone output with gcc -O2.&nbsp; Whether
a function is inlined or not has no effect on Cyclone type-checking.</p>
<p><b><a name="other_crash"></a>If Cyclone is safe, why does my program crash?</b></p>
<p>There are certain classes of errors that Cyclone does not attempt to
prevent.&nbsp; Two examples are stack overflow and various numeric traps, such
as division-by-zero.&nbsp; It is also possible to run out of memory.&nbsp; Other
crashes could be due to compiler bugs or linking against buggy C code (or
linking incorrectly against C code).</p>
<p>Note that when using gdb, it may appear there is a seg fault in GC_findlimit().&nbsp;
This behavior is correct; simply continue execution.</p>
<p><b><a name="other_constants"></a>What are compile-time constants?</b></p>
<p>Compile-time constants are null, sizeof(typ), integer (and character)
constants, and arithmetic operations over compile-time constants.&nbsp;
Constructs requiring compile-time constants are: tuple-subscript (eg. x[3] for
tuple x), case argument when the switch argument has a numeric type (eg. case
3+4:), size in array declaration (eg. int y[37], and size in pointer bound (eg.
int * x{124}).</p>
<p><b><a name="other_arraysize"></a>How can I get the size of an array?</b></p>
<p>If e is an array, then e.size returns the array's size.&nbsp; Note that for
&quot;? types&quot; (eg. int ?) the size is retrieved at runtime from the
object.&nbsp; For other array types (eg. int x[37]), the evaluation is at
compile-time.</p>
&nbsp;<!--msnavigation--></td></tr><!--msnavigation--></table></body>

</html>
