<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>Discriminated Unions</title>
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<meta name="Microsoft Border" content="l, default">
</head>

<body><!--msnavigation--><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr><td valign="top" width="1%">

<nobr><a href="index.htm">Home</a></nobr><br><nobr><a href="quick_questions.htm">Quick&nbsp;Questions</a></nobr><br><nobr><a href="quick_answers.htm">Quick&nbsp;Answers</a></nobr><br><nobr><a href="known_bugs.htm">Known&nbsp;Bugs</a></nobr><br><nobr><a href="pointers.htm">Pointers</a></nobr><br><nobr>Discriminated&nbsp;Unions</nobr><br><nobr><a href="pattern-matching.htm">Pattern-Matching</a></nobr><br><nobr><a href="type_inference.htm">Type&nbsp;Inference</a></nobr><br><nobr><a href="polymorphism.htm">Polymorphism</a></nobr><br><nobr><a href="regions_and_effects.htm">Regions&nbsp;and&nbsp;Effects</a></nobr><br><nobr><a href="definite_assignment.htm">Definite&nbsp;Assignment</a></nobr><br><nobr><a href="namespaces.htm">Namespaces</a></nobr><br><nobr><a href="interfacing_with_c.htm">Interfacing&nbsp;with&nbsp;C</a></nobr>

</td><td valign="top" width="24"></td><!--msnavigation--><td valign="top">
<h1 align="center">Discriminated Unions</h1>
<p>In addition to struct, enum and union, Cyclone has tunion (for &quot;tagged
union&quot;) and xtunion (for &quot;extensible tagged union&quot;) as ways to
construct new aggregate types.&nbsp; Like a union type, each tunion and xtunion
has a number of <i>variants</i> (or members).&nbsp; Unlike with union, an object
of a tunion or xtunion type is exactly one variant, we can detect (or
discriminate) that variant at run-time, and the language prevents using an
object as though it had a different variant.</p>
<p>The difference between tunion and xtunion is that tunion is closed -- a
definition lists all possible variants. It is like the algebraic datatypes in
ML. With xtunion, separately compiled files can add variants, so no code can be
sure that it knows all the variants.&nbsp; There is a rough analogy with not
knowing all the subclasses of a class in an object-oriented language.</p>
<p>For sake of specificity, we first explain how to <a href="#tunion">create and
use tunion</a> types.<font face="Courier New"> </font>We then <a href="#xtunion">explain
xtunion</a> by way of contrast with tunion.&nbsp; Because the only way to read
parts of tunion and xtunion types is pattern-matching, it is hard to understand
tunion without pattern-matching, but for sake of motivation and completeness,
some of the examples in the explanation of pattern-matching use tunion!&nbsp; To
resolve this circular dependency, we will informally explain pattern-matching as
we use it here and we stick to its simplest uses.&nbsp; </p>
<h4 align="center"><font face="Courier New"><a name="tunion"></a>tunion</font></h4>
<p align="left"><b>Basic Type Declarations and Subtyping:</b> </p>
<p align="left"><i>[Warning: For expository purposes, this section contains a
white lie that is exposed in the later section called &quot;regions for tunion&quot;.]</i></p>
<p align="left">A tunion type declaration lists all of its variants.&nbsp; At
its simplest, it looks just like an enum declaration.&nbsp; For example, we
could say:</p>
<p><font face="Courier New">tunion Color { Red, Green, Blue };</font></p>
<p>As with enum, the declaration creates a type (called tunion Color) and three
constants Red, Green, and Blue.&nbsp; Unlike enum, these constants do not have
type tunion Color.&nbsp; Instead, each variant has its <i>own type</i>, namely
tunion Color.Red, tunion Color.Green, and tunion Color.Blue.&nbsp; Fortunately
these are all subtypes of tunion Color and no explicit cast is necessary.&nbsp;
So you can write, as expected:</p>
<p><font face="Courier New">tunion Color c = Red;</font></p>
<p>In this simple example, it we are splitting hairs, but we will soon find all
these distinctions useful.&nbsp; Unlike enum, tunion variants may carry any
fixed number of values, as in this example:</p>
<p style="line-height: 0"><font face="Courier New">tunion Shape { </font></p>
<p style="line-height: 0">&nbsp; <font face="Courier New"> </font><font face="Courier New">Point,
</font></p>
<p style="line-height: 0"><font face="Courier New">&nbsp; </font><font face="Courier New">Circle(float),
</font></p>
<p style="line-height: 0"><font face="Courier New">&nbsp; </font><font face="Courier New">Ellipse(float,float),
</font></p>
<p style="line-height: 0"><font face="Courier New">&nbsp; </font><font face="Courier New">Polygon(int,float),
</font></p>
<p style="line-height: 0"><font face="Courier New">};</font></p>
<p>A Point has no accompanying information, a Circle has a radius, an Ellipse
has two axis lengths, and a (regular) Polygon has a number of sides and a
radius.&nbsp; (The value fields do not have names, so it is often better style
to have a variant carry one value of a struct type, which of course has named
members.)&nbsp; This example creates five types: tunion Shape, tunion
Shape.Point, tunion Shape.Circle, tunion Shape.Ellipse, and tunion Shape.Polygon.
Like in our previous example, tunion Shape.Point is a subtype of tunion Shape
and Point is a constant of type tunion Shape.Point.</p>
<p>Variants that carry one or more values are treated differently.&nbsp; Circle
becomes a <i>constructor</i>; given a float it produces an object of type tunion
Shape.Circle, for example Circle(3.0).&nbsp; Similarly, Ellipse(0,0) has type
tunion Shape.Ellipse (thanks to implicit casts from int to float for 0) and
Polygon(7,4.0) has type tunion Shape.Polygon.&nbsp; The arguments to a
constructor can be arbitrary expressions of the correct type, for example,
Ellipse(rand(), sqrt(rand())).</p>
<p>The second difference is that value-carrying variant types (eg. tunion
Shape.Circle) are not subtypes or the tunion type (eg. tunion Shape).&nbsp;
Rather <i>non-null pointers</i> to the value-carrying variant types are (eg.
tunion Shape.Circle @ is a subtype of tunion Shape).&nbsp; So the following are
correct initializations that use implicit subtyping:</p>
<p style="line-height: 0"><font face="Courier New">tunion Shape s1 = Point;</font></p>
<p style="line-height: 0"><font face="Courier New">tunion Shape s2 = new
Circle(3.0);</font></p>
<p>tunion types are particularly useful for building recursive structures.&nbsp;
For example, a small language of arithmetic expressions might look like this:</p>
<p style="line-height: 0"><font face="Courier New">enum Unops { Negate, Invert
};</font></p>
<p style="line-height: 0"><font face="Courier New">enum Binops { Add, Subtract,
Multiply, Divide };</font></p>
<p style="line-height: 0"><font face="Courier New">tunion Exp { </font></p>
<p style="line-height: 0"><font face="Courier New">&nbsp; Int(int), </font></p>
<p style="line-height: 0"><font face="Courier New">&nbsp; Float(float), </font></p>
<p style="line-height: 0"><font face="Courier New">&nbsp; Unop(enum Unops,
tunion Exp),</font></p>
<p style="line-height: 0"><font face="Courier New">&nbsp; Binop(enum Binops,
tunion Exp, tunion Exp)</font></p>
<p style="line-height: 0"><font face="Courier New">};</font></p>
<p>A function returning an expression representing the multiplication of its
parameter by two could like this:</p>
<p style="line-height: 0"><font face="Courier New">tunion Exp double_exp(tunion
Exp e) {</font></p>
<p style="line-height: 0"><font face="Courier New">&nbsp; return new
Binop(Multiply, new Int(2));</font></p>
<p style="line-height: 0"><font face="Courier New">}</font></p>
<p><b>Accessing tunion Variants: </b>Given a value of a tunion type, such as
tunion Shape, we do not know which variant it is.&nbsp; </p>
<p>For non-value variants, we can use a standard comparison.&nbsp; Continuing
the example from above, &quot;s1 == Point&quot; would be true whereas &quot;s2
== Point&quot; would be false.&nbsp; </p>
<p>Analogous comparisons would not work for value-carrying variants because
these variants are pointers.&nbsp; Rather than provide predicates (perhaps of
the form isCircle(s1)), Cyclone requires pattern-matching.&nbsp; For
example,&nbsp; here is how you could define isCircle:</p>
<p style="line-height: 0"><font face="Courier New">bool isCircle(tunion Shape s)
{</font></p>
<p style="line-height: 0"><font face="Courier New">&nbsp; switch(s) {</font></p>
<p style="line-height: 0"><font face="Courier New">&nbsp; case &amp;Circle(r):
return true;</font></p>
<p style="line-height: 0"><font face="Courier New">&nbsp; default: return false;</font></p>
<p style="line-height: 0"><font face="Courier New">&nbsp; }</font></p>
<p style="line-height: 0"><font face="Courier New">}</font></p>
<p>When a switch statement's argument has a tunion type, the cases describe
variants.&nbsp; One variant of tunion Shape is a pointer to a Circle, which
carries one value.&nbsp; The corresponding pattern has &amp; for the pointer,
Circle for the constructor name, and one identifier for each value carried by
Circle.&nbsp; The identifiers are binding occurrences (declarations, if you
will), and the initial values are the values of the fields of the Circle at
which s points.&nbsp; The scope is the extent of the case clause.&nbsp;
Pattern-matching works for non-value variants too, but there is no &amp; because
they are not pointers.</p>
<p>Here is another example: </p>
<p><i>[The reader is asked to indulge compiler-writers who have forgotten basic
geometry.]</i></p>
<p style="line-height: 0"><font face="Courier New">extern
area_of_ellipse(float,float);</font></p>
<p style="line-height: 0"><font face="Courier New">extern area_of_poly(int,float);</font></p>
<p style="line-height: 0"><font face="Courier New">float area(tunion Shape s) {</font></p>
<p style="line-height: 0"><font face="Courier New">&nbsp; int ans;</font></p>
<p style="line-height: 0"><font face="Courier New">&nbsp; switch(s) {</font></p>
<p style="line-height: 0"><font face="Courier New">&nbsp; case
Point:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
ans =
0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
break;</font></p>
<p style="line-height: 0"><font face="Courier New">&nbsp; case &amp;Circle(r):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
ans =
3.14*r*r;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
break;</font></p>
<p style="line-height: 0"><font face="Courier New">&nbsp; case
&amp;Ellipse(r1,r2):&nbsp;&nbsp; ans = area_of_ellipse(r1,r2); break;</font></p>
<p style="line-height: 0"><font face="Courier New">&nbsp; case &amp;Polygon(sides,r):
ans = area_of_poly(sides,r);&nbsp; break;</font></p>
<p style="line-height: 0"><font face="Courier New">&nbsp; }</font></p>
<p style="line-height: 0"><font face="Courier New">&nbsp; return ans;</font></p>
<p style="line-height: 0"><font face="Courier New">}</font></p>
<p>The cases are compared in order against s.&nbsp; The following are
compile-time errors:</p>
<ul>
  <li>It is possible that a member of the tunion type matches none of the
    cases.&nbsp; Note that default matches everything.</li>
  <li>A case is useless because it could only match if one of the earlier cases
    match.&nbsp; For example, a default case at the end of the switch in area
    would be an error.</li>
</ul>
<p>We emphasize that Cyclone has much richer pattern-matching support than we
have used here.</p>
<p><b>Implementation:</b><font face="Courier New"> </font>Non-value variants are
translated to distinct small integers.&nbsp; Because they are small, they cannot
be confused with pointers to value-carrying variants.&nbsp; Value-carrying
variants have a distinct integer tag field followed by fields for the values
carried.&nbsp; Hence all values of a tunion type occupy one word, either with a
small number or with a pointer.</p>
<p><b>Regions for tunion:</b> We have seen that non-null pointers to
value-carrying variants are subtypes of the tunion type.&nbsp; For example,
tunion Shape.Circle @ is a subtype of tunion Shape.&nbsp; Because tunion
Shape.Circle @ is a pointer into the heap (it is shorthand for tunion
Shape.Circle @`H), it would seem that all values of type tunion Shape are either
non-value variants or pointers into the heap.&nbsp; In fact, this is true, but
only because tunion Shape is itself shorthand for tunion `H Shape.</p>
<p>In other words, tunion types are region-polymorphic over the region into
which the value-carrying variants point.&nbsp; An explicit region annotation
goes after tunion, just like an explicit region annotation goes after * or
@.&nbsp; Here is an example using a stack region:</p>
<p style="line-height: 0"><font face="Courier New">tunion Shape.Circle c =
Circle(3.0);</font></p>
<p style="line-height: 0"><font face="Courier New">tunion _ Shape s = &amp;c;</font></p>
<p>The _ is necessary because we did not give an explicit name to the stack
region.</p>
<p>We can now correct the white lie from the &quot;basic type declarations and
subtyping&quot; section.&nbsp; A declaration tunion Foo {...} creates a type
constructor which given a region creates a type.&nbsp; For any region `r, tunion
`r Foo is a subtype of tunion Foo.Bar @`r if tunion Foo.Bar carries
values.&nbsp; If tunion Foo.Bar does not carry values, then it is a subtype of
tunion `r Foo for all `r.</p>
<p><b>Polymorphism and</b><b> tunion:</b> A tunion declaration may be
polymorphic over types and regions just like a struct definition (see the
section on <a href="polymorphism.htm">polymorphism</a>).&nbsp; For example, here
is a declaration for binary trees where the leaves can hold some BoxKind <font face="Courier New">`a</font>:</p>
<p style="line-height: 0"><font face="Courier New">tunion &lt;`a&gt; Tree {</font></p>
<p style="line-height: 0"><font face="Courier New">&nbsp; Leaf(`a);</font></p>
<p style="line-height: 0"><font face="Courier New">&nbsp; Node(tunion
Tree&lt;`a&gt;, tunion Tree&lt;`a&gt;);</font></p>
<p style="line-height: 0"><font face="Courier New">};</font></p>
<p>In the above example, the root may be in any region, but all children will be
in the heap.&nbsp; This version allows the children to be in any region, but
they must all be in the same region.&nbsp; (The root can still be in a different
region.)</p>
<p style="line-height: 0"><font face="Courier New">tunion &lt;`a,`r::R&gt; Tree
{</font></p>
<p style="line-height: 0"><font face="Courier New">&nbsp; Leaf(`a);</font></p>
<p style="line-height: 0"><font face="Courier New">&nbsp; Node(tunion `r
Tree&lt;`a,`r&gt;, tunion `r Tree&lt;`a,`r&gt;);</font></p>
<p style="line-height: 0"><font face="Courier New">};</font></p>
<p><b>Existential Types:</b> <i>[This feature is independent of the rest of
tunion's features and can be safely ignored when first learning Cyclone.]</i></p>
<p>In addition to polymorphic tunion types, it is also possible to parameterize
individual variants by additional type variables.&nbsp; (From a type-theoretic
point of view, these are existentially-quantified variables.)&nbsp; Here is a
useless example:</p>
<p><font face="Courier New">tunion T { Foo&lt;`a&gt;(`a, `a, int), Bar&lt;`a,`b&gt;(`a,
`b), Baz(int) };</font></p>
<p>The constructors for variants with existential types are used the same way,
for example Foo(&quot;hi&quot;,&quot;mom&quot;,3), Foo(8,9,3), and
Bar(&quot;hello&quot;,17) are all well-typed.&nbsp; The compiler checks that the
type variables are used consistently -- in our example, the first two arguments
to Foo must have the same type.&nbsp; There is no need (and currently no way) to
explicitly specify the types being used.</p>
<p>Once a value of an existential variant is created, there is no way to
determine the types at which it was used.&nbsp; For example,
Foo(&quot;hi&quot;,&quot;mom&quot;,3) and Foo(8,9,3) both have type, &quot;there
exists an `a such that the type is Foo&lt;`a&gt;&quot;.&nbsp; When
pattern-matching an existential variant, you must give an explicit name to the
type variables; the name can be different from the name in the type
definition.&nbsp; Continuing our useless example, we can write:</p>
<p style="line-height: 0"><font face="Courier New">void f(tunion T t) {</font></p>
<p style="line-height: 0"><font face="Courier New">&nbsp; switch(t) {</font></p>
<p style="line-height: 0"><font face="Courier New">&nbsp; case Foo&lt;`a&gt;(x,y,z):
return;</font></p>
<p style="line-height: 0"><font face="Courier New">&nbsp; case Bar&lt;`b,`c&gt;(x,y):
return;</font></p>
<p style="line-height: 0"><font face="Courier New">&nbsp; case Baz(x): return;</font></p>
<p style="line-height: 0"><font face="Courier New">&nbsp; }</font></p>
<p style="line-height: 0"><font face="Courier New">}</font></p>
<p>The scope of the type variables is the body of the case clause.&nbsp; So in
the first clause we could create a local variable of type `a and assign x or y
to it.&nbsp; Our example is fairly &quot;useless&quot; because there is no way
for code to use the values of existentially quantified types.&nbsp; In other
words, given Foo(&quot;hi&quot;,&quot;mom&quot;,3), no code will ever be able to
use the strings &quot;hi&quot; or &quot;mom&quot;.&nbsp; Useful examples
invariably use function pointers.&nbsp; For a realistic library, see fn.cyc in
the distribution.&nbsp; Here is a smaller (and sillier) example; see the section
on region and effects for an explanation of why the `e stuff is necessary.</p>
<p style="line-height: 0"><font face="Courier New">int f1(int x, int y) { return
x+y; }</font></p>
<p style="line-height: 0"><font face="Courier New">int f2(string x, int y) {
printf(&quot;%s&quot;,x); return y; }</font></p>
<p style="line-height: 0"><font face="Courier New">tunion T&lt;`e::E&gt; { Foo&lt;`a&gt;(`a,
int f(`a, int; `e)); };</font></p>
<p style="line-height: 0"><font face="Courier New">void g(bool b) {</font></p>
<p style="line-height: 0"><font face="Courier New">&nbsp; tunion T&lt;{}&gt; t;</font></p>
<p style="line-height: 0"><font face="Courier New">&nbsp; if(b)</font></p>
<p style="line-height: 0"><font face="Courier New">&nbsp;&nbsp;&nbsp; t =
Foo(37,f1);</font></p>
<p style="line-height: 0"><font face="Courier New">&nbsp; else</font></p>
<p style="line-height: 0"><font face="Courier New">&nbsp;&nbsp;&nbsp; t =
Foo(&quot;hi&quot;,f2);</font></p>
<p style="line-height: 0"><font face="Courier New">&nbsp; switch(t) {</font></p>
<p style="line-height: 0"><font face="Courier New">&nbsp; case Foo&lt;`a&gt;(arg,fun):
</font></p>
<p style="line-height: 0"><font face="Courier New">&nbsp;&nbsp;&nbsp; `a x = arg;</font></p>
<p style="line-height: 0"><font face="Courier New">&nbsp;&nbsp;&nbsp; int (*f)(`a,int;{})
= fun;</font></p>
<p style="line-height: 0"><font face="Courier New">&nbsp;&nbsp;&nbsp; f(arg,19);
</font></p>
<p style="line-height: 0"><font face="Courier New">&nbsp;&nbsp;&nbsp; </font><font face="Courier New">break;</font></p>
<p style="line-height: 0"><font face="Courier New">&nbsp; }</font></p>
<p style="line-height: 0"><font face="Courier New">}</font></p>
<p>The case clause could have just been fun(arg) -- the compiler would figure
out all the types for us.&nbsp; Similarly, all of the explicit types above are
for sake of explanation; in practice, we tend to rely heavily on type inference
when using these advanced typing constructs.</p>
<p><b>Future:</b></p>
<ul>
  <li>Currently, given a value of a variant type (eg. tunion Shape.Circle), the
    only way to access the fields is with pattern-matching even though the
    variant is known.&nbsp; We may provide a tuple-like syntax in the future. </li>
  <li>If a tunion has only one value-carrying variant, it does not need a tag
    field in its implementation.&nbsp; We have not yet implemented this
    straightforward optimization.</li>
</ul>
<h4 align="center"><font face="Courier New">&nbsp;<a name="xtunion"></a>xtunion</font></h4>
<p align="left">We now explain how an xtunion type differs from a tunion
type.&nbsp; The main difference is that later declarations may continue to add
variants.&nbsp; Extensible datatypes are useful for allowing clients to extend
data structures in unforeseen ways.&nbsp; For example:</p>
<p align="left" style="line-height: 0"><font face="Courier New">xtunion Food;</font></p>
<p align="left" style="line-height: 0"><font face="Courier New">xtunion Food {
Banana; Grape; Pizza(list_t&lt;xtunion Food&gt;) };</font></p>
<p align="left" style="line-height: 0"><font face="Courier New">xtunion Food {
Candy; Broccoli };</font></p>
<p align="left" style="line-height: 0">After these declarations, <font face="Courier New">Pizza(new
List(Broccoli, null))</font> is a well-typed expression.</p>
<p align="left">If multiple declarations include the same variants, the variants
must have the same declaration (the number of values, types for the values, and
the same existential type variables).</p>
<p align="left">Because different files may add different variants and Cyclone
compiles files separately, no code can know (for sure) all the variants of an
xtunion. Hence all pattern-matches against a value of an xtunion type must end
with a case that matches everything, typically &quot;default&quot;. </p>
<p align="left">There is one built-in xtunion type: xtunion exn is the type of
exceptions.&nbsp; Therefore, you declare new xtunion exn types like this:</p>
<p align="left"><font face="Courier New">xtunion exn {BadFilename(string)};</font></p>
<p align="left">The implementation of xtunion types if very similar to that of
tunion types, but non-value variants cannot be represented as small integers
because of separate compilation.&nbsp; Instead, these variants are represented
as pointers to unique locations in static data.&nbsp; Creating a non-value
variant still does not cause allocation.</p>
<p align="left">Currently, xtunion types cannot be polymorphic.&nbsp; Variants
can have (existential) type variables, but doing so is difficult because
function pointers cannot have effect variables bound polymorphically.</p>
<p align="center">&nbsp;<!--msnavigation--></td></tr><!--msnavigation--></table></body>

</html>
