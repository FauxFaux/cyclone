<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>Pointers</title>
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<meta name="Microsoft Border" content="l, default">
</head>

<body><!--msnavigation--><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr><td valign="top" width="1%">

<nobr><a href="index.htm">Home</a></nobr><br><nobr><a href="quick_questions.htm">Quick&nbsp;Questions</a></nobr><br><nobr><a href="quick_answers.htm">Quick&nbsp;Answers</a></nobr><br><nobr><a href="known_bugs.htm">Known&nbsp;Bugs</a></nobr><br><nobr>Pointers</nobr><br><nobr><a href="discriminated_unions.htm">Discriminated&nbsp;Unions</a></nobr><br><nobr><a href="pattern-matching.htm">Pattern-Matching</a></nobr><br><nobr><a href="type_inference.htm">Type&nbsp;Inference</a></nobr><br><nobr><a href="polymorphism.htm">Polymorphism</a></nobr><br><nobr><a href="regions_and_effects.htm">Regions&nbsp;and&nbsp;Effects</a></nobr><br><nobr><a href="definite_assignment.htm">Definite&nbsp;Assignment</a></nobr><br><nobr><a href="namespaces.htm">Namespaces</a></nobr><br><nobr><a href="interfacing_with_c.htm">Interfacing&nbsp;with&nbsp;C</a></nobr>

</td><td valign="top" width="24"></td><!--msnavigation--><td valign="top">
<h1 align="center">Pointers</h1>
<p>As in C, Cyclone pointers are just addresses.&nbsp; Operations on pointers,
such as <font face="Courier New">*x</font>, &amp;x, <font face="Courier New">x.f</font>,
<font face="Courier New">x-&gt;f</font>, and <font face="Courier New">x[e]</font>
behave the same as in C, with the exception that run-time checks sometimes
precede memory accesses.&nbsp; (Exactly when and where these checks occur is
described below.)&nbsp; However, Cyclone prevents memory errors such as
dereferencing dangling pointers, so it may reject legal C operations on
pointers.</p>
<p>In order to enforce memory safety, Cyclone pointer types contain more
information than their C counterparts.&nbsp; In addition to the type of the
object pointed to, pointer types indicate:</p>
<ul>
  <li><a href="#pointer_null">Whether a value of the type may be <font face="Courier New">null</font></a></li>
  <li><a href="#pointer_bound">The number of objects pointed to</a>&nbsp;</li>
  <li><a href="#pointer_region">The <i>region</i> into which the pointer points</a></li>
</ul>
<p>For example, the type <font face="Courier New">int *{7}`H</font> is for
possibly-null pointers to seven <font face="Courier New">int</font> objects in
the heap.&nbsp; The syntax and semantics of all this additional pointer
information is now explained.&nbsp; Then we introduce a new type for <a href="#pointer_unknown">arrays
of unknown size</a>.&nbsp; Pointer arithmetic is allowed only on this last
collection of types.&nbsp; Throughout, we mention planned improvements.&nbsp; We
end with a <a href="#pointer_summary">summary</a>.</p>
<h4 align="center"><a name="pointer_null"></a>Whether a value of the type may be
<font face="Courier New">null</font></h4>
<p>Cyclone's type system distinguishes between pointers that may be <font face="Courier New">null</font>
and those that may not.</p>
<p><b>Syntax and Semantics:</b>&nbsp;&nbsp; The syntax is straightforward:&nbsp;
The <font face="Courier New">*</font> character is for pointers that may be null
(as in C), and the <font face="Courier New">@</font> character is for pointers
that may not be null.&nbsp; So &quot;<font face="Courier New">int * x = null;</font>&quot;
is accepted, but &quot;<font face="Courier New">int @ x = null;</font>&quot; is
not.&nbsp;&nbsp;</p>
<p><b>Subtyping:</b> For any type <font face="Courier New">t</font>, the type <font face="Courier New">t@</font>
is a subtype of <font face="Courier New">t*</font>.&nbsp; The type of <font face="Courier New">malloc(sizeof(t))</font>
is <font face="Courier New">t@</font>, as is <font face="Courier New">new e</font>
where <font face="Courier New">e</font> has type <font face="Courier New">t</font>.&nbsp;
Hence in the declaration, &quot;<font face="Courier New">int *x =
malloc(sizeof(int))</font>&quot;, there is an implicit legal cast from <font face="Courier New">t@</font>
to <font face="Courier New">t*</font>.&nbsp; Note that even when <font face="Courier New">t1</font>
is a subtype of <font face="Courier New">t2</font>, the type <font face="Courier New">t1*</font>
is not necessarily a subtype of <font face="Courier New">t2*</font>, nor is <font face="Courier New">t1@</font>
necessarily a subtype of <font face="Courier New">t2@</font>.&nbsp; For example,
<font face="Courier New">int@@</font> is not a subtype of <font face="Courier New">int*@</font>.&nbsp;
This illegal code shows why:</p>
<p>&nbsp;</p>
<p style="line-height: 0%"><font face="Courier New">void f(int @@ x) {</font></p>
<p style="line-height: 0%"><font face="Courier New">&nbsp; int *@ y = x;//would
be legal were int *@ a subtype of int @@</font></p>
<p style="line-height: 0%"><font face="Courier New">&nbsp; *y =
null;&nbsp;&nbsp; //legal because *y has type int *</font></p>
<p style="line-height: 0%"><font face="Courier New">&nbsp;
**x;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //seg faults even though
the type of *x is int @</font></p>
<p style="line-height: 0%"><font face="Courier New">}</font></p>
<p>You can explicitly cast a value of type <font face="Courier New">t*</font> to
<font face="Courier New">t@</font>.&nbsp; Doing so will perform a run-time
check.&nbsp; The cast can be omitted, but the compiler emits a warning and
performs the run-time check.&nbsp; Because the current implementation does not
consider tests to change a <font face="Courier New">t*</font> to <font face="Courier New">t@</font>,
such casts are sometimes necessary to avoid spurious warnings, such as in this
code:</p>
<p><font face="Courier New"><br>
extern void f(int @);<br>
<br>
void g(int * x) {<br>
&nbsp; if(x != null)<br>
&nbsp;&nbsp;&nbsp; f((int @)x);<br>
}</font><br>
</p>
<p><b>Implementation:</b> A run-time null-check is a simple comparison.&nbsp; If
it fails (i.e. the value is <font face="Courier New">null</font>), the exception
Null_Exception is thrown.&nbsp; A check is inserted whenever a <font face="Courier New">t*</font>
is (explicitly or implicitly) cast to a <font face="Courier New">t@</font>.
Casting <font face="Courier New">t@</font> to <font face="Courier New">t*</font>
has no run-time effect.</p>
<p>Safety demands that if x may be null, then *e, e.f, e-&gt;f, and e[e2] are
translated such that we first check that e is not null.&nbsp; e is only
evaluated once.&nbsp; The only way to guarantee there is no check at run-time is
to use @ instead of *.&nbsp; For example, the function on the left performs one
check whereas the one on the right performs three (both throw <font face="Courier New">Null_Exception</font>
if passed <font face="Courier New">null</font>):</p>
<p style="line-height: 0"><font face="Courier New">int sum3(int *{3} x)
{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int sum3(int *{3} x) {</font></p>
<p style="line-height: 0"><font face="Courier New">&nbsp; int @{3} y =
x;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return x[0]+x[1]+x[2];</font></p>
<p style="line-height: 0"><font face="Courier New">&nbsp; return y[0]+y[1]+y[2];</font></p>
<p style="line-height: 0"><font face="Courier New">}</font></p>
<p>Note that &amp;e-&gt;f and &amp;e[e2]&nbsp; check (if necessary) that e is
not null even though these constructs do not read through e.</p>
<p><b>Future:</b> </p>
<ul>
  <li>We may allow an implicit cast from 0&nbsp; to a pointer type, as in
    C.&nbsp; Currently 0 must have a numeric type, even though null is
    implemented as address 0.&nbsp; This change would make porting easier.</li>
  <li>We may use dataflow information to avoid spurious warning about implicit
    casts from <font face="Courier New">t*</font> to <font face="Courier New">t@</font>
    and to avoid inserting unnecessary checks.&nbsp; However, the analysis is
    non-trivial (due to the address-of operator, unstructured control flow, and
    undefined evaluation order), and the C compiler may be able to eliminate
    unnecessary checks for us.</li>
  <li>For debugging purposes, we may have <font face="Courier New">Null_Exception</font>
    carry source-position information.</li>
</ul>
<h4 align="center"><a name="pointer_bound"></a>The number of objects pointed to </h4>
<p><b>Syntax and Semantics: </b>The type <font face="Courier New">t@{37}</font>
(similarly <font face="Courier New">t*{37}</font>) describes pointers to 37 t
values.&nbsp; In other words, if x has type <font face="Courier New">t@{37}</font>,
then x[e] is safe so long as e is between 0 and 36, inclusive.&nbsp; If the {n}
is omitted, it is implicitly {1}.&nbsp; Currently, the number must be a
compile-time constant -- see below for arrays of unknown size.</p>
<p>We are taking pains not to say <font face="Courier New">t@{37}</font>
describes an array of 37 t values because C (and therefore Cyclone)
distinguishes arrays and pointers in certain contexts.&nbsp; For example, a
local declaration &quot;<font face="Courier New">t@{37}</font> <font face="Courier New">x;</font>&quot;
allocates space on the stack for a pointer (which must hold a pointer to 37 t
values in the help) whereas &quot;<font face="Courier New">t x[37];</font>&quot;
allocates space on the stack for 37 t values. </p>
<p><b>Subtyping: </b>Pointers to more objects are subtypes of pointers to fewer
objects (of the same type).&nbsp; An explicit cast is not necessary.&nbsp; Put
another way, we could say <font face="Courier New">t@{37}</font> describes
pointers to at least 37 t values.</p>
<p><b>Implementation:</b> The length information is not present at run-time,
except implicitly in run-time checks.&nbsp; That is, if e has type t @{37}, the
compiler translates e[e2] to check that e2 is less than 37.&nbsp; e2 is
evaluated only once.&nbsp; If e2 is a constant expression, there is no run-time
check.&nbsp; If e2 is a constant expression not less than 37, it is a
compile-time error.</p>
<p><b>Future:</b> In the future, the bounds information on a pointer will not
have to be a compile-time constant.&nbsp; For example, you will be able to write</p>
<p style="line-height: 0"><font face="Courier New">void f(int n) {</font></p>
<p style="line-height: 0"><font face="Courier New">&nbsp; int *{n} arr = new
{for i &lt; n : 37};</font></p>
<p style="line-height: 0"><font face="Courier New">&nbsp; ...</font></p>
<p style="line-height: 0"><font face="Courier New">}</font></p>
<p>This addition is non-trivial because, in terms of the above example, the
variable n may be mutated later in the function.&nbsp; In general, we are
developing a general system where the sizes of pointer bounds may be expressed
in terms of expressions, yet the compiler can always insert the correct bounds
check or verify that the check is unnecessary.</p>
<p>Currently, pointer arithmetic is only allowed on types of the form t?.&nbsp;
Soon we will allow adding a compile-time constant c to t@{n} (for example), with
the type of the result being t@{n-c}.&nbsp; It will be a compile-time error if c
&gt; n.</p>
<h4 align="center"><a name="pointer_region"></a>The <i>region</i> into which the
pointer points</h4>
<p><b>Syntax and Semantics:</b> The type <font face="Courier New">t@`r</font>
describes pointers into region r.&nbsp; All regions start with the ` character
so that they are not confused with identifiers.&nbsp; If the region is omitted,
it is `H, which is the name for the heap region.&nbsp; (The heap region
conceptually lives forever; in practice, it is garbage-collected.) As a result,
you cannot say int *x = &amp;y if y is a local variable because y is not in the
heap region.</p>
<p>Every block (i.e. local scope) is a region.&nbsp; If you label a block with <font face="Courier New">L:</font>,
then the region's name is <font face="Courier New">`L</font>.&nbsp; Similarly,
the parameters to a function f are in a region named <font face="Courier New">`f</font>.&nbsp;
Thanks to type inference, you can point into regions without explicit
names.&nbsp; For example, <b>you can say <font face="Courier New">int *_x =
&amp;y</font> if <font face="Courier New">y</font> is a local variable</b> in an
unlabeled block.&nbsp; Conceptually, the compiler creates a label for the block
and fills in the corresponding region name for you.&nbsp; (The output need not
actually have a label.)</p>
<p>Because every pointer has a type and every pointer type has a region, a
pointer cannot be mutated so that it points into a different region than it did
before the assignment.&nbsp; Hence you will need to re-write C code if the same
variable holds heap pointers and stack pointers (or pointers into different
local blocks) at different points.&nbsp; Also, there is currently know way for a
global variable to hold a stack pointer.</p>
<p>Functions are implicitly polymorphic over the regions of their
arguments.&nbsp; For example, <font face="Courier New">void f(int *`r);</font>
is a prototype that can be passed a pointer into any <i>accessible</i>
region.&nbsp; That is, it can be passed a stack pointer or a heap pointer, so
long as it is not passed a dangling pointer.&nbsp; The exact meaning of regions
and effects in function prototypes is defined elsewhere.&nbsp; We just note that
our example function <font face="Courier New">f</font> could not possibly assign
its argument to a global, whereas <font face="Courier New">void g(int *);</font>
could.&nbsp; On the other hand, <font face="Courier New">g</font> cannot be
passed a stack pointer.</p>
<p><b>Subtyping:</b> Currently, if <font face="Courier New">`r1</font> does not
equal <font face="Courier New">`r2</font>, then <font face="Courier New">t *`r1</font>
and <font face="Courier New">t*`r2</font> are neither a subtype of the
other.&nbsp; A sound system could allow <font face="Courier New">t *`r1</font>
to be a subtype of <font face="Courier New">t*`r2</font> so long as <font face="Courier New">`r1</font>
is known to <i>outlive</i> <font face="Courier New">`r2</font>.</p>
<p><b>Implementation:</b> A pointer's region is not stored with the pointer at
run-time.&nbsp; So there is no way to ask for the region into which a pointer
points.&nbsp; For stack regions there is no region object at run-time <i>per se</i>,
just the stack space for the objects.&nbsp; As is normal with region-based
systems, Cyclone does not prevent dangling pointers.&nbsp; Rather, it prevents <i>dereferencing</i>
dangling points.</p>
<p><b>Future:</b> We may provide more subtyping with respect to regions.&nbsp;
Other additions have more to do with regions than pointers, so they are
described elsewhere.</p>
<h4 align="center"><a name="pointer_unknown"></a>Pointers to an Unknown Number
of Objects -- The t ? Types</h4>
<p>So far, we have not provided a way to point to a number of objects when the
number is not known at compile-time.&nbsp; </p>
<p><b>Syntax and Semantics:</b> The type t ? describes such pointers to objects
of type t.&nbsp; Such types may be assigned null.&nbsp; They may have a region
annotation, which as with other pointer types, is the region into which the
pointer points and the default is `H, the heap.&nbsp; Clearly, explicit bounds
information makes no sense for these types.&nbsp; If e has type t ?, then e.size
has type int and is the number of objects pointed to by type t.&nbsp; (Actually,
e.size is allowed for any pointer type, but for other pointers it is evaluated
at compile-time.)&nbsp; The meaning of operations on t ? objects is best
explained in terms of the implementation...</p>
<p><b>Implementation:</b> Unlike with types like <font face="Courier New">t*{37}</font>,
the implementation stores bounds information with objects of type t ?.&nbsp;
Currently, a t ? object occupies three machine words.&nbsp; Conceptually, the
object maintains the starting address of the collection of objects pointed to,
the length of the collection, and the current value of the pointer used for
accessing memory.&nbsp; Pointer arithmetic may cause the access pointer to be
out-of-bounds; no error occurs at this point.&nbsp; On the other hand, a
subscript operation e1[e2] where e1 has type t? checks that the access-pointer
of e1 plus e2 is within bounds of e1.&nbsp; Both e1 and e2 are evaluated
once.&nbsp; If the bound is violated the exception Array_Bounds is thrown.</p>
<p>When an object of type t? is assigned to, it gets the bounds information from
the &quot;right-hand side&quot; of the assignment.&nbsp; So x=y copies all of
y's fields to the fields of x.&nbsp; Similarly x = y + 17, copies y's fields and
then adds 17 to x's access pointer.&nbsp; Finally, x++ just increments x's
access pointer.&nbsp; As in C, pointer arithmetic is limited to addition of
constants and subtraction.&nbsp; WE'RE NOT SURE WHAT SUBTRACTION MEANS.</p>
<p>Even though, t ? types are implemented as multi-word values, comparison
operations (eg. ==) are defined on them -- the comparison is performed on the
access pointers.</p>
<p>Conversions to/from t?`r types from/to t*{n}`r and t@{n}`r types exist.&nbsp;
Converting to a t? type just uses the t* or t@ 's static type information to
initialize the bounds information.&nbsp; The cast may be implicit; no warning is
given.&nbsp; Converting to a t* or t@ type incurs a run-time check that the
access pointer has a value such that the target type's bounds information is
sound.&nbsp; If so, the access pointer is returned, else the exception
Array_Bounds is thrown.&nbsp; Implicit casts of this form cause the compiler to
give a warning.</p>
<p><b>Future:</b> We may add a &quot;cannot be null&quot; version of these types
for sake of completeness.&nbsp; More significantly, we intend to allow
user-defined types to have certain fields describe the bounds information for
other fields, rather than relying on types built into the language.</p>
<h4 align="center"><a name="pointer_summary"></a>Summary and Discussion</h4>
<p align="left">A pointer type has one of the following forms, where t is a type
and n is a constant unsigned expression:</p>
<ul>
  <li>
    <p align="left"><font face="Courier New">t *{n}`r</font>, a possibly null
    pointer to n elements of type t in region `r</li>
  <li>
    <p align="left"><font face="Courier New">t @{n}`r</font>, a non-null pointer
    to n elements of type t in region `r</li>
  <li>
    <p align="left"><font face="Courier New">t ?`r</font>, a pointer to an
    unknown number of elements of type t in region `r.&nbsp; Implemented as a
    multi-word object.</li>
</ul>
<p align="left">If {n} is omitted, it is {1}.&nbsp; If the region is omitted, it
is `H, the heap. </p>
<p align="left">&nbsp;The easiest way to port code is to replace uses of t *
with t ?.&nbsp; Of course, this technique will fail if the code makes
assumptions about the size of pointers or if the pointers may point into the
stack.&nbsp; For functions that only read through their parameters, it is always
possibly to make them region-polymorphic, i.e. replace each t* parameter with
t*`r (or with the above suggestions t?`r), using a different region name for
each pointer parameter.</p>
<p align="left">Of course, using <font face="Courier New">t?</font> delays
errors until run-time and is less efficient.&nbsp; Using <font face="Courier New">t@</font>
is the most efficient and guarantees that <font face="Courier New">Null_Exception</font>
will not be thrown.</p>
<p align="left">Currently, code performing pointer arithmetic must use t?.</p>
&nbsp;<!--msnavigation--></td></tr><!--msnavigation--></table></body>

</html>
